[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <string.h>\n\n#define MAX_TOWNS 1000\n#define MAX_ROADS 10000\n\ntypedef struct {\n    int dest;\n    int length;\n} Road;\n\ntypedef struct {\n    int town;\n    int fuel;\n    int refuels;\n} State;\n\ntypedef struct {\n    State* data;\n    int front;\n    int rear;\n    int size;\n    int capacity;\n} Queue;\n\nRoad graph[MAX_TOWNS][MAX_ROADS];\nint road_count[MAX_TOWNS];\n\nQueue* createQueue(int capacity) {\n    Queue* queue = (Queue*)malloc(sizeof(Queue));\n    queue->data = (State*)malloc(capacity * sizeof(State));\n    queue->front = queue->rear = -1;\n    queue->size = 0;\n    queue->capacity = capacity;\n    return queue;\n}\n\nint isEmpty(Queue* queue) {\n    return queue->size == 0;\n}\n\nvoid enqueue(Queue* queue, State state) {\n    if (queue->size == queue->capacity) return;\n    queue->rear = (queue->rear + 1) % queue->capacity;\n    queue->data[queue->rear] = state;\n    queue->size++;\n    if (queue->front == -1) queue->front = queue->rear;\n}\n\nState dequeue(Queue* queue) {\n    State state = queue->data[queue->front];\n    if (queue->size == 1) queue->front = queue->rear = -1;\n    else queue->front = (queue->front + 1) % queue->capacity;\n    queue->size--;\n    return state;\n}\n\nint findMinRefuels(int N, int L, int start, int end) {\n    Queue* queue = createQueue(N * L);\n    int visited[MAX_TOWNS][MAX_TOWNS] = {0};\n\n    State initial = {start, L, 0};\n    enqueue(queue, initial);\n    visited[start][L] = 1;\n\n    while (!isEmpty(queue)) {\n        State current = dequeue(queue);\n\n        if (current.town == end) return current.refuels;\n\n        for (int i = 0; i < road_count[current.town]; i++) {\n            Road road = graph[current.town][i];\n            int remaining_fuel = current.fuel - road.length;\n\n            if (remaining_fuel >= 0 && !visited[road.dest][remaining_fuel]) {\n                State next = {road.dest, remaining_fuel, current.refuels};\n                enqueue(queue, next);\n                visited[road.dest][remaining_fuel] = 1;\n            }\n\n            if (remaining_fuel < 0) {\n                for (int refuel = 1; refuel <= L && remaining_fuel + refuel >= 0; refuel++) {\n                    int new_fuel = current.fuel - road.length + refuel;\n                    if (new_fuel <= L && !visited[road.dest][new_fuel]) {\n                        State next = {road.dest, new_fuel, current.refuels + 1};\n                        enqueue(queue, next);\n                        visited[road.dest][new_fuel] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int N, M, L, Q;\n    scanf(\"%d %d %d %d\", &N, &M, &L, &Q);\n\n    for (int i = 0; i < M; i++) {\n        int u, v, d;\n        scanf(\"%d %d %d\", &u, &v, &d);\n        graph[u-1][road_count[u-1]].dest = v-1;\n        graph[u-1][road_count[u-1]].length = d;\n        road_count[u-1]++;\n        graph[v-1][road_count[v-1]].dest = u-1;\n        graph[v-1][road_count[v-1]].length = d;\n        road_count[v-1]++;\n    }\n\n    for (int i = 0; i < Q; i++) {\n        int start, end;\n        scanf(\"%d %d\", &start, &end);\n        printf(\"%d\\n\", findMinRefuels(N, L, start-1, end-1));\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:42:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 300\n#define INF INT_MAX\n\nint N, M, L;\nint dist[MAX_N + 1][MAX_N + 1];\nint fuel_steps[MAX_N + 1][MAX_N + 1];\n\nvoid floyd_warshall() {\n    for (int k = 1; k <= N; k++) {\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                if (dist[i][k] != INF && dist[k][j] != INF && dist[i][j] > dist[i][k] + dist[k][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n}\n\nvoid compute_fuel_steps() {\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            if (i == j) {\n                fuel_steps[i][j] = 0;\n            } else if (dist[i][j] <= L) {\n                fuel_steps[i][j] = 1;\n            } else {\n                fuel_steps[i][j] = INF;\n            }\n        }\n    }\n\n    for (int k = 1; k <= N; k++) {\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                if (fuel_steps[i][k] != INF && fuel_steps[k][j] != INF && fuel_steps[i][j] > fuel_steps[i][k] + fuel_steps[k][j]) {\n                    fuel_steps[i][j] = fuel_steps[i][k] + fuel_steps[k][j];\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &L);\n\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            dist[i][j] = (i == j) ? 0 : INF;\n        }\n    }\n\n    for (int i = 0; i < M; i++) {\n        int a, b, c;\n        scanf(\"%d %d %d\", &a, &b, &c);\n        if (c < dist[a][b]) {\n            dist[a][b] = dist[b][a] = c;\n        }\n    }\n\n    floyd_warshall();\n    compute_fuel_steps();\n\n    int Q;\n    scanf(\"%d\", &Q);\n    while (Q--) {\n        int s, t;\n        scanf(\"%d %d\", &s, &t);\n        if (fuel_steps[s][t] == INF) {\n            printf(\"-1\\n\");\n        } else {\n            printf(\"%d\\n\", fuel_steps[s][t] - 1);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:42:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n    int N, M, L;\n    cin >> N >> M >> L;\n    vector<vector<pair<int, int>>> adj(N + 1);\n    for (int i = 0; i < M; ++i) {\n        int A, B, C;\n        cin >> A >> B >> C;\n        adj[A].emplace_back(B, C);\n        adj[B].emplace_back(A, C);\n    }\n\n    vector<vector<int>> dist(N + 1, vector<int>(N + 1, INF));\n    for (int i = 1; i <= N; ++i) {\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        dist[i][i] = 0;\n        pq.emplace(0, i);\n        while (!pq.empty()) {\n            int d = pq.top().first;\n            int u = pq.top().second;\n            pq.pop();\n            if (d > dist[i][u]) continue;\n            for (auto &edge : adj[u]) {\n                int v = edge.first;\n                int w = edge.second;\n                if (dist[i][v] > dist[i][u] + w) {\n                    dist[i][v] = dist[i][u] + w;\n                    pq.emplace(dist[i][v], v);\n                }\n            }\n        }\n    }\n\n    vector<vector<int>> refuel(N + 1, vector<int>(N + 1, INF));\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= N; ++j) {\n            if (i == j) {\n                refuel[i][j] = 0;\n            } else if (dist[i][j] <= L) {\n                refuel[i][j] = 1;\n            }\n        }\n    }\n\n    for (int k = 1; k <= N; ++k) {\n        for (int i = 1; i <= N; ++i) {\n            for (int j = 1; j <= N; ++j) {\n                if (refuel[i][k] + refuel[k][j] < refuel[i][j]) {\n                    refuel[i][j] = refuel[i][k] + refuel[k][j];\n                }\n            }\n        }\n    }\n\n    int Q;\n    cin >> Q;\n    while (Q--) {\n        int s, t;\n        cin >> s >> t;\n        if (refuel[s][t] != INF) {\n            cout << refuel[s][t] - 1 << endl;\n        } else {\n            cout << -1 << endl;\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:42:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        int L = sc.nextInt();\n        \n        long[][] dist = new long[N+1][N+1];\n        for (int i = 1; i <= N; i++) {\n            Arrays.fill(dist[i], Long.MAX_VALUE / 2);\n            dist[i][i] = 0;\n        }\n        \n        for (int i = 0; i < M; i++) {\n            int A = sc.nextInt();\n            int B = sc.nextInt();\n            int C = sc.nextInt();\n            dist[A][B] = C;\n            dist[B][A] = C;\n        }\n        \n        for (int k = 1; k <= N; k++) {\n            for (int i = 1; i <= N; i++) {\n                for (int j = 1; j <= N; j++) {\n                    if (dist[i][k] + dist[k][j] < dist[i][j]) {\n                        dist[i][j] = dist[i][k] + dist[k][j];\n                    }\n                }\n            }\n        }\n        \n        int[][] refuel = new int[N+1][N+1];\n        for (int i = 1; i <= N; i++) {\n            Arrays.fill(refuel[i], Integer.MAX_VALUE / 2);\n            refuel[i][i] = 0;\n        }\n        \n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                if (i != j && dist[i][j] <= L) {\n                    refuel[i][j] = 1;\n                }\n            }\n        }\n        \n        for (int k = 1; k <= N; k++) {\n            for (int i = 1; i <= N; i++) {\n                for (int j = 1; j <= N; j++) {\n                    if (refuel[i][k] + refuel[k][j] < refuel[i][j]) {\n                        refuel[i][j] = refuel[i][k] + refuel[k][j];\n                    }\n                }\n            }\n        }\n        \n        int Q = sc.nextInt();\n        for (int q = 0; q < Q; q++) {\n            int s = sc.nextInt();\n            int t = sc.nextInt();\n            if (refuel[s][t] == Integer.MAX_VALUE / 2) {\n                System.out.println(-1);\n            } else {\n                System.out.println(refuel[s][t] - 1);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:43:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TownTraveler {\n    private int N, L;\n    private List<List<int[]>> graph;\n\n    public TownTraveler(int N, int L) {\n        this.N = N;\n        this.L = L;\n        graph = new ArrayList<>(N + 1);\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n    }\n\n    public void addRoad(int u, int v, int length) {\n        graph.get(u).add(new int[]{v, length});\n        graph.get(v).add(new int[]{u, length});\n    }\n\n    public int minRefuels(int start, int end) {\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        boolean[] visited = new boolean[N + 1];\n        int[] dist = new int[N + 1];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[start] = 0;\n        pq.offer(new int[]{start, 0, L});\n\n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int town = current[0], refuels = current[1], fuel = current[2];\n\n            if (town == end) return refuels;\n            if (visited[town]) continue;\n            visited[town] = true;\n\n            for (int[] neighbor : graph.get(town)) {\n                int nextTown = neighbor[0], roadLength = neighbor[1];\n\n                if (fuel >= roadLength) {\n                    if (!visited[nextTown] && dist[nextTown] > dist[town] + roadLength) {\n                        dist[nextTown] = dist[town] + roadLength;\n                        pq.offer(new int[]{nextTown, refuels, fuel - roadLength});\n                    }\n                } else if (roadLength <= L) {\n                    if (!visited[nextTown]) {\n                        pq.offer(new int[]{nextTown, refuels + 1, L - roadLength});\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}",
    "timestamp": "2025-08-05 22:44:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nconst int MAXN = 100005;\n\nstruct Edge {\n    int to, length;\n};\n\nvector<Edge> graph[MAXN];\nint N, M, L;\n\nint dijkstra(int start, int end) {\n    vector<int> min_refuel(N + 1, numeric_limits<int>::max());\n    priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>> pq;\n    \n    pq.push({0, {start, L}});\n    min_refuel[start] = 0;\n    \n    while (!pq.empty()) {\n        int refuel_count = pq.top().first;\n        int current = pq.top().second.first;\n        int fuel_left = pq.top().second.second;\n        pq.pop();\n        \n        if (current == end) return refuel_count;\n        \n        if (refuel_count > min_refuel[current]) continue;\n        \n        for (const Edge& edge : graph[current]) {\n            int next = edge.to;\n            int road_length = edge.length;\n            \n            if (road_length > L) continue;\n            \n            if (fuel_left >= road_length) {\n                if (refuel_count <= min_refuel[next]) {\n                    min_refuel[next] = refuel_count;\n                    pq.push({refuel_count, {next, fuel_left - road_length}});\n                }\n            }\n            \n            if (refuel_count + 1 <= min_refuel[next]) {\n                min_refuel[next] = refuel_count + 1;\n                pq.push({refuel_count + 1, {next, L - road_length}});\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    cin >> N >> M >> L;\n    \n    for (int i = 0; i < M; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        graph[u].push_back({v, w});\n        graph[v].push_back({u, w});\n    }\n    \n    int Q;\n    cin >> Q;\n    \n    while (Q--) {\n        int start, end;\n        cin >> start >> end;\n        cout << dijkstra(start, end) << \"\\n\";\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:44:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve(N, M, roads, L, Q, queries):\n    from collections import defaultdict\n\n    # Create adjacency list for the graph\n    graph = defaultdict(list)\n    for u, v, d in roads:\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n\n    # Pre-compute minimum number of refuels required between any two towns\n    dist = [[float('inf')] * N for _ in range(N)]\n\n    for start in range(N):\n        pq = [(0, start)]\n        heapq.heapify(pq)\n        dist[start][start] = 0\n\n        while pq:\n            refuels, town = heapq.heappop(pq)\n\n            for neighbor, road_length in graph[town]:\n                # If road length is greater than tank capacity, we can't travel it\n                if road_length > L:\n                    continue\n                new_refuels = refuels\n                current_distance = dist[start][neighbor]\n\n                # Check if refueling is needed\n                if dist[start][town] % L + road_length > L:\n                    new_refuels += 1\n\n                if new_refuels < current_distance:\n                    dist[start][neighbor] = new_refuels\n                    heapq.heappush(pq, (new_refuels, neighbor))\n    \n    results = []\n    for u, v in queries:\n        if dist[u - 1][v - 1] == float('inf'):\n            results.append(-1)\n        else:\n            results.append(dist[u - 1][v - 1])\n\n    return results\n\n# Example of how function can be invoked\nN = 4\nM = 4\nroads = [(1, 2, 3), (2, 3, 1), (3, 4, 1), (4, 1, 5)]\nL = 5\nQ = 2\nqueries = [(1, 4), (2, 4)]\n\nprint(solve(N, M, roads, L, Q, queries))  # Should output the answers for the queries",
    "timestamp": "2025-08-13 12:13:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TravelTowns {\n    static class Edge {\n        int to, length;\n        \n        Edge(int to, int length) {\n            this.to = to;\n            this.length = length;\n        }\n    }\n\n    static int N, M, Q, L;\n    static List<Edge>[] graph;\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n        \n        graph = new ArrayList[N + 1];\n        for (int i = 1; i <= N; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        \n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int length = scanner.nextInt();\n            graph[u].add(new Edge(v, length));\n            graph[v].add(new Edge(u, length));\n        }\n\n        L = scanner.nextInt();\n        Q = scanner.nextInt();\n\n        int[][] minRefuels = new int[N + 1][N + 1];\n        for (int i = 1; i <= N; i++) {\n            Arrays.fill(minRefuels[i], -1);\n            dijkstra(i, minRefuels[i]);\n        }\n\n        while (Q-- > 0) {\n            int start = scanner.nextInt();\n            int target = scanner.nextInt();\n            System.out.println(minRefuels[start][target]);\n        }\n\n        scanner.close();\n    }\n    \n    private static void dijkstra(int start, int[] minRefuels) {\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\n        pq.add(new int[] {start, 0, L});\n        \n        minRefuels[start] = 0;\n        \n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int town = current[0];\n            int refuels = current[1];\n            int fuel = current[2];\n            \n            if (refuels > minRefuels[town]) continue;\n            \n            for (Edge edge : graph[town]) {\n                int nextTown = edge.to;\n                int distance = edge.length;\n                \n                if (fuel >= distance) {\n                    if (minRefuels[nextTown] == -1 || refuels < minRefuels[nextTown]) {\n                        minRefuels[nextTown] = refuels;\n                        pq.add(new int[] {nextTown, refuels, fuel - distance});\n                    }\n                } else {\n                    if (minRefuels[nextTown] == -1 || refuels + 1 < minRefuels[nextTown]) {\n                        minRefuels[nextTown] = refuels + 1;\n                        pq.add(new int[] {nextTown, refuels + 1, L - distance});\n                    }\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-13 12:13:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdlib.h>\n\n#define MAX_N 300\n#define INF INT_MAX\n\ntypedef struct {\n    int to, length;\n} Edge;\n\ntypedef struct {\n    Edge edges[MAX_N * MAX_N];\n    int size;\n} Graph;\n\nGraph graph[MAX_N + 1];\nint N, M, Q, L;\nint dist[MAX_N + 1][MAX_N + 1];  // Minimum refuels to reach each town with starting fuel.\n\ntypedef struct {\n    int town, refuels, fuel;\n} State;\n\ntypedef struct {\n    State states[MAX_N * MAX_N];\n    int size;\n} PriorityQueue;\n\nvoid pq_push(PriorityQueue *pq, State state) {\n    int i = pq->size++;\n    while (i > 0) {\n        int p = (i - 1) / 2;\n        if (pq->states[p].refuels <= state.refuels)\n            break;\n        pq->states[i] = pq->states[p];\n        i = p;\n    }\n    pq->states[i] = state;\n}\n\nState pq_pop(PriorityQueue *pq) {\n    State root = pq->states[0];\n    State last = pq->states[--pq->size];\n    int i = 0;\n    while (i * 2 + 1 < pq->size) {\n        int left = i * 2 + 1, right = i * 2 + 2;\n        int min_child = left;\n        if (right < pq->size && pq->states[right].refuels < pq->states[left].refuels)\n            min_child = right;\n        if (last.refuels <= pq->states[min_child].refuels)\n            break;\n        pq->states[i] = pq->states[min_child];\n        i = min_child;\n    }\n    pq->states[i] = last;\n    return root;\n}\n\nvoid dijkstra(int start) {\n    for (int i = 1; i <= N; i++)\n        dist[start][i] = INF;\n    \n    PriorityQueue pq = { .size = 0 };\n    pq_push(&pq, (State){ start, 0, L });\n    dist[start][start] = 0;\n    \n    while (pq.size > 0) {\n        State state = pq_pop(&pq);\n        if (dist[start][state.town] < state.refuels)\n            continue;\n        \n        for (int i = 0; i < graph[state.town].size; i++) {\n            Edge edge = graph[state.town].edges[i];\n            int next_town = edge.to, length = edge.length;\n            int next_fuel = state.fuel - length;\n            if (next_fuel < 0) continue;\n            \n            if (dist[start][next_town] > state.refuels) {\n                dist[start][next_town] = state.refuels;\n                pq_push(&pq, (State){ next_town, state.refuels, next_fuel });\n            }\n            \n            if (length <= L && dist[start][next_town] > state.refuels + 1) {\n                dist[start][next_town] = state.refuels + 1;\n                pq_push(&pq, (State){ next_town, state.refuels + 1, L - length });\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d %d\", &N, &M, &Q, &L);\n    \n    while (M--) {\n        int u, v, d;\n        scanf(\"%d %d %d\", &u, &v, &d);\n        graph[u].edges[graph[u].size++] = (Edge){ v, d };\n        graph[v].edges[graph[v].size++] = (Edge){ u, d };\n    }\n    \n    for (int i = 1; i <= N; i++) {\n        dijkstra(i);\n    }\n    \n    while (Q--) {\n        int s, t;\n        scanf(\"%d %d\", &s, &t);\n        if (dist[s][t] == INF)\n            printf(\"-1\\n\");\n        else\n            printf(\"%d\\n\", dist[s][t]);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 12:13:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nstruct Edge {\n    int to;\n    int length;\n};\n\nint main() {\n    int N, M, L;\n    cin >> N >> M >> L;\n    \n    vector<vector<Edge>> adj(N + 1);\n    \n    for (int i = 0; i < M; ++i) {\n        int u, v, length;\n        cin >> u >> v >> length;\n        adj[u].push_back({v, length});\n        adj[v].push_back({u, length});\n    }\n    \n    int Q;\n    cin >> Q;\n    \n    vector<vector<int>> minRefuels(N + 1, vector<int>(N + 1, numeric_limits<int>::max()));\n    \n    for (int start = 1; start <= N; ++start) {\n        vector<int> dist(N + 1, numeric_limits<int>::max());\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        \n        dist[start] = 0;\n        pq.push({0, start});\n        \n        while (!pq.empty()) {\n            int d = pq.top().first;\n            int u = pq.top().second;\n            pq.pop();\n            \n            if (d > dist[u]) continue;\n            \n            for (const auto& e : adj[u]) {\n                int v = e.to;\n                int length = e.length;\n                \n                if (length <= L && dist[v] > dist[u] + length) {\n                    dist[v] = dist[u] + length;\n                    pq.push({dist[v], v});\n                }\n            }\n        }\n        \n        queue<pair<int, int>> q;\n        minRefuels[start][start] = 0;\n        \n        for (int i = 1; i <= N; ++i) {\n            if (dist[i] <= L) {\n                q.push({i, minRefuels[start][i] = 0});\n            }\n        }\n        \n        while (!q.empty()) {\n            int u = q.front().first;\n            int refuelCount = q.front().second;\n            q.pop();\n            \n            for (const auto& e : adj[u]) {\n                int v = e.to;\n                int length = e.length;\n                \n                if (length <= L && refuelCount + 1 < minRefuels[start][v]) {\n                    minRefuels[start][v] = refuelCount + 1;\n                    q.push({v, minRefuels[start][v]});\n                }\n            }\n        }\n    }\n    \n    for (int i = 0; i < Q; ++i) {\n        int s, t;\n        cin >> s >> t;\n        \n        int result = minRefuels[s][t];\n        cout << (result == numeric_limits<int>::max() ? -1 : result) << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 12:13:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from heapq import heappush, heappop\nfrom collections import defaultdict\n\ndef min_refuels(N, roads, L, start, end):\n    graph = defaultdict(list)\n    for u, v, dist in roads:\n        graph[u].append((v, dist))\n        graph[v].append((u, dist))\n    \n    visited = set()\n    pq = [(0, start, L)]\n    \n    while pq:\n        refuels, curr, fuel = heappop(pq)\n        \n        if curr == end:\n            return refuels\n        \n        if curr in visited:\n            continue\n        \n        visited.add(curr)\n        \n        for next_town, road_dist in graph[curr]:\n            if next_town in visited:\n                continue\n            \n            if fuel >= road_dist:\n                heappush(pq, (refuels, next_town, fuel - road_dist))\n            \n            heappush(pq, (refuels + 1, next_town, L - road_dist))\n    \n    return -1\n\ndef solve_queries(N, roads, L, queries):\n    return [min_refuels(N, roads, L, start, end) for start, end in queries]",
    "timestamp": "2025-08-13 12:13:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    L = int(data[idx])\n    idx += 1\n    \n    INF = float('inf')\n    adj = [[] for _ in range(N+1)]\n    for _ in range(M):\n        a = int(data[idx])\n        idx += 1\n        b = int(data[idx])\n        idx += 1\n        c = int(data[idx])\n        idx += 1\n        adj[a].append((b, c))\n        adj[b].append((a, c))\n    \n    # Precompute all pairs shortest paths with Dijkstra's\n    dist = [[INF] * (N+1) for _ in range(N+1)]\n    for start in range(1, N+1):\n        heap = []\n        heapq.heappush(heap, (0, start))\n        dist[start][start] = 0\n        while heap:\n            current_dist, u = heapq.heappop(heap)\n            if current_dist > dist[start][u]:\n                continue\n            for v, w in adj[u]:\n                if dist[start][v] > current_dist + w:\n                    dist[start][v] = current_dist + w\n                    heapq.heappush(heap, (dist[start][v], v))\n    \n    # Build new adjacency for the fuel-limited graph\n    fuel_adj = [[] for _ in range(N+1)]\n    for u in range(1, N+1):\n        for v in range(1, N+1):\n            if u == v:\n                continue\n            if dist[u][v] <= L:\n                fuel_adj[u].append((v, 1))\n    \n    # Precompute all pairs shortest paths in the fuel-limited graph\n    fuel_dist = [[INF] * (N+1) for _ in range(N+1)]\n    for start in range(1, N+1):\n        heap = []\n        heapq.heappush(heap, (0, start))\n        fuel_dist[start][start] = 0\n        while heap:\n            current_dist, u = heapq.heappop(heap)\n            if current_dist > fuel_dist[start][u]:\n                continue\n            for v, w in fuel_adj[u]:\n                if fuel_dist[start][v] > current_dist + w:\n                    fuel_dist[start][v] = current_dist + w\n                    heapq.heappush(heap, (fuel_dist[start][v], v))\n    \n    Q = int(data[idx])\n    idx += 1\n    for _ in range(Q):\n        s = int(data[idx])\n        idx += 1\n        t = int(data[idx])\n        idx += 1\n        if fuel_dist[s][t] == INF:\n            print(-1)\n        else:\n            print(fuel_dist[s][t] - 1)\n\nsolve()",
    "timestamp": "2025-08-13 12:13:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "class Town {\n    constructor(id) {\n        this.id = id;\n        this.roads = [];\n    }\n}\n\nclass Road {\n    constructor(targetTown, length) {\n        this.targetTown = targetTown;\n        this.length = length;\n    }\n}\n\nfunction minRefuels(N, M, roads, L, Q, queries) {\n    const towns = Array.from({ length: N + 1 }, (_, i) => new Town(i));\n\n    roads.forEach(([u, v, length]) => {\n        towns[u].roads.push(new Road(v, length));\n        towns[v].roads.push(new Road(u, length));\n    });\n\n    const minRefuelMatrix = Array.from({ length: N + 1 }, () => Array(N + 1).fill(Infinity));\n\n    const calculateMinRefuels = (startTown) => {\n        const minFuel = Array(N + 1).fill(Infinity);\n        const fuelQueue = [[startTown, 0, L]];\n\n        minFuel[startTown] = 0;\n\n        while (fuelQueue.length) {\n            const [currentTown, refuels, remainingFuel] = fuelQueue.shift();\n\n            for (const { targetTown, length } of towns[currentTown].roads) {\n                if (length > L) continue;\n\n                let newRefuels = refuels;\n                let newFuel = remainingFuel;\n\n                if (length > remainingFuel) {\n                    newRefuels += 1;\n                    newFuel = L - length;\n                } else {\n                    newFuel -= length;\n                }\n\n                if (minFuel[targetTown] > newRefuels) {\n                    minFuel[targetTown] = newRefuels;\n                    fuelQueue.push([targetTown, newRefuels, newFuel]);\n                }\n            }\n        }\n\n        for (let i = 1; i <= N; i++) {\n            minRefuelMatrix[startTown][i] = minFuel[i];\n        }\n    };\n\n    for (let i = 1; i <= N; i++) {\n        calculateMinRefuels(i);\n    }\n\n    return queries.map(([startTown, targetTown]) => {\n        const result = minRefuelMatrix[startTown][targetTown];\n        return result === Infinity ? -1 : result;\n    });\n}\n\n// Example usage:\nconst N = 4; // Number of towns\nconst M = 4; // Number of roads\nconst roads = [\n    [1, 2, 5],\n    [2, 3, 7],\n    [3, 4, 10],\n    [1, 4, 20]\n];\nconst L = 15; // Maximum fuel capacity\nconst Q = 2; // Number of queries\nconst queries = [\n    [1, 3],\n    [4, 1]\n];\n\nconsole.log(minRefuels(N, M, roads, L, Q, queries)); // [1, 2]",
    "timestamp": "2025-08-13 12:14:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "class Graph {\n    constructor(n) {\n        this.n = n;\n        this.adj = Array.from({ length: n + 1 }, () => []);\n    }\n\n    addEdge(u, v, w) {\n        this.adj[u].push([v, w]);\n        this.adj[v].push([u, w]);\n    }\n\n    minRefuels(start, end, capacity) {\n        const dist = new Array(this.n + 1).fill(Infinity);\n        const refuels = new Array(this.n + 1).fill(Infinity);\n        const pq = new MinPriorityQueue();\n\n        dist[start] = 0;\n        refuels[start] = 0;\n        pq.push([0, 0, start]);\n\n        while (!pq.isEmpty()) {\n            const [curDist, curRefuels, curNode] = pq.pop();\n\n            if (curNode === end) return curRefuels;\n            if (curRefuels > refuels[curNode]) continue;\n\n            for (const [nextNode, edgeLen] of this.adj[curNode]) {\n                const totalDist = curDist + edgeLen;\n                const totalRefuels = curRefuels + (totalDist > capacity ? 1 : 0);\n\n                if (totalDist <= capacity && totalRefuels < refuels[nextNode]) {\n                    dist[nextNode] = totalDist;\n                    refuels[nextNode] = totalRefuels;\n                    pq.push([totalDist, totalRefuels, nextNode]);\n                }\n            }\n        }\n\n        return -1;\n    }\n}\n\nclass MinPriorityQueue {\n    constructor() {\n        this.heap = [];\n    }\n\n    push(val) {\n        this.heap.push(val);\n        this.bubbleUp(this.heap.length - 1);\n    }\n\n    pop() {\n        const min = this.heap[0];\n        const last = this.heap.pop();\n        if (this.heap.length > 0) {\n            this.heap[0] = last;\n            this.bubbleDown(0);\n        }\n        return min;\n    }\n\n    bubbleUp(idx) {\n        while (idx > 0) {\n            const parentIdx = Math.floor((idx - 1) / 2);\n            if (this.compareNodes(this.heap[parentIdx], this.heap[idx]) <= 0) break;\n            [this.heap[parentIdx], this.heap[idx]] = [this.heap[idx], this.heap[parentIdx]];\n            idx = parentIdx;\n        }\n    }\n\n    bubbleDown(idx) {\n        const n = this.heap.length;\n        while (true) {\n            const left = 2 * idx + 1;\n            const right = 2 * idx + 2;\n            let smallest = idx;\n\n            if (left < n && this.compareNodes(this.heap[left], this.heap[smallest]) < 0) {\n                smallest = left;\n            }\n            if (right < n && this.compareNodes(this.heap[right], this.heap[smallest]) < 0) {\n                smallest = right;\n            }\n\n            if (smallest === idx) break;\n            [this.heap[idx], this.heap[smallest]] = [this.heap[smallest], this.heap[idx]];\n            idx = smallest;\n        }\n    }\n\n    compareNodes(a, b) {\n        if (a[1] !== b[1]) return a[1] - b[1];\n        return a[0] - b[0];\n    }\n\n    isEmpty() {\n        return this.heap.length === 0;\n    }\n}\n\nfunction solve(N, M, roads, Q, queries) {\n    const graph = new Graph(N);\n    for (const [u, v, w] of roads) {\n        graph.addEdge(u, v, w);\n    }\n\n    const results = [];\n    for (const [start, end, capacity] of queries) {\n        results.push(graph.minRefuels(start, end, capacity));\n    }\n\n    return results;\n}",
    "timestamp": "2025-08-13 12:14:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const solve = () => {\n    const fs = require('fs');\n    const input = fs.readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    let ptr = 0;\n    const [N, M, L] = input[ptr++].split(' ').map(Number);\n    const INF = 1 << 30;\n    \n    // Initialize adjacency matrix\n    const dist = Array.from({ length: N + 1 }, () => Array(N + 1).fill(INF));\n    for (let i = 1; i <= N; i++) dist[i][i] = 0;\n    \n    // Read roads\n    for (let i = 0; i < M; i++) {\n        const [a, b, c] = input[ptr++].split(' ').map(Number);\n        if (c <= L) {\n            dist[a][b] = Math.min(dist[a][b], c);\n            dist[b][a] = Math.min(dist[b][a], c);\n        }\n    }\n    \n    // Floyd-Warshall to compute all pairs shortest paths\n    for (let k = 1; k <= N; k++) {\n        for (let i = 1; i <= N; i++) {\n            for (let j = 1; j <= N; j++) {\n                if (dist[i][k] + dist[k][j] < dist[i][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n    \n    // Initialize adjacency matrix for fuel stops\n    const fuelDist = Array.from({ length: N + 1 }, () => Array(N + 1).fill(INF));\n    for (let i = 1; i <= N; i++) fuelDist[i][i] = 0;\n    \n    // Build adjacency matrix for fuel stops\n    for (let i = 1; i <= N; i++) {\n        for (let j = 1; j <= N; j++) {\n            if (i !== j && dist[i][j] <= L) {\n                fuelDist[i][j] = 1;\n            }\n        }\n    }\n    \n    // Floyd-Warshall to compute minimum stops\n    for (let k = 1; k <= N; k++) {\n        for (let i = 1; i <= N; i++) {\n            for (let j = 1; j <= N; j++) {\n                if (fuelDist[i][k] + fuelDist[k][j] < fuelDist[i][j]) {\n                    fuelDist[i][j] = fuelDist[i][k] + fuelDist[k][j];\n                }\n            }\n        }\n    }\n    \n    // Process queries\n    const Q = parseInt(input[ptr++], 10);\n    const res = [];\n    for (let i = 0; i < Q; i++) {\n        const [s, t] = input[ptr++].split(' ').map(Number);\n        if (dist[s][t] === INF) {\n            res.push(-1);\n        } else {\n            const ans = fuelDist[s][t] - 1;\n            res.push(ans === INF ? -1 : ans);\n        }\n    }\n    console.log(res.join('\\n'));\n};\n\nsolve();",
    "timestamp": "2025-08-13 12:14:38"
  }
]