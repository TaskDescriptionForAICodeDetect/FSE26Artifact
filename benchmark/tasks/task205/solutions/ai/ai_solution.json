[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int edges[4];\n} Piece;\n\nPiece pieces[9];\nint used[9];\nint grid[3][3];\nint count;\n\nint valid_pairs[8][8] = {\n    {0, 1, 0, 0, 0, 0, 0, 0},\n    {1, 0, 0, 0, 0, 0, 0, 0},\n    {0, 0, 0, 1, 0, 0, 0, 0},\n    {0, 0, 1, 0, 0, 0, 0, 0},\n    {0, 0, 0, 0, 0, 1, 0, 0},\n    {0, 0, 0, 0, 1, 0, 0, 0},\n    {0, 0, 0, 0, 0, 0, 0, 1},\n    {0, 0, 0, 0, 0, 0, 1, 0}\n};\n\nvoid rotate_piece(Piece *p) {\n    int temp = p->edges[0];\n    p->edges[0] = p->edges[1];\n    p->edges[1] = p->edges[2];\n    p->edges[2] = p->edges[3];\n    p->edges[3] = temp;\n}\n\nint check(int pos) {\n    int row = pos / 3;\n    int col = pos % 3;\n    Piece *p = &pieces[grid[row][col]];\n    \n    if (row > 0) {\n        Piece *up = &pieces[grid[row-1][col]];\n        if (!valid_pairs[up->edges[2]][p->edges[0]])\n            return 0;\n    }\n    if (col > 0) {\n        Piece *left = &pieces[grid[row][col-1]];\n        if (!valid_pairs[left->edges[1]][p->edges[3]])\n            return 0;\n    }\n    return 1;\n}\n\nvoid solve(int pos) {\n    if (pos == 9) {\n        count++;\n        return;\n    }\n    \n    int row = pos / 3;\n    int col = pos % 3;\n    \n    for (int i = 0; i < 9; i++) {\n        if (!used[i]) {\n            used[i] = 1;\n            grid[row][col] = i;\n            \n            for (int rot = 0; rot < 4; rot++) {\n                if (check(pos)) {\n                    solve(pos + 1);\n                }\n                rotate_piece(&pieces[i]);\n            }\n            \n            used[i] = 0;\n        }\n    }\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    \n    while (t--) {\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 4; j++) {\n                scanf(\"%d\", &pieces[i].edges[j]);\n            }\n        }\n        \n        count = 0;\n        for (int i = 0; i < 9; i++) used[i] = 0;\n        \n        solve(0);\n        printf(\"%d\\n\", count / 4);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:04:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class JigsawPuzzleSolver {\n    private static final int BOARD_SIZE = 3;\n    private static final int TOTAL_PIECES = 9;\n    private static final int SYMBOL_COUNT = 8;\n    \n    static class Piece {\n        int[] edges;\n        boolean used;\n        \n        Piece(int[] edges) {\n            this.edges = edges;\n            this.used = false;\n        }\n        \n        Piece rotate() {\n            int[] rotated = new int[4];\n            rotated[0] = edges[1];\n            rotated[1] = edges[2];\n            rotated[2] = edges[3];\n            rotated[3] = edges[0];\n            return new Piece(rotated);\n        }\n    }\n    \n    static boolean matchEdges(int a, int b) {\n        return (a + b == 7) || (a == b);\n    }\n    \n    static int countSolutions(Piece[] pieces) {\n        int[] board = new int[TOTAL_PIECES];\n        boolean[] used = new boolean[TOTAL_PIECES];\n        return backtrack(pieces, board, used, 0);\n    }\n    \n    static int backtrack(Piece[] pieces, int[] board, boolean[] used, int position) {\n        if (position == TOTAL_PIECES) {\n            return 1;\n        }\n        \n        int solutions = 0;\n        for (int i = 0; i < TOTAL_PIECES; i++) {\n            if (used[i]) continue;\n            \n            Piece currentPiece = pieces[i];\n            for (int r = 0; r < 4; r++) {\n                if (isValidPlacement(board, position, currentPiece)) {\n                    board[position] = i;\n                    used[i] = true;\n                    solutions += backtrack(pieces, board, used, position + 1);\n                    used[i] = false;\n                }\n                currentPiece = currentPiece.rotate();\n            }\n        }\n        return solutions;\n    }\n    \n    static boolean isValidPlacement(int[] board, int position, Piece piece) {\n        int row = position / BOARD_SIZE;\n        int col = position % BOARD_SIZE;\n        \n        // Check top edge\n        if (row > 0) {\n            Piece topPiece = pieces[board[position - BOARD_SIZE]];\n            if (!matchEdges(piece.edges[0], topPiece.edges[2])) return false;\n        }\n        \n        // Check left edge\n        if (col > 0) {\n            Piece leftPiece = pieces[board[position - 1]];\n            if (!matchEdges(piece.edges[3], leftPiece.edges[1])) return false;\n        }\n        \n        return true;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int testCases = scanner.nextInt();\n        \n        for (int t = 0; t < testCases; t++) {\n            Piece[] pieces = new Piece[TOTAL_PIECES];\n            for (int i = 0; i < TOTAL_PIECES; i++) {\n                int[] edges = new int[4];\n                for (int j = 0; j < 4; j++) {\n                    edges[j] = scanner.nextInt();\n                }\n                pieces[i] = new Piece(edges);\n            }\n            \n            int solutions = countSolutions(pieces);\n            System.out.println(solutions * 4);\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 19:05:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int ROTATIONS = 4;\nconst int GRID_SIZE = 3;\nconst int PIECES = GRID_SIZE * GRID_SIZE;\n\nstruct Piece {\n    int top, right, bottom, left;\n};\n\nPiece rotatePiece(const Piece& p) {\n    return {p.left, p.top, p.right, p.bottom};\n}\n\nbool isCompatible(const Piece& a, const Piece& b, int dir) {\n    switch (dir) {\n        case 0: return a.right == b.left;\n        case 1: return a.bottom == b.top;\n        default: return false;\n    }\n}\n\nbool solvePuzzle(vector<Piece>& grid, const vector<Piece>& pieces, vector<bool>& used, int pos) {\n    if (pos == PIECES) return true;\n    int row = pos / GRID_SIZE;\n    int col = pos % GRID_SIZE;\n    for (int i = 0; i < pieces.size(); ++i) {\n        if (used[i]) continue;\n        Piece piece = pieces[i];\n        for (int rot = 0; rot < ROTATIONS; ++rot) {\n            if (col > 0 && !isCompatible(grid[pos - 1], piece, 0)) {\n                piece = rotatePiece(piece);\n                continue;\n            }\n            if (row > 0 && !isCompatible(grid[pos - GRID_SIZE], piece, 1)) {\n                piece = rotatePiece(piece);\n                continue;\n            }\n            grid[pos] = piece;\n            used[i] = true;\n            if (solvePuzzle(grid, pieces, used, pos + 1)) return true;\n            used[i] = false;\n            piece = rotatePiece(piece);\n        }\n    }\n    return false;\n}\n\nint countSolutions(vector<Piece> pieces) {\n    vector<Piece> grid(PIECES);\n    vector<bool> used(PIECES, false);\n    int count = 0;\n    grid[0] = pieces[0];\n    used[0] = true;\n    for (int rot = 0; rot < ROTATIONS; ++rot) {\n        if (solvePuzzle(grid, pieces, used, 1)) count++;\n        grid[0] = rotatePiece(grid[0]);\n    }\n    return count * ROTATIONS;\n}\n\nint main() {\n    int T;\n    cin >> T;\n    while (T--) {\n        vector<Piece> pieces(PIECES);\n        for (int i = 0; i < PIECES; ++i) {\n            cin >> pieces[i].top >> pieces[i].right >> pieces[i].bottom >> pieces[i].left;\n        }\n        cout << countSolutions(pieces) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:05:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define PIECES 9\n#define SYMBOLS 8\n\ntypedef struct {\n    int edges[4];\n} Piece;\n\nbool is_valid_edge_match(int edge1, int edge2) {\n    // Edges must match opposite symbols\n    return (edge1 + edge2) % SYMBOLS == 0;\n}\n\nbool is_valid_puzzle_configuration(Piece pieces[], int arrangement[]) {\n    // Check horizontal matches\n    for (int row = 0; row < 3; row++) {\n        for (int col = 0; col < 2; col++) {\n            int idx1 = arrangement[row * 3 + col];\n            int idx2 = arrangement[row * 3 + col + 1];\n            if (!is_valid_edge_match(pieces[idx1].edges[1], pieces[idx2].edges[3])) {\n                return false;\n            }\n        }\n    }\n\n    // Check vertical matches\n    for (int col = 0; col < 3; col++) {\n        for (int row = 0; row < 2; row++) {\n            int idx1 = arrangement[row * 3 + col];\n            int idx2 = arrangement[(row + 1) * 3 + col];\n            if (!is_valid_edge_match(pieces[idx1].edges[2], pieces[idx2].edges[0])) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nvoid rotate_piece(Piece* piece) {\n    int temp = piece->edges[3];\n    piece->edges[3] = piece->edges[2];\n    piece->edges[2] = piece->edges[1];\n    piece->edges[1] = piece->edges[0];\n    piece->edges[0] = temp;\n}\n\nvoid solve_puzzle(Piece pieces[], int* solution_count) {\n    int arrangement[PIECES];\n    bool used[PIECES] = {false};\n\n    void backtrack(int position) {\n        if (position == PIECES) {\n            if (is_valid_puzzle_configuration(pieces, arrangement)) {\n                (*solution_count)++;\n            }\n            return;\n        }\n\n        for (int i = 0; i < PIECES; i++) {\n            if (!used[i]) {\n                used[i] = true;\n                arrangement[position] = i;\n\n                for (int rotation = 0; rotation < 4; rotation++) {\n                    backtrack(position + 1);\n                    rotate_piece(&pieces[i]);\n                }\n\n                used[i] = false;\n            }\n        }\n    }\n\n    backtrack(0);\n}\n\nint main() {\n    int num_puzzles;\n    scanf(\"%d\", &num_puzzles);\n\n    for (int puzzle = 0; puzzle < num_puzzles; puzzle++) {\n        Piece pieces[PIECES];\n        for (int i = 0; i < PIECES; i++) {\n            for (int j = 0; j < 4; j++) {\n                scanf(\"%d\", &pieces[i].edges[j]);\n            }\n        }\n\n        int solution_count = 0;\n        solve_puzzle(pieces, &solution_count);\n\n        printf(\"%d\\n\", solution_count / 4);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:05:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nconst int TOTAL_PIECES = 9;\nconst int TOTAL_SYMBOLS = 8;\n\nstruct Piece {\n    vector<int> edges;\n    bool used = false;\n};\n\nbool validatePuzzle(vector<Piece>& puzzle) {\n    vector<int> grid(9);\n    \n    // Check horizontal edges\n    for (int row = 0; row < 3; row++) {\n        for (int col = 0; col < 2; col++) {\n            int curr = row * 3 + col;\n            int next = curr + 1;\n            if (puzzle[curr].edges[1] != puzzle[next].edges[3]) {\n                return false;\n            }\n        }\n    }\n    \n    // Check vertical edges\n    for (int col = 0; col < 3; col++) {\n        for (int row = 0; row < 2; row++) {\n            int curr = row * 3 + col;\n            int next = curr + 3;\n            if (puzzle[curr].edges[2] != puzzle[next].edges[0]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n\nvoid rotatePiece(Piece& piece) {\n    rotate(piece.edges.begin(), piece.edges.begin() + 1, piece.edges.end());\n}\n\nvoid backtrack(vector<Piece>& pieces, vector<Piece>& currentConfig, int position, int& solutions) {\n    if (position == TOTAL_PIECES) {\n        if (validatePuzzle(currentConfig)) {\n            solutions++;\n        }\n        return;\n    }\n    \n    for (int i = 0; i < pieces.size(); i++) {\n        if (!pieces[i].used) {\n            pieces[i].used = true;\n            currentConfig[position] = pieces[i];\n            \n            for (int rotate = 0; rotate < 4; rotate++) {\n                backtrack(pieces, currentConfig, position + 1, solutions);\n                rotatePiece(currentConfig[position]);\n            }\n            \n            pieces[i].used = false;\n        }\n    }\n}\n\nint main() {\n    int T;\n    cin >> T;\n    \n    for (int t = 0; t < T; t++) {\n        vector<Piece> pieces(TOTAL_PIECES);\n        \n        // Input pieces\n        for (int i = 0; i < TOTAL_PIECES; i++) {\n            pieces[i].edges.resize(4);\n            for (int j = 0; j < 4; j++) {\n                cin >> pieces[i].edges[j];\n            }\n        }\n        \n        vector<Piece> currentConfig(TOTAL_PIECES);\n        int solutions = 0;\n        \n        backtrack(pieces, currentConfig, 0, solutions);\n        \n        // Adjust solutions due to rotational symmetry\n        solutions /= 4;\n        \n        cout << solutions << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:05:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class JigsawPuzzleSolver {\n    static final int SIZE = 3;\n    static final int ROTATIONS = 4;\n    static int[][][] pieces;\n    static int[] used;\n    static int[][] grid;\n    static int count;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            pieces = new int[9][4][4];\n            for (int i = 0; i < 9; i++) {\n                for (int j = 0; j < 4; j++) {\n                    for (int k = 0; k < 4; k++) {\n                        pieces[i][j][k] = scanner.nextInt();\n                    }\n                }\n            }\n            used = new int[9];\n            grid = new int[SIZE][SIZE];\n            count = 0;\n            solve(0, 0);\n            System.out.println(count / 4);\n        }\n        scanner.close();\n    }\n\n    static void solve(int row, int col) {\n        if (row == SIZE) {\n            count++;\n            return;\n        }\n        int nextRow = col == SIZE - 1 ? row + 1 : row;\n        int nextCol = col == SIZE - 1 ? 0 : col + 1;\n        for (int piece = 0; piece < 9; piece++) {\n            if (used[piece] == 1) continue;\n            used[piece] = 1;\n            for (int rot = 0; rot < ROTATIONS; rot++) {\n                if (canPlace(piece, rot, row, col)) {\n                    grid[row][col] = piece * ROTATIONS + rot;\n                    solve(nextRow, nextCol);\n                }\n            }\n            used[piece] = 0;\n        }\n    }\n\n    static boolean canPlace(int piece, int rot, int row, int col) {\n        int top = (rot) % 4;\n        int right = (rot + 1) % 4;\n        int bottom = (rot + 2) % 4;\n        int left = (rot + 3) % 4;\n        if (row > 0) {\n            int abovePiece = grid[row - 1][col] / ROTATIONS;\n            int aboveRot = grid[row - 1][col] % ROTATIONS;\n            int aboveBottom = (aboveRot + 2) % 4;\n            if (pieces[piece][top][0] != pieces[abovePiece][aboveBottom][2] ||\n                pieces[piece][top][1] != pieces[abovePiece][aboveBottom][3] ||\n                pieces[piece][top][2] != pieces[abovePiece][aboveBottom][0] ||\n                pieces[piece][top][3] != pieces[abovePiece][aboveBottom][1]) {\n                return false;\n            }\n        }\n        if (col > 0) {\n            int leftPiece = grid[row][col - 1] / ROTATIONS;\n            int leftRot = grid[row][col - 1] % ROTATIONS;\n            int leftRight = (leftRot + 1) % 4;\n            if (pieces[piece][left][0] != pieces[leftPiece][leftRight][2] ||\n                pieces[piece][left][1] != pieces[leftPiece][leftRight][3] ||\n                pieces[piece][left][2] != pieces[leftPiece][leftRight][0] ||\n                pieces[piece][left][3] != pieces[leftPiece][leftRight][1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 19:06:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import permutations, product\n\ndef generate_rotations(piece):\n    # Generate all four rotations of a piece\n    return [piece, piece[1:] + piece[:1], piece[2:] + piece[:2], piece[3:] + piece[:3]]\n\ndef is_valid_configuration(grid, adjacent_edge_pairs):\n    for i in range(3):\n        for j in range(3):\n            if j < 2:  # Check right edge of current piece\n                if (grid[i][j][-1], grid[i][j+1][1]) not in adjacent_edge_pairs:\n                    return False\n            if i < 2:  # Check bottom edge of current piece\n                if (grid[i][j][2:], grid[i+1][j][:2]) not in adjacent_edge_pairs:\n                    return False\n    return True\n\ndef count_solutions(pieces, adjacent_edge_pairs):\n    # Transform each piece into its four possible rotations\n    pieces_with_rotations = [generate_rotations(piece) for piece in pieces]\n    \n    # Create all permutations of the pieces\n    piece_indices_permutations = permutations(range(9), 9)\n    solutions = 0\n    \n    # Check all piece permutations and their rotations\n    for piece_perm in piece_indices_permutations:\n        for rotations in product(range(4), repeat=9):\n            grid = [[pieces_with_rotations[piece_perm[i*3+j]][rotations[i*3+j]]\n                     for j in range(3)] for i in range(3)]\n            if is_valid_configuration(grid, adjacent_edge_pairs):\n                solutions += 1\n                \n    return solutions // 4  # Count unique solutions considering symmetry\n\ndef main():\n    puzzle_count = int(input())\n    puzzles = []\n    for _ in range(puzzle_count):\n        pieces = [tuple(input().strip().split()) for _ in range(9)]\n        adjacent_edge_pairs = set(tuple(input().strip().split()) for _ in range(int(input())))\n        puzzles.append((pieces, adjacent_edge_pairs))\n\n    for pieces, adjacent_edge_pairs in puzzles:\n        print(count_solutions(pieces, adjacent_edge_pairs))\n\nmain()",
    "timestamp": "2025-08-13 02:20:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class JigsawSolver {\n    \n    static final int BOARD_SIZE = 3;\n    static final int TOTAL_AREAS = 3 * 3;\n    static final int ROTATIONS = 4;\n\n    static class Piece {\n        int[] edges = new int[4];\n\n        void rotate() {\n            int temp = edges[3];\n            for (int i = 3; i > 0; i--) {\n                edges[i] = edges[i - 1];\n            }\n            edges[0] = temp;\n        }\n    }\n\n    static boolean isValid(int symbol1, int symbol2, HashMap<Integer, Integer> validPairs) {\n        return validPairs.getOrDefault(symbol1, -1) == symbol2 \n            || validPairs.getOrDefault(symbol2, -1) == symbol1;\n    }\n\n    static boolean solve(int index, Piece[] pieces, boolean[] used, int[][] board, int[] solutions, \n                         HashMap<Integer, Integer> validPairs) {\n        if (index == TOTAL_AREAS) {\n            solutions[0]++;\n            return true;\n        }\n\n        int row = index / BOARD_SIZE;\n        int col = index % BOARD_SIZE;\n\n        for (int p = 0; p < pieces.length; p++) {\n            if (used[p]) continue;\n            Piece piece = pieces[p];\n\n            for (int rotation = 0; rotation < ROTATIONS; rotation++) {\n                if (row > 0) {\n                    int topPieceIndex = board[row - 1][col];\n                    Piece topPiece = pieces[topPieceIndex];\n                    if (!isValid(topPiece.edges[2], piece.edges[0], validPairs)) {\n                        piece.rotate();\n                        continue;\n                    }\n                }\n                \n                if (col > 0) {\n                    int leftPieceIndex = board[row][col - 1];\n                    Piece leftPiece = pieces[leftPieceIndex];\n                    if (!isValid(leftPiece.edges[1], piece.edges[3], validPairs)) {\n                        piece.rotate();\n                        continue;\n                    }\n                }\n\n                used[p] = true;\n                board[row][col] = p;\n                \n                if (solve(index + 1, pieces, used, board, solutions, validPairs)) {\n                    return true;\n                }\n\n                used[p] = false;\n                piece.rotate();\n            }\n        }\n        return false;\n    }\n\n    static int countSolutions(Piece[] pieces, HashMap<Integer, Integer> validPairs) {\n        boolean[] used = new boolean[pieces.length];\n        int[][] board = new int[BOARD_SIZE][BOARD_SIZE];\n        int[] solutions = new int[1];\n\n        solve(0, pieces, used, board, solutions, validPairs);\n\n        return solutions[0] / ROTATIONS;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        HashMap<Integer, Integer> validPairs = new HashMap<>();\n        // Add specific valid pairs to validPairs map\n\n        int numPuzzles = scanner.nextInt();\n        for (int p = 0; p < numPuzzles; p++) {\n            Piece[] pieces = new Piece[9];\n            for (int j = 0; j < 9; j++) {\n                pieces[j] = new Piece();\n                for (int k = 0; k < 4; k++) { \n                    pieces[j].edges[k] = scanner.nextInt();\n                }\n            }\n            int solutions = countSolutions(pieces, validPairs);\n            System.out.println(solutions);\n        }\n    }\n}",
    "timestamp": "2025-08-13 02:20:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define PIECES 9\n#define SYMBOLS 8\n#define ROTATIONS 4\n\ntypedef struct {\n    int edges[4];\n} Piece;\n\nvoid rotatePiece(Piece* piece) {\n    int temp = piece->edges[0];\n    piece->edges[0] = piece->edges[1];\n    piece->edges[1] = piece->edges[2];\n    piece->edges[2] = piece->edges[3];\n    piece->edges[3] = temp;\n}\n\nint isValid(int edge1, int edge2, int validPairs[][2], int pairCount) {\n    for (int i = 0; i < pairCount; i++) {\n        if ((validPairs[i][0] == edge1 && validPairs[i][1] == edge2) || \n            (validPairs[i][1] == edge1 && validPairs[i][0] == edge2)) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint countSolutions(Piece pieces[], int validPairs[][2], int pairCount, int position, int used[]) {\n    if (position == PIECES) return 1;\n\n    int solutions = 0;\n    for (int i = 0; i < PIECES; i++) {\n        if (!used[i]) {\n            used[i] = 1;\n            for (int rotation = 0; rotation < ROTATIONS; rotation++) {\n                if ((position % 3 == 0 || isValid(pieces[used[i]].edges[3], pieces[position - 1].edges[1], validPairs, pairCount)) && \n                    (position < 3 || isValid(pieces[used[i]].edges[0], pieces[position - 3].edges[2], validPairs, pairCount))) {\n                    solutions += countSolutions(pieces, validPairs, pairCount, position + 1, used);\n                }\n                rotatePiece(&pieces[used[i]]);\n            }\n            used[i] = 0;\n        }\n    }\n    return solutions;\n}\n\nint main() {\n    int testCases;\n    scanf(\"%d\", &testCases);\n\n    int validPairs[SYMBOLS * SYMBOLS][2];\n    for (int i = 0; i < SYMBOLS * SYMBOLS; i++) {\n        scanf(\"%d %d\", &validPairs[i][0], &validPairs[i][1]);\n    }\n\n    while (testCases--) {\n        Piece pieces[PIECES];\n        int used[PIECES] = {0};\n\n        for (int i = 0; i < PIECES; i++) {\n            for (int j = 0; j < 4; j++) {\n                scanf(\"%d\", &pieces[i].edges[j]);\n            }\n        }\n\n        int solutions = countSolutions(pieces, validPairs, SYMBOLS * SYMBOLS, 0, used);\n        printf(\"%d\\n\", solutions);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 02:21:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import permutations\n\ndef count_puzzle_solutions(symbols):\n    def is_valid_configuration(arrangement, symbols):\n        edges = [\n            (0, 1, 2, 3), (1, 4, 5, 6), (2, 5, 7, 8),\n            (3, 4, 6, 7), (6, 7, 8, 5)\n        ]\n        \n        for edge in edges:\n            pieces = [arrangement[p] for p in edge]\n            if not check_edge_compatibility(pieces, symbols):\n                return False\n        return True\n\ndef check_edge_compatibility(pieces, symbols):\n    orientations = [\n        (0, 1), (1, 0), (2, 3), (3, 2),\n        (4, 5), (5, 4), (6, 7), (7, 6)\n    ]\n    for piece1, piece2 in zip(pieces[::2], pieces[1::2]):\n        compatible = any(\n            symbols[piece1][o1] == symbols[piece2][o2]\n            for o1, o2 in orientations\n        )\n        if not compatible:\n            return False\n    return True\n\ndef solve_puzzles(puzzle_data):\n    solutions = []\n    for symbols in puzzle_data:\n        solution_count = 0\n        for arrangement in permutations(range(9)):\n            if is_valid_configuration(arrangement, symbols):\n                solution_count += 1\n        solutions.append(solution_count // 4)\n    return solutions\n\ndef main():\n    num_puzzles = int(input())\n    puzzle_data = []\n    \n    for _ in range(num_puzzles):\n        puzzle_symbols = []\n        for _ in range(9):\n            puzzle_symbols.append(list(map(int, input().split())))\n        puzzle_data.append(puzzle_symbols)\n    \n    results = solve_puzzles(puzzle_data)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:21:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom itertools import permutations, product\n\ndef solve_puzzle(pieces):\n    count = 0\n    for perm in permutations(pieces):\n        for rotations in product([0, 1, 2, 3], repeat=9):\n            valid = True\n            for i in [0, 1, 2, 3, 5, 6, 7, 8]:\n                if i == 0:\n                    continue\n                row, col = i // 3, i % 3\n                piece_idx = row * 3 + col\n                rotated_piece = rotate_piece(perm[piece_idx], rotations[piece_idx])\n                if col > 0:\n                    left_piece_idx = row * 3 + (col - 1)\n                    left_rotated = rotate_piece(perm[left_piece_idx], rotations[left_piece_idx])\n                    if (left_rotated[1], rotated_piece[3]) not in valid_pairs:\n                        valid = False\n                        break\n                if row > 0:\n                    top_piece_idx = (row - 1) * 3 + col\n                    top_rotated = rotate_piece(perm[top_piece_idx], rotations[top_piece_idx])\n                    if (top_rotated[2], rotated_piece[0]) not in valid_pairs:\n                        valid = False\n                        break\n            if valid:\n                count += 1\n    return count // 4  # Each solution is counted 4 times due to rotation of the entire puzzle\n\ndef rotate_piece(piece, rotation):\n    return piece[rotation:] + piece[:rotation]\n\ndef main():\n    input_lines = sys.stdin.read().splitlines()\n    idx = 0\n    T = int(input_lines[idx])\n    idx += 1\n    for _ in range(T):\n        global valid_pairs\n        M = int(input_lines[idx])\n        idx += 1\n        valid_pairs = set()\n        for _ in range(M):\n            a, b = map(int, input_lines[idx].split())\n            valid_pairs.add((a, b))\n            idx += 1\n        pieces = []\n        for _ in range(9):\n            top, right, bottom, left = map(int, input_lines[idx].split())\n            pieces.append((top, right, bottom, left))\n            idx += 1\n        print(solve_puzzle(pieces))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:21:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\n// Represents a jigsaw piece with edges\nstruct Piece {\n    int edges[4]; // Order: Top, Right, Bottom, Left\n\n    // Rotate the piece clockwise once\n    void rotateClockwise() {\n        int temp = edges[3];\n        edges[3] = edges[2];\n        edges[2] = edges[1];\n        edges[1] = edges[0];\n        edges[0] = temp;\n    }\n};\n\n// Puzzle configuration\nstruct Puzzle {\n    vector<Piece> pieces;\n    vector<pair<int, int>> validPairs; // Allowed pairs of adjacent symbols\n};\n\n// Check if two symbols are a valid pair\nbool isValidPair(const vector<pair<int, int>>& validPairs, int a, int b) {\n    for (const auto& pair : validPairs) {\n        if ((pair.first == a && pair.second == b) || (pair.first == b && pair.second == a)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// Check if a given 3x3 board configuration is valid\nbool isValidConfiguration(const vector<Piece>& grid, const vector<pair<int, int>>& validPairs) {\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            if (j < 2 && !isValidPair(validPairs, grid[i * 3 + j].edges[1], grid[i * 3 + j + 1].edges[3])) {\n                return false; // Check right edge with adjacent piece\n            }\n            if (i < 2 && !isValidPair(validPairs, grid[i * 3 + j].edges[2], grid[(i + 1) * 3 + j].edges[0])) {\n                return false; // Check bottom edge with adjacent piece\n            }\n        }\n    }\n    return true;\n}\n\n// Generate all rotations for all pieces\nvoid generateRotations(vector<vector<Piece>>& pieceRotations, const vector<Piece>& pieces) {\n    for (const auto& piece : pieces) {\n        vector<Piece> rotations(4);\n        rotations[0] = piece;\n        for (int i = 1; i < 4; ++i) {\n            rotations[i] = rotations[i - 1];\n            rotations[i].rotateClockwise();\n        }\n        pieceRotations.push_back(rotations);\n    }\n}\n\n// Recursive backtracking to count valid solutions\nvoid countSolutions(vector<vector<Piece>>& pieceRotations, vector<Piece>& currentBoard, vector<bool>& usedPieces, \n                    size_t currentPos, const vector<pair<int, int>>& validPairs, size_t& solutionCount) {\n    if (currentPos == 9) {\n        if (isValidConfiguration(currentBoard, validPairs)) {\n            solutionCount++;\n        }\n        return;\n    }\n\n    for (size_t i = 0; i < pieceRotations.size(); ++i) {\n        if (!usedPieces[i]) {\n            usedPieces[i] = true;\n            for (const auto& rotatedPiece : pieceRotations[i]) {\n                currentBoard[currentPos] = rotatedPiece;\n                countSolutions(pieceRotations, currentBoard, usedPieces, currentPos + 1, validPairs, solutionCount);\n            }\n            usedPieces[i] = false;\n        }\n    }\n}\n\nint main() {\n    int numPuzzles;\n    cin >> numPuzzles;\n    \n    while (numPuzzles--) {\n        Puzzle puzzle;\n        int numSymbols, numPairs, numPieces;\n        \n        cin >> numSymbols >> numPairs;\n        puzzle.validPairs.resize(numPairs);\n        \n        for (auto& pair : puzzle.validPairs) {\n            cin >> pair.first >> pair.second;\n        }\n        \n        cin >> numPieces;\n        puzzle.pieces.resize(numPieces);\n        \n        for (auto& piece : puzzle.pieces) {\n            for (int i = 0; i < 4; ++i) {\n                cin >> piece.edges[i];\n            }\n        }\n        \n        vector<vector<Piece>> pieceRotations;\n        generateRotations(pieceRotations, puzzle.pieces);\n        \n        vector<Piece> currentBoard(9);\n        vector<bool> usedPieces(numPieces, false);\n        size_t solutionCount = 0;\n        \n        countSolutions(pieceRotations, currentBoard, usedPieces, 0, puzzle.validPairs, solutionCount);\n        \n        cout << solutionCount / 4 << endl; // Divide by 4 due to rotational symmetry\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:05:37"
  }
]