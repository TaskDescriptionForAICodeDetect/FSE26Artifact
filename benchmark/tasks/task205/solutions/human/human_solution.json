[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cctype>\n#include <cstring>\n\nusing namespace std;\n\nstring puzzle[9];\nint pl2id[9], pl2rot[9];\n\nbool check(char a, char b) {\n  return toupper(a) == toupper(b) && a != b;\n}\n\nint dfs(int k, bool *used) {\n  if(k == 9) return 1;\n  \n  /*\n  for(int i=0; i<9; i++) {\n    cout << \" \" << used[i];\n  }\n  cout << endl;\n  */\n  \n  int ret = 0;\n  for(int id=0; id<9; id++) {\n    if(used[id]) continue;\n\n    for(int rot=0; rot<4; rot++) {\n      bool ok = true;\n      // 上と一致\n      if(k >= 3) ok &= check(puzzle[id][(rot+1)%4], puzzle[pl2id[k-3]][(pl2rot[k-3]+3)%4]);\n      // 左と一致\n      if(k%3 > 0) ok &= check(puzzle[id][rot], puzzle[pl2id[k-1]][(pl2rot[k-1]+2)%4]);\n      \n      if(ok) {\n\tpl2id[k] = id;\n\tpl2rot[k] = rot;\n\tused[id] = true;\n\tret += dfs(k+1, used);\n\tused[id] = false;\n      }\n    }\n  }\n  \n  return ret;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  while(n--) {\n    for(int i=0; i<9; i++) {\n      cin >> puzzle[i];\n    }\n    \n    bool used[9] = {};\n    cout << dfs(0, used) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nstring piece[9];\nint rot[9];\nint check[12][4] = {\n  {1, 3, 0, 1},\n  {2, 3, 1, 1},\n  {3, 0, 0, 2},\n  {4, 0, 1, 2},\n  {4, 3, 3, 1},\n  {5, 0, 2, 2},\n  {5, 3, 4, 1},\n  {6, 0, 3, 2},\n  {7, 0, 4, 2},\n  {7, 3, 6, 1},\n  {8, 0, 5, 2},\n  {8, 3, 7, 1}\n};\nint toint(char c){\n  if(isupper(c)) return c - 'A';\n  else return c - 'a';\n}\nint dfs(int u){\n  for(int i = 0; i < 12; i++){\n    int p = check[i][0], q = check[i][2];\n    int c1 = (check[i][1] + rot[p]) % 4, c2 = (check[i][3] + rot[q]) % 4;\n    if(p >= u) break;\n    if(toint(piece[p][c1]) != toint(piece[q][c2]) || piece[p][c1] == piece[q][c2]) return 0;\n  }\n  if(u == 10) return 1;\n  int res = 0;\n  for(int i = 0; i <= 3; i++){\n    rot[u] = i;\n    res += dfs(u + 1);\n  }\n  return res;\n}\nint main(){\n  int T; cin>>T;\n  while(T--){\n    REP(i, 9) cin>>piece[i];\n    sort(piece, piece + 9);\n    int ans = 0;\n    do{\n      ans += dfs(0);\n    }while(next_permutation(piece, piece + 9));\n    cout<<ans/4<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint n,dy[]={0,1},dx[]={1,0};\nstring s[10];\n// 0\n//1 3\n// 2\n\nstring rot90(string s){\n    return s[3]+s.substr(0,3);\n}\n\nint enc(char c){\n    if(c=='R')return 0;\n    if(c=='r')return 1;\n    if(c=='G')return 2;\n    if(c=='g')return 3;\n    if(c=='B')return 4;\n    if(c=='b')return 5;\n    if(c=='W')return 6;\n    if(c=='w')return 7;\n    cout<<\"ERROR: \"<<(int)c<<endl;\n    assert(0);\n}\n\n#define id(y,x) ((y)*3+(x))\n\nint f(int y,int x,int* used_,string* state_){\n    if(y==3)return 1;\n    if(x==3)return f(y+1,0,used_,state_);\n    int used[10],res=0;\n    string state[10];\n    rep(i,9)used[i]=used_[i],state[i]=state_[i];\n    rep(i,9)if(!used[i]){\n        string t=s[i];\n        rep(j,4){\n            t=rot90(t);\n            if(y>0){\n                int a=enc(t[0]),b=enc(state[id(y-1,x)][2]);\n                if((a+b)%2==0 || a/2!=b/2)continue;\n            }\n            if(x>0){\n                int a=enc(t[1]),b=enc(state[id(y,x-1)][3]);\n                if((a+b)%2==0 || a/2!=b/2)continue;\n            }\n            used[i]=1;\n            state[id(y,x)]=t;\n            res+=f(y,x+1,used,state);\n            used[i]=0;\n        }\n    }\n    return res;\n}\n\nint main(){\n\tcin>>n;\n    rep(tc,n){\n        rep(i,9)cin>>s[i];\n        int used[10]={};\n        string state[10];\n        cout<<f(0,0,used,state)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nconst int R = 3;\nconst int L = R*R;\nstring P[L];\npair<int,int> G[R][R];\nbool used[L];\n\nchar getC(const string &s, int diff, int dir) {\n  return s[(dir-diff+4)%4];\n}\n\nint rec(int x, int y, int k) {\n  if(x == 3) {\n    x = y+2;\n    y = 2;\n  } else if(y == -1) {\n    y = x;\n    x = 0;\n  }\n  int res = 0;\n  if(k == L) return 1;\n  for(int i = 0; i < L; ++i) {\n    if(used[i]) continue;\n    for(int j = 0; j < 4; ++j) {\n      if(x != 0) {\n        char t = getC(P[G[y][x-1].first], G[y][x-1].second, 1);\n        char s = getC(P[i], j, 3);\n        if((isupper(t) ^ isupper(s)) && toupper(t) == toupper(s)) {\n        } else {\n          continue;\n        }\n      }\n      if(y != 0) {\n        char t = getC(P[G[y-1][x].first], G[y-1][x].second, 2);\n        char s = getC(P[i], j, 0);\n        if((isupper(t) ^ isupper(s)) && toupper(t) == toupper(s)) {\n        } else {\n          continue;\n        }\n      }\n      G[y][x] = make_pair(i, j);\n      used[i] = true;\n      res += rec(x+1, y-1, k+1);\n      used[i] = false;\n    }\n  }\n  return res;\n}\n\nint main() {\n  int T;\n  cin >> T;\n  while(T--) {\n    for(int i = 0; i < L; ++i) cin >> P[i];\n    fill(used, used+L, false);\n    cout << rec(0,0,0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<bitset>\n#include<algorithm>\nusing namespace std;\n\n#define H 3\n#define W 3\n#define N 9\n\nclass Piece {\npublic:\n    char top, right, bottom, left;\n    Piece(string s=\"    \") :top(s[0]), right(s[1]), bottom(s[2]), left(s[3]) {}\n    void rotate() {\n        swap(top, right);\n        swap(top, bottom);\n        swap(top, left);\n    }\n};\n\nbool match(char c1, char c2) {\n    if(c1 == c2) return false;\n    return tolower(c1) == tolower(c2);\n}\n\nvector<Piece> piece;\n\nint dfs(int y, int x, vector< vector<Piece> > board, bitset<N> used) {\n    if(used.count() == N) return 1;\n    int result = 0;\n    for(int i=0; i<N; i++) {\n        if(used[i]) continue;\n        Piece p = piece[i];\n        for(int j=0; j<4; j++) {\n            p.rotate();\n            if(0 < x && !match(board[y][x-1].right, p.left)) continue;\n            if(0 < y && !match(board[y-1][x].bottom, p.top)) continue;\n            int ny = y, nx = x+1;\n            bitset<N> u = used;\n            if(W <= nx) {\n                nx = 0;\n                ny++;\n            }\n            board[y][x] = p;\n            u.set(i);\n            result += dfs(ny, nx, board, u);\n        }\n    }\n    return result;\n}\n\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=0; i<n; i++) {\n        piece.clear();\n        for(int j=0; j<N; j++) {\n            string s;\n            cin>>s;\n            piece.push_back(Piece(s));\n        }\n        vector< vector<Piece> > board(H, vector<Piece>(W, Piece()));\n        bitset<N> used(0);\n        cout<<dfs(0, 0, board, used)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n\n\nusing namespace std;\n\nint cnt;\nvector<string> memo;\n\nchar tonum(char word) {\n\tif(word == 'R') return '1';\n\tif(word == 'G') return '2';\n\tif(word == 'B') return '3';\n\tif(word == 'W') return '4';\n\tif(word == 'r') return '5';\n\tif(word == 'g') return '6';\n\tif(word == 'b') return '7';\n\tif(word == 'w') return '8';\n\n\treturn '0';\n}\n\nvoid calc(int num, string rest, string ing) {\n\tstring bkup_r = rest;\n\tstring bkup_i = ing;\n\n\tif(num==9) {\n\t\tcnt++; return;\n\t}\n\n\tif(num == 0) {\n\t\tfor(int i=0; i<9; i++) {\n\t\t\tfor(int j=0; j<4; j++) {\n\t\t\t\ting.push_back(rest[j%4 + i*4]);\n\t\t\t\ting.push_back(rest[(j+1)%4 + i*4]);\n\t\t\t\ting.push_back(rest[(j+2)%4 + i*4]);\n\t\t\t\ting.push_back(rest[(j+3)%4 + i*4]);\n\t\t\t\tif(find(memo.begin(), memo.end(), ing) != memo.end())\n\t\t\t\t\treturn;\n\t\t\t\telse {\n\t\t\t\t\tmemo.push_back(ing); \n\t\t\t\t\tcalc(1, rest.erase(i*4, 4), ing);  \n\t\t\t\t}\n\t\t\t\trest = bkup_r;\n\t\t\t\ting = \"\";\n\t\t\t}\n\t\t}\n\t}\n\telse if(num<3) {\n\t\tfor(int i=0; i<rest.size(); i++) {\n\t\t\tif(abs((int)ing[2+(num-1)*4] - (int)rest[i]) == 4) {\n\t\t\t\ting.push_back(rest[i%4 + i/4*4]);\n\t\t\t\ting.push_back(rest[(i+1)%4 + i/4*4]);\n\t\t\t\ting.push_back(rest[(i+2)%4 + i/4*4]);\n\t\t\t\ting.push_back(rest[(i+3)%4 + i/4*4]);\n\t\t\t\tif(find(memo.begin(), memo.end(), ing) != memo.end())\n\t\t\t\t\treturn;\n\t\t\t\telse {\n\t\t\t\t\tmemo.push_back(ing); \n\t\t\t\t\tcalc(num+1, rest.erase(i/4*4, 4), ing);  \n\t\t\t\t}\n\t\t\t\trest = bkup_r;\n\t\t\t\ting = bkup_i;\n\t\t\t}\n\t\t}\n\t}\n\telse if(num%3 == 0) {\n\t\tfor(int i=0; i<rest.size(); i++) {\n\t\t\tif(abs((int)ing[3+(num-3)*4] - (int)rest[i]) == 4) {\n\t\t\t\ting.push_back(rest[(i+3)%4 + i/4*4]);\n\t\t\t\ting.push_back(rest[i%4 + i/4*4]);\n\t\t\t\ting.push_back(rest[(i+1)%4 + i/4*4]);\n\t\t\t\ting.push_back(rest[(i+2)%4 + i/4*4]);\n\t\t\t\tif(find(memo.begin(), memo.end(), ing) != memo.end())\n\t\t\t\t\treturn;\n\t\t\t\telse {\n\t\t\t\t\tmemo.push_back(ing); \n\t\t\t\t\tcalc(num+1, rest.erase(i/4*4, 4), ing);  \n\t\t\t\t}\n\t\t\t\trest = bkup_r;\n\t\t\t\ting = bkup_i;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor(int i=0; i<rest.size(); i++) {\n\t\t\tif(abs((int)ing[2+(num-1)*4] - (int)rest[i]) == 4 &&\n\t\t\t\tabs((int)ing[3+(num-3)*4] - (int)rest[(i+1)%4 + i/4*4]) == 4) {\n\t\t\t\ting.push_back(rest[i%4 + i/4*4]);\n\t\t\t\ting.push_back(rest[(i+1)%4 + i/4*4]);\n\t\t\t\ting.push_back(rest[(i+2)%4 + i/4*4]);\n\t\t\t\ting.push_back(rest[(i+3)%4 + i/4*4]);\n\t\t\t\tif(find(memo.begin(), memo.end(), ing) != memo.end())\n\t\t\t\t\treturn;\n\t\t\t\telse {\n\t\t\t\t\tmemo.push_back(ing); \n\t\t\t\t\tcalc(num+1, rest.erase(i/4*4, 4), ing);  \n\t\t\t\t}\n\t\t\t\trest = bkup_r;\n\t\t\t\ting = bkup_i;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint n;\n\tchar input;\n\tstring pieces;\n\n\tcin >> n;\n\tfor(int t=0; t<n; t++) {\n\t\t\tmemo.clear();\n\t\t\tpieces = \"\";\n\t\tfor(int i=0; i<36; i++) {\n\t\t\tcin >> input;\n\t\t\tpieces.push_back(tonum(input));\n\t\t}\n\t\tcnt = 0;\n\t\tcalc(0, pieces, \"\");\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\nvoid func(int);\nbool Check(char,char);\n\n\n\nchar board[4][4][4];\nchar data[9][4];\nbool used[9];\n\nint cnt;\n\nint main(){\n  int n;\n\n  string str;\n  cin >> n;\n  while(n){\n    n--;\n\n    for(int i=0;i<4;i++)\n      for(int j=0;j<4;j++)\n\tfor(int k=0;k<4;k++)\n\t  board[i][j][k]='X';\n\n\n    for(int i=0;i<9;i++){\n      used[i]=false;\n      cin >> str;\n      for(int j=0;j<4;j++){\n\tdata[i][j]=str[j];\n      }\n    }\n\n    cnt=0;\n    func(0);\n    cout << cnt << endl;\n\n  }\n  return 0;\n}\n\n\n\n\nconst int dy[9]={1,1,1,2,2,2,3,3,3};\nconst int dx[9]={1,2,3,1,2,3,1,2,3};\n\nvoid func(int d){\n  if(d==9){\n    cnt++;\n    return;\n  }\n  \n  int y=dy[d],x=dx[d];\n  for(int id=0;id<9;id++){\n    if(used[id])continue;\n    used[id]=true;\n\n    for(int i=0;i<4;i++){\n\n      for(int j=0;j<4;j++)board[y][x][j]=data[id][(i+j)%4];\n      bool r1=Check(board[y-1][x][2],board[y][x][0]);\n      bool r2=Check(board[y][x-1][1],board[y][x][3]);\n      if(r1==true&&r2==true) func(d+1);\n      \n    }\n    used[id]=false;\n  }\n  \n\n}\n\nbool Check(char a,char b){\n  if(a=='X'||b=='X') return true;\n  return (abs(a-b) == abs('A'-'a'));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\nconstexpr int SIZE = 3;\nconstexpr int N = SIZE * SIZE;\nconstexpr int correct = 'a' - 'A';\n\nstring pieces[N];\n\nint ans;\nint turn[SIZE][SIZE];\nint put[SIZE][SIZE];\nbool used[N];\n\ninline bool match(char a, char b) {\n\treturn abs(a - b) == correct;\n}\n\nvoid dfs(int x, int y) {\n\tif(x == SIZE) return dfs(0, y + 1);\n\tif(y == SIZE) {\n\t\t++ans;\n\t\treturn;\n\t}\n\n\tint &i = put[y][x];\n\tint &r = turn[y][x];\n\n\tfor(i = 0; i < N; ++i) {\n\t\tif(used[i]) continue;\n\n\t\tfor(r = 0; r < 4; ++r) {\n\t\t\tif(x && !match(pieces[i][(r+3)%4], pieces[put[y][x-1]][(turn[y][x-1]+1)%4])) continue;\n\t\t\tif(y && !match(pieces[i][r], pieces[put[y-1][x]][turn[y - 1][x] ^ 2])) continue;\n\n\t\t\tused[i] = true;\n\t\t\tdfs(x + 1, y);\n\t\t\tused[i] = false;\n\t\t}\n\t}\n}\n\n\nvoid solve() {\n\tfor(auto &e : pieces) cin >> e;\n\tans = 0;\n\tdfs(0, 0);\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint t;\n\tcin >> t;\n\twhile(t--) solve();\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nconst int correct = abs('a' - 'A');\n\nint ans = 0;\nvector<string> vec(9);\nvector<vector<string> > piece(3,vector<string>(3));\nvector<vector<int> > offset(3,vector<int>(3,0));\nvector<int> used(9,0);\n\nbool valid(char a,char b){\n  return abs(a - b) == correct; \n}\n\nvoid rec(int x, int y) {\n  if(x == 3) return rec(0, y + 1);\n  if(y == 3) {\n    ans++;\n    return ;\n  }\n\n  for(int i = 0;i < 9;i++){\n    if(used[i])continue;\n    for(int d = 0;d < 4;d++){\n      if(x-1 >= 0){\n\tif(!valid(vec[i][(3+d)%4], piece[y][x-1][(1+offset[y][x-1])%4])){\n\t  continue;\n\t}\n      }\n      if(y-1 >= 0){\n\tif(!valid(vec[i][d], piece[y-1][x][(2+offset[y-1][x])%4])){\n\t  continue;\n\t}\n      }\n      piece[y][x] = vec[i];\n      offset[y][x] = d;\n      used[i] = 1;\n      rec(x+1,y);\n      used[i] = 0;\n    }\n  }\n}\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    for(auto &e : vec) {\n      cin >> e;\n    }\n    ans = 0;\n    rec(0,0);\n    cout << ans << endl;\n  }\n    \n    \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nint gSum = 0;\nint key[24];\n\nclass Piece{\npublic:\n\tint pos[4];\n\tPiece(){\n\t\tmemset(pos,0,sizeof(pos));\n\t}\n};\n\nbool check(char pos){\n\tif(pos == 0) return true;\n\t//012\n\t//345\n\t//678\n\n\telse if(pos==1){\n\t\treturn (key[0] + key[1]==0);\n\t}\n\n\telse if(pos==2){\n\t\treturn  (key[2] + key[3]==0);\n\t}\n\n\telse if(pos==3){\n\t\treturn (key[4] + key[7]==0);\n\t}\n\n\telse if(pos==4){\n\t\treturn ((key[5] + key[8]==0)\n\t\t\t&& (key[10] + key[11]==0));\n\t}\n\telse if(pos==5){\n\t\treturn ((key[6] + key[9]==0)\n\t\t\t&& (key[12] + key[13]==0));\n\t}\n\n\telse if(pos==6){\n\t\treturn (key[14] + key[17]==0);\n\t}\n\n\telse if(pos==7){\n\t\treturn ((key[15] + key[18]==0)\n\t\t\t&& (key[20] + key[21]==0));\n\t}\n\n\telse if(pos==8){\n\t\treturn ((key[16] + key[19]==0)\n\t\t\t&& (key[22] + key[23]==0));\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\n\nint dfs(char state,char puzzle[9][5],int visited){\n\n\tif(state==9){\n\t\treturn 1;\n\t}\n\n\tint res = 0;\n\n\tfor(int i=0;i<9;i++){\n\t\tif(visited & (1<<i)) continue;\n\t\tif(state==0){\n\n\t\t\tkey[0] = puzzle[i][0];\n\t\t\tkey[4] = puzzle[i][1];\n\t\t\tres += dfs(1,puzzle,visited | (1<<i));\n\t\t\tkey[0] = puzzle[i][1];\n\t\t\tkey[4] = puzzle[i][2];\n\t\t\tres += dfs(1,puzzle,visited | (1<<i));\n\t\t\tkey[0] = puzzle[i][2];\n\t\t\tkey[4] = puzzle[i][3];\n\t\t\tres += dfs(1,puzzle,visited | (1<<i));\n\t\t\tkey[0] = puzzle[i][3];\n\t\t\tkey[4] = puzzle[i][0];\n\t\t\tres += dfs(1,puzzle,visited | (1<<i));\n\t\t}\n\t\telse if(state==1){\n\n\t\t\tkey[2] = puzzle[i][0];\n\t\t\tkey[5] = puzzle[i][1];\n\t\t\tkey[1] = puzzle[i][2];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[2] = puzzle[i][1];\n\t\t\tkey[5] = puzzle[i][2];\n\t\t\tkey[1] = puzzle[i][3];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[2] = puzzle[i][2];\n\t\t\tkey[5] = puzzle[i][3];\n\t\t\tkey[1] = puzzle[i][0];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[2] = puzzle[i][3];\n\t\t\tkey[5] = puzzle[i][0];\n\t\t\tkey[1] = puzzle[i][1];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\t\t}\n\t\telse if(state==2){  \n\t\t\tkey[6] = puzzle[i][0];\n\t\t\tkey[3] = puzzle[i][1];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[6] = puzzle[i][1];\n\t\t\tkey[3] = puzzle[i][2];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[6] = puzzle[i][2];\n\t\t\tkey[3] = puzzle[i][3];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[6] = puzzle[i][3];\n\t\t\tkey[3] = puzzle[i][0];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\t\t}\n\t\telse if(state==3){\n\n\t\t\tkey[7] = puzzle[i][0];\n\t\t\tkey[10] = puzzle[i][1];\n\t\t\tkey[14] = puzzle[i][2];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[7] = puzzle[i][1];\n\t\t\tkey[10] = puzzle[i][2];\n\t\t\tkey[14] = puzzle[i][3];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[7] = puzzle[i][2];\n\t\t\tkey[10] = puzzle[i][3];\n\t\t\tkey[14] = puzzle[i][0];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[7] = puzzle[i][3];\n\t\t\tkey[10] = puzzle[i][0];\n\t\t\tkey[14] = puzzle[i][1];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\t\t}\n\t\telse if(state==4){\n\t\t\tkey[8] = puzzle[i][0];\n\t\t\tkey[12] = puzzle[i][1];\n\t\t\tkey[15] = puzzle[i][2];\n\t\t\tkey[11] = puzzle[i][3];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[8] = puzzle[i][1];\n\t\t\tkey[12] = puzzle[i][2];\n\t\t\tkey[15] = puzzle[i][3];\n\t\t\tkey[11] = puzzle[i][0];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[8] = puzzle[i][2];\n\t\t\tkey[12] = puzzle[i][3];\n\t\t\tkey[15] = puzzle[i][0];\n\t\t\tkey[11] = puzzle[i][1];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[8] = puzzle[i][3];\n\t\t\tkey[12] = puzzle[i][0];\n\t\t\tkey[15] = puzzle[i][1];\n\t\t\tkey[11] = puzzle[i][2];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\t\t}\n\t\telse if(state==5){\n\t\t\tkey[16] = puzzle[i][0];\n\t\t\tkey[13] = puzzle[i][1];\n\t\t\tkey[9] = puzzle[i][2];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[16] = puzzle[i][1];\n\t\t\tkey[13] = puzzle[i][2];\n\t\t\tkey[9] = puzzle[i][3];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[16] = puzzle[i][2];\n\t\t\tkey[13] = puzzle[i][3];\n\t\t\tkey[9] = puzzle[i][0];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[16] = puzzle[i][3];\n\t\t\tkey[13] = puzzle[i][0];\n\t\t\tkey[9] = puzzle[i][1];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t}\n\t\telse if(state==6){\n\t\t\tkey[17] = puzzle[i][0];\n\t\t\tkey[20] = puzzle[i][1];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[17] = puzzle[i][1];\n\t\t\tkey[20] = puzzle[i][2];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[17] = puzzle[i][2];\n\t\t\tkey[20] = puzzle[i][3];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[17] = puzzle[i][3];\n\t\t\tkey[20] = puzzle[i][0];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\t\t}\n\t\telse if(state==7){\n\t\t\tkey[21] = puzzle[i][0];\n\t\t\tkey[18] = puzzle[i][1];\n\t\t\tkey[22] = puzzle[i][2];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[21] = puzzle[i][1];\n\t\t\tkey[18] = puzzle[i][2];\n\t\t\tkey[22] = puzzle[i][3];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[21] = puzzle[i][2];\n\t\t\tkey[18] = puzzle[i][3];\n\t\t\tkey[22] = puzzle[i][0];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[21] = puzzle[i][3];\n\t\t\tkey[18] = puzzle[i][0];\n\t\t\tkey[22] = puzzle[i][1];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\t\t}\n\t\telse if(state==8){\n\t\t\tkey[23] = puzzle[i][0];\n\t\t\tkey[19] = puzzle[i][1];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[23] = puzzle[i][1];\n\t\t\tkey[19] = puzzle[i][2];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[23] = puzzle[i][2];\n\t\t\tkey[19] = puzzle[i][3];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\n\t\t\tkey[23] = puzzle[i][3];\n\t\t\tkey[19] = puzzle[i][0];\n\t\t\tif(check(state)) res += dfs(state+1,puzzle,visited | (1<<i));\n\t\t}\n\t}\n\treturn res;\n}\n\nchar table[256];\n\nint main(){\n\tint n;\n\n\ttable['r'] = 1;\n\ttable['g'] = 2;\n\ttable['b'] = 3;\n\ttable['w'] = 4;\n\ttable['R'] = -1;\n\ttable['G'] = -2;\n\ttable['B'] = -3;\n\ttable['W'] = -4;\n\n\twhile(~scanf(\"%d\",&n)){\n\t\tfor(int i=0;i<n;i++){\n\n\t\t\tchar puzzle[9][5];\n\t\t\tchar buf[5];\n\t\t\tfor(int j=0;j<9;j++){\n\n\t\t\t\tscanf(\"%s\",buf);\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tpuzzle[j][k] = table[buf[k]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintf(\"%d\\n\",dfs(0,puzzle,0));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nstring s[9], t[3][3];\nint dx[]{ -1,0,1,0 }, dy[]{ 0,1,0,-1 };\nint dfs(int p) {\n\tif (p == 9)return 1;\n\tint res = 0;\n\trep(i, 3)rep(j, 3) {\n\t\tif (t[i][j] != \"\")continue;\n\t\trep(k, 4) {\n\t\t\trotate(s[p].begin(), s[p].begin() + 1, s[p].end());\n\t\t\trep(l, 4){\n\t\t\t\tint nx = i + dx[l], ny = j + dy[l];\n\t\t\t\tif (nx < 0 || 3 <= nx || ny < 0 || 3 <= ny || t[nx][ny] == \"\")continue;\n\t\t\t\tif (isupper(s[p][l])) {\n\t\t\t\t\tif (isupper(t[nx][ny][(l + 2) % 4]) || toupper(t[nx][ny][(l + 2) % 4]) != s[p][l])goto g;\n\t\t\t\t}\n\t\t\t\tif (islower(s[p][l])) {\n\t\t\t\t\tif (islower(t[nx][ny][(l + 2) % 4]) || tolower(t[nx][ny][(l + 2) % 4]) != s[p][l])goto g;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt[i][j] = s[p]; res += dfs(p + 1); g:;\n\t\t}\n\t\tt[i][j] = \"\";\n\t}\n\treturn res;\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n) {\n\t\trep(j, 9)cin >> s[j];\n\t\tprintf(\"%d\\n\", dfs(0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint n,dy[]={0,1},dx[]={1,0};\nstring s[10];\n// 0\n//1 3\n// 2\n\nstring rot90(string s){\n    return s[3]+s.substr(0,3);\n}\n\nint enc(char c){\n    if(c=='R')return 0;\n    if(c=='r')return 1;\n    if(c=='G')return 2;\n    if(c=='g')return 3;\n    if(c=='B')return 4;\n    if(c=='b')return 5;\n    if(c=='W')return 6;\n    if(c=='w')return 7;\n    cout<<\"ERROR: \"<<(int)c<<endl;\n    assert(0);\n}\n\n#define id(y,x) ((y)*3+(x))\n\nint f(int y,int x,int mask,string* state_){\n    if(y==3)return 1;\n    if(x==3)return f(y+1,0,mask,state_);\n    int res=0;\n    string state[10];\n    rep(i,9)state[i]=state_[i];\n    rep(i,9)if(!(mask>>i&1)){\n        string t=s[i];\n        rep(j,4){\n            t=rot90(t);\n            if(y>0){\n                int a=enc(t[0]),b=enc(state[id(y-1,x)][2]);\n                if((a+b)%2==0 || a/2!=b/2)continue;\n            }\n            if(x>0){\n                int a=enc(t[1]),b=enc(state[id(y,x-1)][3]);\n                if((a+b)%2==0 || a/2!=b/2)continue;\n            }\n            state[id(y,x)]=t;\n            res+=f(y,x+1,mask|1<<i,state);\n        }\n    }\n    return res;\n}\n\nint main(){\n\tcin>>n;\n    rep(tc,n){\n        rep(i,9)cin>>s[i];\n        int used[10]={};\n        string state[10];\n        cout<<f(0,0,0,state)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nchar p[3][3][4];\nchar pz[9][4];\n \nbool check(char a,char b){\n    return (a-32 == b || b-32 == a);\n}\n \nint rec(int now,int S){\n    if(now == 9) return 1;\n    int res = 0;\n    int X = now%3, Y = now/3;\n    for(int s = 0 ; s < 9 ; s++){\n        if(S >> s & 1) continue;\n        for(int i = 0 ; i < 4 ; i++){\n            for(int j = 0 ; j < 4 ; j++){\n                p[Y][X][j] = pz[s][(i+j)%4];\n            }\n            bool can = true;    \n            if(X > 0 && !check(p[Y][X][0],p[Y][X-1][2])){\n                can = false;\n            }\n            if(Y > 0 && !check(p[Y][X][1],p[Y-1][X][3])){\n                can = false;            \n            }\n            if(can) res += rec(now+1,S|(1<<s));\n        }\n    }\n    return res;\n}\n \nint main(){\n    int Tc;\n    cin >> Tc;\n    while(Tc--){\n        for(int i = 0 ; i < 9 ; i++){\n            for(int j = 0 ; j < 4 ; j++){\n                cin >> pz[i][j];\n            }\n        }\n        cout << rec(0,0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nstring puzzle[9];\nint pl2id[9], pl2rot[9];\n\nbool check(char a, char b) {\n  return toupper(a) == toupper(b) && a != b;\n}\n\nint dfs(int k, bool *used) {\n  if(k == 9) return 1;\n  \n  int ret = 0;\n  for(int id=0; id<9; id++) {\n    if(used[id]) continue;\n\n    for(int rot=0; rot<4; rot++) {\n      bool ok = true;\n      // 上と一致\n      if(k >= 3) ok &= check(puzzle[id][(rot+1)%4], puzzle[pl2id[k-3]][(pl2rot[k-3]+3)%4]);\n      // 左と一致\n      if(k%3 > 0) ok &= check(puzzle[id][rot], puzzle[pl2id[k-1]][(pl2rot[k-1]+2)%4]);\n      \n      if(ok) {\n\tpl2id[k] = id;\n\tpl2rot[k] = rot;\n\tused[id] = true;\n\tret += dfs(k+1, used);\n\tused[id] = false;\n      }\n    }\n  }\n  \n  return ret;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  while(n--) {\n    for(int i=0; i<9; i++) {\n      cin >> puzzle[i];\n    }\n    \n    bool used[9] = {};\n    cout << dfs(0, used) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define C class\n#define ll long long\n#define ln cout<<'\\n'\n#define _(_1,_2,_3,N,...)N\n#define pr(...) _(__VA_ARGS__,pr3,pr2,pr1)(__VA_ARGS__)\ntemplate<C T>void pr1(T a){cout<<a;ln;}\ntemplate<C T,C T2>void pr2(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<C T,C T2,C T3>void pr3(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<C T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\ntypedef pair<int,int> P;\nstring s[9];\nint a[9];\nint ans;\n\nvoid dfs(int t) {\n  if(t==(1<<9)-1) {\n    ans++;\n    return;\n  }\n  int k=__builtin_popcount(t);\n  rep(i,9) {\n    if(t&(1<<i)) continue;\n    rep(j,4) {\n      rotate(s[i].begin(),s[i].begin()+1,s[i].end());\n      bool f=1;\n      if(k%3) {\n        if(abs(s[i][3]-s[a[k-1]][1])!=abs('A'-'a')) f=0;\n      }\n      if(k>=3) {\n        if(abs(s[i][0]-s[a[k-3]][2])!=abs('A'-'a')) f=0;\n      }\n      if(f) {\n        a[k]=i;\n        dfs(t|(1<<i));\n      }\n    }\n  }\n}\n\nvoid Main() {\n  int T;\n  R T;\n  while(T--) {\n    rep(i,9) R s[i];\n    ans=0;\n    dfs(0);\n    pr(ans);\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nstring s[9], t[3][3];\nint dx[]{ -1,0,1,0 }, dy[]{ 0,1,0,-1 };\nint dfs(int p) {\n\tif (p == 9)return 1;\n\tint res = 0;\n\trep(i, 3)rep(j, 3) {\n\t\tif (!t[i][j].empty())continue;\n\t\trep(k, 4) {\n\t\t\trep(l, 4) {\n\t\t\t\tint nx = i + dx[l], ny = j + dy[l];\n\t\t\t\tif (nx < 0 || 3 <= nx || ny < 0 || 3 <= ny || t[nx][ny].empty())continue;\n\t\t\t\tchar c = t[nx][ny][(l + 2) % 4];\n\t\t\t\tif (isupper(s[p][(l + k) % 4])) {\n\t\t\t\t\tif (isupper(c) || toupper(c) != s[p][(l + k) % 4])goto g;\n\t\t\t\t}\n\t\t\t\telse if (islower(c) || tolower(c) != s[p][(l + k) % 4])goto g;\n\t\t\t}\n\t\t\trep(l, 4)t[i][j] += s[p][(l + k) % 4];\n\t\t\tres += dfs(p + 1); t[i][j].clear(); g:;\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n) {\n\t\trep(j, 9)cin >> s[j];\n\t\tprintf(\"%d\\n\", dfs(0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n \nint gSum = 0;\nint key[24];\n \nclass Piece{\npublic:\n    int pos[4];\n    Piece(){\n        memset(pos,0,sizeof(pos));\n    }\n};\n \nbool check(char pos){\n    if(pos == 0) return true;\n    //012\n    //345\n    //678\n \n    else if(pos==1){\n        return (key[0] + key[1]==0);\n    }\n \n    else if(pos==2){\n        return  (key[2] + key[3]==0);\n    }\n \n    else if(pos==3){\n        return (key[4] + key[7]==0);\n    }\n \n    else if(pos==4){\n        return ((key[5] + key[8]==0)\n        && (key[10] + key[11]==0));\n    }\n    else if(pos==5){\n        return ((key[6] + key[9]==0)\n            && (key[12] + key[13]==0));\n    }\n \n    else if(pos==6){\n        return (key[14] + key[17]==0);\n    }\n \n    else if(pos==7){\n        return ((key[15] + key[18]==0)\n            && (key[20] + key[21]==0));\n    }\n \n    else if(pos==8){\n        return ((key[16] + key[19]==0)\n            && (key[22] + key[23]==0));\n    }\n    else{\n        return false;\n    }\n}\n \nvoid dfs(char state,Piece* puzzle){\n    if(state==9){\n        gSum++;\n        return;\n    }\n \n    int res = 0;\n    if(state==0){\n        key[0] = puzzle[0].pos[0];\n        key[4] = puzzle[0].pos[1];\n        dfs(1,puzzle);\n        key[0] = puzzle[0].pos[1];\n        key[4] = puzzle[0].pos[2];\n        dfs(1,puzzle);\n        key[0] = puzzle[0].pos[2];\n        key[4] = puzzle[0].pos[3];\n        dfs(1,puzzle);\n        key[0] = puzzle[0].pos[3];\n        key[4] = puzzle[0].pos[0];\n        dfs(1,puzzle);\n    }\n    else if(state==1){\n         \n        key[2] = puzzle[1].pos[0];\n        key[5] = puzzle[1].pos[1];\n        key[1] = puzzle[1].pos[2];\n        if(check(1)) dfs(2,puzzle);\n \n        key[2] = puzzle[1].pos[1];\n        key[5] = puzzle[1].pos[2];\n        key[1] = puzzle[1].pos[3];\n        if(check(1)) dfs(2,puzzle);\n \n        key[2] = puzzle[1].pos[2];\n        key[5] = puzzle[1].pos[3];\n        key[1] = puzzle[1].pos[0];\n        if(check(1)) dfs(2,puzzle);\n \n        key[2] = puzzle[1].pos[3];\n        key[5] = puzzle[1].pos[0];\n        key[1] = puzzle[1].pos[1];\n        if(check(1)) dfs(2,puzzle);\n    }\n    else if(state==2){  \n        key[6] = puzzle[2].pos[0];\n        key[3] = puzzle[2].pos[1];\n        if(check(2)) dfs(3,puzzle);\n        key[6] = puzzle[2].pos[1];\n        key[3] = puzzle[2].pos[2];\n        if(check(2)) dfs(3,puzzle);\n        key[6] = puzzle[2].pos[2];\n        key[3] = puzzle[2].pos[3];\n        if(check(2)) dfs(3,puzzle);\n        key[6] = puzzle[2].pos[3];\n        key[3] = puzzle[2].pos[0];\n        if(check(2)) dfs(3,puzzle);\n    }\n    else if(state==3){\n        key[7] = puzzle[3].pos[0];\n        key[10] = puzzle[3].pos[1];\n        key[14] = puzzle[3].pos[2];\n        if(check(3)) dfs(4,puzzle);\n \n        key[7] = puzzle[3].pos[1];\n        key[10] = puzzle[3].pos[2];\n        key[14] = puzzle[3].pos[3];\n        if(check(3)) dfs(4,puzzle);\n \n        key[7] = puzzle[3].pos[2];\n        key[10] = puzzle[3].pos[3];\n        key[14] = puzzle[3].pos[0];\n        if(check(3)) dfs(4,puzzle);\n \n        key[7] = puzzle[3].pos[3];\n        key[10] = puzzle[3].pos[0];\n        key[14] = puzzle[3].pos[1];\n        if(check(3)) dfs(4,puzzle);\n    }\n    else if(state==4){\n        key[8] = puzzle[4].pos[0];\n        key[12] = puzzle[4].pos[1];\n        key[15] = puzzle[4].pos[2];\n        key[11] = puzzle[4].pos[3];\n        if(check(4)) dfs(5,puzzle);\n \n        key[8] = puzzle[4].pos[1];\n        key[12] = puzzle[4].pos[2];\n        key[15] = puzzle[4].pos[3];\n        key[11] = puzzle[4].pos[0];\n        if(check(4)) dfs(5,puzzle);\n \n        key[8] = puzzle[4].pos[2];\n        key[12] = puzzle[4].pos[3];\n        key[15] = puzzle[4].pos[0];\n        key[11] = puzzle[4].pos[1];\n        if(check(4)) dfs(5,puzzle);\n \n        key[8] = puzzle[4].pos[3];\n        key[12] = puzzle[4].pos[0];\n        key[15] = puzzle[4].pos[1];\n        key[11] = puzzle[4].pos[2];\n        if(check(4)) dfs(5,puzzle);\n    }\n    else if(state==5){\n        key[16] = puzzle[5].pos[0];\n        key[13] = puzzle[5].pos[1];\n        key[9] = puzzle[5].pos[2];\n        if(check(5)) dfs(6,puzzle);\n \n        key[16] = puzzle[5].pos[1];\n        key[13] = puzzle[5].pos[2];\n        key[9] = puzzle[5].pos[3];\n        if(check(5)) dfs(6,puzzle);\n \n        key[16] = puzzle[5].pos[2];\n        key[13] = puzzle[5].pos[3];\n        key[9] = puzzle[5].pos[0];\n        if(check(5)) dfs(6,puzzle);\n \n        key[16] = puzzle[5].pos[3];\n        key[13] = puzzle[5].pos[0];\n        key[9] = puzzle[5].pos[1];\n        if(check(5)) dfs(6,puzzle);\n    }\n    else if(state==6){\n        key[17] = puzzle[6].pos[0];\n        key[20] = puzzle[6].pos[1];\n        if(check(6)) dfs(7,puzzle);\n \n        key[17] = puzzle[6].pos[1];\n        key[20] = puzzle[6].pos[2];\n        if(check(6)) dfs(7,puzzle);\n \n        key[17] = puzzle[6].pos[2];\n        key[20] = puzzle[6].pos[3];\n        if(check(6)) dfs(7,puzzle);\n \n        key[17] = puzzle[6].pos[3];\n        key[20] = puzzle[6].pos[0];\n        if(check(6)) dfs(7,puzzle);\n    }\n    else if(state==7){\n        key[21] = puzzle[7].pos[0];\n        key[18] = puzzle[7].pos[1];\n        key[22] = puzzle[7].pos[2];\n        if(check(7)) dfs(8,puzzle);     \n \n        key[21] = puzzle[7].pos[1];\n        key[18] = puzzle[7].pos[2];\n        key[22] = puzzle[7].pos[3];\n        if(check(7)) dfs(8,puzzle); \n \n        key[21] = puzzle[7].pos[2];\n        key[18] = puzzle[7].pos[3];\n        key[22] = puzzle[7].pos[0];\n        if(check(7)) dfs(8,puzzle); \n \n        key[21] = puzzle[7].pos[3];\n        key[18] = puzzle[7].pos[0];\n        key[22] = puzzle[7].pos[1];\n        if(check(7)) dfs(8,puzzle); \n    }\n    else if(state==8){\n        key[23] = puzzle[8].pos[0];\n        key[19] = puzzle[8].pos[1];\n        if(check(8)) dfs(9,puzzle); \n \n        key[23] = puzzle[8].pos[1];\n        key[19] = puzzle[8].pos[2];\n        if(check(8)) dfs(9,puzzle); \n \n        key[23] = puzzle[8].pos[2];\n        key[19] = puzzle[8].pos[3];\n        if(check(8)) dfs(9,puzzle); \n \n        key[23] = puzzle[8].pos[3];\n        key[19] = puzzle[8].pos[0];\n        if(check(8)) dfs(9,puzzle); \n    }\n}\n \nchar table[256];\n \nint main(){\n    int n;\n \n    table['r'] = 1;\n    table['g'] = 2;\n    table['b'] = 3;\n    table['w'] = 4;\n    table['R'] = -1;\n    table['G'] = -2;\n    table['B'] = -3;\n    table['W'] = -4;\n \n    while(~scanf(\"%d\",&n)){\n        for(int i=0;i<n;i++){\n \n            Piece puzzle[9];\n            for(int j=0;j<9;j++){\n                char buf[5];\n                scanf(\"%s\",buf);\n                for(int k=0;k<4;k++){\n                    puzzle[j].pos[k] = table[buf[k]];\n                }\n            }\n \n            char patterns[] = {0,1,2,3,4,5,6,7,8};\n            gSum = 0;\n \n            do{\n                Piece tmp[9];\n                for(int i=0;i<9;i++){\n                    tmp[i] = puzzle[patterns[i]];\n                }\n                dfs(0,tmp);\n            }while(next_permutation(patterns,patterns+9));\n \n            printf(\"%d\\n\",gSum);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint dy[]={-1,0,1,0},dx[]={0,1,0,-1};\nint ans,sp[3][3];\nchar pc[9][5];\nbool use[9];\n\nvoid rec(int c)\n{\n\tif(c==9)\n\t{\n\t\tans++; return;\n\t}\n\trep(i,9)if(!use[i])\n\t{\n\t\tsp[c/3][c%3]=i; use[i]=1;\n\t\trep(rt,4)\n\t\t{\n\t\t\trep(d,4)\n\t\t\t{\n\t\t\t\tint y=c/3+dy[d],x=c%3+dx[d];\n\t\t\t\tif(y<0||x<0||y>=3||x>=3||sp[y][x]<0)continue;\n\t\t\t\tchar c1=pc[i][d],c2=pc[sp[y][x]][d^2];\n\t\t\t\tif(abs(c1-c2)!=abs('A'-'a'))goto FAIL;\n\t\t\t}\n\t\t\trec(c+1);\n\t\t\tFAIL:\n\t\t\trotate(pc[i],pc[i]+1,pc[i]+4);\n\t\t}\n\t\tsp[c/3][c%3]=-1; use[i]=0;\n\t}\n}\n\nint sol()\n{\n\trep(i,9)use[i]=0,sp[i/3][i%3]=-1; ans=0;\n\trec(0);\n\treturn ans;\n}\n\nint main()\n{\n\tint n; scanf(\"%d\",&n);\n\trep(i,n)\n\t{\n\t\trep(j,9)scanf(\"%s\",pc[j]);\n\t\tprintf(\"%d\\n\",sol());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<bitset>\n#include<cmath>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n \nusing namespace std;\n \nstruct Puzzle\n{\n  char t,r,b,l;\n  Puzzle(char t='$',char r='$',char b='$',char l='$'):t(t),r(r),b(b),l(l){}\n \n  void rotate90()\n  {\n    char tmp = t;\n    t = l;\n    l = b;\n    b = r;\n    r = tmp;\n  }\n \n  bool operator < (const Puzzle &p)const\n  {\n    if(t != p.t)return t < p.t;\n    if(r != p.r)return r < p.r;\n    if(b != p.b)return b < p.b;\n    return l < p.l;\n  }\n \n};\n \nPuzzle puzzle[9];\nPuzzle p2[9];\nint cnt;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n \n \n \nbool match(char a,char b)\n{\n  if(a == 'R' && b == 'r')return true;\n  if(a == 'G' && b == 'g')return true;\n  if(a == 'B' && b == 'b')return true;\n  if(a == 'W' && b == 'w')return true;\n  if(a == 'w' && b == 'W')return true;\n  if(a == 'b' && b == 'B')return true;\n  if(a == 'g' && b == 'G')return true;\n  if(a == 'r' && b == 'R')return true;\n    return false;\n}\n \nvoid dfs(int p,int used)\n{\n \n  if(p >= 9)\n    {\n      cnt++;\n      return;\n    }\n \n  rep(i,9)\n    {\n      if((used >> i) & 1)continue;\n      puzzle[p] = p2[i];\n      rep(j,4)\n    {\n      if(p == 0)\n        {\n          dfs(p+1,used|(1<<i));\n          puzzle[p].rotate90();\n          continue;\n        }\n \n      if(p%3 == 0)\n        {\n          if(match(puzzle[p].t,puzzle[p-3].b))\n        {\n          dfs(p+1,used|(1<<i));\n        }\n        }\n      else\n        {\n          bool ok = true;\n          if(p-3>=0)\n        if(!match(puzzle[p].t,puzzle[p-3].b))ok = false;\n          if(!match(puzzle[p].l,puzzle[p-1].r))ok = false;\n          if(ok)\n        {\n          dfs(p+1,used|(1<<i));\n        }\n        }\n      puzzle[p].rotate90();\n    }\n    }\n \n}\n \nint main()\n{\n  int T;\n  cin >> T;\n  while(T--)\n    {\n      cnt = 0;\n      rep(i,3)\n    {\n      rep(j,3)\n        {\n          string s;\n          cin >> s;\n          p2[i*3+j].t = s[0];\n          p2[i*3+j].r = s[1];\n          p2[i*3+j].b = s[2];         \n          p2[i*3+j].l = s[3];         \n        }\n    }\n      dfs(0,0);\n \n      cout << cnt << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cctype>\n\nusing namespace std;\n\nint recur(const vector<string> &pieces, int used, const char *conn){\n\tint index = __builtin_popcount(used);\n\tif(index >= 9){ return 1; }\n\tint x = index % 3, y = index / 3;\n\tchar nextConn[5] = { conn[0], conn[1], conn[2], conn[3], '\\0' };\n\tint answer = 0;\n\tfor(int i = 0; i < pieces.size(); ++i){\n\t\tif(used & (1 << i)){ continue; }\n\t\tfor(int j = 0; j < 4; ++j){\n\t\t\tchar up = pieces[i][j], left = pieces[i][(j + 3) % 4];\n\t\t\tif(conn[x] != '\\0' && conn[x] != (up ^ 0x20)){ continue; }\n\t\t\tif(conn[3] != '\\0' && conn[3] != (left ^ 0x20)){ continue; }\n\t\t\tchar down = pieces[i][(j + 2) % 4], right = pieces[i][(j + 1) % 4];\n\t\t\tnextConn[x] = down;\n\t\t\tnextConn[3] = (x == 2 ? '\\0' : right);\n\t\t\tanswer += recur(pieces, used | (1 << i), nextConn);\n\t\t}\n\t}\n\treturn answer;\n}\n\nint main(){\n\tint N;\n\tcin >> N;\n\twhile(N--){\n\t\tvector<string> pieces(9);\n\t\tfor(int i = 0; i < 9; ++i){ cin >> pieces[i]; }\n\t\tchar initConn[5] = { 0 };\n\t\tcout << recur(pieces, 0, initConn) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n\n\nusing namespace std;\n\nint cnt;\n//vector<string> memo;\n\nchar tonum(char word) {\n\tif(word == 'R') return '1';\n\tif(word == 'G') return '2';\n\tif(word == 'B') return '3';\n\tif(word == 'W') return '4';\n\tif(word == 'r') return '5';\n\tif(word == 'g') return '6';\n\tif(word == 'b') return '7';\n\tif(word == 'w') return '8';\n\n\treturn '0';\n}\n\nvoid calc(int num, string rest, string ing) {\n\tstring bkup_r = rest;\n\tstring bkup_i = ing;\n\n\tif(num==9) {\n\t\tcnt++; return;\n\t}\n\n\tif(num == 0) {\n\t\tfor(int i=0; i<9; i++) {\n\t\t\tfor(int j=0; j<4; j++) {\n\t\t\t\ting.push_back(rest[j%4 + i*4]);\n\t\t\t\ting.push_back(rest[(j+1)%4 + i*4]);\n\t\t\t\ting.push_back(rest[(j+2)%4 + i*4]);\n\t\t\t\ting.push_back(rest[(j+3)%4 + i*4]);\n//\t\t\t\tif(find(memo.begin(), memo.end(), ing) != memo.end())\n//\t\t\t\t\treturn;\n//\t\t\t\telse {\n//\t\t\t\t\tmemo.push_back(ing); \n\t\t\t\t\tcalc(1, rest.erase(i*4, 4), ing);  \n//\t\t\t\t}\n\t\t\t\trest = bkup_r;\n\t\t\t\ting = \"\";\n\t\t\t}\n\t\t}\n\t}\n\telse if(num<3) {\n\t\tfor(int i=0; i<rest.size(); i++) {\n\t\t\tif(abs((int)ing[2+(num-1)*4] - (int)rest[i]) == 4) {\n\t\t\t\ting.push_back(rest[i%4 + i/4*4]);\n\t\t\t\ting.push_back(rest[(i+1)%4 + i/4*4]);\n\t\t\t\ting.push_back(rest[(i+2)%4 + i/4*4]);\n\t\t\t\ting.push_back(rest[(i+3)%4 + i/4*4]);\n//\t\t\t\tif(find(memo.begin(), memo.end(), ing) != memo.end())\n//\t\t\t\t\treturn;\n//\t\t\t\telse {\n//\t\t\t\t\tmemo.push_back(ing); \n\t\t\t\t\tcalc(num+1, rest.erase(i/4*4, 4), ing);  \n//\t\t\t\t}\n\t\t\t\trest = bkup_r;\n\t\t\t\ting = bkup_i;\n\t\t\t}\n\t\t}\n\t}\n\telse if(num%3 == 0) {\n\t\tfor(int i=0; i<rest.size(); i++) {\n\t\t\tif(abs((int)ing[3+(num-3)*4] - (int)rest[i]) == 4) {\n\t\t\t\ting.push_back(rest[(i+3)%4 + i/4*4]);\n\t\t\t\ting.push_back(rest[i%4 + i/4*4]);\n\t\t\t\ting.push_back(rest[(i+1)%4 + i/4*4]);\n\t\t\t\ting.push_back(rest[(i+2)%4 + i/4*4]);\n//\t\t\t\tif(find(memo.begin(), memo.end(), ing) != memo.end())\n//\t\t\t\t\treturn;\n//\t\t\t\telse {\n//\t\t\t\t\tmemo.push_back(ing); \n\t\t\t\t\tcalc(num+1, rest.erase(i/4*4, 4), ing);  \n//\t\t\t\t}\n\t\t\t\trest = bkup_r;\n\t\t\t\ting = bkup_i;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor(int i=0; i<rest.size(); i++) {\n\t\t\tif(abs((int)ing[2+(num-1)*4] - (int)rest[i]) == 4 &&\n\t\t\t\tabs((int)ing[3+(num-3)*4] - (int)rest[(i+1)%4 + i/4*4]) == 4) {\n\t\t\t\ting.push_back(rest[i%4 + i/4*4]);\n\t\t\t\ting.push_back(rest[(i+1)%4 + i/4*4]);\n\t\t\t\ting.push_back(rest[(i+2)%4 + i/4*4]);\n\t\t\t\ting.push_back(rest[(i+3)%4 + i/4*4]);\n//\t\t\t\tif(find(memo.begin(), memo.end(), ing) != memo.end())\n//\t\t\t\t\treturn;\n//\t\t\t\telse {\n//\t\t\t\t\tmemo.push_back(ing); \n\t\t\t\t\tcalc(num+1, rest.erase(i/4*4, 4), ing);  \n//\t\t\t\t}\n\t\t\t\trest = bkup_r;\n\t\t\t\ting = bkup_i;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint n;\n\tchar input;\n\tstring pieces;\n\n\tcin >> n;\n\tfor(int t=0; t<n; t++) {\n//\t\t\tmemo.clear();\n\t\t\tpieces = \"\";\n\t\tfor(int i=0; i<36; i++) {\n\t\t\tcin >> input;\n\t\t\tpieces.push_back(tonum(input));\n\t\t}\n\t\tcnt = 0;\n\t\tcalc(0, pieces, \"\");\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt (string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin();i!=(c).end();++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS=1e-10;\nconst double PI=acos(-1.0);\n\nstruct P{\n\tstring sides;\n\tP(string sides):sides(sides){}\n};\ntypedef vector<P> vP;\ntypedef vector<vP> vvP;\nint dx[]={0,1,0,-1},dy[]={-1,0,1,0};\n\nbool match(char l,char r){\n\tif(l==' '||r==' '){\n\t\treturn true;\n\t}\n\tif(l>r){\n\t\tswap(l,r);\n\t}\n\tswitch(l){\n\tcase 'R':\n\t\treturn r=='r';\n\tcase 'G':\n\t\treturn r=='g';\n\tcase 'B':\n\t\treturn r=='b';\n\tcase 'W':\n\t\treturn r=='w';\n\tdefault:\n\t\tassert(r!='R'&&r!='G'&&r!='B'&&r!='W');\n\t\treturn false;\n\t}\n}\n\nbool ok(vvP &board,P piece,int x,int y){\n\tREP(i,4){\n\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\tif(xx>=0&&xx<3&&yy>=0&&yy<3){\n\t\t\tif(!match(board[xx][yy].sides[(i+2)%4],piece.sides[i])){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nP rotate(P &p,int a){\n\tP ret(\"    \");\n\tREP(i,4){\n\t\tret.sides[i]=p.sides[(i+a)%4];\n\t}\n\treturn ret;\n}\nint aaaa=0;\nint dfs(vvP &board,vi used,int n,vP &pieces){\n\tif(n==9){\n\t\treturn 1;\n\t}\n\tint res=0;\n\tint x=n%3,y=n/3;\n\tREP(i,9){\n\t\tif(!used[i]){\n\t\t\tREP(j,4){\n\t\t\t\tP piece=rotate(pieces[i],j);\n\t\t\t\tif(ok(board,piece,x,y)){\n\t\t\t\t\tvi newUsed(used);\n\t\t\t\t\tnewUsed[i]=1;\n\t\t\t\t\tvvP newBoard(board);\n\t\t\t\t\tnewBoard[x][y]=piece;\n\t\t\t\t\tres+=dfs(newBoard,newUsed,n+1,pieces);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\taaaa=max(aaaa,res);\n\treturn res;\n}\n\nint main(){\n\tint N;\n\tcin>>N;\n\tREP(i,N){\n\t\tvP pieces;\n\t\tREP(j,9){\n\t\t\tstring sides;\n\t\t\tcin>>sides;\n\t\t\tpieces.push_back(P(sides));\n\t\t}\n\t\tvvP v(3,vP(3,P(\"    \")));\n\t\tcout<<dfs(v,vi(9),0,pieces)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cctype>\n#define MAX 9\nusing namespace std;\nchar ChangeCase(char c){\n\tif( islower( c ) )\n\t\treturn toupper( c );\n\telse if( isupper( c ) )\n\t\treturn tolower( c );\n\telse\n\t\treturn '\\0';\n}\nstruct piece{\n\tchar c[4];\n};\nstruct puzzle{\n\tpiece pieces[MAX][4];\n\tbool bUsed[MAX];\n\tpiece pzl[MAX];\n\tpuzzle(){ for(int i = 0; i < MAX; ++i) bUsed[i]=false; }\n\tvoid CreateRotations(){\n\t\tfor(int i = 0; i < MAX; ++i){\n\t\t\tfor(int j = 1; j < 4; ++j){\n\t\t\t\tfor(int k = 0; k < 4; ++k){\n\t\t\t\t\tpieces[i][j].c[k] = pieces[i][0].c[(j+k)%4];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nvoid solve( puzzle &p, int depth, int pos, int &ans ){\n\tconst int cp[] = {1,5,7,3};\n\tconst int ccp[] = {2,8,6,0};\n\tconst int cfp[] = {1,5,3,1};\n\tconst int csp[] = {5,7,7,3};\n\tconst int cfpp[] = {1,2,2,3};\n\tconst int cspp[] = {0,1,3,0};\n\n\tswitch( depth ){\n\t\tcase 0:\n\t\t\tfor(int i = 0; i < MAX; ++i){\n\t\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\t\tp.bUsed[i] = true;\n\t\t\t\t\tp.pzl[4] = p.pieces[i][j];\n\t\t\t\t\tsolve( p, 1, 0, ans );\n\t\t\t\t\tp.bUsed[i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfor(int i = 0; i < MAX; ++i){\n\t\t\t\tif( !p.bUsed[i] ){\n\t\t\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\t\t\tif( p.pzl[4].c[pos] == ChangeCase( p.pieces[i][j].c[(pos+2)%4] ) ){\n\t\t\t\t\t\t\tp.bUsed[i] = true;\n\t\t\t\t\t\t\tp.pzl[ cp[pos] ] = p.pieces[i][j];\n\t\t\t\t\t\t\tsolve( p, pos<3?1:2, (pos+1)%4, ans );\n\t\t\t\t\t\t\tp.bUsed[i] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfor(int i = 0; i < MAX; ++i){\n\t\t\t\tif( !p.bUsed[i] ){\n\t\t\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\t\t\tif( p.pzl[ cfp[pos] ].c[ cfpp[pos] ] == ChangeCase( p.pieces[i][j].c[(cfpp[pos]+2)%4] ) &&\n\t\t\t\t\t\t\tp.pzl[ csp[pos] ].c[ cspp[pos] ] == ChangeCase( p.pieces[i][j].c[(cspp[pos]+2)%4] ) ){\n\t\t\t\t\t\t\tp.bUsed[i] = true;\n\t\t\t\t\t\t\tp.pzl[ ccp[pos] ] = p.pieces[i][j];\n\t\t\t\t\t\t\tif( pos == 3 ){\n\t\t\t\t\t\t\t\t++ans;\n\t\t\t\t\t\t\t\t//cout << ans << endl;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tsolve( p, 2, pos+1, ans );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tp.bUsed[i] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 0; i < n; ++i){\n\t\tint ans = 0;\n\t\tpuzzle p;\n\t\tfor(int j = 0; j < MAX; ++j){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tfor(int k = 0; k < 4; ++k){\n\t\t\t\tp.pieces[j][0].c[k] = s[k];\n\t\t\t}\n\t\t}\n\t\tp.CreateRotations();\n\n\t\tsolve( p, 0, 0, ans );\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\n\nint n;\nstring p[9];\nbool use[9];\nint dir[9],id[9];\n\nint rec(int d){\n  if(d==9)return 1;\n\n  int res = 0;\n  for(int i=0;i<9;i++){\n    if(use[i])continue;\n    use[i] = true;\n\n    for(int j=0;j<4;j++){\n      if(d>2){\n\tif(abs( p[id[d-3]][(2+dir[d-3])%4] - p[i][j] ) != 32)continue;\n      }\n      if(d%3!=0){\n\tif(abs( p[id[d-1]][(1+dir[d-1])%4] - p[i][(j+3)%4] ) != 32)continue;\n      }\n      id[d] = i; dir[d] = j;\n      res += rec(d+1);\n    }\n    use[i] = false;\n  }\n  return res;\n}\n\nint main(){\n  cin >> n;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<9;j++){\n      cin >> p[j];\n      use[j] = false;\n    }\n\n    cout << rec(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nstring piece[9];\nint rot[9];\nint bgn[11] = {0,0,0,1,2,3,5,7,8,10,12};\nint check[12][4] = {\n  {1, 3, 0, 1},\n  {2, 3, 1, 1},\n  {3, 0, 0, 2},\n  {4, 0, 1, 2},\n  {4, 3, 3, 1},\n  {5, 0, 2, 2},\n  {5, 3, 4, 1},\n  {6, 0, 3, 2},\n  {7, 0, 4, 2},\n  {7, 3, 6, 1},\n  {8, 0, 5, 2},\n  {8, 3, 7, 1}\n};\ninline bool ok(char c, char d){\n  return c != d && tolower(c) == tolower(d);\n}\nint ans;\nvoid dfs(int u){\n  for(int i = bgn[u]; i < bgn[u+1]; i++){\n    int p = check[i][0], q = check[i][2];\n    int c1 = (check[i][1] + rot[p]) % 4, c2 = (check[i][3] + rot[q]) % 4;\n    if(!ok(piece[p][c1], piece[q][c2])) return;\n  }\n  if(u == 9){\n    ans ++;\n    return;\n  }\n  for(int i = 0; i <= 3; i++){\n    rot[u] = i;\n    dfs(u + 1);\n  }\n}\nint main(){\n  int T; cin>>T;\n  while(T--){\n    REP(i, 9) cin>>piece[i];\n    sort(piece, piece + 9);\n    ans = 0;\n    do{\n      dfs(0);\n    }while(next_permutation(piece, piece + 9));\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nstring piece[9];\nint rot[9];\nint bgn[10] = {0,0,0,1,2,3,5,7,8,10};\nint check[12][4] = {\n  {1, 3, 0, 1},\n  {2, 3, 1, 1},\n  {3, 0, 0, 2},\n  {4, 0, 1, 2},\n  {4, 3, 3, 1},\n  {5, 0, 2, 2},\n  {5, 3, 4, 1},\n  {6, 0, 3, 2},\n  {7, 0, 4, 2},\n  {7, 3, 6, 1},\n  {8, 0, 5, 2},\n  {8, 3, 7, 1}\n};\nint toint(char c){\n  if(isupper(c)) return c - 'A';\n  else return c - 'a';\n}\nint dfs(int u){\n  for(int i = bgn[u]; i < 12; i++){\n    int p = check[i][0], q = check[i][2];\n    if(p >= u) break;\n    int c1 = (check[i][1] + rot[p]) % 4, c2 = (check[i][3] + rot[q]) % 4;\n    if(toint(piece[p][c1]) != toint(piece[q][c2]) || piece[p][c1] == piece[q][c2]) return 0;\n  }\n  if(u == 9) return 1;\n  int res = 0;\n  for(int i = 0; i <= 3; i++){\n    rot[u] = i;\n    res += dfs(u + 1);\n  }\n  return res;\n}\nint main(){\n  int T; cin>>T;\n  while(T--){\n    REP(i, 9) cin>>piece[i];\n    sort(piece, piece + 9);\n    int ans = 0;\n    do{\n      ans += dfs(0);\n    }while(next_permutation(piece, piece + 9));\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nbool match(char a,char b)\n{\n\treturn (a^1<<5)==b;\n}\n\nint solve(vector<string>& ps,vector<int>& perm,int cur)\n{\n\tif(cur==9)\n\t\treturn 1;\n\t\n\tint res=0;\n\tfor(int k=cur;k<9;k++){\n\t\tswap(perm[cur],perm[k]);\n\t\tint i=cur/3,j=cur%3;\n\t\tfor(int l=0;l<4;l++){\n\t\t\tbool flg=true;\n\t\t\tif(i>=1 && !match(ps[perm[cur]][0],ps[perm[(i-1)*3+j]][2]))\n\t\t\t\tflg=false;\n\t\t\tif(j>=1 && !match(ps[perm[cur]][3],ps[perm[i*3+(j-1)]][1]))\n\t\t\t\tflg=false;\n\t\t\tif(flg)\n\t\t\t\tres+=solve(ps,perm,cur+1);\n\t\t\trotate(ps[perm[cur]].begin(),ps[perm[cur]].begin()+1,ps[perm[cur]].end());\n\t\t}\n\t\tswap(perm[cur],perm[k]);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint tc; cin>>tc;\n\twhile(tc--){\n\t\tvector<string> ps(9);\n\t\tfor(int i=0;i<9;i++)\n\t\t\tcin>>ps[i];\n\t\t\n\t\tvector<int> perm(9);\n\t\tiota(perm.begin(),perm.end(),0);\n\t\tcout<<solve(ps,perm,0)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\nconstexpr int SIZE = 3;\nconstexpr int N = SIZE * SIZE;\nconstexpr int correct = 'a' - 'A';\n\nstring pieces[N];\n\nint ans;\nint turn[SIZE][SIZE];\nint put[SIZE][SIZE];\nbool used[N];\n\ninline bool match(char a, char b) {\n\treturn abs(a - b) == correct;\n}\n\nvoid dfs(int x, int y) {\n\tif(x == SIZE) return dfs(0, y + 1);\n\tif(y == SIZE) {\n\t\t++ans;\n\t\treturn;\n\t}\n\n\tint &i = put[y][x];\n\tint &r = turn[y][x];\n\n\tfor(i = 0; i < N; ++i) {\n\t\tif(used[i]) continue;\n\n\t\tfor(r = 0; r < 4; ++r) {\n\t\t\tif(x && !match(pieces[i][(r+3)%4], pieces[put[y][x-1]][(turn[y][x-1]+1)%4])) continue;\n\t\t\tif(y && !match(pieces[i][r], pieces[put[y-1][x]][turn[y - 1][x] ^ 2])) continue;\n\n\t\t\tused[i] = true;\n\t\t\tdfs(x + 1, y);\n\t\t\tused[i] = false;\n\t\t}\n\t}\n}\n\n\nvoid solve() {\n\tfor(auto &e : pieces) cin >> e;\n\tans = 0;\n\tdfs(0, 0);\n\tcout << ans << endl;\n}\n\nint main() {\n\tint t;\n\tcin >> t;\n\twhile(t--) solve();\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<string> s(9);\nvector<bool> check(9, false);\nvector<int> a(9), b(9);\n\nint solve(int k){\n    if(k == 9)\n        return 1;\n\n    int ret = 0;\n    for(int i=0; i<9; ++i){\n        if(check[i])\n            continue;\n        check[i] = true;\n        a[k] = i;\n        for(int j=0; j<4; ++j){\n            b[k] = j;\n            if(k > 2 && abs(s[i][j] - s[a[k-3]][(b[k-3]+2)%4]) != abs('a'-'A'))\n                continue;\n            if(k % 3 != 0 && abs(s[i][(j+3)%4] - s[a[k-1]][(b[k-1]+1)%4]) != abs('a'-'A'))\n                continue;\n            ret += solve(k+1);\n        }\n        check[i] = false;\n    }\n\n    return ret;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    while(--n >= 0){\n        for(int i=0; i<9; ++i)\n            cin >> s[i];\n\n        int ret = solve(0);\n        cout << ret << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//15\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cctype>\n\nusing namespace std;\n\nstring b[9];\nstring p[9];\n\nbool cn(char a,char b){\n  return a!=b&&tolower(a)==tolower(b);\n}\n\nint dfs(int x,int u){\n  if(x==9){\n    return 1;\n  }else{\n    int r=0;\n    for(int i=0;i<9;i++){\n      if(!(u>>i&1)){\n\tfor(int j=0;j<4;j++){\n\t  rotate(p[i].begin(),p[i].begin()+1,p[i].end());\n\t  if((x/3==0||cn(b[x-3][2],p[i][0]))&&(x%3==0||cn(b[x-1][1],p[i][3]))){\n\t    b[x]=p[i];\n\t    r+=dfs(x+1,u|1<<i);\n\t  }\n\t}\n      }\n    }\n    return r;\n  }\n}\n\nint main(){\n  int n;\n  cin>>n;\n  while(n--){\n    for(int i=0;i<9;i++){\n      cin>>p[i];\n    }\n    cout<<dfs(0,0)<<endl;\n  }\n  return 0;\n}\n  \n  "
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt (string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin();i!=(c).end();++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS=1e-10;\nconst double PI=acos(-1.0);\n\nstruct P{\n\tstring sides;\n\tP(string sides):sides(sides){}\n};\ntypedef vector<P> vP;\ntypedef vector<vP> vvP;\nint dx[]={0,1,0,-1},dy[]={-1,0,1,0};\n\nbool match(char l,char r){\n\tif(l==' '||r==' '){\n\t\treturn true;\n\t}\n\tif(l>r){\n\t\tswap(l,r);\n\t}\n\tswitch(l){\n\tcase 'R':\n\t\treturn r=='r';\n\tcase 'G':\n\t\treturn r=='g';\n\tcase 'B':\n\t\treturn r=='b';\n\tcase 'W':\n\t\treturn r=='w';\n\tdefault:\n\t\tassert(r!='R'&&r!='G'&&r!='B'&&r!='W');\n\t\treturn false;\n\t}\n}\n\nbool ok(vvP &board,P piece,int x,int y){\n\tREP(i,4){\n\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\tif(xx>=0&&xx<3&&yy>=0&&yy<3){\n\t\t\tif(!match(board[xx][yy].sides[(i+2)%4],piece.sides[i])){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nP rotate(P &p,int a){\n\tP ret(\"    \");\n\tREP(i,4){\n\t\tret.sides[i]=p.sides[(i+a)%4];\n\t}\n\treturn ret;\n}\nint aaaa=0;\nint dfs(vvP &board,vi used,int n,vP &pieces){\n\tif(n==9){\n\t\treturn 1;\n\t}\n\tint res=0;\n\tint x=n%3,y=n/3;\n\tREP(i,9){\n\t\tif(!used[i]){\n\t\t\tREP(j,4){\n\t\t\t\tP piece=rotate(pieces[i],j);\n\t\t\t\tif(ok(board,piece,x,y)){\n\t\t\t\t\tvi newUsed(used);\n\t\t\t\t\tnewUsed[i]=1;\n\t\t\t\t\tvvP newBoard(board);\n\t\t\t\t\tnewBoard[x][y]=piece;\n\t\t\t\t\tres+=dfs(newBoard,newUsed,n+1,pieces);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\taaaa=max(aaaa,res);\n\treturn res;\n}\n\nint main(){\n\tint N;\n\tcin>>N;\n\tREP(i,N){\n\t\tvP pieces;\n\t\tREP(j,9){\n\t\t\tstring sides;\n\t\t\tcin>>sides;\n\t\t\tpieces.push_back(P(sides));\n\t\t}\n\t\tcout<<dfs(vvP(3,vP(3,P(\"    \"))),vi(9),0,pieces)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <cctype>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nstring rotate(string s) {\n  return s.substr(1) + string(1,s[0]);\n}\n\nbool equal(char a, char b) {\n  if (isupper(a)) {\n    return (islower(b) && toupper(b) == a);\n  } else {\n    return (isupper(b) && tolower(b) == a);\n  }\n}\n\nstring a[9];\nvector<string> v;\nint solve(int S, int nest) {\n  if (nest == 9) {\n//    cout << S << endl;\n    return 1;\n  }\n//  cout << nest << endl;\n  \n  int res = 0;\n  int sz = v.size();\n  REP(j,9) {\n    if (!((S>>j) & 1)) {\n      string s = a[j];\n      REP(i,4) {\n        if (nest == 0) {\n          v.push_back(s);\n          res += solve(S|(1<<j),nest+1);\n          v.pop_back();\n        } else if (nest == 1 || nest == 2) {\n          if (equal(v[sz-1][1], s[3])) {\n            v.push_back(s);\n            res += solve(S|(1<<j),nest+1);\n            v.pop_back();\n          }\n        } else if (nest % 3 == 0) {\n          if (equal(v[sz-3][2], s[0])) {\n            v.push_back(s);\n            res += solve(S|(1<<j),nest+1);\n            v.pop_back();\n          }\n        } else {\n          if (equal(v[sz-1][1], s[3]) && equal(v[sz-3][2], s[0])) {\n            v.push_back(s);\n            res += solve(S|(1<<j),nest+1);\n            v.pop_back();\n          }\n        }\n\n        s = rotate(s);\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  while(n--) {\n    REP(i,9)\n      cin >> a[i];\n    int res = solve(0, 0);\n    cout << res << endl;;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n;\n// Peace::elem->[0]:up,[1]:right,[2]:buttom,[3]:left\nstruct Peace{\n    char elem[4];\n    void rotate(){\n        char tmp=elem[3];\n        elem[3]=elem[2];\n        elem[2]=elem[1];\n        elem[1]=elem[0];\n        elem[0]=tmp;\n    }\n};\nPeace p[9];\nint allocated[9];\nbool selected[9];\nint cnt=0;\n\nvoid dfs(int s){\n    if(s==9){\n        cnt++;\n    }\n    else{\n        for(int i = 0; i < 9; i++){\n            if(selected[i])\n                continue;\n            selected[i]=true;\n            allocated[s]=i;\n            // ü«\n            for(int j = 0; j < 4; j++){\n                // matchµÈ¢èÄûÈçAÄAµÈ¢\n                // ¶¤ð`FbN\n                bool isl=true;\n                if(s%3!=0){\n                    if(!(abs(p[allocated[s]].elem[3]-p[allocated[s-1]].elem[1])==32))\n                        isl=false;\n                }\n                // ãð`FbN\n                bool isu=true;\n                if(s>=3){\n                    if(!(abs(p[allocated[s]].elem[0]-p[allocated[s-3]].elem[2])==32))\n                        isu=false;\n                }\n                // ÄA\n                if(isu&&isl)\n                    dfs(s+1);\n                p[i].rotate();\n            }\n            allocated[s]=-1;\n            selected[i]=false;\n        }\n    }\n}\n\nint main(){\n\n    int n;\n    cin>>n;\n    for(int i = 0; i < n; i++){\n        cnt=0;\n        for(int j = 0; j < 9; j++){\n            for(int k = 0; k < 4; k++)\n                cin>>p[j].elem[k];\n        }\n        fill(allocated,allocated+9,-1);\n        fill(selected,selected+9,false);\n        // Às\n        dfs(0);\n        cout<<cnt<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint n,dy[]={0,1},dx[]={1,0};\nstring s[10],state[10];\n// 0\n//1 3\n// 2\n\nstring rot90(string s){\n    return s[3]+s.substr(0,3);\n}\n\nint enc(char c){\n    if(c=='R')return 0;\n    if(c=='r')return 1;\n    if(c=='G')return 2;\n    if(c=='g')return 3;\n    if(c=='B')return 4;\n    if(c=='b')return 5;\n    if(c=='W')return 6;\n    if(c=='w')return 7;\n}\n\n#define id(y,x) ((y)*3+(x))\n\nint f(int y,int x,int mask){\n    if(y==3)return 1;\n    if(x==3)return f(y+1,0,mask);\n    int res=0;\n    rep(i,9)if(!(mask>>i&1)){\n        string t=s[i];\n        rep(j,4){\n            t=rot90(t);\n            if(y>0){\n                int a=enc(t[0]),b=enc(state[id(y-1,x)][2]);\n                if((a+b)%2==0 || a/2!=b/2)continue;\n            }\n            if(x>0){\n                int a=enc(t[1]),b=enc(state[id(y,x-1)][3]);\n                if((a+b)%2==0 || a/2!=b/2)continue;\n            }\n            state[id(y,x)]=t;\n            res+=f(y,x+1,mask|1<<i);\n        }\n    }\n    return res;\n}\n\nint main(){\n\tcin>>n;\n    rep(tc,n){\n        rep(i,9)cin>>s[i];\n        int used[10]={};\n        string state[10];\n        cout<<f(0,0,0)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[10][10];\nint v[10];\nchar p[10][5];\nint solve(int a){\n\tif(a==9)return 1;\n\tint ret=0;\n\tfor(int i=0;i<9;i++){\n\t\tif(!v[i]){\n\t\t\tv[i]=1;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(a%3){\n\t\t\t\t\tif((str[i][(j+3)%4]^32)!=p[a-1][1])continue;\n\t\t\t\t}\n\t\t\t\tif(a/3){\n\t\t\t\t\tif((str[i][j]^32)!=p[a-3][2])continue;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<4;k++)p[a][k]=str[i][(j+k)%4];\n\t\t\t\tret+=solve(a+1);\n\t\t\t}\n\t\t\tv[i]=0;\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tint T;scanf(\"%d\",&T);\n\twhile(T--){\n\t\tfor(int i=0;i<9;i++)scanf(\"%s\",str[i]);\n\t\tfor(int i=0;i<9;i++)v[i]=0;\n\t\tprintf(\"%d\\n\",solve(0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nint gSum = 0;\nint key[24];\n\nclass Piece{\npublic:\n\tint pos[4];\n\tPiece(){\n\t\tmemset(pos,0,sizeof(pos));\n\t}\n};\n\nbool check(int pos){\n\tif(pos == 0) return true;\n\t//012\n\t//345\n\t//678\n\n\telse if(pos==1){\n\t\treturn (key[0] + key[1]==0);\n\t}\n\n\telse if(pos==2){\n\t\treturn  (key[2] + key[3]==0);\n\t}\n\n\telse if(pos==3){\n\t\treturn (key[4] + key[7]==0);\n\t}\n\n\telse if(pos==4){\n\t\treturn ((key[5] + key[8]==0)\n\t\t&& (key[10] + key[11]==0));\n\t}\n\telse if(pos==5){\n\t\treturn ((key[6] + key[9]==0)\n\t\t\t&& (key[12] + key[13]==0));\n\t}\n\n\telse if(pos==6){\n\t\treturn (key[14] + key[17]==0);\n\t}\n\n\telse if(pos==7){\n\t\treturn ((key[15] + key[18]==0)\n\t\t\t&& (key[20] + key[21]==0));\n\t}\n\n\telse if(pos==8){\n\t\treturn ((key[16] + key[19]==0)\n\t\t\t&& (key[22] + key[23]==0));\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid dfs(int state,Piece* puzzle){\n\tif(state==9){\n\t\tgSum++;\n\t\treturn;\n\t}\n\n\tint res = 0;\n\tif(state==0){\n\t\tkey[0] = puzzle[0].pos[0];\n\t\tkey[4] = puzzle[0].pos[1];\n\t\tdfs(1,puzzle);\n\t\tkey[0] = puzzle[0].pos[1];\n\t\tkey[4] = puzzle[0].pos[2];\n\t\tdfs(1,puzzle);\n\t\tkey[0] = puzzle[0].pos[2];\n\t\tkey[4] = puzzle[0].pos[3];\n\t\tdfs(1,puzzle);\n\t\tkey[0] = puzzle[0].pos[3];\n\t\tkey[4] = puzzle[0].pos[0];\n\t\tdfs(1,puzzle);\n\t}\n\telse if(state==1){\n\t\t\n\t\tkey[2] = puzzle[1].pos[0];\n\t\tkey[5] = puzzle[1].pos[1];\n\t\tkey[1] = puzzle[1].pos[2];\n\t\tif(check(1)) dfs(2,puzzle);\n\n\t\tkey[2] = puzzle[1].pos[1];\n\t\tkey[5] = puzzle[1].pos[2];\n\t\tkey[1] = puzzle[1].pos[3];\n\t\tif(check(1)) dfs(2,puzzle);\n\n\t\tkey[2] = puzzle[1].pos[2];\n\t\tkey[5] = puzzle[1].pos[3];\n\t\tkey[1] = puzzle[1].pos[0];\n\t\tif(check(1)) dfs(2,puzzle);\n\n\t\tkey[2] = puzzle[1].pos[3];\n\t\tkey[5] = puzzle[1].pos[0];\n\t\tkey[1] = puzzle[1].pos[1];\n\t\tif(check(1)) dfs(2,puzzle);\n\t}\n\telse if(state==2){\t\n\t\tkey[6] = puzzle[2].pos[0];\n\t\tkey[3] = puzzle[2].pos[1];\n\t\tif(check(2)) dfs(3,puzzle);\n\t\tkey[6] = puzzle[2].pos[1];\n\t\tkey[3] = puzzle[2].pos[2];\n\t\tif(check(2)) dfs(3,puzzle);\n\t\tkey[6] = puzzle[2].pos[2];\n\t\tkey[3] = puzzle[2].pos[3];\n\t\tif(check(2)) dfs(3,puzzle);\n\t\tkey[6] = puzzle[2].pos[3];\n\t\tkey[3] = puzzle[2].pos[0];\n\t\tif(check(2)) dfs(3,puzzle);\n\t}\n\telse if(state==3){\n\t\tkey[7] = puzzle[3].pos[0];\n\t\tkey[10] = puzzle[3].pos[1];\n\t\tkey[14] = puzzle[3].pos[2];\n\t\tif(check(3)) dfs(4,puzzle);\n\n\t\tkey[7] = puzzle[3].pos[1];\n\t\tkey[10] = puzzle[3].pos[2];\n\t\tkey[14] = puzzle[3].pos[3];\n\t\tif(check(3)) dfs(4,puzzle);\n\n\t\tkey[7] = puzzle[3].pos[2];\n\t\tkey[10] = puzzle[3].pos[3];\n\t\tkey[14] = puzzle[3].pos[0];\n\t\tif(check(3)) dfs(4,puzzle);\n\n\t\tkey[7] = puzzle[3].pos[3];\n\t\tkey[10] = puzzle[3].pos[0];\n\t\tkey[14] = puzzle[3].pos[1];\n\t\tif(check(3)) dfs(4,puzzle);\n\t}\n\telse if(state==4){\n\t\tkey[8] = puzzle[4].pos[0];\n\t\tkey[12] = puzzle[4].pos[1];\n\t\tkey[15] = puzzle[4].pos[2];\n\t\tkey[11] = puzzle[4].pos[3];\n\t\tif(check(4)) dfs(5,puzzle);\n\n\t\tkey[8] = puzzle[4].pos[1];\n\t\tkey[12] = puzzle[4].pos[2];\n\t\tkey[15] = puzzle[4].pos[3];\n\t\tkey[11] = puzzle[4].pos[0];\n\t\tif(check(4)) dfs(5,puzzle);\n\n\t\tkey[8] = puzzle[4].pos[2];\n\t\tkey[12] = puzzle[4].pos[3];\n\t\tkey[15] = puzzle[4].pos[0];\n\t\tkey[11] = puzzle[4].pos[1];\n\t\tif(check(4)) dfs(5,puzzle);\n\n\t\tkey[8] = puzzle[4].pos[3];\n\t\tkey[12] = puzzle[4].pos[0];\n\t\tkey[15] = puzzle[4].pos[1];\n\t\tkey[11] = puzzle[4].pos[2];\n\t\tif(check(4)) dfs(5,puzzle);\n\t}\n\telse if(state==5){\n\t\tkey[16] = puzzle[5].pos[0];\n\t\tkey[13] = puzzle[5].pos[1];\n\t\tkey[9] = puzzle[5].pos[2];\n\t\tif(check(5)) dfs(6,puzzle);\n\n\t\tkey[16] = puzzle[5].pos[1];\n\t\tkey[13] = puzzle[5].pos[2];\n\t\tkey[9] = puzzle[5].pos[3];\n\t\tif(check(5)) dfs(6,puzzle);\n\n\t\tkey[16] = puzzle[5].pos[2];\n\t\tkey[13] = puzzle[5].pos[3];\n\t\tkey[9] = puzzle[5].pos[0];\n\t\tif(check(5)) dfs(6,puzzle);\n\n\t\tkey[16] = puzzle[5].pos[3];\n\t\tkey[13] = puzzle[5].pos[0];\n\t\tkey[9] = puzzle[5].pos[1];\n\t\tif(check(5)) dfs(6,puzzle);\n\t}\n\telse if(state==6){\n\t\tkey[17] = puzzle[6].pos[0];\n\t\tkey[20] = puzzle[6].pos[1];\n\t\tif(check(6)) dfs(7,puzzle);\n\n\t\tkey[17] = puzzle[6].pos[1];\n\t\tkey[20] = puzzle[6].pos[2];\n\t\tif(check(6)) dfs(7,puzzle);\n\n\t\tkey[17] = puzzle[6].pos[2];\n\t\tkey[20] = puzzle[6].pos[3];\n\t\tif(check(6)) dfs(7,puzzle);\n\n\t\tkey[17] = puzzle[6].pos[3];\n\t\tkey[20] = puzzle[6].pos[0];\n\t\tif(check(6)) dfs(7,puzzle);\n\t}\n\telse if(state==7){\n\t\tkey[21] = puzzle[7].pos[0];\n\t\tkey[18] = puzzle[7].pos[1];\n\t\tkey[22] = puzzle[7].pos[2];\n\t\tif(check(7)) dfs(8,puzzle);\t\t\n\n\t\tkey[21] = puzzle[7].pos[1];\n\t\tkey[18] = puzzle[7].pos[2];\n\t\tkey[22] = puzzle[7].pos[3];\n\t\tif(check(7)) dfs(8,puzzle);\t\n\n\t\tkey[21] = puzzle[7].pos[2];\n\t\tkey[18] = puzzle[7].pos[3];\n\t\tkey[22] = puzzle[7].pos[0];\n\t\tif(check(7)) dfs(8,puzzle);\t\n\n\t\tkey[21] = puzzle[7].pos[3];\n\t\tkey[18] = puzzle[7].pos[0];\n\t\tkey[22] = puzzle[7].pos[1];\n\t\tif(check(7)) dfs(8,puzzle);\t\n\t}\n\telse if(state==8){\n\t\tkey[23] = puzzle[8].pos[0];\n\t\tkey[19] = puzzle[8].pos[1];\n\t\tif(check(8)) dfs(9,puzzle);\t\n\n\t\tkey[23] = puzzle[8].pos[1];\n\t\tkey[19] = puzzle[8].pos[2];\n\t\tif(check(8)) dfs(9,puzzle);\t\n\n\t\tkey[23] = puzzle[8].pos[2];\n\t\tkey[19] = puzzle[8].pos[3];\n\t\tif(check(8)) dfs(9,puzzle);\t\n\n\t\tkey[23] = puzzle[8].pos[3];\n\t\tkey[19] = puzzle[8].pos[0];\n\t\tif(check(8)) dfs(9,puzzle);\t\n\t}\n}\n\nchar table[256];\n\nint main(){\n\tint n;\n\n\ttable['r'] = 1;\n\ttable['g'] = 2;\n\ttable['b'] = 3;\n\ttable['w'] = 4;\n\ttable['R'] = -1;\n\ttable['G'] = -2;\n\ttable['B'] = -3;\n\ttable['W'] = -4;\n\n\twhile(~scanf(\"%d\",&n)){\n\t\tfor(int i=0;i<n;i++){\n\n\t\t\tPiece puzzle[9];\n\t\t\tfor(int j=0;j<9;j++){\n\t\t\t\tstring str;\n\t\t\t\tcin >> str;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tpuzzle[j].pos[k] = table[str[k]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint patterns[] = {0,1,2,3,4,5,6,7,8};\n\n\t\t\tint res = 0;\n\t\t\tgSum = 0;\n\n\t\t\tdo{\n\t\t\t\tPiece tmp[9];\n\t\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\t\ttmp[i] = puzzle[patterns[i]];\n\t\t\t\t}\n\t\t\t\tdfs(0,tmp);\n\t\t\t}while(next_permutation(patterns,patterns+9));\n\n\t\t\tprintf(\"%d\\n\",gSum);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int MAX = 36;\nconst int F = 5;\n\nint n,ans,t[F][F][F-1];\nbool used[MAX];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nstring pz[MAX],str;\n\nvoid init(){\n    fill(used,used+MAX,false);\n    for(int i = 0 ; i < F ; i++)\n        for(int j = 0 ; j < F ; j++)\n            for(int k = 0 ; k < F-1 ; k++)\n                t[i][j][k] = '0';\n}\n\nbool judge(char a,char b){\n    int c = 'A' - 'a';\n    if(a + c == b||b + c == a||a == '0'\n       ||b == '0') return true;\n    return false;\n}\n\nvoid dfs(int y,int x){\n    if(y == 4 &&x == 1){\n        ++ans;\n        return;\n    }\n    for(int i = 0 ; i < MAX ; i++){\n        if(used[i]) continue;\n        int cnt = 0;\n        \n        for(int j = 0 ; j < F-1 ; j++){\n            t[y][x][j] = pz[i][j];\n        }\n        for(int j = 0 ; j < F-1 ; j++){\n            int nx = x + dx[j];\n            int ny = y + dy[j];\n            if(judge(t[ny][nx][(j+2)%4],t[y][x][j])) cnt++;\n        }\n        if(cnt == 4){\n            int ii = i/4*4;\n            used[ii] = used[ii+1] = used[ii+2] = used[ii+3] = true;\n            dfs(y + (x == 3),x + 1 - 3*(x+1 > 3));\n            used[ii] = used[ii+1] = used[ii+2] = used[ii+3] = false;\n        }\n        for(int j = 0 ; j < F-1 ; j++){\n            t[y][x][j] = '0';\n        }\n    }\n}\n\nint main(){\n    cin >> n;\n    while(n--){\n        init();\n        for(int i = 0 ; i < MAX/4 ; i++){\n            cin >> str;\n            for(int j = 0 ; j < F-1 ; j++) pz[i*4][j] = str[j];\n            for(int j = 1 ; j < F-1 ; j++){\n                for(int k = j ; k < j+F-1 ; k++){\n                    pz[i*4+j][k-j] = str[k%4];\n                }\n            }\n        }\n        ans = 0;\n        dfs(1,1);\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nchar pie[9][4], dat[3][3][4];\nbool used[9];\nint ans, T;\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nvoid rec(int y, int x){\n  //cout << y << ' ' << x << endl;\n  if(y == 3){ ans++; return; }\n  for(int i=0;i<9;i++){\n    if(used[i]) continue;\n    used[i] = true;\n    for(int j=0;j<4;j++){\n      for(int k=0;k<4;k++) dat[y][x][k] = pie[i][(j+k)%4];\n      bool f = true;\n      for(int k=0;k<4;k++){\n        int ny = y + dy[k];\n        int nx = x + dx[k];\n        if(min(ny, nx) < 0 || max(ny, nx) >= 3) continue;\n        char nc = dat[ny][nx][(k+2)%4];\n        char c = dat[y][x][k];\n        //cout << i << ' ' << j << ' ' << k << endl;\n        //cout << c << ' ' << nc << endl;\n        if('a' <= c && c <= 'z'){\n          if(!(nc == 'A' + (c - 'a') || nc == '@')) f = false;\n        }else if('A' <= c && c <= 'Z'){\n          if(!(nc == 'a' + (c - 'A') || nc == '@')) f = false;\n        }\n      }\n      if(f) rec((y*3+x+1)/3, (y*3+x+1)%3);\n      for(int k=0;k<4;k++) dat[y][x][k] = '@';\n    }\n    used[i] = false;\n  }\n}\n\nmain(){\n  cin >> T;\n  while(T--){\n    for(int i=0;i<9;i++) for(int j=0;j<4;j++) cin >> pie[i][j];\n    ans = 0;\n    fill(dat[0][0], dat[3][0], '@');\n    fill(used, used+9, false);\n    rec(0, 0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum Loc{\n\tTop,\n\tRight,\n\tUnder,\n\tLeft,\n};\n\nenum Roll{\n\tr_0,\n\tr_90,\n\tr_180,\n\tr_270,\n};\n\nRoll roll_type[4] = {r_0,r_90,r_180,r_270};\n\nstruct Data{\n\tint data_id;\n\tRoll roll;\n};\n\nstruct Info{\n\tint next_loc;\n\tbool check[9];\n\tData table[3][3];\n};\n\nvoid copyInfo(Info from,Info& to){\n\tfor(int i = 0; i < 9; i++)to.check[i] = from.check[i];\n\tfor(int i = 0; i < 3; i++){\n\t\tfor(int k = 0; k < 3; k++){\n\t\t\tto.table[i][k].data_id = from.table[i][k].data_id;\n\t\t\tto.table[i][k].roll = from.table[i][k].roll;\n\t\t}\n\t}\n}\n\nint N,ans;\nchar data[9][4];\n\nbool isMatch(char left,char right){\n\n\tif(left > right){\n\t\tswap(left,right);\n\t}\n\n\tif(left == 'R' && right == 'r'){\n\t\treturn true;\n\t}else if(left == 'G' && right == 'g'){\n\t\treturn true;\n\t}else if(left == 'B' && right == 'b'){\n\t\treturn true;\n\t}else if(left == 'W' && right == 'w'){\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nchar getWord(int data_id,Roll roll,Loc loc){\n\n\tswitch(roll){\n\tcase r_0:\n\t\tswitch(loc){\n\t\tcase Top:\n\t\t\treturn data[data_id][Top];\n\t\tcase Right:\n\t\t\treturn data[data_id][Right];\n\t\tcase Under:\n\t\t\treturn data[data_id][Under];\n\t\tcase Left:\n\t\t\treturn data[data_id][Left];\n\t\t}\n\t\tbreak;\n\tcase r_90:\n\t\tswitch(loc){\n\t\tcase Top:\n\t\t\treturn data[data_id][Left];\n\t\tcase Right:\n\t\t\treturn data[data_id][Top];\n\t\tcase Under:\n\t\t\treturn data[data_id][Right];\n\t\tcase Left:\n\t\t\treturn data[data_id][Under];\n\t\t}\n\t\tbreak;\n\tcase r_180:\n\t\tswitch(loc){\n\t\tcase Top:\n\t\t\treturn data[data_id][Under];\n\t\tcase Right:\n\t\t\treturn data[data_id][Left];\n\t\tcase Under:\n\t\t\treturn data[data_id][Top];\n\t\tcase Left:\n\t\t\treturn data[data_id][Right];\n\t\t}\n\t\tbreak;\n\tcase r_270:\n\t\tswitch(loc){\n\t\tcase Top:\n\t\t\treturn data[data_id][Right];\n\t\tcase Right:\n\t\t\treturn data[data_id][Under];\n\t\tcase Under:\n\t\t\treturn data[data_id][Left];\n\t\tcase Left:\n\t\t\treturn data[data_id][Top];\n\t\t}\n\t\tbreak;\n\t}\n\treturn 'X'; //must not reach here\n}\n\n\nvoid recursive(Info info){\n\n\tif(info.next_loc == 9){\n\t\tans++;\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < 9; i++){\n\t\tif(info.check[i] == false){\n\n\t\t\tswitch(info.next_loc){\n\t\t\tcase 1:\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif(isMatch(data[info.table[1][1].data_id][Top],getWord(i,roll_type[k],Under))){\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tcopyInfo(info,new_info);\n\t\t\t\t\t\tnew_info.check[i] = true;\n\t\t\t\t\t\tnew_info.table[0][1].data_id = i;\n\t\t\t\t\t\tnew_info.table[0][1].roll = roll_type[k];\n\t\t\t\t\t\tnew_info.next_loc = info.next_loc+1;\n\t\t\t\t\t\trecursive(new_info);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif(isMatch(data[info.table[1][1].data_id][Right],getWord(i,roll_type[k],Left))){\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tcopyInfo(info,new_info);\n\t\t\t\t\t\tnew_info.check[i] = true;\n\t\t\t\t\t\tnew_info.table[1][2].data_id = i;\n\t\t\t\t\t\tnew_info.table[1][2].roll = roll_type[k];\n\t\t\t\t\t\tnew_info.next_loc = info.next_loc+1;\n\t\t\t\t\t\trecursive(new_info);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif(isMatch(data[info.table[1][1].data_id][Under],getWord(i,roll_type[k],Top))){\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tcopyInfo(info,new_info);\n\t\t\t\t\t\tnew_info.check[i] = true;\n\t\t\t\t\t\tnew_info.table[2][1].data_id = i;\n\t\t\t\t\t\tnew_info.table[2][1].roll = roll_type[k];\n\t\t\t\t\t\tnew_info.next_loc = info.next_loc+1;\n\t\t\t\t\t\trecursive(new_info);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif(isMatch(data[info.table[1][1].data_id][Left],getWord(i,roll_type[k],Right))){\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tcopyInfo(info,new_info);\n\t\t\t\t\t\tnew_info.check[i] = true;\n\t\t\t\t\t\tnew_info.table[1][0].data_id = i;\n\t\t\t\t\t\tnew_info.table[1][0].roll = roll_type[k];\n\t\t\t\t\t\tnew_info.next_loc = info.next_loc+1;\n\t\t\t\t\t\trecursive(new_info);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif(isMatch(getWord(info.table[0][1].data_id,info.table[0][1].roll,Right),getWord(i,roll_type[k],Left)) == true &&\n\t\t\t\t\t\t\tisMatch(getWord(info.table[1][2].data_id,info.table[1][2].roll,Top),getWord(i,roll_type[k],Under)) == true){\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tcopyInfo(info,new_info);\n\t\t\t\t\t\tnew_info.check[i] = true;\n\t\t\t\t\t\tnew_info.table[0][2].data_id = i;\n\t\t\t\t\t\tnew_info.table[0][2].roll = roll_type[k];\n\t\t\t\t\t\tnew_info.next_loc = info.next_loc+1;\n\t\t\t\t\t\trecursive(new_info);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif(isMatch(getWord(info.table[1][2].data_id,info.table[1][2].roll,Under),getWord(i,roll_type[k],Top)) == true &&\n\t\t\t\t\t\t\tisMatch(getWord(info.table[2][1].data_id,info.table[2][1].roll,Right),getWord(i,roll_type[k],Left)) == true){\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tcopyInfo(info,new_info);\n\t\t\t\t\t\tnew_info.check[i] = true;\n\t\t\t\t\t\tnew_info.table[2][2].data_id = i;\n\t\t\t\t\t\tnew_info.table[2][2].roll = roll_type[k];\n\t\t\t\t\t\tnew_info.next_loc = info.next_loc+1;\n\t\t\t\t\t\trecursive(new_info);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif(isMatch(getWord(info.table[2][1].data_id,info.table[2][1].roll,Left),getWord(i,roll_type[k],Right)) == true &&\n\t\t\t\t\t\t\tisMatch(getWord(info.table[1][0].data_id,info.table[1][0].roll,Under),getWord(i,roll_type[k],Top)) == true){\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tcopyInfo(info,new_info);\n\t\t\t\t\t\tnew_info.check[i] = true;\n\t\t\t\t\t\tnew_info.table[2][0].data_id = i;\n\t\t\t\t\t\tnew_info.table[2][0].roll = roll_type[k];\n\t\t\t\t\t\tnew_info.next_loc = info.next_loc+1;\n\t\t\t\t\t\trecursive(new_info);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif(isMatch(getWord(info.table[1][0].data_id,info.table[1][0].roll,Top),getWord(i,roll_type[k],Under)) == true &&\n\t\t\t\t\t\t\tisMatch(getWord(info.table[0][1].data_id,info.table[0][1].roll,Left),getWord(i,roll_type[k],Right)) == true){\n\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\tcopyInfo(info,new_info);\n\t\t\t\t\t\tnew_info.check[i] = true;\n\t\t\t\t\t\tnew_info.table[0][0].data_id = i;\n\t\t\t\t\t\tnew_info.table[0][0].roll = roll_type[k];\n\t\t\t\t\t\tnew_info.next_loc = info.next_loc+1;\n\t\t\t\t\t\trecursive(new_info);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nvoid func(){\n\n\tans = 0;\n\n\tchar buf[5];\n\n\tfor(int i = 0; i < 9; i++){\n\t\tscanf(\"%s\",buf);\n\n\t\tfor(int k = 0; k < 4; k++){\n\t\t\tdata[i][k] = buf[k];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 9; i++){\n\t\tInfo info;\n\t\tfor(int k = 0; k < 9; k++)info.check[k] = false;\n\t\tinfo.table[1][1].data_id = i;\n\t\tinfo.table[1][1].roll = r_0;\n\t\tinfo.check[i] = true;\n\t\tinfo.next_loc = 1;\n\t\trecursive(info);\n\t}\n\n\tprintf(\"%d\\n\",ans*4);\n}\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\tfor(int i = 0; i < N; i++){\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nint gSum = 0;\nint key[24];\n\nclass Piece{\npublic:\n\tchar pos[4];\n\tPiece(){\n\t\tmemset(pos,0,sizeof(pos));\n\t}\n};\n\nbool check(int pos){\n\tif(pos == 0) return true;\n\t//012\n\t//345\n\t//678\n\n\telse if(pos==1){\n\t\treturn (key[0] + key[1]==0);\n\t}\n\n\telse if(pos==2){\n\t\treturn  (key[2] + key[3]==0);\n\t}\n\n\telse if(pos==3){\n\t\treturn (key[4] + key[7]==0);\n\t}\n\n\telse if(pos==4){\n\t\treturn ((key[5] + key[8]==0)\n\t\t&& (key[10] + key[11]==0));\n\t}\n\telse if(pos==5){\n\t\treturn ((key[6] + key[9]==0)\n\t\t\t&& (key[12] + key[13]==0));\n\t}\n\n\telse if(pos==6){\n\t\treturn (key[14] + key[17]==0);\n\t}\n\n\telse if(pos==7){\n\t\treturn ((key[15] + key[18]==0)\n\t\t\t&& (key[20] + key[21]==0));\n\t}\n\n\telse if(pos==8){\n\t\treturn ((key[16] + key[19]==0)\n\t\t\t&& (key[22] + key[23]==0));\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid dfs(int state,Piece* puzzle,char* pat){\n\tif(state==9){\n\t\tgSum++;\n\t\treturn;\n\t}\n\n\tint res = 0;\n\tif(state==0){\n\t\tkey[0] = puzzle[pat[0]].pos[0];\n\t\tkey[4] = puzzle[pat[0]].pos[1];\n\t\tdfs(1,puzzle,pat);\n\t\tkey[0] = puzzle[pat[0]].pos[1];\n\t\tkey[4] = puzzle[pat[0]].pos[2];\n\t\tdfs(1,puzzle,pat);\n\t\tkey[0] = puzzle[pat[0]].pos[2];\n\t\tkey[4] = puzzle[pat[0]].pos[3];\n\t\tdfs(1,puzzle,pat);\n\t\tkey[0] = puzzle[pat[0]].pos[3];\n\t\tkey[4] = puzzle[pat[0]].pos[0];\n\t\tdfs(1,puzzle,pat);\n\t}\n\telse if(state==1){\n\t\t\n\t\tkey[2] = puzzle[pat[1]].pos[0];\n\t\tkey[5] = puzzle[pat[1]].pos[1];\n\t\tkey[1] = puzzle[pat[1]].pos[2];\n\t\tif(check(1)) dfs(2,puzzle,pat);\n\n\t\tkey[2] = puzzle[pat[1]].pos[1];\n\t\tkey[5] = puzzle[pat[1]].pos[2];\n\t\tkey[1] = puzzle[pat[1]].pos[3];\n\t\tif(check(1)) dfs(2,puzzle,pat);\n\n\t\tkey[2] = puzzle[pat[1]].pos[2];\n\t\tkey[5] = puzzle[pat[1]].pos[3];\n\t\tkey[1] = puzzle[pat[1]].pos[0];\n\t\tif(check(1)) dfs(2,puzzle,pat);\n\n\t\tkey[2] = puzzle[pat[1]].pos[3];\n\t\tkey[5] = puzzle[pat[1]].pos[0];\n\t\tkey[1] = puzzle[pat[1]].pos[1];\n\t\tif(check(1)) dfs(2,puzzle,pat);\n\t}\n\telse if(state==2){\t\n\t\tkey[6] = puzzle[pat[2]].pos[0];\n\t\tkey[3] = puzzle[pat[2]].pos[1];\n\t\tif(check(2)) dfs(3,puzzle,pat);\n\t\tkey[6] = puzzle[pat[2]].pos[1];\n\t\tkey[3] = puzzle[pat[2]].pos[2];\n\t\tif(check(2)) dfs(3,puzzle,pat);\n\t\tkey[6] = puzzle[pat[2]].pos[2];\n\t\tkey[3] = puzzle[pat[2]].pos[3];\n\t\tif(check(2)) dfs(3,puzzle,pat);\n\t\tkey[6] = puzzle[pat[2]].pos[3];\n\t\tkey[3] = puzzle[pat[2]].pos[0];\n\t\tif(check(2)) dfs(3,puzzle,pat);\n\t}\n\telse if(state==3){\n\t\tkey[7] = puzzle[pat[3]].pos[0];\n\t\tkey[10] = puzzle[pat[3]].pos[1];\n\t\tkey[14] = puzzle[pat[3]].pos[2];\n\t\tif(check(3)) dfs(4,puzzle,pat);\n\n\t\tkey[7] = puzzle[pat[3]].pos[1];\n\t\tkey[10] = puzzle[pat[3]].pos[2];\n\t\tkey[14] = puzzle[pat[3]].pos[3];\n\t\tif(check(3)) dfs(4,puzzle,pat);\n\n\t\tkey[7] = puzzle[pat[3]].pos[2];\n\t\tkey[10] = puzzle[pat[3]].pos[3];\n\t\tkey[14] = puzzle[pat[3]].pos[0];\n\t\tif(check(3)) dfs(pat[3],puzzle,pat);\n\n\t\tkey[7] = puzzle[pat[3]].pos[3];\n\t\tkey[10] = puzzle[pat[3]].pos[0];\n\t\tkey[14] = puzzle[pat[3]].pos[1];\n\t\tif(check(3)) dfs(4,puzzle,pat);\n\t}\n\telse if(state==4){\n\t\tkey[8] = puzzle[pat[4]].pos[0];\n\t\tkey[12] = puzzle[pat[4]].pos[1];\n\t\tkey[15] = puzzle[pat[4]].pos[2];\n\t\tkey[11] = puzzle[pat[4]].pos[3];\n\t\tif(check(4)) dfs(5,puzzle,pat);\n\n\t\tkey[8] = puzzle[pat[4]].pos[1];\n\t\tkey[12] = puzzle[pat[4]].pos[2];\n\t\tkey[15] = puzzle[pat[4]].pos[3];\n\t\tkey[11] = puzzle[pat[4]].pos[0];\n\t\tif(check(4)) dfs(5,puzzle,pat);\n\n\t\tkey[8] = puzzle[pat[4]].pos[2];\n\t\tkey[12] = puzzle[pat[4]].pos[3];\n\t\tkey[15] = puzzle[pat[4]].pos[0];\n\t\tkey[11] = puzzle[pat[4]].pos[1];\n\t\tif(check(4)) dfs(5,puzzle,pat);\n\n\t\tkey[8] = puzzle[pat[4]].pos[3];\n\t\tkey[12] = puzzle[pat[4]].pos[0];\n\t\tkey[15] = puzzle[pat[4]].pos[1];\n\t\tkey[11] = puzzle[pat[4]].pos[2];\n\t\tif(check(4)) dfs(5,puzzle,pat);\n\t}\n\telse if(state==5){\n\t\tkey[16] = puzzle[pat[5]].pos[0];\n\t\tkey[13] = puzzle[pat[5]].pos[1];\n\t\tkey[9] = puzzle[pat[5]].pos[2];\n\t\tif(check(5)) dfs(6,puzzle,pat);\n\n\t\tkey[16] = puzzle[pat[5]].pos[1];\n\t\tkey[13] = puzzle[pat[5]].pos[2];\n\t\tkey[9] = puzzle[pat[5]].pos[3];\n\t\tif(check(5)) dfs(6,puzzle,pat);\n\n\t\tkey[16] = puzzle[pat[5]].pos[2];\n\t\tkey[13] = puzzle[pat[5]].pos[3];\n\t\tkey[9] = puzzle[pat[5]].pos[0];\n\t\tif(check(5)) dfs(6,puzzle,pat);\n\n\t\tkey[16] = puzzle[pat[5]].pos[3];\n\t\tkey[13] = puzzle[pat[5]].pos[0];\n\t\tkey[9] = puzzle[pat[5]].pos[1];\n\t\tif(check(5)) dfs(6,puzzle,pat);\n\t}\n\telse if(state==6){\n\t\tkey[17] = puzzle[pat[6]].pos[0];\n\t\tkey[20] = puzzle[pat[6]].pos[1];\n\t\tif(check(6)) dfs(7,puzzle,pat);\n\n\t\tkey[17] = puzzle[pat[6]].pos[1];\n\t\tkey[20] = puzzle[pat[6]].pos[2];\n\t\tif(check(6)) dfs(7,puzzle,pat);\n\n\t\tkey[17] = puzzle[pat[6]].pos[2];\n\t\tkey[20] = puzzle[pat[6]].pos[3];\n\t\tif(check(6)) dfs(7,puzzle,pat);\n\n\t\tkey[17] = puzzle[pat[6]].pos[3];\n\t\tkey[20] = puzzle[pat[6]].pos[0];\n\t\tif(check(6)) dfs(7,puzzle,pat);\n\t}\n\telse if(state==7){\n\t\tkey[21] = puzzle[pat[7]].pos[0];\n\t\tkey[18] = puzzle[pat[7]].pos[1];\n\t\tkey[22] = puzzle[pat[7]].pos[2];\n\t\tif(check(7)) dfs(8,puzzle,pat);\t\t\n\n\t\tkey[21] = puzzle[pat[7]].pos[1];\n\t\tkey[18] = puzzle[pat[7]].pos[2];\n\t\tkey[22] = puzzle[pat[7]].pos[3];\n\t\tif(check(7)) dfs(8,puzzle,pat);\t\n\n\t\tkey[21] = puzzle[pat[7]].pos[2];\n\t\tkey[18] = puzzle[pat[7]].pos[3];\n\t\tkey[22] = puzzle[pat[7]].pos[0];\n\t\tif(check(7)) dfs(8,puzzle,pat);\t\n\n\t\tkey[21] = puzzle[pat[7]].pos[3];\n\t\tkey[18] = puzzle[pat[7]].pos[0];\n\t\tkey[22] = puzzle[pat[7]].pos[1];\n\t\tif(check(7)) dfs(8,puzzle,pat);\t\n\t}\n\telse if(state==8){\n\t\tkey[23] = puzzle[pat[8]].pos[0];\n\t\tkey[19] = puzzle[pat[8]].pos[1];\n\t\tif(check(8)) dfs(9,puzzle,pat);\t\n\n\t\tkey[23] = puzzle[pat[8]].pos[1];\n\t\tkey[19] = puzzle[pat[8]].pos[2];\n\t\tif(check(8)) dfs(9,puzzle,pat);\t\n\n\t\tkey[23] = puzzle[pat[8]].pos[2];\n\t\tkey[19] = puzzle[pat[8]].pos[3];\n\t\tif(check(8)) dfs(9,puzzle,pat);\t\n\n\t\tkey[23] = puzzle[pat[8]].pos[3];\n\t\tkey[19] = puzzle[pat[8]].pos[0];\n\t\tif(check(8)) dfs(9,puzzle,pat);\t\n\t}\n}\n\nchar table[256];\n\nint main(){\n\tint n;\n\n\ttable['r'] = 1;\n\ttable['g'] = 2;\n\ttable['b'] = 3;\n\ttable['w'] = 4;\n\ttable['R'] = -1;\n\ttable['G'] = -2;\n\ttable['B'] = -3;\n\ttable['W'] = -4;\n\n\twhile(~scanf(\"%d\",&n)){\n\t\tfor(int i=0;i<n;i++){\n\n\t\t\tPiece puzzle[9];\n\t\t\tfor(int j=0;j<9;j++){\n\t\t\t\tstring str;\n\t\t\t\tcin >> str;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tpuzzle[j].pos[k] = table[str[k]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchar pat[] = {0,1,2,3,4,5,6,7,8};\n\n\t\t\tint res = 0;\n\t\t\tgSum = 0;\n\n\t\t\tdo{\n\t\t\t\tdfs(0,puzzle,pat);\n\t\t\t}while(next_permutation(pat,pat+9));\n\n\t\t\tprintf(\"%d\\n\",gSum);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nchar grid[5][5][4];\nchar puzzles[9][7];\nbool mask[5][5]={\n    {1,1,1,1,1},\n    {1,0,0,0,1},\n    {1,0,0,0,1},\n    {1,0,0,0,1},\n    {1,1,1,1,1}\n};\n\nconst int diff=abs('A'-'a');\n\nint solve(int pos,int comb){\n    // printf(\"pos=%d\\n\",pos);\n    if (pos>=9) return 1;\n    int x=pos%3+1,y=pos/3+1;\n    int ret=0;\n\n    //全てのパズルを試す\n    for(int pid=0;pid<9;pid++){\n        if ((1<<pid)&comb) continue;\n        // printf(\"pid=%d\\n\",pid);\n        const auto &pz=puzzles[pid];\n\n        //パズルを回す\n        for(int r=0;r<4;r++){\n            if (!mask[x-1][y]&&abs(grid[x-1][y][2]-pz[r])!=diff) continue;\n            if (!mask[x][y-1]&&abs(grid[x][y-1][3]-pz[(r+1)%4])!=diff) continue;\n            // puts(\"rot\");\n            for(int i=0;i<4;i++) grid[x][y][i]=pz[(r+i)%4];\n            ret+=solve(pos+1,comb|(1<<pid));\n        }\n\n    }\n\n    return ret;\n}\n\nint main(){\n\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        for(int i=0;i<9;i++) scanf(\"%5s\",puzzles+i);\n        // for(int i=0;i<9;i++) printf(\"%s\\n\",puzzles+i);\n        printf(\"%d\\n\",solve(0,0));\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <algorithm>\n#include <bitset>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <set>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nint result = 0;\nchar Map[9][4];\nbool check[9];\nint t_map[3][3];\nint alf[256];\n// 0 1 2\n// 3 4 5\n// 6 7 8\nvoid rotate(int num){\n    char c = Map[num][0];\n    for(int i = 0;i < 3;i++){\n        Map[num][i] = Map[num][i+1];\n    }\n    Map[num][3] = c;\n}\n\nvoid dfs(int num){\n    if(num == 9)result++;\n    else{\n        for(int i = 0;i < 9;i++){\n            if(check[i])continue;\n            check[i] = true;\n            t_map[num/3][num%3] = i;\n            for(int j = 0;j < 4;j++){\n                if(num / 3 > 0 && num % 3 > 0){\n                    if(alf[Map[t_map[num/3][num%3]][1]] == -alf[Map[t_map[num/3][(num%3)-1]][3]]\n                       && alf[Map[t_map[num/3][num%3]][0]] == -alf[Map[t_map[(num/3)-1][num%3]][2]])dfs(num+1);\n                }else if(num / 3 > 0){\n                    if(alf[Map[t_map[num/3][num%3]][0]] == -alf[Map[t_map[(num/3)-1][num%3]][2]])dfs(num+1);\n                }else if(num % 3 > 0){\n                    if(alf[Map[t_map[num/3][num%3]][1]] == -alf[Map[t_map[num/3][(num%3)-1]][3]])dfs(num+1);\n                }else{\n                    dfs(num+1);\n                }\n                rotate(i);\n            }\n            check[i] = false;\n        }\n    }\n}\n\nint main(){\n    alf['r'] = 1;alf['g'] = 2; alf['b'] = 3;alf['w'] = 4;\n    alf['R'] = -1;alf['G'] = -2; alf['B'] = -3;alf['W'] = -4;\n    int n;string str;\n    cin >> n;\n    for(int i = 0;i < n;i++){\n        for(int j = 0;j < 9;j++){\n            cin >> str;\n            for(int k = 0;k < 4;k++){\n                Map[j][k] = str[k];\n            }\n        }\n        result = 0;\n        dfs(0);\n        cout << result << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nstring puzzle[9];\nint pl2id[9], pl2rot[9];\n\nbool check(char a, char b) {\n  return toupper(a) == toupper(b) && a != b;\n}\n\nint dfs(int k, bool *used) {\n  if(k == 9) return 1;\n  \n  int ret = 0;\n  for(int id=0; id<9; id++) {\n    if(used[id]) continue;\n\n    for(int rot=0; rot<4; rot++) {\n      // 0: left 1: up 2: right 3: down\n      bool ok = true;\n      // テ、ツクツ甘」ツ?ィテ、ツクツ?ィツ?エ\n      if(k > 2) ok &= check(puzzle[id][(rot+1)%4], puzzle[pl2id[k-3]][(pl2rot[k-3]+3)%4]);\n      // テ・ツキツヲテ」ツ?ィテ、ツクツ?ィツ?エ\n      if(k % 3) ok &= check(puzzle[id][rot], puzzle[pl2id[k-1]][(pl2rot[k-1]+2)%4]);\n      \n      if(ok) {\n\tpl2id[k] = id;\n\tpl2rot[k] = rot;\n\tused[id] = true;\n\tret += dfs(k+1, used);\n\tused[id] = false;\n      }\n    }\n  }\n  \n  return ret;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  while(n--) {\n    for(int i=0; i<9; i++) {\n      cin >> puzzle[i];\n    }\n    \n    bool used[9] = {};\n    cout << dfs(0, used) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cctype>\n\nusing namespace std;\n\nconst int MAX = 9;\nconst int TOP = 0;\nconst int RIGHT = 1;\nconst int BOTTOM = 2;\nconst int LEFT = 3;\n\nbool used[MAX];\nstring puz[MAX];\nstring tmp[MAX];\nint ans;\n\nvoid rotate(int n){\n  string s = \"\";\n  s = puz[n].substr(1);\n  s += puz[n][0];\n  puz[n] = s;\n}\n\nbool able(int n){\n  //top\n  if(n >= 3){\n    char c1 = tmp[n-3][BOTTOM];\n    char c2 = tmp[n][TOP];\n    if(c1 == c2 || tolower(c1) != tolower(c2)) return false;\n  }\n\n  //left\n  if(n % 3){\n    char c1 = tmp[n-1][RIGHT];\n    char c2 = tmp[n][LEFT];\n    if(c1 == c2 || tolower(c1) != tolower(c2)) return false;\n  }\n  return true;\n}\n\nvoid solve(int n){\n  //  cout << n << endl;\n  if(n == 9){\n    ans++;\n    return;\n  }\n\n  for(int i = 0; i < 9; i++){\n    if(used[i]) continue;\n    \n    for(int j = 0; j < 4; j++){\n      rotate(i);\n      tmp[n] = puz[i];\n      used[i] = true;\n      if(able(n)) solve(n+1);\n      used[i] = false;\n    }\n  }\n}\n\nint main(){\n\n  int n;\n  cin >> n;\n  while(n--){\n    for(int i = 0; i < 9; i++) cin >> puz[i];\n    ans = 0;\n    solve(0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar p[3][3][4];\nchar pz[9][5];\n\nbool check(char a,char b){\n    return (a-32 == b || b-32 == a);\n}\n\nint rec(int now,int S){\n    if(now == 9) return 1;\n    int res = 0;\n    int X = now%3, Y = now/3;\n    for(int s = 0 ; s < 9 ; s++){\n        if(S >> s & 1) continue;\n        for(int i = 0 ; i < 4 ; i++){\n            for(int j = 0 ; j < 4 ; j++){\n                p[Y][X][j] = pz[s][(i+j)%4];\n            }\n            bool can = true;    \n            if(X > 0 && !check(p[Y][X][0],p[Y][X-1][2])){\n                can = false;\n            }\n            if(Y > 0 && !check(p[Y][X][1],p[Y-1][X][3])){\n                can = false;            \n            }\n            if(can) res += rec(now+1,S|(1<<s));\n        }\n    }\n    return res;\n}\n\nint main(){\n    int Tc;\n    cin >> Tc;\n    while(Tc--){\n        for(int i = 0 ; i < 9 ; i++){\n            for(int j = 0 ; j < 4 ; j++){\n                cin >> pz[i][j];\n            }\n        }\n        cout << rec(0,0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar p[3][3][4];\nchar pz[9][5];\n\nbool check(char a,char b){\n    return (a-32 == b || b-32 == a);\n}\n\nint rec(int now,int S){\n    if(now == 9) return 1;\n    int res = 0;\n    int X = now%3, Y = now/3;\n    for(int s = 0 ; s < 9 ; s++){\n        if(S >> s & 1) continue;\n        for(int i = 0 ; i < 4 ; i++){\n            for(int j = 0 ; j < 4 ; j++){\n                p[Y][X][j] = pz[s][(i+j)%4];\n            }\n            bool can = true;    \n            if(X > 0 && !check(p[Y][X][0],p[Y][X-1][2])){\n                can = false;\n            }\n            if(Y > 0 && !check(p[Y][X][1],p[Y-1][X][3])){\n                can = false;            \n            }\n            if(can) res += rec(now+1,S|(1<<s));\n            for(int j = 0 ; j < 4 ; j++){\n                p[Y][X][j] = '#';\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    int Tc;\n    cin >> Tc;\n    while(Tc--){\n        for(int i = 0 ; i < 9 ; i++){\n            for(int j = 0 ; j < 4 ; j++){\n                cin >> pz[i][j];\n            }\n        }\n        for(int i = 0 ; i < 3 ; i++){\n            for(int j = 0 ; j < 3 ; j++){\n                for(int k = 0 ; k < 4 ; k++){\n                    p[i][j][k] = '#';\n                }\n            }\n        }\n        cout << rec(0,0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nstring s[9], t[3][3];\nint dx[]{ -1,0,1,0 }, dy[]{ 0,1,0,-1 };\nint dfs(int p) {\n\tif (p == 9)return 1;\n\tint res = 0;\n\trep(i, 3)rep(j, 3) {\n\t\tif (t[i][j] != \"\")continue;\n\t\trep(k, 4) {\n\t\t\trep(l, 4) {\n\t\t\t\tint nx = i + dx[l], ny = j + dy[l];\n\t\t\t\tif (nx < 0 || 3 <= nx || ny < 0 || 3 <= ny || t[nx][ny] == \"\")continue;\n\t\t\t\tchar c = t[nx][ny][(l + 2) % 4];\n\t\t\t\tif (isupper(s[p][(l + k) % 4])) {\n\t\t\t\t\tif (isupper(c) || toupper(c) != s[p][(l + k) % 4])goto g;\n\t\t\t\t}\n\t\t\t\telse if (islower(c) || tolower(c) != s[p][(l + k) % 4])goto g;\n\t\t\t}\n\t\t\trep(l, 4)t[i][j] += s[p][(l + k) % 4];\n\t\t\tres += dfs(p + 1); t[i][j] = \"\"; g:;\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n) {\n\t\trep(j, 9)cin >> s[j];\n\t\tprintf(\"%d\\n\", dfs(0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n#define rep1(a,b,n) for(int a = b ; a < n ; a++)\nconst int MAX = 36;\nconst int F = 5;\n\nint n,ans,t[F][F][F-1];\nbool used[MAX];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nstring pz[MAX],str;\n\nvoid init(){\n    str.clear();\n    fill(used,used+MAX,false);\n    rep(i,F)\n        rep(j,F)\n            rep(k,F-1)\n                t[i][j][k] = '0';\n}\n\nbool judge(char a,char b){\n    int c = 'A' - 'a';\n    if(a + c == b||b + c == a||a == '0'\n       ||b == '0') return true;\n    return false;\n}\n\nvoid dfs(int y,int x){\n    if(y == 4 &&x == 1){\n        ++ans;\n        return;\n    }\n    rep(i,MAX){\n        if(used[i]) continue;\n        int cnt = 0;\n        \n        rep(j,F-1){\n            t[y][x][j] = pz[i][j];\n        }\n        rep(j,F-1){\n            int nx = x + dx[j];\n            int ny = y + dy[j];\n            if(judge(t[ny][nx][(j+2)%4],t[y][x][j])) cnt++;\n        }\n        if(cnt == 4){\n            int ti = i/4*4;\n            used[ti] = used[ti+1] = used[ti+2] = used[ti+3] = true;\n            dfs(y + (x == 3),x + 1 - 3*(x+1 > 3));\n            int fi = i/4*4;\n            used[fi] = used[fi+1] = used[fi+2] = used[fi+3] = false;\n        }\n        rep(j,F-1){\n            t[y][x][j] = '0';\n        }\n    }\n}\n\nint main(){\n    cin >> n;\n    while(n--){\n        init();\n        rep(i,MAX/4){\n            cin >> str;\n            rep(j,F-1) pz[i*4][j] = str[j];\n            rep1(j,1,F-1){\n                rep1(k,j,j+F-1){\n                    pz[i*4+j][k-j] = str[k%4];\n                }\n            }\n        }\n        ans = 0;\n        dfs(1,1);\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nchar s[9][5], t[3][3][5];\nint dx[]{ -1,0,1,0 }, dy[]{ 0,1,0,-1 };\nint dfs(int p) {\n\tint res = 0;\n\trep(i, 3)rep(j, 3) {\n\t\tif (t[i][j][0])continue;\n\t\trep(k, 4) {\n\t\t\trep(l, 4) {\n\t\t\t\tint nx = i + dx[l], ny = j + dy[l];\n\t\t\t\tif (nx < 0 || 3 <= nx || ny < 0 || 3 <= ny || !t[nx][ny][0])continue;\n\t\t\t\tif (abs(s[p][(l + k) % 4] - t[nx][ny][(l + 2) % 4]) != 'a' - 'A')goto g;\n\t\t\t}\n\t\t\tif (p == 8)res++;\n\t\t\telse {\n\t\t\t\trep(l, 4)t[i][j][l] = s[p][(l + k) % 4];\n\t\t\t\tres += dfs(p + 1); t[i][j][0] = 0;\n\t\t\t}g:;\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n) {\n\t\trep(j, 9)cin >> s[j];\n\t\tprintf(\"%d\\n\", dfs(0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nbool match(char a,char b)\n{\n\treturn (a^32)==b;\n}\n\nint solve(string ps[],int perm[],int pos)\n{\n\tif(pos==9)\n\t\treturn 1;\n\tint res=0;\n\tfor(int k=pos;k<9;k++){\n\t\tswap(perm[pos],perm[k]);\n\t\tstring& cur=ps[perm[pos]];\n\t\tfor(int l=0;l<4;l++){\n\t\t\tif((pos/3==0 || match(cur[0],ps[perm[pos-3]][2]))\n\t\t\t&& (pos%3==0 || match(cur[3],ps[perm[pos-1]][1])))\n\t\t\t\tres+=solve(ps,perm,pos+1);\n\t\t\trotate(cur.begin(),cur.begin()+1,cur.end());\n\t\t}\n\t\tswap(perm[pos],perm[k]);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint tc; cin>>tc;\n\twhile(tc--){\n\t\tstring ps[9];\n\t\tfor(int i=0;i<9;i++)\n\t\t\tcin>>ps[i];\n\t\tint perm[9]; iota(perm,perm+9,0);\n\t\tcout<<solve(ps,perm,0)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nstring ps[10];\nchar mp[4][4][4];\nint ans,used[10];\nint dx[] = {1,2,3,1,2,3,1,2,3};\nint dy[] = {1,1,1,2,2,2,3,3,3};\n\nvoid saiki(int kai){\n  if(kai == 9)ans++;\n  else \n    for(int i=0;i<9;i++) {\n      if(used[i] == 1) continue;\n      for(int j=0;j<4;j++){\n\tint flg =0;\n\tif(abs(ps[i][j]-mp[dy[kai]][dx[kai]-1][1]) == 'a'-'A'||mp[dy[kai]][dx[kai]-1][1] == 0) flg++;\n\tif(abs(ps[i][(j+1)%4]-mp[dy[kai]-1][dx[kai]][2]) == 'a'-'A'||mp[dy[kai]-1][dx[kai]][2] == 0) flg++;\n\tif(flg == 2) {\n\t  for(int k=0;k<4;k++)mp[dy[kai]][dx[kai]][(3+k)%4] = ps[i][(j+k)%4];\n\t  used[i] = 1;\n\t  saiki(kai+1);\n\t  used[i] = 0;\n\t  for(int k=0;k<4;k++) mp[dy[kai]][dx[kai]][k] = 0;\n\t}\n      }\n    }\n}\n\nint main() {\n  int q;\n  cin >> q;\n  while(q--) {\n    for(int i=0;i<9;i++) cin >> ps[i];\n    ans = 0;\n    saiki(0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nstring s[9], t[3][3];\nint dx[]{ -1,0,1,0 }, dy[]{ 0,1,0,-1 };\nint cnt;\nvoid dfs(int p) {\n\tif (p == 9) { cnt++; return; }\n\trep(i, 3)rep(j, 3) {\n\t\tif (t[i][j] != \"\")continue;\n\t\tstring w;\n\t\trep(l, 4) {\n\t\t\tint nx = i + dx[l], ny = j + dy[l];\n\t\t\tif (nx < 0 || 3 <= nx || ny < 0 || 3 <= ny || t[nx][ny] == \"\") {\n\t\t\t\tw += \"0\"; continue;\n\t\t\t}\n\t\t\tchar c = t[nx][ny][(l + 2) % 4];\n\t\t\tw += (islower(c) ? toupper(c) : tolower(c));\n\t\t}\n\t\trep(k, 4) {\n\t\t\trotate(s[p].begin(), s[p].begin() + 1, s[p].end());\n\t\t\trep(l, 4) {\n\t\t\t\tif (w[l] != '0'&&s[p][l] != w[l])goto g;\n\t\t\t}\n\t\t\tt[i][j] = s[p]; dfs(p + 1); t[i][j] = \"\"; g:;\n\t\t}\n\t}\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n) {\n\t\trep(j, 9)cin >> s[j];\n\t\tcnt = 0; dfs(0);\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#define INF 9999999\nusing namespace std;\nint ans,n,used[36],t[5][5][4];\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nchar pz[36][4];\nstring str;\nvoid init();\nint judge(char,char);\nvoid dfs(int,int);\nint main(){\n\tcin>>n;\n\tfor(int I=0;I<n;I++){\n\t\tinit();\n\t\tfor(int i=0;i<9;i++){\n\t\t\tcin>>str;\n\t\t\tfor(int j=0;j<4;j++)pz[i*4+0][j-0]=str[j];\n\t\t\tfor(int j=1;j<4;j++)\n\t\t\t\tfor(int k=j;k<4+j;k++)\n\t\t\t\t\tpz[i*4+j][k-j]=str[k%4];\n\t\t}\n\n\t\tans=0;\n\t\tdfs(1,1);\n\t\tcout<<ans<<endl;\n\n\t}\n\treturn 0;\n}\nvoid init(){\n\tfor(int i=0;i<36;i++)used[i]=0;\n\tfor(int i=0;i<5;i++){\n\t\tfor(int j=0;j<5;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tt[i][j][k]='0';\n\t\t\t}\n\t\t}\n\t}\n}\nint judge(char a,char b){\n\t//cout<<a<<\" \"<<b<<endl;\n\tint c = 'A'-'a';\n\tif(a+c==b||a==b+c||a=='0'||b=='0')return 1;\n\telse return 0;\n}\n\nvoid dfs(int y,int x){\n\t//cout<<y<<\" \"<<x<<endl;\n\tif(y==4&&x==1){ans++;return;}\n\tfor(int i=0;i<36;i++){\n\t\tif(used[i]==1)continue;\n\t\tint flg=0,nx,ny;\n\t\t//test\n\t\tfor(int j=0;j<4;j++)t[y][x][j]=pz[i][j];\n\t\tfor(int j=0;j<4;j++){\n\t\t\tnx=x+dx[j];ny=y+dy[j];\n\t\t\tif(judge(t[ny][nx][(j+2)%4],t[y][x][j]))flg++;\n\t\t}\n\t\tif(flg==4){\n\n\t\t\tused[i/4*4]=used[i/4*4+1]=used[i/4*4+2]=used[i/4*4+3]=1;\n\t\t\n\t\t\tdfs(y+(x==3),x+1-3*(x+1>3));\n\t\t\n\t\t\tused[i/4*4]=used[i/4*4+1]=used[i/4*4+2]=used[i/4*4+3]=0;\n\t\t}\n\t\t//test end\n\t\tfor(int j=0;j<4;j++)t[y][x][j]='0';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nstring s[9], t[3][3];\nint dx[]{ -1,0,1,0 }, dy[]{ 0,1,0,-1 };\nint dfs(int p) {\n\tint res = 0;\n\trep(i, 3)rep(j, 3) {\n\t\tif (!t[i][j].empty())continue;\n\t\trep(k, 4) {\n\t\t\trep(l, 4) {\n\t\t\t\tint nx = i + dx[l], ny = j + dy[l];\n\t\t\t\tif (nx < 0 || 3 <= nx || ny < 0 || 3 <= ny || t[nx][ny].empty())continue;\n\t\t\t\tif (abs(s[p][(l + k) % 4] - t[nx][ny][(l + 2) % 4]) != 'a' - 'A')goto g;\n\t\t\t}\n\t\t\tif (p == 8)res++;\n\t\t\telse {\n\t\t\t\trep(l, 4)t[i][j] += s[p][(l + k) % 4];\n\t\t\t\tres += dfs(p + 1); t[i][j].clear();\n\t\t\t}g:;\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n) {\n\t\trep(j, 9)cin >> s[j];\n\t\tprintf(\"%d\\n\", dfs(0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nchar s[9][5], t[3][3][5];\nint dx[]{ -1,0,1,0 }, dy[]{ 0,1,0,-1 };\nint dfs(int p) {\n\tint res = 0;\n\trep(i, 3)rep(j, 3) {\n\t\tif (t[i][j][0])continue;\n\t\trep(k, 4) {\n\t\t\trep(l, 4) {\n\t\t\t\tint nx = i + dx[l], ny = j + dy[l];\n\t\t\t\tif (nx < 0 || 3 <= nx || ny < 0 || 3 <= ny || !t[nx][ny][0])continue;\n\t\t\t\tif (abs(s[p][(l + k) % 4] - t[nx][ny][(l + 2) % 4]) != 'a' - 'A')goto g;\n\t\t\t}\n\t\t\tif (p == 8)res++;\n\t\t\telse {\n\t\t\t\trep(l, 4)t[i][j][l] = s[p][(l + k) % 4];\n\t\t\t\tres += dfs(p + 1); t[i][j][0] = 0;\n\t\t\t}g:;\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n) {\n\t\tscanf(\"%s\", s[j]);\n\t\tprintf(\"%d\\n\", dfs(0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n \nint gSum = 0;\nint key[24];\n \nclass Piece{\npublic:\n    int pos[4];\n    Piece(){\n        memset(pos,0,sizeof(pos));\n    }\n};\n \nbool check(char pos){\n    if(pos == 0) return true;\n    //012\n    //345\n    //678\n \n    else if(pos==1){\n        return (key[0] + key[1]==0);\n    }\n \n    else if(pos==2){\n        return  (key[2] + key[3]==0);\n    }\n \n    else if(pos==3){\n        return (key[4] + key[7]==0);\n    }\n \n    else if(pos==4){\n        return ((key[5] + key[8]==0)\n        && (key[10] + key[11]==0));\n    }\n    else if(pos==5){\n        return ((key[6] + key[9]==0)\n            && (key[12] + key[13]==0));\n    }\n \n    else if(pos==6){\n        return (key[14] + key[17]==0);\n    }\n \n    else if(pos==7){\n        return ((key[15] + key[18]==0)\n            && (key[20] + key[21]==0));\n    }\n \n    else if(pos==8){\n        return ((key[16] + key[19]==0)\n            && (key[22] + key[23]==0));\n    }\n    else{\n        return false;\n    }\n}\n \nvoid dfs(char state,Piece* puzzle){\n    if(state==9){\n        gSum++;\n        return;\n    }\n \n    int res = 0;\n    if(state==0){\n        key[0] = puzzle[0].pos[0];\n        key[4] = puzzle[0].pos[1];\n        dfs(1,puzzle);\n        key[0] = puzzle[0].pos[1];\n        key[4] = puzzle[0].pos[2];\n        dfs(1,puzzle);\n        key[0] = puzzle[0].pos[2];\n        key[4] = puzzle[0].pos[3];\n        dfs(1,puzzle);\n        key[0] = puzzle[0].pos[3];\n        key[4] = puzzle[0].pos[0];\n        dfs(1,puzzle);\n    }\n    else if(state==1){\n         \n        key[2] = puzzle[1].pos[0];\n        key[5] = puzzle[1].pos[1];\n        key[1] = puzzle[1].pos[2];\n        if(check(1)) dfs(2,puzzle);\n \n        key[2] = puzzle[1].pos[1];\n        key[5] = puzzle[1].pos[2];\n        key[1] = puzzle[1].pos[3];\n        if(check(1)) dfs(2,puzzle);\n \n        key[2] = puzzle[1].pos[2];\n        key[5] = puzzle[1].pos[3];\n        key[1] = puzzle[1].pos[0];\n        if(check(1)) dfs(2,puzzle);\n \n        key[2] = puzzle[1].pos[3];\n        key[5] = puzzle[1].pos[0];\n        key[1] = puzzle[1].pos[1];\n        if(check(1)) dfs(2,puzzle);\n    }\n    else if(state==2){  \n        key[6] = puzzle[2].pos[0];\n        key[3] = puzzle[2].pos[1];\n        if(check(2)) dfs(3,puzzle);\n        key[6] = puzzle[2].pos[1];\n        key[3] = puzzle[2].pos[2];\n        if(check(2)) dfs(3,puzzle);\n        key[6] = puzzle[2].pos[2];\n        key[3] = puzzle[2].pos[3];\n        if(check(2)) dfs(3,puzzle);\n        key[6] = puzzle[2].pos[3];\n        key[3] = puzzle[2].pos[0];\n        if(check(2)) dfs(3,puzzle);\n    }\n    else if(state==3){\n        key[7] = puzzle[3].pos[0];\n        key[10] = puzzle[3].pos[1];\n        key[14] = puzzle[3].pos[2];\n        if(check(3)) dfs(4,puzzle);\n \n        key[7] = puzzle[3].pos[1];\n        key[10] = puzzle[3].pos[2];\n        key[14] = puzzle[3].pos[3];\n        if(check(3)) dfs(4,puzzle);\n \n        key[7] = puzzle[3].pos[2];\n        key[10] = puzzle[3].pos[3];\n        key[14] = puzzle[3].pos[0];\n        if(check(3)) dfs(4,puzzle);\n \n        key[7] = puzzle[3].pos[3];\n        key[10] = puzzle[3].pos[0];\n        key[14] = puzzle[3].pos[1];\n        if(check(3)) dfs(4,puzzle);\n    }\n    else if(state==4){\n        key[8] = puzzle[4].pos[0];\n        key[12] = puzzle[4].pos[1];\n        key[15] = puzzle[4].pos[2];\n        key[11] = puzzle[4].pos[3];\n        if(check(4)) dfs(5,puzzle);\n \n        key[8] = puzzle[4].pos[1];\n        key[12] = puzzle[4].pos[2];\n        key[15] = puzzle[4].pos[3];\n        key[11] = puzzle[4].pos[0];\n        if(check(4)) dfs(5,puzzle);\n \n        key[8] = puzzle[4].pos[2];\n        key[12] = puzzle[4].pos[3];\n        key[15] = puzzle[4].pos[0];\n        key[11] = puzzle[4].pos[1];\n        if(check(4)) dfs(5,puzzle);\n \n        key[8] = puzzle[4].pos[3];\n        key[12] = puzzle[4].pos[0];\n        key[15] = puzzle[4].pos[1];\n        key[11] = puzzle[4].pos[2];\n        if(check(4)) dfs(5,puzzle);\n    }\n    else if(state==5){\n        key[16] = puzzle[5].pos[0];\n        key[13] = puzzle[5].pos[1];\n        key[9] = puzzle[5].pos[2];\n        if(check(5)) dfs(6,puzzle);\n \n        key[16] = puzzle[5].pos[1];\n        key[13] = puzzle[5].pos[2];\n        key[9] = puzzle[5].pos[3];\n        if(check(5)) dfs(6,puzzle);\n \n        key[16] = puzzle[5].pos[2];\n        key[13] = puzzle[5].pos[3];\n        key[9] = puzzle[5].pos[0];\n        if(check(5)) dfs(6,puzzle);\n \n        key[16] = puzzle[5].pos[3];\n        key[13] = puzzle[5].pos[0];\n        key[9] = puzzle[5].pos[1];\n        if(check(5)) dfs(6,puzzle);\n    }\n    else if(state==6){\n        key[17] = puzzle[6].pos[0];\n        key[20] = puzzle[6].pos[1];\n        if(check(6)) dfs(7,puzzle);\n \n        key[17] = puzzle[6].pos[1];\n        key[20] = puzzle[6].pos[2];\n        if(check(6)) dfs(7,puzzle);\n \n        key[17] = puzzle[6].pos[2];\n        key[20] = puzzle[6].pos[3];\n        if(check(6)) dfs(7,puzzle);\n \n        key[17] = puzzle[6].pos[3];\n        key[20] = puzzle[6].pos[0];\n        if(check(6)) dfs(7,puzzle);\n    }\n    else if(state==7){\n        key[21] = puzzle[7].pos[0];\n        key[18] = puzzle[7].pos[1];\n        key[22] = puzzle[7].pos[2];\n        if(check(7)) dfs(8,puzzle);     \n \n        key[21] = puzzle[7].pos[1];\n        key[18] = puzzle[7].pos[2];\n        key[22] = puzzle[7].pos[3];\n        if(check(7)) dfs(8,puzzle); \n \n        key[21] = puzzle[7].pos[2];\n        key[18] = puzzle[7].pos[3];\n        key[22] = puzzle[7].pos[0];\n        if(check(7)) dfs(8,puzzle); \n \n        key[21] = puzzle[7].pos[3];\n        key[18] = puzzle[7].pos[0];\n        key[22] = puzzle[7].pos[1];\n        if(check(7)) dfs(8,puzzle); \n    }\n    else if(state==8){\n        key[23] = puzzle[8].pos[0];\n        key[19] = puzzle[8].pos[1];\n        if(check(8)) dfs(9,puzzle); \n \n        key[23] = puzzle[8].pos[1];\n        key[19] = puzzle[8].pos[2];\n        if(check(8)) dfs(9,puzzle); \n \n        key[23] = puzzle[8].pos[2];\n        key[19] = puzzle[8].pos[3];\n        if(check(8)) dfs(9,puzzle); \n \n        key[23] = puzzle[8].pos[3];\n        key[19] = puzzle[8].pos[0];\n        if(check(8)) dfs(9,puzzle); \n    }\n}\n \nchar table[256];\n \nint main(){\n    int n;\n \n    table['r'] = 1;\n    table['g'] = 2;\n    table['b'] = 3;\n    table['w'] = 4;\n    table['R'] = -1;\n    table['G'] = -2;\n    table['B'] = -3;\n    table['W'] = -4;\n \n    while(~scanf(\"%d\",&n)){\n        for(int i=0;i<n;i++){\n \n            Piece puzzle[9];\n            for(int j=0;j<9;j++){\n                char buf[5];\n                scanf(\"%s\",buf);\n                for(int k=0;k<4;k++){\n                    puzzle[j].pos[k] = table[buf[k]];\n                }\n            }\n \n            char patterns[] = {0,1,2,3,4,5,6,7,8};\n            gSum = 0;\n \n\t\t\tPiece tmp[9];\n\n            do{\n                for(int i=0;i<9;i++){\n                    tmp[i] = puzzle[patterns[i]];\n                }\n                dfs(0,tmp);\n            }while(next_permutation(patterns,patterns+9));\n \n            printf(\"%d\\n\",gSum);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<bitset>\n#include<cmath>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n\nusing namespace std;\n\nstruct Puzzle\n{\n  char t,r,b,l;\n  Puzzle(char t='$',char r='$',char b='$',char l='$'):t(t),r(r),b(b),l(l){}\n\n  void rotate90()\n  {\n    char tmp = t;\n    t = l;\n    l = b;\n    b = r;\n    r = tmp;\n  }\n\n};\n\nPuzzle puzzle[9];\nPuzzle p2[9];\nint cnt;\nint dx[] = {0,1,0,-1};//下、右、上、左\nint dy[] = {1,0,-1,0};\n\n\n\nbool match(char a,char b)\n{\n  if(a == 'R' && b == 'r')return true;\n  if(a == 'G' && b == 'g')return true;\n  if(a == 'B' && b == 'b')return true;\n  if(a == 'W' && b == 'w')return true;\n  if(a == 'w' && b == 'W')return true;\n  if(a == 'b' && b == 'B')return true;\n  if(a == 'g' && b == 'G')return true;\n  if(a == 'r' && b == 'R')return true;\n    return false;\n}\n\n\nvoid dfs(int p)\n{\n  if(p >= 9)\n    {\n      cnt++;\n      return;\n    }\n  int x = p%3;\n  int y = p/3;\n  rep(i,4)\n    {\n      bool ok = true;\n      rep(j,4)\n\t{\n\t  int nx = x + dx[j];\n\t  int ny = y + dy[j];\n\t  if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3))continue;\n\t  if(nx+ny*3 >= p)continue;\n\t  if(j == 0)\n\t    {\n\t      if(!match(puzzle[ny*3+nx].t,puzzle[y*3+x].b))\n\t\t{\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\t    }\n\t  if(j == 1)\n\t    {\n\t      if(!match(puzzle[ny*3+nx].l,puzzle[y*3+x].r))\n\t\t{\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\t    }\n\t  if(j == 2)\n\t    {\n\t      if(!match(puzzle[ny*3+nx].b,puzzle[y*3+x].t))\n\t\t{\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\t    }\n\t  if(j == 3)\n\t    {\n\t      if(!match(puzzle[ny*3+nx].r,puzzle[y*3+x].l))\n\t\t{\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n      if(!ok)\n\t{\n\t  puzzle[p].rotate90();\n\t  continue;\n\t}\n      dfs(p+1);\n      puzzle[p].rotate90();\n    }\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  while(T--)\n    {\n      cnt = 0;\n      rep(i,3)\n\t{\n\t  rep(j,3)\n\t    {\n\t      string s;\n\t      cin >> s;\n\t      p2[i*3+j].t = s[0];\n\t      p2[i*3+j].r = s[1];\n\t      p2[i*3+j].b = s[2];\t      \n\t      p2[i*3+j].l = s[3];\t      \n\t    }\n\t}\n\n      \n      int bit = 0;\n      int r = 0;\n      rep(_1,9)\n\t{\n\t  bit = (1<<_1);\n\t  puzzle[0] = p2[_1];\n\t  rep(_2,9)\n\t    {\n\t      if((bit>>_2) & 1)continue;\n\t      bit |= (1<<_2);\n\t      puzzle[1] = p2[_2];\n\t      rep(_3,9)\n\t\t{\n\t\t  if((bit>>_3) & 1)continue;\n\t\t  bit |= (1<<_3);\n\t\t  puzzle[2] = p2[_3];\n\t\t  rep(_4,9)\n\t\t    {\n\t\t      if((bit>>_4) & 1)continue;\n\t\t      bit |= (1<<_4);\n\t\t      puzzle[3] = p2[_4];\n\t\t      rep(_5,9)\n\t\t\t{\n\t\t\t  if((bit>>_5) & 1)continue;\n\t\t\t  bit |= (1<<_5);\n\t\t\t  puzzle[4] = p2[_5];\n\t\t\t  rep(_6,9)\n\t\t\t    {\n\t\t\t      if((bit>>_6) & 1)continue;\n\t\t\t      bit |= (1<<_6);\n\t\t\t      puzzle[5] = p2[_6];\n\t\t\t      rep(_7,9)\n\t\t\t\t{\n\t\t\t\t  if((bit>>_7) & 1)continue;\n\t\t\t\t  bit |= (1<<_7);\n\t\t\t\t  puzzle[6] = p2[_7];\n\t\t\t\t  rep(_8,9)\n\t\t\t\t    {\n\t\t\t\t      if((bit>>_8) & 1)continue;\n\t\t\t\t      bit |= (1<<_8);\n\t\t\t\t      puzzle[7] = p2[_8];\n\t\t\t\t      rep(_9,9)\n\t\t\t\t\t{\n\t\t\t\t\t  if((bit>>_9) & 1)continue;\n\t\t\t\t\t  puzzle[8] = p2[_9];\n\t\t\t\t\t  //print();\n\t\t\t\t\t  dfs(0);\n\t\t\t\t\t}\n\t\t\t\t      r = (1<<_8);\n\t\t\t\t      r = ~r;\n\t\t\t\t      bit = bit&r;\n\t\t\t\t    }\n\t\t\t\t      r = (1<<_7);\n\t\t\t\t      r = ~r;\n\t\t\t\t      bit = bit&r;\n\t\t\t\t}\n\t\t\t      r = (1<<_6);\n\t\t\t      r = ~r;\n\t\t\t      bit = bit&r;\n\t\t\t    }\n\t\t\t  r = (1<<_5);\n\t\t\t  r = ~r;\n\t\t\t  bit = bit&r;\n\t\t\t}\n\t\t      r = (1<<_4);\n\t\t      r = ~r;\n\t\t      bit = bit&r;\n\t\t    }\n\t\t  r = (1<<_3);\n\t\t  r = ~r;\n\t\t  bit = bit&r;\n\t\t}\n\t      r = (1<<_2);\n\t      r = ~r;\n\t      bit = bit&r;\n\t    }\n\t  r = (1<<_1);\n\t  r = ~r;\n\t  bit = bit&r;\n\t}\n\n      cout << cnt << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nint gSum = 0;\n\nclass Piece{\npublic:\n\tint pos[4];\n\tPiece(){\n\t\tmemset(pos,0,sizeof(pos));\n\t}\n};\n\nbool check(int pos,int key[24]){\n\tif(pos == 0) return true;\n\t//012\n\t//345\n\t//678\n\n\telse if(pos==1){\n\t\treturn (key[0] + key[1]==0);\n\t}\n\n\telse if(pos==2){\n\t\treturn  (key[2] + key[3]==0);\n\t}\n\n\telse if(pos==3){\n\t\treturn (key[4] + key[7]==0);\n\t}\n\n\telse if(pos==4){\n\t\treturn ((key[5] + key[8]==0)\n\t\t&& (key[10] + key[11]==0));\n\t}\n\telse if(pos==5){\n\t\treturn ((key[6] + key[9]==0)\n\t\t\t&& (key[12] + key[13]==0));\n\t}\n\n\telse if(pos==6){\n\t\treturn (key[14] + key[17]==0);\n\t}\n\n\telse if(pos==7){\n\t\treturn ((key[15] + key[18]==0)\n\t\t\t&& (key[20] + key[21]==0));\n\t}\n\n\telse if(pos==8){\n\t\treturn ((key[16] + key[19]==0)\n\t\t\t&& (key[22] + key[23]==0));\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid dfs(int key[24],int state,Piece* puzzle){\n\tif(state==9){\n\t\tgSum++;\n\t\treturn;\n\t}\n\n\tint res = 0;\n\tif(state==0){\n\t\tkey[0] = puzzle[0].pos[0];\n\t\tkey[4] = puzzle[0].pos[1];\n\t\tdfs(key,1,puzzle);\n\t\tkey[0] = puzzle[0].pos[1];\n\t\tkey[4] = puzzle[0].pos[2];\n\t\tdfs(key,1,puzzle);\n\t\tkey[0] = puzzle[0].pos[2];\n\t\tkey[4] = puzzle[0].pos[3];\n\t\tdfs(key,1,puzzle);\n\t\tkey[0] = puzzle[0].pos[3];\n\t\tkey[4] = puzzle[0].pos[0];\n\t\tdfs(key,1,puzzle);\n\t}\n\telse if(state==1){\n\t\t\n\t\tkey[2] = puzzle[1].pos[0];\n\t\tkey[5] = puzzle[1].pos[1];\n\t\tkey[1] = puzzle[1].pos[2];\n\t\tif(check(1,key)) dfs(key,2,puzzle);\n\n\t\tkey[2] = puzzle[1].pos[1];\n\t\tkey[5] = puzzle[1].pos[2];\n\t\tkey[1] = puzzle[1].pos[3];\n\t\tif(check(1,key)) dfs(key,2,puzzle);\n\n\t\tkey[2] = puzzle[1].pos[2];\n\t\tkey[5] = puzzle[1].pos[3];\n\t\tkey[1] = puzzle[1].pos[0];\n\t\tif(check(1,key)) dfs(key,2,puzzle);\n\n\t\tkey[2] = puzzle[1].pos[3];\n\t\tkey[5] = puzzle[1].pos[0];\n\t\tkey[1] = puzzle[1].pos[1];\n\t\tif(check(1,key)) dfs(key,2,puzzle);\n\t}\n\telse if(state==2){\t\n\t\tkey[6] = puzzle[2].pos[0];\n\t\tkey[3] = puzzle[2].pos[1];\n\t\tif(check(2,key)) dfs(key,3,puzzle);\n\t\tkey[6] = puzzle[2].pos[1];\n\t\tkey[3] = puzzle[2].pos[2];\n\t\tif(check(2,key)) dfs(key,3,puzzle);\n\t\tkey[6] = puzzle[2].pos[2];\n\t\tkey[3] = puzzle[2].pos[3];\n\t\tif(check(2,key)) dfs(key,3,puzzle);\n\t\tkey[6] = puzzle[2].pos[3];\n\t\tkey[3] = puzzle[2].pos[0];\n\t\tif(check(2,key)) dfs(key,3,puzzle);\n\t}\n\telse if(state==3){\n\t\tkey[7] = puzzle[3].pos[0];\n\t\tkey[10] = puzzle[3].pos[1];\n\t\tkey[14] = puzzle[3].pos[2];\n\t\tif(check(3,key)) dfs(key,4,puzzle);\n\n\t\tkey[7] = puzzle[3].pos[1];\n\t\tkey[10] = puzzle[3].pos[2];\n\t\tkey[14] = puzzle[3].pos[3];\n\t\tif(check(3,key)) dfs(key,4,puzzle);\n\n\t\tkey[7] = puzzle[3].pos[2];\n\t\tkey[10] = puzzle[3].pos[3];\n\t\tkey[14] = puzzle[3].pos[0];\n\t\tif(check(3,key)) dfs(key,4,puzzle);\n\n\t\tkey[7] = puzzle[3].pos[3];\n\t\tkey[10] = puzzle[3].pos[0];\n\t\tkey[14] = puzzle[3].pos[1];\n\t\tif(check(3,key)) dfs(key,4,puzzle);\n\t}\n\telse if(state==4){\n\t\tkey[8] = puzzle[4].pos[0];\n\t\tkey[12] = puzzle[4].pos[1];\n\t\tkey[15] = puzzle[4].pos[2];\n\t\tkey[11] = puzzle[4].pos[3];\n\t\tif(check(4,key)) dfs(key,5,puzzle);\n\n\t\tkey[8] = puzzle[4].pos[1];\n\t\tkey[12] = puzzle[4].pos[2];\n\t\tkey[15] = puzzle[4].pos[3];\n\t\tkey[11] = puzzle[4].pos[0];\n\t\tif(check(4,key)) dfs(key,5,puzzle);\n\n\t\tkey[8] = puzzle[4].pos[2];\n\t\tkey[12] = puzzle[4].pos[3];\n\t\tkey[15] = puzzle[4].pos[0];\n\t\tkey[11] = puzzle[4].pos[1];\n\t\tif(check(4,key)) dfs(key,5,puzzle);\n\n\t\tkey[8] = puzzle[4].pos[3];\n\t\tkey[12] = puzzle[4].pos[0];\n\t\tkey[15] = puzzle[4].pos[1];\n\t\tkey[11] = puzzle[4].pos[2];\n\t\tif(check(4,key)) dfs(key,5,puzzle);\n\t}\n\telse if(state==5){\n\t\tkey[16] = puzzle[5].pos[0];\n\t\tkey[13] = puzzle[5].pos[1];\n\t\tkey[9] = puzzle[5].pos[2];\n\t\tif(check(5,key)) dfs(key,6,puzzle);\n\n\t\tkey[16] = puzzle[5].pos[1];\n\t\tkey[13] = puzzle[5].pos[2];\n\t\tkey[9] = puzzle[5].pos[3];\n\t\tif(check(5,key)) dfs(key,6,puzzle);\n\n\t\tkey[16] = puzzle[5].pos[2];\n\t\tkey[13] = puzzle[5].pos[3];\n\t\tkey[9] = puzzle[5].pos[0];\n\t\tif(check(5,key)) dfs(key,6,puzzle);\n\n\t\tkey[16] = puzzle[5].pos[3];\n\t\tkey[13] = puzzle[5].pos[0];\n\t\tkey[9] = puzzle[5].pos[1];\n\t\tif(check(5,key)) dfs(key,6,puzzle);\n\t}\n\telse if(state==6){\n\t\tkey[17] = puzzle[6].pos[0];\n\t\tkey[20] = puzzle[6].pos[1];\n\t\tif(check(6,key)) dfs(key,7,puzzle);\n\n\t\tkey[17] = puzzle[6].pos[1];\n\t\tkey[20] = puzzle[6].pos[2];\n\t\tif(check(6,key)) dfs(key,7,puzzle);\n\n\t\tkey[17] = puzzle[6].pos[2];\n\t\tkey[20] = puzzle[6].pos[3];\n\t\tif(check(6,key)) dfs(key,7,puzzle);\n\n\t\tkey[17] = puzzle[6].pos[3];\n\t\tkey[20] = puzzle[6].pos[0];\n\t\tif(check(6,key)) dfs(key,7,puzzle);\n\t}\n\telse if(state==7){\n\t\tkey[21] = puzzle[7].pos[0];\n\t\tkey[18] = puzzle[7].pos[1];\n\t\tkey[22] = puzzle[7].pos[2];\n\t\tif(check(7,key)) dfs(key,8,puzzle);\t\t\n\n\t\tkey[21] = puzzle[7].pos[1];\n\t\tkey[18] = puzzle[7].pos[2];\n\t\tkey[22] = puzzle[7].pos[3];\n\t\tif(check(7,key)) dfs(key,8,puzzle);\t\n\n\t\tkey[21] = puzzle[7].pos[2];\n\t\tkey[18] = puzzle[7].pos[3];\n\t\tkey[22] = puzzle[7].pos[0];\n\t\tif(check(7,key)) dfs(key,8,puzzle);\t\n\n\t\tkey[21] = puzzle[7].pos[3];\n\t\tkey[18] = puzzle[7].pos[0];\n\t\tkey[22] = puzzle[7].pos[1];\n\t\tif(check(7,key)) dfs(key,8,puzzle);\t\n\t}\n\telse if(state==8){\n\t\tkey[23] = puzzle[8].pos[0];\n\t\tkey[19] = puzzle[8].pos[1];\n\t\tif(check(8,key)) dfs(key,9,puzzle);\t\n\n\t\tkey[23] = puzzle[8].pos[1];\n\t\tkey[19] = puzzle[8].pos[2];\n\t\tif(check(8,key)) dfs(key,9,puzzle);\t\n\n\t\tkey[23] = puzzle[8].pos[2];\n\t\tkey[19] = puzzle[8].pos[3];\n\t\tif(check(8,key)) dfs(key,9,puzzle);\t\n\n\t\tkey[23] = puzzle[8].pos[3];\n\t\tkey[19] = puzzle[8].pos[0];\n\t\tif(check(8,key)) dfs(key,9,puzzle);\t\n\t}\n}\n\nchar table[256];\n\nint main(){\n\tint n;\n\n\ttable['r'] = 1;\n\ttable['g'] = 2;\n\ttable['b'] = 3;\n\ttable['w'] = 4;\n\ttable['R'] = -1;\n\ttable['G'] = -2;\n\ttable['B'] = -3;\n\ttable['W'] = -4;\n\n\twhile(~scanf(\"%d\",&n)){\n\t\tfor(int i=0;i<n;i++){\n\n\t\t\tPiece puzzle[9];\n\t\t\tfor(int j=0;j<9;j++){\n\t\t\t\tstring str;\n\t\t\t\tcin >> str;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tpuzzle[j].pos[k] = table[str[k]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint patterns[] = {0,1,2,3,4,5,6,7,8};\n\n\t\t\tint key[24];\n\t\t\tmemset(key,-1,sizeof(key));\n\n\t\t\tint res = 0;\n\t\t\tgSum = 0;\n\n\t\t\tdo{\n\t\t\t\tPiece tmp[9];\n\t\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\t\ttmp[i] = puzzle[patterns[i]];\n\t\t\t\t}\n\t\t\t\tdfs(key,0,tmp);\n\t\t\t}while(next_permutation(patterns,patterns+9));\n\n\t\t\tprintf(\"%d\\n\",gSum);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nstring piece[9];\nint rot[9];\nint id[9];\nint bgn[10] = {0,0,1,2,3,5,7,8,10,12};\nint check[12][4] = {\n  {1, 3, 0, 1},\n  {2, 3, 1, 1},\n  {3, 0, 0, 2},\n  {4, 0, 1, 2},\n  {4, 3, 3, 1},\n  {5, 0, 2, 2},\n  {5, 3, 4, 1},\n  {6, 0, 3, 2},\n  {7, 0, 4, 2},\n  {7, 3, 6, 1},\n  {8, 0, 5, 2},\n  {8, 3, 7, 1}\n};\ninline bool ok(char c, char d){\n  return c != d && tolower(c) == tolower(d);\n}\nint ans;\nvoid dfs(int u, int S){\n  if(u == 9){\n    ans ++;\n    return;\n  }\n  for(int nu = 0; nu < 9; nu++)if(!(S >> nu & 1)){\n    id[u] = nu;\n    int NS = S | (1<<nu);\n    for(int r = 0; r <= 3; r++){\n      rot[u] = r;\n      bool next = true;\n      for(int i = bgn[u]; i < bgn[u+1]; i++){\n        int p = check[i][0], q = check[i][2];\n        int c1 = (check[i][1] + rot[p]) % 4, c2 = (check[i][3] + rot[q]) % 4;\n        if(!ok(piece[id[p]][c1], piece[id[q]][c2])) next = false;\n      }\n      if(next) dfs(u + 1, NS);\n    }\n  }\n}\nint main(){\n  int T; cin>>T;\n  while(T--){\n    REP(i, 9) cin>>piece[i];\n    sort(piece, piece + 9);\n    ans = 0;\n    dfs(0, 0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, PP> PPP;\ntypedef pair<double, Point> P2;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF= 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\n\ndouble dis(Point p1, Point p2){\n\treturn sqrt((p1.real() - p2.real())*(p1.real()-p2.real()) + (p1.imag() - p2.imag())*(p1.imag() - p2.imag()));\n}\n\nchar field[5][5][4];\nstring pz[9];\nbool used[9];\n\nint dfs(int n){\n\tif(n == 0) return 1;\n\tint res = 0;\n\tint y = (9 - n) / 3 + 1;\n\tint x = (9 - n) % 3 + 1;\n\t\n\tfor(int i = 0; i < 9; i++){\n\t\tif(used[i]) continue;\n\t\tchar c1 = field[y][x-1][0];\n\t\tchar c2 = field[y-1][x][1];\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tif((c1 == '*' || abs(c1 - pz[i][(j+2)%4]) == 32) && (c2 == '*' || abs(c2 - pz[i][(j+3)%4]) == 32)){\n\t\t\t\tfield[y][x][0] = pz[i][j];\n\t\t\t\tfield[y][x][1] = pz[i][(j+1)%4];\n\t\t\t\tfield[y][x][2] = pz[i][(j+2)%4];\n\t\t\t\tfield[y][x][3] = pz[i][(j+3)%4];\n\t\t\t\tused[i] = true;\n\t\t\t\tres += dfs(n-1);\n\t\t\t\tused[i] = false;\n\t\t\t\tfor(int k = 0; k < 4; k++)field[y][x][k] = '*';\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tfill(&field[0][0][0], &field[4][4][3] + 1, '*');\n\t\tmemset(used, false, sizeof(used));\n\t\tfor(int j= 0; j < 9; j++) cin >> pz[j];\n\t\tcout << dfs(9) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<bitset>\n#include<cmath>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n\nusing namespace std;\n\nstruct Puzzle\n{\n  char t,r,b,l;\n  Puzzle(char t='$',char r='$',char b='$',char l='$'):t(t),r(r),b(b),l(l){}\n\n  void rotate90()\n  {\n    char tmp = t;\n    t = l;\n    l = b;\n    b = r;\n    r = tmp;\n  }\n\n  bool operator < (const Puzzle &p)const\n  {\n    if(t != p.t)return t < p.t;\n    if(r != p.r)return r < p.r;\n    if(b != p.b)return b < p.b;\n    return l < p.l;\n  }\n\n};\n\nPuzzle puzzle[9];\nPuzzle p2[9];\nint cnt;\nint dx[] = {0,1,0,-1};//テ、ツクツ凝」ツ??・ツ渉ウテ」ツ??、ツクツ甘」ツ??・ツキツヲ\nint dy[] = {1,0,-1,0};\n\n\n\nbool match(char a,char b)\n{\n  if(a == 'R' && b == 'r')return true;\n  if(a == 'G' && b == 'g')return true;\n  if(a == 'B' && b == 'b')return true;\n  if(a == 'W' && b == 'w')return true;\n  if(a == 'w' && b == 'W')return true;\n  if(a == 'b' && b == 'B')return true;\n  if(a == 'g' && b == 'G')return true;\n  if(a == 'r' && b == 'R')return true;\n    return false;\n}\n\nvoid dfs(int p,int used)\n{\n\n  if(p >= 9)\n    {\n      cnt++;\n      return;\n    }\n\n  rep(i,9)\n    {\n      if((used >> i) & 1)continue;\n      puzzle[p] = p2[i];\n      rep(j,4)\n\t{\n\t  if(p == 0)\n\t    {\n\t      dfs(p+1,used|(1<<i));\n\t      puzzle[p].rotate90();\n\t      continue;\n\t    }\n\n\t  if(p%3 == 0)\n\t    {\n\t      if(match(puzzle[p].t,puzzle[p-3].b))\n\t\t{\n\t\t  dfs(p+1,used|(1<<i));\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      bool ok = true;\n\t      if(p-3>=0)\n\t\tif(!match(puzzle[p].t,puzzle[p-3].b))ok = false;\n\t      if(!match(puzzle[p].l,puzzle[p-1].r))ok = false;\n\t      if(ok)\n\t\t{\n\t\t  dfs(p+1,used|(1<<i));\n\t\t}\n\t    }\n\t  puzzle[p].rotate90();\n\t}\n    }\n\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  while(T--)\n    {\n      cnt = 0;\n      rep(i,3)\n\t{\n\t  rep(j,3)\n\t    {\n\t      string s;\n\t      cin >> s;\n\t      p2[i*3+j].t = s[0];\n\t      p2[i*3+j].r = s[1];\n\t      p2[i*3+j].b = s[2];\t      \n\t      p2[i*3+j].l = s[3];\t      \n\t    }\n\t}\n      dfs(0,0);\n\n      cout << cnt << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nstring s[9], t[3][3];\nint dx[]{ -1,0,1,0 }, dy[]{ 0,1,0,-1 };\nint dfs(int p) {\n\tint res = 0;\n\trep(i, 3)rep(j, 3) {\n\t\tif (!t[i][j].empty())continue;\n\t\trep(k, 4) {\n\t\t\trep(l, 4) {\n\t\t\t\tint nx = i + dx[l], ny = j + dy[l];\n\t\t\t\tif (nx < 0 || 3 <= nx || ny < 0 || 3 <= ny || t[nx][ny].empty())continue;\n\t\t\t\tchar c = t[nx][ny][(l + 2) % 4];\n\t\t\t\tif (isupper(s[p][(l + k) % 4])) {\n\t\t\t\t\tif (isupper(c) || toupper(c) != s[p][(l + k) % 4])goto g;\n\t\t\t\t}\n\t\t\t\telse if (islower(c) || tolower(c) != s[p][(l + k) % 4])goto g;\n\t\t\t}\n\t\t\tif (p == 8) { res++; goto g; }\n\t\t\trep(l, 4)t[i][j] += s[p][(l + k) % 4];\n\t\t\tres += dfs(p + 1); t[i][j].clear(); g:;\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n) {\n\t\trep(j, 9)cin >> s[j];\n\t\tprintf(\"%d\\n\", dfs(0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nchar s[9][5], t[3][3][5];\nint dx[]{ -1,0,1,0 }, dy[]{ 0,1,0,-1 };\nint dfs(int p) {\n\tint res = 0;\n\trep(i, 3)rep(j, 3) {\n\t\tif (t[i][j][0])continue;\n\t\trep(k, 4) {\n\t\t\trep(l, 4) {\n\t\t\t\tint nx = i + dx[l], ny = j + dy[l];\n\t\t\t\tif (nx < 0 || 3 <= nx || ny < 0 || 3 <= ny || !t[nx][ny][0])continue;\n\t\t\t\tif (abs(s[p][(l + k) % 4] - t[nx][ny][(l + 2) % 4]) != 'a' - 'A')goto g;\n\t\t\t}\n\t\t\tif (p == 8)res++;\n\t\t\telse {\n\t\t\t\trep(l, 4)t[i][j][l] = s[p][(l + k) % 4];\n\t\t\t\tres += dfs(p + 1); t[i][j][0] = 0;\n\t\t\t}g:;\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n) {\n\t\trep(j, 9)scanf(\"%s\", s[j]);\n\t\tprintf(\"%d\\n\", dfs(0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nchar pie[9][4], dat[3][3][4];\nbool used[9];\nint ans, T;\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nvoid rec(int y, int x){\n  if(y == 3){ ans++; return; }\n  for(int i=0;i<9;i++){\n    if(used[i]) continue;\n    used[i] = true;\n    for(int j=0;j<4;j++){\n      for(int k=0;k<4;k++) dat[y][x][k] = pie[i][(j+k)%4];\n      bool f = true;\n      for(int k=0;k<4;k++){\n        int ny = y + dy[k];\n        int nx = x + dx[k];\n        if(min(ny, nx) < 0 || max(ny, nx) >= 3) continue;\n        char nc = dat[ny][nx][(k+2)%4];\n        char c = dat[y][x][k];\n        if('a' <= c && c <= 'z' && !(nc == 'A' + (c - 'a') || nc == '@')) f = false;\n        if('A' <= c && c <= 'Z' && !(nc == 'a' + (c - 'A') || nc == '@')) f = false;\n      }\n      if(f) rec((y*3+x+1)/3, (y*3+x+1)%3);\n      for(int k=0;k<4;k++) dat[y][x][k] = '@';\n    }\n    used[i] = false;\n  }\n}\n\nmain(){\n  cin >> T;\n  while(T--){\n    for(int i=0;i<9;i++) for(int j=0;j<4;j++) cin >> pie[i][j];\n    ans = 0;\n    fill(dat[0][0], dat[3][0], '@');\n    fill(used, used+9, false);\n    rec(0, 0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(n) n.begin(),n.end()\n#define TOP 0\n#define BOTTOM 2\n#define RIGHT 1\n#define LEFT 3\n\nint dx[] = {3,-1,-3,1};\nint pt[] = {TOP,RIGHT,BOTTOM,LEFT};\nint my[] = {BOTTOM,LEFT,TOP,RIGHT};\n\nvector<string> puz(9);\nvector<string> cur(9);\nbool done[9];\nint ret;\n\n\n/*string change(string s,int l){\n\tswitch(l){\n\tcase 0:\n\t\treturn s;\n\tcase 1:\n\t\tswap(s[0],s[2]);\n\t\treturn s;\n\tcase 2:\n\t\tswap(s[1],s[3]);\n\t\treturn s;\n\tcase 3:\n\t\tswap(s[0],s[2]);\n\t\tswap(s[1],s[3]);\n\t\treturn s;\n\t}\n\treturn \"\";\n}*/\nvoid view(){\n\trep(i,3){\n\t\tprintf(\" %c  %c  %c \\n\",cur[i*3+0][TOP],cur[i*3+1][TOP],cur[i*3+2][TOP]);\n\t\tprintf(\"%c %c%c %c%c %c\\n\",cur[i*3+0][LEFT],cur[i*3+0][RIGHT],cur[i*3+1][LEFT],cur[i*3+1][RIGHT],cur[i*3+2][LEFT],cur[i*3+2][RIGHT]);\n\t\tprintf(\" %c  %c  %c \\n\",cur[i*3+0][BOTTOM],cur[i*3+1][BOTTOM],cur[i*3+2][BOTTOM]); \n\t}\n\tputs(\"---\");\n\treturn;\n}\nbool check(char a,char b){\n\tif(a != b && tolower(a) == tolower(b))return true;\n\treturn false;\n}\nbool check(int p){\n\trep(i,4){\n\t\tif( p%3==0 && i == 1)continue;\n\t\tif( p%3==2 && i == 3)continue;\n\t\t\n\t\tint t = p+dx[i];\n\t\tif(t<0 || t>=9)continue;\n\t\tif(cur[t]== \"\")continue;\n\t\t\n\t\tif(!check(cur[t][pt[i]],cur[p][my[i]])){\n\t\t\tif( p > 7){\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nvoid bt(int x){\n\t//cout << ret << endl;\n\n\tif( x == 9){\n\t\tret++;\n\t\treturn;\n\t}\n\t\n\trep(i,9){\n\t\tif(done[i])continue;\n\t\t\n\t\trep(l,4){\n\t\t\trotate(puz[i].begin(),puz[i].begin()+1,puz[i].end());\n\t\t\tcur[x] = puz[i];\n\t\t\tdone[i] = true;\n\t\t\tif(check(x))bt(x+1);\n\t\t\tdone[i] = false;\n\t\t\tcur[x] = \"      \";\n\t\t\tcur[x] = \"\";\n\t\t}\n\t}\n\treturn;\n}\n\n\nint main(){\n\tint n; cin >> n;\n\twhile(n--){\n\t\tret = 0;\n\t\trep(i,9)cin >> puz[i];\n\t\t\n\t\tbt(0);\n\t\t\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\nclass P{\npublic:  \n  int d,r;\n};\n\nint data,res;\nvector<string>sv;\n\nint dy[] = {-1,0,1,0};\nint dx[] = {0,1,0,-1};\n\nvoid input(){\n  string tmp;\n  sv.clear();\n  for(int i = 0 ; i < 9 ; i++)cin >> tmp,sv.push_back(tmp);\n}\n\nbool check(int x,int y){\n  if(!(0 <= x && x < 3))return false;\n  if(!(0 <= y && y < 3))return false;\n  return true;\n}\n\nvoid dfs(int pos,int data,vector<P>v){\n\n  //cout << \"pos = \" << pos << endl;//\n  //cout << \"res = \" << res << endl;//\n\n  if(pos == 9){\n    res++;\n    return;\n  }\n  \n  for(int i = 0 ; i < 9 ; i++){\n    if(data & (1 << i))continue;\n    int ndata = (data | (1 << i));\n    string str = sv[i];\n    for(int j = 0 ; j < 4 ; j++){\n      vector<P>nv = v;\n      char u,r,d,l;\n\n      u = str[j];\n      r = str[(j+1)%4];\n      d = str[(j+2)%4];\n      l = str[(j+3)%4];\n      \n      int x,y;\n      x = pos%3;\n      y = pos/3;\n      \n      int nx,ny,npos;\n\n      // up\n      ny = y + dy[0];\n      nx = x + dx[0];\n      if(check(nx,ny)){\n        npos = ny * 3 + nx;\n        if(abs(v[npos].d - u) != abs('A'- 'a'))continue;\n      }\n\n      // left\n      ny = y + dy[3];\n      nx = x + dx[3];\n      if(check(nx,ny)){\n        npos = ny * 3 + nx;\n        if(abs(v[npos].r - l) != abs('A'- 'a'))continue;\n      }\n\n      P p;\n      p.r = r;\n      p.d = d;\n      \n      nv.push_back(p);\n      dfs(pos+1,ndata,nv);\n    }\n  }\n}\n\nvoid solve(){\n  input();\n  data = 0;\n  res = 0;\n  vector<P>v;\n  dfs(0,data,v);\n  cout << res << endl;\n}\n\nint main(){\n  int n;\n  cin >> n;\n  for(int i = 0 ; i < n ; i++)solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n \nint gSum = 0;\nint key[24];\n \nclass Piece{\npublic:\n    int pos[4];\n    Piece(){\n        memset(pos,0,sizeof(pos));\n    }\n};\n \nbool check(char pos){\n    if(pos == 0) return true;\n    //012\n    //345\n    //678\n \n    else if(pos==1){\n        return (key[0] + key[1]==0);\n    }\n \n    else if(pos==2){\n        return  (key[2] + key[3]==0);\n    }\n \n    else if(pos==3){\n        return (key[4] + key[7]==0);\n    }\n \n    else if(pos==4){\n        return ((key[5] + key[8]==0)\n        && (key[10] + key[11]==0));\n    }\n    else if(pos==5){\n        return ((key[6] + key[9]==0)\n            && (key[12] + key[13]==0));\n    }\n \n    else if(pos==6){\n        return (key[14] + key[17]==0);\n    }\n \n    else if(pos==7){\n        return ((key[15] + key[18]==0)\n            && (key[20] + key[21]==0));\n    }\n \n    else if(pos==8){\n        return ((key[16] + key[19]==0)\n            && (key[22] + key[23]==0));\n    }\n    else{\n        return false;\n    }\n}\n \nvoid dfs(char state,char puzzle[9][5]){\n    if(state==9){\n        gSum++;\n        return;\n    }\n \n    int res = 0;\n    if(state==0){\n        key[0] = puzzle[0][0];\n        key[4] = puzzle[0][1];\n        dfs(1,puzzle);\n        key[0] = puzzle[0][1];\n        key[4] = puzzle[0][2];\n        dfs(1,puzzle);\n        key[0] = puzzle[0][2];\n        key[4] = puzzle[0][3];\n        dfs(1,puzzle);\n        key[0] = puzzle[0][3];\n        key[4] = puzzle[0][0];\n        dfs(1,puzzle);\n    }\n    else if(state==1){\n         \n        key[2] = puzzle[1][0];\n        key[5] = puzzle[1][1];\n        key[1] = puzzle[1][2];\n        if(check(1)) dfs(2,puzzle);\n \n        key[2] = puzzle[1][1];\n        key[5] = puzzle[1][2];\n        key[1] = puzzle[1][3];\n        if(check(1)) dfs(2,puzzle);\n \n        key[2] = puzzle[1][2];\n        key[5] = puzzle[1][3];\n        key[1] = puzzle[1][0];\n        if(check(1)) dfs(2,puzzle);\n \n        key[2] = puzzle[1][3];\n        key[5] = puzzle[1][0];\n        key[1] = puzzle[1][1];\n        if(check(1)) dfs(2,puzzle);\n    }\n    else if(state==2){  \n        key[6] = puzzle[2][0];\n        key[3] = puzzle[2][1];\n        if(check(2)) dfs(3,puzzle);\n        key[6] = puzzle[2][1];\n        key[3] = puzzle[2][2];\n        if(check(2)) dfs(3,puzzle);\n        key[6] = puzzle[2][2];\n        key[3] = puzzle[2][3];\n        if(check(2)) dfs(3,puzzle);\n        key[6] = puzzle[2][3];\n        key[3] = puzzle[2][0];\n        if(check(2)) dfs(3,puzzle);\n    }\n    else if(state==3){\n        key[7] = puzzle[3][0];\n        key[10] = puzzle[3][1];\n        key[14] = puzzle[3][2];\n        if(check(3)) dfs(4,puzzle);\n \n        key[7] = puzzle[3][1];\n        key[10] = puzzle[3][2];\n        key[14] = puzzle[3][3];\n        if(check(3)) dfs(4,puzzle);\n \n        key[7] = puzzle[3][2];\n        key[10] = puzzle[3][3];\n        key[14] = puzzle[3][0];\n        if(check(3)) dfs(4,puzzle);\n \n        key[7] = puzzle[3][3];\n        key[10] = puzzle[3][0];\n        key[14] = puzzle[3][1];\n        if(check(3)) dfs(4,puzzle);\n    }\n    else if(state==4){\n        key[8] = puzzle[4][0];\n        key[12] = puzzle[4][1];\n        key[15] = puzzle[4][2];\n        key[11] = puzzle[4][3];\n        if(check(4)) dfs(5,puzzle);\n \n        key[8] = puzzle[4][1];\n        key[12] = puzzle[4][2];\n        key[15] = puzzle[4][3];\n        key[11] = puzzle[4][0];\n        if(check(4)) dfs(5,puzzle);\n \n        key[8] = puzzle[4][2];\n        key[12] = puzzle[4][3];\n        key[15] = puzzle[4][0];\n        key[11] = puzzle[4][1];\n        if(check(4)) dfs(5,puzzle);\n \n        key[8] = puzzle[4][3];\n        key[12] = puzzle[4][0];\n        key[15] = puzzle[4][1];\n        key[11] = puzzle[4][2];\n        if(check(4)) dfs(5,puzzle);\n    }\n    else if(state==5){\n        key[16] = puzzle[5][0];\n        key[13] = puzzle[5][1];\n        key[9] = puzzle[5][2];\n        if(check(5)) dfs(6,puzzle);\n \n        key[16] = puzzle[5][1];\n        key[13] = puzzle[5][2];\n        key[9] = puzzle[5][3];\n        if(check(5)) dfs(6,puzzle);\n \n        key[16] = puzzle[5][2];\n        key[13] = puzzle[5][3];\n        key[9] = puzzle[5][0];\n        if(check(5)) dfs(6,puzzle);\n \n        key[16] = puzzle[5][3];\n        key[13] = puzzle[5][0];\n        key[9] = puzzle[5][1];\n        if(check(5)) dfs(6,puzzle);\n    }\n    else if(state==6){\n        key[17] = puzzle[6][0];\n        key[20] = puzzle[6][1];\n        if(check(6)) dfs(7,puzzle);\n \n        key[17] = puzzle[6][1];\n        key[20] = puzzle[6][2];\n        if(check(6)) dfs(7,puzzle);\n \n        key[17] = puzzle[6][2];\n        key[20] = puzzle[6][3];\n        if(check(6)) dfs(7,puzzle);\n \n        key[17] = puzzle[6][3];\n        key[20] = puzzle[6][0];\n        if(check(6)) dfs(7,puzzle);\n    }\n    else if(state==7){\n        key[21] = puzzle[7][0];\n        key[18] = puzzle[7][1];\n        key[22] = puzzle[7][2];\n        if(check(7)) dfs(8,puzzle);     \n \n        key[21] = puzzle[7][1];\n        key[18] = puzzle[7][2];\n        key[22] = puzzle[7][3];\n        if(check(7)) dfs(8,puzzle); \n \n        key[21] = puzzle[7][2];\n        key[18] = puzzle[7][3];\n        key[22] = puzzle[7][0];\n        if(check(7)) dfs(8,puzzle); \n \n        key[21] = puzzle[7][3];\n        key[18] = puzzle[7][0];\n        key[22] = puzzle[7][1];\n        if(check(7)) dfs(8,puzzle); \n    }\n    else if(state==8){\n        key[23] = puzzle[8][0];\n        key[19] = puzzle[8][1];\n        if(check(8)) dfs(9,puzzle); \n \n        key[23] = puzzle[8][1];\n        key[19] = puzzle[8][2];\n        if(check(8)) dfs(9,puzzle); \n \n        key[23] = puzzle[8][2];\n        key[19] = puzzle[8][3];\n        if(check(8)) dfs(9,puzzle); \n \n        key[23] = puzzle[8][3];\n        key[19] = puzzle[8][0];\n        if(check(8)) dfs(9,puzzle); \n    }\n}\n \nchar table[256];\n \nint main(){\n    int n;\n \n    table['r'] = 1;\n    table['g'] = 2;\n    table['b'] = 3;\n    table['w'] = 4;\n    table['R'] = -1;\n    table['G'] = -2;\n    table['B'] = -3;\n    table['W'] = -4;\n \n    while(~scanf(\"%d\",&n)){\n        for(int i=0;i<n;i++){\n \n            char puzzle[9][5];\n\t\t\tchar buf[5];\n            for(int j=0;j<9;j++){\n          \n                scanf(\"%s\",buf);\n                for(int k=0;k<4;k++){\n                    puzzle[j][k] = table[buf[k]];\n                }\n            }\n \n            char patterns[] = {0,1,2,3,4,5,6,7,8};\n            gSum = 0;\n \n\t\t\tchar tmp[9][5];\n\n            do{\n                for(int i=0;i<9;i++){\n\t\t\t\t\tmemcpy(tmp[i],puzzle[patterns[i]],sizeof(char)*5);\n\t\t\t\t}\n                dfs(0,tmp);\n            }while(next_permutation(patterns,patterns+9));\n \n            printf(\"%d\\n\",gSum);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nstring s[9];\nint indeces[9];\nint ans;\n\nvoid rec(int n){ // n テ」ツつ津ァツスツョテ」ツ??\n\n  int nn = n-1;  // nn テ」ツ?セテ」ツ?ァテァツスツョテ」ツ?凝」ツつ古」ツ?ヲテ」ツ??」ツつ?\n  if( n>0 && nn%3!=0 ){ // check left\n    char a = s[indeces[nn-1]][1];\n    char b = s[indeces[nn]][3];\n    if(b<a) swap(a,b );\n    switch(a){\n    case 'R': if(b!='r') return; break;\n    case 'G': if(b!='g') return; break;\n    case 'B': if(b!='b') return; break;\n    case 'W': if(b!='w') return; break;\n    default: return; // テ、ツクツ。テヲツ鳴ケテ・ツーツ湘ヲツ鳴?・ツュツ?\n    }\n  }\n  if( nn>=3 ){ // check up\n    char a = s[indeces[nn-3]][2];\n    char b = s[indeces[nn]][0];\n    if(b<a) swap(a, b);\n    switch(a){\n    case 'R': if(b!='r') return; break;\n    case 'G': if(b!='g') return; break;\n    case 'B': if(b!='b') return; break;\n    case 'W': if(b!='w') return; break;\n    default: return; // テ、ツクツ。テヲツ鳴ケテ・ツーツ湘ヲツ鳴?・ツュツ?\n    }\n  }\n  if( n == 9 ){\n    ans++;    return;\n  }\n\n  for( int i=0;i<9;i++ ){\n    bool flag = false;\n    for( int j=0;j<n;j++ )\n      if( indeces[j] == i ){ flag = true; break; }\n    if( flag )\n      continue;\n\n    indeces[n] = i;\n    for( int j=0;j<4;j++ ){\n      string ss = s[i].substr(1) + s[i][0]; // totation\n      s[i] = ss;\n      rec( n+1 );\n    }\n  }\n}\n\nint main(){\n  int n;\n  cin >> n;\n  while( n-- ){\n    for( int i=0;i<9;i++ )\n      cin >> s[i];\n    ans=0;\n    rec(0);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<bitset>\n#include<cmath>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n\nusing namespace std;\n\nstruct Puzzle\n{\n  char t,r,b,l;\n  Puzzle(char t='$',char r='$',char b='$',char l='$'):t(t),r(r),b(b),l(l){}\n\n  void rotate90()\n  {\n    char tmp = t;\n    t = l;\n    l = b;\n    b = r;\n    r = tmp;\n  }\n\n  bool operator < (const Puzzle &p)const\n  {\n    if(t != p.t)return t < p.t;\n    if(r != p.r)return r < p.r;\n    if(b != p.b)return b < p.b;\n    return l < p.l;\n  }\n\n};\n\nPuzzle puzzle[9];\nPuzzle p2[9];\nint cnt;\nint dx[] = {0,1,0,-1};//下、右、上、左\nint dy[] = {1,0,-1,0};\n\n\n\nbool match(char a,char b)\n{\n  if(a == 'R' && b == 'r')return true;\n  if(a == 'G' && b == 'g')return true;\n  if(a == 'B' && b == 'b')return true;\n  if(a == 'W' && b == 'w')return true;\n  if(a == 'w' && b == 'W')return true;\n  if(a == 'b' && b == 'B')return true;\n  if(a == 'g' && b == 'G')return true;\n  if(a == 'r' && b == 'R')return true;\n    return false;\n}\n\n/*\nvoid dfs(int p)\n{\n  if(p >= 9)\n    {\n      cnt++;\n      return;\n    }\n  int x = p%3;\n  int y = p/3;\n  rep(i,4)\n    {\n      bool ok = true;\n      rep(j,4)\n\t{\n\t  int nx = x + dx[j];\n\t  int ny = y + dy[j];\n\t  if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3))continue;\n\t  if(nx+ny*3 >= p)continue;\n\t  if(j == 0)\n\t    {\n\t      if(!match(puzzle[ny*3+nx].t,puzzle[y*3+x].b))\n\t\t{\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\t    }\n\t  else if(j == 1)\n\t    {\n\t      if(!match(puzzle[ny*3+nx].l,puzzle[y*3+x].r))\n\t\t{\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\t    }\n\t  else if(j == 2)\n\t    {\n\t      if(!match(puzzle[ny*3+nx].b,puzzle[y*3+x].t))\n\t\t{\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\t    }\n\t  else if(j == 3)\n\t    {\n\t      if(!match(puzzle[ny*3+nx].r,puzzle[y*3+x].l))\n\t\t{\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n      if(!ok)\n\t{\n\t  puzzle[p].rotate90();\n\t  continue;\n\t}\n      dfs(p+1);\n      puzzle[p].rotate90();\n    }\n}\n*/\n\nvoid dfs(int p,int used)\n{\n\n  if(p >= 9)\n    {\n      cnt++;\n      return;\n    }\n\n  rep(i,9)\n    {\n      if((used >> i) & 1)continue;\n      puzzle[p] = p2[i];\n      rep(j,4)\n\t{\n\t  if(p == 0)\n\t    {\n\t      dfs(p+1,used|(1<<i));\n\t      puzzle[p].rotate90();\n\t      continue;\n\t    }\n\n\t  if(p%3 == 0)\n\t    {\n\t      if(match(puzzle[p].t,puzzle[p-3].b))\n\t\t{\n\t\t  dfs(p+1,used|(1<<i));\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      bool ok = true;\n\t      if(p-3>=0)\n\t\tif(!match(puzzle[p].t,puzzle[p-3].b))ok = false;\n\t      if(!match(puzzle[p].l,puzzle[p-1].r))ok = false;\n\t      if(ok)\n\t\t{\n\t\t  dfs(p+1,used|(1<<i));\n\t\t}\n\t    }\n\t  puzzle[p].rotate90();\n\t}\n    }\n\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  while(T--)\n    {\n      cnt = 0;\n      rep(i,3)\n\t{\n\t  rep(j,3)\n\t    {\n\t      string s;\n\t      cin >> s;\n\t      p2[i*3+j].t = s[0];\n\t      p2[i*3+j].r = s[1];\n\t      p2[i*3+j].b = s[2];\t      \n\t      p2[i*3+j].l = s[3];\t      \n\t    }\n\t}\n      dfs(0,0);\n      /*      \n      int bit = 0;\n      int r = 0;\n      rep(_1,9)\n\t{\n\t  bit = (1<<_1);\n\t  puzzle[0] = p2[_1];\n\t  rep(_2,9)\n\t    {\n\t      if((bit>>_2) & 1)continue;\n\t      puzzle[1] = p2[_2];\n\n\t      //if(!match(puzzle[0].r,puzzle[1].l))continue;\n\t\t\n\t      bit |= (1<<_2);\n\n\t      rep(_3,9)\n\t\t{\n\t\t  if((bit>>_3) & 1)continue;\n\t\t  puzzle[2] = p2[_3];\n\t\t  //if(!match(puzzle[1].r,puzzle[2].l))continue;\n\t\t  bit |= (1<<_3);\n\n\t\t  rep(_4,9)\n\t\t    {\n\t\t      if((bit>>_4) & 1)continue;\n\t\t      puzzle[3] = p2[_4];\n\t\t      //if(!match(puzzle[3].t,puzzle[0].b))continue;\n\t\t      bit |= (1<<_4);\n\n\t\t      rep(_5,9)\n\t\t\t{\n\t\t\t  if((bit>>_5) & 1)continue;\n\t\t\t  puzzle[4] = p2[_5];\n\t\t\t  //if(!match(puzzle[4].t,puzzle[1].b))continue;\n\t\t\t  //if(!match(puzzle[4].l,puzzle[3].r))continue;\n\t\t\t  bit |= (1<<_5);\n\n\t\t\t  rep(_6,9)\n\t\t\t    {\n\t\t\t      if((bit>>_6) & 1)continue;\n\t\t\t      puzzle[5] = p2[_6];\n\t\t\t      //if(!match(puzzle[5].t,puzzle[2].b))continue;\n\t\t\t      //if(!match(puzzle[5].l,puzzle[4].r))continue;\n\t\t\t      bit |= (1<<_6);\n\n\t\t\t      rep(_7,9)\n\t\t\t\t{\n\t\t\t\t  if((bit>>_7) & 1)continue;\n\t\t\t\t  puzzle[6] = p2[_7];\n\t\t\t\t  //if(!match(puzzle[6].t,puzzle[3].b))continue;\n\t\t\t\t  bit |= (1<<_7);\n\n\t\t\t\t  rep(_8,9)\n\t\t\t\t    {\n\t\t\t\t      if((bit>>_8) & 1)continue;\n\t\t\t\t      puzzle[7] = p2[_8];\n\t\t\t\t      //if(!match(puzzle[7].t,puzzle[4].b))continue;\n\t\t\t\t      //if(!match(puzzle[7].l,puzzle[6].r))continue;\n\t\t\t\t      bit |= (1<<_8);\n\n\t\t\t\t      rep(_9,9)\n\t\t\t\t\t{\n\t\t\t\t\t  if((bit>>_9) & 1)continue;\n\t\t\t\t\t  puzzle[8] = p2[_9];\n\t\t\t\t\t  //if(!match(puzzle[8].t,puzzle[5].b))continue;\n\t\t\t\t\t  //if(!match(puzzle[8].l,puzzle[7].r))continue;\n\t\t\t\t\t  //print();\n\t\t\t\t\t  dfs(0);\n\t\t\t\t\t}\n\t\t\t\t      r = (1<<_8);\n\t\t\t\t      r = ~r;\n\t\t\t\t      bit = bit&r;\n\t\t\t\t    }\n\t\t\t\t      r = (1<<_7);\n\t\t\t\t      r = ~r;\n\t\t\t\t      bit = bit&r;\n\t\t\t\t}\n\t\t\t      r = (1<<_6);\n\t\t\t      r = ~r;\n\t\t\t      bit = bit&r;\n\t\t\t    }\n\t\t\t  r = (1<<_5);\n\t\t\t  r = ~r;\n\t\t\t  bit = bit&r;\n\t\t\t}\n\t\t      r = (1<<_4);\n\t\t      r = ~r;\n\t\t      bit = bit&r;\n\t\t    }\n\t\t  r = (1<<_3);\n\t\t  r = ~r;\n\t\t  bit = bit&r;\n\t\t}\n\t      r = (1<<_2);\n\t      r = ~r;\n\t      bit = bit&r;\n\t    }\n\t  r = (1<<_1);\n\t  r = ~r;\n\t  bit = bit&r;\n\t}\n      */\n\n      cout << cnt << endl;\n    }\n  return 0;\n}\n\n\n/*\n\nvoid print()\n{\n  rep(i,3)\n    {\n      rep(j,3)\n\t{\n\t  cout << \"(\" << puzzle[i*3+j].t << \",\" << puzzle[i*3+j].r << \",\"  << puzzle[i*3+j].b << \",\" << puzzle[i*3+j].l<< \") \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nbool check()\n{\n  rep(y,3)\n    {\n      rep(x,3)\n\t{\n\t  rep(k,4)\n\t    {\n\t      int nx = x + dx[k];\n\t      int ny = y + dy[k];\n\t      if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3))continue;\n\t      if(k == 0)\n\t\t{\n\t\t  if(!match(puzzle[ny*3+nx].t,puzzle[y*3+x].b))return false;\n\t\t}\n\t      if(k == 1)\n\t\t{\n\t\t  if(!match(puzzle[ny*3+nx].l,puzzle[y*3+x].r))return false;\n\t\t}\n\t      if(k == 2)\n\t\t{\n\t\t  if(!match(puzzle[ny*3+nx].b,puzzle[y*3+x].t))return false;\n\t\t}\n\t      if(k == 3)\n\t\t{\n\t\t  if(!match(puzzle[ny*3+nx].r,puzzle[y*3+x].l))return false;\n\t\t}\n\t    }\n\t}\n    }\n  return true;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\nchar mp[3][3][4];\nstring str[10];\nbool used[9];long long cnt,ans;\nvoid saiki2(int num){\n  int ex[] ={0,0,2,2};\n  int ey[] ={2,0,0,2};\n  int tx[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\n  int ty[4][2] = {{0,-1},{1,0},{0,1},{-1,0}};\n  if(num == 4) ans++;\n  else\n    for(int i=0;i<9;i++){\n      if(used[i] == 1) continue;\n      for(int j=0;j<4;j++){\n\tint nx = ex[num]+tx[num][0];\n\tint nx2 = ex[num]+tx[num][1];\n\tint ny = ey[num]+ty[num][0];\n\tint ny2 = ey[num]+ty[num][1];\n\tif(abs(str[i][j] - mp[ny][nx][(num+3)%4])=='a'-'A' &&\n\t   abs(str[i][(j+3)%4] - mp[ny2][nx2][(num+2)%4]) == 'a'-'A'){\n\t  used[i] = 1;\n\t  saiki2(num+1);\n\t  used[i] = 0;\n\t}\t \n      }\n    }\n}\n\nvoid saiki(int num){\nint dx[] = {0,-1,0 ,1};\nint dy[] = {1,0,-1,0};\n  if(num == 4) {\n    saiki2(0);\n    return;\n  }\n  for(int i=0;i<9;i++){\n    if(used[i] == 1) continue;\n    for(int j=0;j<4;j++)\n      if(abs(mp[1][1][(num+2)%4] - str[i][j])=='a'-'A') {\n\tfor(int k=0;k<4;k++) mp[1+dy[num]][1+dx[num]][(k+num)%4] = str[i][(j+k)%4];\n\tused[i] = 1;\n\tsaiki(num+1);\n\tused[i] = 0;\n      }\n  }\n}\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    ans = 0;\n  for(int i=0;i<9;i++) cin >> str[i];\n  for(int i=0;i<=9;i++){\n    for(int j=0;j<4;j++) mp[1][1][j] = str[i][j];\n    used[i] = 1;\n    saiki(0);\n    used[i] = 0;\n  }\n  cout << ans*4<<endl;\n  }\n  return 0;     \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nchar piece[9][5];\nchar put[3][3][4];\n\nbool match(char a,char b){ return a-b=='a'-'A' || a-b=='A'-'a'; }\n\nint dfs(int y,int x,bool *used){\n\tif(y==3) return 1;\n\tif(x==3) return dfs(y+1,0,used);\n\n\tint res=0;\n\trep(i,9) if(!used[i]) rep(j,4) {\n\t\tbool ok=true;\n\t\tfor(int k=1;k<=2;k++){\n\t\t\tint yy=y+dy[k],xx=x+dx[k];\n\t\t\tif(0<=yy && 0<=xx && !match(piece[i][(j+k)%4],put[yy][xx][(k+2)%4])) ok=false;\n\t\t}\n\n\t\tif(ok){\n\t\t\trep(k,4) put[y][x][k]=piece[i][(j+k)%4];\n\t\t\tused[i]=true;\n\t\t\tres+=dfs(y,x+1,used);\n\t\t\tused[i]=false;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint T; scanf(\"%d\",&T);\n\twhile(T--){\n\t\trep(i,9){\n\t\t\tscanf(\"%s\",piece[i]);\n\t\t\trep(j,2) swap(piece[i][j],piece[i][3-j]);\n\t\t}\n\n\t\tbool used[9]={};\n\t\tprintf(\"%d\\n\",dfs(0,0,used));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n\nusing namespace std;\n\nint n;\nchar str[9][5];\nchar fie[3][3][5];\nint cnt;\nbool used[9];\nchar data[8]={'g','w','r','b','G','W','R','B'};\n\nvoid swap(int x,int y){\n\tchar d=fie[x][y][0];\n\tfor(int i=0;i<3;i++){\n\t\tfie[x][y][i]=fie[x][y][i+1];\n\t}\n\tfie[x][y][3]=d;\n}\n\nvoid dfs(int x,int y){\n\tif(y==3){\n\t\tcnt++;\n\t\treturn;\n\t}\n\tfor(int l=0;l<9;l++){\n\t\tif(used[l])continue;\n\t\tused[l]=true;\n\t\tfor(int i=0;i<4;i++)fie[x][y][i]=str[l][i];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tswap(x,y);\n\t\t\t//printf(\"%d %d %s\\n\",x,y,fie[x][y]);\n\t\t\tbool flag=true;\n\t\t\tif(y>0){\n\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\tif(fie[x][y][0]==data[j]){\n\t\t\t\t\t\tif(fie[x][y-1][2]!=data[(j+4)%8])flag=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x>0){\n\t\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\t\tif(fie[x][y][3]==data[j]){\n\t\t\t\t\t\tif(fie[x-1][y][1]!=data[(j+4)%8])flag=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)dfs((x+1)%3,y+(x+1)/3);\n\t\t}\n\t\tused[l]=false;\n\t}\n}\nint main(void){\n\tscanf(\"%d%*c\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<9;j++){\n\t\t\tscanf(\"%c%c%c%c%*c\",&str[j][0],&str[j][1],&str[j][2],&str[j][3]);\n\t\t}\n\t\tcnt=0;\n\t\tdfs(0,0);\n\t\tprintf(\"%d\\n\",cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nchar piece[9][4];\n\nvoid rot(int i) {\n  rep (j, 3) swap(piece[i][j], piece[i][j + 1]);\n}\n\nbool ok(char a, char b) {return (a ^ b) == 32;}\n\nint solve(int i, int j) {\n  int res = 0;\n  rep (k, 4) {\n    rot(i * 3 + j);\n    if (i > 0 && !ok(piece[i * 3 + j][0], piece[i * 3 + j - 3][2])) continue;\n    if (j > 0 && !ok(piece[i * 3 + j][1], piece[i * 3 + j - 1][3])) continue;\n    if (j == 2) {\n      if (i == 2) ++res;\n      else res += solve(i + 1, 0);\n    } else {\n      res += solve(i, j + 1);\n    }\n  }\n  return res;\n}\n\nbool mem[9][9];\n\nbool check(vector<int> per) {\n  rep (i, 3) rep (j, 3) {\n    if (i > 0) if (!mem[per[i * 3 + j]][per[i * 3 + j - 3]]) return false;\n    if (j > 0) if (!mem[per[i * 3 + j]][per[i * 3 + j - 1]]) return false;\n  }\n  return true;\n}\n\nvoid solve() {\n  vector<string> p(9);\n  rep (i, 9) cin >> p[i];\n  rep (i, 9) rep (j, 9) mem[i][j] = false;\n  rep (i, 9) rep (j, 9) rep (k1, 4) rep (k2, 4) if (ok(p[i][k1], p[j][k2])) mem[i][j] = true;\n  vector<int> per;\n  rep (i, 9) per.push_back(i);\n  int res = 0;\n  do {\n    if (!check(per)) continue;\n    rep (i, 9) rep (j, 4) piece[i][j] = p[per[i]][j];\n    res += solve(0, 0);\n  } while (next_permutation(per.begin(), per.end()));\n  cout << res << endl;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  rep (i, n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nstring puzzle[9];\nint pl2id[9], pl2rot[9];\n\nbool check(char a, char b) {\n  return toupper(a) == toupper(b) && a != b;\n}\n\nint dfs(int k, bool *used) {\n  if(k == 9) return 1;\n  \n  int ret = 0;\n  for(int id=0; id<9; id++) {\n    if(used[id]) continue;\n\n    for(int rot=0; rot<4; rot++) {\n      bool ok = true;\n      // 上と一致\n      if(k > 2) ok &= check(puzzle[id][(rot+1)%4], puzzle[pl2id[k-3]][(pl2rot[k-3]+3)%4]);\n      // 左と一致\n      if(k % 3) ok &= check(puzzle[id][rot], puzzle[pl2id[k-1]][(pl2rot[k-1]+2)%4]);\n      \n      if(ok) {\n\tpl2id[k] = id;\n\tpl2rot[k] = rot;\n\tused[id] = true;\n\tret += dfs(k+1, used);\n\tused[id] = false;\n      }\n    }\n  }\n  \n  return ret;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  while(n--) {\n    for(int i=0; i<9; i++) {\n      cin >> puzzle[i];\n    }\n    \n    bool used[9] = {};\n    cout << dfs(0, used) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\nusing namespace std;\n\n#define TOP     0\n#define RIGHT   1\n#define BOTTOM  2\n#define LEFT    3\n\nconst char aToA = 'A' - 'a';\n\ninline bool check( char a, char b )\n{\n    return a == b + aToA || a + aToA == b;\n}\n\ninline void rotate( string& piece )\n{\n    piece = piece.substr( 1, 3 ) + piece[0];\n}\n\nint main( void )\n{\n    int n;\n    cin >> n;\n\n    string pieces[9];\n\n    for ( int lpc = 0; lpc < n; lpc++ )\n    {\n        for ( int i = 0; i < 9; i++ )\n        {\n            cin >> pieces[i];\n        }\n\n        map <string, int>   ID;\n        set <string>        P;\n        for ( int i = 0; i < 9; i++ )   \n        {\n            for ( int j = 0; j < 4; j++ )\n            {\n                P.insert( pieces[i] );\n                ID[pieces[i]] = i;\n                rotate( pieces[i] );\n            }\n        }\n\n        int answer = 0;\n        bool used[9];\n        memset( used, false, sizeof( used ) );\n\n        for ( set <string> ::iterator it_1 = P.begin(); it_1 != P.end(); it_1++ )\n        {\n            used[ID[*it_1]] = true;\n            for ( set <string> ::iterator it_2 = P.begin(); it_2 != P.end(); it_2++ )\n            {\n                if ( used[ID[*it_2]] ) continue;\n                if ( check( (*it_2)[LEFT], (*it_1)[RIGHT] ) == false ) continue;\n                used[ID[*it_2]] = true;\n                for ( set <string> ::iterator it_3 = P.begin(); it_3 != P.end(); it_3++ )\n                {\n                    if ( used[ID[*it_3]] ) continue;\n                    if ( check( (*it_3)[LEFT], (*it_2)[RIGHT] ) == false ) continue;\n                    used[ID[*it_3]] = true;\n                    for ( set <string> ::iterator it_4 = P.begin(); it_4 != P.end(); it_4++ )\n                    {\n                        if ( used[ID[*it_4]] ) continue;\n                        if ( check( (*it_4)[TOP], (*it_1)[BOTTOM] ) == false ) continue;\n                        used[ID[*it_4]] = true;\n                        for ( set <string> ::iterator it_5 = P.begin(); it_5 != P.end(); it_5++ )\n                        {\n                            if ( used[ID[*it_5]] ) continue;\n                            if ( check( (*it_5)[TOP], (*it_2)[BOTTOM] ) == false || check( (*it_5)[LEFT], (*it_4)[RIGHT] ) == false ) continue;\n                            used[ID[*it_5]] = true;\n                            for ( set <string> ::iterator it_6 = P.begin(); it_6 != P.end(); it_6++ )\n                            {\n                                if ( used[ID[*it_6]] ) continue;\n                                if ( check( (*it_6)[TOP], (*it_3)[BOTTOM] ) == false || check( (*it_6)[LEFT], (*it_5)[RIGHT] ) == false ) continue;\n                                used[ID[*it_6]] = true;\n                                for ( set <string> ::iterator it_7 = P.begin(); it_7 != P.end(); it_7++ )\n                                {\n                                    if ( used[ID[*it_7]] ) continue;\n                                    if ( check( (*it_7)[TOP], (*it_4)[BOTTOM] ) == false ) continue;\n                                    used[ID[*it_7]] = true;\n                                    for ( set <string> ::iterator it_8 = P.begin(); it_8 != P.end(); it_8++ )\n                                    {\n                                        if ( used[ID[*it_8]] ) continue;\n                                        if ( check( (*it_8)[TOP], (*it_5)[BOTTOM] ) == false || check( (*it_8)[LEFT], (*it_7)[RIGHT] ) == false ) continue;\n                                        used[ID[*it_8]] = true;\n                                        for ( set <string> ::iterator it_9 = P.begin(); it_9 != P.end(); it_9++ )\n                                        {\n                                            if ( used[ID[*it_9]] ) continue;\n                                            if ( check( (*it_9)[TOP], (*it_6)[BOTTOM] ) == false || check( (*it_9)[LEFT], (*it_8)[RIGHT] ) == false ) continue;\n                                            used[ID[*it_9]] = true;\n                                            answer++;\n                                            used[ID[*it_9]] = false;\n                                        }\n                                        used[ID[*it_8]] = false;\n                                    }\n                                    used[ID[*it_7]] = false;\n                                }\n                                used[ID[*it_6]] = false;\n                            }\n                            used[ID[*it_5]] = false;\n                        }\n                        used[ID[*it_4]] = false;\n                    }\n                    used[ID[*it_3]] = false;\n                }\n                used[ID[*it_2]] = false;\n            }\n            used[ID[*it_1]] = false;\n        } // end of loop\n\n        cout << answer << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar p[3][3][4];\nchar pz[9][4];\n\nbool check(char a,char b){\n    return (a-32 == b || b-32 == a);\n}\n\nint rec(int now,int S){\n    if(now == 9) return 1;\n    int res = 0;\n    int X = now%3, Y = now/3;\n    for(int s = 0 ; s < 9 ; s++){\n        if(S >> s & 1) continue;\n        for(int i = 0 ; i < 4 ; i++){\n            for(int j = 0 ; j < 4 ; j++){\n                p[Y][X][j] = pz[s][(i+j)%4];\n            }\n            bool can = true;    \n            if(X > 0 && !check(p[Y][X][0],p[Y][X-1][2])){\n                can = false;\n            }\n            if(Y > 0 && !check(p[Y][X][1],p[Y-1][X][3])){\n                can = false;            \n            }\n            if(can) res += rec(now+1,S|(1<<s));\n        }\n    }\n    return res;\n}\n\nint main(){\n    int Tc;\n    cin >> Tc;\n    while(Tc--){\n        for(int i = 0 ; i < 9 ; i++){\n            for(int j = 0 ; j < 4 ; j++){\n                cin >> pz[i][j];\n            }\n        }\n        cout << rec(0,0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nstring s[9], t[3][3];\nint dx[]{ -1,0,1,0 }, dy[]{ 0,1,0,-1 };\nint dfs(int p) {\n\tint res = 0;\n\trep(i, 3)rep(j, 3) {\n\t\tif (!t[i][j].empty())continue;\n\t\trep(k, 4) {\n\t\t\trep(l, 4) {\n\t\t\t\tint nx = i + dx[l], ny = j + dy[l];\n\t\t\t\tif (nx < 0 || 3 <= nx || ny < 0 || 3 <= ny || t[nx][ny].empty())continue;\n\t\t\t\tchar c = t[nx][ny][(l + 2) % 4];\n\t\t\t\tif (isupper(s[p][(l + k) % 4])) {\n\t\t\t\t\tif (isupper(c) || toupper(c) != s[p][(l + k) % 4])goto g;\n\t\t\t\t}\n\t\t\t\telse if (islower(c) || tolower(c) != s[p][(l + k) % 4])goto g;\n\t\t\t}\n\t\t\tif (p == 8)res++;\n\t\t\telse {\n\t\t\t\trep(l, 4)t[i][j] += s[p][(l + k) % 4];\n\t\t\t\tres += dfs(p + 1); t[i][j].clear();\n\t\t\t}g:;\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n) {\n\t\trep(j, 9)cin >> s[j];\n\t\tprintf(\"%d\\n\", dfs(0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\nchar mp[3][3][4];\nstring str[10];\nbool used[9];long long cnt,ans;\nvoid saiki2(int num){\n  int ex[] ={0,0,2,2};\n  int ey[] ={2,0,0,2};\n  int tx[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\n  int ty[4][2] = {{0,-1},{1,0},{0,1},{-1,0}};\n  if(num == 4) ans++;\n  else\n    for(int i=0;i<9;i++){\n      if(used[i] == 1) continue;\n      for(int j=0;j<4;j++){\n\tint nx = ex[num]+tx[num][0];\n\tint nx2 = ex[num]+tx[num][1];\n\tint ny = ey[num]+ty[num][0];\n\tint ny2 = ey[num]+ty[num][1];\n\tif(abs(str[i][j] - mp[ny][nx][(num+3)%4])=='a'-'A' &&\n\t   abs(str[i][(j+3)%4] - mp[ny2][nx2][(num+2)%4]) == 'a'-'A'){\n\t  \n\t  used[i] = 1;\n\t  saiki2(num+1);\n\t  used[i] = 0;\n\t}\t \n      }\n    }\n}\n\nvoid saiki(int num){\nint dx[] = {0,-1,0 ,1};\nint dy[] = {1,0,-1,0};\n  if(num == 4) {\n    saiki2(0);\n    return;\n  }\n  for(int i=0;i<9;i++){\n    if(used[i] == 1) continue;\n    for(int j=0;j<4;j++)\n      if(abs(mp[1][1][(num+2)%4] - str[i][j])=='a'-'A') {\n\tfor(int k=0;k<4;k++) mp[1+dy[num]][1+dx[num]][(k+num)%4] = str[i][(j+k)%4];\n\tused[i] = 1;\n\tsaiki(num+1);\n\tused[i] = 0;\n      }\n  }\n}\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    ans = 0;\n  for(int i=0;i<9;i++) cin >> str[i];\n  for(int i=0;i<=9;i++){\n    for(int j=0;j<4;j++) mp[1][1][j] = str[i][j];\n    used[i] = 1;\n    saiki(0);\n    used[i] = 0;\n  }\n  cout << ans*4<<endl;\n  }\n  return 0;     \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n\n\nint my[] = {0, 0, 1, -1};\nint mx[] = {1, -1, 0, 0};\nint wt[] = {1, 3, 2, 0};\nint wv[] = {3, 1, 0, 2};\n\nbool ok(char a, char b){\n  char la = tolower(a), lb = tolower(b);\n  if(la != lb) return false;\n  if((islower(a) && isupper(b)) || (isupper(a) && islower(b))) return true;\n  return false;\n}\n\nbool check(int y, int x, int cnt, vector< vector<string> > &v, string &p){\n  REP(i, 4){\n    int ny = y + my[i], nx = x + mx[i], nc = ny * 3 + nx;\n    if(ny < 0 || nx < 0 || ny >= 3 || nx >= 3 || nc < 0 || nc > 8 || nc > cnt) continue;\n    if(!ok(p[wt[i]], v[ny][nx][wv[i]])) return false;\n  }\n  return true;\n}\n\nint dfs(vector<string> &ps, vector< vector<string> > &v, int cnt, vector<bool> &used){\n  int res = 0;\n  if(cnt >= 9){\n    //cout <<\"-----------\" <<endl; REP(i, 3){ REP(j, 3) cout <<v[i][j] <<\" \"; cout <<endl; }\n    return 1;\n  }\n  int y = cnt / 3, x = cnt % 3;\n  REP(i, 9){\n    if(used[i]) continue;\n    REP(j, 4){\n      if(check(y, x, cnt, v, ps[i])){\n        used[i] = true; v[y][x] = ps[i];\n        res += dfs(ps, v, cnt + 1, used);\n        used[i] = false; v[y][x] = ps[i];;\n      }\n      ps[i] = ps[i].substr(1) + ps[i].substr(0, 1);\n    }\n  }\n  return res;\n}\n\nint main() {\n  int N; cin >>N;\n  REP(n, N){\n    vector<string> ps(9); REP(i, 9) cin >>ps[i];\n    vector<bool> used(9, false);\n    vector< vector<string> > v(3, vector<string>(3, \"....\"));\n    int ans = dfs(ps, v, 0, used);\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nchar s[9][5], t[3][3][5];\nint dx[]{ -1,0,1,0 }, dy[]{ 0,1,0,-1 };\nint cnt = 0;\nvoid dfs(int p) {\n\trep(i, 3)rep(j, 3) {\n\t\tif (t[i][j][0])continue;\n\t\trep(k, 4) {\n\t\t\trep(l, 4) {\n\t\t\t\tint nx = i + dx[l], ny = j + dy[l];\n\t\t\t\tif (nx < 0 || 3 <= nx || ny < 0 || 3 <= ny || !t[nx][ny][0])continue;\n\t\t\t\tif (abs(s[p][(l + k) % 4] - t[nx][ny][(l + 2) % 4]) != 'a' - 'A')goto g;\n\t\t\t}\n\t\t\tif (p == 8)cnt++;\n\t\t\telse {\n\t\t\t\trep(l, 4)t[i][j][l] = s[p][(l + k) % 4];\n\t\t\t\tdfs(p + 1); t[i][j][0] = 0;\n\t\t\t}g:;\n\t\t}\n\t}\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n) {\n\t\trep(j, 9)scanf(\"%s\", s[j]);\n\t\tcnt = 0; dfs(0);\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(n) n.begin(),n.end()\n#define TOP 0\n#define BOTTOM 2\n#define RIGHT 1\n#define LEFT 3\n\nint dx[] = {3,-1,-3,1};\nint pt[] = {TOP,RIGHT,BOTTOM,LEFT};\nint my[] = {BOTTOM,LEFT,TOP,RIGHT};\n\nvector<string> puz(9);\nvector<string> cur(9);\nbool done[9];\nint ret;\n\nbool check(char a,char b){\n\tif(a != b && tolower(a) == tolower(b))return true;\n\treturn false;\n}\nbool check(int p){\n\trep(i,4){\n\t\tif( p%3==0 && i == 1)continue;\n\t\tif( p%3==2 && i == 3)continue;\n\t\t\n\t\tint t = p+dx[i];\n\t\tif(t<0 || t>=9)continue;\n\t\tif(cur[t]== \"\")continue;\n\t\tif(!check(cur[t][pt[i]],cur[p][my[i]]))return false;\n\t}\n\treturn true;\n}\nvoid bt(int x){\n\n\tif( x == 9){\n\t\tret++;\n\t\treturn;\n\t}\n\t\n\trep(i,9){\n\t\tif(done[i])continue;\n\t\t\n\t\trep(l,4){\n\t\t\trotate(puz[i].begin(),puz[i].begin()+1,puz[i].end());\n\t\t\tcur[x] = puz[i];\n\t\t\tdone[i] = true;\n\t\t\tif(check(x))bt(x+1);\n\t\t\tdone[i] = false;\n\t\t\tcur[x] = \"\";\n\t\t}\n\t}\n\treturn;\n}\n\n\nint main(){\n\tint n; cin >> n;\n\twhile(n--){\n\t\tret = 0;\n\t\trep(i,9)cin >> puz[i];\n\n\t\tbt(0);\n\t\t\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<bitset>\n#include<cmath>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n\nusing namespace std;\n\nstruct Puzzle\n{\n  char t,r,b,l;\n  Puzzle(char t='$',char r='$',char b='$',char l='$'):t(t),r(r),b(b),l(l){}\n\n  void rotate90()\n  {\n    char tmp = t;\n    t = l;\n    l = b;\n    b = r;\n    r = tmp;\n  }\n\n};\n\nPuzzle puzzle[9];\nPuzzle p2[9];\nint cnt;\nint dx[] = {0,1,0,-1};//下、右、上、左\nint dy[] = {1,0,-1,0};\n\nvoid print()\n{\n  rep(i,3)\n    {\n      rep(j,3)\n\t{\n\t  cout << \"(\" << puzzle[i*3+j].t << \",\" << puzzle[i*3+j].r << \",\"  << puzzle[i*3+j].b << \",\" << puzzle[i*3+j].l<< \") \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nbool match(char a,char b)\n{\n  if(a == 'R' && b == 'r')return true;\n  if(a == 'G' && b == 'g')return true;\n  if(a == 'B' && b == 'b')return true;\n  if(a == 'W' && b == 'w')return true;\n  if(a == 'w' && b == 'W')return true;\n  if(a == 'b' && b == 'B')return true;\n  if(a == 'g' && b == 'G')return true;\n  if(a == 'r' && b == 'R')return true;\n    return false;\n}\n\nbool check()\n{\n  rep(y,3)\n    {\n      rep(x,3)\n\t{\n\t  rep(k,4)\n\t    {\n\t      int nx = x + dx[k];\n\t      int ny = y + dy[k];\n\t      if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3))continue;\n\t      if(k == 0)\n\t\t{\n\t\t  if(!match(puzzle[ny*3+nx].t,puzzle[y*3+x].b))return false;\n\t\t}\n\t      if(k == 1)\n\t\t{\n\t\t  if(!match(puzzle[ny*3+nx].l,puzzle[y*3+x].r))return false;\n\t\t}\n\t      if(k == 2)\n\t\t{\n\t\t  if(!match(puzzle[ny*3+nx].b,puzzle[y*3+x].t))return false;\n\t\t}\n\t      if(k == 3)\n\t\t{\n\t\t  if(!match(puzzle[ny*3+nx].r,puzzle[y*3+x].l))return false;\n\t\t}\n\t    }\n\t}\n    }\n  return true;\n}\n\nvoid dfs(int p)\n{\n  if(p >= 9)\n    {\n      //print();\n      if(check())cnt++;\n      return;\n    }\n  int x = p%3;\n  int y = p/3;\n  rep(i,4)\n    {\n      bool ok = true;\n      rep(j,4)\n\t{\n\t  int nx = x + dx[j];\n\t  int ny = y + dy[j];\n\t  if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3))continue;\n\t  if(nx+ny*3 > p)continue;\n\t  if(j == 0)\n\t    {\n\t      if(!match(puzzle[ny*3+nx].t,puzzle[y*3+x].b))\n\t\t{\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\t    }\n\t  if(j == 1)\n\t    {\n\t      if(!match(puzzle[ny*3+nx].l,puzzle[y*3+x].r))\n\t\t{\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\t    }\n\t  if(j == 2)\n\t    {\n\t      if(!match(puzzle[ny*3+nx].b,puzzle[y*3+x].t))\n\t\t{\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\t    }\n\t  if(j == 3)\n\t    {\n\t      if(!match(puzzle[ny*3+nx].r,puzzle[y*3+x].l))\n\t\t{\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n      if(!ok)\n\t{\n\t  puzzle[p].rotate90();\n\t  continue;\n\t}\n      dfs(p+1);\n      puzzle[p].rotate90();\n    }\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  while(T--)\n    {\n      cnt = 0;\n      rep(i,3)\n\t{\n\t  rep(j,3)\n\t    {\n\t      string s;\n\t      cin >> s;\n\t      p2[i*3+j].t = s[0];\n\t      p2[i*3+j].r = s[1];\n\t      p2[i*3+j].b = s[2];\t      \n\t      p2[i*3+j].l = s[3];\t      \n\t    }\n\t}\n\n      //dfs(0);\n      int bit = 0;\n      int r = 0;\n      rep(_1,9)\n\t{\n\t  bit = (1<<_1);\n\t  puzzle[0] = p2[_1];\n\t  rep(_2,9)\n\t    {\n\t      if((bit>>_2) & 1)continue;\n\t      bit |= (1<<_2);\n\t      puzzle[1] = p2[_2];\n\t      rep(_3,9)\n\t\t{\n\t\t  if((bit>>_3) & 1)continue;\n\t\t  bit |= (1<<_3);\n\t\t  puzzle[2] = p2[_3];\n\t\t  rep(_4,9)\n\t\t    {\n\t\t      if((bit>>_4) & 1)continue;\n\t\t      bit |= (1<<_4);\n\t\t      puzzle[3] = p2[_4];\n\t\t      rep(_5,9)\n\t\t\t{\n\t\t\t  if((bit>>_5) & 1)continue;\n\t\t\t  bit |= (1<<_5);\n\t\t\t  puzzle[4] = p2[_5];\n\t\t\t  rep(_6,9)\n\t\t\t    {\n\t\t\t      if((bit>>_6) & 1)continue;\n\t\t\t      bit |= (1<<_6);\n\t\t\t      puzzle[5] = p2[_6];\n\t\t\t      rep(_7,9)\n\t\t\t\t{\n\t\t\t\t  if((bit>>_7) & 1)continue;\n\t\t\t\t  bit |= (1<<_7);\n\t\t\t\t  puzzle[6] = p2[_7];\n\t\t\t\t  rep(_8,9)\n\t\t\t\t    {\n\t\t\t\t      if((bit>>_8) & 1)continue;\n\t\t\t\t      bit |= (1<<_8);\n\t\t\t\t      puzzle[7] = p2[_8];\n\t\t\t\t      rep(_9,9)\n\t\t\t\t\t{\n\t\t\t\t\t  if((bit>>_9) & 1)continue;\n\t\t\t\t\t  puzzle[8] = p2[_9];\n\t\t\t\t\t  //print();\n\t\t\t\t\t  dfs(0);\n\t\t\t\t\t}\n\t\t\t\t      r = (1<<_8);\n\t\t\t\t      r = ~r;\n\t\t\t\t      bit = bit&r;\n\t\t\t\t    }\n\t\t\t\t      r = (1<<_7);\n\t\t\t\t      r = ~r;\n\t\t\t\t      bit = bit&r;\n\t\t\t\t}\n\t\t\t      r = (1<<_6);\n\t\t\t      r = ~r;\n\t\t\t      bit = bit&r;\n\t\t\t    }\n\t\t\t  r = (1<<_5);\n\t\t\t  r = ~r;\n\t\t\t  bit = bit&r;\n\t\t\t}\n\t\t      r = (1<<_4);\n\t\t      r = ~r;\n\t\t      bit = bit&r;\n\t\t    }\n\t\t  r = (1<<_3);\n\t\t  r = ~r;\n\t\t  bit = bit&r;\n\t\t}\n\t      r = (1<<_2);\n\t      r = ~r;\n\t      bit = bit&r;\n\t    }\n\t  r = (1<<_1);\n\t  r = ~r;\n\t  bit = bit&r;\n\t}\n\n      cout << cnt << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar arr[5][5][4];\nchar puzzle[36][4];\nbool used[36];\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {1,0,-1,0};\n\nbool check(char a, char b){\n  int d = -32;\n  return (a + d == b || b + d == a || a == '0' || b == '0');\n}\n\nint rec(int y, int x){\n  if(y == 4 && x == 1){\n    return 1;\n  }\n  int res = 0;\n  for(int i = 0 ; i < 36 ; i++){\n    if(used[i]) continue;\n    int cnt = 0;\n    for(int j = 0 ; j < 4 ; j++){\n      arr[y][x][j] = puzzle[i][j];\n    }\n    for(int j = 0 ; j < 4 ; j++){\n      int nx = x + dx[j];\n      int ny = y + dy[j];\n\n      if(check(arr[ny][nx][(j+2)%4], arr[y][x][j])){\n        cnt++;\n      }\n    }\n    if(cnt == 4){\n      int ii = i/4*4;\n      for(int j = ii ; j < ii+4 ; j++){\n        used[j] = true;\n      }\n      int a = 0, b = 0;\n      if(x == 3) a++;\n      if(x > 2) b++;\n      res += rec(y + a, x + 1 - 3*b);\n      for(int j = ii ; j < ii+4 ; j++){\n        used[j] = false;\n      }\n    }\n    for(int j = 0 ; j < 4 ; j++){\n      arr[y][x][j] = '0';\n    }\n  }\n  return res;\n}\n\nint main(){\n  int Tc;\n  string str;\n\n  cin >> Tc;\n  while(Tc--){\n    memset(used, false, sizeof(used));\n    fill(arr[0][0], arr[5][5], '0');\n    for(int i = 0 ; i < 9 ; i++){\n      cin >> str;\n      for(int j = 0 ; j < 4 ; j++){\n        puzzle[i*4][j] = str[j];\n      }\n      for(int j = 1 ; j < 4 ; j++){\n        for(int k = j ; k < j+4 ; k++){\n          puzzle[i*4+j][k-j] = str[k%4];\n        }\n      }\n    }    \n    cout << rec(1, 1) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nstring s[9], t[3][3];\nint dx[]{ -1,0,1,0 }, dy[]{ 0,1,0,-1 };\nint dfs(int p) {\n\tint res = 0;\n\trep(i, 3)rep(j, 3) {\n\t\tif (!t[i][j].empty())continue;\n\t\trep(k, 4) {\n\t\t\trep(l, 4) {\n\t\t\t\tint nx = i + dx[l], ny = j + dy[l];\n\t\t\t\tif (nx < 0 || 3 <= nx || ny < 0 || 3 <= ny || t[nx][ny].empty())continue;\n\t\t\t\tchar c = t[nx][ny][(l + 2) % 4];\n\t\t\t\tif (isupper(s[p][(l + k) % 4])) {\n\t\t\t\t\tif (isupper(c) || toupper(c) != s[p][(l + k) % 4])goto g;\n\t\t\t\t}\n\t\t\t\telse if (islower(c) || tolower(c) != s[p][(l + k) % 4])goto g;\n\t\t\t}\n\t\t\tif (p == 8) {\n\t\t\t\tres++; goto g;\n\t\t\t}\n\t\t\trep(l, 4)t[i][j] += s[p][(l + k) % 4]; t[i][j].clear(); g:;\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n) {\n\t\trep(j, 9)cin >> s[j];\n\t\tprintf(\"%d\\n\", dfs(0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\nusing namespace std;\n\n\nclass Piece {\npublic:\n  string s;\n\n  string getTurnR(int n) {\n    string tmp = s;\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < 4; j++) {\n        tmp[j] = s[(j+3)%4];\n      }\n    }\n    return tmp;\n  }\n\n  //n=0123:trdl\n  char getS(int n) {\n    return s[n];\n  }\n};\n\nPiece p[9];\nPiece now[3][3];\nint pflag[9];\nint num;\n\nvoid rec1(int);\nvoid rec2(int);\n\nvoid rec1(int cnt) {\n  static int d[4][2] = {{1,0},{2,1},{1,2},{0,1}};\n  if(cnt == 4) {\n    rec2(0);\n    return;\n  }\n  for(int i = 0; i < 9; i++) {\n    if(pflag[i] != 0) continue;\n    pflag[i] = 1;\n    Piece tp = p[i];\n    for(int j = 0; j < 4; j++) {\n      if(abs(now[1][1].getS(cnt)-tp.getS((cnt+2)%4)) == 32) {\n\tnow[d[cnt][1]][d[cnt][0]] = tp;\n\trec1(cnt+1);\n      }\n      tp.s = tp.getTurnR(1);\n    }\n    pflag[i] = 0;\n  }\n}\n\nvoid rec2(int cnt) {\n  static int d1[4][2] = {{1,0},{2,1},{1,2},{0,1}};\n  static int d2[4][2] = {{2,0},{2,2},{0,2},{0,0}};\n  if(cnt == 4) {\n    num += 4;\n    return;\n  }\n\n  for(int i = 0; i < 9; i++) {\n    if(pflag[i] != 0) continue;\n    pflag[i] = 1;\n    Piece tp = p[i];\n    for(int j = 0; j < 4; j++) {\n      if(abs(now[d1[cnt][1]][d1[cnt][0]].getS((cnt+1)%4)\n\t     -tp.getS((cnt+3)%4)) == 32 &&\n\t abs(now[d1[(cnt+1)%4][1]][d1[(cnt+1)%4][0]].getS(cnt)\n\t     -tp.getS((cnt+2)%4)) == 32) {\n\tnow[d2[cnt][1]][d2[cnt][0]] = tp;\n\trec2(cnt+1);\n      }\n      tp.s = tp.getTurnR(1);\n    }\n    pflag[i] = 0;\n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n  for(int t = 0; t < n; t++) {\n    for(int i = 0; i < 9; i++) {\n      cin >> p[i].s;\n    }\n    num = 0;\n    for(int i = 0; i < 9; i++) {\n      now[1][1] = p[i];\n      fill(&pflag[0], &pflag[9], 0);\n      pflag[i] = 1;\n      rec1(0);\n    }\n    cout << num << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nclass P{\npublic:  \n  int d,r;\n};\n\nint data,res;\nvector<string>sv;\n\nint dy[] = {-1,0,1,0};\nint dx[] = {0,1,0,-1};\n\nvoid input(){\n  string tmp;\n  sv.clear();\n  for(int i = 0 ; i < 9 ; i++)cin >> tmp,sv.push_back(tmp);\n}\n\nbool check(int x,int y){\n  if(!(0 <= x && x < 3))return false;\n  if(!(0 <= y && y < 3))return false;\n  return true;\n}\n\nvoid dfs(int pos,int data,vector<P>v){\n\n  //cout << \"pos = \" << pos << endl;//\n  //cout << \"res = \" << res << endl;//\n\n  if(pos == 9){\n    res++;\n    return;\n  }\n  \n  for(int i = 0 ; i < 9 ; i++){\n    if(data & (1 << i))continue;\n    int ndata = (data | (1 << i));\n    string str = sv[i];\n    for(int j = 0 ; j < 4 ; j++){\n      vector<P>nv = v;\n      char u,r,d,l;\n\n      u = str[j];\n      r = str[(j+1)%4];\n      d = str[(j+2)%4];\n      l = str[(j+3)%4];\n      \n      int x,y;\n      x = pos%3;\n      y = pos/3;\n      \n      int nx,ny,npos;\n\n      // up\n      ny = y + dy[0];\n      nx = x + dx[0];\n      if(check(nx,ny)){\n        npos = ny * 3 + nx;\n        if(abs(v[npos].d - u) != abs('A'- 'a'))continue;\n      }\n\n      // left\n      ny = y + dy[3];\n      nx = x + dx[3];\n      if(check(nx,ny)){\n        npos = ny * 3 + nx;\n        if(abs(v[npos].r - l) != abs('A'- 'a'))continue;\n      }\n\n      P p;\n      p.r = r;\n      p.d = d;\n      \n      nv.push_back(p);\n      dfs(pos+1,ndata,nv);\n    }\n  }\n}\n\nvoid solve(){\n  input();\n  data = 0;\n  res = 0;\n  vector<P>v;\n  dfs(0,data,v);\n  cout << res << endl;\n}\n\nint main(){\n  int n;\n  cin >> n;\n  for(int i = 0 ; i < n ; i++)solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\nint dfs(vector<vector<vector<int>>>&field, int nowx, int nowy,bitset<9>&used,const vector<vector<int>>&pieces) {\n\tif (nowy == 3)return 1;\n\telse {\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < 9; ++i) {\n\t\t\tif (!used[i]) {\n\t\t\t\tused[i] = true;\n\t\t\t\tvector<int>v(pieces[i]);\n\t\t\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\t\t\trotate(v.begin(), v.begin() + 1, v.end());\n\t\t\t\t\tbool ok = true;\n\t\t\t\t\tif (nowx) {\n\t\t\t\t\t\tif (field[nowy][nowx - 1][2] + v[0]) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (nowy) {\n\t\t\t\t\t\tif (field[nowy - 1][nowx][1] + v[3]) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tfield[nowy][nowx] = v;\n\t\t\t\t\t\tans += dfs(field, (nowx + 1) % 3, nowx == 2 ? nowy + 1 : nowy, used, pieces);\n\t\t\t\t\t\tfield[nowy][nowx].clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tused[i] = false;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\nint main() {\n\tint N; cin >> N;\n\tmap<int, int>mp;\n\tmp['W'] = 1;\n\tmp['R'] = 2;\n\tmp['G'] = 3;\n\tmp['B'] = 4;\n\tmp['w'] = -1;\n\tmp['r'] = -2;\n\tmp['g'] = -3;\n\tmp['b'] = -4;\n\twhile (N--) {\n\t\tvector<vector<int>>pieces(9);\n\t\tfor (int i = 0; i < 9; ++i) {\n\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tpieces[i].push_back(mp[st[j]]);\n\t\t\t}\n\t\t}\n\t\tbitset<9>used;\n\t\tvector<vector<vector<int>>>field(3, vector<vector<int>>(3));\n\t\tint ans = dfs(field, 0, 0, used, pieces);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nstring p[9],m[9];\nbool used[9];\nint dfs(int cnt){\n    int ret=0;\n    if(cnt==9) return 1;\n    rep(i,9){\n        if(used[i]) continue;\n        rep(j,4){\n            if(cnt>0&&cnt%3==0){\n                if(abs(m[cnt-3][2]-p[i][j])!=32) continue;\n            }\n            else if(cnt>2&&cnt%3!=0){\n                if(abs(m[cnt-3][2]-p[i][j])!=32||abs(m[cnt-1][1]-p[i][(j+3)%4])!=32) continue;\n            }\n            else if(cnt<3&&cnt>0){\n                if(abs(m[cnt-1][1]-p[i][(j+3)%4])!=32) continue;\n            }\n            used[i]=true;\n            string rp=p[i];\n            rotate_copy(p[i].begin(),p[i].begin()+j,p[i].end(),rp.begin());\n            m[cnt]=rp;\n            ret +=dfs(cnt+1);\n            used[i]=false;\n        }\n    }\n    return ret;\n}\nint main(){\n    int n;\n    cin>>n;\n    while(n--){\n        rep(i,9) cin>>p[i];\n        cout<<dfs(0)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<bitset>\n#include<cmath>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n\nusing namespace std;\n\nstruct Puzzle\n{\n  char t,r,b,l;\n  Puzzle(char t='$',char r='$',char b='$',char l='$'):t(t),r(r),b(b),l(l){}\n\n  void rotate90()\n  {\n    char tmp = t;\n    t = l;\n    l = b;\n    b = r;\n    r = tmp;\n  }\n\n};\n\nPuzzle puzzle[9];\nPuzzle p2[9];\nint cnt;\nint dx[] = {0,1,0,-1};//下、右、上、左\nint dy[] = {1,0,-1,0};\n\nvoid print()\n{\n  rep(i,3)\n    {\n      rep(j,3)\n\t{\n\t  cout << \"(\" << puzzle[i*3+j].t << \",\" << puzzle[i*3+j].r << \",\"  << puzzle[i*3+j].b << \",\" << puzzle[i*3+j].l<< \") \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nbool match(char a,char b)\n{\n  if(a == 'R' && b == 'r')return true;\n  if(a == 'G' && b == 'g')return true;\n  if(a == 'B' && b == 'b')return true;\n  if(a == 'W' && b == 'w')return true;\n  if(a == 'w' && b == 'W')return true;\n  if(a == 'b' && b == 'B')return true;\n  if(a == 'g' && b == 'G')return true;\n  if(a == 'r' && b == 'R')return true;\n    return false;\n}\n\nbool check()\n{\n  rep(y,3)\n    {\n      rep(x,3)\n\t{\n\t  rep(k,4)\n\t    {\n\t      int nx = x + dx[k];\n\t      int ny = y + dy[k];\n\t      if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3))continue;\n\t      if(k == 0)\n\t\t{\n\t\t  if(!match(puzzle[ny*3+nx].t,puzzle[y*3+x].b))return false;\n\t\t}\n\t      if(k == 1)\n\t\t{\n\t\t  if(!match(puzzle[ny*3+nx].l,puzzle[y*3+x].r))return false;\n\t\t}\n\t      if(k == 2)\n\t\t{\n\t\t  if(!match(puzzle[ny*3+nx].b,puzzle[y*3+x].t))return false;\n\t\t}\n\t      if(k == 3)\n\t\t{\n\t\t  if(!match(puzzle[ny*3+nx].r,puzzle[y*3+x].l))return false;\n\t\t}\n\t    }\n\t}\n    }\n  return true;\n}\n\nvoid dfs(int p)\n{\n  if(p >= 9)\n    {\n      cnt++;\n      return;\n    }\n  int x = p%3;\n  int y = p/3;\n  rep(i,4)\n    {\n      bool ok = true;\n      rep(j,4)\n\t{\n\t  int nx = x + dx[j];\n\t  int ny = y + dy[j];\n\t  if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3))continue;\n\t  if(nx+ny*3 > p)continue;\n\t  if(j == 0)\n\t    {\n\t      if(!match(puzzle[ny*3+nx].t,puzzle[y*3+x].b))\n\t\t{\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\t    }\n\t  if(j == 1)\n\t    {\n\t      if(!match(puzzle[ny*3+nx].l,puzzle[y*3+x].r))\n\t\t{\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\t    }\n\t  if(j == 2)\n\t    {\n\t      if(!match(puzzle[ny*3+nx].b,puzzle[y*3+x].t))\n\t\t{\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\t    }\n\t  if(j == 3)\n\t    {\n\t      if(!match(puzzle[ny*3+nx].r,puzzle[y*3+x].l))\n\t\t{\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n      if(!ok)\n\t{\n\t  puzzle[p].rotate90();\n\t  continue;\n\t}\n      dfs(p+1);\n      puzzle[p].rotate90();\n    }\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  while(T--)\n    {\n      cnt = 0;\n      rep(i,3)\n\t{\n\t  rep(j,3)\n\t    {\n\t      string s;\n\t      cin >> s;\n\t      p2[i*3+j].t = s[0];\n\t      p2[i*3+j].r = s[1];\n\t      p2[i*3+j].b = s[2];\t      \n\t      p2[i*3+j].l = s[3];\t      \n\t    }\n\t}\n\n      \n      int bit = 0;\n      int r = 0;\n      rep(_1,9)\n\t{\n\t  bit = (1<<_1);\n\t  puzzle[0] = p2[_1];\n\t  rep(_2,9)\n\t    {\n\t      if((bit>>_2) & 1)continue;\n\t      bit |= (1<<_2);\n\t      puzzle[1] = p2[_2];\n\t      rep(_3,9)\n\t\t{\n\t\t  if((bit>>_3) & 1)continue;\n\t\t  bit |= (1<<_3);\n\t\t  puzzle[2] = p2[_3];\n\t\t  rep(_4,9)\n\t\t    {\n\t\t      if((bit>>_4) & 1)continue;\n\t\t      bit |= (1<<_4);\n\t\t      puzzle[3] = p2[_4];\n\t\t      rep(_5,9)\n\t\t\t{\n\t\t\t  if((bit>>_5) & 1)continue;\n\t\t\t  bit |= (1<<_5);\n\t\t\t  puzzle[4] = p2[_5];\n\t\t\t  rep(_6,9)\n\t\t\t    {\n\t\t\t      if((bit>>_6) & 1)continue;\n\t\t\t      bit |= (1<<_6);\n\t\t\t      puzzle[5] = p2[_6];\n\t\t\t      rep(_7,9)\n\t\t\t\t{\n\t\t\t\t  if((bit>>_7) & 1)continue;\n\t\t\t\t  bit |= (1<<_7);\n\t\t\t\t  puzzle[6] = p2[_7];\n\t\t\t\t  rep(_8,9)\n\t\t\t\t    {\n\t\t\t\t      if((bit>>_8) & 1)continue;\n\t\t\t\t      bit |= (1<<_8);\n\t\t\t\t      puzzle[7] = p2[_8];\n\t\t\t\t      rep(_9,9)\n\t\t\t\t\t{\n\t\t\t\t\t  if((bit>>_9) & 1)continue;\n\t\t\t\t\t  puzzle[8] = p2[_9];\n\t\t\t\t\t  //print();\n\t\t\t\t\t  dfs(0);\n\t\t\t\t\t}\n\t\t\t\t      r = (1<<_8);\n\t\t\t\t      r = ~r;\n\t\t\t\t      bit = bit&r;\n\t\t\t\t    }\n\t\t\t\t      r = (1<<_7);\n\t\t\t\t      r = ~r;\n\t\t\t\t      bit = bit&r;\n\t\t\t\t}\n\t\t\t      r = (1<<_6);\n\t\t\t      r = ~r;\n\t\t\t      bit = bit&r;\n\t\t\t    }\n\t\t\t  r = (1<<_5);\n\t\t\t  r = ~r;\n\t\t\t  bit = bit&r;\n\t\t\t}\n\t\t      r = (1<<_4);\n\t\t      r = ~r;\n\t\t      bit = bit&r;\n\t\t    }\n\t\t  r = (1<<_3);\n\t\t  r = ~r;\n\t\t  bit = bit&r;\n\t\t}\n\t      r = (1<<_2);\n\t      r = ~r;\n\t      bit = bit&r;\n\t    }\n\t  r = (1<<_1);\n\t  r = ~r;\n\t  bit = bit&r;\n\t}\n\n      cout << cnt << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nchar s[9][5], t[3][3][5];\nint dx[]{ -1,0,1,0 }, dy[]{ 0,1,0,-1 };\nint dfs(int p) {\n\tint res = 0;\n\trep(i, 3)rep(j, 3) {\n\t\tif (t[i][j][0])continue;\n\t\trep(k, 4) {\n\t\t\trep(l, 4) {\n\t\t\t\tint nx = i + dx[l], ny = j + dy[l];\n\t\t\t\tif (nx < 0 || 3 <= nx || ny < 0 || 3 <= ny || !t[nx][ny][0])continue;\n\t\t\t\tif (abs(s[p][(l + k) % 4] - t[nx][ny][(l + 2) % 4]) != 'a' - 'A')goto g;\n\t\t\t}\n\t\t\tif (p == 8)res++;\n\t\t\telse {\n\t\t\t\trep(l, 4)t[i][j][l] = s[p][(l + k) % 4];\n\t\t\t\tres += dfs(p + 1); t[i][j][0] = 0;\n\t\t\t}g:;\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n) {\n\t\trep(j, 9)scanf(\"%s\", s[i]);\n\t\tprintf(\"%d\\n\", dfs(0));\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint flg[9];\n\nstruct P{\n\tchar s[8];\n}p[9],set[9];\n\nint solve(int idx){\n\tint i,j,k,res=0;\n\n\tif(idx == 9) return 1;\n\n\tfor(k=0;k<9;k++){\n\t\tif(flg[k] == 1) continue;\n\t\tflg[k] = 1;\n\t\tfor(i=0;i<4;i++){\n\t\t\tfor(j=0;j<4;j++){\n\t\t\t\tset[idx].s[(i+j)%4] = p[k].s[j];\n\t\t\t}\n\n\t\t\tif(idx%3>0 &&\n\t\t\t\t set[idx].s[3] + 32 != set[idx-1].s[1] &&\n\t\t\t\t set[idx].s[3] - 32 != set[idx-1].s[1])\n\t\t\t\tcontinue;\n\t\t\tif(idx>2 &&\n\t\t\t\t set[idx].s[0] + 32 != set[idx-3].s[2] &&\n\t\t\t\t set[idx].s[0] - 32 != set[idx-3].s[2])\n\t\t\t\tcontinue;\n\n\t\t\tres += solve(idx+1);\n\t\t}\n\t\tflg[k] = 0;\n\t}\n\n\treturn res;\n}\n\nint main(void){\n\tint i,n;\n\n\tscanf(\"%d\",&n);\n\n\twhile(n--){\n\t\tfor(i=0;i<9;i++){\n\t\t\tscanf(\"%s\",p[i].s);\n\t\t}\n\t\tmemset(flg,0,sizeof(flg));\n\t\tprintf(\"%d\\n\",solve(0));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1116: Jigsaw Puzzles for Computers\n// 2017.9.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nchar dice[9][6];\nchar map[3][3][4];\nchar tr['z'];\nint f[10];\nint ans;\nint rot[4][4] = {{0,1,2,3},{1,2,3,0},{2,3,0,1},{3,0,1,2}};\n\nvoid combi(int k)\n{\n\tint r, c, i, j, m;\n\n\tif (k == 9) { ans++; return; }\n\tr = k / 3, c = k % 3;\n\tfor (i = 0; i < 9; i++) {\n\t\tif (f[i]) continue;\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tfor (m = 0; m < 4; m++) map[r][c][m] = dice[i][rot[j][m]];\n\t\t\tif (r > 0 && map[r][c][0] + map[r-1][c][2] != 0) continue;\n\t\t\tif (c > 0 && map[r][c][3] + map[r][c-1][1] != 0) continue;\n\t\t\tf[i] = 1, combi(k+1), f[i] = 0;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n, i, j;\n\n\ttr['R'] =  1, tr['G'] =  2, tr['B'] =  3, tr['W'] =  4;\n\ttr['r'] = -1, tr['g'] = -2, tr['b'] = -3, tr['w'] = -4;\n\tscanf(\"%d\", &n); while (n-- > 0) {\n\t\tfor (i = 0; i < 9; i++) {\n\t\t\tscanf(\"%s\", dice[i]);\n\t\t\tfor (j = 0; j < 4; j++) dice[i][j] = tr[dice[i][j]];\n\t\t}\n\t\tmemset(f, 0, sizeof(f)), ans = 0;\n\t\tcombi(0);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nchar p[9][4];\nint map[9];\nint use[9];\nint dic[9];\nint ans;\n\nint check(char a, char b){\n  if(a == 'w' && b == 'W')return 1;\n  else if(a == 'W' && b == 'w')return 1;\n  else if(a == 'b' && b == 'B')return 1;\n  else if(a == 'B' && b == 'b')return 1;\n  else if(a == 'g' && b == 'G')return 1;\n  else if(a == 'G' && b == 'g')return 1;\n  else if(a == 'r' && b == 'R')return 1;\n  else if(a == 'R' && b == 'r')return 1;\n  else return 0;\n}\n\nchar mapdic(int num, int purse){\n  return p[map[num]][(4+purse-dic[num])%4];\n}\n\nvoid backtrack(int num){\n  int i,j;\n  int f1,f2;\n\n  if(num == 9)ans++;\n  else {\n    for(i=0;i<9;i++){\n      if(!use[i]){\n\tuse[i] = 1;\n\tmap[num] = i;\n\tfor(j=0;j<4;j++){\n\t  dic[num] = j;\n\t  f2 = 1;\n\t  if(num >= 3){\n\t    f1 = check(mapdic(num,0),mapdic(num-3,2));\n\t    if(!f1)f2 = 0;\n\t  }\n\t  if(num % 3 != 0){\n\t    f1 = check(mapdic(num,3),mapdic(num-1,1));\n\t    if(!f1)f2 = 0;\n\t  }\n\t  if(f2)backtrack(num+1);\n\t}\n\tuse[i] = 0;\n      }\n    }\n  }\t\n}\n\nint main(void){\n  int i,k,l;\n  int n;\n\n  scanf(\"%d\",&n);\n\n  for(k=0;k<n;k++){\n    for(l=0;l<9;l++){\n      for(i=0;i<4;i++){\n\tscanf(\" %c \",&p[l][i]);\n      }\n    }\n\n    for(i=0;i<9;i++)use[i] = 0;\n    ans = 0;\n\n    backtrack(0);\n    printf(\"%d\\n\",ans);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1116\n  Title:\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n\nint N;\nchar piece[9][5];\nchar ban[3][3][5]; // N,E,S,W\nchar use[9];\n\n\nvoid show()\n{\n  int i,j;\n\n  for(i=0;i<3;i++)\n    {\n      for(j=0;j<3;j++)\n\tprintf(\"-%c-|\",ban[i][j][0]);\n      printf(\"\\n\");\n      for(j=0;j<3;j++)\n\tprintf(\"%c-%c|\",ban[i][j][3],ban[i][j][1]);\n      printf(\"\\n\");\n      for(j=0;j<3;j++)\n\tprintf(\"-%c-|\",ban[i][j][2]);\n      printf(\"\\n\");\n      printf(\"---+---+---+\\n\");\n    }\n}\nint match(char c1,char c2)\n{\n  if((islower(c1) && isupper(c2) && toupper(c1)==c2) ||\n     (islower(c2) && isupper(c1) && toupper(c2)==c1))\n    return(1);\n  else\n    return(0);\n}\n\nsolve(int y,int x,char use[])\n{\n  int i,j,k,ret,xn,yn;\n  char use2[9];\n\n  //printf(\"y=%d x=%d\\n\",y,x);\n\n  ret=0;\n  for(i=0;i<9;i++)\n    {\n      if(use[i])\n\tcontinue;\n      for(j=0;j<4;j++)\n\tif(((x == 0) ||match(piece[i][(j+3)%4],ban[y][x-1][1])) &&\n\t   ((y == 0) ||match(piece[i][j]      ,ban[y-1][x][2])))\n\t  {\n\t    for(k=0;k<4;k++)\n\t      ban[y][x][k]=piece[i][(j+k)%4];\n\n\t    if(x==2 && y==2)\n\t      {\n\t\t//show();\n\t\tret++;\n\t      }\n\t    xn=x+1,yn=y;\n\t    if(xn>2)\n\t      xn=0,yn=y+1;\n\t    memcpy(use2,use,sizeof(use2));\n\t    use2[i]=1;\n\t    ret += solve(yn,xn,use2);\n\t  }\n    }\n  return(ret);\n}\n\n\n\nmain()\n{\n  int i,j,k,ret;\n  \n  scanf(\"%d\",&N);\n  for(i=0;i<N;i++)\n    {\n      for(j=0;j<9;j++)\n\tscanf(\"%s\",&piece[j][0]);\n\n      memset(use,0,sizeof(use));\n      memset(ban,' ',sizeof(ban));\n      ret=solve(0,0,use);\n      printf(\"%d\\n\",ret);\n    }\n  return(0);\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tC [][] pass;\n\tint ans;\n\tString [][] data;\n\tchar [][] map;\n\tString [] store;\n\tboolean [] used;\n\tHashMap<Character, Character> change;\n\n\tclass C{\n\t\tint pos ,ind;\n\t\tpublic C(int pos, int ind) {\n\t\t\tthis.pos = pos;    this.ind = ind;\n\t\t}\n\t}\n\n\tprivate void dfs(int deep){\n\t\tif(deep == 9){\n\t\t\tans++;\n\t\t\treturn;\n\t\t}\n\t\tfor(int j = 0; j< 9; j++){\n\t\t\tif(used[j]) continue;\n\t\t\tfor(int i=0; i < 4; i++){\n\t\t\t\tstore[deep] = data[j][i];\n\t\t\t\tif(check(deep)){\n\t\t\t\t\tused[j] = true;\n\t\t\t\t\tdfs(deep+1);\n\t\t\t\t\tused[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ;\n\t}\n\n\tprivate boolean check(int deep){\n\t\tfor(int i = 0 ;  i <= 3; i += 3){\n\t\t\tC to = pass[deep][i];\n\t\t\tif(to == null) continue;\n\t\t\t//System.out.println(\"A= \" + store[deep] + \" \" + store[to.pos] + \" \" + deep);\n\t\t\tif(store[deep].charAt(i) != change.get(store[to.pos].charAt(to.ind))){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tpass = new C[9][4];\n\t\tpassCreate();\n\t\tchange = new HashMap<Character, Character>();\n\t\tchange.put('R', 'r');\n\t\tchange.put('G', 'g');\n\t\tchange.put('B', 'b');\n\t\tchange.put('W', 'w');\n\t\tchange.put('r', 'R');\n\t\tchange.put('g', 'G');\n\t\tchange.put('b', 'B');\n\t\tchange.put('w', 'W');\n\t\twhile(n-- > 0){\n\t\t\tdata = new String[9][4];\n\t\t\tfor(int i =0; i < 9; i++){\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int j =0; j < 4; j ++){\n\t\t\t\t\tchar [] work = new char[4];\n\t\t\t\t\tfor(int k =0; k < 4; k++){\n\t\t\t\t\t\twork[k] = str.charAt((k+j) % 4);\n\t\t\t\t\t}\n\t\t\t\t\tdata[i][j] = new String(work);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = 0;\n\t\t\tmap = new char[9][9];\n\t\t\tstore = new String[9];\n\t\t\tused = new boolean[9];\n\t\t\tfor(int i = 0; i < 9; i++)\tArrays.fill(map[i], '*');\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate void passCreate(){\n\t\tpass[1][3] = new C(0,1);\n\t\tpass[2][3] = new C(1,1);\n\t\tpass[3][0] = new C(0,2);\n\t\tpass[4][0] = new C(1,2);\n\t\tpass[4][3] = new C(3,1);\n\t\tpass[5][0] = new C(2,2);\n\t\tpass[5][3] = new C(4,1);\n\t\tpass[6][0] = new C(3,2);\n\t\tpass[7][0] = new C(4,2);\n\t\tpass[7][3] = new C(6,1);\n\t\tpass[8][0] = new C(5,2);\n\t\tpass[8][3] =  new C(7,1);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays; \nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int MAX = 3;\n\tpublic static final int SIZE = MAX * MAX;\n\t\n\tpublic static int[][] move_dir = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\tpublic static int[] use = new int[]{0, 1, 2, 3};\n\tpublic static int[] ref = new int[]{2, 3, 0, 1};\n\t\n\tpublic static boolean is_sat(int x, int y, char[] piece, char[][][] press){\n\t\tfor(int dir = 0; dir < move_dir.length; dir++){\n\t\t\tfinal int nx = x + move_dir[dir][0];\n\t\t\tfinal int ny = y + move_dir[dir][1];\n\t\t\t\n\t\t\tif(!is_ok(nx, ny)){\n\t\t\t\tcontinue;\n\t\t\t}else if(press[ny][nx][0] == '?'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif((piece[use[dir]] ^ press[ny][nx][ref[dir]]) != ('a' ^ 'A')){\n\t\t\t\t//System.out.println(piece[use[dir]] + \" \" + press[ny][nx][ref[dir]]);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean is_ok(int x, int y){\n\t\tif(x < 0 || y < 0 || x >= MAX || y >= MAX){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static final int dfs(final int x, final int y, boolean[] using, char[][] pieces, char[][][] press){\n\t\tfinal int next_x = x == MAX - 1 ? 0 : x + 1;\n\t\tfinal int next_y = x == MAX - 1 ? y + 1 : y;\n\t\t\n\t\tif(y == MAX && x == 0){\n\t\t\t/*\n\t\t\tfor(int i = 0; i < MAX; i++){\n\t\t\t\tfor(int j = 0; j < MAX; j++){\n\t\t\t\t\tSystem.out.println(Arrays.toString(press[i][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t*/\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\t//System.out.println(x + \" \" + y);\n\t\t\n\t\tint sum = 0;\n\t\t\n\t\tfor(int use_piece = 0; use_piece < SIZE; use_piece++){\n\t\t\tif(using[use_piece]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tusing[use_piece] = true;\n\t\t\t\n\t\t\tfor(int rotate = 0; rotate < 4; rotate++){\n\t\t\t\t//System.out.println(Arrays.toString(pieces[use_piece]));\n\t\t\t\tchar tmp = pieces[use_piece][0];\n\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\tpieces[use_piece][i] = pieces[use_piece][i + 1];\n\t\t\t\t}\n\t\t\t\tpieces[use_piece][3] = tmp;\n\t\t\t\t//System.out.println(\"rotate :\" + Arrays.toString(pieces[use_piece]));\n\t\t\t\t\n\t\t\t\tif(is_sat(x, y, pieces[use_piece], press)){\n\t\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\t\tpress[y][x][i] = pieces[use_piece][i];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tsum += dfs(next_x, next_y, using, pieces, press);\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\t\tpress[y][x][i] = '?';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tusing[use_piece] = false;\n\t\t}\n\t\t\n\t\treturn sum;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int T = sc.nextInt();\n\t\t\n\t\tchar[][] pieces = new char[SIZE][4];\n\t\tchar[][][] press  = new char[MAX][MAX][4];\n\t\tboolean[] using = new boolean[SIZE];\n\t\t\n\t\tfor(int tt = 0; tt < T; tt++){\n\t\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\t\tpieces[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < MAX; i++){\n\t\t\t\tfor(int j = 0; j < MAX; j++){\n\t\t\t\t\tArrays.fill(press[i][j], '?');\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(using, false);\n\t\t\t\n\t\t\tSystem.out.println(dfs(0, 0, using, pieces, press));\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint T;\n\tfinal int m=3, n=9;\n\tString[] ss;\n\n\tvoid run(){\n\t\tT=sc.nextInt();\n\t\tfor(int k=0; k<T; k++){\n\t\t\tss=new String[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tss[i]=sc.next();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tint[] is, rot;\n\tboolean[] used;\n\tint answer;\n\n\tvoid solve(){\n\t\tis=new int[n];\n\t\trot=new int[n];\n\t\tused=new boolean[n];\n\t\tanswer=0;\n\t\tdfs(0);\n\t\tprintln(answer+\"\");\n\t}\n\n\tvoid dfs(int index){\n\t\tif(index==n){\n\t\t\tanswer++;\n\t\t\treturn;\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(used[j]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tis[index]=j;\n\t\t\tused[j]=true;\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\trot[index]=i;\n\t\t\t\tif(check(index)){\n\t\t\t\t\tdfs(index+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tused[j]=false;\n\t\t}\n\t}\n\n\tboolean check(int index){\n\t\tint x=index%m;\n\t\tint y=index/m;\n\t\tif(x>0){\n\t\t\tint index2=y*m+(x-1);\n\t\t\tchar c1=ss[is[index]].charAt((3+rot[index])%4);\n\t\t\tchar c2=ss[is[index2]].charAt((1+rot[index2])%4);\n\t\t\tif(Character.toLowerCase(c1)==Character.toLowerCase(c2)&&c1!=c2){}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif(y>0){\n\t\t\tint index2=(y-1)*m+x;\n\t\t\tchar c1=ss[is[index]].charAt((0+rot[index])%4);\n\t\t\tchar c2=ss[is[index2]].charAt((2+rot[index2])%4);\n\t\t\tif(Character.toLowerCase(c1)==Character.toLowerCase(c2)&&c1!=c2){}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main{\n    String[][] puzzle;\n    String[][] field; \n    boolean[] used;\n    void run(){\n\tScanner sc=new Scanner(System.in);\n\tint n=sc.nextInt();\n\tfor(int attend=0;attend<n;attend++){\n\t    field =new String[3][3];\n\t    puzzle=new String[9][4];\n\t    used=new boolean[9];\n\t    for(int i=0;i<9;i++){\n\t\tsetPuzzle(i,sc.next());\n\t    }\n\t    System.out.println(dfs(0));\n\t}\n    }\n    void setPuzzle(int num,String pu){\n\tfor(int i=0;i<4;i++){\n\t    puzzle[num][i]=pu.substring(i,pu.length())+pu.substring(0,i);\n\t}\n    }\n    int dfs(int step){\n\tif(step==9) return 1;\n\tint ans=0;\n\tfor(int i=0;i<9;i++){\n\t    if(used[i]==true)continue;\n\t    for(int j=0;j<4;j++){\n\t\tif(step>2){\n\t\t    if(!puzzleCompare(field[step/3-1][step%3].charAt(2),puzzle[i][j].charAt(0)))continue;\n\t\t}\n\t\tif(step%3!=0){\n\t\t    if(!puzzleCompare(field[step/3][step%3-1].charAt(3),puzzle[i][j].charAt(1)))continue;\n\t\t}\n\t\tfield[step/3][step%3]=puzzle[i][j];\n\t\tused[i]=true;\n\t\tans+=dfs(step+1);\n\t\tused[i]=false;\n\t    }\n\t}\n\treturn ans;\n    }\n    boolean puzzleCompare(char puz1,char puz2){\n\tif(puz1-'a'+'A'==puz2)return true;\n\telse if(puz2-'a'+'A'==puz1)return true;\n\telse return false;\n    }\n    public static void Main(String[] args){\n\tnew AOJ1116().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n  \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n  \n    public static void main(String[] args) {\n        new Main(); \n    }\n  \n    public Main() {\n        new aoj1116().doIt();\n    }\n    class aoj1116{\n    \tint result = 0;\n    \tchar map[][] = new char [9][4];\n    \tboolean check[] = new boolean[9];\n    \tint t_map[][] = new int [3][3];\n    \tint alf[] = new int[256];\n//    \tint cnt = 0;\n    \t// 0 1 2\n\t\t// 3 4 5\n\t\t// 6 7 8\n    \tvoid rotate(int num){\n//    \t\tif(num == 0){\n//    \t\t\tfor(int i = 0;i < 4;i++){\n//    \t\t\t\tSystem.out.print(map[num][i]);\n//    \t\t\t}\n//    \t\t\tSystem.out.println();\n//    \t\t}\n    \t\tchar c = map[num][0];\n    \t\tfor(int i = 0;i < 3;i++){\n    \t\t\tmap[num][i] = map[num][i+1];\n    \t\t}\n    \t\tmap[num][3] = c; \n    \t}\n    \tvoid dfs(int num){\n//    \t\tcnt++;\n//    \t\tSystem.out.println(num);\n    \t\tif(num == 9)result++;\n    \t\telse{\n    \t\t\tfor(int i = 0;i < 9;i++){\n    \t\t\t\tif(check[i])continue;\n    \t\t\t\tcheck[i] = true;\n    \t\t\t\tt_map[num/3][num%3] = i;\n    \t\t\t\tfor(int j = 0;j < 4;j++){\n    \t\t\t\t\tif(num / 3 > 0 && num % 3 > 0){\n    \t\t\t\t\t\tif(alf[map[t_map[num/3][num%3]][1]] == -alf[map[t_map[num/3][(num%3)-1]][3]]\n    \t\t\t\t\t\t\t\t&& alf[map[t_map[num/3][num%3]][0]] == -alf[map[t_map[(num/3)-1][num%3]][2]])dfs(num+1);\n    \t\t\t\t\t}else if(num / 3 > 0){\n    \t\t\t\t\t\tif(alf[map[t_map[num/3][num%3]][0]] == -alf[map[t_map[(num/3)-1][num%3]][2]])dfs(num+1);\n    \t\t\t\t\t}else if(num % 3 > 0){\n    \t\t\t\t\t\tif(alf[map[t_map[num/3][num%3]][1]] == -alf[map[t_map[num/3][(num%3)-1]][3]])dfs(num+1);\n    \t\t\t\t\t}else{\n    \t\t\t\t\t\tdfs(num+1);\n    \t\t\t\t\t}\n    \t\t\t\t\trotate(i);\n    \t\t\t\t}\n    \t\t\t\tcheck[i] = false;\n    \t\t\t}\n    \t\t}\n    \t}\n    \tvoid doIt(){\n    \t\talf['r'] = 1;alf['g'] = 2; alf['b'] = 3;alf['w'] = 4;\n    \t\talf['R'] = -1;alf['G'] = -2; alf['B'] = -3;alf['W'] = -4;\n    \t\tint n = sc.nextInt();\n    \t\tfor(int i = 0;i < n;i++){\n    \t\t\tfor(int j = 0;j < 9;j++){\n    \t\t\t\tString str = sc.next();\n    \t\t\t\tchar ctr[] = str.toCharArray();\n    \t\t\t\tfor(int k = 0;k < 4;k++){\n    \t\t\t\t\tmap[j][k] = ctr[k];\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tresult = 0;\n    \t\t\tdfs(0);\n    \t\t\tSystem.out.println(result);\n//    \t\t\tSystem.out.println(cnt);\n    \t\t}\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tstatic Puzzle[][] p = new Puzzle[5][5];\n\tstatic Puzzle[] tmp;\n\tstatic int ans;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tint N = cin.nextInt();\n\t\twhile(N--!=0){\n\t\t\tp = new Puzzle[5][5];\n\t\t\ttmp = new Puzzle[10];\n\t\t\tans=0;\n\t\t\tfor(int i = 0;i<5;i++){\n\t\t\t\tfor(int j = 0;j<5;j++){\n\t\t\t\t\tp[i][j]= new Puzzle(0,0,0,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 1;i<=9;i++){\n\t\t\t\tString str = cin.next();\n\t\t\t\tchar[] s = str.toCharArray();\n\t\t\t\ttmp[i]=new Puzzle(s[0],s[1],s[2],s[3]);\n\t\t\t}\n\t\t\tpiece(0);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic void piece(int a){\n\t\tif(a==9){\n\t\t\tans++;\n\t\t\treturn;\n\t\t}\n\t\tint x = a/3+1;\n\t\tint y = a%3+1;\n\t\tif(a==1){\n\t\t//System.out.println(a+\" \"+ x+\" \" +y);\n\t\t}\n\t\tfor(int i = 1;i<=9;i++){\n\t\t\tfor(int j = 1;j<=4;j++){\n\t\t\t\tif(tmp[i].top==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(set(x,y,tmp[i])){\n\t\t\t\t\tp[x][y]=tmp[i];\n\t\t\t\t\tPuzzle puz = tmp[i];\n\t\t\t\t\ttmp[i]=new Puzzle(0,0,0,0);\n\t\t\t\t\tpiece(a+1);\n\t\t\t\t\ttmp[i]=puz;\n\t\t\t\t\tp[x][y]=new Puzzle(0,0,0,0);\n\t\t\t\t}\n\t\t\t\ttmp[i].turn();\n\t\t\t}\n\t\t}\n\t}\n\tstatic boolean set(int x,int y,Puzzle puzzle){\n\t\tif(!(Math.abs(puzzle.top-p[x-1][y].bottom) == 32 || p[x-1][y].bottom==0)){\n\t\t\treturn false;\n\t\t}\n\t\tif(!(Math.abs(puzzle.left-p[x][y-1].right) == 32 || p[x][y-1].right==0)){\n\t\t\treturn false;\n\t\t}\n\t\tif(!(Math.abs(puzzle.bottom-p[x+1][y].top) == 32 || p[x+1][y].top==0)){\n\t\t\treturn false;\n\t\t}\n\t\tif(!(Math.abs(puzzle.right-p[x][y+1].left) == 32 || p[x][y+1].left==0)){\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t\t\n\t}\n}\nclass Puzzle{\n\tint top;\n\tint bottom;\n\tint right;\n\tint left;\n\tPuzzle(int a,int b,int c,int d){\n\t\ttop=a;bottom=c;right=b;left=d;\n\t}\n\tvoid turn(){\n\t\tint tmp = top;\n\t\ttop = right;\n\t\tright = bottom;\n\t\tbottom = left;\n\t\tleft = tmp;\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Jigsaw Puzzles for Computers\npublic class Main{\n\n\tint trans(char ch){\n\t\treturn ch=='R'?1:\n\t\t\tch=='r'?-1:\n\t\t\tch=='G'?2:\n\t\t\tch=='g'?-2:\n\t\t\tch=='B'?3:\n\t\t\tch=='b'?-3:\n\t\t\tch=='W'?4:-4;\t\n\t}\n\t\n\tclass R{\n\t\tint a[], top;\n\t\tpublic R(int[] a, int top) {\n\t\t\tthis.a = a;\n\t\t\tthis.top = top;\n\t\t}\n\t}\n\t\n\tR[][] assign;\n\tboolean[] u;\n\tint c;\n\tR[][] piece;\n\t\n\tvoid dfs(int k){\n\t\tif(k==9){\n\t\t\tc++;return;\n\t\t}\n\t\tint i=k/3;\n\t\tint j=k%3;\n\t\tfor(int use=0;use<9;use++){\n\t\t\tif(u[use])continue;\n\t\t\tfor(int d=0;d<4;d++){\n\t\t\t\tR r = piece[use][d];\n\t\t\t\tif(i>0){\n\t\t\t\t\tR up = assign[i-1][j];\n\t\t\t\t\tif(r.a[r.top]+up.a[(up.top+2)%4]!=0)continue;\n\t\t\t\t}\n\t\t\t\tif(j>0){\n\t\t\t\t\tR left = assign[i][j-1];\n\t\t\t\t\tif(r.a[(r.top+3)%4]+left.a[(left.top+1)%4]!=0)continue;\n\t\t\t\t}\n\t\t\t\tu[use] = true;\n\t\t\t\tassign[i][j] = r;\n\t\t\t\tdfs(k+1);\n\t\t\t\tu[use] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\twhile(N--!=0){\n\t\t\tpiece = new R[9][4];\n\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\tchar[] s = sc.next().toCharArray();\n\t\t\t\tint[] a = new int[4];\n\t\t\t\tfor(int j=0;j<4;j++)a[j]=trans(s[j]);\n\t\t\t\tfor(int j=0;j<4;j++)piece[i][j]=new R(a, j);\n\t\t\t}\n\t\t\tc = 0;\n\t\t\tu = new boolean[9];\n\t\t\tassign = new R[3][3];\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main{\n\n\tstatic char[][] input = new char[9][4];\n\tstatic char[][] puzzles = new char[9][4];\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint cnt = Integer.parseInt(s.nextLine());\n\t\tfor(int i=0 ; i<cnt ; i++) {\n\t\t\tString[] tmp = s.nextLine().split(\" \");\n\t\t\tfor(int j=0 ; j<9 ; j++) {\n\t\t\t\tinput[j] = tmp[j].toCharArray();\n\t\t\t}\n\t\t\tboolean[] isUsed = new boolean[9];\n\t\t\tSystem.out.println(solve(0, isUsed));\n\t\t}\n\t}\n\n\tpublic static int solve(int position, boolean[] isUsed) {\n\t\tif(position == 9)\n\t\t\treturn 1;\n\t\tint cnt = 0;\n\t\tfor(int i=0 ; i<9 ; i++) {\n\t\t\t// ??¢???????±?????????????????????????????????´???\n\t\t\tif(isUsed[i])\n\t\t\t\tcontinue;\n\t\t\tchar[] puzzle = input[i];\n\t\t\tpuzzles[position] = puzzle;\n\t\t\tfor(int j=0 ; j<4 ; j++) {\n\t\t\t\tif(check(position)) {\n\t\t\t\t\tisUsed[i] = true;\n\t\t\t\t\tcnt += solve(position+1, isUsed);\n\t\t\t\t\tisUsed[i] = false;\n\t\t\t\t}\n\t\t\t\trotate(position);\n\t\t\t}\n\t\t}\n\t\tpuzzles[position] = null;\n\t\treturn cnt;\n\t}\n\n\tpublic static boolean check(int position) {\n\t\tboolean result = false;\n\t\tswitch (position) {\n\t\tcase 0:\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(puzzles[0][1] == 'r') {\n\t\t\t\tif(puzzles[1][3] == 'R')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[0][1] == 'g') {\n\t\t\t\tif(puzzles[1][3] == 'G')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[0][1] == 'b') {\n\t\t\t\tif(puzzles[1][3] == 'B')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[0][1] == 'w') {\n\t\t\t\tif(puzzles[1][3] == 'W')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[0][1] == 'R') {\n\t\t\t\tif(puzzles[1][3] == 'r')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[0][1] == 'G') {\n\t\t\t\tif(puzzles[1][3] == 'g')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[0][1] == 'B') {\n\t\t\t\tif(puzzles[1][3] == 'b')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[0][1] == 'W') {\n\t\t\t\tif(puzzles[1][3] == 'w')\n\t\t\t\t\tresult = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif(puzzles[1][1] == 'r') {\n\t\t\t\tif(puzzles[2][3] == 'R')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[1][1] == 'g') {\n\t\t\t\tif(puzzles[2][3] == 'G')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[1][1] == 'b') {\n\t\t\t\tif(puzzles[2][3] == 'B')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[1][1] == 'w') {\n\t\t\t\tif(puzzles[2][3] == 'W')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[1][1] == 'R') {\n\t\t\t\tif(puzzles[2][3] == 'r')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[1][1] == 'G') {\n\t\t\t\tif(puzzles[2][3] == 'g')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[1][1] == 'B') {\n\t\t\t\tif(puzzles[2][3] == 'b')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[1][1] == 'W') {\n\t\t\t\tif(puzzles[2][3] == 'w')\n\t\t\t\t\tresult = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(puzzles[0][2] == 'r') {\n\t\t\t\tif(puzzles[3][0] == 'R')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[0][2] == 'g') {\n\t\t\t\tif(puzzles[3][0] == 'G')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[0][2] == 'b') {\n\t\t\t\tif(puzzles[3][0] == 'B')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[0][2] == 'w') {\n\t\t\t\tif(puzzles[3][0] == 'W')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[0][2] == 'R') {\n\t\t\t\tif(puzzles[3][0] == 'r')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[0][2] == 'G') {\n\t\t\t\tif(puzzles[3][0] == 'g')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[0][2] == 'B') {\n\t\t\t\tif(puzzles[3][0] == 'b')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[0][2] == 'W') {\n\t\t\t\tif(puzzles[3][0] == 'w')\n\t\t\t\t\tresult = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif((puzzles[1][2] == 'r' && puzzles[4][0] == 'R') ||\n\t\t\t\t\t(puzzles[1][2] == 'g' && puzzles[4][0] == 'G') ||\n\t\t\t\t\t(puzzles[1][2] == 'b' && puzzles[4][0] == 'B') ||\n\t\t\t\t\t(puzzles[1][2] == 'w' && puzzles[4][0] == 'W') ||\n\t\t\t\t\t(puzzles[1][2] == 'R' && puzzles[4][0] == 'r') ||\n\t\t\t\t\t(puzzles[1][2] == 'G' && puzzles[4][0] == 'g') ||\n\t\t\t\t\t(puzzles[1][2] == 'B' && puzzles[4][0] == 'b') ||\n\t\t\t\t\t(puzzles[1][2] == 'W' && puzzles[4][0] == 'w')) {\n\t\t\t\tif(puzzles[3][1] == 'r' && puzzles[4][3] == 'R')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[3][1] == 'g' && puzzles[4][3] == 'G')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[3][1] == 'b' && puzzles[4][3] == 'B')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[3][1] == 'w' && puzzles[4][3] == 'W')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[3][1] == 'R' && puzzles[4][3] == 'r')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[3][1] == 'G' && puzzles[4][3] == 'g')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[3][1] == 'B' && puzzles[4][3] == 'b')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[3][1] == 'W' && puzzles[4][3] == 'w')\n\t\t\t\t\tresult = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tif((puzzles[2][2] == 'r' && puzzles[5][0] == 'R') ||\n\t\t\t\t\t(puzzles[2][2] == 'g' && puzzles[5][0] == 'G') ||\n\t\t\t\t\t(puzzles[2][2] == 'b' && puzzles[5][0] == 'B') ||\n\t\t\t\t\t(puzzles[2][2] == 'w' && puzzles[5][0] == 'W') ||\n\t\t\t\t\t(puzzles[2][2] == 'R' && puzzles[5][0] == 'r') ||\n\t\t\t\t\t(puzzles[2][2] == 'G' && puzzles[5][0] == 'g') ||\n\t\t\t\t\t(puzzles[2][2] == 'B' && puzzles[5][0] == 'b') ||\n\t\t\t\t\t(puzzles[2][2] == 'W' && puzzles[5][0] == 'w')) {\n\t\t\t\tif(puzzles[4][1] == 'r' && puzzles[5][3] == 'R')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[4][1] == 'g' && puzzles[5][3] == 'G')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[4][1] == 'b' && puzzles[5][3] == 'B')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[4][1] == 'w' && puzzles[5][3] == 'W')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[4][1] == 'R' && puzzles[5][3] == 'r')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[4][1] == 'G' && puzzles[5][3] == 'g')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[4][1] == 'B' && puzzles[5][3] == 'b')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[4][1] == 'W' && puzzles[5][3] == 'w')\n\t\t\t\t\tresult = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tif(puzzles[3][2] == 'r') {\n\t\t\t\tif(puzzles[6][0] == 'R')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[3][2] == 'g') {\n\t\t\t\tif(puzzles[6][0] == 'G')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[3][2] == 'b') {\n\t\t\t\tif(puzzles[6][0] == 'B')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[3][2] == 'w') {\n\t\t\t\tif(puzzles[6][0] == 'W')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[3][2] == 'R') {\n\t\t\t\tif(puzzles[6][0] == 'r')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[3][2] == 'G') {\n\t\t\t\tif(puzzles[6][0] == 'g')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[3][2] == 'B') {\n\t\t\t\tif(puzzles[6][0] == 'b')\n\t\t\t\t\tresult = true;\n\t\t\t}else if(puzzles[3][2] == 'W') {\n\t\t\t\tif(puzzles[6][0] == 'w')\n\t\t\t\t\tresult = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tif((puzzles[4][2] == 'r' && puzzles[7][0] == 'R') ||\n\t\t\t\t\t(puzzles[4][2] == 'g' && puzzles[7][0] == 'G') ||\n\t\t\t\t\t(puzzles[4][2] == 'b' && puzzles[7][0] == 'B') ||\n\t\t\t\t\t(puzzles[4][2] == 'w' && puzzles[7][0] == 'W') ||\n\t\t\t\t\t(puzzles[4][2] == 'R' && puzzles[7][0] == 'r') ||\n\t\t\t\t\t(puzzles[4][2] == 'G' && puzzles[7][0] == 'g') ||\n\t\t\t\t\t(puzzles[4][2] == 'B' && puzzles[7][0] == 'b') ||\n\t\t\t\t\t(puzzles[4][2] == 'W' && puzzles[7][0] == 'w')) {\n\t\t\t\tif(puzzles[6][1] == 'r' && puzzles[7][3] == 'R')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[6][1] == 'g' && puzzles[7][3] == 'G')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[6][1] == 'b' && puzzles[7][3] == 'B')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[6][1] == 'w' && puzzles[7][3] == 'W')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[6][1] == 'R' && puzzles[7][3] == 'r')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[6][1] == 'G' && puzzles[7][3] == 'g')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[6][1] == 'B' && puzzles[7][3] == 'b')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[6][1] == 'W' && puzzles[7][3] == 'w')\n\t\t\t\t\tresult = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif((puzzles[5][2] == 'r' && puzzles[8][0] == 'R') ||\n\t\t\t\t\t(puzzles[5][2] == 'g' && puzzles[8][0] == 'G') ||\n\t\t\t\t\t(puzzles[5][2] == 'b' && puzzles[8][0] == 'B') ||\n\t\t\t\t\t(puzzles[5][2] == 'w' && puzzles[8][0] == 'W') ||\n\t\t\t\t\t(puzzles[5][2] == 'R' && puzzles[8][0] == 'r') ||\n\t\t\t\t\t(puzzles[5][2] == 'G' && puzzles[8][0] == 'g') ||\n\t\t\t\t\t(puzzles[5][2] == 'B' && puzzles[8][0] == 'b') ||\n\t\t\t\t\t(puzzles[5][2] == 'W' && puzzles[8][0] == 'w')) {\n\t\t\t\tif(puzzles[7][1] == 'r' && puzzles[8][3] == 'R')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[7][1] == 'g' && puzzles[8][3] == 'G')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[7][1] == 'b' && puzzles[8][3] == 'B')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[7][1] == 'w' && puzzles[8][3] == 'W')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[7][1] == 'R' && puzzles[8][3] == 'r')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[7][1] == 'G' && puzzles[8][3] == 'g')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[7][1] == 'B' && puzzles[8][3] == 'b')\n\t\t\t\t\tresult = true;\n\t\t\t\telse if(puzzles[7][1] == 'W' && puzzles[8][3] == 'w')\n\t\t\t\t\tresult = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static void rotate(int position) {\n\t\tchar[] tmp = puzzles[position];\n\t\tchar tm = tmp[0];\n\t\tfor(int i=1 ; i<tmp.length ; i++) {\n\t\t\ttmp[i-1] = tmp[i];\n\t\t}\n\t\ttmp[tmp.length-1] = tm;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tHashMap<C,C> pass;\n\tint ans;\n\tString [][] data;\n\tchar [][] map;\n\tString [] store;\n\tboolean [] used;\n\tHashMap<Character, Character> change;\n\t\n\tclass C{\n\t\tint pos ,ind;\n\t\tpublic C(int pos, int ind) {\n\t\t\tthis.pos = pos;\tthis.ind = ind;\n\t\t}\n\t}\n\t\n\tprivate void dfs(int deep){\n\t\tif(deep == 9){\n\t\t\tans++;\n\t\t\treturn;\n\t\t}\n\t\tfor(int j = 0; j< 9; j++){\n\t\t\tif(used[j]) continue;\n\t\t\tfor(int i=0; i < 4; i++){\n\t\t\t\tstore[deep] = data[j][i];\n\t\t\t\tif(check(deep+1)){\n\t\t\t\t\tused[j] = true;\n\t\t\t\t\tdfs(deep+1);\n\t\t\t\t\tused[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ;\n\t}\n\t\n\tprivate boolean check(int deep){\n\t\tfor(C from: pass.keySet()){\n\t\t\tC to = pass.get(from);\n\t\t\tif( from.pos >= deep || from.pos <= to.pos ) continue;\n\t\t\tif(store[from.pos].charAt(from.ind) != change.get(store[to.pos].charAt(to.ind))){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t//System.out.println(store[from.pos].charAt(from.ind) +\" \"+ change.get(store[to.pos].charAt(to.ind)));\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tpass = new HashMap<C,C>();\n\t\tpassCreate();\n\t\tchange = new HashMap<Character, Character>();\n\t\tchange.put('R', 'r');\n\t\tchange.put('G', 'g');\n\t\tchange.put('B', 'b');\n\t\tchange.put('W', 'w');\n\t\tchange.put('r', 'R');\n\t\tchange.put('g', 'G');\n\t\tchange.put('b', 'B');\n\t\tchange.put('w', 'W');\n\t\twhile(n-- > 0){\n\t\t\tdata = new String[9][4];\n\t\t\tfor(int i =0; i < 9; i++){\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int j =0; j < 4; j ++){\n\t\t\t\t\tchar [] work = new char[4];\n\t\t\t\t\tfor(int k =0; k < 4; k++){\n\t\t\t\t\t\twork[k] = str.charAt((k+j) % 4);\n\t\t\t\t\t}\n\t\t\t\t\tdata[i][j] = new String(work);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//ini\n\t\t\tans = 0;\n\t\t\tmap = new char[9][9];\n\t\t\tstore = new String[9];\n\t\t\tused = new boolean[9];\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\tArrays.fill(map[i], '*');\n\t\t\t}\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate void passCreate(){\n\t\tpass.put(new C(0,1), new C(1,3));\n\t\tpass.put(new C(0,2), new C(3,0));\n\t\t\n\t\tpass.put(new C(1,3), new C(0,1));\n\t\tpass.put(new C(1,1), new C(2,3));\n\t\tpass.put(new C(1,2), new C(4,0));\n\t\t\n\t\tpass.put(new C(2,3), new C(1,1));\n\t\tpass.put(new C(2,2), new C(5,0));\n\t\t\n\t\tpass.put(new C(3,0), new C(0,2));\n\t\tpass.put(new C(3,1), new C(4,3));\n\t\tpass.put(new C(3,2), new C(6,0));\n\t\t\n\t\tpass.put(new C(4,0), new C(1,2));\n\t\tpass.put(new C(4,1), new C(5,3));\n\t\tpass.put(new C(4,2), new C(7,0));\n\t\tpass.put(new C(4,3), new C(3,1));\n\t\t\n\t\tpass.put(new C(5,0), new C(2,2));\n\t\tpass.put(new C(5,3), new C(4,1));\n\t\tpass.put(new C(5,2), new C(8,0));\n\t\t\n\t\tpass.put(new C(6,0), new C(3,2));\n\t\tpass.put(new C(6,1), new C(7,3));\n\t\t\n\t\tpass.put(new C(7,0), new C(4,2));\n\t\tpass.put(new C(7,1), new C(8,3));\n\t\tpass.put(new C(7,3), new C(6,1));\n\t\t\n\t\tpass.put(new C(8,0), new C(5,2));\n\t\tpass.put(new C(8,3), new C(7,1));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Jigsaw {\n\n\tstatic char[][] input = new char[9][4];\n\tstatic char[][] puzzles = new char[9][4];\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint cnt = Integer.parseInt(s.nextLine());\n\t\tfor(int i=0 ; i<cnt ; i++) {\n\t\t\tString[] tmp = s.nextLine().split(\" \");\n\t\t\tfor(int j=0 ; j<9 ; j++) {\n\t\t\t\tinput[j] = tmp[j].toCharArray();\n\t\t\t}\n\t\t\tboolean[] isUsed = new boolean[9];\n\t\t\tSystem.out.println(solve(0, isUsed));\n\t\t}\n\t}\n\n\tpublic static int solve(int position, boolean[] isUsed) {\n\t\tif(position == 9)\n\t\t\treturn 1;\n\t\tint cnt = 0;\n\t\tfor(int i=0 ; i<9 ; i++) {\n\t\t\t// ??¢???????±?????????????????????????????????´???\n\t\t\tif(isUsed[i])\n\t\t\t\tcontinue;\n\t\t\tchar[] puzzle = input[i];\n\t\t\tpuzzles[position] = puzzle;\n\t\t\tfor(int j=0 ; j<4 ; j++) {\n\t\t\t\tif(check(position)) {\n\t\t\t\t\tisUsed[i] = true;\n\t\t\t\t\tcnt += solve(position+1, isUsed);\n\t\t\t\t\tisUsed[i] = false;\n\t\t\t\t}\n\t\t\t\trotate(position);\n\t\t\t}\n\t\t}\n\t\tpuzzles[position] = null;\n\t\treturn cnt;\n\t}\n\n\tpublic static boolean check(int position) {\n\t\tboolean result = false;\n\t\treturn result;\n\t}\n\n\tpublic static void rotate(int position) {\n\t\tchar[] tmp = puzzles[position];\n\t\tchar tm = tmp[0];\n\t\tfor(int i=1 ; i<tmp.length ; i++) {\n\t\t\ttmp[i-1] = tmp[i];\n\t\t}\n\t\ttmp[tmp.length-1] = tm;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main{\n    String[][] puzzle;\n    String[][] field; \n    boolean[] used;\n    void run(){\n\tScanner sc=new Scanner(System.in);\n\tint n=sc.nextInt();\n\tfor(int attend=0;attend<n;attend++){\n\t    field =new String[3][3];\n\t    puzzle=new String[9][4];\n\t    used=new boolean[9];\n\t    for(int i=0;i<9;i++){\n\t\tsetPuzzle(i,sc.next());\n\t    }\n\t    System.out.println(dfs(0));\n\t}\n    }\n    void setPuzzle(int num,String pu){\n\tfor(int i=0;i<4;i++){\n\t    puzzle[num][i]=pu.substring(i,pu.length())+pu.substring(0,i);\n\t}\n    }\n    int dfs(int step){\n\tif(step==9) return 1;\n\tint ans=0;\n\tfor(int i=0;i<9;i++){\n\t    if(used[i]==true)continue;\n\t    for(int j=0;j<4;j++){\n\t\tif(step>2){\n\t\t    if(!puzzleCompare(field[step/3-1][step%3].charAt(2),puzzle[i][j].charAt(0)))continue;\n\t\t}\n\t\tif(step%3!=0){\n\t\t    if(!puzzleCompare(field[step/3][step%3-1].charAt(3),puzzle[i][j].charAt(1)))continue;\n\t\t}\n\t\tfield[step/3][step%3]=puzzle[i][j];\n\t\tused[i]=true;\n\t\tans+=dfs(step+1);\n\t\tused[i]=false;\n\t    }\n\t}\n\treturn ans;\n    }\n    boolean puzzleCompare(char puz1,char puz2){\n\tif(puz1-'a'+'A'==puz2)return true;\n\telse if(puz2-'a'+'A'==puz1)return true;\n\telse return false;\n    }\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public string via { get; set; }\n    public string via2 { get; set; }\n}\n\npublic class hello\n{\n    public static void Main()\n    {\n        var d = new Dictionary<char, int>()\n        { { 'R', 1 }, { 'r', -1 }, { 'G', 2 }, { 'g', -2 }, { 'B', 3 }, { 'b', -3 }, { 'W', 4 }, { 'w', -4 } };\n        var n = int.Parse(Console.ReadLine().Trim());\n        var z = 0;\n        while (z++ < n)\n        {\n            var ps = new int[9, 4, 4];\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            for (int i = 0; i < 9; i++)\n            {\n                var t = line[i];\n                for (int j = 0; j < 4; j++) ps[i, 0, j] = d[t[j]];\n            }\n            getPs(ps);\n            getAns(ps);\n        }\n    }\n    static void getAns(int[,,] ps)\n    {\n        var ans = 0;\n        var q = new Queue<P>();\n        for (int i = 0; i < 9; i++)\n            for (int j = 0; j < 4; j++)\n                q.Enqueue(new P { via = i.ToString(), via2 = j.ToString() });\n        while (q.Count() > 0)\n        {\n            var w = q.Dequeue();\n            if (w.via.Length == 9) { ans++; continue; }\n            for (int i = 0; i < 9; i++)\n                for (int j = 0; j < 4; j++)\n                    if (!w.via.Contains(i.ToString()) && check(ps, w.via, w.via2, i, j))\n                        q.Enqueue(new P { via = w.via + i.ToString(), via2 = w.via2 + j.ToString() });\n        }\n        Console.WriteLine(ans);\n    }\n    static bool check(int[,,] ps, string via, string via2, int i, int j)\n    {\n        var vL = via.Length;\n        if (vL == 1 | vL == 2)\n        {\n            var t = ps[via[vL - 1] - '0', via2[vL - 1] - '0', 1];\n            return ps[i, j, 3] + t == 0;\n        }\n        else if (vL == 3)\n        {\n            var t = ps[via[0] - '0', via2[0] - '0', 2];\n            return ps[i, j, 0] + t == 0;\n        }\n        else if (vL == 6)\n        {\n            var t = ps[via[3] - '0', via2[3] - '0', 2];\n            return ps[i, j, 0] + t == 0;\n        }\n        else\n        {\n            var t = ps[via[vL - 3] - '0', via2[vL - 3] - '0', 2];\n            var t2 = ps[via[vL - 1] - '0', via2[vL - 1] - '0', 1];\n            return (ps[i, j, 0] + t == 0) && (ps[i, j, 3] + t2 == 0);\n        }\n    }\n    static void getPs(int[,,] ps)\n    {\n        for (int i = 0; i < 9; i++)\n        {\n            ps[i, 1, 0] = ps[i, 0, 3];\n            ps[i, 1, 1] = ps[i, 0, 0];\n            ps[i, 1, 2] = ps[i, 0, 1];\n            ps[i, 1, 3] = ps[i, 0, 2];\n\n            ps[i, 2, 0] = ps[i, 0, 2];\n            ps[i, 2, 1] = ps[i, 0, 3];\n            ps[i, 2, 2] = ps[i, 0, 0];\n            ps[i, 2, 3] = ps[i, 0, 1];\n\n            ps[i, 3, 0] = ps[i, 0, 1];\n            ps[i, 3, 1] = ps[i, 0, 2];\n            ps[i, 3, 2] = ps[i, 0, 3];\n            ps[i, 3, 3] = ps[i, 0, 0];\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public string via { get; set; }\n    public string via2 { get; set; }\n}\n\npublic class hello\n{\n    public static void Main()\n    {\n        var d = new Dictionary<char, int>()\n        { { 'R', 1 }, { 'r', -1 }, { 'G', 2 }, { 'g', -2 }, { 'B', 3 }, { 'b', -3 }, { 'W', 4 }, { 'w', -4 } };\n        var n = int.Parse(Console.ReadLine().Trim());\n        var z = 0;\n        while (z++ < n)\n        {\n            var ps = new int[9, 4, 4];\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            for (int i = 0; i < 9; i++)\n            {\n                var t = line[i];\n                for (int j = 0; j < 4; j++) ps[i, 0, j] = d[t[j]];\n            }\n            getPs(ps);\n            getAns(ps);\n        }\n    }\n    static void getAns(int[,,] ps)\n    {\n        var ans = 0;\n        var st = new Stack<P>();\n        for (int i = 0; i < 9; i++)\n            for (int j = 0; j < 4; j++)\n                st.Push(new P { via = i.ToString(), via2 = j.ToString() });\n        while (st.Count() > 0)\n        {\n            var w = st.Pop();\n            if (w.via.Length == 9) { ans++; continue; }\n            for (int i = 0; i < 9; i++)\n            {\n                if (!w.via.Contains(i.ToString()))\n                {\n                    for (int j = 0; j < 4; j++)\n                        if (check(ps, w.via, w.via2, i, j))\n                            st.Push(new P { via = w.via + i.ToString(), via2 = w.via2 + j.ToString() });\n                }\n            }\n        }\n        Console.WriteLine(ans);\n    }\n    static bool check(int[,,] ps, string via, string via2, int i, int j)\n    {\n        var vL = via.Length;\n        if (vL == 1 | vL == 2)\n        {\n            var t = ps[via[vL - 1] - '0', via2[vL - 1] - '0', 1];\n            return ps[i, j, 3] + t == 0;\n        }\n        else if (vL == 3 | vL == 6)\n        {\n            var t = ps[via[vL - 3] - '0', via2[vL - 3] - '0', 2];\n            return ps[i, j, 0] + t == 0;\n        }\n        else\n        {\n            var t = ps[via[vL - 3] - '0', via2[vL - 3] - '0', 2];\n            var t2 = ps[via[vL - 1] - '0', via2[vL - 1] - '0', 1];\n            return (ps[i, j, 0] + t == 0) && (ps[i, j, 3] + t2 == 0);\n        }\n    }\n    static void getPs(int[,,] ps)\n    {\n        for (int i = 0; i < 9; i++)\n        {\n            ps[i, 1, 0] = ps[i, 0, 3];\n            ps[i, 1, 1] = ps[i, 0, 0];\n            ps[i, 1, 2] = ps[i, 0, 1];\n            ps[i, 1, 3] = ps[i, 0, 2];\n\n            ps[i, 2, 0] = ps[i, 0, 2];\n            ps[i, 2, 1] = ps[i, 0, 3];\n            ps[i, 2, 2] = ps[i, 0, 0];\n            ps[i, 2, 3] = ps[i, 0, 1];\n\n            ps[i, 3, 0] = ps[i, 0, 1];\n            ps[i, 3, 1] = ps[i, 0, 2];\n            ps[i, 3, 2] = ps[i, 0, 3];\n            ps[i, 3, 3] = ps[i, 0, 0];\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public string via { get; set; }\n    public string via2 { get; set; }\n}\n\npublic class hello\n{\n    public static void Main()\n    {\n        var d = new Dictionary<char, int>()\n        { { 'R', 1 }, { 'r', -1 }, { 'G', 2 }, { 'g', -2 }, { 'B', 3 }, { 'b', -3 }, { 'W', 4 }, { 'w', -4 } };\n        var n = int.Parse(Console.ReadLine().Trim());\n        var z = 0;\n        while (z++ < n)\n        {\n            var ps = new int[9, 4, 4];\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            for (int i = 0; i < 9; i++)\n            {\n                var t = line[i];\n                for (int j = 0; j < 4; j++) ps[i, 0, j] = d[t[j]];\n            }\n            getPs(ps);\n            getAns(ps);\n        }\n    }\n    static void getAns(int[,,] ps)\n    {\n        var ans = 0;\n        var st = new Stack<P>();\n        for (int i = 0; i < 9; i++)\n            for (int j = 0; j < 4; j++)\n                st.Push(new P { via = i.ToString(), via2 = j.ToString() });\n        while (st.Count() > 0)\n        {\n            var w = st.Pop();\n            if (w.via.Length == 9) { ans++; continue; }\n            for (int i = 0; i < 9; i++)\n                for (int j = 0; j < 4; j++)\n                    if (!w.via.Contains(i.ToString()) && check(ps, w.via, w.via2, i, j))\n                        st.Push(new P { via = w.via + i.ToString(), via2 = w.via2 + j.ToString() });\n        }\n        Console.WriteLine(ans);\n    }\n    static bool check(int[,,] ps, string via, string via2, int i, int j)\n    {\n        var vL = via.Length;\n        if (vL == 1 | vL == 2)\n        {\n            var t = ps[via[vL - 1] - '0', via2[vL - 1] - '0', 1];\n            return ps[i, j, 3] + t == 0;\n        }\n        else if (vL == 3)\n        {\n            var t = ps[via[0] - '0', via2[0] - '0', 2];\n            return ps[i, j, 0] + t == 0;\n        }\n        else if (vL == 6)\n        {\n            var t = ps[via[3] - '0', via2[3] - '0', 2];\n            return ps[i, j, 0] + t == 0;\n        }\n        else\n        {\n            var t = ps[via[vL - 3] - '0', via2[vL - 3] - '0', 2];\n            var t2 = ps[via[vL - 1] - '0', via2[vL - 1] - '0', 1];\n            return (ps[i, j, 0] + t == 0) && (ps[i, j, 3] + t2 == 0);\n        }\n    }\n    static void getPs(int[,,] ps)\n    {\n        for (int i = 0; i < 9; i++)\n        {\n            ps[i, 1, 0] = ps[i, 0, 3];\n            ps[i, 1, 1] = ps[i, 0, 0];\n            ps[i, 1, 2] = ps[i, 0, 1];\n            ps[i, 1, 3] = ps[i, 0, 2];\n\n            ps[i, 2, 0] = ps[i, 0, 2];\n            ps[i, 2, 1] = ps[i, 0, 3];\n            ps[i, 2, 2] = ps[i, 0, 0];\n            ps[i, 2, 3] = ps[i, 0, 1];\n\n            ps[i, 3, 0] = ps[i, 0, 1];\n            ps[i, 3, 1] = ps[i, 0, 2];\n            ps[i, 3, 2] = ps[i, 0, 3];\n            ps[i, 3, 3] = ps[i, 0, 0];\n        }\n    }\n}\n"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nN = 3\nNN = N * N\n\nMCHARS = [['R', 'r'], ['G', 'g'], ['B', 'b'], ['W', 'w']]\n\n### subroutines\n\ndef count_rec(x, y)\n  return 1 if y >= N\n\n  x0 = x + 1\n  y0 = y\n  if x0 >= N\n    x0 = 0\n    y0 += 1\n  end\n\n  id = y * N + x\n  count = 0\n\n  for i in (0...NN)\n    next if $used[i]\n\n    for pc in $pcs[i]\n      next if x > 0 && $matches[$grds[id - 1][1]][pc[3]].nil?\n      next if y > 0 && $matches[$grds[id - N][2]][pc[0]].nil?\n\n      $used[i] = true\n      $grds[id] = pc\n\n      count += count_rec(x0, y0)\n\n      $used[i] = false\n    end\n  end\n\n  count\nend\n\n### main\n\n$matches = {}\nfor mch in MCHARS\n  c0, c1 = mch\n  $matches[c0] = {c1 => true}\n  $matches[c1] = {c0 => true}\nend\n\nn = gets.to_i\n\nn.times do\n  $pcs = []\n  for pc in gets.strip.split\n    pns = pc.split('')\n    rots = [pns.clone]\n    for i in (1..3)\n      rots << pns.rotate(i)\n    end\n    $pcs << rots\n  end\n  #p $pcs\n\n  $used = NN.times.map{false}\n  $grds = []\n\n  c = count_rec(0, 0)\n  puts c\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport core.bitop;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nconst dy = [-1, 0, 1, 0],\n      dx = [0, 1, 0, -1];\n\nstring[] P;\nvoid input() {\n    P = readln.chomp.split(\" \").array;\n}\nvoid solve() {\n    int Ans = 0;\n    string[] X = new string[9];\n    bool check(int y, int x) {\n        for (int i = 0, k = 3; i < 2; i++, k = (k + 1) % 4) {\n            int ny = y + dy[k],\n                nx = x + dx[k];\n            if (ny < 0 || ny >= 3) continue;\n            if (nx < 0 || nx >= 3) continue;\n            //writeln([y, x], \" \", [ny, nx]);\n            char a = X[y * 3 + x][k],\n                 b = X[ny * 3 + nx][(k + 2) % 4];\n            if (a == b || std.ascii.toUpper(a) != std.ascii.toUpper(b)) return false;\n        }\n        return true;\n    }\n\n    string rotate(in string s) {\n        return s[3] ~ s[0 .. 3];\n    }\n\n    void dfs(int v, int used) {\n        //writefln(\"%d: %09b\", v, used);\n        if (v == 9) {\n            Ans++;\n            return;\n        }\n\n        int y = v / 3,\n            x = v % 3;\n\n        foreach (i; 0 .. 9) {\n            if (used & (1 << i)) continue;\n            X[v] = P[i];\n            //writeln(X[v], \" \", rotate(X[v]));\n            for (int k = 0; k < 4; k++, X[v] = rotate(X[v])) {\n                if (check(y, x)) {\n                    dfs(v + 1, used | (1 << i));\n                }\n            }\n        }\n\n    }\n    dfs(0, 0);\n    writeln(Ans);\n}\n\nvoid main() {\n    int N;\n    scanf(\"%d\\n\", &N);\n    foreach (i; 0 .. N) {\n        input; solve;\n    }\n}"
  },
  {
    "language": "Python",
    "code": "p_ch = [True] * 9\nrot = ((0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2))\nadj = ['c'] * 13\n\n# record indices of right and botoom adjacent edge label. 12 is invalid.\nrec_adj = [[0, 2], [1, 3], [12, 4], [5, 7], [6, 8], [12, 9], [10, 12],\n           [11, 12], [12, 12]]\n\n# refernce indices to top and left adjacent edge label. 12 is invalid.\nref_adj = [[12, 12], [12, 0], [12, 1], [2, 12], [3, 5], [4, 6], [7, 12],\n           [8, 10], [9, 11]]\n\ntr = dict(zip(\"RGBWrgbw\", \"rgbwRGBW\"))\n\ndef dfs(i = 0, a = []):\n    if i == 9:\n        global ans\n        ans += 1\n    else:\n        for j, p in enumerate(pieces):\n            if p_ch[j]:\n                ati, ali = ref_adj[i]\n                for t, r, b, l in rot:\n                    if ati == 12 or tr[p[t]] == adj[ati]:\n                        if ali == 12 or tr[p[l]] == adj[ali]:\n                            ari, abi = rec_adj[i]\n                            adj[ari] = p[r]\n                            adj[abi] = p[b]\n                            p_ch[j] = False\n                            dfs(i + 1)\n                            p_ch[j] = True\n\nfrom sys import stdin\nfile_input = stdin\n\nN = int(file_input.readline())\n\nfor line in file_input:\n    pieces = line.split()\n    ans = 0\n    dfs()\n    print(ans)\n"
  },
  {
    "language": "Rust",
    "code": "use std::ascii::AsciiExt;\nuse std::ops::DivAssign;\nuse std::ops::MulAssign;\nuse std::ops::SubAssign;\nuse std::collections::BinaryHeap;\nuse std::str::FromStr;\nuse std::collections::HashSet;\nuse std::collections::BTreeMap;\nuse std::fmt::Display;\nuse std::ops::Neg;\nuse std::ops::Div;\nuse std::ops::Mul;\nuse std::ops::Add;\nuse std::ops::{AddAssign, Sub};\nuse std::cmp::max;\nuse std::collections::VecDeque;\nuse std::cmp::min;\nuse std::collections::{HashMap, BTreeSet};\nuse std::cmp::Ordering;\nuse std::fmt::Debug;\n\nfn read_line() -> String {\n    let mut buffer = String::new();\n    std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n    buffer.trim().to_owned()\n}\nfn read_lines<T: std::str::FromStr>(count: usize) -> Vec<T> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(buffer.trim().parse().ok().expect(\"Can't Parse\"));\n        buffer.clear();\n    }\n    vec\n}\nfn read_tabulate<R, T: Fn(&str)->R> (count: usize, transformer: T) -> Vec<R> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(transformer(buffer.trim()));\n        buffer.clear();\n    }\n    vec\n}\nfn read_value<T: std::str::FromStr>() -> T {\n    read_line().trim().parse().ok().unwrap()\n}\nfn read_values<T: std::str::FromStr>() -> Vec<T> {\n    read_line().trim().split_whitespace().map(|x| x.parse().ok().expect(\"Can't Parse\")).collect::<Vec<T>>()\n}\nmacro_rules! freeze {\n    ($($id:ident), *) => {\n        $(let $id = $id;)*\n    };\n}\nmacro_rules! read_map {\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n}\nmacro_rules! read {\n    (mut $ident: ident: String) => {\n        let mut $ident = read_value::<String>();\n    };\n    ($ident: ident: String) => {\n        let $ident = read_value::<String>();\n    };\n    (mut $ident: ident: [$ty:ty]) => {\n        let mut $ident = read_values::<$ty>();\n    };\n    ($ident: ident: [$ty:ty]) => {\n        let $ident = read_values::<$ty>();\n    };\n    (mut $ident: ident: [[$ty:ty]; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    ($ident: ident: [[$ty:ty]; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$ty:ty; $size:expr]) => {\n        let mut $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$ty:ty; $size:expr]) => {\n        let $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    ($($token: tt)*) => {\n        let mut iter = read_values::<String>().into_iter();\n        read_from_iter!(iter; $($token)*);\n    };\n}\nmacro_rules! read_from_iter {\n    ($iter:expr; mut $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; mut $ident:ident:$ty:ty) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter:expr; $ident:ident:$ty:ty) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter: expr; ) => {};\n}\nstruct KeyValue<K, V> {\n    key: K,\n    value: V\n}\nimpl <K: PartialOrd, V> PartialEq for KeyValue<K, V> {\n    fn eq(&self, other: &Self) -> bool {\n        self.key.eq(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Eq for KeyValue<K, V> {}\nimpl <K: PartialOrd, V> PartialOrd for KeyValue<K, V> {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        self.key.partial_cmp(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Ord for KeyValue<K, V> {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.key.partial_cmp(&other.key).ok_or(\"Can't Compare\").unwrap()\n    }\n}\n#[derive(Copy, Clone, Debug)]\nstruct Position {\n    x: i32, y: i32\n}\nimpl Position {\n    fn neighbor(&self) -> Vec<Position> {\n        vec![(-1, 0), (0, -1)].into_iter().map(|(dx, dy)| Position{x: self.x + dx, y: self.y + dy} ).filter(|p| 0 <= p.x && p.x < 3 && 0 <= p.y && p.y < 3).collect()\n    }\n}\nimpl Sub for Position {\n    type Output = Position;\n    fn sub(self, rhs: Position) -> <Self as std::ops::Sub<Position>>::Output { \n        Position{x: self.x - rhs.x, y: self.y - rhs.y}\n    }\n}\n\n#[derive(Clone, Debug)]\nstruct Piece {\n    chars: Vec<char>\n}\nimpl FromStr for Piece {\n    type Err = ();\n    fn from_str(s: &str) -> std::result::Result<Self, <Self as std::str::FromStr>::Err> { \n        if s.len() != 4 || s.chars().any(|c| !\"rgbw\".contains(c.to_ascii_lowercase())) {\n            Err(())\n        }else {\n            Ok(Piece{chars: s.chars().collect()})\n        }\n    }\n}\n#[derive(Debug)]\nstruct Placed<'a> {\n    piece: &'a Piece,\n    position: Position,\n    rotate: usize\n}\nimpl <'a> Placed<'a> {\n    fn up(&self) -> char {\n        self.piece.chars[self.rotate & 3]\n    }\n    fn right(&self) -> char {\n        self.piece.chars[(self.rotate + 1) & 3]\n    }\n    fn down(&self) -> char {\n        self.piece.chars[(self.rotate + 2) & 3]\n    }\n    fn left(&self) -> char {\n        self.piece.chars[(self.rotate + 3) & 3]\n    }\n    fn is_match<'b>(&self, other: &Placed<'b>) -> bool {\n        match self.position - other.position {\n            Position{x: -1, y: 0} => Placed::can_face(self.right(), other.left()),\n            Position{x: 1, y: 0} => Placed::can_face(self.left(), other.right()),\n            Position{x: 0, y: 1} => Placed::can_face(self.up(), other.down()),\n            Position{x: 0, y: -1} => Placed::can_face(self.down(), other.up()),\n            _ => panic!()\n        }\n    }\n    fn can_face(a: char, b: char) -> bool {\n        a != b && AsciiExt::to_ascii_uppercase(&a) == AsciiExt::to_ascii_uppercase(&b)\n    }\n}\nfn put<'a>(pieces: &'a Vec<Piece>, state: &mut Vec<Placed<'a>>, used: &mut Vec<bool>) -> i32 {\n    if state.len() == 9 {\n        return 1;\n    }\n    let current = Position{x: state.len() as i32 % 3, y: state.len() as i32 / 3};\n    let neighbor = current.neighbor();\n    let mut count = 0;\n    for i in 0 .. pieces.len() {\n        if used[i] {continue;}\n        for r in 0 .. 4 {\n            let placed = Placed{piece: &pieces[i], position: current, rotate: r};\n            if neighbor.iter().any(|pos| !state[pos.x as usize + (pos.y * 3) as usize].is_match(&placed)) {continue;}\n            used[i] = true;\n            state.push(placed);\n            count += put(pieces, state, used);\n            state.pop();\n            used[i] = false;\n        }\n    }\n    count\n}\n\nfn main() {\n    read!(n: usize);\n    let mut used = vec![false; 9];\n    for _ in 0 .. n {\n        read!(pieces: [Piece]);\n        let mut state = Vec::with_capacity(9);\n        println!(\"{}\", put(&pieces, &mut state, &mut used));\n    }\n}\n"
  }
]