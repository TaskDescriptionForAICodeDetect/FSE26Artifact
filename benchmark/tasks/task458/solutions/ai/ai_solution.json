[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_NODES 100\n#define MAX_EDGES 1000\n\ntypedef struct {\n    int from, to, value;\n} Edge;\n\nint n, m;\nEdge edges[MAX_EDGES];\nint graph[MAX_NODES][MAX_NODES];\nbool used[MAX_EDGES];\n\nint gaussian_elimination(int matrix[MAX_NODES][MAX_NODES], int rows, int cols) {\n    int rank = 0;\n    for (int col = 0; col < cols; col++) {\n        for (int row = rank; row < rows; row++) {\n            if (matrix[row][col]) {\n                for (int k = 0; k < cols; k++) {\n                    int temp = matrix[rank][k];\n                    matrix[rank][k] = matrix[row][k];\n                    matrix[row][k] = temp;\n                }\n                break;\n            }\n        }\n        \n        if (!matrix[rank][col]) continue;\n        \n        for (int row = 0; row < rows; row++) {\n            if (row != rank && matrix[row][col]) {\n                for (int k = col; k < cols; k++) {\n                    matrix[row][k] ^= matrix[rank][k];\n                }\n            }\n        }\n        rank++;\n    }\n    return rank;\n}\n\nint solve() {\n    int matrix[MAX_NODES][MAX_EDGES] = {0};\n    \n    for (int i = 0; i < m; i++) {\n        matrix[edges[i].from][i] = 1;\n        matrix[edges[i].to][i] = -1;\n    }\n    \n    int rank = gaussian_elimination(matrix, n, m);\n    \n    int unnecessary_edges = m - rank;\n    return unnecessary_edges;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    \n    while (t--) {\n        scanf(\"%d %d\", &n, &m);\n        \n        for (int i = 0; i < m; i++) {\n            scanf(\"%d %d %d\", &edges[i].from, &edges[i].to, &edges[i].value);\n            edges[i].from--;\n            edges[i].to--;\n        }\n        \n        printf(\"%d\\n\", solve());\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:45:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int u, v, w;\n} Edge;\n\nint parent[1000];\n\nint find(int u) {\n    if (parent[u] != u) {\n        parent[u] = find(parent[u]);\n    }\n    return parent[u];\n}\n\nvoid union_sets(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u != v) {\n        parent[v] = u;\n    }\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n, m;\n        scanf(\"%d %d\", &n, &m);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n        for (int i = 0; i < m; i++) {\n            int u, v, w;\n            scanf(\"%d %d %d\", &u, &v, &w);\n            union_sets(u, v);\n        }\n        int components = 0;\n        for (int i = 0; i < n; i++) {\n            if (find(i) == i) {\n                components++;\n            }\n        }\n        printf(\"%d\\n\", m - n + components);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:46:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct DSU {\n    vector<int> parent, rank;\n    DSU(int n) : parent(n), rank(n, 0) {\n        for (int i = 0; i < n; ++i)\n            parent[i] = i;\n    }\n    int find(int u) {\n        if (parent[u] != u)\n            parent[u] = find(parent[u]);\n        return parent[u];\n    }\n    void unite(int u, int v) {\n        u = find(u), v = find(v);\n        if (u == v) return;\n        if (rank[u] < rank[v])\n            parent[u] = v;\n        else {\n            parent[v] = u;\n            if (rank[u] == rank[v])\n                rank[u]++;\n        }\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int T;\n    cin >> T;\n    while (T--) {\n        int N, M;\n        cin >> N >> M;\n        DSU dsu(N);\n        for (int i = 0; i < M; ++i) {\n            int u, v;\n            cin >> u >> v;\n            dsu.unite(u - 1, v - 1);\n        }\n        int components = 0;\n        for (int i = 0; i < N; ++i) {\n            if (dsu.find(i) == i)\n                components++;\n        }\n        cout << M - N + components << '\\n';\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:46:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            int n = scanner.nextInt();\n            int m = scanner.nextInt();\n            if (n == 0 && m == 0) break;\n            \n            UnionFind uf = new UnionFind(n);\n            for (int i = 0; i < m; i++) {\n                int u = scanner.nextInt() - 1;\n                int v = scanner.nextInt() - 1;\n                uf.union(u, v);\n            }\n            \n            System.out.println(m - uf.count + n);\n        }\n        scanner.close();\n    }\n    \n    static class UnionFind {\n        int[] parent;\n        int[] rank;\n        int count;\n        \n        UnionFind(int size) {\n            parent = new int[size];\n            rank = new int[size];\n            count = size;\n            for (int i = 0; i < size; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n        \n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            if (rootX != rootY) {\n                if (rank[rootX] > rank[rootY]) {\n                    parent[rootY] = rootX;\n                } else if (rank[rootX] < rank[rootY]) {\n                    parent[rootX] = rootY;\n                } else {\n                    parent[rootY] = rootX;\n                    rank[rootX]++;\n                }\n                count--;\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:46:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class FlowEdgeRecovery {\n    static class Edge {\n        int from, to, value;\n        Edge(int from, int to, int value) {\n            this.from = from;\n            this.to = to;\n            this.value = value;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int testCases = Integer.parseInt(br.readLine());\n\n        for (int t = 0; t < testCases; t++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int m = Integer.parseInt(st.nextToken());\n\n            List<Edge> edges = new ArrayList<>();\n            int[] inDegree = new int[n + 1];\n            int[] outDegree = new int[n + 1];\n\n            for (int i = 0; i < m; i++) {\n                st = new StringTokenizer(br.readLine());\n                int u = Integer.parseInt(st.nextToken());\n                int v = Integer.parseInt(st.nextToken());\n                int w = Integer.parseInt(st.nextToken());\n\n                edges.add(new Edge(u, v, w));\n                outDegree[u]++;\n                inDegree[v]++;\n            }\n\n            int minEdgesToRemove = calculateMinEdges(n, edges, inDegree, outDegree);\n            System.out.println(minEdgesToRemove);\n        }\n    }\n\n    private static int calculateMinEdges(int n, List<Edge> edges, int[] inDegree, int[] outDegree) {\n        int[] flowConservation = new int[n + 1];\n        \n        for (Edge edge : edges) {\n            flowConservation[edge.from] -= edge.value;\n            flowConservation[edge.to] += edge.value;\n        }\n\n        Set<Integer> nodesWithFlow = new HashSet<>();\n        for (int i = 1; i <= n; i++) {\n            if (flowConservation[i] != 0) {\n                nodesWithFlow.add(i);\n            }\n        }\n\n        int minEdgesToRemove = 0;\n        for (int node : nodesWithFlow) {\n            if (inDegree[node] + outDegree[node] > 1) {\n                minEdgesToRemove++;\n            }\n        }\n\n        return minEdgesToRemove;\n    }\n}",
    "timestamp": "2025-08-05 21:46:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findMinEdgesNeeded(int n, vector<vector<int>>& edges) {\n        vector<vector<int>> graph(n);\n        vector<int> inDegree(n, 0);\n        vector<int> outDegree(n, 0);\n        \n        for (const auto& edge : edges) {\n            int u = edge[0], v = edge[1], val = edge[2];\n            graph[u].push_back({v, val});\n            outDegree[u]++;\n            inDegree[v]++;\n        }\n        \n        int minEdges = 0;\n        for (int i = 0; i < n; i++) {\n            if (inDegree[i] == 0 || outDegree[i] == 0) {\n                minEdges++;\n            }\n        }\n        \n        return minEdges;\n    }\n};\n\nint main() {\n    int t;\n    cin >> t;\n    \n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        \n        vector<vector<int>> edges(m);\n        for (int i = 0; i < m; i++) {\n            int u, v, val;\n            cin >> u >> v >> val;\n            edges[i] = {u, v, val};\n        }\n        \n        Solution sol;\n        int result = sol.findMinEdgesNeeded(n, edges);\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:47:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_flow_conservation(test_cases):\n    results = []\n\n    for nodes, edges, edge_list in test_cases:\n        if nodes == 0 or edges == 0:\n            results.append(0)\n            continue\n\n        in_degree = [0] * nodes\n        out_degree = [0] * nodes\n\n        for u, v, value in edge_list:\n            out_degree[u] += 1\n            in_degree[v] += 1\n\n        min_subset_size = min(in_degree.count(0), out_degree.count(0))\n        \n        # Due to flow conservation:\n        # min subset size is nodes - 1, which equals rank deficiency in incidence matrix\n        # since each node equation is linearly dependent of total sum constraints\n        # Min subset needed is thus always number of nodes - 1\n        results.append(nodes - 1)\n\n    return results\n\n# Example usage:\ntest_cases = [\n    (4, 3, [(0, 1, 5), (1, 2, 5), (2, 3, 5)]),\n    (3, 3, [(0, 1, 10), (1, 2, 10), (2, 0, 10)])\n]\n\nprint(solve_flow_conservation(test_cases))",
    "timestamp": "2025-08-13 07:23:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class FlowNetwork {\n\n    static class Edge {\n        int from, to;\n        int index;\n        Edge(int from, int to, int index) {\n            this.from = from;\n            this.to = to;\n            this.index = index;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int t = sc.nextInt(); // number of test cases\n        while (t-- > 0) {\n            int n = sc.nextInt(); // number of nodes\n            int m = sc.nextInt(); // number of edges\n\n            List<Edge> edges = new ArrayList<>();\n            int[] inDegree = new int[n];\n            int[] outDegree = new int[n];\n\n            for (int i = 0; i < m; i++) {\n                int u = sc.nextInt();\n                int v = sc.nextInt();\n                edges.add(new Edge(u, v, i));\n                outDegree[u]++;\n                inDegree[v]++;\n            }\n\n            // Keep track of visited nodes and process nodes\n            boolean[] visited = new boolean[n];\n            int edgeCount = 0;\n\n            // Using a queue for iterative component finding\n            Queue<Integer> queue = new LinkedList<>();\n            for (int i = 0; i < n; i++) {\n                if (!visited[i] && (inDegree[i] > 0 || outDegree[i] > 0)) {\n                    queue.offer(i);\n                    visited[i] = true;\n                    edgeCount--; // start from -1 since we consider edgeCount + 1 at the end\n\n                    while (!queue.isEmpty()) {\n                        int node = queue.poll();\n                        for (Edge e : edges) {\n                            if (e.from == node && !visited[e.to]) {\n                                queue.offer(e.to);\n                                visited[e.to] = true;\n                                edgeCount++;\n                            }\n                            if (e.to == node && !visited[e.from]) {\n                                queue.offer(e.from);\n                                visited[e.from] = true;\n                                edgeCount++;\n                            }\n                        }\n                    }\n                }\n            }\n\n            System.out.println(edgeCount + 1); // +1 to include the initial node\n        }\n    }\n}",
    "timestamp": "2025-08-13 07:23:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint findSmallestEdgeSubset(int nodes, int edges, int edgeList[edges][2]) {\n    return edges - nodes + 1;\n}\n\nint main() {\n    int testCases;\n    scanf(\"%d\", &testCases);\n\n    while (testCases--) {\n        int nodes, edges;\n        scanf(\"%d %d\", &nodes, &edges);\n\n        int edgeList[edges][2];\n        for (int i = 0; i < edges; i++) {\n            scanf(\"%d %d\", &edgeList[i][0], &edgeList[i][1]);\n        }\n\n        int result = findSmallestEdgeSubset(nodes, edges, edgeList);\n        printf(\"%d\\n\", result);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 07:23:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_graph_recovery(n, edges):\n    def can_recover(subset):\n        graph = [[] for _ in range(n)]\n        in_degree = [0] * n\n        out_degree = [0] * n\n        \n        for u, v, w in subset:\n            graph[u].append((v, w))\n            out_degree[u] += 1\n            in_degree[v] += 1\n        \n        flow = [[0] * n for _ in range(n)]\n        \n        for u in range(n):\n            if in_degree[u] == 0 or out_degree[u] == 0:\n                continue\n            \n            for v, w in graph[u]:\n                flow[u][v] = w\n        \n        for u in range(n):\n            incoming_sum = sum(flow[v][u] for v in range(n))\n            outgoing_sum = sum(flow[u][v] for v in range(n))\n            \n            if incoming_sum != outgoing_sum:\n                return False\n        \n        return True\n    \n    def generate_subsets(edges):\n        result = []\n        for k in range(1, len(edges) + 1):\n            for subset in itertools.combinations(edges, k):\n                result.append(subset)\n        return result\n    \n    import itertools\n    \n    min_size = float('inf')\n    for subset in generate_subsets(edges):\n        if can_recover(subset):\n            min_size = min(min_size, len(subset))\n    \n    return min_size\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, m = map(int, input().split())\n        edges = []\n        for _ in range(m):\n            u, v, w = map(int, input().split())\n            edges.append((u-1, v-1, w))\n        \n        result = solve_graph_recovery(n, edges)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 07:23:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    while ptr < len(input):\n        N = int(input[ptr])\n        M = int(input[ptr+1])\n        ptr +=2\n        \n        in_degree = [0]*(N+1)\n        out_degree = [0]*(N+1)\n        \n        for _ in range(M):\n            u = int(input[ptr])\n            v = int(input[ptr+1])\n            w = int(input[ptr+2])\n            ptr +=3\n            out_degree[u] +=1\n            in_degree[v] +=1\n        \n        # The answer is M - (N - C), where C is the number of connected components\n        # But since the graph is directed, we need to consider strongly connected components (SCCs)\n        # So first find the number of SCCs\n        \n        # Build the graph for SCC computation\n        adj = [[] for _ in range(N+1)]\n        rev_adj = [[] for _ in range(N+1)]\n        ptr_temp = ptr - 3*M\n        for _ in range(M):\n            u = int(input[ptr_temp])\n            v = int(input[ptr_temp+1])\n            w = int(input[ptr_temp+2])\n            ptr_temp +=3\n            adj[u].append(v)\n            rev_adj[v].append(u)\n        \n        # Kosaraju's algorithm to find SCCs\n        visited = [False]*(N+1)\n        order = []\n        \n        def dfs(u):\n            stack = [(u, False)]\n            while stack:\n                node, processed = stack.pop()\n                if processed:\n                    order.append(node)\n                    continue\n                if visited[node]:\n                    continue\n                visited[node] = True\n                stack.append((node, True))\n                for neighbor in adj[node]:\n                    if not visited[neighbor]:\n                        stack.append((neighbor, False))\n        \n        for u in range(1, N+1):\n            if not visited[u]:\n                dfs(u)\n        \n        visited = [False]*(N+1)\n        scc_count = 0\n        \n        def reverse_dfs(u):\n            stack = [u]\n            visited[u] = True\n            while stack:\n                node = stack.pop()\n                for neighbor in rev_adj[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        stack.append(neighbor)\n        \n        for u in reversed(order):\n            if not visited[u]:\n                reverse_dfs(u)\n                scc_count +=1\n        \n        if scc_count == 0:\n            print(0)\n        else:\n            print(M - N + scc_count)\n\nsolve()",
    "timestamp": "2025-08-13 07:24:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <cstring>\n\nusing namespace std;\n\nstruct Edge {\n    int u, v, idx;\n};\n\nvoid findMinimumEdgeSubset(int nodes, int edges, vector<Edge>& edgeList, vector<int>& result) {\n    vector<int> inDegree(nodes, 0);\n    vector<int> outDegree(nodes, 0);\n\n    for (const Edge& edge : edgeList) {\n        outDegree[edge.u]++;\n        inDegree[edge.v]++;\n    }\n\n    vector<bool> visited(edges, false);\n    \n    for (int v = 0; v < nodes; ++v) {\n        if (inDegree[v] > 0) {\n            for (const Edge& edge : edgeList) {\n                if (edge.u == v && !visited[edge.idx]) {\n                    visited[edge.idx] = true;\n                    outDegree[v]--;\n                    inDegree[edge.v]--;\n                    if (inDegree[edge.v] >= 0) break;\n                }\n            }\n        }\n    }\n    \n    for (int v = 0; v < nodes; ++v) {\n        if (outDegree[v] > 0) {\n            for (const Edge& edge : edgeList) {\n                if (edge.v == v && !visited[edge.idx]) {\n                    visited[edge.idx] = true;\n                    inDegree[v]--;\n                    outDegree[edge.u]--;\n                    if (outDegree[edge.u] >= 0) break;\n                }\n            }\n        }\n    }\n\n    int count = 0;\n    for (bool flag : visited) {\n        if (flag) count++;\n    }\n\n    result.push_back(count);\n}\n\nint main() {\n    int T;\n    cin >> T;\n    \n    vector<int> results;\n    \n    while (T--) {\n        int nodes, edges;\n        cin >> nodes >> edges;\n        \n        vector<Edge> edgeList;\n        for (int i = 0; i < edges; ++i) {\n            int u, v;\n            cin >> u >> v;\n            edgeList.push_back({u, v, i});\n        }\n        \n        findMinimumEdgeSubset(nodes, edges, edgeList, results);\n    }\n\n    for (int res : results) {\n        cout << res << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:38:21"
  }
]