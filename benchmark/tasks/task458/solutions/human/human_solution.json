[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define ALL(x) begin(x), end(x)\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nconstexpr double EPS = 1e-8;\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nint rank_of(const mat& A) {\n\tconst int n = A.size();\n\tconst int m = A[0].size();\n\n\tmat B(A);\n\tint res = 0;\n\tint col = -1;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tint pivot;\n\t\tfor(;;) {\n\t\t\tif(++col == m) goto rank_end;\n\n\t\t\tpivot = -1;\n\t\t\tfor(int j = i; j < n; ++j) {\n\t\t\t\tif(abs(B[j][col]) > EPS) {\n\t\t\t\t\tpivot = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pivot >= 0) break;\n\t\t}\n\n\t\tB[i].swap(B[pivot]);\n\t\t++res;\n\n\t\tfor(int j = i + 1; j < m; ++j) {\n\t\t\tB[i][j] /= B[i][i];\n\t\t}\n\n\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\tif(abs(B[j][col]) > EPS) {\n\t\t\t\tfor(int k = col + 1; k < m; ++k) {\n\t\t\t\t\tB[j][k] -= B[j][i] * B[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nrank_end:;\n\treturn res;\n}\n\nint rank_of(const mat& A, const vec& b) {\n\tconst int n = A.size();\n\n\tmat B(A);\n\tfor(int i = 0; i < n; ++i) {\n\t\tB[i].emplace_back(b[i]);\n\t}\n\treturn rank_of(B);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tmat A(n, vec(m, 0));\n\n\tfor(int i = 0; i < m; ++i) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\t--s; --t;\n\t\tA[s][i] = 1;\n\t\tA[t][i] = -1;\n\t}\n\n\tcout << m - rank_of(A) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\ndouble eps=1e-8;\n\nvoid gauss_jordan(mat& A){\n  int n=A.size();\n  int m=A[0].size();\n  \n  int rank=0;\n  \n  vector<bool> flg(n,false);\n  \n  for(int i=0;i<n;i++){\n    int pivot=i;\n    for(int j=0;j<n;j++){\n      if(flg[j])continue;\n      if(abs(A[j][i]) > abs(A[pivot][i]))pivot=j;\n    }\n\n\n    \n    swap(A[pivot],A[i]);\n    \n    if(abs(A[i][i]) < eps)continue;\n    \n    rank++;\n    flg[i]=true;\n    \n    double val=A[i][i];\n    for(int j=0;j<m;j++)A[i][j]/=val;\n    \n    for(int j=0;j<n;j++){\n      if(i==j)continue;\n      double va=A[j][i];\n      for(int k=0;k<m;k++)\n        A[j][k]-=A[i][k]*va;\n    }\n  }\n  /*\n  cout<<\"rank = \"<<rank<<endl;\n  cout<<\" n = \"<<n<<endl;\n  cout<<\" m = \"<<m<<endl;\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<m;j++){\n      printf(\"%3d\",(int)A[i][j]);\n    }\n    cout<<endl;\n  }\n\n  */\n  cout<<m-rank<<endl;\n}\n\nint N,M;\nint G[500][500];\n\nint main(){\n  memset(G,-1,sizeof(G));\n  mat A;\n  cin>>N>>M;\n  for(int i=0;i<M;i++){\n    int a,b;\n    cin>>a>>b;\n    a--,b--;\n    G[a][b]=i;\n  }\n\n  for(int i=0;i<N;i++){\n    vec B(M,0);\n    for(int j=0;j<N;j++){\n      if(G[i][j]==-1)continue;\n      int id=G[i][j];\n      B[ id ]=1;\n    }\n    for(int j=0;j<N;j++){\n      if(G[j][i]==-1)continue;\n      int id=G[j][i];\n      B[ id ]=-1;\n    }\n    A.push_back(B);\n  }\n\n  while(A.size()<A[0].size()){\n    vec B(M,0);\n    A.push_back(B);\n  }\n  gauss_jordan(A);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nvector<int> G[510];\nbool used[510];\n\nvoid dfs(int v){\n\tused[v] = true;\n\tfor(int to : G[v]){\n\t\tif(!used[to]) dfs(to);\n\t}\n}\n\nsigned main(){\n\tint n,m,k = 0;\n\tcin >> n >> m;\n\tfor(int i = 0;i < m;i++){\n\t\tint a,b;\n\t\tcin >> a >> b; a--;b--;\n\t\tG[a].push_back(b);\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tif(!used[i]){\n\t\t\tdfs(i);\n\t\t\tk++;\n\t\t}\n\t}\n\tcout << m - n + k << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct edge{\n  int to,from;  \n  edge(int to,int from) :\n    to(to), from(from) {}\n  edge(){}\n};\n\nint N,M;\nbool used[5000];\nset<int> G[555];\nvector<edge> E;\n\nint main(){\n  cin >> N >> M;  \n  for(int i=0;i<M;i++){\n    int s,t; cin >> s >> t;\n    --s; --t;\n    E.push_back( edge(t,s) );\n    G[s].insert( i );\n    G[t].insert( i );\n  }\n  if( M == 0 ) {\n    cout << 0 << endl;\n    return 0;\n  }\n  bool ed = true;\n  int res = 0;\n  while( ed ){\n    int minid=0;\n    while( G[minid].empty() ) minid++;\n    for(int i=0;i<N;i++){\n      if( G[i].empty() ) continue;\n      if( G[minid].size() > G[i].size()  ) minid = i;\n    }\n    //   cout << G[minid].size() << endl;\n    res += G[minid].size()-1;\n    for(auto it = G[minid].begin(); it != G[minid].end(); it++ ){\n      used[*it] = true;\n      // cout << \"new \" << *it << endl;\n      for(int i=0;i<N;i++){\n        if( i == minid ) continue;\n        G[i].erase(*it);\n      }\n    }\n    G[minid].clear();\n    ed = false;\n    for(int i=0;i<M;i++)\n      if( !used[i] ) ed = true;\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m; cin >> n >> m;\n\tGraph g(n);\n\tREP(i, m)\n\t{\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tadd_edge(g, a, b, 0);\n\t}\n\tvector<bool> vis(n);\n\tint ans = 0;\n\tREP(i, n)\n\t{\n\t\tif (vis[i]) continue;\n\t\tvis[i] = true;\n\t\tint cntv = 1, cnte = 0;\n\t\tqueue<int> que; que.push(i);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint t = que.front();\n\t\t\tque.pop();\n\t\t\tfor (auto e : g[t])\n\t\t\t{\n\t\t\t\tcnte++;\n\t\t\t\tif (!vis[e.to])\n\t\t\t\t{\n\t\t\t\t\tvis[e.to] = true;\n\t\t\t\t\tcntv++;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans += cnte - cntv + 1;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x != y) {\n      if(data[x] > data[y]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\n\nint main()\n{\n  int N, M;\n  int S[3000], G[3000];\n\n  cin >> N >> M;\n  UnionFind tree(N);\n  for(int i = 0; i < M; i++) {\n    cin >> S[i] >> G[i];\n    tree.unite(--S[i], --G[i]);\n  }\n\n  int sum[3000] = {};\n  for(int i = 0; i < M; i++) {\n    ++sum[tree.find(S[i])];\n  }\n\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    if(tree.find(i) != i) continue;\n    ret += 1 + sum[i] - tree.size(i);\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\ntypedef long long  ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\n\nstruct uf {\nprivate:\n\tvector<int> par, ran;\npublic:\n\tvoid init(int n) {\n\t\tpar.resize(n, 0);\n\t\tran.resize(n, 0);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\tuf u; u.init(n + 1);\n\trep(i, m) {\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tu.unite(a, b);\n\t}\n\tint tmp = 0;\n\trep(i, n) {\n\t\tif (u.same(i, n))continue;\n\t\ttmp++; u.unite(i, n);\n\t}\n\tcout << m - n + tmp << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(5);\n\t//while (cin >> n,n)solve();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n\nusing namespace std;\n\nmultiset<int> edges[523];\n\nvoid erase(int v){\n  while(edges[v].size()==1){\n    int nv=*edges[v].begin();\n    edges[nv].erase(edges[nv].find(v));\n    edges[v].clear();\n    v=nv;\n  }\n}    \n\nint main(){\n  int N,M;\n  cin>>N>>M;\n  for(int i=0;i<M;i++){\n    int s,t;\n    cin>>s>>t;\n    edges[s].insert(t);\n    edges[t].insert(s);\n  }\n  int ans=0;\n  for(int i=1;i<=N;i++){\n    while(!edges[i].empty()){\n      ans++;\n      auto it=edges[i].begin();\n      int t=*it;\n      edges[i].erase(it);\n      edges[t].erase(edges[t].find(i));\n      erase(t);\n      erase(i);\n    }\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\nconst double eps = 1e-8;\n\nmat mul(const mat& A, const mat& B)\n{\n  mat C(A.size(), vec(B[0].size()));\n  for(int i = 0; i < (int)A.size(); i++) {\n    for(int j = 0; j < (int)B.size(); j++) {\n      for(int k = 0; k < (int)B[0].size(); k++) {\n\tC[i][k] += A[i][j] * B[j][k];\n      }\n    }\n  }\n  return C;\n}\n\nmat pow(mat A, int n)\n{\n  mat B(A.size(), vec(A.size()));\n  for(int i = 0; i < (int)A.size(); i++) B[i][i] = 1;\n  while(n > 0) {\n    if(n & 1) B = mul(B, A);\n    A = mul(A, A);\n    n >>= 1;\n  }\n  return B;\n}\n\ndouble det(mat A) {\n  const int n = A.size();\n  double D = 1;\n  for(int i = 0; i < n; i++) {\n    int pivot = i;\n    for(int j = i+1; j < n; j++) {\n      if(abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n    }\n    swap(A[pivot], A[i]);\n    D *= A[i][i] * (i != pivot ? -1 : 1);\n    if(abs(A[i][i]) < eps) break;\n    for(int j = i+1; j < n; j++) {\n      for(int k = n-1; k >= i; k--) {\n\tA[j][k] -= A[i][k]*A[j][i] / A[i][i];\n      }\n    }\n  }\n  return D;\n}\n\nint Rank(mat A) {\n  const int n = A.size(), m = A[0].size();\n  int r = 0, c = 0;\n  for(int i = 0; i < n; i++) {\n    int pivot = -1;\n    while(c < m) {\n      for(int j = i; j < n; j++) {\n\tif(abs(A[j][c]) > eps) { pivot = j; break; }\n      }\n      if(~pivot) break;\n      c++;\n    }\n    if(c >= m) break;\n    r++;\n    swap(A[pivot], A[i]);\n    double a = A[i][c];\n    for(int j = 0; j < m; j++) A[i][j] /= a;\n    for(int j = i+1; j < n; j++) {\n      double aa = A[j][c];\n      for(int k = 0; k < m; k++) A[j][k] -= aa*A[i][k];\n    }\n    c++;\n  }\n  return r;\n}\n\nint N, M;\nmat A;\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> M;\n  A.resize(N, vec(M));\n  rep(i, M) {\n    int s, t;\n    cin >> s >> t;\n    --s, --t;\n    A[s][i]++;\n    A[t][i]--;\n  }\n\n  cout << M - Rank(A) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ntypedef vector<double> Vect;\ntypedef vector<Vect> Matrix;\nconst double EPS = 1e-8;\n\nint rank_of_matrix(Matrix M){\n    int H = M.size();\n    int W = M[0].size();\n    int cy, cx;\n    for(cy = 0, cx = 0; cy < H && cx < W; cy++, cx++){\n        for(int y = cy + 1; y < H; y++){\n            if(abs(M[cy][cx]) < abs(M[y][cx])){\n                swap(M[cy], M[y]);\n            }\n        }\n        if(abs(M[cy][cx]) < EPS){\n            cy--;\n            continue;\n        }\n        for(int y = cy + 1; y < H; y++){\n            double p = M[y][cx] / M[cy][cx];\n            for(int x = cx; x < W; x++){\n                M[y][x] -= p * M[cy][x];\n            }\n        }\n    }\n    return cy;\n}\n\nint main(){\n    int N, M;\n    while(cin >> N >> M){\n        Matrix Mat(N, Vect(M));\n        for(int i = 0; i < M; i++){\n            int s, t;\n            cin >> s >> t;\n            s--; t--;\n            Mat[s][i] += 1.0;\n            Mat[t][i] -= 1.0;\n        }\n        cout << M - rank_of_matrix(Mat) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n,m;\n  cin >> n >> m;\n  vector<int> v[n];\n  for(int i=0; i<m; i++) {\n    int x,y;\n    cin >> x >> y;\n    x--,y--;\n    v[x].push_back(y);\n  }\n  bool u[n];\n  memset(u,0,sizeof(u));\n  int ans=0;\n  for(int i=0; i<n; i++) {\n    if(u[i]) continue;\n    ans++;\n    u[i]=1;\n    queue<int> que;\n    que.push(i);\n    while(!que.empty()) {\n      int x=que.front();que.pop();\n      ans+=v[x].size()-1;\n      for(int i=0; i<v[x].size(); i++) {\n        int y=v[x][i];\n        if(u[y]) continue;\n        u[y]=1;\n        que.push(y);\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<ctime>\n#include<stack>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint n,m;\nint in[510];\nint out[510];\nint visit[510];\nint maze[510][510];\n\nvoid del(int x)\n{\n    for(int i=1;i<=n;i++)\n    {\n        if(maze[i][x])\n        {\n            maze[i][x]=0;\n            //in[x]--;\n            out[i]--;\n        }\n        if(maze[x][i])\n        {\n            maze[x][i]=0;\n            //out[x]--;\n            in[i]--;\n        }\n    }\n}\n\nint main()\n{\n    int ans=0;\n    scanf(\"%d%d\",&n,&m);\n    while(m--)\n    {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        in[b]++;\n        out[a]++;\n        maze[a][b]=1;\n    }\n\n    for(int t=1;t<=n;t++)\n    {\n        int flag=0;\n        for(int i=1;i<=n;i++)\n        {\n            if((visit[i]==0)&&(in[i]==0||out[i]==0))\n            {\n                if(in[i]==0)\n                    ans+=out[i]-1;\n                else\n                    ans+=in[i]-1;\n                visit[i]=1;\n                del(i);\n\n                flag=1;\n                break;\n            }\n        }\n        if(flag)\n            continue;\n\n        int Min=10000;\n        int pos;\n        for(int i=1;i<=n;i++)\n        {\n            if((visit[i]==0)&&in[i]+out[i]<Min)\n            {\n                Min=in[i]+out[i];\n                pos=i;\n            }\n        }\n        visit[pos]=1;\n        if(Min>0)\n            ans+=Min-1;\n        del(pos);\n    }\n    printf(\"%d\\n\",ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 1000\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n\n#define rank Asdfiasofsad\nclass UF{\npublic:\n  int V;\n  vector<int> par,rank;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0){for(int i=0;i<V;i++)par[i]=i;}\n  \n  int find(int x){\n    assert(x < V);\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])par[x]=y;\n    else{\n      par[y]=x;\n      if(rank[x]==rank[y])rank[x]++;\n    }\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nint n,m;\nvector<int> G[N];\n\nint used[N];\nint dfs(int pos){\n  if(used[pos]++) return 0;\n  int res = G[pos].size() - 1;\n  for(int to:G[pos]) res += dfs(to);\n  return res;\n}\n\nsigned main(){\n  cin>>n>>m;\n  UF uf(n);\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b; a--,b--;\n    G[a].push_back(b);\n    uf.unite(a,b);\n  }\n  \n  map<int,int> val;\n  for(int i=0;i<n;i++){\n    memset(used,0,sizeof(used));\n    int v = dfs(i);\n    if(val.count(uf.find(i))) Min(val[uf.find(i)],v);\n    else val[uf.find(i)] = v;\n  }\n\n  int sum = 0;\n  typedef pair<int,int> P;\n  for(P p:val) sum += p.second+1;\n  cout<<sum<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n\n/* verified AOJ1327 One-Dimensional Cellular Automaton\n~Matrix~\n??????????°????????¨?????????§??????\nvector iostream cmath cassert ??????\nMatrix a(VV), b(VV);\n?????????:a*b\n????????????:l*a\n???:a+b\n???:a-b\n??¢???:a.transport()\n?????????:a.cofactor()\n?????????:a.det()\na???i???j??????:a.get(i,j)???\na???i??????j?????????k?????£??\\:set(i,j,k)\n????????????a[i][j] (a[i][j]=k)\na???x???:a.pow(x)\nn*n?????¬??????E:Matrix(n)\nm*n 0??????:Matrix(m,n)\nm*n ??¨????´????p?????????:Matrix(m,n,p)\nRow???row??§????????????(m*1??????):Matrix(row)\n**(??´??°??????)**\n????§????:a.triangulate()\n?????????:a.rank()\n?????????:a.inverse()\n//(????????????a.det()?????????a.pre_inverse()??§?±??????? ??´??°???)\n??¬??????????¶???????:a.rowReduction()\n//??£???????¬?????¨????????§£??????\n***\n*/\n\n#include <vector>\n#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\ntypedef int Elem;\ntypedef vector<Elem> Row;\ntypedef vector<Row> VV;\n\ntypedef long double ld;\nconst ld EPS = 1e-11;\n\nconst bool isZero(const Elem e) {\n\treturn abs(e) < EPS;\n}\n\nstruct Matrix {\n\tVV matrix;\n\tint n, m;\n\n\tMatrix(const VV &matrix_);\n\texplicit Matrix(int n_);\n\texplicit Matrix(const Row &row);\n\tMatrix(int m_, int n_);\n\tMatrix(int m_, int n_, Elem e);\n\n\tconst Elem get(const int i, const int j) const;\n\tvoid set(const int x, const int y, const Elem k);\n\n\tconst Matrix operator + (const Matrix &rhs) const;\n\tconst Matrix operator * (const Matrix &rhs) const;\n\tconst Matrix operator - (const Matrix &rhs) const;\n\tMatrix &operator += (const Matrix &rhs);\n\tMatrix &operator *= (const Matrix &rhs);\n\tMatrix &operator -= (const Matrix &rhs);\n\n\tRow &operator[](const int x);\n\n\tconst Matrix transport() const;\n\tconst Matrix pow(int x) const;\n\tconst Matrix cofactor(int x, int y) const;\n\tconst Elem det() const;\n\n\tconst Matrix triangulate() const;\n\tconst int rank() const;\n\n\t//?????????????????¨????????°???(?????????)*(?????????)?????????\n\t//A:matrix,return det A * A^-1\n\tconst Matrix pre_inverse() const;\n\tconst Matrix inverse() const;\n\tconst Matrix rowReduction() const;\n};\n\nconst Matrix operator * (const Elem lambda, const Matrix &rhs) {\n\tMatrix tmp(rhs);\n\tfor (int i = 0; i < rhs.m; i++)\n\t\tfor (int j = 0; j < rhs.n; j++)\n\t\t\ttmp.set(i, j, tmp.get(i, j) * lambda);\n\treturn tmp;\n}\n\nMatrix::Matrix(const VV &matrix_) : matrix(matrix_) {\n\tm = matrix_.size();\n\tif (m == 0) n = 0;\n\telse n = matrix_[0].size();\n}\nMatrix::Matrix(int n_) : m(n_), n(n_) {\n\tmatrix = VV(n, Row(n, 0));\n\tfor (int i = 0; i < n; ++i)\n\t\tset(i, i, 1);\n}\nMatrix::Matrix(const Row &row) : m(1), n(row.size()), matrix(VV(1, row)) {\n\t//size???m???vector<Elem>??????mx1???????????????\n\t(*this) = transport();\n}\nMatrix::Matrix(int m_, int n_) : m(m_), n(n_) {\n\tmatrix = VV(m, Row(n, 0));\n}\nMatrix::Matrix(int m_, int n_, Elem e) : m(m_), n(n_) {\n\tmatrix = VV(m, Row(n, e));\n}\n\nconst Elem Matrix::get(const int i, const int j) const {\n\tif (0 <= i && i < m && 0 <= j && j < n)\n\t\treturn matrix[i][j];\n\n\tcerr << \"get(\" << i << \",\" << j << \")is not exist.\" << endl;\n\tthrow;\n}\nvoid Matrix::set(const int i, const int j, const Elem k) {\n\tif (0 <= i && i < m && 0 <= j && j < n) {\n\t\t*(matrix[i].begin() + j) = k;\n\t\treturn;\n\t}\n\tcerr << \"set(\" << i << \",\" << j << \")is not exist.\" << endl;\n\tthrow;\n}\n\nconst Matrix Matrix::operator + (const Matrix &rhs) const {\n\tassert(m == rhs.m && n == rhs.n);\n\n\tMatrix tmp(m, n, 0);\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\ttmp.set(i, j, get(i, j) + rhs.get(i, j));\n\t\t}\n\t}\n\treturn tmp;\n}\n\nconst Matrix Matrix::operator * (const Matrix &rhs) const {\n\tassert(n == rhs.m);\n\n\tMatrix tmp(m, rhs.n, 0);\n\tElem sum;\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < rhs.n; j++) {\n\t\t\tsum = 0;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tsum += get(i, k) * rhs.get(k, j);\n\t\t\t}\n\t\t\ttmp.set(i, j, sum);\n\t\t}\n\treturn tmp;\n}\n\nconst Matrix Matrix::operator - (const Matrix &rhs) const {\n\treturn *this + ((Elem)-1 * rhs);\n}\n\nMatrix &Matrix::operator += (const Matrix &rhs) {\n\treturn *this = *this + rhs;\n}\n\nMatrix &Matrix::operator *= (const Matrix &rhs) {\n\treturn *this = *this * rhs;;\n}\n\nMatrix &Matrix::operator -= (const Matrix &rhs) {\n\treturn *this = *this - rhs;\n}\n\nRow &Matrix::operator[](const int x) {\n\treturn matrix[x];\n}\n\nconst Matrix Matrix::transport() const {\n\tVV tmp;\n\tfor (int i = 0; i < n; i++) {\n\t\tRow row;\n\t\tfor (int j = 0; j < m; j++)\n\t\t\trow.push_back(get(j, i));\n\t\ttmp.push_back(row);\n\t}\n\treturn tmp;\n}\n\nconst Matrix Matrix::pow(int x) const {\n\tMatrix tmp(*this), e(m);\n\tfor (int i = 1; i <= x; i <<= 1) {\n\t\tif ((x & i) > 0)\n\t\t\te = e * tmp;\n\t\ttmp = tmp * tmp;\n\t}\n\treturn e;\n}\n\nconst Matrix Matrix::cofactor(int x, int y) const {\n\tVV tmp;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (x == i) continue;\n\t\tRow row;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (y == j) continue;\n\t\t\trow.push_back(get(i, j));\n\t\t}\n\t\ttmp.push_back(row);\n\t}\n\treturn Matrix(tmp);\n}\n\nconst Elem Matrix::det() const {\n\tassert(n == m);\n\n\tif (m == 1)\n\t\treturn get(0, 0);\n\tElem sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tsum += ((i % 2 == 0 ? 1 : -1) * get(i, 0)) * Matrix(cofactor(i, 0)).det();\n\t}\n\treturn sum;\n}\n\nconst Matrix Matrix::triangulate() const {\n\tMatrix tmp(*this);\n\tElem e;\n\tint p = 0;\n\tfor (int i = 0; i < m && p < n; i++, p++) {\n\t\tif (isZero(tmp.get(i, p))) {\n\t\t\ttmp.set(i, p, 0);\n\t\t\tbool flag = true;\n\t\t\tfor (int j = i + 1; j < m; j++)\n\t\t\t\tif (!isZero(tmp.get(j, p))) {\n\t\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t\t\ttmp.set(i, k, tmp.get(i, k) + tmp.get(j, k));\n\t\t\t\t\t//tmp[i].swap(tmp[j]);\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor (int j = i + 1; j < m; j++) {\n\t\t\te = tmp.get(j, p) / tmp.get(i, p);\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\ttmp.set(j, k, tmp.get(j, k) - tmp.get(i, k) * e);\n\t\t}\n\t}\n\treturn tmp;\n}\n\nconst int Matrix::rank() const {\n\tMatrix tmp(triangulate());\n\tfor (int i = min(tmp.m - 1, tmp.n - 1); i >= 0; i--) {\n\t\tfor (int j = tmp.n - 1; j >= i; j--)\n\t\t\tif (isZero(tmp.get(i, j)))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn i + 1;\n\t}\n\treturn 0;\n}\n\nconst Matrix Matrix::pre_inverse() const {\n\tassert(m == n);\n\n\tMatrix tmp(m, n, 0);\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\ttmp.set(i, j, ((i + j) % 2 == 0 ? 1 : -1)*cofactor(i, j).det());\n\treturn tmp.transport();\n}\n\n/*O(n!)????£?\nconst Matrix Matrix::inverse() const {\nMatrix tmp(pre_inverse());\nElem e = det();\nassert(!isZero(e));\ntmp = 1 / e * tmp;\nreturn tmp.transport();\n}*/\n\nconst Matrix Matrix::inverse() const {\n\tassert(m == n);\n\n\tMatrix tmp(m, n * 2), tmp2(m, n);\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\ttmp.set(i, j, get(i, j));\n\tfor (int i = 0; i < m; i++)\n\t\ttmp.set(i, i + n, 1);\n\n\ttmp = tmp.rowReduction();\n\n\t//?????????????????¨??????????????????????????§??????\n\tfor (int i = 0; i < m; i++)\n\t\tassert(isZero(tmp.get(i, i) - 1));\n\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\ttmp2.set(i, j, tmp.get(i, j + n));\n\n\treturn tmp2;\n}\n\n/*\na b c j\nd e f k\ng h i l\n\nax+by+cz=j;\ndx+ey+fz=k;\ngx+hy+iz=l;\n\n|\nV\n\n1 0 0 x\n0 1 0 y\n0 0 1 z\n???????????????\n*/\nconst Matrix Matrix::rowReduction() const {\n\tMatrix tmp(*this);\n\tElem e;\n\tint p = 0;\n\tfor (int i = 0; i < m && p < n; i++, p++) {\n\t\tif (isZero(tmp.get(i, p))) {\n\t\t\ttmp.set(i, p, 0);\n\t\t\tbool flag = true;\n\t\t\tfor (int j = i + 1; j < m; j++)\n\t\t\t\tif (!isZero(tmp.get(j, p))) {\n\t\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t\t\ttmp.set(i, k, tmp.get(i, k) + tmp.get(j, k));\n\t\t\t\t\t//tmp[i].swap(tmp[j]);\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\te = 1 / tmp.get(i, p);\n\t\ttmp.set(i, p, 1);\n\t\tfor (int k = i + 1; k < n; k++)\n\t\t\ttmp.set(i, k, tmp.get(i, k)*e);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i == j) continue;\n\t\t\te = tmp.get(j, p);\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\ttmp.set(j, k, tmp.get(j, k) - tmp.get(i, k) * e);\n\t\t}\n\t}\n\treturn tmp;\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<int>>edges(N, vector<int>(M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tedges[a][i]++;\n\t\tedges[b][i]--;\n\t}\n\tMatrix mat(edges);\n\tint num=mat.rank();\n\tint ans = M - num;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    vector<vector<int>> mat(n,vector<int>(m,0));\n    vector<int> plus(m);\n    vector<int> minus(m);\n    for(int i=0;i<m;i++){\n        int s,t;\n        cin>>s>>t;\n        s--,t--;\n        mat[s][i]=1;\n        plus[i]=s;\n        mat[t][i]=-1;\n        minus[i]=t;\n    }\n\n    for(int i=0;i<n;i++){\n        int e=-1;\n        for(int j=0;j<m;j++){\n            if(mat[i][j]){\n                e=j;\n                break;\n            }\n        }\n        if(e==-1) continue;\n        int tar;\n        if(mat[i][e]>0){\n            tar=minus[e];\n        }\n        else{\n            tar=plus[e];\n        }\n        if(tar<i) continue;\n        for(int j=0;j<m;j++){\n            mat[tar][j]+=mat[i][j];\n            if(mat[tar][j]>0){\n                plus[j]=tar;\n            }\n            else if(mat[tar][j]<0){\n                minus[j]=tar;\n            }\n        }\n    }\n    int cnt=0;\n    for(int i=0;i<n;i++){\n        if(all_of(mat[i].begin(),mat[i].end(),[](int x){return x==0;})){\n            cnt++;\n        }\n    }\n    cout<<m-(n-cnt)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nstruct aa {\n\tint f;\n\tint t;\n\tint id;\n};\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<pair<int,int>>>nums(N);\n\tvector<aa>ps;\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint s, t; cin >> s >> t;\n\t\ts--; t--;\n\t\tnums[s].emplace_back(t,id); nums[t].emplace_back(s,id);\n\t\tps.push_back(aa{ s, t,id++ });\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\n\t\tsort(nums[i].begin(), nums[i].end());\n\t}\n\tvector<int>oks(M, false);\n\n\tint now = 0;\n\tint ans = 0;\n\twhile (1) {\n\t\tif (nums[ps[now].f].size() >= 2 && nums[ps[now].t].size() >= 2) {\n\t\t\tans++;\n\t\t\tif (oks[now])continue;\n\t\t\tqueue<int>que;\n\t\t\tque.push(now);\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint atop(que.front());\n\t\t\t\tque.pop();\n\t\t\t\tif (oks[atop])continue;\n\t\t\t\toks[atop] = true;\n\t\t\t\tauto p = ps[atop];\n\t\t\t\tnums[p.f].erase(lower_bound(nums[p.f].begin(),nums[p.f].end(),make_pair(p.t,atop)));\n\t\t\t\tnums[p.t].erase(lower_bound(nums[p.t].begin(), nums[p.t].end(), make_pair(p.f, atop)));\n\t\t\t\tif (nums[p.f].size() == 1) {\n\t\t\t\t\tif (!oks[nums[p.f][0].second]) {\n\n\t\t\t\t\t\tque.push(nums[p.f][0].second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nums[p.t].size() == 1) {\n\t\t\t\t\tif (!oks[nums[p.t][0].second]) {\n\n\t\t\t\t\t\tque.push(nums[p.t][0].second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tassert(oks[now]);\n\t\t}\n\t\tnow++;\n\t\tif (now == ps.size())break;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\ntypedef unsigned long long ll;\nvector<vector<int> >G;\nvector<int>visited;\n\nint equ,unk;\n\nvoid dfs(int now){\n    equ++;\n    visited[now]=1;\n    for(int i=0;i<G[now].size();i++){\n        unk++;\n        if(!visited[G[now][i]])\n            dfs(G[now][i]);\n    }\n}\n\nint main(){\n    int n,m,ans=0;\n    cin>>n>>m;\n    G.resize(n);\n    visited.resize(n,0);\n    for(int i=0;i<m;i++){\n        int s,t;\n        cin>>s>>t;\n        G[s-1].push_back(t-1);\n    }\n    for(int i=0;i<n;i++){\n        if(!visited[i]){\n            unk=0;\n            equ=0;\n            dfs(i);\n            ans+=unk-equ+1;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,a,b,m;\nbool vis[501];\nvector<int>v[501];\nint dfs(int x){\n  int res=v[x].size()-1;\n  for(int i=0;i<v[x].size();i++)\n    if(!vis[v[x][i]]){\n      vis[v[x][i]]=1;\n      res+=dfs(v[x][i]);\n    }\n  return res;\n}\nmain(){\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    v[a].push_back(b);\n  }\n  int sum=0;\n  for(int i=1;i<=n;i++){\n    memset(vis,0,sizeof(vis));\n    vis[i]=1;\n    sum=max(sum,dfs(i));\n  }\n  if(sum)cout<<sum+1<<endl;\n  else cout<<2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n\nconst double eps=1e-9;\ntypedef valarray<double> vec;\ntypedef valarray<vec> mat;\n\ninline int pivoting(mat &a,int k,int &c){\n\tint n=a.size(),m=a[0].size(),p=k,ret=0;\n\tfor(;c<m;++c){\n\t\tdouble cmax=abs(a[k][c]);\n\t\trange(i,k+1,n){\n\t\t\tif(abs(a[i][c])>cmax){\n\t\t\t\tp=i,ret=1;\n\t\t\t\tcmax=abs(a[i][c]);\n\t\t\t}\n\t\t}\n\t\tif(abs(cmax)>eps) break;\n\t}\n\tif(k!=p) swap(a[k],a[p]);\n\treturn ret;\n}\n\nint forward(mat &a){\n\tint n=a.size(),m=a[0].size(),ret=0,c=0;\n\trep(i,n-1){\n\t\tret+=pivoting(a,i,c);\n\t\tif(abs(a[i][c])<eps) break;\n\t\trange(j,i+1,n){\n\t\t\tdouble coef=a[j][c]/a[i][c];\n\t\t\trange(k,c,m) a[j][k]-=coef*a[i][k];\n\t\t}\n\t}\n\treturn ret;\n}\n\nint rnk(mat &a){\n\tint n=a.size(),m=a[0].size(),ret=0;\n\trep(i,n)rep(j,m) if(abs(a[i][j])>eps) ret=i+1;\n\treturn ret;\n}\n\nint main(void){\n\tint n,m;\n\tcin >> n >> m;\n\tmat a(vec(0.0,m),n);\n\trep(i,m){\n\t\tint s,t;\n\t\tcin >> s >> t;\n\t\ts--,t--;\n\t\ta[s][i]+=1.0;\n\t\ta[t][i]-=1.0;\n\t}\n\tforward(a);\n\tint ans=m-rnk(a);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 1000\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n\n#define rank Asdfiasofsad\nclass UF{\npublic:\n  int V;\n  vector<int> par,rank;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0){for(int i=0;i<V;i++)par[i]=i;}\n  \n  int find(int x){\n    assert(x < V);\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])par[x]=y;\n    else{\n      par[y]=x;\n      if(rank[x]==rank[y])rank[x]++;\n    }\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nint n,m;\nvector<int> G[N];\n\nint used[N];\nint dfs(int pos){\n  if(used[pos]++) return 0;\n  int res = G[pos].size() - 1;\n  for(int to:G[pos]) res += dfs(to);\n  return res;\n}\n\nsigned main(){\n  cin>>n>>m;\n  UF uf(n);\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b; a--,b--;\n    G[a].push_back(b);\n    uf.unite(a,b);\n  }\n  \n  map<int,int> val;\n  for(int i=0;i<n;i++){\n    memset(used,0,sizeof(used));\n    int v = dfs(i);\n    if(val.count(uf.find(i))) Min(val[uf.find(i)],v);\n    else val[uf.find(i)] = v;\n  }\n\n  int sum = 0;\n  typedef pair<int,int> P;\n  for(P p:val) sum += p.second+1;\n  cout<<sum<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nbool used[555];\nset<int> G[555];\nvoid dfs(int v){\n  if(used[v]) return;\n  used[v]=1;\n  for(int u:G[v]) dfs(u);\n}\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    int s,t;\n    cin>>s>>t;\n    s--;t--;\n    G[s].insert(t);\n  }\n  memset(used,0,sizeof(used));\n  int cnt=0;\n  for(int i=0;i<n;i++){\n    if(used[i]) continue;\n    cnt++;\n    dfs(i);\n  }\n  cout<<m-n+cnt<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nstruct aa {\n\tint f;\n\tint t;\n\tint id;\n};\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<pair<int,int>>>nums(N);\n\tvector<aa>ps;\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint s, t; cin >> s >> t;\n\t\ts--; t--;\n\t\tnums[s].emplace_back(t,id); nums[t].emplace_back(s,id);\n\t\tps.push_back(aa{ s, t,id++ });\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\n\t\tsort(nums[i].begin(), nums[i].end());\n\t}\n\tvector<int>oks(M, false);\n\n\tint now = 0;\n\tint ans = 0;\n\twhile (1) {\n\t\tif (now == ps.size())break;\n\t\tif (nums[ps[now].f].size() >= 2 && nums[ps[now].t].size() >= 2) {\n\t\t\tans++;\n\t\t\tif (oks[now])continue;\n\t\t\tqueue<int>que;\n\t\t\tque.push(now);\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint atop(que.front());\n\t\t\t\tque.pop();\n\t\t\t\tif (oks[atop])continue;\n\t\t\t\toks[atop] = true;\n\t\t\t\tauto p = ps[atop];\n\t\t\t\tnums[p.f].erase(lower_bound(nums[p.f].begin(),nums[p.f].end(),make_pair(p.t,atop)));\n\t\t\t\tnums[p.t].erase(lower_bound(nums[p.t].begin(), nums[p.t].end(), make_pair(p.f, atop)));\n\t\t\t\tif (nums[p.f].size() == 1) {\n\t\t\t\t\tif (!oks[nums[p.f][0].second]) {\n\n\t\t\t\t\t\tque.push(nums[p.f][0].second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nums[p.t].size() == 1) {\n\t\t\t\t\tif (!oks[nums[p.t][0].second]) {\n\n\t\t\t\t\t\tque.push(nums[p.t][0].second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tassert(oks[now]);\n\t\t}\n\t\tnow++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<(b)?(a=b,1):0)\n#define chmin(a,b) (a>(b)?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nvector<int> g[500];\nbool visited[500];\nint main() {\n  int n,m;\n  while(cin>>n>>m) {\n    REP(i,n)g[i].clear();\n    REP(i,m) {\n      int a, b;\n      cin >> a >> b;\n      a--;b--;\n      g[a].push_back(b);\n    }\n    memset(visited,0,sizeof(visited));\n    int cnt = 0;\n    REP(i,n) {\n      if (!visited[i]) {\n        cnt++;\n        visited[i] = 1;\n        queue<int> Q;\n        Q.push(i);\n        while(!Q.empty()) {\n          int a = Q.front(); Q.pop();\n          FOR(it, g[a]) {\n            if (!visited[*it]) {\n              visited[*it] = 1;\n              Q.push(*it);\n            }\n          }\n        }\n      }\n    }\n    cout << m-n+cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct edge{\n  int to,from,no,flag;\n};\nint N,M;\nvector<int> same[3111];\nvector<int> Gs[511],Gn[511];\nedge E[3111];\nstruct uni{\n  int d[3111];\n  void init(){ memset(d,-1,sizeof(d)); }\n  int find(int a){ return d[a]<0?a:(d[a] = find(d[a])); }\n  void marge(int a,int b){\n    a = find(a), b = find(b);\n    if( a == b ) return;\n    if( d[a] > d[b] ) swap(a,b);\n    d[a] += d[b]; d[b] = a;   \n  }\n};\nuni U;\n\nvoid view(){\n  cout << \"view\" << endl;\n  for(int i=0;i<M;i++){\n    cout << E[i].flag << endl;\n  }\n}\n\nbool check(){\n  //  view();\n  for(int i=0;i<M;i++) if( !E[i].flag ) return false;\n  return true;\n}\n\nbool update(){\n  //  view();\n  bool ret = false;\n  for(int i=0;i<M;i++){\n    if( E[i].flag ) {\n      int p = U.find(i);\n      if( same[p].empty() ) continue;\n      \n      for(int i=0;i<(int)same[p].size();i++)\n\tE[same[p][i]].flag = 1;\n      ret = true;\n      same[p].clear();\n    }\n  }\n  for(int i=0;i<N;i++){\n    vector<int> e;\n    for(int j=0;j<(int)Gs[i].size();j++)\n      if( !E[Gs[i][j]].flag ) e.push_back( Gs[i][j] );\n    for(int j=0;j<(int)Gn[i].size();j++)\n      if( !E[Gn[i][j]].flag ) e.push_back( Gn[i][j] );\n    if(e.size()==1) {\n      E[e[0]].flag = 1;      \n      ret = true;\n    }\n \n  }\n  return ret;\n}\n\nint main(){\n  \n  cin >> N >> M;\n  for(int i=0;i<M;i++){\n    int s,t; cin >> s>> t;\n    E[i] = (edge){s,t,i,0};\n    Gs[s].push_back(i);\n    Gn[t].push_back(i);\n  }\n\n  U.init();\n  for(int i=0;i<N;i++)\n    if( Gs[i].size() == 1 && Gn[i].size() ==1 )\n      U.marge(Gs[i][0],Gn[i][0]);\n  for(int i=0;i<M;i++)\n    same[U.find(E[i].no)].push_back( E[i].no );\n  \n \n\n  int cnt = 0;\n  do{\n    if( M == 0 ) continue;\n    cnt++;\n    for(int i=0;i<M;i++){\n      if( E[i].flag ) continue;\n      E[i].flag = 1;\n      break;\n    }\n    while( update() );\n    \n  } while( !check() );\n  cout << cnt << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nint main() {\n  int n,m;\n  cin>>n>>m;\n  vector<int> v[n];\n  for(int i=0; i<m; i++) {\n    int x,y;\n    cin>>x>>y;\n    x--,y--;\n    v[x].push_back(y);\n  }\n  bool u[n];\n  memset(u,0,sizeof(u));\n  int ans=0;\n  for(int i=0; i<n; i++) {\n    if(u[i]) continue;\n    ans++;\n    u[i]=1;\n    queue<int> que;\n    que.push(i);\n    while(!que.empty()) {\n      int x=que.front();que.pop();\n      ans+=v[x].size()-1;\n      for(int i=0; i<v[x].size(); i++) {\n        int y=v[x][i];\n        if(u[y]) continue;\n        u[y]=1;\n        que.push(y);\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\nvector<int> G[600];\nint ans=0;\nbool vis[600]={};\nvoid dfs(int r){\n\tvis[r]=1;\n\tfor(auto v:G[r]){\n\t\tif(vis[v])ans++;\n\t\telse dfs(v);\n\t}\n}\n\n\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\t\n \tint n,m;\n \tcin>>n>>m;\n \t\n \tfor(int i=1;i<=m;i++){\n \t\tint y,yy;\n \t\tcin>>y>>yy;\n \t\tG[y].pb(yy);\n \t}\n \tans=0;\n \tfor(int i=1;i<=n;i++)if(!vis[i]){\n \t\tdfs(i);\n \t}\n \tcout<<ans<<endl;\n \t\n \treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <map>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct UnionFind{\n\tint size;\n\tvector<int> parent;\n\t\n\tUnionFind(){}\n\tUnionFind(int size){\n\t\tthis->size = size;\n\t\tparent.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 0; i <= size; i++) parent[i] = i;\n\t}\n\tint root(int i){\n\t\tif(parent[i] == i) return i;\n\t\treturn parent[i] = root(parent[i]);\n\t}\n\tbool same(int i, int j){\n\t\treturn root(i) == root(j);\n\t}\n\tvoid unite(int i, int j){\n\t\tint root_i = root(i), root_j = root(j);\n\t\tif(root_i == root_j) return;\n\t\tparent[root_i] = root_j;\n\t}\n};\n\nint n, m;\nUnionFind uf(505);\nP edge[3005];\nmap<int, P> mp;\n\n\nint main(void)\n{\n\twhile(cin >> n){\n\t\tcin >> m;\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint s, t;\n\t\t\tcin >> s >> t;\n\t\t\tedge[i] = make_pair(s, t);\n\t\t}\n\t\t\n\t\tuf.init();\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tuf.unite(edge[i].first, edge[i].second);\n\t\t}\n\t\t\n\t\tmp.clear();\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tmp[uf.root(i)].first++;\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tmp[uf.root(edge[i].first)].second++;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(auto it = mp.begin(); it != mp.end(); it++){\n\t\t\tans += it->second.second - it->second.first + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint N, M;\nvector< vector< int > > adj;\nvector< bool > vis;\n\nint dfs(int v) {\n\tvis[v] = true;\n\t\n\tint res = 0;\n\t\n\tfor (int u : adj[v]) {\n\t\tif (vis[u]) ++res;\n\t\telse res += dfs(u);\n\t}\n\t\n\treturn res;\n}\n\nint solve() {\n\tvis.assign(N, false);\n\t\n\tint res = 0;\n\t\n\tfor_(v,0,N) {\n\t\tif (vis[v]) continue;\n\t\tres += dfs(v);\n\t}\n\t\n\treturn res;\n}\n\nint main() {\n\tcin >> N >> M;\n\t\n\tadj.assign(N, vector< int >());\n\t\n\tfor_(i,0,M) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\t--s; --t;\n\t\tadj[s].push_back(t);\n\t}\n\t\n\tcout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m;\nbool used[100005];\nvector<int> G[100005];\nvector<int> rG[100005];\nint su=0;\nint ct=0;\n\nvoid dfs(int v){\n\tused[v]=true;\n\tct++;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i]]){\n\t\t\tdfs(G[v][i]);\n\t\t}\n\t}\n\tsu+=G[v].size();\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\trG[b].push_back(a);\n\t}\n\tint cnt=0;\n\tint ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(!used[i]){\n\t\t\tcnt++;\n\t\t\tct=0;\n\t\t\tsu=0;\n\t\t\tdfs(i);\n\t\t\tans+=su-(ct-1);\n\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nvector<int> G[500];\nbool vis[500];\nint n,m,ans;\nvoid dfs(int v){\n\tvis[v]=1;\n\tn++;\n\tfor(int u:G[v]){\n\t\tm++;\n\t\tif(!vis[u]) dfs(u);\n\t}\n}\nint main(){\n\tint N,M,ans=0;\n\tcin>>N>>M;\n\trep(i,M){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tG[a-1].pb(b-1);\n\t}\n\trep(i,N) if(!vis[i]){\n\t\tn=m=0;\n\t\tdfs(i);\n\t\tans+=m-(n-1);\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nstruct aa {\n\tint f;\n\tint t;\n\tint id;\n};\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<pair<int,int>>>nums(N);\n\tvector<aa>ps;\n\tint id = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint s, t; cin >> s >> t;\n\t\ts--; t--;\n\t\tnums[s].emplace_back(t,id); nums[t].emplace_back(s,id);\n\t\tps.push_back(aa{ s, t,id++ });\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\n\t\tsort(nums[i].begin(), nums[i].end());\n\t}\n\tvector<int>oks(M, false);\n\n\tint now = 0;\n\tint ans = 0;\n\twhile (1) {\n\t\tif (nums[ps[now].f].size() >= 2 && nums[ps[now].t].size() >= 2) {\n\t\t\tans++;\n\t\t\tassert(!oks[now]);\n\t\t\tqueue<int>que;\n\t\t\tque.push(now);\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint atop(que.front());\n\t\t\t\tque.pop();\n\t\t\t\tif (oks[atop])continue;\n\t\t\t\toks[atop] = true;\n\t\t\t\tauto p = ps[atop];\n\t\t\t\tnums[p.f].erase(lower_bound(nums[p.f].begin(),nums[p.f].end(),make_pair(p.t,atop)));\n\t\t\t\tnums[p.t].erase(lower_bound(nums[p.t].begin(), nums[p.t].end(), make_pair(p.f, atop)));\n\t\t\t\tif (nums[p.f].size() == 1) {\n\t\t\t\t\tif (!oks[nums[p.f][0].second]) {\n\n\t\t\t\t\t\tque.push(nums[p.f][0].second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nums[p.t].size() == 1) {\n\t\t\t\t\tif (!oks[nums[p.t][0].second]) {\n\n\t\t\t\t\t\tque.push(nums[p.t][0].second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tassert(oks[now]);\n\t\t}\n\t\tnow++;\n\t\tif (now == ps.size())break;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n\nusing namespace std;\n\nmultiset<int> edges[523];\n\nvoid erase(int v){\n  while(edges[v].size()==1){\n    int nv=*edges[v].begin();\n    edges[nv].erase(edges[nv].find(v));\n    edges[v].clear();\n    v=nv;\n  }\n}    \n\nint main(){\n  int N,M;\n  cin>>N>>M;\n  for(int i=0;i<M;i++){\n    int s,t;\n    cin>>s>>t;\n    edges[s].insert(t);\n    edges[t].insert(s);\n  }\n  int ans=0;\n  for(;;){\n    int m=1e9;\n    int x;\n    for(int i=1;i<=N;i++){\n      if(!edges[i].empty()&&edges[i].size()<m){\n\tm=edges[i].size();\n\tx=i;\n      }\n    }\n    if(m>1e8)break;\n    while(!edges[x].empty()){\n      ans++;\n      auto it=edges[x].begin();\n      int t=*it;\n      edges[x].erase(it);\n      edges[t].erase(edges[t].find(x));\n      erase(t);\n      erase(x);\n    }\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct edge{\n  int to,from;  \n  edge(int to,int from) :\n    to(to), from(from) {}\n  edge(){}\n};\n\nint N,M;\nbool used[5000];\nset<int> G[555];\nvector<edge> E;\n\nint main(){\n  cin >> N >> M;  \n  for(int i=0;i<M;i++){\n    int s,t; cin >> s >> t;\n    --s; --t;\n    E.push_back( edge(t,s) );\n    G[s].insert( i );\n    G[t].insert( i );\n  }\n  bool ed = true;\n  int res = 0;\n  while( ed ){\n    int minid=0;\n    while( G[minid].empty() ) minid++;\n    for(int i=0;i<N;i++){\n      if( G[i].empty() ) continue;\n      if( G[minid].size() > G[i].size()  ) minid = i;\n    }\n    //   cout << G[minid].size() << endl;\n    res += G[minid].size()-1;\n    for(auto it = G[minid].begin(); it != G[minid].end(); it++ ){\n      used[*it] = true;\n      // cout << \"new \" << *it << endl;\n      for(int i=0;i<N;i++){\n        if( i == minid ) continue;\n        G[i].erase(*it);\n      }\n    }\n    G[minid].clear();\n    ed = false;\n    for(int i=0;i<M;i++)\n      if( !used[i] ) ed = true;\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define rep1(i,n) for(int i = 1; i < n; i++)\n#define repv(i,n) for(int i = n-1; i >= 0; i--)\n#define fi first\n#define sc second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\n\nchar BUF[3500000];\ninline void I(int&a){scanf(\"%d\",&a);}\ninline void I(int&a,int&b){scanf(\"%d%d\",&a,&b);}\ninline void I(int&a,int&b,int&c){scanf(\"%d%d%d\",&a,&b,&c);}\ninline void I(int&a,int&b,int&c,int&d){scanf(\"%d%d%d%d\",&a,&b,&c,&d);}\ninline void L(ll&a){scanf(\"%lld\",&a);}\ninline void L(ll&a,ll&b){scanf(\"%lld%lld\",&a,&b);}\ninline void L(ll&a,ll&b,ll&c){scanf(\"%lld%lld%lld\",&a,&b,&c);}\ninline void L(ll&a,ll&b,ll&c,ll&d){scanf(\"%lld%lld%lld%lld\",&a,&b,&c,&d);}\ninline void S(string&str){str.clear();scanf(\"%s\",BUF);int s=strlen(BUF);rep(i,s)str.pb(BUF[i]);}\ninline void SV(vector<int>&v){v.clear();scanf(\"%s\",BUF);int s=strlen(BUF);rep(i,s)if('a'<=BUF[i]&&BUF[i]<='z')v.pb(BUF[i]-'a');else v.pb(BUF[i]-'A');}\n\nconst auto EPS = 1e-10;\nconst auto INF = 100000000;\nconst auto MOD = 1000000007;\ntypedef pair<ll,ll> P;\n\n#define MAX_N 500\n\nstruct UF{\n\tint par[MAX_N];\n\tint rank[MAX_N];\n\tint si[MAX_N];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsi[i] = 1;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t\tsi[y] += si[x];\n\t\t} else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t\tsi[x] += si[y];\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n} uf;\n\nint n, m;\nvector<int> e[500];\nbool saw[500];\n\nint dfs(int v){\n    saw[v] = true;\n    int ret = 0;\n    rep(i,e[v].size()){\n        if(saw[e[v][i]]) ret++;\n        else ret += dfs(e[v][i]);\n    }\n    return ret;\n}\n\nint main(){\n    I(n,m);\n    uf.init(n);\n    rep(i,m){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        e[a].push_back(b);\n        uf.unite(a,b);\n    }\n    int ans = dfs(0);\n    ans--;\n    rep(i,n) if(uf.par[i] == i) ans++;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst double EPS = 1e-8;\nusing vec = vector<double>;\nusing mat = vector<vec>;\n\n// 行列の階数を求める\n// 係数行列と拡大係数行列の階数が異なるときは不能\n// 係数行列と拡大係数行列の階数が等しく、係数行列の階数と変数の個数が異なるときは不定\n// 係数行列と拡大係数行列の階数と変数の個数がすべて等しいときは一意解が存在\nint mat_rank(mat A){\n    const int R = A.size(), C = A[0].size();\n    int ret = 0;\n    for(int i=0; ret<R&&i<C; ++i){\n        int pivot = ret;\n        for(int j=ret+1; j<R; ++j){\n            if(abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n        }\n        swap(A[pivot], A[ret]);\n\n        if(abs(A[ret][i]) < EPS) continue;\n\n        for(int k=C-1; k>=i; --k) A[ret][k] /= A[ret][i];\n        for(int j=ret+1; j<R; ++j){\n            for(int k=C-1; k>=i; --k) A[j][k] -= A[ret][k]*A[j][i];\n        }\n        ++ret;\n    }\n    return ret;\n}\n\nint main(){\n    int n,m;\n    cin >>n >>m;\n\n    mat Ab(n, vec(m+1));\n    rep(i,m){\n        int s,t;\n        cin >>s >>t;\n        --s;\n        --t;\n\n        Ab[s][i] = -1;\n        Ab[t][i] = 1;\n    }\n\n    cout << m - mat_rank(Ab) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n#include <bitset>\n \nusing namespace std;\ntypedef long long ll;\n\ntemplate <int N>\nstruct UnionFind {\n    int ig[N];\n    vector<int> gi[N];\n    int gn;\n    /// UnionFind???????????°n??§???????????????\n    void init(int n = N) {\n        for (int i = 0; i < n; ++i) {\n            ig[i] = i;\n            gi[i] = {i};\n        }\n        gn = n;\n    }\n\n    /// ??????a??¨??????b????????????\n    void merge(int a, int b) {\n        if (same(a, b)) return;\n        gn--;\n        int x = ig[a], y = ig[b];\n        if (gi[x].size() < gi[y].size()) swap(x, y);\n        for (int j: gi[y]) {\n            ig[j] = x;\n        }\n        gi[x].insert(gi[x].end(), gi[y].begin(), gi[y].end());\n        gi[y].clear();\n    }\n    /// ??????a??¨??????b???????????°????????????????±?????????????????????????\n    bool same(int a, int b) {\n        return ig[a] == ig[b];\n    }\n    /// ??°??????????????°\n    int group_num() {\n        return gn;\n    }\n};\n\nconst int MN = 550;\nUnionFind<MN> uf;\n\nbool solve() {\n    int n, m;\n    if (scanf(\"%d %d\", &n, &m) != 2) return false;\n    uf.init(n);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b); a--; b--;\n        uf.merge(a, b);\n    }\n    printf(\"%d\\n\", m-n+uf.group_num());\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#include<vector>\nstruct UF{\n\tint n;\n\tvector<int>parent,rank;\n\tUF(int n_=0):n(n_),parent(n_),rank(n_,1)\n\t{\n\t\tfor(int i=0;i<n_;i++)parent[i]=i;\n\t}\n\tint find(int a){return parent[a]!=a?parent[a]=find(parent[a]):a;}\n\tbool same(int a,int b){return find(a)==find(b);}\n\tbool unite(int a,int b)\n\t{\n\t\ta=find(a),b=find(b);\n\t\tif(a==b)return false;\n\t\tif(rank[a]<rank[b])\n\t\t{\n\t\t\tparent[a]=b;\n\t\t\trank[b]+=rank[a];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[b]=a;\n\t\t\trank[a]+=rank[b];\n\t\t}\n\t\treturn true;\n\t}\n\tint size(int a){return rank[find(a)];}\n};\nint N,M;\nvector<int>G[500];\nmain()\n{\n\tcin>>N>>M;\n\tUF uf(N);\n\tint ans=N;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint u,v;cin>>u>>v;\n\t\tu--,v--;\n\t\tG[u].push_back(v);\n\t\tans-=uf.unite(u,v);\n\t}\n\tfor(int i=0;i<N;i++)ans+=G[i].size()-1;\n\tcout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nstruct UnionFind{\n  vector<int> v;\n  UnionFind(int n) : v(n, -1) {}\n  void init(){ for(int i = 0;i < v.size();i++)v[i]=-1; }\n  int find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    v[x] += v[y]; v[y] = x;\n    return true;\n  }\n  bool root(int x) { return v[x] < 0; }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return -v[find(x)]; }\n};\n\nint n,m;\n\nint main(){\n  cin>>n>>m;\n  int cnt=0;\n  UnionFind uf(n);\n  rep(i,m){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    cnt+=uf.unite(a,b);\n  }\n  cout<<m-cnt<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 505\nusing namespace std;\n\nint n, m, used[N];\nvector<int> G[N];\n\nint dfs(int x){\n  \n  if(used[x]) return 0;\n  used[x]=1;\n  \n  int res=0;\n\n  for(int i=0;i<G[x].size();i++) res+=dfs(G[x][i]);\n  \n  return res+G[x].size()-1;\n}\n\nint main(){\n  \n  cin>>n>>m;\n  \n  for(int i=0;i<m;i++){\n    int s, t;\n    cin>>s>>t;\n    G[s-1].push_back(t-1);\n  }\n\n  int ans=0;\n  \n  for(int i=0;i<n;i++)\n    if(!used[i]) ans+=dfs(i)+1;\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct edge{\n  int to,from,no,flag;\n};\nint N,M;\nvector<int> same[3111];\nvector<int> Gs[511],Gn[511];\nedge E[3111];\nstruct uni{\n  int d[3111];\n  void init(){ memset(d,-1,sizeof(d)); }\n  int find(int a){ return d[a]<0?a:(d[a] = find(d[a])); }\n  void marge(int a,int b){\n    a = find(a), b = find(b);\n    if( a == b ) return;\n    if( d[a] > d[b] ) swap(a,b);\n    d[a] += d[b]; d[b] = a;   \n  }\n};\nuni U;\n\nvoid view(){\n  cout << \"view\" << endl;\n  for(int i=0;i<M;i++){\n    cout << E[i].flag << endl;\n  }\n}\n\nbool check(){\n  //  view();\n  for(int i=0;i<M;i++) if( !E[i].flag ) return false;\n  return true;\n}\n\nbool update(){\n  //  view();\n  bool ret = false;\n  for(int i=0;i<M;i++){\n    if( E[i].flag ) {\n      int p = U.find(i);\n      if( same[p].empty() ) continue;\n      \n      for(int i=0;i<(int)same[p].size();i++)\n\tE[same[p][i]].flag = 1;\n      ret = true;\n      same[p].clear();\n    }\n  }\n  for(int i=0;i<N;i++){\n    vector<int> e;\n    for(int j=0;j<(int)Gs[i].size();j++)\n      if( !E[Gs[i][j]].flag ) e.push_back( Gs[i][j] );\n    for(int j=0;j<(int)Gn[i].size();j++)\n      if( !E[Gn[i][j]].flag ) e.push_back( Gn[i][j] );\n    if(e.size()==1) {\n      E[e[0]].flag = 1;      \n      ret = true;\n    }\n \n  }\n  return ret;\n}\n\nint main(){\n  \n  cin >> N >> M;\n  for(int i=0;i<M;i++){\n    int s,t; cin >> s>> t;\n    E[i] = (edge){s,t,i,0};\n    Gs[s].push_back(i);\n    Gn[t].push_back(i);\n  }\n\n  U.init();\n  for(int i=0;i<N;i++)\n    if( Gs[i].size() == 1 && Gn[i].size() ==1 )\n      U.marge(Gs[i][0],Gn[i][0]);\n  for(int i=0;i<M;i++)\n    same[U.find(E[i].no)].push_back( E[i].no );\n  \n \n  \n  int cnt = 0;\n  do{\n    cnt++;\n    for(int i=0;i<M;i++){\n      if( E[i].flag ) continue;\n      E[i].flag = 1;\n      break;\n    }\n    while( update() );\n    \n  } while( !check() );\n  cout << cnt << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define rep1(i,n) for(int i = 1; i < n; i++)\n#define repv(i,n) for(int i = n-1; i >= 0; i--)\n#define fi first\n#define sc second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\n\nchar BUF[3500000];\ninline void I(int&a){scanf(\"%d\",&a);}\ninline void I(int&a,int&b){scanf(\"%d%d\",&a,&b);}\ninline void I(int&a,int&b,int&c){scanf(\"%d%d%d\",&a,&b,&c);}\ninline void I(int&a,int&b,int&c,int&d){scanf(\"%d%d%d%d\",&a,&b,&c,&d);}\ninline void L(ll&a){scanf(\"%lld\",&a);}\ninline void L(ll&a,ll&b){scanf(\"%lld%lld\",&a,&b);}\ninline void L(ll&a,ll&b,ll&c){scanf(\"%lld%lld%lld\",&a,&b,&c);}\ninline void L(ll&a,ll&b,ll&c,ll&d){scanf(\"%lld%lld%lld%lld\",&a,&b,&c,&d);}\ninline void S(string&str){str.clear();scanf(\"%s\",BUF);int s=strlen(BUF);rep(i,s)str.pb(BUF[i]);}\ninline void SV(vector<int>&v){v.clear();scanf(\"%s\",BUF);int s=strlen(BUF);rep(i,s)if('a'<=BUF[i]&&BUF[i]<='z')v.pb(BUF[i]-'a');else v.pb(BUF[i]-'A');}\n\nconst auto EPS = 1e-10;\nconst auto INF = 100000000;\nconst auto MOD = 1000000007;\ntypedef pair<ll,ll> P;\n\n#define MAX_N 500\n\nstruct UF{\n\tint par[MAX_N];\n\tint rank[MAX_N];\n\tint si[MAX_N];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsi[i] = 1;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t\tsi[y] += si[x];\n\t\t} else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t\tsi[x] += si[y];\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n} uf;\n\nint n, m;\nvector<int> e[500];\nbool saw[500];\n\nint dfs(int v){\n    saw[v] = true;\n    int ret = 0;\n    rep(i,e[v].size()){\n        if(saw[e[v][i]]) ret++;\n        else ret += dfs(e[v][i]);\n    }\n    return ret;\n}\n\nint main(){\n    I(n,m);\n    uf.init(n);\n    rep(i,m){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        e[a].push_back(b);\n        uf.unite(a,b);\n    }\n    int ans = dfs(0);\n    ans--;\n    rep(i,n) if(uf.par[i] == i) ans++;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define ALL(x) begin(x), end(x)\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\ntypedef double R;\nconstexpr R EPS = 1e-8;\n\ntypedef vector<R> vec;\ntypedef vector<vec> mat;\n\nint rank_of(const mat& A) {\n\tconst int n = A.size();\n\tconst int m = A[0].size();\n\n\tmat B(A);\n\tint res = 0;\n\tint col = -1;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tint pivot = -1;\n\t\tfor(;;) {\n\t\t\tif(++col == m) goto rank_end;\n\n\t\t\tfor(int j = i; j < n; ++j) {\n\t\t\t\tif(abs(B[j][col]) > EPS) {\n\t\t\t\t\tpivot = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pivot != -1) break;\n\t\t}\n\n\t\tB[i].swap(B[pivot]);\n\t\t++res;\n\n\t\tfor(int j = col + 1; j < m; ++j) {\n\t\t\tB[i][j] /= B[i][col];\n\t\t}\n\n\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\tif(abs(B[j][col]) > EPS) {\n\t\t\t\tfor(int k = col + 1; k < m; ++k) {\n\t\t\t\t\tB[j][k] -= B[j][col] * B[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nrank_end:;\n\treturn res;\n}\n\nint rank_of(const mat& A, const vec& b) {\n\tconst int n = A.size();\n\n\tmat B(A);\n\tfor(int i = 0; i < n; ++i) {\n\t\tB[i].emplace_back(b[i]);\n\t}\n\treturn rank_of(B);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tmat A(n, vec(m, 0));\n\n\tfor(int i = 0; i < m; ++i) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tA[s - 1][i] = 1;\n\t\tA[t - 1][i] = -1;\n\t}\n\n\tcout << m - rank_of(A) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,a,b,m;\nvector<int>v[501];\nbool used[501];\nvoid dfs(int x){\n  used[x]=1;\n  for(int i=0;i<v[x].size();i++)\n    if(!used[v[x][i]])dfs(v[x][i]);\n}\nmain(){\n  cin>>n>>m;\n  for(int i=0;i<m;i++)\n    cin>>a>>b,\n    v[a].push_back(b);\n \n  int sum=0,aa=0;\n\n  for(int i=1;i<=n;i++)\n    if(!used[i])dfs(i),aa++;\n  \n  for(int i=1;i<=n;i++)\n    sum+=v[i].size()-1;\n\n  cout<<sum+aa<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint N,M;\n\nsigned main(){\n    cin>>N>>M;\n    UnionFindTree uf(N);\n    rep(i,M){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        uf.unite(a,b);\n    }\n\n    int cnt=0;\n    rep(i,N)if(uf.find(i)==i)cnt++;\n    cout<<M-N+cnt<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 1000\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n\n#define rank Asdfiasofsad\nclass UF{\npublic:\n  int V;\n  vector<int> par,rank;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0){for(int i=0;i<V;i++)par[i]=i;}\n  \n  int find(int x){\n    assert(x < V);\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])par[x]=y;\n    else{\n      par[y]=x;\n      if(rank[x]==rank[y])rank[x]++;\n    }\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nint n,m;\nvector<int> G[N];\n\nint used[N];\nint dfs(int pos){\n  if(used[pos]++) return 0;\n  int res = G[pos].size() - 1;\n  for(int to:G[pos]) res += dfs(to);\n  return res;\n}\n\nsigned main(){\n  cin>>n>>m;\n  UF uf(n);\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b; a--,b--;\n    G[a].push_back(b);\n    uf.unite(a,b);\n  }\n  \n  map<int,int> val;\n  for(int i=0;i<n;i++){\n    memset(used,0,sizeof(used));\n    int v = dfs(i);\n    if(val.count(uf.find(i))) Min(val[uf.find(i)],v);\n    else val[uf.find(i)] = v;\n  }\n\n  int sum = 0;\n  typedef pair<int,int> P;\n  for(P p:val) sum += p.second+1;\n  cout<<sum<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct edge{\n  int to,from;  \n  edge(int to,int from) :\n    to(to), from(from) {}\n  edge(){}\n};\n\nint N,M;\nbool used[5000];\nset<int> G[555];\nvector<edge> E;\n\nint main(){\n  cin >> N >> M;  \n  for(int i=0;i<M;i++){\n    int s,t; cin >> s >> t;\n    --s; --t;\n    E.push_back( edge(t,s) );\n    G[s].insert( i );\n    G[t].insert( i );\n  }\n  if( M == 0 ) {\n    cout << 0 << endl;\n    return 0;\n  }\n  bool ed = true;\n  int res = 0;\n  while( ed ){\n    int minid=0;\n    while( G[minid].empty() ) minid++;\n    for(int i=0;i<N;i++){\n      if( G[i].empty() ) continue;\n      if( G[minid].size() > G[i].size()  ) minid = i;\n    }\n    //   cout << G[minid].size() << endl;\n    res += G[minid].size()-1;\n    for(auto it = G[minid].begin(); it != G[minid].end(); it++ ){\n      used[*it] = true;\n      // cout << \"new \" << *it << endl;\n      for(int i=0;i<N;i++){\n        if( i == minid ) continue;\n        G[i].erase(*it);\n      }\n    }\n    G[minid].clear();\n    ed = false;\n    for(int i=0;i<M;i++)\n      if( !used[i] ) ed = true;\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 500\n\nint V,E;\nint ans;\nvector<int> G[NUM];\nbool visited[NUM];\n\nvoid recursive(int node_id,bool is_first){\n\n\tvisited[node_id] = true;\n\n\tif(!is_first){\n\t\t/*最初の頂点以外は、出次数-1のエッジを残す\n\t\t (再帰的に考えると、入次の情報は分っているので、残りの1本は引き算で計算できる)\n\t\t */\n\t\tans += (int)G[node_id].size()-1;\n\t}\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(visited[G[node_id][i]])continue;\n\t\trecursive(G[node_id][i],false);\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < V; i++)G[i].clear();\n\n\tint from,to;\n\tfor(int loop = 0; loop < E; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tG[from].push_back(to);\n\t}\n\n\tfor(int i = 0; i < V; i++)visited[i] = false;\n\n\tans = 0;\n\tfor(int i = 0; i < V; i++){\n\t\tif(visited[i])continue;\n\t\tans += (int)G[i].size(); //最初の頂点は、すべての出次エッジを残す\n\t\trecursive(i,true);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 1000\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n\n#define rank Asdfiasofsad\nclass UF{\npublic:\n  int V;\n  vector<int> par,rank;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0){for(int i=0;i<V;i++)par[i]=i;}\n  \n  int find(int x){\n    assert(x < V);\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])par[x]=y;\n    else{\n      par[y]=x;\n      if(rank[x]==rank[y])rank[x]++;\n    }\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nint n,m;\nvector<int> G[N];\n\nint used[N];\nint dfs(int pos){\n  if(used[pos]++) return 0;\n  int res = G[pos].size() - 1;\n  for(int to:G[pos]) res += dfs(to);\n  return res;\n}\n\nsigned main(){\n  cin>>n>>m;\n  UF uf(n);\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b; a--,b--;\n    G[a].push_back(b);\n    uf.unite(a,b);\n  }\n  \n  map<int,int> val;\n  for(int i=0;i<n;i++){\n    memset(used,0,sizeof(used));\n    int v = dfs(i);\n    if(val.count(uf.find(i))) Min(val[uf.find(i)],v);\n    else val[uf.find(i)] = v;\n  }\n\n  int sum = 0;\n  typedef pair<int,int> P;\n  for(P p:val) sum += p.second+1;\n  cout<<sum<<endl;\n  \n  return 0;\n}\n#include <bits/stdc++.h>\n#define int long long\n#define N 1000\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n\n#define rank Asdfiasofsad\nclass UF{\npublic:\n  int V;\n  vector<int> par,rank;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0){for(int i=0;i<V;i++)par[i]=i;}\n  \n  int find(int x){\n    assert(x < V);\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])par[x]=y;\n    else{\n      par[y]=x;\n      if(rank[x]==rank[y])rank[x]++;\n    }\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nint n,m;\nvector<int> G[N];\n\nint used[N];\nint dfs(int pos){\n  if(used[pos]++) return 0;\n  int res = G[pos].size() - 1;\n  for(int to:G[pos]) res += dfs(to);\n  return res;\n}\n\nsigned main(){\n  cin>>n>>m;\n  UF uf(n);\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b; a--,b--;\n    G[a].push_back(b);\n    uf.unite(a,b);\n  }\n  \n  map<int,int> val;\n  for(int i=0;i<n;i++){\n    memset(used,0,sizeof(used));\n    int v = dfs(i);\n    if(val.count(uf.find(i))) Min(val[uf.find(i)],v);\n    else val[uf.find(i)] = v;\n  }\n\n  int sum = 0;\n  typedef pair<int,int> P;\n  for(P p:val) sum += p.second+1;\n  cout<<sum<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nbool used[555];\nset<int> G[555];\nvoid dfs(int v){\n  if(used[v]) return;\n  used[v]=1;\n  for(int u:G[v]) dfs(u);\n}\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    int s,t;\n    cin>>s>>t;\n    s--;t--;\n    G[s].insert(t);\n  }\n  memset(used,0,sizeof(used));\n  int cnt=0;\n  for(int i=0;i<n;i++){\n    if(used[i]) continue;\n    cnt++;\n    dfs(i);\n  }\n  cout<<m-n+cnt<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n\n/* verified AOJ1327 One-Dimensional Cellular Automaton\n~Matrix~\n??????????°????????¨?????????§??????\nvector iostream cmath cassert ??????\nMatrix a(VV), b(VV);\n?????????:a*b\n????????????:l*a\n???:a+b\n???:a-b\n??¢???:a.transport()\n?????????:a.cofactor()\n?????????:a.det()\na???i???j??????:a.get(i,j)???\na???i??????j?????????k?????£??\\:set(i,j,k)\n????????????a[i][j] (a[i][j]=k)\na???x???:a.pow(x)\nn*n?????¬??????E:Matrix(n)\nm*n 0??????:Matrix(m,n)\nm*n ??¨????´????p?????????:Matrix(m,n,p)\nRow???row??§????????????(m*1??????):Matrix(row)\n**(??´??°??????)**\n????§????:a.triangulate()\n?????????:a.rank()\n?????????:a.inverse()\n//(????????????a.det()?????????a.pre_inverse()??§?±??????? ??´??°???)\n??¬??????????¶???????:a.rowReduction()\n//??£???????¬?????¨????????§£??????\n***\n*/\n\n#include <vector>\n#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\ntypedef int Elem;\ntypedef vector<Elem> Row;\ntypedef vector<Row> VV;\n\ntypedef long double ld;\nconst ld EPS = 1e-11;\n\nconst bool isZero(const Elem e) {\n\treturn abs(e) < EPS;\n}\n\nstruct Matrix {\n\tVV matrix;\n\tint n, m;\n\n\tMatrix(const VV &matrix_);\n\texplicit Matrix(int n_);\n\texplicit Matrix(const Row &row);\n\tMatrix(int m_, int n_);\n\tMatrix(int m_, int n_, Elem e);\n\n\tconst Elem get(const int i, const int j) const;\n\tvoid set(const int x, const int y, const Elem k);\n\n\tconst Matrix operator + (const Matrix &rhs) const;\n\tconst Matrix operator * (const Matrix &rhs) const;\n\tconst Matrix operator - (const Matrix &rhs) const;\n\tMatrix &operator += (const Matrix &rhs);\n\tMatrix &operator *= (const Matrix &rhs);\n\tMatrix &operator -= (const Matrix &rhs);\n\n\tRow &operator[](const int x);\n\n\tconst Matrix transport() const;\n\tconst Matrix pow(int x) const;\n\tconst Matrix cofactor(int x, int y) const;\n\tconst Elem det() const;\n\n\tconst Matrix triangulate() const;\n\tconst int rank() const;\n\n\t//?????????????????¨????????°???(?????????)*(?????????)?????????\n\t//A:matrix,return det A * A^-1\n\tconst Matrix pre_inverse() const;\n\tconst Matrix inverse() const;\n\tconst Matrix rowReduction() const;\n};\n\nconst Matrix operator * (const Elem lambda, const Matrix &rhs) {\n\tMatrix tmp(rhs);\n\tfor (int i = 0; i < rhs.m; i++)\n\t\tfor (int j = 0; j < rhs.n; j++)\n\t\t\ttmp.set(i, j, tmp.get(i, j) * lambda);\n\treturn tmp;\n}\n\nMatrix::Matrix(const VV &matrix_) : matrix(matrix_) {\n\tm = matrix_.size();\n\tif (m == 0) n = 0;\n\telse n = matrix_[0].size();\n}\nMatrix::Matrix(int n_) : m(n_), n(n_) {\n\tmatrix = VV(n, Row(n, 0));\n\tfor (int i = 0; i < n; ++i)\n\t\tset(i, i, 1);\n}\nMatrix::Matrix(const Row &row) : m(1), n(row.size()), matrix(VV(1, row)) {\n\t//size???m???vector<Elem>??????mx1???????????????\n\t(*this) = transport();\n}\nMatrix::Matrix(int m_, int n_) : m(m_), n(n_) {\n\tmatrix = VV(m, Row(n, 0));\n}\nMatrix::Matrix(int m_, int n_, Elem e) : m(m_), n(n_) {\n\tmatrix = VV(m, Row(n, e));\n}\n\nconst Elem Matrix::get(const int i, const int j) const {\n\tif (0 <= i && i < m && 0 <= j && j < n)\n\t\treturn matrix[i][j];\n\n\tcerr << \"get(\" << i << \",\" << j << \")is not exist.\" << endl;\n\tthrow;\n}\nvoid Matrix::set(const int i, const int j, const Elem k) {\n\tif (0 <= i && i < m && 0 <= j && j < n) {\n\t\t*(matrix[i].begin() + j) = k;\n\t\treturn;\n\t}\n\tcerr << \"set(\" << i << \",\" << j << \")is not exist.\" << endl;\n\tthrow;\n}\n\nconst Matrix Matrix::operator + (const Matrix &rhs) const {\n\tassert(m == rhs.m && n == rhs.n);\n\n\tMatrix tmp(m, n, 0);\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\ttmp.set(i, j, get(i, j) + rhs.get(i, j));\n\t\t}\n\t}\n\treturn tmp;\n}\n\nconst Matrix Matrix::operator * (const Matrix &rhs) const {\n\tassert(n == rhs.m);\n\n\tMatrix tmp(m, rhs.n, 0);\n\tElem sum;\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < rhs.n; j++) {\n\t\t\tsum = 0;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tsum += get(i, k) * rhs.get(k, j);\n\t\t\t}\n\t\t\ttmp.set(i, j, sum);\n\t\t}\n\treturn tmp;\n}\n\nconst Matrix Matrix::operator - (const Matrix &rhs) const {\n\treturn *this + ((Elem)-1 * rhs);\n}\n\nMatrix &Matrix::operator += (const Matrix &rhs) {\n\treturn *this = *this + rhs;\n}\n\nMatrix &Matrix::operator *= (const Matrix &rhs) {\n\treturn *this = *this * rhs;;\n}\n\nMatrix &Matrix::operator -= (const Matrix &rhs) {\n\treturn *this = *this - rhs;\n}\n\nRow &Matrix::operator[](const int x) {\n\treturn matrix[x];\n}\n\nconst Matrix Matrix::transport() const {\n\tVV tmp;\n\tfor (int i = 0; i < n; i++) {\n\t\tRow row;\n\t\tfor (int j = 0; j < m; j++)\n\t\t\trow.push_back(get(j, i));\n\t\ttmp.push_back(row);\n\t}\n\treturn tmp;\n}\n\nconst Matrix Matrix::pow(int x) const {\n\tMatrix tmp(*this), e(m);\n\tfor (int i = 1; i <= x; i <<= 1) {\n\t\tif ((x & i) > 0)\n\t\t\te = e * tmp;\n\t\ttmp = tmp * tmp;\n\t}\n\treturn e;\n}\n\nconst Matrix Matrix::cofactor(int x, int y) const {\n\tVV tmp;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (x == i) continue;\n\t\tRow row;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (y == j) continue;\n\t\t\trow.push_back(get(i, j));\n\t\t}\n\t\ttmp.push_back(row);\n\t}\n\treturn Matrix(tmp);\n}\n\nconst Elem Matrix::det() const {\n\tassert(n == m);\n\n\tif (m == 1)\n\t\treturn get(0, 0);\n\tElem sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tsum += ((i % 2 == 0 ? 1 : -1) * get(i, 0)) * Matrix(cofactor(i, 0)).det();\n\t}\n\treturn sum;\n}\n\nconst Matrix Matrix::triangulate() const {\n\tMatrix tmp(*this);\n\tElem e;\n\tint p = 0;\n\tfor (int i = 0; i < m && p < n; i++, p++) {\n\t\tif (isZero(tmp.get(i, p))) {\n\t\t\ttmp.set(i, p, 0);\n\t\t\tbool flag = true;\n\t\t\tfor (int j = i + 1; j < m; j++)\n\t\t\t\tif (!isZero(tmp.get(j, p))) {\n\t\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t\t\ttmp.set(i, k, tmp.get(i, k) + tmp.get(j, k));\n\t\t\t\t\t//tmp[i].swap(tmp[j]);\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor (int j = i + 1; j < m; j++) {\n\t\t\te = tmp.get(j, p) / tmp.get(i, p);\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\ttmp.set(j, k, tmp.get(j, k) - tmp.get(i, k) * e);\n\t\t}\n\t}\n\treturn tmp;\n}\n\nconst int Matrix::rank() const {\n\tMatrix tmp(triangulate());\n\tfor (int i = min(tmp.m - 1, tmp.n - 1); i >= 0; i--) {\n\t\tfor (int j = tmp.n - 1; j >= i; j--)\n\t\t\tif (isZero(tmp.get(i, j)))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn i + 1;\n\t}\n\treturn 0;\n}\n\nconst Matrix Matrix::pre_inverse() const {\n\tassert(m == n);\n\n\tMatrix tmp(m, n, 0);\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\ttmp.set(i, j, ((i + j) % 2 == 0 ? 1 : -1)*cofactor(i, j).det());\n\treturn tmp.transport();\n}\n\n/*O(n!)????£?\nconst Matrix Matrix::inverse() const {\nMatrix tmp(pre_inverse());\nElem e = det();\nassert(!isZero(e));\ntmp = 1 / e * tmp;\nreturn tmp.transport();\n}*/\n\nconst Matrix Matrix::inverse() const {\n\tassert(m == n);\n\n\tMatrix tmp(m, n * 2), tmp2(m, n);\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\ttmp.set(i, j, get(i, j));\n\tfor (int i = 0; i < m; i++)\n\t\ttmp.set(i, i + n, 1);\n\n\ttmp = tmp.rowReduction();\n\n\t//?????????????????¨??????????????????????????§??????\n\tfor (int i = 0; i < m; i++)\n\t\tassert(isZero(tmp.get(i, i) - 1));\n\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\ttmp2.set(i, j, tmp.get(i, j + n));\n\n\treturn tmp2;\n}\n\n/*\na b c j\nd e f k\ng h i l\n\nax+by+cz=j;\ndx+ey+fz=k;\ngx+hy+iz=l;\n\n|\nV\n\n1 0 0 x\n0 1 0 y\n0 0 1 z\n???????????????\n*/\nconst Matrix Matrix::rowReduction() const {\n\tMatrix tmp(*this);\n\tElem e;\n\tint p = 0;\n\tfor (int i = 0; i < m && p < n; i++, p++) {\n\t\tif (isZero(tmp.get(i, p))) {\n\t\t\ttmp.set(i, p, 0);\n\t\t\tbool flag = true;\n\t\t\tfor (int j = i + 1; j < m; j++)\n\t\t\t\tif (!isZero(tmp.get(j, p))) {\n\t\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t\t\ttmp.set(i, k, tmp.get(i, k) + tmp.get(j, k));\n\t\t\t\t\t//tmp[i].swap(tmp[j]);\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\te = 1 / tmp.get(i, p);\n\t\ttmp.set(i, p, 1);\n\t\tfor (int k = i + 1; k < n; k++)\n\t\t\ttmp.set(i, k, tmp.get(i, k)*e);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i == j) continue;\n\t\t\te = tmp.get(j, p);\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\ttmp.set(j, k, tmp.get(j, k) - tmp.get(i, k) * e);\n\t\t}\n\t}\n\treturn tmp;\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<int>>edges(M, vector<int>(N));\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tedges[i][a]++;\n\t\tedges[i][b]--;\n\t}\n\tMatrix mat(edges);\n\tint num=mat.rank();\n\tint ans = M - num;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define rep1(i,n) for(int i = 1; i < n; i++)\n#define repv(i,n) for(int i = n-1; i >= 0; i--)\n#define fi first\n#define sc second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\n\nchar BUF[3500000];\ninline void I(int&a){scanf(\"%d\",&a);}\ninline void I(int&a,int&b){scanf(\"%d%d\",&a,&b);}\ninline void I(int&a,int&b,int&c){scanf(\"%d%d%d\",&a,&b,&c);}\ninline void I(int&a,int&b,int&c,int&d){scanf(\"%d%d%d%d\",&a,&b,&c,&d);}\ninline void L(ll&a){scanf(\"%lld\",&a);}\ninline void L(ll&a,ll&b){scanf(\"%lld%lld\",&a,&b);}\ninline void L(ll&a,ll&b,ll&c){scanf(\"%lld%lld%lld\",&a,&b,&c);}\ninline void L(ll&a,ll&b,ll&c,ll&d){scanf(\"%lld%lld%lld%lld\",&a,&b,&c,&d);}\ninline void S(string&str){str.clear();scanf(\"%s\",BUF);int s=strlen(BUF);rep(i,s)str.pb(BUF[i]);}\ninline void SV(vector<int>&v){v.clear();scanf(\"%s\",BUF);int s=strlen(BUF);rep(i,s)if('a'<=BUF[i]&&BUF[i]<='z')v.pb(BUF[i]-'a');else v.pb(BUF[i]-'A');}\n\nconst auto EPS = 1e-10;\nconst auto INF = 100000000;\nconst auto MOD = 1000000007;\ntypedef pair<ll,ll> P;\n\n#define MAX_N 500\n\nstruct UF{\n\tint par[MAX_N];\n\tint rank[MAX_N];\n\tint si[MAX_N];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsi[i] = 1;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t\tsi[y] += si[x];\n\t\t} else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t\tsi[x] += si[y];\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n} uf;\n\nint n, m;\nvector<int> e[500];\nbool saw[500];\n\nint dfs(int v){\n    saw[v] = true;\n    int ret = 0;\n    rep(i,e[v].size()){\n        if(saw[e[v][i]]) ret++;\n        else ret += dfs(e[v][i]);\n    }\n    return ret;\n}\n\nint main(){\n    I(n,m);\n    uf.init(n);\n    rep(i,m){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        e[a].push_back(b);\n        uf.unite(a,b);\n    }\n    int ans = 0;\n    rep(i,n){\n        if(saw[i]) continue;\n        ans += dfs(i);\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\ndouble eps=1e-8;\n\nvoid gauss_jordan(mat& A){\n  int n=A.size();\n  int m=A[0].size();\n  \n  int rank=0;\n  \n  vector<bool> flg(n,false);\n  \n  for(int i=0;i<n;i++){\n    int pivot=i;\n    for(int j=0;j<n;j++){\n      if(flg[j])continue;\n      if(abs(A[j][i]) > abs(A[pivot][i]))pivot=j;\n    }\n\n\n    \n    swap(A[pivot],A[i]);\n    \n    if(abs(A[i][i]) < eps)continue;\n    \n    rank++;\n    flg[i]=true;\n    \n    double val=A[i][i];\n    for(int j=0;j<m;j++)A[i][j]/=val;\n    \n    for(int j=0;j<n;j++){\n      if(i==j)continue;\n      double va=A[j][i];\n      for(int k=0;k<m;k++)\n        A[j][k]-=A[i][k]*va;\n    }\n  }\n  /*\n  cout<<\"rank = \"<<rank<<endl;\n  cout<<\" n = \"<<n<<endl;\n  cout<<\" m = \"<<m<<endl;\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<m;j++){\n      printf(\"%3d\",(int)A[i][j]);\n    }\n    cout<<endl;\n  }\n\n  */\n  cout<<m-rank<<endl;\n}\n\nint N,M;\nint G[500][500];\n\nint main(){\n  memset(G,-1,sizeof(G));\n  mat A;\n  cin>>N>>M;\n  if(M==0){\n    cout<<0<<endl;\n    return 0;\n  }\n  for(int i=0;i<M;i++){\n    int a,b;\n    cin>>a>>b;\n    a--,b--;\n    G[a][b]=i;\n  }\n\n  for(int i=0;i<N;i++){\n    vec B(M,0);\n    for(int j=0;j<N;j++){\n      if(G[i][j]==-1)continue;\n      int id=G[i][j];\n      B[ id ]=1;\n    }\n    for(int j=0;j<N;j++){\n      if(G[j][i]==-1)continue;\n      int id=G[j][i];\n      B[ id ]=-1;\n    }\n    A.push_back(B);\n  }\n\n  while(A.size()<A[0].size()){\n    vec B(M,0);\n    A.push_back(B);\n  }\n  gauss_jordan(A);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n// 連結成分分解　（連結成分ごとにグラフを再構築、Sはグラフの集合）\nstruct CC{\n  int n;\n  vector<vector<int> >G,rG;\n  vector<int>used;\n  vector<vector<vector<int> > >S;\n  CC(int sz):n(sz),G(sz),rG(sz),used(sz){}\n  void add(int from,int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n  void CC_dfs1(int x,int &cnt,map<int,int>& m){\n    m[x]=cnt++;\n    used[x]=1;\n    for(int i=0;i<G[x].size();i++){\n      if(used[G[x][i]])continue;\n      CC_dfs1(G[x][i],cnt,m);\n    }\n    for(int i=0;i<rG[x].size();i++){\n      if(used[rG[x][i]])continue;\n      CC_dfs1(rG[x][i],cnt,m);\n    }\n  }\n  void CC_dfs2(int x,vector<vector<int> > &v,map<int,int>& m,vector<int> &vis){\n    vis[m[x]]=1;\n    for(int i=0;i<G[x].size();i++){\n      v[m[x]].push_back(m[G[x][i]]);\n      if(vis[m[G[x][i]]])continue;\n      CC_dfs2(G[x][i],v,m,vis);\n    }\n    for(int i=0;i<rG[x].size();i++){\n      if(vis[m[rG[x][i]]])continue;\n      CC_dfs2(rG[x][i],v,m,vis);\n    }\n  }\n  void build(){\n    for(int i=0;i<n;i++)used[i]=0;\n    for(int i=0;i<n;i++){\n      if(used[i])continue;\n      int cnt=0;\n      map<int,int>M;\n      CC_dfs1(i,cnt,M);\n      vector<vector<int> >v(cnt);\n      vector<int>U(cnt,0);\n      CC_dfs2(i,v,M,U);\n      S.push_back(v);\n    }\n  }\n};\n\nsigned main(){\n  int n,m,ans=0;\n  cin>>n>>m;\n  CC C(n);\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;a--;b--;\n    C.add(a,b);\n  }\n  C.build();\n  int N=C.S.size();\n  for(int i=0;i<N;i++,ans++){\n    vector<vector<int> >V=C.S[i];\n    for(int j=0;j<V.size();j++){\n      ans+=V[j].size()-1;\n    }\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconstexpr double eps = 1e-9;\n\nnamespace detail {\n    bool is_zero(double x) {\n        return std::fabs(x) < eps;\n    }\n}\n\ntemplate <typename T>\nclass matrix {\npublic:\n    matrix() : matrix(0, 0) {}\n    matrix(int r, int c, T init = T())\n        : a(r, std::vector<T>(c, init)), row_sz(r), col_sz(c)\n    {}\n\n    void init(int r, int c) {\n        *this = matrix(r, c);\n    }\n\n    matrix& operator+=(matrix const& that) {\n        assert(row_sz == that.row_size() && col_sz == that.col_size());\n        for(int i = 0; i < row_sz; ++i) {\n            for(int j = 0; j < col_sz; ++j) {\n                a[i][j] += that[i][j];\n            }\n        }\n    }\n    matrix& operator-=(matrix const& that) {\n        assert(row_sz == that.row_size() && col_sz == that.col_size());\n        for(int i = 0; i < row_sz; ++i) {\n            for(int j = 0; j < col_sz; ++j) {\n                a[i][j] -= that[i][j];\n            }\n        }\n    }\n    matrix& operator*=(matrix const& that) {\n        assert(col_sz == that.row_size());\n        matrix res(row_sz, that.col_size());\n        for(int i = 0; i < row_sz; ++i) {\n            for(int k = 0; k < that.col_size(); ++k) {\n                for(int j = 0; j < col_sz; ++j) {\n                    res[i][j] += a[i][k] * that[k][j];\n                }\n            }\n        }\n        return res;\n    }\n    std::vector<T> operator*(std::vector<T> const& that) {\n        assert(col_sz == (int)that.size());\n        std::vector<T> res(row_sz);\n        for(int i = 0; i < row_sz; ++i) {\n            for(int j = 0; j < col_sz; ++j) {\n                res[i] += a[i][j] * that[j];\n            }\n        }\n        return res;\n    }\n    matrix operator+(matrix const& that) const { return matrix(*this) += that; }\n    matrix operator-(matrix const& that) const { return matrix(*this) -= that; }\n    matrix operator*(matrix const& that) const { return matrix(*this) *= that; }\n\n    bool operator==(matrix const& that) const { return a == that.a; }\n    bool operator!=(matrix const& that) const { return !(*this == that); }\n\n    std::vector<T>& operator[](size_t i)             { return a[i]; }\n    std::vector<T> const& operator[](size_t i) const { return a[i]; }\n\n    int row_size() const { return row_sz; }\n    int col_size() const { return col_sz; }\n\nprivate:\n    std::vector<std::vector<T>> a;\n    int row_sz, col_sz;\n};\n\ntemplate <typename T>\nmatrix<T> eye(int n) {\n    matrix<T> res(n, n);\n    for(int i = 0; i < n; ++i) {\n        res[i][i] = 1;\n    }\n    return res;\n}\n\ntemplate <typename T>\nint rank_matrix(matrix<T> a) {\n    const int R = a.row_size(), C = a.col_size();\n    int r = 0;\n    for(int i = 0; i < C && r < R; ++i) {\n        int pivot = r;\n        for(int j = r + 1; j < R; ++j) {\n            if(std::abs(a[j][i]) > std::abs(a[pivot][i])) {\n                pivot = j;\n            }\n        }\n        std::swap(a[pivot], a[r]);\n        if(detail::is_zero(a[r][i])) continue;\n        for(int k = C - 1; k >= i; --k) {\n            a[r][k] = a[r][k] / a[r][i];\n        }\n        for(int j = r + 1; j < R; ++j) {\n            for(int k = C - 1; k >= i; --k) {\n                a[j][k] -= a[r][k] * a[j][i];\n            }\n        }\n        ++r;\n    }\n    return r;\n}\n\n// solve Ax = b\n// @note: A must be regular(non-singular)\n// @return: x or size 0 vector (when x does not exist or not unique)\ntemplate <typename T>\nstd::vector<T> gauss_jordan(matrix<T> const& A, std::vector<T> const& b) {\n    const int n = A.row_size();\n    matrix<T> B(n, n + 1);\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            B[i][j] = A[i][j];\n        }\n    }\n    for(int i = 0; i < n; ++i) {\n        B[i][n] = b[i];\n    }\n\n    for(int i = 0; i < n; ++i) {\n        int pivot = i;\n        for(int j = i; j < n; ++j) {\n            if(std::abs(B[j][i]) > std::abs(B[pivot][i])) {\n                pivot = j;\n            }\n        }\n        std::swap(B[i], B[pivot]);\n\n        if(detail::is_zero(B[i][i])) return std::vector<T>(); // no solution\n\n        for(int j = i + 1; j <= n; ++j) {\n            B[i][j] /= B[i][i];\n        }\n        for(int j = 0; j < n; ++j) {\n            if(i == j) continue;\n            for(int k = i + 1; k <= n; ++k) {\n                B[j][k] -= B[j][i] * B[i][k];\n            }\n        }\n    }\n\n    std::vector<T> x(n);\n    for(int i = 0; i < n; ++i) {\n        x[i] = B[i][n];\n    }\n    return x;\n}\n\nusing namespace std;\n\nint main() {\n    int n, m; cin >> n >> m;\n    matrix<double> a(n, m);\n    for(int i = 0; i < m; ++i) {\n        int s, t; cin >> s >> t;\n        a[s - 1][i] = 1;\n        a[t - 1][i] = -1;\n    }\n    cout << m - rank_matrix(a) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\n//const ll mod = 1000000007;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    UnionFind uni(N);\n    for(int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        uni.merge(a, b);\n    }\n    ll ans = M;\n    for(int i = 0; i < N; i++) {\n        if(uni.root(i) != i) continue;\n        ans -= uni.size(i) - 1;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,a,b,m;\nvector<int>v[501];\nbool used[501];\nvoid dfs(int x){\n  used[x]=1;\n  for(int i=0;i<v[x].size();i++){\n    if(!used[v[x][i]])dfs(v[x][i]);\n  }\n}\nmain(){\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    v[a].push_back(b);\n  }\n  int sum=0,aa=0;\n  for(int i=1;i<=n;i++){\n    if(!used[i])dfs(i),aa++;\n  }\n  for(int i=1;i<=n;i++)\n    sum+=v[i].size()-1;\n  cout<<sum+aa<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author:  vawait\n * Created Time:  2015/8/22 16:45:15\n * Problem: test.cpp\n */\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<ctime>\nusing namespace std;\n#define rep(i, a, b) for (int i = (a); i <= (b); ++i)\n#define red(i, a, b) for (int i = (a); i >= (b); --i)\n#define clr( x , y ) memset(x,y,sizeof(x))\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n#define sqr(x) ((x) * (x))\ntypedef long long lint;\nconst int maxn = 600;\nint n , m , f[maxn];\n\nint find(int t)\n{\n    return f[t] == t ? t : f[t] = find( f[t] );\n}\n\nvoid init()\n{\n    int x , y;\n    rep(i,1,n) f[i] = i;\n    rep(i,1,m) {\n        scanf(\"%d%d\",&x,&y);\n        f[find(x)] = find( y );\n    }\n}\n\nvoid work()\n{\n    int ans = m - n;\n    rep(i,1,n) if ( find( i ) == i ) ans ++;\n    printf(\"%d\\n\",ans);\n}\n\nint main()\n{\n    while ( cin >> n >> m ) {\n        init();\n        work();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nbool used[555];\nset<int> G[555];\nvoid dfs(int v){\n  if(used[v]) return;\n  used[v]=1;\n  for(int u:G[v]) dfs(u);\n}\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    int s,t;\n    cin>>s>>t;\n    s--;t--;\n    G[s].insert(t);\n  }\n  memset(used,0,sizeof(used));\n  int cnt=0;\n  for(int i=0;i<n;i++){\n    if(used[i]) continue;\n    cnt++;\n    dfs(i);\n  }\n  cout<<m-n+cnt<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <set>\n#include <cmath>\n#define pb push_back\n#define PB pop_back\n#define fs first\n#define se second\n#define bk back()\n#define sq(x) (x)*(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst int maxn=5050;\nstruct EDGE{\n\tint to,rev;\n\tEDGE(int to):to(to){}\n};\nvector<EDGE> G[maxn];\npriority_queue<P,vector<P> ,greater<P> > Q;\nint d[maxn];\nmap<P,bool> del;\nbool deter[maxn];\nvoid clear(){\n\tfor(int i=0;i<maxn;i++){\n\t\tG[i].clear();\n\t}\n\tdel.clear();\n\tmemset(d,0,sizeof d);\n\tmemset(deter,0,sizeof deter);\n}\nint n,m;\nint main(){\t\n\t////freopen(\"/home/files/CppFiles/in\",\"r\",stdin);\n\t/*\tstd::ios::sync_with_stdio(false);\n\t\tstd::cin.tie(0);*/\n\twhile(cin>>n>>m){\n\t\tclear();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tG[a].pb(EDGE(b));\n\t\t\tG[b].pb(EDGE(a));\n\t\t\td[a]++,d[b]++;\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tQ.push(P(d[i],i));\n\t\t}\n\t\tint ans=0;\n\t\twhile(!Q.empty()){\n\t\t\tint v=Q.top().se;Q.pop();\n\t\t/*\tcout<<v<<endl;\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tcout<<d[i]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;*/\n\t\t\td[v]=0;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tif(!deter[G[v][i].to]) d[v]++;\n\t\t\t}\n\t\t\tif(d[v]<=1){\n\t\t\t\tdeter[v]=1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(deter[G[v].bk.to]||del[P(v,G[v].bk.to)]){\n\t\t\t\tG[v].PB();\n\t\t\t}\n\t\t\td[v]--,d[G[v].bk.to]--;\n\t\t//\tcout<<v<<\" \"<<G[v].bk.to<<endl;\n\t\t\tans++;\n\t\t\tif(d[v]<=1) {\n\t\t\t\tdeter[v]=1;\n\t\t\t}\n\t\t\tif(d[G[v].bk.to]<=1){\n\t\t\t\tdeter[G[v].bk.to]=1;\n\t\t\t}\n\t\t\tif(d[v]>1) Q.push(P(d[v],v));\n\t\t\tif(d[G[v].bk.to]>1) Q.push(P(d[G[v].bk.to],G[v].bk.to));\n\t\t\tdel[P(v,G[v].bk.to)]=del[P(G[v].bk.to,v)]=1;\n\t\t\tG[v].PB();\n\t\t}\n\t\tcout<<ans<<endl;\n\t//\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define rep1(i,n) for(int i = 1; i < n; i++)\n#define repv(i,n) for(int i = n-1; i >= 0; i--)\n#define fi first\n#define sc second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\n\nchar BUF[3500000];\ninline void I(int&a){scanf(\"%d\",&a);}\ninline void I(int&a,int&b){scanf(\"%d%d\",&a,&b);}\ninline void I(int&a,int&b,int&c){scanf(\"%d%d%d\",&a,&b,&c);}\ninline void I(int&a,int&b,int&c,int&d){scanf(\"%d%d%d%d\",&a,&b,&c,&d);}\ninline void L(ll&a){scanf(\"%lld\",&a);}\ninline void L(ll&a,ll&b){scanf(\"%lld%lld\",&a,&b);}\ninline void L(ll&a,ll&b,ll&c){scanf(\"%lld%lld%lld\",&a,&b,&c);}\ninline void L(ll&a,ll&b,ll&c,ll&d){scanf(\"%lld%lld%lld%lld\",&a,&b,&c,&d);}\ninline void S(string&str){str.clear();scanf(\"%s\",BUF);int s=strlen(BUF);rep(i,s)str.pb(BUF[i]);}\ninline void SV(vector<int>&v){v.clear();scanf(\"%s\",BUF);int s=strlen(BUF);rep(i,s)if('a'<=BUF[i]&&BUF[i]<='z')v.pb(BUF[i]-'a');else v.pb(BUF[i]-'A');}\n\nconst auto EPS = 1e-10;\nconst auto INF = 100000000;\nconst auto MOD = 1000000007;\ntypedef pair<ll,ll> P;\n\n#define MAX_N 500\n\nstruct UF{\n\tint par[MAX_N];\n\tint rank[MAX_N];\n\tint si[MAX_N];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsi[i] = 1;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t\tsi[y] += si[x];\n\t\t} else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t\tsi[x] += si[y];\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n} uf;\n\nint n, m;\nvector<int> e[500];\nbool saw[500];\n\nint dfs(int v){\n    saw[v] = true;\n    int ret = 0;\n    rep(i,e[v].size()){\n        if(saw[e[v][i]]) ret++;\n        else ret += dfs(e[v][i]);\n    }\n    return ret;\n}\n\nint main(){\n    I(n,m);\n    uf.init(n);\n    rep(i,m){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        e[a].push_back(b);\n        uf.unite(a,b);\n    }\n    int ans = 0;\n    rep(i,n){\n        if(saw[i]) continue;\n        ans += dfs(i);\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 505\nusing namespace std;\n\nint n, m, used[N];\nvector<int> G[N];\n\nint dfs(int x){\n  \n  if(used[x]) return 0;\n  used[x]=1;\n  \n  int res=0;\n\n  for(int i=0;i<G[x].size();i++) res+=dfs(G[x][i]);\n  \n  return res+G[x].size()-1;\n}\n\nint main(){\n  \n  cin>>n>>m;\n  \n  for(int i=0;i<m;i++){\n    int s, t;\n    cin>>s>>t;\n    G[s-1].push_back(t-1);\n  }\n\n  int ans=0;\n  \n  for(int i=0;i<n;i++)\n    if(!used[i]) ans+=dfs(i)+1;\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,a,b,m;\nvector<int>v[501];\nbool used[501];\nvoid dfs(int x){\n  used[x]=1;\n  for(int i=0;i<v[x].size();i++){\n    if(!used[v[x][i]])dfs(v[x][i]);\n  }\n}\nmain(){\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    v[a].push_back(b);\n  }\n  int sum=0,aa=0;\n  for(int i=1;i<=n;i++){\n    if(!used[i])dfs(i),aa++;\n  }\n  for(int i=1;i<=n;i++)\n    sum+=v[i].size()-1;\n  cout<<sum+aa<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n\nusing namespace std;\n\nset<int> edges[523];\n\nvoid erase(int v){\n  while(edges[v].size()==1){\n    int nv=*edges[v].begin();\n    edges[nv].erase(v);\n    edges[v].clear();\n    v=nv;\n  }\n}    \n\nint main(){\n  int N,M;\n  cin>>N>>M;\n  for(int i=0;i<M;i++){\n    int s,t;\n    cin>>s>>t;\n    edges[s].insert(t);\n    edges[t].insert(s);\n  }\n  int ans=0;\n  for(int i=1;i<=N;i++){\n    while(!edges[i].empty()){\n      ans++;\n      int t=*edges[i].begin();\n      edges[i].erase(t);\n      edges[t].erase(i);\n      erase(t);\n      erase(i);\n    }\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\ndouble eps=1e-8;\n\nvoid gauss_jordan(mat& A){\n  int n=A.size();\n  int m=A[0].size();\n  \n  int rank=0;\n  \n  vector<bool> flg(n,false);\n  \n  for(int i=0;i<n;i++){\n    int pivot=i;\n    for(int j=0;j<n;j++){\n      if(flg[j])continue;\n      if(abs(A[j][i]) > abs(A[pivot][i]))pivot=j;\n    }\n\n\n    \n    swap(A[pivot],A[i]);\n    \n    if(abs(A[i][i]) < eps)continue;\n    \n    rank++;\n    flg[i]=true;\n    \n    double val=A[i][i];\n    for(int j=0;j<m;j++)A[i][j]/=val;\n    \n    for(int j=0;j<n;j++){\n      if(i==j)continue;\n      double va=A[j][i];\n\n      for(int k=0;k<m;k++){\n        A[j][k]-=A[i][k]*va;\n      }\n    }\n  }\n  /*\n  cout<<\"rank = \"<<rank<<endl;\n  cout<<\" n = \"<<n<<endl;\n  cout<<\" m = \"<<m<<endl;\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<m;j++){\n      printf(\"%3d\",(int)A[i][j]);\n    }\n    cout<<endl;\n  }\n\n  */\n  cout<<m-rank<<endl;\n}\n\nint N,M;\nint G[500][500];\n\nint main(){\n  memset(G,-1,sizeof(G));\n  mat A;\n  cin>>N>>M;\n  if(M==0){\n    cout<<0<<endl;\n    return 0;\n  }\n  for(int i=0;i<M;i++){\n    int a,b;\n    cin>>a>>b;\n    a--,b--;\n    G[a][b]=i;\n  }\n\n  for(int i=0;i<N;i++){\n    bool flg=false;\n    vec B(M,0);\n    for(int j=0;j<N;j++){\n      if(G[i][j]==-1)continue;\n      int id=G[i][j];\n      B[ id ]=1;\n      flg=true;\n    }\n    for(int j=0;j<N;j++){\n      if(G[j][i]==-1)continue;\n      int id=G[j][i];\n      B[ id ]=-1;\n      flg=true;\n    }\n    if(flg)  A.push_back(B);\n  }\n\n  while(A.size()<A[0].size()){\n    vec B(M,0);\n    A.push_back(B);\n  }\n\n  gauss_jordan(A);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n#define MOD 1000000007\n#define pb push_back\n\nvector<int> e[555];\nbool vis[555];\nint ans=0;\n\nvoid dfs(int i)\n{\n    vis[i]=1;\n    for (vector<int>::iterator j=e[i].begin();j!=e[i].end();++j)\n        if (!vis[*j])\n        {\n            ++ans;\n            dfs(*j);\n        }\n}\n\nint main()\n{\n    int n,m,x,y;\n    cin>>n>>m;\n    for (int i=1;i<=m;++i)\n    {\n        cin>>x>>y;\n        e[x].pb(y);\n        e[y].pb(x);\n    }\n    for (int i=1;i<=n;++i)\n        if (!vis[i])\n            dfs(i);\n    cout<<(m-ans)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T> int len(const T &v) { return v.size(); }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int &s = 0, const int &d = 0, const Weight &w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = vector<Edge>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nclass Graph {\n  vector<Edges> g;\n  using iterator = vector<Edges>::iterator;\n  using const_iterator = vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int &size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  const Edges &operator[](const int &i) const { return g[i]; }\n  Edges &operator[](const int &i) { return g[i]; }\n  void addArc(const int &src, const int &dst, const Weight &w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int &node1, const int &node2, const Weight &w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\nmain() {\n  int n, m;\n  cin >> n >> m;\n  Graph g(n);\n  rep(i, m) {\n    int s, t;\n    cin >> s >> t;\n    g.addEdge(--s, --t);\n  }\n  vector<int> used(n);\n  function<void(int)> dfs = [&](int v) {\n    if (used[v]) return;\n    used[v] = true;\n    for (auto &e : g[v]) dfs(e.dst);\n  };\n  int ans = m - n;\n  rep(i, n) {\n    if (used[i]) continue;\n    ans++;\n    dfs(i);\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Author:  vawait\n * Created Time:  2015/8/22 16:45:15\n * Problem: test.cpp\n */\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<ctime>\nusing namespace std;\n#define rep(i, a, b) for (int i = (a); i <= (b); ++i)\n#define red(i, a, b) for (int i = (a); i >= (b); --i)\n#define clr( x , y ) memset(x,y,sizeof(x))\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n#define sqr(x) ((x) * (x))\ntypedef long long lint;\nconst int maxn = 600;\nint n , m , f[maxn] , sum[maxn];\n\nint find(int t)\n{\n    return f[t] == t ? t : f[t] = find( f[t] );\n}\n\nvoid init()\n{\n    int x , y;\n    clr( sum , 0 );\n    rep(i,1,n) f[i] = i;\n    while ( m -- ) {\n        scanf(\"%d%d\",&x,&y);\n        sum[x] ++;\n        f[find(x)] = find( y );\n    }\n}\n\nvoid work()\n{\n    int ans = 0;\n    rep(i,1,n) if ( find( i ) == i ) ans ++;\n    rep(i,1,n) ans += sum[i] - 1;\n    printf(\"%d\\n\",ans);\n}\n\nint main()\n{\n    while ( cin >> n >> m ) {\n        init();\n        work();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,a,b,m;\nvector<int>v[501];\nmain(){\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    v[a].push_back(b);\n  }\n  int sum=0;\n  for(int i=1;i<=n;i++)\n    sum+=v[i].size()-1;\n  if(sum)cout<<sum+1<<endl;\n  else cout<<2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n\n/* verified AOJ1327 One-Dimensional Cellular Automaton\n~Matrix~\n??????????°????????¨?????????§??????\nvector iostream cmath cassert ??????\nMatrix a(VV), b(VV);\n?????????:a*b\n????????????:l*a\n???:a+b\n???:a-b\n??¢???:a.transport()\n?????????:a.cofactor()\n?????????:a.det()\na???i???j??????:a.get(i,j)???\na???i??????j?????????k?????£??\\:set(i,j,k)\n????????????a[i][j] (a[i][j]=k)\na???x???:a.pow(x)\nn*n?????¬??????E:Matrix(n)\nm*n 0??????:Matrix(m,n)\nm*n ??¨????´????p?????????:Matrix(m,n,p)\nRow???row??§????????????(m*1??????):Matrix(row)\n**(??´??°??????)**\n????§????:a.triangulate()\n?????????:a.rank()\n?????????:a.inverse()\n//(????????????a.det()?????????a.pre_inverse()??§?±??????? ??´??°???)\n??¬??????????¶???????:a.rowReduction()\n//??£???????¬?????¨????????§£??????\n***\n*/\n\n#include <vector>\n#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\ntypedef ld Elem;\ntypedef vector<Elem> Row;\ntypedef vector<Row> VV;\n\ntypedef long double ld;\nconst ld EPS = 1e-11;\n\nconst bool isZero(const Elem e) {\n\treturn abs(e) < EPS;\n}\n\nstruct Matrix {\n\tVV matrix;\n\tint n, m;\n\n\tMatrix(const VV &matrix_);\n\texplicit Matrix(int n_);\n\texplicit Matrix(const Row &row);\n\tMatrix(int m_, int n_);\n\tMatrix(int m_, int n_, Elem e);\n\n\tconst Elem get(const int i, const int j) const;\n\tvoid set(const int x, const int y, const Elem k);\n\n\tconst Matrix operator + (const Matrix &rhs) const;\n\tconst Matrix operator * (const Matrix &rhs) const;\n\tconst Matrix operator - (const Matrix &rhs) const;\n\tMatrix &operator += (const Matrix &rhs);\n\tMatrix &operator *= (const Matrix &rhs);\n\tMatrix &operator -= (const Matrix &rhs);\n\n\tRow &operator[](const int x);\n\n\tconst Matrix transport() const;\n\tconst Matrix pow(int x) const;\n\tconst Matrix cofactor(int x, int y) const;\n\tconst Elem det() const;\n\n\tconst Matrix triangulate() const;\n\tconst int rank() const;\n\n\t//?????????????????¨????????°???(?????????)*(?????????)?????????\n\t//A:matrix,return det A * A^-1\n\tconst Matrix pre_inverse() const;\n\tconst Matrix inverse() const;\n\tconst Matrix rowReduction() const;\n};\n\nconst Matrix operator * (const Elem lambda, const Matrix &rhs) {\n\tMatrix tmp(rhs);\n\tfor (int i = 0; i < rhs.m; i++)\n\t\tfor (int j = 0; j < rhs.n; j++)\n\t\t\ttmp.set(i, j, tmp.get(i, j) * lambda);\n\treturn tmp;\n}\n\nMatrix::Matrix(const VV &matrix_) : matrix(matrix_) {\n\tm = matrix_.size();\n\tif (m == 0) n = 0;\n\telse n = matrix_[0].size();\n}\nMatrix::Matrix(int n_) : m(n_), n(n_) {\n\tmatrix = VV(n, Row(n, 0));\n\tfor (int i = 0; i < n; ++i)\n\t\tset(i, i, 1);\n}\nMatrix::Matrix(const Row &row) : m(1), n(row.size()), matrix(VV(1, row)) {\n\t//size???m???vector<Elem>??????mx1???????????????\n\t(*this) = transport();\n}\nMatrix::Matrix(int m_, int n_) : m(m_), n(n_) {\n\tmatrix = VV(m, Row(n, 0));\n}\nMatrix::Matrix(int m_, int n_, Elem e) : m(m_), n(n_) {\n\tmatrix = VV(m, Row(n, e));\n}\n\nconst Elem Matrix::get(const int i, const int j) const {\n\tif (0 <= i && i < m && 0 <= j && j < n)\n\t\treturn matrix[i][j];\n\n\tcerr << \"get(\" << i << \",\" << j << \")is not exist.\" << endl;\n\tthrow;\n}\nvoid Matrix::set(const int i, const int j, const Elem k) {\n\tif (0 <= i && i < m && 0 <= j && j < n) {\n\t\t*(matrix[i].begin() + j) = k;\n\t\treturn;\n\t}\n\tcerr << \"set(\" << i << \",\" << j << \")is not exist.\" << endl;\n\tthrow;\n}\n\nconst Matrix Matrix::operator + (const Matrix &rhs) const {\n\tassert(m == rhs.m && n == rhs.n);\n\n\tMatrix tmp(m, n, 0);\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\ttmp.set(i, j, get(i, j) + rhs.get(i, j));\n\t\t}\n\t}\n\treturn tmp;\n}\n\nconst Matrix Matrix::operator * (const Matrix &rhs) const {\n\tassert(n == rhs.m);\n\n\tMatrix tmp(m, rhs.n, 0);\n\tElem sum;\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < rhs.n; j++) {\n\t\t\tsum = 0;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tsum += get(i, k) * rhs.get(k, j);\n\t\t\t}\n\t\t\ttmp.set(i, j, sum);\n\t\t}\n\treturn tmp;\n}\n\nconst Matrix Matrix::operator - (const Matrix &rhs) const {\n\treturn *this + ((Elem)-1 * rhs);\n}\n\nMatrix &Matrix::operator += (const Matrix &rhs) {\n\treturn *this = *this + rhs;\n}\n\nMatrix &Matrix::operator *= (const Matrix &rhs) {\n\treturn *this = *this * rhs;;\n}\n\nMatrix &Matrix::operator -= (const Matrix &rhs) {\n\treturn *this = *this - rhs;\n}\n\nRow &Matrix::operator[](const int x) {\n\treturn matrix[x];\n}\n\nconst Matrix Matrix::transport() const {\n\tVV tmp;\n\tfor (int i = 0; i < n; i++) {\n\t\tRow row;\n\t\tfor (int j = 0; j < m; j++)\n\t\t\trow.push_back(get(j, i));\n\t\ttmp.push_back(row);\n\t}\n\treturn tmp;\n}\n\nconst Matrix Matrix::pow(int x) const {\n\tMatrix tmp(*this), e(m);\n\tfor (int i = 1; i <= x; i <<= 1) {\n\t\tif ((x & i) > 0)\n\t\t\te = e * tmp;\n\t\ttmp = tmp * tmp;\n\t}\n\treturn e;\n}\n\nconst Matrix Matrix::cofactor(int x, int y) const {\n\tVV tmp;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (x == i) continue;\n\t\tRow row;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (y == j) continue;\n\t\t\trow.push_back(get(i, j));\n\t\t}\n\t\ttmp.push_back(row);\n\t}\n\treturn Matrix(tmp);\n}\n\nconst Elem Matrix::det() const {\n\tassert(n == m);\n\n\tif (m == 1)\n\t\treturn get(0, 0);\n\tElem sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tsum += ((i % 2 == 0 ? 1 : -1) * get(i, 0)) * Matrix(cofactor(i, 0)).det();\n\t}\n\treturn sum;\n}\n\nconst Matrix Matrix::triangulate() const {\n\tMatrix tmp(*this);\n\tElem e;\n\tint p = 0;\n\tfor (int i = 0; i < m && p < n; i++, p++) {\n\t\tif (isZero(tmp.get(i, p))) {\n\t\t\ttmp.set(i, p, 0);\n\t\t\tbool flag = true;\n\t\t\tfor (int j = i + 1; j < m; j++)\n\t\t\t\tif (!isZero(tmp.get(j, p))) {\n\t\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t\t\ttmp.set(i, k, tmp.get(i, k) + tmp.get(j, k));\n\t\t\t\t\t//tmp[i].swap(tmp[j]);\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor (int j = i + 1; j < m; j++) {\n\t\t\te = tmp.get(j, p) / tmp.get(i, p);\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\ttmp.set(j, k, tmp.get(j, k) - tmp.get(i, k) * e);\n\t\t}\n\t}\n\treturn tmp;\n}\n\nconst int Matrix::rank() const {\n\tMatrix tmp(triangulate());\n\tfor (int i = min(tmp.m - 1, tmp.n - 1); i >= 0; i--) {\n\t\tfor (int j = tmp.n - 1; j >= i; j--)\n\t\t\tif (isZero(tmp.get(i, j)))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn i + 1;\n\t}\n\treturn 0;\n}\n\nconst Matrix Matrix::pre_inverse() const {\n\tassert(m == n);\n\n\tMatrix tmp(m, n, 0);\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\ttmp.set(i, j, ((i + j) % 2 == 0 ? 1 : -1)*cofactor(i, j).det());\n\treturn tmp.transport();\n}\n\n/*O(n!)????£?\nconst Matrix Matrix::inverse() const {\nMatrix tmp(pre_inverse());\nElem e = det();\nassert(!isZero(e));\ntmp = 1 / e * tmp;\nreturn tmp.transport();\n}*/\n\nconst Matrix Matrix::inverse() const {\n\tassert(m == n);\n\n\tMatrix tmp(m, n * 2), tmp2(m, n);\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\ttmp.set(i, j, get(i, j));\n\tfor (int i = 0; i < m; i++)\n\t\ttmp.set(i, i + n, 1);\n\n\ttmp = tmp.rowReduction();\n\n\t//?????????????????¨??????????????????????????§??????\n\tfor (int i = 0; i < m; i++)\n\t\tassert(isZero(tmp.get(i, i) - 1));\n\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\ttmp2.set(i, j, tmp.get(i, j + n));\n\n\treturn tmp2;\n}\n\n/*\na b c j\nd e f k\ng h i l\n\nax+by+cz=j;\ndx+ey+fz=k;\ngx+hy+iz=l;\n\n|\nV\n\n1 0 0 x\n0 1 0 y\n0 0 1 z\n???????????????\n*/\nconst Matrix Matrix::rowReduction() const {\n\tMatrix tmp(*this);\n\tElem e;\n\tint p = 0;\n\tfor (int i = 0; i < m && p < n; i++, p++) {\n\t\tif (isZero(tmp.get(i, p))) {\n\t\t\ttmp.set(i, p, 0);\n\t\t\tbool flag = true;\n\t\t\tfor (int j = i + 1; j < m; j++)\n\t\t\t\tif (!isZero(tmp.get(j, p))) {\n\t\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t\t\ttmp.set(i, k, tmp.get(i, k) + tmp.get(j, k));\n\t\t\t\t\t//tmp[i].swap(tmp[j]);\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\te = 1 / tmp.get(i, p);\n\t\ttmp.set(i, p, 1);\n\t\tfor (int k = i + 1; k < n; k++)\n\t\t\ttmp.set(i, k, tmp.get(i, k)*e);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i == j) continue;\n\t\t\te = tmp.get(j, p);\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\ttmp.set(j, k, tmp.get(j, k) - tmp.get(i, k) * e);\n\t\t}\n\t}\n\treturn tmp;\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<ld>>edges(N, vector<ld>(M));\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tedges[a][i]++;\n\t\tedges[b][i]--;\n\t}\n\tMatrix mat(edges);\n\tint num=mat.rank();\n\tint ans = M - num;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Tree Reconstruction\n//Level: 3\n//Category: グラフ,Graph\n//Note:\n\n/**\n * まず、入次数と出次数がともに1の頂点は、単なる辺と変わらないので取り除いてよい。\n * この操作をしたあとのグラフで考えると、ある辺eが復元可能な条件は\n * ・eが出ている頂点について、e以外の辺の容量がすべて判明している\n * ・eが入っていく頂点について、e以外の辺の容量がすべて判明している\n * のどちらか（強連結性により、孤立していなければどの頂点も1以上の入次数、出次数をもつため、必ず復元に寄与できる）。\n * これを繰り返し適用することで全体が復元できる必要がある。\n *\n * 上記の条件から、1つの頂点につき、高々1つの辺しか復元できないことが分かる。\n * また、復元を開始するためのポイントとして、初期状態で1辺を除いてすべての辺の容量が判明している頂点が少なくとも1つ必要である。\n * したがって、取り除ける辺数は高々V-1個であることが分かる。\n * 実際、このような選び方は、二部マッチングを用いることで求められる\n * （左の頂点集合を辺、右の頂点集合を頂点として、辺の結ぶ2頂点に対して辺を張ればよい）。\n *\n * この問題では、選び方は関係ないので、入次数と出次数がともに1の頂点を取り除いてから残った辺数と頂点数を数えればよい。\n * グラフ全体が連結とは限らないため、各連結成分ごとにカウントする必要があることに注意が必要だが、連結成分ごとに(頂点数-1)個の辺を除去できるので、\n * 連結成分の個数だけ数えて後からまとめて引けばよい。\n * オーダーは O(N+M)。\n */\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct DisjointSet/*{{{*/\n{\n  vector<int> parent;\n\n  int root(int x)\n  {\n    if (parent[x] < 0) {\n      return x;\n    } else {\n      parent[x] = root(parent[x]);\n      return parent[x];\n    }\n  }\n\n  explicit DisjointSet(int n) : parent(n, -1) {}\n\n  bool unite(int x, int y)\n  {\n    const int a = root(x);\n    const int b = root(y);\n    if (a != b) {\n      if (parent[a] < parent[b]) {\n        parent[a] += parent[b];\n        parent[b] = a;\n      } else {\n        parent[b] += parent[a];\n        parent[a] = b;\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  bool find(int x, int y) { return root(x) == root(y); }\n  int size(int x) { return -parent[root(x)]; }\n};/*}}}*/\n\nbool solve() {\n    int N, M;\n    if(!(cin >> N >> M)) return false;\n    if(!N && !M) return false;\n\n    int vs = N, es = M;\n    DisjointSet ds(N);\n    vector<int> in(N, 0), out(N, 0);\n    for(int i = 0; i < M; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a; --b;\n        out[a]++;\n        in[b]++;\n        ds.unite(a, b);\n    }\n    for(int i = 0; i < N; ++i) {\n        if(in[i] == 1 && out[i] == 1) {\n            --vs;\n            --es;\n        }\n    }\n    int comps = 0;\n    for(int i = 0; i < N; ++i) {\n        if(ds.root(i) == i) {\n            ++comps;\n        }\n    }\n    cout << es - vs + comps << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct edge{\n  int to,from;  \n  edge(int to,int from) :\n    to(to), from(from) {}\n  edge(){}\n};\n\nint N,M;\nbool used[5000];\nset<int> G[555];\nvector<edge> E;\n\nint main(){\n  cin >> N >> M;  \n  for(int i=0;i<M;i++){\n    int s,t; cin >> s >> t;\n    --s; --t;\n    E.push_back( edge(t,s) );\n    G[s].insert( i );\n    G[t].insert( i );\n  }\n  bool ed = true;\n  int res = 0;\n  while( ed ){\n    int minid=0;\n    while( G[minid].empty() ) minid++;\n    for(int i=0;i<N;i++){\n      if( G[i].empty() ) continue;\n      if( G[minid].size() > G[i].size()  ) minid = i;\n    }\n    //   cout << G[minid].size() << endl;\n    res += G[minid].size()-1;\n    for(auto it = G[minid].begin(); it != G[minid].end(); it++ ){\n      used[*it] = true;\n      // cout << \"new \" << *it << endl;\n      for(int i=0;i<N;i++){\n        if( i == minid ) continue;\n        G[i].erase(*it);\n      }\n    }\n    G[minid].clear();\n    ed = false;\n    for(int i=0;i<M;i++)\n      if( !used[i] ) ed = true;\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint p[3100];\nint q[3100];\ndouble A[510][3100];\ndouble ABS(double a){return max(a,-a);}\ndouble EPS=1e-9;\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%d%d\",p+i,q+i);\n\t\tp[i]--;q[i]--;\n\t\tA[p[i]][i]+=1.0;\n\t\tA[q[i]][i]-=1.0;\n\t}\n\tint rank=b;\n\tint col=0;\n\t/*for(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++)printf(\"%.0f \",A[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\tfor(int i=0;i<a;i++){\n\t\tint at=-1;\n\t\twhile(col<b){\n\t\t\tfor(int j=i;j<a;j++){\n\t\t\t\tif(ABS(A[j][col])>EPS){\n\t\t\t\t\tat=j;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(~at)break;\n\t\t\tcol++;\n\t\t}\n\t\tif(col>=b)break;\n\t\trank--;\n\t\tfor(int j=0;j<b;j++)swap(A[i][j],A[at][j]);\n\t\tdouble ks=A[i][col];\n\t\tfor(int j=0;j<b;j++)A[i][j]/=ks;\n\t\tfor(int j=i+1;j<a;j++){\n\t\t\tdouble t=A[j][col];\n\t\t\tfor(int k=0;k<b;k++)A[j][k]-=t*A[i][k];\n\t\t}\n\t\tcol++;\n\t\t/*for(int k=0;k<a;k++){\n\t\t\tfor(int j=0;j<b;j++)printf(\"%.0f \",A[k][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t}\n\tprintf(\"%d\\n\",rank);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2564 Tree Reconstruction\n// 2018.5.7 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_V 505\n\n/* UNION-FIND library */\nint id[MAX_V], size[MAX_V];\nvoid init(int n) { int i; for (i = 0; i < n; i++) id[i] = i, size[i] = 1; }\nint root(int i) { while (i != id[i]) id[i] = id[id[i]], i = id[i]; return i; }\nint connected(int p, int q) { return root(p) == root(q); }\nvoid unite(int p, int q)\n{\n    int i = root(p), j = root(q); if (i == j) return;\n    if (size[i] < size[j]) id[i] = j, size[j] += size[i]; else id[j] = i, size[i] += size[j];\n}\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\n\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, s, t, i, ans;\n\n\tn = in(), m = in();\n\tinit(n);\n\tfor (i = 0; i < m; i++) {\n\t\ts = in()-1, t = in()-1;\n\t\tunite(s, t);\n\t}\n\t\n\tans = m-n;\n\tfor (i = 0; i < n; i++) {\n\t\tif (root(i) == i) ans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\treturn dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nclass Digraph < Graph\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_out_edge(e)\n\t\tv.add_in_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.out_edges.delete(e)\n\t\tv.in_edges.delete(e)\n\t\te\n\tend\n\n\tclass Node < Graph::Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@out_edges = Set.new\n\t\t\t@in_edges = Set.new\n\t\tend\n\n\t\tdef add_out_edge(e)\n\t\t\t@out_edges << e\n\t\tend\n\n\t\tdef del_out_edge(e)\n\t\t\t@out_edges.delete(e)\n\t\tend\n\n\t\tdef add_in_edge(e)\n\t\t\t@in_edges << e\n\t\tend\n\n\t\tdef del_in_edge(e)\n\t\t\t@in_edges.delete(e)\n\t\tend\n\n\t\tattr_reader :in_edges, :out_edges\n\tend\n\n\tclass Edge < Graph::Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@property = property\n\t\tend\n\n\t\tattr_reader :from, :to\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.out_edges.each{|e|\n\t\t\tyield [e.to, e.length]\n\t\t}\n\tend\n\n\tdef each_in_connection_of(v)\n\t\tv.in_edges.each{|e|\n\t\t\tyield [e.from, e.length]\n\t\t}\n\tend\n\n#----------------------------------------------------------\n\n\tdef get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\nend\n\nclass SparseMatrix\n\tdef initialize(m, n)\n\t\t@m, @n = m, n\n\t\t@rows = (1..m).map{ Hash.new(0) }\n\tend\n\n\tdef [](i)\n\t\t@rows[i]\n\tend\n\n\tdef rank\n\t\trank = 0\n\t\tj = 0\n\t\t(0..@m-1).each{|i|\n\t\t\tpivot_idx = nil\n\t\t\tj += 1 until j >= @n || pivot_idx = @rows.index{|row| row[j] && row[j] != 0}\n\t\t\tbreak if j >= @n\n\t\t\trank += 1\n\n\t\t\tpivot_row = @rows.delete_at(pivot_idx)\n\t\t\ta = pivot_row[j]\n\t\t\t\n\t\t\t@rows.each{|row|\n\t\t\t\tb = row[j]\n\t\t\t\tif b && b != 0\n\t\t\t\t\tr = b / a\n\t\t\t\t\tpivot_row.each{|k, val|\n\t\t\t\t\t\trow[k] -= r * val\n\t\t\t\t\t\trow.delete(k) if row[k] == 0\n\t\t\t\t\t}\n\t\t\t\tend\n\t\t\t}\n\n\t\t\tj += 1\n\t\t}\t\t\n\t\trank\n\tend\nend\n\nrequire 'matrix'\nrequire 'mathn'\n\nn, m = gets.split.map &:to_i\ng = Digraph.new\nnodes = (0..n-1).map{|i| g.add_node({:index => i}) }\n\nm.times{|k|\n\ti, j = gets.split.map &:to_i\n\tg.add_edge(nodes[i-1], nodes[j-1], {:index => k})\n}\n\nmat = SparseMatrix.new(n, m)\n(0..n-1).each{|i|\n\tnodes[i].in_edges.each{|e|\n\t\tj = e.property[:index]\n\t\tmat[i][j] = 1\n\t}\n\tnodes[i].out_edges.each{|e|\n\t\tj = e.property[:index]\n\t\tmat[i][j] = -1\n\t}\n}\np m - mat.rank"
  },
  {
    "language": "Ruby",
    "code": "class SparseMatrix\n\tdef initialize(m, n)\n\t\t@m, @n = m, n\n\t\t@rows = (1..m).map{ Hash.new(0) }\n\tend\n\n\tdef [](i)\n\t\t@rows[i]\n\tend\n\n\tdef rank\n\t\tsave = Marshal.load(Marshal.dump(self))\n\t\trank = 0\n\t\tj = 0\n\t\t(0..@m-1).each{|i|\n\t\t\tpivot_idx = nil\n\t\t\tj += 1 until j >= @n || pivot_idx = @rows.index{|row| row[j] && row[j] != 0}\n\t\t\tbreak if j >= @n\n\t\t\trank += 1\n\n\t\t\tpivot_row = @rows.delete_at(pivot_idx)\n\t\t\ta = pivot_row[j]\n\t\t\t\n\t\t\t@rows.each{|row|\n\t\t\t\tb = row[j]\n\t\t\t\tif b && b != 0\n\t\t\t\t\tr = b / a\n\t\t\t\t\tpivot_row.each{|k, val|\n\t\t\t\t\t\trow[k] -= r * val\n\t\t\t\t\t\trow.delete(k) if row[k] == 0\n\t\t\t\t\t}\n\t\t\t\tend\n\t\t\t}\n\n\t\t\tj += 1\n\t\t}\t\t\n\t\t@rows = save.rows\n\t\trank\n\tend\n\n\tattr_reader :rows\nend\n\nrequire 'mathn'\nn, m = gets.split.map &:to_i\nmat = SparseMatrix.new(n, m)\nm.times{|k|\n\ti, j = gets.split.map &:to_i\n\tmat[i-1][k] = -1\n\tmat[j-1][k] = 1\n}\np m - mat.rank"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\treturn dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nclass Digraph < Graph\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_out_edge(e)\n\t\tv.add_in_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.out_edges.delete(e)\n\t\tv.in_edges.delete(e)\n\t\te\n\tend\n\n\tclass Node < Graph::Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@out_edges = Set.new\n\t\t\t@in_edges = Set.new\n\t\tend\n\n\t\tdef add_out_edge(e)\n\t\t\t@out_edges << e\n\t\tend\n\n\t\tdef del_out_edge(e)\n\t\t\t@out_edges.delete(e)\n\t\tend\n\n\t\tdef add_in_edge(e)\n\t\t\t@in_edges << e\n\t\tend\n\n\t\tdef del_in_edge(e)\n\t\t\t@in_edges.delete(e)\n\t\tend\n\n\t\tattr_reader :in_edges, :out_edges\n\tend\n\n\tclass Edge < Graph::Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@property = property\n\t\tend\n\n\t\tattr_reader :from, :to\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.out_edges.each{|e|\n\t\t\tyield [e.to, e.length]\n\t\t}\n\tend\n\n\tdef each_in_connection_of(v)\n\t\tv.in_edges.each{|e|\n\t\t\tyield [e.from, e.length]\n\t\t}\n\tend\n\n#----------------------------------------------------------\n\n\tdef get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\nend\n\nrequire 'matrix'\nrequire 'mathn'\n\nn, m = gets.split.map &:to_i\ng = Digraph.new\nnodes = (0..n-1).map{|i| g.add_node({:index => i}) }\n\nm.times{|k|\n\ti, j = gets.split.map &:to_i\n\tg.add_edge(nodes[i-1], nodes[j-1], {:index => k})\n}\n\na = (1..n).map{ [0] * m }\n(0..n-1).each{|i|\n\tnodes[i].in_edges.each{|e|\n\t\tj = e.property[:index]\n\t\ta[i][j] = 1\n\t}\n\tnodes[i].out_edges.each{|e|\n\t\tj = e.property[:index]\n\t\ta[i][j] = -1\n\t}\n}\np m - Matrix[*a].rank"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    N, M = map(int, readline().split())\n    G = [[] for i in range(N)]\n    for i in range(M):\n        s, t = map(int, readline().split())\n        G[s-1].append(t-1)\n\n    used = [0]*N\n    cnt = 0\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v])-1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    write(\"%d\\n\" % ans)\nsolve()\n\n"
  }
]