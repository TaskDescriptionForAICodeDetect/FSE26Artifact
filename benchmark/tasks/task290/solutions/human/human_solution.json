[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define pb(a) push_back(a)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\n\nint m;\nint ans;\nvector<int> used, X, Y;\nvector<P> p;\n\nbool parallel(int i, int j, int k, int l){\n\tLL dx1 = X[i] - X[j];\n\tLL dy1 = Y[i] - Y[j];\n\tLL dx2 = X[k] - X[l];\n\tLL dy2 = Y[k] - Y[l];\n\treturn dx1 * dy2 == dx2 * dy1;\n}\n\nvoid dfs(int d){\n    rep(i, m){\n        if(!used[i]){\n            used[i] = 1;\n            for(int j=i; j<m; j++){\n                if(!used[j]){\n                    used[j] = 1;\n                    p[d] = make_pair(i,j);\n                    if(d == m/2-1){\n                        int ret = 0;\n                        rep(k,m/2)for(int l=k+1; l<m/2; l++){\n                            if(parallel(p[k].fs, p[k].sc, p[l].fs, p[l].sc)){\n                                ret++;\n                            }\n                        }\n                        ans = max(ans, ret);\n                    }else{\n                        dfs(d+1);\n                    }\n                    used[j] = 0;\n                }\n            }\n            used[i] = 0;\n            break;\n        }\n    }\n}\n\nint main(){\n    cin>>m;\n    used = vector<int>(m);\n    p  = vector<P>(m);\n    X = vector<int>(m);\n    Y = vector<int>(m);\n    rep(i, m) cin >> X[i] >> Y[i];\n    dfs(0);\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, x[19], y[19], h[129][19][19], dp[65555][549]; bool vis[65555][549]; map<pair<int, int>, vector<pair<int, int> > > d; vector<vector<pair<int, int> > > v;\nint gcd(int pa, int pb) {\n\tif (pb == 0) return pa;\n\treturn gcd(pb, pa % pb);\n}\nint solve(int bit, int p1, int p2, int cur) {\n\tif (p1 == v.size()) return 0;\n\tif (p2 == v[p1].size()) {\n\t\tint res = solve(bit, p1 + 1, 0, 0);\n\t\treturn res + cur * (cur - 1) / 2;\n\t}\n\tif (vis[bit][h[p1][p2][cur]]) return dp[bit][h[p1][p2][cur]];\n\tint pa = v[p1][p2].first, pb = v[p1][p2].second;\n\tint ret = solve(bit, p1, p2 + 1, cur);\n\tif (!(bit & (1 << pa)) && !(bit & (1 << pb))) {\n\t\tint res = solve(bit | (1 << pa) | (1 << pb), p1, p2 + 1, cur + 1);\n\t\tret = max(ret, res);\n\t}\n\tvis[bit][h[p1][p2][cur]] = true;\n\tdp[bit][h[p1][p2][cur]] = ret;\n\treturn ret;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint vx = x[j] - x[i], vy = y[j] - y[i];\n\t\t\tif (vy < 0) vy = -vy, vx = -vx;\n\t\t\tif (vy == 0 && vx < 0) vx = -vx;\n\t\t\tint g = gcd(abs(vx), vy);\n\t\t\td[make_pair(abs(vx) / g * (vx > 0 ? 1 : -1), vy / g)].push_back(make_pair(i, j));\n\t\t}\n\t}\n\tfor (pair<pair<int, int>, vector<pair<int, int> > > i : d) {\n\t\tv.push_back(i.second);\n\t}\n\tint curs = 0;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tfor (int j = 0; j < v[i].size(); j++) {\n\t\t\tfor (int k = 0; k <= j; k++) {\n\t\t\t\th[i][j][k] = curs++;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = solve(0, 0, 0, 0);\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> mypair;\n#define eps 1e-6\n#define equals(a,b) (fabs( (a) - (b) )< EPS )\n#define EPS eps\ntypedef struct point{\n\tdouble x,y;\n\tpoint(){};\n\tpoint(double x ,double y):x(x),y(y){};\n\tpoint operator + (point &p){ return point(x+p.x,y+p.y);\t}\n\tpoint operator - (point &p){ return point(x-p.x,y-p.y);\t}\n\tpoint operator * (point &p){ return point(x*p.x-y*p.y,x*p.y+y*p.x) ;}\n\tpoint operator * (double a){ return point(x*a,y*a);\t}\n\tpoint operator / (double a){ return point(x/a,y/a);\t}\n\t\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x+y*y; }\n\t\n\tbool operator < (const point &p) const { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (const point &p) const { return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS; }\n}point;\n\ndouble cross(point a,point b){ return a.x*b.y - a.y*b.x ; }//ﾂ外ﾂ静・zﾂ青ｬﾂ閉ｪ)ﾂ　aﾂ×b\nbool isparallel(point a,point b){ return equals(cross(a,b),0.0); }\ndouble dot(point a,point b){ return a.x*b.x+a.y*b.y ; } //ﾂ禿ﾂ静渉　aﾂ・b\npoint make(){ \n\tdouble x,y; cin>>x>>y;\n       \treturn point(x,y);\n}\nint dfs(int now,int m,int ans,vector<vector<point > > &ang,vector<bool>&used){\n\tif(now == m-1)return ans;\n\tif(!used[now]) return dfs(now+1,m,ans,ang,used);\n\tused[now] = false;\n\tint tmp = ans;\n       for(int i = 0;i< m;i++) if(used[i]){\n\tused[i] = false;\n\tint count = 1;\n\tvector<int> convert;\n\tconvert.push_back(i);\n\tpoint tmpang = ang[now][i] ;\n\t\tfor(int j = now+1;j<m;j++){\n\t\t\tif(used[j] )for(int k = j+1;k<m;k++){\n\t\t\t\tif(used[k]){\n\t\t\t\t\tif(isparallel(tmpang,ang[j][k])){\n\t\t\t\t\tused[j] =false;\n\t\t\t\t\tused[k] = false;\n\t\t\t\t\tconvert.push_back(j);\n\t\t\t\t\tconvert.push_back(k);\n\t\t\t\t\tcount++;\n\t\t\t\t\tbreak;\t\n\t\t\t\t\t}\t\t\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t//\tcout<<endl<<\"debug\"<<now<<' '<<i<<' '<<count<<' '<<count*(count-1)/2<<endl;\n\t\ttmp = max(tmp,dfs(now+1,m,ans+(count*(count-1))/2,ang,used));\n\t\tfor(int j=0;j<convert.size();j++){\n\t\t\tused[convert[j]]  = true;\n\t\t//\tcout<<convert[j]<<' ';\n       \t\t}\n\t}\n\tused[now] = true;\n\treturn tmp;\t\n}\n\nint main(){\n\tint m;\n\tcin>>m;\n\tvector<point> p(m);\n\tfor(int i=0;i<m;i++){\n\tp[i] = make();\n\t}\n\tvector<vector<point> > ang(m,vector<point> (m) );\n\tfor(int i=0;i<m;i++){\n\n\t\tfor(int j=0;j<m;j++){\n\t\t\tang[i][j] = p[i]-p[j];\n\t\t}\n\t}\n\tvector<bool> used(m,true);\n\tcout<<dfs(0,m,0,ang,used)<<endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstatic const int MAX_N = 16;\n\nint n;\nint x[MAX_N], y[MAX_N];\n\nint l[MAX_N];\nint p1[MAX_N / 2], p2[MAX_N / 2];\n\nvoid rec(int num, int &res){\n\tif(num == n / 2){\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < n / 2; i++){\n\t\t\tfor(int j = i + 1; j < n / 2; j++){\n\t\t\t\tif((x[p2[i]] - x[p1[i]]) * (y[p2[j]] - y[p1[j]]) == (x[p2[j]] - x[p1[j]]) * (y[p2[i]] - y[p1[i]])) cnt++;\n\t\t\t}\n\t\t}\n\t\tres = max(res, cnt);\n\t\treturn;\n\t}\n\tint num2;\n\tfor(int i = 0; i < n; i++){\n\t\tif(l[i] == -1){\n\t\t\tl[i] = num;\n\t\t\tp1[num] = i;\n\t\t\tnum2 = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tif(l[i] == -1){\n\t\t\tl[i] = num;\n\t\t\tp2[num] = i;\n\t\t\trec(num + 1, res);\n\t\t\tl[i] = -1;\n\t\t}\n\t}\n\tl[num2] = -1;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++) scanf(\"%d %d\", &x[i], &y[i]);\n\tfill(l, l + n, -1);\n\tint res = 0;\n\trec(0, res);\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define LL long long\nusing namespace std;\nint m,cnt;\nint ans;\nstruct poi{\n\tint x,y;\n\tpoi(){}\n\tpoi(int xx,int yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tvoid read(){\n\t\tscanf(\"%d%d\",&x,&y);\n\t}\n\tfriend poi operator-(poi a,poi b){\n\t\treturn poi(a.x-b.x,a.y-b.y);\n\t}\n\tfriend int operator^(poi a,poi b){\n\t\treturn a.x*b.y-a.y*b.x;\n\t}\n} p[20],s[10];\nbool flag[20];\nvoid work(){\n\tint fst=0;\n\tfor (fst=1;fst<=m;fst++) if (flag[fst]==0){\n\t\tflag[fst]=1;\n\t\tbreak;\n\t}\n\tif (fst>m){\n\t\tint res=0;\n\t\tfor (int i=1;i<=m/2;i++) for (int j=i+1;j<=m/2;j++){\n\t\t\tif ((s[i]^s[j])==0) res++;\n\t\t\tif (res>ans) ans=res;\n\t\t}\n\t\treturn;\n\t}\n\tfor (int i=fst+1;i<=m;i++) if (!flag[i]){\n\t\ts[++cnt]=p[i]-p[fst];\n\t\tflag[i]=1;\n\t\twork();\n\t\tflag[i]=0;\n\t\tcnt--;\n\t}\n\tflag[fst]=0;\n}\nint main(){\n\tscanf(\"%d\",&m);\n\tfor (int i=1;i<=m;i++) p[i].read();\n\twork();\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\nusing namespace std;\nint ans,n;\nint x[16],y[16];\nbool used[16];\npair<int,int>id[8];\nvoid dfs(int d)\n{\n\tif(d*2==n)\n\t{\n\t\tpair<int,int>p[8];\n\t\tfor(int i=0;i<d;i++)p[i]=make_pair(x[id[i].first]-x[id[i].second],y[id[i].first]-y[id[i].second]);\n\t\tint now=0;\n\t\tfor(int i=0;i<d;i++)\n\t\t{\n\t\t\tfor(int j=i+1;j<d;j++)\n\t\t\t{\n\t\t\t\tif(p[i].first*p[j].second==p[i].second*p[j].first)now++;\n\t\t\t}\n\t\t}\n\t\tif(ans<now)ans=now;\n\t\treturn;\n\t}\n\tint i=0;\n\twhile(used[i])i++;\n\tfor(int j=i+1;j<n;j++)\n\t{\n\t\tif(used[j])continue;\n\t\tused[i]=used[j]=1;\n\t\tid[d].first=i;\n\t\tid[d].second=j;\n\t\tdfs(d+1);\n\t\tused[i]=used[j]=0;\n\t}\n}\nmain()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)cin>>x[i]>>y[i];\n\tdfs(0);\n\tcout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <iostream>\n//#include <vector>\n//#include <map>\n//#include <numeric>\n#include <bits/stdc++.h>\nusing namespace std;\n\nint M;\nvector<int> X, Y;\n\nint nc2(int x){\n    if(x < 2)\n        return 0;\n    return x * (x-1) / 2;\n}\n\nint get_counts(map<pair<int, int>, int> &counts){\n    int res = 0;\n    for(auto p: counts)\n        res += nc2(p.second);\n    return res;\n}\n\npair<int, int> get_fraction(int i, int j){\n    int dx = X[i] - X[j];\n    int dy = Y[i] - Y[j];\n    int g = __gcd(dx, dy);\n    \n    return {dx/g, dy/g};\n}\n\nint dfs(int idx, int used, map<pair<int, int>, int> &counts){\n    if(idx == M){\n        return get_counts(counts);\n    }\n    \n    int res = -1;\n    if((used >> idx) & 1){\n        res = max(res, dfs(idx+1, used, counts));\n    }else{\n        for(int i=idx+1; i<M; i++) if(((used >> i) & 1) == 0){\n            int nused = used;\n            nused |= 1 << idx;\n            nused |= 1 << i;\n            \n            pair<int, int> fr = get_fraction(idx, i);\n            counts[fr]++;\n            res = max(res, dfs(idx+1, nused, counts));\n            counts[fr]--;\n        }\n    }\n    return res;\n}\n\nint main(){\n    cin >> M;\n    X.resize(M), Y.resize(M);\n    \n    for(int i=0; i<M; i++)\n        cin >> X[i] >> Y[i];\n    \n    map<pair<int, int>, int> counts;\n    cout << dfs(0, 0, counts) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, x[19], y[19], h[129][19][19], dp[65555][549]; bool vis[65555][549]; map<pair<int, int>, vector<pair<int, int> > > d; vector<vector<pair<int, int> > > v;\nint gcd(int pa, int pb) {\n\tif (pb == 0) return pa;\n\treturn gcd(pb, pa % pb);\n}\nint solve(int bit, int p1, int p2, int cur) {\n\tif (p1 == v.size()) return 0;\n\tif (p2 == v[p1].size()) {\n\t\tint res = solve(bit, p1 + 1, 0, 0);\n\t\treturn res + cur * (cur - 1) / 2;\n\t}\n\tif (vis[bit][h[p1][p2][cur]]) return dp[bit][h[p1][p2][cur]];\n\tint pa = v[p1][p2].first, pb = v[p1][p2].second;\n\tint ret = solve(bit, p1, p2 + 1, cur);\n\tif (!(bit & (1 << pa)) && !(bit & (1 << pb))) {\n\t\tint res = solve(bit | (1 << pa) | (1 << pb), p1, p2 + 1, cur + 1);\n\t\tret = max(ret, res);\n\t}\n\tvis[bit][h[p1][p2][cur]] = true;\n\tdp[bit][h[p1][p2][cur]] = ret;\n\treturn ret;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint vx = x[j] - x[i], vy = y[j] - y[i];\n\t\t\tif (vy < 0) vy = -vy, vx = -vx;\n\t\t\tint g = gcd(abs(vx), vy);\n\t\t\td[make_pair(abs(vx) / g * (vx > 0 ? 1 : -1), vy / g)].push_back(make_pair(i, j));\n\t\t}\n\t}\n\tfor (pair<pair<int, int>, vector<pair<int, int> > > i : d) {\n\t\tv.push_back(i.second);\n\t}\n\tint curs = 0;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tfor (int j = 0; j < v[i].size(); j++) {\n\t\t\tfor (int k = 0; k < j; k++) {\n\t\t\t\th[i][j][k] = curs++;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = solve(0, 0, 0, 0);\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing namespace std;\n\nint m;\nint x[21], y[21];\n\nint ans = 0;\n\nvoid solve(int num, vector<int>& v, bitset<30> used) {\n    if (num >= m) {\n        //\n        map<double, int> mp;\n        int ret = 0;\n        for (int i=0; i<m; i+=2) {\n            for (int j=i+2; j<m; j+=2) {\n                int a = (y[v[i]] - y[v[i+1]]) * (x[v[j]] - x[v[j+1]]);\n                int b = (y[v[j]] - y[v[j+1]]) * (x[v[i]] - x[v[i+1]]);\n                if (a == b) ret++;\n            }\n        }\n\n        // for (int i=0; i<m; i+=2) {\n        //     mp[(double)(y[i]-y[i+1])/(x[i]-x[i+1])]++;\n        // }\n        // int ret = 0;\n        // for (auto & tmp : mp) {\n        //     if (tmp.second >= 2) {\n        //         ret += tmp.second * (tmp.second-1) / 2;\n        //     }\n        // }\n        ans = max(ans, ret);\n        return;\n    }\n\n    // 左橋から選ぶ\n    int idx = 0;\n    for (int i=0; i<m; ++i) {\n        if (!used[i]) {\n            v.push_back(i);\n            used[i] = true;\n            idx = i;\n            break;\n        }\n    }\n\n    for (int i=0; i<m; ++i) {\n        if (!used[i]) {\n            v.push_back(i);\n            used[i] = true;\n            solve(num+2, v, used);\n            used[i] = false;\n            v.pop_back();\n        }\n    }\n\n    v.pop_back();\n    used[idx] = false;\n}\n\nint main() {\n    cin >> m;\n    rep(i, m) cin >> x[i] >> y[i];\n\n    vector<int> v;\n    bitset<30> used;\n\n    solve(0, v, used);\n\n    cout << ans << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, gx[19][19], gy[19][19];\nint gcd(int pa, int pb) {\n\tif (pb == 0) return pa;\n\treturn gcd(pb, pa % pb);\n}\nint main() {\n\tcin >> n;\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\tint ret = 0;\n\twhile (true) {\n\t\tmap<pair<int, int>, int> d;\n\t\tn = x.size();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tint vx = x[i] - x[j], vy = y[i] - y[j];\n\t\t\t\tif (vy < 0) vy = -vy, vx = -vx;\n\t\t\t\tint vp = (vx > 0 ? vx : -vx);\n\t\t\t\tint g = gcd(vy, vp);\n\t\t\t\td[make_pair(vx / g, vy / g)]++;\n\t\t\t\tgx[i][j] = vx / g;\n\t\t\t\tgy[i][j] = vy / g;\n\t\t\t}\n\t\t}\n\t\tpair<int, int> r; int mx = 0;\n\t\tfor (pair<pair<int, int>, int> i : d) {\n\t\t\tif (i.second > mx) {\n\t\t\t\tmx = i.second;\n\t\t\t\tr = i.first;\n\t\t\t}\n\t\t}\n\t\tif (mx <= 1) break;\n\t\tvector<int> erase_pts;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (gx[i][j] == r.first && gy[i][j] == r.second) {\n\t\t\t\t\terase_pts.push_back(i);\n\t\t\t\t\terase_pts.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(erase_pts.begin(), erase_pts.end());\n\t\tfor (int i = erase_pts.size() - 1; i >= 0; i--) {\n\t\t\tx.erase(x.begin() + erase_pts[i]);\n\t\t\ty.erase(y.begin() + erase_pts[i]);\n\t\t}\n\t\tret += mx * (mx - 1) / 2;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iomanip>\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<LD, LD> PLDLD;\ntypedef vector<int> VI;\ntypedef vector<char> VB;\n \n#define FOR(i,a,b) for(int i=(a);i<(int)(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) a.begin(),a.end()\n \nconst LD eps=1e-10;\nconst long long INFLL=(LL)(1e9)*(LL)(1e9);\nconst int INF=1e9;\n \ntemplate<class T>\nvoid chmin(T& a, const T b)\n{\n\tif(a>b)\n\t\ta=b;\n}\ntemplate<class T>\nvoid chmax(T& a, const T b)\n{\n\tif(a<b)\n\t\ta=b;\n}\n \nconst LL pow(const LL p, const LL q)\n{\n\tLL t=1;\n\tfor(int i=0;i<q;i++)\n\t\tt*=p;\n\treturn t;\n}\n\ntemplate <typename T>\nstruct has_iter\n{\n\tprivate:\n\t\ttemplate <typename U>\n\t\tstatic constexpr true_type check(typename U::iterator*);\n\t\ttemplate <typename U>\n\t\tstatic constexpr false_type check(...);\n\n\tpublic:\n\t\tstatic constexpr bool value = decltype(check<T>(nullptr))::value;\n};\n\ntemplate<typename T, typename U = typename T::iterator>\nvoid print(const T& container)\n{\n\t\tauto&& first=begin(container), last=end(container);\n\t\tauto&& back=prev(last);\n\t\tfor(auto e=first; e!=last; e=next(e))\n\t\t\tcout<<*e<<\" \\n\"[e==back];\n}\n\nextern void* enabler;\ntemplate<typename Head, typename enable_if<!has_iter<Head>::value>::type*& = enabler>\nvoid print(const Head& head)\n{\n\tcout<<head<<endl;\n}\n\ntemplate<typename Head, typename... Tail>\nvoid print(const Head& head, const Tail&... tail)\n{\n\tcout<<head<<\" \";\n\tprint(tail...);\n}\n\nvoid io_speedup()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n}\n\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec)\n{\n\tfor(T& x: vec) is >> x;\n\treturn is;\n}\n\ntemplate<typename T>\nvector<T> read(int n)\n{\n\tvector<T> t(n);\n\tcin>>t;\n\treturn t;\n}\n\ntemplate<typename T>\nT read()\n{\n\tT t;\n\tcin>>t;\n\treturn t;\n}\n\ntypedef complex<double> Point;\nstruct Line\n{\n\tPoint a,b;\n\tLine(Point a_, Point b_):a(a_),b(b_)\n\t{}\n\tLine():a(Point(0,0)),b(Point(0,0))\n\t{}\n};\nbool paralell(Line a,Line b)\n{\n\tPoint p=a.a-a.b;\n\tPoint q=b.a-b.b;\n\treturn abs(p.real()*q.imag()-q.real()*p.imag())<eps;\n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\tvector<Point> p(n);\n\tREP(i,n)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tp[i]=Point(x,y);\n\t}\n\tauto pa=[&](int a,int b)\n\t{\n\t\treturn a*n +b;\n\t};\n\tvector<set<PII>> para(n*n);\n\tREP(i,n)\n\tREP(j,n)\n\t{\n\t\tif(i==j) continue;\n\t\tLine ln(p[i],p[j]);\n\t\tset<PII> s;\n\t\tREP(k,n)\n\t\tFOR(l,k+1,n)\n\t\t{\n\t\t\tif(k==l) continue;\n\t\t\tif(i==k) continue;\n\t\t\tif(i==l) continue;\n\t\t\tif(j==k) continue;\n\t\t\tif(j==l) continue;\n\t\t\tif(paralell(ln, Line(p[k], p[l])))\n\t\t\t\ts.insert(PII(k,l));\n\t\t}\n\t\t//print(i,j,\":\");\n\t\t//for(auto&& e:s)\n\t\t//cout<<e.first<<\" \"<<e.second<<endl;\n\t\tpara[pa(i,j)]=s;\n\t}\n\n\tVI memo(1<<n, -1);\n\tfunction<int(int)> dfs=[&](int p)\n\t{\n\t\tif(memo[p]!=-1) return memo[p];\n\t\tint a,b;\n\t\tREP(i,n)\n\t\t{\n\t\t\tif(((1<<i)&p)==0)\n\t\t\t{\n\t\t\t\ta=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tREP(i,n)\n\t\t{\n\t\t\tif(i==a)continue;\n\t\t\tif(((1<<i)&p)==0)\n\t\t\t{\n\t\t\t\tb=i;\n\t\t\t\tauto s=para[pa(a,b)];\n\t\t\t\tvector<PII> ok;\n\t\t\t\tfor(auto&& e:s)\n\t\t\t\t{\n\t\t\t\t\tint c,d;\n\t\t\t\t\ttie(c,d)=e;\n\t\t\t\t\tif((p&(1<<c))>0) continue;\n\t\t\t\t\tif((p&(1<<d))>0) continue;\n\t\t\t\t\tok.push_back(e);\n\t\t\t\t}\n\t\t\t\tint ssz=ok.size();\n\t\t\t\tREP(j,(1<<ssz))\n\t\t\t\t{\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tint q=(1<<a)+(1<<b);\n\t\t\t\t\tREP(k,ssz)\n\t\t\t\t\t{\n\t\t\t\t\t\tif((j&(1<<k))>0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tint c,d;\n\t\t\t\t\t\t\ttie(c,d)=ok[k];\n\t\t\t\t\t\t\tq+=(1<<c);\n\t\t\t\t\t\t\tq+=(1<<d);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tchmax(ans, dfs(p|q) + (cnt+1)*cnt/2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//print(p,ans);\n\t\treturn memo[p]=ans;\n\t};\n\n\tprint(dfs(0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <stack>\nusing namespace std;\n#define debug(x) std::cerr << #x << \" = \" << (x) << std::endl\ntypedef pair<int, int> PII;\ntypedef long long ll;\ntypedef unsigned long long ULL;\n\nint x[30], y[30], ans[30][30],vis[30][30];\n\nint main()\n{\n\tint m;\n\tlong long res;\n\tmemset(ans, 0, sizeof(ans));\n\tmemset(vis, 0, sizeof(vis));\n\tscanf(\"%d\", &m);\n\tfor(int i = 0; i < m; i++){\n\t\tscanf(\"%d %d\", &x[i], &y[i]);\n\t}\n\tfor(int i = 0; i < m; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tif(i == j) continue;\n\t\t\tfor(int k = 0; k < m; k++){\n\t\t\t\tfor(int l = k + 1; l < m; l++){\n\t\t\t\t\tif(k == i || k == j || l == i || l == j) continue;\n\t\t\t\t\tif(((y[j] - y[i]) * (x[k] - x[l])) == ((y[k] - y[l]) * (x[j] - x[i])) && vis[i][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvis[k][l] = 1;\n\t\t\t\t\t\tvis[l][k] = 1;\n\t\t\t\t\t\tvis[j][i] = 1;\n\t\t\t\t\t\tans[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint Max = -1;\n\tres = 0;\n\tfor(int i = 0; i < m; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tif(vis[i][j] == 0)\n\t\t\t{\n\t\t\t\tres += ans[i][j] * (ans[i][j] + 1) / 2;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing Number = double;\nconst Number EPS = 1e-10;\n\ninline int sign(Number x) { return (x < -EPS) ? -1 : (x > EPS) ? +1 : 0; }\ninline bool equal(Number a, Number b) { return sign(a - b) == 0; }\n\nclass Point {\npublic:\n    Number x, y;\n\n    Point() {}\n    Point(Number x, Number y) : x(x), y(y) {}\n\n    Point operator+(const Point &rhs) const {\n        return Point(this->x + rhs.x, this->y + rhs.y);\n    }\n    Point operator-(const Point &rhs) const {\n        return Point(this->x - rhs.x, this->y - rhs.y);\n    }\n};\n\ninline Number abs_cross(const Point &p1, const Point &p2) {\n    return p1.x * p2.y - p1.y * p2.x;\n}\n\nclass Line : public std::array<Point, 2> {\npublic:\n    Line() {}\n    Line(const Point &p1, const Point &p2) {\n        (*this)[0] = p1;\n        (*this)[1] = p2;\n    }\n};\ninline bool IsParallel(const Line &l1, const Line &l2) {\n    return equal(abs_cross(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\n\nint Search(const int i, const int m, vector<int> &idx, const vector<Point> &p) {\n    if (i == m - 2) {\n        int sum = 0;\n        vector<bool> check(m / 2, false);\n\n        for (int j = 0; 2 * j < m; ++j) {\n            if (check[j]) continue;\n\n            check[j] = true;\n            int num = 1;\n            Line l(p[idx[2 * j]], p[idx[2 * j + 1]]);\n            for (int k = j + 1; 2 * k < m; ++k)\n                if (IsParallel(l, Line(p[idx[2 * k]], p[idx[2 * k + 1]]))) {\n                    ++num;\n                    check[k] = true;\n                }\n            sum += num * (num - 1) / 2;\n        }\n        return sum;\n    }\n\n    int res = 0;\n    if (i % 2 == 0) {\n        int min_idx = distance(idx.begin(), min_element(idx.begin() + i, idx.end()));\n        swap(idx[i], idx[min_idx]);\n        res=  Search(i + 1, m, idx, p);\n    }\n    else {\n        for (int j = i; j < m; ++j) {\n            swap(idx[i], idx[j]);\n            res = max(res, Search(i + 1, m, idx, p));\n        }\n    }\n\n    return res;\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    int m;\n\n    cin >> m;\n    vector<Point> p(m);\n    for (auto &pp : p) cin >> pp.x >> pp.y;\n\n    vector<int> idx(m);\n    iota(idx.begin(), idx.end(), 0);\n\n    cout << Search(1, m, idx, p) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nvector<int> x, y;\nvector<pair<int, int>> u;\nint n;\nint dfs(vector<int> &v, int depth = 1){\n    if(n-(depth-1)*2 < 1) {\n        int ret = 0;\n        for (int i = 0; i < u.size(); ++i) {\n            for (int j = i+1; j < u.size(); ++j) {\n                if(u[i].first*u[j].second == u[j].first*u[i].second) ret++;\n            }\n        }\n        return ret;\n    }\n\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        if(v[i]) continue;\n        for (int j = i+1; j < n; ++j) {\n            if(v[j]) continue;\n            int tmp1 = v[i], tmp2 = v[j];\n            v[i] = v[j] = depth;\n            u.emplace_back(x[i]-x[j], y[i]-y[j]);\n            ans = max(ans, dfs(v, depth+1));\n            u.pop_back();\n            v[i] = tmp1; v[j] = tmp2;\n        }\n        break;\n    }\n    return ans;\n}\n\nint main() {\n    cin >> n;\n    x.resize(n); y.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> x[i] >> y[i];\n    }\n    vector<int> v(n);\n    cout << dfs(v) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nint x[16],y[16];\nvector<P>v;\nint m;\nint Max=0;\nbool used[16];\n\nvoid dfs(){\n\tif(v.size()==m/2){\n\t\tint cnt=0;\n\t\trep(i,v.size())for(int j=i+1;j<v.size();j++){\n\t\t\tint a=x[v[i].first]-x[v[i].second],b=y[v[i].first]-y[v[i].second],\n\t\t\tc=x[v[j].first]-x[v[j].second],d=y[v[j].first]-y[v[j].second];\t\t\n\t\t\tif(a*d==b*c){cnt++;continue;}\n\t\t\ta=-a;b=-b;\n\t\t\tif(a*d==b*c){cnt++;continue;}\n\t\t\ta=-a;b=-b;\n\t\t\tc=-c;d=-d;\n\t\t\tif(a*d==b*c){cnt++;continue;}\n\t\t\ta=-a;b=-b;\n\t\t\tif(a*d==b*c){cnt++;continue;}\n\t\t}\n\t\tMax=max(Max,cnt);return;\n\t}\n\tint i=0;\n\twhile(used[i])i++;\n\tfor(int j=i+1;j<16;j++){\n\t\tif(!used[j]){\n\t\t\tv.push_back(P(i,j));\n\t\t\tused[i]=used[j]=true;\n\t\t\tdfs();\n\t\t\tused[i]=used[j]=false;\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d\",&m);\n\trep(i,m)cin>>x[i]>>y[i];\n\tdfs();\n\tcout<<Max<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream&\noperator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream&\noperator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream&\noperator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\nint one_hot(int x) { return 1 << x; }\n\npii calc_arg(int dx, int dy) {\n    if(dx < 0) {\n        dx *= -1;\n        dy *= -1;\n    }\n    int g = __gcd(abs(dx), abs(dy));\n    dx /= g;\n    dy /= g;\n    if(dx == 0) dy = 1;\n    else if(dy == 0) dx = 1;\n    return make_pair(dx, dy);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N; cin >> N;\n    vector<int> X(N), Y(N);\n    rep(i, N) cin >> X[i] >> Y[i];\n    int ans = 0;\n    function<void(int, map<pii, int>&)> dfs = [&] (int used, map<pii, int> &args) {\n        if(__builtin_popcount(used) == N) {\n            int tmp = 0;\n            for(auto &p : args) {\n                tmp += p.second * (p.second - 1) / 2;\n            }\n            set_max(ans, tmp);\n            return;\n        }\n        int now = -1;\n        rep(i, N) if(not(used & one_hot(i))) {\n            now = i;\n            break;\n        }\n        assert(now >= 0);\n        used |= one_hot(now);\n        rep(i, N) {\n            if(not (used & one_hot(i))) {\n                pii arg = calc_arg(X[now] - X[i], Y[now] - Y[i]);\n                args[arg]++;\n                dfs(used | one_hot(i), args);\n                if(--args[arg] == 0) args.erase(arg);\n            }\n        }\n    };\n    map<pii, int> args;\n    dfs(0, args);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\n\nint N, n;\nint x[16], y[16];\nint a[16];\n\nbool parallel(int x1, int y1, int x2, int y2) {\n\treturn !(x1 * y2 - y1 * x2);\n}\n\nint f(vector<int> p, vector<int> q) {\n\tint ans = 0;\n\trep(k, n) rep(l, k) {\n\t\tint i1 = p[k], i2 = q[k];\n\t\tint j1 = p[l], j2 = q[l];\n\t\tif (parallel(x[i1] - x[i2], y[i1] - y[i2], x[j1] - x[j2], y[j1] - y[j2]))\n\t\t\tans++;\n\t}\n\treturn ans;\n}\n\nint ma = 0;\n\nvoid dfs(int i, int k) {\n\tif (i == N) {\n\t\tvector<int> p(n, -1), q(n, -1);\n\t\trep(i, N) {\n\t\t\tint k = a[i];\n\t\t\tif (p[k] == -1) p[k] = i;\n\t\t\telse q[k] = i;\n\t\t}\n\t\tma = max(ma, f(p, q));\n\t\treturn;\n\t}\n\tif (a[i] == -1) {\n\t\ta[i] = k;\n\t\tfor (int j = i + 1; j < N; j++) if (a[j] == -1) {\n\t\t\ta[j] = k;\n\t\t\tdfs(i + 1, k + 1);\n\t\t\ta[j] = -1;\n\t\t}\n\t\ta[i] = -1;\n\t}\n\telse dfs(i + 1, k);\n}\n\nint main() {\n\tcin >> N; n = N / 2;\n\trep(i, N) cin >> x[i] >> y[i];\n\trep(i, N) a[i] = -1;\n\tdfs(0, 0);\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n#include <map>\nusing namespace std;\nusing ll = long long;\nconst double INF = (1<<30) * 1.0;\nconst int MOD = 1e9 + 7;\nint n, ans;\nvector<pair<double, double>> v;\ndouble calc(double a, double b)\n{\n    pair<double, double> p = v[a], q = v[b];\n    double w = p.first - q.first;\n    double h = p.second - q.second;\n    if(w == 0) return INF;\n    return h / w;\n}\nvoid dfs(vector<int> used, vector<double> grad)\n{\n    if(grad.size() == n / 2)\n    {\n        map<double, int> mp;\n        for(int i = 0; i < grad.size(); i++) mp[grad[i]]++;\n        int cnt = 0;\n        for(auto x : mp) cnt += x.second * (x.second - 1) / 2;\n        ans = max(ans, cnt);\n        return;\n    }\n    int pos;\n    for(int i = 0; i < n; i++)\n    {\n        if(used[i]) continue;\n        pos = i;\n        used[i] = true;\n        break;\n    }\n    for(int i = 0; i < n; i++)\n    {\n        if(used[i]) continue;\n        used[i] = true;\n        grad.push_back(calc(pos, i));\n        dfs(used, grad);\n        grad.pop_back();\n        used[i] = false;\n    }\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    for(int i = 0; i < n; i++)\n    {\n        double x, y; cin >> x >> y;\n        v.push_back(make_pair(x, y));\n    }\n    sort(v.begin(), v.end());\n    vector<int> used(n, 0);\n    vector<double> tmp;\n    dfs(used, tmp);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "int main(){\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt dp[16][16][10][1<<16];\ntemplate<typename T>\nvoid chmax(T &a,T b){\n  if(a<b) a=b;\n}\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n;\n  cin>>n;\n  using P = pair<Int, Int>;\n  vector<P> v;\n  for(Int i=0;i<n;i++){\n    Int x,y;\n    cin>>x>>y;\n    v.emplace_back(x,y);\n  }\n  vector<vector<P> > r(n,vector<P>(n)); \n  for(Int i=0;i<n;i++){\n    for(Int j=i+1;j<n;j++){\n      if(v[i].first==v[j].first){\n\tr[i][j]=P(0,1);\n\tcontinue;\n      }\n      if(v[i].second==v[j].second){\n\tr[i][j]=P(1,0);\n\tcontinue;\n      }\n      Int dx=v[i].first-v[j].first;\n       Int dy=v[i].second-v[j].second;\n       if(dx<0){\n\t dx*=-1;\n\t dy*=-1;\n       }\n       Int k=__gcd(dx,abs(dy));\n       dx/=k;dy/=k;\n       r[i][j]=P(dx,dy);\n       //cout<<i<<\" \"<<j<<\":\"<<dx<<\" \"<<dy<<endl;\n     }\n   }\n  memset(dp,-1,sizeof(dp));\n  //dp[0][0][0][0]=0;\n  for(Int i=0;i<n;i++){\n    for(Int j=i+1;j<n;j++){\n      dp[i][j][1][(1<<i)|(1<<j)]=0;\n    }\n  }\n  Int ans=0;\n  for(Int b=0;b<(1<<n);b++){\n    for(Int i=0;i<n;i++){\n      for(Int j=i+1;j<n;j++){\n\tfor(Int k=0;k<=n/2;k++){\n\t  if(dp[i][j][k][b]<0) continue;\n\t  //cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<b<<\":\"<<dp[i][j][k][b]<<endl;\n\t  for(Int s=0;s<n;s++){\n\t    for(Int t=s+1;t<n;t++){\n\t      if((b>>s)&1) continue;\n\t      if((b>>t)&1) continue;\n\t      Int nb=b|(1<<s)|(1<<t);\n\t      if(r[i][j]==r[s][t]){\n\t\tchmax(dp[s][t][k+1][nb],dp[i][j][k][b]+k);\n\t\tchmax(ans,dp[s][t][k+1][nb]);\n\t      }else{\n\t\tchmax(dp[s][t][1][nb],dp[i][j][k][b]);\n\t\tchmax(ans,dp[s][t][1][nb]);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n  }  \n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<pa,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                 \n                                        using namespace std;\n\nint par[500100],ranks[500100],kosuu[500100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\n\nint gcd(int a1,int a2){\n\tif(a1<a2) return gcd(a2,a1);\n\tif(a2==1) return 1;\n\tif(a1%a2==0) return a2;\n\treturn gcd(a2,a1%a2);\n}\n\n\nint rui2(int e,int r){\n\tif(r==0) return 1;\n\tif(r==1) return e%inf;\n\tif(r%2==1) return (e*rui2(e,r-1))%inf;\n\tint w=rui2(e,r/2)%inf;\n\treturn (w*w)%inf;\n}\n\nbool heikou(pa a,pa b){\n\treturn (a.first*b.second==a.second*b.first);\n}\n\npa po[100];\nint n;\nbool sumi[20]={0};\nvector<pa> ve;\nint ans=0;\nvoid dfs(int nokori,int kazu){\n\tif(nokori==0){\n\t\tans=max(ans,kazu);\n\t\treturn;\n\t}\n\t\n\tint s=0;\n\twhile(sumi[s])s++;\n\tsumi[s]=1;\n\tfor(int i=s+1;i<n;i++){\n\t\tif(sumi[i])continue;\n\t\tint r=kazu;\n\t\tpa sabun=mp(po[i].first-po[s].first,po[i].second-po[s].second);\n\t\tfor(auto v:ve)if(heikou(v,sabun))r++;\n\t\tsumi[i]=1;\n\t\tve.pb(sabun);\n\t\tdfs(nokori-2,r);\n\t\tve.pop_back();\n\t\tsumi[i]=0;\n\t\t\n\t}\n\tsumi[s]=0;\n\t\n}\n\n\n            signed main(){\n   cin>>n;\n            \tfor(int i=0;i<n;i++)cin>>po[i].first>>po[i].second;\n            \tans=0;\n            \tdfs(n,0);\n            \tcout<<ans<<endl;\n            \treturn 0;\n            }\n             "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\n\nstruct Point {\n\tint x, y;\n\tPoint operator - (const Point& p) const { return Point{x - p.x, y - p.y}; }\n};\n\nint m;\nPoint p[16];\n\nint cross(Point& a, Point& b) { return a.x * b.y - a.y * b.x; }\nbool is_para(Point& a, Point& b) { return cross(a, b) == 0; }\n\nint calc(vector< int >& a, vector< int >& b) {\n\tint res = 0;\n\tfor_(i,0,m/2) for_(j,i+1,m/2) {\n\t\tPoint ai = p[a[i]] - p[b[i]];\n\t\tPoint bi = p[a[j]] - p[b[j]];\n\t\tres += is_para(ai, bi);\n\t}\n\treturn res;\n}\n\nint rec(int i, vector< int >& a, vector< int >& b, vector< bool >& used) {\n\tif (i == m) return calc(a, b);\n\tif (used[i]) return rec(i+1, a, b, used);\n\t\n\tint ret = 0;\n\t\n\ta.push_back(i);\n\tused[i] = true;\n\t\n\tfor_(j,0,16) {\n\t\tif (used[j]) continue;\n\t\tb.push_back(j);\n\t\tused[j] = true;\n\t\tret = max(ret, rec(i+1, a, b, used));\n\t\tb.pop_back();\n\t\tused[j] = false;\n\t}\n\t\n\ta.pop_back();\n\tused[i] = false;\n\t\n\treturn ret;\n}\n\nint main() {\n\tcin >> m;\n\tfor_(i,0,m) cin >> p[i].x >> p[i].y;\t\n\tvector< int > a, b;\n\tvector< bool > used(m, false);\n\tcout << rec(0, a, b, used) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\n#define EPS 1e-6\n\nvector<pair<int,int> > v;\nvector<pair<int,int> > p(20);\nint n;\nint ans;\nint comb[10][10];\n\nbool equal(double a,double b)\n{\n\treturn ((abs(a - b) < EPS)?true:false);\n}\n\nvoid check()\n{\n\tvector<double> tmp;\n\tREP(i,n/2)\n\t{\n\t\tint j = i*2;\n\t\tpair<double,double> a,b,c;\n\t\ta = p[j];b = p[j+1];\n\t\tc.FI = a.FI - b.FI;\n\t\tc.SE = a.SE - b.SE;\n\t\tdouble in = 1000000;\n\t\tif(c.SE != 0)in = c.FI / c.SE;\n\t\ttmp.PB(in);\n\t}\n\tsort(ALL(tmp));\n\tint ret = 0;\n\tREP(i,tmp.size())\n\t{\n\t\tint cou = 0;\n\t\twhile(i < tmp.size()-1 && equal(tmp[i],tmp[i+1])) \n\t\t{\n\t\t\ti++;cou++;\n\t\t}\n\t\tif(cou)ret += comb[cou+1][2];\n\t}\n\tans = max(ans,ret);\n}\n\nvoid dfs(int num,int memo)\n{\n\tif(num <= 1)\n\t{\n\t\tcheck();\n\t\treturn;\n\t}\n//\tcout << \"!\" << endl;\n\tint tmp = 0;\n\twhile(memo & (1<<tmp))tmp++;\n\tp[n-num] = v[tmp];\n\tmemo |= (1<<tmp);\n\t\n\tfor(int i = tmp+1;i < n;i++)\n\t{\n//\t\tcout << \"!!\" << endl;\n\t\tif(!(memo&(1<<i)))\n\t\t{\n//\t\t\tcout << \"!!!\" << endl;\n\t\t\tp[n-num+1] = v[i];\n//\t\t\tSHOW1d(ME,n);\n\t\t\tdfs(num-2,memo|(1<<i));\n\t\t}\n\t}\n\t\n}\n\nint main()\n{\n\tREP(i,10)comb[i][i] = comb[i][0] = 1;\n\tREP(i,10)\n\t{\n\t\tfor(int j = 1;j < i;j++)comb[i][j] = comb[i-1][j] + comb[i-1][j-1];\n\t}\n\t\n//\tSHOW2d(comb,8,8);\n\t\n\tcin >> n;\n\tREP(i,n)\n\t{\n\t\tint a,b;cin >> a >> b;\n\t\tv.PB(MP(a,b));\n\t}\n\t\n\tdfs(n,0);\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> point;\n#define x first\n#define y second\n\nint n;\nvector<point> vp;\n\nint gcd(int a, int b) {\n  return a ? gcd(b % a, a) : b;\n}\nint tmp[1 << 16];\nvoid process(vector<point> idx) {\n  int nmask = 1 << n;\n  for (int i = 0; i < nmask; ++i)\n    tmp[i] = 0;\n  tmp[0] = 1;\n  for (int i = 0; i < nmask; ++i) {\n    if (!tmp[i]) continue;\n    for (auto it : idx) {\n      int cur = (1 << it.first) | (1 << it.second);\n      if (cur & i) continue;\n      cur |= i;\n      tmp[cur] = 1;\n    }\n  }\n}\n\nint tra[1 << 16], dp[1 << 16];\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    vp.emplace_back(x, y);\n  }\n  vector<pair<point, point> > sorted;\n  for (int i = 0; i < n; ++i)\n    for (int j = i+1; j < n; ++j) {\n      int dx = vp[i].x - vp[j].x, dy = vp[i].y - vp[j].y;\n      if (dx < 0)\n        dx *= -1, dy *= -1;\n      int gd = gcd(dx, dy);\n      if (gd)\n        dx /= gd, dy /= gd;\n      sorted.emplace_back(point(dx, dy), point(i, j));\n    }\n  sort(sorted.begin(), sorted.end());\n  int nmask = 1 << n;\n  for (int i = 0; i < sorted.size(); ) {\n    vector<point> cur;\n    point val = sorted[i].x;\n    for (; i < sorted.size() && sorted[i].first == val; ++i)\n      cur.push_back(sorted[i].y);\n    process(cur);\n    for (int j = 0; j < nmask; ++j)\n      tra[j] |= tmp[j];\n  }\n  int ans = 0;\n  for (int i = 0; i < nmask; ++i) {\n    dp[i] = 0;\n    if (tra[i]) {\n      int cnt = __builtin_popcount(i)/2;\n      dp[i] = cnt * (cnt-1)/2;\n    }\n    for (int j = (i-1) & i; j > 0; j = (j-1) & i) {\n      if (tra[j]) {\n        int cnt = __builtin_popcount(j)/2;\n        dp[i] = max(dp[i], dp[i^j] + cnt * (cnt-1) / 2);\n      }\n    }\n    ans = max(ans, dp[i]);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,double> LP;\n \n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define all(x) x.begin(),x.end()\n \n#define inf 1e16\n \nll n;\nll x[1010],y[1010];\nmap<double,vector<P> > vs;\nvector<LP> as;\nbool used[1001];\n \nint main(){\n  cin>>n;\n  rep(i,n)cin>>x[i]>>y[i];\n  rep(i,n)rep(j,i){\n    ll dx=x[i]-x[j];\n    ll dy=y[i]-y[j];\n\n    if(dx==0){\n      vs[inf].push_back(P(i,j));\n    }else if(dy==0){\n      vs[0].push_back(P(i,j));\n    }else{\n      /*\n      ll pdx=dx<0?-dx:dx;\n      ll pdy=dy<0?-dy:dy;\n      ll g=__gcd(pdx,pdy);\n\n      if(dx<0)vs[P(-dx/g,-dy/g)].push_back(P(i,j));\n      else vs[P(dx/g,dy/g)].push_back(P(i,j));\n      */\n      vs[(double)dy/(double)dx].push_back(P(i,j));\n    }\n  }\n \n  for(auto it : vs){\n    as.push_back(LP(it.se.size(),it.fi));\n  }\n  sort(all(as));\n  reverse(all(as));\n \n  ll res=0;\n \n  rep(i,as.size()){\n    ll cnt=0;\n    for(auto it : vs[as[i].se]){\n      if(used[it.fi]||used[it.se])continue;\n      used[it.fi]=true; used[it.se]=true;\n      cnt++;\n    }\n    res+=cnt*(cnt-1)/2;\n  }\n \n  cout<<res<<endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <list>\n#include <map>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <bitset>\n#include <utility>\n#include <complex>\n#include <assert.h>\n#include <limits.h>\n#include <iomanip>\n//#include <unordered_map>\n//#include <unordered_set>\n//#include <bits/stdc++.h>\nusing namespace std;\n#define rank rankk\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define xo(a,b) ((b)&1?(a):0)\n#define tm tmp\n//#define LL ll\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef pair<ll,int> pli;\ntypedef pair<int,ll>pil;\ntypedef pair<ll,ll> pll;\n\n\nconst int INF=0x3f3f3f3f;\n//const ll INFF=1200000000000000000ll;\nconst ll INFF=0x3f3f3f3f3f3f3f3fll;\n//const ll INFF=1e14+5;\nconst int MAX=3e5+5;\nconst int MOD=1e9+7;\nconst double pi=acos(-1.0);\n//#define double long double\n//#define ls T[k].l\n//#define rs T[k].r\nconst double eps=1e-6;\n//#define double long double\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<typename T>inline T abs(T a) {return a>0?a:-a;}\n//#define double long double\ntemplate<class T> inline\nvoid read(T& num) {\n    bool start=false,neg=false;\n    char c;\n    num=0;\n    while((c=getchar())!=EOF) {\n        if(c=='-') start=neg=true;\n        else if(c>='0' && c<='9') {\n            start=true;\n            num=num*10+c-'0';\n        } else if(start) break;\n    }\n    if(neg) num=-num;\n}\ninline int powMM(int a,int b,int M){\n    int ret=1;\n    a%=M;\n    while (b){\n        if (b&1) ret=1LL*ret*a%M;\n        b>>=1;\n        a=1LL*a*a%M;\n    }\n    return ret;\n}\ninline int add(int x,int y){x%=MOD;y%=MOD;return (1LL*x+y)%MOD;}\n//inline int add(int x,int y){x+=y;if(x>=MOD)x-=MOD;return x;}\ninline void addi(int &x,int y){y%=MOD;x+=y;if(x>=MOD)x-=MOD;}\ninline int mul(int x,int y){return 1LL*x*y%MOD;}\n//inline void addi(int &x,int y){x%=MOD;y%=MOD;(x+=y)%=MOD;}\ninline void muli(int &x,int y){x%=MOD;y%=MOD;x=1LL*x*y%MOD;if(x<0)x+=MOD;}\ninline void mod(int &x){if(x<0){x%=MOD;x=(x+MOD)%MOD;}}\n\n//ll mul(ll a , ll b,ll Q){\n//    return (a * b - (ll) ((long double)a * b / Q) * Q) % Q;\n//}\n//#define debug\n//clock_t t1 = clock();\n//fprintf(stderr, \"%ld ms\\n\", clock() - t1);\n\nint m,ans,ge;\nint x[20],y[20],s[20][2];\nbool used[20];\ninline bool check(int i,int j){\n    int p=s[i][0],q=s[i][1],r=s[j][0],t=s[j][1];\n    int sx=x[p]-x[q],sy=y[p]-y[q],ex=x[r]-x[t],ey=y[r]-y[t];\n    return (sx*ey==sy*ex);\n}\nvoid dfs(int dep){\n    if(dep>=m){\n        int cnt=0;\n        for(int i=0;i<ge;i++){\n            for(int j=i+1;j<ge;j++){\n                if(check(i,j))++cnt;\n            }\n        }\n        ans=max(ans,cnt);\n        return;\n    }\n    if(used[dep]){dfs(dep+1);return;}\n    for(int i=dep+1;i<m;i++)if(!used[i]){\n        s[ge][0]=dep,s[ge][1]=i;++ge;\n        used[i]=used[dep]=1;\n        dfs(dep+1);--ge;\n        used[i]=used[dep]=0;\n    }\n}\nint main()\n{\n    read(m);\n    for(int i=0;i<m;i++)read(x[i]),read(y[i]);\n    dfs(0);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n/*\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//construct DAG by dijkstra and then create dominator tree\n#define uu second\ntypedef long long ll;\nconst ll maxN = 100007;\nconst ll inf=1e15;\nstruct DominatorTree {\n    ll par[maxN][25], level[maxN],dis[maxN];\n    ll dis2[maxN];\n    vector<ll>adj[maxN],cost[maxN],mama[maxN] ;\n    vector<ll>adj2[maxN],cost2[maxN] ;\n    vector<pair<ll,ll> >nodes ;\n    void addEdge(int u,int v,int w){\n        adj[u].push_back(v);\n        adj2[v].push_back(u);\n        cost[u].push_back(w);\n        cost2[v].push_back(w);\n    }\n\n    ll lca(ll u,ll v) {\n        if(level[u]< level[v])swap(u,v);\n        ll tmp=1;\n        for(; (1<<tmp)<=level[u]; ++tmp);\n        --tmp;\n        for(ll i=tmp; i>=0; --i) {\n            if(level[u]-(1<<i)>=level[v])u=par[u][i];\n        }\n        if(u==v)return u ;\n        for(ll i = tmp ; i >= 0 ; --i) if(par[u][i]!=par[v][i])u=par[u][i],v=par[v][i] ;\n        return par[u][0];\n    }\n    void dijkstra( ll n, ll src ) {\n        priority_queue< pair < ll, ll > > pq ;\n        pq.push( make_pair( 0, src ) ) ;\n        for( ll i = 0 ; i <= n ; i++ ) dis[i] = inf ;\n        //for( ll i = 0 ; i <= n ; i++ )cout <<i << \" \"<< dis[i] << endl;\n        dis[src] = 0LL ;\n        while( !pq.empty() ) {\n            pair<ll,ll>node = pq.top() ;\n            pq.pop();\n            for( ll i  = 0 ; i < adj[node.uu].size() ; i++  ) {\n                ll v = adj[node.uu][i] ;\n                ll w = cost[node.uu][i] ;\n                if(dis[node.uu]+w<dis[v]) {\n                    dis[v]=dis[node.uu]+w;\n                    pq.push(make_pair(-dis[v], v) );\n                }\n            }\n        }\n        //for( ll i = 0 ; i <= n ; i++ )cout <<i << \" \"<< dis[i] << endl;\n    }\n    void dijkstra2( ll n, ll src ) {\n        priority_queue< pair < ll, ll > > pq ;\n        pq.push( make_pair( 0, src ) ) ;\n        for( ll i = 0 ; i <= n ; i++ ) dis2[i] = inf ;\n        dis2[src] = 0LL ;\n        while( !pq.empty() ) {\n            pair<ll,ll>node = pq.top() ;\n            pq.pop();\n            for( ll i  = 0 ; i < adj2[node.uu].size() ; i++  ) {\n                ll v = adj2[node.uu][i] ;\n                ll w = cost2[node.uu][i] ;\n                if(dis2[node.uu]+w<dis2[v]) {\n                    dis2[v]=dis2[node.uu]+w;\n                    pq.push(make_pair(-dis2[v], v) );\n                }\n            }\n        }\n    }\n    void constructDag(ll n, ll src) {\n        for(ll i =1 ; i <=n; i++)\n            nodes.push_back(make_pair(dis[i],i));\n        sort(nodes.begin(),nodes.end());\n        for(ll i = 0 ; i < n ; i++) {\n            ll u = nodes[i].uu;\n            for(ll j=0; j < adj[u].size() ; j++ ) {\n                ll v = adj[u][j];\n                ll w = cost[u][j];\n                if(dis[v]+w==dis[u])mama[u].push_back(v);\n            }\n        }\n    }\n    void dominatorTree(ll n,ll src=1) {\n        dijkstra(n,1);\n        dijkstra2(n,2);\n        constructDag(n,src);\n        for(ll i = 0; i<20; i++)par[1][i]=1;\n        level[1]=1;\n        n=nodes.size();\n        for(ll i =1; i < n ; i++) {\n            ll u = nodes[i].second ;\n            if(mama[u].size()==0) {\n                continue;\n            }\n            ll sz = mama[u].size();\n            ll jaime = mama[u][0] ;\n            cout << jaime << \" \" << u << endl;\n            ll cur = 1 ;\n            while(cur < sz ) {\n                jaime = lca( jaime, mama[u][cur]) ;\n\n                cout << mama[u][cur] << \" \" << u << endl;\n                cur++;\n            }\n            par[u][0]=jaime;\n            level[u]=1+level[jaime];\n            for( ll i = 1 ; i <20 ; i++ )par[u][i] = par[par[u][i-1]][i-1] ;\n        }\n    }\n};\nll n, m;\nll x[maxN],y[maxN],z[maxN];\nDominatorTree dtree;\nll ans[maxN];\nmap<pair<ll,ll>,ll>id;\nmap<pair<ll,ll>,ll>koyta;\n\nvoid go(ll u){\n    if(u==0)return ;\n    if(u==1)return ;\n    ll p = dtree.par[u][0];\n    cout << p << \" \" << u << endl;\n    if(koyta[{p,u}]==1){\n        ans[id[{p,u}]]=1;\n    }\n    go(p);\n}\nint main(){\n    cin>>n>>m;\n    for(ll i=0;i<m;i++){\n        scanf(\"%lld %lld %lld\",&x[i],&y[i],&z[i]);\n        dtree.addEdge(x[i],y[i],z[i]);\n        koyta[{x[i],y[i]}]++;\n        id[{x[i],y[i]}]=i;\n    }\n    dtree.dominatorTree(n);\n    go(2);\n    for(int i=0;i<m;i++){\n        if(dtree.dis[2]>dtree.dis[y[i]]+dtree.dis2[x[i]]+z[i])\n            ans[i]=-1;\n        if(ans[i]==-1)printf(\"HAPPY\\n\");\n        else if(ans[i]==1)printf(\"SAD\\n\");\n        else printf(\"SOSO\\n\");\n    }\n\n\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nvp pos;\nint n;\nint ans;\n\nll gcd(ll a,ll b)\n{\n    if(a == 0 || b == 0){\n        return max(a,b);\n    }\n    if(a % b == 0){\n        return b;\n    }else{\n        return gcd(b,a%b);\n    }\n}\n\nP trans(int i,int j)\n{\n    int nx = abs(pos[i].fi-pos[j].fi);\n    int ny = abs(pos[i].se-pos[j].se);\n    int g = gcd(nx,ny);\n    return P(nx/g,ny/g);\n}\n\nvoid dfs(int u,int used,int par,vp& kp)\n{\n    if(par == n/2){\n        map<P,int> mp;\n        rep(i,len(kp)){\n            mp[kp[i]]++;\n        }\n        int cri = 0;\n        each(it,mp){\n            if(it.se >= 2){\n                cri += it.se*(it.se-1)/2;\n            }\n        }\n        cmx(ans,cri);\n        return;\n    }\n    if((used >> u) & 1){\n        dfs(u+1,used,par,kp);\n    }else{\n        srep(i,u+1,n){\n            if(!((used >> i) & 1)){\n                kp.push_back(trans(u,i));\n                used ^= (1 << i);\n                dfs(u+1,used,par+1,kp);\n                used ^= (1 << i);\n                kp.pop_back();\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    pos.resize(n);\n    rep(i,n){\n        int u,v;\n        cin >> u >> v;\n        pos[i] = P(u,v);\n    }\n    vector<P> kp;\n    ans = 0;\n    dfs(0,0,0,kp);\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\n#define rep(i, n) for (long long i = (long long)(0); i < (long long)(n); ++i)\n#define reps(i, n) for (long long i = (long long)(1); i <= (long long)(n); ++i)\n#define rrep(i, n) for (long long i = ((long long)(n)-1); i >= 0; i--)\n#define rreps(i, n) for (long long i = ((long long)(n)); i > 0; i--)\n#define irep(i, m, n) for (long long i = (long long)(m); i < (long long)(n); ++i)\n#define ireps(i, m, n) for (long long i = (long long)(m); i <= (long long)(n); ++i)\n#define SORT(v, n) sort(v, v + n);\n#define REVERSE(v, n) reverse(v, v+n);\n#define vsort(v) sort(v.begin(), v.end());\n#define all(v) v.begin(), v.end()\n#define mp(n, m) make_pair(n, m);\n#define cout(d) cout<<d<<endl;\n#define coutd(d) cout<<std::setprecision(10)<<d<<endl;\n#define cinline(n) getline(cin,n);\n#define replace_all(s, b, a) replace(s.begin(),s.end(), b, a);\n#define PI (acos(-1))\n#define FILL(v, n, x) fill(v, v + n, x);\n#define sz(x) long long(x.size())\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vs = vector<string>;\nusing vpll = vector<pair<ll, ll>>;\nusing vtp = vector<tuple<ll,ll,ll>>;\nusing vb = vector<bool>;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst ll INF = 1e9;\nconst ll MOD = 1e9+7;\nconst ll LINF = 1e18;\n\n// https://www.hamayanhamayan.com/entry/2017/12/18/181730\n\nconst ll maxn=1<<16;\nll dp1[maxn];           // sの時、全ての線分を平行にできるか\nset<pll> dp2[maxn];     // sの時、全ての線分が平行な状態の時の傾きの集合\nll dp3[maxn];           // sの時、平行な線分の組数の最大\n\n// dp1[s]は以下の様に求める\n// sから2点を取り除いた集合をnmaskとする\n// dp1[nmask]==1 かつ 取り除いた2点の傾きが、dp2[nmask]に含まれるならば、dp1[s]=1となり、dp2[s]にはその傾きが含まれる\n// よって、dp1を更新するためには、以下の初期化を行う\n// dp1は全ての2点の組合せに対して、1にしておく(...011=3, ...101=5 など)\n// dp2も同様に全ての2点の組合せに対して、傾きを求めておく\n\nll bitcount(ll x){\n  if(x==0) return 0;\n  return bitcount(x>>1)+(x&1);\n}\n\nsigned main()\n{\n  cin.tie( 0 ); ios::sync_with_stdio( false );\n  \n  ll m; cin>>m;\n  vpll p(m);\n  rep(i,m){\n    ll x,y; cin>>x>>y;\n    p[i]={x,y};\n  }\n  \n  dp1[0]=1;\n  rep(i,m) irep(j,i+1,m){\n    ll s=(1<<i)|(1<<j);\n    ll x=p[i].first-p[j].first, y=p[i].second-p[j].second;\n    dp1[s]=1;\n    dp2[s].insert({x,y});\n  }\n  \n  irep(s,1,1<<m){\n    if(bitcount(s)%2!=0) continue;\n    rep(i,m) if(s>>i&1) irep(j,i+1,m) if(s>>j&1){\n      ll nmask=s^(1<<i)^(1<<j);\n      if(!dp1[nmask]) continue;\n      \n      ll x=p[i].first-p[j].first, y=p[i].second-p[j].second;\n      for(auto e: dp2[nmask]){\n        if(e.first*y==e.second*x){\n          dp1[s]=1;\n          dp2[s].insert(e);\n        }\n      }\n    }\n  }\n  \n  rep(s,1<<m) if(dp1[s]){\n    ll cnt=bitcount(s)/2;\n    dp3[s]=cnt*(cnt-1)/2;\n  }\n  \n  rep(s,1<<m){\n    for(ll sub=s; sub>=0; sub--){\n      sub&=s;\n      chmax(dp3[s],dp3[s-sub]+dp3[sub]);\n    }\n  }\n  \n  // rep(s,1<<m) cout<<dp1[s]<<endl;\n  // rep(s,1<<m) cout<<dp3[s]<<endl;\n  \n  cout<<dp3[(1<<m)-1]<<endl;\n  \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#if __has_include(\"../library/Basic/Debug.hpp\")\n\n#include \"../library/Basic/Debug.hpp\"\n\n#else\n\n/* ----- Header Files ----- */\n// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <cstdint>\n\n\n/* ----- Type Alias ----- */\nusing Bool = bool;\nusing Int = long long int;\nusing Real = long double;\nusing Char = char;\nusing String = std::string;\ntemplate <class... Ts>\nusing Tuple = std::tuple<Ts...>;\n\ntemplate <class T>\nusing Vector = std::vector<T>;\ntemplate <class T>\nusing Matrix = Vector<Vector<T>>;\ntemplate <class T>\nusing Queue = std::queue<T>;\ntemplate <class T>\nusing Stack = std::stack<T>;\ntemplate <class T>\nusing Deque = std::deque<T>;\n\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T>\nusing Set = std::set<T>;\ntemplate <class T, class U>\nusing Map = std::map<T, U>;\n\ntemplate <class T, class... Us>\nusing Func = std::function<T(Us...)>;\n\ntemplate <class T>\nT genv(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto genv(size_t l, Ts... ts) {\n    return Vector<decltype(genv<T>(ts...))>(l, genv<T>(ts...));\n}\n\ntemplate <class Cost = Int>\nstruct Edge {\n    Int src, dst;\n    Cost cost;\n    Edge(Int src = -1, Int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = Int>\nusing Edges = Vector<Edge<Cost>>;\ntemplate <class Cost = Int>\nusing Graph = Vector<Vector<Edge<Cost>>>;\n\n#endif\n\n/* ----- Misc ----- */\nvoid fastio() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n}\n\nstruct Fout {\n    Int precision;\n    Fout(Int precision) : precision(precision) {}\n};\nstd::ostream& operator<<(std::ostream& os, const Fout& fio) {\n    os << std::fixed << std::setprecision(fio.precision);\n    return os;\n}\n\n\n/* ----- Constants ----- */\n// constexpr Int INF = std::numeric_limits<Int>::max() / 3;\n// constexpr Int MOD = 1000000007;\n// constexpr Real PI = acos(-1);\n// constexpr Real EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nint main() {\n    Int n;\n    std::cin >> n;\n\n    Vector<Int> x(n), y(n);\n    for (Int i = 0; i < n; ++i) {\n        std::cin >> x[i] >> y[i];\n    }\n\n    Func<Int, Int, Vector<Int>&> dfs =\n        [&](Int b, Vector<Int>& ps) {\n            Int ret = 0;\n\n            if (__builtin_popcountll(b) == n) {\n                Vector<Int> dx(n / 2), dy(n / 2);\n                for (Int i = 0; i < n / 2; ++i) {\n                    dx[i] = x[ps[i * 2]] - x[ps[i * 2 + 1]];\n                    dy[i] = y[ps[i * 2]] - y[ps[i * 2 + 1]];\n                }\n\n                for (Int i = 0; i < n / 2; ++i) {\n                    for (Int j = 0; j < i; ++j) {\n                        if (dx[i] * dy[j] == dy[i] * dx[j]) ++ret;\n                    }\n                }\n            } else {\n                Int i;\n                for (i = 0; (b >> i) & 1; ++i) {}\n                for (Int j = i + 1; j < n; ++j) {\n                    if ((b >> j) & 1) continue;\n                    ps.push_back(i);\n                    ps.push_back(j);\n\n                    ret = std::max(ret, dfs(b + (1 << i) + (1 << j), ps));\n\n                    ps.pop_back();\n                    ps.pop_back();\n                }\n            }\n            return ret;\n        };\n\n    Vector<Int> p;\n    std::cout << dfs(0, p) << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nvector<pair<int, int>> inputs;\n\nmap<pair<int, int>, int> cnt;\nint sol(int now,int itr) {\n\tfor (int i = itr; i < inputs.size(); ++i) {\n\t\tif ((1 << i) & now) continue;\n\t\tint ans = 0;\n\t\tfor (int q = i + 1; q < inputs.size(); ++q) {\n\t\t\tif ((1 << q) & now) continue;\n\t\t\tpair<int, int> next = mp(inputs[q].first - inputs[i].first, inputs[q].second - inputs[i].second);\n\t\t\tint hoge = gcd(next.first, llabs(next.second));\n\t\t\tnext.first /= hoge;\n\t\t\tnext.second /= hoge;\n\t\t\tcnt[next]++;\n\t\t\tans = max(ans, sol(now + (1 << i) + (1 << q), i + 1));\n\t\t\tcnt[next]--;\n\t\t}\n\t\treturn ans;\n\t}\n\t//solution\n\tint ans = 0;\n\tfor (auto x : cnt) {\n\t\tans += x.second * (x.second - 1) / 2;\n\t}\n\treturn ans;\n}\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tREP(i, n) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tinputs.push_back(mp(a, b));\n\t}\n\tsort(ALL(inputs));\n\tcout << sol(0, 0) << endl;\n}\n\n#undef int\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//make_tuple emplace_back next_permutation push_back make_pair second first setprecision\n\n#if MYDEBUG\n#include \"lib/cp_debug.h\"\n#else\n#define DBG(...) ;\n#endif\n\nusing LL = long long;\nconstexpr LL LINF=334ll<<53;\nconstexpr int INF=15<<26;\nconstexpr LL  MOD=1E9+7;\n\nstruct Problem{\n    int n,ans,loop;\n    vector<pair<int,int>> p;\n    Problem(LL n):n(n),p(n){};\n\n    void dfs(int mask, multiset<pair<int,int>> slopes){\n        int s = 0;\n        for(int i=0; i<n; ++i){\n            if(((mask>>i)&1) ==0){\n                s=i;\n                break;\n            }\n            if(i==n-1){\n                assert(slopes.size()==n/2);\n                //DBG(slopes)\n                auto it = slopes.begin();\n                vector<int> c;\n                int tmp=0;\n                for(;it!=slopes.end();++it){\n                    c.push_back(slopes.count(*it));\n                }\n                assert(c.size()==n/2);\n                for(int i=0; i<(int)c.size(); ++i){\n                    tmp+=c[i]*(c[i]-1)/2;\n                    i+=c[i]-1;\n                }\n                ans=max(ans,tmp);\n                loop++;\n                return;\n            }\n        }\n        pair<int,int> p1 ,p2;\n\n        for(int i=s+1; i<n; ++i){\n            p1=p[s];\n            if((mask>>i)&1)continue;\n            p2=p[i];\n            if(p1.first>p2.first)swap(p1,p2);\n            pair<int,int>slope;\n            if(p1.first==p2.first)slope={0,1};\n            else if (p1.second==p2.second)slope={1,0};\n            else{\n                int dy=p2.second-p1.second;\n                int dx=p2.first-p1.first;\n                int g=__gcd(dx,dy);\n                slope={dx/g,dy/g};\n            }\n            slopes.insert(slope);\n            dfs((mask|(1<<i))|(1<<s),slopes);\n            slopes.erase(slopes.lower_bound(slope));\n            //slopes.erase(slope);\n        }\n    }\n    void solve(){\n        ans=0;loop=0;\n        for(int i=0; i<n; ++i){\n            cin >> p[i].first >> p[i].second;\n        }\n        dfs(0,{});\n        cout << ans <<\"\\n\";\n        DBG(loop)\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    long long n=0;\n    cin >> n;\n    Problem p(n);\n    p.solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\nstruct Node\n{\n    double x,y;\n} node[20];\nint n;\nlong long ans;\nint vis[20];\nstruct Line\n{\n\n    int idx1,idx2;\n} L[20];\nbool check(Line x,Line y)\n{\n    int a=x.idx1;\n    int b=x.idx2;\n    int c=y.idx1;\n    int d=y.idx2;\n    double xx=(node[a].y-node[b].y)*(node[c].x-node[d].x);\n    double yy=(node[c].y-node[d].y)*(node[a].x-node[b].x);\n    if(xx==yy) return true;\n    return false;\n}\nvoid  CH()\n{\n    long long  sum=0;\n    for(int i=1; i<=n/2; i++)\n    {\n\n        for(int j=i+1; j<=n/2; j++)\n        {\n            if(check(L[i],L[j])) sum++;\n        }\n    }\n    ans=max(ans,sum);\n}\nint f(int cnt)\n{\n    long long  sum=0;\n    for(int i=1;i<=cnt;i++)\n    {\n        for(int j=i+1;j<=cnt;j++)\n        {\n            if(check(L[i],L[j])) sum++;\n        }\n    }\n    int t=n-cnt*2;\n    t=t/2;\n    sum=sum+t*cnt;\n}\nvoid dfs(int x,int cnt)\n{\n   // cout<<x<<\" \"<<cnt<<endl;\n    vis[x]=cnt;\n    for(int i=0; i<n; i++)\n    {\n        if(!vis[i]&&i>x)\n        {\n            vis[i]=cnt;\n            L[cnt].idx1=x;\n            L[cnt].idx2=i;\n//               if(cnt>1)\n//               {\n//                int ss=f(cnt);\n//\n//                if(ss<=ans) continue;\n//               }\n\n            if(cnt==n/2)\n            {\n                CH();\n            }\n            for(int i=0; i<n; i++)\n            {\n                if(!vis[i])\n                {\n                    dfs(i,cnt+1);\n                }\n            }\n            vis[i]=0;\n        }\n    }\n    vis[x]=0;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=0; i<n; i++)\n        scanf(\"%lf%lf\",&node[i].x,&node[i].y);\n    ans=0;\n    memset(vis,0,sizeof(vis));\n    dfs(0,1);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,ans;\nint r;\nstruct P\n{\n    int x,y;\n    int z;\n    bool operator<(const P &a)const\n    {\n        if(x!=a.x) return x<a.x;\n        else return y<a.y;\n    }\n} p[20],Ge[20],nn[20];\n\nvector<P> G[20];\nint vis[20];\n\nvoid DFS(int pre,int id,int num)\n{\n    vis[id]=1;\n    if(num==n/2)\n    {\n        for(int i=0; i<r; i++)\n            nn[i]=Ge[i];\n        sort(nn,nn+r);\n        int X=nn[0].x;\n        int Y=nn[0].y;\n        int sum=1;\n        int temp=0;\n        for(int i=1; i<r; i++)\n        {\n            if(nn[i].x!=X || nn[i].y!=Y)\n            {\n                X=nn[i].x;\n                Y=nn[i].y;\n                temp+=(sum*(sum-1)/2);\n                sum=1;\n            }\n            else sum++;\n        }\n        temp+=(sum*(sum-1)/2);\n        ans=max(ans,temp);\n        return ;\n    }\n    for(int i=pre+1; i<=n; i++)\n    {\n        if(!vis[i])\n        {\n            vis[i]=1;\n            for(int j=0; j<G[i].size(); j++)\n            {\n                int u=G[i][j].z;\n                if(!vis[u])\n                {\n                    Ge[r]=G[i][j];\n                    r++;\n                    DFS(i,u,num+1);\n                    vis[u]=0;\n                    r--;\n                }\n            }\n            vis[i]=0;\n            break ;\n        }\n    }\n}\n\nint main()\n{\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        for(int i=0;i<=n;i++) G[i].clear();\n        memset(vis,0,sizeof(vis));\n        r=ans=0;\n        for(int i=1; i<=n; i++)\n            scanf(\"%d%d\",&p[i].x,&p[i].y);\n        for(int i=1; i<=n; i++)\n        {\n            for(int j=i+1; j<=n; j++)\n            {\n                P node;\n                node.x=p[i].x-p[j].x;\n                node.y=p[i].y-p[j].y;\n                if(node.x<0 && node.y<0)\n                {\n                    node.x=-node.x;\n                    node.y=-node.y;\n\n                }\n                else if(node.x*node.y<0 || (node.x<0 && node.y==0) || (node.x==0 && node.y<0))\n                {\n                    node.x=abs(node.x);\n                    node.y=abs(node.y);\n                    node.x*=-1;\n                }\n                if(node.x==0) node.y=1;\n                else if(node.x!=0 && node.y!=0)\n                {\n                    int c=__gcd(abs(node.x),abs(node.y));\n                    node.x/=c;\n                    node.y/=c;\n                }\n                else if(node.y==0) node.x=1;\n                node.z=j;\n                G[i].push_back(node);\n            }\n        }\n        vis[1]=1;\n        for(int i=0; i<G[1].size(); i++)\n        {\n            Ge[r]=G[1][i];\n            r++;\n            int u=G[1][i].z;\n            DFS(1,u,1);\n            vis[u]=0;\n            r--;\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <cstdlib>\n\nusing namespace std;\n\nstruct Pos {\n  int x, y;\n};\n\nint N;\nPos p[16];\nvector<vector<int>> g;\n\nint gcd(int x, int y) {\n  if (y == 0) return x;\n  return gcd(y, x%y);\n}\n\npair<int, int> grad(const Pos&a, const Pos& b) {\n  int x = a.x - b.x;\n  int y = a.y - b.y;\n  int neg = x*y < 0 ? -1 : 1;\n  int g = gcd(abs(x), abs(y));\n  return make_pair((abs(x)/g), (abs(y)/g)*neg);\n}\n\nint cache[32][32][32][1<<16];\n\nint Solve(int i, int j, int c, int used) {\n  if (i == g.size()) return 0;\n  if (cache[i][j][c][used] >= 0) return cache[i][j][c][used];\n  if (j == g[i].size()) return Solve(i+1, 0, 0, used) + c * (c-1) / 2;\n  int a = Solve(i, j+1, c, used);\n  if ((used & g[i][j]) == 0) {\n    a = max(a, Solve(i, j+1, c+1, used | g[i][j]));\n  }\n  return cache[i][j][c][used] = a;\n}\n\nint main() {\n  while (cin >> N) {\n    memset(cache, -1, sizeof(cache));\n    for (int i = 0; i < N; ++i) {\n      cin >> p[i].x >> p[i].y;\n    }\n    map<pair<int, int>, vector<int>> cnt;\n    for (int i = 0; i < N; ++i) {\n      for (int j = i+1; j < N; ++j) {\n\tcnt[grad(p[i], p[j])].push_back((1<<i) | (1<<j));\n      }\n    }\n    g.clear();\n    for (const auto& kv : cnt) {\n      auto& c = kv.second;\n      if (c.size() > 1)\n\tg.push_back(c);\n    }\n    sort(g.begin(), g.end(), [](const auto& a, const auto& b){ return a.size() > b.size();});\n    cout << Solve(0, 0, 0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <list>\n#include <cstdlib>\n#include <memory>\n#include <cstring>\n#include <sstream>\n#include <list>\n#include <deque>\n#include <bitset>\n#include <vector>\n\nusing namespace std;\n\n#define INF 0x3f3f3f3f\n#define PI 3.141592653579\n#define FRER() freopen(\"input.txt\" , \"r\" , stdin);\n#define FREW()  freopen(\"output.txt\" , \"w\" , stdout);\n#define  QIO std::ios::sync_with_stdio(false)\n#define mem(a , b) memset(a , b , sizeof(a))\nconst double eps = 1e-8;\ntypedef long long ll;\nconst int maxn = 30;\nint cnt, n;\nll ans;\n\nstruct Point\n{\n    int x, y;\n    int cur;\n}point[maxn];\n\nstruct Vec\n{\n    Point p[2]; //起始点和终点\n    int hav;\n} vec[maxn*maxn];\n\nint gcd(int a, int b)\n{\n    return b==0?a:gcd(b, a%b);\n}\n\nint _hash(Point a, Point b)\n{\n    int x=a.x-b.x;\n    int y=a.y-b.y;\n    if(x<0) {\n        x = -x;\n        y = -y;\n    }\n    int gc=gcd(abs(x), abs(y));\n    x=x/gc;\n    y=y/gc+2000;\n    return x * 10000 + y;\n}\n\nmap<int, int> m;\nbool vis[maxn*maxn];\nbool visp[maxn];\nset<int> st;   // 在一个集合的所有点的idx\n\nvoid dfs(int cur)\n{\n//    cout << \"nnn\" <<  n << endl;\n//    cout << \"==========\" << endl;\n//    cout << cur << n/2 << endl;\n    if(cur==n/2) {\n//        cout << \"===fsgdgsdg=======\" << endl;\n        ll sum=0;\n        for(map<int, int>::iterator it = m.begin(); it != m.end(); it++)\n        {\n            sum+=(it->second)*(it->second-1)/2;\n        }\n        ans=max(ans, sum);\n        return;\n    }\n    for(int i=0; i<cnt;i++)\n    {\n        if(!vis[i]&&!visp[vec[i].p[0].cur]&&!visp[vec[i].p[1].cur]) {\n            vis[i]=true;\n            visp[vec[i].p[0].cur]=true;\n            visp[vec[i].p[1].cur] = true;\n            m[vec[i].hav]++;\n            dfs(cur+1);\n            visp[vec[i].p[0].cur]=false;\n            visp[vec[i].p[1].cur] =false;\n            m[vec[i].hav]--;\n            vis[i]=false;\n        }\n    }\n}\n\nint main()\n{\n//    FRER();\n\n    scanf(\"%d\" , &n);\n    for(int i = 0 ; i < n ; i++)\n    {\n        scanf(\"%d%d\", &point[i].x, &point[i].y);\n        point[i].cur=i;\n    }\n    cnt=0;\n    for(int i = 0 ; i < n ; i++)\n    {\n        for(int j = i+1 ; j < n ; j++)\n        {\n                vec[cnt].hav = _hash(point[i], point[j]);\n                vec[cnt].p[0] = point[i];\n                vec[cnt].p[1] = point[j];\n                cnt++;\n        }\n    }\n//    cout <<n <<\"fsafsadfas\" << endl;\n    ans=-134566;\n    memset(vis, false, sizeof(vis));\n    memset(visp, false, sizeof(visp));\n    dfs(0);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <cstdlib>\n\nusing namespace std;\n\nstruct Pos {\n  int x, y;\n};\n\nint N;\nPos p[16];\nvector<vector<int>> g;\n\nint gcd(int x, int y) {\n  if (y == 0) return x;\n  return gcd(y, x%y);\n}\n\npair<int, int> grad(const Pos&a, const Pos& b) {\n  int x = a.x - b.x;\n  int y = a.y - b.y;\n  int neg = x*y < 0 ? -1 : 1;\n  int g = gcd(abs(x), abs(y));\n  return make_pair((abs(x)/g), (abs(y)/g)*neg);\n}\n\nlong long Solve(int i, int used) {\n  if (i == g.size()) return 0;\n  long long a = Solve(i+1, used);\n  long long c = 0;\n  for (int v : g[i]) {\n    if ((used & v) == 0) {\n      ++c;\n      used |= v;\n    }\n  }\n  long long r = c * (c-1) / 2 + Solve(i+1, used);\n  return max(a, r);\n}\n\nint main() {\n  while (cin >> N) {\n    for (int i = 0; i < N; ++i) {\n      cin >> p[i].x >> p[i].y;\n    }\n    map<pair<int, int>, vector<int>> cnt;\n    for (int i = 0; i < N; ++i) {\n      for (int j = i+1; j < N; ++j) {\n\tcnt[grad(p[i], p[j])].push_back((1<<i) | (1<<j));\n      }\n    }\n    g.clear();\n    for (const auto& kv : cnt) {\n      auto& c = kv.second;\n      if (c.size() > 1)\n\tg.push_back(c);\n    }\n    cout << Solve(0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nconst double eps=1e-7;\n\nstruct Vector\n{\n\tint x,y;\n\tVector(){};\n\tVector(int x,int y):x(x),y(y){};\n\tvoid read()\n\t{\n\t\tscanf(\"%d %d\",&this->x,&this->y);\n\t\treturn;\n\t}\n};\n\ninline Vector operator + (const Vector &fi,const Vector &se)\n{\n\treturn Vector(fi.x+se.x,fi.y+se.y);\n}\n\ninline Vector operator - (const Vector &fi,const Vector &se)\n{\n\treturn Vector(fi.x-se.x,fi.y-se.y);\n}\n\ninline int operator ^ (const Vector &fi,const Vector &se)\n{\n\treturn fi.x*se.y-fi.y*se.x;\n}\n\ntypedef Vector Point;\n\nint n;\nPoint p[20];\nbool use[20];\n\nVector e[20];\nint cnt=0;\nint ans=0;\n\n\nvoid dfs(int w)\n{\n\tif(w>n)\n\t{\n\t\tint nowans=0;\n\t\tfor(int i=1;i<=cnt;i++)\n\t\t{\n\t\t\tfor(int j=i+1;j<=cnt;j++)\n\t\t\t{\n\t\t\t\tif((e[i]^e[j])==0)\n\t\t\t\t{\n\t\t\t\t\tnowans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(nowans>ans)\n\t\t\tans=nowans;\n\t\treturn;\n\t}\n\tif(use[w])\n\t{\n\t\tdfs(w+1);\n\t\treturn;\n\t}\n\tuse[w]=1;\n\tfor(int i=w+1;i<=n;i++)\n\t{\n\t\tif(!use[i])\n\t\t{\n\t\t\tuse[i]=1;\n\t\t\tcnt++;\n\t\t\te[cnt]=p[i]-p[w];\n\t\t\tdfs(w+1);\n\t\t\tcnt--;\n\t\t\tuse[i]=0;\n\t\t}\n\t}\n\tuse[w]=0;\n}\n\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tp[i].read();\n\t}\n\tdfs(1);\n\tprintf(\"%d\\n\",ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 16;\nint x[N], y[N], n;\nlong long ans;\nint chk[N];\nvector<int> a[N];\nmap<pair<int, int>, int> M;\n\nvoid dfs(int step) {\n\tif (step == n / 2) {\n\t\tlong long rlt = 0;\n\t\tfor (int i = 0; i < N / 2; i++) a[i].clear();\n\t\tfor (int i = 0; i < n; i++) a[chk[i]].push_back(i);\n\t\tM.clear();\n\t\tfor (int i = 0; i < n / 2 + 1; i++) if (a[i].size() == 2) {\n\t\t\tint dx = abs(x[a[i][0]] - x[a[i][1]]);\n\t\t\tint dy = (y[a[i][0]] - y[a[i][1]]) * ((x[a[i][0]] - x[a[i][1]] < 0) ? -1 : 1);\n\t\t\tint gcd = __gcd(dx, dy);\n\t\t\tdx /= gcd, dy /= gcd;\n\t\t\tM[make_pair(dx, dy)]++;\n\t\t}\n\t\tfor (map<pair<int, int>, int> :: iterator it = M.begin(); it != M.end(); it++) rlt += 1LL * it->second * (it->second - 1) / 2;\n\t\tans = max(ans, rlt);\n\t\treturn;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (chk[i] != -1) continue;\n\t\tchk[i] = step;\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (chk[j] != -1) continue;\n\t\t\tchk[j] = step;\n\t\t\tdfs(step + 1);\n\t\t\tchk[j] = -1;\n\t\t}\n\t\tchk[i] = -1;\n\t\tbreak;\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tmemset(chk, -1, sizeof chk);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\t\n\tdfs(0);\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\nint one_hot(int x) { return 1 << x; }\n\npii calc_arg(int dx, int dy) {\n    if(dx < 0) {\n        dx *= -1;\n        dy *= -1;\n    }\n    int g = __gcd(abs(dx), abs(dy));\n    dx /= g;\n    dy /= g;\n    if(dx == 0) dy = 1;\n    else if(dy == 0) dx = 1;\n    return make_pair(dx, dy);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N; cin >> N;\n    vector<int> X(N), Y(N);\n    rep(i, N) cin >> X[i] >> Y[i];\n    int ans = 0;\n    function<void(int, map<pii, int>&)> dfs = [&] (int used, map<pii, int> &args) {\n        if(__builtin_popcount(used) == N) {\n            int acc = accumulate(begin(args), end(args), 0, [] (int sum, auto &p) {\n                    return sum + p.second * (p.second - 1) / 2;\n                });\n            set_max(ans, acc);\n            return;\n        }\n        int now = -1;\n        rep(i, N) if(not(used & one_hot(i))) {\n            now = i;\n            break;\n        }\n        assert(now >= 0);\n        used |= one_hot(now);\n        rep(i, N) {\n            if(not (used & one_hot(i))) {\n                pii arg = calc_arg(X[now] - X[i], Y[now] - Y[i]);\n                args[arg]++;\n                dfs(used | one_hot(i), args);\n                if(--args[arg] == 0) args.erase(arg);\n            }\n        }\n    };\n    map<pii, int> args;\n    dfs(0, args);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, j, n) for (int i = (j); i < (int)(n); i++)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\nusing P = pair<int, int>;\nusing ll = long long;\n\nstruct Point {\n  int x, y;\n  Point(int _x = 0, int _y = 0) : x(_x), y(_y) {}\n  friend istream& operator>>(istream& input, Point& p) {\n    return input >> p.x >> p.y, input;\n  }\n  friend ostream& operator<<(ostream& output, const Point& p) {\n    return output << '(' << p.x << ',' << p.y << ')';\n  }\n};\n\nint m;\nvector<Point> ps;\nll ans = 0;\n\nvoid solve(vector<P> pairs) {\n  // for (auto pr : pairs) cerr << '(' << pr.first << ',' << pr.second << ')' << ' ';\n  // cerr << endl;\n  map<P, ll> mp;\n  for (auto pr : pairs) {\n    int x = ps[pr.first].x - ps[pr.second].x;\n    int y = ps[pr.first].y - ps[pr.second].y;\n    int div = __gcd(abs(x), abs(y));\n    if (y < 0) x = -x, y = -y;\n    if (y == 0) x = abs(x);\n    mp[P(x / div, y / div)]++;\n    // cerr << '(' << x / div << ',' << y / div << ')' << ' ';\n  }\n  // cerr << endl;\n  ll tmp = 0;\n  for (auto v : mp) tmp += v.second * (v.second - 1) / 2;\n  ans = max(ans, tmp);\n}\n\nvoid dfs(vector<P> pairs, vector<bool> used, int n) {\n  if (n == 0) return solve(pairs);\n  P pr;\n  REP(i, m) {\n    if (used[i]) continue;\n    used[i] = true;\n    pr.first = i;\n    break;\n  }\n  REP(i, m) {\n    if (used[i]) continue;\n    used[i] = true;\n    pr.second = i;\n    pairs.push_back(pr);\n    dfs(pairs, used, n - 2);\n    used[i] = false;\n    pairs.pop_back();\n  }\n}\n\nint main() {\n  cin >> m;\n  ps.resize(m);\n  REP(i, m) cin >> ps[i];\n  vector<P> pairs;\n  vector<bool> used(m, false);\n  dfs(pairs, used, m);\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt dp[16][16][10][1<<16];\ntemplate<typename T>\nvoid chmax(T &a,T b){\n  if(a<b) a=b;\n}\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n;\n  cin>>n;\n  using P = pair<Int, Int>;\n  vector<P> v;\n  for(Int i=0;i<n;i++){\n    Int x,y;\n    cin>>x>>y;\n    v.emplace_back(x,y);\n  }\n  vector<vector<P> > r(n,vector<P>(n)); \n  for(Int i=0;i<n;i++){\n    for(Int j=i+1;j<n;j++){\n      if(v[i].first==v[j].first){\n\tr[i][j]=P(0,1);\n\tcontinue;\n      }\n      if(v[i].second==v[j].second){\n\tr[i][j]=P(1,0);\n\tcontinue;\n      }\n      Int dx=v[i].first-v[j].first;\n       Int dy=v[i].second-v[j].second;\n       if(dx<0){\n\t dx*=-1;\n\t dy*=-1;\n       }\n       Int k=__gcd(dx,abs(dy));\n       dx/=k;dy/=k;\n       r[i][j]=P(dx,dy);\n       //cout<<i<<\" \"<<j<<\":\"<<dx<<\" \"<<dy<<endl;\n     }\n   }\n  memset(dp,-1,sizeof(dp));\n  //dp[0][0][0][0]=0;\n  for(Int i=0;i<n;i++){\n    for(Int j=i+1;j<n;j++){\n      dp[i][j][1][(1<<i)|(1<<j)]=0;\n    }\n  }\n  Int ans=0;\n  for(Int b=0;b<(1<<n);b++){\n    for(Int i=0;i<n;i++){\n      for(Int j=i+1;j<n;j++){\n\tfor(Int k=0;k<=n/2;k++){\n\t  if(dp[i][j][k][b]<0) continue;\n\t  //cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<b<<\":\"<<dp[i][j][k][b]<<endl;\n\t  for(Int s=0;s<n;s++){\n\t    for(Int t=s+1;t<n;t++){\n\t      if((b>>s)&1) continue;\n\t      if((b>>t)&1) continue;\n\t      Int nb=b|(1<<s)|(1<<t);\n\t      if(r[i][j]==r[s][t]){\n\t\tchmax(dp[s][t][k+1][nb],dp[i][j][k][b]+k);\n\t\tchmax(ans,dp[s][t][k+1][nb]);\n\t      }else{\n\t\tchmax(dp[s][t][1][nb],dp[i][j][k][b]);\n\t\tchmax(ans,dp[s][t][1][nb]);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n  }  \n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing Number = double;\nconst Number EPS = 1e-10;\n\ninline int sign(Number x) { return (x < -EPS) ? -1 : (x > EPS) ? +1 : 0; }\ninline bool equal(Number a, Number b) { return sign(a - b) == 0; }\n\nclass Point {\npublic:\n    Number x, y;\n\n    Point() {}\n    Point(Number x, Number y) : x(x), y(y) {}\n\n    Point operator+(const Point &rhs) const {\n        return Point(this->x + rhs.x, this->y + rhs.y);\n    }\n    Point operator-(const Point &rhs) const {\n        return Point(this->x - rhs.x, this->y - rhs.y);\n    }\n};\n\ninline Number abs_cross(const Point &p1, const Point &p2) {\n    return p1.x * p2.y - p1.y * p2.x;\n}\n\nclass Line : public std::array<Point, 2> {\npublic:\n    Line() {}\n    Line(const Point &p1, const Point &p2) {\n        (*this)[0] = p1;\n        (*this)[1] = p2;\n    }\n};\ninline bool IsParallel(const Line &l1, const Line &l2) {\n    return equal(abs_cross(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\n\nint Search(const int i, const int m, vector<int> &idx, const vector<Point> &p) {\n    if (i == m - 2) {\n        int sum = 0;\n        vector<bool> check(m / 2, false);\n\n        for (int j = 0; 2 * j < m; ++j) {\n            if (check[j]) continue;\n\n            check[j] = true;\n            int num = 1;\n            Line l(p[idx[2 * j]], p[idx[2 * j + 1]]);\n            for (int k = j + 1; 2 * k < m; ++k)\n                if (IsParallel(l, Line(p[idx[2 * k]], p[idx[2 * k + 1]]))) {\n                    ++num;\n                    check[k] = true;\n                }\n            sum += num * (num - 1) / 2;\n        }\n        return sum;\n    }\n\n    int res = 0;\n    if (i % 2 == 0) {\n        int min_idx = distance(idx.begin(), min_element(idx.begin() + i, idx.end()));\n        swap(idx[i], idx[min_idx]);\n        res=  Search(i + 1, m, idx, p);\n        swap(idx[i], idx[min_idx]);\n    }\n    else {\n        for (int j = i; j < m; ++j) {\n            swap(idx[i], idx[j]);\n            res = max(res, Search(i + 1, m, idx, p));\n            swap(idx[i], idx[j]);\n        }\n    }\n\n    return res;\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    int m;\n\n    cin >> m;\n    vector<Point> p(m);\n    for (auto &pp : p) cin >> pp.x >> pp.y;\n\n    vector<int> idx(m);\n    iota(idx.begin(), idx.end(), 0);\n\n    cout << Search(1, m, idx, p) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int maxn = 400;\nstruct Point{\n   int x,y;\n   Point (int x=0, int y=0):x(x),y(y){}\n};\nPoint p[maxn];\nint n;\n\nstruct node{\n   int x,y;\n   node (int x=0, int y=0):x(x),y(y){}\n   bool operator <(const node& rhs) const {\n      if (x!=rhs.x) return x<rhs.x;\n      return y<rhs.y;\n   }\n   bool operator ==(const node &rhs) const {\n      return x==rhs.x && y==rhs.y;\n   }\n}e[maxn];\n\nmap<node,int>mp;\nint tot;\n\nint gcd(int x, int y) {return y==0?x:gcd(y,x%y); }\n\nint main(){\n    int x,y;\n    //freopen(\"1.txt\",\"r\",stdin);\n    while (scanf(\"%d\",&n)==1) {\n         for (int i=1; i<=n; i++) {\n            scanf(\"%d%d\",&x,&y);\n            p[i] = Point(x,y);\n         }\n\n         tot = 0;\n         mp.clear();\n         node u;\n         int tx,ty,g;\n         for (int i=1; i<=n; i++) {\n            for (int j=i+1; j<=n; j++) {\n                x = p[i].x-p[j].x;\n                y = p[i].y-p[j].y;\n\n                tx = abs(x);\n                ty = abs(y);\n                g = gcd(tx,ty);\n                x /= g; y /= g;\n\n                if (x<0 && y<0) {x=-x; y=-y; }\n                else if (x*y<0 && x<0) {x=-x; y=-y;}\n                else if (x==0) y=1;\n                else if (y==0) x=1;\n                u = node(x,y);\n\n                mp[u]++;\n                e[tot++] = u;\n            }\n         }\n\n         sort(e,e+tot);\n         tot = unique(e,e+tot)-e;\n         int ans = 0,tmp = -1;\n         for (int i=0; i<tot; i++) {\n             tmp = max(tmp,mp[e[i]]);\n         }\n         ans = tmp*(tmp-1)/2;\n         printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint n, x[20], y[20];\nbool parallel(int i, int j, int k, int l){\n\tll dx1 = x[i] - x[j];\n\tll dy1 = y[i] - y[j];\n\tll dx2 = x[k] - x[l];\n\tll dy2 = y[k] - y[l];\n\treturn dx1 * dy2 == dx2 * dy1;\n}\nint num[1 << 16];\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tcin >> n;\n\trep(i, n) cin >> x[i] >> y[i];\n\trep(mask, 1 << n){\n\t\trep(i, n) rep(j, i) if((mask >> i & 1) && (mask >> j & 1)){\n\t\t\tint cnt = 0;\n\t\t\trep(k, n) rep(l, k) if((mask >> k & 1) && (mask >> l & 1) && parallel(i, j, k, l)) cnt++;\n\t\t\tnum[mask] = max(num[mask], cnt * (cnt - 1) / 2);\n\t\t}\n\t}\n\t\n\trep(i, 1 << n) for(int j = i; j; j = j - 1 & i) num[i] = max(num[i], num[j] + num[i ^ j]);\n\tcout << num[(1 << n) - 1] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, x[19], y[19], h[129][19][19], dp[65555][549]; bool vis[65555][549]; map<pair<int, int>, vector<pair<int, int> > > d; vector<vector<pair<int, int> > > v;\nint gcd(int pa, int pb) {\n\tif (pb == 0) return pa;\n\treturn gcd(pb, pa % pb);\n}\nint solve(int bit, int p1, int p2, int cur) {\n\tif (p1 == v.size()) return 0;\n\tif (p2 == v[p1].size()) {\n\t\tint res = solve(bit, p1 + 1, 0, 0);\n\t\treturn res + cur * (cur - 1) / 2;\n\t}\n\tif (vis[bit][h[p1][p2][cur]]) return dp[bit][h[p1][p2][cur]];\n\tint pa = v[p1][p2].first, pb = v[p1][p2].second;\n\tint ret = solve(bit, p1, p2 + 1, cur);\n\tif (!(bit & (1 << pa)) && !(bit & (1 << pb))) {\n\t\tint res = solve(bit | (1 << pa) | (1 << pb), p1, p2 + 1, cur + 1);\n\t\tret = max(ret, res);\n\t}\n\tvis[bit][h[p1][p2][cur]] = true;\n\tdp[bit][h[p1][p2][cur]] = ret;\n\treturn ret;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint vx = x[j] - x[i], vy = y[j] - y[i];\n\t\t\tif (vy < 0) vy = -vy, vx = -vx;\n\t\t\tif (vy == 0 && vx < 0) vx = -vx;\n\t\t\tint g = gcd(abs(vx), vy);\n\t\t\td[make_pair(abs(vx) / g * (vx > 0 ? 1 : -1), vy / g)].push_back(make_pair(i, j));\n\t\t}\n\t}\n\tfor (pair<pair<int, int>, vector<pair<int, int> > > i : d) {\n\t\tv.push_back(i.second);\n\t}\n\tint curs = 0;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tfor (int j = 0; j < v[i].size(); j++) {\n\t\t\tfor (int k = 0; k <= j; k++) {\n\t\t\t\th[i][j][k] = curs++;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = solve(0, 0, 0, 0);\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing Number = double;\nconst Number EPS = 1e-10;\n\ninline int sign(Number x) { return (x < -EPS) ? -1 : (x > EPS) ? +1 : 0; }\ninline bool equal(Number a, Number b) { return sign(a - b) == 0; }\n\nclass Point {\npublic:\n    Number x, y;\n\n    Point() {}\n    Point(Number x, Number y) : x(x), y(y) {}\n\n    Point operator-(const Point &rhs) const {\n        return Point(this->x - rhs.x, this->y - rhs.y);\n    }\n};\n\ninline Number abs_cross(const Point &p1, const Point &p2) {\n    return p1.x * p2.y - p1.y * p2.x;\n}\n\nclass Line : public std::array<Point, 2> {\npublic:\n    Line() {}\n    Line(const Point &p1, const Point &p2) {\n        (*this)[0] = p1; (*this)[1] = p2;\n    }\n};\ninline bool IsParallel(const Line &l1, const Line &l2) {\n    return equal(abs_cross(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\n\n//set<vector<int>> memo;\nint Search(const int i, const int m, vector<int> &idx, const vector<Point> &p) {\n    if (i == m - 2) {\n        // if (memo.count(idx) != 0) {cout << \"same\" << endl;  }\n        // memo.insert(idx);\n\n        int sum = 0;\n        vector<bool> check(m / 2, false);\n        // for (auto x : idx) cout << x << \", \";\n        // cout << endl;\n\n        for (int j = 0; 2 * j < m; ++j) {\n            if (check[j]) continue;\n\n            check[j] = true;\n            int num = 1;\n            Line l(p[idx[2 * j]], p[idx[2 * j + 1]]);\n            for (int k = j + 1; 2 * k < m; ++k)\n                if (IsParallel(l, Line(p[idx[2 * k]], p[idx[2 * k + 1]]))) {\n                    ++num;\n                    check[k] = true;\n                }\n            sum += num * (num - 1) / 2;\n        }\n        return sum;\n    }\n\n    int min_idx = distance(idx.begin(), min_element(idx.begin() + i, idx.end()));\n    swap(idx[i], idx[min_idx]);\n\n    int res = 0;\n    for (int j = i + 1; j < m; ++j) {\n        swap(idx[i + 1], idx[j]);\n        res = max(res, Search(i + 2, m, idx, p));\n        swap(idx[i + 1], idx[j]);\n    }\n\n    return res;\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    int m;\n    cin >> m;\n    vector<Point> p(m);\n    for (auto &pp : p) cin >> pp.x >> pp.y;\n\n    vector<int> idx(m);\n    iota(idx.begin(), idx.end(), 0);\n\n    cout << Search(0, m, idx, p) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int N=1007;\nint n,ans,vis[N];\nvector<pii > q;\nstruct node\n{\n    int x,y;\n}a[N];\nvoid judge()\n{\n    int cnt=0;\n    for(int i=0; i<q.size(); i++)\n    {\n        int x1=a[q[i].second].x - a[q[i].first].x;\n        int y1=a[q[i].second].y - a[q[i].first].y;\n        for(int j=0; j<q.size(); j++)\n        {\n            if(i!=j)\n            {\n                int x2=a[q[j].second].x - a[q[j].first].x;\n                int y2=a[q[j].second].y - a[q[j].first].y;\n                if(x2*y1 == x1*y2) cnt++;\n            }\n        }\n    }\n    ans=max(ans, cnt);\n}\nvoid dfs(int pos)\n{\n    if(pos==n+1)\n    {\n        judge();\n        return ;\n    }\n    if(vis[pos]) dfs(pos+1);\n    else\n    {\n        for(int i=1; i<=n; i++)\n        {\n            if(vis[i] || i==pos) continue;\n            q.push_back(make_pair(pos, i));\n            vis[i]=vis[pos]=1;\n            dfs(pos+1);\n            q.pop_back();\n            vis[i]=vis[pos]=0;\n        }\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1; i<=n; i++) scanf(\"%d%d\",&a[i].x,&a[i].y);\n    dfs(1);\n    printf(\"%d\\n\",ans/2);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Pos {\n  int x, y;\n};\n\nint N;\nPos p[16];\nvector<vector<int>> g;\n\nint gcd(int x, int y) {\n  if (y == 0) return x;\n  return gcd(y, x%y);\n}\n\npair<int, int> grad(const Pos&a, const Pos& b) {\n  int x = a.x - b.x;\n  int y = a.y - b.y;\n  int neg = x*y < 0 ? -1 : 1;\n  int g = gcd(abs(x), abs(y));\n  return make_pair((abs(x)/g), (abs(y)/g)*neg);\n}\n\nmap<tuple<int, int, int, int>, int> cache;\n\nint Solve(int i, int j, int c, int used) {\n  if (i == g.size()) return 0;\n  auto key = make_tuple(i, j, c, used);\n  if (cache.count(key) > 0) return cache[key];\n  if (j == g[i].size()) return Solve(i+1, 0, 0, used) + c * (c-1) / 2;\n  int a = Solve(i, j+1, c, used);\n  if ((used & g[i][j]) == 0) {\n    a = max(a, Solve(i, j+1, c+1, used | g[i][j]));\n  }\n  return cache[key] = a;\n}\n\nint main() {\n  while (cin >> N) {\n    cache.clear();\n    for (int i = 0; i < N; ++i) {\n      cin >> p[i].x >> p[i].y;\n    }\n    map<pair<int, int>, vector<int>> cnt;\n    for (int i = 0; i < N; ++i) {\n      for (int j = i+1; j < N; ++j) {\n\tcnt[grad(p[i], p[j])].push_back((1<<i) | (1<<j));\n      }\n    }\n    g.clear();\n    for (const auto& kv : cnt) {\n      auto& c = kv.second;\n      if (c.size() > 1)\n\tg.push_back(c);\n    }\n    sort(g.begin(), g.end(), [](const auto& a, const auto& b){ return a.size() > b.size();});\n    cout << Solve(0, 0, 0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REP1(i,n) for(int i=1;i<=n;i++)\n#define SZ(i) int(i.size())\n#ifdef tmd\n#define IOS()\n#define debug(...) fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);_do(__VA_ARGS__);\ntemplate<typename T> void _do(T &&x){cerr<<x<<endl;}\ntemplate<typename T, typename ...S> void _do(T &&x, S &&...y){cerr<<x<<\", \";_do(y...);}\n#else\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#define endl '\\n'\n#define debug(...)\n#endif\n\nconst int MAXN = 1000006;\nconst ll MOD = 1000000007;\n\ntypedef pair<ll, ll> pii;\npii pt[21];\nvector<pii> slope;\n\nbool cmp (const pii &p1, const pii &p2) {\n    return p1.first * p2.second < p1.second * p2.first;\n}\n\nbool sm (const pii &p1, const pii &p2) {\n    return p1.first * p2.second == p1.second * p2.first;\n}\n\npii operator - (const pii &p1, const pii &p2) {\n    pii ret = {p1.first - p2.first, p1.second - p2.second};\n    if (ret.second < 0) {\n        ret.first *= -1;\n        ret.second *= -1;\n    } else if (ret.second == 0) {\n        ret.first = abs(ret.first);\n    }\n    return ret;\n}\nint ans;\n\nbool vis[21];\npii id[21];\nvoid check () {\n    sort(slope.begin(), slope.end(), cmp);\n    int cnt = 1;\n    int cur = 0;\n    REP1 (i, SZ(slope)) {\n        if (i == SZ(slope) || !sm(slope[i], slope[i-1])) {\n            cur += cnt * (cnt - 1) / 2;\n            cnt = 0;\n        }\n        cnt++;\n    }\n    ans = max(ans, cur);\n}\n\nvoid dfs (int idx, int n) {\n    if (idx == n) {\n        slope.clear();\n        REP (i, n) {\n            slope.emplace_back(pt[id[i].first] - pt[id[i].second]);\n        }\n        check();\n    } else {\n        int f = -1;\n        REP (i, n * 2) {\n            if (!vis[i]) {\n                f = i;\n                break;\n            }\n        }\n        assert(f != -1);\n        vis[f] = true;\n        for (int j=f+1; j<n*2; j++) {\n            if (!vis[j]) {\n                id[idx] = pii(f, j);\n                vis[j] = true;\n                dfs(idx+1, n);\n                vis[j] = false;\n            }\n        }\n        vis[f] = false;\n    }\n}\n/*********************GoodLuck***********************/\nint main () {\n    IOS();\n\n    int n;\n    cin >> n;\n    REP (i, n) {\n        cin >> pt[i].first >> pt[i].second;\n    }\n\n    dfs(0, n/2);\n\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing Number = double;\nconst Number EPS = 1e-10;\n\ninline int sign(Number x) { return (x < -EPS) ? -1 : (x > EPS) ? +1 : 0; }\ninline bool equal(Number a, Number b) { return sign(a - b) == 0; }\n\nclass Point {\npublic:\n    Number x, y;\n\n    Point() {}\n    Point(Number x, Number y) : x(x), y(y) {}\n\n    Point operator-(const Point &rhs) const {\n        return Point(this->x - rhs.x, this->y - rhs.y);\n    }\n};\n\ninline Number abs_cross(const Point &p1, const Point &p2) {\n    return p1.x * p2.y - p1.y * p2.x;\n}\n\nclass Line : public std::array<Point, 2> {\npublic:\n    Line() {}\n    Line(const Point &p1, const Point &p2) {\n        (*this)[0] = p1; (*this)[1] = p2;\n    }\n};\ninline bool IsParallel(const Line &l1, const Line &l2) {\n    return equal(abs_cross(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\n\nint Search(const int i, const int m, vector<int> &idx, const vector<Point> &p) {\n    if (i == m - 2) {\n        int sum = 0;\n        vector<bool> check(m / 2, false);\n\n        for (int j = 0; 2 * j < m; ++j) {\n            if (check[j]) continue;\n\n            check[j] = true;\n            int num = 1;\n            Line l(p[idx[2 * j]], p[idx[2 * j + 1]]);\n            for (int k = j + 1; 2 * k < m; ++k)\n                if (IsParallel(l, Line(p[idx[2 * k]], p[idx[2 * k + 1]]))) {\n                    ++num;\n                    check[k] = true;\n                }\n            sum += num * (num - 1) / 2;\n        }\n        return sum;\n    }\n\n    int res = 0;\n    for (int j = i + 1; j < m; ++j) {\n        swap(idx[i + 1], idx[j]);\n        res = max(res, Search(i + 2, m, idx, p));\n        swap(idx[i + 1], idx[j]);\n    }\n\n    return res;\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    int m;\n    cin >> m;\n    vector<Point> p(m);\n    for (auto &pp : p) cin >> pp.x >> pp.y;\n\n    vector<int> idx(m);\n    iota(idx.begin(), idx.end(), 0);\n\n    cout << Search(0, m, idx, p) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <functional>\n#include <utility>\n#include <map>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#ifdef _DEBUG_\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n#else\n#define dump(val)\n#endif\n\nusing namespace std;\n\ntypedef long long int ll;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) {\n    return vector<T>(a, b);\n}\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\ntemplate<typename T>\nvoid chmax(T &a, T b) {\n    a = max(a, b);\n}\n\nusing P = pair<int, int>;\nP sub(P a, P b) {\n    return P(a.first - b.first, a.second - b.second);\n}\n\nint gcd(int a, int b) {\n    return (b == 0 ? a : gcd(b, a % b));\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int m;\n    cin >> m;\n    vector<P> xy(m);\n    REP(i, 0, m) {\n        cin >> xy[i].first >> xy[i].second;\n    }\n    int ans = 0;\n    vector<int> Pair(m);\n    vector<bool> used(m, false);\n    function<void(int)> dfs = [&](int pos) {\n        if (pos == m) {\n            int res = 0;\n            map<P, int> mp;\n            for (int i = 0; i < m; i += 2) {\n                P sb = sub(xy[Pair[i]], xy[Pair[i + 1]]);\n                bool sig = true;\n                if (sb.first < 0) {\n                    sb.first = -sb.first;\n                    sb.second = -sb.second;\n                }\n                if (sb.second < 0) {\n                    sig = false;\n                    sb.second = -sb.second;\n                }\n                int gd = gcd(sb.first, sb.second);\n                sb.first /= gd;\n                sb.second /= gd;\n                if (sb.first == 0) {\n                    sb.second = 1;\n                }\n                if (sb.second == 0) {\n                    sb.first = 1;\n                }\n                if (!sig && sb.first * sb.second != 0) {\n                    sb.second = -sb.second;\n                }\n                mp[sb] += 1;\n            }\n            for (auto &e : mp) {\n                res += e.second * (e.second - 1) / 2;\n            }\n            /*\n            if (res >= 2) {\n                for (auto &e : mp) {\n                    cout << e.first.first << \" \" << e.first.second << \" \" << e.second << endl;\n                }\n            }\n            */\n            chmax(ans, res);\n        } else {\n            if (pos % 2) {\n                REP(i, 0, m) {\n                    if (used[i]) continue;\n                    Pair[pos] = i;\n                    used[i] = true;\n                    dfs(pos + 1);\n                    used[i] = false;\n                    break;\n                }\n            } else {\n                REP(i, 0, m) {\n                    if (used[i]) continue;\n                    used[i] = true;\n                    Pair[pos] = i;\n                    dfs(pos + 1);\n                    used[i] = false;\n                }\n            }\n        }\n    };\n    dfs(0);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<vector>\n#include<tuple>\n#define llint long long int\n#define lldo long double\n#define fir first\n#define sec second\n#define pub push_back\n#define mp make_pair\n#define mt make_tuple\nusing namespace std;\nint main(void){\n\tint i,j,n;cin>>n;\n\tvector<pair<int,int>> pot(n);\n\tvector<tuple<lldo,int,int>>kata;\n\tfor(i=0;i<n;i++){cin>>pot[i].fir>>pot[i].sec;}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<i;j++){\n\t\t\tlldo dy=pot[i].sec-pot[j].sec;\n\t\t\tlldo dx=pot[i].fir-pot[j].fir;if(abs(dx)<0.5){dx=1e-16*dy;}//0????????????\n\t\t\tkata.pub(mt(dy/dx,i,j));\n\t\t}\n\t}\n\tsort(kata.begin(),kata.end());\n\tstatic int dp[65536]={0};\n\tvector<pair<int,int>> hen;\n\tfor(i=0;i<kata.size();i++){\n\t\then.pub(mp(get<1>(kata[i]),get<2>(kata[i])));\n\t\tif(i==kata.size()-1||abs(get<0>(kata[i])-get<0>(kata[i+1]))>1e-7){\n\t\t\t//?¬?????????¨???????????§??????\n\t\t\tfor(int bii=0;bii<(1<<hen.size());bii++){\n\t\t\t\tint use=0;\n\t\t\t\tint pot=0;\n\t\t\t\tfor(j=0;j<hen.size();j++){\n\t\t\t\t\tif((bii&(1<<j))==0){continue;}\n\t\t\t\t\tuse+=(1<<hen[j].fir);\n\t\t\t\t\tuse+=(1<<hen[j].sec);\n\t\t\t\t\tpot++;\n\t\t\t\t}\n\t\t\t\tpot*=(pot-1);\n\t\t\t\tif(pot==0){continue;}\n\t\t\t\tfor(int bi=0;bi<(1<<n);bi++){\n\t\t\t\t\tif((bi&use)!=0){continue;}\n\t\t\t\t\tif(dp[bi+use]<dp[bi]+pot){dp[bi+use]=dp[bi]+pot;}\n\t\t\t\t}\n\t\t\t}\n\t\t\then.clear();\n\t\t}\n\t\t\n\t}\n\tint ans=0;\n\tfor(i=0;i<65536;i++){if(ans<dp[i]){ans=dp[i];}}\n\tcout<<ans/2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Pos {\n  int x, y;\n};\n\nint N;\nPos p[16];\nvector<vector<int>> g;\n\nint gcd(int x, int y) {\n  if (y == 0) return x;\n  return gcd(y, x%y);\n}\n\npair<int, int> grad(const Pos&a, const Pos& b) {\n  int x = a.x - b.x;\n  int y = a.y - b.y;\n  int neg = x*y < 0 ? -1 : 1;\n  int g = gcd(abs(x), abs(y));\n  return make_pair((abs(x)/g), (abs(y)/g)*neg);\n}\n\nint cache[32][32][32][1<<16];\n\nint Solve(int i, int j, int c, int used) {\n  if (i == g.size()) return 0;\n  if (cache[i][j][c][used] >= 0) return cache[i][j][c][used];\n  if (j == g[i].size()) return Solve(i+1, 0, 0, used) + c * (c-1) / 2;\n  int a = Solve(i, j+1, c, used);\n  if ((used & g[i][j]) == 0) {\n    a = max(a, Solve(i, j+1, c+1, used | g[i][j]));\n  }\n  return cache[i][j][c][used] = a;\n}\n\nint main() {\n  while (cin >> N) {\n    memset(cache, -1, sizeof(cache));\n    for (int i = 0; i < N; ++i) {\n      cin >> p[i].x >> p[i].y;\n    }\n    map<pair<int, int>, vector<int>> cnt;\n    for (int i = 0; i < N; ++i) {\n      for (int j = i+1; j < N; ++j) {\n\tcnt[grad(p[i], p[j])].push_back((1<<i) | (1<<j));\n      }\n    }\n    g.clear();\n    for (const auto& kv : cnt) {\n      auto& c = kv.second;\n      if (c.size() > 1)\n\tg.push_back(c);\n    }\n    sort(g.begin(), g.end(), [](const auto& a, const auto& b){ return a.size() > b.size();});\n    cout << Solve(0, 0, 0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Point{\n\tdouble x,y;\n};\nPoint point[16];\n\nstruct Data{\n\tdouble slope;\n\tint count;\n};\nData data[8];\n\nenum Type{\n\tFROM,\n\tTO,\n};\n\nint M;\nint ans = 0;\n\ndouble calc_slope(int a,int b){\n\n\tif(point[a].x == point[b].x){\n\t\treturn DBL_MAX;\n\t}else{\n\t\treturn (point[b].y-point[a].y)/(point[b].x-point[a].x);\n\t}\n}\n\nvoid recursive(int array[16],int pair[8][2],int num,Type type){\n\n\tif(num == M/2){\n\n\t\tint index = 0;\n\t\tdouble tmp_slope;\n\n\t\tbool FLG;\n\n\t\tfor(int i = 0; i < M/2; i++){\n\t\t\ttmp_slope = calc_slope(pair[i][0],pair[i][1]);\n\n\t\t\tFLG = false;\n\t\t\tfor(int k = 0; k < index; k++){\n\t\t\t\tif(fabs(data[k].slope-tmp_slope) < EPS){\n\t\t\t\t\tdata[k].count++;\n\t\t\t\t\tFLG = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG)continue;\n\n\t\t\tdata[index].slope = tmp_slope;\n\t\t\tdata[index].count = 1;\n\t\t\tindex++;\n\t\t}\n\n\t\tint tmp_count = 0;\n\t\tfor(int i = 0; i < index; i++){\n\t\t\ttmp_count += (data[i].count*(data[i].count-1))/2;\n\t\t}\n\n\t\tans = max(ans,tmp_count);\n\n\t\treturn;\n\t}\n\n\tif(type == FROM){\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tif(array[i] == -1){\n\t\t\t\tint next_array[16];\n\t\t\t\tfor(int k = 0; k < M; k++)next_array[k] = array[k];\n\t\t\t\tnext_array[i] = 1;\n\t\t\t\tint next_pair[8][2];\n\t\t\t\tfor(int k = 0; k < num; k++){\n\t\t\t\t\tnext_pair[k][0] = pair[k][0];\n\t\t\t\t\tnext_pair[k][1] = pair[k][1];\n\t\t\t\t}\n\t\t\t\tnext_pair[num][0] = i;\n\t\t\t\trecursive(next_array,next_pair,num,TO);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}else{ //type == TO\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tif(array[i] == -1){\n\t\t\t\tint next_array[16];\n\t\t\t\tfor(int k = 0; k < M; k++)next_array[k] = array[k];\n\t\t\t\tnext_array[i] = 1;\n\t\t\t\tint next_pair[8][2];\n\t\t\t\tfor(int k = 0; k <= num; k++){\n\t\t\t\t\tnext_pair[k][0] = pair[k][0];\n\t\t\t\t\tnext_pair[k][1] = pair[k][1];\n\t\t\t\t}\n\t\t\t\tnext_pair[num][1] = i;\n\t\t\t\trecursive(next_array,next_pair,num+1,FROM);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\tscanf(\"%d\",&M);\n\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%lf %lf\",&point[i].x,&point[i].y);\n\t}\n\n\tint first_array[16],first_pair[8][2];\n\tfor(int i = 0; i < M; i++)first_array[i] = -1;\n\n\trecursive(first_array,first_pair,0,FROM);\n\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n#define F first\n#define S second\nconst ll MOD=1000000007;\nconst ll E=1e18;\n\nll gcd(ll a,ll b){\n  while(a%b){a%=b; swap(a,b);}\n  return b;\n}\n\nbool same(pll a,pll b,pll c,pll d){\n  b.F-=a.F; b.S-=a.S;\n  d.F-=c.F; d.S-=c.S;\n  if(b.S==0 && d.S==0){return true;}\n  if(b.S==0 || d.S==0){return false;}\n  ll g=gcd(abs(b.F),abs(b.S));\n  b.F/=g; b.S/=g;\n  if(b.S<0){b.S*=-1; b.F*=-1;}\n  g=gcd(abs(d.F),abs(d.S));\n  d.F/=g; d.S/=g;\n  if(d.S<0){d.S*=-1; d.F*=-1;}\n  return b==d || (b.F==0 && d.F==0);\n}\n\n\nint main(){\n  ll n;\n  cin>>n;\n  vector<pll> A(n);\n  const ll MX=1LL<<n;\n  for(auto &I:A){cin>>I.F>>I.S;}\n  vector<ll> dp(MX,0);\n  vector<int> dp2(MX);\n  vector<ll> bitcount(MX,0);\n  for(int i=0;i<MX;i++){\n    for(int j=0;j<n;j++){bitcount[i]+=i>>j&1;}\n    bitcount[i]/=2;\n  }\n  for(int i=0;i<n;i++){\n    for(int t=i+1;t<n;t++){\n      for(auto &I:dp2){I=0;}\n      dp2[0]=1;\n      for(ll j=1;j<MX;j++){\n\tll B=-1;\n\tfor(int k=0;k<n;k++){\n\t  if(j>>k&1){B=k; break;}\n\t}\n\tfor(int k=B+1;k<n;k++){\n\t  if(j>>k&1 && dp2[j^(1LL<<B)^(1LL<<k)] && same(A[i],A[t],A[B],A[k])){dp2[j]=1;}\n\t}\n      }\n      for(int j=0;j<MX;j++){\n\tif(dp2[j]){dp[j]=bitcount[j]*(bitcount[j]-1)/2;}\n      }\n    }\n  }\n  for(int i=0;i<MX;i++){\n    ll z=(MX-1)^i;\n    for(int k=z;k>0;k=(k-1)&z){\n      dp[i^k]=max(dp[i^k],dp[i]+dp[k]);\n    }\n  }\n  cout<<dp.back()<<endl;\n  \n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <stack>\nusing namespace std;\n#define debug(x) std::cerr << #x << \" = \" << (x) << std::endl\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst int MAXN = 25;\n\nmap<PII, int> cnt;\nPII a[MAXN * MAXN];\n\nint n, ans;\nint x[MAXN+5], y[MAXN+5];\nbool vis[MAXN + 5];\n\nint gcd(int x, int y){\n\tif(y == 0) return x;\n\telse return gcd(y, x % y);\n}\n\nbool cmp1(PII A, PII B) {\n\treturn cnt[A] > cnt[B];\n}\n\nPII solve(int x_1, int x_2, int y_1, int y_2){\n\tint dx = x_1 - x_2; int dy = y_1 - y_2;\n\tif(dx == 0){ return PII(-1, 0);}\n\telse if(dy == 0){return PII(0, -1);}\n\telse if(dx < 0 && dy > 0){\n\t\tint Gcd = gcd(-dx, dy);\n\t\tdx /= Gcd; dy /= Gcd;\n\t}\n\telse if(dx > 0 && dy < 0){\n\t\tint Gcd = gcd(dx, -dy);\n\t\tdx = -(dx / Gcd); dy = -(dy / Gcd);\n\t}\n\telse{\n\t\tdx = abs(dx), dy = abs(dy);\n\t\tint Gcd = gcd(dx, dy);\n\t\tdx /= Gcd; dy /= Gcd;\n\t}\n\treturn PII(dx, dy);\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++) scanf(\"%d %d\", &x[i], &y[i]);\n\tint tot = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = i + 1; j <= n; j++){\n\t\t\tPII tmp = solve(x[i], x[j], y[i], y[j]);\n\t\t\tif(cnt[tmp] == 0) a[++tot] = tmp;\n\t\t\tcnt[tmp]++;\n\t\t}\n\t}\n\tmemset(vis, 0, sizeof(vis));\n\tfor(int p = 1; p <= tot; p++) {\n\t\tsort(a + 1, a + tot + 1, cmp1);\n\t\tif(cnt[a[1]] == 0) break;\n\t//\tprintf(\"%d %d\\n\", a[1].first, a[1].second);\n\t//\tprintf(\"%d\\n\", cnt[a[1]]);\n\t\tans += (cnt[a[1]] * (cnt[a[1]] - 1) / 2);\n\t\tfor(int i = 1; i <= n; i++) \n\t\t\tfor(int j = i + 1; j <= n; j++)\n\t\t\t\tif(!vis[i] && !vis[j] && solve(x[i], x[j], y[i], y[j]) == a[1]) {\n\t\t\t\t\tvis[i] = 1; vis[j] = 1;\n\t\t\t\t\tcnt[solve(x[i], x[j], y[i], y[j])]--;\n\t\t\t\t\tfor(int k = 1; k <= n; k++)\n\t\t\t\t\t\tif(!vis[k]) {\n\t\t\t\t\t\t\tcnt[solve(x[i], x[k], y[i], y[k])]--;\n\t\t\t\t\t\t\tcnt[solve(x[j], x[k], y[j], y[k])]--;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n\nint m;\nvector<pii> v;\n\nint gcd(int a, int b) {\n\treturn a % b ? gcd(b, a % b) : b;\n}\n\nint solve(int stat, vector<pii> & ktmk) {\n\tint res = 0;\n\tif(stat == (1 << m)-1 || true) {\n\t\tvector<pii> vv(ktmk.begin(), ktmk.end());\n\t\tsort(vv.begin(), vv.end());\n\t\tvv.push_back(pii(-1,-1));\n\t\tint t = 1;\n\t\tfor(int i = 1; i <= vv.size(); i++) {\n\t\t\tif(vv[i] == vv[i-1]) {\n\t\t\t\tt++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres += t * (t-1) / 2;\n\t\t\t\tt = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i = 0; i < vv.size(); i++) {\n\t\t\tcout << vv[i].fi << \",\" << vv[i].se << \" \";\n\t\t} cout << endl;\n\t\tcout << res << endl;\n\t\t// */\n\t\t//return res;\n\t}\n\n\tfor(int i = 0; i < m; i++) {\n\t\tif((stat & (1<<i)) == 0) {\n\t\t\tfor(int j = i+1; j < m; j++) {\n\t\t\t\tif((stat & (1<<j)) == 0) {\n\t\t\t\t\tpii a(v[i].fi - v[j].fi, v[i].se - v[j].se);\n\t\t\t\t\tif(a.se == 0) {\n\t\t\t\t\t\ta.fi = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint d = gcd(a.fi, a.se);\n\t\t\t\t\t\ta.fi /= d; a.se /= d;\n\t\t\t\t\t\tif(a.se < 0) {\n\t\t\t\t\t\t\ta.fi *= -1; a.se *= -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tktmk.push_back(a);\n\t\t\t\t\tres = max(res,solve(stat | (1 << i) | (1 << j), ktmk));\n\t\t\t\t\tktmk.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin >> m;\n\tv.resize(m);\n\tfor(int i = 0; i < m; i++) {\n\t\tcin >> v[i].fi >> v[i].se;\n\t}\n\tvector<pii> ktmk;\n\tcout << solve(0,ktmk) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL mod=1000000007;\nconst LL LINF=1LL<<62;\nconst LL INF=1<<17;\n\nint m;\nvector<bool> b(16,false);\nvector<P> f;\n\nint dfs(int k,vector<int> v){\n    int ret=0;\n    if(k==m){\n        map<P,int> ma;\n        for(int i=0;i<m;i++){\n            if(i%2){\n                int x=f[v[i]].fs-f[v[i-1]].fs;\n                int y=f[v[i]].sc-f[v[i-1]].sc;\n                int g=__gcd(abs(x),abs(y));\n                x/=g;\n                y/=g;\n                if(x*y<0) ma[{-abs(x),abs(y)}]++;\n                else ma[{abs(x),abs(y)}]++;\n            }\n        }\n        for(auto p:ma) ret+=p.sc*(p.sc-1)/2;\n        return ret;\n    }\n    for(int i=0;i<m;i++){\n        if(!b[i]){\n            v.pb(i);\n            b[i]=true;\n            ret=max(ret,dfs(k+1,v));\n            b[i]=false;\n            if(k%2==0) return ret;\n            v.pop_back();\n        }\n    }\n    return ret;\n}\nint main(){\n    cin >> m;\n    for (int i = 0; i < m; i++) {\n        int x,y;\n        cin >> x >> y;\n        f.pb({x,y});\n    }\n    cout << dfs(0,vector<int> ()) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <deque>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <map>\n#include <stack>\n#include <set>\n#include <sstream>\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0);\n#define ll long long\n#define INF 0x3f3f3f3f \n#define MEM(x,y) memset(x,y,sizeof(x))\n#define int long long\n#define rep(i , a , b) for(int i = a ; i <= b ; i ++)\n#define P pair<int,int>\n#define  sc(a) scanf(\"%lld\",&a)\n#define pf(a) printf(\"%lld \",a)\nusing namespace std;\nstruct point\n{\n\tint x;\n\tint y;\n}point [20];\nstruct xia\n{\n\tint x;\n\tint y;\n}v[10];\nint vis[20];\nint maxx;\nint n, q;\nvoid ju()\n{\n\tint temp = 0;\n\tfor (int i = 0; i < q; i++)\n\t\tfor (int j = i+1; j < q; j++)\n\t\t\tif (v[i].x * v[j].y == v[i].y * v[j].x)\n\t\t\t\ttemp++;\n\tmaxx = max(temp, maxx);\n\treturn;\n}\nvoid dfs(int x)\n{\n\twhile (vis[x])x++;\n\tif (x >= n) {\n\t\tju();\n\t\treturn;\n\t}\n\tvis[x] = 1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (!vis[i])\n\t\t{\n\t\t\tvis[i] = 1;\n\t\t\tint dy = point[x].y - point[i].y;\n\t\t\tint dx = point[x].x - point[i].x;\n\t\t\tv[q].x = dx, v[q].y = dy;\n\t\t\tq++;\n\t\t\tdfs(x + 1);\n\t\t\tq--;\n\t\t\tvis[i] = 0;\n\t\t}\n\t}\n\tvis[x] = 0;\n\treturn;\n}\nsigned main()\n{\n\tsc(n);\n\tMEM(vis, 0);\n\trep(i, 0, n - 1)\n\t\tsc(point[i].x), sc(point[i].y);\n\tdfs(0);\n\tcout << maxx << endl;\n}\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <numeric>\nusing namespace std;\n\nint M;\nvector<int> X, Y;\n\nint nc2(int x){\n    if(x < 2)\n        return 0;\n    return x * (x-1) / 2;\n}\n\nint get_counts(map<pair<int, int>, int> &counts){\n    int res = 0;\n    for(auto p: counts)\n        res += nc2(p.second);\n    return res;\n}\n\npair<int, int> get_fraction(int i, int j){\n    int dx = X[i] - X[j];\n    int dy = Y[i] - Y[j];\n    int g = __gcd(dx, dy);\n    \n    return {dx/g, dy/g};\n}\n\nint dfs(int idx, int used, map<pair<int, int>, int> &counts){\n    if(idx == M){\n        return get_counts(counts);\n    }\n    \n    int res = -1;\n    if((used >> idx) & 1){\n        res = max(res, dfs(idx+1, used, counts));\n    }else{\n        for(int i=idx+1; i<M; i++) if(((used >> i) & 1) == 0){\n            int nused = used;\n            nused |= 1 << idx;\n            nused |= 1 << i;\n            \n            pair<int, int> fr = get_fraction(idx, i);\n            counts[fr]++;\n            res = min(res, dfs(idx+1, nused, counts));\n            counts[fr]--;\n        }\n    }\n    return res;\n}\n\nint main(){\n    cin >> M;\n    X.resize(M), Y.resize(M);\n    \n    for(int i=0; i<M; i++)\n        cin >> X[i] >> Y[i];\n    \n    map<pair<int, int>, int> counts;\n    cout << dfs(0, 0, counts) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nusing P=complex<ld>;\nstruct Line{\n    P a,b;\n};\nvector<P> ps;\nint m;\nconst ld EPS=1e-9;\nld cross(P a,P b){\n    return a.real()*b.imag()-a.imag()*b.real();\n}\nint solve(int id,vector<int> flag){\n    if(id==m){\n        \n        vector<Line> lines(m/2);\n        for(int i=1;i<=m/2;i++){\n            for(int j=0;j<m;j++){\n                if(flag[j]==i){\n                    lines[i-1].a=ps[j];\n                    j++;\n                    for(;j<m;j++){\n                        if(flag[j]==i){\n                            lines[i-1].b=ps[j];\n                            break;\n                        }\n                        \n                    }\n                    break;\n                }\n            }\n        }    \n        int res=0;\n        for(int i=0;i<m/2;i++){\n            for(int j=0;j<i;j++){\n                if(abs(cross(lines[i].a-lines[i].b,lines[j].a-lines[j].b))<EPS){\n                    res++;\n                }\n            }\n        }  \n\n        return res;\n    }\n    if(flag[id]) return solve(id+1,flag);\n    int res=0;\n    int nex=1+*max_element(flag.begin(),flag.end());\n    flag[id]=nex;\n    for(int i=id+1;i<m;i++){\n        if(!flag[i]){\n            flag[i]=nex;\n            res=max(res,solve(id+1,flag));\n            flag[i]=0;\n        }\n    }\n    return res;\n}\nint main(){\n    cin>>m;\n    ps.resize(m);\n    for(int i=0;i<m;i++){\n        ld x,y; cin>>x>>y;\n        ps[i]={x,y};\n    }\n    vector<int> flag(m);\n    cout<<solve(0,flag)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing Number = double;\nconst Number EPS = 1e-10;\n\ninline int sign(Number x) { return (x < -EPS) ? -1 : (x > EPS) ? +1 : 0; }\ninline bool equal(Number a, Number b) { return sign(a - b) == 0; }\n\nclass Point {\npublic:\n    Number x, y;\n\n    Point() {}\n    Point(Number x, Number y) : x(x), y(y) {}\n\n    Point operator-(const Point &rhs) const {\n        return Point(this->x - rhs.x, this->y - rhs.y);\n    }\n};\n\ninline Number abs_cross(const Point &p1, const Point &p2) {\n    return p1.x * p2.y - p1.y * p2.x;\n}\n\nclass Line : public std::array<Point, 2> {\npublic:\n    Line() {}\n    Line(const Point &p1, const Point &p2) {\n        (*this)[0] = p1; (*this)[1] = p2;\n    }\n};\ninline bool IsParallel(const Line &l1, const Line &l2) {\n    return equal(abs_cross(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\n\nint Search(const int i, const int m, vector<int> &idx, const vector<Point> &p) {\n    if (i == m - 2) {\n        int sum = 0;\n        vector<bool> check(m / 2, false);\n\n        for (int j = 0; 2 * j < m; ++j) {\n            if (check[j]) continue;\n\n            check[j] = true;\n            int num = 1;\n            Line l(p[idx[2 * j]], p[idx[2 * j + 1]]);\n            for (int k = j + 1; 2 * k < m; ++k)\n                if (IsParallel(l, Line(p[idx[2 * k]], p[idx[2 * k + 1]]))) {\n                    ++num;\n                    check[k] = true;\n                }\n            sum += num * (num - 1) / 2;\n        }\n        return sum;\n    }\n\n    int res = 0;\n//    int min_idx = distance(idx.begin(), min_element(idx.begin() + i, idx.end()));\n//    swap(idx[i], idx[min_idx]);\n    for (int j = i + 1; j < m; ++j) {\n        swap(idx[i + 1], idx[j]);\n        res = max(res, Search(i + 2, m, idx, p));\n        swap(idx[i + 1], idx[j]);\n    }\n//    swap(idx[i], idx[min_idx]);\n\n    return res;\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    int m;\n\n    cin >> m;\n    vector<Point> p(m);\n    for (auto &pp : p) cin >> pp.x >> pp.y;\n\n    vector<int> idx(m);\n    iota(idx.begin(), idx.end(), 0);\n\n    cout << Search(0, m, idx, p) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> LP;\n \n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define all(x) x.begin(),x.end()\n \n#define inf 1e16\n \nll n;\nll x[1010],y[1010];\nmap<P,vector<P> > vs;\nvector<LP> as;\nbool used[1001];\n \nint main(){\n  cin>>n;\n  rep(i,n)cin>>x[i]>>y[i];\n  rep(i,n)rep(j,i){\n    ll dx=x[i]-x[j];\n    ll dy=y[i]-y[j];\n\n    if(dx==0){\n      vs[P(0,inf)].push_back(P(i,j));\n    }else if(dy==0){\n      vs[P(0,0)].push_back(P(i,j));\n    }else{\n      ll pdx=dx<0?-dx:dx;\n      ll pdy=dy<0?-dy:dy;\n      ll g=__gcd(pdx,pdy);\n\n      if(dx<0)vs[P(-dx/g,-dy/g)].push_back(P(i,j));\n      else vs[P(dx/g,dy/g)].push_back(P(i,j));\n    }\n  }\n \n  for(auto it : vs){\n    as.push_back(LP(it.se.size(),it.fi));\n  }\n  sort(all(as));\n  reverse(all(as));\n \n  ll res=0;\n \n  rep(i,as.size()){\n    ll cnt=0;\n    for(auto it : vs[as[i].se]){\n      if(used[it.fi]||used[it.se])continue;\n      used[it.fi]=true; used[it.se]=true;\n      cnt++;\n    }\n    res+=cnt*(cnt-1)/2;\n  }\n \n  cout<<res<<endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\ntypedef complex<int> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\n\nint m, res = 0;\nVP ps;\n\nbool isParallel(Point a, Point b){\n    return a.Y * b.X == a.X * b.Y;\n}\n\nvoid solve(vector<bool> &used, VP &vs){\n\n    if((int)vs.size() == m/2){\n        int cnt = 0;\n        rep(i,m/2)rep(j,i){\n            if(isParallel(vs[i],vs[j])) cnt++;\n        }\n        res = max(res,cnt);\n        return;\n    }\n\n    rep(i,m)if(!used[i]){\n        used[i] = true;\n        rep(j,m)if(!used[j]){\n            vs.push_back(ps[i]-ps[j]);\n            used[j] = true;\n            solve(used,vs);\n            vs.pop_back();\n            used[j] = false;\n        }\n        used[i] = false;\n        return;\n    }\n}\n\nint main(void){\n    cin>>m;\n    ps.resize(m);\n    rep(i,m){\n        int x,y;\n        cin>>x>>y;\n        ps[i] = Point(x,y);\n    }\n    vector<bool> used(m);\n    VP vs;\n    solve(used,vs);\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned char dp[16][16][10][1<<16];\ntemplate<typename T1,typename T2>\nvoid chmax(T1 &a,T2 b){\n  if(a<b) a=b;\n}\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n;\n  cin>>n;\n  using P = pair<Int, Int>;\n  vector<P> v;\n  for(Int i=0;i<n;i++){\n    Int x,y;\n    cin>>x>>y;\n    v.emplace_back(x,y);\n  }\n  vector<vector<P> > r(n,vector<P>(n)); \n  for(Int i=0;i<n;i++){\n    for(Int j=i+1;j<n;j++){\n      if(v[i].first==v[j].first){\n\tr[i][j]=P(0,1);\n\tcontinue;\n      }\n      if(v[i].second==v[j].second){\n\tr[i][j]=P(1,0);\n\tcontinue;\n      }\n      Int dx=v[i].first-v[j].first;\n       Int dy=v[i].second-v[j].second;\n       if(dx<0){\n\t dx*=-1;\n\t dy*=-1;\n       }\n       Int k=__gcd(dx,abs(dy));\n       dx/=k;dy/=k;\n       r[i][j]=P(dx,dy);\n       //cout<<i<<\" \"<<j<<\":\"<<dx<<\" \"<<dy<<endl;\n     }\n   }\n  memset(dp,-1,sizeof(dp));\n  //dp[0][0][0][0]=0;\n  for(Int i=0;i<n;i++){\n    for(Int j=i+1;j<n;j++){\n      dp[i][j][1][(1<<i)|(1<<j)]=0;\n    }\n  }\n  Int ans=0;\n  for(Int b=0;b<(1<<n);b++){\n    for(Int i=0;i<n;i++){\n      for(Int j=i+1;j<n;j++){\n\tfor(Int k=0;k<=n/2;k++){\n\t  if(dp[i][j][k][b]<0) continue;\n\t  //cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<b<<\":\"<<dp[i][j][k][b]<<endl;\n\t  for(Int s=0;s<n;s++){\n\t    for(Int t=s+1;t<n;t++){\n\t      if((b>>s)&1) continue;\n\t      if((b>>t)&1) continue;\n\t      Int nb=b|(1<<s)|(1<<t);\n\t      if(r[i][j]==r[s][t]){\n\t\tchmax(dp[s][t][k+1][nb],dp[i][j][k][b]+k);\n\t\tchmax(ans,dp[s][t][k+1][nb]);\n\t      }else{\n\t\tchmax(dp[s][t][1][nb],dp[i][j][k][b]);\n\t\tchmax(ans,dp[s][t][1][nb]);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n  }  \n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nusing P=complex<ld>;\nstruct Line{\n    P a,b;\n};\nvector<P> ps;\nint m;\nconst ld EPS=1e-9;\nld cross(P a,P b){\n    return a.real()*b.imag()-a.imag()*b.real();\n}\nint solve(int id,vector<int> flag){\n    if(id==m){\n        \n        vector<Line> lines(m/2);\n        for(int i=1;i<=m/2;i++){\n            for(int j=0;j<m;j++){\n                if(flag[j]==i){\n                    lines[i-1].a=ps[j];\n                    j++;\n                    for(;j<m;j++){\n                        if(flag[j]==i){\n                            lines[i-1].b=ps[j];\n                            break;\n                        }\n                        \n                    }\n                    break;\n                }\n            }\n        }    \n        int res=0;\n        for(int i=0;i<m/2;i++){\n            for(int j=0;j<i;j++){\n                if(abs(cross(lines[i].a-lines[i].b,lines[j].a-lines[j].b))<EPS){\n                    res++;\n                }\n            }\n        }  \n\n        return res;\n    }\n    if(flag[id]) return solve(id+1,flag);\n    int res=0;\n    int nex=1+*max_element(flag.begin(),flag.end());\n    flag[id]=nex;\n    for(int i=id+1;i<m;i++){\n        if(!flag[i]){\n            flag[i]=nex;\n            res=max(res,solve(id+1,flag));\n            flag[i]=0;\n        }\n    }\n    return res;\n}\nint main(){\n    cin>>m;\n    ps.resize(m);\n    for(int i=0;i<m;i++){\n        int x,y; cin>>x>>y;\n        ps[i]={x,y};\n    }\n    vector<int> flag(m);\n    cout<<solve(0,flag)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  for(auto it = v.begin(); it != v.end(); it++) {\n    os << *it << \" \";\n  }\n  return os;\n}\n\nint main(int argc, char*argv[])\n{\n  int m;\n  vector<int> xs, ys;\n  cin >> m;\n  for(int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    xs.push_back(x);\n    ys.push_back(y);\n  }\n    /*\n      | x1 y1 1 |\n      | x2 y2 1 |\n      | x3 y3 1 |\n     */\n  auto area = [](int x1, int y1, int x2, int y2, int x3, int y3) {\n    return x1 * y2 + x2 * y3 + x3 * y1 - (x1 * y3 + x2 * y1 + x3 * y2) ;\n  };\n  // 1-2 and 3-4\n  auto isPara = [&xs,&ys,&area](int p1, int p2, int p3, int p4) {\n    int dx = xs[p1] - xs[p3];\n    int dy = ys[p1] - ys[p3];\n    return 0 == area(xs[p1], ys[p1], xs[p2], ys[p2], xs[p4] + dx, ys[p4] + dy);\n  };\n  int memo[256][256];\n  for(int i = 0; i < m; i++) {\n    for(int j = 0; j < m; j++) {\n      for(int k = 0; k < m; k++) {\n        for(int l = 0; l < m; l++) {\n          memo[(i<<4)+j][(k<<4)+l] = isPara(i,j,k,l) ? 1 : 0;\n        }\n      }\n    }\n  }\n  vector<bool> vss(m);  // choice of sources\n  for(int i = 0; i < m/2; i++) {\n    vss[i] = false;\n    vss[i+m/2] = true;\n  }\n  int mx = 0;\n  do {\n    //cout << vss << endl;\n    vector<int> ts, ss;\n    for(int i = 0; i < m; i++) {\n      if(!vss[i]) ts.push_back(i);\n      else ss.push_back(i);\n    }\n    do {\n      // check if ts[i] > ss[i]\n      bool skip = false;\n      for(int i = 0; i < m/2; i++) {\n        if(ss[i] < ts[i]) {\n          skip = true;\n          break;\n        }\n      }\n      if(!skip) {\n        int pp = 0;\n        for(int i = 0; i < m/2; i++) {\n          const int *mm = memo[(ss[i]<<4)+ts[i]];\n          for(int j = i+1; j < m/2; j++) {\n            pp += mm[(ss[j]<<4)+ts[j]];\n          }\n        }\n        if(pp > mx) mx = pp;\n      }\n    } while(next_permutation(ts.begin(), ts.end()));\n  } while(next_permutation(vss.begin(), vss.end()));\n  cout << mx << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n\nusing namespace std;\n\nint m;\nint x[17], y[17];\nint dp[1<<16];\nbool dp2[1<<16];\nint size[1<<16];\n\nint gcd(int a, int b){\n  if(b == 0) return a;\n  return gcd(b, a%b);\n}\n\nint check(int i, int j, int k, int l)\n{\n  if(x[i] == x[j] || x[k] == x[l]){\n    if(x[i] == x[j] && x[k] == x[l]) return 1;\n    else return 0;\n  }\n\n  int dx1 = x[i] - x[j], dy1 = y[i] - y[j];\n  int dx2 = x[k] - x[l], dy2 = y[k] - y[l];\n  if(dy1 == 0 || dy2 == 0){\n    if(dy1 == 0 && dy2 == 0) return 1;\n    else return 0;\n  }\n\n  int d1 = gcd(abs(dx1), abs(dy1)), d2 = gcd(abs(dx2), abs(dy2));\n  if(dx1 < 0) dx1 *= -1, dy1 *= -1;\n  if(dx2 < 0) dx2 *= -1, dy2 *= -1;\n  if(dx1/d1 == dx2/d2 && dy1/d1 == dy2/d2) return 1;\n  else return 0;\n}\n\nint comb(int x){\n  return x * (x-1) / 2;\n}\n\nint main(void)\n{\n  cin >> m;\n  for(int i = 0; i < m; i++) cin >> x[i] >> y[i];\n\n  int S = 1<<m;\n  for(int i = 0; i < S; i++){\n    for(int j = 0; j < m; j++) if(i & (1<<j)) size[i]++;\n  }\n\n  dp2[0] = true;\n  for(int i = 1; i < S; i++){\n    if(size[i] % 2) continue;\n    int x;\n    for(int j = 0; j < m; j++){\n      if(i & (1<<j)){\n        x = j;\n        break;\n      }\n    }\n    for(int j = x+1; j < m; j++){\n      int s = i;\n      s &= ~(1<<x), s &= ~(1<<j);\n      for(int k = 0; k < m; k++){\n        if((s & (1<<k)) == 0) continue;\n        bool flag = false;\n        for(int l = k+1; l < m; l++){\n          if((s & (1<<l)) == 0) continue;\n          if(!check(x, j, k, l)) continue;\n          s &= ~(1<<k), s &= ~(1<<l);\n          flag = true;\n          break;\n        }\n        if(!flag) goto ng;\n      }\n      dp2[i] = true;\n      break;\n      ng:;\n    }\n  }\n\n  for(int i = 1; i < S; i++){\n    if(dp2[i]) dp[i] = comb(size[i]/2);\n    for(int j = (i-1)&i; j > 0; j = (j-1)&i){\n      if(!dp2[j]) continue;\n      dp[i] = max(dp[i], comb(size[j]/2) + dp[i & ~j]);\n    }\n  }\n  cout << dp[S-1] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n\n#define int long long\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define itrep(i, a) for (auto i = (a).begin(); i != (a).end(); i++)\n#define REP(i, a, n) for (int i = (a); i <= (n); i++)\n#define all(a) (a).begin(), (a).end()\n#define mp(a, b) make_pair((a), (b))\n\nusing namespace std;\n\ntemplate<class T> void inputVector(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < v.size(); i++) cin >> v[i];\n}\n\nstruct Point {\n    int x, y;\n    bool choiced;\n    Point() {}\n    Point(int x, int y) {\n\tthis->x = x;\n\tthis->y = y;\n    }\n};\n\nsigned main() {\n    int N;\n    cin >> N;\n\n    vector<Point> ps;\n    rep(i, N) {\n\tint x, y;\n\tcin >> x >> y;\n\tps.push_back(Point(x, y));\n    }\n\n    int ret = 0;\n    vector<bool> maxC(N, false);\n    while (true) {\n\tint ret2 = 0;\n\tvector<bool> ttmaxC = maxC;\n\trep(i, N) rep(j, N) {\n\t    if (i == j) continue;\n\t    int dx = ps[i].x - ps[j].x;\n\t    int dy = ps[i].y - ps[j].y;\n\t    vector<bool> tmaxC = ttmaxC;\n\n\t    int tmp = 0;\n\t    rep(v, N) rep(w, N) {\n\t\tif (v == w) continue;\n\t\tif (tmaxC[v] || tmaxC[w]) continue;\n\t\tint dx2 = ps[v].x - ps[w].x;\n\t\tint dy2 = ps[v].y - ps[w].y;\n\t\tif (dx * dy2 == dx2 * dy) {\n\t\t    tmaxC[v] = true;\n\t\t    tmaxC[w] = true;\n\t\t    tmp++;\n\t\t}\n\t    }\n\t    int tmp2 = tmp * (tmp - 1) / 2;\n\t    if (tmp2 > ret2) {\n\t\tret2 = tmp2;\n\t\tmaxC = tmaxC;\n\t    }\n\t    ret2 = max(ret2, tmp2);\n\t}\n\tret += ret2;\n\tif (ret2 == 0) break;\n    }\n\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dfs(vector<int> &x, vector<int> &y, vector<int> &P, vector<pair<int, int>> &id, int d){\n  int m = x.size();\n  if (d == m / 2){\n    return 0;\n  } else {\n    vector<int> R;\n    for (int i = 0; i < m; i++){\n      if (P[i] == -1){\n        R.push_back(i);\n      }\n    }\n    int sz = R.size();\n    int ans = 0;\n    P[R[0]] = d;\n    for (int i = 1; i < sz; i++){\n      P[R[i]] = d;\n      id[d] = make_pair(R[0], R[i]);\n      int dy = y[R[i]] - y[R[0]];\n      int dx = x[R[i]] - x[R[0]];\n      int cnt = 0;\n      for (int j = 0; j < d; j++){\n        if ((x[id[j].second] - x[id[j].first]) * dy == (y[id[j].second] - y[id[j].first]) * dx){\n          cnt++;\n        }\n      }\n      ans = max(ans, cnt + dfs(x, y, P, id, d + 1));\n      id[d] = make_pair(-1, -1);\n      P[R[i]] = -1;\n    }\n    P[R[0]] = -1;\n    return ans;\n  }\n}\nint main(){\n  int m;\n  cin >> m;\n  vector<int> x(m), y(m);\n  for (int i = 0; i < m; i++){\n    cin >> x[i] >> y[i];\n  }\n  vector<int> P(m, -1);\n  vector<pair<int, int>> id(m);\n  for (int i = 0; i < m; i++){\n    id[i] = make_pair(-1, -1);\n  }\n  cout << dfs(x, y, P, id, 0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define MAXN 3005\n#define MOD 1000000007\n#define P pair<int,int>\nusing namespace std;\nconst double eps=1e-8;\nconst double INF=1e20;\nconst double PI=acos(-1.0);\n\nint sgn(double a)\n{\n    if(fabs(a)<eps) return 0;\n    return (a<0?-1:1);\n}\nstruct Point\n{\n    double x,y;\n    Point (double _x=0,double _y=0):x(_x),y(_y) {}\n    Point (Point a,Point b)\n    {\n        x=b.x-a.x;\n        y=b.y-a.y;\n    }\n    bool operator <(const Point &b) const  //less is more left, same then more down\n    {\n        return (sgn(x-b.x)==0?sgn(y-b.y)<0:x<b.x);\n    }\n    Point operator +(const Point &b) const\n    {\n        return Point(x+b.x,y+b.y);\n    }\n    Point operator -(const Point &b) const\n    {\n        return Point(x-b.x,y-b.y);\n    }\n    Point operator *(double a)\n    {\n        return Point(x*a,y*a);\n    }\n    Point operator /(double a)\n    {\n        return Point(x/a,y/a);\n    }\n    double len2()\n    {\n        return x*x+y*y;\n    }\n    double len()\n    {\n        return sqrt(len2());\n    }\n    Point change_len(double r)\n    {\n        double l=len();\n        if(sgn(l)==0) return *this;\n        r/=l;\n        return Point(x*r,y*r);\n    }\n};\ndouble xmul(const Point& a,const Point& b)\n{\n    return a.x*b.y-a.y*b.x;\n}\ndouble dis(Point A,Point B)\n{\n    return Point(A,B).len();\n}\nstruct Line\n{\n    Point s,e;\n    double k;\n    Line() {}\n    Line(Point _s,Point _e)\n    {\n        s=_s,e=_e;\n        if(e<s) swap(s,e);\n        k=atan2(e.y-s.y,e.x-s.x);\n    }\n    double len()\n    {\n        return dis(s,e);\n    }\n};\ndouble DisPointLine(Point p,Line l)\n{\n    return fabs(xmul(p-l.s,l.e-l.s)/l.len());\n}\ndouble LineWithLine(Line a,Line b,Point& p)\n{\n    //<0 insect at p, other distance\n    double s1,s2;\n    s1=xmul(a.e-a.s,b.s-a.s);\n    s2=xmul(a.e-a.s,b.e-a.s);\n    if(sgn(s1)==0 && sgn(s2)==0)\n        return 0;\n    if(sgn(s1-s2)==0) return DisPointLine(a.e,b);\n    p=(b.s*s2-b.e*s1)/(s2-s1);\n    return -1.0;\n}\nPoint p[20];\nint n;\nmap<int,bool> Find(map<int,bool> ausd,int& ttt){\n    map<int,bool> usd=ausd;\n    map<int,bool> good;\n    map<P,bool> tryd;\n    int ans=1;\n    /*for(auto it=usd.begin();it!=usd.end();++it)if(it->second==false){\n        printf(\"m:%d \",it->first);\n    }\n    puts(\"\");*/\n    for(int i=0;i<n;i++)\n    for(int j=i+1;j<n;j++) if(!usd[i]&&!usd[j]){\n        int cur=1;\n        Line l=Line(p[i],p[j]);\n        tryd[P(i,j)]=1;\n        usd[i]=1;\n        usd[j]=1;\n        for(int k=0;k<n;k++)\n        for(int kk=k+1;kk<n;kk++) if(!usd[k] && !usd[kk] && !tryd[P(k,kk)]){\n            Line ll=Line(p[k],p[kk]);\n            Point pp;\n            if(sgn(LineWithLine(l,ll,pp))>0){\n                tryd[P(k,kk)]=1;\n                cur++;\n                if(cur>ans){\n                    //printf(\"%d %d %d %d \\n\",i,j,k,kk);\n                    usd[k]=1; usd[kk]=1;\n                    ans=cur;\n                    good=usd;\n                }\n            }\n        }\n        usd=ausd;\n    }\n    ttt=ans*(ans-1)/2;\n    return good;\n}\n\nint main()\n{\n#ifdef Vince\n    freopen(\"data.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    //clock_t st=clock();\n#endif // ONLINE_JUDGE\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        double x,y;\n        scanf(\"%lf%lf\",&x,&y);\n        p[i]=Point(x,y);\n    }\n    int ans=0;\n    map<int,bool> usd;\n    while(1){\n        int cur=0;\n        usd=Find(usd,cur);\n        /*printf(\"ans:%d\\n\",cur);\n        puts(\"\");*/\n        if(cur<1) break;\n        ans+=cur;\n    }\n    printf(\"%d\",ans);\n#ifdef Vince\n    //fprintf(stderr,\"Time Cost:%lf\\n\",(double)(clock()-st)/CLOCKS_PER_SEC);\n#endif // ONLINE_JUDGE\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < int(n); ++i)\n#define REPE(i, a, b) for (int i = (a); i <= int(b); ++i)\n#define SZ(x) ((int)(x).size())\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n#define EB emplace_back\nusing LL = long long;\nusing PII = pair<int, int>;\n#define F first\n#define S second\nvoid R(int &x) { scanf(\"%d\", &x); }\nvoid R(LL &x) { scanf(\"%lld\", &x); }\nvoid R(double &x) { scanf(\"%lf\", &x); }\ntemplate <typename T> void R(T &t) { cin >> t; }\ntemplate <typename T> void R(vector<T> &ar) {\n  for (auto &it : ar)\n    R(it);\n}\ntemplate <typename T, typename... Args> void R(T &t, Args &... args) {\n  R(t);\n  R(args...);\n}\n\nmap<PII, int> m;\nint add(int x, int y, int v) {\n  if (x == 0) y = 1;\n  else if (y == 0) x = 1;\n  else if (x < 0) x = -x, y = -y;\n  int g = __gcd(abs(x), abs(y));\n  x /= g, y /= g;\n  int r = m[{x, y}];\n  m[{x, y}] += v;\n  return r;\n}\n\nint n, x[22], y[22];\nbool v[22];\n\nint sum = 0, ans = 0;\nint md;\nvoid dfs(int a, int d) {\n  if (d * 2 == n) {\n    ans = max(ans, sum);\n    return;\n  }\n  while (v[a]) a++;\n  v[a] = true;\n  for (int i = a + 1; i < n; ++i) {\n    if (v[i]) continue;\n    v[i] = true;\n    int t = add(x[i] - x[a], y[i] - y[a], 1);\n    sum += t;\n    dfs(a + 1, d + 1);\n    add(x[i] - x[a], y[i] - y[a], -1);\n    sum -= t;\n    v[i] = false;\n  }\n  v[a] = false;\n}\n\nint main() {\n  R(n);\n  REP(i, n) R(x[i], y[i]);\n  dfs(0, 0);\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 22;\nint n, ans = 0;\nstruct node {\n\tint x, y;\n}point[MAX];\nnode line[MAX];\nint vis[MAX] = { 0 };\nint getNum() {\n\tint cnt = 0;\n\tint u = n / 2;\n\tfor (int i = 0; i < u - 1; i++) {\n\t\tfor (int j = i + 1; j < u; j++) {\n\t\t\tif (line[i].x * line[j].y == line[i].y * line[j].x) cnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\nvoid dfs(int num, int sum) {\n\tif (sum == n / 2) {\n\t\tans = max(ans, getNum());\n\t\treturn;\n\t}\n\tif (vis[num]) dfs(num + 1, sum);\n\telse {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (vis[i] == 1 || i == num) continue;\n\t\t\tvis[i] = 1;\n\t\t\tvis[num] = 1;\n\t\t\tline[sum].x = point[i].x - point[num].x;\n\t\t\tline[sum].y = point[i].y - point[num].y;\n\t\t\tdfs(num + 1, sum + 1);\n\t\t\tvis[i] = 0;\n\t\t\tvis[num] = 0;\n\t\t}\n\t}\n}\nint main()\n{\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> point[i].x >> point[i].y;\n\tdfs(0, 0);\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint m,x[16],y[16],dp[1<<16];\nbool s[1<<16][16][16],f[1<<16];\nint hei(int a,int b,int c,int d){return a*d-b*c;}\n\nint main(){\n  cin>>m;\n  for(int i=0;i<m;i++)cin>>x[i]>>y[i];\n  s[0][0][1]=1;\n  for(int i=0;i<1<<m;i++){\n    for(int a=0;a<m;a++)\n      for(int b=a+1;b<m;b++)\n\tif(s[i][a][b])\n\t  for(int c=0;c<m;c++)\n\t    if(!(i&1<<c))\n\t      for(int d=c+1;d<m;d++)\n\t\tif(!(i&1<<d))\n\t\t  if(!i||hei(x[a]-x[b],y[a]-y[b],x[c]-x[d],y[c]-y[d])==0)\n\t\t    s[i|1<<c|1<<d][c][d]=1;\n    for(int j=0;j<m;j++)\n      for(int k=j+1;k<m;k++)if(s[i][j][k])f[i]=1;\n  }\n  memset(dp,-1,sizeof(dp));\n  dp[0]=0;\n  int ans=0;\n  for(int i=0;i<1<<m;i++)\n    if(dp[i]!=-1)\n      for(int j=0;j<1<<m;j++){\n\tif(!(i&j)&&f[j]){\n\t  int a=__builtin_popcount(j)/2;\n\t  ans=max(ans,dp[i|j]=max(dp[i|j],dp[i]+a*(a-1)/2));\n\t}\n      }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\n#define EPS 1e-6\n\nvector<pair<int,int> > v;\nint n;\nint ans;\nint comb[10][10];\n\nbool equal(pair<double,double> a,pair<double,double> b)\n{\n\treturn ((abs(a.FI - b.FI) < EPS && abs(a.SE - b.SE) < EPS)?true:false);\n}\n\nvoid check(vector<pair<int,int> > p)\n{\n\tvector<pair<double,double> > tmp;\n\tREP(i,p.size()/2)\n\t{\n\t\tint j = i*2;\n\t\tpair<double,double> a,b,c;\n\t\ta = p[j];b = p[j+1];\n\t\tc.FI = a.FI - b.FI;\n\t\tc.SE = a.SE - b.SE;\n\t\tdouble l = sqrt(c.FI*c.FI + c.SE*c.SE);\n\t\tc.FI /= l;c.SE /= l;\n\t\tif(c.FI < 0)\n\t\t{\n\t\t\tc.FI = -(c.FI);\n\t\t\tc.SE = -(c.SE);\n\t\t}\n\t\ttmp.PB(c);\n\t}\n\t\n\tint ret = 0;\n\tREP(i,tmp.size())\n\t{\n\t\tint cou = 0;\n\t\twhile(i < tmp.size()-1 && equal(tmp[i],tmp[i+1])) \n\t\t{\n\t\t\ti++;cou++;\n\t\t}\n\t\tif(cou)ret += comb[cou+1][2];\n\t}\n\tans = max(ans,ret);\n}\n\nvoid dfs(int num,vector<bool> memo,vector<pair<int,int> > p)\n{\n\tif(num <= 1)\n\t{\n\t\tcheck(p);\n\t\treturn;\n\t}\n\t\n\tint tmp = 0;\n\twhile(memo[tmp])tmp++;\n\tp.PB(v[tmp]);\n\tmemo[tmp] = true;\n\t\n\tfor(int i = tmp+1;i < n;i++)\n\t{\n\t\tif(!memo[i])\n\t\t{\n\t\t\tvector<pair<int,int> > P = p;\n\t\t\tvector<bool> ME = memo;\n\t\t\tP.PB(v[i]);\n\t\t\tME[i] = true;\n//\t\t\tSHOW1d(ME,n);\n\t\t\tdfs(num-2,ME,P);\n\t\t}\n\t}\n\t\n}\n\nint main()\n{\n\tREP(i,10)comb[i][i] = comb[i][0] = 1;\n\tREP(i,10)\n\t{\n\t\tfor(int j = 1;j < i;j++)comb[i][j] = comb[i-1][j] + comb[i-1][j-1];\n\t}\n\t\n\tSHOW2d(comb,8,8);\n\t\n\tcin >> n;\n\tREP(i,n)\n\t{\n\t\tint a,b;cin >> a >> b;\n\t\tv.PB(MP(a,b));\n\t}\n\t\n\tvector<bool> memo(16);\n\tvector<pair<int,int> > p;\n\tdfs(n,memo,p);\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nusing P=complex<ld>;\nstruct Line{\n    P a,b;\n};\nvector<P> ps;\nint m;\nconst ld EPS=1e-9;\nld cross(P a,P b){\n    return a.real()*b.imag()-a.imag()*b.real();\n}\nint solve(int id,vector<int> flag){\n    if(id==m){\n        \n        vector<Line> lines(m/2);\n        for(int i=1;i<=m/2;i++){\n            for(int j=0;j<m;j++){\n                if(flag[j]==i){\n                    lines[i-1].a=ps[j];\n                    j++;\n                    for(;j<m;j++){\n                        if(flag[j]==i){\n                            lines[i-1].b=ps[j];\n                            break;\n                        }\n                        \n                    }\n                    break;\n                }\n            }\n        }    \n        int res=0;\n        for(int i=0;i<m/2;i++){\n            for(int j=0;j<i;j++){\n                if(abs(cross(lines[i].a-lines[i].b,lines[j].a-lines[j].b))<EPS){\n                    res++;\n                }\n            }\n        }  \n\n        return res;\n    }\n    if(flag[id]) return solve(id+1,flag);\n    int res=0;\n    int nex=1+*max_element(flag.begin(),flag.end());\n    flag[id]=nex;\n    for(int i=id+1;i<m;i++){\n        if(!flag[i]){\n            flag[i]=nex;\n            res=max(res,solve(id+1,flag));\n            flag[i]=0;\n        }\n    }\n    return res;\n}\nint main(){\n    cin>>m;\n    ps.resize(m);\n    for(int i=0;i<m;i++){\n        int x,y; cin>>x>>y;\n        ps[i]={x,y};\n    }\n    vector<int> flag(m);\n    cout<<solve(0,flag)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <stack>\nusing namespace std;\n#define debug(x) std::cerr << #x << \" = \" << (x) << std::endl\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst int MAXN = 25;\n\nmap<PII, int> pos;\n\nint n, ans;\nint x[MAXN+5], y[MAXN+5];\nbool vis[MAXN + 5];\nint dp[70000], cnt[70000][400];\n\nint gcd(int x, int y){\n\tif(y == 0) return x;\n\telse return gcd(y, x % y);\n}\n\nPII solve(int x_1, int x_2, int y_1, int y_2){\n\tint dx = x_1 - x_2; int dy = y_1 - y_2;\n\tif(dx == 0){ return PII(-1, 0);}\n\telse if(dy == 0){return PII(0, -1);}\n\telse if(dx < 0 && dy > 0){\n\t\tint Gcd = gcd(-dx, dy);\n\t\tdx /= Gcd; dy /= Gcd;\n\t}\n\telse if(dx > 0 && dy < 0){\n\t\tint Gcd = gcd(dx, -dy);\n\t\tdx = -(dx / Gcd); dy = -(dy / Gcd);\n\t}\n\telse{\n\t\tdx = abs(dx), dy = abs(dy);\n\t\tint Gcd = gcd(dx, dy);\n\t\tdx /= Gcd; dy /= Gcd;\n\t}\n\treturn PII(dx, dy);\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++) scanf(\"%d %d\", &x[i], &y[i]);\n\tint tot = 0;\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = i + 1; j <= n; j++) {\n\t\t\tPII tmp = solve(x[i], x[j], y[i], y[j]);\n\t\t\tif(!pos[tmp]) pos[tmp] = ++tot;\n\t\t}\n\tfor(int i = 0; i < (1 << n); i++) {\n\t\tint cnt1 = 0;\n\t\tfor(int j = 1; j <= n; j++) vis[j] = 0;\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tif(i & (1 << j)) vis[j + 1] = 1, cnt1++;\n\t\tif(!(cnt1 & 1)) {\n\t\t\tfor(int v1 = 1; v1 <= n; v1++)\n\t\t\t\tfor(int v2 = v1 + 1; v2 <= n; v2++)\n\t\t\t\t\tif(!vis[v1] && !vis[v2]) {\n\t\t\t\t\t\tint p = i;\n\t\t\t\t\t\tp |= (1 << (v1 - 1));\n\t\t\t\t\t\tp |= (1 << (v2 - 1));\n\t\t\t\t\t\tint c = pos[solve(x[v1], x[v2], y[v1], y[v2])];\n\t\t\t\t\t\tif(dp[i] + cnt[i][c] >= dp[p]) {\n\t\t\t\t\t\t\tfor(int r = 1; r <= tot; r++) cnt[p][r] = cnt[i][r];\n\t\t\t\t\t\t\tcnt[p][c] += 1;\n\t\t\t\t\t\t\tdp[p] = dp[i] + cnt[i][c];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[(1 << n) - 1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nint n;\nvi xs, ys;\n\nconst int M = 10000;\ninline void f(int& sx, int& sy){\n    assert(sx != 0 or sy != 0);\n\n    if(sx == 0){\n        sy = M;\n    }\n    else if(sy == 0){\n        sx = M;\n    }\n    else {\n        int g = __gcd(abs(sx), abs(sy));\n        sx /= g;\n        sy /= g;\n    }\n}\n\nvi used;\nusing P = tuple<int, int>;\nusing A = tuple<int, int>;\n\nset<A> s;\nmap<A, int> dic;\n\ninline int comb(int x){\n    if(x <= 1) return 0;\n    return x * (x - 1) / 2;\n}\n\nint dfs(int d){\n    if(d == n){\n        int cur = 0;\n        for(auto& e : s){\n            cur += comb(dic[e]);\n        }\n        return cur;\n    }\n\n    if(used[d]) return dfs(d + 1);\n    used[d] = true;\n\n    int ret = 0;\n    rep(nd, d + 1, n){\n        if(used[nd]) continue;\n        used[nd] = true;\n        int sx = xs[nd] - xs[d];\n        int sy = ys[nd] - ys[d];\n        f(sx, sy);\n        A a = A(sx, sy);\n        s.insert(a);\n        dic[a]++;\n\n        chmax(ret, dfs(d + 1));\n\n        used[nd] = false;\n        if(--dic[a] == 0){\n            s.erase(a);\n        }\n    }\n    used[d] = false;\n\n    return ret;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> n;\n    vector<P> in(n);\n    rep(i, n){\n        int x, y; cin >> x >> y;\n        in[i] = P(x, y);\n    }\n    sort(_all(in));\n\n    xs = ys = vi(n);\n    rep(i, n){\n        int x, y; tie(x, y) = in[i];\n        xs[i] = x, ys[i] = y;\n    }\n\n    used = vi(n);\n    cout << dfs(0) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nint sum[1 << 16];\nint dp[1 << 16];\n\nint x[16], y[16];\n\nbool is_parallel(int a, int b, int c, int d) {\n\treturn (y[b] - y[a])*(x[d] - x[c]) == (x[b] - x[a])*(y[d] - y[c]);\n}\nvoid solve() {\n\tint n; cin >> n;\n\trep(i, n)cin >> x[i] >> y[i];\n\n\trep(i, (1 << n)) {\n\t\trep(j, n) {\n\t\t\tif (i&(1<<j))continue;\n\t\t\tRep(k, j + 1, n) {\n\t\t\t\tif (i&(1<<k))continue;\n\t\t\t\tvector<bool> used(n);\n\t\t\t\trep(l, n)if (i&(1 << l))used[l] = true;\n\t\t\t\tqueue<int> q; q.push(i);\n\t\t\t\tint cnt = 0;\n\t\t\t\trep(l, n) {\n\t\t\t\t\tif (used[l])continue;\n\t\t\t\t\tused[l] = true;\n\t\t\t\t\tvector<int> al = { l };\n\t\t\t\t\tRep(m, l + 1, n) {\n\t\t\t\t\t\tif (used[m])continue;\n\t\t\t\t\t\tif (is_parallel(j, k, l, m)) {\n\t\t\t\t\t\t\tal.push_back(m); used[m] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcnt += al.size() / 2;\n\t\t\t\t\tif (al.size() >= 2) {\n\t\t\t\t\t\tint xsum = 0;\n\t\t\t\t\t\trep(m, al.size()) {\n\t\t\t\t\t\t\txsum ^= (1 << al[m]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint len = q.size();\n\t\t\t\t\t\trep(aa, len) {\n\t\t\t\t\t\t\tint id = q.front(); q.pop();\n\t\t\t\t\t\t\tif (al.size() % 2) {\n\t\t\t\t\t\t\t\trep(m, al.size()) {\n\t\t\t\t\t\t\t\t\tint zsum = xsum ^ (1 << al[m]);\n\t\t\t\t\t\t\t\t\tq.push(id^zsum);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tq.push(id^xsum);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (!q.empty()) {\n\t\t\t\t\tint s = q.front(); q.pop();\n\t\t\t\t\tdp[s] = max(dp[s], dp[i] + cnt*(cnt-1)/2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i, (1 << n))ans = max(ans, dp[i]);\n\tcout << ans << endl;\n\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,double> LP;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define all(x) x.begin(),x.end()\n#define maxch(x,y) x=max(x,y)\n\n#define inf 1e16\n\nll n;\nll x[1010],y[1010];\nmap<double,vector<P> > vs;\nvector<ll> a,b;\n\nll dp[300][1<<16];\n\nint main(){\n  cin>>n;\n  rep(i,n)cin>>x[i]>>y[i];\n  rep(i,n)rep(j,i){\n    ll dx=x[i]-x[j];\n    ll dy=y[i]-y[j];\n    /*\n    ll pdx=dx<0?-dx:dx;\n    ll pdy=dy<0?-dy:dy;\n    dbg(pdx); dbg(pdy);\n    ll g=__gcd(pdx,pdy);\n    dbg(pdx); dbg(pdy);\n    dbg(g);\n    P tmp;\n    if(dy<0) tmp=P(-dx/g,-dy/g);\n    else tmp=P(dx/g,dy/g);\n    */\n    if(dy!=0)vs[(double)dx/(double)dy].push_back(P(i,j));\n    else vs[dx<0?-inf:inf].push_back(P(i,j));\n  }\n\n  for(auto it : vs){\n    a.push_back(it.se.size()*(it.se.size()-1)/2);\n    ll tmp=0;\n    rep(i,it.se.size()){\n      tmp|=1<<it.se[i].fi;\n      tmp|=1<<it.se[i].se;\n    }\n    b.push_back(tmp);\n  }\n  ll m=a.size();\n\n  rep(i,m){\n    rep(S,1<<n){\n      maxch(dp[i+1][S],dp[i][S]);\n      if((S&b[i])==b[i])maxch(dp[i+1][S^b[i]],dp[i][S]+a[i]);\n    }\n  }\n\n  ll res=0;\n  rep(S,1<<n){\n    maxch(res,dp[m][S]);\n  }\n  cout<<res<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\nconst int maxn = 2e3+5;\nstruct Node\n{\n    int x,y;\n} node[20];\nint n;\nint ans;\nint vis[20];\nint num[maxn][maxn][2];\nint gcd(int a,int b)\n{\n    int c = 1;\n    while(b)\n    {\n        c = b;\n        b = a%b;\n        a = c;\n    }\n    return a;\n}\nint get(int x,int y,int &a,int &b,int &c)\n{\n    if(x==0)\n    {\n        a= 0;\n        b= 0;\n        c = 0;\n    }\n    else if(y==0)\n    {\n        a = 0;\n        b = 0;\n        c = 1;\n    }\n    else if(x<0)\n    {\n        int cc = gcd(x,y);\n        a = abs(x/cc);\n        b = abs(y/cc);\n        if(y<0)\n            c = 0;\n        else\n            c = 1;\n    }\n    else\n    {\n        int cc = gcd(x,y);\n        a = abs(x/cc);\n        b = abs(y/cc);\n        if(y>0)\n            c = 0;\n        else\n            c = 1;\n    }\n}\nvoid dfs(int t,int res,int cnt)\n{\n    if(cnt>n/2)\n    {\n        return ;\n    }\n    if(t>=n)\n    {\n        return ;\n    }\n//    if(res + (n-t)/2 <= ans)\n//        return ;\n    if(vis[t])\n    {\n        dfs(t+1,res,cnt);\n        return ;\n    }\n    vis[t] = cnt;\n    for(int i=0; i<n; i++)\n    {\n        if(vis[i])\n            continue;\n        vis[i] = cnt;\n        int x =  node[i].x - node[t].x;\n        int y = node[i].y - node[t].y;\n        int nr = 0;\n        int a=0,b=0,c=0;\n        get(x,y,a,b,c);\n        nr = num[a][b][c];\n        num[a][b][c]++;\n        //cout<<ans<<endl;\n        ans = max(ans,res+nr);\n//        if(cnt+1>n/2)\n//            return ;\n        dfs(t+1,res+nr,cnt+1);\n        vis[i] = 0;\n        num[a][b][c]--;\n    }\n    vis[t] = 0;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=0; i<n; i++)\n        scanf(\"%d%d\",&node[i].x,&node[i].y);\n    ans=0;\n   // memset(vis,0,sizeof(vis));\n   // memset(num,0,sizeof(num));\n    dfs(0,0,1);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nbool parallel(const pair<P, P>& l1, const pair<P, P>& l2)\n{\n    const ll dx1 = l1.first.first - l1.second.first;\n    const ll dx2 = l2.first.first - l2.second.first;\n    const ll dy1 = l1.first.second - l1.second.second;\n    const ll dy2 = l2.first.second - l2.second.second;\n    return dx2 * dy1 == dx1 * dy2;\n}\n\nint m;\nll rec(const ll used, const vector<ll>& x, const vector<ll>& y, vector<pair<P, P>>& pairs)\n{\n    if (pairs.size() == m / 2) {\n        ll sum = 0;\n        //        show(pairs);\n        const int size = pairs.size();\n        for (int i = 0; i < size; i++) {\n            for (int j = i + 1; j < size; j++) {\n                if (parallel(pairs[i], pairs[j])) {\n                    sum++;\n                }\n            }\n        }\n        return sum;\n    } else {\n        int head = 0;\n        for (head = 0; head < m; head++) {\n            if ((used & (1LL << head)) == 0) {\n                break;\n            }\n        }\n        ll maxi = 0;\n        for (int i = head + 1; i < m; i++) {\n            vector<pair<P, P>> p = pairs;\n            if ((used & (1LL << i)) == 0) {\n                p.push_back(make_pair(make_pair(x[head], y[head]), make_pair(x[i], y[i])));\n                maxi = max(maxi, rec(used | (1LL << head) | (1LL << i), x, y, p));\n            }\n        }\n        return maxi;\n    }\n}\n\nint main()\n{\n    cin >> m;\n    vector<ll> x(m);\n    vector<ll> y(m);\n    for (int i = 0; i < m; i++) {\n        cin >> x[i] >> y[i];\n    }\n    vector<pair<P, P>> pairs;\n    cout << rec(0, x, y, pairs) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\nconst int INF = 1001001001001001LL;\nconst int MOD = 1000000007;\n\nint di[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nint dj[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nvoid dfs(vector<int> &x, vector<int> &y, vector<int> &result, int &ans, int n){\n    \n    int len = (int)x.size();\n    if(n == 0){\n        int tmp = 0;\n        // 個数数え挙げて ans を更新\n        vector<pair<int, int>> vp;\n        for(int i = 0; i < len; i++){\n            for(int j = i + 1; j < len; j++){\n                if(result[i] == result[j]){\n                    vp.push_back({i, j});\n                }\n            }\n        }\n        \n    \n        for(int i = 0; i < (int)vp.size(); i++){\n            for(int j = i + 1; j < (int)vp.size(); j++){\n                \n                int x1 = x[vp[i].first] - x[vp[i].second];\n                int y1 = y[vp[i].first] - y[vp[i].second];\n                \n                int x2 = x[vp[j].first] - x[vp[j].second];\n                int y2 = y[vp[j].first] - y[vp[j].second];\n                if(x1 * y2 - x2 * y1 == 0) tmp++;\n            }\n        }\n        ans = max(ans, tmp);\n\n    }else{\n        \n        int u = 0;\n        for(int i = 0; i < len; i++){\n            if(result[i] == -1){\n                u = i;\n                break;\n            }\n        }\n\n        for(int v = u + 1; v < len; v++){\n            if(result[v] != -1) continue;\n            result[u] = n;\n            result[v] = n;\n            dfs(x, y, result, ans, n - 2);\n            result[u] = -1;\n            result[v] = -1;\n        }\n    }\n}\n\nsigned main(){\n    \n    int n; cin >> n;\n    vector<int> x(n);\n    vector<int> y(n);\n    for(int i = 0; i < n; i++) cin >> x[i] >> y[i];\n    vector<int> result(n, -1);\n\n    int ans = 0;\n    dfs(x, y, result, ans, n);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\n\nP get_a(int x1, int y1, int x2, int y2){\n    if(y2 < y1){\n        swap(x1, x2);\n        swap(y1, y2);\n    }\n    int x = x2 - x1, y = y2 - y1;\n    if(y == 0) return P(1, 0);\n    else if(x == 0) return P(0, 1);\n\n    int gcd = __gcd(abs(x), y);\n    return P(x / gcd, y / gcd);\n}\n\nint x[17], y[17];\nP a[17][17];\nint dp[1 << 17];\n\nint main(){\n    int n;\n    cin >> n;\n\n    vector<int> x(n), y(n);\n    for(int i=0;i<n;i++){\n        cin >> x[i] >> y[i];\n    }\n\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            a[i][j] = get_a(x[i], y[i], x[j], y[j]);\n            a[j][i] = a[i][j];\n        }\n    }\n\n    map<P, vector<P>> para_pairs;\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            if(para_pairs.count(a[i][j]) > 0) continue;\n            vector<P> pairs;\n            for(int k=0;k<n;k++){\n                for(int l=k+1;l<n;l++){\n                    if(a[i][j] == a[k][l]){\n                        pairs.emplace_back(k, l);\n                    }\n                }\n            }\n            para_pairs[a[i][j]] = pairs;\n        }\n    }\n\n    memset(dp, 0, sizeof(dp));\n    for(int i=0;i<(1 << n);i++){\n        for(auto& e : para_pairs){\n            int cnt = 0;\n            int bit = 0;\n            for(P& p : e.second){\n                int pair_bit = (1 << p.first) | (1 << p.second);\n                if(i&pair_bit) continue;\n                bit |= pair_bit;\n                cnt++;\n            }\n            if(cnt > 0){\n                dp[i | bit] = max(dp[i | bit], dp[i] + cnt * (cnt - 1) / 2);                \n            }\n        }\n    }\n    cout << dp[(1 << n) - 1] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,double> LP;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define all(x) x.begin(),x.end()\n#define maxch(x,y) x=max(x,y)\n\n#define inf 1e16\n\nll n;\nll x[1010],y[1010];\nmap<double,vector<P> > vs;\nvector<ll> a,b;\n\nll dp[300][1<<16];\n\nint main(){\n  cin>>n;\n  rep(i,n)cin>>x[i]>>y[i];\n  rep(i,n)rep(j,i){\n    ll dx=x[i]-x[j];\n    ll dy=y[i]-y[j];\n\n    if(dx==0){\n      vs[inf].push_back(P(i,j));\n    }else if(dy==0){\n      vs[0].push_back(P(i,j));\n    }else{\n      /*\n      ll pdx=dx<0?-dx:dx;\n      ll pdy=dy<0?-dy:dy;\n      ll g=__gcd(pdx,pdy);\n\n      if(dx<0)vs[P(-dx/g,-dy/g)].push_back(P(i,j));\n      else vs[P(dx/g,dy/g)].push_back(P(i,j));\n      */\n      vs[(double)dy/(double)dx].push_back(P(i,j));\n    }\n  }\n\n  for(auto it : vs){\n    a.push_back(it.se.size()*(it.se.size()-1)/2);\n    ll tmp=0;\n    rep(i,it.se.size()){\n      tmp|=1<<it.se[i].fi;\n      tmp|=1<<it.se[i].se;\n    }\n    b.push_back(tmp);\n  }\n  ll m=a.size();\n\n  rep(i,m){\n    rep(S,1<<n){\n      maxch(dp[i+1][S],dp[i][S]);\n      if((S&b[i])==b[i])maxch(dp[i+1][S^b[i]],dp[i][S]+a[i]);\n    }\n  }\n\n  ll res=0;\n  rep(S,1<<n){\n    maxch(res,dp[m][S]);\n  }\n  cout<<res<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// B\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <string>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n#include <cassert>\n#include <cinttypes>\nconst double EPS = 1e-10;\n#define equals(a,b) (fabs((a) - (b)) < EPS)\n\nusing namespace std;\n\ntypedef int64_t ll;\ntypedef uint64_t ull;\n\ntypedef pair<ll, ll> P;\ninline P operator+(const P& p1, const P& p2) {\n  return P(p1.first + p2.first, p1.second + p2.second);\n}\n\nstruct Point {\n  double x,y;\n  Point operator - (const Point& p){ return Point{x - p.x, y - p.y};}\n};\n\ntypedef Point Vector;\n\ndouble cross(Vector a, Vector b){return a.x*b.y - a.y*b.x;}\nbool isParallel(Vector a, Vector b) {\n  return equals(cross(a,b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1-a2, b1-b2);\n}\n\nint M;\nPoint p[20];\nbool ispara[20][20][20][20];\nint seg[8];\nint ans;\n\n\nvoid dfs(int depth){\n  if (depth == M / 2) {\n    int res = 0;\n    for (int i = 0; i < M / 2; i++) {\n      int i_p[2], ct = 0;\n      for(int bit = 0; bit < M && ct < 2; bit++){\n        if(seg[i] & (1 << bit)){\n          i_p[ct++] = bit;\n        }\n      }\n      for (int j = i + 1; j < M / 2; j++) {\n        int j_p[2], jct = 0;\n        for(int bit = 0; bit < M && jct < 2; bit++){\n          if(seg[j] & (1 << bit)){\n            j_p[jct++] = bit;\n          }\n        }\n        if(ispara[i_p[0]][i_p[1]][j_p[0]][j_p[1]]) res++;\n      }\n    }\n    ans = max(res, ans);\n    return;\n  }\n  int i = 0;\n  if (depth > 0) {\n    while(true){\n      bool isinc = false;\n      for (int j = 0; j < depth; j++) {\n        if (seg[j] & (1 << i)){\n          isinc = true;\n          break;\n        }\n      }\n      if(isinc) i++;\n      else break;\n    }\n  }\n  seg[depth] |= (1 << i);\n  for (int j = i + 1; j < M; j++) {\n    bool isinc = false;\n    for (int k = 0; k < depth; k++) {\n      if (seg[k] & (1 << j)){\n        isinc = true;\n        break;\n      }\n    }\n    if(isinc) continue;\n    seg[depth] |= (1 << j);\n    dfs(depth + 1);\n    seg[depth] ^= (1 << j);\n  }\n  seg[depth] ^= (1 << i);\n}\n\nint main() {\n  cin.tie(0), cout.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> M;\n  for(int i = 0; i < M; i++) cin >> p[i].x >> p[i].y;\n\n  for (int i = 0; i < M; i++) {\n    for (int j = 0; j < M; j++) {\n      if(i == j) continue;\n      for (int k = 0; k < M; k++) {\n        if(k == j || k == i) continue;\n        for (int l = 0; l < M; l++) {\n          if(i == l || j == l || k == l) continue;\n          ispara[i][j][k][l] = isParallel(p[i], p[j], p[k], p[l]);\n        }\n      }\n    }\n  }\n  dfs(0);\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst int inf=1e9+3;\nconst double eps=1e-10;\ntemplate <class T> inline void read(T &x) {\n    int t;\n    bool flag = false;\n    while((t = getchar()) != '-' && (t < '0' || t > '9')) ;\n    if(t == '-') flag = true, t = getchar(); x = t - '0';\n    while((t = getchar()) >= '0' && t <= '9') x = x * 10 + t - '0';\n    if(flag) x = -x;\n}\ndouble k[350];\nint cnt;\nvector<int> vertex[350];\nint inlinex(double kk)\n{\n    for(int i=0;i<cnt;i++)\n    {\n        if(fabs(k[i]-kk)<eps) return i;\n    }\n    return cnt;\n}\nint main(){\n    int n,use[20]={},maxtt=88,sum=0,maxpos;\n    double x[20],y[20];\n    cin>>n;\n    for(int i=0;i<n;i++) cin>>x[i]>>y[i];\n    while(maxtt>1)\n    {\n        maxtt=0;\n        maxpos=-1;\n        for(int i=0;i<cnt;i++) vertex[i].clear();\n        cnt=0;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                if(use[i]||use[j]) continue;\n                else\n                {\n                    int nb=inlinex((x[i]-x[j])/(y[i]-y[j]));\n                    if(nb==cnt)\n                    {k[cnt]=(x[i]-x[j])/(y[i]-y[j]);cnt++;}\n                    vertex[nb].push_back(i);\n                    vertex[nb].push_back(j);\n                }\n            }\n        }\n        for(int i=0;i<cnt;i++)\n        {\n            if(vertex[i].size()/2>maxtt)\n            {\n                maxtt=vertex[i].size()/2;\n                maxpos=i;\n            }\n        }\n        sum=sum+maxtt*(maxtt-1)/2;\n        for(int i=0;i<vertex[maxpos].size();i++) use[vertex[maxpos][i]]=1;\n    }\n    cout<<sum<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, X[16], Y[16];\n\nbool isparallel(int a, int b, int c, int d)\n{\n  auto dx1 = X[a] - X[b];\n  auto dy1 = Y[a] - Y[b];\n  auto dx2 = X[c] - X[d];\n  auto dy2 = Y[c] - Y[d];\n  return (dx1 * dy2 == dy1 * dx2);\n}\n\nbool matched[16];\n\nint rec(int);\n\nint parallel_rec(int latte, int malta, int idx, int sz)\n{\n  if(idx == N) {\n    return (rec(latte + 1));\n  }\n  if(matched[idx]) {\n    return (parallel_rec(latte, malta, idx + 1, sz));\n  }\n  int ret = parallel_rec(latte, malta, idx + 1, sz);\n  for(int j = idx + 1; j < N; j++) {\n    if(matched[j]) continue;\n    if(isparallel(latte, malta, idx, j)) {\n      matched[idx] = true;\n      matched[j] = true;\n      ret = max(ret, parallel_rec(latte, malta, idx + 1, sz + 1) + sz);\n      matched[j] = false;\n      matched[idx] = false;\n    }\n  }\n  return (ret);\n}\n\nint rec(int idx)\n{\n  if(idx == N) {\n    return (0);\n  }\n  if(matched[idx]) {\n    return (rec(idx + 1));\n  }\n  int ret = rec(idx + 1);\n  for(int j = idx + 1; j < N; j++) {\n    if(matched[j]) continue;\n    matched[idx] = true;\n    matched[j] = true;\n    ret = max(ret, parallel_rec(idx, j, 0, 1));\n    matched[j] = false;\n    matched[idx] = false;\n  }\n  return (ret);\n}\n\nint main()\n{\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    cin >> X[i] >> Y[i];\n  }\n  cout << rec(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define F first\n#define S second\n#define pii pair<int, int>\n#define eb emplace_back\n#define all(v) v.begin(), v.end()\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep3(i, l, n) for (int i = l; i < (n); ++i)\n#define sz(v) (int)v.size()\n#define inf (int)(1e9+7)\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<typename T> T gcd(T a, T b) { if (b == 0) return a; return gcd(b, a % b); }\n\n\n\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3968082#2\n// bit dpで書いてみる\n// dfsをdpで書くということ\n// 上のコードは以下を参考にした\n// http://kyopro.hateblo.jp/entry/2018/02/12/080534\n\n\nint m;\nint ans;\nvector<pii> v(20);\n\npii incline(int i, int j) {\n    pii s;\n    s.F = v[j].S - v[i].S;\n    s.S = v[j].F - v[i].F;\n    int g = gcd(s.F, s.S);\n    s.F /= g;\n    s.S /= g;\n    if (s.S < 0) { s.S = -s.S; s.F = -s.F; }\n    return s;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    \n    cin >> m;\n    rep(i, m) cin >> v[i].F >> v[i].S;\n    \n    int dp[1 << 20] = {0};\n    \n    rep(bit, 1 << m) {\n        rep(i, m) {\n            if (bit & (1 << i)) continue;\n            rep3(j, i + 1, m) {\n                if (bit & (1 << j)) continue;\n                pii s = incline(i, j);\n                int B = bit | (1 << i);\n                B |= (1 << j);\n                int num = 1;\n                rep(k, m) {\n                    if (B & (1 << k)) continue;\n                    rep3(l, k + 1, m) {\n                        if (B & (1 << l)) continue;\n                        pii t = incline(k, l);\n                        if (s != t) continue;\n                        B |= (1 << k); B |= (1 << l);\n                        num++;\n                        // cout << endl << i << \" \" << j << \" \" << k << \" \" << l << \" \" << endl << s.F << \" \" << s.S << \" \" << t.F << \" \" << t.S << endl;\n                    }\n                }\n                if (num == 1) continue;\n                chmax(dp[B], dp[bit] + num * (num - 1) / 2);\n            }\n            \n        }\n    }\n    int ans = 0;\n    rep(i, 1 << m) chmax(ans, dp[i]);\n    cout << ans << endl;\n    // rep(i, 1 << m) cout << dp[i] << \" \"; cout << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\n\nint n;\nvector<P> ps;\n\nint gcd(int a, int b) {\n    while (b > 0) {\n        int t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nint cnt(const map<P, int>& mp) {\n    int ret = 0;\n    for (auto& i : mp)\n        ret += i.second * (i.second - 1) / 2;\n\n    return ret;\n}\n\nP getpair(int i, int j) {\n    int dx = ps[j].first - ps[i].first;\n    int dy = ps[j].second - ps[i].second;\n    int g = gcd(abs(dx), abs(dy));\n    dx /= g;\n    dy /= g;\n    if (dx > 0 || dx == 0 && dy >= 0)\n        return P(dx, dy);\n    else\n        return P(-dx, -dy);\n}\n\nint dfs(int s, map<P, int>& mp) {\n    if (s == 0) return cnt(mp);\n    int fir = -1;\n    for (int i = 0; i < n; ++i) {\n        if ((s >> i) & 1) {\n            fir = i;\n            s ^= 1 << i;\n            break;\n        }\n    }\n    int ma = 0;\n    for (int i = 0; i < n; ++i) {\n        if ((s >> i) & 1) {\n            P p = getpair(i, fir);\n            ++mp[p];\n            ma = max(ma, dfs(s ^ (1 << i), mp));\n            --mp[p];\n        }\n    }\n    return ma;\n}\n\nint main() {\n    cin >> n;\n    ps = vector<P>(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> ps[i].first >> ps[i].second;\n    }\n    map<P, int> mp;\n    cout << dfs((1 << n) - 1, mp) << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, x[19], y[19], h[129][19][19], dp[65555][549]; bool vis[65555][549]; map<pair<int, int>, vector<pair<int, int> > > d; vector<vector<pair<int, int> > > v;\nint gcd(int pa, int pb) {\n\tif (pb == 0) return pa;\n\treturn gcd(pb, pa % pb);\n}\nint solve(int bit, int p1, int p2, int cur) {\n\tif (p1 == v.size()) return 0;\n\tif (p2 == v[p1].size()) {\n\t\tint res = solve(bit, p1 + 1, 0, 0);\n\t\treturn res + cur * (cur - 1) / 2;\n\t}\n\tif (vis[bit][h[p1][p2][cur]]) return dp[bit][h[p1][p2][cur]];\n\tint pa = v[p1][p2].first, pb = v[p1][p2].second;\n\tint ret = solve(bit, p1, p2 + 1, cur);\n\tif (!(bit & (1 << pa)) && !(bit & (1 << pb))) {\n\t\tint res = solve(bit | (1 << pa) | (1 << pb), p1, p2 + 1, cur + 1);\n\t\tret = max(ret, res);\n\t}\n\tvis[bit][h[p1][p2][cur]] = true;\n\tdp[bit][h[p1][p2][cur]] = ret;\n\treturn ret;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint vx = x[j] - x[i], vy = y[j] - y[i];\n\t\t\tif (vy < 0) vy = -vy, vx = -vx;\n\t\t\tint g = gcd(abs(vx), vy);\n\t\t\td[make_pair(abs(vx) / g * (vx > 0 ? 1 : -1), vy / g)].push_back(make_pair(i, j));\n\t\t}\n\t}\n\tfor (pair<pair<int, int>, vector<pair<int, int> > > i : d) {\n\t\tv.push_back(i.second);\n\t}\n\tint curs = 0;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tfor (int j = 0; j < v[i].size(); j++) {\n\t\t\tfor (int k = 0; k <= j; k++) {\n\t\t\t\th[i][j][k] = curs++;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = solve(0, 0, 0, 0);\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> pp;\ntypedef pair<ll, ll> pl;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\ninline bool is_parallel(pp l1, pp l2) {\n  return (l1.second.second-l1.first.second)*(l2.second.first-l2.first.first) == (l1.second.first-l1.first.first)*(l2.second.second-l2.first.second);\n}\n\nint n;\npi points[16];\nbool used[16];\nint ans = 0;\npp vl[8];\nint vl_l;\n\nvoid dfs(int cnt) {\n    rep(i,n) {\n        if (!used[i]) {\n            used[i] = true;\n            for (int j = i+1; j < n; j++) {\n                if (!used[j]) {\n                    used[j] = true;\n                    pp l = pp(points[i], points[j]);\n                    int now = cnt;\n                    rep(k,vl_l) {\n                        if (is_parallel(l, vl[k])) now++;\n                    }\n                    vl[vl_l++] = l;\n                    ans = max(ans,now);\n\n                    dfs(now);\n\n                    used[j] = false;\n                    vl_l--;\n                }\n            }\n            used[i] = false;\n            break;\n        }\n    }\n}\n\nvoid solve() {\n    cin >> n;\n    rep(i,n) {\n        int x, y; cin >> x >> y;\n        points[i] = pi(x,y);\n    }\n    memset(used,0,sizeof(used));\n    dfs(0);\n    cout << ans << endl;\n}\n\nint main() {\n#ifndef LOCAL\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n    cout.precision(20);\n    cerr << fixed;\n    cerr.precision(6);\n#ifdef LOCAL\n    //freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif  \n    solve();\n    //cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <math.h>\n#include <complex>\nusing ll = long long;\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\nint const MOD = 1e9 + 7;\n\nusing P = pair<int, int>;\n\nint m;\nll ans;\nint x[16], y[16];\nvector<P> v;\nbool used[16];\nvoid dfs()\n{\n    if (v.size() == m / 2)\n    {\n        ll cnt = 0;\n        for (int i = 0; i < v.size(); ++i)\n        {\n            for (int j = i + 1; j < v.size(); ++j)\n            {\n                int a = x[v[i].first] - x[v[i].second], b = y[v[i].first] - y[v[i].second],\n                    c = x[v[j].first] - x[v[j].second], d = y[v[j].first] - y[v[j].second];\n                if (a * d == b * c)\n                {\n                    cnt++;\n                    continue;\n                }\n                if (a * d == b * c)\n                {\n                    cnt++;\n                    continue;\n                }\n                a = -a;\n                b = -b;\n                if (a * d == b * c)\n                {\n                    cnt++;\n                    continue;\n                }\n                a = -a;\n                b = -b;\n                c = -c;\n                d = -d;\n                if (a * d == b * c)\n                {\n                    cnt++;\n                    continue;\n                }\n                a = -a;\n                b = -b;\n                if (a * d == b * c)\n                {\n                    cnt++;\n                    continue;\n                }\n            }\n        }\n        ans = max(ans, cnt);\n        return;\n    }\n    int i = 0;\n    while (used[i])\n        i++;\n    for (int j = i + 1; j < m; ++j)\n    {\n        if (!used[j])\n        {\n            v.push_back(P(i, j));\n            used[i] = used[j] = true;\n            dfs();\n\n            used[i] = used[j] = false;\n            v.pop_back();\n        }\n    }\n    return;\n}\nint main(void)\n{\n    cin >> m;\n    for (int i = 0; i < m; ++i)\n    {\n        cin >> x[i] >> y[i];\n    }\n    dfs();\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> P3;\ntypedef pair<P ,P> PP;\nconstexpr ll MOD = ll(1e9) + 7;\nconstexpr int IINF = INT_MAX;\nconstexpr ll LLINF = LLONG_MAX;\nconstexpr int MAX_N = int(1e5) + 5;\nconstexpr double EPS = 1e-8;\nconstexpr int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\nll ans = 0;\nvector<ll> x, y;\nvector<bool> used;\nmap<P,ll> cnt;\n\nll gcd(ll p, ll q){\n    if(q==0) return p;\n    else return gcd(q, p%q);\n}\n\nP calc_line(int i, int j){\n    ll dx, dy, g;\n    dx = x[i] - x[j];\n    dy = y[i] - y[j];\n    if(dx < 0){\n        dx *= -1;\n        dy *= -1;\n    }\n    else if(dx == 0){\n        dy = abs(dy);\n    }\n    g = gcd(abs(dx), abs(dy));\n    return P(dx/g, dy/g);\n}\n\nvoid rec(int i){\n    if(i<0){\n        ll sum = 0;\n        for(auto p : cnt){\n            ll c = p.second;\n            sum += c*(c-1)/2;\n        }\n        ans = max(ans, sum);\n    }\n    else if(used[i]) rec(i-1);\n    else{\n        used[i] = true;\n        for(int j=i-1;j>=0;j--){\n            if(used[j]) continue;\n            P line = calc_line(i,j);\n            used[j] = true;\n            cnt[line]++;\n            rec(i-1);\n            used[j] = false;\n            cnt[line]--;\n        }\n        used[i] = false;\n    }\n}\n\nint main() {\n    int m;\n    cin >> m;\n    x.resize(m);\n    y.resize(m);\n    used.resize(m);\n    for(int i=0;i<m;i++){\n        cin >> x[i] >> y[i];\n    }\n    rec(m-1);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconstexpr long double PI = acos(-1);\nconstexpr long double EPS = 1e-15;\nconstexpr int inf = 2e9;\nconstexpr ll INF = 2e18;\nconstexpr ll MOD = 1e9+7;\nconstexpr ll MOD1 = 998244353;\ntypedef pair<ll,ll> P;\n\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define rrep(i,a,b) for (int i = (a); i >= (b); i--)\n#define REP(i,n) rep(i,0,n)\n#define RREP(i,n) rrep(i,n,0)\n#define sz(s) (s).size()\n#define pb push_back\n#define fi first\n#define se second\n//#define mp make_pair\n\nint m;\nvector<pair<ll,ll>> a(16);\nint memo[(1<<16)];\nmap<pair<ll,ll>,int> mp;\n\nint f(int s) {\n  if (s == (1 << m) - 1) {\n    int ret = 0;\n    for (auto p:mp) {\n      ret += p.se * (p.se - 1) / 2;\n    }\n    return ret;\n  }\n  int cnt = 0;\n  for (int i = 0; i < m; i++) {\n    if ((s >> i) & 1) continue;\n    for (int j = i+1; j < m; j++) {\n      if ((s >> j) & 1) continue;\n      //cout << s << \" \" << i << \" \" << j << endl;\n      int x1 = a[i].fi, x2 = a[j].fi;\n      int y1 = a[i].se, y2 = a[j].se;\n      int xx = x2 - x1;\n      int yy = y2 - y1;\n      bool change = 0;\n      pair<ll,ll> p = {xx,yy};\n      for (auto k : mp) {\n        if (xx * k.fi.se == yy * k.fi.fi) {\n          p = k.fi;\n          change = 1;\n          break;\n        }\n      }\n      if (change) {\n        mp[p]++;\n        cnt = max(cnt, f(((s | (1 << i)) | (1 << j))));\n        mp[p]--;\n      } else {\n        mp[p]++;\n        cnt = max(cnt, f(((s | (1 << i)) | (1 << j))));\n        mp.erase(p);\n      }\n    }\n    break;\n  }\n  return cnt;\n}\n\nint main(){\n  cin >> m;\n  REP(i,m) {\n    cin >> a[i].fi >> a[i].se;\n  }\n  cout << f(0) << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n# define REP(i,n,N) for(int i=n;i<N;i++)\n# define p(S) cout<<S<<endl;\nusing namespace std;\nint ans;\nvector<pair<int, int>> vt;\nvector<int> vt2;\nint m;\n\nint product(pair<int, int> p1, pair<int, int> p2, pair<int, int> p3, pair<int, int> p4){\n    int x2 = p2.first - p1.first;\n    int y2 = p2.second - p1.second;\n    int x4 = p4.first - p3.first;\n    int y4 = p4.second - p3.second;\n    return x2 * y4 - x4 * y2;\n}\nbool used[20];\nvoid dfs(vector<pair<pair<int,int>, pair<int,int>>> &po){\n    if(po.size()==m/2){\n        int cnt=0;\n        for(int i=0;i<m/2-1;i++){\n            for(int j=i+1;j<m/2;j++){\n                if(product(po[i].first, po[i].second, po[j].first, po[j].second) == 0) cnt++;\n            }\n        }\n        ans = max(ans,cnt);\n        return;\n    }\n    int left;\n    for(int i=0;i<m; i++){\n        if(!used[i]){\n            used[i]=true;\n            left=i;\n            break;\n        }\n    }\n    for(int i=0;i<m;i++){\n        if(used[i]) continue;\n        used[i] = true;\n        po.emplace_back(vt[left], vt[i]);\n        dfs(po);\n        po.pop_back();\n        used[i]=false;\n    }\n    used[left]=false;\n}\nint main() {\n    cin>>m;\n    REP(i,0,m){\n        int x,y;\n        cin >> x >> y;\n        vt.emplace_back(x, y);\n    }\n    vector<pair<pair<int,int>, pair<int,int>>> tmp;\n    dfs(tmp);\n    p(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;(i)<(n);++(i))\nusing namespace std;\n\n#define fst first\n#define snd second\n\nint n, x[20], y[20];\n\nusing pii = pair<int, int>;\nvector<pii> ary;\n\ninline int det(pii a, pii b) {\n\tint ax = x[a.snd] - x[a.fst];\n\tint ay = y[a.snd] - y[a.fst];\n\tint bx = x[b.snd] - x[b.fst];\n\tint by = y[b.snd] - y[b.fst];\n\treturn ax * by - ay * bx;\n}\n\n\nint ans = 0;\n\nvoid dfs(int mask) {\n\tif (mask == (1 << n) - 1) {\n\t\tconst int m = ary.size();\n\t\tint cur = 0;\n\t\trep(j, m)rep(i, j) if (det(ary[i], ary[j]) == 0) cur++;\n\t\tans = max(ans, cur);\n\t}\n\n\tint low = -1;\n\trep(i, n) if (((mask >> i) & 1) == 0) low = i;\n\tmask |= (1 << low);\n\n\trep(i, n) {\n\t\tif (((mask >> i) & 1) == 0) {\n\t\t\tary.push_back(pii(low, i));\n\t\t\tdfs(mask | (1 << i));\n\t\t\tary.pop_back();\n\t\t}\n\t}\n}\n\nint main(void) {\n\tcin >> n;\n\trep(i, n) cin >> x[i] >> y[i];\n\tdfs(0);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <stack>\n#include <cstring>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nconst int maxN = 110;\n\n#define FORU(i, l, r) for (int i = l; i <= r; ++i)\n#define FORD(i, r, l) for (int i = r; i >= l; --i)\n#define REPU(i, r) for (int i = 0; i < r; ++i)\n#define F first\n#define S second\n#define PB push_back\n#define LL long long\n#define BIT(x, i) ((x >> i) & 1)\n\nint res, m, x[maxN], y[maxN];\nvector < int > idx1, idx2, idx;\nset < int > mset;\n\ndouble get_slope(int i, int j) {\n    return (x[i] == x[j] ? -1 : (1.0 * (y[i] - y[j])) / (x[i] - x[j]));\n}\n\nint cmp_slope(int i, int j) {\n    if (x[idx1[i]] == x[idx2[i]] &&\n        x[idx1[j]] == x[idx2[j]]) return 0;\n    if (x[idx1[i]] == x[idx2[i]]) return -1;\n    if (x[idx1[j]] == x[idx2[j]]) return 1;\n\n    int dxi = x[idx1[i]] - x[idx2[i]], dyi = y[idx1[i]] - y[idx2[i]];\n    int dxj = x[idx1[j]] - x[idx2[j]], dyj = y[idx1[j]] - y[idx2[j]];\n    if (dxi < 0) dxi *= (-1), dyi *= (-1);\n    if (dxj < 0) dxj *= (-1), dyj *= (-1);\n\n    if (dyi * dxj == dyj * dxi) return 0;\n    if (dyi * dxj < dyj * dxi) return -1;\n    return 1;\n}\n\nbool cmp(int i, int j) {\n    return (cmp_slope(i, j) == -1);\n}\n\nvoid solve(int t) {\n    if (t > (m / 2)) {\n        idx.clear();\n        REPU(i, idx1.size()) idx.PB(i);\n        sort(idx.begin(), idx.end(), cmp);\n        int num = 0, tmp = 0;\n        REPU(t, idx.size()) {\n            if (t && cmp_slope(idx[t], idx[t - 1]) != 0) {\n                tmp += (num * (num - 1)) / 2;\n                num = 0;\n            }\n            ++num;\n        }\n        tmp += (num * (num - 1)) / 2;\n        res = max(res, tmp);\n        return;\n    }\n    vector < int > arr; arr.clear();\n    for (auto i : mset) arr.PB(i);\n    idx1.PB(arr[0]);\n    mset.erase(arr[0]);\n    FORU(i, 1, arr.size() - 1) {\n        idx2.PB(arr[i]);\n        mset.erase(arr[i]);\n        solve(t + 1);\n        mset.insert(arr[i]);\n        idx2.pop_back();\n    }\n    mset.insert(arr[0]);\n    idx1.pop_back();\n}\n\nint main() {\n    cin >> m;\n    FORU(i, 1, m) {\n        cin >> x[i] >> y[i];\n        mset.insert(i);\n    }\n    solve(1);\n    cout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,double> LP;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define all(x) x.begin(),x.end()\n#define maxch(x,y) x=max(x,y)\n\n#define inf 1e16\n\nll n;\nll x[1010],y[1010];\nmap<P,vector<P> > vs;\nvector<ll> a,b;\n\nll dp[300][1<<16];\n\nint main(){\n  cin>>n;\n  rep(i,n)cin>>x[i]>>y[i];\n  rep(i,n)rep(j,i){\n    ll dx=x[i]-x[j];\n    ll dy=y[i]-y[j];\n\n    if(dx==0){\n      vs[P(0,inf)].push_back(P(i,j));\n    }else if(dy==0){\n      vs[P(0,0)].push_back(P(i,j));\n    }else{\n      ll pdx=dx<0?-dx:dx;\n      ll pdy=dy<0?-dy:dy;\n      ll g=__gcd(pdx,pdy);\n\n      if(dx<0)vs[P(-dx/g,-dy/g)].push_back(P(i,j));\n      else vs[P(dx/g,dy/g)].push_back(P(i,j));\n    }\n  }\n\n  for(auto it : vs){\n    a.push_back(it.se.size()*(it.se.size()-1)/2);\n    ll tmp=0;\n    rep(i,it.se.size()){\n      tmp|=1<<it.se[i].fi;\n      tmp|=1<<it.se[i].se;\n    }\n    b.push_back(tmp);\n  }\n  ll m=a.size();\n\n  rep(i,m){\n    rep(S,1<<n){\n      maxch(dp[i+1][S],dp[i][S]);\n      if((S&b[i])==b[i])maxch(dp[i+1][S^b[i]],dp[i][S]+a[i]);\n    }\n  }\n\n  ll res=0;\n  rep(S,1<<n){\n    maxch(res,dp[m][S]);\n  }\n  cout<<res<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<pair<int, int>>v(N);\n\tfor (auto &i : v)cin >> i.first >> i.second;\n\tvector<int>p(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tp[i] = i / (N / 2);\n\t}\n\tint ans = 0;\n\tvector<int>a(N/2);\n\tvector<int>b(N/2);\n\tvector<pair<int, int>>vp(N / 2);\n\tint ai = 0;\n\tint bi = 0;\n\tint box = 0;\n\tdo {\n\t\tai = 0;\n\t\tbi = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (p[i])a[ai++] = i;\n\t\t\telse b[bi++] = i;\n\t\t}\n\t\tdo {\n\t\t\tbool flag = false;\n\t\t\tfor (int i = 0; i < N / 2; i++) {\n\t\t\t\tvp[i] = { v[a[i]].first - v[b[i]].first,v[a[i]].second - v[b[i]].second };\n\t\t\t\tif (a[i] < b[i])flag = true;\n\t\t\t}\n\t\t\tif (flag)continue;\n\t\t\tbox = 0;\n\t\t\tfor (int i = 0; i < N / 2; i++) {\n\t\t\t\tfor (int j = i + 1; j < N / 2; j++) {\n\t\t\t\t\tif (vp[i].first*vp[j].second == vp[i].second*vp[j].first)box++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, box);\n\t\t} while (next_permutation(b.begin(), b.end()));\n\t} while (next_permutation(p.begin(), p.end()));\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint m;\nint x[16], y[16];\nint vx[8], vy[8];\nint ans;\n\nint cross(int x1, int y1, int x2, int y2) {\n\treturn x1 * y2 - y1 * x2;\n}\n\nvoid dfs(int rem, int pairNum, int depth) {\n\tif (depth == m / 2) {\n\t\tans = max(ans, pairNum);\n\t\treturn;\n\t}\n\t\n\tint i, j;\n\tfor (i = 0; i < m; i++) if ((rem >> i) & 1) break;\n\tfor (j = i + 1; j < m; j++) {\n\t\tif ((rem >> j) & 1) {\n\t\t\t//connect (Pi, Pj)\n\t\t\tint cnt = 0;\n\t\t\tfor (int k = 0; k < depth; k++) {\n\t\t\t\tif (cross(vx[k], vy[k], x[j] - x[i], y[j] - y[i]) == 0)\n\t\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tvx[depth] = x[j] - x[i];\n\t\t\tvy[depth] = y[j] - y[i];\n\t\t\tdfs(rem - (1 << i) - (1 << j), pairNum + cnt, depth + 1);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) cin >> x[i] >> y[i];\n\tdfs((1 << m) - 1, 0, 0);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint m;\n\nint x[20];\nint y[20];\n\nint dfs1(vector<bool>& used);\n\nint dfs2(vector<bool>& used, int i1, int i2, int d) {\n\tint c = count(used.begin(), used.end(), true);\n\tint res = d;\n\tif (c == m) return res;\n\tbool ng = true;\n\tfor (int i = 0; i < m; i++) if (!used[i]) {\n\t\tused[i] = true;\n\t\tfor (int j = i + 1; j < m; j++) if (!used[j]) {\n\t\t\tint dx1 = x[i1] - x[i2], dy1 = y[i1] - y[i2];\n\t\t\tint dx2 = x[i] - x[j], dy2 = y[i] - y[j];\n\t\t\tif (dx1 * dy2 != dx2 * dy1) continue;\n\t\t\tused[j] = true;\n\t\t\tng = false;\n\t\t\tres = max(res, d + dfs2(used, i, j, d + 1));\n\t\t\tused[j] = false;\n\t\t}\n\t\tused[i] = false;\n\t}\n\tif (ng) res = max(res, d + dfs1(used));\n\treturn res;\n}\n\nmap<vector<bool>, int> dic;\n\nint dfs1(vector<bool>& used) {\n\tif (dic.count(used)) return dic[used];\n\tint res = 0;\n\tfor (int i = 0; i < m; i++) if (!used[i]) {\n\t\tused[i] = true;\n\t\tfor (int j = i + 1; j < m; j++) if (!used[j]) {\n\t\t\tused[j] = true;\n\t\t\tres = max(res, dfs2(used, i, j, 0));\n\t\t\tused[j] = false;\n\t\t}\n\t\tused[i] = false;\n\t}\n\treturn dic[used] = res;\n}\n\nint main()\n{\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tvector<bool> used(m);\n\tcout << dfs1(used) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, x[19], y[19], h[129][19], dp[65555][129]; bool vis[65555][129]; map<pair<int, int>, vector<pair<int, int> > > d; vector<vector<pair<int, int> > > v;\nint gcd(int pa, int pb) {\n\tif (pb == 0) return pa;\n\treturn gcd(pb, pa % pb);\n}\nint solve(int bit, int p1, int p2, int cur) {\n\tif (p1 == v.size()) return 0;\n\tif (p2 == v[p1].size()) {\n\t\tint res = solve(bit, p1 + 1, 0, 0);\n\t\treturn res + cur * (cur - 1) / 2;\n\t}\n\tif (vis[bit][h[p1][p2]]) return dp[bit][h[p1][p2]];\n\tint pa = v[p1][p2].first, pb = v[p1][p2].second;\n\tint ret = solve(bit, p1, p2 + 1, cur);\n\tif (!(bit & (1 << pa)) && !(bit & (1 << pb))) {\n\t\tint res = solve(bit | (1 << pa) | (1 << pb), p1, p2 + 1, cur + 1);\n\t\tret = max(ret, res);\n\t}\n\tvis[bit][h[p1][p2]] = true;\n\tdp[bit][h[p1][p2]] = ret;\n\treturn ret;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint vx = x[j] - x[i], vy = y[j] - y[i];\n\t\t\tif (vy < 0) vy = -vy, vx = -vx;\n\t\t\tint g = gcd(abs(vx), vy);\n\t\t\td[make_pair(abs(vx) / g * (vx > 0 ? 1 : -1), vy / g)].push_back(make_pair(i, j));\n\t\t}\n\t}\n\tfor (pair<pair<int, int>, vector<pair<int, int> > > i : d) {\n\t\tv.push_back(i.second);\n\t}\n\tint curs = 0;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tfor (int j = 0; j < v[i].size(); j++) {\n\t\t\th[i][j] = curs++;\n\t\t}\n\t}\n\tint ret = solve(0, 0, 0, 0);\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=23,INF=1<<30;\nconst long double eps=1e-10;\nlong double x[MAX],y[MAX];\nint DFS(vector<int> state,int nex){\n    int N=state.size();\n    if(nex==N/2+1){\n        vector<double> A;\n        \n        for(int i=0;i<N;i++){\n            for(int j=i+1;j<N;j++){\n                if(state[i]==state[j]){\n                    if(x[i]==x[j]) A.push_back(INF);\n                    else A.push_back((y[j]-y[i])/(x[j]-x[i]));\n                    \n                    break;\n                }\n            }\n        }\n        \n        sort(all(A));\n        \n        int res=0;\n        \n        for(int i=0;i<N/2;i++){\n            for(int j=i+1;j<N/2;j++){\n                if(A[i]+eps>A[j]) res++;\n            }\n        }\n        \n        return res;\n    }\n    \n    int res=0;\n    \n    for(int i=0;i<N;i++){\n        if(state[i]==0){\n            for(int j=i+1;j<N;j++){\n                if(state[j]==0){\n                    state[i]=nex;\n                    state[j]=nex;\n                    res=max(res,DFS(state,nex+1));\n                    state[i]=0;\n                    state[j]=0;\n                }\n            }\n            break;\n        }\n    }\n    \n    return res;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    \n    for(int i=0;i<N;i++) cin>>x[i]>>y[i];\n    \n    vector<int> A(N,0);\n    \n    cout<<DFS(A,1)<<endl;\n    \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    /** output whole vector. ex) vector<int>{1, 2, 3} -> '1 2 3'. */\n    template<typename T>\n    ostream& operator<<(ostream& os, const vector<T>& xs) {\n       if (xs.empty()) return os << \"[]\";\n       os << \"[\" << xs[0];\n       for (auto i = 1; i < xs.size(); i++) os << ' ' << xs[i];\n       return os << \"]\";\n    }\n\n    const double EPS = 1e-8;\n    struct Point {\n        double x, y;\n        Point() {}\n        Point(double x, double y) : x(x), y(y) {}\n        Point operator-() const {\n            return Point(-x, -y);\n        }\n        Point operator-(const Point& p) const {\n            return Point(x - p.x, y - p.y);\n        }\n        Point unit() const {\n            auto d = sqrt(x*x + y*y);\n            return Point(x / d, y / d);\n        }\n    };\n    bool eq(const Point &a, const Point& b) {\n        return abs(a.x - b.x) < EPS && abs(a.y - b.y) < EPS;\n    }\n    int M;\n    vector<Point> P;\n    void input() {\n        cin >> M;\n        P.resize(M);\n        for (int i = 0; i < M; i++) {\n            cin >> P[i].x >> P[i].y;\n        }\n    }\n\n    const int N = 100;\n    int dp[N][N];\n    void init_pascal() {\n        memset(dp, 0, sizeof(dp));\n        dp[0][0] = 1;\n        for (int i = 1; i < N; i++) {\n            dp[i][0] = dp[i - 1][0];\n            for (int j = 1; j <= i; j++) {\n                dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]);\n            }\n        }\n    }\n    int comb(int n, int k) {\n        return dp[n][k];\n    }\n\n    struct Line {\n        Point a, b;\n        Line(Point a, Point b) : a(a), b(b) {}\n    };\n    bool parallel(Line& l, Line& s) {\n        auto p = l.b - l.a;\n        auto q = s.b - s.a;\n        return eq(p.unit(), q.unit()) || eq(-p.unit(), q.unit());\n    }\n\n    int memo[(1 << 16) + 10];\n    int f(int bit) {\n        auto& cache = memo[bit];\n        if (cache >= 0) return cache;\n        int ans = 0;\n        for (int i = 0; i < M; i++) {\n            if (bit & (1 << i)) continue;\n            for (int j = i + 1; j < M; j++) {\n                if (bit & (1 << j)) continue;\n                auto l = Line(P[i], P[j]);\n\n                vector<vector<int>> cands(M, vector<int>());\n                for (int k = 0; k < M; k++) {\n                    if (k == i || k == j) continue;\n                    if (bit & (1 << k)) continue;\n                    for (int x = k + 1; x < M; x++) {\n                        if (bit & (1 << x)) continue;\n                        auto s = Line(P[k], P[x]);\n                        if (parallel(l, s)) {\n                            cands[k].push_back(x);\n                        }\n                    }\n                }\n                //cout << \"(\" << i << \",\" << j << \")\" << endl << cands << endl;\n\n                // (k, x)??¨???????????????????????????????????????\n                function<int(int, int, int)> dfs = [&](int p, int bit, int count) {\n                    if (p == M) return f(bit) + comb(count + 1, 2);\n                    if (bit & 1 << p) return dfs(p + 1, bit, count);\n                    if (cands[p].empty()) return dfs(p + 1, bit, count);\n                    int ans = comb(count + 1, 2);\n                    for (auto c : cands[p]) {\n                        if (bit & (1 << c)) continue;\n                        auto nbit = bit | 1 << c | 1 << p;\n                        ans = max(ans, dfs(p, nbit, count + 1));\n                    }\n                    return ans;\n                };\n                ans = max(ans, dfs(0, bit | 1 << i | 1 << j, 0));\n            }\n        }\n        return cache = ans;\n    }\n\n    void solve() {\n        init_pascal();\n        memset(memo, -1, sizeof(memo));\n        cout << f(0) << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\n#ifdef _WIN32\ninline unsigned int __builtin_ctz(unsigned int x) { unsigned long r; _BitScanForward(&r, x); return r; }\ninline unsigned int __builtin_clz(unsigned int x) { unsigned long r; _BitScanReverse(&r, x); return 31 - r; }\ninline unsigned int __builtin_ffs(unsigned int x) { unsigned long r; return _BitScanForward(&r, x) ? r + 1 : 0; }\ninline unsigned int __builtin_popcount(unsigned int x) { return __popcnt(x); }\n#endif // _WIN32\n#pragma pop_macro(\"long\")\n#endif // _MSC_VER\n/*---------------------------------------------------------------------------------------------------\n????????????????????????????????? ??§?????§  \n??????????????? ??§?????§ ???????´<_??? ?????? Welcome to My Coding Space!\n???????????? ??? ?´_???`??????/??? ???i     \n?????????????????????????????? ???  |???|     \n????????? /?????? /??£??£??£??£/??????|  \n??? ???_(__??????/???    ???/ .| .|????????????  \n??? ????????????/????????????/??????u??????  \n---------------------------------------------------------------------------------------------------*/\n \n\n\nint M, X[20], Y[20];\nint dp1[1 << 16];\nset<pair<int, int>> dp2[1 << 16];\nint dp3[1 << 16];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> M;\n    rep(i, 0, M) cin >> X[i] >> Y[i];\n\n    dp1[0] = 1;\n    rep(a, 0, M) rep(b, a + 1, M) {\n        int msk = (1 << a) + (1 << b);\n        dp1[msk] = 1;\n        dp2[msk].insert({X[b] - X[a], Y[b] - Y[a]});\n    }\n\n    rep(msk, 0, 1 << M) {\n        if (__builtin_popcount(msk) % 2 == 1) continue;\n        if (__builtin_popcount(msk) <= 3) continue;\n        rep(a, 0, M) if (msk & (1 << a)) rep(b, a + 1, M) if (msk & (1 << b)) {\n            int nmsk = msk - (1 << a) - (1 << b);\n            if (!dp1[nmsk]) continue;\n            \n            int dx = X[a] - X[b];\n            int dy = Y[a] - Y[b];\n\n            fore(p, dp2[nmsk]) {\n                if (dx * p.second == dy * p.first) {\n                    dp1[msk] = 1;\n                    dp2[msk].insert(p);\n                }\n            }\n        }\n    }\n\n    rep(msk, 0, 1 << M) if(dp1[msk]) {\n        int c = __builtin_popcount(msk)/ 2;\n        dp3[msk] = c * (c - 1) / 2;\n    }\n\n    rep(msk, 0, 1 << M) {\n        for (int i = msk; i >= 0; i--) {\n            i &= msk;\n\n            dp3[msk] = max(dp3[msk], dp3[i] + dp3[msk - i]);\n        }\n    }\n\n    int ans = dp3[(1 << M) - 1];\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <cstdio>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <tr1/unordered_map>\n#define N 100\ntypedef unsigned long long ull;\ntypedef long long ll;\nusing namespace std::tr1;\nusing namespace std;\nint m, ans, flag[N], x[N], y[N], ct, c[N], con[N];\nint read(){\n    int p=0, q=1;\n    char ch=getchar();\n    while (ch<'0' || ch>'9')\n        (ch=='-'?q=-1:0),\n        ch=getchar();\n    while (ch>='0' && ch<='9') p=p*10+ch-'0', ch=getchar();\n    return p*q;\n}\nint check(){\n\tint p=0;\n\tfor (int i=1;i<=ct;i++)\n\t\tfor (int j=i+1;j<=ct;j++){\n\t\t\tint u1=x[c[i]]-x[con[c[i]]], v1=y[c[i]]-y[con[c[i]]];\n\t\t\tint u2=x[c[j]]-x[con[c[j]]], v2=y[c[j]]-y[con[c[j]]];\n\t\t\tif (!u1 && !u2) {p++; continue;}\n\t\t\tif (!u1 || !u2) continue;\n\t\t\tif (v1*u2==u1*v2) {p++; continue;}\t\t\t\n\t\t}\n\treturn p;\n}\nvoid dfs(int t){\n\tif (t>m){\n\t\t//cout<<\"lyk\"<<' '<<ct<<' '<<check()<<endl;\n\t\tans=max(ans,check());\n\t\treturn;\n\t}\n\tif (flag[t]) { dfs(t+1);return;}\n\tflag[t]=1;\n\tc[++ct]=t;\n\tfor (int i=t+1;i<=m;i++)\n\t\tif (!flag[i]){\n\t\t\tflag[i]=1;\n\t\t\tcon[t]=i;\n\t\t\tdfs(t+1);\n\t\t\tflag[i]=0;\n\t\t}\n\tflag[t]=0;\n\tct--;\n}\nint main(){\n\tm=read();\n\tfor (int i=1;i<=m;i++) x[i]=read(), y[i]=read();\n\tdfs(1);\n\tcout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int64)1e9\n#define REP(i, n) for(int64 i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int64 i = (a); i < (b); i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint32_t;\nusing int64 = int64_t;\nusing uint64 = uint64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\ntemplate<typename A, typename B> inline void chmin(A &a, B b) { if (a > b) a = b; }\ntemplate<typename A, typename B> inline void chmax(A &a, B b) { if (a < b) a = b; }\n\nint64 m;\nusing Line = pair<PLL, PLL>;\nvector<PLL> pts;\nvector<Line> ls;\nint64 dp[17][1 << 16] = {};\n\nbool isParallel(Line a, Line b) {\n  PLL aa = PLL(a.sc.fs-a.fs.fs, a.sc.sc-a.fs.sc), bb = PLL(b.sc.fs-b.fs.fs, b.sc.sc-b.fs.sc);\n//  cout << aa.fs << \" \" << aa.sc << \": \" << bb.fs << \" \" << bb.sc << endl;\n  if (aa.fs*bb.sc-aa.sc*bb.fs == 0) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nint64 dfs(int64 d=0, int64 used=0) {\n  if (used == (1 << m) -1) {\n    int64 sum = 0;\n    REP(i, m/2) {\n      FOR(j, i+1, m/2) {\n        sum += isParallel(ls[i], ls[j]);\n      }\n    }\n//    cout << sum << endl;\n    return sum;\n  }\n  while ((used >> d) & 1) d++;\n  FOR(i, d+1, m) {\n    if (used >> i & 1) continue;\n    ls.push_back({pts[i], pts[d]});\n    chmax(dp[d][used], dfs(d+1, used | (1 << d) | (1 << i)));\n    ls.pop_back();\n  }\n  return dp[d][used];\n}\n\nint main(void) {\n  cin >> m;\n  REP(i, m) {\n    PLL p;\n    cin >> p.fs >> p.sc;\n    pts.push_back(p);\n  }\n  memset(dp, -1, sizeof dp);\n  cout << dfs() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, x[19], y[19], h[129][19][19], dp[65555][509]; bool vis[65555][509]; map<pair<int, int>, vector<pair<int, int> > > d; vector<vector<pair<int, int> > > v;\nint gcd(int pa, int pb) {\n\tif (pb == 0) return pa;\n\treturn gcd(pb, pa % pb);\n}\nint solve(int bit, int p1, int p2, int cur) {\n\tif (p1 == v.size()) return 0;\n\tif (p2 == v[p1].size()) {\n\t\tint res = solve(bit, p1 + 1, 0, 0);\n\t\treturn res + cur * (cur - 1) / 2;\n\t}\n\tif (vis[bit][h[p1][p2][cur]]) return dp[bit][h[p1][p2][cur]];\n\tint pa = v[p1][p2].first, pb = v[p1][p2].second;\n\tint ret = solve(bit, p1, p2 + 1, cur);\n\tif (!(bit & (1 << pa)) && !(bit & (1 << pb))) {\n\t\tint res = solve(bit | (1 << pa) | (1 << pb), p1, p2 + 1, cur + 1);\n\t\tret = max(ret, res);\n\t}\n\tvis[bit][h[p1][p2][cur]] = true;\n\tdp[bit][h[p1][p2][cur]] = ret;\n\treturn ret;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint vx = x[j] - x[i], vy = y[j] - y[i];\n\t\t\tif (vy < 0) vy = -vy, vx = -vx;\n\t\t\tint g = gcd(abs(vx), vy);\n\t\t\td[make_pair(abs(vx) / g * (vx > 0 ? 1 : -1), vy / g)].push_back(make_pair(i, j));\n\t\t}\n\t}\n\tfor (pair<pair<int, int>, vector<pair<int, int> > > i : d) {\n\t\tv.push_back(i.second);\n\t}\n\tint curs = 0;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tfor (int j = 0; j < v[i].size(); j++) {\n\t\t\tfor (int k = 0; k < v[i].size(); k++) {\n\t\t\t\th[i][j][k] = curs++;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = solve(0, 0, 0, 0);\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mem(a,b) memset(a,b,sizeof a);\n#define rep(i,a,b) for(int i = a; i <= b; i++)\n#define per(i,a,b) for(int i = a; i >= b; i--)\n#define __ ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)\ntypedef long long ll;\ntypedef double db;\nconst int N = 20;\nconst db EPS = 1e-9;\nusing namespace std;\n\nvoid dbg() {cout << \"\\n\";}\ntemplate<typename T, typename... A> void dbg(T a, A... x) {cout << a << ' '; dbg(x...);}\n#define logs(x...) {cout << #x << \" -> \"; dbg(x);}\n\nint n,x[N],y[N],ans,vis[N],flag[N],sz;\n\nvoid dfs(vector<int> v, int tmp){\n\tans = max(ans, tmp);\n\tint sz = v.size();\n\tif(sz == 0) return;\n\trep(i,0,sz-1){\n\t\trep(j,i+1,sz-1){\n\t\t\tint x1 = x[v[i]]-x[v[j]], y1 = y[v[i]]-y[v[j]];\n\t\t\tint cnt = 0;\n\t\t\trep(k1,0,sz-1){\n\t\t\t\tif(flag[v[k1]]) continue;\n\t\t\t\trep(k2,k1+1,sz-1){\n\t\t\t\t\tif(flag[v[k2]]) continue;\n\t\t\t\t\tint x2 = x[v[k2]]-x[v[k1]], y2 = y[v[k2]]-y[v[k1]];\n\t\t\t\t\tif(y2*x1 == y1*x2){\n\t\t\t\t\t\tflag[v[k1]] = flag[v[k2]] = 1;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt > 1){\n\t\t\t\tvector<int> vv; vv.clear();\n\t\t\t\trep(k1,0,sz-1)\n\t\t\t\t\tif(!flag[v[k1]]) vv.push_back(v[k1]);\n\t\t\t\tdfs(vv, tmp+cnt*(cnt-1)/2);\n\t\t\t\tvv.clear();\n\t\t\t}\n\t\t\trep(k1,0,sz-1) flag[v[k1]] = 0;\n\t\t}\n\t}\n\tv.clear();\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\trep(i,1,n) scanf(\"%d %d\",&x[i],&y[i]);\n\tvector<int> v;\n\trep(i,1,n) v.push_back(i);\n\tdfs(v,0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n\nbool paralell(P a, P b, P c, P d){\n  auto check=[](P a, P b, P c, P d){\n    b = P(b.first - a.first, b.second - a.second);\n    d = P(d.first - c.first, d.second - c.second);\n    //b.second / b.first == d.second / d.first;\n    return b.second * d.first == d.second * b.first;\n  };\n  return check(a, b, c, d) || check(a, b, d, c);\n}\n\nint n;\n\nvector<P> A;\n\nint used[1<<16], mem[1<<16];\nint dfs(int bit){\n  if(used[bit]++) return mem[bit];\n  \n  int res = 0;\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      if((bit >> i & 1) || (bit >> j & 1)) continue;\n      int cnt = 1;\n      int nbit = bit | (1<<i) | (1<<j);\n      for(int k=0;k<n;k++)\n\tfor(int l=k+1;l<n;l++){\n\t  if((nbit>>k&1) || (nbit>>l&1)) continue;\n\t  if(!paralell(A[i], A[j], A[k], A[l])) continue;\n\t  nbit |= (1<<k) | (1<<l);\n\t  cnt++;\n\t}\n      Max(res, dfs(nbit) + cnt * (cnt - 1) / 2);\n    }\n  }\n  return mem[bit] = res;\n}\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n  cin>>n;\n  A.resize(n);\n  cin>>A;\n\n  int ans = dfs(0);\n  cout<<ans<<endl;  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,double> LP;\n \n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define all(x) x.begin(),x.end()\n#define maxch(x,y) x=max(x,y)\n#define bcnt __builtin_popcount\n \n#define inf 1e16\n \nll n;\nll x[1010],y[1010];\nmap<double,vector<P> > vs;\nvector<ll> a,b;\n \nll dp[2][1<<16];\n \nint main(){\n  cin>>n;\n  rep(i,n)cin>>x[i]>>y[i];\n  rep(i,n)rep(j,i){\n    ll dx=x[i]-x[j];\n    ll dy=y[i]-y[j];\n \n    if(dx==0){\n      vs[inf].push_back(P(i,j));\n    }else if(dy==0){\n      vs[0].push_back(P(i,j));\n    }else{\n      /*\n      ll pdx=dx<0?-dx:dx;\n      ll pdy=dy<0?-dy:dy;\n      ll g=__gcd(pdx,pdy);\n \n      if(dx<0)vs[P(-dx/g,-dy/g)].push_back(P(i,j));\n      else vs[P(dx/g,dy/g)].push_back(P(i,j));\n      */\n      vs[(double)dy/(double)dx].push_back(P(i,j));\n    }\n  }\n \n  for(auto it : vs){\n    rep(S,1<<it.se.size()){\n      if(bcnt(S)<2)continue;\n      a.push_back(bcnt(S)*(bcnt(S)-1)/2);\n      ll tmp=0;\n      rep(i,it.se.size()){\n        if((S>>i)&1){\n          tmp|=1<<it.se[i].fi;\n          tmp|=1<<it.se[i].se;\n        }\n      }\n      b.push_back(tmp);\n    }\n  }\n  ll m=a.size();\n \n  ll crt=0,nxt=1;\n  rep(i,m){\n    rep(S,1<<n){\n      maxch(dp[nxt][S],dp[crt][S]);\n      if((S&b[i])==b[i])maxch(dp[nxt][S^b[i]],dp[crt][S]+a[i]);\n    }\n    swap(crt,nxt);\n  }\n \n  ll res=0;\n  rep(S,1<<n){\n    maxch(res,dp[crt][S]);\n  }\n  cout<<res<<endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\n\nstruct Point {\n\tint x, y;\n\tPoint operator - (const Point& p) const { return Point{x - p.x, y - p.y}; }\n};\n\nint m;\nPoint p[16];\n\nint cross(Point& a, Point& b) { return a.x * b.y - a.y * b.x; }\nbool is_para(Point& a, Point& b) { return cross(a, b) == 0; }\n\nint calc(vector< int >& a, vector< int >& b) {\n\tint res = 0;\n\tfor_(i,0,m/2) for_(j,i+1,m/2) {\n\t\tPoint ai = p[a[i]] - p[b[i]];\n\t\tPoint bi = p[a[j]] - p[b[j]];\n\t\tres += is_para(ai, bi);\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin >> m;\n\tfor_(i,0,m) cin >> p[i].x >> p[i].y;\n\t\n\tset< int > hash_set;\n\tint x, y, k = m / 2, S = (1 << m) - 1, ans = 0;\n\tfor (int T = (1 << k) - 1; T < (1 << m); x = T & -T, y = T + x, T = (((T & ~y) / x) >> 1) | y) {\n\t\tif (hash_set.count(T) || hash_set.count(S ^ T)) continue;\n\t\n\t\tvector< int > a, b;\n\t\tfor_(i,0,m) {\n\t\t\tif (T >> i & 1) a.push_back(i);\n\t\t\telse b.push_back(i);\n\t\t}\n\t\t\n\t\tdo {\n\t\t\tans = max(ans, calc(a, b));\n\t\t} while (next_permutation(b.begin(), b.end()));\n\t\t\n\t\thash_set.insert(T);\n\t\thash_set.insert(S ^ T);\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nint x[100000];\nint y[100000];\ndouble k[100000];\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i=1;i<=n;i++) \t{\n\t\tscanf(\"%d%d\", &x[i],&y[i]);\n\t}\n\tint top=0;\n\tint verti=0;\n\tfor (int i=1;i<=n;i++) {\n\t\tfor (int j=i+1;j<=n;j++) {\n\t\t\tif (i!=j) {\n\t\t\t\tif (x[i]!=x[j]) {\n\t\t\t\t\ttop++;\n\t\t\t\t\tdouble xx=x[i]-x[j];\n\t\t\t\t\tdouble yy=y[i]-y[j];\n\t\t\t\t\tk[top]=yy/xx;\n\t\t\t\t} else {verti++;}\n\t\t\t}\n\t\t}\n\t}\n\tsort(k+1,k+top+1);\n\tint max=0;\n\tint tmp=1;\n\tfor (int i=2;i<=top;i++) {\n\t\tif (fabs(k[i-1]-k[i])<=1E-3) {tmp++;}\n\t\telse {if (tmp>max) {max=tmp;} tmp=1;}\n\t} \n\tif (max<verti) {max=verti;}\n\tint ans=max*(max-1)/2;\n\tprintf(\"%d\\n\", ans); \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <cmath>\n#include <string>\nusing namespace std;\n\n#define MAX 100005\n\nint n, t;\nint h[MAX];\nint c[MAX];\nint s[MAX];\nint o[MAX];\n\nint main() {\n  scanf(\"%d %d\", &n, &t);\n\n  c[1] = 0;\n  s[1] = 0;\n  scanf(\"%d\", &h[1]);\n  for ( int i = 2; i <= n; i++ ) {\n    scanf(\"%d\", &h[i]);\n    c[i] = h[i - 1] + h[i - 2];\n    s[i] = h[i] > h[i - 1] ? 1 : 0;\n  }\n\n  // for ( int i = 1; i <= n; i++ ) {\n  //   printf(\"h:%d, c:%d, s:%d\\n\", h[i], c[i], s[i]);\n  // }\n\n  int t; // ????????????\n  int p; // ???\n  int q; // ?????????\n  int temp; // ???????????°\n  t = l - c[1];\n  p = l / h[1];\n  q = l % h[1];\n  if ( q == 0 ) {\n    p += 1;\n  }\n  o[1] = p;\n  printf(\"%d\", o[1]);\n  for ( int i = 2; i <= n; i++ ) {\n    t = l - c[i];\n    if (s[i] == 1 ) {\n      temp = h[i] - h[i - 1];\n    } else {\n      temp = h[i];\n    }\n    p = l / temp;\n    q = l % temp;\n    if ( q == 0 ) {\n      p += 1;\n    }\n    o[i] = p;\n    printf(\"%d\\n\", o[i]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\n\nvoid solve(){\n    ll res = 0;\n    ll m; cin >> m;\n    vector<pll> ps(m);\n    for(int i = 0; i < m;i++) cin >> ps[i].first >> ps[i].second;\n    \n    map<pii,vector<int>> angle;\n    for(int i = 0; i < m; i++){\n        for(int j = i+1; j < m;j++){\n            pii vec = {ps[j].first-ps[i].first,ps[j].second-ps[i].second};\n            ll GCD = gcd(abs(vec.first),abs(vec.second));\n            vec.first /= GCD;\n            vec.second /= GCD;\n            \n            if(vec.second < 0){\n                vec.first *= -1;\n                vec.second *= -1;\n            }\n            if(vec.second == 0) vec.first = 1;\n            if(vec.first == 0) vec.second = 1;\n            angle[{vec.second,vec.first}].push_back((1<<i)|(1<<j));\n        }\n    }\n    vector<int> dp(1<<m,-1);\n    dp[0] = 0;\n    for(int b = 0; b < (1<<m); b++){\n        if(dp[b] == -1) continue;\n        for(auto P:angle){\n            vector<int> T;\n            T.push_back(0);\n            for (int mask : P.second) {\n                if (b & mask) continue;\n                for (int i = (int)T.size(); i --; ) {\n                    int t = T[i] | mask;\n                    int k = __builtin_popcount(t) / 2;\n                    dp[b|t]  = max(dp[b|t],dp[b] + k*(k-1)/2);\n                    T.push_back(t);\n                }\n            }\n        }\n    }\n    cout << dp[(1<<m)-1] << endl;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ms(x) memset(x, 0, sizeof(x))\nusing namespace std;\nconst int N = 20;\nstruct node{\n    int x, y;\n}q[N];\nint vis[N], n, top, ans = 0;\nvector<pair<int, int> >que;\nbool check(){\n    int tp = 0;\n    for(int i=0;i<que.size();i++){\n        int dx = q[que[i].first].x - q[que[i].second].x;\n        int dy = q[que[i].first].y - q[que[i].second].y;\n        for(int j=0;j<que.size();j++){\n            if(i==j) continue;\n            int tx = q[que[j].first].x - q[que[j].second].x;\n            int ty = q[que[j].first].y - q[que[j].second].y;\n            if(ty*dx == dy*tx) tp++;\n        }\n    }\n    ans = max(tp, ans);\n}\nvoid dfs(int now){\n    if(now == n+1){\n        check();\n        return ;\n    }\n    if(vis[now]) dfs(now+1);\n    else{\n        for(int i=1;i<=n;i++) {\n            if(vis[i]||i==now) continue;\n            que.push_back(make_pair(now, i));\n            vis[i] = vis[now] = 1;\n            dfs(now+1);\n            que.pop_back();\n            vis[now] = vis[i] = 0;\n        }\n    }\n}\nint main(){\n    while(scanf(\"%d\", &n)!=EOF){\n        ms(vis);\n        ans = 0;\n        for(int i=1;i<=n;i++){\n            scanf(\"%d%d\",&q[i].x,&q[i].y);\n        }\n        dfs(1);\n        printf(\"%d\\n\",ans/2);\n    }\n    return 0;\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing Number = double;\nconst Number EPS = 1e-10;\n\ninline int sign(Number x) { return (x < -EPS) ? -1 : (x > EPS) ? +1 : 0; }\ninline bool equal(Number a, Number b) { return sign(a - b) == 0; }\n\nclass Point {\npublic:\n    Number x, y;\n\n    Point() {}\n    Point(Number x, Number y) : x(x), y(y) {}\n\n    Point operator-(const Point &rhs) const {\n        return Point(this->x - rhs.x, this->y - rhs.y);\n    }\n};\n\ninline Number abs_cross(const Point &p1, const Point &p2) {\n    return p1.x * p2.y - p1.y * p2.x;\n}\n\nclass Line : public std::array<Point, 2> {\npublic:\n    Line() {}\n    Line(const Point &p1, const Point &p2) {\n        (*this)[0] = p1; (*this)[1] = p2;\n    }\n};\ninline bool IsParallel(const Line &l1, const Line &l2) {\n    return equal(abs_cross(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\n\n//set<vector<int>> memo;\nint Search(const int i, const int m, vector<int> &idx, const vector<Point> &p) {\n    if (i == m - 2) {\n        // if (memo.count(idx) != 0) {cout << \"same\" << endl;  }\n        // memo.insert(idx);\n\n        int sum = 0;\n        vector<bool> check(m / 2, false);\n        // for (auto x : idx) cout << x << \", \";\n        // cout << endl;\n\n        for (int j = 0; 2 * j < m; ++j) {\n            if (check[j]) continue;\n\n            check[j] = true;\n            int num = 1;\n            Line l(p[idx[2 * j]], p[idx[2 * j + 1]]);\n            for (int k = j + 1; 2 * k < m; ++k)\n                if (IsParallel(l, Line(p[idx[2 * k]], p[idx[2 * k + 1]]))) {\n                    ++num;\n                    check[k] = true;\n                }\n            sum += num * (num - 1) / 2;\n        }\n        return sum;\n    }\n\n    int min_idx = distance(idx.begin(), min_element(idx.begin() + i, idx.end()));\n    swap(idx[i], idx[min_idx]);\n\n    int res = 0;\n    for (int j = i + 1; j < m; ++j) {\n        swap(idx[i + 1], idx[j]);\n        res = max(res, Search(i + 2, m, idx, p));\n//        swap(idx[i + 1], idx[j]);\n    }\n\n    return res;\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    int m;\n    cin >> m;\n    vector<Point> p(m);\n    for (auto &pp : p) cin >> pp.x >> pp.y;\n\n    vector<int> idx(m);\n    iota(idx.begin(), idx.end(), 0);\n\n    cout << Search(0, m, idx, p) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define D(x)    cout << #x \" = \" << (x) << endl\n#define MAX     100000\n\nint health[MAX+5];\nconst int LIMIT = 1000000000;\n\nint main()\n{\n    freopen(\"rm.txt\", \"r\", stdin);\n\n    int n, t, i, st = 0;\n\n    scanf(\"%d %d\", &n, &t);\n    for(i = 1; i <= n; i++) scanf(\"%d\", &health[i]);\n    int prev_st_time;\n\n\n    int prev_ans;\n    for(i = 1; i <= n; i++){\n        if(i == 1)\n        {\n            printf(\"%d\\n\", prev_ans = t / health[i] + 1);\n            prev_st_time = t / health[i] * health[i];\n        }\n        else{\n\n            if(t <= st){\n                printf(\"%d\\n\", prev_ans = 0);\n                continue;\n            }\n\n            if(health[i] >= health[i - 1]){\n                printf(\"%d\\n\", prev_ans = (t - st) / health[i] + 1);\n                prev_st_time = st + (t - st) / health[i] * health[i];\n            }\n            else{\n                int elapsed = t - prev_st_time;\n                if(elapsed < health[i]) printf(\"%d\\n\", prev_ans = max(0, prev_ans - 1));\n                else printf(\"%d\\n\", prev_ans);\n\n                prev_st_time = prev_st_time + health[i - 1];\n            }\n        }\n        st += health[i];\n        if(st > LIMIT) st = LIMIT + 1;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, x[19], y[19], h[129][19], dp[65555][129][10]; bool vis[65555][129][10]; map<pair<int, int>, vector<pair<int, int> > > d; vector<vector<pair<int, int> > > v;\nint gcd(int pa, int pb) {\n\tif (pb == 0) return pa;\n\treturn gcd(pb, pa % pb);\n}\nint solve(int bit, int p1, int p2, int cur) {\n\tif (p1 == v.size()) return 0;\n\tif (p2 == v[p1].size()) {\n\t\tint res = solve(bit, p1 + 1, 0, 0);\n\t\treturn res + cur * (cur - 1) / 2;\n\t}\n\tif (vis[bit][h[p1][p2]][cur]) return dp[bit][h[p1][p2]][cur];\n\tint pa = v[p1][p2].first, pb = v[p1][p2].second;\n\tint ret = solve(bit, p1, p2 + 1, cur);\n\tif (!(bit & (1 << pa)) && !(bit & (1 << pb))) {\n\t\tint res = solve(bit | (1 << pa) | (1 << pb), p1, p2 + 1, cur + 1);\n\t\tret = max(ret, res);\n\t}\n\tvis[bit][h[p1][p2]][cur] = true;\n\tdp[bit][h[p1][p2]][cur] = ret;\n\treturn ret;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint vx = x[j] - x[i], vy = y[j] - y[i];\n\t\t\tif (vy < 0) vy = -vy, vx = -vx;\n\t\t\tint g = gcd(abs(vx), vy);\n\t\t\td[make_pair(abs(vx) / g * (vx > 0 ? 1 : -1), vy / g)].push_back(make_pair(i, j));\n\t\t}\n\t}\n\tfor (pair<pair<int, int>, vector<pair<int, int> > > i : d) {\n\t\tv.push_back(i.second);\n\t}\n\tint curs = 0;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tfor (int j = 0; j < v[i].size(); j++) {\n\t\t\th[i][j] = curs++;\n\t\t}\n\t}\n\tint ret = solve(0, 0, 0, 0);\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb         push_back\n\ntypedef long long ll;\nconst ll INF = 1000000000000000000ll;\nconst ll MOD = 1000000007ll;\nconst double EPS = 1e-8;\n\nlong long gcd(long long a, long long b){\n  long long c;\n  while ( a != 0 ) {\n\t c = a; a = b%a; b = c;\n  }\n  return b;\n}\n\nconst int MAX_N = 100;\nll fact[MAX_N];\nll factinv[MAX_N];\nll ans = 0;\nlong long mod_pow(long long x, long long n, long long mod){\n\tlong long res = 1;\n\twhile(n > 0){\n\t\tif(n & 1) res = res * x % mod;\n\t\tx = x*x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\n//???????????????????????????\nvoid make_fact_tbl(long long n, long long mod){\n\tfact[0] = 1;\n\tfor(long long i=1; i<=n; i++){\n\t\tfact[i] = fact[i-1] * i;\n\t\tfact[i] %= mod;\n\t}\n}\n\n//????????????????????????????????????\nvoid make_factinv_tbl(long long n, long long mod){\n\tfactinv[0] = 1; //0?????????????????¨?????????\n\tfor(long long i=1; i<=n; i++){\n\t\tfactinv[i] = mod_pow(fact[i], mod-2, mod);\n\t}\n}\n\n//???????????????????¨?????????????????????±?????????\nvoid comb_init(long long n, long long mod){\n\tmake_fact_tbl(n, mod);\n\tmake_factinv_tbl(n, mod);\n}\n\n//???????????????????¨????\nlong long comb(long long n, long long k, long long mod){\n\tif(n < k) return 0;\n\tif(k == 0 || n-k == 0) return 1;\n\t//printf(\"n:%lld k:%lld n-k:%lld\\n\", fact[n], factinv[k], factinv[n-k]);\n\treturn ((fact[n] * factinv[k]) % mod) * factinv[n-k] % mod;\n}\n\nvector<int> x;\nvector<int> y;\n\nvoid dfs(int idx, queue<int> nouse, map<pair<int, int>, int> para){\n\tint num = nouse.size();\n\t//printf(\"num: %d\\n\", num);\n\tfor(int i=0; i<num; i++){\n\t\tqueue<int> next = nouse;\n\t\tmap<pair<int, int>, int> next_para = para;\n\t\tint tgt = next.front();\n\t\tnext.pop();\n\t\tnouse.pop();\n\t\tnouse.push(tgt);\n\n\t\tpair<int, int> a;\n\t\tif(x[tgt] == x[idx]){\n\t\t\t//printf(\"%d %d %lld\\n\", tgt, idx, x[tgt]);\n\t\t\ta = make_pair(1, 0);\n\t\t}else if(y[tgt] == y[idx]){\n\t\t\ta = make_pair(0, 1);\n\t\t}else{\n\t\t\tll dy = y[tgt] - y[idx];\n\t\t\tll dx = x[tgt] - x[idx];\n\t\t\ta = make_pair(dy/gcd(dy, dx), dx/gcd(dy, dx));\n\t\t}\n\t\tnext_para[a] += 1;\n\n\t\tif(next.size() != 0){\n\t\t\tint src = next.front();\n\t\t\tnext.pop();\n\t\t\tdfs(src, next, next_para);\n\t\t}else{\n\t\t\t//????????¶????????????????????¨\n\t\t\tll cnt = 0;\n\t\t\tfor(auto it=next_para.begin(); it != next_para.end(); it++){\n\t\t\t\t//printf(\"second:%d\\n\", it->first);\n\t\t\t\tif(it->second >= 2){\n\t\t\t\t\tcnt += comb(it->second, 2, MOD);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tans = max(ans, cnt);\n\t\t}\n\t}\n}\n\nint main(void) {\n\t//ios_base::sync_with_stdio(false);\n\t//cin.tie(0);\n\tcomb_init(30, MOD);\n\n\tint m;\n\tcin >> m;\n\n\tqueue<int> nouse;\n\tfor(int i=0; i<m; i++){\n\t\tint tx, ty;\n\t\tcin >> tx >> ty;\n\t\tx.pb(tx);\n\t\ty.pb(ty);\n\n\t\tnouse.push(i);\n\t}\n\tmap<pair<int, int>, int> para;\n\tnouse.pop();\n\tdfs(0, nouse, para);\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <iostream>\n//#include <vector>\n//#include <map>\n//#include <numeric>\n#include <bits/stdc++.h>\nusing namespace std;\n\nint M;\nvector<int> X, Y;\n\nint nc2(int x){\n    if(x < 2)\n        return 0;\n    return x * (x-1) / 2;\n}\n\nint get_counts(map<pair<int, int>, int> &counts){\n    int res = 0;\n    for(auto p: counts)\n        res += nc2(p.second);\n    return res;\n}\n\npair<int, int> get_fraction(int i, int j){\n    int dx = X[i] - X[j];\n    int dy = Y[i] - Y[j];\n    int g = __gcd(dx, dy);\n    \n    return {dx/g, dy/g};\n}\n\nint dfs(int idx, int used, map<pair<int, int>, int> &counts){\n    if(idx == M){\n        return get_counts(counts);\n    }\n    \n    int res = -1;\n    if((used >> idx) & 1){\n        res = max(res, dfs(idx+1, used, counts));\n    }else{\n        for(int i=idx+1; i<M; i++) if(((used >> i) & 1) == 0){\n            int nused = used;\n            nused |= 1 << idx;\n            nused |= 1 << i;\n            \n            pair<int, int> fr = get_fraction(idx, i);\n            counts[fr]++;\n            res = min(res, dfs(idx+1, nused, counts));\n            counts[fr]--;\n        }\n    }\n    return res;\n}\n\nint main(){\n    cin >> M;\n    X.resize(M), Y.resize(M);\n    \n    for(int i=0; i<M; i++)\n        cin >> X[i] >> Y[i];\n    \n    map<pair<int, int>, int> counts;\n    cout << dfs(0, 0, counts) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main() {\n    int n;\n    cin >> n;\n    VI x(n), y(n);\n    REP(i,n){\n        cin >> x[i] >> y[i];\n    }\n\n    int d = 1;\n    for (int s = 3; s <= n; s += 2) d *= s;\n\n    // cout << d << endl;\n\n    int ans = 0;\n\n    REP(z,d){\n        VI p(n, -1);\n        VI dx, dy;\n        int zz = z;\n        REP(i,n/2){\n            int r = zz % (n-1-2*i);\n            zz /= n-1-2*i;\n            int j = 0;\n            while (p[j] != -1) j++;\n            p[j] = i;\n            int k = n - 1;\n            r++;\n            while (1){\n                if (p[k] == -1) r--;\n                if (!r) break;\n                k--;\n            }\n            p[k] = i;\n\n            dx.push_back(x[k] - x[j]);\n            dy.push_back(y[k] - y[j]);\n        }\n        int tmp = 0;\n        REP(i,n/2) REP(j,i){\n            if (dx[i] * dy[j] == dx[j] * dy[i]) tmp++;\n        }\n        ans = max(ans, tmp);\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unordered_map>\n\n//#include <ext/pb_ds/assoc_container.hpp> // Common file\n//#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update\n\n#define rep(i,n) for(i=1;i<=n;i++)\n#define Rep(i,n) for(i=0;i<n;i++)\n#define For(i,a,b) for(i=a;i<=b;i++)\n\n#define pb(x) push_back(x)\n#define sz(x) (int)x.size()\n\n#define mem(ara,val) memset(ara,val,sizeof(ara))\n#define eps 1e-5\n\n#define si(x) scanf(\"%d\",&x)\n#define sii(x,y) scanf(\"%d %d\",&x,&y)\n#define siii(x,y,z) scanf(\"%d %d %d\",&x,&y,&z)\n#define sl(x) scanf(\"%lld\",&x)\n#define sll(x,y) scanf(\"%lld %lld\",&x,&y)\n#define slll(x,y,z) scanf(\"%lld %lld %lld\",&x,&y,&z)\n#define ss(str) scanf(\"%s\",str)\n#define pi(x) printf(\"%d\",x)\n//#define pii(x,y) printf(\"%d %d\",x,y)\n#define piii(x,y,z) printf(\"%d %d %d\",x,y,z)\n#define pl(x) printf(\"%lld\",x)\n#define pll(x,y) printf(\"%lld %lld\",x,y)\n#define plll(x,y,z) printf(\"%lld %lld %lld\",x,y,z)\n#define NL printf(\"\\n\")\n#define Max 100005\n#define INF 1e18\n#define un(x) x.erase(unique( x.begin() , x.end() ), x.end())\n#define mod 1000000007\n\n#define FI freopen(\"z.txt\",\"r\",stdin)\n\n#define D(x) cout << #x << \" = \" << x << endl\n#define DD(x,y) cout << #x << \" = \" << x << \"   \" << #y << \" = \" << y << endl\n#define DDD(x,y,z) cout << #x << \" = \" << x << \"   \" << #y << \" = \" << y << \"   \" << #z << \" = \" << z << endl\n#define all(x) x.begin(),x.end()\n#define pc(x) __builtin_popcount(x)\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst double PI = acos(-1.0);\n\nusing namespace std;\n\nint setb(int n,int pos)\n{\n    return n=n | (1 << pos);\n}\nint resb(int n,int pos)\n{\n    return n=n & ~(1 << pos);\n}\nbool checkb(int n,int pos)\n{\n    return (bool)(n & (1 << pos));\n}\n\nLL bigmod(LL b,LL p,LL m)\n{\n    if( p == 0 ) return 1;\n    LL ret = bigmod(b,p/2,m);\n    ret = ( ret * ret ) % m;\n    if( p & 1 ) ret = ( ret * b ) % m;\n    return ret;\n}\n\nstruct info\n{\n    int x, y;\n};\ninfo ara[20];\nint n;\n\nmap < pair<int,int> , int > mp;\nint N;\nint get_slope(int idx1, int idx2)\n{\n    int dy = ( ara[idx1].y - ara[idx2].y );\n    int dx = ( ara[idx1].x - ara[idx2].x );\n    if( dx == 0 )\n    {\n        dy = 1;\n    }\n    else if( dy == 0 )\n    {\n        dx = 1;\n    }\n    else\n    {\n        int sx = dx / abs(dx);\n        int sy = dy / abs(dy);\n        int s = sx * sy;\n        dx = abs(dx);\n        dy = abs(dy);\n        int g = __gcd( dx , dy );\n        dx /= g;\n        dy /= g;\n        dx *= s;\n    }\n    if( mp.find( make_pair(dy,dx) ) == mp.end() ) mp[ make_pair(dy,dx) ] = ++N;\n    return mp[ make_pair(dy,dx) ];\n}\n\nint lol[20][20];\nvoid build()\n{\n    int i,j;\n    Rep(i,n)\n    {\n        Rep(j,n)\n        {\n            if( i == j ) continue;\n            lol[i][j] = get_slope(i,j);\n        }\n    }\n}\n\n\nbool visit[ (1 << 16) + 10 ];\nint cnt[505];\nint solve(int mask)\n{\n    int p[15], act[15], k = 0, l = 0;\n    for(int i = 0; i < n; i++)\n    {\n        if( checkb(mask,i) == 0 )\n        {\n            p[k++] = i;\n        }\n        else act[l++] = i;\n    }\n\n    int ret = 0;\n    int keep[15];\n    while( 1 )\n    {\n        int now = 0;\n        for(int i = 0; i < k; i++)\n        {\n            int my = lol[ act[i] ][ p[i] ];\n            now += cnt[my];\n            cnt[my]++;\n            keep[i] = my;\n        }\n        ret = max( ret , now );\n        for(int i = 0; i < k; i++) cnt[ keep[i] ]--;\n\n        bool f = next_permutation(p,p+k);\n        if( !f ) break;\n    }\n    return ret;\n}\n\nint super_solve()\n{\n    int ret = 0;\n    for(int mask = 0; mask < (1 << n); mask++)\n    {\n        if( 2 * pc(mask) == n )\n        {\n            int other = ( (1 << n) - 1 ) ^ mask;\n            if( visit[ other ] ) continue;\n            visit[ mask ] = 1;\n            ret = max( ret , solve(mask) );\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    //FI;\n    int i;\n    si(n);\n    Rep(i,n)\n    {\n        sii(ara[i].x,ara[i].y);\n    }\n    build();\n    int ret = super_solve();\n    pi( ret ); NL;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define REP(i,n) for (int i=0; i<n; i++)\n\nusing namespace std;\n\nint m, x[20], y[20], ct=0;\ndouble tilt[20][20];\n\nint dfs (int j, int used, vector<double> vec){\n\t// printf(\"dfs j: %d\\n\", j);\n\t\n\tint ret=0;\n\tused += 1<<j;\n\t\n\tint k=j+1;\n\tfor (; k<m; k++){\n\t\tif ((used>>k) & 1){\n\t\t\tcontinue;\n\t\t}\n\t\tused += 1<<k;\n\t\tvec.push_back(tilt[j][k]);\n\t\t\n\t\t// printf(\"used: %x, tilt[%d][%d] = %f\\n\", used, j, k, tilt[j][k]);\n\t\t// printf(\"j: %d, k: %d\\n\", j, k);\n\t\t\n\t\t// 一番下までたどりついた\n\t\tif (used>=(1<<m)-1){\n\t\t\t// ct++;\n\t\t\t// printf(\"%d ---------------------\\n\", ct);\n\t\t\t// printf(\"j: %d, k: %d, used: %x, count: %d\\n\", j, k, used, ct);\n\t\t\t\n\t\t\tsort(vec.begin(), vec.end());\n\n\t\t\tint count=1, ret=0;\n\t\t\tdouble prev=vec[0];\n\t\t\t\n\t\t\tfor (int i=1; i<vec.size(); i++){\n\t\t\t\tif (vec[i]!=prev){\n\t\t\t\t\tret += count*(count-1)/2;\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tprev = vec[i];\t\t\t\t\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tret += count*(count-1)/2;\n\t\t\t\n\t\t\t/*\n\t\t\tif (ret>=12){\n\t\t\t\tprintf(\"ret: %d\\nvec = {\", ret);\n\t\t\t\tREP(i,vec.size()){\n\t\t\t\t\tprintf(\"%f, \", vec[i]);\n\t\t\t\t}\n\t\t\t\tprintf(\"}\\n\");\n\t\t\t}\n\t\t\t//*/\n\t\t\treturn ret;\n\t\t\t\n\t\t}\n\t\n\t\tint j2 = j+1;\n\t\tfor (; j2<m; j2++){\n\t\t\tif (!((used>>j2) & 1)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tret = max(ret, dfs(j2, used, vec));\n\n\t\tused -= 1<<k;\n\t\tvec.pop_back();\n\t}\n\t\n\treturn ret;\n\t\n}\n\nint main(){\n\tvector<double> vec;\n\tcin >> m;\n\tfor (int i=0; i<m; i++){\n\t\tcin >> x[i] >> y[i];\t\n\t\t// printf(\"x[%d]: %d\\n\", i, x[i]);\n\t}\n\t\n\tREP(j,m){\n\t\tfor (int k=j+1; k<m; k++){\n\t\t\tif (y[j]-y[k]==0){\n\t\t\t\ttilt[j][k] = 3000;\n\t\t\t}else{\n\t\t\t\ttilt[j][k] = (double)(x[j]-x[k])/(double)(y[j]-y[k]);\n\t\t\t}\n\t\t\t// printf(\"tilt[%d][%d] = %f\\n\", j, k, tilt[j][k]);\n\t\t}\n\t}\n\t\n\tcout << dfs(0, 0, vec) << endl;\n\t\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n\nbool paralell(P a, P b, P c, P d){\n  auto check=[](P a, P b, P c, P d){\n    b = P(b.first - a.first, b.second - a.second);\n    d = P(d.first - c.first, d.second - c.second);\n    //b.second / b.first == d.second / d.first;\n    return b.second * d.first == d.second * b.first;\n  };\n  return check(a, b, c, d) || check(a, b, d, c);\n}\n\nint n;\n\nvector<P> A;\n\nint used[1<<16], mem[1<<16];\nint dfs(int bit){\n  if(used[bit]++) return mem[bit];\n  \n  int res = 0;\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      if((bit >> i & 1) || (bit >> j & 1)) continue;\n      int cnt = 1;\n      int nbit = bit | (1<<i) | (1<<j);\n      for(int k=0;k<n;k++)\n\tfor(int l=k+1;l<n;l++){\n\t  if((nbit>>k&1) || (nbit>>l&1)) continue;\n\t  if(!paralell(A[i], A[j], A[k], A[l])) continue;\n\t  nbit |= (1<<k) | (1<<l);\n\t  cnt++;\n\t}\n      Max(res, dfs(nbit) + cnt * (cnt - 1) / 2);\n    }\n  }\n  return mem[bit] = res;\n}\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n  cin>>n;\n  A.resize(n);\n  cin>>A;\n\n  int ans = dfs(0);\n  cout<<ans<<endl;  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < int(n); ++i)\n#define REPE(i, a, b) for (int i = (a); i <= int(b); ++i)\n#define SZ(x) ((int)(x).size())\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n#define EB emplace_back\nusing LL = long long;\nusing PII = pair<int, int>;\n#define F first\n#define S second\nvoid R(int &x) { scanf(\"%d\", &x); }\nvoid R(LL &x) { scanf(\"%lld\", &x); }\nvoid R(double &x) { scanf(\"%lf\", &x); }\ntemplate <typename T> void R(T &t) { cin >> t; }\ntemplate <typename T> void R(vector<T> &ar) {\n  for (auto &it : ar)\n    R(it);\n}\ntemplate <typename T, typename... Args> void R(T &t, Args &... args) {\n  R(t);\n  R(args...);\n}\n\nmap<PII, int> m;\nint add(int x, int y, int v) {\n  if (x == 0) y = 1;\n  else if (y == 0) x = 1;\n  else if (x < 0) x = -x, y = -y;\n  int g = __gcd(abs(x), abs(y));\n  x /= g, y /= g;\n  int r = m[{x, y}];\n  m[{x, y}] += v;\n  return r;\n}\n\nint n, x[22], y[22];\nbool v[22];\n\nint sum = 0, ans = 0;\nint md;\nvoid dfs(int a, int d) {\n  if (d * 2 == n) {\n    ans = max(ans, sum);\n    return;\n  }\n  while (v[a]) a++;\n  v[a] = true;\n  for (int i = a + 1; i < n; ++i) {\n    if (v[i]) continue;\n    v[i] = true;\n    int t = add(x[i] - x[a], y[i] - y[a], 1);\n    sum += t;\n    dfs(a + 1, d + 1);\n    add(x[i] - x[a], y[i] - y[a], -1);\n    sum -= t;\n    v[i] = false;\n  }\n  v[a] = false;\n}\n\nint main() {\n  R(n);\n  REP(i, n) R(x[i], y[i]);\n  dfs(0, 0);\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nint m;\nint x[16],y[16];\nint pairID[16] = {};\n\nint dfs(int h = 0){\n  int res = 0;\n  \n  if(h*2 == m){\n    // dy1/dx1 == dy2/dx2\n    int id = 0;\n    int dx[8], dy[8];\n    for(int i=0;i<m;i++){\n      if(pairID[i] > i){\n        dx[id] = x[pairID[i]] - x[i];\n        dy[id] = y[pairID[i]] - y[i];\n        id++;\n      }\n    }\n\n    int counter = 0;\n    \n    for(int i=0;i<m/2;i++){\n      for(int j=i+1;j<m/2;j++){\n        if(dx[i] == 0 || dx[j] == 0 || dy[i] == 0 || dy[j] == 0){\n          if(dx[i] == 0 && dx[j] == 0){\n            counter++;\n          }\n          if(dy[i] == 0 && dy[j] == 0){\n            counter++;\n          }\n        }else{\n          if(dy[i] * dx[j] == dy[j] * dx[i]){\n            counter++;\n          }\n        }\n      }\n    }\n\n    return counter;\n  }\n  \n  for(int i=0;i<m;i++){\n    if(pairID[i] == -1){\n\n      for(int j=i+1;j<m;j++){\n        if(pairID[j] == -1){\n          pairID[i] = j;\n          pairID[j] = i;\n          res = max(res,dfs(h+1));\n          pairID[i] = -1;\n          pairID[j] = -1;\n        }\n      }\n\n      break;\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  \n  scanf(\"%d\",&m);\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d\",x+i, y+i);\n    pairID[i] = -1;\n  }\n\n  printf(\"%d\\n\",dfs());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    /** output whole vector. ex) vector<int>{1, 2, 3} -> '1 2 3'. */\n    template<typename T>\n    ostream& operator<<(ostream& os, const vector<T>& xs) {\n       if (xs.empty()) return os << \"[]\";\n       os << \"[\" << xs[0];\n       for (auto i = 1; i < xs.size(); i++) os << ' ' << xs[i];\n       return os << \"]\";\n    }\n\n    const double EPS = 1e-8;\n    struct Point {\n        double x, y;\n        Point() {}\n        Point(double x, double y) : x(x), y(y) {}\n        Point operator-() const {\n            return Point(-x, -y);\n        }\n        Point operator-(const Point& p) const {\n            return Point(x - p.x, y - p.y);\n        }\n        Point unit() const {\n            auto d = sqrt(x*x + y*y);\n            return Point(x / d, y / d);\n        }\n    };\n    bool eq(const Point &a, const Point& b) {\n        return abs(a.x - b.x) < EPS && abs(a.y - b.y) < EPS;\n    }\n    int M;\n    vector<Point> P;\n    void input() {\n        cin >> M;\n        P.resize(M);\n        for (int i = 0; i < M; i++) {\n            cin >> P[i].x >> P[i].y;\n        }\n    }\n\n    const int N = 100;\n    int dp[N][N];\n    void init_pascal() {\n        memset(dp, 0, sizeof(dp));\n        dp[0][0] = 1;\n        for (int i = 1; i < N; i++) {\n            dp[i][0] = dp[i - 1][0];\n            for (int j = 1; j <= i; j++) {\n                dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]);\n            }\n        }\n    }\n    int comb(int n, int k) {\n        return dp[n][k];\n    }\n\n    struct Line {\n        Point a, b;\n        Line(Point a, Point b) : a(a), b(b) {}\n    };\n    bool parallel(Line& l, Line& s) {\n        auto p = l.b - l.a;\n        auto q = s.b - s.a;\n        return eq(p.unit(), q.unit()) || eq(-p.unit(), q.unit());\n    }\n\n    int memo[(1 << 16) + 10];\n    int f(int bit) {\n        auto& cache = memo[bit];\n        if (cache >= 0) return cache;\n        int ans = 0;\n        for (int i = 0; i < M; i++) {\n            if (bit & (1 << i)) continue;\n            for (int j = i + 1; j < M; j++) {\n                if (bit & (1 << j)) continue;\n                auto l = Line(P[i], P[j]);\n\n                vector<vector<int>> cands(M, vector<int>());\n                for (int k = 0; k < M; k++) {\n                    if (k == i || k == j) continue;\n                    if (bit & (1 << k)) continue;\n                    for (int x = k + 1; x < M; x++) {\n                        if (bit & (1 << x)) continue;\n                        auto s = Line(P[k], P[x]);\n                        if (parallel(l, s)) {\n                            cands[k].push_back(x);\n                        }\n                    }\n                }\n                //cout << \"(\" << i << \",\" << j << \")\" << endl << cands << endl;\n\n                // (k, x)??¨???????????????????????????????????????\n                function<int(int, int, int)> dfs = [&](int p, int bit, int count) {\n                    if (p == M) return f(bit) + comb(count + 1, 2);\n                    if (bit & 1 << p) return dfs(p + 1, bit, count);\n                    if (cands[p].empty()) return dfs(p + 1, bit, count);\n                    int ans = comb(count + 1, 2);\n                    for (auto c : cands[p]) {\n                        if (bit & (1 << c)) continue;\n                        auto nbit = bit | 1 << c | 1 << p;\n                        ans = max(ans, dfs(p, nbit, count + 1));\n                    }\n                    return ans;\n                };\n                ans = max(ans, dfs(0, bit | 1 << i | 1 << j, 0));\n            }\n        }\n        return cache = ans;\n    }\n\n    void solve() {\n        init_pascal();\n        memset(memo, -1, sizeof(memo));\n        cout << f(0) << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint m,x[16],y[16],dp[1<<16];\nbool s[1<<16][16][16],f[1<<16];\nint hei(int a,int b,int c,int d){return a*d-b*c;}\n\nint main(){\n  cin>>m;\n  for(int i=0;i<m;i++)cin>>x[i]>>y[i];\n  s[0][0][1]=1;\n  for(int i=0;i<1<<m;i++){\n    for(int a=0;a<m;a++)\n      for(int b=a+1;b<m;b++)\n\tif(s[i][a][b])\n\t  for(int c=0;c<m;c++)\n\t    if(!(i&1<<c))\n\t      for(int d=c+1;d<m;d++)\n\t\tif(!(i&1<<d))\n\t\t  if(!i||hei(x[a]-x[b],y[a]-y[b],x[c]-x[d],y[c]-y[d])==0)\n\t\t    s[i|1<<c|1<<d][c][d]=1;\n    for(int j=0;j<m;j++)\n      for(int k=j+1;k<m;k++)if(s[i][j][k])f[i]=1;\n  }\n  memset(dp,-1,sizeof(dp));\n  dp[0]=0;\n  int ans=0;\n  for(int i=0;i<1<<m;i++)\n    if(dp[i]!=-1)\n      for(int j=0;j<1<<m;j++){\n\tif(!(i&j)&&f[j]){\n\t  int a=__builtin_popcount(j)/2;\n\t  ans=max(ans,dp[i|j]=max(dp[i|j],dp[i]+a*(a-1)/2));\n\t}\n      }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nint n, x[20], y[20], ans;\nint v[10], w[10];\nbool used[20];\n\nbool is_parallel(int x, int y, int p, int q){\n    return x * q == y * p;\n}\n\nvoid dfs(int cur, int cnt){\n    if(cnt == n/2){\n        int tmp = 0;\n        rep(i, n/2)For(j, i+1, n/2){\n            tmp += is_parallel(x[w[i]]-x[v[i]], y[w[i]]-y[v[i]], x[w[j]]-x[v[j]], y[w[j]]-y[v[j]]);\n        }\n        chmax(ans, tmp);\n        return;\n    }\n    For(i, cur, n)if(!used[i]){\n        used[i] = true;\n        v[cnt] = i;\n\n        For(j, i+1, n)if(!used[j]){\n            used[j] = true;\n            w[cnt] = j;\n            dfs(i + 1, cnt + 1);\n            used[j] = false;\n        }\n\n        used[i] = false;\n        return;\n    }\n}\n\nint main(){\n    scanf(\"%d\", &n);\n    rep(i, n) scanf(\"%d%d\", &x[i], &y[i]);\n    dfs(0, 0);\n    printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <stack>\nusing namespace std;\n#define debug(x) std::cerr << #x << \" = \" << (x) << std::endl\ntypedef pair<int, int> PII;\ntypedef long long ll;\ntypedef unsigned long long ULL;\n\nlong long x[30], y[30], ans[30][30],vis[30][30];\n\nint main()\n{\n\tlong long m;\n\tlong long res;\n\tmemset(ans, 0, sizeof(ans));\n\tmemset(vis, 0, sizeof(vis));\n\tscanf(\"%d\", &m);\n\tfor(int i = 0; i < m; i++){\n\t\tscanf(\"%lld %lld\", &x[i], &y[i]);\n\t}\n\tfor(int i = 0; i < m; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tif(i == j) continue;\n\t\t\tfor(int k = 0; k < m; k++){\n\t\t\t\tfor(int l = k + 1; l < m; l++){\n\t\t\t\t\tif(k == i || k == j || l == i || l == j) continue;\n\t\t\t\t\tif(((y[j] - y[i]) * (x[k] - x[l])) == ((y[k] - y[l]) * (x[j] - x[i])) && vis[i][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvis[k][l] = 1;\n\t\t\t\t\t\tvis[l][k] = 1;\n\t\t\t\t\t\tvis[j][i] = 1;\n\t\t\t\t\t\tans[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long Max = -1;\n\tres = 0;\n\tfor(int i = 0; i < m; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tif(vis[i][j] == 0)\n\t\t\t{\n\t\t\t\tres += ans[i][j] * (ans[i][j] + 1) / 2;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double>P;\ntypedef pair<P, P> L;\n\nint n,ans,dp[1<<16];\nbool dp1[1<<16];\nvector<P>v;\ndouble EPS=1e-15,x,y;\n\ndouble cross(P a, P b){return (conj(a)*b).imag();}\n\nbool isparallel(L a,L b){\n  return cross(a.first-a.second,b.first-b.second) == 0.0 ;\n}\n\nvoid make(int a,int b){\n\n  memset(dp1,0,sizeof(dp1));\n\n  vector<int>g;\n\n  g.push_back((1<<a)+(1<<b));\n\n  for(int i=0;i<n;i++)if(i!=a&&i!=b){\n    for(int j=i+1;j<n;j++)if(j!=a&&j!=b){\n      if(isparallel(L(v[a],v[b]),L(v[i],v[j]))){\n        g.push_back((1<<i)+(1<<j));\n      }\n    }\n  }\n\n  dp1[0]=1;\n  int c=0;\n\n  for(int i=0;i<g.size();i++){\n    for(int j=0;j<(1<<n);j++)if(dp1[j]){\n      if((g[i]&j)==0)dp1[g[i]|j]=1;\n    }\n  }\n\n  for(int i=0;i<(1<<n);i++)\n    if(dp1[i]){\n      int t=__builtin_popcount(i);\n      t/=2;\n      dp[i]=(t-1)*t/2;\n    }\n}\nmain(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    v.push_back(P(x,y));\n  }\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      make(i,j);\n    }\n  }\n  for(int i=0;i<(1<<n);i++){\n    for(int j=0;j<(1<<n);j++){\n      if((i&j)==0){\n        dp[i|j]=max(dp[i|j],dp[i]+dp[j]);\n        ans=max(ans,dp[i|j]);\n      }\n    }\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#include <vector>\n#include <string>\n#include <utility>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <deque>\n#include <bitset>\n\n#include <cmath>\n#include <functional>\n\n#define ALL(a) (a).begin(), (a).end()\n#define FOR(i, a, b) for(int i = int(a); i < int(b); ++i)\n#define RFOR(i, a, b) for(int i = int(b)-1; i >= int(a); --i)\n#define REP(i, n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define IN(a, x ,b) (a<_x && x < b)\ntemplate<class T> inline T CHMAX(T& a, T& b){return a=(a<b)?b:a;}\ntemplate<class T> inline T CHMIN(T& a, T& b){return a=(a>b)?b:a;}\n\nusing ll = long long;\nconstexpr double PI = 3.1415926535897;\n\nusing std::vector;\nusing std::cout;\nusing std::endl;\nusing std::cin;\n\nint M;\nll ans = 0;\nll f(std::vector<int> &x,std::vector<int> &y,std::vector<int> &p){\n  std::vector<std::vector<std::pair<int,int>>>pp(M/2);\n  /*REP(i,M){\n    cout<<p[i]<<\" \";\n  }cout<<endl;*/\n  REP(i,M){\n    pp[p[i]].push_back({x[i],y[i]});\n  }\n  std::map<double,int>mp;\n  std::vector<double> v;\n  for(auto e:pp){\n    if(e.size()==1)continue;\n    //mp[atan((e[0].second-e[1].second)/(e[0].first-e[1].first))]++;\n    //v.push_back(atan((e[0].second-e[1].second)/(e[0].first-e[1].first)));\n    double theta = atan2((e[0].second-e[1].second),(e[0].first-e[1].first));\n    if(theta<0.0)theta+=PI;\n    v.push_back(theta);\n  }\n  int ret = 0;\n  REP(i,v.size()){\n    FOR(j,i+1,v.size()){\n      if(fabs(v[i]-v[j])<1e-6)ret++;\n      if(PI-fabs(v[i]-v[j])<1e-6)ret++;\n    }\n  }\n  return ret;\n}\n\nvoid dfs(int now,int cnt,std::vector<int>&x,std::vector<int> &y,std::vector<int>&p,int odd){\n/*\n  cout<<now<<\" \"<<cnt<<endl;\n  REP(i,M){\n    cout<<p[i]<<\" \";\n  }cout<<endl;*/\n  if(now==M){\n    ans=std::max(ans,f(x,y,p));\n  }\n  else{\n    if(p[now]!=-1){\n      dfs(now+1,cnt,x,y,p,odd);\n    }else{\n      int left=-1;\n      REP(i,M){\n        if(p[i]==-1){\n          left=i;\n          break;\n        }\n      }\n      p[left]=cnt;\n      if(odd){\n        dfs(now+1,cnt+1,x,y,p,0);\n      }\n      REP(i,M){\n        if(p[i]==-1){\n          p[i]=cnt;\n          dfs(now+1,cnt+1,x,y,p,odd);\n          p[i]=-1;\n        }\n      }\n      p[left]=-1;\n    }\n  }\n}\n\nint main(){\n  cin>>M;\n  std::vector<int>x(M),y(M);\n  REP(i,M)cin>>x[i]>>y[i];\n  std::vector<int>p(M,-1);\n  dfs(0,0,x,y,p,M%2);\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nconst int maxn = 400;\nstruct Point{\n   int x,y,idx;\n   Point (int x=0, int y=0,int idx = 0):x(x),y(y),idx(idx){}\n};\nPoint p[maxn];\nint n;\n\nint gcd(int x, int y) {return y==0?x:gcd(y,x%y); }\nint tx,ty,g;\n\nstruct node{\n   int ida,idb;\n   int x,y;\n   node () {}\n   node (Point a, Point b){\n        ida = a.idx;\n        idb = b.idx;\n        x = a.x-b.x;\n        y = a.y-b.y;\n        tx = abs(x);\n        ty = abs(y);\n        g = gcd(tx,ty);\n        x /= g; y /= g;\n\n        if (x<0 && y<0) {x=-x; y=-y; }\n        else if (x*y<0 && x<0) {x=-x; y=-y;}\n        else if (x==0) y=1;\n        else if (y==0) x=1;\n   }\n   bool operator ==(const node &rhs) const {\n      return x==rhs.x && y==rhs.y;\n   }\n}e[maxn];\n\nint tot,ans;\nbool vis[maxn];\nint v[maxn],cnt;\n\nvoid dfs(int pos,int num){\n   if (pos>=tot && num<n) return;\n   if (num>=n) {\n          int tmp = 0;\n          //printf(\"FAQ%d\\n\",cnt);\n          for (int i=0; i<cnt; i++)\n            for (int j=i+1; j<cnt; j++) if (e[v[i]]==e[v[j]]) tmp++;\n     ans = max(ans,tmp);\n     return ;\n   }\n\n   for (int i=pos; i<tot; i++) {\n      if (vis[e[i].ida] || vis[e[i].idb]) continue;\n            vis[e[i].ida] = vis[e[i].idb] = 1;\n            v[cnt++] = i;\n            dfs(i+1,num+2);\n            vis[e[i].ida] = vis[e[i].idb] = 0;\n            cnt--;\n   }\n}\n\nint main(){\n    int x,y;\n   //freopen(\"1.txt\",\"r\",stdin);\n    while (scanf(\"%d\",&n)==1) {\n         for (int i=1; i<=n; i++) {\n            scanf(\"%d%d\",&x,&y);\n            p[i] = Point(x,y,i);\n         }\n\n         tot = 0;\n         node u;\n         for (int i=1; i<=n; i++) {\n            for (int j=i+1; j<=n; j++) e[tot++] = node(p[i],p[j]);\n         }\n         ans = 0;\n\n         memset(vis,0,sizeof(vis));\n         memset(v,0,sizeof(v));\n         cnt = 0;\n         for (int i=0; i<n; i++) {\n            vis[e[i].ida] = vis[e[i].idb] = 1;\n            v[cnt++] = i;\n            dfs(n-2,2);\n            vis[e[i].ida] = vis[e[i].idb] = 0;\n            cnt--;\n         }\n         printf(\"%d\\n\",ans);\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef ONLINE_JUDGE\n    #define gc getchar\n    #define pc putchar\n#else\n    #define gc getchar_unlocked\n    #define pc putchar_unlocked\n#endif\n\nusing namespace std;\n\n#define vi vector<int>\n#define si set<int>\n#define vs vector<string>\n#define pii pair<int,int>\n#define vpi vector<pii>\n#define pri priority_queue<int>\n#define rev_pri priority_queue<int,vector<int>,greater<int> >\n#define mpi map<int,int>\n#define i64 long long int\n#define endl '\\n'\n#define pi acos(-1)\n#define all(v) v.begin(),v.end()\n#define pb push_back\n#define mp make_pair\n#define mod 1000000007\n#define inf INT_MAX/2\n#define infll LLONG_MAX/3\n#define For(i,n) for(int i=0;i<n;i++)\n#define Fre(i,a,b) for(int i = a; i < b; i++)\n#define sf(n) scanf(\"%d\", &n)\n#define sff(a,b) scanf(\"%d %d\", &a, &b)\n#define sfff(a,b,c) scanf(\"%d %d %d\", &a, &b, &c)\n#define pfn(n) printf(\"%d\\n\", n)\n#define pfs(n) printf(\"%d \", n)\n#define eps 1e-8\n#define ff first\n#define ss second\n#define mem(a,b) memset(a,b,sizeof(a))\n#define READ freopen(\"in.txt\", \"r\", stdin)\n#define WRITE freopen(\"out.txt\", \"w\", stdout)\n#define sz size()\n#define dbg(i) printf(\"yo %d\\n\", i)\n#define foreach(i,c) for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)\n#define sqr(a) (a) * (a)\n#define clr clear()\n#define CASE(a) printf(\"Case %d: \",a)\n\n//int dx[] = {0,1,0,-1,1,1,-1,-1};\n//int dy[] = {1,0,-1,0,1,-1,-1,1};\n\n\ni64 gcd(i64 a,i64 b){if(!b)return a;return gcd(b,a%b);}\n\n//inline void fastRead(int *a){register char c=0;while(c<33)c=gc();*a=0;while(c>33){*a=*a*10+c-'0';c=gc();}}\n\n//inline void fastWrite(int a){char snum[20];int i=0;do{snum[i++]=a%10+48;a=a/10;}while(a!=0);i=i-1;while(i>=0)pc(snum[i--]);pc('\\n');}\n\ni64 bigmod(i64 num,i64 n){if(n==0)return 1;i64 x=bigmod(num,n/2);x=x*x%mod;if(n%2==1)x=x*num%mod;return x;}\n\ni64 modinverse(i64 num){return bigmod(num,mod-2)%mod;}\n\n//i64 po(i64 a,i64 b){i64 ans=1;while(b--)ans *= a;return ans;}\n\n//i64 ncr(i64 n,i64 r){if(n==r)return 1;if(r==1)return n;if(dp[n][r]!=-1)return dp[n][r];return dp[n][r]=ncr(n-1,r)+ncr(n-1,r-1);}\n\n\n// bit manipulations\n\nbool checkbit(int mask,int bit){return mask & (1<<bit);}\n\nint setbit(int mask,int bit){ return mask  | (1<<bit) ; }\n\n//int clearbit(int mask,int bit){return mask & ~(1<<bit);}\n\n//int togglebit(int mask,int bit){return mask ^ (1<<bit);}\n\n\n\nint process(vpi dhal)\n{\n        int ans = 0;\n        For(i,dhal.sz)\n                Fre(j,i+1,dhal.sz)\n                        if(dhal[i].ss * dhal[j].ff == dhal[i].ff * dhal[j].ss)\n                                ans++;\n        return ans;\n}\n\nvpi v;\n\nint f(int pos,int mask,vpi dhal)\n{\n        if(pos==v.sz)\n                return process(dhal);\n        if(checkbit(mask,pos))\n                return f(pos+1,mask,dhal);\n\n        int ans = 0;\n\n\n        For(i,v.sz)\n                if(!checkbit(mask,i) && i!=pos)\n                {\n                        int nmask = setbit(mask,pos);\n                        nmask = setbit(nmask,i);\n                        dhal.pb (  mp( abs(v[pos].ff - v[i].ff) , abs(v[pos].ss - v[i].ss)  )   );\n                        ans = max( f(pos+1,nmask,dhal) , ans);\n                        dhal.pop_back();\n                }\n\n        return ans;\n\n}\n\nint main()\n{\n        int n,a,b;\n        sf(n);\n\n        while(n--)\n        {\n                sff(a,b);\n                v.pb(mp(a,b));\n        }\n        vpi gg;\n        cout << f(0,0,gg) << endl;\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n#define MAX_N 18\nint n;\nPoint ps[MAX_N];\nint pairs[MAX_N];\n\nint calcScore() {\n  int score = 0;\n  rep(i,n) {\n    Segment s1 = Segment(ps[i],ps[pairs[i]]);\n    REP(j,i+1,n) {\n      if( j == pairs[i] ) continue;\n      Segment s2 = Segment(ps[j],ps[pairs[j]]);\n      if( equals(cross(s1.p1-s1.p2,s2.p1-s2.p2),0) ) {\n\t++score;\n      }\n    }\n  }\n  return score/4;\n}\n\nint maxi;\nvoid dfs(int used) {\n  if( used == ((1<<n)-1) ) {\n    maxi = max(maxi,calcScore());\n    return;\n  }\n  int tmp = ~used;\n  tmp = tmp & -tmp;\n  int x = ( ( tmp == 0 ) ? 0 : log2(tmp) );\n  REP(i,x+1,n) {\n    if( ( (used>>i) & 1 ) ) continue;\n    pairs[x] = i;\n    pairs[i] = x;\n    dfs(used|(1<<x)|(1<<i));\n    pairs[i] = pairs[x] = -1;\n  }\n}\n\nvoid compute() {\n  maxi = 0;\n  memset(pairs,-1,sizeof pairs);\n  dfs(0);\n  cout << maxi << endl;\n}\n\nint main() {\n  if(0){\n  Segment s1 = Segment(Point(0,0),Point(1,0));\n  Segment s2 = Segment(Point(12,33),Point(10,10));\n  cout << (double)cross(s1.p1-s1.p2,s2.p1-s2.p2) << endl;\n  }\n  cin >> n;\n  rep(i,n) cin >> ps[i].x >> ps[i].y;\n  compute();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <list>\n#include <cstdlib>\n#include <memory>\n#include <cstring>\n#include <sstream>\n#include <list>\n#include <deque>\n#include <bitset>\n#include <vector>\n\nusing namespace std;\n\n#define INF 0x3f3f3f3f\n#define PI 3.141592653579\n#define FRER() freopen(\"input.txt\" , \"r\" , stdin);\n#define FREW()  freopen(\"output.txt\" , \"w\" , stdout);\n#define  QIO std::ios::sync_with_stdio(false)\n#define mem(a, b) memset(a , b , sizeof(a))\nconst double eps = 1e-8;\ntypedef long long ll;\nconst int maxn = 30;\nint cnt, n;\nll ans;\nint x[maxn], y[maxn];\nbool vis[maxn];\nstruct Vec\n{\n    int x, y;\n} vec[maxn * maxn];\nint res, cntl;\n\nbool isping(Vec a, Vec b)\n{\n    if (a.x * b.y - b.x * a.y == 0) return true;\n    return false;\n}\n\nvoid dfs(int cur)\n{\n//    while(cur < n && vis[cur]) cur++;\n    if (cur == n)\n    {\n        int cntp = 0;\n        for (int i = 0; i < cntl; i++)\n        {\n            for (int j = i + 1; j < cntl; j++)\n            {\n//                cout << /\"===\" << endl;\n                if (isping(vec[i], vec[j]))\n                {\n//                    cout << \"yes\" << endl;\n                    cntp++;\n                }\n            }\n        }\n        res = max(res, cntp);\n        return;\n    }\n    if (vis[cur]) dfs(cur + 1);\n    else\n    {\n        vis[cur] = true;\n        for (int i = cur + 1; i < n; i++)\n        {\n            if (vis[i] || i == cur) continue;\n            vis[i] = true;\n            vec[cntl].x = x[i] - x[cur];\n            vec[cntl++].y = y[i] - y[cur];\n            dfs(cur + 1);\n            vis[i] = false;\n            cntl--;\n        }\n        vis[cur] = false;\n    }\n\n}\n\n\nint main()\n{\n//    FRER();\n    mem(vis, false);\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++)\n        scanf(\"%d%d\", &x[i], &y[i]);\n    res = 0;\n    cntl = 0;\n    dfs(0);\n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nvp pos;\nint n;\nint ans;\n\nll gcd(ll a,ll b)\n{\n    if(a == 0 || b == 0){\n        return max(a,b);\n    }\n    if(a % b == 0){\n        return b;\n    }else{\n        return gcd(b,a%b);\n    }\n}\n\nP trans(int i,int j)\n{\n    int nx = pos[i].fi-pos[j].fi;\n    int ny = pos[i].se-pos[j].se;\n    int g = gcd(abs(nx),abs(ny));\n    if(nx < 0 || (nx == 0 && ny < 0)){\n        g = -g;\n    }\n    return P(nx/g,ny/g);\n}\n\nvoid dfs(int u,int used,int par,vp& kp)\n{\n    if(par == n/2){\n        map<P,int> mp;\n        rep(i,len(kp)){\n            mp[kp[i]]++;\n        }\n        int cri = 0;\n        each(it,mp){\n            if(it.se >= 2){\n                cri += it.se*(it.se-1)/2;\n            }\n        }\n        cmx(ans,cri);\n        return;\n    }\n    if((used >> u) & 1){\n        dfs(u+1,used,par,kp);\n    }else{\n        srep(i,u+1,n){\n            if(!((used >> i) & 1)){\n                kp.push_back(trans(u,i));\n                used ^= (1 << i);\n                dfs(u+1,used,par+1,kp);\n                used ^= (1 << i);\n                kp.pop_back();\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    pos.resize(n);\n    rep(i,n){\n        int u,v;\n        cin >> u >> v;\n        pos[i] = P(u,v);\n    }\n    vector<P> kp;\n    ans = 0;\n    dfs(0,0,0,kp);\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <iomanip>\n#include <climits>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <functional>\n#include <iterator>\n#include <bitset>\nusing namespace std;\n\n#define CORD_SIZE 1010\n#define SIZE 20\n\ntypedef struct _Node\n{\n    int x, y;\n} Node;\n\nNode arr[SIZE];\n\nbool cntState[SIZE];\n\nmap<long long int, int> mp;\n\nlong long int ans;\nint num;\n\nlong long int getId(int ka, int kb, int ksgn)\n{\n    return (1ll * ka * CORD_SIZE + kb) * ksgn;\n}\n\nvoid dfs(int cntNum)\n{\n    if (cntNum == num)\n    {\n        long long int cntAns = 0;\n        for (map<long long int, int>::iterator it = mp.begin(); it != mp.end(); ++it)\n        {\n            cntAns += (1ll * (it -> second) * (it -> second - 1)) >> 1;\n        }\n        ans = max(ans, cntAns);\n        return;\n    }\n\n\n    int i = 0;\n    while (cntState[i])\n        i++;\n\n    for (int j = i + 1; j < num; j++)\n    {\n        if (cntState[j])\n            continue;\n\n        int cntKa = arr[i].y - arr[j].y;\n        int cntKb = arr[i].x - arr[j].x;\n        int cntKsgn = 1;\n\n        if ((cntKa > 0) != (cntKb > 0))\n            cntKsgn = -1;\n\n        cntKa = abs(cntKa);\n        cntKb = abs(cntKb);\n\n        if (cntKb == 0)\n        {\n            cntKsgn = 1;\n            cntKa = 1;\n        }\n        else if (cntKa == 0)\n        {\n            cntKsgn = 1;\n            cntKb = 0;\n        }\n\n        if (cntKa != 0 && cntKb != 0)\n        {\n            int gcd = __gcd(cntKa, cntKb);\n            cntKa /= gcd;\n            cntKb /= gcd;\n        }\n\n        long long int id = getId(cntKa, cntKb, cntKsgn);\n        mp[id]++;\n        cntState[i] = true;\n        cntState[j] = true;\n        dfs(cntNum + 2);\n        mp[id]--;\n        cntState[i] = false;\n        cntState[j] = false;\n    }\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    while (cin >> num)\n    {\n        memset(cntState, false, sizeof(cntState));\n        mp.clear();\n        for (int i = 0; i < num; i++)\n        {\n            cin >> arr[i].x >> arr[i].y;\n        }\n\n        ans = 0;\n        dfs(0);\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <numeric>\nusing namespace std;\n\nint M;\nvector<int> X, Y;\n\nint nc2(int x){\n    if(x < 2)\n        return 0;\n    return x * (x-1) / 2;\n}\n\nint get_counts(map<pair<int, int>, int> &counts){\n    int res = 0;\n    for(auto p: counts)\n        res += nc2(p.second);\n    return res;\n}\n\npair<int, int> get_fraction(int i, int j){\n    int dx = X[i] - X[j];\n    int dy = Y[i] - Y[j];\n    int g = __gcd(dx, dy);\n    \n    return {dx/g, dy/g};\n}\n\nint dfs(int idx, int used, map<pair<int, int>, int> &counts){\n    if(idx == M){\n        return get_counts(counts);\n    }\n    \n    int res = -1;\n    if((used >> idx) & 1){\n        res = max(res, dfs(idx+1, used, counts));\n    }else{\n        for(int i=idx+1; i<M; i++) if(((used >> i) & 1) == 0){\n            int nused = used;\n            nused |= 1 << idx;\n            nused |= 1 << i;\n            \n            pair<int, int> fr = get_fraction(idx, i);\n            counts[fr]++;\n            res = min(res, dfs(idx+1, nused, counts));\n            counts[fr]--;\n        }\n    }\n    return res;\n}\n\nint main(){\n    cin >> M;\n    X.resize(M), Y.resize(M);\n    \n    for(int i=0; i<M; i++)\n        cin >> X[i] >> Y[i];\n    \n    map<pair<int, int>, int> counts;\n    cout << dfs(0, 0, counts) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\nusing namespace std;\ntemplate <class T> inline void chmax(T & a, T const & b) { a = max(a, b); }\ntemplate <typename T> T gcd(T a, T b) { while (a) { b %= a; swap(a, b); } return b; }\n\nint main() {\n    // input\n    int m; scanf(\"%d\", &m);\n    assert (m % 2 == 0);\n    vector<int> x(m), y(m);\n    REP (i, m) scanf(\"%d%d\", &x[i], &y[i]);\n    // solve\n    map<pair<int, int>, vector<int> > from_angle;\n    REP (j, m) REP (i, j) {\n        int dy = y[j] - y[i];\n        int dx = x[j] - x[i];\n        int d = gcd(abs(dy), abs(dx));\n        dy /= d;\n        dx /= d;\n        if (dy < 0) { dy *= -1; dx *= -1; }\n        if (dy == 0) dx = 1;\n        if (dx == 0) dy = 1;\n        from_angle[make_pair(dy, dx)].push_back((1 << i) | (1 << j));\n    }\n    vector<int> dp(1 << m, -1);\n    dp[0] = 0;\n    REP (s, 1 << m) if (dp[s] != -1) {\n        for (auto pairs : from_angle) {\n            vector<int> ts;\n            ts.push_back(0);\n            for (int dt : pairs.second) {\n                if (s & dt) continue;\n                for (int i = ts.size(); i --; ) {\n                    int t = ts[i] | dt;\n                    int k = __builtin_popcount(t) / 2;\n                    chmax(dp[s | t], dp[s] + k * (k - 1) / 2);\n                    ts.push_back(t);\n                }\n            }\n        }\n    }\n    // output\n    printf(\"%d\\n\", dp.back());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\nusing namespace std;\ntemplate <class T> inline void chmax(T & a, T const & b) { a = max(a, b); }\ntemplate <typename T> T gcd(T a, T b) { while (a) { b %= a; swap(a, b); } return b; }\n \nint main() {\n    // input\n    int m; scanf(\"%d\", &m);\n    assert (m % 2 == 0);\n    vector<int> x(m), y(m);\n    REP (i, m) scanf(\"%d%d\", &x[i], &y[i]);\n    // solve\n    map<pair<int, int>, vector<int> > from_angle;\n    REP (j, m) REP (i, j) {\n        int dy = y[j] - y[i];\n        int dx = x[j] - x[i];\n        int d = gcd(abs(dy), abs(dx));\n        dy /= d;\n        dx /= d;\n        if (dy < 0) { dy *= -1; dx *= -1; }\n        if (dy == 0) dx = 1;\n        if (dx == 0) dy = 1;\n        from_angle[make_pair(dy, dx)].push_back((1 << i) | (1 << j));\n    }\n    vector<int> dp(1 << m, -1);\n    dp[0] = 0;\n    REP (s, 1 << m) if (dp[s] != -1) {\n        for (auto pairs : from_angle) {\n            vector<int> ts;\n            ts.push_back(0);\n            for (int dt : pairs.second) {\n                if (s & dt) continue;\n                for (int i = ts.size(); i --; ) {\n                    int t = ts[i] | dt;\n                    int k = __builtin_popcount(t) / 2;\n                    chmax(dp[s | t], dp[s] + k * (k - 1) / 2);\n                    ts.push_back(t);\n                }\n            }\n        }\n    }\n    // output\n    printf(\"%d\\n\", dp.back());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    /** output whole vector. ex) vector<int>{1, 2, 3} -> '1 2 3'. */\n    template<typename T>\n    ostream& operator<<(ostream& os, const vector<T>& xs) {\n       if (xs.empty()) return os << \"[]\";\n       os << \"[\" << xs[0];\n       for (auto i = 1; i < xs.size(); i++) os << ' ' << xs[i];\n       return os << \"]\";\n    }\n\n    const double EPS = 1e-8;\n    struct Point {\n        double x, y;\n        Point() {}\n        Point(double x, double y) : x(x), y(y) {}\n        Point operator-() const {\n            return Point(-x, -y);\n        }\n        Point operator-(const Point& p) const {\n            return Point(x - p.x, y - p.y);\n        }\n        Point unit() const {\n            auto d = sqrt(x*x + y*y);\n            return Point(x / d, y / d);\n        }\n    };\n    bool eq(const Point &a, const Point& b) {\n        return abs(a.x - b.x) < EPS && abs(a.y - b.y) < EPS;\n    }\n    int M;\n    vector<Point> P;\n    void input() {\n        cin >> M;\n        P.resize(M);\n        for (int i = 0; i < M; i++) {\n            cin >> P[i].x >> P[i].y;\n        }\n    }\n\n    const int N = 100;\n    int dp[N][N];\n    void init_pascal() {\n        memset(dp, 0, sizeof(dp));\n        dp[0][0] = 1;\n        for (int i = 1; i < N; i++) {\n            dp[i][0] = dp[i - 1][0];\n            for (int j = 1; j <= i; j++) {\n                dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]);\n            }\n        }\n    }\n    int comb(int n, int k) {\n        return dp[n][k];\n    }\n\n    struct Line {\n        Point a, b;\n        Line(Point a, Point b) : a(a), b(b) {}\n    };\n    bool parallel(Line& l, Line& s) {\n        auto p = l.b - l.a;\n        auto q = s.b - s.a;\n        return eq(p.unit(), q.unit()) || eq(-p.unit(), q.unit());\n    }\n\n    int memo[(1 << 16) + 10];\n    int f(int bit) {\n        auto& cache = memo[bit];\n        if (cache >= 0) return cache;\n        int ans = 0;\n        for (int i = 0; i < M; i++) {\n            if (bit & (1 << i)) continue;\n            for (int j = i + 1; j < M; j++) {\n                if (bit & (1 << j)) continue;\n                auto l = Line(P[i], P[j]);\n\n                vector<vector<int>> cands(M, vector<int>());\n                for (int k = 0; k < M; k++) {\n                    if (k == i || k == j) continue;\n                    if (bit & (1 << k)) continue;\n                    for (int x = k + 1; x < M; x++) {\n                        if (bit & (1 << x)) continue;\n                        auto s = Line(P[k], P[x]);\n                        if (parallel(l, s)) {\n                            cands[k].push_back(x);\n                        }\n                    }\n                }\n                //cout << \"(\" << i << \",\" << j << \")\" << endl << cands << endl;\n\n                // (k, x)??¨???????????????????????????????????????\n                function<int(int, int, int)> dfs = [&](int p, int bit, int count) {\n                    if (p == M) return f(bit) + comb(count + 1, 2);\n                    if (bit & 1 << p) return dfs(p + 1, bit, count);\n                    if (cands[p].empty()) return dfs(p + 1, bit, count);\n                    int ans = comb(count + 1, 2);\n                    for (auto c : cands[p]) {\n                        if (bit & (1 << c)) continue;\n                        auto nbit = bit | 1 << c | 1 << p;\n                        ans = max(ans, dfs(p, nbit, count + 1));\n                    }\n                    return ans;\n                };\n                ans = max(ans, dfs(0, bit | 1 << i | 1 << j, 0));\n            }\n        }\n        return cache = ans;\n    }\n\n    void solve() {\n        init_pascal();\n        memset(memo, -1, sizeof(memo));\n        cout << f(0) << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>h\n\nusing namespace std;\n\nstruct Pos {\n  int x, y;\n};\n\nint N;\nPos p[16];\nvector<vector<int>> g;\n\nint gcd(int x, int y) {\n  if (y == 0) return x;\n  return gcd(y, x%y);\n}\n\npair<int, int> grad(const Pos&a, const Pos& b) {\n  int x = a.x - b.x;\n  int y = a.y - b.y;\n  int neg = x*y < 0 ? -1 : 1;\n  int g = gcd(abs(x), abs(y));\n  return make_pair((abs(x)/g), (abs(y)/g)*neg);\n}\n\nint cache[32][32][32][1<<16];\n\nint Solve(int i, int j, int c, int used) {\n  if (i == g.size()) return 0;\n  if (cache[i][j][c][used] >= 0) return cache[i][j][c][used];\n  if (j == g[i].size()) return Solve(i+1, 0, 0, used) + c * (c-1) / 2;\n  int a = Solve(i, j+1, c, used);\n  if ((used & g[i][j]) == 0) {\n    a = max(a, Solve(i, j+1, c+1, used | g[i][j]));\n  }\n  return cache[i][j][c][used] = a;\n}\n\nint main() {\n  while (cin >> N) {\n    memset(cache, -1, sizeof(cache));\n    for (int i = 0; i < N; ++i) {\n      cin >> p[i].x >> p[i].y;\n    }\n    map<pair<int, int>, vector<int>> cnt;\n    for (int i = 0; i < N; ++i) {\n      for (int j = i+1; j < N; ++j) {\n\tcnt[grad(p[i], p[j])].push_back((1<<i) | (1<<j));\n      }\n    }\n    g.clear();\n    for (const auto& kv : cnt) {\n      auto& c = kv.second;\n      if (c.size() > 1)\n\tg.push_back(c);\n    }\n    sort(g.begin(), g.end(), [](const auto& a, const auto& b){ return a.size() > b.size();});\n    cout << Solve(0, 0, 0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\ntypedef pair<int, int> pii;\nint gcd(int a, int b){\n    if(a%b==0) return b;\n    return gcd(b,a%b);\n}\n\nint n;\nbool used[17]={};\npii p[16];\nvector<pii> l;\nint solve(int curr){\n    if(used[curr]) return solve(curr+1);\n    if(curr == n){\n        int ret = 0;\n        for(int i=0; i<n/2; i++){\n            for(int j=i+1; j<n/2; j++){\n                if(l[i] == l[j]) ret++;\n            }\n        }\n        return ret;\n    }\n    int ret = 0;\n    for(int i=curr+1; i<n; i++){\n        if(used[i]) continue;\n        int a = p[curr].first -p[i].first;\n        int b = p[curr].second -p[i].second;\n        if(a == 0){\n            b = 1;\n        }else if(b == 0){\n            a = 1;\n        }else{\n            if(a < 0){\n                a = -a;\n                b = -b;\n            }\n            int d = gcd(a, abs(b));\n            a /= d;\n            b /= d;\n        }\n        used[i] = true;\n        l.emplace_back(a, b);\n        ret = max(ret, solve(curr+1));\n        l.pop_back();\n        used[i] = false;\n    }\n    return ret;\n}\n\nint main(){\n    cin >> n;\n    for(int i=0; i<n; i++){\n        cin >> p[i].first >> p[i].second;\n    }\n    cout << solve(0) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n#define _GLIBCXX_DEBUG // for STL debug\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint N, x[20], y[20], ans;\n\nbool is_parallel(pair<int, int> A, pair<int, int> B) {\n    // fprintf(stderr, \"A = (%lld, %lld), B = (%lld, %lld)\\n\", A.first, A.second, B.first, B.second);\n    // fprintf(stderr, \"result = %d\\n\", A.first * B.second - A.second * B.first == 0);\n    return A.first * B.second - A.second * B.first == 0;\n}\n\nvoid solve(int bit=0, vector< pair<int, int> > lines=vector< pair<int, int> >(), int cnt=0) {\n    for(int i=0; i<N; i++) {\n        if(!(bit >> i & 1)) {\n            for(int j=0; j<N; j++) {\n                if(i == j) continue;\n                if(bit >> j & 1) continue;\n\n                int nbit = bit | (1 << i) | (1 << j);\n                pair<int, int> vec(x[i] - x[j], y[i] - y[j]);\n                int ncnt = cnt;\n                for(auto L : lines) {\n                    ncnt += is_parallel(vec, L);\n                }\n\n                auto nlines = lines;\n                nlines.push_back(vec);\n                solve(nbit, nlines, ncnt);\n            }\n            return;\n        }\n    }\n    ans = max(ans, cnt);\n}\n\nsigned main() {\n    cin >> N;\n    for(int i=0; i<N; i++) {\n        cin >> x[i] >> y[i];\n    }\n    solve();\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\n\nstruct Point {\n\tint x, y;\n\tPoint operator - (const Point& p) const { return Point{x - p.x, y - p.y}; }\n};\n\nint m;\nPoint p[16];\n\nint cross(Point& a, Point& b) { return a.x * b.y - a.y * b.x; }\nbool is_para(Point& a, Point& b) { return cross(a, b) == 0; }\n\nint calc(vector< int >& a, vector< int >& b) {\n\tint res = 0;\n\tfor_(i,0,m/2) for_(j,i+1,m/2) {\n\t\tPoint ai = p[a[i]] - p[b[i]];\n\t\tPoint bi = p[a[j]] - p[b[j]];\n\t\tres += is_para(ai, bi);\n\t}\n\treturn res;\n}\n\nint rec(int i, vector< int >& a, vector< int >& b, vector< bool >& used) {\n\tif (i == m) return calc(a, b);\n\tif (used[i]) return rec(i+1, a, b, used);\n\t\n\tint ret = 0;\n\t\n\ta.push_back(i);\n\tused[i] = true;\n\t\n\tfor_(j,0,m) {\n\t\tif (used[j]) continue;\n\t\tb.push_back(j);\n\t\tused[j] = true;\n\t\tret = max(ret, rec(i+1, a, b, used));\n\t\tb.pop_back();\n\t\tused[j] = false;\n\t}\n\t\n\ta.pop_back();\n\tused[i] = false;\n\t\n\treturn ret;\n}\n\nint main() {\n\tcin >> m;\n\tfor_(i,0,m) cin >> p[i].x >> p[i].y;\t\n\tvector< int > a, b;\n\tvector< bool > used(m, false);\n\tcout << rec(0, a, b, used) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// 最初に自力で思いついた方法はまあまあ合ってた\n// 計算量解析を間違っていて、その方法が現実的で無いと\n// 思い込んでいた\n// 1.8e8\n#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nint gcd(int a, int b){\n    return b==0 ? a : gcd(b, a%b);\n}\n\ntypedef pair<int,int> pii;\n\nint main(){\n    int n;\n    cin >> n;\n    map<pii,vector<int>> m;\n    pii p[n];\n    for(int i = 0; i < n; i++){\n        cin >> p[i].first >> p[i].second;\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = i+1; j < n; j++){\n            int x = p[j].first-p[i].first;\n            int y = p[j].second-p[i].second;\n            int g = gcd(abs(x), abs(y));\n            x /= g, y /= g;\n            if(x < 0)   x *= -1, y *= -1;\n            // {0, -1}, {0, 1}を同一視したい\n            if(x == 0)  y = 1;\n            m[{x,y}].push_back((1<<i)+(1<<j));\n        }\n    }\n    vector<int> dp(1<<n, -1);\n    dp[0] = 0;\n    for(int s = 0; s < 1<<n; s++){\n        if(dp[s] == -1) continue;\n        for(auto p : m){\n            int siz = p.second.size();\n            for(int j = 0; j < 1<<siz; j++){\n                int ors = 0, flag = 0, popcnt = 0;\n                for(int k = 0; k < siz; k++){\n                    if(j>>k&1){\n                        ors |= p.second[k];\n                        if(s&p.second[k])   flag = 1;\n                        popcnt++;\n                    }\n                }\n                if(flag==0) dp[s|ors] = max(dp[s|ors], dp[s]+popcnt*(popcnt-1)/2);\n            }\n        }\n    }\n    cout << *max_element(dp.begin(), dp.end()) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\ninline long long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\n\nint main() {\n    int m; cin >> m;\n    vector<int> x(m), y(m);\n    for (int i = 0; i < m; i++) cin >> x[i] >> y[i];\n    map<pair<int, int>, vector<int>> angles;\n    for (int i = 0; i < m; i++) for (int j = 0; j < i; j++) {\n        int dy = y[j] - y[i], dx = x[j] - x[i];\n        int g = gcd(abs(dy), abs(dx));\n        dy /= g, dx /= g;\n        if (dy < 0) { dy = -dy, dx = -dx; }\n        if (dy == 0) dx = 1;\n        if (dx == 0) dy = 1;\n        angles[{dy, dx}].emplace_back(1 << i | 1 << j);\n    }\n    vector<int> dp(1 << m, -1);\n    dp[0] = 0;\n    for (int s = 0; s < 1 << m; s++) if (~dp[s]) {\n        for (auto &angle: angles) {\n            vector<int> ts;\n            ts.emplace_back(0);\n            for (int p: angle.second) if (!(s & p)) {\n                for (int i = ts.size() - 1; i >= 0; i--) {\n                    int t = ts[i] | p;\n                    int k = __builtin_popcount(t) / 2;\n                    chmax(dp[s | t], dp[s] + k * (k - 1) / 2);\n                    ts.emplace_back(t);\n                }\n            }\n        }\n    }\n    cout << dp.back() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> mypair;\n#define eps 1e-6\n#define equals(a,b) (fabs( (a) - (b) )< EPS )\n#define EPS eps\ntypedef struct point{\n\tdouble x,y;\n\tpoint(){};\n\tpoint(double x ,double y):x(x),y(y){};\n\tpoint operator + (point &p){ return point(x+p.x,y+p.y);\t}\n\tpoint operator - (point &p){ return point(x-p.x,y-p.y);\t}\n\tpoint operator * (point &p){ return point(x*p.x-y*p.y,x*p.y+y*p.x) ;}\n\tpoint operator * (double a){ return point(x*a,y*a);\t}\n\tpoint operator / (double a){ return point(x/a,y/a);\t}\n\t\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x+y*y; }\n\t\n\tbool operator < (const point &p) const { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (const point &p) const { return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS; }\n}point;\n\ndouble cross(point a,point b){ return a.x*b.y - a.y*b.x ; }//ﾂ外ﾂ静・zﾂ青ｬﾂ閉ｪ)ﾂ　aﾂ×b\nbool isparallel(point a,point b){ return equals(cross(a,b),0.0); }\ndouble dot(point a,point b){ return a.x*b.x+a.y*b.y ; } //ﾂ禿ﾂ静渉　aﾂ・b\npoint make(){ \n\tdouble x,y; cin>>x>>y;\n       \treturn point(x,y);\n}\nint dfs(int now,int m,int ans,vector<vector<point > > &ang,vector<bool>&used){\n\tif(now == m-1)return ans;\n\tif(!used[now]) return dfs(now+1,m,ans,ang,used);\n\tused[now] = false;\n\tint tmp = ans;\n       for(int i = 0;i< m;i++) if(used[i]){\n\tused[i] = false;\n\tint count = 1;\n\tvector<int> convert;\n\tconvert.push_back(i);\n\tpoint tmpang = ang[now][i] ;\n\t\tfor(int j = 0;j<m;j++){\n\t\t\tif(used[j] )for(int k = j+1;k<m;k++){\n\t\t\t\tif(used[k]){\n\t\t\t\t\tif(isparallel(tmpang,ang[j][k])){\n\t\t\t\t\tused[j] =false;\n\t\t\t\t\tused[k] = false;\n\t\t\t\t\tconvert.push_back(j);\n\t\t\t\t\tconvert.push_back(k);\n\t\t\t\t\tcount++;\n\t\t\t\t\tbreak;\t\n\t\t\t\t\t}\t\t\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t//\tcout<<endl<<\"debug\"<<now<<' '<<i<<' '<<count<<' '<<count*(count-1)/2<<endl;\n\t\ttmp = max(tmp,dfs(now+1,m,ans+(count*(count-1))/2,ang,used));\n\t\tfor(int j=0;j<convert.size();j++){\n\t\t\tused[convert[j]]  = true;\n\t\t//\tcout<<convert[j]<<' ';\n       \t\t}\n\t}\n\tused[now] = true;\n\treturn tmp;\t\n}\n\nint main(){\n\tint m;\n\tcin>>m;\n\tvector<point> p(m);\n\tfor(int i=0;i<m;i++){\n\tp[i] = make();\n\t}\n\tvector<vector<point> > ang(m,vector<point> (m) );\n\tfor(int i=0;i<m;i++){\n\n\t\tfor(int j=0;j<m;j++){\n\t\t\tang[i][j] = p[i]-p[j];\n\t\t}\n\t}\n\tvector<bool> used(m,true);\n\tcout<<dfs(0,m,0,ang,used)<<endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n  vector<pair<int, int> > ten;\n  int m;\n\nint gcd(int x, int y){\n  if(x>y)return gcd(y, x);\n  if(x==0)return y;\n  return gcd(x, y%x);\n}\n\nint calc(vector<pair<int, int> > &pairs){\n  map<pair<int, int>, int > katamuki;\n  for(int i=0;i<m/2;i++){\n    pair<int, int> pairr = make_pair(ten[pairs[i].first].first - ten[pairs[i].second].first, ten[pairs[i].first].second - ten[pairs[i].second].second  );\n    if(pairr.first == 0)katamuki[make_pair(0, 1)]++;\n    else{\n      if(pairr.first < 0){\n      pairr.first *= -1;\n      pairr.second *= -1;\n    }\n    int fuck = gcd(pairr.first, abs(pairr.second));\n      pairr.first /= fuck;\n      pairr.second /= fuck;\n    katamuki[pairr]++;\n\n  }\n}\nint ans=0;\nfor(auto i:katamuki){\n  ans += i.second * (i.second - 1)/2;\n}\nreturn ans;\n}\n\nint dfs(vector<pair<int, int> > &pairs , set<int> &rest){\n  if(pairs.size() == m/2)return calc(pairs);\n  int maxx = 0;\n  int i = *rest.begin();\n  rest.erase(i);\n    for(auto j: rest){\n      pairs.push_back(make_pair(i, j));\n      set<int> rest2 = rest;\n      rest2.erase(j);\n      maxx=max(maxx, dfs(pairs, rest2));\n      pairs.pop_back();\n    }\n    return maxx;\n}\n\nint main(){\n  scanf(\"%d\", &m);\n  for(int i=0;i<m;i++){\n    int x,y;\n    scanf(\"%d%d\", &x, &y);\n    ten.push_back(make_pair(x, y));\n  }\n  vector<pair<int, int> > pairs;\n  set<int> rst;\n  for(int i=0;i<m;i++)rst.insert(i);\n  int ans = dfs(pairs, rst);\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstruct point {\n\tint x, y;\n\tpoint operator +(const point &p)const {\n\t\treturn { x + p.x,y + p.y };\n\t}\n\tpoint operator -(const point &p)const {\n\t\treturn { x - p.x,y - p.y };\n\t}\n\tint Mul(point &p) {\n\t\treturn x*p.x + y*p.y;\n\t}\n}w[20];\nint n, Res, D[65536], U[65536];\nvoid Do(point a) {\n\tpoint A = { a.y,-a.x };\n\tint i, j, k;\n\tfor (i = 0; i < (1<<n); i++)D[i] = -1;\n\tD[0] = 0;\n\tfor (k = 0; k < (1 << n); k++) {\n\t\tif (D[k] == -1)continue;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = i + 1; j < n; j++) {\n\t\t\t\tint mask = (1 << i) | (1 << j);\n\t\t\t\tif (mask & k)continue;\n\t\t\t\tif ((w[j] - w[i]).Mul(A) == 0) {\n\t\t\t\t\tD[mask | k] = max(D[mask | k], D[k] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mask = (1 << n) - 1 - k;\n\t\tfor (i = mask; ; i = (i - 1)&mask) {\n\t\t\tU[i | k] = max(U[i | k], U[i] + D[k]*(D[k]-1)/2);\n\t\t\tif (!i)break;\n\t\t}\n\t}\n}\nint main() {\n\tint i, j;\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++)scanf(\"%d%d\", &w[i].x, &w[i].y);\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tDo(w[j] - w[i]);\n\t\t}\n\t}\n\tint res = 0;\n\tfor (i = 0; i < (1 << n); i++)res = max(res, U[i]);\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * 1379.cc: Parallel Lines\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_M = 16;\nconst int MAX_N = MAX_M * (MAX_M - 1) / 2;\n\n/* typedef */\n\ntemplate <typename T>\nstruct Pt {\n  T x, y;\n\n  Pt() {}\n  Pt(T _x, T _y) : x(_x), y(_y) {}\n  Pt(const Pt<T> &pt) : x(pt.x), y(pt.y) {}\n\n  Pt<T> operator+(const Pt<T> pt) const { return Pt<T>(x + pt.x, y + pt.y); }\n  Pt<T> operator-() const { return Pt<T>(-x, -y); }\n  Pt<T> operator-(const Pt<T> pt) const { return Pt<T>(x - pt.x, y - pt.y); }\n  Pt<T> operator*(T t) const { return Pt<T>(x * t, y * t); }\n  Pt<T> operator/(T t) const { return Pt<T>(x / t, y / t); }\n  T dot(Pt<T> v) const { return x * v.x + y * v.y; }\n  T cross(Pt<T> v) const { return x * v.y - y * v.x; }\n\n  bool operator==(const Pt<T> pt) const { return x == pt.x && y == pt.y; }\n  bool operator<(const Pt<T> &pt) const {\n    return x < pt.x || (x == pt.x && y < pt.y);\n  }\n  void print() { printf(\"(%d,%d)\", x, y); }\n};\n\ntypedef Pt<int> pt;\n\n/* global variables */\n\npt ps[MAX_M], vs[MAX_M][MAX_M], v[MAX_M], w[MAX_M];\nbool used[MAX_M];\nint maxpn = 0;\n\n/* subroutines */\n\ntemplate <typename T>\nT gcd(T m, T n) {  // m > 0, n > 0\n  if (m < n) swap(m, n);\n  while (n > 0) {\n    T r = m % n;\n    m = n;\n    n = r;\n  }\n  return m;\n}\n\nvoid normalize(pt &p) {\n  if (p.x != 0 || p.y != 0) {\n    if (p.x == 0) p.y = 1;\n    else if (p.y == 0) p.x = 1;\n    else {\n      if (p.x < 0) p.x = -p.x, p.y = -p.y;\n      int g = gcd(abs(p.x), abs(p.y));\n      if (g > 1) p.x /= g, p.y /= g;\n    }\n  }\n}\n\nvoid rec(int u, int m, int k) {\n  if (k >= m / 2) {\n    memcpy(w, v, sizeof(w));\n    sort(w, w + k);\n    int pn = 0;\n    for (int i = 0; i < k;) {\n      int j = i + 1;\n      while (j < k && w[i] == w[j]) j++;\n      int a = j - i;\n      pn += a * (a - 1) / 2;\n      i = j;\n    }\n    if (maxpn < pn) maxpn = pn;\n    return;\n  }\n\n  while (u < m && used[u]) u++;\n  used[u] = true;\n  for (int j = u + 1; j < m; j++)\n    if (! used[j]) {\n      used[j] = true;\n      v[k] = vs[u][j];\n      rec(u + 1, m, k + 1);\n      used[j] = false;\n    }\n  used[u] = false;\n}\n\n/* main */\n\nint main() {\n  int m;\n  scanf(\"%d\", &m);\n\n  for (int i = 0; i < m; i++) scanf(\"%d%d\", &ps[i].x, &ps[i].y);\n\n  for (int i = 0; i < m; i++)\n    for (int j = i + 1; j < m; j++) {\n      vs[i][j] = ps[j] - ps[i];\n      normalize(vs[i][j]);\n    }\n\n  rec(0, m, 0);\n\n  printf(\"%d\\n\", maxpn);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,a,b) for(int i=a;i<=b;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define vi vector<int>\n#define pb push_back\n#define pi pair<int,int>\n#define vp vector<pair<int,int>>\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define MEMSET(a) memset(a,0,sizeof(a))\n#define inf (1ll<<60)\n#define Yes(f) cout<<(f?\"Yes\":\"No\")<<endl\n#define yes(f) cout<<(f?\"yes\":\"no\")<<endl\n#define YES(f) cout<<(f?\"YES\":\"NO\")<<endl\n\nusing namespace std;\n\nconst int mod=1e9+7;\n\nvoid run();\n\nvoid init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(12);\n}\n\nsigned main(){\n    init();\n    run();\n    return 0;\n}\n\nint m;\nvp p,a,b;\nint ans=0;\nbool used[16];\nint u;\n\nvoid calc(){\n    int t=0;\n    rep(i,a.size()){\n        Rep(j,i+1,a.size()){\n            if((a[i].fi-b[i].fi)*(a[j].se-b[j].se)==(a[i].se-b[i].se)*(a[j].fi-b[j].fi)){\n                t++;\n            }\n        }\n    }\n    ans=max(ans,t);u++;\n}\n\nvoid rec(int k,int i){\n    if(k==m/2){\n        calc();\n        return;\n    }\n    if(i>=m)return;\n    if(used[i]){\n        rec(k,i+1);\n        return;\n    }\n    a.pb(p[i]);\n    used[i]=true;\n    rep(j,m){\n        if(used[j])continue;\n        b.pb(p[j]);\n        used[j]=true;\n        rec(k+1,i+1);\n        b.pop_back();\n        used[j]=false;\n    }\n    a.pop_back();\n    used[i]=false;\n}\n\nvoid run(){\n    cin>>m;\n    int x,y;\n    rep(i,m){\n        cin>>x>>y;\n        p.pb({x,y});\n    }\n    rec(0,0);\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, x[19], y[19], dp[65555][19][19]; bool vis[65555][19][19]; map<pair<int, int>, vector<pair<int, int> > > d; vector<vector<pair<int, int> > > v;\nint gcd(int pa, int pb) {\n\tif (pb == 0) return pa;\n\treturn gcd(pb, pa % pb);\n}\nint solve(int bit, int p1, int p2, int cur) {\n\tif (p1 == v.size()) return 0;\n\tif (p2 == v[p1].size()) {\n\t\tint res = solve(bit, p1 + 1, 0, 0);\n\t\treturn res + cur * (cur - 1) / 2;\n\t}\n\tif (vis[bit][p1][p2]) return dp[bit][p1][p2];\n\tint pa = v[p1][p2].first, pb = v[p1][p2].second;\n\tint ret = solve(bit, p1, p2 + 1, cur);\n\tif (!(bit & (1 << pa)) && !(bit & (1 << pb))) {\n\t\tint res = solve(bit | (1 << pa) | (1 << pb), p1, p2 + 1, cur + 1);\n\t\tret = max(ret, res);\n\t}\n\treturn ret;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint vx = x[j] - x[i], vy = y[j] - y[i];\n\t\t\tif (vy < 0) vy = -vy, vx = -vx;\n\t\t\tint g = gcd(abs(vx), vy);\n\t\t\td[make_pair(vx / g, vy / g)].push_back(make_pair(i, j));\n\t\t}\n\t}\n\tfor (pair<pair<int, int>, vector<pair<int, int> > > i : d) {\n\t\tv.push_back(i.second);\n\t}\n\tint ret = solve(0, 0, 0, 0);\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\ninline long long cross(pair<int, int> p1, pair<int, int> p2) {\n    return p1.first * p2.second - p1.second * p2.first;\n}\n\ninline bool isPall(pair<int, int> p1, pair<int, int> p2) {\n    return cross(p1, p2) == 0;\n}\n\nlong long bfs(long long i, vector<pair<int, int>> &xy, vector<bool> &used, int M, int d, vector<int> &ord) {\n\n    if (d == M / 2) {\n        long long ans = 0;\n        vector<pair<int, int>> vec(M / 2);\n        for (int j = 0; j < M / 2; j++) {\n            int l = j * 2;\n            int r = j * 2 + 1;\n            vec[j] = make_pair(xy[ord[l]].first - xy[ord[r]].first, xy[ord[l]].second - xy[ord[r]].second);\n        }\n        for (int j = 0; j < M / 2; j++) {\n            for (int k = j + 1; k < M / 2; k++) {\n                if (isPall(vec[j], vec[k])) ans++;\n            }\n        }\n        return ans;\n    }\n\n    long long ret = 0;\n    for (int j = i + 1; j < M; j++) {\n            swap(ord[i + 1], ord[j]);\n            ret = max(bfs(i + 2, xy, used, M, d + 1, ord), ret);\n        swap(ord[i + 1], ord[j]);\n    }\n    return ret;\n}\n\nint main() {\n\n    int M;\n    cin >> M;\n\n    vector<pair<int, int>> xy(M);\n    for (int i = 0; i < M; i++) {\n        int x, y;\n        cin >> x >> y;\n        xy[i] = make_pair(x, y);\n    }\n\n    vector<bool> used(M, false);\n    vector<int> ord(M);\n    for (int i = 0; i < M; i++) ord[i] = i;\n    auto ans = bfs(0, xy, used, M, 0, ord);\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,double> LP;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define all(x) x.begin(),x.end()\n\n#define inf 1e16\n\nll n;\nll x[1010],y[1010];\nmap<double,vector<P> > vs;\nvector<LP> as;\nbool used[1001];\n\nint main(){\n  cin>>n;\n  rep(i,n)cin>>x[i]>>y[i];\n  rep(i,n)rep(j,i){\n    ll dx=x[i]-x[j];\n    ll dy=y[i]-y[j];\n    /*\n    ll pdx=dx<0?-dx:dx;\n    ll pdy=dy<0?-dy:dy;\n    dbg(pdx); dbg(pdy);\n    ll g=__gcd(pdx,pdy);\n    dbg(pdx); dbg(pdy);\n    dbg(g);\n    P tmp;\n    if(dy<0) tmp=P(-dx/g,-dy/g);\n    else tmp=P(dx/g,dy/g);\n    */\n    if(dy!=0)vs[(double)dx/(double)dy].push_back(P(i,j));\n    else vs[dx<0?-inf:inf].push_back(P(i,j));\n  }\n\n  for(auto it : vs){\n    as.push_back(LP(it.se.size(),it.fi));\n  }\n  sort(all(as));\n  reverse(all(as));\n\n  ll res=0;\n\n  rep(i,as.size()){\n    ll cnt=0;\n    for(auto it : vs[as[i].se]){\n      if(used[it.fi]||used[it.se])continue;\n      used[it.fi]=true; used[it.se]=true;\n      cnt++;\n    }\n    res+=cnt*(cnt-1)/2;\n  }\n\n  cout<<res<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\n// <<<\n// >>> Point\ntemplate <class T>\nstruct Point {\n    T x,y;\n    constexpr Point(T x = 0, T y = 0) : x(x), y(y) {}\n    constexpr pair<T,T> to_pair() const { return {x,y}; }\n    constexpr Point inv() const { return {x/norm(),-y/norm()}; }\n    constexpr Point conj() const { return {x,-y}; }\n    constexpr T norm() const { return x*x + y*y; }\n    constexpr Point rot90(int n = 1) const {\n        n %= 4; if (n < 0) n += 4;\n        if (n == 1) return *this * Point(0,1);\n        if (n == 2) return *this * (-1);\n        if (n == 3) return *this * Point(0,-1);\n        return *this;\n    }\n    constexpr Point operator+() const { return *this; }\n    constexpr Point operator-() const { return {-x,-y}; }\n    constexpr Point operator+(Point const& p) const { return {x+p.x, y+p.y}; }\n    constexpr Point operator-(Point const& p) const { return {x-p.x, y-p.y}; }\n    constexpr Point operator*(Point const& p) const { return {x*p.x-y*p.y, x*p.y+y*p.x}; }\n    constexpr Point operator/(Point const& p) const { return *this * p.inv(); }\n    constexpr Point& operator+=(Point const& p) { return *this = *this + p; }\n    constexpr Point& operator-=(Point const& p) { return *this = *this - p; }\n    constexpr Point& operator*=(Point const& p) { return *this = *this * p; }\n    constexpr Point& operator/=(Point const& p) { return *this = *this / p; }\n    constexpr friend Point operator*(T const& a, Point const& p) { return Point(a)*p; }\n    constexpr friend Point operator/(T const& a, Point const& p) { return Point(a)/p; }\n    constexpr T dot(Point const& q) const { return x*q.x + y*q.y; }\n    constexpr T cross(Point const& q) const { return x*q.y - y*q.x; }\n\n    constexpr friend Point conj(Point const& p) { return p.conj(); }\n    constexpr friend T norm(Point const& p) { return p.x*p.x + p.y*p.y; }\n    constexpr friend T dot(Point const& p, Point const& q) { return p.dot(q); }\n    constexpr friend T cross(Point const& p, Point const& q) { return p.cross(q); }\n#ifdef LOCAL\n    friend string to_s(Point const& p) { return to_s(p.to_pair()); }\n#endif\n    friend istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }\n};\n// <<<\nusing P = Point<int>;\n\nint32_t main() {\n    int n; cin >> n;\n    vector<P> p(n); cin >> p;\n\n    vector<int> a(n,-1);\n    int ma = 0;\n    int debug_cnt = 0;\n    def (dfs, int i) -> void {\n        if (i < n) {\n            if (a[i] >= 0) {\n                dfs(i+1);\n            } else {\n                loop (j,i+1,<n) if (a[j] < 0) {\n                    a[i] = j, a[j] = i;\n                    dfs(i+1);\n                    a[j] = -1;\n                }\n                a[i] = -1;\n            }\n            return;\n        }\n        debug {\n            debug_cnt++;\n        }\n\n        static vector<P> v;\n        v.clear();\n        rep (i,n) if (i < a[i]) v.eb(p[i]-p[a[i]]);\n        int cnt = 0;\n        rep (i,n/2) rep (j,n/2) if (i < j && cross(v[i],v[j]) == 0) cnt++;\n        chmax(ma, cnt);\n    };\n    dfs(0);\n\n    cout << ma << endl;\n\n    debug {\n\n        int x = 1;\n        rep1 (i,n) if (i%2 == 1) x *= i;\n        dump(n,debug_cnt,x);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> Pa;\n\nint main(){\n    int M;\n    cin >> M;\n    vector<int> X(M),Y(M);\n    for(int i=0;i<M;i++) cin >> X[i] >> Y[i];\n    auto islinear = [&](Pa& p1,Pa& p2){\n        int dx1 = X[p1.second]-X[p1.first];\n        int dy1 = Y[p1.second]-Y[p1.first];\n        int dx2 = X[p2.second]-X[p2.first];\n        int dy2 = Y[p2.second]-Y[p2.first];\n        return dx1*dy2==dx2*dy1;\n    };\n    vector<int> used(M,0);\n    vector<pair<int,int>> P;\n    int ans = 0;\n    int c = 0;\n    const auto dfs = [&](auto& self,int dep) -> void{\n        if(P.size()==M/2){\n            int cnt = 0;\n            c++;\n            for(int i=0;i<M/2;i++) for(int j=i+1;j<M/2;j++) cnt += islinear(P[i],P[j]);\n            ans = max(ans,cnt);\n            return;\n        }\n        vector<int> v;\n        for(int i=0;i<M;i++) if(!used[i]) v.push_back(i);\n        for(int i=0;i<M-1-2*dep;i++){\n            P.push_back({v[0],v[i+1]});\n            used[v[0]] = used[v[i+1]] = 1;\n            self(self,dep+1);\n            P.pop_back();\n            used[v[0]] = used[v[i+1]] = 0;\n        }\n    };\n    dfs(dfs,0);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <cmath>\n#include <string>\nusing namespace std;\n\n#define MAX 100005\n\nint n, t;\nint h[MAX];\nint c[MAX];\nint s[MAX];\nint o[MAX];\n\nint main() {\n  scanf(\"%d %d\", &n, &t);\n\n  c[1] = 0;\n  s[1] = 0;\n  scanf(\"%d\", &h[1]);\n  for ( int i = 2; i <= n; i++ ) {\n    scanf(\"%d\", &h[i]);\n    c[i] = h[i - 1] + h[i - 2];\n    s[i] = h[i] > h[i - 1] ? 1 : 0;\n  }\n\n  // for ( int i = 1; i <= n; i++ ) {\n  //   printf(\"h:%d, c:%d, s:%d\\n\", h[i], c[i], s[i]);\n  // }\n\n  int t; // ????????????\n  int p; // ???\n  int q; // ?????????\n  int temp; // ???????????°\n  t = l - c[1];\n  p = l / h[1];\n  q = l % h[1];\n  if ( q == 0 ) {\n    p += 1;\n  }\n  o[1] = p;\n  printf(\"%d\", o[1]);\n  for ( int i = 2; i <= n; i++ ) {\n    t = l - c[i];\n    if (s[i] == 1 ) {\n      temp = h[i] - h[i - 1];\n    } else {\n      temp = h[i];\n    }\n    p = l / temp;\n    q = l % temp;\n    if ( q == 0 ) {\n      p += 1;\n    }\n    o[i] = p;\n    printf(\"%d\\n\", o[i]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nshort dp[16][16][10][1<<16];\ntemplate<typename T>\nvoid chmax(T &a,T b){\n  if(a<b) a=b;\n}\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n;\n  cin>>n;\n  using P = pair<Int, Int>;\n  vector<P> v;\n  for(Int i=0;i<n;i++){\n    Int x,y;\n    cin>>x>>y;\n    v.emplace_back(x,y);\n  }\n  vector<vector<P> > r(n,vector<P>(n)); \n  for(Int i=0;i<n;i++){\n    for(Int j=i+1;j<n;j++){\n      if(v[i].first==v[j].first){\n\tr[i][j]=P(0,1);\n\tcontinue;\n      }\n      if(v[i].second==v[j].second){\n\tr[i][j]=P(1,0);\n\tcontinue;\n      }\n      Int dx=v[i].first-v[j].first;\n       Int dy=v[i].second-v[j].second;\n       if(dx<0){\n\t dx*=-1;\n\t dy*=-1;\n       }\n       Int k=__gcd(dx,abs(dy));\n       dx/=k;dy/=k;\n       r[i][j]=P(dx,dy);\n       //cout<<i<<\" \"<<j<<\":\"<<dx<<\" \"<<dy<<endl;\n     }\n   }\n  memset(dp,-1,sizeof(dp));\n  //dp[0][0][0][0]=0;\n  for(Int i=0;i<n;i++){\n    for(Int j=i+1;j<n;j++){\n      dp[i][j][1][(1<<i)|(1<<j)]=0;\n    }\n  }\n  Int ans=0;\n  for(Int b=0;b<(1<<n);b++){\n    for(Int i=0;i<n;i++){\n      for(Int j=i+1;j<n;j++){\n\tfor(Int k=0;k<=n/2;k++){\n\t  if(dp[i][j][k][b]<0) continue;\n\t  //cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<b<<\":\"<<dp[i][j][k][b]<<endl;\n\t  for(Int s=0;s<n;s++){\n\t    for(Int t=s+1;t<n;t++){\n\t      if((b>>s)&1) continue;\n\t      if((b>>t)&1) continue;\n\t      Int nb=b|(1<<s)|(1<<t);\n\t      if(r[i][j]==r[s][t]){\n\t\tchmax(dp[s][t][k+1][nb],dp[i][j][k][b]+k);\n\t\tchmax(ans,dp[s][t][k+1][nb]);\n\t      }else{\n\t\tchmax(dp[s][t][1][nb],dp[i][j][k][b]);\n\t\tchmax(ans,dp[s][t][1][nb]);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n  }  \n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <ostream>\n#include <fstream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <math.h>\n#include <set>\n#define maxn 20\nusing namespace std;\nstruct Node\n{\n    int x,y;\n} node[maxn];\n\nbool vis[maxn];\nvector<pair<int,int> >vec;\nint ans = 0,n;\nvoid solve()\n{\n    int num = 0;\n    int all = vec.size();\n    for(int i=0; i<all; ++i)\n    {\n        int xx1 = node[vec[i].first].x-node[vec[i].second].x;\n        int yy1 = node[vec[i].first].y-node[vec[i].second].y;\n        for(int j=0; j<all; ++j)\n        {\n            if(i == j)continue;\n            int xx2 = node[vec[j].first].x-node[vec[j].second].x;\n            int yy2 = node[vec[j].first].y-node[vec[j].second].y;\n            if(xx1*yy2 == xx2*yy1)\n                ++num;\n        }\n    }\n    ans = max(ans,num);\n}\nvoid IDA(int a)\n{\n    if(a == n)\n    {\n        solve();\n        return;\n    }\n    if(vis[a] == 1)IDA(a+1);\n    else\n    {\n        for(int i=0; i<n; i++)\n        {\n            if(vis[i] || i == a) continue;\n            vec.push_back(make_pair(a,i));\n            vis[a] = vis[i] = 1;\n            IDA(a+1);\n            vec.pop_back();\n            vis[a] = vis[i] = 0;\n        }\n    }\n}\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    vec.clear();\n    cin>>n;\n    for(int i=0; i<n; i++)\n        cin>>node[i].x>>node[i].y;\n    memset(vis,0,sizeof(vis));\n    ans = 0;\n    IDA(0);\n    cout<<ans/2<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,double> LP;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define all(x) x.begin(),x.end()\n#define maxch(x,y) x=max(x,y)\n\n#define inf 1e16\n\nll n;\nll x[1010],y[1010];\nmap<P,vector<P> > vs;\nvector<ll> a,b;\n\nll dp[300][1<<16];\n\nint main(){\n  cin>>n;\n  rep(i,n)cin>>x[i]>>y[i];\n  rep(i,n)rep(j,i){\n    ll dx=x[i]-x[j];\n    ll dy=y[i]-y[j];\n\n    if(dx==0){\n      if(dy>0)vs[P(0,inf)].push_back(P(i,j));\n      else vs[P(0,-inf)].push_back(P(i,j));\n    }else if(dy==0){\n      vs[P(0,0)].push_back(P(i,j));\n    }else{\n      ll pdx=dx<0?-dx:dx;\n      ll pdy=dy<0?-dy:dy;\n      ll g=__gcd(pdx,pdy);\n\n      if(dy<0)vs[P(-dx/g,-dy/g)].push_back(P(i,j));\n      else vs[P(dx/g,dy/g)].push_back(P(i,j));\n    }\n  }\n\n  for(auto it : vs){\n    a.push_back(it.se.size()*(it.se.size()-1)/2);\n    ll tmp=0;\n    rep(i,it.se.size()){\n      tmp|=1<<it.se[i].fi;\n      tmp|=1<<it.se[i].se;\n    }\n    b.push_back(tmp);\n  }\n  ll m=a.size();\n\n  rep(i,m){\n    rep(S,1<<n){\n      maxch(dp[i+1][S],dp[i][S]);\n      if((S&b[i])==b[i])maxch(dp[i+1][S^b[i]],dp[i][S]+a[i]);\n    }\n  }\n\n  ll res=0;\n  rep(S,1<<n){\n    maxch(res,dp[m][S]);\n  }\n  cout<<res<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nshort dp[16][16][10][1<<16];\ntemplate<typename T1,typename T2>\nvoid chmax(T1 &a,T2 b){\n  if(a<b) a=b;\n}\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n;\n  cin>>n;\n  using P = pair<Int, Int>;\n  vector<P> v;\n  for(Int i=0;i<n;i++){\n    Int x,y;\n    cin>>x>>y;\n    v.emplace_back(x,y);\n  }\n  vector<vector<P> > r(n,vector<P>(n)); \n  for(Int i=0;i<n;i++){\n    for(Int j=i+1;j<n;j++){\n      if(v[i].first==v[j].first){\n\tr[i][j]=P(0,1);\n\tcontinue;\n      }\n      if(v[i].second==v[j].second){\n\tr[i][j]=P(1,0);\n\tcontinue;\n      }\n      Int dx=v[i].first-v[j].first;\n       Int dy=v[i].second-v[j].second;\n       if(dx<0){\n\t dx*=-1;\n\t dy*=-1;\n       }\n       Int k=__gcd(dx,abs(dy));\n       dx/=k;dy/=k;\n       r[i][j]=P(dx,dy);\n       //cout<<i<<\" \"<<j<<\":\"<<dx<<\" \"<<dy<<endl;\n     }\n   }\n  memset(dp,-1,sizeof(dp));\n  //dp[0][0][0][0]=0;\n  for(Int i=0;i<n;i++){\n    for(Int j=i+1;j<n;j++){\n      dp[i][j][1][(1<<i)|(1<<j)]=0;\n    }\n  }\n  Int ans=0;\n  for(Int b=0;b<(1<<n);b++){\n    for(Int i=0;i<n;i++){\n      for(Int j=i+1;j<n;j++){\n\tfor(Int k=0;k<=n/2;k++){\n\t  if(dp[i][j][k][b]<0) continue;\n\t  //cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<b<<\":\"<<dp[i][j][k][b]<<endl;\n\t  for(Int s=0;s<n;s++){\n\t    for(Int t=s+1;t<n;t++){\n\t      if((b>>s)&1) continue;\n\t      if((b>>t)&1) continue;\n\t      Int nb=b|(1<<s)|(1<<t);\n\t      if(r[i][j]==r[s][t]){\n\t\tchmax(dp[s][t][k+1][nb],dp[i][j][k][b]+k);\n\t\tchmax(ans,dp[s][t][k+1][nb]);\n\t      }else{\n\t\tchmax(dp[s][t][1][nb],dp[i][j][k][b]);\n\t\tchmax(ans,dp[s][t][1][nb]);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n  }  \n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100;\nint n;\nint x[N], y[N];\nint gcd(int a, int b) {return b ? gcd(b, a % b) : a;}\ntypedef pair<int, int> pii;\nmap<pii, pii> mp;\npii a[N];\nint m, ans;\nint sum;\ninline int calc(int x) {return x * (x - 1) >> 1;}\nvoid DFS(int cur, int d) {\n\tif(d > m) return;\n\tfor(int i = d; i <= m; i++) {\n\t\tif(!(cur & a[i].first)) {\n\t\t\tcur |= a[i].second;\n\t\t\tsum += calc(a[i].first);\n\t\t\tans = max(ans, sum);\n\t\t\tDFS(cur, i + 1);\n\t\t\tcur ^= a[i].second;\n\t\t\tsum -= calc(a[i].first);\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d\", &n);\n//\tfreopen(\"b.out\", \"w\", stdout);\n\tfor(int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d\", x + i, y + i);\n\t\tfor(int j = 0; j < i; j++) {\n\t\t\tint dx = x[i] - x[j], dy = y[i] - y[j];\n\t\t\tint d = gcd(dx, dy);\n\t\t\tdx /= d;\n\t\t\tdy /= d;\n\t\t\tif(dx < 0) dx = -dx, dy = -dy;\n//\t\t\tprintf(\"%d %d\\n\", dx, dy);\n\t\t\tpii np(dx, dy);\n\t\t\tif(mp.find(np) == mp.end()) {\n\t\t\t\tmp[np] = pii(1, (1 << i) | (1 << j));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmp[np].first ++;\n\t\t\t\tmp[np].second |= (1 << i) | (1 << j);\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto i = mp.begin(); i != mp.end(); i++) {\n\t\tif(i->second.first > 1) {\n\t\t\ta[++m] = i->second;\n\t\t\tif(m > (calc(n) >> 1)) for(;;);\n//\t\t\tprintf(\"%d\\n\", i->second.first);\n\t\t}\n\t}\n\tDFS(0, 1);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\n#include <cctype>\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//constexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\n\nint gcd(int x, int y)\n{\n\tint r;\n\tif (x < y) {\n\t\tswap(x, y);\n\t}\n\twhile (y > 0) {\n\t\tr = x % y;\n\t\tx = y;\n\t\ty = r;\n\t}\n\treturn x;\n}\n\nstruct Point {\n\tint x, y;\n\tPoint() :x(0), y(0) {}\n\tPoint(int x, int y) :x(x), y(y) {}\n};\n\nusing Points = vector<Point>;\npair<int, int> f(Point a, Point b) {\n\tif (a.x == b.x) {\n\t\treturn { inf,inf };\n\t}\n\ta.x -= b.x;\n\ta.y -= b.y;\n\tint g = gcd(abs(a.x), abs(a.y));\n\ta.x /= g;\n\ta.y /= g;\n\tif (a.x < 0) {\n\t\ta.x *= -1;\n\t\ta.y *= -1;\n\t}\n\treturn { a.x,a.y };\n}\n\n\n\nint main()\n{\n\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n; cin >> n;\n\tPoints p(n); for (int i = 0; i < n; i++) cin >> p[i].x >> p[i].y;\n\tmap<pair<int, int>, vector<pair<int, int>>> mp;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tmp[f(p[i], p[j])].emplace_back(i, j);\n\t\t}\n\t}\n\tvector<int> dp(1 << n);\n\tfor (int S = 0; S < (1 << n); S++) {\n\t\tfor (auto& e : mp) {\n\t\t\tauto& v = e.second;\n\t\t\tint nS = S;\n\t\t\tint cnt = 0;\n\t\t\tfor (auto& p : v) {\n\t\t\t\tif ((nS >> p.first & 1) or (nS >> p.second & 1)) continue;\n\t\t\t\tcnt++;\n\t\t\t\tnS |= (1 << p.first);\n\t\t\t\tnS |= (1 << p.second);\n\t\t\t}\n\t\t\tchmax(dp[nS], dp[S] + cnt * (cnt - 1) / 2);\n\t\t}\n\t}\n\tcout << dp[(1 << n) - 1] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nconst int maxn = 16 + 2;\nconst int INF = 0x3f3f3f3f;\n\nstruct Point {\n    int x;\n    int y;\n};\n\nPoint P[maxn];\nbool vis[maxn];\nint p1[maxn], p2[maxn];\nint n, ans;\ndouble slope[maxn];\n\ndouble get_slope(int a, int b) {\n    if (P[a].x == P[b].x)\n        return (double)INF;\n    return (double)(P[a].y - P[b].y) / (double)(P[a].x - P[b].x);\n}\n\nvoid dfs(int pr, int step) {\n    if (pr == n / 2) {\n        int k = 0;\n\n        for (int i = 0; i < n / 2; i++) {\n            slope[k++] = get_slope(p1[i], p2[i]);\n        }\n\n        int cnt = 0;\n\n        for (int i = 0; i < k; i++) {\n            for (int j = i + 1; j < k; j++) {\n                if (slope[i] == slope[j]) {\n                    cnt++;\n                }\n            }\n        }\n\n        if (ans <= cnt)\n            ans = cnt;\n        return;\n    }\n\n    for (int i = step; i < n; i++) {\n        if (!vis[i]) {\n            vis[i] = true;\n            p1[pr] = i;\n\n            for (int j = i + 1; j < n; j++) {\n                if (!vis[j]) {\n                    vis[j] = true;\n                    p2[pr] = j;\n                    dfs(pr + 1, i + 1);\n                    vis[j] = false;\n                }\n            }\n\n            vis[i] = false;\n            break;\n        }\n    }\n}\n\nint main() {\n    while (~scanf(\"%d\", &n)) {\n        memset(vis, false, sizeof(vis));\n        ans = 0;\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d%d\", &P[i].x, &P[i].y);\n        }\n        dfs(0, 0);\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nint main() {\n    int m; cin >> m;\n    vector<int> x(m), y(m);\n    for(int i = 0; i < m; ++i) {\n        cin >> x[i] >> y[i];\n    }\n\n    auto slope = [&] (int i, int j) {\n        if(x[i] == x[j]) return make_pair(0, 1);\n        if(y[i] == y[j]) return make_pair(1, 0);\n        if(x[i] > x[j]) swap(i, j);\n        const int g = __gcd(abs(y[j] - y[i]), x[j] - x[i]);\n        return make_pair((y[j] - y[i]) / g, (x[j] - x[i]) / g);\n    };\n\n    vector<pii> as;\n    function<int(int)> solve = [&] (int S) {\n        int res = 0;\n        if(S == (1 << m) - 1) {\n            map<pii, int> cnt;\n            for(auto& p : as) cnt[p] += 1;\n            for(auto& p : cnt) {\n                res += p.second * (p.second - 1) / 2;\n            }\n            return res;\n        }\n        int i = 0;\n        while(S & (1 << i)) i++;\n        for(int j = i + 1; j < m; ++j) {\n            if(S & (1 << j)) continue;\n            as.push_back(slope(i, j));\n            res = max(res, solve(S | (1 << j) | (1 << i)));\n            as.pop_back();\n        }\n        return res;\n    };\n\n    cout << solve(0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG_ \n#include \"../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\nusing R = long double;\nconst R EPS = 1e-10;\nint sgn(const R &r) { return (r>EPS) - (r<-EPS); }\nint sgn(const R &a, const R &b) { return sgn(a-b); }\n\nll n, ans, x[16], y[16];\nvoid dfs(vector<PII> v, vector<int> used, int last) {\n    if((int)v.size() == n/2) {\n        map<PII,ll> mp;\n        for(auto p: v) {\n            ll i = p.first, j = p.second;\n            PII a;\n            if(x[i] == x[j]) a = {INF, 1};\n            else {\n                ll g = __gcd(y[i]-y[j], x[i]-x[j]);\n                a = {(y[i]-y[j])/g, (x[i]-x[j])/g};\n            }\n            mp[a]++;\n        }\n        ll ret = 0;\n        for(auto p: mp) ret += p.second*(p.second-1)/2;\n        chmax(ans, ret);\n        return;\n    }\n\n    // last とペアにするやつを決める\n    FOR(i, last+1, n) {\n        if(used[i]) continue;\n        v.emplace_back(last, i);\n        used[last] = used[i] = true;\n        int nlast = last+1;\n        while(nlast<n && used[nlast]) nlast++;\n        dfs(v, used, nlast);\n        used[last] = used[i] = false;\n        v.pop_back();\n    }\n}\n\nint main(void) {\n    cin >> n;\n    REP(i, n) cin >> x[i] >> y[i];\n\n    vector<PII> v;\n    vector<int> used(n);\n    dfs(v, used, 0);\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef ONLINE_JUDGE\n    #define gc getchar\n    #define pc putchar\n#else\n    #define gc getchar_unlocked\n    #define pc putchar_unlocked\n#endif\n\nusing namespace std;\n\n#define vi vector<int>\n#define si set<int>\n#define vs vector<string>\n#define pii pair<int,int>\n#define vpi vector<pii>\n#define pri priority_queue<int>\n#define rev_pri priority_queue<int,vector<int>,greater<int> >\n#define mpi map<int,int>\n#define i64 long long int\n#define endl '\\n'\n#define pi acos(-1)\n#define all(v) v.begin(),v.end()\n#define pb push_back\n#define mp make_pair\n#define mod 1000000007\n#define inf INT_MAX/2\n#define infll LLONG_MAX/3\n#define For(i,n) for(int i=0;i<n;i++)\n#define Fre(i,a,b) for(int i = a; i < b; i++)\n#define sf(n) scanf(\"%d\", &n)\n#define sff(a,b) scanf(\"%d %d\", &a, &b)\n#define sfff(a,b,c) scanf(\"%d %d %d\", &a, &b, &c)\n#define pfn(n) printf(\"%d\\n\", n)\n#define pfs(n) printf(\"%d \", n)\n#define eps 1e-8\n#define ff first\n#define ss second\n#define mem(a,b) memset(a,b,sizeof(a))\n#define READ freopen(\"in.txt\", \"r\", stdin)\n#define WRITE freopen(\"out.txt\", \"w\", stdout)\n#define sz size()\n#define dbg(i) printf(\"yo %d\\n\", i)\n#define foreach(i,c) for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)\n#define sqr(a) (a) * (a)\n#define clr clear()\n#define CASE(a) printf(\"Case %d: \",a)\n\n//int dx[] = {0,1,0,-1,1,1,-1,-1};\n//int dy[] = {1,0,-1,0,1,-1,-1,1};\n\n\ni64 gcd(i64 a,i64 b){if(!b)return a;return gcd(b,a%b);}\n\n//inline void fastRead(int *a){register char c=0;while(c<33)c=gc();*a=0;while(c>33){*a=*a*10+c-'0';c=gc();}}\n\n//inline void fastWrite(int a){char snum[20];int i=0;do{snum[i++]=a%10+48;a=a/10;}while(a!=0);i=i-1;while(i>=0)pc(snum[i--]);pc('\\n');}\n\ni64 bigmod(i64 num,i64 n){if(n==0)return 1;i64 x=bigmod(num,n/2);x=x*x%mod;if(n%2==1)x=x*num%mod;return x;}\n\ni64 modinverse(i64 num){return bigmod(num,mod-2)%mod;}\n\n//i64 po(i64 a,i64 b){i64 ans=1;while(b--)ans *= a;return ans;}\n\n//i64 ncr(i64 n,i64 r){if(n==r)return 1;if(r==1)return n;if(dp[n][r]!=-1)return dp[n][r];return dp[n][r]=ncr(n-1,r)+ncr(n-1,r-1);}\n\n\n// bit manipulations\n\nbool checkbit(int mask,int bit){return mask & (1<<bit);}\n\nint setbit(int mask,int bit){ return mask  | (1<<bit) ; }\n\n//int clearbit(int mask,int bit){return mask & ~(1<<bit);}\n\n//int togglebit(int mask,int bit){return mask ^ (1<<bit);}\n\n\n#define set<pii> spi;\n\n\nint process(vpi dhal)\n{\n        int ans = 0;\n        For(i,dhal.sz)\n                Fre(j,i+1,dhal.sz)\n                        if(dhal[i].ss * dhal[j].ff == dhal[i].ff * dhal[j].ss)\n                                ans++;\n        return ans;\n}\n\nvpi v;\n\nint f(int pos,int mask,vpi dhal)\n{\n        if(pos==v.sz)\n                return process(dhal);\n        if(checkbit(mask,pos))\n                return f(pos+1,mask,dhal);\n\n        int ans = 0;\n\n\n        For(i,v.sz)\n                if(!checkbit(mask,i) && i!=pos)\n                {\n                        int nmask = setbit(mask,pos);\n                        nmask = setbit(nmask,i);\n                        dhal.pb (  mp( abs(v[pos].ff - v[i].ff) , abs(v[pos].ss - v[i].ss)  )   );\n                        ans = max( f(pos+1,nmask,dhal) , ans);\n                        dhal.pop_back();\n                }\n\n        return ans;\n\n}\n\nint main()\n{\n        int n,a,b;\n        sf(n);\n\n        while(n--)\n        {\n                sff(a,b);\n                v.pb(mp(a,b));\n        }\n        vpi gg;\n        cout << f(0,0,gg) << endl;\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  for(auto it = v.begin(); it != v.end(); it++) {\n    os << *it << \" \";\n  }\n  return os;\n}\n\nint main(int argc, char*argv[])\n{\n  int m;\n  vector<int> xs, ys;\n  cin >> m;\n  for(int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    xs.push_back(x);\n    ys.push_back(y);\n  }\n    /*\n      | x1 y1 1 |\n      | x2 y2 1 |\n      | x3 y3 1 |\n     */\n  auto area = [](int x1, int y1, int x2, int y2, int x3, int y3) {\n    return x1 * y2 + x2 * y3 + x3 * y1 - (x1 * y3 + x2 * y1 + x3 * y2) ;\n  };\n  // 1-2 and 3-4\n  auto isPara = [&xs,&ys,&area](int p1, int p2, int p3, int p4) {\n    int dx = xs[p1] - xs[p3];\n    int dy = ys[p1] - ys[p3];\n    return 0 == area(xs[p1], ys[p1], xs[p2], ys[p2], xs[p4] + dx, ys[p4] + dy);\n  };\n  int memo[m][m][m][m];\n  for(int i = 0; i < m; i++) {\n    for(int j = 0; j < m; j++) {\n      for(int k = 0; k < m; k++) {\n        for(int l = 0; l < m; l++) {\n          memo[i][j][k][l] = isPara(i,j,k,l) ? 1 : 0;\n        }\n      }\n    }\n  }\n  vector<bool> vss(m);  // choice of sources\n  for(int i = 0; i < m/2; i++) {\n    vss[i] = false;\n    vss[i+m/2] = true;\n  }\n  int mx = 0;\n  do {\n    //cout << vss << endl;\n    vector<int> ts, ss;\n    for(int i = 0; i < m; i++) {\n      if(!vss[i]) ts.push_back(i);\n      else ss.push_back(i);\n    }\n    do {\n      int pp = 0;\n      for(int i = 0; i < m/2; i++) {\n        for(int j = i+1; j < m/2; j++) {\n          pp += memo[ss[i]][ts[i]][ss[j]][ts[j]];\n        }\n      }\n      if(pp > mx) mx = pp;\n    } while(next_permutation(ts.begin(), ts.end()));\n  } while(next_permutation(vss.begin(), vss.end()));\n  cout << mx << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<map>\nusing namespace std;\ntypedef long long LL;\nstruct P{\n\tdouble x,y;\n}s[20];\ndouble dis[20][20];\nint vis[20][20],f[25],z;\nbool ans[20],qwe[20];\nint main(){\n\tint n;\n\tf[0]=0;\n\tfor(int i=1;i<=20;i++) f[i]=f[i-1]+i;\n\tfor(int i=1;i<=19;i++){\n\t\tfor(int j=1;j<=19;j++){\n\t\t\tvis[i][j]=0;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%lf%lf\",&s[i].x,&s[i].y);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(j==i) continue;\n\t\t\tif(s[i].x==s[j].x) dis[i][j]=1e7+2;\n\t\t\telse dis[i][j]=(s[i].y-s[j].y)/(s[i].x-s[j].x);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(j==i) continue;\n\t\t\tmemset(ans,0,sizeof(ans));\n\t\t\tans[i]=1;\n\t\t\tans[j]=1;\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tif(ans[k]==1) continue;\n\t\t\t\tfor(int h=1;h<=n;h++){\n\t\t\t\t\tif(ans[h]==1) continue;\n\t\t\t\t\tif(h==k) continue;\n\t\t\t\t\tif(dis[k][h]==dis[i][j]){\n\t\t\t\t\t\tvis[i][j]++;\n\t\t\t\t\t\tans[k]=1;\n\t\t\t\t\t\tans[h]=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint MAX=0;\n\t\t\tz=0;\n\t\t\tif(vis[i][j]>0){\n\t\t\t\tmemset(qwe,0,sizeof(qwe));\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tif(ans[k]==1) continue;\n\t\t\t\t\tif(qwe[k]==1) continue;\n\t\t\t\t\tfor(int h=1;h<=n;h++){\n\t\t\t\t\t\tif(h==k) continue;\n\t\t\t\t\t\tif(ans[h]==1) continue;\n\t\t\t\t\t\tif(qwe[h]==1) continue;\n\t\t\t\t\t\tfor(int o=1;o<=n;o++){\n\t\t\t\t\t\t\tif(o==h||o==k) continue;\n\t\t\t\t\t\t\tif(ans[o]==1) continue;\n\t\t\t\t\t\t\tif(qwe[o]==1) continue;\n\t\t\t\t\t\t\tfor(int p=1;p<=n;p++){\n\t\t\t\t\t\t\t\tif(p==h||p==k) continue;\n\t\t\t\t\t\t\t\tif(qwe[p]==1) continue;\n\t\t\t\t\t\t\t\tif(ans[p]==1) continue;\n\t\t\t\t\t\t\t\tif(p==o) continue;\n\t\t\t\t\t\t\t\tif(dis[o][p]==dis[k][h]){\n\t\t\t\t\t\t\t\t\tz++;\n\t\t\t\t\t\t\t\t\tqwe[o]=1;\n\t\t\t\t\t\t\t\t\tqwe[p]=1;\n\t\t\t\t\t\t\t\t\tqwe[k]=1;\n\t\t\t\t\t\t\t\t\tqwe[h]=1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tMAX+=z;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvis[i][j]=f[vis[i][j]]+f[MAX];\n\t\t}\n\t}\n\tint Max=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(j==i) continue;\n\t\t\tif(vis[i][j]>Max) Max=vis[i][j];\n\t\t}\n\t}\n\tif(n<=3) printf(\"0\\n\");\n\telse printf(\"%d\\n\",Max);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define P pair<int,int>\n#define PP pair<P,P>\n#define F first\n#define S second\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define rep(i,n) FOR(i,0,n)\n#define PB push_back\n\n\nint m,ans=0;\n\nvoid num(vector<PP> v){\n  int ret=0;\n  rep(i,v.size()){\n    FOR(j,i+1,v.size()){\n      int xi=v[i].F.F-v[i].S.F;\n      int yi=v[i].F.S-v[i].S.S;\n      int xj=v[j].F.F-v[j].S.F;\n      int yj=v[j].F.S-v[j].S.S;\n      if(xi<0){\n        xi*=-1;\n        yi*=-1;\n      }\n      if(xj<0){\n        xj*=-1;\n        yj*=-1;\n      }\n      if(xi*yj==xj*yi) ret++;\n    }\n  }\n\n  ans=max(ans,ret);\n}\n\nvoid comb(vector<P> v,bool b[],vector<PP> res){\n  int s=-1;\n  rep(i,m){\n    if(!b[i]){\n      s=i;\n      b[i]=true;\n      break;\n    }\n  }\n  if(s==-1){\n    num(res);\n    return;\n  }\n\n  rep(i,m){\n    if(!b[i]){\n      b[i]=true;\n      res.PB(PP(v[s],v[i]));\n      comb(v,b,res);\n      b[i]=false;\n      res.erase(res.begin()+res.size()-1);\n    }\n  }\n\n  b[s]=false;\n\n  \n}\n\nsigned main(){\n\n  cin>>m;\n  vector<P> v;\n  rep(i,m){\n    int x,y;\n    cin>>x>>y;\n    v.PB(P(x,y));\n  }\n\n  bool b[20]={};\n  comb(v,b,vector<PP>());\n\n  cout<<ans<<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing Number = double;\nconst Number EPS = 1e-10;\n\ninline int sign(Number x) { return (x < -EPS) ? -1 : (x > EPS) ? +1 : 0; }\ninline bool equal(Number a, Number b) { return sign(a - b) == 0; }\n\nclass Point {\npublic:\n    Number x, y;\n\n    Point() {}\n    Point(Number x, Number y) : x(x), y(y) {}\n\n    Point operator+(const Point &rhs) const {\n        return Point(this->x + rhs.x, this->y + rhs.y);\n    }\n    Point operator-(const Point &rhs) const {\n        return Point(this->x - rhs.x, this->y - rhs.y);\n    }\n};\n\ninline Number abs_cross(const Point &p1, const Point &p2) {\n    return p1.x * p2.y - p1.y * p2.x;\n}\n\nclass Line : public std::array<Point, 2> {\npublic:\n    Line() {}\n    Line(const Point &p1, const Point &p2) {\n        (*this)[0] = p1;\n        (*this)[1] = p2;\n    }\n};\ninline bool IsParallel(const Line &l1, const Line &l2) {\n    return equal(abs_cross(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\n\nint Search(const int i, const int m, vector<int> &idx, const vector<Point> &p) {\n    if (i == m - 2) {\n        int sum = 0;\n        vector<bool> check(m / 2, false);\n\n        for (int j = 0; 2 * j < m; ++j) {\n            if (check[j]) continue;\n\n            check[j] = true;\n            int num = 1;\n            Line l(p[idx[2 * j]], p[idx[2 * j + 1]]);\n            for (int k = j + 1; 2 * k < m; ++k)\n                if (IsParallel(l, Line(p[idx[2 * k]], p[idx[2 * k + 1]]))) {\n                    ++num;\n                    check[k] = true;\n                }\n            sum += num * (num - 1) / 2;\n        }\n        return sum;\n    }\n\n    int res = 0;\n    int min_idx = distance(idx.begin(), min_element(idx.begin() + i, idx.end()));\n    swap(idx[i], idx[min_idx]);\n    for (int j = i + 1; j < m; ++j) {\n        swap(idx[i + 1], idx[j]);\n        res = max(res, Search(i + 2, m, idx, p));\n        swap(idx[i + 1], idx[j]);\n    }\n    swap(idx[i], idx[min_idx]);\n\n    return res;\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    int m;\n\n    cin >> m;\n    vector<Point> p(m);\n    for (auto &pp : p) cin >> pp.x >> pp.y;\n\n    vector<int> idx(m);\n    iota(idx.begin(), idx.end(), 0);\n\n    cout << Search(0, m, idx, p) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<stack>\n#include<algorithm>\n#include<cstdio>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<iomanip>\n#include<cstring>\n#include<list>\n#include<typeinfo>\n#include<vector>\n\nusing namespace std;\n\nstruct point\n{\n    int x;int y;\n}a[20];\n\nstruct vectors\n{\n    int a;int b;\n}vec[1000];\n\nint m;\nint vis[20];\nint maxn,cnt;\n\nvoid judge()\n{\n    int ans = 0;\n    for(int i=0;i<cnt;i++)\n    {\n        for(int j=i+1;j<cnt;j++)\n        {\n            if(vec[i].a*vec[j].b==vec[j].a*vec[i].b)\n                ans++;\n        }\n    }\n    maxn=max(maxn,ans);\n}\n\nvoid dfs(int temp)\n{\n    while(vis[temp])\n        temp++;\n    if(temp>=m)\n    {\n        judge();\n        return;\n    }\n    vis[temp]=1;\n    for(int i=0;i<m;i++)\n    {\n        if(!vis[i]&&i!=temp)\n        {\n            vis[i] = 1;\n            vec[cnt].a = a[temp].x - a[i].x;\n            vec[cnt].b= a[temp].y - a[i].y;\n            cnt++;\n            dfs(temp+1);\n            cnt--;\n            vis[i] = 0;\n        }\n    }\n    vis[temp] = 0;\n}\n\n\nint main()\n{\n    cnt = 0;\n    scanf(\"%d\",&m);\n    for(int i=0;i<m;i++)\n        scanf(\"%d%d\",&a[i].x,&a[i].y);\n    maxn = 0;\n    dfs(0);\n    cout << maxn << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint m;\n\nstruct Seg{\n\tll dx, dy;\n};\n\nbool check(Seg s1, Seg s2){\n\treturn s1.dx * s2.dy - s1.dy * s2.dx == 0;\n}\n\nvector<Seg> s;\nint calc(){\n\tint ret = 0;\n\tfor(int i = 0; i < s.size(); i++){\n\t\tfor(int j = i + 1; j < s.size(); j++){\n\t\t\tif(check(s[i], s[j])) ret++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nll x[16], y[16];\n\nint ans;\n\nvoid dfs(ll bit){\n\tif(bit == (1 << m) - 1){\n\t\tans = max(ans, calc());\n\t\treturn;\n\t}\n\tfor(int i = 0; i < m; i++){\n\t\tif(bit >> i & 1) continue;\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tif(i == j || (bit >> j & 1)) continue;\n\t\t\tll nbit = bit | (1 << i) | (1 << j);\n\t\t\tll dx = x[i] - x[j];\n\t\t\tll dy = y[i] - y[j];\n\t\t\ts.push_back({ dx, dy });\n\t\t\tdfs(nbit);\n\t\t\ts.pop_back();\n\t\t}\n\t\tbreak;\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tcin >> m;\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\n\tdfs(0);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nmap< pair<int,int>, vector<int> > lns;\n\npair<int,int> f(int x,int y){\n\tint g = __gcd(x,y);\n\tx /= g;\n\ty /= g;\n\tif( x < 0 ) x *= -1, y *= -1;\n\treturn make_pair(x,y);\n}\n\nint main(){\n\tint m;\n\tcin >> m;\n\tvector< pair<int,int> > ps;\n\tfor(int i = 0 ; i < m ; i++){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tps.push_back({x,y});\n\t}\n\tfor(int i = 0 ; i < m ; i++){\n\t\tfor(int j = 0 ; j < i ; j++){\n\t\t\tlns[f(ps[i].first-ps[j].first,ps[i].second-ps[j].second)].push_back((1<<i) + (1<<j));\n\t\t}\n\t}\n\t\n\t\n\tint dp[2][1<<16][9];\n\tint cur = 0;\n\tint nex = 1;\n\tmemset(dp[cur],0xf0,sizeof(dp[cur]));\t\t\t\n\tdp[cur][0][0] = 0;\n\tfor( auto ls : lns ){\n\t\tfor(auto v : ls.second ){\n\t\t\tmemcpy(dp[nex],dp[cur],sizeof(dp[nex]));\t\t\t\n\t\t\tfor(int i = 0 ; i < (1<<16) ; i++){\n\t\t\t\tif( v & i ) continue;\n\t\t\t\tfor(int j = 0 ; j < 8 ; j++){\n\t\t\t\t\tdp[nex][i|v][j+1] = max(dp[nex][i|v][j+1], dp[cur][i][j] + j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(dp[cur],dp[nex]);\n\t\t}\n\t\tmemset(dp[nex],0xf0,sizeof(dp[nex]));\t\n\t\tfor(int i = 0 ; i < (1<<16) ; i++){\n\t\t\tfor(int j = 0 ; j < 9 ; j++){\n\t\t\t\tdp[nex][i][0] = max(dp[nex][i][0], dp[cur][i][j]);\n\t\t\t}\n\t\t}\n\t\tswap(cur,nex);\n\t}\n\tint ans = 0;\n\tfor(int i = 0 ; i < (1<<16) ; i++)\n\t\tans = max(ans,dp[cur][i][0]);\n\tcout << ans << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint x[16], y[16];\n\nint memo[1 << 16];\n\nint m;\n\nint calc(int s) {\n\tif (s == 0) return 0;\n\tif (__builtin_popcount(s) <= 3) return 0;\n\tif (memo[s] != -1) return memo[s];\n\tint res = 0;\n\tfor (int i = 0; i < m; i++) if (s & (1 << i)) {\n\t\ts -= 1 << i;\n\t\tfor (int j = i + 1; j < m; j++) if (s & (1 << j)) {\n\t\t\ts -= 1 << j;\n\t\t\tint cnt = 1;\n\t\t\tint tmp = s;\n\t\t\tfor (int k = 0; k < m; k++) if (s & (1 << k)) {\n\t\t\t\tfor (int l = k + 1; l < m; l++) if (s & (1 << l)) {\n\t\t\t\t\tif ((x[i] - x[j]) * (y[k] - y[l]) == (x[k] - x[l]) * (y[i] - y[j])) {\n\t\t\t\t\t\t++cnt;\n\t\t\t\t\t\ttmp -= 1 << k;\n\t\t\t\t\t\ttmp -= 1 << l;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = max(res, cnt * (cnt - 1) / 2 + calc(tmp));\n\t\t\ts += 1 << j;\n\t\t}\n\t\ts += 1 << i;\n\t}\n\treturn memo[s] = res;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tfor (int i = 0; i < (1 << m); i++) memo[i] = -1;\n\tcout << calc((1 << m) - 1) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unordered_map>\n\n//#include <ext/pb_ds/assoc_container.hpp> // Common file\n//#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update\n\n#define rep(i,n) for(i=1;i<=n;i++)\n#define Rep(i,n) for(i=0;i<n;i++)\n#define For(i,a,b) for(i=a;i<=b;i++)\n\n#define pb(x) push_back(x)\n#define sz(x) (int)x.size()\n\n#define mem(ara,val) memset(ara,val,sizeof(ara))\n#define eps 1e-5\n\n#define si(x) scanf(\"%d\",&x)\n#define sii(x,y) scanf(\"%d %d\",&x,&y)\n#define siii(x,y,z) scanf(\"%d %d %d\",&x,&y,&z)\n#define sl(x) scanf(\"%lld\",&x)\n#define sll(x,y) scanf(\"%lld %lld\",&x,&y)\n#define slll(x,y,z) scanf(\"%lld %lld %lld\",&x,&y,&z)\n#define ss(str) scanf(\"%s\",str)\n#define pi(x) printf(\"%d\",x)\n//#define pii(x,y) printf(\"%d %d\",x,y)\n#define piii(x,y,z) printf(\"%d %d %d\",x,y,z)\n#define pl(x) printf(\"%lld\",x)\n#define pll(x,y) printf(\"%lld %lld\",x,y)\n#define plll(x,y,z) printf(\"%lld %lld %lld\",x,y,z)\n#define NL printf(\"\\n\")\n#define Max 100005\n#define INF 1e18\n#define un(x) x.erase(unique( x.begin() , x.end() ), x.end())\n#define mod 1000000007\n\n#define FI freopen(\"z.txt\",\"r\",stdin)\n\n#define D(x) cout << #x << \" = \" << x << endl\n#define DD(x,y) cout << #x << \" = \" << x << \"   \" << #y << \" = \" << y << endl\n#define DDD(x,y,z) cout << #x << \" = \" << x << \"   \" << #y << \" = \" << y << \"   \" << #z << \" = \" << z << endl\n#define all(x) x.begin(),x.end()\n#define pc(x) __builtin_popcount(x)\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst double PI = acos(-1.0);\n\nusing namespace std;\n\nint setb(int n,int pos)\n{\n    return n=n | (1 << pos);\n}\nint resb(int n,int pos)\n{\n    return n=n & ~(1 << pos);\n}\nbool checkb(int n,int pos)\n{\n    return (bool)(n & (1 << pos));\n}\n\nLL bigmod(LL b,LL p,LL m)\n{\n    if( p == 0 ) return 1;\n    LL ret = bigmod(b,p/2,m);\n    ret = ( ret * ret ) % m;\n    if( p & 1 ) ret = ( ret * b ) % m;\n    return ret;\n}\n\nstruct info\n{\n    int x, y;\n};\ninfo ara[20];\nint n;\n\nmap < pair<int,int> , int > mp;\nint N;\nint get_slope(int idx1, int idx2)\n{\n    int dy = ( ara[idx1].y - ara[idx2].y );\n    int dx = ( ara[idx1].x - ara[idx2].x );\n    if( dx == 0 )\n    {\n        dy = 1;\n    }\n    else if( dy == 0 )\n    {\n        dx = 1;\n    }\n    else\n    {\n        int sx = dx / abs(dx);\n        int sy = dy / abs(dy);\n        int s = sx * sy;\n        dx = abs(dx);\n        dy = abs(dy);\n        int g = __gcd( dx , dy );\n        dx /= g;\n        dy /= g;\n        dx *= s;\n    }\n    if( mp.find( make_pair(dy,dx) ) == mp.end() ) mp[ make_pair(dy,dx) ] = ++N;\n    return mp[ make_pair(dy,dx) ];\n}\n\nint lol[20][20];\nvoid build()\n{\n    int i,j;\n    Rep(i,n)\n    {\n        Rep(j,n)\n        {\n            if( i == j ) continue;\n            lol[i][j] = get_slope(i,j);\n        }\n    }\n}\n\n\nbool visit[ (1 << 16) + 10 ];\nint cnt[505];\nint solve(int mask)\n{\n    int p[15], act[15], k = 0, l = 0;\n    for(int i = 0; i < n; i++)\n    {\n        if( checkb(mask,i) == 0 )\n        {\n            p[k++] = i;\n        }\n        else act[l++] = i;\n    }\n\n    int ret = 0;\n    int keep[15];\n    while( 1 )\n    {\n        int now = 0;\n        for(int i = 0; i < k; i++)\n        {\n            int my = lol[ act[i] ][ p[i] ];\n            now += cnt[my];\n            cnt[my]++;\n            keep[i] = my;\n        }\n        ret = max( ret , now );\n        for(int i = 0; i < k; i++) cnt[ keep[i] ]--;\n\n        bool f = next_permutation(p,p+k);\n        if( !f ) break;\n    }\n    return ret;\n}\n\nint super_solve()\n{\n    int ret = 0;\n    for(int mask = 0; mask < (1 << n); mask++)\n    {\n        if( 2 * pc(mask) == n )\n        {\n            int other = ( (1 << n) - 1 ) ^ mask;\n//            if( visit[ other ] ) continue;\n            visit[ mask ] = 1;\n            ret = max( ret , solve(mask) );\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    //FI;\n    int i;\n    si(n);\n    Rep(i,n)\n    {\n        sii(ara[i].x,ara[i].y);\n    }\n    build();\n    int ret = super_solve();\n    pi( ret ); NL;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nint x[16],y[16];\nint dp[1<<16];\nvector<P>v;\nint m;\nint Max=0;\nbool used[16];\n\nvoid dfs(){\n\tif(v.size()==m/2){\n\t\tint cnt=0;\n\t\trep(i,v.size())for(int j=i+1;j<v.size();j++){\n\t\t\tint a=x[v[i].first]-x[v[i].second],b=y[v[i].first]-y[v[i].second],\n\t\t\tc=x[v[j].first]-x[v[j].second],d=y[v[j].first]-y[v[j].second];\n\t\t\t\n\t\t\tif(a*d==b*c)cnt++;\n\t\t}\n\t\tMax=max(Max,cnt);return;\n\t}\n\tint i=0;\n\twhile(used[i])i++;\n\tfor(int j=i+1;j<16;j++){\n\t\tif(!used[i]&&!used[j]){\n\t\t\tv.push_back(P(i,j));\n\t\t\tused[i]=used[j]=true;\n\t\t\tdfs();\n\t\t\tused[i]=used[j]=false;\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d\",&m);\n\trep(i,m)cin>>x[i]>>y[i];\n\tdfs();\n\tcout<<Max<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n \nint x[16],y[16];\nvector<P>v;\nint m;\nint Max=0;\nbool used[16];\n \nvoid dfs(){\n    if(v.size()==m/2){\n        int cnt=0;\n        rep(i,v.size())for(int j=i+1;j<v.size();j++){\n            int a=x[v[i].first]-x[v[i].second],b=y[v[i].first]-y[v[i].second],\n            c=x[v[j].first]-x[v[j].second],d=y[v[j].first]-y[v[j].second];      \n            if(a*d==b*c){cnt++;continue;}\n            a=-a;b=-b;\n            if(a*d==b*c){cnt++;continue;}\n            a=-a;b=-b;\n            c=-c;d=-d;\n            if(a*d==b*c){cnt++;continue;}\n            a=-a;b=-b;\n            if(a*d==b*c){cnt++;continue;}\n        }\n        Max=max(Max,cnt);return;\n    }\n    int i=0;\n    while(used[i])i++;\n    for(int j=i+1;j<m;j++){\n        if(!used[j]){\n            v.push_back(P(i,j));\n            used[i]=used[j]=true;\n            dfs();\n            used[i]=used[j]=false;\n            v.pop_back();\n        }\n    }\n}\nint main(){\n    scanf(\"%d\",&m);\n    rep(i,m)cin>>x[i]>>y[i];\n    dfs();\n    cout<<Max<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,double> LP;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define all(x) x.begin(),x.end()\n#define maxch(x,y) x=max(x,y)\n\n#define inf 1e16\n\nll n;\nll x[1010],y[1010];\nmap<double,vector<P> > vs;\nvector<ll> a,b;\n\nll dp[300][1<<16];\n\nint main(){\n  cin>>n;\n  rep(i,n)cin>>x[i]>>y[i];\n  rep(i,n)rep(j,i){\n    ll dx=x[i]-x[j];\n    ll dy=y[i]-y[j];\n    /*\n    ll pdx=dx<0?-dx:dx;\n    ll pdy=dy<0?-dy:dy;\n    dbg(pdx); dbg(pdy);\n    ll g=__gcd(pdx,pdy);\n    dbg(pdx); dbg(pdy);\n    dbg(g);\n    P tmp;\n    if(dy<0) tmp=P(-dx/g,-dy/g);\n    else tmp=P(dx/g,dy/g);\n    */\n    if(dx!=0)vs[(double)dy/(double)dx].push_back(P(i,j));\n    else vs[dy<0?-inf:inf].push_back(P(i,j));\n  }\n\n  for(auto it : vs){\n    a.push_back(it.se.size()*(it.se.size()-1)/2);\n    ll tmp=0;\n    rep(i,it.se.size()){\n      tmp|=1<<it.se[i].fi;\n      tmp|=1<<it.se[i].se;\n    }\n    b.push_back(tmp);\n  }\n  ll m=a.size();\n\n  rep(i,m){\n    rep(S,1<<n){\n      maxch(dp[i+1][S],dp[i][S]);\n      if((S&b[i])==b[i])maxch(dp[i+1][S^b[i]],dp[i][S]+a[i]);\n    }\n  }\n\n  ll res=0;\n  rep(S,1<<n){\n    maxch(res,dp[m][S]);\n  }\n  cout<<res<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  for(auto it = v.begin(); it != v.end(); it++) {\n    os << *it << \" \";\n  }\n  return os;\n}\n\nint main(int argc, char*argv[])\n{\n  int m;\n  vector<int> xs, ys;\n  cin >> m;\n  for(int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    xs.push_back(x);\n    ys.push_back(y);\n  }\n    /*\n      | x1 y1 1 |\n      | x2 y2 1 |\n      | x3 y3 1 |\n     */\n  auto area = [](int x1, int y1, int x2, int y2, int x3, int y3) {\n    return x1 * y2 + x2 * y3 + x3 * y1 - (x1 * y3 + x2 * y1 + x3 * y2) ;\n  };\n  // 1-2 and 3-4\n  auto isPara = [&xs,&ys,&area](int p1, int p2, int p3, int p4) {\n    int dx = xs[p1] - xs[p3];\n    int dy = ys[p1] - ys[p3];\n    return 0 == area(xs[p1], ys[p1], xs[p2], ys[p2], xs[p4] + dx, ys[p4] + dy);\n  };\n  int memo[256][256];\n  for(int i = 0; i < m; i++) {\n    for(int j = 0; j < m; j++) {\n      for(int k = 0; k < m; k++) {\n        for(int l = 0; l < m; l++) {\n          memo[(i<<4)+j][(k<<4)+l] = isPara(i,j,k,l) ? 1 : 0;\n        }\n      }\n    }\n  }\n  vector<bool> vss(m);  // choice of sources\n  for(int i = 0; i < m/2; i++) {\n    vss[i] = false;\n    vss[i+m/2] = true;\n  }\n  int mx = 0;\n  do {\n    //cout << vss << endl;\n    vector<int> ts, ss;\n    for(int i = 0; i < m; i++) {\n      if(!vss[i]) ts.push_back(i);\n      else ss.push_back(i);\n    }\n    do {\n      int pp = 0;\n      for(int i = 0; i < m/2; i++) {\n        const int *mm = memo[(ss[i]<<4)+ts[i]];\n        for(int j = i+1; j < m/2; j++) {\n          pp += mm[(ss[j]<<4)+ts[j]];\n        }\n      }\n      if(pp > mx) mx = pp;\n    } while(next_permutation(ts.begin(), ts.end()));\n  } while(next_permutation(vss.begin(), vss.end()));\n  cout << mx << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint vis[200],m,ans=0;\ndouble k[30000];\nstruct sc\n{\n    int x,y;\n} s[200];\nbool flag=true;\nvoid update(int cnt)\n{\n    int sum=0;\n    for(int i=0; i<cnt; i++)\n        for(int j=i+1; j<cnt; j++)\n            if(k[j]==k[i])sum++;\n    ans=max(sum,ans);\n    flag=false;\n}\nvoid dfs(int i,int cnt)\n{\n    while(vis[i]&&i<=m)i++;\n    if(i==m+1)\n    {\n        update(cnt);\n        return ;\n    }\n    vis[i]=1;\n    for(int j=i+1; j<=m; j++)\n    {\n        if(vis[j])continue;\n        int a=s[i].x-s[j].x,b=s[i].y-s[j].y;\n        k[cnt]=(a==0?100000.0:1.0*b/a);\n        vis[j]=1;\n        dfs(0,cnt+1);\n        vis[j]=0;\n    }\n    vis[i]=0;\n}\nint main()\n{\n    scanf(\"%d\",&m);\n    memset(vis,0,sizeof vis);\n    for(int i=1; i<=m; i++)scanf(\"%d %d\",&s[i].x,&s[i].y);\n    vis[0]=1;\n    dfs(0,0);\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nint m;\nint x[16], y[16];\n// int used[16];\nvector<pii> v;\nint ans;\n\nint paralell(pii p, pii q) {\n  return p.first*q.second-p.second*q.first == 0;\n}\n\nvoid dfs(int s) {\n  int no = 1;\n  for (int i = 0; i < m; i++) {\n    if (s >> i & 1) continue;\n    // if (used[i]) continue;\n    for (int j = i+1; j < m; j++) {\n      if (s >> j & 1) continue;\n      // if (used[j]) continue;\n      no = 0;\n      s += 1 << i;\n      s += 1 << j;\n      // used[i] = used[j] = 1;\n      v.emplace_back(x[i]-x[j], y[i]-y[j]);\n      dfs(s);\n      v.pop_back();\n      s -= 1 << i;\n      s -= 1 << j;\n      // used[i] = used[j] = 0;\n    }\n    break;\n  }\n  if (no) {\n    int sum = 0;\n    for (int i = 0; i < v.size(); i++) {\n      for (int j = i+1; j < v.size(); j++) {\n        if (paralell(v[i], v[j])) sum++;\n      }\n    }\n    ans = max(ans, sum);\n  }\n}\n\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> x[i] >> y[i];\n  }\n  dfs(0);\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int, int>> pos;\nint m;\nvector<pair<int, int>> table;\n\nint dfs(bitset<16> s) {\n  int ans = 0;\n  if (s.count() == m) {\n    for (int i = 0; i < table.size(); ++i) {\n      for (int j = i + 1; j < table.size(); ++j) {\n        if (!(table[i].first * table[j].second - table[i].second * table[j].first)) {\n          ans++;\n        }\n      }\n    }\n    return ans;\n  } else {\n    int i, j;\n    for (i = 0; i < m; ++i) {\n      if (!s[i]) {\n        break;\n      }\n    }\n    for (j = i+1; j < m; ++j) {\n      if (!s[j]) {\n        table.push_back(pair<int, int>{pos[i].first - pos[j].first, pos[i].second - pos[j].second});\n        ans = max(dfs(s | bitset<16>(1 << i) | bitset<16>(1 << j)), ans);\n        table.pop_back();\n      }\n    }\n    return ans;\n  }\n}\n\nint main() {\n  cin >> m;\n  pos = vector<pair<int, int>>(m);\n  for (int i = 0; i < m; ++i) {\n    cin >> pos[i].first >> pos[i].second;\n  }\n  bitset<16> s;\n  cout << dfs(s) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\n#ifdef _WIN32\ninline unsigned int __builtin_ctz(unsigned int x) { unsigned long r; _BitScanForward(&r, x); return r; }\ninline unsigned int __builtin_clz(unsigned int x) { unsigned long r; _BitScanReverse(&r, x); return 31 - r; }\ninline unsigned int __builtin_ffs(unsigned int x) { unsigned long r; return _BitScanForward(&r, x) ? r + 1 : 0; }\ninline unsigned int __builtin_popcount(unsigned int x) { return __popcnt(x); }\n#endif // _WIN32\n#pragma pop_macro(\"long\")\n#endif // _MSC_VER\n/*---------------------------------------------------------------------------------------------------\n????????????????????????????????? ??§?????§  \n??????????????? ??§?????§ ???????´<_??? ?????? Welcome to My Coding Space!\n???????????? ??? ?´_???`??????/??? ???i     \n?????????????????????????????? ???  |???|     \n????????? /?????? /??£??£??£??£/??????|  \n??? ???_(__??????/???    ???/ .| .|????????????  \n??? ????????????/????????????/??????u??????  \n---------------------------------------------------------------------------------------------------*/\n \n\n\nint M, X[20], Y[20];\nint dp1[1 << 16];\nvector<pair<int, int>> dp2[1 << 16];\nint dp3[1 << 16];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> M;\n    rep(i, 0, M) cin >> X[i] >> Y[i];\n\n    dp1[0] = 1;\n    rep(a, 0, M) rep(b, a + 1, M) {\n        int msk = (1 << a) + (1 << b);\n        dp1[msk] = 1;\n        dp2[msk].push_back({X[b] - X[a], Y[b] - Y[a]});\n    }\n\n    rep(msk, 0, 1 << M) {\n        if (__builtin_popcount(msk) % 2 == 1) continue;\n        if (__builtin_popcount(msk) <= 3) continue;\n        rep(a, 0, M) if (msk & (1 << a)) rep(b, a + 1, M) if (msk & (1 << b)) {\n            int nmsk = msk - (1 << a) - (1 << b);\n            if (!dp1[nmsk]) continue;\n            \n            int dx = X[a] - X[b];\n            int dy = Y[a] - Y[b];\n\n            fore(p, dp2[nmsk]) {\n                if (dx * p.second == dy * p.first) {\n                    dp1[msk] = 1;\n                    dp2[msk].push_back(p);\n                }\n            }\n        }\n    }\n\n    rep(msk, 0, 1 << M) if(dp1[msk]) {\n        int c = __builtin_popcount(msk)/ 2;\n        dp3[msk] = c * (c - 1) / 2;\n    }\n\n    rep(msk, 0, 1 << M) {\n        for (int i = msk; i >= 0; i--) {\n            i &= msk;\n\n            dp3[msk] = max(dp3[msk], dp3[i] + dp3[msk - i]);\n        }\n    }\n\n    int ans = dp3[(1 << M) - 1];\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntypedef complex<int>P;\n\nint N;\nP p[16];\nbool ok[1<<16];\n\nint dp[1<<16];\nsigned main(){\n    cin>>N;\n    rep(i,N){\n        int a,b;cin>>a>>b;\n        p[i]=P(a,b);\n    }\n\n    rep(i,N){\n        for(int j=i+1;j<N;j++){\n            P d=p[j]-p[i];\n\n            vpint lis;\n            rep(k,N){\n                for(int l=k+1;l<N;l++){\n                    P dd=p[l]-p[k];\n                    if(real(d)*imag(dd)-imag(d)*real(dd)==0)lis.pb({k,l});\n                }\n            }\n\n            rep(i,1<<lis.size()){\n                int b=0;\n                rep(j,lis.size())if(i>>j&1)b|=(1<<lis[j].fi)|(1<<lis[j].se);\n                ok[b]=true;\n            }\n        }\n    }\n\n    fill_n(dp,1<<16,INT_MIN);\n    dp[0]=0;\n    rep(i,1<<N){\n        int sup=((1<<N)-1)^i;\n        int sub=sup;\n        do{\n            if(ok[sub]){\n                int c=__builtin_popcount(sub);\n                c/=2;\n                chmax(dp[i|sub],dp[i]+c*(c-1)/2);\n            }\n            sub=(sub-1)&sup;\n\n        }while(sub!=sup);\n    }\n    cout<<*max_element(dp,dp+(1<<N))<<endl;\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1379: Parallel Lines\n// 2017.12.20 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define INF 1e7\n#define EPS 1e-7\n#define EQ(a,b)   (fabs((a)-(b))<=EPS)\n\ntypedef struct { int n; double k; } T;\nT tbl[300]; int n;\n\nint x[16], y[16];\ndouble k[16][16];\nchar used[16];\n\nint cmp(T *a, T *b) { return b->n - a->n; }\n\nint main()\n{\n\tint m, i, j, u, v, p, cnt, ans;\n\tdouble t;\n\n\tscanf(\"%d\", &m);\n\tfor (i = 0; i < m; i++) scanf(\"%d%d\", x+i, y+i);\n\tfor (i = 0; i < m; i++) for (j = i+1; j < m; j++) {\n\t\tif (x[i] == x[j]) t = INF;\n\t\telse t = ((double)(y[i]-y[j])) / (x[i]-x[j]);\n\t\tk[i][j] = k[j][i] = t;\n\t}\n\n\tn = 0;\n\tfor (i = 0; i < m; i++) for (j = i+1; j < m; j++) {\n\t\tt = k[i][j];\n\t\tfor (u = i+1; u < m; u++) if (u != j) {\n\t\t\tfor (v = u+1; v < m; v++) {\n\t\t\t\tif (v != j && EQ(k[u][v], t)) {\n\t\t\t\t\tfor (p = 0; p < n; p++) {\n\t\t\t\t\t\tif (EQ(tbl[p].k, t)) { tbl[p].n++; break; } \n\t\t\t\t\t}\n\t\t\t\t\tif (p == n) tbl[p].n = 2, tbl[p].k = t, n++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!n) { puts(\"0\"); return 0; }\n\n\tqsort(tbl, n, sizeof(T), cmp);\n\tans = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tcnt = 0;\n\t\tfor (u = 0; u < m; u++) {\n\t\t\tif (used[u]) continue;\n\t\t\tfor (v = u+1; v < m; v++) {\n\t\t\t\tif (used[v]) continue;\n\t\t\t\tif (EQ(k[u][v], tbl[i].k)) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tused[u] = used[v] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans += cnt*(cnt-1)/2;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/**\n* 　　　┏┓　　　┏┓\n* 　　┏┛┻━━━┛┻┓\n* 　　┃　　　　　　　 ┃\n* 　　┃　　　━　　　 ┃\n* 　　┃　┳┛　┗┳　┃\n* 　　┃　　　　　　　 ┃\n* 　　┃　　　┻　　　 ┃\n* 　　┃　　　　　　　 ┃\n* 　　┗━┓　　　┏━┛Codes are far away from bugs with the animal protecting\n* 　　　　┃　　　┃    神兽保佑,代码无bug\n* 　　　　┃　　　┃\n* 　　　　┃　　　┗━━━┓\n* 　　　　┃　　　　　 ┣┓\n* 　　　　┃　　　　 ┏┛\n* 　　　　┗┓┓┏━┳┓┏┛\n* 　　　　　┃┫┫　┃┫┫\n* 　　　　　┗┻┛　┗┻┛\n**/\n\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 20;\nstruct Node\n{\n    int x, y;\n    Node(int x=0, int y=0): x(x), y(y) {}\n} pt[maxn];\n\nNode vec[maxn*maxn];\nint n;\nint vis[maxn];\nint ins;\nint sum;\n\nvoid dfs(int u)\n{\n    while(u<n&&vis[u]) u++;\n    if(u==n) {\n        int thisum=0;\n        for(int i=0;i<ins;i++){\n            for(int j=i+1;j<ins;j++) {\n                if(vec[i].x*vec[j].y==vec[i].y*vec[j].x) {\n                    thisum++;\n                }\n            }\n        }\n        sum=max(thisum, sum);\n        return ;\n    }\n    vis[u]=1;\n    for(int i=0;i<n;i++) {\n        if(!vis[i]) {\n            vis[i]=1;\n            vec[ins++]=Node(pt[i].x-pt[u].x,pt[i].y-pt[u].y);\n            dfs(u+1);\n            ins--;\n            vis[i]=0;\n        }\n    }\n    vis[u]=0;\n}\n\nint main()\n{\n    ///////////freopen(\"input.txt\", \"r\", stdin);\n    while(~scanf(\"%d\", &n)) {\n        for(int i=0;i<n;i++) {\n            scanf(\"%d%d\", &pt[i].x, &pt[i].y);\n        }\n        ins=0;\n        sum=0;\n        memset(vis, 0, sizeof(vis));\n        dfs(0);\n        cout << sum << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1379 Parallel Lines\n// 2018.3.9 bal4u\n\n#include <stdio.h>\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tif (c == '-') {\n\t\tc = getchar_unlocked();\n\t\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\t\twhile (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint gcd(int a, int b)\n{\n\tint r;\n\twhile (b != 0) r = a % b, a = b, b = r;\n\treturn a;\n}\n\n#define BASE 2000\n#define SFT  12\t\t// 2^12 = 4096\nint slope[16][16];\nint x[16], y[16];\nint dp[1<<16];\n\nint main()\n{\n\tint m, i, j, lim, s, a, b, f;\n\tint dx, dy;\n\n\tm = in(), lim = 1 << m;\n\tfor (i = 0; i < m; i++) x[i] = in(), y[i] = in();\n\n\tfor (i = 0; i < m; i++) for (j = i+1; j < m; j++) {\n\t\tdx = x[i] - x[j], dy = y[i] - y[j];\n\t\tif (dx < 0) dx = -dx, dy = -dy;\n\t\tif (!dx) dy = 1;\n\t\telse if (!dy) dx = 1;\n\t\telse {\n\t\t\ta = gcd(dx, dy); if (a < 0) a = -a;\n\t\t\tif (a > 1) dx /= a, dy /= a;\n\t\t}\n\t\tslope[i][j] = ((dx+BASE) << SFT) | (dy+BASE);\n\t}\n\n\tfor (s = 0; s < lim; s++) {\n\t\tfor (i = 0; i < m; i++) if ((1 << i) & s) {\n\t\t\tfor (j = i+1; j < m; j++) if ((1 << j) & s) {\n\t\t\t\tf = 0;\n\t\t\t\tfor (a = 0; a < m; a++) if ((1 << a) & s) {\n\t\t\t\t\tfor (b = a+1; b < m; b++) if ((1 << b) & s) {\n\t\t\t\t\t\tif (slope[i][j] == slope[a][b]) f++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tf = (f*(f-1)) >> 1;\n\t\t\t\tif (dp[s] < f) dp[s] = f;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (s = 0; s < lim; s++) for (i = s; i; i = i-1 & s) {\n\t\tif (dp[s] < (f = dp[i]+dp[i^s])) dp[s] = f;\n\t}\n\tprintf(\"%d\\n\", dp[lim-1]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n  static long[][] d;\n  static int m;\n  private static void solve() {\n    m = ni();\n    int[][] p = new int[m][2];\n    for (int i = 0; i < m;i ++) {\n      p[i][0] = ni();\n      p[i][1] = ni();\n      \n    }\n    d = new long[m][m];\n    for (int i = 0; i < m; i ++) {\n      for (int j = 0; j < m; j ++) {\n        d[i][j] = f(p[i], p[j]);\n      }\n    }\n    long ret = dfs(new HashMap<Long, Integer>(), new boolean[m], 0);\n    System.out.println(ret);\n  }\n  \n  static Map<String, Long> memo = new HashMap<>();\n  private static long dfs(Map<Long, Integer> now, boolean[] used, int depth) {\n    if (depth == m / 2) {\n      long ret = 0;\n      for (Map.Entry<Long, Integer> entry : now.entrySet()) {\n        int x = entry.getValue();\n        ret += x * (x - 1) / 2;\n      }\n      return ret;\n    }\n    \n    long ret = 0;\n    for (int i = 0; i < m; i ++) {\n      if (used[i]) continue;\n      used[i] = true;\n      \n      for (int j = i + 1; j < m; j ++) {\n        if (used[j]) continue;\n        \n        used[j] = true;\n        long key = d[i][j];\n        if (!now.containsKey(key)) {\n          now.put(key, 0);\n        }\n        int num = now.get(key);\n        now.put(key, num + 1);\n        long v = dfs(now, used, depth + 1);\n        ret = Math.max(ret, v);\n        now.put(key, num);\n        used[j] = false;\n      }\n      used[i] = false;\n      break;\n    }\n    return ret;\n  }\n\n\n  private static long f(int[] p1, int[] p2) {\n    if (p1 == p2) return -1;\n    int dx = p2[0] - p1[0];\n    int dy = p2[1] - p1[1];\n    \n    if (dx < 0) {\n      dx = -dx;\n      dy = -dy;\n    }\n    \n    int g = gcd(dx, Math.abs(dy));\n    dx /= g;\n    dy /= g;\n\n    return (long)dx * 1000000 + dy;\n    \n  }\n\n\n  public static int gcd(int a, int b) {\n    if (a > b) {\n      int tmp = a;\n        a = b;\n        b = tmp;\n    }\n    while (a != 0) {\n      int c = a;\n        a = b % c;\n        b = c;\n    }\n    return b;\n}\n  \n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Main {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        int m=sc.nextInt();\n        int[]x=new int[m],y=new int[m];\n        for(int i=0;i<m;++i){\n            x[i]=sc.nextInt();\n            y[i]=sc.nextInt();\n        }\n        int[]e=new int[1<<m];\n        for(int i=0;i<1<<m;++i){\n            if(Integer.bitCount(i)<4)continue;\n            int max=0;\n            for(int j=0;j<m;++j){\n                if((i&1<<j)==0)continue;\n                for(int k=0;k<m;++k){\n                    if(j==k||(i&1<<k)==0)continue;\n                    Map<Integer,Integer>hm=new HashMap<Integer,Integer>();\n                    for(int l=0;l<m;++l){\n                        if((i&1<<l)==0)continue;\n                        int cl=x[l]*(y[k]-y[j])-y[l]*(x[k]-x[j]);\n                        hm.put(cl,hm.getOrDefault(cl,0)+1);\n                    }\n                    int c=0;\n                    for(Integer el:hm.values()){\n                        if(el>=3)System.err.println(\"err hm=\"+hm);\n                        if(el>=2)\n                            c++;\n                    }\n                    max=Math.max(max,c);\n                }\n            }\n            e[i]=max*(max-1)/2;\n        }\n        //System.err.println(Arrays.toString(e));\n        int[]dp=new int[1<<m];\n        for(int i=1;i<1<<m;++i){\n            int b=i;\n            int max=e[i];\n            while(b>0){\n                max=Math.max(max,dp[b]+e[b^i]);\n                b=(b-1)&i;\n            }\n            dp[i]=max;\n        }\n        out.println(dp[(1<<m)-1]);\n        out.close();\n    }\n    // http://codeforces.com/blog/entry/7018\n    //-----------PrintWriter for faster output---------------------------------\n    public static PrintWriter out;\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine(){\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\npoints = (1..n).map { gets.split.map(&:to_i) }\n\na = [0] * (n / 2)\nk = n / 2 - 1\nmax = 0\n\nloop do\n  b = (0..n-1).to_a\n  c = []\n  k.downto(0) do |i|\n    c << b.shift\n    c << b.delete_at(a[i])\n  end\n\n  angles = c\n    .map{|i| points[i]}\n    .each_slice(2)\n    .map {\n      |p1, p2| p1[0] == p2[0] ? Float::INFINITY : (p2[1] - p1[1]) * 1000000 / (p2[0] - p1[0])\n    }\n  m = angles\n    .group_by(&:itself)\n    .values\n    .map(&:size)\n    .map {|s| s * (s - 1) / 2}\n    .inject(:+)\n  max = m if m > max\n  \n  a[k] += 1\n  while k > 0 && a[k] > 2 * k\n    a[k] = 0\n    a[k -= 1] += 1\n  end\n  break if k == 0\n  k = n / 2 - 1\nend\n\np max\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python3\n\nfrom fractions import Fraction\nimport os\nimport sys\n\n\ndef main():\n    M = read_int()\n    A = [Vec(*read_ints()) for _ in range(M)]\n    print(solve(M, A))\n\n\ndef solve(M, A):\n    D = [[None] * M for _ in range(M)]\n    last_did = 0\n    did_map = {}\n    for i in range(M):\n        for j in range(i + 1, M):\n            v = A[j] - A[i]\n            if v.y < 0 or (v.y == 0 and v.x < 0):\n                v = -v\n            c = Fraction(v.x ** 2, v.abs2())\n            if v.x < 0:\n                c = -c\n            if c not in did_map:\n                did_map[c] = last_did\n                did = last_did\n                last_did += 1\n            else:\n                did = did_map[c]\n            D[i][j] = did\n            D[j][i] = did\n\n    used = [False] * M\n    m = {}\n    best = 0\n\n    def rec(i):\n        nonlocal best\n        while i < M and used[i]:\n            i += 1\n        if i == M:\n            s = 0\n            for c in m.values():\n                s += c * (c - 1) // 2\n            best = max(best, s)\n            return\n\n        used[i] = True\n        for j in range(i + 1, M):\n            if used[j]:\n                continue\n            used[j] = True\n            d = D[i][j]\n            if d not in m:\n                m[d] = 1\n            else:\n                m[d] += 1\n            rec(i + 1)\n            m[d] -= 1\n            if m[d] == 0:\n                del m[d]\n            used[j] = False\n        used[i] = False\n\n    rec(0)\n    return best\n\n\n###############################################################################\n\nclass Vec(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        super().__init__()\n\n    def __add__(self, other):\n        return Vec(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vec(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, scalar):\n        return Vec(self.x * scalar, self.y * scalar)\n\n    def __rmul__(self, scalar):\n        return Vec(self.x * scalar, self.y * scalar)\n\n    def __truediv__(self, scalar):\n        return Vec(self.x / scalar, self.y / scalar)\n\n    def __iadd__(self, other):\n        self.x += other.x\n        self.y += other.y\n        return self\n\n    def __isub__(self, other):\n        self.x -= other.x\n        self.y -= other.y\n        return self\n\n    def __imul__(self, scalar):\n        self.x *= scalar\n        self.y *= scalar\n        return self\n\n    def __idiv__(self, scalar):\n        self.x /= scalar\n        self.y /= scalar\n        return self\n\n    def __neg__(self):\n        return Vec(-self.x, -self.y)\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return hash(('Vec', self.x, self.y))\n\n    def dot(self, other):\n        return self.x * other.x + self.y * other.y\n\n    def cross(self, other):\n        return self.x * other.y - self.y * other.x\n\n    def abs2(self):\n        return self.x * self.x + self.y * self.y\n\n    def __abs__(self):\n        return math.sqrt(float(self.abs2()))\n\n    def __repr__(self):\n        return '({}, {})'.format(self.x, self.y)\n\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef read_int():\n    return int(inp())\n\n\ndef read_ints():\n    return [int(e) for e in inp().split()]\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from fractions import gcd\nm = int(input())\nP = [list(map(int, input().split())) for _ in range(m)]\ntmp = {}\nfor i, pi in enumerate(P):\n    for j, pj in enumerate(P):\n        if i == j:\n            break\n        x = pi[0] - pj[0]\n        y = pi[1] - pj[1]\n        k = (x / gcd(x, y), y / gcd(x, y))\n        if k in tmp:\n            tmp[k].append([pi, pj])\n        else:\n            tmp[k] = [[pi, pj]]\n\ndic = {}\nfor t in tmp:\n    if len(tmp[t]) == 1:\n        continue\n    dic[t] = tmp[t]\n\nans = 0 \nfor d1 in dic:\n    line1 = []\n    line1.append(dic[d1])\n    used1 = [p for pp in dic[d1] for p in pp]\n    for d2 in dic:\n        tmp = []\n        for t in dic[d2]:\n            if t[0] in used1 or t[1] in used1:\n                continue\n            tmp.append(t)\n        if 1 == len(tmp):\n            continue\n        line2 = line1 + [tmp]\n        used2 = used1 + [p for pp in tmp for p in pp]\n\n        for d3 in dic:\n            tmp = []\n            for t in dic[d3]:\n                if t[0] in used2 or t[1] in used2:\n                    continue\n                tmp.append(t)\n            if 1 == len(tmp):\n                continue\n            line3 = line2 + [tmp]\n            used3 = used2 + [p for pp in tmp for p in pp]\n\n            for d4 in dic:\n                tmp = []\n                for t in dic[d4]:\n                    if t[0] in used3 or t[1] in used3:\n                        continue\n                    tmp.append(t)\n                    if 1 == len(tmp):\n                        continue\n                line4 = line3 + [tmp]\n                anstmp = 0\n                for l in line4:\n                    anstmp += len(l) * (len(l) - 1) / 2\n                ans = max(anstmp, ans)\nprint(int(ans))\n                        \n\n"
  },
  {
    "language": "Python",
    "code": "m = int(input())\nP = [list(map(int, input().split())) for i in range(m)]\ns = set()\nfor i in range(m):\n    xi, yi = P[i]\n    for j in range(i+1, m):\n        xj, yj = P[j]\n        u = xj - xi; v = yj - yi\n        for x, y in s:\n            if x * v == y * u:\n                break\n        else:\n            s.add((u, v))\nmemo = {}\ndef dfs(state, dx, dy):\n    if (state, dx, dy) in memo:\n        return memo[state, dx, dy]\n    pstate = state\n    update = 1\n    cnt = -1\n    while update:\n        update = 0; cnt += 1\n        for i in range(m):\n            if (state >> i) & 1:\n                continue\n            xi, yi = P[i]\n            for j in range(i+1, m):\n                if (state >> j) & 1:\n                    continue\n                xj, yj = P[j]\n                u = xj - xi; v = yj - yi\n                if dx * v == dy * u:\n                    update = 1\n                    state |= (1 << i) | (1 << j)\n                    break\n            if update: break\n    if cnt <= 1:\n        res = 0\n    else:\n        res = cnt*(cnt-1)//2 + max(dfs(state, *e) for e in s)\n    memo[pstate, dx, dy] = res\n    return res\nprint(max(dfs(0, *e) for e in s))"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n    n,k = LI()\n    ans = 0\n    for l in range(1,n+1):\n        for i in range(1000):\n            if i*k > l:break\n            j = l-i*k+i\n            if j%2:\n                j //= 2\n                j += 1\n                s = 1\n                for a in range(i):\n                    s *= j-a\n                    s //= a+1\n                ans += s\n    print(ans)\n    return\n\n\ndef dfs(d,k,f,n,nu,v,e):\n    global ans\n    if d == nu:\n        l = defaultdict(int)\n        for i in k:\n            l[i] += 1\n        res = 0\n        for i in l.values():\n            res += calc(i)\n        if res > ans:\n            ans = res\n    else:\n        for i in range(n):\n            if f[i]:\n                p = i\n                break\n        f_ = [f[i] if i != p else 0 for i in range(n)]\n        for q in range(p+1,n):\n            if f[q]:\n                m = e[(p,q)]\n                k_ = [k[i] if i != d else m for i in range(nu)]\n                f__ = [f_[i] if i != q else 0 for i in range(n)]\n                dfs(d+1,k_,f__,n,nu,v,e)\n\ndef calc(n):\n    return n*(n-1)//2\n\ndef gcd(a,b):\n    if a == 0:\n        return b\n    return gcd(b%a,a)\nans = 0\n#B\ndef B():\n    n = I()\n    nu = n//2\n    v = LIR(n)\n    v.sort()\n    e = defaultdict(set)\n    for p in range(n):\n        for q in range(p+1,n):\n            x,y = v[q][0]-v[p][0],v[q][1]-v[p][1]\n            if x == 0:\n                if y < 0:\n                    m = (0,-1)\n                else:\n                    m = (0,1)\n            elif y == 0:\n                m = (1,0)\n            else:\n                g = gcd(x,abs(y))\n                m = (x//g,y//g)\n            e[(p,q)] = m\n    f = [1 for i in range(n)]\n    k = [None for i in range(n//2)]\n    dfs(0,k,f,n,nu,v,e)\n    print(ans)\n    return\n\n\n#C\ndef C():\n    while 1:\n        n = I()\n        if n == 0:\n            break\n        v = [input().split() for i in range(n)]\n        d = defaultdict(int)\n        f = [[1 for j in range(n)] for i in range(n)]\n        i = 0\n        s = 0\n        while i < n:\n            v[i][1] = int(v[i][1])\n            v[i][2] = int(v[i][2])\n            if v[i][2] == 0:\n                s += v[i][1]\n                v.pop(i)\n                n -= 1\n            else:\n                d[v[i][0]] = i\n                i += 1\n\n        for i in range(n):\n            for j in v[i][3:]:\n                f[i][d[j]] = 0\n        e = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if i == j:continue\n                if f[i][j]:\n                    e[i].append(j)\n        for i in e:\n            print(i)\n        print(ans)\n    return\n\n#D\ndef D():\n    n = I()\n    s = [0 for i in range(100001)]\n    l = LIR(n)\n    l.sort(key = lambda x:x[1])\n    r = [l[i][0] for i in range(n)]\n    r.sort()\n    f = [0 for i in range(100001)]\n    for a,b in l:\n        s[a] += 1\n        s[b] -= 1\n        f[b] += 1\n    for i in range(100000):\n        s[i+1] += s[i]\n        f[i+1] += f[i]\n    ans = 0\n\n    for a,b in l:\n        ri = bisect.bisect_left(r,b)\n        ri = n-ri\n        le = f[a]\n        ans = max(ans,n-(ri+le))\n    print(ans,max(s))\n    return\n\n#E\ndef E():\n    n = I()\n    c = LI()\n    f = [[i,c[i]] for i in range(n)]\n    f.sort(key = lambda x:x[1])\n    v = [[] for i in range(n)]\n    m = I()\n    for i in range(m):\n        a,b = LI()\n        a -= 1\n        b -= 1\n        v[a].append(b)\n        v[b].append(a)\n    q = deque()\n    bfs_map = [1 for i in range(n)]\n    ans = [0 for i in range(n)]\n    for i,j in f:\n        if not bfs_map[i]:continue\n        q.append(i,-1)\n        bfs_map[i] = 0\n        ans[i] = 1\n        while q:\n            x,pre = q.popleft()\n            for y in v[x]:\n                if bfs_map[y]:\n                    if x == 0:\n                        bfs_map[y] = 0\n                        q.append(y)\n    print(sum(ans))\n    return\n\n#F\ndef F():\n    return\n\n#G\ndef G():\n    return\n\n#H\ndef H():\n    return\n\n#I\ndef I_():\n    return\n\n#J\ndef J():\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    B()\n\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::cmp::{Ordering, min, max};\nuse std::fmt::{Display, Error, Formatter};\nuse std::f32::MAX;\nuse std::ops::{Add, Sub, Mul, Div, Neg, Index, IndexMut};\nuse std::collections::BTreeMap;\n\nfn show<T: Display>(vec: &Vec<T>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        print!(\"[{}\", vec[0]);\n        for i in 1 .. vec.len() {\n            print!(\", {}\", vec[i]);\n        }\n        println!(\"]\");\n    }\n}\nfn show2<T: Display>(vec: &Vec<Vec<T>>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        for l in vec {\n            show(l);\n        }\n    }\n}\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! read_value{\n    () => {\n        read_line!().trim().parse().ok().unwrap()\n    }\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\nmacro_rules! let_mut_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let mut $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\n#[derive(Copy, Clone, Eq, PartialEq)]\nstruct Point {\n    x: i32, y: i32\n}\n#[derive(Copy, Clone, Eq, PartialEq)]\nstruct Line {\n    a: i32, b: i32, c: i32\n}\nimpl Line {\n    fn by_two_point(a: Point, b: Point) -> Line {\n        Line{a: a.x - b.x, b: b.y - a.y, c: a.y * b.x - a.x * b.y}\n    }\n    fn is_parallel(&self, other: &Self) -> bool {\n        self.a * other.b == self.b * other.a\n    }\n}\nfn solve(used: usize, lines: &mut Vec<Line>, points: &Vec<Point>) -> usize {\n    let mut first = points.len();\n    for i in 0 .. points.len() {\n        if used & (1 << i) == 0 {\n            first = i;\n            break\n        }\n    }\n    if first == points.len() {\n        0\n    }else {\n        let mut max = 0;\n        for j in first + 1 .. points.len() {\n            if used & (1 << j) == 0 {\n                let line = Line::by_two_point(points[first], points[j]);\n                let mut count = 0;\n                for l in lines.iter() {\n                    if line.is_parallel(l) {\n                        count += 1;\n                    }\n                }\n                lines.push(line);\n                count += solve(used | (1 << first) | (1 << j), lines, points);\n                lines.pop();\n                if max < count {\n                    max = count;\n                }\n            }\n        }\n        max\n    }\n}\nfn main() {\n    let_all!(m: usize);\n    let mut points = Vec::with_capacity(m);\n    for _ in 0 .. m {\n        let_all!(x: i32, y: i32);\n        points.push(Point{x: x, y: y});\n    }\n    let points = points;\n    println!(\"{}\", solve(0, &mut Vec::with_capacity(m / 2), &points));\n}\n"
  }
]