[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    double dx, dy;\n} Vector;\n\nint compareVectors(const void *a, const void *b) {\n    Vector *v1 = (Vector *)a;\n    Vector *v2 = (Vector *)b;\n    if (v1->dx * v2->dy < v2->dx * v1->dy) return -1;\n    if (v1->dx * v2->dy > v2->dx * v1->dy) return 1;\n    return 0;\n}\n\nint countParallelPairs(Vector *vectors, int n) {\n    qsort(vectors, n, sizeof(Vector), compareVectors);\n    int max_count = 0;\n    int current_count = 1;\n    for (int i = 1; i < n; i++) {\n        if (vectors[i].dx * vectors[i-1].dy == vectors[i-1].dx * vectors[i].dy) {\n            current_count++;\n        } else {\n            if (current_count > max_count) {\n                max_count = current_count;\n            }\n            current_count = 1;\n        }\n    }\n    if (current_count > max_count) {\n        max_count = current_count;\n    }\n    return max_count / 2;\n}\n\nint maxParallelPairs(Point *points, int n) {\n    if (n % 2 != 0) return 0;\n    int max_pairs = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            Vector *vectors = (Vector *)malloc((n - 2) * sizeof(Vector));\n            int idx = 0;\n            for (int k = 0; k < n; k++) {\n                if (k == i || k == j) continue;\n                vectors[idx].dx = points[k].x - points[i].x;\n                vectors[idx].dy = points[k].y - points[i].y;\n                idx++;\n            }\n            int pairs = countParallelPairs(vectors, n - 2);\n            if (pairs > max_pairs) {\n                max_pairs = pairs;\n            }\n            free(vectors);\n        }\n    }\n    return max_pairs;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Point *points = (Point *)malloc(n * sizeof(Point));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &points[i].x, &points[i].y);\n    }\n    printf(\"%d\\n\", maxParallelPairs(points, n));\n    free(points);\n    return 0;\n}",
    "timestamp": "2025-08-05 20:56:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n};\n\nint gcd(int a, int b) {\n    a = abs(a);\n    b = abs(b);\n    while (b) {\n        int t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}\n\npair<int, int> get_slope(Point a, Point b) {\n    int dx = a.x - b.x;\n    int dy = a.y - b.y;\n    if (dx == 0) return {0, 1};\n    if (dy == 0) return {1, 0};\n    int g = gcd(dx, dy);\n    dx /= g;\n    dy /= g;\n    if (dx < 0) {\n        dx = -dx;\n        dy = -dy;\n    }\n    return {dx, dy};\n}\n\nint maxParallelPairs(vector<Point>& points) {\n    int n = points.size();\n    if (n % 2 != 0) return 0;\n    \n    int max_pairs = 0;\n    vector<bool> used(n, false);\n    \n    function<void(int, int)> backtrack = [&](int pos, int count) {\n        if (pos == n) {\n            max_pairs = max(max_pairs, count);\n            return;\n        }\n        if (used[pos]) {\n            backtrack(pos + 1, count);\n            return;\n        }\n        for (int i = pos + 1; i < n; ++i) {\n            if (!used[i]) {\n                used[i] = true;\n                for (int j = pos + 1; j < n; ++j) {\n                    if (j != i && !used[j]) {\n                        for (int k = j + 1; k < n; ++k) {\n                            if (!used[k]) {\n                                auto slope1 = get_slope(points[pos], points[i]);\n                                auto slope2 = get_slope(points[j], points[k]);\n                                if (slope1 == slope2) {\n                                    used[j] = used[k] = true;\n                                    backtrack(pos + 1, count + 1);\n                                    used[j] = used[k] = false;\n                                }\n                            }\n                        }\n                    }\n                }\n                used[i] = false;\n            }\n        }\n        backtrack(pos + 1, count);\n    };\n    \n    backtrack(0, 0);\n    return max_pairs;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Point> points(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> points[i].x >> points[i].y;\n    }\n    cout << maxParallelPairs(points) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 20:56:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MaxParallelPairs {\n    public int maxParallelPairs(int[][] points) {\n        int n = points.length;\n        if (n % 2 != 0) return 0;\n        int maxPairs = 0;\n        List<List<int[]>> allPairings = new ArrayList<>();\n        generatePairings(points, new boolean[n], new ArrayList<>(), allPairings);\n        \n        for (List<int[]> pairing : allPairings) {\n            int pairs = countParallelPairs(pairing);\n            if (pairs > maxPairs) {\n                maxPairs = pairs;\n            }\n        }\n        return maxPairs;\n    }\n    \n    private void generatePairings(int[][] points, boolean[] used, List<int[]> current, List<List<int[]>> result) {\n        if (current.size() == points.length / 2) {\n            result.add(new ArrayList<>(current));\n            return;\n        }\n        \n        int first = -1;\n        for (int i = 0; i < points.length; i++) {\n            if (!used[i]) {\n                first = i;\n                used[i] = true;\n                break;\n            }\n        }\n        \n        for (int i = first + 1; i < points.length; i++) {\n            if (!used[i]) {\n                used[i] = true;\n                current.add(new int[]{first, i});\n                generatePairings(points, used, current, result);\n                current.remove(current.size() - 1);\n                used[i] = false;\n            }\n        }\n        used[first] = false;\n    }\n    \n    private int countParallelPairs(List<int[]> pairing) {\n        int count = 0;\n        for (int i = 0; i < pairing.size(); i++) {\n            int[] pair1 = pairing.get(i);\n            int x1 = pair1[0], y1 = pair1[1];\n            for (int j = i + 1; j < pairing.size(); j++) {\n                int[] pair2 = pairing.get(j);\n                int x2 = pair2[0], y2 = pair2[1];\n                if (isParallel(x1, y1, x2, y2)) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n    \n    private boolean isParallel(int x1, int y1, int x2, int y2) {\n        int dx1 = x1 - y1;\n        int dy1 = y1 - x1;\n        int dx2 = x2 - y2;\n        int dy2 = y2 - x2;\n        return dx1 * dy2 == dx2 * dy1;\n    }\n}",
    "timestamp": "2025-08-05 20:57:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public int maxParallelLines(int[][] points) {\n        int n = points.length;\n        int maxParallel = 0;\n\n        for (int mask = 0; mask < (1 << n); mask++) {\n            if (Integer.bitCount(mask) == n / 2) {\n                List<int[]> selectedPoints = new ArrayList<>();\n                for (int i = 0; i < n; i++) {\n                    if ((mask & (1 << i)) != 0) {\n                        selectedPoints.add(points[i]);\n                    }\n                }\n                maxParallel = Math.max(maxParallel, countParallelPairs(selectedPoints));\n            }\n        }\n\n        return maxParallel;\n    }\n\n    private int countParallelPairs(List<int[]> points) {\n        int parallelLines = 0;\n        for (int i = 0; i < points.size(); i++) {\n            for (int j = i + 1; j < points.size(); j++) {\n                for (int k = j + 1; k < points.size(); k++) {\n                    for (int l = k + 1; l < points.size(); l++) {\n                        if (areParallel(points.get(i), points.get(j), points.get(k), points.get(l))) {\n                            parallelLines++;\n                        }\n                    }\n                }\n            }\n        }\n        return parallelLines;\n    }\n\n    private boolean areParallel(int[] p1, int[] p2, int[] p3, int[] p4) {\n        return slope(p1, p2) == slope(p3, p4);\n    }\n\n    private double slope(int[] p1, int[] p2) {\n        if (p1[0] == p2[0]) return Double.POSITIVE_INFINITY;\n        return (double)(p2[1] - p1[1]) / (p2[0] - p1[0]);\n    }\n}",
    "timestamp": "2025-08-05 20:57:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX_POINTS 1000\n#define EPS 1e-9\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble slope(Point p1, Point p2) {\n    if (p1.x == p2.x) return INFINITY;\n    return (p2.y - p1.y) / (p2.x - p1.x);\n}\n\nint compare_double(double a, double b) {\n    return fabs(a - b) < EPS;\n}\n\nint max_parallel_pairs(Point points[], int n) {\n    int max_parallel = 0;\n    \n    for (int mask = 0; mask < (1 << n); mask++) {\n        if (__builtin_popcount(mask) != n / 2) continue;\n        \n        Point paired[MAX_POINTS];\n        int paired_count = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                paired[paired_count++] = points[i];\n            }\n        }\n        \n        int parallel_count = 0;\n        \n        for (int i = 0; i < paired_count; i += 2) {\n            for (int j = i + 2; j < paired_count; j += 2) {\n                if (compare_double(slope(paired[i], paired[i+1]), slope(paired[j], paired[j+1]))) {\n                    parallel_count++;\n                }\n            }\n        }\n        \n        max_parallel = fmax(max_parallel, parallel_count);\n    }\n    \n    return max_parallel;\n}\n\nint main() {\n    int n;\n    Point points[MAX_POINTS];\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &points[i].x, &points[i].y);\n    }\n    \n    printf(\"%d\\n\", max_parallel_pairs(points, n));\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:57:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <unordered_set>\n#include <cmath>\n\nclass Solution {\npublic:\n    int maxParallelLines(std::vector<std::vector<int>>& points) {\n        int n = points.size();\n        int maxParallel = 0;\n        \n        // Try all possible pairings\n        for (int mask = 0; mask < (1 << n); mask++) {\n            if (__builtin_popcount(mask) != n / 2) continue;\n            \n            std::vector<std::pair<int, int>> currentPairs;\n            \n            // Extract current pairing\n            for (int i = 0; i < n; i++) {\n                if (mask & (1 << i)) {\n                    for (int j = i + 1; j < n; j++) {\n                        if (mask & (1 << j)) {\n                            currentPairs.push_back({i, j});\n                        }\n                    }\n                }\n            }\n            \n            // Count parallel lines\n            int parallelCount = countParallelLines(points, currentPairs);\n            maxParallel = std::max(maxParallel, parallelCount);\n        }\n        \n        return maxParallel;\n    }\n    \nprivate:\n    int countParallelLines(std::vector<std::vector<int>>& points, \n                            std::vector<std::pair<int, int>>& pairs) {\n        int parallelCount = 0;\n        \n        for (int i = 0; i < pairs.size(); i++) {\n            for (int j = i + 1; j < pairs.size(); j++) {\n                if (isParallel(points[pairs[i].first], \n                                points[pairs[i].second],\n                                points[pairs[j].first], \n                                points[pairs[j].second])) {\n                    parallelCount++;\n                }\n            }\n        }\n        \n        return parallelCount;\n    }\n    \n    bool isParallel(std::vector<int>& p1, std::vector<int>& p2, \n                    std::vector<int>& p3, std::vector<int>& p4) {\n        // Compute line directions using slope\n        double slope1 = computeSlope(p1, p2);\n        double slope2 = computeSlope(p3, p4);\n        \n        return std::abs(slope1 - slope2) < 1e-9;\n    }\n    \n    double computeSlope(std::vector<int>& p1, std::vector<int>& p2) {\n        if (p1[0] == p2[0]) return INFINITY;\n        return (double)(p2[1] - p1[1]) / (p2[0] - p1[0]);\n    }\n};",
    "timestamp": "2025-08-05 20:57:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import itertools\n\ndef max_parallel_pairs(points):\n    def is_parallel(p1, p2, p3, p4):\n        # Check if the vectors p1->p2 and p3->p4 are parallel\n        return (p2[1] - p1[1]) * (p4[0] - p3[0]) == (p2[0] - p1[0]) * (p4[1] - p3[1])\n\n    def count_parallel_pairs(pairs):\n        count = 0\n        for (p1, p2), (p3, p4) in itertools.combinations(pairs, 2):\n            if is_parallel(p1, p2, p3, p4):\n                count += 1\n        return count\n\n    n = len(points)\n    max_parallel = 0\n    # Generate all possible pairings\n    for perm in itertools.permutations(points):\n        pairs = [perm[i:i+2] for i in range(0, n, 2)]\n        max_parallel = max(max_parallel, count_parallel_pairs(pairs))\n        \n    return max_parallel\n\n# Example usage:\n# points = [(0, 0), (1, 2), (3, 2), (4, 4), (5, 5), (7, 9)]\n# print(max_parallel_pairs(points))",
    "timestamp": "2025-08-13 04:14:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MaxParallelPairs {\n\n    public static void main(String[] args) {\n        // Example points\n        int[][] points = {{0, 0}, {1, 1}, {1, 0}, {2, 0}, {2, 1}, {3, 0}, {3, 1}, {1, 2}};\n        \n        int result = maxParallelPairs(points);\n        System.out.println(result);\n    }\n\n    public static int maxParallelPairs(int[][] points) {\n        int n = points.length;\n        HashMap<String, Integer> slopeMap = new HashMap<>();\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                String slope = getSlope(points[i], points[j]);\n                slopeMap.put(slope, slopeMap.getOrDefault(slope, 0) + 1);\n            }\n        }\n\n        int maxPairs = 0;\n        for (int count : slopeMap.values()) {\n            maxPairs = Math.max(maxPairs, count / 2);\n        }\n        return maxPairs;\n    }\n\n    private static String getSlope(int[] p1, int[] p2) {\n        int dx = p2[0] - p1[0];\n        int dy = p2[1] - p1[1];\n        int gcd = gcd(dx, dy);\n        \n        dx /= gcd;\n        dy /= gcd;\n        \n        String slope = dy + \"/\" + dx;\n        if (dx == 0) slope = \"inf\";\n        if (dy == 0) slope = \"0\";\n        if (dy < 0) slope = (-dy) + \"/\" + (-dx);\n\n        return slope;\n    }\n\n    private static int gcd(int a, int b) {\n        if (b == 0) return Math.abs(a);\n        return gcd(b, a % b);\n    }\n}",
    "timestamp": "2025-08-13 04:14:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint compare(const void *a, const void *b) {\n    Point *p1 = (Point *)a;\n    Point *p2 = (Point *)b;\n    if (p1->x == p2->x) return p1->y - p2->y;\n    return p1->x - p2->x;\n}\n\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nvoid simplify_fraction(int *num, int *den) {\n    int g = gcd(*num, *den);\n    *num /= g;\n    *den /= g;\n}\n\ntypedef struct {\n    int dx, dy;\n} Slope;\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    if (n % 2 != 0) {\n        printf(\"Error: Number of points must be even.\\n\");\n        return 1;\n    }\n    \n    Point points[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &points[i].x, &points[i].y);\n    }\n    \n    qsort(points, n, sizeof(Point), compare);\n    \n    Slope slopes[n * (n - 1) / 2];\n    int slope_index = 0;\n    \n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int dx = points[j].x - points[i].x;\n            int dy = points[j].y - points[i].y;\n            simplify_fraction(&dx, &dy);\n            slopes[slope_index++] = (Slope){dx, dy};\n        }\n    }\n    \n    qsort(slopes, slope_index, sizeof(Slope), compare);\n    \n    int max_parallel_pairs = 0;\n    int current_parallel_pairs = 1;\n    \n    for (int i = 1; i < slope_index; i++) {\n        if (slopes[i].dx == slopes[i - 1].dx && slopes[i].dy == slopes[i - 1].dy) {\n            current_parallel_pairs++;\n        } else {\n            if (current_parallel_pairs > max_parallel_pairs) {\n                max_parallel_pairs = current_parallel_pairs;\n            }\n            current_parallel_pairs = 1;\n        }\n    }\n    \n    if (current_parallel_pairs > max_parallel_pairs) {\n        max_parallel_pairs = current_parallel_pairs;\n    }\n    \n    printf(\"%d\\n\", max_parallel_pairs / 2);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 04:14:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import combinations\n\ndef max_parallel_pairs(points):\n    n = len(points)\n    if n % 2 != 0:\n        return 0\n    \n    def slope(p1, p2):\n        x1, y1 = p1\n        x2, y2 = p2\n        if x1 == x2:\n            return float('inf')\n        return (y2 - y1) / (x2 - x1)\n    \n    max_parallel = 0\n    \n    for pairing in combinations(points, n):\n        parallel_count = 0\n        used_pairs = set()\n        \n        for i in range(0, n, 2):\n            for j in range(i+2, n, 2):\n                if (slope(pairing[i], pairing[i+1]) == \n                    slope(pairing[j], pairing[j+1]) and\n                    (i, j) not in used_pairs and \n                    (j, i) not in used_pairs):\n                    parallel_count += 1\n                    used_pairs.add((i, j))\n        \n        max_parallel = max(max_parallel, parallel_count)\n    \n    return max_parallel",
    "timestamp": "2025-08-13 04:14:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import itertools\nimport math\n\ndef max_parallel_pairs(points):\n    n = len(points)\n    if n % 2 != 0:\n        return 0\n    \n    max_pairs = 0\n    # Generate all possible perfect matchings\n    for pairing in itertools.permutations(points):\n        # To avoid redundant checks, we can use a smarter way to generate pairings\n        # But for simplicity, we'll proceed with this approach\n        # Pairing is a permutation, so we pair (0,1), (2,3), etc.\n        lines = []\n        for i in range(0, n, 2):\n            x1, y1 = pairing[i]\n            x2, y2 = pairing[i+1]\n            # Avoid division by zero for vertical lines\n            if x1 == x2:\n                angle = math.pi / 2  # 90 degrees in radians\n            else:\n                angle = math.atan2(y2 - y1, x2 - x1)\n            lines.append(angle)\n        \n        # Count parallel pairs\n        angle_counts = {}\n        for angle in lines:\n            # Normalize angle to handle opposite directions\n            normalized_angle = angle % math.pi\n            angle_counts[normalized_angle] = angle_counts.get(normalized_angle, 0) + 1\n        \n        current_pairs = sum(v // 2 for v in angle_counts.values())\n        if current_pairs > max_pairs:\n            max_pairs = current_pairs\n    \n    # The above approach is too slow for large n, so we need a smarter way\n    # Instead, we can consider all possible pairs and their slopes\n    # Then find the maximum number of pairs with the same slope\n    \n    # Precompute all possible pairs and their slopes\n    slopes = {}\n    for i in range(n):\n        x1, y1 = points[i]\n        for j in range(i+1, n):\n            x2, y2 = points[j]\n            if x1 == x2:\n                slope = 'inf'\n            else:\n                slope = (y2 - y1) / (x2 - x1)\n            if slope not in slopes:\n                slopes[slope] = []\n            slopes[slope].append((i, j))\n    \n    # The problem reduces to selecting non-overlapping pairs with the same slope\n    max_pairs = 0\n    for slope in slopes:\n        edges = slopes[slope]\n        # This is a maximum matching problem in a graph\n        # But for simplicity, we can use a greedy approach\n        used = [False] * n\n        count = 0\n        for i, j in edges:\n            if not used[i] and not used[j]:\n                used[i] = used[j] = True\n                count += 1\n        if count > max_pairs:\n            max_pairs = count\n    \n    return max_pairs\n\n# Example usage:\n# points = [(0, 0), (1, 1), (2, 2), (3, 3)]\n# print(max_parallel_pairs(points))",
    "timestamp": "2025-08-13 04:15:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> Point;\ntypedef pair<int, int> Line;\n\nLine getLine(const Point &a, const Point &b) {\n    int dx = b.first - a.first;\n    int dy = b.second - a.second;\n    int gcd = __gcd(dx, dy);\n    return {dx / gcd, dy / gcd};\n}\n\nint maxParallelPairs(vector<Point> &points) {\n    int n = points.size();\n    map<Line, int> line_count;\n\n    for(int i = 0; i < n; i+=2) {\n        for(int j = 0; j < n; j++) {\n            if(i != j) {\n                Line line = getLine(points[i], points[j]);\n                line_count[line]++;\n            }\n        }\n    }\n    \n    int max_pairs = 0;\n    \n    for (const auto &entry : line_count) {\n        max_pairs = max(max_pairs, entry.second / 2);\n    }\n\n    return max_pairs;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> points(n);\n    for(int i = 0; i < n; ++i) {\n        cin >> points[i].first >> points[i].second;\n    }\n    cout << maxParallelPairs(points) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:17:56"
  }
]