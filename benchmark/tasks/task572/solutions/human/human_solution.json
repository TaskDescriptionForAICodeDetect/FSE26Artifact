[
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readLine,readInt}\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n  def prefix(p:String) = {\n    val m = p.length\n    val a = new Array[Int](m)\n    var k=0\n\n    a(0) = 0\n    for(q<-1 until m) {\n      while(k>0 && p(k)!=p(q)) k = a(k-1)\n      if(p(k) == p(q)) k = k+1\n      a(q) = k\n    }\n    a\n  }\n\n  def main(args:Array[String]) = {\n    val t = readLine.trim\n    val n = readInt\n    val f = new Array[Array[Int]](n)\n    val q = new Array[Int](n)\n    val p = for(i<-0 until n) yield {\n      val s = readLine.trim\n      f(i) = prefix(s)\n      s\n    }\n    val r = new Array[Int](n)\n\n    for(i<-0 until t.length) {\n      for(j<-0 until n if r(j)==0) {\n        while(q(j)>0 && p(j)(q(j))!=t(i)) q(j) = f(j)(q(j)-1)\n        if(p(j)(q(j))==t(i)) q(j) = q(j)+1\n        if(q(j)==p(j).length) {\n          r(j)=1\n          q(j) = f(j)(q(j)-1)\n        }\n      }\n    }\n\n    println(r.mkString(\"\\n\"))\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n\n\nusing namespace std;\n\nstring t;\nint q,n,size;\nbool flag;\nint id[70] = {};\n\nint main()\n{\n\tcin >> t >> q;\n\t\n\tfor(int i = 0 ;i < t.size();i++)\n\t{\n\t\tif(t[i] > 'a' && t[i] < 'Z')id[t[i] - 'a']++;\n\t\telse id[52 + t[i] - '0']++;\n\t}\n\t\n\t\n\tfor(int i = 0;i < q ;i++)\n\t{\n\t\tflag = false;\n\t\tint z[70] = {};\n\t\tstring p;\n\t\tcin >> p;\n\t\tsize = p.size();\n\t\t\n\t\tfor(int h = 0 ;h < size;h++)\n\t\t{\n\t\t\tif(t[h] > 'a' && t[h] < 'Z')id[t[h] - 'a']++;\n\t\t\telse z[52 + t[h] - '0']++;\n\t\t}\n\t\t\n\t\tfor(int w = 0;w < 70;w++)\n\t\tif(id[w] < z[w]) flag = true;\n\t\t\n\t\tif(flag) continue;\n\n\t\t\n\t\tfor(int j = 0;j < t.size();j++)\n\t\t{\n\t\t\tif(t[j] == p[0])\n\t\t\t{\n\t\t\t\tif(size == 1) \n\t\t\t\t{\n\t\t\t\t\tcout << 1 << endl;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\tfor(int k = 1;k < size;k++)\n\t\t\t\t{\n\t\t\t\t\tif(t[j+k] != p[k]) break;\n\t\t\t\t\tif(k == size -1) \n\t\t\t\t\t{\n\t\t\t\t\t\tcout << 1 << endl;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tif(flag) break;\n\t\t}\n\tif(!flag) cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nclass SuffixArray {\n\tvoid CEB(vector<int> &v, vector<int> &b) {\n\t\tfill(b.begin(), b.end(), 0);\n\t\tfor (int i = 0; i < v.size(); i++) b[v[i]]++;\n\t\tfor (int i = 1; i < b.size(); i++) b[i] += b[i - 1];\n\t}\n\tvoid ISort(vector<int> &v, vector<int> &SA, int mv, vector<int> &b, vector<int> &isL) {\n\t\tfill(b.begin(), b.end(), 0);\n\t\tfor (int i = 0; i < v.size(); i++) b[v[i]]++;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < b.size(); i++) b[i] += sum, swap(sum, b[i]);\n\t\tfor (int i = 0; i < v.size(); i++) {\n\t\t\tif (SA[i] > 0 && isL[SA[i] - 1]) SA[b[v[SA[i] - 1]]++] = SA[i] - 1;\n\t\t}\n\t}\n\tvoid IISort(vector<int> &v, vector<int> &SA, int mv, vector<int> &b, vector<int> &isL) {\n\t\tCEB(v, b);\n\t\tfor (int i = v.size() - 1; i >= 0; i--) {\n\t\t\tif (SA[i] > 0 && !isL[SA[i] - 1]) SA[--b[v[SA[i] - 1]]] = SA[i] - 1;\n\t\t}\n\t}\n\tvector<int>SA_IS(vector<int> v, int mv) {\n\t\tint vs = v.size();\n\t\tif (vs == 1) return vector<int>(1, 0);\n\t\tvector<int> isL(vs), b(mv + 1), SA(vs, -1), ord(vs);\n\t\tauto isLMS = [&](int x)->bool { return x > 0 && isL[x - 1] && !isL[x]; };\n\t\tfor (int i = vs - 2; i >= 0; i--) isL[i] = (v[i] > v[i + 1]) || (v[i] == v[i + 1] && isL[i + 1]);\n\t\tCEB(v, b);\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) SA[--b[v[i]]] = i;\n\t\t}\n\t\tISort(v, SA, mv, b, isL);\n\t\tIISort(v, SA, mv, b, isL);\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) ord[i] = cur++;\n\t\t}\n\t\tvector<int> nxv(cur);\n\t\tcur = -1;\n\t\tint prev = -1;\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (!isLMS(SA[i])) continue;\n\t\t\tbool diff = false;\n\t\t\tfor (int d = 0; d < vs; d++) {\n\t\t\t\tif (prev == -1 || v[SA[i] + d] != v[prev + d] || isL[SA[i] + d] != isL[prev + d]) {\n\t\t\t\t\tdiff = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (d && isLMS(SA[i] + d))break;\n\t\t\t}\n\t\t\tif (diff) cur++, prev = SA[i];\n\t\t\tnxv[ord[SA[i]]] = cur;\n\t\t}\n\t\tvector<int> reord(nxv.size());\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) reord[ord[i]] = i;\n\t\t}\n\t\tvector<int> nxSA = SA_IS(nxv, cur);\n\t\tCEB(v, b);\n\t\tfor (int i = 0; i < SA.size(); i++) SA[i] = -1;\n\t\tfor (int i = nxSA.size() - 1; i >= 0; i--) {\n\t\t\tSA[--b[v[reord[nxSA[i]]]]] = reord[nxSA[i]];\n\t\t}\n\t\tISort(v, SA, mv, b, isL);\n\t\tIISort(v, SA, mv, b, isL);\n\t\treturn SA;\n\t}\n\tvector<int>SA_IS(string s) {\n\t\tvector<int> v(s.size() + 1);\n\t\tfor (int i = 0; i < s.size(); i++) v[i] = s[i] + 1;\n\t\treturn SA_IS(v, *max_element(v.begin(), v.end()));\n\t}\n\tvector<int>construct_lcp(string &s, vector<int> &sa) {\n\t\tvector<int> lcp, rank(s.size() + 1);\n\t\tint n = s.size(), h = 0;\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (s[j + h] != s[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\npublic:\n\tstring s;\n\tvector<int> sa, lcp;\n\tvoid init(string &T) {\n\t\ts = T;\n\t\tsa = SA_IS(s);\n\t}\n\tSuffixArray(string &t) { init(t); }\n\tSuffixArray() {}\n\tbool contain(string &t) {\n\t\tint a = 0, b = s.size();\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (s.compare(sa[c], t.size(), t) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn s.compare(sa[b], t.size(), t) == 0;\n\t}\n};\nint q; string s, t;\nint main() {\n\tcin >> s >> q;\n\tSuffixArray v(s);\n\tfor(int i = 0; i < q; i++) {\n\t\tcin >> t;\n\t\tcout << (v.contain(t) ? 1 : 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n \n#define MAX 1000002\n \ntypedef unsigned char byte;\nbyte mask[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\n  \nint *Lv;\nint n, k;\n  \nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n  \nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n  \n    return L_i < L_j;\n}\n  \nint main()\n{\n    int *A;\n    char c[MAX];\n    scanf(\"%s\", c);\n    std::string T = std::string(c);\n    n = T.size();\n \n    A = new int[n + 1], Lv = new int [n + 1];\n \n    byte *t;\n    t = new byte [(n >> 3) + 1];\n  \n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n  \n    int bkt[129];\n    for(i = 0; i < 129; i++){ bkt[i] = 0; }\n    for(i = 0; i < n; i++){ bkt[Lv[i]]++; }\n    int sum = 0;\n    for(i = 0; i < 129; i++){ sum += bkt[i]; bkt[i] = sum; }\n    for(i = 0; i < n; i++){ A[--bkt[Lv[i]]] = i; }\n  \n    for(i = 1; i < n; i++){\n        t[i >> 3] = (Lv[A[i]] != Lv[A[i - 1]] ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n    }\n    t[n >> 3] = t[n >> 3] | mask[n & 7];\n  \n    Lv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n    }\n  \n    k = 1;\n    while(1){\n        if(k > n) break;\n \n        std::sort(A, A + n, cmp);\n  \n        for(i = 1; i < n; i++){\n            t[i >> 3] = (cmp(A[i - 1], A[i]) ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n        }\n        Lv[A[0]] = 0;\n        for(i = 1; i < n; i++){\n            Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n        }\n \n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n  \n    char p[1000];\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n  \n    A[n] = n;\n  \n    while(q){\n        scanf(\"%s\", p);\n        std::string P = std::string(p);\n        left = 0, right = n, exist = false;\n        while(left < right){\n  \n            if(n < P.size()){ exist = false; break; }\n  \n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n  \n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(string s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  bool operator()(int i, int j) { \n    int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  \n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  \n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  sort(ALL(sa),rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  if(10000 < s.size())assert(false);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\n\ntypedef struct SAManberMyers_ {\n  string s;\n  vector<int> rank;\n  vector<int> tmp;\n  vector<int> sa;\n  int n, k;\n  SAManberMyers_(string ss){\n    s = ss;\n    n = s.size();\n    rank.resize(n + 1);\n    tmp.resize(n + 1);\n    sa.resize(n + 1);\n    k = 0;\n\n    // construct suffix array\n    construct();\n  }\n  bool comp(const int &a, const int &b){\n    if(rank[a] != rank[b])return rank[a] < rank[b];\n    int ra = a + k <= n ? rank[a + k] : -1;\n    int rb = b + k <= n ? rank[b + k] : -1;\n    return ra < rb;\n  }\n  void construct(){\n    for(int i = 0; i <= n; i++){\n      sa[i] = i;\n      rank[i] = i < n ? s[i] : -1;\n    }\n\n    for(k = 1; k <= n; k *= 2){\n      sort(sa.begin(), sa.end(), [this] (const int &a, const int &b) {return comp(a, b);});\n\n      tmp[sa[0]] = 0;\n      for(int i = 1; i <= n; i++){\n        tmp[sa[i]] = tmp[sa[i-1]] + (comp(sa[i-1], sa[i]) ? 1 : 0);\n      }\n      for(int i = 0; i <= n; i++){\n        rank[i] = tmp[i];\n      }\n    }\n  }\n} SAManberMyers;\n\nvector<int> sa_search_(SAManberMyers &sa, string &s, string &t){\n  vector<int> res;\n  t += \"$\";\n  s += \"$\";\n  int ld = -1;\n  int rd = sa.sa.size() - 1;\n  while(rd - ld > 1){\n    int md = (rd + ld) / 2;\n    if(s.substr(sa.sa[md]) < t)ld = md;\n    else rd = md;\n  }\n  t = t.substr(0, t.size() - 1);\n  while(rd < sa.sa.size()){\n    if(s.substr(sa.sa[rd], t.size()) != t)break;\n    res.push_back(sa.sa[rd]);\n    rd++;\n  }\n  sort(res.begin(), res.end());\n  return res;\n}\n\nvector<int> sa_search(string s, string t){\n  SAManberMyers sa(s);\n  vector<int> res = sa_search_(sa, s, t);\n  return res;\n}\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  SAManberMyers sa(s);\n  int q;\n  cin >> q;\n  rep(i, q){\n    string p;\n    cin >> p;\n    auto res = sa_search_(sa, s, p);\n    if(sz(res) >= 1)cout << 1 << endl;\n    else cout << 0 << endl;\n  }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\nclass suffix_array{\nprivate:\n    typedef unsigned long ul;\n    \n    struct node{\n        ll begin;\n        ll Rank;\n        node* next; //sortで狂ってる\n        \n        bool operator < (const node &N) const {\n            if(Rank==N.Rank){\n                return (next==NULL?-1:next->Rank)<(N.next==NULL?-1:N.next->Rank);\n            }\n            return Rank<N.Rank;\n        }\n        \n        node(ll begin=0,ll Rank=0,node* next=NULL):begin(begin),Rank(Rank),next(next){}\n    };\n    \n    static bool pointer_cmp(node* &a,node* &b){return (*a)<(*b);}\n    \n    vector<node*> sa;\n    vector<ll> Rank;\n    const string s;\n    \n    void build(){\n        for(int i=0;i<s.size();i++){\n            *sa[i]={i,s[i],sa[i+1]};\n        }\n        sa[s.size()]->begin=s.size();\n        sa[s.size()]->Rank=-1;\n        sa[s.size()]->next=NULL;\n        vector<node*> Next(s.size()+1);\n        for(ll k=1;k<=s.size();k<<=1){\n            sort(sa.begin(),sa.end(),pointer_cmp);\n            Rank[sa[0]->begin]=0;\n            Next[0]=(sa[0]->next==NULL?NULL:sa[0]->next->next);\n            for(int i=1;i<=s.size();i++){\n                Rank[sa[i]->begin]=Rank[sa[i-1]->begin]+(*sa[i-1]<*sa[i]?1:0);\n                Next[i]=(sa[i]->next==NULL?NULL:sa[i]->next->next);\n            }\n            for(int i=0;i<=s.size();i++){\n                sa[i]->Rank=Rank[sa[i]->begin];\n                sa[i]->next=Next[i];\n            }\n        }\n        for(int i=0;i<=s.size();i++){\n            Next[sa[i]->begin]=sa[i];\n        }\n        for(int i=0;i<=s.size();i++){\n            sa[i]->next=sa[i]->begin==s.size()?NULL:Next[sa[i]->begin+1];\n        }\n    }\n    \n    //1::greater 0::same -1::less\n    int compare(const ul &saf,const string &str){\n        for(int i=0;i<str.size();i++){\n            if(sa[saf]->begin+i>=s.size()){return -1;}\n            if(s[sa[saf]->begin+i]!=str[i]){return s[sa[saf]->begin+i]<str[i]?-1:1;}\n        }\n        return 0;\n    }\n    \npublic:\n    suffix_array(const string &str):s(str),Rank(str.size()+1),sa(str.size()+1){\n        for(int i=0;i<=str.size();i++){\n            \n        }\n        build();\n    }\n    \n    ll rank(const ul &where) const {return Rank[where];}\n    \n    ul size() const {return sa.size();}\n    \n    const node & operator [] (const ul &where) const {return *sa[where];}\n    \n    //返すのはsuffixの番号\n    ul lower_bound(const string &sub){\n        ll l=0;\n        ll r=s.size();\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            if(compare(m,sub)==-1){l=m+1;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(compare(i,sub)>=0){return i;}\n        }\n        return r+1;\n    }\n    \n    //返すのはsuffixの番号\n    ul upper_bound(const string &sub){\n        ll l=0;\n        ll r=s.size();\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            if(compare(m,sub)<=0){l=m+1;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(compare(i,sub)>0){return i;}\n        }\n        return r+1;\n    }\n    \n    bool match(const string &sub){\n        ll l=0;\n        ll r=s.size();\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            int st=compare(m,sub);\n            if(st==0){return true;}\n            else if(st==-1){l=m+1;}\n            else{r=m-1;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(compare(i,sub)==0){return true;}\n        }\n        return false;\n    }\n};\n\n\nint main(){\n    string t;\n    cin>>t;\n    suffix_array S(t);\n    ll q;\n    cin>>q;\n    while(q--){\n        string p;\n        cin>>p;\n        cout<<S.match(p)<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<complex>\n#include<typeinfo>\nusing namespace std;\n\nstruct Node{\n    Node* child[256];\n    vector<int> output;\n    Node(){\n        memset(child, 0, sizeof(child));\n    }\n    ~Node(){\n        for(int i = 0; i < 256; i++) if(child[i]) delete child[i];\n    }\n};\n\nvoid concatIntVector(vector<int> &v1, vector<int> &v2){\n    v1.insert(v1.begin(), v2.begin(), v2.end());\n}\n\nNode* makePMA(vector<string> &P){\n    Node* root = new Node;\n    root->child[0] = 0;\n    Node* now;\n    for (int i=0;i<P.size();i++){\n        now = root;\n        for (int j=0;j<P[i].size();j++){\n            if(now->child[(int)P[i][j]] == 0){\n                now->child[(int)P[i][j]] = new Node;\n            }\n            now = now->child[(int)P[i][j]];\n        }\n        now->output.push_back(i);\n    }\n\n    queue<Node*> qu;\n    for(int i=1;i<256;i++){\n        if(root->child[i]){\n            root->child[i]->child[0] = root;\n            qu.push(root->child[i]);\n        }else{\n            root->child[i] = root;\n        }\n    }\n    while(!qu.empty()){\n        now = qu.front();qu.pop();\n        for(int i=1;i<256;i++){\n            if(now->child[i]){\n                Node* fail = now->child[0];\n                while(!fail->child[i]){\n                    fail = fail->child[0];\n                }\n                now->child[i]->child[0] = fail->child[i];\n                concatIntVector(now->child[i]->output, fail->child[i]->output);\n                qu.push(now->child[i]);\n            }\n        }\n    }\n    return root;\n}\n\n\nvoid searchPMA(Node* &root, string &T, vector<bool> &res){\n    Node* now = root;\n    for (int i=0;i<T.size();i++){\n        while(!now->child[(int)T[i]]){\n            now = now->child[0];\n        }\n        now = now->child[(int)T[i]];\n        for (int j=0;j<(now->output).size();j++){\n            res[(now->output)[j]] = true;\n        }\n    }\n    return;\n}\n\nint main(){\n    string T;\n    cin >> T;\n    int Q;\n    cin >> Q;\n    vector<string> P;\n    string tmp;\n    for (int i=0;i<Q;i++){\n        cin >> tmp;\n        P.push_back(tmp);\n    }\n    Node* root = makePMA(P);\n    vector<bool> res(Q, false);\n    searchPMA(root, T, res);\n    for (int i=0;i<res.size();i++){\n        cout << res[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n\tstring T, P;\n\tlong Q;\n\tcin >> T >> Q;\n\tfor (long j = 0; j < Q; j++){\n\t\tcin >> P;\n\t\tlong flag = 0;\n\t\tif (T.size() < P.size()){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\telse \n\t\tfor (long i = 0; i < T.size() - P.size() + 1; i++){\n\t\t\tif (T[i] == P[0]){\n\t\t\t\tif (T.substr(i, P.size()) == P) flag = 1;\n\t\t\t}\n\t\t}\n\t\tif (flag) printf(\"1\\n\");\n\t\telse printf(\"0\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nvector<int> dat;\nvector<int> tmp;\n\nint doubles, lengths;\n\nbool compare_suffix(int i, int j)\n{\n\tif (dat[i] == dat[j])\n\t{\n\t\tint ri = (i + doubles <= lengths ? dat[i + doubles] : -1);\n\t\tint rj = (j + doubles <= lengths ? dat[j + doubles] : -1);\n\n\t\treturn ri < rj;\n\t}\n\n\treturn dat[i] < dat[j];\n}\n\nvector<int> suffix_array(string S)\n{\n\tlengths = S.size();\n\n\tvector<int> arrays(lengths + 1);\n\n\tdat.resize(lengths + 1);\n\ttmp.resize(lengths + 1);\n\n\tfor (int i = 0; i <= lengths; i++)\n\t{\n\t\tarrays[i] = i;\n\n\t\tdat[i] = i < lengths ? S[i] : -1;\n\t}\n\n\tfor (doubles = 1; doubles <= lengths; doubles <<= 1)\n\t{\n\t\tsort(arrays.begin(), arrays.begin() + lengths + 1, compare_suffix);\n\n\t\ttmp[arrays[0]] = 0;\n\n\t\tfor (int i = 1; i <= lengths; i++)\n\t\t{\n\t\t\ttmp[arrays[i]] = tmp[arrays[i - 1]] + (compare_suffix(arrays[i - 1], arrays[i]) ? 1 : 0);\n\t\t}\n\n\t\tfor (int i = 0; i <= lengths; i++)\n\t\t{\n\t\t\tdat[i] = tmp[i];\n\t\t}\n\t}\n\n\treturn arrays;\n}\n\nint main()\n{\n\tstring S, T; int Q;\n\t\n\tcin >> S >> Q;\n\n\tvector<int> sa = suffix_array(S);\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tcin >> T;\n\n\t\tint l = 0;\n\t\tint r = sa.size();\n\n\t\tbool flag = false;\n\n\t\twhile (r - l > 1)\n\t\t{\n\t\t\tint m = (l + r) / 2;\n\n\t\t\tstring S1 = S.substr(sa[m], T.size());\n\n\t\t\tif (S1 == T)\n\t\t\t{\n\t\t\t\tflag = true; break;\n\t\t\t}\n\t\t\t\n\t\t\tif (S1 < T)\n\t\t\t{\n\t\t\t\tl = m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = m;\n\t\t\t}\n\t\t}\n\n\t\tif (flag)\n\t\t{\n\t\t\tprintf(\"1\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define VARNAME(x) #x\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nconstexpr ll MOD = 1000000007LL;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n\n\n\n\nclass SuffixArray\n{\nprivate:\n    // static constexpr int encode(const int c) { return c == '$' ? 0 : c - 'a' + 1; }\n    // static constexpr char decode(const int n) { return (n == 0 ? '$' : 'a' + n - 1); }\n    static constexpr int encode(const int c) { return c == '$' ? 0 : c <= '9' ? 1 + c - '0' : c <= 'Z' ? 11 + c - 'A' : 37 + c - 'a'; }\n    static constexpr char decode(const int n) { return n == 0 ? '$' : n <= 10 ? '0' + n - 1 : n <= 36 ? 'A' + n - 11 : 'a' * n - 37; }\n    enum class Type : char\n    {\n        L = 0,\n        S = 1,\n        LMS = 2,\n    };\n\npublic:\n    SuffixArray(const string& s, const int kind_) : N(s.size() + 1), kind{kind_ + 1}, S(s.size() + 1, 0), type(N), next(N, 1), bucket(kind), num(kind, 0), head(kind, 0), tail(kind, 0)\n    {\n        for (int i = 0; i < s.size(); i++) {\n            S[i] = encode(s[i]);\n        }\n        initializeData();\n        sortLMS();\n    }\n    SuffixArray(const vector<int>& s, const int kind_) : N(s.size() + 1), kind{kind_ + 1}, S(s), type(N), next(N, 1), bucket(kind), num(kind, 0), head(kind, 0), tail(kind, 0)\n    {\n        S.push_back(0);\n        initializeData();\n        sortLMS();\n    }\n    void debugPrint() const\n    {\n        for (int i = 0; i < N; i++) {\n            cout << decode(S[i]);\n        }\n        cout << endl;\n        for (int i = 0; i < N; i++) {\n            cout << (type[i] == Type::L ? \"L\" : \"S\");\n        }\n        cout << endl;\n        for (int i = 0; i < N; i++) {\n            cout << (type[i] == Type::LMS ? \"@\" : \" \");\n        }\n        cout << endl;\n        for (int i = 0; i < kind; i++) {\n            if (bucket[i].empty()) continue;\n            cout << \"[\" << decode(i) << \"]:\\n\";\n            for (const int p : bucket[i]) {\n                cout << \"  \" << p << endl;\n            }\n        }\n    }\n\n    vector<int> getSuffixArray() const\n    {\n        vector<int> ans(N - 1);\n        for (int pos = 0, i = 1; i < kind; i++) {  // 番兵以外\n            for (const int p : bucket[i]) {\n                ans[pos++] = p;\n            }\n        }\n        return ans;\n    }\n\nprivate:\n    void initializeData()\n    {\n        for (const int i : S) {\n            num[i]++;\n        }\n        for (int i = 0; i < kind; i++) {\n            bucket[i].resize(num[i], -1);\n            tail[i] = num[i] - 1;\n        }\n        type[N - 1] = Type::S;\n        for (int i = N - 2; i >= 0; i--) {\n            type[i] = (S[i] != S[i + 1] ? (S[i] < S[i + 1] ? Type::S : Type::L) : type[i + 1]);\n            if (type[i] == Type::L and type[i + 1] == Type::S) {\n                type[i + 1] = Type::LMS;\n                LMS.push_back(i + 1);\n            }\n        }\n        for (int pos = N - 1, i = N - 2; i >= 0; i--) {\n            next[i] = pos;\n            if (type[i] == Type::LMS) {\n                pos = i;\n            }\n        }\n    }\n\n    void sortLMS()\n    {\n        for (const int l : LMS) {\n            insertTail(l);\n        }\n        induce();\n        vector<int> lms;\n        for (int i = 0; i < kind; i++) {\n            for (const int p : bucket[i]) {\n                if (type[p] == Type::LMS) {\n                    lms.push_back(p);\n                }\n            }\n        }\n        const int size = lms.size();\n        vector<int> order(N / 2 + 1, 0);\n        int number = 1;\n        order[N / 2] = 1;\n        bool same = false;\n        for (int i = 1; i < size; i++) {\n            const int l1 = lms[i - 1];\n            const int r1 = next[l1];\n            const int l2 = lms[i];\n            const int r2 = next[l2];\n            if (r1 - l1 == r2 - l2 and vector<int>(S.begin() + l1, S.begin() + r1 + 1) == vector<int>(S.begin() + l2, S.begin() + r2 + 1)) {\n                same = true;\n            } else {\n                number++;\n            }\n            order[l2 / 2] = number;\n        }\n        if (same) {\n            vector<int> s(size);\n            for (int p = 0, i = 0; i <= N / 2; i++) {\n                if (order[i] > 0) {\n                    s[p++] = order[i];\n                }\n            }\n            const vector<int> sorted = SuffixArray{s, number}.getSuffixArray();\n            for (int i = 0; i < kind; i++) {\n                head[i] = 0;\n                tail[i] = num[i] - 1;\n            }\n            for (int i = size - 1; i >= 0; i--) {\n                insertTail(LMS[size - 1 - sorted[i]]);\n            }\n            induce();\n        } else {\n            for (int i = 0; i < kind; i++) {\n                head[i] = 0;\n                tail[i] = num[i] - 1;\n            }\n            for (int i = size - 1; i >= 0; i--) {\n                insertTail(lms[i]);\n            }\n            induce();\n        }\n    }\n\n    void induce()\n    {\n        for (int i = 0; i < kind; i++) {\n            for (int j = 0; j < head[i]; j++) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] == Type::L) {\n                    insertHead(p - 1);\n                }\n            }\n            for (int j = tail[i] + 1; j < num[i]; j++) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] == Type::L) {\n                    insertHead(p - 1);\n                }\n            }\n        }\n        for (int i = 1; i < kind; i++) {  // 番兵以外\n            tail[i] = num[i] - 1;\n        }\n        for (int i = kind - 1; i >= 0; i--) {\n            for (int j = num[i] - 1; j > tail[i]; j--) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] != Type::L) {\n                    insertTail(p - 1);\n                }\n            }\n            for (int j = head[i] - 1; j >= 0; j--) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] != Type::L) {\n                    insertTail(p - 1);\n                }\n            }\n        }\n    }\n    void insertHead(const int i) { bucket[S[i]][head[S[i]]++] = i; }\n    void insertTail(const int i) { bucket[S[i]][tail[S[i]]--] = i; }\n\n    const int N;\n    const int kind;\n    vector<int> S;               // O(N)\n    vector<Type> type;           // O(N)\n    vector<int> next;            // O(N)\n    vector<vector<int>> bucket;  // O(N)\n    vector<int> num;             // O(K)\n    vector<int> head;            // O(K)\n    vector<int> tail;            // O(K)\n    vector<int> LMS;             // O(N)\n};\n\n\n\n// Problem: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n// Status: Accepted\n\nint main()\n{\n    string S;\n    cin >> S;\n    const auto sa = SuffixArray{S, 62}.getSuffixArray();\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; q++) {\n        string P;\n        cin >> P;\n        cout << (match(S, P, sa) ? 1 : 0) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<complex>\n#include<typeinfo>\nusing namespace std;\n\nstruct Node{\n    Node* child[256];\n    vector<int> output;\n    Node(){\n        memset(child, 0, sizeof(child));\n    }\n    ~Node(){\n        for(int i = 0; i < 256; i++) if(child[i]) delete child[i];\n    }\n};\n\nvoid concatIntVector(vector<int> &v1, vector<int> &v2){\n    v1.insert(v1.begin(), v2.begin(), v2.end());\n}\n\nNode* makePMA(vector<string> &P){\n    Node* root = new Node;\n    root->child[0] = 0;\n    Node* now;\n    for (int i=0;i<P.size();i++){\n        now = root;\n        for (int j=0;j<P[i].size();j++){\n            if(now->child[(int)P[i][j]] == 0){\n                now->child[(int)P[i][j]] = new Node;\n            }\n            now = now->child[(int)P[i][j]];\n        }\n        now->output.push_back(i);\n    }\n\n    queue<Node*> qu;\n    for(int i=1;i<256;i++){\n        if(root->child[i]){\n            root->child[i]->child[0] = root;\n            qu.push(root->child[i]);\n        }else{\n            root->child[i] = root;\n        }\n    }\n    while(!qu.empty()){\n        now = qu.front();qu.pop();\n        for(int i=1;i<256;i++){\n            if(now->child[i]){\n                Node* fail = now->child[0];\n                while(!fail->child[i]){\n                    fail = fail->child[0];\n                }\n                now->child[i]->child[0] = fail->child[i];\n                concatIntVector(now->child[i]->output, fail->child[i]->output);\n                qu.push(now->child[i]);\n            }\n        }\n    }\n    return root;\n}\n\n\nvoid searchPMA(Node* &root, string &T, vector<bool> &res){\n    Node* now = root;\n    for (int i=0;i<T.size();i++){\n        while(!now->child[(int)T[i]]){\n            now = now->child[0];\n        }\n        now = now->child[(int)T[i]];\n        for (int j=0;j<(now->output).size();j++){\n            res[(now->output)[j]] = true;\n        }\n    }\n    return;\n}\n\nint main(){\n    string T;\n    cin >> T;\n    int Q;\n    cin >> Q;\n    vector<string> P;\n    string tmp;\n    for (int i=0;i<Q;i++){\n        cin >> tmp;\n        P.push_back(tmp);\n    }\n    Node* root = makePMA(P);\n    vector<bool> res(Q, false);\n    searchPMA(root, T, res);\n    for (int i=0;i<res.size();i++){\n        cout << res[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 1100000\nint Rank[MAX_N],x[MAX_N];\nint SA[MAX_N];char S[MAX_N],T[MAX_N];int V;\nbool Compare(int p,int q){\n\tif(Rank[p]<Rank[q])return true;\n\tif(Rank[p]>Rank[q])return false;\n\tint D1=-1,D2=-1;\n\tif(p+V<=S.size())D1=Rank[p+V];\n\tif(q+V<=S.size())D2=Rank[q+V];\n\tif(D1<D2)return true;\n\treturn false;\n}\nvoid Build(){\n\tint SSIZE=strlen(S);\n\tfor(int i=0;i<SSIZE;i++){SA[i]=i;Rank[i]=S[i];}\n\tSA[SSIZE]=SSIZE;Rank[SSIZE]=-1;\n\tfor(V=1;V<=SSIZE;V*=2){\n\t\tsort(SA,SA+SSIZE+1,Compare);\n\t\tx[SA[0]]=0;\n\t\tfor(int i=1;i<=SSIZE;i++){\n\t\t\tx[SA[i]]=x[SA[i-1]]+Compare(SA[i-1],SA[i]);\n\t\t}\n\t\tfor(int i=0;i<=S.size();i++)Rank[i]=x[i];\n\t}\n}\nint hantei(string &V1,string &V2){\n\tint H=min(V1.size(),V2.size());\n\tfor(int i=0;i<H;i++){\n\t\tif(V1[i]<V2[i])return -1;\n\t\tif(V1[i]>V2[i])return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tcin>>S;int Q;cin>>Q;\n\tfor(int i=0;i<Q;i++){\n\t\tcin>>T;int L=0,R=S.size()+1,M;\n\t\twhile(L+1<R){\n\t\t\tM=(L+R)/2;\n\t\t\tif(hantei(S+SA[M],T)<=0)L=M;\n\t\t\telse{R=M;}\n\t\t}\n\t\tif(hantei(S+SA[L],T)==0)cout<<\"1\"<<endl;\n\t\telse cout<<\"0\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S 1000005\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\nstruct d{\n  int a,b,c;\n  d(){}\n  d(int A,int B,int C){\n    a=A,b=B,c=C;\n  };\n  bool operator<(const d&r)const{\n    if(a!=r.a)return a<r.a;\n    return b<r.b;\n  }\n};\n\nint n,slen,tlen,r[S];\nchar s[S],t[N];\nd ran[S];\nP a[S];\n\nvoid init(){\n  for(int i=0;i<26;i++)\n    for(int j=0;j<slen;j++)\n      if('a'+i==s[j])r[j]=i+1;\n  int x=1;\n  while(x<slen){\n    for(int i=0;i<slen;i++){\n      int a=i+x;\n      if(a>slen)a=slen;\n      ran[i]=d(r[i],r[a],i);\n    }\n    sort(ran,ran+slen);\n    int cnt=1;\n    for(int i=0;i<slen;i++){\n      r[ran[i].c]=cnt;\n      if(ran[i].a==ran[i+1].a&&ran[i].b==ran[i+1].b)\n\tcontinue;\n      cnt++;\n    }\n    x*=2;\n  }\n  for(int i=0;i<slen;i++)a[i]=P(r[i],i);\n  sort(a,a+slen);\n}\n\nbool bynary_search(){\n  int L=0,R=slen;\n  while(L<R){\n    int M=(L+R)/2;\n    if(strncmp(s+a[M].second,t,tlen)<0)L=M+1;\n    else R=M;\n  }\n  if(!strncmp(s+a[L].second,t,tlen))return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s%d\",s,&n);\n  slen=strlen(s);\n  init();  \n  while(n--){\n    scanf(\"%s\",t);\n    tlen=strlen(t);\n    if(bynary_search())printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define MAX_T 1000001\n#define MAX_P 1001\ntypedef vector<int> Vec;\n \nVec build_fail(const char *s){\n    int N = strlen(s);\n    Vec fail(N+1);\n    int j = fail[0] = -1;\n    for(int i = 1 ; i <= N ; i++){\n        while(j >= 0 && s[j] != s[i-1]) j = fail[j];\n        fail[i] = ++j;\n    }\n    return fail;\n}\n \nint match(const char *t,const char *s,const Vec &fail){\n    int n = strlen(t),m = strlen(s);\n    for(int i = 0, k = 0 ; i < n ; i++){\n        while(k >= 0 && s[k] != t[i]) k = fail[k];\n        if(++k >= m){\n            return true;\n        }\n    }\n    return false;\n}\n\nint main(){\n    int Q;\n    char T[MAX_T],P[MAX_P];\n    scanf(\"%s %d\",T, &Q);\n    Vec fail = build_fail(T);\n    while(Q--){\n        scanf(\"%s\",P);\n        if(match(T,P,fail)){\n            puts(\"1\");\n        }else{\n            puts(\"0\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nclass SA_IS\n{\nprivate:\n    using byte = unsigned char;\n    byte mask[8] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };\n    #define tget(i) !!(t[(i)>>3]&mask[(i)&7])\n    #define tset(i, b) t[(i)>>3]=(b) ? (mask[(i)&7]|t[(i)>>3]) : ((~mask[(i)&7])&t[(i)>>3])\n    #define chr(i) (cs==sizeof(int)?((int*)s)[i]:((byte *)s)[i])\n    #define isLMS(i) (i>0 && tget(i) && !tget(i-1))\n    void getBuckets(byte *s, int *bkt, int n, int K, int cs, bool end=true){\n        fill(bkt, bkt + K + 1, 0);\n        for(int i = 0; i < n; i++){\n            bkt[chr(i)]++;\n        }\n        for(int i = 0,tmp = 0; i < K+1; i++){\n            tmp += bkt[i];\n            bkt[i] = end ? tmp : tmp - bkt[i];\n        }\n    }\n    void induceSAl(byte *t, byte *s, int *bkt, int n, int K, int cs){\n        getBuckets(s, bkt, n, K, cs, false);\n        for(int i = 0; i < n; i++){\n            if(sa[i]>0 && !tget(sa[i]-1)){\n                sa[bkt[chr(sa[i]-1)]++] = sa[i]-1;\n            }\n        }\n    }\n    void induceSAs(byte *t, byte *s, int *bkt, int n, int K, int cs){\n        getBuckets(s, bkt, n, K, cs, true);\n        for(int i = n-1; i >= 0; i--){\n            if(sa[i] > 0 && tget(sa[i]-1)){\n                sa[--bkt[chr(sa[i]-1)]] = sa[i]-1;\n            }\n        }\n    }\n    void solve(byte *s, int n, int K=128, int cs=1){\n        byte t[(n >> 3)+1];\n        int bkt[K+1], n1 = 0, name = 0;\n        tset(n-2, 0), tset(n-1, 1);\n        for(int i = n - 3; i >=0; i--){\n            tset(i, (chr(i)<chr(i+1) || (chr(i)==chr(i+1) && tget(i+1))));\n        }\n        getBuckets(s, bkt, n, K, cs);\n        fill(sa, sa+n, -1);\n        for(int i = 1; i < n; i++){\n            if(isLMS(i)){\n                sa[--bkt[chr(i)]] = i;\n            }\n        }\n        induceSAl(t, s, bkt, n, K, cs);\n        induceSAs(t, s, bkt, n, K, cs);\n        for(int i = 0; i < n; i++){\n            if(isLMS(sa[i])){\n                sa[n1++] = sa[i];\n            }\n        }\n        fill(sa + n1, sa + n, -1);\n        for(int i = 0, tmp = -1; i < n1; i++){\n            int pos = sa[i], diff = false;\n            for(int d = 0; d < n && !diff; d++){\n                diff = chr(pos+d) != chr(tmp+d) || tget(pos+d) != tget(tmp+d);\n                if(!diff && d && (isLMS(pos+d) || isLMS(tmp+d))) break;\n            }\n            if(diff){\n                name++, tmp = pos;\n            }\n            sa[n1+((pos - (pos & 1)) >> 1)] = name - 1;\n        }\n        int* s1 = sa + n - n1;\n        for(int i = n - 1,j = n - 1; i >= n1; i--){\n            if(sa[i] >= 0){\n                sa[j--] = sa[i];\n            }\n        }\n        if(name < n1){\n            solve((byte*)s1, n1, name - 1, sizeof(int));\n        }else{\n            for(int i = 0; i < n1; i++){\n                sa[s1[i]] = i;\n            }\n        }\n        getBuckets(s, bkt, n, K, cs);\n        for(int i = 1, j = 0; i < n; i++){\n            if(isLMS(i)){\n                s1[j++] = i;\n            }\n        }\n        for(int i = 0; i < n1; i++){\n            sa[i] = s1[sa[i]];\n        }\n        fill(sa + n1, sa + n, -1);\n        for(int i = n1 - 1; i >= 0; i--){\n          int tmp = sa[i];\n          sa[i] = -1, sa[--bkt[chr(tmp)]] = tmp;\n        }\n        induceSAl(t, s, bkt, n, K, cs);\n        induceSAs(t, s, bkt, n, K, cs);\n    }\npublic:\n    bool contain(const string& T){\n        string SS = string((char*)S);\n        int a = 0, b = sz;\n        while(b - a > 1){\n            int c = (a + b) / 2;\n            if(SS.compare(sa[c], T.length(), T) < 0){\n                a = c;\n            }else{\n                b = c;\n            }\n        }\n        return SS.compare(sa[b], T.length(), T) == 0;\n    }\n    byte* S;\n    int sz;\n    int* sa;\n    SA_IS(string& arg){\n        sz = (int)arg.size();\n        sa = new int[sz+1];\n        S = (byte*)arg.c_str();\n        solve(S, sz+1);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    SA_IS sa(s);\n    int n;\n    cin >> n;\n    rep(i,n){\n        string t;\n        cin >> t;\n        cout << sa.contain(t) << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n\nusing namespace std;\n\nstring S, T; int Q;\n\nint main()\n{\n\tcin >> S >> Q;\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tcin >> T;\n\n\t\tcout << (S.find(T) != string::npos ? 1 : 0) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint n, k;\nstring s;\nvector<int> order;\nvector<int> tmp;\nvector<int> sa;\n\nbool compare_sa(const int &i, const int &j)\n{\n  if(order[i] != order[j]) return order[i] < order[j];\n  else\n  {\n    int ri = i + k <= n ? order[i+k] : -1;\n    int rj = j + k <= n ? order[j+k] : -1;\n    return ri < rj;\n  }\n}\n\nvoid construct_sa()\n{\n  for(int i = 0; i <= n; i++)\n  {\n    sa[i] = i;\n    order[i] = i < n ? s[i] : -1;\n  }\n  for(k = 1; k <= n; k*=2)\n  {\n    sort(sa.begin(),sa.end(),compare_sa);\n    tmp[sa[0]] = 0;\n    for(int i = 1; i <= n; i++)\n      tmp[sa[i]] = tmp[sa[i-1]] + (compare_sa(sa[i-1],sa[i])?1:0);\n    for(int i = 0; i <= n; i++)\n      order[i] = tmp[i];\n  }\n}\n\nvoid init()\n{\n  n = s.size();\n  order.resize(n+1);\n  tmp.resize(n+1);\n  sa.resize(n+1);\n  construct_sa();\n}\n\nbool contain(string t)\n{\n  int l=0, r=n;\n  while(r-l>1)\n  {\n    int m = (l+r)/2;\n    if(s.compare(sa[m],t.size(),t)<0) l = m;\n    else r = m;\n  }\n  return s.compare(sa[r],t.size(),t) == 0;\n}\n\nint main()\n{\n  cin >> s;\n  string t;\n  int q; cin >> q;\n  init();\n  construct_sa();\n  REP(i,q)\n  {\n     cin >> t;\n     cout << contain(t) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint ranker_MAX[1000005];\nint tenpaman[1000005];\nint kc,len;\nbool compare_sa(int i,int j){\n  return\n    ranker_MAX[i]!=ranker_MAX[j]?\n    ranker_MAX[i]<ranker_MAX[j]:\n    (i+kc<=len?ranker_MAX[i+kc]:-1)<(j+kc<=len?ranker_MAX[j+kc]:-1);\n}\n\nvoid construct_sa(char* S,int *sachiko){\n  len=strlen(S);\n  for(int i=0;i<=len;i++){\n    sachiko[i]=i;\n    ranker_MAX[i]=i<len?S[i]:-1;\n  }\n  for(kc=1;kc<=len;kc*=2){\n    sort(sachiko,sachiko+len+1,compare_sa);\n    tenpaman[sachiko[0]]=0;\n    for(int i=1;i<=len;i++){\n      tenpaman[sachiko[i]]=tenpaman[sachiko[i-1]]+compare_sa(sachiko[i-1],sachiko[i]);\n    }\n    for(int i=0;i<=len;i++)ranker_MAX[i]=tenpaman[i];\n  }\n}\nint n,m;\nchar strttenannkaiiiyone[1000005];\nchar t[1000005];\nint sachiko[1000005];\n\nint main(){\n  scanf(\"%s\",strttenannkaiiiyone);\n  n=strlen(strttenannkaiiiyone);\n  construct_sa(strttenannkaiiiyone,sachiko);\n  scanf(\"%d\",&m);\n  while(m--){\n    scanf(\"%s\",t);\n    int k=strlen(t);\n    int l=0,r=n+1,m;\n    while(l+1<r){\n      m=(l+r)/2;\n      if(strncmp(strttenannkaiiiyone+sachiko[m],t,k)<=0)l=m;\n      else r=m;\n    }\n    printf(\"%d\\n\",(strncmp(strttenannkaiiiyone+sachiko[l],t,k)==0));\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\nusing namespace std;\n\nstruct P {\n  static vector<P*> data;\n  map<char,P*> next;\n  P(){}\n  void initialize(char* str){\n    P* tar=this;\n    while(*str){\n      P** lpnx;\n      if(tar!=this&&*(lpnx=&(this->next[*str]))==NULL) *lpnx=new P();\n      data.push_back(tar=tar->next[*str]=new P()); ++str;\n    }\n  }\n  void add(char* str, int index){\n    P** lpnx;\n    str+=index;P* tar=this->next[*str];++str;++index;\n    if(*(lpnx=&(tar->next[*str]))==NULL) *lpnx=data[index];\n  }\n  int find (char* str) {\n    P* tar=this;\n    while(*str){\n      P** lpnx;\n      if(*(lpnx=&(tar->next[*str]))==NULL) return 0;\n      tar=*lpnx; ++str;\n    }\n    return 1;\n  }\n};\nvector<P*> P::data;\n\nint main () {\n  string s;int q;cin>>s>>q;\n  P* root=new P();char* str=(char*)s.c_str();\n  root->initialize(str);int len=s.size()-1;\n  for(int i=1;i<len;++i)\n    root->add(str,i);\n  for(int i=0;i<q;++i){\n    string t;cin>>t;\n    cout<<root->find((char*)t.c_str())<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint Rank[1000005];\nint Tmp[1000005];\nint kc,len;\n\nbool compare_sa(int i,int j){\n  return\n    Rank[i]==Rank[j]?\n    Rank[i]<Rank[j]:\n    (i+kc<=len?Rank[i+kc]:-1)<(j+kc<=len?Rank[j+kc]:-1);\n}\n\nvoid construct_sa(char* S,int *sa){\n  len=strlen(S);\n  for(int i=0;i<=len;i++){\n    sa[i]=i;\n    Rank[i]=i<len?S[i]:-1;\n  }\n  for(kc=1;kc<=len;kc*=2){\n    sort(sa,sa+len+1,compare_sa);\n    Tmp[sa[0]]=0;\n    for(int i=1;i<=len;i++){\n      Tmp[sa[i]]=Tmp[sa[i-1]]+compare_sa(sa[i-1],sa[i]);\n    }\n    for(int i=0;i<=len;i++)Rank[i]=Tmp[i];\n  }\n}\n\n\nint n,m;\nchar str[1000005];\nchar t[1000005];\nint sa[1000005];\n\nint main(){\n  scanf(\"%s\",str);\n  n=strlen(str);\n  construct_sa(str,sa);\n  scanf(\"%d\",&m);\n  while(m--){\n    scanf(\"%s\",t);\n    int k=strlen(t);\n    int l=0,r=n+1,m;\n    while(l+1<r){\n      m=(l+r)/2;\n      if(strncmp(str+sa[m],t,k)<=0)l=m;\n      else r=m;\n    }\n    printf(\"%d\\n\",(strncmp(str+sa[l],t,k)==0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Multiple string matching (suffix array)\n * O(T log T + \\sum (P_i log T))\n *\n * Construction: reduce to sorting the cyclic shifts of A||'$'\n */\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconstexpr int kAlphabetSize = 37;\n\nint ValueOf(char ch) {\n  if (ch == '$')\n    return 0;\n  if ('0' <= ch && ch <= '9')\n    return 1 + ch - '0';\n  if ('a' <= ch && ch <= 'z')\n    return 11 + ch - 'a';\n  cout << \"Unexpected character!\" << endl;\n  exit(1);\n  return -1;\n}\n\nvector<int> SortCyclicShifts(string &A) {\n  // Approach: sort cyclic substrings of length 1, 2, 4, ..., 2^(\\ceil \\lg n)\n  int n = A.size();\n\n  // After step k,\n  // p[i] stores the index (in A) of the ith-smallest (starting\n  // from 0) cyclic substring of A of length 2^k;\n  // c[i] stores the equivalence class (dense, starting from 0, in increasing\n  // sorted value order) of the length-2^k substring starting at A[i]\n  //\n  // psecond and cnext are temporary arrays used to populate p and c each step\n  // count is an auxiliary array used for bucket sort\n  vector<int> p(n), c(n), psecond(n), cnext(n), count(max(n, kAlphabetSize));\n\n  // Step 1: sort cyclic substrings of length 1\n  for (int i = 0; i < n; ++i)\n    ++count[ValueOf(A[i])];\n  for (int i = 1; i < count.size(); ++i)\n    count[i] += count[i - 1];\n  for (int i = n - 1; i >= 0; --i)\n    p[--count[ValueOf(A[i])]] = i;\n\n  int num_classes = 1;\n  for (int i = 1; i < n; ++i) {\n    if (A[p[i]] != A[p[i - 1]]) {\n      c[p[i]] = num_classes;\n      ++num_classes;\n    } else {\n      c[p[i]] = c[p[i - 1]];\n    }\n  }\n\n  // Step 2: for each k=1,...,ceil(log2(n)), use\n  // the result of sorting the cyclic substrings of length 2^{k-1} to\n  // sort the cyclic substrings of length 2^k\n  for (int h /* k-1 */ = 0; (1 << h) < n; ++h) {\n    // First, sort the cyclic substrings of length 2^k by their second halves;\n    // to do this, directly apply the fact that the second half of a length\n    // 2^k substring starting at index i is the length-2^{k-1} substring\n    // starting at index (i+2^{k-1})\n    for (int i = 0; i < n; ++i) {\n      psecond[i] = p[i] - (1 << h);\n      if (psecond[i] < 0)\n        psecond[i] += n;\n    }\n\n    // Second, complete the sort of cyclic substrings of\n    // length 2^k by performing an in-place sort keyed by their first halves\n    fill_n(begin(count), num_classes, 0);\n\n    // Count the number of occurrences of each equivalence class\n    // among cyclic substrings of length 2^{k-1}\n    for (int i = 0; i < n; ++i)\n      ++count[c[i]];\n    for (int i = 1; i < num_classes; ++i)\n      count[i] += count[i - 1];\n\n    // Proceding in decreasing order sorted by second half,\n    // put each index of the array at the last available spot of the\n    // range, in sorted order, accorded to the equivalence class to which\n    // the index's _first_ half belongs\n    for (int i = n - 1; i >= 0; --i)\n      p[--count[c[psecond[i]]]] = psecond[i];\n\n    num_classes = 1;\n    cnext[p[0]] = 0;\n    for (int i = 1; i < n; ++i) {\n      if (c[p[i]] == c[p[i - 1]] &&\n          c[p[i] + (1 << h) % n] == c[p[i - 1] + (1 << h) % n]) {\n        cnext[p[i]] = cnext[p[i - 1]];\n      } else {\n        cnext[p[i]] = cnext[p[i - 1]] + 1;\n        ++num_classes;\n      }\n    }\n\n    c.swap(cnext);\n  }\n\n  return p;\n}\n\nint main() {\n  string T;\n  cin >> T;\n  T.push_back('$');\n\n  auto suf = SortCyclicShifts(T);\n\n  int q;\n  cin >> q;\n  string P;\n  for (int i = 0; i < q; ++i) {\n    cin >> P;\n    auto res =\n        lower_bound(begin(suf), end(suf), P, [&T](int x, const string &P) {\n          string cmp = T.substr(x, P.size());\n          return cmp < P;\n        });\n    cout << (P == T.substr(*res, P.size())) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\nint *Lv;\nint n, k;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n    return L_i < L_j;\n}\n\nint main()\n{\n    int *A, *newLv;\n    std::string T;\n    std::cin >> T;\n    n = T.size();\n\n    A = new int [n + 1]; Lv = new int [n + 1]; newLv = new int [n + 1];\n\n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n    std::sort(A, A + n, cmp_Lv);\n\n    newLv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        newLv[A[i]] = newLv[A[i - 1]] + (Lv[A[i]] != Lv[A[i - 1]] ? 1 : 0);\n    }\n    for(i = 0; i < n; i++){ Lv[i] = newLv[i]; }\n\n    k = 1;\n    while(1){\n        if(k > n) break;\n\n        std::sort(A, A + n, cmp);\n        newLv[A[0]] = 0;\n        for(i = 1; i < n; i++){ newLv[A[i]] = newLv[A[i - 1]] + (cmp(A[i - 1], A[i]) ? 1 : 0); }\n        for(i = 0; i < n; i++){ Lv[i] = newLv[i]; }\n\n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n\n    delete [] Lv; delete [] newLv;\n\n\tstd::string P;\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n\n    A[n] = n;\n\n    while(q){\n\t\tstd::cin >> P;\n        left = 0, right = n, exist = false;\n        while(left < right){\n\n            if(n < P.size()){ exist = false; break; }\n\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n\n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n\tdelete [] A;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nvector<string> sa;\nstring P;\nint Plen;\n\nvoid qmultisort(vector<string> &src, int size, int suffix) {\n    if (size <= 1) {\n        return;\n    }\n    vector<string> lower, middle, larger;\n    char pivot = src[size / 2][suffix];\n\n    for (int i = 0; i < size; i++) {\n        if (src[i][suffix] == pivot) {\n            middle.push_back(src[i]);\n        }\n        else if (src[i][suffix] < pivot) {\n            lower.push_back(src[i]);\n        }\n        else {\n            larger.push_back(src[i]);\n        }\n    }\n    \n    int lowsize = lower.size(), midsize = middle.size(), larsize = larger.size(), now = 0;\n    qmultisort(lower, lowsize, suffix);\n    qmultisort(middle, midsize, suffix + 1);\n    qmultisort(larger, larsize, suffix);\n\n    for (int i = 0; i < lowsize; i++) {\n        src[now++] = lower[i];\n    }\n    for (int i = 0; i < midsize; i++) {\n        src[now++] = middle[i];\n    }\n    for (int i = 0; i < larsize; i++) {\n        src[now++] = larger[i];\n    }\n}\n\nbool binary_search(int left, int right) {\n    if (left > right) {\n        return false;\n    }\n    \n    int pivot = (left + right) / 2;\n    if (P == sa[pivot].substr(0, Plen)) {\n        return true;\n    }\n    else if (P < sa[pivot]) {\n        return binary_search(0, pivot - 1);\n    }\n    else {\n        return binary_search(pivot + 1, right);\n    }\n}\n\nint main() {\n    string T;\n    int Tlen, n;\n    cin >> T;\n    Tlen = T.size();\n\n    sa.resize(Tlen);\n    for (int i = 0; i < Tlen; i++) {\n        sa[i] = T.substr(i);\n    }\n    qmultisort(sa, Tlen, 0);\n\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> P;\n        Plen = P.size();\n        cout << binary_search(0, Tlen - 1) << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S 2500005\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\nstruct d{\n  int a,b,c;\n  d(){}\n  d(int A,int B,int C){\n    a=A,b=B,c=C;\n  };\n  bool operator<(const d&r)const{\n    if(a!=r.a)return a<r.a;\n    return b<r.b;\n  }\n};\n\nint n,slen,tlen,r[S];\nchar s[S],t[N];\nd ran[S];\nP a[S];\n\nvoid init(){\n  for(int i=0;i<26;i++)\n    for(int j=0;j<slen;j++)\n      if('a'+i==s[j])r[j]=i+1;\n  int x=1;\n  r[slen]=0;\n  while(x<=slen){\n    for(int i=0;i<slen;i++){\n      int o=i+x;\n      if(o>slen)o=slen;\n      ran[i]=d(r[i],r[o],i);\n    }\n    sort(ran,ran+slen);\n    int cnt=1;\n    for(int i=0;i<slen;i++){\n      r[ran[i].c]=cnt;\n      if(ran[i].a==ran[i+1].a&&ran[i].b==ran[i+1].b)\n\tcontinue;\n      cnt++;\n    }\n    x*=2;\n  }\n  for(int i=0;i<slen;i++)a[i]=P(r[i],i);\n  sort(a,a+slen);\n}\n\nbool bynary_search(){\n  int L=0,R=slen;\n  while(L<R){\n    int M=(L+R)/2;\n    if(strncmp(s+a[M].second,t,tlen)<0)L=M+1;\n    else R=M;\n  }\n  if(!strncmp(s+a[L].second,t,tlen))return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s%d\",s,&n);\n  slen=strlen(s);\n  init();  \n  while(n--){\n    scanf(\"%s\",t);\n    tlen=strlen(t);\n    if(bynary_search())printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring str;\nint k, len;\nint sa[1000001], Rank[1000001], temp[1000001];\n\nbool compare_sa(int i, int j) {\n    if (Rank[i] == Rank[j]) {\n        int t1 = -1, t2 = -1;\n        if (i + k <= len) {\n            t1 = Rank[i + k];\n        }\n        if (j + k <= len) {\n            t2 = Rank[j + k];\n        }\n        return t1 < t2;\n    }\n    else {\n        return Rank[i] < Rank[j];\n    }\n}\n\nvoid construct_sa() {\n    for (int i = 0; i <= len; i++) {\n        sa[i] = i;\n        if (i == len) {\n            Rank[i] = -1;\n        }\n        else {\n            Rank[i] = str[i];\n        }\n    }\n\n    for (k = 1; k <= len; k *= 2) {\n        sort(sa, sa + len + 1, compare_sa);\n        \n        temp[sa[0]] = 0;\n        for (int i = 1; i <= len; i++) {\n            temp[sa[i]] = temp[sa[i - 1]] + compare_sa(sa[i - 1], sa[i]);\n        }\n        for (int i = 0; i <= len; i++) {\n            Rank[i] = temp[i];\n        }\n    }\n}\n\nint main() {\n    cin >> str;\n    len = str.size();\n\n    construct_sa();\n\n    int n, tlen;\n    string t, copy;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> t;\n        tlen = t.size();\n        int left = 1, right = len + 1, pivot;\n        while (left + 1 < right) {\n            pivot = (left + right) / 2;\n            copy = &str[0] + sa[pivot];\n            if (t <= copy.substr(0, tlen)) {\n                right = pivot;\n            }\n            else {\n                left = pivot;\n            }\n        }\n        if (t == copy.substr(0, tlen)) {\n            cout << 1 << endl;\n        }\n        else {\n            cout << 0 << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef unsigned long long int ull;\n\nclass RollingHash{\npublic:\n  RollingHash(std::string _s):s(_s){Hashing();};\n  std::vector<int> search(std::string p);\n  \nprivate:\n  ull PatternHash(std::string s);\n  void Hashing();\n  std::string s;\n  std::vector<ull> rh;//???????????\\??????????´??????????vector\n  std::vector<ull> bh;//base????´????\n  ull base = 1e9 + 7;\n};\n\nstd::vector<int> RollingHash::search(std::string p){\n  ull pHash = PatternHash(p);\n  std::vector<int> res;\n  int sl = s.length(), pl = p.length();\n  for (int i = 0; i < sl - pl + 1; i++) {\n    if(pHash == rh[pl + i] - rh[i]*bh[i]){\n      res.push_back(i);\n    }\n  }\n  return res;\n}\n\null RollingHash::PatternHash(std::string s){\n  ull res = 0;\n  for (int i = 0; i < s.length(); i++) {\n    res = res*base + s[i];\n  }\n  return res;\n}\n\nvoid RollingHash::Hashing(){\n  int n = s.length();\n  rh.resize(n + 1, 0);\n  bh.resize(n + 1, 1);\n  for (int i = 0; i < n; i++) {\n    rh[i + 1] = rh[i]*base + (ull)s[i];\n    bh[i + 1] = bh[i]*base;\n  }\n}\n\nint main(){\n  string s, t;\n  int q;\n  std::cin >> s >> q;\n  RollingHash rh(s);\n  for (int i = 0; i < q; i++) {\n    std::cin >> t;\n    vector<int> ans = rh.search(t);\n    if(ans.size() == 0){\n      std::cout << 0 << std::endl;\n    }else{\n      std::cout << 1 << std::endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n \n#define REP(i,n) for(int i=0;i<n;i++)\n \nusing namespace std;\n \nint n, k;\nstring s;\nvector<int> order;\nvector<int> tmp;\nvector<int> sa;\n \nbool compare_sa(const int &i, const int &j)\n{\n  if(order[i] != order[j]) return order[i] < order[j];\n  else\n  {\n    int ri = i + k <= n ? order[i+k] : -1;\n    int rj = j + k <= n ? order[j+k] : -1;\n    return ri < rj;\n  }\n}\n \nvoid construct_sa()\n{\n  for(int i = 0; i <= n; i++)\n  {\n    sa[i] = i;\n    order[i] = i < n ? s[i] : -1;\n  }\n  for(k = 1; k <= n; k*=2)\n  {\n    sort(sa.begin(),sa.end(),compare_sa);\n    tmp[sa[0]] = 0;\n    for(int i = 1; i <= n; i++)\n      tmp[sa[i]] = tmp[sa[i-1]] + (compare_sa(sa[i-1],sa[i])?1:0);\n    for(int i = 0; i <= n; i++)\n      order[i] = tmp[i];\n  }\n}\n \nvoid init()\n{\n  n = s.size();\n  order.resize(n+1);\n  tmp.resize(n+1);\n  sa.resize(n+1);\n  construct_sa();\n}\n \nbool contain(string t)\n{\n  int l=0, r=n;\n  while(r-l>1)\n  {\n    int m = (l+r)/2;\n    if(s.compare(sa[m],t.size(),t)<0) l = m;\n    else r = m;\n  }\n  return s.compare(sa[r],t.size(),t) == 0;\n}\n \nint main()\n{\n  cin >> s;\n  string t;\n  int q; cin >> q;\n  init();\n  construct_sa();\n  REP(i,q)\n  {\n     cin >> t;\n     cout << contain(t) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <numeric>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint Q; string s; vector<unsigned long long> p, h;\nunsigned long long gethash(int l, int r) {\n\treturn h[r] - h[l] * p[r - l];\n}\nint lcp(int x, int y) {\n\tint l = 0, r = min(s.size() - x, s.size() - y) + 1;\n\twhile (r - l > 1) {\n\t\tint m = (l + r) >> 1;\n\t\tif (gethash(x, x + m) == gethash(y, y + m)) l = m;\n\t\telse r = m;\n\t}\n\treturn l;\n}\nbool compare_sa(int i, int j) {\n\tint k = lcp(i, j);\n\tif (i + k >= s.size()) return true;\n\tif (j + k >= s.size()) return false;\n\treturn s[i + k] <= s[j + k];\n}\nint main() {\n\tcin >> s >> Q;\n\tvector<int> l(Q + 2); l[1] = s.size();\n\tfor (int i = 0; i < Q; i++) {\n\t\tstring t;\n\t\tcin >> t; s += t;\n\t\tl[i + 2] = l[i + 1] + t.size();\n\t}\n\tp.resize(s.size() + 1); p[0] = 1;\n\th.resize(s.size() + 1);\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tp[i + 1] = p[i] * 265;\n\t\th[i + 1] = h[i] * 265 + s[i];\n\t}\n\tvector<int> sa(s.size());\n\tiota(sa.begin(), sa.end(), 0);\n\tsort(sa.begin(), sa.end(), compare_sa);\n\tvector<int> sa_inv(s.size());\n\tfor (int i = 0; i < s.size(); i++) sa_inv[sa[i]] = i;\n\tvector<int> v;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (sa[i] < l[1]) v.push_back(i);\n\t}\n\tfor (int i = 0; i < Q; i++) {\n\t\tint w = sa_inv[l[i + 1]];\n\t\tint ptr = lower_bound(v.begin(), v.end(), w) - v.begin();\n\t\tbool flag = false;\n\t\tfor (int j = -1; j <= 0; j++) {\n\t\t\tint pos = ptr + j;\n\t\t\tif (0 <= pos && pos < v.size()) {\n\t\t\t\tif (min(l[1] - sa[v[pos]], lcp(sa[v[pos]], l[i + 1])) >= l[i + 2] - l[i + 1]) flag = true;\n\t\t\t}\n\t\t}\n\t\tcout << flag << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\nchar str[1000001];\nint k, len;\nint sa[1000001], Rank[1000001], temp[1000001];\n\nbool compare_sa(int i, int j) {\n    if (Rank[i] == Rank[j]) {\n        int t1 = -1, t2 = -1;\n        if (i + k <= len) {\n            t1 = Rank[i + k];\n        }\n        if (j + k <= len) {\n            t2 = Rank[j + k];\n        }\n        return t1 < t2;\n    }\n    else {\n        return Rank[i] < Rank[j];\n    }\n}\n\nvoid construct_sa() {\n    for (int i = 0; i <= len; i++) {\n        sa[i] = i;\n        if (i == len) {\n            Rank[i] = -1;\n        }\n        else {\n            Rank[i] = str[i];\n        }\n    }\n\n    for (k = 1; k <= len; k *= 2) {\n        sort(sa, sa + len + 1, compare_sa);\n        \n        temp[sa[0]] = 0;\n        for (int i = 1; i <= len; i++) {\n            temp[sa[i]] = temp[sa[i - 1]] + compare_sa(sa[i - 1], sa[i]);\n        }\n        for (int i = 0; i <= len; i++) {\n            Rank[i] = temp[i];\n        }\n    }\n}\n\nint main() {\n    cin >> str;\n    len = strlen(str);\n\n    construct_sa();\n\n    int n, tlen;\n    char t[1001];\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> t;\n        tlen = strlen(t);\n        int left = 0, right = len + 1, pivot;\n        while (left + 1 < right) {\n            pivot = (left + right) / 2;\n\n            if (strncmp(str + sa[pivot], t, tlen) <= 0) {\n                left = pivot;\n            }\n            else {\n                right = pivot;\n            }\n        }\n        cout << (strncmp(str + sa[left], t, tlen) == 0) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <map>\n#include <new>\n#include <deque>\n#include <functional>\nusing namespace std;\n\ntemplate <class T>\nstruct myalloc{\n\tusing value_type = T;\n\n\tstatic const int num = 512;\n\tint k;\n\n\tdeque<vector<char>> dq;\n\tmyalloc() : k(num) {}\n\n\ttemplate <class U>\n\tmyalloc(const myalloc<U> &){}\n\n\tT* allocate(size_t n){\n\t\tif(k >= num){\n\t\t\tdq.emplace_back(num * sizeof(T));\n\t\t\tk = 0;\n\t\t}\n\t\treturn reinterpret_cast<T*>(&dq.back()[k++ * sizeof(T)]);\n\t}\n\n\tvoid deallocate(T*, size_t){}\n};\n\nstruct node{\n\tint fail;\n\tbool vis;\n\tmap<char,int,less<char>,myalloc<char>> nxt;\n};\n\nvector<node> trie;\n\nstring input(){\n\tstatic char buf[1000010];\n\tbuf[0] = 0;\n\tscanf(\"%s\", buf);\n\treturn buf;\n}\n\nint main(){\n\ttrie.reserve(1000010);\n\n\ttrie.emplace_back();\n\ttrie[0].fail = -1;\n\n\tstring t = input();\n\tint q;\n\tscanf(\"%d\", &q);\n\tvector<int> idx(q);\n\tfor(int i = 0; i < q; ++i){\n\t\tstring p = input();\n\t\tint u = 0;\n\t\tfor(char c : p){\n\t\t\tif(!trie[u].nxt.count(c)){\n\t\t\t\ttrie[u].nxt.emplace(c, trie.size());\n\t\t\t\ttrie.emplace_back();\n\t\t\t}\n\t\t\tu = trie[u].nxt[c];\n\t\t}\n\t\tidx[i] = u;\n\t}\n\n\tvector<int> bfs;\n\tbfs.push_back(0);\n\tint k = 0;\n\twhile(k < (int)bfs.size()){\n\t\tint u = bfs[k++];\n\t\tfor(const auto &pr : trie[u].nxt){\n\t\t\tchar c = pr.first;\n\t\t\tint v = pr.second;\n\t\t\tbfs.push_back(v);\n\n\t\t\tint f = trie[u].fail;\n\t\t\twhile(f >= 0 && !trie[f].nxt.count(c)){\n\t\t\t\tf = trie[f].fail;\n\t\t\t}\n\t\t\ttrie[v].fail = f >= 0 ? trie[f].nxt[c] : 0;\n\t\t}\n\t}\n\n\tint r = 0;\n\tfor(char c : t){\n\t\twhile(r >= 0 && !trie[r].nxt.count(c)){\n\t\t\tr = trie[r].fail;\n\t\t}\n\t\tr = r >= 0 ? trie[r].nxt[c] : 0;\n\t\ttrie[r].vis = true;\n\t}\n\n\tfor(int i = bfs.size(); --i; ){\n\t\tint u = bfs[i];\n\t\tif(trie[u].vis){\n\t\t\ttrie[trie[u].fail].vis = true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < q; ++i){\n\t\tprintf(\"%d\\n\", +trie[idx[i]].vis);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nstruct SAComp{\n\tconst int h,*g;\n\tSAComp(const int h, const char* g) : h(h), g(g) {}\n\tbool operator()(const int a, const int b){\n\t\treturn a == b ? false : g[a] != g[b] ? g[a] < g[b] : g[a+h] < g[b+h];\n\t}\n};\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s;\n\tcin>>s;\n\ts+='$';\n\tint n=s.size();\n\tvector<int>suff(n);\n\tiota(suff.begin(),suff.end(),0);\n\t{\n\t\tconst char *str=s.c_str();\n\t\tsort(suff.begin(),suff.end(),SAComp(0,str));\n\t}\n\tvector<pair<char,int>>sorted(n);\n\tfor(int i=0;i<n;i++)sorted[i]={s[(suff[i]-1+n)%n],i};\n\tsort(sorted.begin(),sorted.end());\n\n\tint T;\n\tfor(cin>>T;T--;){\n\t\tstring q;\n\t\tcin>>q;\n\t\tint start=0,stop=n,idx=q.size()-1;\n\t\tfor(;idx>=0;idx--){\n\t\t\tpair<char,int> ql={q[idx],start},qr={q[idx],stop};\n\t\t\tstart=lower_bound(sorted.begin(),sorted.end(),ql)-sorted.begin();\n\t\t\tstop=lower_bound(sorted.begin(),sorted.end(),qr)-sorted.begin();\n\t\t\tif(start==stop)break;\n\t\t}\n\t\tif(idx<0){\n\t\t\t//{vector<int>v;for(;start<stop;start++)v.push_back(suff[start]);sort(v.begin(),v.end());for(auto &e:v)printf(\"%d\\n\",e);}\n\t\t\tputs(\"1\");\n\t\t}else{\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n\n#pragma warning(disable: 4996)\n\nusing namespace std;\n\nint Q; char STR1[1000001], STR2[1001];\n\nvector<int> ptr[62];\n\nconst char strings[63] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890\";\n\nint main()\n{\n\tscanf(\"%s\", &STR1);\n\n\tfor (int i = 0; i < strlen(STR1); i++)\n\t{\n\t\tfor (int j = 0; j < 62; j++)\n\t\t{\n\t\t\tif (STR1[i] == strings[j])\n\t\t\t{\n\t\t\t\tptr[j].push_back(i); break;\n\t\t\t}\n\t\t}\n\t}\n\n\tscanf(\"%d\", &Q);\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%s\", STR2);\n\n\t\tint code_;\n\t\tint size_;\n\n\t\tfor (int j = 0; j < 62; j++)\n\t\t{\n\t\t\tif (STR2[0] == strings[j])\n\t\t\t{\n\t\t\t\tsize_ = ptr[j].size();\n\n\t\t\t\tcode_ = j;\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 0; j < size_; j++)\n\t\t{\n\t\t\tint ptr_ = ptr[code_][j];\n\n\t\t\tbool ok = false;\n\n\t\t\tif (ptr[code_][j] + strlen(STR2) <= strlen(STR1))\n\t\t\t{\n\t\t\t\tok = true;\n\n\t\t\t\tfor (int k = 0; k < strlen(STR2); k++)\n\t\t\t\t{\n\t\t\t\t\tif (STR1[ptr_ + k] != STR2[k])\n\t\t\t\t\t{\n\t\t\t\t\t\tok = false; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ok)\n\t\t\t{\n\t\t\t\tprintf(\"1\\n\");\n\n\t\t\t\tgoto Exit;\n\t\t\t}\n\n\t\t\tif (j + 1 >= size_)\n\t\t\t{\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t}\n\t\t}\n\n\tExit:;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\n\n#define fi(x) get<0>(x)\n#define se(x) get<1>(x)\n\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\ntypedef vector<pll> vpl;\n\nstring t;\nstring p;\nlli q;\n\nvll sa;\nvll tmp;\nvll rnk_;\nvll rnk;\n\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> t;\n    sa = vll(t.size());rnk = vll(t.size()),rnk_ = vll(t.size());tmp = vll(t.size());\n    for(lli i = 0;i < t.size();i++) sa[i] = i;\n    for(lli i = 0;i < t.size();i++) rnk[i] = t[i];\n    sort(sa.begin(),sa.end(),[](lli a,lli b){\n        return rnk[a] < rnk[b];\n    });\n    for(lli k = 1;k < t.size();k *= 2){\n        lli from = 0;\n        lli to = 0;\n        do{\n            from = to;\n            while(rnk[sa[from]] == rnk[sa[to]]) to++;\n            for(lli i = from;i < to;i++) rnk_[sa[i]] = sa[i]+k < rnk.size() ? rnk[sa[i]+k] : -1;\n            sort(sa.begin()+from,sa.begin()+to,[](lli a,lli b){\n                return rnk_[a] < rnk_[b];\n            });\n        }while(to < sa.size());\n        tmp[sa[0]] = 0;\n        for(lli i = 1;i < sa.size();i++){\n            lli c = 1;\n            if(rnk[sa[i-1]] == rnk[sa[i]] && rnk_[sa[i-1]] == rnk_[sa[i]]) c = 0;\n            tmp[sa[i]] = tmp[sa[i-1]] + c;\n\n        }\n        for(lli i = 0;i < sa.size();i++){\n            rnk[sa[i]] = tmp[sa[i]];\n        }\n    }\n    sort(sa.begin(),sa.end(),[](lli a,lli b){\n        return rnk[a] < rnk[b];\n    });\n    //for(lli i = 0;i < sa.size();i++) cout << sa[i] << endl;\n    /*\n    for(lli i = 0;i < sa.size();i++){\n        for(lli j = sa[i];j < t.size();j++) cout << t[j];\n        cout << endl;\n    }\n    */\n    \n    cin >> q;\n    for(lli i = 0;i < q;i++){\n        cin >> p;\n        auto from = sa.begin();\n        auto to = sa.end();\n        for(lli i = 0;i < p.size();i++){\n            from = lower_bound(from,to,p[i],[i](lli x,char c){\n                if(x+i >= t.size()) return false;\n                return t[x+i] < c;\n            });\n            to = lower_bound(from,to,p[i],[i](lli x,char c){\n                if(x+i >= t.size()) return false;\n                return t[x+i] < c+1;\n            });\n            //cout << from-sa.begin() << \" \" << to-sa.begin() << endl;\n        }\n        if(to-from > 0) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S 2500005\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\nstruct d{\n  int a,b,c;\n  d(){}\n  d(int A,int B,int C){\n    a=A,b=B,c=C;\n  };\n  bool operator<(const d&r)const{\n    if(a!=r.a)return a<r.a;\n    return b<r.b;\n  }\n};\n\nint n,slen,tlen,r[S];\nchar s[S],t[N];\nd ran[S];\nP a[S];\n\nvoid init(){\n  for(int i=0;i<slen;i++)r[i]=s[i];\n  int x=1;\n  r[slen]=0;\n  while(1){\n    for(int i=0;i<slen;i++){\n      int o=i+x;\n      if(o>slen)o=slen;\n      ran[i]=d(r[i],r[o],i);\n    }\n    sort(ran,ran+slen);\n    int cnt=1;\n    for(int i=0;i<slen;i++){\n      r[ran[i].c]=cnt;\n      if(ran[i].a==ran[i+1].a&&ran[i].b==ran[i+1].b)\n\tcontinue;\n      cnt++;\n    }\n    if(x>slen)break;\n    x*=2;\n  }\n  for(int i=0;i<slen;i++)a[i]=P(r[i],i);\n  sort(a,a+slen);\n}\n\nbool bynary_search(){\n  int L=0,R=slen;\n  while(L<R){\n    int M=(L+R)/2;\n    if(strncmp(s+a[M].second,t,tlen)<0)L=M+1;\n    else R=M;\n  }\n  if(!strncmp(s+a[L].second,t,tlen))return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s%d\",s,&n);\n  slen=strlen(s);\n  init();  \n  while(n--){\n    scanf(\"%s\",t);\n    tlen=strlen(t);\n    if(bynary_search())printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef vector<int> V;\n\nconst int inf = 1e7;\n\nint n;\nstring t;\nint q;\nstring p[10000];\nint sa[20][1000000];\nint isa[1000000];\nint lcp[2 << 20];\n\nint stu(int i, int x, int k, int l, int r){\n\tif(r <= i || i < l){\n\t\treturn lcp[k];\n\t}\n\tif(i <= l && r <= i + 1){\n\t\treturn lcp[k] = x;\n\t}\n\tint m = (l + r) / 2;\n\treturn lcp[k] = min(\n\t\tstu(i, x, 2 * k + 1, l, m),\n\t\tstu(i, x, 2 * k + 2, m, r)\n\t);\n}\nvoid stu(int i, int x){\n\tstu(i, x, 0, 0, n - 1);\n}\n\nint rmq(int a, int b, int k, int l, int r){\n\tif(r <= a || b <= l){\n\t\treturn inf;\n\t}\n\tif(a <= l && r <= b){\n\t\treturn lcp[k];\n\t}\n\tint m = (l + r) / 2;\n\treturn min(\n\t\trmq(a, b, 2 * k + 1, l, m),\n\t\trmq(a, b, 2 * k + 2, m ,r)\n\t);\n}\nint rmq(int a, int b){\n\treturn rmq(a, b, 0, 0, n - 1);\n}\n\nV rs(vector<P>& v){\n\tvector<V> a(n + 1, V());\n\trep(i, n){\n\t\ta[v[i].second + 1].push_back(i);\n\t}\n\tvector<V> b(n, V());\n\tfor(V& x: a){\n\t\tfor(int i: x){\n\t\t\tb[v[i].first].push_back(i);\n\t\t}\n\t}\n\tV c(n);\n\tint cnt = 0;\n\tfor(V& x: b){\n\t\trep(i, x.size()){\n\t\t\tc[x[i]] = i == 0 || x[i - 1] < x[i] ? cnt : c[x[i - 1]];\n\t\t\t++cnt;\n\t\t}\n\t}\n\treturn c;\n}\n\nvoid pp(){\n\tstring v = t;\n\tsort(v.begin(), v.end());\n\trep(i, n){\n\t\tsa[0][i] = lower_bound(v.begin(), v.end(), t[i]) - v.begin();\n\t}\n\tfor(int i = 1; i <= 19; ++i){\n\t\tint k = 1 << i - 1;\n\t\tvector<P> s;\n\t\trep(j, n){\n\t\t\ts.push_back(P(sa[i - 1][j], j + k < n ? sa[i - 1][j + k] : -1));\n\t\t}\n\t\tV v = rs(s);\n\t\trep(j, n){\n\t\t\tsa[i][j] = v[j];\n\t\t}\n\t\t/*\n\t\tvector<P> v = s;\n\t\tsort(v.begin(), v.end());\n\t\trep(j, n){\n\t\t\tsa[i][j] = lower_bound(v.begin(), v.end(), s[j]) - v.begin();\n\t\t}\n\t\t*/\n\t}\n\n\trep(i, n){\n\t\tisa[sa[19][i]] = i;\n\t}\n\n\tint l = 0;\n\trep(i, n){\n\t\tint r = sa[19][i];\n\t\tif(r == n - 1){\n\t\t\tl = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tint j = isa[r + 1];\n\t\twhile(i + l < n && j + l < n && t[i + l] == t[j + l]){\n\t\t\t++l;\n\t\t}\n\t\tstu(r, l);\n\t\tl = max(l - 1, 0);\n\t}\n}\n\nbool srch(const string& p){\n\tint m = p.size();\n\n\tint h = 0;\n\twhile(isa[0] + h < n && h < m && t[isa[0] + h] == p[h]){\n\t\t++h;\n\t}\n\n\tint l = 0;\n\tint r = n;\n\tbool b = true;\n\twhile(r - l > 1){\n\t\tint k = (l + r) / 2;\n\t\tif(b){\n\t\t\tint c = rmq(l, k);\n\t\t\tif(c > h){\n\t\t\t\tl = k;\n\t\t\t}\n\t\t\telse if(c < h){\n\t\t\t\tr = k;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(isa[k] + h < n && h < m && t[isa[k] + h] == p[h]){\n\t\t\t\t\t++h;\n\t\t\t\t}\n\t\t\t\tif(isa[k] + h == n){\n\t\t\t\t\tl = k;\n\t\t\t\t}\n\t\t\t\telse if(h == m){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(t[isa[k] + h] < p[h]){\n\t\t\t\t\t\tl = k;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tr = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint c = rmq(k, r);\n\t\t\tif(c > h){\n\t\t\t\tr = k;\n\t\t\t}\n\t\t\telse if(c < h){\n\t\t\t\tl = k;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(isa[k] + h < n && h < m && t[isa[k] + h] == p[h]){\n\t\t\t\t\t++h;\n\t\t\t\t}\n\t\t\t\tif(isa[k] + h == n){\n\t\t\t\t\tl = k;\n\t\t\t\t}\n\t\t\t\telse if(h == m){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(t[isa[k] + h] < p[h]){\n\t\t\t\t\t\tl = k;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tr = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tb = l == k;\n\t}\n\treturn isa[l] + m <= n && string(t, isa[l], m) == p;\n}\n\nint main(){\n\tcin >> t >> q;\n\tn = t.size();\n\trep(i, q){\n\t\tcin >> p[i];\n\t}\n\n\tpp();\n\n\trep(i, q){\n\t\tcout << srch(p[i]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <string>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nunsigned char mask[] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };\n#define tget(i) ( (t[(i)/8]&mask[(i)%8]) ? 1 : 0 )\n#define tset(i, b) t[(i)/8]=(b) ? (mask[(i)%8]|t[(i)/8]) : ((~mask[(i)%8])&t[(i)/8])\n#define chr(i) (cs==sizeof(int)?((int*)s)[i]:((unsigned char *)s)[i])\n#define isLMS(i) (i>0 && tget(i) && !tget(i-1))\n\n// find the start or end of each bucket\nvoid getBuckets(unsigned char *s, int *bkt, int n, int K, int cs, bool end) {\n    int i, sum = 0;\n    for (i = 0; i <= K; i++)\n        bkt[i] = 0; // clear all buckets\n    for (i = 0; i < n; i++)\n        bkt[chr(i)]++; // compute the size of each bucket\n    for (i = 0; i <= K; i++) {\n        sum += bkt[i];\n        bkt[i] = end ? sum : sum - bkt[i];\n    }\n}\n// compute SAl\nvoid induceSAl(unsigned char *t, int *SA, unsigned char *s, int *bkt, int n, int K, int cs, bool end) {\n    int i, j;\n    getBuckets(s, bkt, n, K, cs, end); // find starts of buckets\n    for (i = 0; i < n; i++) {\n        j = SA[i] - 1;\n        if (j >= 0 && !tget(j))\n            SA[bkt[chr(j)]++] = j;\n    }\n}\n// compute SAs\nvoid induceSAs(unsigned char *t, int *SA, unsigned char *s, int *bkt, int n, int K, int cs, bool end) {\n    int i, j;\n    getBuckets(s, bkt, n, K, cs, end); // find ends of buckets\n    for (i = n - 1; i >= 0; i--) {\n        j = SA[i] - 1;\n        if (j >= 0 && tget(j))\n            SA[--bkt[chr(j)]] = j;\n    }\n}\n\n// find the suffix array SA of s[0..n-1] in {1..K}^n\n// require s[n-1]=0 (the sentinel!), n>=2\n// use a working space (excluding s and SA) of at most 2.25n+O(1) for a constant alphabet\nvoid SA_IS(unsigned char *s, int *SA, int n, int K, int cs) {\n    int i, j;\n    unsigned char *t = (unsigned char *) malloc(n / 8 + 1); // LS-type array in bits\n    // Classify the type of each character\n    tset(n-2, 0);\n    tset(n-1, 1); // the sentinel must be in s1, important!!!\n    for (i = n - 3; i >= 0; i--)\n        tset(i, (chr(i)<chr(i+1) || (chr(i)==chr(i+1) && tget(i+1)==1))?1:0);\n    // stage 1: reduce the problem by at least 1/2\n    // sort all the S-substrings\n    int *bkt = (int *) malloc(sizeof(int) * (K + 1)); // bucket array\n    getBuckets(s, bkt, n, K, cs, true); // find ends of buckets\n    for (i = 0; i < n; i++)\n        SA[i] = -1;\n    for (i = 1; i < n; i++)\n        if (isLMS(i))\n            SA[--bkt[chr(i)]] = i;\n    induceSAl(t, SA, s, bkt, n, K, cs, false);\n    induceSAs(t, SA, s, bkt, n, K, cs, true);\n    free(bkt);\n    // compact all the sorted substrings into the first n1 items of SA\n    // 2*n1 must be not larger than n (proveable)\n    int n1 = 0;\n    for (i = 0; i < n; i++)\n        if (isLMS(SA[i]))\n            SA[n1++] = SA[i];\n    // find the lexicographic names of all substrings\n    for (i = n1; i < n; i++)\n        SA[i] = -1; // init the name array buffer\n    int name = 0, prev = -1;\n    for (i = 0; i < n1; i++) {\n        int pos = SA[i];\n        bool diff = false;\n        for (int d = 0; d < n; d++)\n            if (prev == -1 || chr(pos+d) != chr(prev+d) || tget(pos+d) != tget(prev+d)) {\n                diff = true;\n                break;\n            } else if (d > 0 && (isLMS(pos+d) || isLMS(prev+d)))\n                break;\n        if (diff) {\n            name++;\n            prev = pos;\n        }\n        pos = (pos % 2 == 0) ? pos / 2 : (pos - 1) / 2;\n        SA[n1 + pos] = name - 1;\n    }\n    for (i = n - 1, j = n - 1; i >= n1; i--)\n        if (SA[i] >= 0)\n            SA[j--] = SA[i];\n    // stage 2: solve the reduced problem\n    // recurse if names are not yet unique\n    int *SA1 = SA, *s1 = SA + n - n1;\n    if (name < n1)\n        SA_IS((unsigned char*) s1, SA1, n1, name - 1, sizeof(int));\n    else\n        // generate the suffix array of s1 directly\n        for (i = 0; i < n1; i++)\n            SA1[s1[i]] = i;\n    // stage 3: induce the result for the original problem\n    bkt = (int *) malloc(sizeof(int) * (K + 1)); // bucket array\n    // put all left-most S characters into their buckets\n    getBuckets(s, bkt, n, K, cs, true); // find ends of buckets\n    for (i = 1, j = 0; i < n; i++)\n        if (isLMS(i))\n            s1[j++] = i; // get p1\n    for (i = 0; i < n1; i++)\n        SA1[i] = s1[SA1[i]]; // get index in s\n    for (i = n1; i < n; i++)\n        SA[i] = -1; // init SA[n1..n-1]\n    for (i = n1 - 1; i >= 0; i--) {\n        j = SA[i];\n        SA[i] = -1;\n        SA[--bkt[chr(j)]] = j;\n    }\n    induceSAl(t, SA, s, bkt, n, K, cs, false);\n    induceSAs(t, SA, s, bkt, n, K, cs, true);\n    free(bkt);\n    free(t);\n}\n\nconst int maxn = 600000;\nint sa[maxn];\nint lcp[maxn];\nint pos[maxn];\nunsigned char *s;\nint n;\n\nvoid calc_lcp() {\n    for (int i = 0; i < n+1; i++)\n        pos[sa[i]] = i;\n    for (int i = 0, h = 0; i < n+1; i++) {\n        if (pos[i] < n ) {\n            for (int j = sa[pos[i] + 1]; s[i + h] == s[j + h]; ++h)\n                ;\n            lcp[pos[i]] = h;\n            if (h > 0)\n                --h;\n        }\n    }\n}\n/*\n str=\"abcab\" n=5\n SA_IS(str,sa,n+1,256,1)\n calc_lcp()\n sa={5,3,0,4,1,2}\n str.subtring(sa)={\"\",\"ab\",\"abcab\",\"b\",\"bcab\",\"cab\"}\n lcp={0,2,0,1,0,0}\n pos={2,4,5,1,3,0}\n*/\n\npair<int,int> longest_repeated_substring(int overlap){\n    //overlap=1 non-overlapping , overlap=0 overlap allowed\n    int maxl=0,maxidx=-1;\n    for(int i=1;i<n+1;i++){\n        if(lcp[i]>maxl) {\n            if(overlap && abs(sa[i]-sa[i-1])<lcp[i]) continue;\n            maxl=lcp[i];\n            maxidx=sa[i];\n        }\n    }\n    if(maxidx==-1) return make_pair(-1,-1);\n    return make_pair(maxidx,maxl);\n}\npair<pair<int,int>,int> longest_k_repeated_substring(string str,int k){\n    k--;\n    for (int i = 0; i < n+1; i++)\n        pos[sa[i]] = i;\n    int maxl=0,maxidx=-1,rightmostidx=0;\n    for (int i = 0, h = 0; i < n+1; i++) {\n        if (pos[i] < n +1-k) {\n            for (int j = sa[pos[i] + k]; s[i + h] == s[j + h]; ++h)\n                ;\n            if(h>=maxl){\n                if(h>maxl) rightmostidx=sa[pos[i] + k];\n                maxl=h;\n                maxidx=i;\n                if(rightmostidx<sa[pos[i] + k]) rightmostidx=sa[pos[i] + k];\n            }\n            //cout<<i<<\" \"<<h<<\" \"<<str.substr(i,h)<<maxl<<\" \"<<str.substr(maxidx,maxl)<<\" \"<<rightmostidx<<endl;\n\n            if (h > 0)\n                --h;\n        }\n    }\n    if(maxidx==-1) return make_pair(make_pair(-1,-1),-1);\n    return make_pair(make_pair(rightmostidx,maxidx),maxl);\n}\npair<pair<int,int>,pair<int,int> > longest_common_substring(string str1,string str2){\n    string str=str1+\" \"+str2;\n    s = (unsigned char*) str.c_str();\n    n = (int)str.size();\n    SA_IS(s, sa, n + 1, 256, 1);\n    calc_lcp();\n    pair<int,int> p=longest_repeated_substring(0);\n    int indx2=sa[pos[p.first]+1];\n    //cout<<str.substr(p.first,p.second)<<\" \"<<str.substr(indx2,p.second)<<endl;\n    if((p.first<str1.length()&&indx2<str1.length())||(p.first>str1.length()&&indx2>str1.length()) || str.substr(p.first,p.second)!=str.substr(indx2,p.second)) {\n                return make_pair(make_pair(0,0),p);\n    }\n    return make_pair(p,make_pair(indx2,p.second));\n}\n\npair<int,int> smallest_lex_rotation(string str){\n    \n    str=str+str;\n    s = (unsigned char*) str.c_str();\n    \n    n = (int)str.size();\n    SA_IS(s, sa, n + 1, 256, 1);\n    for(int i=1;i<n+1;i++){\n        //cout<<str.substr(sa[i])<<\" \"<<sa[i]<<\"\\n\";\n    }\n    \n    int minval=maxn;\n    for(int i=0;i<n+1;i++){\n        if(sa[i]<=n/2){\n            while(i<n && sa[i]<=n/2 && str.substr(sa[i],n/2)==str.substr(sa[i+1],n/2)){\n                if(minval>sa[i]) minval=sa[i];\n                //printf(\"i %d\\n\",i);\n                i++;\n            }\n            return make_pair(sa[i],n/2);\n        }\n    }\n    \n    return make_pair(-1,n/2);\n}\n\nlong count_distinct_substrings(string str){\n    s = (unsigned char*) str.c_str();\n    n = (int)str.size();\n    SA_IS(s, sa, n + 1, 256, 1);\n    calc_lcp();\n    long count=0;\n    for(int i=1;i<n+1;i++) count+=n-sa[i]-lcp[i];\n    return count;\n}\n\npair<int,int> longest_palindromic_substring(string str){\n    string revstr=string(str.rbegin(),str.rend());\n    return longest_common_substring(str, revstr).first;\n}\n\nbool contain(string str, int *sa, string T){\n    int a = 0, b = str.length();\n    while( b - a > 1 ){\n        int c = (a + b ) / 2;\n        if ( str.compare(sa[c], T.length(), T) < 0 ) a = c;\n        else b = c;\n    }\n    return str.compare(sa[b], T.length(), T) == 0;\n}\n\n\nint main() {\n    string str;\n    cin>>str;\n    s = (unsigned char*) str.c_str();\n    n = (int)str.size();\n    SA_IS(s, sa, n + 1, 256, 1);\n    int t;\n    cin>>t;\n    while(t--){\n    \tstring pat;\n    \tcin>>pat;\n    \tcout<<contain(str,sa,pat)<<\"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#pragma GCC target(\"avx2\")\n\ntemplate<class T>\nconst std::vector<int>& sa_is(std::vector<T> s, int k) {\n  int N = s.size();\n  static std::vector<int> sa;\n  static std::vector<int> cnt;\n  sa.resize(N + 1);\n\n  if(N == 0) return sa;\n\n  for(auto& c: s) c++;\n  s.push_back(0);\n  k++;\n\n  std::vector<bool> iss(N + 1);\n  std::vector<int> lms;\n  std::vector<int> is_lms(N + 1, -1);\n  std::vector<int> bin(k + 1);\n\n  iss[N] = true;\n  bin[1]++;\n  for(int i = N; i --> 0; ) {\n    if(s[i] == s[i + 1])\n      iss[i] = iss[i + 1];\n    else\n      iss[i] = s[i] < s[i + 1];\n    if(!iss[i] && iss[i + 1]) {\n      is_lms[i + 1] = lms.size();\n      lms.push_back(i + 1);\n    }\n    bin[s[i] + 1]++;\n  }\n\n  for(int i = 1;i <= k;i++)\n    bin[i] += bin[i - 1];\n\n  auto induce = [&](const std::vector<int>& lms) {\n    sa.assign(N + 1, -1);\n    cnt.assign(k, 0);\n\n    for(int i = 0;i < lms.size();i++) {\n      int x = lms[i];\n      sa[bin[s[x] + 1] - 1 - cnt[s[x]]] = x;\n      cnt[s[x]]++;\n    }\n\n    cnt.assign(k, 0);\n    for(int i = 0;i <= N;i++) {\n      int x = sa[i] - 1;\n      if(x >= 0 && !iss[x]) {\n        sa[bin[s[x]] + cnt[s[x]]] = x;\n        cnt[s[x]]++;\n      }\n    }\n\n    cnt.assign(k, 0);\n    for(int i = N + 1;i --> 0;) {\n      int x = sa[i] - 1;\n      if(x >= 0 && iss[x]) {\n        sa[bin[s[x] + 1] - 1 - cnt[s[x]]] = x;\n        cnt[s[x]]++;\n      }\n    }\n  };\n\n  induce(lms);\n\n\n  if(lms.size() >= 2) {\n    int M = lms.size();\n    int li = 0;\n    std::vector<int> rec_lms(M);\n    for(auto x: sa) {\n      if(is_lms[x] != -1) rec_lms[li++] = x;\n    }\n    int rec_n = 1;\n    std::vector<int> rec_s(M);\n    rec_s[M - 1 - is_lms[rec_lms[1]]] = 1;\n    for(int i = 2;i < M;i++) {\n      int xl = rec_lms[i];\n      int yl = rec_lms[i - 1];\n      int xr = lms[is_lms[xl] - 1];\n      int yr = lms[is_lms[yl] - 1];\n      if(xr - xl != yr - yl)\n        rec_n++;\n      else {\n        while(xl <= xr) {\n          if(s[xl] != s[yl]) {\n            rec_n++;\n            break;\n          }\n          xl++;\n          yl++;\n        }\n      }\n      rec_s[M - 1 - is_lms[rec_lms[i]]] = rec_n;\n    }\n\n\n    sa_is(std::move(rec_s), rec_n + 1);\n    li = M;\n    for(int i = 1;i < M + 1;i++) {\n      rec_lms[--li] = lms[M - 1 - sa[i]];\n    }\n    induce(rec_lms);\n  }\n\n  return sa;\n}\n\n#include <cstdint>\n#include <set>\n#include <vector>\n#include <iostream>\n\nusing i64 = long long;\n\nclass bitvector {\n  using bit_type = std::uint_least64_t;\n  using size_type = std::size_t;\n  static constexpr size_type wordsize = 64;\n  \n  std::vector<bit_type> bit;\n  std::vector<size_type> sum;\n  \npublic:\n\n  bitvector() : bit(), sum() {} \n  bitvector(const size_type size)\n    : bit(size / wordsize + 1, 0), sum(size / wordsize + 1, 0) {}\n\n  void set(const size_type i) {\n    bit[i / wordsize] |= static_cast<bit_type>(1) << (i % wordsize);\n  }\n  void build() {\n    for (size_type i = 1; i < bit.size(); i++) {\n      sum[i] = sum[i - 1] + __builtin_popcountll(bit[i - 1]);\n    }\n  }\n\n  size_type at(const size_type i) const {\n    return bit[i / wordsize] >> (i % wordsize);\n  }\n\n  // count of ones in [0, i)\n  size_type rank(const size_type i) const {\n    return sum[i / wordsize]\n      + __builtin_popcountll(bit[i / wordsize] & (static_cast<bit_type>(1) << (i % wordsize)) - 1);\n  }\n\n  // count of ones in [0, i)\n  size_type rank(const size_type i, const size_type b) const {\n    size_type ans = sum[i / wordsize]\n      + __builtin_popcountll(bit[i / wordsize] & (static_cast<bit_type>(1) << (i % wordsize)) - 1);\n    if(b) return ans;\n    else return i - ans;\n  }\n};\n\ntemplate<class T>\nclass wavelet_matrix {\n  using Integer = T;\n  using integer_type = Integer;\n  using size_type = std::size_t;\n\n\n  size_type depth;\n  size_type len;\n  std::vector<bitvector> mat;\n  std::vector<size_type> spl;\n\npublic:\n\n  wavelet_matrix(): depth(0), len(0) {}\n  wavelet_matrix(std::vector<integer_type> arr, size_type de)\n    : depth(de),\n      len(arr.size()),\n      mat(std::vector<bitvector>(depth, bitvector(arr.size()))),\n      spl(std::vector<size_type>(depth, 0)) {\n        std::vector<T> arr2(len);\n        int l1 = len;\n        int l2 = 0;\n        std::vector<T> left(len), right(len);\n        for(size_type d = depth; d-- > 0;) {\n          size_type l = 0, r = 0;\n          \n          for(size_type i = 0; i < l1; i++) {\n            size_type k = (arr[i] >> d) & 1;\n            if(k) right[r++] = arr[i], mat[d].set(i);\n            else left[l++] = arr[i];\n          }\n          for(size_type i = 0; i < l2; i++) {\n            size_type k = (arr2[i] >> d) & 1;\n            if(k) right[r++] = arr2[i], mat[d].set(i+l1);\n            else left[l++] = arr2[i];\n          }\n          mat[d].build();\n          spl[d] = l;\n          swap(arr, left);\n          swap(arr2, right);\n          l1 = l;\n          l2 = r;\n        }\n      }\n\n  integer_type at(size_type i) const {\n    integer_type x = static_cast<integer_type>(0);\n    for(size_type d = depth; d-- > 0;) {\n      size_type k = mat[d].at(i);\n      x |= (static_cast<integer_type>(k) << d);\n      i = mat[d].rank(i, k) + spl[d] * k;\n    }\n    return x;\n  }\n\n  // counting elements that equal to x in range [left, right)\n  size_type rank_x(size_type left, size_type right, integer_type x) const {\n    for(size_type d = depth; d-- > 0;) {\n      size_type k = ((x >> d) & 1);\n      if(k) {\n        left = mat[d].rank(left, k) + spl[d];\n        right = mat[d].rank(right, k) + spl[d];\n      }\n      else {\n        left = mat[d].rank(left, k);\n        right = mat[d].rank(right, k);\n      }\n    }\n    return right - left;\n  }\n\n  // sorted(arr[left..right])[i]\n  integer_type quantile(size_type left, size_type right, size_type i) const {\n    integer_type x = static_cast<integer_type>(0);\n    for(size_type d = depth; d-- > 0;) {\n      size_type cnt = mat[d].rank(right, 0) - mat[d].rank(left, 0);\n      size_type k = (i < cnt) ? 0 : 1;\n      x |= (k << d);\n      left = mat[d].rank(left, k) + spl[d] * k;\n      right = mat[d].rank(right, k) + spl[d] * k;\n    }\n    return x;\n  }\n\n  struct rank_result {\n    size_type le;\n    size_type eq;\n    size_type mo;\n  };\n\n  // couting elements that less than x, equal to x, and more than x in range [left, right)\n  rank_result rank_less_eq_more(size_type left, size_type right, integer_type x) const {\n    size_type le = 0, mo = 0;\n    for(size_type d = depth; d --> 0;) {\n      size_type k = (x >> d) & 1;\n      size_type l = mat[d].rank(left, 1);\n      size_type r = mat[d].rank(right, 1);\n      if(k == 0) {\n        mo += r - l;\n        left -= l;\n        right -= r;\n      }\n      else {\n        le += (right - left) - (r - l);\n        left = l + spl[d];\n        right = r + spl[d];\n      }\n    }\n    return rank_result { le, right - left, mo };\n  }\n\n  size_type rangefreq(size_type left, size_type right, integer_type x, integer_type y, integer_type l, size_type d) const {\n    integer_type r = l + (1 << d);\n    if(x <= l && r <= y) {\n      return right - left;\n    }\n    else if(y <= l || r <= x) {\n      return 0;\n    }\n    else {\n      d--;\n      size_type lr = mat[d].rank(left, 1);\n      size_type rr = mat[d].rank(right, 1);\n      return\n        rangefreq(left - lr, right - rr, x, y, l, d) +\n        rangefreq(lr + spl[d], rr + spl[d], x, y, l + (1 << d), d);\n    }\n  }\n\n  size_type rangefreq(size_type left, size_type right, integer_type x, integer_type y) const {\n    return rangefreq(left, right, x, y, 0, depth);\n  }\n};\n\ntemplate<class T>\nstruct burrows_wheeler {\n  std::vector<int> sa;\n  std::vector<T> L;\n  std::vector<int> C;\n  wavelet_matrix<T> wm;\n  burrows_wheeler(const std::vector<T>& s, int k, int de): sa(sa_is(s, k)), L(s.size() + 1), C(k + 1) {\n    for(int i = 0;i < sa.size();i++) {\n      if(sa[i] > 0) L[i] = s[sa[i] - 1];\n      else L[i] = 0;\n    }\n    for(int i = 0;i < s.size();i++) {\n      C[s[i] + 1]++;\n    }\n    C[0]++;\n    for(int i = 0; i < k; i++) {\n      C[i + 1] += C[i];\n    }\n    wm = wavelet_matrix<T>(L, de);\n  }\n  int match(const std::string& p) {\n    int s = 0;\n    int e = sa.size();\n    for(int i = p.size();i --> 0;) {\n    int a = p[i];\n    if(a >= 97) a -= 6;\n    if(a >= 65) a -= 7;\n    a -= 47;\n      s = wm.rank_x(0, s, a) + C[a];\n      e = wm.rank_x(0, e, a) + C[a];\n      if(s >= e) break;\n    }\n    return e - s;\n  }\n};\n\n\n#include <iostream>\n#include <string>\n\nstatic struct IO {\n\tchar tmp[1 << 10];\n\n\t// fast input routines\n\tchar cur;\n\n//#define nextChar() (cur = getc_unlocked(stdin))\n//#define peekChar() (cur)\n\tinline char nextChar() { return cur = getc_unlocked(stdin); }\n\tinline char peekChar() { return cur; }\n\n\tinline operator bool() { return peekChar(); }\n\tinline static bool isBlank(char c) { return (c < '-' && c); }\n\tinline bool skipBlanks() { while (isBlank(nextChar())); return peekChar() != 0; }\n\n\tinline IO& operator >> (char & c) { c = nextChar(); return *this; }\n\n\tinline IO& operator >> (char * buf) {\n\t\tif (skipBlanks()) {\n\t\t\tif (peekChar()) {\n\t\t\t\t*(buf++) = peekChar();\n\t\t\t\twhile (!isBlank(nextChar())) *(buf++) = peekChar();\n\t\t\t} *(buf++) = 0; } return *this; }\n\n\tinline IO& operator >> (std::string & s) {\n\t\tif (skipBlanks()) {\ts.clear(); s += peekChar();\n\t\t\twhile (!isBlank(nextChar())) s += peekChar(); }\n\t\treturn *this; }\n\n\tinline IO& operator >> (double & d) { if ((*this) >> tmp) sscanf(tmp, \"%lf\", &d); return *this;\t}\n\n#define defineInFor(intType) \\\n\tinline IO& operator >>(intType & n) { \\\n\t\tif (skipBlanks()) { \\\n\t\t\tint sign = +1; \\\n\t\t\tif (peekChar() == '-') { \\\n\t\t\t\tsign = -1; \\\n\t\t\t\tn = nextChar() - '0'; \\\n\t\t\t} else \\\n\t\t\t\tn = peekChar() - '0'; \\\n\t\t\twhile (!isBlank(nextChar())) { \\\n\t\t\t\tn += n + (n << 3) + peekChar() - 48; \\\n\t\t\t} \\\n\t\t\tn *= sign; \\\n\t\t} \\\n\t\treturn *this; \\\n\t}\n\ndefineInFor(int)\ndefineInFor(unsigned int)\ndefineInFor(long long)\n\n\t// fast output routines\n\n//#define putChar(c) putc_unlocked((c), stdout)\n\tinline void putChar(char c) { putc_unlocked(c, stdout); }\n\tinline IO& operator << (char c) { putChar(c); return *this; }\n\tinline IO& operator << (const char * s) { while (*s) putChar(*s++); return *this; }\n\n\tinline IO& operator << (const std::string & s) { for (int i = 0; i < (int)s.size(); ++i) putChar(s[i]); return *this; }\n\n\tchar * toString(double d) { sprintf(tmp, \"%lf%c\", d, '\\0'); return tmp; }\n\tinline IO& operator << (double d) { return (*this) << toString(d); }\n\n\n#define defineOutFor(intType) \\\n\tinline char * toString(intType n) { \\\n\t\tchar * p = (tmp + 30); \\\n\t\tif (n) { \\\n\t\t\tbool isNeg = 0; \\\n\t\t\tif (n < 0) isNeg = 1, n = -n; \\\n\t\t\twhile (n) \\\n\t\t\t\t*--p = (n % 10) + '0', n /= 10; \\\n\t\t\tif (isNeg) *--p = '-'; \\\n\t\t} else *--p = '0'; \\\n\t\treturn p; \\\n\t} \\\n\tinline IO& operator << (intType n) { return (*this) << toString(n); }\n\ndefineOutFor(int)\ndefineOutFor(long long)\n\n#define endl ('\\n')\n#define cout __io__\n#define cin __io__\n} __io__;\n\nint main() {\n  std::string s;\n  cin >> s;\n  std::vector<int> ss(s.size());\n  for(int i = 0;i < s.size();i++) {\n    int a = s[i];\n    if(a >= 97) a -= 6;\n    if(a >= 65) a -= 7;\n    a -= 47;\n    ss[i] = a;\n  }\n  burrows_wheeler<int> bw(ss, 64, 6);\n  std::string t;\n\n  int Q;\n  cin >> Q;\n  for(int i = 0;i < Q;i++) {\n    cin >> t;\n    i64 tmp = bw.match(t);\n    if(tmp > 0)  {\n      cout << 1 << \"\\n\";\n    }\n    else {\n      cout << 0 << \"\\n\";\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstring> //memcpy\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <map>\n//#include <unordered_map> //hash func.\n#include <fstream> //ifstream, ofstream\n\n//#define NDEBUG //If NDEBUG is defined before #include <cassert>, assert will be ignored. You had better define NDEBUG when u submit the code.\n#include <cassert> //assert\n\nusing namespace std;\n\n\n#define dout cout\n//If u wanna output to a text file instead of standard output, plz define OUTPUTFILE.\n//#define OUTPUTFILE \"output.txt\" //*******************************************************************************************************************************************\n#ifdef OUTPUTFILE\n#define dout outputfile\nofstream outputfile(OUTPUTFILE);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n\n#define din cin\n//If u wanna input from a text file instead of standard input, plz define INPUTFROMTEXTFILE???.\n//#define INPUTFILE \"input.txt\" //*******************************************************************************************************************************************\n#ifdef INPUTFILE\n#define din inputfile\nifstream inputfile(INPUTFILE);\n#endif\n\n#define scan(A) scanf(\"%d\", &(A))\n#define disp(A) dout << #A << \" = \" << setw(3) << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \"\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n//#define dispAll(A,n) cout << #A << \" = \"; rep(j, 0, (n)) {cout << setw(3) << A[j] << \" \";} cout << endl\n\n#define sign(x) ((x)>0)-((x)<0) //x<0: -1, x=0: 0, x>0: +1\n#define p(i) (i)/2\n#define l(i) (i)*2\n#define r(i) (i)*2+1\n\nint dx[] = {1,-1, 0, 0, 1, 1,-1,-1}; //???????????????????????????????¨??????????????????????????????????\nint dy[] = {0, 0,-1, 1,-1, 1, 1,-1};\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef unsigned long ull;\n\nconst int INF = (int)2e9+10;\nconst ll INF_LL = (ll)9e18-1LL; //Be careful for overflow.\nconst ull INF_ULL = (ull)1e19-1ULL;\nconst int NONE = -1;\nconst ll MOD = (ll)1e9+7; //??§???????´???°?????£??¨??¨????????°????????????10???7??????\n\nconst int N_MAX = 1000010; //num of vertex or element\nconst int M_MAX = 100000; //num of edge\nconst int DATA_MAX = 1000000010;\n\nint N;\n\nchar T[N_MAX];\n\nconst int P_LEN_MAX = 1010;\nchar P[10010][P_LEN_MAX];\n\nint hashTable_T[P_LEN_MAX][N_MAX]; //????????????lenP????????????T??????????????\\???\n\n\nint main() {\n    \n    //cin, cout????????????  ?????¨??????cin?????????????????¨??¨cin??§???scanf?????????????????¨??¨scanf??§??±?????????????????????\n    cin.tie(0); //cin??¨cout??????????????????\n    ios::sync_with_stdio(false); //iostream??¨stdio??????????????????\n    \n    //read input data\n    int i = 0;\n    while(1) {\n        scanf(\"%c\", &T[i]);\n        if(T[i]=='\\n') { T[i] = '\\0'; break; }\n        else i++;\n    }\n    \n    int Q;\n    scanf(\"%d \", &Q);\n    rep(i,0,Q) {\n        int j = 0;\n        while(1) {\n            scanf(\"%c\", &P[i][j]);\n            if(P[i][j]=='\\n') { P[i][j] = '\\0'; break; }\n            else j++;\n        }\n    }\n    \n#ifdef debug\n    disp(T);\n    disp(strlen(T));\n    rep(i,0,Q) { disp(P[i]); disp(strlen(P[i])); }\n#endif\n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //start timer\n    auto startTime = chrono::system_clock::now();\n#endif\n    //------------------------------------------------------------------------------------------\n    \n    \n    \n    //find P[i] among T by Rabin-Karp Algorithm (using Rolling Hash)\n    \n    int lenT = strlen(T);\n    const int B = 10007;\n    \n    //calc. hashTable_T[][]\n    rep(lenP,1,P_LEN_MAX+1) {\n        \n        int BpowLenP = 1;\n        rep(k,0,lenP) BpowLenP *= B;\n        \n        hashTable_T[lenP][0] = 0;\n        rep(k,0,lenP) hashTable_T[lenP][0] = hashTable_T[lenP][0] * B + T[k];\n        \n        rep(j,1,lenT-lenP+1) {\n            hashTable_T[lenP][j] = hashTable_T[lenP][j-1] * B - T[j-1] * BpowLenP + T[j-1+lenP];\n        }\n    }\n    \n    \n    rep(i,0,Q) {\n        int lenP = strlen(P[i]);\n        \n        int hashP = 0;\n        rep(k,0,lenP) hashP = hashP * B + P[i][k];\n        \n        \n        bool found = false;\n        rep(j,0,lenT-lenP+1) {\n            if(hashP == hashTable_T[lenP][j]) {\n                found = true;\n                break;\n            }\n        }\n        \n        printf(\"%d\\n\", found);\n        \n    }\n\n    \n    \n    \n    \n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //stop timer\n    auto endTime = chrono::system_clock::now();\n    auto dur = endTime - startTime;\n    auto msec = chrono::duration_cast<chrono::milliseconds>(dur).count();\n    dout << fixed << setprecision(4) << (double)msec/1000 << \" sec \\n\";\n#endif\n    //------------------------------------------------------------------------------------------\n    \n#ifdef INPUTFILE\n    inputfile.close();\n#endif\n    \n#ifdef OUTPUTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring S,T;\nstring V[1000][100];\nint main(){\n\tint q,a,b,c;\n\tcin>>S;\n\tb=S.size();\n\ta=min(b,100);\n\tfor(int i=1;i<100;i++){\n\t\tfor(int j=0;j<=b-i;j++){\n\t\t\tV[j][i]=S.substr(j,i);\n\t\t}\n\t}\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>T;\n\t\tc=T.size();\n\t\tfor(int j=0;j<=b-c;j++){\n\t\t\tif(V[j][c]==T){\n\t\t\t\tcout<<\"1\"<<endl;\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t}\n\t\tcout<<\"0\"<<endl;\n\t\tExit:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstring> //memcpy\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <map>\n//#include <unordered_map> //hash func.\n#include <fstream> //ifstream, ofstream\n\n//#define NDEBUG //If NDEBUG is defined before #include <cassert>, assert will be ignored. You had better define NDEBUG when u submit the code.\n#include <cassert> //assert\n\nusing namespace std;\n\n\n#define dout cout\n//If u wanna output to a text file instead of standard output, plz define OUTPUTFILE.\n//#define OUTPUTFILE \"output.txt\" //*******************************************************************************************************************************************\n#ifdef OUTPUTFILE\n#define dout outputfile\nofstream outputfile(OUTPUTFILE);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n\n#define din cin\n//If u wanna input from a text file instead of standard input, plz define INPUTFROMTEXTFILE???.\n//#define INPUTFILE \"input.txt\" //*******************************************************************************************************************************************\n#ifdef INPUTFILE\n#define din inputfile\nifstream inputfile(INPUTFILE);\n#endif\n\n#define scan(A) scanf(\"%d\", &(A))\n#define disp(A) dout << #A << \" = \" << setw(3) << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \"\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n//#define dispAll(A,n) cout << #A << \" = \"; rep(j, 0, (n)) {cout << setw(3) << A[j] << \" \";} cout << endl\n\n#define sign(x) ((x)>0)-((x)<0) //x<0: -1, x=0: 0, x>0: +1\n#define p(i) (i)/2\n#define l(i) (i)*2\n#define r(i) (i)*2+1\n\nint dx[] = {1,-1, 0, 0, 1, 1,-1,-1}; //???????????????????????????????¨??????????????????????????????????\nint dy[] = {0, 0,-1, 1,-1, 1, 1,-1};\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef unsigned long ull;\n\nconst int INF = (int)2e9+10;\nconst ll INF_LL = (ll)9e18-1LL; //Be careful for overflow.\nconst ull INF_ULL = (ull)1e19-1ULL;\nconst int NONE = -1;\nconst ll MOD = (ll)1e9+7; //??§???????´???°?????£??¨??¨????????°????????????10???7??????\n\nconst int N_MAX = 1000000; //num of vertex or element\nconst int M_MAX = 100000; //num of edge\nconst int DATA_MAX = 1000000010;\n\nint N;\n\nchar T[N_MAX];\nchar P[10010][1010];\n\nint main() {\n    \n    //cin, cout????????????  ?????¨??????cin?????????????????¨??¨cin??§???scanf?????????????????¨??¨scanf??§??±?????????????????????\n    cin.tie(0); //cin??¨cout??????????????????\n    ios::sync_with_stdio(false); //iostream??¨stdio??????????????????\n    \n    //read input data\n    int i = 0;\n    while(1) {\n        scanf(\"%c\", &T[i]);\n        if(T[i]=='\\n') { T[i] = '\\0'; break; }\n        else i++;\n    }\n    \n    int Q;\n    scanf(\"%d \", &Q);\n    rep(i,0,Q) {\n        int j = 0;\n        while(1) {\n            scanf(\"%c\", &P[i][j]);\n            if(P[i][j]=='\\n') { P[i][j] = '\\0'; break; }\n            else j++;\n        }\n    }\n    \n#ifdef debug\n    disp(T);\n    disp(strlen(T));\n    rep(i,0,Q) { disp(P[i]); disp(strlen(P[i])); }\n#endif\n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //start timer\n    auto startTime = chrono::system_clock::now();\n#endif\n    //------------------------------------------------------------------------------------------\n    \n    \n    \n    //find P[i] among T by Rabin-Karp Algorithm (using Rolling Hash)\n    int lenT = strlen(T);\n    const int B = 10007;\n    rep(i,0,Q) {\n        int lenP = strlen(P[i]);\n        \n        int BpowLenP = 1;\n        rep(k,0,lenP) BpowLenP *= B;\n        \n        int hashP = 0;\n        rep(k,0,lenP) hashP = hashP * B + P[i][k];\n        \n        int hashT = 0;\n        rep(k,0,lenP) hashT = hashT * B + T[k];\n        \n        bool found = false;\n        rep(j,0,lenT-lenP+1) {\n            if(hashP == hashT) {\n                found = true;\n                break;\n            }\n            \n            if(j+lenP<lenT) hashT = hashT * B - T[j]*BpowLenP + T[j+lenP];\n        }\n        \n        printf(\"%d\\n\", found);\n        \n    }\n\n    \n    \n    \n    \n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //stop timer\n    auto endTime = chrono::system_clock::now();\n    auto dur = endTime - startTime;\n    auto msec = chrono::duration_cast<chrono::milliseconds>(dur).count();\n    dout << fixed << setprecision(4) << (double)msec/1000 << \" sec \\n\";\n#endif\n    //------------------------------------------------------------------------------------------\n    \n#ifdef INPUTFILE\n    inputfile.close();\n#endif\n    \n#ifdef OUTPUTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<complex>\n#include<typeinfo>\nusing namespace std;\n\nstruct Node{\n    Node* child[256];\n    vector<int> output;\n    Node(){\n        memset(child, 0, sizeof(child));\n    }\n};\n\nvoid concatIntVector(vector<int> &v1, vector<int> &v2){\n    v1.insert(v1.begin(), v2.begin(), v2.end());\n}\n\nNode* makePMA(vector<string> &P){\n    Node* root = new Node;\n    root->child[0] = 0;\n    Node* now;\n    for (int i=0;i<P.size();i++){\n        now = root;\n        for (int j=0;j<P[i].size();j++){\n            if(now->child[(int)P[i][j]] == 0){\n                now->child[(int)P[i][j]] = new Node;\n            }\n            now = now->child[(int)P[i][j]];\n        }\n        now->output.push_back(i);\n    }\n\n    queue<Node*> qu;\n    for(int i=1;i<256;i++){\n        if(root->child[i]){\n            root->child[i]->child[0] = root;\n            qu.push(root->child[i]);\n        }else{\n            root->child[i] = root;\n        }\n    }\n    while(!qu.empty()){\n        now = qu.front();qu.pop();\n        for(int i=1;i<256;i++){\n            if(now->child[i]){\n                Node* fail = now->child[0];\n                while(!fail->child[i]){\n                    fail = fail->child[0];\n                }\n                now->child[i]->child[0] = fail->child[i];\n                concatIntVector(now->child[i]->output, fail->child[i]->output);\n            }\n        }\n    }\n    return root;\n}\n\n\nvoid searchPMA(Node* &root, string &T, vector<bool> &res){\n    Node* now = root;\n    for (int i=0;i<T.size();i++){\n        while(!now->child[(int)T[i]]){\n            now = now->child[0];\n        }\n        now = now->child[(int)T[i]];\n        for (int j=0;j<(now->output).size();j++){\n            res[(now->output)[j]] = true;\n        }\n    }\n    return;\n}\n\nint main(){\n    string T;\n    cin >> T;\n    int Q;\n    cin >> Q;\n    vector<string> P;\n    string tmp;\n    for (int i=0;i<Q;i++){\n        cin >> tmp;\n        P.push_back(tmp);\n    }\n    Node* root = makePMA(P);\n    vector<bool> res(Q, false);\n    searchPMA(root, T, res);\n    for (int i=0;i<res.size();i++){\n        cout << res[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <sstream>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n#define rrep(i, a) RREP(i, a, 0)\n#define RREP(i, a, b) for(int i = a; i >= b; --i)\n#define repll(i, a) REPLL(i, 0, a)\n#define REPLL(i, a, b) for(ll i = a; i < b; ++i)\n#define rrepll(i, a) RREPLL(i, a, 0)\n#define RREPLL(i, a, b) for(ll i = a; i >= b; --i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<int, P> PP;\nconst double PI = 3.14159265358979323846;\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+18 + 10;\n\nclass RollingHash{\nprivate:\n\tstatic const ull B = (ull)1e+8 + 7;\n\n\tstd::string text;\n\tint texSize;\n\tstd::vector<ull> pow, phash;\n\n\tinline ull TextHash(int s, int e){\n\t\treturn phash[e] - phash[s] * pow[e - s];\n\t}\n\npublic:\n\tRollingHash(std::string tex) :text(tex), texSize(text.size()), pow(texSize + 1), phash(texSize + 1){\n\t\tpow[0] = 1;\n\t\tphash[0] = 0;\n\t\trep(i, texSize){\n\t\t\tphash[i + 1] = phash[i] * B + text[i];\n\t\t\tpow[i + 1] = pow[i] * B;\n\t\t}\n\t}\n\n\tbool find(std::string pat){\n\t\tint patSize = pat.size();\n\t\tif (patSize > texSize)return false;\n\n\t\tull patHash = 0;\n\t\trep(i, patSize)patHash = patHash * B + pat[i];\n\n\t\trep(i, texSize - patSize + 1){\n\t\t\tif (TextHash(i, i + patSize) == patHash){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint n;\n\nint main(){\n\tstd::string a;\n\tstd::cin >> a >> n;\n\n\tRollingHash rh(a);\n\n\trep(i, n){\n\t\tstd::string b;\n\t\tstd::cin >> b;\n\t\tstd::cout << (rh.find(b) ? 1 : 0) << std::endl;;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\n#define NUM 48\nusing namespace std;\n\nint T_char_count[128] = {0},P_char_count[128];\nint T_Chain[128][128];\n\nclass LocRecord{\n\npublic:\n\t//?????¢???????¢????\n\tLocRecord(){\n\t\tlocationTable = new int**[128];\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tlocationTable[i] = new int*[128];\n\t\t\tfor(int k = 0; k < 128; k++){\n\t\t\t\tif(T_Chain[i][k] > 0){\n\t\t\t\t\tlocationTable[i][k] = new int[T_Chain[i][k]+1];\n\t\t\t\t\tfor(int p = 0; p < T_Chain[i][k]+1; p++){\n\t\t\t\t\t\tlocationTable[i][k][p] = -1;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tlocationTable[i][k] = new int[2];\n\t\t\t\t\tfor(int p = 0; p < 2; p++){\n\t\t\t\t\t\tlocationTable[i][k][p] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinit();\n\t}\n\n\t//-1?????£??\\\n\tvoid init(){\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tfor(int k = 0; k < 128; k++){\n\t\t\t\tindex[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init_index(char first,char second){\n\t\tindex[first][second] = 0;\n\t}\n\n\tvoid regist_loc(char first,char second,int location){\n\t\tlocationTable[first][second][index[first][second]] = location;\n\t\tindex[first][second]++;\n\t}\n\n\tint next_loc(char first,char second){\n\t\tint ret = locationTable[first][second][index[first][second]];\n\t\tindex[first][second]++;\n\t\treturn ret;\n\t}\n\nprivate:\n\tint*** locationTable;\n\tint index[128][128];\n};\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\t\t\treturn length < arg.length;\n\t};\n\tInfo(int arg_length,int arg_id,ull arg_hashValue){\n\t\tlength = arg_length;\n\t\tid = arg_id;\n\t\thashValue = arg_hashValue;\n\t}\n\n\tint length,id;\n\tull hashValue;\n};\n\nint main(){\n\n\tfor(int i = 0; i < 128; i++){\n\t\tT_char_count[i] = 0;\n\t\tfor(int k = 0; k < 128; k++){\n\t\t\tT_Chain[i][k] = 0;\n\t\t}\n\t}\n\n\tint T_length;\n\n\tchar* T = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tchar pre = T[0];\n\tT_char_count[T[0]]++;\n\n\tfor(T_length = 1; T[T_length] != '\\0';T_length++){\n\t\tT_char_count[T[T_length]]++;\n\t\tT_Chain[pre][T[T_length]]++;\n\t\tpre = T[T_length];\n\t}\n\n\tLocRecord locRecord;\n\tlocRecord.init();\n\n\n\tpre = T[0];\n\t//T[i]????????????i??§???????????¨????¨????\n\tfor(int i = 1; i < T_length; i++){\n\t\tlocRecord.regist_loc(pre,T[i],i-1);\n\t\tpre = T[i];\n\t}\n\n\tull* HASH = new ull[T_length+1];\n\tull* P = new ull[T_length+1];\n\n\tHASH[0] = 0;\n\tP[0] = 1;\n\n\t//T??????????????\\???????±???????\n\tfor(int i = 1; i <= T_length; i++){\n\t\tHASH[i] = T[i-1] + HASH[i-1]*MOD;\n\t\tP[i] = P[i-1]*MOD;\n\t}\n\n\n\tvector<Info> V[128][128];\n\n\tint Q,S_length,left,P_char_count[128];\n\tscanf(\"%d\",&Q);\n\n\tbool check[Q];\n\n\tfor(int i = 0; i < Q; i++)check[i] = false;\n\n\tchar S[1001];\n\tull S_HASH[1001],S_value,T_value,D;\n\tbool FLG;\n\n\n\t//Q??¶??????????????\\???????¨????\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",S);\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tP_char_count[i] = 0;\n\t\t}\n\n\t\tfor(S_length = 0;S[S_length] != '\\0';S_length++){\n\t\t\tP_char_count[S[S_length]]++;\n\t\t}\n\n\t\tFLG = true;\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tif(T_char_count[i] < P_char_count[i]){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG)continue;\n\n\t\tif(S_length == 1){\n\t\t\tcheck[loop] = true;\n\t\t\tcontinue;\n\t\t}\n\n\n\n\t\tS_HASH[0] = 0;\n\t\tfor(int i = 1; i <= S_length; i++){\n\t\t\tS_HASH[i] = S[i-1] + S_HASH[i-1]*MOD;\n\t\t}\n\n\t\tS_value = S_HASH[S_length];\n\n\t\tV[S[0]][S[1]].push_back(Info(S_length,loop,S_value));\n\t}\n\n\tint calc_length;\n\n\tfor(int first_word = 48; first_word <= 122; first_word++){\n\t\tfor(int second_word = 48; second_word <= 122;second_word++){\n\t\t\tfor(int i = 0; i < V[first_word][second_word].size();i++){\n\n\t\t\t\tlocRecord.init_index(first_word,second_word);\n\n\t\t\t\tcalc_length = V[first_word][second_word][i].length;\n\t\t\t\tS_value = V[first_word][second_word][i].hashValue;\n\n\t\t\t\tD = P[calc_length];\n\n\t\t\t\twhile((left = locRecord.next_loc(first_word,second_word)) != -1){\n\t\t\t\t\tif(left+calc_length-1 >= T_length)break;\n\n\t\t\t\t\tT_value = HASH[left+calc_length]-HASH[left]*D;\n\n\t\t\t\t\tif(T_value == S_value){\n\t\t\t\t\t\tcheck[V[first_word][second_word][i].id] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tif(check[i])printf(\"1\\n\");\n\t\telse{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nlong long MOD = 1000000000 + 7;\nconstexpr long long INF = numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourd; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\n\nLL h, w, n, m, k, t, s, p,q, last, cnt, sum, ans, dp[100], a[20000], b[20000];\nstring str, ss;\nbool f[1100];\nchar c;\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nstruct Edge { LL to, cost; };\nvector<Edge>vec[100];\nvector<LL>v;\npair<string, LL>sa[1000000];\nmap<string, vector<LL>>ma;\nmultiset<LL>st;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nvoid compare() {\n\tstring ss = \"\";\n\tsa[0] = make_pair(ss, str.size());\n\tfor(int i=0;i<str.size();i++) {\n\t\tss = str[i] + ss;\n\t\tsa[i + 1] = make_pair(ss, str.size() - i - 1);\n\t}\n\tsort(sa, sa + str.size() + 1);\n}\nint main() {\n\tcin >> str;\n\tcompare();\n\tcin >> q;\n\trep(i, q) {\n\t\tcin >> ss;\n\t\tint l = 0, r = str.size();\n\t\twhile (r - l>1)\n\t\t{\n\t\t\tint m = (l + r) / 2;\n\t\t\tif (str.compare(sa[m].sec, ss.size(), ss)<0) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tcout << (str.compare(sa[r].sec, ss.size(), ss) == 0) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//接尾辞配列の作成\n//sa[]は接尾辞の場所\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n//配列、+１忘れすに。\nstruct SuffixArray {\n\n\tint n,k;\n\tstring S;\n\tvector<int> rnk,tmp,sa,lcp;\n\t\n\tSuffixArray(string s){\n\t\tS = s;\n\t\tn = s.size();\n\t\trnk.resize(n+1);\n\t\ttmp.resize(n+1);\n\t\tsa.resize(n+1);\n\t\tlcp.resize(n+1);\n\t\tconstruct_sa();\n\t\tconstruct_lcp();\n\t}\n\t\n\t//文字列sの接尾辞配列を構築\n\tvoid construct_sa(){\n\t\t\n\t\t//最初は一文字ランクは文字コードでいい\n\t\tfor(int i = 0; i <= n;i++){\n\t\t\tsa[i] = i;\n\t\t\trnk[i] = i < n ? S[i] : -1;\n\t\t}\n\t\t\n\t\tauto comp = [&](int &i, int &j){\n\t\t\tif(rnk[i] != rnk[j]){\n\t\t\t\treturn rnk[i] < rnk[j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint ri =( i + k <= n )? rnk[i + k] : -1;\n\t\t\t\tint rj =( j + k <= n )? rnk[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t}\n\t\t};\n\t\t\n\t\t//k文字についてソートされているところから、2k文字でソートする\n\t\tfor(k = 1;k <= n ; k *= 2){\n\t\t\tsort(sa.begin(), sa.end(), comp);\n\t\t\t\n\t\t\t//いったんtmpに入れてからrnkに移す\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor(int i = 1; i <= n; i++)\t{\n\t\t\t\ttmp[sa[i]] = tmp[sa[i -1]] + (comp(sa[i - 1],sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor(int i = 0;i <= n;i++){\n\t\t\t\trnk[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool contain(string t){\n\t\tint a = 0,b = S.length();\n\t\twhile(b - a > 1){\n\t\t\tint c = (a + b) / 2;\n\t\t\t\n\t\t\tif(S.compare(sa[c],t.length(),t) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\t\n\t\treturn (S.compare(sa[b], t.length(),t) == 0);\n\t}\n\n\tvoid construct_lcp(){\n\t\tint n = S.length();\n\t\tfor(int i = 0;i <= n;i++)rnk[sa[i]] = i;\n\t\t\n\t\tint h = 0;\n\t\tlcp[0] = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\t//文字列中で位置iの接尾辞と、接尾辞配列中でそのひとつ前の接尾辞のLCPを求める。\n\t\t\tint j = sa[rnk[i] - 1];\n\t\t\t\n\t\t\t// hを先頭の分一個減らし、後ろが一致しているだけ増やす\n\t\t\tif(h > 0)h--;\n\t\t\tfor(;j + h < n && i + h < n;h++){\n\t\t\t\tif(S[j + h] != S[i + h])break;\n\t\t\t}\n\t\t\tlcp[rnk[i] - 1] = h;\n\t\t}\n\t}\n};\n\nint main()\n{\n\tstring S;\n\tint N;\n\t\n\tcin >> S; \n\tcin >> N;\n\tSuffixArray sa(S);\n\t\t\n\tfor(int i = 0 ;i < N;i++)\n\t{\n\t\tstring T;\n\t\tcin >> T;\n\t\tif(sa.contain(T)) cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int B=999999937;\nconst int P=1000000007;\n\nvector<long long> gen_hash(const string &s){\n\tvector<long long> hash(s.size());\n\tlong long c=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tc=(c*B+s[i])%P;\n\t\thash[i]=c;\n\t}\n\treturn hash;\n}\nlong long pow_binary_mod(long long x,long long y,long long mod){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%mod;\n\t\tx=x*x%mod;\n\t}\n\treturn z;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s;\n\tcin>>s;\n\tvector<long long> v=gen_hash(s);\n\n\tint T;\n\tfor(cin>>T;T--;){\n\t\tstring q;\n\t\tcin>>q;\n\t\tlong long hash=gen_hash(q)[q.size()-1];\n\t\tlong long Brev=pow_binary_mod(B,q.size(),P);\n\t\t//vector<int> r;\n\t\tint i=q.size()-1;\n\t\tfor(;i<s.size();i++){\n\t\t\tif(v[i]==((i==q.size()-1?0:v[i-q.size()])*Brev+hash)%P)break;//r.push_back(i-q.size()+1);\n\t\t}\n\t\tif(i<s.size()){\n\t\t\t//for(int i=0;i<r.size();i++)printf(\"%d\\n\",r[i]);\n\t\t\tputs(\"1\");\n\t\t}else{\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<cstdio>\n#include<algorithm>\n\nstring T;\nint *A, *lev, *new_lev;\nint k, n;\n\nbool cmp_ex(int i, int j)\n{\n    if(T[i] != T[j]){ return lev[i] < lev[j]; }\n    return (i + k <= n ? lev[i + k] : -1) < (j + k <= n ? lev[j + k] : -1);\n}\n\nint main()\n{\n    int i;\n    cin >> T;\n    n = T.size();\n\n    A = new int [n + 1];\n    lev = new int [n + 1];\n    new_lev = new int [n + 1];\n\n    for(i = 0; i < n; i++){ A[i] = i; lev[i] = T[i]; }\n    A[n] = n, lev[n] = -1;\n\n    k = 1;\n    while(1){\n        sort(A, A + n + 1, cmp_ex);\n\n        new_lev[A[0]] = 0;\n        for(i = 0; i < n; i++){ new_lev[A[i + 1]] = new_lev[A[i]] + (cmp_ex(A[i], A[i + 1]) ? 1 : 0); }\n        if(new_lev[A[n]] == n) break;\n        for(i = 0; i <= n; i++) lev[i] = new_lev[i];\n\n        k <<= 1;\n    };\n\n    int q;\n    scanf(\"%d\", &q);\n    string P; int lp, left, right, mid, crit; bool exist;\n\n    while(q){\n        cin >> P;\n        lp = P.size();\n        left = 1; right = n; exist = false;\n        while(left <= right){\n            if(lp > n) break;\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], lp, P);\n            if(crit > 0){\n                right = mid - 1;\n            }else if(crit < 0){\n                left = mid + 1;\n            }else{\n                exist = true; break;\n            }\n        };\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    };\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\n#define NUM 48\nusing namespace std;\n\nint checkTable[10000]={0};\n\nclass Node{\npublic:\n    Node(){\n        ch=0;\n        num_of_child=num_of_end_str=0;\n        parent=0;\n        cameFLG=false;\n        table=new short[128-NUM];\n        for(int i=48;i<=122;i++)table[i-NUM]=-1;\n    }\n\n    void addSTR(char str[],int ptn_index){\n        int index=0;\n        Node* tmp=this;\n        while(true){\n            if(str[index+1]=='\\0'){\n                tmp->end_str.push_back(ptn_index);\n                tmp->num_of_end_str++;\n                break;\n            }else{\n                if(tmp->table[str[index+1]-NUM]==-1){\n                    Node* new_node=new Node();\n                    new_node->parent=tmp;\n                    new_node->ch=str[index+1];\n                    tmp->nodes.push_back(new_node);\n                    tmp->table[str[index+1]-NUM]=tmp->num_of_child;\n                    tmp->num_of_child++;\n                }\n                tmp=tmp->nodes[tmp->table[str[index+1]-NUM]];\n                index++;\n            }\n        }\n    }\n    bool searchSTR(char str[],int index){\n        Node* tmp=this;\n        while(true){\n            if(!tmp->cameFLG){\n                for(int i=0;i<tmp->num_of_end_str;i++)checkTable[tmp->end_str[i]]=1;\n                tmp->cameFLG=true;\n            }\n            if(tmp->num_of_child==0){\n                if(tmp->parent != 0){\n                    Node* parent=tmp->parent;\n                    parent->num_of_child--;\n                    parent->table[tmp->ch-NUM]=-1;\n                    while(parent->parent!=0&&parent->num_of_child==0){\n                        parent->parent->num_of_child--;\n                        parent->parent->table[parent->ch-NUM]=-1;\n                        parent=parent->parent;\n                    }\n                }\n                return false;\n            }else{\n                if(str[index+1]=='\\0')return true;\n                else{\n                    if(tmp->table[str[index+1]-NUM]!=-1){\n                        tmp=tmp->nodes[tmp->table[str[index+1]-NUM]];\n                        index++;\n                    }else{\n                        return false;\n                    }\n                }\n            }\n        }\n        return false;   //must not reach here.\n    }\n    short num_of_child;\n    short num_of_end_str;\n    vector<short> end_str;\n    vector<Node*> nodes;\n    Node* parent;\n    short* table;\n    char ch;\n    bool cameFLG;\n};\n\n\n\nclass MotherNode{\npublic:\n    MotherNode(){\n        motherNode = new Node*[128-NUM];\n        for(int i=48;i<=122;i++){\n            motherNode[i-NUM]=new Node();\n            motherNode[i-NUM]->ch=i;\n        }\n    }\n    void addSTR(char str[],int ptn_index){\n        motherNode[str[0]-NUM]->addSTR(str,ptn_index);\n    }\n    bool searchSTR(char str[]){\n        return motherNode[str[0]-NUM]->searchSTR(str,0);\n    }\nprivate:\n    Node** motherNode;\n};\n\nint main(){\n\n    char* T = new char[1000001];\n    int Q,T_length=0;\n    scanf(\"%s\",T);\n    scanf(\"%d\",&Q);\n    char* P = new char[1001];\n    MotherNode motherNode;\n    for(int i=0;i<Q;i++){\n        scanf(\"%s\",P);\n        motherNode.addSTR(P,i);\n    }\n    for(int i=0;T[i]!='\\0';i++)T_length++;\n    char tmp[1001];\n    for(int i=0;i<T_length;i++){\n        for(int k=0;k<1001;k++)tmp[k]='\\0';\n        for(int k=0;T[i+k]!='\\0'&&k<1000;k++){\n            tmp[k]=T[i+k];\n            if(motherNode.searchSTR(tmp)==false)break;\n        }\n    }\n    for(int i=0;i<Q;i++){\n        if(checkTable[i]==0)printf(\"0\\n\");\n        else{\n            printf(\"1\\n\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass suffix_array {\n\tconst int n;\n\tstring S;\n\tvector<int> sa, rank;\npublic:\n\tsuffix_array(const string &S_) : n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [&](int i, int j) {\n\t\t\t\tif (rank[i] != rank[j]) return rank[i] < rank[j];\n\t\t\t\tint ri = i + k <= n ? rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\tfor (int i = 0; i <= n; i++)\n\t\t\t\trank[i] = tmp[i];\n\t\t}\n\t}\n\tbool is_contain(const string &T) {\n\t\tint lb = 0, ub = n;\n\t\twhile (ub - lb > 1) {\n\t\t\tint m = (lb + ub) / 2;\n\t\t\tif (S.compare(sa[m], T.length(), T) < 0) lb = m;\n\t\t\telse ub = m;\n\t\t}\n\t\treturn S.compare(sa[ub], T.length(), T) == 0;\n\t}\n\tvector<int> get_lcp() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint Q;\n\tstring T;\n\tcin >> T;\n\tsuffix_array sa(T);\n\tcin >> Q;\n\twhile (Q--) {\n\t\tstring P;\n\t\tcin >> P;\n\t\tprintf(\"%d\\n\", (int)sa.is_contain(P));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n\n#define MAX 1000000\n\nusing namespace std;\n\nint n,k;\nint rankk[MAX+1];\nint tmp[MAX+1];\nint sa[MAX+1];\n\nbool compare_sa(int i,int j){\n\tif(rankk[i]!=rankk[j]) return rankk[i]<rankk[j];\n\telse{\n\t\tint ri=(i+k<=n ? rankk[i+k]:-1);\n\t\tint rj=(j+k<=n ? rankk[j+k]:-1);\n\t\treturn ri<rj;\n\t}\n}\n\nvoid construct_sa(string S){\n\tn = S.length();\n\t//???????¨???????, 1????????§, rank????????????????????§??????.\n\tfor(int i=0;i<=n;i++){\n\t\tsa[i]=i;\n\t\trankk[i]=(i<n ? S[i]:-1);\n\t}\n\t\n\t//k??????????????????sort?????????????????¨?????????, 2k????????§sort\n\tfor(k=1;k<=n;k*=2){\n\t\tsort(sa,sa+n+1,compare_sa);\n\t\t//tmp????¬????rank????¨????, rank????§?????????????.\n\t\ttmp[sa[0]]=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\ttmp[sa[i]]=tmp[sa[i-1]]+(compare_sa(sa[i-1],sa[i]) ? 1:0);\n\t\t}\n\t\tfor(int i=0;i<=n;i++){\n\t\t\trankk[i]=tmp[i];\n\t\t}\n\t}\n}\n\nbool contains(string S, string P){\n\tint a=0;\n\tint b=S.length();\n\twhile(b-a>1){\n\t\tint c=(a+b)/2;\n\t\t//S???sa[C]???????????????|T|????????¨T?????????\n\t\tif(S.compare(sa[c],P.length(),P)<0) a=c;\n\t\telse b=c;\n\t}\n\treturn S.compare(sa[b],P.length(),P)==0;\n}\n\nint main(){\n\tint q;\n\tbool ans;\n\tstring T,P;\n\tcin >> T;\n\tconstruct_sa(T);//Construct Suffix Array\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tcin.ignore();\n\t\tcin >> P;\n\t\tans = contains(T,P);\n\t\tif(ans==true)\n\t\tprintf(\"1\\n\");\n\t\telse\n\t\tprintf(\"0\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nclass SuffixArray {\npublic:\n  string &s;\n  vector<int> sa;\n  int n;\n  SuffixArray(string &str) : s(str){\n    n = s.size();\n  }\n  void construct_sa(){\n    sa.resize(n+1);\n    vector<int> rank(n+1);\n    rep(i,n+1){\n      sa[i]=i;\n      rank[i] = (i<n)?s[i]:(-1);\n    }\n    vector<int> tmp(n+1,0);\n    for(int k=1; k<=n; k*=2){\n      auto comp = [&](int i, int j){\n        if(rank[i]!=rank[j]) return rank[i]<rank[j];\n        int ri = (i+k<=n)?(rank[i+k]):-1;\n        int rj = (j+k<=n)?(rank[j+k]):-1;\n        return ri < rj;\n      };\n      sort(all(sa), comp);\n      tmp[sa[0]]=0;\n      repl(i,1,n+1){\n        tmp[sa[i]] = tmp[sa[i-1]];\n        if(comp(sa[i-1], sa[i])) tmp[sa[i]]++;\n      }\n      swap(tmp, rank);\n    }\n  }\n  bool contain(const string &t){\n    int m = t.size();\n    int l = 0, r = n;\n    while(r-l>1){\n      int mid = (r+l)/2;\n      if(s.compare(sa[mid], m, t) < 0) l = mid;\n      else r = mid;\n    }\n    return s.compare(sa[r], m, t) == 0;\n  }\n};\n\nint main(){\n  string t;\n  int q;\n  cin>>t>>q;\n\n  SuffixArray sa(t);\n  sa.construct_sa();\n\n  rep(_,q){\n    string p;\n    cin>>p;\n    cout << sa.contain(p) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\nusing namespace std;\n\nint T_char_count[128] = {0},P_char_count[128];\n\nclass LocRecord{\n\npublic:\n\t//?????¢???????¢????\n\tLocRecord(){\n\t\tlocationTable = new int*[128];\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t}\n\n\t//-1?????£??\\\n\tvoid init(){\n\t\tint limit;\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init_index(){\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t}\n\n\tvoid regist_loc(int ch, int location){\n\t\tlocationTable[ch][index[ch]] = location;\n\t\tindex[ch]++;\n\t}\n\n\tint next_loc(int ch){\n\t\tint ret = locationTable[ch][index[ch]];\n\t\tindex[ch]++;\n\t\treturn ret;\n\t}\n\nprivate:\n\tint** locationTable;\n\tint index[128];\n};\n\nint main(){\n\n\tfor(int i = 0; i < 128; i++)T_char_count[i] = 0;\n\n\tint length;\n\n\tchar* T = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tfor(length = 0; T[length] != '\\0';length++){\n\t\tT_char_count[T[length]]++;\n\t}\n\n\tLocRecord locRecord;\n\tlocRecord.init();\n\n\t//T[i]????????????i??§???????????¨????¨????\n\tfor(int i = 0; i < length; i++){\n\t\tlocRecord.regist_loc(T[i],i);\n\t}\n\n\tull* HASH = new ull[length+1];\n\tull* P = new ull[length+1];\n\n\tHASH[0] = 0;\n\tP[0] = 1;\n\n\t//T??????????????\\???????±???????\n\tfor(int i = 1; i <= length; i++){\n\t\tHASH[i] = T[i-1] + HASH[i-1]*MOD;\n\t\tP[i] = P[i-1]*MOD;\n\t}\n\n\tint Q,S_length,left,P_char_count[128];\n\tscanf(\"%d\",&Q);\n\n\tchar S[1001];\n\tull S_HASH[1001],S_value,T_value;\n\tbool FLG;\n\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",S);\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tP_char_count[i] = 0;\n\t\t}\n\n\t\tfor(S_length = 0;S[S_length] != '\\0';S_length++){\n\t\t\tP_char_count[S[S_length]]++;\n\t\t}\n\n\t\tFLG = true;\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tif(T_char_count[i] < P_char_count[i]){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG)continue;\n\n\n\t\tS_HASH[0] = 0;\n\t\tfor(int i = 1; i <= S_length; i++){\n\t\t\tS_HASH[i] = S[i-1] + S_HASH[i-1]*MOD;\n\t\t}\n\n\t\tS_value = S_HASH[S_length];\n\n\t\tlocRecord.init_index();\n\n\t\tFLG = false;\n\n\t\twhile((left = locRecord.next_loc(S[0])) != -1){\n\t\t\tif(left+S_length-1>=length)break;\n\n\t\t\tT_value = HASH[left+S_length]-HASH[left]*P[S_length];\n\n\t\t\tif(T_value == S_value){\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(FLG){\n\t\t\tprintf(\"1\\n\");\n\t\t}else{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define MAX_T 1000001\n#define MAX_P 1001\ntypedef vector<int> Vec;\n \nVec build_fail(const char *s){\n    int N = strlen(s);\n    Vec fail(N+1);\n    int j = fail[0] = -1;\n    for(int i = 1 ; i <= N ; i++){\n        while(j >= 0 && s[j] != s[i-1]) j = fail[j];\n        fail[i] = ++j;\n    }\n    return fail;\n}\n \nint match(const char *t,const char *p,const Vec &fail){\n    int n = strlen(t),m = strlen(p);\n    for(int i = 0, k = 0 ; i < n ; i++){\n        while(k >= 0 && p[k] != t[i]) k = fail[k];\n        if(++k >= m){\n            return true;\n        }\n    }\n    return false;\n}\n\nint main(){\n    int Q,N,M;\n    char T[MAX_T],P[MAX_P];\n    scanf(\"%s %d\",T, &Q);\n    N = strlen(T);\n    Vec fail = build_fail(T);\n    while(Q--){\n        scanf(\"%s\",P);\n        M = strlen(P);\n        if(N < M){\n            puts(\"0\");\n            continue;\n        }\n        if(match(T,P,fail)){\n            puts(\"1\");\n        }else{\n            puts(\"0\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<cstdio>\n#include<algorithm>\n\nstring T;\nint *A, *lev, *new_lev;\nint k, n;\n\nbool cmp_ex(int i, int j)\n{\n    if(T[i] != T[j]){ return lev[i] < lev[j]; }\n    return (i + k < n ? lev[i + k] : -1) < (j + k < n ? lev[j + k] : -1);\n}\n\nint main()\n{\n    int i;\n    cin >> T;\n    n = T.size();\n\n    A = new int [n + 1];\n    lev = new int [n + 1];\n    new_lev = new int [n + 1];\n\n    for(i = 0; i < n; i++){ A[i] = i; lev[i] = T[i]; }\n    A[n] = n, lev[n] = -1;\n\n    k = 1;\n    while(1){\n        sort(A, A + n + 1, cmp_ex);\n        if((k << 1) > n) break;\n        new_lev[A[0]] = 0;\n        for(i = 0; i < n; i++){ new_lev[A[i + 1]] = new_lev[A[i]] + (cmp_ex(i, i + 1) ? 1 : 0); }\n        for(i = 0; i <= n; i++) lev[i] = new_lev[i];\n        k <<= 1;\n    };\n\n    int q;\n    scanf(\"%d\", &q);\n    string P; int lp, left, right, mid, crit; bool exist;\n\n    while(q){\n        cin >> P;\n        lp = P.size();\n        left = 0; right = n; exist = false;\n        while(left <= right){\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], lp, P);\n            if(crit > 0){\n                right = mid - 1;\n            }else if(crit < 0){\n                left = mid + 1;\n            }else{\n                exist = true; break;\n            }\n        };\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    };\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring S,T;\nstring V[100000][100];\nint main(){\n\tint q,a,b;\n\tb=S.size();\n\tcin>>S;\n\ta=min(b,100);\n\tfor(int i=1;i<100;i++){\n\t\tfor(int j=0;j<=S.size()-j;j++){\n\t\t\tV[j][i]=S.substr(j,i);\n\t\t}\n\t}\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>T;\n\t\tfor(int j=0;j<S.size()-T.size();j++){\n\t\t\tif(V[j][T.size()]==T){\n\t\t\t\tcout<<\"1\"<<endl;\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t}\n\t\tcout<<\"0\"<<endl;\n\t\tExit:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(string s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  bool operator()(int i, int j) { \n    int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  \n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  \n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  sort(ALL(sa),rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  if(1000 < s.size())assert(false);\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)>>1;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n/*\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n-nb,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k>=nc)a[i]=b[j++];\n      else if(j>=nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n*/\n\nint L[1000000],R[1000000];\n\ninline void merge(int *A, const int left, const int mid, const int right, const RollingHash &rh){\n  const int n1 = mid - left, n2 = right - mid;\n  REP(i,n1)L[i]=A[left+i];\n  REP(i,n2)R[i]=A[mid+i];\n  for(int k =left,i=0,j=0;k<right;k++){\n    if(n2<=j)A[k]=L[i++];\n    else if(n1<=i)A[k]=R[j++];\n    else A[k]=rh(L[i],R[j])?L[i++]:R[j++];\n  }\n}\n\nvoid mergeSort(int *A,const int left,const int right, const RollingHash &rh){\n  if(left+1<right){\n    const int mid = (left+right)>>1;\n    mergeSort(A,left,mid, rh);\n    mergeSort(A,mid,right, rh);\n    merge(A,left,mid,right, rh);\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  //mergesort(n,sa,rh);\n  mergeSort(sa,0,n,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nconst int MAX_N = 1000000;\n\nint n, k;\nint Rank[MAX_N + 1];\nint tmp[MAX_N + 1];\n\n//(rank[i],rank[i+k])と(rank[j],rank[j+k])を比較\nbool compare_sa(int i, int j) {\n\tif (Rank[i] != Rank[j]) return Rank[i] < Rank[j];\n\telse {\n\t\tint r1 = (i + k <= n ? Rank[i + k] : -1);\n\t\tint r2 = (j + k <= n ? Rank[j + k] : -1);\n\t\treturn r1 < r2;\n\t}\n}\n\n//文字列Sの接尾辞配列（全ての接尾辞を辞書順にソートしたもの）を構築\nvoid construct_sa(string s, int *sa) {\n\tn = s.length();\n\n\t//最初は1文字、ランクは文字コードにすればよい\n\tfor (int i = 0; i <= n; i++) {\n\t\tsa[i] = i;\n\t\tRank[i] = (i < n ? s[i] : -1);\n\t}\n\n\t//k文字についてソートされているところから2k文字でソートする\n\tfor (k = 1; k <= n; k *= 2) {\n\t\tsort(sa, sa + n + 1, compare_sa);\n\n\t\t//いったんtmpに次のランクを計算し、それからRankに移す\n\t\ttmp[sa[0]] = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (compare_sa(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t}\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tRank[i] = tmp[i];\n\t\t}\n\t}\n}\n\n//文字列検索\nbool contain(string s, int *sa, string t) {\n\tint a = 0, b = s.length();\n\twhile (b - a > 1) {\n\t\tint c = (a + b) / 2;\n\t\t//sのsa[c]文字目から|T|文字とTを比較\n\t\tif (s.compare(sa[c], t.length(), t) < 0)a = c;\n\t\telse b = c;\n\t}\n\treturn s.compare(sa[b], t.length(), t) == 0;//0の時一致を表す\n}\n\nint Rank2[MAX_N + 1];\n\n//文字列Sとその接尾辞配列saを受け取り、高さ配列をlcpに計算\nvoid construct_lcp(string s, int *sa, int *lcp) {\n\tint N = s.length();\n\tfor (int i = 0; i <= N; i++)Rank2[sa[i]] = i;\n\n\tint h = 0;\n\tlcp[0] = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\t//文字列中での位置iの接尾辞と、接尾辞配列中でその1つ前の接尾辞のLCPを求める\n\t\tint j = sa[Rank2[i] - 1];\n\n\t\t//hを先頭の分1減らし、後ろが一致しているだけ増やす\n\t\tif (h > 0)h--;\n\t\tfor (; j + h < N&&i + h < N; h++) {\n\t\t\tif (s[j + h] != s[i + h])break;\n\t\t}\n\t\tlcp[Rank2[i] - 1] = h;\n\t}\n}\n\nstring s, p;\nint q;\nint sa[MAX_N + 1];\nint main() {\n\tcin >> s >> q;\n\tconstruct_sa(s,sa);\n\tREP(qqq, q) {\n\t\tcin >> p;\n\t\tcout << contain(s, sa, p) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint T_length,P_length,range;\nint *Rank;\nint *Suffix_Array;\nint *Work;\n\nchar *T,*P;\n\n\nint strCmp_Suffix_Array(int start){\n\tint index,ret;\n\n\tret = 0;\n\n\tfor(index = 0; index < P_length && T[start+index] != '\\0'; index++){\n\t\tif(P[index] != T[start+index]){\n\t\t\tif(P[index] > T[start+index]){\n\t\t\t\tret = 2;\n\t\t\t}else{\n\t\t\t\tret = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(ret == 0 && index < P_length){\n\t\tret = 2;\n\t}\n\treturn ret;\n}\n\n\nbool compare_Suffix_Array(int a,int b){\n\tif(Rank[a] != Rank[b])return Rank[a] < Rank[b];\n\telse{\n\t\tint rank_a = a + range <= T_length ? Rank[a+range]:-1;\n\t\tint rank_b = b + range <= T_length ? Rank[b+range]:-1;\n\t\treturn rank_a < rank_b;\n\t}\n}\n\nbool isContain(){\n\tint left = 0,right = T_length,m;\n\tm = (left+right)/2;\n\n\twhile(left <= right){\n\t\tswitch(strCmp_Suffix_Array(Suffix_Array[m])){\n\t\tcase 0:\n\t\t\treturn true;\n\t\tcase 1:\n\t\t\tright = m-1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tleft = m+1;\n\t\t\tbreak;\n\t\t}\n\t\tm = (left+right)/2;\n\t}\n\treturn false;\n}\n\nvoid make_Suffix_Array(){\n\tfor(int i = 0; i <= T_length; i++){\n\t\tSuffix_Array[i] = i;\n\t\tRank[i] = i < T_length? T[i]:-1;\n\t}\n\n\tfor(range = 1; range <= T_length; range*=2){\n\t\tsort(Suffix_Array,Suffix_Array+(T_length+1),compare_Suffix_Array);\n\n\t\tWork[Suffix_Array[0]] = 0;\n\t\tfor(int i = 1; i <= T_length; i++){\n\t\t\tWork[Suffix_Array[i]] = Work[Suffix_Array[i-1]] + (compare_Suffix_Array(Suffix_Array[i-1],Suffix_Array[i])?1:0);\n\t\t}\n\t\tfor(int i = 0; i <= T_length; i++){\n\t\t\tRank[i] = Work[i];\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\tT = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tfor(T_length = 0; T[T_length] != '\\0'; T_length++);\n\tRank = new int[T_length+1];\n\tSuffix_Array = new int[T_length+1];\n\tWork = new int[T_length+1];\n\n\tmake_Suffix_Array();\n\n\tint Q;\n\tscanf(\"%d\",&Q);\n\n\tP = new char[1001];\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",P);\n\n\t\tfor(P_length = 0; P[P_length] != '\\0'; P_length++);\n\n\t\tif(isContain()){\n\t\t\tprintf(\"1\\n\");\n\t\t}else{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n/2+n%2,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i-1];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==nc)a[i]=b[j++];\n      else if(j==nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000000];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(string s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  bool operator()(int i, int j) { \n    int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  \n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  \n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  sort(ALL(sa),rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    S.push_back('$');\n    vector<int> c(n+1,0),ord(n+1,0);\n    for(int i=0;i<=n;i++) ord[i]=n-i;\n    sort(ord.begin(),ord.end(),[&](int a,int b){return S[a]<S[b];});\n    for(int i=0;i<=n;i++){\n      sa[i]=ord[i];\n      c[i]=S[i];\n    }\n    for(int len=1;len<=n;len*=2){\n      vector<int> r=c;\n      for(int i=0;i<=n;i++){\n\t c[sa[i]] =\n\t   i > 0 &&\n\t   r[sa[i - 1]] == r[sa[i]] &&\n\t   sa[i - 1] + len <= n &&\n\t   r[sa[i - 1] + len / 2] == r[sa[i] + len / 2]\n\t   ? c[sa[i - 1]] : i;\n      }\n      vector<int> cnt(n+1);\n      for(int i=0;i<=n;i++) cnt[i]=i;\n      vector<int> s=sa;\n      for(int i=0;i<=n;i++){\n\tint s1=s[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n);\n    for(int i=0;i<n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    //assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(string s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  bool operator()(int i, int j) { \n    int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  \n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  \n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  sort(ALL(sa),rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n  if(100000 < s.size())assert(false);\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstring s, t; int q;\n\nstruct SuffixArray {\n    string str;\n    vector<int> sa, rnk;\n\n    SuffixArray (string &str) : str(str) {\n        int n = (int)str.size(), itr = 1;\n\n        auto comp = [&](int a, int b) {\n            if(rnk[a] != rnk[b]) return rnk[a] < rnk[b];\n            return (a + itr < n ? rnk[a + itr] : -1) < (b + itr < n ? rnk[b + itr] : -1);\n        };\n\n        for(int i = 0; i < n; ++i) sa.push_back(i), rnk.push_back(str[i]);\n\n        vector<int> tmp(n);\n        for(; itr <= n; itr *= 2) {\n            sort(sa.begin(), sa.end(), comp);\n\n            tmp[sa[0]] = 0;\n            for(int i = 1; i < n; ++i) tmp[sa[i]] = tmp[sa[i-1]] + comp(sa[i-1], sa[i]);\n            rnk = tmp;\n        }\n    }\n\n    bool find(string &t) {\n        int ng = -1, ok = (int)str.size()-1;\n        while(ok - ng > 1) {\n            int mid = (ok + ng) / 2;\n            if(str.substr(sa[mid], t.size()) < t) ng = mid;\n            else ok = mid;\n        }\n        return str.substr(sa[ok], t.size()) == t;\n    }\n};\n\nint main(){\n    cin >> s >> q;\n    SuffixArray sa(s);\n\n    while(q--) {\n        cin >> t;\n        cout << sa.find(t) << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(string s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  bool operator()(int i, int j) { \n    int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  \n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  \n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  sort(ALL(sa),rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n  if(10000 < s.size())assert(false);\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nll n,k;\nvector<ll> Rank;\nvector<ll> tmp;\nvector<ll> sa;\nstring str;\n\n\nbool less_cmp(ll a,const string &s){\n    for(ll i=a;i<a+s.size();i++){\n        if(i>=n){return true;}\n        if(str[i]!=s[i-a]){return str[i]<s[i-a];}\n    }\n    return false;\n}\n\nbool equal_cmp(ll a,const string &s){\n    for(ll i=0;i<s.size();i++){\n        if(i+a>=n){return false;}\n        if(str[i+a]!=s[i]){return false;}\n    }\n    return true;\n}\n\nbool cmp(ll i,ll j){\n    if(Rank[i]!=Rank[j]){return Rank[i]<Rank[j];}\n    return (i+k<=n?Rank[i+k]:-1)<(i+j<=n?Rank[j+k]:-1);\n}\n\nvoid build(const string &s){\n    n=s.size();\n    sa.resize(n+1);\n    Rank.resize(n+1);\n    tmp.resize(n+1);\n    for(int i=0;i<=n;i++){\n        sa[i]=i;\n        Rank[i]=i<n?s[i]:-1;\n    }\n    for(k=1;k<=n;k++){\n        sort(sa.begin(),sa.end(),cmp);\n        tmp[sa[0]]=0;\n        for(int i=1;i<=n;i++){\n            tmp[sa[i]]=tmp[sa[i-1]]+(cmp(sa[i-1],sa[i])?1:0);\n        }\n        for(int i=0;i<=n;i++){\n            Rank[i]=tmp[i];\n        }\n    }\n}\n\n\nbool search(const string &s){\n    ll l=0,r=n;\n    \n    while(r-l>=4){\n        ll m=l+(r-l)/2;\n        if(less_cmp(sa[m],s)){l=m;}\n        else{r=m;}\n    }\n     \n    for(ll i=l;i<=r;i++){\n        if(equal_cmp(sa[i],s)){return true;}\n    }\n    return false;\n}\n\n\n\n\nint main(){\n    cin>>str;\n    build(str);\n    ll q;\n    cin>>q;\n    while(q--){\n        string p;\n        cin>>p;\n        cout<<search(p)<<endl;\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n\tstring T, P;\n\tlong Q;\n\tcin >> T >> Q;\n\tfor (long i = 0; i < Q; i++){\n\t\tcin >> P;\n\t\tlong flag = 0;\n\t\tfor (long j = 0; j < T.size() - P.size() + 1; j++){\n\t\t\tif (T[j] == P[0] && T.substr(j, P.size()) == P){\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag) printf(\"1\\n\");\n\t\telse printf(\"0\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nclass suffix_array{\n    void create_begin_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        int sum=0;\n        for(int i=0;i<bucket.size();i++){bucket[i]+=sum;swap(sum,bucket[i]);}\n    }\n\n    void create_end_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        for(int i=1;i<bucket.size();i++)bucket[i]+=bucket[i-1];\n    }\n\n    void induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_begin_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(sa[i]>0&&is_l[sa[i]-1])sa[bucket[v[sa[i]-1]]++]=sa[i]-1;\n    }\n\n    void invert_induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_end_bucket(v,bucket);\n        for(int i=v.size()-1;i>=0;i--)if(sa[i]>0&&!is_l[sa[i]-1])sa[--bucket[v[sa[i]-1]]]=sa[i]-1;\n    }\n\n    vector<int>sa_is(vector<int>v,int mv){\n        if(v.size()==1)return vector<int>(1,0);\n\n        vector<int>is_l(v.size());\n        vector<int>bucket(mv+1);\n        vector<int>sa(v.size(),-1);\n        auto is_lms=[&](int x)->bool{return x>0&&is_l[x-1]&&!is_l[x];};\n\n        is_l[v.size()-1]=0;\n        for(int i=v.size()-2;i>=0;i--)is_l[i]=v[i]>v[i+1]||(v[i]==v[i+1]&&is_l[i+1]);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(is_lms(i))sa[--bucket[v[i]]]=i;\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n\n        int cur=0;\n        vector<int>order(v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))order[i]=cur++;\n\n        vector<int>next_v(cur);\n        cur=-1;\n        int prev=-1;\n        for(int i=0;i<v.size();i++){\n            if(!is_lms(sa[i]))continue;\n            bool diff=false;\n            for(int d=0;d<v.size();d++){\n                if(prev==-1||v[sa[i]+d]!=v[prev+d]||is_l[sa[i]+d]!=is_l[prev+d]){\n                    diff=true;\n                    break;\n                }\n                else if(d>0&&is_lms(sa[i]+d))break;\n            }\n            if(diff){cur++;prev=sa[i];}\n            next_v[order[sa[i]]]=cur;\n        }\n\n        vector<int>re_order(next_v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))re_order[order[i]]=i;\n        vector<int>next_sa=sa_is(next_v,cur);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<sa.size();i++)sa[i]=-1;\n        for(int i=next_sa.size()-1;i>=0;i--)sa[--bucket[v[re_order[next_sa[i]]]]]=re_order[next_sa[i]];\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n        return sa;\n    }\n\n    vector<int>sa_is(string &s){\n        vector<int>v(s.size()+1);\n        for(int i=0;i<s.size();i++)v[i]=s[i];\n        sa=sa_is(v,*max_element(v.begin(),v.end()));\n    }\n\n    void construct_lcp(){\n        lcp.resize(s.size());\n        rank.resize(s.size()+1);\n        int n=s.size();\n        for(int i=0;i<=n;i++)rank[sa[i]]=i;\n        int h=0;\n        lcp[0]=0;\n        for(int i=0;i<n;i++){\n            int j=sa[rank[i]-1];\n\n            if(h>0)h--;\n            for(;j+h<n&&i+h<n;h++){\n                if(s[j+h]!=s[i+h])break;\n            }\n            lcp[rank[i]-1]=h;\n        }\n    }\n\n    class sparse_table{\n        vector<vector<int> >st;\n    public:\n        void init(vector<int>&v){\n            int b;\n            for(b=0;(1<<b)<=v.size();b++);\n            st.resize(b);for(int i=0;i<b;i++)st[i].resize(1<<b);\n            for(int i=0;i<v.size();i++)st[0][i]=v[i];\n\n            for(int i=1;i<b;i++){\n                for(int j=0;j+(1<<i)<=(1<<b);j++){\n                    st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);\n                }\n            }\n        }\n        int get_min(int l,int r){\n            assert(l<r);\n            int b=32-__builtin_clz(r-l)-1;\n            return min(st[b][l],st[b][r-(1<<b)]);\n        }\n        sparse_table(){}\n        sparse_table(vector<int>&v){init(v);}\n    };\n    sparse_table st;\npublic:\n    string s;\n    vector<int>sa,lcp,rank;\n    void init(string &t){\n        s=t;\n        sa_is(s);\n        construct_lcp();\n        st.init(lcp);\n    }\n    suffix_array(string &t){init(t);}\n    suffix_array(){}\n\n    bool contain(string &t){\n        int lb=0,ub=s.size();\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            if(s.compare(sa[mid],t.size(),t)<0)lb=mid;\n            else ub=mid;\n        }\n        return s.compare(sa[ub],t.size(),t)==0;\n    }\n\n    int get_lcp(int i,int j){\n        if(rank[i]>rank[j])swap(i,j);\n        return st.get_min(rank[i],rank[j]);\n    }\n};\n\nsigned main(){\n    string s;cin>>s;\n    suffix_array sa(s);\n    int q;cin>>q;\n    while(q--){\n        string t;\n        cin>>t;\n        cout<<sa.contain(t)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct node{\n\tint fail;\n\tbool vis;\n\tmap<char,int> nxt;\n};\n\nvector<node> trie;\n\nstring input(){\n\tstatic char buf[1000010];\n\tbuf[0] = 0;\n\tscanf(\"%s\", buf);\n\treturn buf;\n}\n\nint main(){\n\ttrie.assign(1, node());\n\ttrie[0].fail = -1;\n\n\tstring t = input();\n\tint q;\n\tscanf(\"%d\", &q);\n\tvector<int> idx(q);\n\tfor(int i = 0; i < q; ++i){\n\t\tstring p = input();\n\t\tint u = 0;\n\t\tfor(char c : p){\n\t\t\tif(!trie[u].nxt.count(c)){\n\t\t\t\ttrie[u].nxt.emplace(c, trie.size());\n\t\t\t\ttrie.emplace_back();\n\t\t\t}\n\t\t\tu = trie[u].nxt[c];\n\t\t}\n\t\tidx[i] = u;\n\t}\n\n\tvector<int> bfs;\n\tbfs.push_back(0);\n\tint k = 0;\n\twhile(k < (int)bfs.size()){\n\t\tint u = bfs[k++];\n\t\tfor(const auto &pr : trie[u].nxt){\n\t\t\tchar c = pr.first;\n\t\t\tint v = pr.second;\n\t\t\tbfs.push_back(v);\n\n\t\t\tint f = trie[u].fail;\n\t\t\twhile(f >= 0 && !trie[f].nxt.count(c)){\n\t\t\t\tf = trie[f].fail;\n\t\t\t}\n\t\t\ttrie[v].fail = f >= 0 ? trie[f].nxt[c] : 0;\n\t\t}\n\t}\n\n\tint r = 1;\n\tfor(char c : t){\n\t\twhile(r >= 0 && !trie[r].nxt.count(c)){\n\t\t\tr = trie[r].fail;\n\t\t}\n\t\tr = r >= 0 ? trie[r].nxt[c] : 0;\n\t\ttrie[r].vis = true;\n\t}\n\n\tfor(int i = bfs.size(); i--; ){\n\t\tint u = bfs[i];\n\t\tif(trie[u].vis){\n\t\t\ttrie[trie[u].fail].vis = true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < q; ++i){\n\t\tprintf(\"%d\\n\", +trie[idx[i]].vis);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n\n#define MAX_N 1000005\n\nusing namespace std;\nint k;\nunsigned long n;\nint ranks[MAX_N + 1];\nint tmp[MAX_N + 1];\nint sa[MAX_N + 1];\n\nbool compare_sa(int i, int j){\n    if(ranks[i] != ranks[j]){\n        return ranks[i] < ranks[j];\n    } else {\n        int ri =( i + k <= n )? ranks[i + k] : -1;\n        int rj =( j + k <= n )? ranks[j + k] : -1;\n        return ri < rj;\n    }\n    return true;\n}\n\nvoid construct_sa(string s,int* sa)\n{\n    n = s.length();\n    \n    for(int i = 0; i <= n;++i)\n    {\n        sa[i] = i;\n        ranks[i] = i < n ? s[i] : -1;\n    }\n    \n    for(k = 1;k <= n ; k *= 2)\n    {\n        sort(sa,sa + n + 1,compare_sa);\n        \n        tmp[sa[0]] = 0;\n        for(int i = 1; i <= n; ++i)\n        {\n            tmp[sa[i]] = tmp[sa[i -1]] + (compare_sa(sa[i - 1],sa[i]) ? 1 : 0);\n        }\n        for(int i = 0;i <= n;++i)\n        {\n            ranks[i] = tmp[i];\n        }\n    }\n}\n\nbool contain(string s,int* sa, string t)\n{\n    unsigned long a = 0;\n    unsigned long b = s.length();\n    while(b - a > 1)\n    {\n        unsigned long c = (a + b) / 2;\n        \n        if(s.compare(sa[c],t.length(),t) < 0) a = c;\n        else b = c;\n    }\n    \n    return (s.compare(sa[b], t.length(),t) == 0);\n    \n}\n\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    string S;\n    int N;\n    \n    cin >> S;\n    cin >> N;\n    \n    construct_sa(S,sa);\n    \n    for(int i = 0 ;i < N;++i)\n    {\n        string T;\n        cin >> T;\n        if(contain(S,sa,T)) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n  \n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define REPV(i, v, n) for (int i=0,tmp=v;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define DWN(i, b, a) for (int i=int(b-1);i>=int(a);--i)\n  \nusing namespace std;\n  \ntypedef unsigned char byte;\n  \nbyte mask[] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };\n#define tget(i) !!(t[(i)>>3]&mask[(i)&7])\n#define tset(i, b) t[(i)>>3]=(b) ? (mask[(i)&7]|t[(i)>>3]) : ((~mask[(i)&7])&t[(i)>>3])\n#define chr(i) (cs==sizeof(int)?((int*)s)[i]:((byte *)s)[i])\n#define isLMS(i) (i>0 && tget(i) && !tget(i-1))\n  \nvoid getBuckets(byte *s, int *bkt, int n, int K, int cs, bool end=true){\n  fill(bkt, bkt + K + 1, 0);\n  REP(i,n)bkt[chr(i)]++;\n  REPV(i, 0, K+1)tmp += bkt[i], bkt[i] = end ? tmp : tmp - bkt[i];\n}\n  \nvoid induceSAl(byte *t, int *SA, byte *s, int *bkt, int n, int K, int cs, bool end=false){\n  getBuckets(s, bkt, n, K, cs, end);\n  REP(i,n)if(SA[i]>0 && !tget(SA[i]-1)) SA[ bkt[chr(SA[i]-1)]++ ] = SA[i]-1;\n}\n  \nvoid induceSAs(byte *t, int *SA, byte *s, int *bkt, int n, int K, int cs, bool end=true){\n  getBuckets(s, bkt, n, K, cs, end);\n  DWN(i,n,0)if(SA[i]>0 && tget(SA[i]-1))SA[--bkt[chr(SA[i]-1)]] = SA[i]-1;\n}\n  \nvoid SA_IS(byte *s, int *SA, int n, int K=128, int cs=1) {\n  byte t[(n >> 3) + 1];\n  int bkt[K + 1],n1=0,name=0;\n    \n  tset(n-2, 0), tset(n-1, 1);\n  DWN(i,n-2,0)tset(i, (chr(i)<chr(i+1) || (chr(i)==chr(i+1) && tget(i+1))));\n  getBuckets(s, bkt, n, K, cs);\n  fill(SA, SA+n, -1);\n  FOR(i,1,n)if(isLMS(i))SA[--bkt[chr(i)]] = i;\n  \n  induceSAl(t, SA, s, bkt, n, K, cs);\n  induceSAs(t, SA, s, bkt, n, K, cs);\n    \n  REP(i,n)if(isLMS(SA[i]))SA[n1++] = SA[i];\n  fill(SA + n1, SA + n, -1);\n  \n  REPV(i,-1,n1){\n    int pos = SA[i], diff = false;\n    for(int d = 0; d < n && !diff; d++){\n      diff = chr(pos+d) != chr(tmp+d) || tget(pos+d) != tget(tmp+d);\n      if(!diff && d && (isLMS(pos+d) || isLMS(tmp+d)))break;\n    }\n    if(diff)name++,tmp=pos;\n    SA[ n1 + ((pos - (pos & 1)) >> 1) ] = name - 1;\n  }\n  int *s1 = SA + n - n1;\n  for(int i=n-1,j=n-1;i>=n1;i--)if(SA[i]>=0)SA[j--]=SA[i];\n  if(name < n1)SA_IS((byte*)s1, SA, n1, name - 1, sizeof(int));\n  else REP(i,n1)SA[s1[i]]=i;\n    \n  getBuckets(s, bkt, n, K, cs);\n  for(int i = 1, j = 0; i < n; i++)if(isLMS(i))s1[j++] = i;\n  REP(i,n1)SA[i]=s1[SA[i]];\n  fill(SA + n1, SA + n, -1);\n  \n  DWN(i,n1,0){\n    int tmp = SA[i];\n    SA[i] = -1, SA[--bkt[chr(tmp)]] = tmp;\n  }\n  induceSAl(t, SA, s, bkt, n, K, cs);\n  induceSAs(t, SA, s, bkt, n, K, cs);\n}\n  \nconst int maxn = 1000001;\nint n,sa[maxn];\n  \nbool contain(string S, int *sa, string T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n  \nchar a[maxn],b[maxn];\n  \nint main(void){\n  int q;\n  scanf(\"%s\", a);\n  string s = string(a);\n  SA_IS((byte*) s.c_str(), sa, s.size()+1);\n  \n  scanf(\"%d\", &q);\n  while(q--){\n    scanf(\"%s\", b);\n    if(contain(s, sa, string(b))) printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n\nusing namespace std;\n\nstring S; int Q; char STR[1005];\n\nint main()\n{\n\tcin >> S >> Q; cout << string::npos << endl;\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%s\", STR);\n\n\t\tif(S.find(STR) == -1)\n\t\t{\n\t\t    printf(\"0\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t    printf(\"1\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstruct SuffixArray {\n  vector< int > SA;\n  const string s;\n\n  SuffixArray(const string &str) : s(str) {\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](int a, int b) {\n      return s[a] == s[b] ? a > b : s[a] < s[b];\n    });\n    vector< int > classes(s.size()), c(s.begin(), s.end()), cnt(s.size());\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const {\n    return SA[k];\n  }\n\n  size_t size() const {\n    return s.size();\n  }\n\n  bool lt_substr(const string &t, int si = 0, int ti = 0) {\n    int sn = (int) s.size(), tn = (int) t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return true;\n      if(s[si] > t[ti]) return false;\n      ++si, ++ti;\n    }\n    return si >= sn && ti < tn;\n  }\n\n  int lower_bound(const string &t) {\n    int low = -1, high = (int) SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) / 2;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return high;\n  }\n\n  pair< int, int > lower_upper_bound(string &t) {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = (int) SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) / 2;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return {idx, high};\n  }\n\n  void output() {\n    for(int i = 0; i < size(); i++) {\n      cout << i << \": \" << s.substr(SA[i]) << endl;\n    }\n  }\n};\n\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string in;\n    cin >> in;\n    SuffixArray sfx(in);\n    int Q;\n    cin >> Q;\n    while(Q--) {\n        string sub;\n        cin >> sub;\n        pair<int, int> a = sfx.lower_upper_bound(sub);\n        //cerr << a.first << \" \" << a.second << endl;\n        if(a.first != a.second) cout << \"1\" << endl;\n        else cout << \"0\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\n\nstruct PMA{\n    PMA *next[256];\n    Vec matched;\n    PMA(){ fill(next,next+256,(PMA*)0); }\n};\n\nVec set_union(const Vec &a,const Vec &b){\n    int i = 0, j = 0, A = a.size(), B = b.size();\n    Vec res;\n    while(i < A && j < B){\n\tif(a[i] == b[j]){\n\t    res.push_back(a[i]);\n\t    i++; j++;\n\t}else if(a[i] > b[j]){\n\t    res.push_back(b[j++]);\n\t}else{\n\t    res.push_back(a[i++]);\n\t}\n    }\n    for( ; i < A ; i++) res.push_back(a[i]);\n    for( ; j < B ; j++) res.push_back(b[j]);\n    return res;\n}\n\nPMA *buildPMA(char *pattern[],int size){\n    PMA *root = new PMA;\n    for(int i = 0 ; i < size ; i++){\n\tPMA *t = root;\n\tfor(int j = 0 ; pattern[i][j] != '\\0' ; j++){\n\t    char c = pattern[i][j];\n\t    if(t->next[c] == NULL) t->next[c] = new PMA;\n\t    t = t->next[c];\n\t}\n\tt->matched.push_back(i);\n    }\n    queue<PMA*> Q;\n    for(int i = 'a' ; i <= 'z' ; i++){\n\tif(root->next[i]){\n\t    root->next[i]->next[0] = root;\n\t    Q.push(root->next[i]);\n\t}else{\n\t    root->next[i] = root;\n\t}\n    }\n    while(!Q.empty()){\n\tPMA *t = Q.front(); Q.pop();\n\tfor(int i = 'a' ; i <= 'z' ; i++){\n\t    if(t->next[i]){\n\t\tPMA *next = t->next[0];\n\t\twhile(!next->next[i]) next = next->next[0];\n\t\tt->next[i]->next[0] = next->next[i];\n\t\tt->next[i]->matched =\n\t\t    set_union(t->next[i]->matched,next->next[i]->matched);\n\t\tQ.push(t->next[i]);\n\t    }\n\t}\n    }\n    return root;\n}\n\nvoid match(PMA *pma,const char *s,Vec &res){\n    for(int i = 0 ; s[i] != '\\0' ; i++){\n\tint c = s[i];\n\twhile(!pma->next[c]) pma = pma->next[0];\n\tpma = pma->next[c];\n\tfor(int j = 0 ; j < (int)pma->matched.size() ; j++){\n\t    res[pma->matched[j]] = 1;\n\t}\n    }\n}\n\nchar T[1000001];\nchar *P[10000];\n\nint main(){\n    int Q;\n    scanf(\"%s%d\",T,&Q);\n    for(int i = 0 ; i < Q ; i++){\n\tP[i] = new char[1001];\n\tscanf(\"%s\",P[i]);\n    }\n    PMA *pma = buildPMA(P,Q);\n    Vec res(Q);\n    match(pma,T,res);\n    for(auto x : res){\n\tprintf(\"%d\\n\",x);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    vector<int> c(n+1,0),ord(n+1,0);\n    for(int i=0;i<=n;i++) ord[i]=n-i;\n    sort(ord.begin(),ord.end(),[&](int a,int b){return S[a]<S[b];});\n    \n    for(int i=0;i<=n;i++){\n      sa[i]=ord[i];\n      c[i]=i<n?S[i]:-1;\n    }\n    \n    for(int len=1;len<=n;len*=2){\n      vector<int> r=c;\n      for(int i=0;i<=n;i++){\n\t c[sa[i]] = i > 0 && r[sa[i - 1]] == r[sa[i]] && sa[i - 1] + len < n && r[sa[i - 1] + len / 2] == r[sa[i] + len / 2] ? c[sa[i - 1]] : i;\n      }\n      vector<int> cnt(n+1);\n      for(int i=0;i<=n;i++) cnt[i]=i;\n      vector<int> s=sa;\n      for(int i=0;i<=n;i++){\n\tint s1=s[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n    }\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n);\n    for(int i=0;i<n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nclass SuffixArray {\npublic:\n  string &s;\n  vector<int> sa;\n  int n;\n  SuffixArray(string &str) : s(str){\n    n = s.size();\n  }\n  void construct_sa(){\n    sa.resize(n+1);\n    vector<int> rank(n+1);\n    rep(i,n+1){\n      sa[i]=i;\n      rank[i] = (i<n)?s[i]:(-1);\n    }\n    for(int k=1; k<=n; k*=2){\n      function<bool(int,int)> comp = [&](int i, int j){\n        if(rank[i]!=rank[j]) return rank[i]<rank[j];\n        int ri = (i+k<=n)?(rank[i+k]):-1;\n        int rj = (j+k<=n)?(rank[j+k]):-1;\n        return ri < rj;\n      };\n      sort(all(sa), comp);\n      vector<int> tmp(n+1,0);\n      tmp[sa[0]]=0;\n      repl(i,1,n+1){\n        tmp[sa[i]] = tmp[sa[i-1]];\n        if(comp(sa[i-1], sa[i])) tmp[sa[i]]++;\n      }\n      swap(tmp, rank);\n    }\n  }\n  bool contain(const string &t){\n    int m = t.size();\n    int l = 0, r = n;\n    while(r-l>1){\n      int mid = (r+l)/2;\n      if(s.compare(sa[mid], m, t) < 0) l = mid;\n      else r = mid;\n    }\n    return s.compare(sa[r], m, t) == 0;\n  }\n};\n\nint main(){\n  string t;\n  int q;\n  cin>>t>>q;\n\n  SuffixArray sa(t);\n  sa.construct_sa();\n\n  rep(_,q){\n    string p;\n    cin>>p;\n    cout << sa.contain(p) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n\n#define MAX_N 1000005\n\nusing namespace std;\n\n\nint n,k;\nint rank[MAX_N + 1];\nint tmp[MAX_N + 1];\nint sa[MAX_N + 1];\n\n\nbool compare_sa(int i, int j)\n{\n\tif(rank[i] != rank[j]) \n\t{\n\t\treturn rank[i] < rank[j];\n\t}\n\telse\n\t{\n\tint ri =( i + k <= n )? rank[i + k] : -1;\n\tint rj =( j + k <= n )? rank[j + k] : -1;\n\treturn ri < rj;\n\t}\n}\n\nvoid construct_sa(string s,int* sa)\n{\n\tn = s.length();\n\t\n\tfor(int i = 0; i <= n;i++)\n\t{\n\t\tsa[i] = i;\n\t\trank[i] = i < n ? s[i] : -1;\n\t}\n\t\n\tfor(k = 1;k <= n ; k *= 2)\n\t{\n\t\tsort(sa,sa + n + 1,compare_sa);\n\t\t\n\t\ttmp[sa[0]] = 0;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\ttmp[sa[i]] = tmp[sa[i -1]] + (compare_sa(sa[i - 1],sa[i]) ? 1 : 0);\n\t\t}\n\t\tfor(int i = 0;i <= n;i++)\n\t\t{\n\t\t\trank[i] = tmp[i];\n\t\t}\n\t}\n}\n\nbool contain(string s,int* sa, string t)\n{\n\tint a = 0,b = s.length();\n\twhile(b - a > 1)\n\t{\n\t\tint c = (a + b) / 2;\n\t\t\n\t\tif(s.compare(sa[c],t.length(),t) < 0) a = c;\n\t\telse b = c;\n\t}\n\t\n\treturn (s.compare(sa[b], t.length(),t) == 0);\n\t\n}\n\n\nint main()\n{\n\tstring S;\n\tint N;\n\t\n\t\n\tcin >> S; \n\tcin >> N;\n\t\n\tconstruct_sa(S,sa);\n\t\n\tfor(int i = 0 ;i < N;i++)\n\t{\n\t\tstring T;\n\t\tcin >> T;\n\t\tif(contain(S,sa,T)) cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntemplate<typename S_Iter, typename SA_Iter>\nvoid induceSAL(S_Iter S_begin, S_Iter S_end, SA_Iter SA_begin, SA_Iter SA_end, const vector<bool> &t, uint32_t buckets_size) {\n    int32_t n = S_end - S_begin;\n    vector<int32_t> buckets(buckets_size+1, 0);\n    for (auto itr = S_begin; itr != S_end; itr++) buckets[*itr]++;\n\n    int32_t sum = 0;\n    for (uint32_t i = 0; i < buckets.size(); i++) {\n        sum += buckets[i];\n        buckets[i] = sum - buckets[i];\n    }\n\n    if (!t[n-1]) SA_begin[buckets[S_begin[n-1]]++] = n-1;\n\n    for (int32_t i = 0; i < n; i++) {\n        if (SA_begin[i] > 0 && !t[SA_begin[i]-1]) SA_begin[buckets[S_begin[SA_begin[i]-1]]++] = SA_begin[i]-1;\n    }\n\n    return;\n}\n\ntemplate<typename S_Iter, typename SA_Iter>\nvoid induceSAS(S_Iter S_begin, S_Iter S_end, SA_Iter SA_begin, SA_Iter SA_end, const vector<bool> &t, uint32_t buckets_size) {\n    int32_t n = S_end - S_begin;\n    vector<int32_t> buckets(buckets_size+1, 0);\n    for (auto itr = S_begin; itr != S_end; itr++) buckets[*itr]++;\n    partial_sum(buckets.begin(), buckets.end(), buckets.begin());\n\n    for (int32_t i = n-1; i > 0; i--) {\n        if (SA_begin[i] > 0 && t[SA_begin[i]-1]) SA_begin[--buckets[S_begin[SA_begin[i]-1]]] = SA_begin[i]-1;\n    }\n\n    return;\n}\n\ntemplate<typename S_Iter, typename SA_Iter>\nvoid SA_IS(S_Iter S_begin, S_Iter S_end, SA_Iter SA_begin, SA_Iter SA_end, uint32_t buckets_size) {\n    int32_t n = S_end - S_begin;\n    fill(SA_begin, SA_end, -1);\n\n    // classify the type of each character\n    // true <=> S-type\n    vector<bool> t(n);\n    for (int32_t i = n; i >= 0; i--) {\n        t[i] = S_begin[i] < S_begin[i+1] || (S_begin[i] == S_begin[i+1] && t[i+1]);\n    }\n\n    auto is_lms = [&t](int32_t i){return i > 0 && !t[i-1] && t[i];};\n\n    // sort all the S-substrings\n    vector<int32_t> buckets(buckets_size+1, 0);\n    for (auto itr = S_begin; itr != S_end; itr++) buckets[*itr]++;\n    partial_sum(buckets.begin(), buckets.end(), buckets.begin());\n    for (int32_t i = 0; i < n; i++) {\n        if (is_lms(i)) SA_begin[--buckets[S_begin[i]]] = i;\n    }\n    induceSAL(S_begin, S_end, SA_begin, SA_end, t, buckets_size);\n    induceSAS(S_begin, S_end, SA_begin, SA_end, t, buckets_size);\n\n    // compact all the sorted substrings into the first nl items of SA\n    auto lms_end = remove_if(SA_begin, SA_end, [is_lms](int32_t x){return !is_lms(x);});\n    fill(lms_end, SA_end, -1);\n    int32_t nl = lms_end - SA_begin;\n\n    // find the lexicographic names of substrings\n    int32_t name = 0;\n    for (auto itr = SA_begin; itr != lms_end; itr++) {\n        if (itr == SA_begin) {\n            lms_end[*itr/2] = name;\n        } else {\n            int32_t cur = *itr, prev = *(itr - 1);\n            bool miss = S_begin[cur] != S_begin[prev] || t[cur] != t[prev];\n            if (!miss) do {\n                ++cur; ++prev;\n                miss |= cur == n ||\n                        prev == n ||\n                        S_begin[cur] != S_begin[prev] ||\n                        t[cur] != t[prev];\n            } while (!miss && !(cur > 0 && !t[cur-1] && t[cur]) && !(prev > 0 && !t[prev-1] && t[prev]));\n\n            if (miss) ++name;\n            lms_end[*itr/2] = name;\n        }\n    }\n    remove_if(reverse_iterator<decltype(SA_end)>(SA_end), reverse_iterator<decltype(SA_begin)>(SA_begin) - nl, [](int32_t i) {return i < 0;});\n\n    // solve the reduced problem\n    auto S1_begin = SA_end - nl, S1_end = SA_end;\n    auto SA1_begin = SA_begin, SA1_end = SA_begin + nl;\n    if (name + 1 < nl) {\n        SA_IS(S1_begin, S1_end, SA1_begin, SA1_end, nl);\n    } else {\n        for (int32_t i = 0; i < nl; i++) {\n            SA1_begin[S1_begin[i]] = i;\n        }\n    }\n\n    // induce the result for the original problem\n    fill(buckets.begin(), buckets.end(), 0);\n    for (auto itr = S_begin; itr != S_end; itr++) buckets[*itr]++;\n    partial_sum(buckets.begin(), buckets.end(), buckets.begin());\n\n    for (int32_t i = 1, j = 0; i < n; i++) {\n        if (is_lms(i)) S1_begin[j++] = i;\n    }\n    for (int32_t i = 0; i < nl; i++) SA1_begin[i] = S1_begin[SA1_begin[i]];\n    fill(lms_end, SA_end, -1);\n    for (int32_t i = nl-1; i >= 0; i--) {\n        int32_t j = SA_begin[i];\n        SA_begin[i] = -1;\n        SA_begin[--buckets[S_begin[j]]] = j;\n    }\n    induceSAL(S_begin, S_end, SA_begin, SA_end, t, buckets_size);\n    induceSAS(S_begin, S_end, SA_begin, SA_end, t, buckets_size);\n\n    return;\n}\n\nint main() {\n    string T;\n    cin >> T;\n\n    int32_t Q;\n    cin >> Q;\n\n    vector<int32_t> SA(T.length());\n    SA_IS(T.begin(), T.end(), SA.begin(), SA.end(), UINT8_MAX);\n\n    for (int32_t i = 0; i < Q; i++) {\n        string P;\n        cin >> P;\n\n        auto itr_lb = lower_bound(SA.begin(), SA.end(), P, [T](uint32_t i, string s) {return T.substr(i, T.length()-i) < s;});\n        auto itr_ub = upper_bound(itr_lb, SA.end(), P, [T](string s, uint32_t i) {return s < T.substr(i, T.length()-i).substr(0, s.length());});\n\n        cout << (itr_ub - itr_lb > 0 ? '1' : '0') << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define MAX_T 1000001\n#define MAX_P 1001\ntypedef vector<int> Vec;\n \nVec build_fail(const char *s){\n    int N = strlen(s);\n    Vec fail(N+1);\n    int j = fail[0] = -1;\n    for(int i = 1 ; i <= N ; i++){\n        while(j >= 0 && s[j] != s[i-1]) j = fail[j];\n        fail[i] = ++j;\n    }\n    return fail;\n}\n \nint match(const char *t,const char *p,const Vec &fail){\n    int n = strlen(t),m = strlen(p),res = 0;\n    for(int i = 0, k = 0 ; i < n ; i++){\n        while(k >= 0 && p[k] != t[i]) k = fail[k];\n        if(++k >= m){\n            res++;\n            k = fail[k];\n        }\n    }\n    return res;\n}\n\nint main(){\n    int Q,M;\n    char T[MAX_T],P[MAX_P];\n    scanf(\"%s %d\",T, &Q);\n    Vec fail = build_fail(T);\n    while(Q--){\n        scanf(\"%s\",P);\n        M = strlen(P);\n        cout << (match(T,P,fail) == M+1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// ----- SuffixArray -----\n\nclass SuffixArray\n{\n  int N, K;\n  string S;\n  vector<int> sa;\n\npublic:\n  SuffixArray(string S) : N{static_cast<int>(S.size())}, K{1}, S{S}, sa(N + 1)\n  {\n    // initialize for 1 char\n    for (auto i = 0; i <= N; i++)\n    {\n      sa[i] = i;\n    }\n    vector<int> rank(N + 1);\n    for (auto i = 0; i < N; i++)\n    {\n      rank[i] = static_cast<int>(S[i]);\n    }\n    rank[N] = -1;\n    // lambda for comparing\n    auto compare_sa = [&](auto i, auto j) {\n      if (rank[i] != rank[j])\n      {\n        return rank[i] < rank[j];\n      }\n      else\n      {\n        int ri{i + K <= N ? rank[i + K] : -1};\n        int rj{j + K <= N ? rank[j + K] : -1};\n        return ri < rj;\n      }\n    };\n    // construct sa with rank\n    vector<int> tmp(N + 1);\n    for (; K <= N; K *= 2)\n    {\n      sort(sa.begin(), sa.end(), compare_sa);\n      tmp[sa[0]] = 0;\n      for (auto i = 1; i <= N; i++)\n      {\n        tmp[sa[i]] = tmp[sa[i - 1]] + (compare_sa(sa[i - 1], sa[i]) ? 1 : 0);\n      }\n      swap(rank, tmp);\n    }\n  }\n\n  int operator[](int i) const\n  {\n    return sa[i];\n  }\n\n  int lower_bound(string const &T) const\n  {\n    int a{-1}, b{N + 1};\n    auto cmp = [&](auto c) {\n      return S.compare(sa[c], T.size(), T) < 0;\n    };\n    binary_search(a, b, cmp);\n    return b;\n  }\n\n  int upper_bound(string const &T) const\n  {\n    int a{-1}, b{N + 1};\n    auto cmp = [&](auto c) {\n      return S.compare(sa[c], T.size(), T) <= 0;\n    };\n    binary_search(a, b, cmp);\n    return a;\n  }\n\n  bool contain(string const &T) const\n  {\n    int b{lower_bound(T)};\n    return b <= N && S.compare(sa[b], T.size(), T) == 0;\n  }\n\n  int count(string const &T) const\n  {\n    int lb{lower_bound(T)};\n    int ub{upper_bound(T)};\n    if (lb > ub)\n    {\n      return 0;\n    }\n    return ub - lb + 1;\n  }\n\nprivate:\n  template <typename T>\n  void binary_search(int &a, int &b, T cmp) const\n  {\n    while (abs(a - b) > 1)\n    {\n      int c{(a + b) / 2};\n      if (cmp(c))\n      {\n        a = c;\n      }\n      else\n      {\n        b = c;\n      }\n    }\n  }\n};\n\n// ----- main() -----\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D&lang=ja\n\nvoid solve()\n{\n  string S;\n  int Q;\n  cin >> S >> Q;\n  vector<string> T(Q);\n  for (auto i = 0; i < Q; i++)\n  {\n    cin >> T[i];\n  }\n  SuffixArray sa(S);\n  for (auto i = 0; i < Q; i++)\n  {\n    cout << (sa.contain(T[i]) ? 1 : 0) << endl;\n  }\n}\n\nint main()\n{\n  solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n \nusing namespace std;\n \nint n, k;\nstring s;\nvector<int> order;\nvector<int> tmp;\nvector<int> sa;\n \nbool compare_sa(const int &i, const int &j)\n{\n  if(order[i] != order[j]) return order[i] < order[j];\n  else\n  {\n    int ri = i + k <= n ? order[i+k] : -1;\n    int rj = j + k <= n ? order[j+k] : -1;\n    return ri < rj;\n  }\n}\n \nvoid construct_sa()\n{\n  for(int i = 0; i <= n; i++)\n  {\n    sa[i] = i;\n    order[i] = i < n ? s[i] : -1;\n  }\n  for(k = 1; k <= n; k*=2)\n  {\n    sort(sa.begin(),sa.end(),compare_sa);\n    tmp[sa[0]] = 0;\n    for(int i = 1; i <= n; i++)\n      tmp[sa[i]] = tmp[sa[i-1]] + (compare_sa(sa[i-1],sa[i])?1:0);\n    for(int i = 0; i <= n; i++)\n      order[i] = tmp[i];\n  }\n}\n \nvoid init()\n{\n  n = s.size();\n  order.resize(n+1);\n  tmp.resize(n+1);\n  sa.resize(n+1);\n  construct_sa();\n}\n \nbool contain(string t)\n{\n  int l=0, r=n;\n  while(r-l>1)\n  {\n    int m = (l+r)/2;\n    if(s.compare(sa[m],t.size(),t)<0) l = m;\n    else r = m;\n  }\n  return s.compare(sa[r],t.size(),t) == 0;\n}\n \nint main(){\n \n    cin >> s;\n    string t;\n    int q ; cin >> q;\n    init();\n    construct_sa ();\n    for (int i = 0; i < q; ++i)\n     {\n        cin >> t;\n        cout << contain(t) << endl;\n     } \n     return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstring> //memcpy\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <map>\n//#include <unordered_map> //hash func.\n#include <fstream> //ifstream, ofstream\n#include <iterator> //insert_iterator::inserter\n\n\n//#define NDEBUG //If NDEBUG is defined before #include <cassert>, assert will be ignored. You had better define NDEBUG when u submit the code.\n#include <cassert> //assert\n\nusing namespace std;\n\n\n#define dout cout\n//If u wanna output to a text file instead of standard output, plz define OUTPUTFILE.\n//#define OUTPUTFILE \"output.txt\" //*******************************************************************************************************************************************\n#ifdef OUTPUTFILE\n#define dout outputfile\nofstream outputfile(OUTPUTFILE);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n\n#define din cin\n//If u wanna input from a text file instead of standard input, plz define INPUTFROMTEXTFILE???.\n//#define INPUTFILE \"input.txt\" //*******************************************************************************************************************************************\n#ifdef INPUTFILE\n#define din inputfile\nifstream inputfile(INPUTFILE);\n#endif\n\n#define scan(A) scanf(\"%d\", &(A))\n#define disp(A) dout << #A << \" = \" << setw(3) << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \"\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n//#define dispAll(A,n) cout << #A << \" = \"; rep(j, 0, (n)) {cout << setw(3) << A[j] << \" \";} cout << endl\n\n#define sign(x) ((x)>0)-((x)<0) //x<0: -1, x=0: 0, x>0: +1\n#define p(i) (i)/2\n#define l(i) (i)*2\n#define r(i) (i)*2+1\n\nint dx[] = {1,-1, 0, 0, 1, 1,-1,-1}; //???????????????????????????????¨??????????????????????????????????\nint dy[] = {0, 0,-1, 1,-1, 1, 1,-1};\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef unsigned long ull;\n\nconst int INF = (int)2e9+10;\nconst ll INF_LL = (ll)9e18-1LL; //Be careful for overflow.\nconst ull INF_ULL = (ull)1e19-1ULL;\nconst int NONE = -1;\nconst ll MOD = (ll)1e9+7; //??§???????´???°?????£??¨??¨????????°????????????10???7??????\n\nconst int N_MAX = 1000010; //num of vertex or element\nconst int M_MAX = 10010; //num of edge\nconst int DATA_MAX = 1010;\n\nint N;\n\nchar T[N_MAX];\nchar* P[M_MAX];\nvi placeOfP[M_MAX];\n\n\nstruct PMA { //Pattern Matching Automaton\n#ifdef debug\n    string str = \"\";\n#endif\n    PMA* next[128]; //next[0] = failure link\n    vi accept;\n    \n    PMA() { fill(next, next+128, (PMA*)0); }\n};\n\n\nvi set_union(const vi &a, const vi &b) {\n    vi res;\n    set_union(a.begin(), a.end(), b.begin(), b.end(), back_inserter(res) );\n    return res;\n}\n\n\n\nPMA* buildPMA(char* P[], int numOfP) {\n    PMA* root = new PMA;\n#ifdef debug\n    root->str = \"root \";\n#endif\n    \n    //construct PMA according to P[i]\n    rep(i,0,numOfP) {\n        PMA* t = root;\n        \n        for (int j=0; P[i][j]; j++) {\n            char c = P[i][j];\n            if(t->next[c]==NULL) {\n                t->next[c] = new PMA;\n#ifdef debug\n                t->next[c]->str = t->str + c;\n#endif\n            }\n            t = t->next[c];\n        }\n        \n        t->accept.push_back(i);\n    }\n    \n    \n    //make failure link for all node using BFS\n    queue<PMA*> Q;\n    \n    //failure link of root's child ---> root\n    rep(c,'0','z'+1) {\n        if(root->next[c]!=NULL) {\n            root->next[c]->next[0] = root;\n            Q.push(root->next[c]);\n        }\n        else root->next[c] = root; //all other character except for P[] ---> root\n    }\n    \n    //BFS\n    while(!Q.empty()) {\n        \n        PMA* now = Q.front(); Q.pop();\n        \n        rep(c,'0','z'+1) {\n            if(now->next[c]!=NULL) {\n                Q.push(now->next[c]);\n                \n                PMA* failure = now->next[0];\n                while(failure->next[c]==NULL) failure = failure->next[0]; //c??????????????????????????§failure link?????????\n                \n                now->next[c]->next[0] = failure->next[c]; //now->next[c]???failure link?????????\n                now->next[c]->accept = set_union(now->next[c]->accept, failure->next[c]->accept); //now->next[c]????????????????????????failure link?????????????????????????¶????\n            }\n        }\n    }\n    \n    return root;\n}\n\n\n\nvoid match(PMA* v, char *text, vi result[]) {\n    \n    int lenT = strlen(text);\n    \n    rep(i,0,lenT) {\n        char c = text[i];\n        \n        while(v->next[c]==NULL) {\n            v = v->next[0];\n        }\n        \n        v = v->next[c];\n        \n        rep(j,0,v->accept.size()) {\n            result[v->accept[j]].push_back(i+1-strlen(P[v->accept[j]]));\n        }\n    }\n    \n    return;\n}\n\n\n\nvoid display_DFS(PMA* r) {\n    \n    dout << \"-----\\n\";\n    disp(r->str);\n    \n    dout << \"accept = \";\n    rep(i,0,r->accept.size()) {\n        dout << r->accept[i] << \" \";\n    }\n    dout << endl;\n    \n    rep(c,'0','z'+1) {\n        if(r->next[c]!=NULL && r->next[c]!=r) {\n            display_DFS(r->next[c]);\n        }\n    }\n}\n\n\nint main() {\n    \n    //cin, cout????????????  ?????¨??????cin?????????????????¨??¨cin??§???scanf?????????????????¨??¨scanf??§??±?????????????????????\n    cin.tie(0); //cin??¨cout??????????????????\n    ios::sync_with_stdio(false); //iostream??¨stdio??????????????????\n    \n    //read input data\n    scanf(\"%s\", T);\n    \n    int Q;\n    scanf(\"%d \", &Q);\n    rep(i,0,Q) {\n        P[i] = (char *)malloc(sizeof(char)*DATA_MAX);\n        scanf(\"%s\", P[i]);\n    }\n    \n#ifdef debug\n    disp(T);\n    disp(strlen(T));\n    rep(i,0,Q) { disP(P[i]); disp(strlen(P[i])); }\n#endif\n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //start timer\n    auto startTime = chrono::system_clock::now();\n#endif\n    //------------------------------------------------------------------------------------------\n    \n    \n    //Aho-Corasick Algorithm\n    PMA* root = buildPMA(P, Q);\n    \n#ifdef debug\n    display_DFS(root);\n#endif\n    \n    \n    match(root, T, placeOfP);\n    \n#ifdef debug\n    dout << \"=====================================\\n\";\n    rep(i,0,Q) {\n        disP(P[i]); dout << \" : \";\n        rep(j,0,placeOfP[i].size()) {\n            disP(placeOfP[i][j]);\n        }\n        dout << endl;\n    }\n    dout << \"=====================================\\n\";\n#endif\n    \n    rep(i,0,Q) {\n        printf(\"%d\\n\", placeOfP[i].size()!=0);\n    }\n    \n    \n\n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //stop timer\n    auto endTime = chrono::system_clock::now();\n    auto dur = endTime - startTime;\n    auto msec = chrono::duration_cast<chrono::milliseconds>(dur).count();\n    dout << fixed << setprecision(4) << (double)msec/1000 << \" sec \\n\";\n#endif\n    //------------------------------------------------------------------------------------------\n    \n#ifdef INPUTFILE\n    inputfile.close();\n#endif\n    \n#ifdef OUTPUTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    //const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    //const int k=lcp2(i,j,0,(n-max(i,j))*2+1);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  inline bool cmp(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    //const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    //const int k=lcp2(i,j,0,(n-max(i,j))*2+1);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n  */\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    //int l=0,r=min(n-i,n-j)+1;\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n  \n  /*\n  inline int lcp2(const int& i, const int& j, const int& l, const int& r){\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n  */\n};\n/*\nvoid quicksort(vector<int> &a, const int& l, const int& r, const RollingHash &rh) {\n  if (rh.cmp(l,r)) {\n    int p = a[(l+r)/2];\n    int i = l-1, j = r+1;\n    while (1) {\n      while (a[++i] < p);\n      while (a[--j] > p);\n      if (i >= j) break;\n      swap(a[i], a[j]);\n    }\n    quicksort(a, l, i-1,rh);\n    quicksort(a, j+1, r,rh);\n  }\n}\nvoid quicksort(vector<int> &a, const RollingHash& rh) {\n  quicksort(a, 0, a.size()-1,rh);\n}\n*/\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\n  //quicksort(sa,rh);\nif(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\n#define NUM 48\nusing namespace std;\n\nint T_char_count[128] = {0},P_char_count[128];\n\nclass LocRecord{\n\npublic:\n\t//?????¢???????¢????\n\tLocRecord(){\n\t\tlocationTable = new int*[128];\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t}\n\n\t//-1?????£??\\\n\tvoid init(){\n\t\tint limit;\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init_index(){\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t}\n\n\tvoid regist_loc(int ch, int location){\n\t\tlocationTable[ch][index[ch]] = location;\n\t\tindex[ch]++;\n\t}\n\n\tint next_loc(int ch){\n\t\tint ret = locationTable[ch][index[ch]];\n\t\tindex[ch]++;\n\t\treturn ret;\n\t}\n\nprivate:\n\tint** locationTable;\n\tint index[128];\n};\n\nint main(){\n\n\tfor(int i = 0; i < 128; i++)T_char_count[i] = 0;\n\n\tint length;\n\n\tchar* T = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tfor(length = 0; T[length] != '\\0';length++){\n\t\tT_char_count[T[length]]++;\n\t}\n\n\tLocRecord locRecord;\n\tlocRecord.init();\n\n\t//T[i]????????????i??§???????????¨????¨????\n\tfor(int i = 0; i < length; i++){\n\t\tlocRecord.regist_loc(T[i],i);\n\t}\n\n\tull* HASH = new ull[length+1];\n\tull* P = new ull[length+1];\n\n\tHASH[0] = 0;\n\tP[0] = 1;\n\n\t//T??????????????\\???????±???????\n\tfor(int i = 1; i <= length; i++){\n\t\tHASH[i] = T[i-1] + HASH[i-1]*MOD;\n\t\tP[i] = P[i-1]*MOD;\n\t}\n\n\tint Q,S_length,left,P_char_count[128];\n\tscanf(\"%d\",&Q);\n\n\tchar S[1001];\n\tull S_HASH[1001],S_value,T_value;\n\tbool FLG;\n\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",S);\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tP_char_count[i] = 0;\n\t\t}\n\n\t\tfor(S_length = 0;S[S_length] != '\\0';S_length++){\n\t\t\tP_char_count[S[S_length]]++;\n\t\t}\n\n\t\tFLG = true;\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tif(T_char_count[i] < P_char_count[i]){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG)continue;\n\n\n\t\tS_HASH[0] = 0;\n\t\tfor(int i = 1; i <= S_length; i++){\n\t\t\tS_HASH[i] = S[i-1] + S_HASH[i-1]*MOD;\n\t\t}\n\n\t\tS_value = S_HASH[S_length];\n\n\t\tlocRecord.init_index();\n\n\t\tFLG = false;\n\n\t\twhile((left = locRecord.next_loc(S[0])) != -1){\n\t\t\tif(left+S_length-1>=length)break;\n\n\t\t\tT_value = HASH[left+S_length]-HASH[left]*P[S_length];\n\n\t\t\tif(T_value == S_value){\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(FLG){\n\t\t\tprintf(\"1\\n\");\n\t\t}else{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string& S):S(S){init();}\n  void init(){\n    n=S.length();\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    sa.clear();\n    sa.resize(n+1,0);\n    S.push_back('$');\n    iota(sa.begin(),sa.end(),0);\n    sort(sa.begin(),sa.end(),\n\t [&](int a,int b){\n\t   if(S[a]==S[b]) return a>b;\n\t   return S[a]<S[b];\n\t });\n    vector<int> c(n+1,0),r(n+1),cnt(n+1),s(n+1);\n    for(int i=0;i<=n;i++) r[i]=S[i];\n    for(int len=1;len<=n;len*=2){\n      for(int i=0;i<=n;i++){\n\t c[sa[i]]=\n\t   i>0 &&\n\t   r[sa[i-1]]==r[sa[i]] &&\n\t   sa[i-1]+len<=n &&\n\t   r[sa[i-1]+len/2]==r[sa[i]+len/2] ?\n\t   c[sa[i-1]]:i;\n      }\n      iota(cnt.begin(),cnt.end(),0);\n      copy(sa.begin(),sa.end(),r.begin());\n      for(int i=0;i<=n;i++){\n\tint s1=r[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n      c.swap(r);\n    }\n    S.pop_back();\n  }\n  \n  // O(|T|*log|S|)\n  pair<int,int> count(string& T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\tif(S.compare(sa[c],tl,T)<0||\n\t   (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n\telse b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return make_pair(0,0);\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return make_pair(b[0],a[1]+1);\n  }\n  \n  bool contains(string& T){\n    auto tmp=count(T);\n    return tmp.first!=tmp.second;\n  }\n  \n  void build_lcp(){\n    lcp.clear();\n    lcp.resize(n+1,0);\n    vector<int> r2(n+1);\n    for(int i=0;i<=n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  pair<int,int> count2(string& T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return make_pair(0,0);\n\n    return make_pair(b[0],a[1]+1);\n  }\n\n  bool contains2(string& T){\n    auto tmp=count2(T);\n    return tmp.first!=tmp.second;\n  }\n};\n//END CUT HERE\n\n\n//*//\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    auto tmp=sa.count2(P);\n    printf(\"%d\\n\",tmp.first!=tmp.second);\n    //assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n//*/\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/\n\n/*/\nchar buf[1145141];\nsigned main(){\n  int n;\n  scanf(\"%d\",&n);\n  int m;\n  scanf(\"%d\",&m);\n  scanf(\"%s\",buf);\n  string s(buf);\n  SuffixArray sa(s);\n  string t=\"I\";\n  for(int i=0;i<n;i++) t=t+\"OI\";\n  auto tmp=sa.count(t);\n  printf(\"%d\\n\",tmp.second-tmp.first);\n  return 0;\n}\n//*/\n/*\n  verified on 2017/10/20\nhttp://joi2009ho.contest.atcoder.jp/tasks/joi2009ho_a\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <map>\n#include <new>\n#include <deque>\n#include <functional>\nusing namespace std;\n\ntemplate <class T>\nstruct myalloc{\n\tusing value_type = T;\n\n\tstatic const int num = 1024;\n\tstatic int k;\n\tstatic deque<vector<char>> dq;\n\n\tmyalloc(){}\n\ttemplate <class U>\n\tmyalloc(const myalloc<U> &){}\n\n\tT* allocate(size_t n){\n\t\tif(k >= num || dq.empty()){\n\t\t\tdq.emplace_back(num * sizeof(T));\n\t\t\tk = 0;\n\t\t}\n\t\treturn reinterpret_cast<T*>(&dq.back()[k++ * sizeof(T)]);\n\t}\n\n\tvoid deallocate(T*, size_t){}\n};\n\ntemplate <class T>\nint myalloc<T>::k;\ntemplate <class T>\ndeque<vector<char>> myalloc<T>::dq;\n\nstruct node{\n\tint fail;\n\tbool vis;\n\tmap<char,int,less<char>,myalloc<char>> nxt;\n};\n\nvector<node> trie;\n\nstring input(){\n\tstatic char buf[1000010];\n\tbuf[0] = 0;\n\tscanf(\"%s\", buf);\n\treturn buf;\n}\n\nint main(){\n\ttrie.reserve(1000010);\n\n\ttrie.emplace_back();\n\ttrie[0].fail = -1;\n\n\tstring t = input();\n\tint q;\n\tscanf(\"%d\", &q);\n\tvector<int> idx(q);\n\tfor(int i = 0; i < q; ++i){\n\t\tstring p = input();\n\t\tint u = 0;\n\t\tfor(char c : p){\n\t\t\tif(!trie[u].nxt.count(c)){\n\t\t\t\ttrie[u].nxt.emplace(c, trie.size());\n\t\t\t\ttrie.emplace_back();\n\t\t\t}\n\t\t\tu = trie[u].nxt[c];\n\t\t}\n\t\tidx[i] = u;\n\t}\n\n\tvector<int> bfs;\n\tbfs.push_back(0);\n\tint k = 0;\n\twhile(k < (int)bfs.size()){\n\t\tint u = bfs[k++];\n\t\tfor(const auto &pr : trie[u].nxt){\n\t\t\tchar c = pr.first;\n\t\t\tint v = pr.second;\n\t\t\tbfs.push_back(v);\n\n\t\t\tint f = trie[u].fail;\n\t\t\twhile(f >= 0 && !trie[f].nxt.count(c)){\n\t\t\t\tf = trie[f].fail;\n\t\t\t}\n\t\t\ttrie[v].fail = f >= 0 ? trie[f].nxt[c] : 0;\n\t\t}\n\t}\n\n\tint r = 0;\n\tfor(char c : t){\n\t\twhile(r >= 0 && !trie[r].nxt.count(c)){\n\t\t\tr = trie[r].fail;\n\t\t}\n\t\tr = r >= 0 ? trie[r].nxt[c] : 0;\n\t\ttrie[r].vis = true;\n\t}\n\n\tfor(int i = bfs.size(); --i; ){\n\t\tint u = bfs[i];\n\t\tif(trie[u].vis){\n\t\t\ttrie[trie[u].fail].vis = true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < q; ++i){\n\t\tprintf(\"%d\\n\", +trie[idx[i]].vis);\n\t}\n\n\ttrie.clear();\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> dat;\nvector<int> tmp;\n\nint doubles, lengths;\n\nbool compare_suffix(int i, int j)\n{\n\tif (dat[i] == dat[j])\n\t{\n\t\tint ri = (i + doubles <= lengths ? dat[i + doubles] : -1);\n\t\tint rj = (j + doubles <= lengths ? dat[j + doubles] : -1);\n\n\t\treturn ri < rj;\n\t}\n\n\treturn dat[i] < dat[j];\n}\n\nvector<int> suffix_array(string S)\n{\n\tlengths = S.size();\n\n\tvector<int> arrays(lengths + 1);\n\n\tdat.resize(lengths + 1);\n\ttmp.resize(lengths + 1);\n\n\tfor (int i = 0; i <= lengths; i++)\n\t{\n\t\tarrays[i] = i;\n\n\t\tdat[i] = i < lengths ? S[i] : -1;\n\t}\n\n\tfor (doubles = 1; doubles <= lengths; doubles <<= 1)\n\t{\n\t\tsort(arrays.begin(), arrays.begin() + lengths + 1, compare_suffix);\n\n\t\ttmp[arrays[0]] = 0;\n\n\t\tfor (int i = 1; i <= lengths; i++)\n\t\t{\n\t\t\ttmp[arrays[i]] = tmp[arrays[i - 1]] + (compare_suffix(arrays[i - 1], arrays[i]) ? 1 : 0);\n\t\t}\n\n\t\tfor (int i = 0; i <= lengths; i++)\n\t\t{\n\t\t\tdat[i] = tmp[i];\n\t\t}\n\t}\n\n\treturn arrays;\n}\n\nint main()\n{\n\tstring S, T; int Q;\n\t\n\tcin >> S;\n\n\tvector<int> sa = suffix_array(S);\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tcin >> T;\n\n\t\tint l = 0;\n\t\tint r = sa.size();\n\n\t\tbool flag = false;\n\n\t\twhile (r - l > 1)\n\t\t{\n\t\t\tint m = (l + r) / 2;\n\n\t\t\tstring S1 = S.substr(sa[m], T.size());\n\n\t\t\tif (S1 == T)\n\t\t\t{\n\t\t\t\tflag = true; break;\n\t\t\t}\n\t\t\t\n\t\t\tif (S1 < T)\n\t\t\t{\n\t\t\t\tl = m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = m;\n\t\t\t}\n\t\t}\n\n\t\tif (flag)\n\t\t{\n\t\t\tprintf(\"1\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define INF 1 << 30\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntypedef complex<double> dcomplex;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\nll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\n\nint n;\nstring s;\n\nbool solve(string t)\n{\n  int m = t.size();\n  map<char,int> f;\n  DOWN(i,m-1,0) f[t[i]] = i;\n  int p = m-1;\n  while(p<n)\n  {\n    int k = m-1;\n    while(k >= 0 && t[k] == s[p]) {k--; p--;}\n    if(k == -1) return true;\n    else p += max(f[s[p]],m-k);\n  }\n  return false;\n}\n\nint main()\n{\n  cin >> s;\n  n = s.size();\n  int q; cin >> q;\n  REP(i,q)\n  {\n    string t; cin >> t;\n    cout << solve(t) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S 2500005\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\nstruct d{\n  int a,b,c;\n  d(){}\n  d(int A,int B,int C){\n    a=A,b=B,c=C;\n  };\n  bool operator<(const d&r)const{\n    if(a!=r.a)return a<r.a;\n    return b<r.b;\n  }\n};\n\nint n,slen,tlen,r[S];\nchar s[S],t[N];\nd ran[S];\nP a[S];\n\nvoid init(){\n\n  for(int j=0;j<slen;j++)r[j]=s[j];\n\n  int x=1;\n  r[slen]=0;\n  while(1){\n    for(int i=0;i<slen;i++){\n      int o=i+x;\n      if(o>slen)o=slen;\n      ran[i]=d(r[i],r[o],i);\n    }\n    sort(ran,ran+slen);\n    int cnt=0;\n    for(int i=0;i<slen;i++){\n      r[ran[i].c]=cnt;\n      if(ran[i].a==ran[i+1].a&&ran[i].b==ran[i+1].b)\n\tcontinue;\n      cnt++;\n    }\n    if(x>slen)break;\n    x*=2;\n  }\n  for(int i=0;i<slen;i++)a[i]=P(r[i],i);\n  sort(a,a+slen);\n}\n\nbool bynary_search(){\n  int L=0,R=slen;\n  while(L<R){\n    int M=(L+R)/2;\n    if(strncmp(s+a[M].second,t,tlen)<0)L=M+1;\n    else R=M;\n  }\n  if(!strncmp(s+a[L].second,t,tlen))return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s%d\",s,&n);\n  slen=strlen(s);\n  init();  \n  while(n--){\n    scanf(\"%s\",t);\n    tlen=strlen(t);\n    if(bynary_search())printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nclass StringSearch {\n\tconst int n;\n\tstring S;\n\tvector<int> SA, Rank;\npublic:\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), SA(n + 1), Rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tSA[i] = i;\n\t\t\tRank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (Rank[i] != Rank[j]) return Rank[i] < Rank[j];\n\t\t\t\telse {\n\t\t\t\t\tint ri = i + k <= n ? Rank[i + k] : -1;\n\t\t\t\t\tint rj = j + k <= n ? Rank[j + k] : -1;\n\t\t\t\t\treturn ri < rj;\n\t\t\t\t}\n\t\t\t};\n\t\t\tsort(SA.begin(), SA.end(), Compare_SA);\n\n\t\t\ttmp[SA[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[SA[i]] = tmp[SA[i - 1]] + (Compare_SA(SA[i - 1], SA[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tRank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(SA[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(SA[b], T.length(), T) == 0;\n\t}\n};\n\nint main()\n{\n\tint Q;\n\tstring T, P;\n\tcin >> T;\n\tStringSearch SS(T);\n\tcin >> Q;\n\twhile (Q--) {\n\t\tcin >> P;\n\t\tcout << SS.Contain(P) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass SA{\npublic:\n  string S;\n  int n;\n  vector<int> sa;\n  \n  SA():n(-1){}\n  SA(string S):S(S),n(S.size()),sa(n){  \n    vector<int> rnk(n);\n    vector<int> tmp(n);\n    for(int i=0;i<n;i++) sa[i]=i;\n    for(int i=0;i<n;i++) rnk[i] = S[i];\n    \n    //k文字についてソートされているところから、2k文字でソート\n    for(int Len=1;Len<=n;Len*=2){\n      \n      //(rnk[i],rnk[i+k])と(rnk[j],rnk[j+k])を比較\n      auto compare_sa=[&](const int &i,const int &j){\n        if(rnk[i]!=rnk[j])return rnk[i]<rnk[j];\n        int ri=i+Len<=n?rnk[i+Len]:-1;\n        int rj=j+Len<=n?rnk[j+Len]:-1;\n        return ri<rj;\n      };\n      \n      sort(sa.begin(),sa.end(),compare_sa);\n\n      //いったんtmpに次のランクを計算して、rnkに代入\n      for(int i=1;i<n;i++)\n        tmp[sa[i]] = tmp[sa[i-1]] + compare_sa(sa[i-1],sa[i]);\n      rnk = tmp;\n    }\n  }\n\n  int lower_bound(string T){\n    assert(n >= 0);\n    int L=-1,R=S.length();\n    while(L+1<R){\n      int M = (L+R)/2;\n      S.compare(sa[M],T.size(),T)<0? L = M:R = M;\n    }\n    return R;\n  } \n\n  int upper_bound(string T){return lower_bound(T+char('z'+ 1));} \n  int count(string T){return upper_bound(T) - lower_bound(T);};\n};\n\nint main(){\n  string s;\n  cin>>s;\n  SA sa(s);\n  \n  int q;\n  cin>>q;\n  while(q--){\n    string t;\n    cin>>t;\n    int ans = sa.count(t) != 0;\n    printf(\"%d\\n\",ans);\n  }\n  \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow, *phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow = (ull*)malloc(n+1);\n    phash = (ull*)malloc(n+1);\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }  \n};\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  const int n = SZ(a);\n  if(n>1){\n    vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(b,rh), mergesort(c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==SZ(c))a[i]=b[j++];\n      else if(j==SZ(b))a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  mergesort(sa,rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000000];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nll n,k;\nvector<ll> Rank;\nvector<ll> tmp;\nvector<ll> sa;\nstring str;\n\n\nbool less_cmp(ll a,const string &s){\n    for(ll i=0;i<s.size();i++){\n        if(i+a>=n){return true;}\n        if(str[i+a]!=s[i]){return str[i+a]<s[i];}\n    }\n    return false;\n}\n\nbool equal_cmp(ll a,const string &s){\n    for(ll i=0;i<s.size();i++){\n        if(i+a>=n){return false;}\n        if(str[i+a]!=s[i]){return false;}\n    }\n    return true;\n}\n\nbool cmp(ll i,ll j){\n    if(Rank[i]!=Rank[j]){return Rank[i]<Rank[j];}\n    return (i+k<=n?Rank[i+k]:-1)<(j+k<=n?Rank[j+k]:-1);\n}\n\nvoid build(const string &s){\n    n=s.size();\n    sa.resize(n+1);\n    Rank.resize(n+1);\n    tmp.resize(n+1);\n    for(int i=0;i<=n;i++){\n        sa[i]=i;\n        Rank[i]=i<n?s[i]:-1;\n    }\n    for(k=1;k<=n;k<<=1){\n        sort(sa.begin(),sa.end(),cmp);\n        tmp[sa[0]]=0;\n        for(int i=1;i<=n;i++){\n            tmp[sa[i]]=tmp[sa[i-1]]+(cmp(sa[i-1],sa[i])?1:0);\n        }\n        for(int i=0;i<=n;i++){\n            Rank[i]=tmp[i];\n        }\n    }\n}\n\n\nbool search(const string &s){\n    ll l=0,r=n;\n    while(r-l>=10){\n        ll m=l+(r-l)/2;\n        if(less_cmp(sa[m],s)){l=m+1;}\n        else{r=m;}\n    }\n    for(ll i=l;i<=r;i++){\n        if(equal_cmp(sa[i],s)){return true;}\n    }\n    return false;\n}\n\n\n\n\nint main(){\n    cin>>str;\n    build(str);\n    /*\n    cout<<endl;\n    for(int i=0;i<=str.size();i++){\n        cout<<i<<\" \"<<Rank[sa[i]]<<endl;\n        for(ll t=sa[i];t<str.size();t++){cout<<str[t];}\n        cout<<endl;\n    }\n     */\n    ll q;\n    cin>>q;\n    while(q--){\n        string p;\n        cin>>p;\n        cout<<search(p)<<endl;\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<long long mod=1000000007,long long roll=82371827>\nclass suffix_array{\nprivate:\n    ll mod_pow(ll a,ll x){\n        if(a==0){return 0;}\n        ll ret=1;\n        while(x>0){\n            if(x&1){(ret*=a)%=mod;}\n            (a*=a)%=mod;\n            x>>=1;\n        }\n        return ret;\n    }\n    \n    typedef unsigned long ul;\n    \n    struct node{\n        ll begin;\n        ll Rank;\n        node* next;\n        \n        inline bool operator < (const node &N) const {\n            if(Rank==N.Rank){\n                return (next==NULL?-1:next->Rank)<(N.next==NULL?-1:N.next->Rank);\n            }\n            return Rank<N.Rank;\n        }\n        \n        node(ll begin=0,ll Rank=0,node* next=NULL):begin(begin),Rank(Rank),next(next){}\n    };\n    \n    static bool pointer_cmp(node* &a,node* &b){return (*a)<(*b);}\n    \n    vector<node*> sa;\n    vector<ll> Rank;\n    vector<ll> Hash;\n    const string s;\n    \n    void build(){\n        for(int i=0;i<s.size();i++){\n            *sa[i]={i,s[i],sa[i+1]};\n        }\n        sa[s.size()]->begin=s.size();\n        sa[s.size()]->Rank=-1;\n        sa[s.size()]->next=NULL;\n        vector<node*> Next(s.size()+1);\n        for(ll k=1;k<=s.size();k<<=1){\n            sort(sa.begin(),sa.end(),pointer_cmp);\n            Rank[sa[0]->begin]=0;\n            Next[0]=(sa[0]->next==NULL?NULL:sa[0]->next->next);\n            for(int i=1;i<=s.size();i++){\n                Rank[sa[i]->begin]=Rank[sa[i-1]->begin]+(*sa[i-1]<*sa[i]?1:0);\n                Next[i]=(sa[i]->next==NULL?NULL:sa[i]->next->next);\n            }\n            for(int i=0;i<=s.size();i++){\n                sa[i]->Rank=Rank[sa[i]->begin];\n                sa[i]->next=Next[i];\n            }\n        }\n        for(int i=0;i<=s.size();i++){\n            Next[sa[i]->begin]=sa[i];\n        }\n        for(int i=0;i<=s.size();i++){\n            sa[i]->next=sa[i]->begin==s.size()?NULL:Next[sa[i]->begin+1];\n        }\n    }\n    \n    //1::greater 0::same -1::less\n    int compare(const ul &saf,const vector<ll> &str){\n        if(s[sa[saf]->begin]!=str[1]){return s[sa[saf]->begin]<str[1]?-1:1;}\n        ll l=1,r=min((ll)str.size()-1,(ll)s.size()-sa[saf]->begin)-1;\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            if(hash(sa[saf]->begin,sa[saf]->begin+m)==str[m+1]){l=m+1;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(hash(sa[saf]->begin,sa[saf]->begin+i)!=str[i+1]){return hash(sa[saf]->begin+i,sa[saf]->begin+i)<(str[i+1]+mod-str[i])%mod?-1:1;}\n        }\n        return str.size()-1>s.size()-sa[saf]->begin?1:0;\n    }\n    \n    ul diff(const ul &saf,const vector<ll> &str){\n        if(s[sa[saf]->begin]!=str[1]){return 0;}\n        ll l=1,r=min(str.size()-1,s.size()-sa[saf].begin)-1;\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            if(hash(sa[saf]->begin,sa[saf]->begin+m)==str[m+1]){l=m+1;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(hash(sa[saf]->begin,sa[saf]->begin+i)!=str[i+1]){return i;}\n        }\n        return min(str.size()-1,s.size()-sa[saf].begin);\n    }\n    \n    bool is_in(const ul &saf,const vector<ll> &str){\n        return sa[saf]->begin+str.size()<=Hash.size() && str.back()==hash(sa[saf]->begin,sa[saf]->begin+str.size()-2);\n    }\n    \npublic:\n    suffix_array(const string &str):s(str),Rank(str.size()+1),sa(str.size()+1),Hash(str.size()+1,0){\n        for(int i=1;i<Hash.size();i++){\n            Hash[i]=Hash[i-1]*roll%mod+s[i-1];\n            Hash[i]%=mod;\n        }\n        for(int i=0;i<=s.size();i++){\n            sa[i]=(node*)malloc(sizeof(node));\n        }\n        build();\n    }\n    \n    ~suffix_array(){\n        for(int i=0;i<=s.size();i++){free(sa[i]);}\n    }\n    \n    ll rank(const ul &where) const {return Rank[where];}\n    \n    ul size() const {return sa.size();}\n    \n    const node & operator [] (const ul &where) const {return *sa[where];}\n    \n    ll hash(ll where){return Hash[where+1];}\n    \n    ll hash(ll l,ll r){return (Hash[r+1]+mod-Hash[l]*mod_pow(roll,r-l+1)%mod)%mod;}\n    \n    //返すのはsuffixの番号\n    ul lower_bound(const string &sub){\n        vector<ll> H(sub.size()+1,0);\n        for(int i=1;i<H.size();i++){\n            H[i]=H[i-1]*roll%mod+sub[i-1];\n            H[i]%=mod;\n        }\n        ll l=0;\n        ll r=s.size();\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            if(compare(m,H)==-1){l=m+1;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(compare(i,H)>=0){return i;}\n        }\n        return r+1;\n    }\n    \n    //返すのはsuffixの番号\n    ul upper_bound(const string &sub){\n        vector<ll> H(sub.size()+1,0);\n        for(int i=1;i<H.size();i++){\n            H[i]=H[i-1]*roll%mod+sub[i-1];\n            H[i]%=mod;\n        }\n        ll l=0;\n        ll r=s.size();\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            if(compare(m,H)<=0){l=m+1;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(compare(i,H)>0){return i;}\n        }\n        return r+1;\n    }\n    \n    bool match(const string &sub){\n        vector<ll> H(sub.size()+1,0);\n        for(int i=1;i<H.size();i++){\n            H[i]=H[i-1]*roll%mod+sub[i-1];\n            H[i]%=mod;\n        }\n        ll l=0;\n        ll r=s.size();\n        while(r-l>10){\n            ll m=l+(r-l)/2;\n            int st=compare(m,H);\n            if(st==0){return true;}\n            else if(st==-1){l=m+1;}\n            else{r=m-1;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(is_in(i,H)){return true;}\n        }\n        return false;\n    }\n};\n\n\nint main(){\n    string t;\n    cin>>t;\n    suffix_array<1000000007,82371827> S(t);\n    ll q;\n    cin>>q;\n    while(q--){\n        string p;\n        cin>>p;\n        cout<<S.match(p)<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<algorithm>\n\n#define MAX 1000002\n\nint Lv[MAX], A[MAX], newLv[MAX];\nint n, k;\nstring T;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n\tif(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n\tint L_i = (i + k >= n ? -1 : Lv[i + k]);\n\tint L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n\treturn L_i < L_j;\n}\n\nint main()\n{\n\tcin >> T;\n\tn = T.size();\n\n\tint i;\n\tfor(i = 0; i < n; i++){ A[i] = i; }\n\tfor(i = 0; i < n; i++){ Lv[i] = T[i]; }\n\tsort(A, A + n, cmp_Lv);\n\n\tnewLv[A[0]] = 0;\n\tfor(i = 1; i < n; i++){\n\t\tnewLv[A[i]] = newLv[A[i - 1]] + (Lv[A[i]] != Lv[A[i - 1]] ? 1 : 0);\n\t}\n\tfor(i = 0; i < n; i++){ Lv[i] = newLv[i]; }\n\n\tk = 1;\n\twhile(1){\n\t\tif(k > n) break;\n\n\t\tsort(A, A + n, cmp);\n\t\tnewLv[A[0]] = 0;\n\t\tfor(i = 1; i < n; i++){ newLv[A[i]] = newLv[A[i - 1]] + (cmp(A[i - 1], A[i]) ? 1 : 0); }\n\t\tfor(i = 0; i < n; i++){ Lv[i] = newLv[i]; }\n\n\t\tif(Lv[A[n - 1]] == n - 1) break;\n\t\tk <<= 1;\n\t};\n\n\tstring P;\n\tint q, left, right, mid, crit;\n\tbool exist;\n\tscanf(\"%d\", &q);\n\n\tA[n] = n;\n\n\twhile(q){\n\t\tcin >> P;\n\t\tleft = 0, right = n, exist = false;\n\t\twhile(left < right){\n\n\t\t\tif(n < P.size()){ exist = false; break; }\n\n\t\t\tmid = (left + right) / 2;\n\t\t\tcrit = T.compare(A[mid], P.size(), P);\n\n\t\t\tif(crit > 0){ right = mid; }\n\t\t\telse if(crit < 0){ left = mid + 1; }\n\t\t\telse{ exist = true; break; }\n\t\t};\n\t\tif(T.compare(A[right], P.size(), P) == 0) exist = true;\n\t\tif(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n\t\tq--;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string.h>\nusing namespace std;\n\n#define TEXT_T_MAX 1000000 \n#define TEXT_P_MAX 1000\n\nbool searchText(const char t1[], const char t2[]);\nbool compareText(const char *t1, char const *t2, int len);\n\nint main (void)\n{\n\tchar t[TEXT_T_MAX + 1] = \"\\0\";\n\tcin >> t;\n\tint\tq;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tchar p[TEXT_P_MAX + 1] = \"\\0\";\n\t\tcin >> p;\n\t\tcout << (int)searchText(t, p) << endl;\n\t}\n\n\treturn 0;\t\n}\n\nbool searchText(const char t1[], const char t2[])\n{\n\tint t1_len = strlen(t1);\n\tint t2_len = strlen(t2);\n\n\tfor (int i = 0; i + t2_len < t1_len; i++) {\n\t\tif (compareText(&t1[i], t2, t2_len)) return true;\n\t}\n\treturn false;\n}\n\nbool compareText(const char *t1, const char *t2, int len)\n{\n\tfor (int i = 0; i < len; i++) {\n\t\tif (*(t1 + i) != *(t2 + i)) return false;\n\t}\n\treturn true;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define MAX 1000002\ntypedef unsigned char byte;   // ???????????§????????????0??¨1???????????????????????±????????????\nbyte mask[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\n\nint Lv[MAX];\nint n, k;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n    return L_i < L_j;\n}\n\nint main()\n{\n    int A[MAX];\n    //std::string T;\n\tchar c[MAX];\n    //std::cin >> T;\n\tscanf(\"%s\", c);\n\tstd::string T = std::string(c);\n    n = T.size();\n    byte *t;\n    t = new byte [(n >> 3) + 1];  // ??¬???????????´??°???1??¨0???????????°?????\\????????¨????????´?°??????????????????§???????????§??????\n\n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n    std::sort(A, A + n, cmp_Lv);\n\n    for(i = 1; i < n; i++){\n        t[i >> 3] = (Lv[A[i]] != Lv[A[i - 1]] ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n    }  // ????????±??????????????????8?????????????????????0??¨1???????´??????????????????????\n\n    Lv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]); \n    } // 0???1????????????????????????0???0??§??????????????????????????¢??°!!????????????\n\n    k = 1;\n    while(1){\n        if(k > n) break;\n\n        std::sort(A, A + n, cmp);\n \n        for(i = 1; i < n; i++){\n            t[i >> 3] = (cmp(A[i - 1], A[i]) ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n        }\n        Lv[A[0]] = 0;\n        for(i = 1; i < n; i++){\n            Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n        }\n\n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n\n    char p[1000];  // ????????§char??????????????¢???????¢????????????????\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n\n    A[n] = n;\n\n    while(q){\n        scanf(\"%s\", p);\n        std::string P = std::string(p);\n        left = 0, right = n, exist = false;\n        while(left < right){\n\n            if(n < P.size()){ exist = false; break; }\n\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n\n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define MAX 1000000\n \nint n,k,sa[MAX];\nint rank[MAX],tmp[MAX];\n \nbool compare_sa(int i,int j){\n    if(rank[i] != rank[j]){\n        return rank[i] < rank[j];\n    }else{\n        int ri = i + k <= n ? rank[i+k] : -1;\n        int rj = j + k <= n ? rank[j+k] : -1;\n        return ri < rj;\n    }\n}\n\nvoid construct_sa(string &S,int *sa){\n    n = S.length();\n   \n    for(int i = 0 ; i <= n ; i++){\n        sa[i] = i;\n        rank[i] = i < n ? S[i] : -1;\n    }\n \n    for(k = 1 ; k <= n ; k *= 2){\n        sort(sa,sa+n+1,compare_sa);\n     \n        tmp[sa[0]] = 0;\n        for(int i = 1 ; i <= n ; i++){\n            tmp[sa[i]] = tmp[sa[i-1]] + (compare_sa(sa[i-1],sa[i]) ? 1 : 0);\n        }\n        for(int i = 0 ; i <= n ; i++){\n            rank[i] = tmp[i];\n        }\n    }\n}\n \nbool contain(string &S,int *sa,string &T){\n    int a = 0, b = S.length();\n    while(b - a > 1){\n        int c = (a + b ) / 2;\n        if(S.compare(sa[c],T.length(),T) < 0) a = c;\n        else b = c;\n    }\n    return S.compare(sa[b],T.length(),T) == 0;\n}\n \nint main(){\n    int Q;\n    string S,T;\n    cin >> S >> Q;\n    construct_sa(S,sa);\n    while(Q--){\n        cin >> T;\n        if(S.size() < T.size()){ puts(\"0\"); continue; }\n        puts(contain(S,sa,T) ? \"1\" : \"0\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define MAX 100005\n#define INF 1001001001\n\nint main(int, char**)\n{\n  string t;\n  cin >> t;\n\n  int ts = t.size();\n  vector<int> sa(ts+1), rank(ts+1);\n  int k;\n\n  auto comp_sa = [&] (int i, int j) -> bool {\n    if (rank[i] != rank[j]) return rank[i] < rank[j];\n    int ri = i+k<=ts ? rank[i+k] : -1;\n    int rj = j+k<=ts ? rank[j+k] : -1;\n    return ri < rj;\n  };\n\n  rep(i,ts+1) {\n    sa[i] = i;\n    rank[i] = i < ts ? t[i] : -1;\n  }\n  for (k = 1; k <= ts; k <<= 1) {\n    sort(sa.begin(), sa.end(), comp_sa);\n    int tmpr = 0;\n    vector<int> tmpr_v(ts+1);\n    rep(i,ts+1) {\n      tmpr_v[sa[i]] = tmpr;\n      if (i < ts && comp_sa(sa[i], sa[i+1])) tmpr++;\n    }\n    rep(i,ts+1) rank[i] = tmpr_v[i];\n  }\n\n  int q;\n  cin >> q;\n  vector<int> ans;\n  rep(i,q) {\n    string p;\n    cin >> p;\n\n    int l = 0, r = ts;\n    int found = 0;\n    while (r>=l) {\n      int m = (r+l)/2;\n      int res = t.compare(sa[m], p.size(), p);\n      if (res < 0) l = m+1;\n      else if (res > 0) r = m-1;\n      else {\n        found = 1;\n        break;\n      }\n    }\n    ans.push_back(found);\n  }\n  for (auto a : ans) cout << a << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef vector<vvll> vvvll;\ntypedef vector<ld> vld;\ntypedef vector<string> vstr;\ntypedef pair<ll, ll> pll;\ntypedef vector<pll> vpll;\ntypedef priority_queue<ll, vector<ll>, greater<ll>> spqll;  // 小さい順に取り出し\ntypedef priority_queue<ll, vector<ll>, less<ll>> bpqll;     // 大きい順に取り出し\n\n#define REP(i, n) for (ll i = 0; i < (ll)(n); i++)\n#define IREP(i, v) for (auto i = (v).begin(); i != (v).end(); ++i)\n#define TS to_string\n#define NP next_permutation\n#define ALL(v) (v).begin(), (v).end()\n#define endl \"\\n\"\n\nll INF = 1e9;\nll MOD = 1000000007;\nll LINF = 1e18;\nld EPS = 1e-9;\nld PI = M_PI;\nvll dx = {1, 0, -1, 0, 1, -1, -1, 1};\nvll dy = {0, 1, 0, -1, 1, 1, -1, -1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a;} //最大公約数\nll lcm(ll a, ll b) { return a / gcd(a, b) * b;}     //最小公倍数\n\nvoid yes(){ cout << \"Yes\" << endl;}\nvoid no(){ cout << \"No\" << endl;}\n\n//-----------------------------------------\nclass suffix_array{\n  private:\n    string s; // suffix_array の対象\n    ll n, k; // n : sの長さ\n    vll sa, tmp, rank; // sa : sufffixの開始位置\n\n  public:\n\n    suffix_array(string &str){\n      s = str;\n      n = s.size();\n\n      sa.resize(n+1);\n      rank.resize(n+1);\n      tmp.resize(n+1);\n\n      for(ll i=0;i<=n;i++){\n        sa[i] = i;\n        rank[i] = i < n ? (ll)s[i] : -1;\n      }\n\n      auto compare_sa = [&](ll i, ll j){\n        if(rank[i] != rank[j]) return rank[i] < rank[j];\n        else{\n          ll ri = i + k <= n ? rank[i + k] : -1;\n          ll rj = j + k <= n ? rank[j + k] : -1;\n          return ri < rj;\n        }\n      };\n\n      for(k=1;k<=n;k*=2){\n        sort(sa.begin(),sa.end(), compare_sa);\n\n        tmp[sa[0]] = 0;\n\n        for(ll i=1;i<=n;i++){\n          tmp[sa[i]] = tmp[sa[i-1]] + (compare_sa(sa[i-1], sa[i]) ? 1 : 0);\n        }\n        for(ll i=0;i<=n;i++){\n          rank[i] = tmp[i];\n        }\n      }\n    }\n\n    // [lb,ub) の各要素はtを部分文字列として含む\n    pll range(string &t){\n      ll m = t.size();\n      ll ub, lb;\n      ll lef, rig, mid;\n      \n      lef = 0; rig = n+1; // sa[0]は空 サイズがn+1\n\n      while(rig - lef > 1){\n        mid = (lef + rig) / 2; \n        string subs = s.substr(sa[mid],m);\n        if(t <= subs) rig = mid;\n        else lef = mid;\n      }\n      lb = rig;\n\n      lef = 0; rig = n+1; // sa[0]は空 サイズがn+1\n\n      while(rig - lef > 1){\n        mid = (lef + rig) / 2;\n        string subs = s.substr(sa[mid],m);\n        if(t < subs) rig = mid;\n        else lef = mid;\n      }\n      ub = rig;\n\n      return make_pair(lb, ub);\n    }\n\n    // 何箇所tを含むか\n    ll cnt(string &t){\n      pll res = range(t);\n      return res.second - res.first;\n    }\n};\n//-----------------------------------------\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  string t;\n  cin >> t;\n\n  suffix_array sarray(t);\n\n  ll q;\n  cin >> q;\n  REP(i,q){\n    string p;\n    cin >> p;\n    ll a = sarray.cnt(p);\n    cout << (a != 0) <<endl;\n  }\n\n\n    \n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<set>\n#include<complex>\n#include<typeinfo>\nusing namespace std;\n\nconst int MAX = 1000000;\n\nint n, k;\nint rank[MAX+1];\nint preRank[MAX+1];\n\nbool comp(int x, int y){\n    if(rank[x] == rank[y]){\n        int xx = (x + k <= n ? rank[x+k] : -1);\n        int yy = (y + k <= n ? rank[y+k] : -1);\n        return xx < yy;\n    }else{\n        return rank[x] < rank[y];\n    }\n}\n\nvector<int> makeSA(string &T){\n    n = T.size();\n    vector<int> SA(n+1);\n\n    for (int i=0;i<n+1;i++){\n        SA[i] = i;\n        rank[i] = (i<n) ? (int)T[i] : -1;\n    }\n\n    for (k=1;k<n+1;k*=2){\n        sort(SA.begin(), SA.begin()+n+1, comp);\n        preRank[SA[0]] = 0;\n        for (int j=1;j<n+1;j++){\n            preRank[SA[j]] = preRank[SA[j-1]] + (comp(SA[j-1], SA[j]) ? 1 : 0);\n        }\n        for (int j=0;j<n+1;j++){\n            rank[j] = preRank[j];\n        }\n    }\n    return SA;\n}\n\nbool searchSA(string &T, string &Pat, vector<int> &SA){\n    int l = -1;\n    int r = T.size();\n    while(r-l>1){\n        int c = (l+r)/2;\n        if(T.compare(SA[c], Pat.length(), Pat) < 0){\n            l = c;\n        }else{\n            r = c;\n        }\n    }\n    return T.compare(SA[r], Pat.length(), Pat) == 0;\n}\n\nint main(){\n    string T;\n    cin >> T;\n    vector<int> SA = makeSA(T);\n    int Q;\n    cin >> Q;\n    string Pat;\n    for (int i=0;i<Q;i++){\n        cin >> Pat;\n        cout << searchSA(T, Pat, SA) << endl;\n    }\n\n    /*\n    for (int i=0;i<SA.size();i++){\n        cout << SA[i] << endl;\n    }\n    */\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate<class T,class U> using P = pair<T,U>;\ntemplate<class T> using vec = vector<T>;\ntemplate<class T> using vvec = vector<vec<T>>;\n\n//空文字列はなし！\n//forever ei1333\nclass SuffixArray{\n    vec<int> SA;\n    const string S;\n    int N;\npublic:\n    SuffixArray(const string& S):S(S){\n        N = S.size();\n        SA.resize(N);\n        iota(SA.begin(),SA.end(),0);\n        sort(SA.begin(),SA.end(),[&](int i,int j){\n            return S[i]==S[j]? i>j:S[i]<S[j];\n        });\n        vec<int> classes(N),C(S.begin(),S.end()),cnt(S.size());\n        for(int len=1;len<N;len<<=1){\n            for(int i=0;i<N;i++){\n                if(i>0 && C[SA[i-1]]==C[SA[i]] && \n                SA[i-1]+len<N && C[SA[i-1]+len/2]==C[SA[i]+len/2]){\n                    classes[SA[i]] = classes[SA[i-1]];\n                }else{\n                    classes[SA[i]] = i;\n                }\n            }\n            iota(cnt.begin(),cnt.end(),0);\n            copy(SA.begin(),SA.end(),C.begin());\n            for(int i=0;i<N;i++){\n                int sl = C[i]-len;\n                if(sl>=0) SA[cnt[classes[sl]]++] = sl;\n            }\n            classes.swap(C);\n        }\n    }\n\n    int operator[](int k)const{\n        return SA[k];\n    }\n\n    int size()const{\n        return N;\n    }\n\n    bool lt_substr(const string& T,int si=0,int ti=0){\n        int sn = N,tn = T.size();\n        while(si<sn && ti<tn){\n            if(S[si]<T[ti]) return true;\n            if(S[si]>T[ti]) return false;\n            si++; ti++;\n        }\n        return si>=sn && ti<tn;\n    }\n\n    int lower_bound(const string& T,int si=0,int ti=0){\n        int l = -1,r = N;\n        while(l+1<r){\n            int m = (l+r)>>1;\n            (lt_substr(T,SA[m])? l:r) = m;\n        }\n        return r;\n    }\n\n    P<int,int> lower_upper_bound(string& T){\n        int id = lower_bound(T);\n        int l = id-1,r = N;\n        T.back()++;\n        while(l+1<r){\n            int m = (l+r)>>1;\n            (lt_substr(T,SA[m])? l:r) = m;\n        }\n        T.back()--;\n        return {id,r};\n    }\n\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string S;\n    cin >> S;\n    SuffixArray SA(S);\n    int Q;\n    cin >> Q;\n    for(int i=0;i<Q;i++){\n        string T;\n        cin >> T;\n        auto r = (SA.lower_upper_bound(T));\n        cout << (r.first!=r.second) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// ------ Suffix Array ------ //\nclass SuffixArray {\n\tvoid CreateBeginBucket(vector<int>&v, vector<int>&bucket) {\n\t\tfill(bucket.begin(), bucket.end(), 0);\n\t\tfor (int i = 0; i<v.size(); i++)bucket[v[i]]++;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i<bucket.size(); i++) { bucket[i] += sum; swap(sum, bucket[i]); }\n\t}\n\tvoid CreateEndBucket(vector<int>&v, vector<int>&bucket) {\n\t\tfill(bucket.begin(), bucket.end(), 0);\n\t\tfor (int i = 0; i<v.size(); i++)bucket[v[i]]++;\n\t\tfor (int i = 1; i<bucket.size(); i++)bucket[i] += bucket[i - 1];\n\t}\n\tvoid InducedSort(vector<int>&v, vector<int>&SA, int mv, vector<int>&bucket, vector<int>&isL) {\n\t\tCreateBeginBucket(v, bucket);\n\t\tfor (int i = 0; i<v.size(); i++)if (SA[i]>0 && isL[SA[i] - 1])SA[bucket[v[SA[i] - 1]]++] = SA[i] - 1;\n\t}\n\tvoid InvertInducedSort(vector<int>&v, vector<int>&SA, int mv, vector<int>&bucket, vector<int>&isL) {\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = v.size() - 1; i >= 0; i--)if (SA[i]>0 && !isL[SA[i] - 1])SA[--bucket[v[SA[i] - 1]]] = SA[i] - 1;\n\t}\n\tvector<int>SA_IS(vector<int>v, int mv) {\n\t\tif (v.size() == 1)return vector<int>(1, 0);\n\t\tvector<int>isL(v.size());\n\t\tvector<int>bucket(mv + 1);\n\t\tvector<int>SA(v.size(), -1);\n\t\tauto isLMS = [&](int x)->bool {return x>0 && isL[x - 1] && !isL[x]; };\n\t\tisL[v.size() - 1] = 0;\n\t\tfor (int i = v.size() - 2; i >= 0; i--)isL[i] = v[i]>v[i + 1] || (v[i] == v[i + 1] && isL[i + 1]);\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))SA[--bucket[v[i]]] = i;\n\t\tInducedSort(v, SA, mv, bucket, isL);\n\t\tInvertInducedSort(v, SA, mv, bucket, isL);\n\t\tint cur = 0;\n\t\tvector<int>ord(v.size());\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))ord[i] = cur++;\n\t\tvector<int>nxv(cur);\n\t\tcur = -1;\n\t\tint prev = -1;\n\t\tfor (int i = 0; i<v.size(); i++) {\n\t\t\tif (!isLMS(SA[i]))continue;\n\t\t\tbool diff = false;\n\t\t\tfor (int d = 0; d<v.size(); d++) {\n\t\t\t\tif (prev == -1 || v[SA[i] + d] != v[prev + d] || isL[SA[i] + d] != isL[prev + d]) {\n\t\t\t\t\tdiff = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (d>0 && isLMS(SA[i] + d))break;\n\t\t\t}\n\t\t\tif (diff) { cur++; prev = SA[i]; }\n\t\t\tnxv[ord[SA[i]]] = cur;\n\t\t}\n\t\tvector<int>reord(nxv.size());\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))reord[ord[i]] = i;\n\t\tvector<int>nxSA = SA_IS(nxv, cur);\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = 0; i<SA.size(); i++)SA[i] = -1;\n\t\tfor (int i = nxSA.size() - 1; i >= 0; i--)SA[--bucket[v[reord[nxSA[i]]]]] = reord[nxSA[i]];\n\t\tInducedSort(v, SA, mv, bucket, isL);\n\t\tInvertInducedSort(v, SA, mv, bucket, isL);\n\t\treturn SA;\n\t}\n\tvector<int>SA_IS(string s) {\n\t\tvector<int>v(s.size() + 1);\n\t\tfor (int i = 0; i<s.size(); i++)v[i] = s[i] + 1;\n\t\treturn SA_IS(v, *max_element(v.begin(), v.end()));\n\t}\n\tvector<int>construct_lcp(string &s, vector<int>&sa) {\n\t\tvector<int> lcp, rank(s.size() + 1);\n\t\tint n = s.size();\n\t\tfor (int i = 0; i <= n; i++)rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tlcp[0] = 0;\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h>0) h--;\n\t\t\tfor (; j + h<n&&i + h<n; h++) {\n\t\t\t\tif (s[j + h] != s[i + h])break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\npublic:\n\tstring s;\n\tvector<int> sa, lcp;\n\tvoid init(string &T) {\n\t\ts = T;\n\t\tsa = SA_IS(s);\n\t}\n\tSuffixArray(string &t) { init(t); }\n\tSuffixArray() {}\n\tbool contain(string &t) {\n\t\tint a = 0, b = s.size();\n\t\twhile (b - a>1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (s.compare(sa[c], t.size(), t) < 0)a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn s.compare(sa[b], t.size(), t) == 0;\n\t}\n};"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> pp;\ntypedef pair<pp,int> P;\nchar t[2500001],p[1001];\nint a[2500001],d[1000001],i;\nP b[1000001];\n\nvoid mk(){\n  for(i=0;t[i]!=0;i++)\n    b[i].f.f=t[i],b[i].s=i;\n  b[i].f.f=0,b[i].s=i;\n\n  for(int j=1;j<=i;j*=2){\n    sort(b,b+i+1);\n    a[b[0].s]=0;\n    for(int k=1,l=0;k<=i;k++)\n      if(b[k-1].f==b[k].f)a[b[k].s]=l;\n      else a[b[k].s]=++l;\n    for(int k=0,o=b[0].s;k<=i;k++,o=b[k].s)\n      b[k]=P(pp(a[o],a[o+j]),o);\n  }\n  sort(b,b+i+1);\n  a[b[0].s]=0;\n  for(int k=1,l=0;k<=i;k++)\n    if(b[k-1].f==b[k].f)a[b[k].s]=l;\n    else a[b[k].s]=++l;\n  for(int j=0;j<=i;j++)d[a[j]]=j;\n}\n\nvoid bs(int n){\n  int l=0,r=i,m;\n  while(l<r){\n    m=(l+r)/2;\n    if(strncmp(t+d[m],p,n)<0)l=m+1;\n    else r=m;\n  }\n  if(strncmp(t+d[l],p,n) ==0 )cout<<\"1\"<<endl;\n  else cout<<\"0\"<<endl;\n}\n\n\nint main(){\n  int q;\n  scanf(\"%s\",t);\n  mk();\n  cin>>q;\n  while(q--&&scanf(\"%s\",p))bs(strlen(p));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cstdio>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst ull B = 10007;\n\nvoid RollingHash(string T, string P){\n    int S = 0;\n    int t=T.size();\n    int p=P.size();\n\n    ull x=1;\n    for (int i=0;i<p;i++) x*=B;\n\n    ull th=0,ph=0;\n    for (int i=0;i<p;i++) th=th*B+T[i];\n    for (int i=0;i<p;i++) ph=ph*B+P[i];\n\n    for (int i=0;i+p<=t;i++){\n        if(th==ph){\n            printf(\"1\\n\");\n            return;\n        }\n        if(i+p<t) th=th*B+T[i+p]-T[i]*x;\n    }\n    printf(\"0\\n\");\n}\n\nint main(){\n    string T;\n    cin >> T;\n\n    int Q;\n    cin >> Q;\n    vector<string> P(Q);\n    for (int i=0;i<Q;i++){\n        cin >> P[i];\n        RollingHash(T, P[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    //return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n    return i+k < n ? 0 : j+k < n ? 1 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n/2+n%2,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==nc)a[i]=b[j++];\n      else if(j==nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  /*\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n  */\n  int sa[rh.n+1];\n  REP(i,rh.n+1)sa[i]=i;\n  sort(sa,sa+rh.n+1,rh);\n  vector<int>res(rh.n+1);\n  REP(i,rh.n+1)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define Rep(i,n) for(int i=0;i<(int)(n);i++)\n#define For(i,n1,n2) for(int i=(int)(n1);i<(int)(n2);i++)\n#define REP(i,n) for(ll i=0;i<(ll)(n);i++)\n#define RREP(i,n) for(ll i=((ll)(n)-1);i>=0;i--)\n#define FOR(i,n1,n2) for(ll i=(ll)(n1);i<(ll)(n2);i++)\n#define RFOR(i,n1,n2) for(ll i=((ll)(n1)-1);i>=(ll)(n2);i--)\n#define all(a)  (a).begin(),(a).end()\n#define IOS std::cin.tie(0),std::ios::sync_with_stdio(false)\n\nnamespace idaten {\n\n\tusing namespace std;\n\tusing ll = int_fast64_t;\n\tusing ull = uint_fast64_t;\n\tusing P = std::pair<int64_t, int64_t>;\n\ttemplate<typename T1, typename T2> inline bool chmin(T1& a, T2 b) { if (a > b) { a = b; return 1; }return 0; }\n\ttemplate<typename T1, typename T2> inline bool chmax(T1& a, T2 b) { if (a < b) { a = b; return 1; }return 0; }\n\ttemplate<class Type>struct is_vector : std::false_type {};\n\ttemplate<class ValueType, class Alloc>struct is_vector<std::vector<ValueType, Alloc>> : std::true_type {};\n\ttemplate <typename T> inline std::ostream& operator << (std::ostream& out, const std::vector<T>& v) {\n\t\tif (v.empty())return out;\n\t\tconstexpr bool is_vector_v = is_vector<T>::value;\n\t\tif (is_vector_v)for (auto itr = v.begin(); itr != v.end();)out << (*itr), out << ((++itr != v.end()) ? \"\\n\" : \"\");\n\t\telse for (auto itr = v.begin(); itr != v.end();)out << (*itr), out << ((++itr != v.end()) ? \" \" : \"\");\n\t\treturn out;\n\t}\n\tinline void put() {}\n\ttemplate<class T> inline void put(const T& first) { std::cout << first << \"\\n\"; }\n\ttemplate<class T, class... N> inline void put(const T& first, const N& ... rest) { std::cout << first << \" \"; put(rest...); }\n\tinline void putn() {}\n\ttemplate<class T, class... N> inline void putn(const T& first, const N& ... rest) { std::cout << first << \"\\n\"; putn(rest...); }\n\tint get_front(vector<int>& t, vector<int>& sum, vector<int>& ch, int num) {\n\t\tint res = sum[t[num]];\n\t\tres += ch[t[num]]++;\n\t\treturn res;\n\t}\n\n\tint get_back(vector<int>& t, vector<int>& sum, vector<int>& ct, int num) {\n\t\tint res = sum[t[num] + 1] - 1;\n\t\tres -= ct[t[num]]++;\n\t\treturn res;\n\t}\n\n\tvoid induced_sort(vector<int>& t, vector<int>& table, vector<int>& sum, vector<int>& ls, int ma) {\n\t\tint n = t.size();\n\t\tvector<int> ch(ma + 1, 0), ct(ma + 1, 0);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (table[i] >= 0) {\n\t\t\t\tint ind = table[i] - 1;\n\t\t\t\tif (ind >= 0 && ls[ind]) {\n\t\t\t\t\tint d = get_front(t, sum, ch, ind);\n\t\t\t\t\ttable[d] = ind;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = n - 1; i >= 0; --i) {\n\t\t\tif (table[i] >= 0) {\n\t\t\t\tint ind = table[i] - 1;\n\t\t\t\tif (ind >= 0 && !ls[ind]) {\n\t\t\t\t\tint d = get_back(t, sum, ct, ind);\n\t\t\t\t\ttable[d] = ind;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool is_lms(vector<int>& ls, int ind) {\n\t\treturn ind > 0 && ls[ind - 1] && !ls[ind];\n\t}\n\n\ttemplate<typename T>\n\tvector<T> substr(vector<T> v, int a, int b) { // v[a,b)\n\t\ta = max(0, a);\n\t\tb = min(v.size() - 1, b);\n\t\tvector<T> res(max(0, b - a));\n\t\tfor (int i = a; i < b; i++) {\n\t\t\tres[i - a] = v[i];\n\t\t}\n\t\treturn res;\n\t}\n\n\tvector<int> sais(vector<int>& s) {\n\t\tint n = s.size();\n\t\tif (n == 1) {\n\t\t\treturn vector<int>(1, 0);\n\t\t}\n\t\tint m = *min_element(s.begin(), s.end());\n\t\tif (m != 1) { // 最小値が1となるように変換\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\ts[i] -= m - 1;\n\t\t\t}\n\t\t}\n\t\tint sent = 0; // 番兵が0\n\t\tvector<int> t = s;\n\t\tt.push_back(sent);\n\t\tn++;\n\t\tvector<int> ls(n); // 1がl,0がs\n\t\tls.back() = 0;\n\t\tfor (int i = n - 2; i >= 0; --i) {\n\t\t\tif (t[i] == t[i + 1]) {\n\t\t\t\tls[i] = ls[i + 1];\n\t\t\t} else {\n\t\t\t\tls[i] = t[i] > t[i + 1];\n\t\t\t}\n\t\t}\n\t\tvector<int> lms;\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tif (ls[i - 1] && !ls[i]) {\n\t\t\t\tlms.push_back(i);\n\t\t\t}\n\t\t}\n\t\tint ma = *max_element(s.begin(), s.end());\n\t\tvector<int> cnt(ma + 1, 0);\n\t\tfor (auto&& v : t) {\n\t\t\tcnt[v]++;\n\t\t}\n\t\tvector<int> sum(cnt.size() + 1);\n\t\tsum[0] = 0;\n\t\tfor (int i = 0; i < cnt.size(); ++i) {\n\t\t\tsum[i + 1] = sum[i] + cnt[i];\n\t\t}\n\t\tvector<int> table(n, -1), ch(ma + 1, 0);\n\t\tfor (int i = (int)lms.size() - 1; i >= 0; --i) {\n\t\t\tint ind = lms[i];\n\t\t\tint d = get_back(t, sum, ch, ind);\n\t\t\ttable[d] = lms[i];\n\t\t}\n\t\tinduced_sort(t, table, sum, ls, ma);\n\t\t//sorted lms-substring\n\t\tvector<int> nt(lms.size());\n\t\tint cn = 0;\n\t\tvector<int> lms_index(n, -1); // iがlmsのうち先頭から何番目に現れるか\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (is_lms(ls, i)) {\n\t\t\t\tlms_index[i] = cn++;\n\t\t\t}\n\t\t}\n\t\tcn = 1;\n\t\tint sub = 0, preind = -1;\n\t\tfor (int i = 0; i < n; ++i) { // lms-substringを復元\n\t\t\tint ind = table[i];\n\t\t\tif (is_lms(ls, ind)) {\n\t\t\t\tif (cn > 1) {\n\t\t\t\t\tint a = lms[preind];\n\t\t\t\t\tint b = lms[min<int>(preind + 1, lms.size() - 1)];\n\t\t\t\t\tint c = lms[lms_index[ind]];\n\t\t\t\t\tint d = lms[min<int>(lms_index[ind] + 1, lms.size() - 1)];\n\t\t\t\t\tint pre_len = b - a;\n\t\t\t\t\tint post_len = d - c;\n\t\t\t\t\tif (pre_len != post_len) {\n\t\t\t\t\t\tsub--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (int j = 0; j < pre_len; j++) {\n\t\t\t\t\t\t\tif (t[j + a] != t[j + c]) {\n\t\t\t\t\t\t\t\tsub--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsub++;\n\t\t\t\t}\n\t\t\t\tnt[lms_index[ind]] = cn - sub;\n\t\t\t\tpreind = lms_index[ind];\n\t\t\t\tcn++;\n\t\t\t}\n\t\t}\n\t\t// ntのSAを求めるs\n\t\tauto lms_sa = sais(nt);\n\t\tstd::fill(ch.begin(), ch.end(), 0);\n\t\tstd::fill(table.begin(), table.end(), 0);\n\t\tfor (int i = (int)lms_sa.size() - 1; i >= 0; --i) {\n\t\t\tint ind = lms[lms_sa[i]];\n\t\t\tint d = get_back(t, sum, ch, ind);\n\t\t\ttable[d] = ind;\n\t\t}\n\t\tinduced_sort(t, table, sum, ls, ma);\n\t\tvector<int> res(n - 1);\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\tres[i] = table[i + 1];\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid sais_rec(vector<int>& s) {}\n\n\tvector<int> stovi(string& s) {\n\t\tint n = s.size();\n\t\tvector<int> res(n);\n\t\tchar mi = *min_element(s.begin(), s.end());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres[i] = s[i] - mi + 1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tint find_begin_naive(string& s, vector<int>& sa, string& str) {\n\t\tint ng = -1, ok = sa.size();\n\t\tint l = str.size();\n\t\twhile (abs(ng - ok) > 1) {\n\t\t\tint mid = (ng + ok) / 2;\n\t\t\tint suffix_ind = sa[mid];\n\t\t\tint r = min<int>(l, s.size() - suffix_ind);\n\t\t\tstring suffix = s.substr(suffix_ind, r);\n\t\t\tif (suffix >= str) {\n\t\t\t\tok = mid;\n\t\t\t} else {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\n\tint find_end_naive(string& s, vector<int>& sa, string& str) {\n\t\tint ok = -1, ng = sa.size();\n\t\tint l = str.size();\n\t\twhile (abs(ng - ok) > 1) {\n\t\t\tint mid = (ng + ok) / 2;\n\t\t\tint suffix_ind = sa[mid];\n\t\t\tint r = min<int>(l, s.size() - suffix_ind);\n\t\t\tstring suffix = s.substr(suffix_ind, r);\n\t\t\tif (suffix <= str) {\n\t\t\t\tok = mid;\n\t\t\t} else {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\n\tint count(string& s, vector<int>& sa, string& str) {\n\t\tint beg = find_begin_naive(s, sa, str);\n\t\tint en = find_end_naive(s, sa, str);\n\t\treturn en - beg + 1;\n\t}\n\n\tvoid solve() {\n\t\tIOS; \n\t\tstring t;\n\t\tcin >> t;\n\t\tauto vi = stovi(t);\n\t\tauto sa = sais(vi);\n\t\tint q;\n\t\tcin >> q;\n\t\tREP(loop, q) {\n\t\t\tstring p;\n\t\t\tcin >> p;\n\t\t\tint c = count(t, sa, p);\n\t\t\tput(!!c);\n\t\t}\n\t\t\n\t}\n} // namespace idaten\n\nint main() {\n\tidaten::solve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntemplate<typename S_Iter, typename SA_Iter>\nvoid induceSAL(S_Iter S_begin, S_Iter S_end, SA_Iter SA_begin, SA_Iter SA_end, const vector<bool> &t, uint32_t buckets_size) {\n    int32_t n = S_end - S_begin;\n    vector<int32_t> buckets(buckets_size+1, 0);\n    for (auto itr = S_begin; itr != S_end; itr++) buckets[*itr]++;\n\n    int32_t sum = 0;\n    for (uint32_t i = 0; i < buckets.size(); i++) {\n        sum += buckets[i];\n        buckets[i] = sum - buckets[i];\n    }\n\n    if (!t[n-1]) SA_begin[buckets[S_begin[n-1]]++] = n-1;\n\n    for (int32_t i = 0; i < n; i++) {\n        if (SA_begin[i] > 0 && !t[SA_begin[i]-1]) SA_begin[buckets[S_begin[SA_begin[i]-1]]++] = SA_begin[i]-1;\n    }\n\n    return;\n}\n\ntemplate<typename S_Iter, typename SA_Iter>\nvoid induceSAS(S_Iter S_begin, S_Iter S_end, SA_Iter SA_begin, SA_Iter SA_end, const vector<bool> &t, uint32_t buckets_size) {\n    int32_t n = S_end - S_begin;\n    vector<int32_t> buckets(buckets_size+1, 0);\n    for (auto itr = S_begin; itr != S_end; itr++) buckets[*itr]++;\n    partial_sum(buckets.begin(), buckets.end(), buckets.begin());\n\n    for (int32_t i = n-1; i > 0; i--) {\n        if (SA_begin[i] > 0 && t[SA_begin[i]-1]) SA_begin[--buckets[S_begin[SA_begin[i]-1]]] = SA_begin[i]-1;\n    }\n\n    return;\n}\n\ntemplate<typename S_Iter, typename SA_Iter>\nvoid SA_IS(S_Iter S_begin, S_Iter S_end, SA_Iter SA_begin, SA_Iter SA_end, uint32_t buckets_size) {\n    int32_t n = S_end - S_begin;\n    fill(SA_begin, SA_end, -1);\n\n    // classify the type of each character\n    // true <=> S-type\n    vector<bool> t(n);\n    for (int32_t i = n; i >= 0; i--) {\n        t[i] = S_begin[i] < S_begin[i+1] || (S_begin[i] == S_begin[i+1] && t[i+1]);\n    }\n\n    auto is_lms = [&t](int32_t i){return i > 0 && !t[i-1] && t[i];};\n\n    // sort all the S-substrings\n    vector<int32_t> buckets(buckets_size+1, 0);\n    for (auto itr = S_begin; itr != S_end; itr++) buckets[*itr]++;\n    partial_sum(buckets.begin(), buckets.end(), buckets.begin());\n    for (int32_t i = 0; i < n; i++) {\n        if (is_lms(i)) SA_begin[--buckets[S_begin[i]]] = i;\n    }\n    induceSAL(S_begin, S_end, SA_begin, SA_end, t, buckets_size);\n    induceSAS(S_begin, S_end, SA_begin, SA_end, t, buckets_size);\n\n    // compact all the sorted substrings into the first nl items of SA\n    auto lms_end = remove_if(SA_begin, SA_end, [is_lms](int32_t x){return !is_lms(x);});\n    fill(lms_end, SA_end, -1);\n    int32_t nl = lms_end - SA_begin;\n\n    // find the lexicographic names of substrings\n    int32_t name = 0;\n    for (auto itr = SA_begin; itr != lms_end; itr++) {\n        if (itr == SA_begin) {\n            lms_end[*itr/2] = name;\n        } else {\n            int32_t cur = *itr, prev = *(itr - 1);\n            bool miss = S_begin[cur] != S_begin[prev] || t[cur] != t[prev];\n            if (!miss) do {\n                ++cur; ++prev;\n                miss |= cur == n ||\n                        prev == n ||\n                        S_begin[cur] != S_begin[prev] ||\n                        t[cur] != t[prev];\n            } while (!miss && !(cur > 0 && !t[cur-1] && t[cur]) && !(prev > 0 && !t[prev-1] && t[prev]));\n\n            if (miss) ++name;\n            lms_end[*itr/2] = name;\n        }\n    }\n    remove_if(reverse_iterator<decltype(SA_end)>(SA_end), reverse_iterator<decltype(SA_begin)>(SA_begin) - nl, [](int32_t i) {return i < 0;});\n\n    // solve the reduced problem\n    auto S1_begin = SA_end - nl, S1_end = SA_end;\n    auto SA1_begin = SA_begin, SA1_end = SA_begin + nl;\n    if (name + 1 < nl) {\n        SA_IS(S1_begin, S1_end, SA1_begin, SA1_end, nl);\n    } else {\n        for (int32_t i = 0; i < nl; i++) {\n            SA1_begin[S1_begin[i]] = i;\n        }\n    }\n\n    // induce the result for the original problem\n    fill(buckets.begin(), buckets.end(), 0);\n    for (auto itr = S_begin; itr != S_end; itr++) buckets[*itr]++;\n    partial_sum(buckets.begin(), buckets.end(), buckets.begin());\n\n    for (int32_t i = 1, j = 0; i < n; i++) {\n        if (is_lms(i)) S1_begin[j++] = i;\n    }\n    for (int32_t i = 0; i < nl; i++) SA1_begin[i] = S1_begin[SA1_begin[i]];\n    fill(lms_end, SA_end, -1);\n    for (int32_t i = nl-1; i >= 0; i--) {\n        int32_t j = SA_begin[i];\n        SA_begin[i] = -1;\n        SA_begin[--buckets[S_begin[j]]] = j;\n    }\n    induceSAL(S_begin, S_end, SA_begin, SA_end, t, buckets_size);\n    induceSAS(S_begin, S_end, SA_begin, SA_end, t, buckets_size);\n\n    return;\n}\n\nint main() {\n    char tmp[1000000];\n    scanf(\"%s\", tmp);\n    string T = tmp;\n\n    int32_t Q;\n    scanf(\"%d\", &Q);\n\n    vector<int32_t> SA(T.length());\n    SA_IS(T.begin(), T.end(), SA.begin(), SA.end(), 'z');\n\n    for (int32_t i = 0; i < Q; i++) {\n        char tmp[1000];\n        scanf(\"%s\", tmp);\n        string P = tmp;\n\n        auto itr_lb = lower_bound(SA.begin(), SA.end(), P, [&T](uint32_t i, string s) {return T.substr(i, T.length()-i) < s;});\n\n        if (*itr_lb <= T.length() - P.length() && T.substr(*itr_lb, P.length()) == P) {\n            printf(\"1\\n\");\n        } else {\n            printf(\"0\\n\");\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    //return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n    return i+k >= n ? 0 : j+k >= n ? 1 : s[i+k] > s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n/2+n%2,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==nc)a[i]=b[j++];\n      else if(j==nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  /*\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n  */\n  int sa[rh.n+1];\n  REP(i,rh.n+1)sa[i]=i;\n  sort(sa,sa+rh.n+1,rh);\n  vector<int>res(rh.n+1);\n  REP(i,rh.n+1)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int i, const int j) { \n    //const int k=lcp(i,j);\n    const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    if(i+k>=n)return 1;\n    if(j+k>=n)return 0;\n    return s[i+k] <= s[j+k];\n    //return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int b, const int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  /*\n  inline int lcp(const int i, const int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n  */\n  int lcp2(const int i, const int j, const int l, const int r){\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\nif(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\ntypedef unsigned long long ull;\nstatic const ull B = 100000007;\n\nbool contain(string a, string b){\n\tint al = a.length(), bl = b.length();\n\tif(al > bl) return false;\n\n\tull t = 1;\n\tfor(int i = 0; i < al; i++) t *= B;\n\n\tull ah = 0, bh = 0;\n\tfor(int i = 0; i < al; i++) ah = ah * B + a[i];\n\tfor(int i = 0; i < al; i++) bh = bh * B + b[i];\n\n\tfor(int i = 0; i + al <= bl; i++){\n\t\tif(ah == bh) return true;\n\t\tif(i + al < bl) bh = bh * B + b[i + al] - b[i] * t;\n\t}\n\treturn false;\n}\n\nint main(){\n\tint Q; \n\tstring a, b;\n\tcin >> a;\n\tcin >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> b;\n\t\tcout << (contain(b, a) ? \"1\" : \"0\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// ------ Suffix Array ------ //\nclass SuffixArray {\n\tvoid CreateBeginBucket(vector<int>&v, vector<int>&bucket) {\n\t\tfill(bucket.begin(), bucket.end(), 0);\n\t\tfor (int i = 0; i<v.size(); i++)bucket[v[i]]++;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i<bucket.size(); i++) { bucket[i] += sum; swap(sum, bucket[i]); }\n\t}\n\tvoid CreateEndBucket(vector<int>&v, vector<int>&bucket) {\n\t\tfill(bucket.begin(), bucket.end(), 0);\n\t\tfor (int i = 0; i<v.size(); i++)bucket[v[i]]++;\n\t\tfor (int i = 1; i<bucket.size(); i++)bucket[i] += bucket[i - 1];\n\t}\n\tvoid InducedSort(vector<int>&v, vector<int>&SA, int mv, vector<int>&bucket, vector<int>&isL) {\n\t\tCreateBeginBucket(v, bucket);\n\t\tfor (int i = 0; i<v.size(); i++)if (SA[i]>0 && isL[SA[i] - 1])SA[bucket[v[SA[i] - 1]]++] = SA[i] - 1;\n\t}\n\tvoid InvertInducedSort(vector<int>&v, vector<int>&SA, int mv, vector<int>&bucket, vector<int>&isL) {\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = v.size() - 1; i >= 0; i--)if (SA[i]>0 && !isL[SA[i] - 1])SA[--bucket[v[SA[i] - 1]]] = SA[i] - 1;\n\t}\n\tvector<int>SA_IS(vector<int>v, int mv) {\n\t\tif (v.size() == 1)return vector<int>(1, 0);\n\t\tvector<int>isL(v.size());\n\t\tvector<int>bucket(mv + 1);\n\t\tvector<int>SA(v.size(), -1);\n\t\tauto isLMS = [&](int x)->bool {return x>0 && isL[x - 1] && !isL[x]; };\n\t\tisL[v.size() - 1] = 0;\n\t\tfor (int i = v.size() - 2; i >= 0; i--)isL[i] = v[i]>v[i + 1] || (v[i] == v[i + 1] && isL[i + 1]);\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))SA[--bucket[v[i]]] = i;\n\t\tInducedSort(v, SA, mv, bucket, isL);\n\t\tInvertInducedSort(v, SA, mv, bucket, isL);\n\t\tint cur = 0;\n\t\tvector<int>ord(v.size());\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))ord[i] = cur++;\n\t\tvector<int>nxv(cur);\n\t\tcur = -1;\n\t\tint prev = -1;\n\t\tfor (int i = 0; i<v.size(); i++) {\n\t\t\tif (!isLMS(SA[i]))continue;\n\t\t\tbool diff = false;\n\t\t\tfor (int d = 0; d<v.size(); d++) {\n\t\t\t\tif (prev == -1 || v[SA[i] + d] != v[prev + d] || isL[SA[i] + d] != isL[prev + d]) {\n\t\t\t\t\tdiff = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (d>0 && isLMS(SA[i] + d))break;\n\t\t\t}\n\t\t\tif (diff) { cur++; prev = SA[i]; }\n\t\t\tnxv[ord[SA[i]]] = cur;\n\t\t}\n\t\tvector<int>reord(nxv.size());\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))reord[ord[i]] = i;\n\t\tvector<int>nxSA = SA_IS(nxv, cur);\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = 0; i<SA.size(); i++)SA[i] = -1;\n\t\tfor (int i = nxSA.size() - 1; i >= 0; i--)SA[--bucket[v[reord[nxSA[i]]]]] = reord[nxSA[i]];\n\t\tInducedSort(v, SA, mv, bucket, isL);\n\t\tInvertInducedSort(v, SA, mv, bucket, isL);\n\t\treturn SA;\n\t}\n\tvector<int>SA_IS(string s) {\n\t\tvector<int>v(s.size() + 1);\n\t\tfor (int i = 0; i<s.size(); i++)v[i] = s[i] + 1;\n\t\treturn SA_IS(v, *max_element(v.begin(), v.end()));\n\t}\n\tvector<int>construct_lcp(string &s, vector<int>&sa) {\n\t\tvector<int> lcp, rank(s.size() + 1);\n\t\tint n = s.size();\n\t\tfor (int i = 0; i <= n; i++)rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tlcp[0] = 0;\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h>0) h--;\n\t\t\tfor (; j + h<n&&i + h<n; h++) {\n\t\t\t\tif (s[j + h] != s[i + h])break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\npublic:\n\tstring s;\n\tvector<int> sa, lcp;\n\tvoid init(string &T) {\n\t\ts = T;\n\t\tsa = SA_IS(s);\n\t}\n\tSuffixArray(string &t) { init(t); }\n\tSuffixArray() {}\n\tbool contain(string &t) {\n\t\tint a = 0, b = s.size();\n\t\twhile (b - a>1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (s.compare(sa[c], t.size(), t) < 0)a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn s.compare(sa[b], t.size(), t) == 0;\n\t}\n};\n\n// ------ Main ------ //\nint q; string s, t;\nint main() {\n\tcin >> s >> q;\n\tSuffixArray v(s);\n\tfor(int i = 0; i < q; i++) {\n\t\tcin >> t;\n\t\tcout << (v.contain(t) ? 1 : 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S 2500005\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\nstruct d{\n  int a,b,c;\n  d(){}\n  d(int A,int B,int C){\n    a=A,b=B,c=C;\n  };\n  bool operator<(const d&r)const{\n    if(a!=r.a)return a<r.a;\n    return b<r.b;\n  }\n};\n\nint n,slen,tlen,r[S];\nchar s[S],t[N];\nd ran[S];\nP a[S];\n\nvoid init(){\n  for(int i=0;i<26;i++)\n    for(int j=0;j<slen;j++)\n      if('a'+i==s[j])r[j]=i+1;\n  int x=1;\n  while(x<slen){\n    for(int i=0;i<slen;i++){\n      int a=i+x;\n      if(a>slen)a=slen;\n      ran[i]=d(r[i],r[a],i);\n    }\n    sort(ran,ran+slen);\n    int cnt=1;\n    for(int i=0;i<slen;i++){\n      r[ran[i].c]=cnt;\n      if(ran[i].a==ran[i+1].a&&ran[i].b==ran[i+1].b)\n\tcontinue;\n      cnt++;\n    }\n    x*=2;\n  }\n  for(int i=0;i<slen;i++)a[i]=P(r[i],i);\n  sort(a,a+slen);\n}\n\nbool bynary_search(){\n  int L=0,R=slen;\n  while(L<R){\n    int M=(L+R)/2;\n    if(strncmp(s+a[M].second,t,tlen)<0)L=M+1;\n    else R=M;\n  }\n  if(!strncmp(s+a[L].second,t,tlen))return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s%d\",s,&n);\n  slen=strlen(s);\n  init();  \n  while(n--){\n    scanf(\"%s\",t);\n    tlen=strlen(t);\n    if(bynary_search())printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nnamespace SA{\n    const int MAX=1000000;\n    int N,K;\n    int tmp[MAX+1],rank[MAX+1];\n    bool compare_sa(int i,int j){\n        if(rank[i]!=rank[j])return rank[i]<rank[j];\n        else{\n            int ri=(i+K<=N)?rank[i+K]:-1;\n            int rj=(j+K<=N)?rank[j+K]:-1;\n            return ri<rj;\n        }\n    }\n\n    vector<int> construct_sa(string S){\n        N=S.size();\n        vector<int>sa(N+1);\n        for(int i=0;i<=N;i++)sa[i]=i;\n        for(int i=0;i<=N;i++){\n            rank[i]=i==N?-1:S[i];\n        }\n\n        for(K=1;K<=N;K*=2){\n            sort(sa.begin(),sa.end(),compare_sa);\n            tmp[sa[0]]=0;\n            for(int i=1;i<=N;i++){\n                tmp[sa[i]]=tmp[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n            }\n            for(int i=0;i<=N;i++)rank[i]=tmp[i];\n        }\n        return sa;\n    }\n\n    int contain(string &S,vector<int>&sa,string &T){\n        int a=0,b=S.size();\n        while(b-a>1){\n            int c=(a+b)/2;\n            if(S.compare(sa[c],T.size(),T)<0)a=c;\n            else b=c;\n        }\n        if(S.compare(sa[b],T.size(),T)==0)return b;\n        return -1;\n    }\n}\n\nsigned main(){\n    string S;\n    vint sa;\n    int Q;\n    cin>>S>>Q;\n    sa=SA::construct_sa(S);\n    while(Q--){\n        string T;cin>>T;\n        if(SA::contain(S,sa,T)!=-1)cout<<1<<endl;\n        else cout<<0<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int MAX = 62;\n\nint encode(char c){\n\tif(isdigit(c)){\n\t\treturn  c - '0';\n\t}else if(islower(c)){\n\t\treturn 10 + c - 'a';\n\t}else if(isupper(c)){\n\t\treturn 10 + 26 + c - 'A';\n\t}\n\n\tassert(false && \"invalid string\");\n}\n\nstruct Node{\n\tint nxt[MAX+1];\t\t\t// 次のalphabeteのノード番号\n\tint exist;\t\t\t\t// 子ども以下に存在する文字列の数の合計\n\tvector<int> accept;\t\t// その文字列id\n\tNode() : exist(0){memset(nxt, -1, sizeof(nxt));}\n};\n\nclass Trie{\n\tprivate:\n\t\tvoid updateDirect(int node,int id){\n\t\t\tac.emplace_back(node);\n\t\t\tnodes[node].accept.emplace_back(id);\n\t\t}\n\t\tvoid updateChild(int node,int child,int id){\n\t\t\t++nodes[node].exist;\n\t\t}\n\t\tvoid add(const string &str,int str_index,int node_index,int id){\n\t\t\tif(str_index == str.size())\n\t\t\t\tupdateDirect(node_index, id);\n\t\t\telse{\n\t\t\t\tconst int c = encode(str[str_index]);\n\t\t\t\tif(nodes[node_index].nxt[c] == -1) {\n\t\t\t\t\tnodes[node_index].nxt[c] = (int) nodes.size();\n\t\t\t\t\tnodes.emplace_back(Node());\n\t\t\t\t}\n\t\t\t\tadd(str, str_index + 1, nodes[node_index].nxt[c], id);\n\t\t\t\tupdateChild(node_index, nodes[node_index].nxt[c], id);\n\t\t\t}\n\t\t}\n\t\tvoid add(const string &str,int id){add(str, 0, 0, id);}\n\tpublic:\n\t\tvector<Node>nodes;\n\t\tvector<int> ac; // ac[i] := i番目のパターンを受理する状態番号\n\t\tint root;\n\t\tTrie() : root(0){nodes.emplace_back(Node());}\n\t\tvoid add(const string &str){add(str, nodes[0].exist);}\n\t\tint size(){return (nodes[0].exist);}\n\t\tint nodesize(){return ((int) nodes.size());}\n};\n\nclass AhoCorasick : public Trie{\n\tpublic: \n\t\tstatic const int FAIL = MAX;\n\t\tvector<int> correct;\n\t\tAhoCorasick() : Trie() {}\n\n\t\tvoid build(){\n\t\t\tcorrect.resize(nodes.size());\n\t\t\trep(i,nodes.size())correct[i]=(int)nodes[i].accept.size();\n\n\t\t\tqueue<int> que;\n\t\t\trep(i,MAX+1){\n\t\t\t\tif(~nodes[0].nxt[i]) {\n\t\t\t\t\tnodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n\t\t\t\t\tque.emplace(nodes[0].nxt[i]);\n\t\t\t\t}else nodes[0].nxt[i] = 0;\n\t\t\t}\n\t\t\twhile(!que.empty()) {\n\t\t\t\tNode now = nodes[que.front()];\n\t\t\t\tcorrect[que.front()] += correct[now.nxt[FAIL]];\n\t\t\t\tque.pop();\n\t\t\t\trep(i,MAX){\n\t\t\t\t\tif(now.nxt[i] == -1) continue;\n\t\t\t\t\tint fail = now.nxt[FAIL];\n\t\t\t\t\twhile(nodes[fail].nxt[i] == -1) {\n\t\t\t\t\t\tfail = nodes[fail].nxt[FAIL];\n\t\t\t\t\t}\n\t\t\t\t\tnodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n\n\t\t\t\t\tauto &u = nodes[now.nxt[i]].accept;\n\t\t\t\t\tauto &v = nodes[nodes[fail].nxt[i]].accept;\n\t\t\t\t\tvector<int> accept;\n\t\t\t\t\tset_union(all(u),all(v),back_inserter(accept));\n\t\t\t\t\tu=accept;\n\t\t\t\t\tque.emplace(now.nxt[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// result := 各パターンがそれぞれ何度マッチしたか\n\t\tint match(const string &str,vector<int> &result,int now=0){\n\t\t\tresult.assign(size(),0);\n\t\t\tint count=0;\n\t\t\tfor(auto &c:str) {\n\t\t\t\twhile(nodes[now].nxt[encode(c)]==-1)now=nodes[now].nxt[FAIL];\n\t\t\t\tnow = nodes[now].nxt[encode(c)];\n\t\t\t\tcount += correct[now];\n\t\t\t\tfor(auto &v:nodes[now].accept)result[v]++;\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\t\tint next(int now,char c){\n\t\t\twhile(nodes[now].nxt[encode(c)]==-1)now=nodes[now].nxt[FAIL];\n\t\t\treturn nodes[now].nxt[encode(c)];\n\t\t}\n};\n\nint main(){\n\tstring s;\n\tint n;\n\tcin >> s >> n;\n\n\tAhoCorasick aho;\n\trep(i,n){\n\t\tstring a;\n\t\tcin >> a;\n\t\taho.add(a);\n\t}\n\tvector<int> res;\n\taho.build();\n\taho.match(s, res);\n\tfor(auto i : res) cout << (i == 0 ? 0 : 1) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct SA{\n  int n,k;\n  string S;\n  vector<int> r,r2,t,sa;\n  SA(){}\n  SA(string S):S(S){init();}\n  void init(){\n    n=S.size();\n    r.resize(n+1,0);\n    r2.resize(n+1,0);\n    t.resize(n+1,0);\n    sa.resize(n+1,0);\n    constract_sa();\n  }\n  bool compare_sa(int i,int j){\n    if(r[i]!=r[j]) return r[i]<r[j];\n    else{\n      int ri=i+k<=n?r[i+k]:-1;\n      int rj=j+k<=n?r[j+k]:-1;\n      return ri<rj;\n    }\n  }\n  void constract_sa(){\n    n=S.length();\n    for(int i=0;i<=n;i++){\n      sa[i]=i;\n      r[i]=i<n?S[i]:-1;\n    }\n    for(k=1;k<=n;k*=2){\n      sort(sa.begin(),sa.end(),[&](const int &i, const int &j){\n\t  if(r[i]!=r[j]) return r[i]<r[j];\n\t  else{\n\t    int ri=i+k<=n?r[i+k]:-1;\n\t    int rj=j+k<=n?r[j+k]:-1;\n\t    return ri<rj;\n\t  }\n\t});\n      t[sa[0]]=0;\n      for(int i=1;i<=n;i++){\n\tt[sa[i]]=t[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n      }\n      for(int i=0;i<=n;i++){\n\tr[i]=t[i];\n      }\n    }\n  }\n  bool contains(string T){\n    int a=0,b=S.length()+1;\n    while(b-a>1){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n};\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SA sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define REPV(i, v, n) for (int i=0,tmp=v;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define DWN(i, b, a) for (int i=int(b-1);i>=int(a);--i)\n\nusing namespace std;\n\ntypedef unsigned char byte;\n\nbyte mask[] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };\n#define tget(i) !!(t[(i)>>3]&mask[(i)&7])\n#define tset(i, b) t[(i)>>3]=(b) ? (mask[(i)&7]|t[(i)>>3]) : ((~mask[(i)&7])&t[(i)>>3])\n#define chr(i) (cs==sizeof(int)?((int*)s)[i]:((byte *)s)[i])\n#define isLMS(i) (i>0 && tget(i) && !tget(i-1))\n\nvoid getBuckets(byte *s, int *bkt, int n, int K, int cs, bool end=true){\n  fill(bkt, bkt + K + 1, 0);\n  REP(i,n)bkt[chr(i)]++;\n  REPV(i, 0, K+1)tmp += bkt[i], bkt[i] = end ? tmp : tmp - bkt[i];\n}\n\nvoid induceSAl(byte *t, int *SA, byte *s, int *bkt, int n, int K, int cs, bool end=false){\n  getBuckets(s, bkt, n, K, cs, end);\n  REP(i,n)if(SA[i]>0 && !tget(SA[i]-1)) SA[ bkt[chr(SA[i]-1)]++ ] = SA[i]-1;\n}\n\nvoid induceSAs(byte *t, int *SA, byte *s, int *bkt, int n, int K, int cs, bool end=true){\n  getBuckets(s, bkt, n, K, cs, end);\n  DWN(i,n,0)if(SA[i]>0 && tget(SA[i]-1))SA[--bkt[chr(SA[i]-1)]] = SA[i]-1;\n}\n\nvoid SA_IS(byte *s, int *SA, int n, int K=128, int cs=1) {\n  byte t[(n >> 3) + 1];\n  int bkt[K + 1],n1=0,name=0;\n  \n  tset(n-2, 0), tset(n-1, 1);\n  DWN(i,n-2,0)tset(i, (chr(i)<chr(i+1) || (chr(i)==chr(i+1) && tget(i+1))));\n  getBuckets(s, bkt, n, K, cs);\n  fill(SA, SA+n, -1);\n  FOR(i,1,n)if(isLMS(i))SA[--bkt[chr(i)]] = i;\n\n  induceSAl(t, SA, s, bkt, n, K, cs);\n  induceSAs(t, SA, s, bkt, n, K, cs);\n  \n  REP(i,n)if(isLMS(SA[i]))SA[n1++] = SA[i];\n  fill(SA + n1, SA + n, -1);\n\n  REPV(i,-1,n1){\n    int pos = SA[i], diff = false;\n    for(int d = 0; d < n && !diff; d++){\n      diff = chr(pos+d) != chr(tmp+d) || tget(pos+d) != tget(tmp+d);\n      if(!diff && d && (isLMS(pos+d) || isLMS(tmp+d)))break;\n    }\n    if(diff)name++,tmp=pos;\n    SA[ n1 + ((pos - (pos & 1)) >> 1) ] = name - 1;\n  }\n  int *s1 = SA + n - n1;\n  for(int i=n-1,j=n-1;i>=n1;i--)if(SA[i]>=0)SA[j--]=SA[i];\n  if(name < n1)SA_IS((byte*)s1, SA, n1, name - 1, sizeof(int));\n  else REP(i,n1)SA[s1[i]]=i;\n  \n  getBuckets(s, bkt, n, K, cs);\n  for(int i = 1, j = 0; i < n; i++)if(isLMS(i))s1[j++] = i;\n  REP(i,n1)SA[i]=s1[SA[i]];\n  fill(SA + n1, SA + n, -1);\n\n  DWN(i,n1,0){\n    int tmp = SA[i];\n    SA[i] = -1, SA[--bkt[chr(tmp)]] = tmp;\n  }\n  induceSAl(t, SA, s, bkt, n, K, cs);\n  induceSAs(t, SA, s, bkt, n, K, cs);\n}\n\nconst int maxn = 1000001;\nint n,sa[maxn];\n\nbool contain(string S, int *sa, string T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nchar a[maxn],b[maxn];\n\nint main(void){\n  int q;\n  scanf(\"%s\", a);\n  string s = string(a);\n  SA_IS((byte*) s.c_str(), sa, s.size()+1);\n\n  scanf(\"%d\", &q);\n  while(q--){\n    scanf(\"%s\", b);\n    if(contain(s, sa, string(b))) printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int mb=n/2,mc=n/2+n%2,b[mb],c[mc];\n    for(int i=0;i<mb;i++)b[i]=a[i];\n    for(int i=0;i<mc;i++)c[i]=a[mb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(mb,b,rh), mergesort(mc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==mc)a[i]=b[j++];\n      else if(j==mb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int sa[rh.n+1];\n  REP(i,rh.n+1)sa[i]=i;\n  mergesort(rh.n+1,sa,rh);\n  vector<int>res(rh.n+1);\n  REP(i,rh.n+1)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000000];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int B=999999937;\nconst int P=1000000007;\n\nvector<long long> gen_hash(const string &s){\n\tvector<long long> hash(s.size());\n\tlong long c=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tc=(c*B+s[i])%P;\n\t\thash[i]=c;\n\t}\n\treturn hash;\n}\nlong long pow_binary_mod(long long x,long long y,long long mod){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%mod;\n\t\tx=x*x%mod;\n\t}\n\treturn z;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s;\n\tcin>>s;\n\tvector<long long> v=gen_hash(s);\n\n\t//int T;\n\t//for(cin>>T;T--;){\n\t\tstring q;\n\t\tcin>>q;\n\t\tlong long hash=gen_hash(q)[q.size()-1];\n\t\tlong long Brev=pow_binary_mod(B,q.size(),P);\n\t\tvector<int> r;\n\t\tint i=q.size()-1;\n\t\tfor(;i<s.size();i++){\n\t\t\tlong long h=((v[i]-(i==q.size()-1?0:v[i-q.size()])*Brev)%P+P)%P;\n\t\t\tif(h==hash)break;//r.push_back(i-q.size()+1);\n\t\t}\n\t\tif(i<s.size()){\n\t\t\tfor(int i=0;i<r.size();i++)printf(\"%d\\n\",r[i]);\n\t\t\t//puts(\"1\");\n\t\t}else{\n\t\t\t//puts(\"0\");\n\t\t}\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n\tstring T, P;\n\tlong Q;\n\tcin >> T >> Q;\n\tfor (long i = 0; i < Q; i++){\n\t\tcin >> P;\n\t\tif (T.find(P, 0) != -1) printf(\"1\\n\");\n\t\telse printf(\"0\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst long long B=999999937LL;\nconst long long P=1000000007LL;\n\nvoid gen_hash(const string &s,vector<long long> &hash){\n\tlong long c=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tc=(c*(__int128_t)B+s[i])%P;\n\t\thash[i]=c;\n\t}\n}\nlong long pow_binary_mod(long long x,long long y,long long mod){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=(__int128_t)z*x%mod;\n\t\tx=(__int128_t)x*x%mod;\n\t}\n\treturn z;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s;\n\tcin>>s;\n\tint ls=s.size();\n\tvector<long long> v(ls),hsh(10001);\n\tgen_hash(s,v);\n\n\tint T;\n\tfor(cin>>T;T--;){\n\t\tstring q;\n\t\tcin>>q;\n\t\tint lq=q.size();\n\t\tgen_hash(q,hsh);\n\t\tlong long hash=hsh[lq-1];\n\t\tlong long Brev=pow_binary_mod(B,lq,P);\n\t\tvector<int> r;\n\t\tint i=lq-1;\n\t\tfor(;i<ls;i++){\n\t\t\tif(v[i]==((i>=lq?v[i-lq]:0)*(__int128_t)Brev+hash)%P){\n\t\t\t\tr.push_back(i-lq+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!r.empty()){\n\t\t\t//for(int i=0;i<r.size();i++)printf(\"%d\\n\",r[i]);\n\t\t\tputs(\"1\");\n\t\t}else{\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }  \n};\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  const int n = SZ(a);\n  if(n>1){\n    vector<int> b(a.begin(), a.begin()+n/2);\n    vector<int> c(a.begin()+n/2, a.end());\n    mergesort(b,rh);\n    mergesort(c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==SZ(c))a[i]=b[j++];\n      else if(j==SZ(b))a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  //sort(ALL(sa),rh);\n  mergesort(sa,rh);\n  //if(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    //if(S.compare(sa[c],T.length(),T)<0 )a=c;\n    //else b=c;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  while(n--){\n    cin >> t;\n    cout << contain(s,sa,t) << \"\\n\";\n    //cout << !!rh.find(t) << \"\\n\";\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cassert>\nusing namespace std;\n\nconst int ALPH = 256;\nstruct SuffixArray {\nprivate:\n    string s;\n    vector<int> rec, cnt;\n    int len, cnt_size;\npublic:\n    SuffixArray(string s_) : s(s_) {\n        s += \"$\"; // 辞書順で最も小さいダミー文字\n        len = s.length();\n        cnt_size = max(ALPH, len); cnt.resize(cnt_size);\n        rec = getArray();\n    }\n\n    void dump_array(vector<int> &indices, vector<int> &classes) {\n        fprintf(stderr, \"# debug\\n\");\n        fprintf(stderr, \"# indices:\");\n        for(int i=0; i<len; i++) fprintf(stderr, \" %d\", indices[i]);\n        fprintf(stderr, \"\\n\");\n        fprintf(stderr, \"# classes:\");\n        for(int i=0; i<len; i++) fprintf(stderr, \" %d\", classes[i]);\n        fprintf(stderr, \"\\n\");\n    }\n    \n    vector<int> getArray() {\n        vector<int> indices(len), prev_idx(len);\n        vector<int> classes(len), prev_cls(len);\n        vector<int> tmp_val(len);\n\n        // k == 0 はカウントソートのみ\n        for(int i=0; i<len; i++) {\n            cnt[ s[i] ]++;\n        }\n        for(int i=1; i<cnt_size; i++) {\n            cnt[i] += cnt[i-1];\n        }\n        for(int i=len-1; i>=0; i--) {\n            indices[ --cnt[ s[i] ] ] = i;\n        }\n        for(int i=1; i<len; i++) {\n            int pena = (s[ indices[i] ] != s[ indices[i-1] ]);\n            classes[ indices[i] ] = classes[ indices[i-1] ] + pena;\n        }\n        // dump_array(indices, classes);\n        \n        for(int k=0; (1 << k) < len; k++) {\n            swap(indices, prev_idx);\n            swap(classes, prev_cls);\n            for(int i=0; i<len; i++) {\n                // 後半だけソート済みにしたものを indices に代入\n                prev_idx[i] = prev_idx[i] - (1 << k);\n                if(prev_idx[i] < 0) prev_idx[i] += len;\n                tmp_val[i] = prev_cls[ prev_idx[i] ];\n            }\n\n            // 前半についてカウントソート\n            fill(cnt.begin(), cnt.end(), (int)0);\n            for(int i=0; i<len; i++) {\n                cnt[ tmp_val[i] ]++;\n            }\n            for(int i=1; i<cnt_size; i++) {\n                cnt[i] += cnt[i-1];\n            }\n            for(int i=len-1; i>=0; i--) {\n                indices[ --cnt[ tmp_val[i] ] ] = prev_idx[i];\n            }\n            classes[ indices[0] ] = 0;\n            for(int i=1; i<len; i++) {\n                int shift = (1 << k);\n                pair<int, int> pre(prev_cls[ indices[i-1] ], prev_cls[ (indices[i-1] + shift) % len ]);\n                pair<int, int> cur(prev_cls[ indices[i  ] ], prev_cls[ (indices[i  ] + shift) % len ]);\n                int pena = (pre != cur);\n                classes[ indices[i] ] = classes[ indices[i-1] ] + pena;\n            }   \n            // dump_array(indices, classes);\n        }\n        return indices;\n    }\n\n    int size() {\n        return rec.size();\n    }\n    int get(int idx) {\n        assert(0 <= idx and idx < size());\n        return rec[idx];\n    }\n    // パターン文字列 p は、idx 番目に小さい接尾辞に比べて大きいか？\n    bool is_greater(string &p, int idx) {\n        idx = get(idx);\n        int N = size(), M = p.size(), x, y;\n        for(x=idx, y=0; x<N and y<M; x++, y++) {\n            if(s[x] < p[y]) return true;\n            if(s[x] > p[y]) return false;\n        }\n        return x >= N and y < M;\n    }\n};\n\nint search_by_sa(SuffixArray &sa, string &p) {\n    int N = sa.size(), ansL, ansR;\n\n    int lb = 0, ub = N;\n    while(ub - lb > 1) {\n        int mid = (ub + lb) / 2;\n        if(sa.is_greater(p, mid)) lb = mid;\n        else ub = mid;\n    }\n    ansL = ub;\n\n    p.back()++;\n    \n    lb = 0, ub = N;\n    while(ub - lb > 1) {\n        int mid = (ub + lb) / 2;\n        if(sa.is_greater(p, mid)) lb = mid;\n        else ub = mid;\n    }\n    ansR = ub;\n    p.back()--;\n\n    return ansR - ansL;\n}\n\nint main() {\n    string s; cin >> s;\n    SuffixArray sa(s);\n\n    /*\n    for(int i=0; i<=s.length(); i++) {\n        cout << s.substr(sa.get(i)) << endl;\n    }\n    */\n\n    int N; cin >> N;\n    for(int i=0; i<N; i++) {\n        string p; cin >> p;\n        if(search_by_sa(sa, p) > 0) {\n            cout << 1 << endl;\n        }\n        else {\n            cout << 0 << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nstruct SuffixArray\n{\n    int sz,k;\n    string s;\n    vector<int> rank,sa;\n\n    SuffixArray(string str){\n        s=str;\n        sz=str.length();\n        rank.resize(sz+1);\n        sa.resize(sz+1);\n        build();\n    }\n\n    void build(){\n        for(int i=0;i<=sz;i++){\n            sa[i]=i;\n            rank[i]=i<sz?s[i]:-1;\n        }\n\n        auto compare = [&](int i, int j) {\n            if (rank[i] != rank[j]) return rank[i] < rank[j];\n            else {\n                int ri = i + k <= sz ? rank[i + k] : -1;\n                int rj = j + k <= sz ? rank[j + k] : -1;\n                return ri < rj;\n            }\n        };\n\n        vector<int> tmp(sz+1);\n        for(int k=1;k<=sz;k*=2){\n            sort(sa.begin(),sa.end(),compare);\n            tmp[sa[0]]=0;\n            for(int i=1;i<=sz;i++){\n                tmp[sa[i]]=tmp[sa[i-1]]+(compare(sa[i-1],sa[i])?1:0);\n            }\n            for(int i=0;i<=sz;i++){\n                rank[i]=tmp[i];\n            }\n        }\n    }\n    bool contains(string t){\n        int l=0,r=sz;\n        while(r-l>1){\n            int mid=(l+r)/2;\n            if(s.substr(sa[mid],t.length())<t) l=mid;\n            else r=mid;\n        }\n        return s.substr(sa[r],t.size()) ==t;\n    }\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n    string t;cin>>t;\n    int q;cin>>q;\n    SuffixArray sf(t);\n    for(int i=0;i<q;i++){\n        string p;cin>>p;\n        cout<<sf.contains(p)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\nusing namespace std;\nstring S, T;\nint main() {\n\tint q,sum;\n\tcin >> S;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tsum = 0;\n\t\tscanf(\"%s\", &T);\n\t\tif (S.size() >= T.size()) {\n\t\t\tfor (int i = 0; i <= S.size() - T.size(); i++) {\n\t\t\t\tif (T == S.substr(i, T.size())) {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\nconst ull B= 100000007;\null thash[1001];\null BB[1001];\nstring T;\nint bl;\n\nbool contain(string a){\n\tint al=a.length();\n\tull t;\n\t//B???al???????¨????\n\t/*\n\tull t=1;\n\tfor(int i=0;i<al;i++) t*=B;\n\t*/\n\t//a??¨b????????????al???????????¢?????????????????\\???????¨????\n\tull ah=0,bh=0;\n\tfor(int i=0;i<al;i++) ah=ah*B+a[i];\n\t//for(int i=0;i<al;i++) bh=bh*B+b[i];\n\t\n\t//b?????´????????????????????????????????????????????\\???????????§??????\n\tbh=thash[al];\n\tt=BB[al];\n\tfor(int i=0;i+al<=bl;i++){\n\t\tif(ah==bh) return true;\n\t\tbh=bh*B+T[i+al]-T[i]*t;\n\t}\n\treturn false;\n}\n\nint main(){\n\tint k;\n\tbool ans;\n\tstring P;\n\t\n\tcin>>T;\n\tbl=T.length();\n\t\n\tthash[0]=0;\n\tfor(int i=1;i<=1000;i++) thash[i]=thash[i-1]*B+T[i-1];\n\tBB[0]=1;\n\tfor(int i=1;i<=1000;i++) BB[i]=BB[i-1]*B;\n\t\n\tscanf(\"%d\",&k);\n\tfor(int i=0;i<k;i++){\n\t\tcin>>P;\n\t\tif(T.size()>=P.size()){\n\t\t\tans=contain(P); //P???T?????????????????????????\n\t\t\tif(ans) printf(\"1\\n\");\n\t\t\telse printf(\"0\\n\");\n\t\t}\n\t\telse\n\t\tprintf(\"0\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    build_sa();\n    //build_lcp();\n    //build_rmq();\n  }\n  void build_sa(){\n    S.push_back('$');\n    vector<int> c(n+1,0),ord(n+1,0);\n    for(int i=0;i<=n;i++) ord[i]=n-i;\n    sort(ord.begin(),ord.end(),[&](int a,int b){return S[a]<S[b];});\n    for(int i=0;i<=n;i++){\n      sa[i]=ord[i];\n      c[i]=S[i];\n    }\n    return;\n    for(int len=1;len<=n;len*=2){\n      vector<int> r=c;\n      for(int i=0;i<=n;i++){\n\t c[sa[i]] =\n\t   i > 0 &&\n\t   r[sa[i - 1]] == r[sa[i]] &&\n\t   sa[i - 1] + len <= n &&\n\t   r[sa[i - 1] + len / 2] == r[sa[i] + len / 2]\n\t   ? c[sa[i - 1]] : i;\n      }\n      vector<int> cnt(n+1);\n      for(int i=0;i<=n;i++) cnt[i]=i;\n      vector<int> s=sa;\n      for(int i=0;i<=n;i++){\n\tint s1=s[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n);\n    for(int i=0;i<n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  return 0;\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    //assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string& S):S(S){init();}\n  void init(){\n    n=S.length();\n    S.push_back('$');\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    sa.clear();\n    sa.resize(n+1,0);\n    iota(sa.begin(),sa.end(),0);\n    sort(sa.begin(),sa.end(),\n\t [&](int a,int b){\n\t   if(S[a]==S[b]) return a>b;\n\t   return S[a]<S[b];\n\t });\n    vector<int> c(n+1,0),r(n+1),cnt(n+1),s(n+1);\n    for(int i=0;i<=n;i++) r[i]=S[i];\n    for(int len=1;len<=n;len*=2){\n      for(int i=0;i<=n;i++){\n\t c[sa[i]]=\n\t   i>0 &&\n\t   r[sa[i-1]]==r[sa[i]] &&\n\t   sa[i-1]+len<=n &&\n\t   r[sa[i-1]+len/2]==r[sa[i]+len/2] ?\n\t   c[sa[i-1]]:i;\n      }\n      iota(cnt.begin(),cnt.end(),0);\n      copy(sa.begin(),sa.end(),r.begin());\n      for(int i=0;i<=n;i++){\n\tint s1=r[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n      c.swap(r);\n    }\n  }\n  \n  bool lt_substr(string &T,int si=0,int ti=0){\n    int sn=S.size(),tn=T.size();\n    while(si<sn&&ti<tn){\n      if(S[si]<T[ti]) return 1;\n      if(S[si]>T[ti]) return 0;\n      si++;ti++;\n    }\n    return si>=sn&&ti<tn;\n  }\n  \n  int lower_bound(string& T){\n    int low=0,high=n+1;\n    while(low+1<high){\n      int mid=(low+high)/2;\n      if(lt_substr(T,sa[mid],0)) low=mid;\n      else high=mid;\n    }\n    return high;\n  }\n  \n  int upper_bound(string& T){\n    T.back()++;\n    int res=lower_bound(T);\n    T.back()--;\n    return res;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string& T){\n    return upper_bound(T)-lower_bound(T);\n  }\n  \n  void build_lcp(){\n    lcp.clear();\n    lcp.resize(n+1,0);\n    vector<int> r2(n+1);\n    for(int i=0;i<=n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(max(a,0),b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n\n  int lower_bound2(string &T){\n    int sl=S.length(),tl=T.length();\n    if(lt_substr(T,sa[sl-1],0)) return sl;\n    int p=tl;\n    int low=0,high=sl-1;\n    int l=getlcp(sa[low],T,0);\n    int r=getlcp(sa[high],T,0);\n    while(low+1<high){\n      int mid=(low+high)/2;\n      int k;\n      if(l>=r){\n\tint m=rmq.query(low,mid);\n\tif(m<l){\n\t  high=mid,r=m;\n\t  continue;\n\t}\n\tk=l+getlcp(sa[mid],T,l);\n      }else{\n\tint m=rmq.query(mid,high);\n\tif(m<r){\n\t  low=mid,l=m;\n\t  continue;\n\t}\n\tk=r+getlcp(sa[mid],T,r);\n      }\n      if(k==p) high=mid,r=k;\n      else if(S[sa[mid]+k]<T[k]) low=mid,l=k;\n      else high=mid,r=k;\n    }\n\t\t\t\t \n    return high;\n  }\n\n  int upper_bound2(string &T){\n    T.back()++;\n    int res=lower_bound2(T);\n    T.back()--;\n    return res;\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string& T){\n    return  upper_bound2(T)-lower_bound2(T);\n  }\n};\n//END CUT HERE\n\nsigned AOJ_ALDS114D(){\n  static char buf[1000001];\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%d\\n\",!!sa.count2(P));\n    //assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/\n\nsigned JOI2009HO_A(){\n  int n,m;\n  string s;\n  cin>>n>>m>>s;\n  SuffixArray sa(s);\n  string t=\"I\";\n  for(int i=0;i<n;i++) t+=\"OI\";\n  cout<<sa.count(t)<<endl;\n  //cout<<sa.count2(t)<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://joi2009ho.contest.atcoder.jp/tasks/joi2009ho_a\n*/\n\nsigned main(){\n  AOJ_ALDS114D();\n  //JOI2009HO_A();\n  return 0;\n};"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 1000005\n\n//Suffix_Array\n//O(|T|log|S|) S??????????????????T????????????????????????????´¢\n#define rank A\nint n,Len;\nint rank[MAX_N+1];\nint tmp[MAX_N+1];\n\n//(rank[i],rank[i+k])??¨(rank[j],rank[j+k])?????????\nbool compare_sa(int i,int j){\n  if(rank[i]!=rank[j])return rank[i]<rank[j];\n  int ri=i+Len<=n?rank[i+Len]:-1;\n  int rj=j+Len<=n?rank[j+Len]:-1;\n  return ri<rj;\n}\n\n//?????????S?????\\?°??????????????§????\nvoid construct_sa(string S,int *sa){\n  n=S.length();\n  //?????????????????????????????????????????????????????????\n  for(int i=0;i<=n;i++){\n    sa[i]=i;\n    rank[i]=i<n?S[i]:-1;\n  }\n  //k????????????????????????????????????????????¨???????????????2k????????§?????????\n  for(Len=1;Len<=n;Len*=2){\n    sort(sa,sa+n+1,compare_sa);\n    //?????£??????tmp????¬?????????????????¨?????????????rank?????£??\\\n    tmp[sa[0]]=0;\n    for(int i=1;i<=n;i++)\n      tmp[sa[i]]=tmp[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n    for(int i=0;i<=n;i++)rank[i]=tmp[i];\n  }\n}\n\n//S??????????????????T????????????????????????????´¢??????\nbool contain(string S,int *sa,string T){\n  int left=0,right=S.length();\n  while(right-left>1){\n    int mid=(left+right)/2;\n    if(S.compare(sa[mid],T.length(),T)<0)left=mid;\n    else right=mid;\n  }\n  return S.compare(sa[right],T.length(),T)==0;\n}\n\nchar t[MAX_N],p[MAX_N];\nint q,sa[MAX_N];\nint main(){\n  cin>>t;\n  construct_sa(t,sa);\n  cin>>q;\n  while(q--){\n    scanf(\"%s\",p);\n    if(contain(t,sa,p))printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nclass StringSearch {\n\tconst int n;\n\tstring S;\n\tvector<int> SA, Rank;\npublic:\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), SA(n + 1), Rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tSA[i] = i;\n\t\t\tRank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tint k = 1;\n\t\tvector<int> tmp(n + 1);\n\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\tif (Rank[i] != Rank[j]) return Rank[i] < Rank[j];\n\t\t\telse {\n\t\t\t\tint ri = i + k <= n ? Rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? Rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t}\n\t\t};\n\t\tfor (; k <= n; k *= 2) {\n\t\t\tsort(SA.begin(), SA.end(), Compare_SA);\n\n\t\t\ttmp[SA[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[SA[i]] = tmp[SA[i - 1]] + (Compare_SA(SA[i - 1], SA[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tRank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(SA[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(SA[b], T.length(), T) == 0;\n\t}\n};\n\nint main()\n{\n\tint Q;\n\tstring T, P;\n\tcin.sync_with_stdio(false);\n\tcin >> T;\n\tStringSearch SS(T);\n\tcin >> Q;\n\twhile (Q--) {\n\t\tcin >> P;\n\t\tcout << SS.Contain(P) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nnamespace SA{\n    const int MAX=1000000;\n    int N,K;\n    int tmp[MAX+1],rank[MAX+1];\n    bool compare_sa(int i,int j){\n        if(rank[i]!=rank[j])return rank[i]<rank[j];\n        else{\n            int ri=(i+K<=N)?rank[i+K]:-1;\n            int rj=(j+K<=N)?rank[j+K]:-1;\n            return ri<rj;\n        }\n    }\n\n    vector<int> construct_sa(string S){\n        N=S.size();\n        vector<int>sa(N+1);\n        for(int i=0;i<=N;i++)sa[i]=i;\n        for(int i=0;i<=N;i++){\n            rank[i]=i==N?-1:S[i];\n        }\n\n        for(K=1;K<=N;K*=2){\n            sort(sa.begin(),sa.end(),compare_sa);\n            tmp[sa[0]]=0;\n            for(int i=1;i<=N;i++){\n                tmp[sa[i]]=tmp[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n            }\n            for(int i=0;i<=N;i++)rank[i]=tmp[i];\n        }\n        return sa;\n    }\n}\n\n\nbool exist(string &S,vint &sa,string &T){\n    int a=0,b=S.size();\n    while(b-a>1){\n        int c=(a+b)/2;\n        if(S.substr(sa[c],S.size()-sa[c])<T)a=c;\n        else b=c;\n    }\n    return S.substr(sa[b],min(S.size()-sa[b],T.size()))==T;\n}\n\nbool contain(string &S,vint &sa,string &T){\n    int a=0,b=S.size();\n    while(b-a>1){\n        int c=(a+b)/2;\n        if(S.compare(sa[c],T.size(),T)<0)a=c;\n        else b=c;\n    }\n    return S.compare(sa[b],T.size(),T)==0;\n}\n\nsigned main(){\n    string S;\n    vint sa;\n    int Q;\n    cin>>S;\n    sa=SA::construct_sa(S);\n    cin>>Q;\n\n    while(Q--){\n        string T;cin>>T;\n        if(exist(S,sa,T))cout<<1<<endl;\n        else cout<<0<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n/2+n%2,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==nc)a[i]=b[j++];\n      else if(j==nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  /*\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n  */\n  int sa[rh.n+1];\n  REP(i,rh.n+1)sa[i]=i;\n  sort(sa,sa+rh.n,rh);\n  vector<int>res(rh.n+1);\n  REP(i,rh.n+1)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring S,T;\nstring V[1000][100];\nint main(){\n\tint q,a,b,c;\n\tcin>>S;\n\tb=S.size();\n\ta=min(b,100);\n\tfor(int i=1;i<100;i++){\n\t\tfor(int j=0;j<=b-i;j++){\n\t\t\tV[j][i]=S.substr(j,i);\n\t\t}\n\t}\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>T;\n\t\tc=T.size();\n\t\tfor(int j=0;j<b-c;j++){\n\t\t\tif(V[j][c]==T){\n\t\t\t\tcout<<\"1\"<<endl;\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t}\n\t\tcout<<\"0\"<<endl;\n\t\tExit:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(a>b)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\nstruct SA{\n\tint n;\n\tvi sa,as,lcp;\n\ttemplate<class t> SA(t s):n(s.size()),sa(n),as(n),lcp(n-1){\n\t\trep(i,n)sa[i]=n-1-i;\n\t\tstable_sort(all(sa),[&](int a,int b){return s[a]<s[b];});\n\t\tvi c(n);\n\t\trep(i,n)c[i]=s[i];\n\t\tfor(int w=1;w<n;w*=2){\n\t\t\tvi d(c);\n\t\t\trep(i,n){\n\t\t\t\tif(i&&sa[i-1]+w<n&&d[sa[i-1]]==d[sa[i]]&&d[sa[i-1]+w/2]==d[sa[i]+w/2])\n\t\t\t\t\tc[sa[i]]=c[sa[i-1]];\n\t\t\t\telse\n\t\t\t\t\tc[sa[i]]=i;\n\t\t\t}\n\t\t\tvi e(sa),f(n);\n\t\t\tiota(all(f),0);\n\t\t\trep(i,n){\n\t\t\t\tint j=e[i]-w;\n\t\t\t\tif(j>=0)sa[f[c[j]]++]=j;\n\t\t\t}\n\t\t}\n\t\t//as\n\t\trep(i,n)as[sa[i]]=i;\n\t\t//lcp\n\t\tint w=0;\n\t\tfor(auto i:as){\n\t\t\tif(w)w--;\n\t\t\tif(i<n-1){\n\t\t\t\twhile(max(sa[i],sa[i+1])+w<n&&s[sa[i]+w]==s[sa[i+1]+w])w++;\n\t\t\t\tlcp[i]=w;\n\t\t\t}\n\t\t}\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tstring s;cin>>s;\n\tSA sa(s);\n\tdmp(sa.sa);\n\tint n=s.size();\n\t\n\tint q;cin>>q;\n\trep(_,q){\n\t\tstring p;cin>>p;\n\t\tconst auto cmp=[&](int x){\n\t\t\tint i=0,y=n-x,z=min(y,int(p.size()));\n\t\t\twhile(i<z&&s[x+i]==p[i])i++;\n\t\t\tif(i==z){\n\t\t\t\tif(y<int(p.size()))return -1;\n\t\t\t\tif(y>int(p.size()))return 1;\n\t\t\t\treturn 0;\n\t\t\t}else\n\t\t\t\treturn s[x+i]<p[i]?-1:1;\n\t\t};\n\t\tconst auto cmp2=[&](int x){\n\t\t\tint i=0,y=n-x,z=min(y,int(p.size()));\n\t\t\twhile(i<z&&s[x+i]==p[i])i++;\n\t\t\treturn i==z&&y>=int(p.size());\n\t\t};\n\t\tint lw=-1,up=n;\n\t\twhile(up-lw>1){\n\t\t\tint m=(up+lw)/2;\n\t\t\tif(cmp(sa.sa[m])<0)lw=m;\n\t\t\telse up=m;\n\t\t}\n\t\tdmp(up);\n\t\tif(up<n&&cmp2(sa.sa[up]))\n\t\t\tcout<<1<<\"\\n\";\n\t\telse\n\t\t\tcout<<0<<\"\\n\";\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\n\n// ------ Suffix Array ------ //\nclass SuffixArray {\n\tvoid CreateBeginBucket(vector<int>&v, vector<int>&bucket) {\n\t\tfill(bucket.begin(), bucket.end(), 0);\n\t\tfor (int i = 0; i<v.size(); i++)bucket[v[i]]++;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i<bucket.size(); i++) { bucket[i] += sum; swap(sum, bucket[i]); }\n\t}\n\tvoid CreateEndBucket(vector<int>&v, vector<int>&bucket) {\n\t\tfill(bucket.begin(), bucket.end(), 0);\n\t\tfor (int i = 0; i<v.size(); i++)bucket[v[i]]++;\n\t\tfor (int i = 1; i<bucket.size(); i++)bucket[i] += bucket[i - 1];\n\t}\n\tvoid InducedSort(vector<int>&v, vector<int>&SA, int mv, vector<int>&bucket, vector<int>&isL) {\n\t\tCreateBeginBucket(v, bucket);\n\t\tfor (int i = 0; i<v.size(); i++)if (SA[i]>0 && isL[SA[i] - 1])SA[bucket[v[SA[i] - 1]]++] = SA[i] - 1;\n\t}\n\tvoid InvertInducedSort(vector<int>&v, vector<int>&SA, int mv, vector<int>&bucket, vector<int>&isL) {\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = v.size() - 1; i >= 0; i--)if (SA[i]>0 && !isL[SA[i] - 1])SA[--bucket[v[SA[i] - 1]]] = SA[i] - 1;\n\t}\n\tvector<int>SA_IS(vector<int>v, int mv) {\n\t\tif (v.size() == 1)return vector<int>(1, 0);\n\t\tvector<int>isL(v.size());\n\t\tvector<int>bucket(mv + 1);\n\t\tvector<int>SA(v.size(), -1);\n\t\tauto isLMS = [&](int x)->bool {return x>0 && isL[x - 1] && !isL[x]; };\n\t\tisL[v.size() - 1] = 0;\n\t\tfor (int i = v.size() - 2; i >= 0; i--)isL[i] = v[i]>v[i + 1] || (v[i] == v[i + 1] && isL[i + 1]);\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))SA[--bucket[v[i]]] = i;\n\t\tInducedSort(v, SA, mv, bucket, isL);\n\t\tInvertInducedSort(v, SA, mv, bucket, isL);\n\t\tint cur = 0;\n\t\tvector<int>ord(v.size());\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))ord[i] = cur++;\n\t\tvector<int>nxv(cur);\n\t\tcur = -1;\n\t\tint prev = -1;\n\t\tfor (int i = 0; i<v.size(); i++) {\n\t\t\tif (!isLMS(SA[i]))continue;\n\t\t\tbool diff = false;\n\t\t\tfor (int d = 0; d<v.size(); d++) {\n\t\t\t\tif (prev == -1 || v[SA[i] + d] != v[prev + d] || isL[SA[i] + d] != isL[prev + d]) {\n\t\t\t\t\tdiff = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (d>0 && isLMS(SA[i] + d))break;\n\t\t\t}\n\t\t\tif (diff) { cur++; prev = SA[i]; }\n\t\t\tnxv[ord[SA[i]]] = cur;\n\t\t}\n\t\tvector<int>reord(nxv.size());\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))reord[ord[i]] = i;\n\t\tvector<int>nxSA = SA_IS(nxv, cur);\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = 0; i<SA.size(); i++)SA[i] = -1;\n\t\tfor (int i = nxSA.size() - 1; i >= 0; i--)SA[--bucket[v[reord[nxSA[i]]]]] = reord[nxSA[i]];\n\t\tInducedSort(v, SA, mv, bucket, isL);\n\t\tInvertInducedSort(v, SA, mv, bucket, isL);\n\t\treturn SA;\n\t}\n\tvector<int>SA_IS(string s) {\n\t\tvector<int>v(s.size() + 1);\n\t\tfor (int i = 0; i<s.size(); i++)v[i] = s[i] + 1;\n\t\treturn SA_IS(v, *max_element(v.begin(), v.end()));\n\t}\n\tvector<int>construct_lcp(string &s, vector<int>&sa) {\n\t\tvector<int> lcp, rank(s.size() + 1);\n\t\tint n = s.size();\n\t\tfor (int i = 0; i <= n; i++)rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tlcp[0] = 0;\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h>0) h--;\n\t\t\tfor (; j + h<n&&i + h<n; h++) {\n\t\t\t\tif (s[j + h] != s[i + h])break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\npublic:\n\tstring s;\n\tvector<int> sa, lcp;\n\tvoid init(string &T) {\n\t\ts = T;\n\t\tsa = SA_IS(s);\n\t}\n\tSuffixArray(string &t) { init(t); }\n\tSuffixArray() {}\n\tbool contain(string &t) {\n\t\tint a = 0, b = s.size();\n\t\twhile (b - a>1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (s.compare(sa[c], t.size(), t) < 0)a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn s.compare(sa[b], t.size(), t) == 0;\n\t}\n};\n\n// ------ Main ------ //\nint q; string s, t;\nint main() {\n\tcin >> s >> q;\n\tSuffixArray v(s);\n\tfor(int i = 0; i < q; i++) {\n\t\tcin >> t;\n\t\tcout << (v.contain(t) ? 1 : 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n#define MAX_N 1100000\nint Rank[MAX_N],x[MAX_N];\nint SA[MAX_N];string S,T;int V;\nbool Compare(int p,int q){\n\tif(Rank[p]<Rank[q])return true;\n\tif(Rank[p]>Rank[q])return false;\n\tint D1=-1,D2=-1;]\n\tif(p+V<=S.size())D1=Rank[p+V];\n\tif(q+V<=S.size())D2=Rank[q+V];\n\tif(D1<D2)return true;\n\treturn false;\n}\nvoid Build(){\n\tfor(int i=0;i<S.size();i++){SA[i]=i;Rank[i]=S[i];}\n\tSA[S.size()]=S.size();Rank[S.size()]=-1;\n\tfor(V=1;V<=S.size();V*=2){\n\t\tsort(SA.begin(),SA.end(),Compare)\n\t\tx[SA[0]]=0;\n\t\tfor(int i=1;i<=S.size();i++){\n\t\t\tx[SA[i]]=x[SA[i-1]]+Compare(SA[i-1],SA[i]);\n\t\t}\n\t\tfor(int i=0;i<=S.size();i++)Rank[i]=x[i];\n\t}\n}\nint hantei(string &V1,string &V2){\n\tint H=min(V1.size(),V2.size());\n\tfor(int i=0;i<H;i++){\n\t\tif(V1[i]<V2[i])return -1:\n\t\tif(V1[i]>V2[i])return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tcin>>S;int Q;cin>>Q;\n\tfor(int i=0;i<Q;i++){\n\t\tcin>>T;int L=0,R=S.size()+1,M;\n\t\twhile(L+1<R){\n\t\t\tM=(L+R)/2;\n\t\t\tif(hantei(S+SA[M],T)<=0)L=M;\n\t\t\telse{R=M;}\n\t\t}\n\t\tif(hantei(S+SA[L],T)==0)cout<<\"1\"<<endl;\n\t\telse cout<<\"0\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Multiple string matching (suffix array)\n * O(T log T + \\sum (P_i log T))\n *\n * Construction: reduce to sorting the cyclic shifts of A||'$'\n */\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconstexpr int kAlphabetSize = 37;\n\nint ValueOf(char ch) {\n  if (ch == '$')\n    return 0;\n  if ('0' <= ch && ch <= '9')\n    return 1 + ch - '0';\n  if ('a' <= ch && ch <= 'z')\n    return 11 + ch - 'a';\n  cout << \"Unexpected character!\" << endl;\n  exit(1);\n  return -1;\n}\n\nvector<int> SortCyclicShifts(string &A) {\n  // Approach: sort cyclic substrings of length 1, 2, 4, ..., 2^(\\ceil \\lg n)\n  int n = A.size();\n\n  // After step k,\n  // p[i] stores the index (in A) of the ith-smallest (starting\n  // from 0) cyclic substring of A of length 2^k;\n  // c[i] stores the equivalence class (dense, starting from 0, in increasing\n  // sorted value order) of the length-2^k substring starting at A[i]\n  //\n  // psecond and cnext are temporary arrays used to populate p and c each step\n  // count is an auxiliary array used for bucket sort\n  vector<int> p(n), c(n), psecond(n), cnext(n), count(max(n, kAlphabetSize));\n\n  // Step 1: sort cyclic substrings of length 1\n  for (int i = 0; i < n; ++i)\n    ++count[ValueOf(A[i])];\n  for (int i = 1; i < count.size(); ++i)\n    count[i] += count[i - 1];\n  for (int i = n - 1; i >= 0; --i)\n    p[--count[ValueOf(A[i])]] = i;\n\n  int num_classes = 1;\n  for (int i = 1; i < n; ++i) {\n    if (A[p[i]] != A[p[i - 1]]) {\n      c[p[i]] = num_classes;\n      ++num_classes;\n    } else {\n      c[p[i]] = c[p[i - 1]];\n    }\n  }\n\n  // Step 2: for each k=1,...,ceil(log2(n)), use\n  // the result of sorting the cyclic substrings of length 2^{k-1} to\n  // sort the cyclic substrings of length 2^k\n  for (int h /* k-1 */ = 0; (1 << h) < n; ++h) {\n    // First, sort the cyclic substrings of length 2^k by their second halves;\n    // to do this, directly apply the fact that the second half of a length\n    // 2^k substring starting at index i is the length-2^{k-1} substring\n    // starting at index (i+2^{k-1})\n    for (int i = 0; i < n; ++i) {\n      psecond[i] = p[i] - (1 << h);\n      if (psecond[i] < 0)\n        psecond[i] += n;\n    }\n\n    // Second, complete the sort of cyclic substrings of\n    // length 2^k by performing an in-place sort keyed by their first halves\n    fill_n(begin(count), num_classes, 0);\n\n    // Count the number of occurrences of each equivalence class\n    // among cyclic substrings of length 2^{k-1}\n    for (int i = 0; i < n; ++i)\n      ++count[c[i]];\n    for (int i = 1; i < num_classes; ++i)\n      count[i] += count[i - 1];\n\n    // Proceding in decreasing order sorted by second half,\n    // put each index of the array at the last available spot of the\n    // range, in sorted order, accorded to the equivalence class to which\n    // the index's _first_ half belongs\n    for (int i = n - 1; i >= 0; --i)\n      p[--count[c[psecond[i]]]] = psecond[i];\n\n    num_classes = 1;\n    cnext[p[0]] = 0;\n    for (int i = 1; i < n; ++i) {\n      if (c[p[i]] == c[p[i - 1]] &&\n          c[p[i] + (1 << h) % n] == c[p[i - 1] + (1 << h) % n]) {\n        cnext[p[i]] = cnext[p[i - 1]];\n      } else {\n        cnext[p[i]] = cnext[p[i - 1]] + 1;\n        ++num_classes;\n      }\n    }\n\n    c.swap(cnext);\n  }\n\n  return p;\n}\n\nint main() {\n  string T;\n  cin >> T;\n  T.push_back('$');\n\n  auto suf = SortCyclicShifts(T);\n\n  int q;\n  cin >> q;\n  string P;\n  for (int i = 0; i < q; ++i) {\n    cin >> P;\n    auto res =\n        lower_bound(begin(suf), end(suf), P, [&T](int x, const string &P) {\n          string cmp = T.substr(x, P.size());\n          return cmp < P;\n        });\n    cout << (res != end(suf) && (P == T.substr(*res, P.size()))) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string.h>\nusing namespace std;\n\n#define TEXT_T_MAX 1000000 \n#define TEXT_P_MAX 1000\n\nbool searchText(const char t1[], const char t2[]);\nbool compareText(const char *t1, char const *t2, int len);\n\nint main (void)\n{\n\tchar t[TEXT_T_MAX + 1] = \"\\0\";\n\tcin >> t;\n\tint\tq;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tchar p[TEXT_P_MAX + 1] = \"\\0\";\n\t\tcin >> p;\n\t\tcout << (int)searchText(t, p) << endl;\n\t}\n\n\treturn 0;\t\n}\n\nbool searchText(const char t1[], const char t2[])\n{\n\tint t1_len = strlen(t1);\n\tint t2_len = strlen(t2);\n\n\tif (t1_len < t2_len) return false;\n\n\tfor (int i = 0; i + t2_len <= t1_len; i++) {\n\t\tif (compareText(&t1[i], t2, t2_len)) return true;\n\t}\n\treturn false;\n}\n\nbool compareText(const char *t1, const char *t2, int len)\n{\n\tfor (int i = 0; i < len; i++) {\n\t\tif (*(t1 + i) != *(t2 + i)) return false;\n\t}\n\treturn true;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nvector<string> sa;\nstring P;\nint Plen;\n\nvoid qmultisort(vector<string> &src, int size, int suffix) {\n    if (size <= 1) {\n        return;\n    }\n    vector<string> lower, middle, larger;\n    char pivot = src[size / 2][suffix];\n\n    for (int i = 0; i < size; i++) {\n        if (src[i][suffix] == pivot) {\n            middle.push_back(src[i]);\n        }\n        else if (src[i][suffix] < pivot) {\n            lower.push_back(src[i]);\n        }\n        else {\n            larger.push_back(src[i]);\n        }\n    }\n    \n    int lowsize = lower.size(), midsize = middle.size(), larsize = larger.size(), now = 0;\n    qmultisort(lower, lowsize, suffix);\n    qmultisort(middle, midsize, suffix + 1);\n    qmultisort(larger, larsize, suffix);\n\n    for (int i = 0; i < lowsize; i++) {\n        src[now++] = lower[i];\n    }\n    for (int i = 0; i < midsize; i++) {\n        src[now++] = middle[i];\n    }\n    for (int i = 0; i < larsize; i++) {\n        src[now++] = larger[i];\n    }\n}\n\nbool binary_search(int left, int right) {\n    if (left == right) {\n        if (P == sa[left].substr(0, Plen)) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    \n    int pivot = (left + right) / 2;\n    if (P < sa[pivot]) {\n        return binary_search(0, pivot - 1);\n    }\n    else {\n        return binary_search(pivot + 1, right);\n    }\n}\n\nint main() {\n    string T;\n    int Tlen, n;\n    cin >> T;\n    Tlen = T.size();\n\n    sa.resize(Tlen);\n    for (int i = 0; i < Tlen; i++) {\n        sa[i] = T.substr(i);\n    }\n    qmultisort(sa, Tlen, 0);\n\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> P;\n        Plen = P.size();\n        cout << binary_search(0, Tlen - 1) << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\nconst int MOD = 1000000000 + 7;\n\n\nclass SuffixArray {\n    int n, k;\n    std::vector<int> rank;\n    std::vector<int> tmp;\n\npublic:\n    const std::string s;\n    std::vector<int> sa;\n    std::vector<int> lcp;\n\n\npublic:\n    SuffixArray(const std::string &s) : n(s.size()), s(s) {\n        sa.assign(n + 1, 0);\n        lcp.assign(n, 0);\n        rank.assign(n + 1, 0);\n        tmp.assign(n + 1, 0);\n    }\n\n    void build() {\n        this->construct_sa();\n        this->construct_lcp();\n    }\n\n    // sがpatternを含んでいるか\n    bool contain(const string &pattern) {\n        int left = 0, right = n;\n        while (right - left > 1) {\n            int c = (left + right) / 2;\n            // Sのsa[c]文字目から|T|文字とTを比較\n            if (s.compare(sa[c], pattern.length(), pattern) < 0) {\n                left = c;\n            }\n            else {\n                right = c;\n            }\n        }\n        return s.compare(sa[right], pattern.length(), pattern) == 0;\n    }\n\n    // sa上で最初にpatternが現れる位置\n    int lower_bound(const string &pattern) {\n        int left = -1, right = n;\n        while (right - left > 1) {\n            int c = (left + right) / 2;\n            int ret = s.compare(sa[c], pattern.length(), pattern);\n            // patternが大きい\n            if (ret >= 0) {\n                 right = c;\n            }\n            else {\n                left = c;\n            }\n        }\n        if (s.compare(sa[right], pattern.length(), pattern) == 0) {\n            return right;\n        }\n        return -1;\n    }\n\n    // sa上で最後にpatternが現れる位置\n    int upper_bound(const string &pattern) {\n        int left = -1, right = n + 1;\n        while (right - left > 1) {\n            int c = (left + right) / 2;\n            int ret = s.compare(sa[c], pattern.length(), pattern);\n            // patternが小さい\n            if (ret <= 0) {\n                left = c;\n            }\n            else {\n                right = c;\n            }\n        }\n        if (s.compare(sa[left], pattern.length(), pattern) == 0) {\n            return left;\n        }\n        return -1;\n    }\n\n    void debug() {\n        std::cout << \"idx lcp sa sa[i]\" << std::endl;\n        for (int i = 0; i < n; ++i) {\n            std::cout << i << \" \" << lcp[i] << \" \" << sa[i] << \" \" << s.substr(sa[i]) << std::endl;\n        }\n    }\n\nprivate:\n    struct compare {\n        compare(const SuffixArray &sa) : sa(sa) {}\n        const SuffixArray &sa;\n\n        // (rank[i], rank[i + k])と(rank[j], rank[j + k])を比較\n        bool operator()(const int &i, const int &j) {\n            if (sa.rank[i] != sa.rank[j]) {\n                return sa.rank[i] < sa.rank[j];\n            }\n            else {\n                int ri = i + sa.k <= sa.n ? sa.rank[i + sa.k] : -1;\n                int rj = j + sa.k <= sa.n ? sa.rank[j + sa.k] : -1;\n                return ri < rj;\n            }\n        }\n    };\n\n    void construct_sa() {\n        for (int i = 0; i <= n; i++) {\n            sa[i] = i;\n            rank[i] = i < n ? s[i] : -1;\n        }\n        // k文字についてソートされているところから、2k文字でソートする\n        for (k = 1; k <= n; k *= 2) {\n            sort(sa.begin(), sa.end(), compare(*this));\n            // いったんtmpに次のランクを計算し、それからrankに移す\n            tmp[sa[0]] = 0;\n            for (int i = 1; i <= n; i++) {\n                tmp[sa[i]] = tmp[sa[i - 1]] + (compare(*this).operator()(sa[i - 1], sa[i]) ? 1 : 0);\n            }\n            for (int i = 0; i <= n; i++) {\n                rank[i] = tmp[i];\n            }\n        }\n    }\n\n    void construct_lcp() {\n        for (int i = 0; i <= n; i++) {\n            rank[sa[i]] = i;\n        }\n        int h = 0;\n        lcp[0] = 0;\n        for (int i = 0; i < n; i++) {\n            // 文字列中での位置iの接尾辞と、接尾辞配列中でその1つ前の接尾辞のLCPを求める\n            int j = sa[rank[i] - 1];\n            // hを先頭の分1減らし、後ろが一致しているだけ増やす\n            if (h > 0) {\n                h--;\n            }\n            for (; j + h < n and i + h < n; h++) {\n                if (s[j + h] != s[i + h]) {\n                    break;\n                }\n            }\n            lcp[rank[i] - 1] = h;\n        }\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    string s;\n    cin >> s;\n\n    SuffixArray sa(s);\n    sa.build();\n\n    int Q;\n    cin >> Q;\n    FOR(i, 0, Q) {\n        string p;\n        cin >> p;\n        print(sa.contain(p) ? 1 : 0);\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct suffix_array{\n    int n;\n    vector <int> x;\n    suffix_array(const char *s) : n(strlen(s)),x(n){\n        vector<int> r(n),t(n);\n        for (int i = 0; i < n; ++i) r[x[i] = i] = s[i];\n        for (int h = 1; t[n-1] != n-1 ; h *= 2) {\n            auto cmp = [&](int i,int j){\n                if(r[i] != r[j]) return r[i] < r[j];\n                return i + h < n && j + h < n ? r[i+h] < r[j+h] : i >j;\n            };\n            sort(x.begin(),x.end(),cmp);\n            for (int i = 0; i + 1 < n ; ++i)  t[i + 1] = t[i] + cmp(x[i],x[i+1]);\n            for (int i = 0; i < n; ++i)  r[x[i]] = t[i];\n        }\n    }\n    int operator[] (int i) const {return x[i];}\n};\n\nbool contain(const string &S, int *sa, const string &T) {\n    int lb = -1, ub = S.size() - 1;\n    while(ub -lb > 1){\n        int mid = (lb + ub )/ 2;\n        if(S.compare(sa[mid], T.size(), T) >= 0) ub = mid;\n        else lb = mid;\n    }\n    return S.compare(sa[ub], T.size(), T) == 0;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    string T; cin >> T;\n    int Q; cin >> Q;\n    suffix_array sary(T.c_str());\n    while(Q--){\n        string P; cin >> P;\n        cout << (contain(T,sary.x.data(),P) ? 1 : 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\n//typedef pair<ll, ll> P;\n//const double INF = 1e10;\n//const ll INF = LONG_LONG_MAX / 10;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\nconst int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\ntypedef pair<int, int> P;\n\nbool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\n\n\nvoid print_line(vector<int> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\n\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\nconst int mod = 1000000007;\n\nvoid buildSA(const string &s, vector<ll> &sa, vector<ll> &rank) {\n    int N = s.size();\n    vector<int> tmp(N + 1);\n    sa.assign(N + 1, 0);\n    rank.assign(N + 1, 0);\n    for (int i = 0; i < N + 1; ++i) sa[i] = i, rank[i] = (i < N ? s[i] : -1);\n\n    int h;\n    auto comp = [&](int x, int y) {\n        return rank[x] != rank[y] ? rank[x] < rank[y]\n                                  : (x + h <= N ? rank[x + h] : -1) < (y + h <= N ? rank[y + h] : -1);\n    };\n    for (h = 1; h <= N; h *= 2) {\n        sort(sa.begin(), sa.end(), comp);\n        tmp[sa[0]] = 0;\n        for (int i = 1; i <= N; ++i)\n            tmp[sa[i]] = tmp[sa[i - 1]] + (comp(sa[i - 1], sa[i]) ? 1 : 0);\n        for (int i = 0; i <= N; ++i)\n            rank[i] = tmp[i];\n    }\n}\n\nint findSA(const string &t, const string &p, const vector<ll> &sa) {\n    int a = 0, b = t.size(), m = p.size();\n    while (a < b) {\n        int c = (a + b) / 2;\n        if (strncmp(t.c_str() + sa[c], p.c_str(), m) < 0)\n            a = c + 1;\n        else\n            b = c;\n    }\n    return strncmp(t.c_str() + sa[a], p.c_str(), m) == 0 ? sa[a] : -1;\n}\n\nint main() {\n\n\n    string text;\n    cin >> text;\n    vector<ll> sa, rank;\n    buildSA(text, sa, rank);\n\n    int l;\n    cin >> l;\n    rep(i, l) {\n        string p;\n        cin >> p;\n        cout << (findSA(text, p, sa) != -1) << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstring S; string U;\nvector<string>T; int N;\nint main() {\n\tcin >> S >> N;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tint L = S.size() - i;\n\t\tif (L > 1000)L = 1000;\n\t\tT.push_back(S.substr(i, L));\n\t}\n\tsort(T.begin(), T.end());\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> U;\n\t\tint pos = lower_bound(T.begin(), T.end(), U) - T.begin();\n\t\tstring V = T[pos].substr(0, U.size());\n\t\tif (U == V) { cout << \"1\" << endl; }\n\t\telse { cout << \"0\" << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define MAX 10002\ntypedef unsigned char byte;\nbyte mask[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\n\nint Lv[MAX];\nint n, k;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n    return L_i < L_j;\n}\n\nint main()\n{\n    int A[MAX];\n    char c[MAX];\n    scanf(\"%s\", c);\n    std::string T = std::string(c);\n    n = T.size();\n    byte *t;\n    t = new byte [(n >> 3) + 1];\n\tbool act;\n\tint l, r;\n\n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n\t\n\tbyte bkt[129];\n\tfor(i = 0; i < 129; i++){ bkt[i] = 0; }\n\tfor(i = 0; i < n; i++){ bkt[Lv[i]]++; }\n\tint sum = 0;\n\tfor(i = 0; i < 129; i++){ sum += bkt[i]; bkt[i] = sum; }\n\tfor(i = 0; i < n; i++){ A[--bkt[Lv[i]]] = i; }\n\n    std::sort(A, A + n, cmp_Lv);\n\n\n\n\n    for(i = 1; i < n; i++){\n        t[i >> 3] = (Lv[A[i]] != Lv[A[i - 1]] ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n    }\n    t[n >> 3] = t[n >> 3] | mask[n & 7];\n\n    Lv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n    }\n\n    k = 1;\n    while(1){\n        if(k > n) break;\n\n        act = true;\n        for(i = 1; i <= n; i++){\n            if(act){\n                if(!!(mask[i & 7] & t[i >> 3])){ continue; }\n                else{ l = i - 1; act = false; }\n            }else{\n                if(!!(mask[i & 7] & t[i >> 3])){\n                    r = i; std::sort(A + l, A + r, cmp); act = true; }\n                    else{ continue; }\n            }\n        }\n\n        for(i = 1; i < n; i++){\n            t[i >> 3] = (cmp(A[i - 1], A[i]) ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n        }\n        t[n >> 3] = t[n >> 3] | mask[n & 7];\n\n        Lv[A[0]] = 0;\n        for(i = 1; i < n; i++){\n            Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n        }\n\n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n\n    char p[1000];\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n\n    A[n] = n;\n\n    while(q){\n        scanf(\"%s\", p);\n        std::string P = std::string(p);\n        left = 0, right = n, exist = false;\n        while(left < right){\n\n            if(n < P.size()){ exist = false; break; }\n\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n\n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <map>\n#include <new>\n#include <deque>\n#include <functional>\nusing namespace std;\n\ntemplate <class T>\nstruct myalloc{\n\tusing value_type = T;\n\n\tstatic const int num = 1024;\n\tint k;\n\n\tdeque<vector<char>> dq;\n\tmyalloc() : k(num) {}\n\n\ttemplate <class U>\n\tmyalloc(const myalloc<U> &){}\n\n\tT* allocate(size_t n){\n\t\tif(k >= num){\n\t\t\tdq.emplace_back(num * sizeof(T));\n\t\t\tk = 0;\n\t\t}\n\t\treturn reinterpret_cast<T*>(&dq.back()[k++ * sizeof(T)]);\n\t}\n\n\tvoid deallocate(T*, size_t){}\n};\n\ntemplate <class T, class U>\nbool operator==(const myalloc<T>&, const myalloc<U>&)\n{ return true; }\n\ntemplate <class T, class U>\nbool operator!=(const myalloc<T>&, const myalloc<U>&)\n{ return false; }\n\nstruct node{\n\tint fail;\n\tbool vis;\n\tmap<char,int,less<char>,myalloc<char>> nxt;\n};\n\nvector<node> trie;\n\nstring input(){\n\tstatic char buf[1000010];\n\tbuf[0] = 0;\n\tscanf(\"%s\", buf);\n\treturn buf;\n}\n\nint main(){\n\ttrie.reserve(1000010);\n\n\ttrie.emplace_back();\n\ttrie[0].fail = -1;\n\n\tstring t = input();\n\tint q;\n\tscanf(\"%d\", &q);\n\tvector<int> idx(q);\n\tfor(int i = 0; i < q; ++i){\n\t\tstring p = input();\n\t\tint u = 0;\n\t\tfor(char c : p){\n\t\t\tif(!trie[u].nxt.count(c)){\n\t\t\t\ttrie[u].nxt.emplace(c, trie.size());\n\t\t\t\ttrie.emplace_back();\n\t\t\t}\n\t\t\tu = trie[u].nxt[c];\n\t\t}\n\t\tidx[i] = u;\n\t}\n\n\tvector<int> bfs;\n\tbfs.push_back(0);\n\tint k = 0;\n\twhile(k < (int)bfs.size()){\n\t\tint u = bfs[k++];\n\t\tfor(const auto &pr : trie[u].nxt){\n\t\t\tchar c = pr.first;\n\t\t\tint v = pr.second;\n\t\t\tbfs.push_back(v);\n\n\t\t\tint f = trie[u].fail;\n\t\t\twhile(f >= 0 && !trie[f].nxt.count(c)){\n\t\t\t\tf = trie[f].fail;\n\t\t\t}\n\t\t\ttrie[v].fail = f >= 0 ? trie[f].nxt[c] : 0;\n\t\t}\n\t}\n\n\tint r = 0;\n\tfor(char c : t){\n\t\twhile(r >= 0 && !trie[r].nxt.count(c)){\n\t\t\tr = trie[r].fail;\n\t\t}\n\t\tr = r >= 0 ? trie[r].nxt[c] : 0;\n\t\ttrie[r].vis = true;\n\t}\n\n\tfor(int i = bfs.size(); --i; ){\n\t\tint u = bfs[i];\n\t\tif(trie[u].vis){\n\t\t\ttrie[trie[u].fail].vis = true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < q; ++i){\n\t\tprintf(\"%d\\n\", +trie[idx[i]].vis);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nclass SuffixArrayInducedSorting\n{\nprivate:\n    static constexpr int encode(const int c) { return c == '$' ? 0 : 'a' <= c and c <= 'z' ? c - 'a' + 1 : 'A' <= c and c <= 'Z' ? c - 'A' + 27 : c - '0' + 53; }\n    static constexpr char decode(const int n) { return (n == 0 ? '$' : 'a' + n - 1); }\n    enum class Type : char {\n        L = 0,\n        S = 1,\n        LMS = 2,\n    };\n\npublic:\n    SuffixArrayInducedSorting(const string& s, const int kind_) : N(s.size() + 1), kind{kind_ + 1}, S(s.size() + 1, 0), type(N), next(N, 1), bucket(kind), num(kind, 0), head(kind, 0), tail(kind, 0)\n    {\n        for (int i = 0; i < s.size(); i++) {\n            S[i] = encode(s[i]);\n        }\n        initializeData();\n        sortLMS();\n    }\n    SuffixArrayInducedSorting(const vector<int>& s, const int kind_) : N(s.size() + 1), kind{kind_ + 1}, S(s), type(N), next(N, 1), bucket(kind), num(kind, 0), head(kind, 0), tail(kind, 0)\n    {\n        S.push_back(0);\n        initializeData();\n        sortLMS();\n    }\n    void debugPrint() const\n    {\n        for (int i = 0; i < N; i++) {\n            cout << decode(S[i]);\n        }\n        cout << endl;\n        for (int i = 0; i < N; i++) {\n            cout << (type[i] == Type::L ? \"L\" : \"S\");\n        }\n        cout << endl;\n        for (int i = 0; i < N; i++) {\n            cout << (type[i] == Type::LMS ? \"@\" : \" \");\n        }\n        cout << endl;\n        for (int i = 0; i < kind; i++) {\n            if (bucket[i].empty())\n                continue;\n            cout << \"[\" << decode(i) << \"]:\\n\";\n            for (const int p : bucket[i]) {\n                cout << \"  \" << p << endl;\n            }\n        }\n    }\n\n    vector<int> getSuffixArray() const\n    {\n        vector<int> ans(N - 1);\n        for (int pos = 0, i = 1; i < kind; i++) {  // 番兵以外\n            for (const int p : bucket[i]) {\n                ans[pos++] = p;\n            }\n        }\n        return ans;\n    }\n\nprivate:\n    void initializeData()\n    {\n        for (const int i : S) {\n            num[i]++;\n        }\n        for (int i = 0; i < kind; i++) {\n            bucket[i].resize(num[i], -1);\n            tail[i] = num[i] - 1;\n        }\n        type[N - 1] = Type::S;\n        for (int i = N - 2; i >= 0; i--) {\n            type[i] = (S[i] != S[i + 1] ? (S[i] < S[i + 1] ? Type::S : Type::L) : type[i + 1]);\n            if (type[i] == Type::L and type[i + 1] == Type::S) {\n                type[i + 1] = Type::LMS;\n                LMS.push_back(i + 1);\n            }\n        }\n        for (int pos = N - 1, i = N - 2; i >= 0; i--) {\n            next[i] = pos;\n            if (type[i] == Type::LMS) {\n                pos = i;\n            }\n        }\n    }\n\n    void sortLMS()\n    {\n        for (const int l : LMS) {\n            insertTail(l);\n        }\n        induce();\n        vector<int> lms;\n        for (int i = 0; i < kind; i++) {\n            for (const int p : bucket[i]) {\n                if (type[p] == Type::LMS) {\n                    lms.push_back(p);\n                }\n            }\n        }\n        const int size = lms.size();\n        vector<int> order(N / 2 + 1, 0);\n        int number = 1;\n        order[N / 2] = 1;\n        bool same = false;\n        for (int i = 1; i < size; i++) {\n            const int l1 = lms[i - 1];\n            const int r1 = next[l1];\n            const int l2 = lms[i];\n            const int r2 = next[l2];\n            if (r1 - l1 == r2 - l2 and vector<int>(S.begin() + l1, S.begin() + r1 + 1) == vector<int>(S.begin() + l2, S.begin() + r2 + 1)) {\n                same = true;\n            } else {\n                number++;\n            }\n            order[l2 / 2] = number;\n        }\n        if (same) {\n            vector<int> s(size);\n            for (int p = 0, i = 0; i <= N / 2; i++) {\n                if (order[i] > 0) {\n                    s[p++] = order[i];\n                }\n            }\n            const vector<int> sorted = SuffixArrayInducedSorting{s, number}.getSuffixArray();\n            for (int i = 0; i < kind; i++) {\n                head[i] = 0;\n                tail[i] = num[i] - 1;\n            }\n            for (int i = size - 1; i >= 0; i--) {\n                insertTail(LMS[size - 1 - sorted[i]]);\n            }\n            induce();\n        } else {\n            for (int i = 0; i < kind; i++) {\n                head[i] = 0;\n                tail[i] = num[i] - 1;\n            }\n            for (int i = size - 1; i >= 0; i--) {\n                insertTail(lms[i]);\n            }\n            induce();\n        }\n    }\n\n    void induce()\n    {\n        for (int i = 0; i < kind; i++) {\n            for (int j = 0; j < head[i]; j++) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] == Type::L) {\n                    insertHead(p - 1);\n                }\n            }\n            for (int j = tail[i] + 1; j < num[i]; j++) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] == Type::L) {\n                    insertHead(p - 1);\n                }\n            }\n        }\n        for (int i = 1; i < kind; i++) {  // 番兵以外\n            tail[i] = num[i] - 1;\n        }\n        for (int i = kind - 1; i >= 0; i--) {\n            for (int j = num[i] - 1; j > tail[i]; j--) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] != Type::L) {\n                    insertTail(p - 1);\n                }\n            }\n            for (int j = head[i] - 1; j >= 0; j--) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] != Type::L) {\n                    insertTail(p - 1);\n                }\n            }\n        }\n    }\n    void insertHead(const int i) { bucket[S[i]][head[S[i]]++] = i; }\n    void insertTail(const int i) { bucket[S[i]][tail[S[i]]--] = i; }\n\n    const int N;\n    const int kind;\n    vector<int> S;               // O(N)\n    vector<Type> type;           // O(N)\n    vector<int> next;            // O(N)\n    vector<vector<int>> bucket;  // O(N)\n    vector<int> num;             // O(K)\n    vector<int> head;            // O(K)\n    vector<int> tail;            // O(K)\n    vector<int> LMS;             // O(N)\n};\n\nint main()\n{\n    string s;\n    cin >> s;\n    const int size = s.size();\n    const vector<int> sa = SuffixArrayInducedSorting(s, 79).getSuffixArray();\n    int N;\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        string p;\n        cin >> p;\n        const int psize = p.size();\n        int inf = -1;\n        int sup = size;\n        while (sup - inf > 1) {\n            const int mid = (sup + inf) / 2;\n            const bool ok = s.substr(sa[mid], psize) < p;\n            if (ok) {\n                inf = mid;\n            } else {\n                sup = mid;\n            }\n        }\n        const bool ans = s.substr(sa[sup], psize) == p;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntemplate<typename S_Iter, typename SA_Iter>\nvoid induceSAL(S_Iter S_begin, S_Iter S_end, SA_Iter SA_begin, SA_Iter SA_end, const vector<bool> &t, uint32_t buckets_size) {\n    int32_t n = S_end - S_begin;\n    vector<int32_t> buckets(buckets_size+1, 0);\n    for (auto itr = S_begin; itr != S_end; itr++) buckets[*itr]++;\n\n    int32_t sum = 0;\n    for (uint32_t i = 0; i < buckets.size(); i++) {\n        sum += buckets[i];\n        buckets[i] = sum - buckets[i];\n    }\n\n    if (!t[n-1]) SA_begin[buckets[S_begin[n-1]]++] = n-1;\n\n    for (int32_t i = 0; i < n; i++) {\n        if (SA_begin[i] > 0 && !t[SA_begin[i]-1]) SA_begin[buckets[S_begin[SA_begin[i]-1]]++] = SA_begin[i]-1;\n    }\n\n    return;\n}\n\ntemplate<typename S_Iter, typename SA_Iter>\nvoid induceSAS(S_Iter S_begin, S_Iter S_end, SA_Iter SA_begin, SA_Iter SA_end, const vector<bool> &t, uint32_t buckets_size) {\n    int32_t n = S_end - S_begin;\n    vector<int32_t> buckets(buckets_size+1, 0);\n    for (auto itr = S_begin; itr != S_end; itr++) buckets[*itr]++;\n    partial_sum(buckets.begin(), buckets.end(), buckets.begin());\n\n    for (int32_t i = n-1; i > 0; i--) {\n        if (SA_begin[i] > 0 && t[SA_begin[i]-1]) SA_begin[--buckets[S_begin[SA_begin[i]-1]]] = SA_begin[i]-1;\n    }\n\n    return;\n}\n\ntemplate<typename S_Iter, typename SA_Iter>\nvoid SA_IS(S_Iter S_begin, S_Iter S_end, SA_Iter SA_begin, SA_Iter SA_end, uint32_t buckets_size) {\n    int32_t n = S_end - S_begin;\n    fill(SA_begin, SA_end, -1);\n\n    // classify the type of each character\n    // true <=> S-type\n    vector<bool> t(n);\n    for (int32_t i = n; i >= 0; i--) {\n        t[i] = S_begin[i] < S_begin[i+1] || (S_begin[i] == S_begin[i+1] && t[i+1]);\n    }\n\n    auto is_lms = [&t](int32_t i){return i > 0 && !t[i-1] && t[i];};\n\n    // sort all the S-substrings\n    vector<int32_t> buckets(buckets_size+1, 0);\n    for (auto itr = S_begin; itr != S_end; itr++) buckets[*itr]++;\n    partial_sum(buckets.begin(), buckets.end(), buckets.begin());\n    for (int32_t i = 0; i < n; i++) {\n        if (is_lms(i)) SA_begin[--buckets[S_begin[i]]] = i;\n    }\n    induceSAL(S_begin, S_end, SA_begin, SA_end, t, buckets_size);\n    induceSAS(S_begin, S_end, SA_begin, SA_end, t, buckets_size);\n\n    // compact all the sorted substrings into the first nl items of SA\n    auto lms_end = remove_if(SA_begin, SA_end, [is_lms](int32_t x){return !is_lms(x);});\n    fill(lms_end, SA_end, -1);\n    int32_t nl = lms_end - SA_begin;\n\n    // find the lexicographic names of substrings\n    int32_t name = 0;\n    for (auto itr = SA_begin; itr != lms_end; itr++) {\n        if (itr == SA_begin) {\n            lms_end[*itr/2] = name;\n        } else {\n            int32_t cur = *itr, prev = *(itr - 1);\n            bool miss = S_begin[cur] != S_begin[prev] || t[cur] != t[prev];\n            if (!miss) do {\n                ++cur; ++prev;\n                miss |= cur == n ||\n                        prev == n ||\n                        S_begin[cur] != S_begin[prev] ||\n                        t[cur] != t[prev];\n            } while (!miss && !(cur > 0 && !t[cur-1] && t[cur]) && !(prev > 0 && !t[prev-1] && t[prev]));\n\n            if (miss) ++name;\n            lms_end[*itr/2] = name;\n        }\n    }\n    remove_if(reverse_iterator<decltype(SA_end)>(SA_end), reverse_iterator<decltype(SA_begin)>(SA_begin) - nl, [](int32_t i) {return i < 0;});\n\n    // solve the reduced problem\n    auto S1_begin = SA_end - nl, S1_end = SA_end;\n    auto SA1_begin = SA_begin, SA1_end = SA_begin + nl;\n    if (name + 1 < nl) {\n        SA_IS(S1_begin, S1_end, SA1_begin, SA1_end, nl);\n    } else {\n        for (int32_t i = 0; i < nl; i++) {\n            SA1_begin[S1_begin[i]] = i;\n        }\n    }\n\n    // induce the result for the original problem\n    fill(buckets.begin(), buckets.end(), 0);\n    for (auto itr = S_begin; itr != S_end; itr++) buckets[*itr]++;\n    partial_sum(buckets.begin(), buckets.end(), buckets.begin());\n\n    for (int32_t i = 1, j = 0; i < n; i++) {\n        if (is_lms(i)) S1_begin[j++] = i;\n    }\n    for (int32_t i = 0; i < nl; i++) SA1_begin[i] = S1_begin[SA1_begin[i]];\n    fill(lms_end, SA_end, -1);\n    for (int32_t i = nl-1; i >= 0; i--) {\n        int32_t j = SA_begin[i];\n        SA_begin[i] = -1;\n        SA_begin[--buckets[S_begin[j]]] = j;\n    }\n    induceSAL(S_begin, S_end, SA_begin, SA_end, t, buckets_size);\n    induceSAS(S_begin, S_end, SA_begin, SA_end, t, buckets_size);\n\n    return;\n}\n\nint main() {\n    char tmp[1000000];\n    scanf(\"%s\", tmp);\n    string T = tmp;\n\n    int32_t Q;\n    scanf(\"%d\", &Q);\n\n    vector<int32_t> SA(T.length());\n    SA_IS(T.begin(), T.end(), SA.begin(), SA.end(), 'z');\n\n    for (int32_t i = 0; i < Q; i++) {\n        char tmp[1000];\n        scanf(\"%s\", tmp);\n        string P = tmp;\n\n        auto itr_lb = lower_bound(SA.begin(), SA.end(), P, [&T](uint32_t i, string s) {return T.substr(i, T.length()-i) < s;});\n\n        if (T.substr(*itr_lb, P.length()) == P) {\n            printf(\"1\\n\");\n        } else {\n            printf(\"0\\n\");\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring s,t;\nint n;\nint sa[2000005],bb[2000005],x[2000005],y[2000005];\nbool cmp(int *y,int a,int b,int k){\n\tint a1=y[a],b1=y[b];\n\tint a2=a+k>=n?-1:y[a+k];\n\tint b2=b+k>=n?-1:y[b+k];\n\treturn a1==b1&&a2==b2;\n}\nvoid init(){\n\t// 建立后缀数组\n\tint m=256;\n\tfor(int i=0;i<m;i++)bb[i]=0;\n\tfor(int i=0;i<n;i++)bb[x[i]=s[i]]++;\n\tfor(int i=1;i<m;i++)bb[i]+=bb[i-1];\n\tfor(int i=n-1;i>=0;i--)sa[--bb[x[i]]]=i;\n\tfor(int k=1;k<=n;k<<=1){\n\t\tint p=0;\n\t\tfor(int i=n-k;i<n;i++)y[p++]=i;\n\t\tfor(int i=0;i<n;i++)if(sa[i]>=k)y[p++]=sa[i]-k;\n\t\tfor(int i=0;i<m;i++)bb[i]=0;\n\t\tfor(int i=0;i<n;i++)bb[x[y[i]]]++;\n\t\tfor(int i=1;i<m;i++)bb[i]+=bb[i-1];\n\t\tfor(int i=n-1;i>=0;i--)sa[--bb[x[y[i]]]]=y[i];\n\t\tswap(x,y);\n\t\tm=1;x[sa[0]]=0;\n\t\tfor(int i=1;i<n;i++)\n\t\t\tx[sa[i]]=cmp(y,sa[i],sa[i-1],k)?m-1:m++;\n//\t\t\tx[sa[i]]=y[sa[i-1]]==y[sa[i]]&&y[sa[i-1]+k]==y[sa[i]+k]?m-1:m++;\n\t\tif(m>=n)break;\n\t}\n//\tfor(int i=0;i<n;i++)cout<<sa[i]<<' ';\n}\nint judge(int i){\n\treturn t.compare(s.substr(i,min(n-i,(int)t.length())));\n}\nvoid calc(){\n\tint l=0,r=n,m;\n\twhile(l<r-2){\n\t\tm=(l+r)/2;\n\t\tint res=judge(sa[m]);\n\t\tif(res==0){puts(\"1\");return;}\n\t\telse if(res<0)r=m;\n\t\telse l=m;\n\t}\n\tfor(int i=l;i<=r;i++){\n\t\tint res=judge(sa[i]);\n\t\tif(res==0){puts(\"1\");return;}\n\t}\n\tputs(\"0\");\n}\nint main(){\n//\tfreopen(\"a.txt\",\"r\",stdin);\n\tios::sync_with_stdio(false);cin.tie(0);\n\tint Q;cin>>s>>Q;n=s.length();\n\tinit();\n\twhile(Q--){\n\t\tcin>>t;\n\t\tcalc();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct SA{\n  int n,k;\n  string S;\n  vector<int> r,r2,t,sa;\n  SA(){}\n  SA(string S):S(S){init();}\n  void init(){\n    n=S.size();\n    r.resize(n+1,0);\n    r2.resize(n+1,0);\n    t.resize(n+1,0);\n    sa.resize(n+1,0);\n    constract_sa();\n  }\n  bool compare_sa(int i,int j){\n    if(r[i]!=r[j]) return r[i]<r[j];\n    else{\n      int ri=i+k<=n?r[i+k]:-1;\n      int rj=j+k<=n?r[j+k]:-1;\n      return ri<rj;\n    }\n  }\n  void constract_sa(){\n    n=S.length();\n    for(int i=0;i<=n;i++){\n      sa[i]=i;\n      r[i]=i<n?S[i]:-1;\n    }\n    for(k=1;k<=n;k*=2){\n      sort(sa.begin(),sa.end(),[&](const int &i, const int &j){\n\t  if(r[i]!=r[j]) return r[i]<r[j];\n\t  else{\n\t    int ri=i+k<=n?r[i+k]:-1;\n\t    int rj=j+k<=n?r[j+k]:-1;\n\t    return ri<rj;\n\t  }\n\t});\n      t[sa[0]]=0;\n      for(int i=1;i<=n;i++){\n\tt[sa[i]]=t[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n      }\n      for(int i=0;i<=n;i++){\n\tr[i]=t[i];\n      }\n    }\n  }\n  bool contains(string T){\n    int a=0,b=S.length()+1;\n    while(b-a>1){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n};\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SA sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//??\\?°???????????????????\n//sa[]?????\\?°?????????´???\n#include<iostream>\n#include<string>\n#include<algorithm>\n\n#define MAX_N 100000000\n\nusing namespace std;\n\n\n//?????????+??????????????????\nint n,k;\nint rank[MAX_N + 1];\nint tmp[MAX_N + 1];\n\n\nbool compare_sa(int i, int j)\n{\n\tif(rank[i] != rank[j]) \n\t{\n\t\treturn rank[i] < rank[j];\n\t}\n\telse\n\t{\n\tint ri = i + k <= n ? rank[i + k] : -1;\n\tint rj = j + k <= n ? rank[j + k] : -1;\n\treturn ri < rj;\n\t}\n}\n\n//?????????s?????\\?°??????????????§????\nvoid construct_sa(string s,int *sa)\n{\n\tn = s.length();\n\t\n\t//???????????????????????????????????????????????§??????\n\tfor(int i = 0; i <= n;i++)\n\t{\n\t\tsa[i] = i;\n\t\trank[i] = i < n ? s[i] : -1;\n\t}\n\t\n\t//k????????????????????????????????????????????¨???????????????2k????????§???????????????\n\tfor(k = 1;k <= n ; k *= 2)\n\t{\n\t\tsort(sa,sa + n + 1,compare_sa);\n\t\t\n\t\t//?????£??????tmp?????\\????????????rank????§????\n\t\ttmp[sa[0]] = 0;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\ttmp[sa[i]] = tmp[sa[i -1]] + (compare_sa(sa[i - 1],sa[i]) ? 1 : 0);\n\t\t}\n\t\tfor(int i = 0;i <= n;i++)\n\t\t{\n\t\t\trank[i] = tmp[i];\n\t\t}\n\t}\n}\n\nbool contain(string s,int *sa, string t)\n{\n\tint a = 0,b = s.length();\n\twhile(b - a > 1)\n\t{\n\t\tint c = (a + b) / 2;\n\t\t\n\t\tif(s.compare(sa[c],t.length(),t) < 0) a = c;\n\t\telse b = c;\n\t}\n\t\n\treturn (s.compare(sa[b], t.length(),t) == 0);\n\t\n}\n\n\nint main()\n{\n\tstring S;\n\tint N,sa[MAX_N];\n\t\n\t\n\tcin >> S >> N;\n\t\n\tconstruct_sa(S,sa);\n\t\n\tfor(int i = 0 ;i < N;i++)\n\t{\n\t\tstring T;\n\t\tcin >> T;\n\t\tif(contain(S,sa,T)) cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nclass suffix_array{\n    void create_begin_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        int sum=0;\n        for(int i=0;i<bucket.size();i++){bucket[i]+=sum;swap(sum,bucket[i]);}\n    }\n\n    void create_end_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        for(int i=1;i<bucket.size();i++)bucket[i]+=bucket[i-1];\n    }\n\n    void induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_begin_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(sa[i]>0&&is_l[sa[i]-1])sa[bucket[v[sa[i]-1]]++]=sa[i]-1;\n    }\n\n    void invert_induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_end_bucket(v,bucket);\n        for(int i=v.size()-1;i>=0;i--)if(sa[i]>0&&!is_l[sa[i]-1])sa[--bucket[v[sa[i]-1]]]=sa[i]-1;\n    }\n\n    vector<int>sa_is(vector<int>v,int mv){\n        if(v.size()==1)return vector<int>(1,0);\n\n        vector<int>is_l(v.size());\n        vector<int>bucket(mv+1);\n        vector<int>sa(v.size(),-1);\n        auto is_lms=[&](int x)->bool{return x>0&&is_l[x-1]&&!is_l[x];};\n\n        is_l[v.size()-1]=0;\n        for(int i=v.size()-2;i>=0;i--)is_l[i]=v[i]>v[i+1]||(v[i]==v[i+1]&&is_l[i+1]);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(is_lms(i))sa[--bucket[v[i]]]=i;\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n\n        int cur=0;\n        vector<int>order(v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))order[i]=cur++;\n\n        vector<int>next_v(cur);\n        cur=-1;\n        int prev=-1;\n        for(int i=0;i<v.size();i++){\n            if(!is_lms(sa[i]))continue;\n            bool diff=false;\n            for(int d=0;d<v.size();d++){\n                if(prev==-1||v[sa[i]+d]!=v[prev+d]||is_l[sa[i]+d]!=is_l[prev+d]){\n                    diff=true;\n                    break;\n                }\n                else if(d>0&&is_lms(sa[i]+d))break;\n            }\n            if(diff){cur++;prev=sa[i];}\n            next_v[order[sa[i]]]=cur;\n        }\n\n        vector<int>re_order(next_v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))re_order[order[i]]=i;\n        vector<int>next_sa=sa_is(next_v,cur);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<sa.size();i++)sa[i]=-1;\n        for(int i=next_sa.size()-1;i>=0;i--)sa[--bucket[v[re_order[next_sa[i]]]]]=re_order[next_sa[i]];\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n        return sa;\n    }\n\n    vector<int>sa_is(string &s){\n        vector<int>v(s.size()+1);\n        for(int i=0;i<s.size();i++)v[i]=s[i];\n        sa=sa_is(v,*max_element(v.begin(),v.end()));\n    }\n\n    void construct_lcp(){\n        lcp.resize(s.size());\n        rank.resize(s.size()+1);\n        int n=s.size();\n        for(int i=0;i<=n;i++)rank[sa[i]]=i;\n        int h=0;\n        lcp[0]=0;\n        for(int i=0;i<n;i++){\n            int j=sa[rank[i]-1];\n\n            if(h>0)h--;\n            for(;j+h<n&&i+h<n;h++){\n                if(s[j+h]!=s[i+h])break;\n            }\n            lcp[rank[i]-1]=h;\n        }\n    }\n\n    class sparse_table{\n        vector<vector<int> >st;\n    public:\n        void init(vector<int>&v){\n            int b;\n            for(b=0;(1<<b)<=v.size();b++);\n            vector<int>tmp(1<<b);\n            for(int i=0;i<b;i++)st.push_back(tmp);\n            for(int i=0;i<v.size();i++)st[0][i]=v[i];\n\n            for(int i=1;i<b;i++){\n                for(int j=0;j+(1<<i)<=(1<<b);j++){\n                    st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);\n                }\n            }\n        }\n        int get_min(int l,int r){\n            assert(l<r);\n            int b=32-__builtin_clz(r-l)-1;\n            return min(st[b][l],st[b][r-(1<<b)]);\n        }\n        sparse_table(){}\n        sparse_table(vector<int>&v){init(v);}\n    };\n    sparse_table st;\npublic:\n    string s;\n    vector<int>sa,lcp,rank;\n    void init(string &t){\n        s=t;\n        sa_is(s);\n        construct_lcp();\n        st.init(lcp);\n    }\n    suffix_array(string &t){init(t);}\n    suffix_array(){}\n\n    bool contain(string &t){\n        int lb=0,ub=s.size();\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            if(s.compare(sa[mid],t.size(),t)<0)lb=mid;\n            else ub=mid;\n        }\n        return s.compare(sa[ub],t.size(),t)==0;\n    }\n\n    int get_lcp(int i,int j){\n        if(rank[i]>rank[j])swap(i,j);\n        return st.get_min(rank[i],rank[j]);\n    }\n};\n\nsigned main(){\n    string s;cin>>s;\n    suffix_array sa(s);\n    int q;cin>>q;\n    while(q--){\n        string t;\n        cin>>t;\n        cout<<sa.contain(t)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nclass suffix_array{\n    void create_begin_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        int sum=0;\n        for(int i=0;i<bucket.size();i++){bucket[i]+=sum;swap(sum,bucket[i]);}\n    }\n\n    void create_end_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        for(int i=1;i<bucket.size();i++)bucket[i]+=bucket[i-1];\n    }\n\n    void induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_begin_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(sa[i]>0&&is_l[sa[i]-1])sa[bucket[v[sa[i]-1]]++]=sa[i]-1;\n    }\n\n    void invert_induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_end_bucket(v,bucket);\n        for(int i=v.size()-1;i>=0;i--)if(sa[i]>0&&!is_l[sa[i]-1])sa[--bucket[v[sa[i]-1]]]=sa[i]-1;\n    }\n\n    vector<int>sa_is(vector<int>v,int mv){\n        if(v.size()==1)return vector<int>(1,0);\n\n        vector<int>is_l(v.size());\n        vector<int>bucket(mv+1);\n        vector<int>sa(v.size(),-1);\n        auto is_lms=[&](int x)->bool{return x>0&&is_l[x-1]&&!is_l[x];};\n\n        is_l[v.size()-1]=0;\n        for(int i=v.size()-2;i>=0;i--)is_l[i]=v[i]>v[i+1]||(v[i]==v[i+1]&&is_l[i+1]);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(is_lms(i))sa[--bucket[v[i]]]=i;\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n\n        int cur=0;\n        vector<int>order(v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))order[i]=cur++;\n\n        vector<int>next_v(cur);\n        cur=-1;\n        int prev=-1;\n        for(int i=0;i<v.size();i++){\n            if(!is_lms(sa[i]))continue;\n            bool diff=false;\n            for(int d=0;d<v.size();d++){\n                if(prev==-1||v[sa[i]+d]!=v[prev+d]||is_l[sa[i]+d]!=is_l[prev+d]){\n                    diff=true;\n                    break;\n                }\n                else if(d>0&&is_lms(sa[i]+d))break;\n            }\n            if(diff){cur++;prev=sa[i];}\n            next_v[order[sa[i]]]=cur;\n        }\n\n        vector<int>re_order(next_v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))re_order[order[i]]=i;\n        vector<int>next_sa=sa_is(next_v,cur);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<sa.size();i++)sa[i]=-1;\n        for(int i=next_sa.size()-1;i>=0;i--)sa[--bucket[v[re_order[next_sa[i]]]]]=re_order[next_sa[i]];\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n        return sa;\n    }\n\n    vector<int>sa_is(string &s){\n        vector<int>v(s.size()+1);\n        for(int i=0;i<s.size();i++)v[i]=s[i];\n        sa=sa_is(v,*max_element(v.begin(),v.end()));\n    }\n\n    void construct_lcp(){\n        lcp.resize(s.size());\n        rank.resize(s.size()+1);\n        int n=s.size();\n        for(int i=0;i<=n;i++)rank[sa[i]]=i;\n        int h=0;\n        lcp[0]=0;\n        for(int i=0;i<n;i++){\n            int j=sa[rank[i]-1];\n\n            if(h>0)h--;\n            for(;j+h<n&&i+h<n;h++){\n                if(s[j+h]!=s[i+h])break;\n            }\n            lcp[rank[i]-1]=h;\n        }\n    }\n\n    class sparse_table{\n        vector<vector<int> >st;\n    public:\n        void init(vector<int>&v){\n            int b;\n            for(b=0;(1<<b)<v.size();b++);\n            st.assign(b,vector<int>(1<<b));\n            for(int i=0;i<v.size();i++)st[0][i]=v[i];\n\n            for(int i=1;i<b;i++){\n                for(int j=0;j+(1<<i)<=(1<<b);j++){\n                    st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);\n                }\n            }\n        }\n        int get_min(int l,int r){\n            assert(l<r);\n            int b=32-__builtin_clz(r-l)-1;\n            return min(st[b][l],st[b][r-(1<<b)]);\n        }\n        sparse_table(){}\n        sparse_table(vector<int>&v){init(v);}\n    };\n    sparse_table st;\npublic:\n    string s;\n    vector<int>sa,lcp,rank;\n    void init(string &t){\n        s=t;\n        sa_is(s);\n        construct_lcp();\n        //st.init(lcp);\n    }\n    suffix_array(string &t){init(t);}\n    suffix_array(){}\n\n    bool contain(string &t){\n        int lb=0,ub=s.size();\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            if(s.compare(sa[mid],t.size(),t)<0)lb=mid;\n            else ub=mid;\n        }\n        return s.compare(sa[ub],t.size(),t)==0;\n    }\n\n    int get_lcp(int i,int j){\n        if(rank[i]>rank[j])swap(i,j);\n        return st.get_min(rank[i],rank[j]);\n    }\n};\n\nsigned main(){\n    string s;cin>>s;\n    suffix_array sa(s);\n    int q;cin>>q;\n    while(q--){\n        string t;\n        cin>>t;\n        cout<<sa.contain(t)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int i, const int j) { \n    //const int k=lcp(i,j);\n    const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    if(i+k>=n)return 1;\n    if(j+k>=n)return 0;\n    return s[i+k] <= s[j+k];\n    //return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int b, const int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  /*\n  inline int lcp(const int i, const int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n  */\n  int lcp2(const int i, const int j, const int l, const int r){\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  if(100000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\nif(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)>>1;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nint L[1000000],R[1000000];\n\ninline void merge(int *A, const int left, const int mid, const int right, const RollingHash &rh){\n  const int n1 = mid - left, n2 = right - mid;\n  REP(i,n1)L[i]=A[left+i];\n  REP(i,n2)R[i]=A[mid+i];\n  for(int k =left,i=0,j=0;k<right;k++){\n    if(n2<=j)A[k]=L[i++];\n    else if(n1<=i)A[k]=R[j++];\n    else A[k]=rh(L[i],R[j])?L[i++]:R[j++];\n  }\n}\n\nvoid mergeSort(int *A,const int left,const int right, const RollingHash &rh){\n  if(left+1<right){\n    const int mid = (left+right)>>1;\n    mergeSort(A,left,mid, rh);\n    mergeSort(A,mid,right, rh);\n    merge(A,left,mid,right, rh);\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  /*\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergeSort(sa,0,n,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n  */\n  vector<int>sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  sort(ALL(sa),rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s;\n\tcin>>s;\n\ts+='$';\n\tint n=s.size();\n\tvector<int>suff(n);\n\tiota(suff.begin(),suff.end(),0);\n\t{\n\t\tconst char *str=s.c_str();\n\t\tsort(suff.begin(),suff.end(),[&](int a,int b){\n\t\t\treturn str[a]<str[b];\n\t\t});\n\t}\n\tvector<pair<char,int>>sorted(n);\n\tfor(int i=0;i<n;i++)sorted[i]={s[(suff[i]-1+n)%n],i};\n\tsort(sorted.begin(),sorted.end());\n\n\tint T;\n\tfor(cin>>T;T--;){\n\t\tstring q;\n\t\tcin>>q;\n\t\tint start=0,stop=n,idx=q.size()-1;\n\t\tfor(;idx>=0;idx--){\n\t\t\tpair<char,int> ql={q[idx],start},qr={q[idx],stop};\n\t\t\tstart=lower_bound(sorted.begin(),sorted.end(),ql)-sorted.begin();\n\t\t\tstop=lower_bound(sorted.begin(),sorted.end(),qr)-sorted.begin();\n\t\t\tif(start==stop)break;\n\t\t}\n\t\tif(idx<0){\n\t\t\t//{vector<int>v;for(;start<stop;start++)v.push_back(suff[start]);sort(v.begin(),v.end());for(auto &e:v)printf(\"%d\\n\",e);}\n\t\t\tputs(\"1\");\n\t\t}else{\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <tuple>\n#include <cstdio>\n#include <bitset>\n#include <sstream>\n#include <iterator>\n#include <numeric>\n#include <map>\n#include <cstring>\n#include <set>\n#include <functional>\n#include <iomanip>\n\nusing namespace std;\n\n#define DEBUG_ //!!提出時にコメントアウト!!\n#ifdef DEBUG_\n\t#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#else\n\t#define dump(x)  ;\n#endif\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define eb emplace_back\n\n//#define int long long\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\n\ntemplate <typename T>\nstd::string printVector(const std::vector<T> &data)\n{\n    std::stringstream ss;\n    std::ostream_iterator<T> out_it(ss, \", \");\n    ss << \"[\";\n    std::copy(data.begin(), data.end() - 1, out_it);\n    ss << data.back() << \"]\";\n    return ss.str();\n}\n\nconst int MOD = 1e9+7;\nconst LL LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n\n//蟻本写経版 O(N*(logN)^2)\nstruct SuffixArray{\n    VI sa;\n    int k;\n    const string S;\n    VI rank,tmp;\n    int n;\n\n    SuffixArray(const string &str) : S(str){\n        sa.resize(S.size()+1);\n        rank.resize(S.size()+1);\n        tmp.resize(S.size()+1);\n        n = S.size();\n        construct_sa();\n    }\n\n    // (rank[i],rank[i+k]),(rank[j],rank[j+k])を比較\n    bool compare_sa(int i, int j){\n        if(rank[i] != rank[j]) return rank[i] < rank[j];\n\n        int ri = i + k <= n ? rank[i+k] : -1;\n        int rj = j + k <= n ? rank[j+k] : -1;\n        return ri < rj;\n    }\n\n    void construct_sa(){\n        int n = S.length();\n        for(int i = 0; i <= n; i++){\n            sa[i] = i;\n            rank[i] = i < n ? S[i] : -1;\n        }\n\n        for(k = 1; k <= n; k *= 2){\n            sort(sa.begin(),sa.end(),[this](int a, int b){\n                return compare_sa(a,b);\n            });\n\n            tmp[sa[0]] = 0;\n            for(int i = 1; i <= n; i++){\n                tmp[sa[i]] = tmp[sa[i-1]] + (compare_sa(sa[i-1],sa[i]) ? 1 : 0);\n            }\n            for(int i = 0; i <= n; i++){\n                rank[i] = tmp[i];\n            }\n        }\n    }\n\n    bool contain(string T){\n        int l = 0, r = n;\n        while(r-l > 1){\n            int mid = (r+l) / 2;\n            if(S.compare(sa[mid], T.length(), T) < 0) l = mid;\n            else r = mid;\n        }\n        return S.compare(sa[r], T.length(), T) == 0;\n    }\n};\n\n\n\nsigned main(int argc, char const *argv[])\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string S; int Q;\n    cin >> S;\n    SuffixArray sa(S);\n    cin >> Q;\n    while(Q--){\n        string T;\n        cin >> T;\n        cout << sa.contain(T) << endl;\n\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nstruct SuffixArray\n{\n    int sz;\n    string s;\n    vector<int> rank,sa;\n\n    SuffixArray(string str){\n        s=str;\n        sz=str.length();\n        rank.resize(sz+1);\n        sa.resize(sz+1);\n        build();\n    }\n\n    void build(){\n        for(int i=0;i<=sz;i++){\n            sa[i]=i;\n            rank[i]=i<sz?s[i]:-1;\n        }\n\n        int k;\n        auto compare = [&](int i, int j) {\n            if (rank[i] != rank[j]) return rank[i] < rank[j];\n            else {\n                int ri = i + k <= sz ? rank[i + k] : -1;\n                int rj = j + k <= sz ? rank[j + k] : -1;\n                return ri < rj;\n            }\n        };\n\n        vector<int> tmp(sz+1);\n        for(k=1;k<=sz;k*=2){\n            sort(sa.begin(),sa.end(),compare);\n            tmp[sa[0]]=0;\n            for(int i=1;i<=sz;i++){\n                tmp[sa[i]]=tmp[sa[i-1]]+(compare(sa[i-1],sa[i])?1:0);\n            }\n            for(int i=0;i<=sz;i++){\n                rank[i]=tmp[i];\n            }\n        }\n    }\n    bool contains(string t){\n        int l=0,r=sz;\n        while(r-l>1){\n            int mid=(l+r)/2;\n            if(s.substr(sa[mid],t.length())<t) l=mid;\n            else r=mid;\n        }\n        return s.substr(sa[r],t.size()) ==t;\n    }\n    void print(){\n        for(int i=0;i<sz;i++){\n            cout<<s.substr(sa[i])<<endl;\n        }\n    }\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n    string t;cin>>t;\n    int q;cin>>q;\n    SuffixArray sf(t);\n    //sf.print();\n    for(int i=0;i<q;i++){\n        string p;cin>>p;\n        cout<<sf.contains(p)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define each(it,c) for(__typeof(c.begin()) it=c.begin(); it!=c.end(); it++)\n#define INF 1<<30\n#define mp make_pair\n#define pb push_back\n\ntypedef vector<int> vi;\n\ntypedef long long ll;\n\nbool has(map <char, int> m,char c){\n\tif (m.find(c) == m.end()) return false;\n\telse return true;\n}\n\nint bm(string t,string p){\n\tint i,j;\n\tint n = t.size();\n\tint m = p.size();\n\tmap <char,int> skip;\n\trep(k,m-1){\n\t\tskip[p[k]] = m-k-1;\n\t}\n\n\teach(it,skip){\n\t\tcout<<it->first<<\" \"<<it->second<<endl;\n\t}\n\n\tfor(i=m-1,j=m-1;j>=0;i--,j--){\n\t\twhile(t[i]!=p[j]){\n\t\t\tint x = (has(skip,t[i])) ? skip[t[i]] : m;\n\t\t\ti += ( (m-j > x) ? m-j : x );\n\t\t\tif(i>=n) return -1;\n\t\t\tj = m-1;\n\t\t}\n\t}\n\treturn i+1;\n}\n\nint main(){\n\tstring t;\n\tcin>>t;\n\tint n; cin>>n;\n\trep(i,n){\n\t\tstring p;\n\t\tcin>>p;\n\t\tint ans = bm(t,p);\n\t\t//cout<<ans<<endl;\n\t\tif(ans!=-1) cout<<1<<endl;\n\t\telse cout<<0<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define MAX 1000002\ntypedef unsigned char byte;\nbyte mask[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\n\nint Lv[MAX];\nint n, k;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n    return L_i < L_j;\n}\n\nint main()\n{\n    int A[MAX];\n    std::string T;\n    std::cin >> T;\n    n = T.size();\n\tbyte *t;\n\tt = new byte [(n >> 3) + 1];\n\n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n    std::sort(A, A + n, cmp_Lv);\n\n\tfor(i = 1; i < n; i++){\n\t\tt[i >> 3] = (Lv[A[i]] != Lv[A[i - 1]] ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n\t}\n\n    Lv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n    }\n\n    k = 1;\n    while(1){\n        if(k > n) break;\n\n        std::sort(A, A + n, cmp);\n\n\t\tfor(i = 1; i < n; i++){\n\t\t\tt[i >> 3] = (cmp(A[i - 1], A[i]) ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n\t\t}\n\t\tLv[A[0]] = 0;\n\t\tfor(i = 1; i < n; i++){\n\t\t\tLv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n\t\t}\n\n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n\n    //std::string P;\n\tchar p[1000];\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n\n    A[n] = n;\n\n    while(q){\n        //std::cin >> P;\n\t\tscanf(\"%s\", p);\n\t\tstd::string P = std::string(p);\n        left = 0, right = n, exist = false;\n        while(left < right){\n\n            if(n < P.size()){ exist = false; break; }\n\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n\n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  //ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)),pow(n+1),phash(n+1){\n    //pow=new ull[n+1];\n    //phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  //~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)>>1;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nint L[1000000],R[1000000];\n\ninline void merge(int *A, const int left, const int mid, const int right, const RollingHash &rh){\n  const int n1 = mid - left, n2 = right - mid;\n  REP(i,n1)L[i]=A[left+i];\n  REP(i,n2)R[i]=A[mid+i];\n  for(int k =left,i=0,j=0;k<right;k++){\n    if(n2<=j)A[k]=L[i++];\n    else if(n1<=i)A[k]=R[j++];\n    else A[k]=rh(L[i],R[j])?L[i++]:R[j++];\n  }\n}\n\nvoid mergeSort(int *A,const int left,const int right, const RollingHash &rh){\n  if(left+1<right){\n    const int mid = (left+right)>>1;\n    mergeSort(A,left,mid, rh);\n    mergeSort(A,mid,right, rh);\n    merge(A,left,mid,right, rh);\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  /*\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergeSort(sa,0,n,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n  */\n  vector<int>sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  sort(ALL(sa),rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\nclass suffix_array{\nprivate:\n    typedef unsigned long ul;\n    \n    struct node{\n        ll begin;\n        ll Rank;\n        node* next; //sortで狂ってる\n        \n        bool operator < (const node &N) const {\n            if(Rank==N.Rank){\n                return (next==NULL?-1:next->Rank)<(N.next==NULL?-1:N.next->Rank);\n            }\n            return Rank<N.Rank;\n        }\n        \n        node(ll begin=0,ll Rank=0,node* next=NULL):begin(begin),Rank(Rank),next(next){}\n    };\n    \n    static bool pointer_cmp(const node* &a,const node* &b){return (*a)<(*b);}\n    \n    vector<node*> sa;\n    vector<ll> Rank;\n    const string s;\n    \n    void build(){\n        for(int i=0;i<s.size();i++){\n            *sa[i]={i,s[i],sa[i+1]};\n        }\n        sa[s.size()]->begin=s.size();\n        sa[s.size()]->Rank=-1;\n        sa[s.size()]->next=NULL;\n        vector<node*> Next(s.size()+1);\n        for(ll k=1;k<=s.size();k<<=1){\n            sort(sa.begin(),sa.end(),pointer_cmp);\n            Rank[sa[0]->begin]=0;\n            Next[0]=(sa[0]->next==NULL?NULL:sa[0]->next->next);\n            for(int i=1;i<=s.size();i++){\n                Rank[sa[i]->begin]=Rank[sa[i-1]->begin]+(*sa[i-1]<*sa[i]?1:0);\n                Next[i]=(sa[i]->next==NULL?NULL:sa[i]->next->next);\n            }\n            for(int i=0;i<=s.size();i++){\n                sa[i]->Rank=Rank[sa[i]->begin];\n                sa[i]->next=Next[i];\n            }\n        }\n        for(int i=0;i<=s.size();i++){\n            Next[sa[i]->begin]=sa[i];\n        }\n        for(int i=0;i<=s.size();i++){\n            sa[i]->next=sa[i]->begin==s.size()?NULL:Next[sa[i]->begin+1];\n        }\n    }\n    \n    //1::greater 0::same -1::less\n    int compare(const ul &saf,const string &str){\n        for(int i=0;i<str.size();i++){\n            if(sa[saf]->begin+i>=s.size()){return -1;}\n            if(s[sa[saf]->begin+i]!=str[i]){return s[sa[saf]->begin+i]<str[i]?-1:1;}\n        }\n        return 0;\n    }\n    \npublic:\n    suffix_array(const string &str):s(str),Rank(str.size()+1),sa(str.size()+1){\n        for(int i=0;i<=str.size();i++){\n            \n        }\n        build();\n    }\n    \n    ll rank(const ul &where) const {return Rank[where];}\n    \n    ul size() const {return sa.size();}\n    \n    const node & operator [] (const ul &where) const {return *sa[where];}\n    \n    //返すのはsuffixの番号\n    ul lower_bound(const string &sub){\n        ll l=0;\n        ll r=s.size();\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            if(compare(m,sub)==-1){l=m+1;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(compare(i,sub)>=0){return i;}\n        }\n        return r+1;\n    }\n    \n    //返すのはsuffixの番号\n    ul upper_bound(const string &sub){\n        ll l=0;\n        ll r=s.size();\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            if(compare(m,sub)<=0){l=m+1;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(compare(i,sub)>0){return i;}\n        }\n        return r+1;\n    }\n    \n    bool match(const string &sub){\n        ll l=0;\n        ll r=s.size();\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            int st=compare(m,sub);\n            if(st==0){return true;}\n            else if(st==-1){l=m+1;}\n            else{r=m-1;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(compare(i,sub)==0){return true;}\n        }\n        return false;\n    }\n};\n\n\nint main(){\n    string t;\n    cin>>t;\n    suffix_array S(t);\n    ll q;\n    cin>>q;\n    while(q--){\n        string p;\n        cin>>p;\n        cout<<S.match(p)<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct SuffixArray {\n  vector< int > SA;\n  const string s;\n\n  SuffixArray(const string &str) : s(str) {\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](int a, int b) {\n      return s[a] == s[b] ? a > b : s[a] < s[b];\n    });\n    vector< int > classes(s.size()), c(s.begin(), s.end()), cnt(s.size());\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const {\n    return SA[k];\n  }\n\n  size_t size() const {\n    return s.size();\n  }\n\n  bool lt_substr(const string &t, int si = 0, int ti = 0) {\n    int sn = (int) s.size(), tn = (int) t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return true;\n      if(s[si] > t[ti]) return false;\n      ++si, ++ti;\n    }\n    return si >= sn && ti < tn;\n  }\n\n  int lower_bound(const string &t) {\n    int low = -1, high = (int) SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) / 2;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return high;\n  }\n\n  pair< int, int > lower_upper_bound(string &t) {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = (int) SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) / 2;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return {idx, high};\n  }\n\n  void output() {\n    for(int i = 0; i < size(); i++) {\n      cout << i << \": \" << s.substr(SA[i]) << endl;\n    }\n  }\n};\n\n\nstruct LongestCommonPrefixArray {\n  const SuffixArray &SA;\n  vector< int > LCP, rank;\n\n  LongestCommonPrefixArray(const SuffixArray &SA) : SA(SA), LCP(SA.size()) {\n    rank.resize(SA.size());\n    for(int i = 0; i < SA.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    for(int i = 0, h = 0; i < SA.size(); i++) {\n      if(rank[i] + 1 < SA.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < SA.size() && SA.s[i + h] == SA.s[j + h]; ++h);\n        LCP[rank[i] + 1] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const {\n    return LCP[k];\n  }\n\n  size_t size() const {\n    return LCP.size();\n  }\n\n  void output() {\n    for(int i = 0; i < size(); i++) {\n      cout << i << \": \" << LCP[i] << \" \" << SA.s.substr(SA[i]) << endl;\n    }\n  }\n};\n\nint main() {\n  string S;\n  int Q;\n\n  cin >> S;\n  SuffixArray sa(S);\n  cin >> Q;\n  while(Q--) {\n    string T;\n    cin >> T;\n    auto range = sa.lower_upper_bound(T);\n    cout << (range.first != range.second) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nstring S; int Q; char STR[1005];\n\nint main()\n{\n\tcin >> S >> Q; cout << string::npos << endl;\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%s\", STR);\n\n\t\tprintf(\"%d\\n\", S.find(STR) != 18446744073709551615ULL ? 1 : 0);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int i, const int j) { \n    //const int k=lcp(i,j);\n    const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    if(i+k>=n)return 1;\n    if(j+k>=n)return 0;\n    return s[i+k] <= s[j+k];\n    //return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int b, const int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  /*\n  inline int lcp(const int i, const int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n  */\n  inline int lcp2(const int& i, const int& j, const int& l, const int& r){\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\nif(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nclass SuffixArray {\n\tvoid CEB(vector<int> &v, vector<int> &b) {\n\t\tint vs = v.size(), bs = b.size();\n\t\tfill(b.begin(), b.end(), 0);\n\t\tfor (int i = 0; i < vs; i++) b[v[i]]++;\n\t\tfor (int i = 1; i < bs; i++) b[i] += b[i - 1];\n\t}\n\tvoid ISort(vector<int> &v, vector<int> &SA, int mv, vector<int> &b, vector<int> &isL) {\n\t\tint vs = v.size(), bs = b.size();\n\t\tfill(b.begin(), b.end(), 0);\n\t\tfor (int i = 0; i < vs; i++) b[v[i]]++;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < bs; i++) b[i] += sum, swap(sum, b[i]);\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (SA[i] > 0 && isL[SA[i] - 1]) SA[b[v[SA[i] - 1]]++] = SA[i] - 1;\n\t\t}\n\t}\n\tvoid IISort(vector<int> &v, vector<int> &SA, int mv, vector<int> &b, vector<int> &isL) {\n\t\tCEB(v, b);\n\t\tfor (int i = v.size() - 1; i >= 0; i--) {\n\t\t\tif (SA[i] > 0 && !isL[SA[i] - 1]) SA[--b[v[SA[i] - 1]]] = SA[i] - 1;\n\t\t}\n\t}\n\tvector<int>SA_IS(vector<int> v, int mv) {\n\t\tint vs = v.size();\n\t\tif (vs == 1) return vector<int>(1, 0);\n\t\tvector<int> isL(vs), b(mv + 1), SA(vs, -1), ord(vs);\n\t\tauto isLMS = [&](int x)->bool { return x > 0 && isL[x - 1] && !isL[x]; };\n\t\tfor (int i = vs - 2; i >= 0; i--) isL[i] = (v[i] > v[i + 1]) || (v[i] == v[i + 1] && isL[i + 1]);\n\t\tCEB(v, b);\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) SA[--b[v[i]]] = i;\n\t\t}\n\t\tISort(v, SA, mv, b, isL);\n\t\tIISort(v, SA, mv, b, isL);\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) ord[i] = cur++;\n\t\t}\n\t\tvector<int> nxv(cur);\n\t\tcur = -1;\n\t\tint prev = -1;\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (!isLMS(SA[i])) continue;\n\t\t\tbool diff = false;\n\t\t\tfor (int d = 0; d < vs; d++) {\n\t\t\t\tif (prev == -1 || v[SA[i] + d] != v[prev + d] || isL[SA[i] + d] != isL[prev + d]) {\n\t\t\t\t\tdiff = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (d && isLMS(SA[i] + d))break;\n\t\t\t}\n\t\t\tif (diff) cur++, prev = SA[i];\n\t\t\tnxv[ord[SA[i]]] = cur;\n\t\t}\n\t\tvector<int> reord(nxv.size());\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) reord[ord[i]] = i;\n\t\t}\n\t\tvector<int> nxSA = SA_IS(nxv, cur);\n\t\tCEB(v, b);\n\t\tfor (int i = 0; i < SA.size(); i++) SA[i] = -1;\n\t\tfor (int i = nxSA.size() - 1; i >= 0; i--) {\n\t\t\tSA[--b[v[reord[nxSA[i]]]]] = reord[nxSA[i]];\n\t\t}\n\t\tISort(v, SA, mv, b, isL);\n\t\tIISort(v, SA, mv, b, isL);\n\t\treturn SA;\n\t}\n\tvector<int>SA_IS(string s) {\n\t\tvector<int> v(s.size() + 1);\n\t\tfor (int i = 0; i < s.size(); i++) v[i] = s[i] + 1;\n\t\treturn SA_IS(v, *max_element(v.begin(), v.end()));\n\t}\npublic:\n\tstring s;\n\tvector<int> sa;\n\tvoid init(string &T) {\n\t\ts = T;\n\t\tsa = SA_IS(s);\n\t}\n\tSuffixArray(string &t) { init(t); }\n\tSuffixArray() {}\n\tbool contain(string &t) {\n\t\tint a = 0, b = s.size();\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (s.compare(sa[c], t.size(), t) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn s.compare(sa[b], t.size(), t) == 0;\n\t}\n};\nint q; string s, t;\nint main() {\n\tcin >> s >> q;\n\tSuffixArray v(s);\n\tfor(int i = 0; i < q; i++) {\n\t\tcin >> t;\n\t\tcout << (v.contain(t) ? 1 : 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n\nusing namespace std;\n\nstring S; int Q; char STR[1005];\n\nint main()\n{\n\tcin >> S >> Q;\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%s\", STR);\n\n\t\tif(S.find(STR) == -1)\n\t\t{\n\t\t    printf(\"0\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t    printf(\"1\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> r,r2,t,sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.size();\n    r.resize(n+1,0);\n    r2.resize(n+1,0);\n    t.resize(n+1,0);\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  bool compare_sa(int i,int j){\n    if(r[i]!=r[j]) return r[i]<r[j];\n    else{\n      int ri=i+k<=n?r[i+k]:-1;\n      int rj=j+k<=n?r[j+k]:-1;\n      return ri<rj;\n    }\n  }\n  void build_sa(){\n    n=S.length();\n    for(int i=0;i<=n;i++){\n      sa[i]=i;\n      r[i]=i<n?S[i]:-1;\n    }\n    for(k=1;k<=n;k*=2){\n      sort(sa.begin(),sa.end(),[&](const int &i, const int &j){\n\t  if(r[i]!=r[j]) return r[i]<r[j];\n\t  else{\n\t    int ri=i+k<=n?r[i+k]:-1;\n\t    int rj=j+k<=n?r[j+k]:-1;\n\t    return ri<rj;\n\t  }\n\t});\n      t[sa[0]]=0;\n      for(int i=1;i<=n;i++){\n\tt[sa[i]]=t[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n      }\n      for(int i=0;i<=n;i++){\n\tr[i]=t[i];\n      }\n    }\n  }\n  bool contains(string T){\n    int a=0,b=S.length()+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==(int)S.length()+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    for(int i=0;i<=n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/06/22\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint Rank[1000005];\nint Tmp[1000005];\nint kc,len;\n\nbool compare_sa(int i,int j){\n  return\n    Rank[i]!=Rank[j]?\n    Rank[i]<Rank[j]:\n    (i+kc<=len?Rank[i+kc]:-1)<(j+kc<=len?Rank[j+kc]:-1);\n}\n\nvoid construct_sa(char* S,int *sa){\n  len=strlen(S);\n  for(int i=0;i<=len;i++){\n    sa[i]=i;\n    Rank[i]=i<len?S[i]:-1;\n  }\n  for(kc=1;kc<=len;kc*=2){\n    sort(sa,sa+len+1,compare_sa);\n    Tmp[sa[0]]=0;\n    for(int i=1;i<=len;i++){\n      Tmp[sa[i]]=Tmp[sa[i-1]]+compare_sa(sa[i-1],sa[i]);\n    }\n    for(int i=0;i<=len;i++)Rank[i]=Tmp[i];\n  }\n}\n\n\nint n,m;\nchar str[1000005];\nchar t[1000005];\nint sa[1000005];\n\nint main(){\n  scanf(\"%s\",str);\n  n=strlen(str);\n  construct_sa(str,sa);\n  scanf(\"%d\",&m);\n  while(m--){\n    scanf(\"%s\",t);\n    int k=strlen(t);\n    int l=0,r=n+1,m;\n    while(l+1<r){\n      m=(l+r)/2;\n      if(strncmp(str+sa[m],t,k)<=0)l=m;\n      else r=m;\n    }\n    printf(\"%d\\n\",(strncmp(str+sa[l],t,k)==0));\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1000000000 + 7;\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nstruct SuffixArray {\n    int n, k;\n    string text;\n    vector<int> sa;\n    vector<int> rank;\n    vector<int> lcp;\n\n    SuffixArray (const string &s)\n    : text(s), n(s.size()), sa(n + 1), rank(n + 1), lcp(n)\n    {}\n\n    bool comp(int i, int j) {\n        if (rank[i] != rank[j]) return rank[i] < rank[j];\n        int ri = i + k <= n ? rank[i + k] : -1;\n        int rj = j + k <= n ? rank[j + k] : -1;\n        return ri < rj;\n    }\n\n    void construct_sa() {\n        for (int i = 0; i <= n; i++) {\n            sa[i] = i;\n            rank[i] = i < n ? text[i] : -1;\n        }\n\n        for (k = 1; k <= n; k *= 2) {\n            sort(sa.begin(), sa.end(), [&](const int& i, const int& j) {return comp(i, j);});\n\n            vector<int> tmp(n + 1);\n            tmp[sa[0]] = 0;\n            for (int i = 1; i <= n; i++) {\n                tmp[sa[i]] = tmp[sa[i - 1]] + (comp(sa[i - 1], sa[i]) ? 1 : 0);\n            }\n\n            for (int i = 0; i <= n; i++) {\n                rank[i] = tmp[i];\n            }\n        }\n    }\n\n    void construct_lcp () {\n        int h = 0;\n        lcp[0] = 0;\n        for (int i = 0; i < n; i++) {\n            int j = sa[rank[i] - 1];\n            if (h > 0) h--;\n            for (; j + h < n && i + h < n; h++) {\n                if (text[j + h] != text[i + h]) break;\n            }\n            lcp[rank[i] - 1] = h;\n        }\n    }\n\n    int low_bd(const string &pt) {\n        int l = 0, r = n + 1;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val < 0) l = m;\n            else r = m;\n        }\n        return r;\n    }\n\n    int up_bd(const string &pt) {\n        int l = 1, r = n + 1;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val <= 0) l = m;\n            else r = m;\n        }\n        return r;\n    }\n\n    bool match(const string &pt) {\n        int idx = low_bd(pt);\n        if (idx == sa.size()) return false;\n        return text.compare(sa[idx], pt.length(), pt) == 0 ? true : false;\n    }\n\n    int count(const string &pt) {\n        int l_idx = low_bd(pt);\n        if (l_idx == sa.size()) return 0;\n        if (text.compare(sa[l_idx], pt.length(), pt) != 0) return 0;\n        int r_idx = up_bd(pt);\n        return r_idx - l_idx;\n    }\n};\n\nstring t;\nint q;\nstring p[10000];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> t;\n    cin >> q;\n    rep(i, q) cin >> p[i];\n    SuffixArray suf(t);\n    suf.construct_sa();\n    rep(i, q) {\n        if (suf.match(p[i])) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct SA{\n  int n,k;\n  string S;\n  vector<int> r,r2,t,sa,lcp;\n  SA(){}\n  SA(string S):S(S){init();}\n  void init(){\n    n=S.size();\n    r.resize(n+1,0);\n    r2.resize(n+1,0);\n    t.resize(n+1,0);\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    construct_sa();\n    construct_lcp();\n    construct_rmq();\n  }\n  bool compare_sa(int i,int j){\n    if(r[i]!=r[j]) return r[i]<r[j];\n    else{\n      int ri=i+k<=n?r[i+k]:-1;\n      int rj=j+k<=n?r[j+k]:-1;\n      return ri<rj;\n    }\n  }\n  void construct_sa(){\n    n=S.length();\n    for(int i=0;i<=n;i++){\n      sa[i]=i;\n      r[i]=i<n?S[i]:-1;\n    }\n    for(k=1;k<=n;k*=2){\n      sort(sa.begin(),sa.end(),[&](const int &i, const int &j){\n\t  if(r[i]!=r[j]) return r[i]<r[j];\n\t  else{\n\t    int ri=i+k<=n?r[i+k]:-1;\n\t    int rj=j+k<=n?r[j+k]:-1;\n\t    return ri<rj;\n\t  }\n\t});\n      t[sa[0]]=0;\n      for(int i=1;i<=n;i++){\n\tt[sa[i]]=t[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n      }\n      for(int i=0;i<=n;i++){\n\tr[i]=t[i];\n      }\n    }\n  }\n  bool contains(string T){\n    int a=0,b=S.length()+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==(int)S.length()+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void construct_lcp(){\n    for(int i=0;i<=n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);construct(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void construct(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void construct_rmq(){\n    rmq.init(n);\n    rmq.construct(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SA sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 1000001\n \nint n,k,sa[MAX_N];\nint rank[MAX_N],tmp[MAX_N];\n \nbool compare_sa(int i,int j){\n    if(rank[i] != rank[j]){\n        return rank[i] < rank[j];\n    }else{\n        int ri = i + k <= n ? rank[i+k] : -1;\n        int rj = j + k <= n ? rank[j+k] : -1;\n        return ri < rj;\n    }\n}\n\nvoid construct_sa(string &S,int *sa){\n    n = S.length();\n   \n    for(int i = 0 ; i <= n ; i++){\n        sa[i] = i;\n        rank[i] = i < n ? S[i] : -1;\n    }\n \n    for(k = 1 ; k <= n ; k *= 2){\n        sort(sa,sa+n+1,compare_sa);\n     \n        tmp[sa[0]] = 0;\n        for(int i = 1 ; i <= n ; i++){\n            tmp[sa[i]] = tmp[sa[i-1]] + (compare_sa(sa[i-1],sa[i]) ? 1 : 0);\n        }\n        for(int i = 0 ; i <= n ; i++){\n            rank[i] = tmp[i];\n        }\n    }\n}\n \nbool contain(string &S,int *sa,string &T){\n    int a = 0, b = S.length();\n    while(b - a > 1){\n        int c = (a + b) / 2;\n        if(S.compare(sa[c],T.length(),T) < 0) a = c;\n        else b = c;\n    }\n    return S.compare(sa[b],T.length(),T) == 0;\n}\n \nint main(){\n    ios::sync_with_stdio(0);\n    \n    int Q;\n    string S,T;\n    cin >> S >> Q;\n    construct_sa(S,sa);\n    while(Q--){\n        cin >> T;\n        if(S.size() < T.size()){ cout << '0' << endl; continue; }\n        cout << (contain(S,sa,T) ? '1' : '0') << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n/2+n%2,b[2*nb],c[2*nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==nc)a[i]=b[j++];\n      else if(j==nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[2*n];\n  REP(i,n)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(2*n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[2000000];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring S,T;\nstring V[100000][100];\nint main(){\n\tint q,a,b;\n\tb=S.size();\n\tcin>>S;\n\ta=min(b,100);\n\tfor(int i=1;i<100;i++){\n\t\tfor(int j=0;j<=S.size()-i;j++){\n\t\t\tV[j][i]=S.substr(j,i);\n\t\t}\n\t}\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>T;\n\t\tfor(int j=0;j<S.size()-T.size();j++){\n\t\t\tif(V[j][T.size()]==T){\n\t\t\t\tcout<<\"1\"<<endl;\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t}\n\t\tcout<<\"0\"<<endl;\n\t\tExit:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int B=999999937;\nconst int P=1000000007;\n\nvector<long long> gen_hash(const string &s){\n\tvector<long long> hash(s.size());\n\tlong long c=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tc=(c*B+s[i])%P;\n\t\thash[i]=c;\n\t}\n\treturn hash;\n}\nlong long pow_binary_mod(long long x,long long y,long long mod){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%mod;\n\t\tx=x*x%mod;\n\t}\n\treturn z;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s;\n\tcin>>s;\n\tvector<long long> v=gen_hash(s);\n\n\tint T;\n\tfor(cin>>T;T--;){\n\t\tstring q;\n\t\tcin>>q;\n\t\tlong long hash=gen_hash(q)[q.size()-1];\n\t\tlong long Brev=pow_binary_mod(B,q.size(),P);\n\t\tvector<int> r;\n\t\tfor(int i=q.size()-1;i<s.size();i++){\n\t\t\tlong long h=((v[i]-(i==q.size()-1?0:v[i-q.size()])*Brev)%P+P)%P;\n\t\t\tif(h==hash)r.push_back(i-q.size()+1);\n\t\t}\n\t\tif(!r.empty()){\n\t\t\t//for(int i=0;i<r.size();i++)printf(\"%d\\n\",r[i]);\n\t\t\tputs(\"1\");\n\t\t}else{\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nstruct characters\n{\n    static int const size = 62;\n    static int convert(char c)\n    {\n        // assert('a' <= c && c <= 'z');\n        if ('a' <= c && c <= 'z')\n        {\n            return c - 'a';\n        }\n        else if ('A' <= c && c <= 'Z')\n        {\n            return 26 + c - 'A';\n        }\n        else\n        {\n            return 52 + c - '0';\n        }\n    }\n    static char invert(int i)\n    {\n        // assert(0 <= i && i < size);\n        if (0 <= i && i < 26)\n        {\n            return 'a' + i;\n        }\n        else if (26 <= i && i < 52)\n        {\n            return 'A' + i - 26;\n        }\n        else\n        {\n            return '0' + i - 52;\n        }\n    }\n};\n\ntemplate <typename Characters>\nclass AhoCorasick\n{\n    static constexpr int invalidIndex = -1;\n\n    struct PMA\n    {\n        int fail;\n        std::vector<int> next, accept;\n\n        PMA() : fail(invalidIndex), next(Characters::size, invalidIndex) {}\n    };\n\n    const int K;\n    std::vector<std::unique_ptr<PMA>> nodes;\n\n    int transition(int nodeIndex, char cc)\n    {\n        assert(0 <= nodeIndex && nodeIndex < (int)nodes.size());\n        int c = Characters::convert(cc);\n        int now = nodeIndex;\n        while (nodes[now]->next[c] == invalidIndex && now != 0)\n        {\n            now = nodes[now]->fail;\n        }\n        now = nodes[now]->next[c];\n        if (now == invalidIndex)\n            now = 0;\n        return now;\n    }\n\n  public:\n    AhoCorasick(const std::vector<std::string> &ts) : K((int)ts.size())\n    {\n        const int rootIndex = 0;\n        // root node\n        nodes.push_back(std::make_unique<PMA>());\n        nodes[rootIndex]->fail = rootIndex;\n        for (int i = 0; i < K; i++)\n        {\n            int now = rootIndex;\n            for (auto cs : ts[i])\n            {\n                int c = Characters::convert(cs);\n                if (nodes[now]->next[c] == invalidIndex)\n                {\n                    nodes[now]->next[c] = (int)nodes.size();\n                    nodes.push_back(std::make_unique<PMA>());\n                }\n                now = nodes[now]->next[c];\n            }\n            nodes[now]->accept.push_back(i);\n        }\n\n        std::queue<int> que;\n        for (int c = 0; c < Characters::size; c++)\n        {\n            if (nodes[rootIndex]->next[c] != invalidIndex)\n            {\n                nodes[nodes[rootIndex]->next[c]]->fail = rootIndex;\n                que.push(nodes[rootIndex]->next[c]);\n            }\n        }\n        while (!que.empty())\n        {\n            int now = que.front();\n            que.pop();\n            for (int c = 0; c < Characters::size; c++)\n            {\n                if (nodes[now]->next[c] != invalidIndex)\n                {\n                    que.push(nodes[now]->next[c]);\n                    int nxt = transition(nodes[now]->fail, Characters::invert(c));\n                    nodes[nodes[now]->next[c]]->fail = nxt;\n                    for (auto ac : nodes[nxt]->accept)\n                    {\n                        nodes[nodes[now]->next[c]]->accept.push_back(ac);\n                    }\n                }\n            }\n        }\n    }\n    std::vector<std::vector<int>> match(const std::string &str)\n    {\n        std::vector<std::vector<int>> ret(K);\n        int now = 0;\n        for (int i = 0; i < (int)str.size(); i++)\n        {\n            now = transition(now, str[i]);\n            for (auto k : nodes[now]->accept)\n            {\n                ret[k].push_back(i);\n            }\n        }\n        return ret;\n    }\n    std::vector<bool> contain(const std::string &str)\n    {\n        std::vector<bool> ret(K, false);\n        int now = 0;\n        for (int i = 0; i < (int)str.size(); i++)\n        {\n            now = transition(now, str[i]);\n            for (auto k : nodes[now]->accept)\n            {\n                ret[k] = true;\n            }\n        }\n        return ret;\n    }\n};\n\nclass SuffixArray\n{\n    int n;\n    std::string str;\n    std::vector<int> sa, rank;\n\n    template <typename Compare>\n    int binarySearch(const std::string &t)\n    {\n        int m = t.size();\n        int lb = -1, ub = n + 1;\n        while (ub - lb > 1)\n        {\n            int mid = (ub + lb) / 2;\n            if (Compare()(strncmp(str.c_str() + sa[mid], t.c_str(), m), 0))\n            {\n                lb = mid;\n            }\n            else\n            {\n                ub = mid;\n            }\n        }\n        return ub;\n    }\n\n  public:\n    // 構築 O(n (logn)^2)\n    SuffixArray(const std::string _s) : n(_s.size()), str(_s), sa(n + 1), rank(n + 1)\n    {\n        for (int i = 0; i <= n; i++)\n        {\n            sa[i] = i;\n            rank[i] = i < n ? str[i] : -1;\n        }\n        std::vector<int> tmp(n + 1);\n        for (int k = 1; k <= n; k *= 2)\n        {\n            // (rank[i], rank[i+k]), (rank[j], rank[j+k]) を比較\n            auto compare_sa = [=](int i, int j) {\n                if (rank[i] != rank[j])\n                    return rank[i] < rank[j];\n                else\n                {\n                    int ri = i + k <= n ? rank[i + k] : -1;\n                    int rj = j + k <= n ? rank[j + k] : -1;\n                    return ri < rj;\n                }\n            };\n            std::sort(sa.begin(), sa.end(), compare_sa);\n            tmp[sa[0]] = 0;\n            for (int i = 1; i <= n; i++)\n            {\n                tmp[sa[i]] = tmp[sa[i - 1]] + (compare_sa(sa[i - 1], sa[i]) ? 1 : 0);\n            }\n            for (int i = 0; i <= n; i++)\n            {\n                rank[i] = tmp[i];\n            }\n        }\n    }\n    // O(|t|logn)\n    bool contain(const std::string &t)\n    {\n        int lb = 0, ub = n;\n        while (ub - lb > 1)\n        {\n            int mid = (lb + ub) / 2;\n            if (str.compare(sa[mid], t.size(), t) < 0)\n                lb = mid;\n            else\n                ub = mid;\n        }\n        return str.compare(sa[ub], t.size(), t) == 0;\n    }\n    // 高さ配列 := 接尾辞配列における隣接要素で先頭何文字が共通しているか\n    // つまり, lcp[i] = str[sa[i]..] と str[sa[i+1]..] の先頭共通文字数\n    // O(n)\n    std::vector<int> getLcp()\n    {\n        for (int i = 0; i <= n; i++)\n            rank[str[i]] = i;\n        int h = 0;\n        std::vector<int> lcp(n + 1);\n        for (int i = 0; i < n; i++)\n        {\n            int j = sa[rank[i] - 1];\n            if (h > 0)\n                h--;\n            for (; j + h < n && i + h < n; h++)\n            {\n                if (str[j + h] != str[i + h])\n                    break;\n            }\n            lcp[rank[i] - 1] = h;\n        }\n        return lcp;\n    }\n    std::vector<int> getSa()\n    {\n        return sa;\n    }\n    int lowerBound(const std::string &t)\n    {\n        return binarySearch<std::less<int>>(t);\n    }\n    int upperBound(const std::string &t)\n    {\n        return binarySearch<std::less_equal<int>>(t);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    string T;\n    cin >> T;\n    SuffixArray sa(T);\n    int Q;\n    cin >> Q;\n    vector<string> s;\n    while (Q--)\n    {\n        string t;\n        cin >> t;\n        cout << (sa.contain(t) ? 1 : 0) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n// #define double long double\n#define FOR(i, a, b) for(ll i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(ll i = (a); i > (b); --i)\n#define REP(i, n) for(ll i = 0; i < (n); ++i)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt(x) __builtin_popcount(x)\n#define lbit(x) __builtin_ffsll(x)\n#define rbit(x) __builtin_clzll(x)\n#define SZ(x) ((ll)(x).size())\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\n#define rAll(a) (a).rbegin(), (a).rend()\n#define PERM(c)                                                                \\\n    sort(All(c));                                                              \\\n    for(bool cp = true; cp; cp = next_permutation(All(c)))\n#define MKORDER(n)                                                             \\\n    vector<ll> od(n);                                                          \\\n    iota(All(od), 0LL);\n\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CCIN(...)                                                              \\\n    char __VA_ARGS__;                                                          \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    ll __VA_ARGS__;                                                            \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << \"\\n\"\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << \"\\n\"\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\n\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<ll, ll> PL;\ntypedef vector<PL> VPL;\ntypedef vector<bool> VB;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nconst ll LINF = 1e18;\nconst double PI = atan(1.0) * 4.0;\nconst ll dw[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dh[] = {0, 1, 1, 1, 0, -1, -1, -1};\n#define PI 3.141592653589793238\n// NlogN\nstruct SuffixArray {\n    vector<int> SA;\n    string s;\n\n    SuffixArray(const string &str) { Build_SA(str); }\n\n    void Build_SA(const string &str) {\n        s = str;\n        SA.resize(s.size());\n        iota(begin(SA), end(SA), 0);\n        sort(begin(SA), end(SA), [&](const int &a, const int &b) {\n            if(s[a] == s[b]) return (a > b);\n            return (s[a] < s[b]);\n        });\n        vector<int> classes(s.size()), c(s.size()), cnt(s.size());\n        for(int i = 0; i < s.size(); i++) {\n            c[i] = s[i];\n        }\n        for(int len = 1; len < s.size(); len <<= 1) {\n            for(int i = 0; i < s.size(); i++) {\n                if(i > 0 && c[SA[i - 1]] == c[SA[i]] &&\n                   SA[i - 1] + len < s.size() &&\n                   c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n                    classes[SA[i]] = classes[SA[i - 1]];\n                } else {\n                    classes[SA[i]] = i;\n                }\n            }\n            iota(begin(cnt), end(cnt), 0);\n            copy(begin(SA), end(SA), begin(c));\n            for(int i = 0; i < s.size(); i++) {\n                int s1 = c[i] - len;\n                if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n            }\n            classes.swap(c);\n        }\n        SA.insert(SA.begin(), s.size());\n    }\n\n    int operator[](int k) const { return (SA[k]); }\n\n    int size() const { return (s.size()); }\n\n    bool lt_substr(string &t, int si = 0, int ti = 0) {\n        int sn = s.size(), tn = t.size();\n        while(si < sn && ti < tn) {\n            if(s[si] < t[ti]) return (true);\n            if(s[si] > t[ti]) return (false);\n            ++si, ++ti;\n        }\n        return (si >= sn && ti < tn);\n    }\n\n    int lower_bound(string &t) {\n        int low = -1, high = SA.size();\n        while(high - low > 1) {\n            int mid = (low + high) >> 1;\n            if(lt_substr(t, SA[mid]))\n                low = mid;\n            else\n                high = mid;\n        }\n        return (high);\n    }\n\n    pair<int, int> lower_upper_bound(string &t) {\n        int idx = lower_bound(t);\n        int low = idx - 1, high = SA.size();\n        t.back()++;\n        while(high - low > 1) {\n            int mid = (low + high) >> 1;\n            if(lt_substr(t, SA[mid]))\n                low = mid;\n            else\n                high = mid;\n        }\n        t.back()--;\n        return (make_pair(idx, high));\n    }\n\n    void output() {\n        for(int i = 0; i < size(); i++) {\n            cout << i << \": \" << s.substr(SA[i]) << endl;\n        }\n    }\n};\n\n// Sparse Table\ntemplate <class MeetSemiLattice> struct SparseTable {\n    vector<vector<MeetSemiLattice>> dat;\n    vector<int> height;\n\n    SparseTable() {}\n    SparseTable(const vector<MeetSemiLattice> &vec) { init(vec); }\n    void init(const vector<MeetSemiLattice> &vec) {\n        int n = (int)vec.size(), h = 0;\n        while((1 << h) < n) ++h;\n        dat.assign(h, vector<MeetSemiLattice>(1 << h));\n        height.assign(n + 1, 0);\n        for(int i = 2; i <= n; i++) height[i] = height[i >> 1] + 1;\n        for(int i = 0; i < n; ++i) dat[0][i] = vec[i];\n        for(int i = 1; i < h; ++i)\n            for(int j = 0; j < n; ++j)\n                dat[i][j] = min(dat[i - 1][j],\n                                dat[i - 1][min(j + (1 << (i - 1)), n - 1)]);\n    }\n\n    MeetSemiLattice get(int a, int b) {\n        return min(dat[height[b - a]][a],\n                   dat[height[b - a]][b - (1 << height[b - a])]);\n    }\n};\n\nstruct LCP {\n    vector<int> lcp, rank;\n    SparseTable<int> st;\n\n    LCP(SuffixArray &SA) { Build_LCP(SA); }\n\n    int operator[](int k) const { return (lcp[k]); }\n\n    int size() const { return (lcp.size()); }\n\n    void Build_LCP(SuffixArray &SA) {\n        string &s = SA.s;\n        ll n = s.size();\n        rank.resize(n + 1);\n        for(int i = 0; i <= n; ++i) rank[SA[i]] = i;\n        lcp.resize(n + 1);\n        lcp[0] = 0;\n        int cur = 0;\n        for(int i = 0; i < n; ++i) {\n            int pi = SA[rank[i] - 1];\n            if(cur > 0) --cur;\n            for(; pi + cur < n && i + cur < n; ++cur) {\n                if(s[pi + cur] != s[i + cur]) break;\n            }\n            lcp[rank[i] - 1] = cur;\n        }\n        st.init(lcp);\n    }\n\n    // calc lcp\n    int getLCP(int a, int b) { // lcp of str.sutstr(a) and str.substr(b)\n        return st.get(min(rank[a], rank[b]), max(rank[a], rank[b]));\n    }\n};\n\nsigned main() {\n    SCIN(T);\n    LCIN(n);\n    SuffixArray sa(T);\n    REP(i, n) {\n        SCIN(P);\n        PL p = sa.lower_upper_bound(P);\n        cout << (p.se - p.fi > 0) << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define MAX 10002\ntypedef unsigned char byte;\nbyte mask[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\n\nint Lv[MAX];\nint n, k;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n    return L_i < L_j;\n}\n\nint main()\n{\n    int A[MAX];\n    char c[MAX];\n    scanf(\"%s\", c);\n    std::string T = std::string(c);\n    n = T.size();\n    byte *t;\n    t = new byte [(n >> 3) + 1];\n\tbool act;\n\tint l, r;\n\n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n\t\n\tbyte bkt[256];\n\tfor(i = 0; i < 256; i++){ bkt[i] = 0; }\n\tfor(i = 0; i < n; i++){ bkt[Lv[i]]++; }\n\tint sum = 0;\n\tfor(i = 0; i < 256; i++){ sum += bkt[i]; bkt[i] = sum; }\n\tfor(i = 0; i < n; i++){ A[--bkt[Lv[i]]] = i; }\n\n    //std::sort(A, A + n, cmp_Lv);\n\n\t\n\n\n\n    for(i = 1; i < n; i++){\n        t[i >> 3] = (Lv[A[i]] != Lv[A[i - 1]] ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n    }\n    t[n >> 3] = t[n >> 3] | mask[n & 7];\n\n    Lv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n    }\n\n    k = 1;\n    while(1){\n        if(k > n) break;\n\n        act = true;\n        for(i = 1; i <= n; i++){\n            if(act){\n                if(!!(mask[i & 7] & t[i >> 3])){ continue; }\n                else{ l = i - 1; act = false; }\n            }else{\n                if(!!(mask[i & 7] & t[i >> 3])){\n                    r = i; std::sort(A + l, A + r, cmp); act = true; }\n                    else{ continue; }\n            }\n        }\n\n        for(i = 1; i < n; i++){\n            t[i >> 3] = (cmp(A[i - 1], A[i]) ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n        }\n        t[n >> 3] = t[n >> 3] | mask[n & 7];\n\n        Lv[A[0]] = 0;\n        for(i = 1; i < n; i++){\n            Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n        }\n\n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n\n    char p[1000];\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n\n    A[n] = n;\n\n    while(q){\n        scanf(\"%s\", p);\n        std::string P = std::string(p);\n        left = 0, right = n, exist = false;\n        while(left < right){\n\n            if(n < P.size()){ exist = false; break; }\n\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n\n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\nclass suffix_array{\nprivate:\n    typedef unsigned long ul;\n    \n    struct node{\n        ll begin;\n        ll Rank;\n        node* next; //sortで狂ってる\n        \n        bool operator < (const node &N) const {\n            if(Rank==N.Rank){\n                return (next==NULL?-1:next->Rank)<(N.next==NULL?-1:N.next->Rank);\n            }\n            return Rank<N.Rank;\n        }\n        \n        node(ll begin=0,ll Rank=0,node* next=NULL):begin(begin),Rank(Rank),next(next){}\n    };\n    \n    static bool pointer_cmp(node* &a,node* &b){return (*a)<(*b);}\n    \n    vector<node*> sa;\n    vector<ll> Rank;\n    const string s;\n    \n    void build(){\n        for(int i=0;i<s.size();i++){\n            *sa[i]={i,s[i],sa[i+1]};\n        }\n        sa[s.size()]->begin=s.size();\n        sa[s.size()]->Rank=-1;\n        sa[s.size()]->next=NULL;\n        vector<node*> Next(s.size()+1);\n        for(ll k=1;k<=s.size();k<<=1){\n            sort(sa.begin(),sa.end(),pointer_cmp);\n            Rank[sa[0]->begin]=0;\n            Next[0]=(sa[0]->next==NULL?NULL:sa[0]->next->next);\n            for(int i=1;i<=s.size();i++){\n                Rank[sa[i]->begin]=Rank[sa[i-1]->begin]+(*sa[i-1]<*sa[i]?1:0);\n                Next[i]=(sa[i]->next==NULL?NULL:sa[i]->next->next);\n            }\n            for(int i=0;i<=s.size();i++){\n                sa[i]->Rank=Rank[sa[i]->begin];\n                sa[i]->next=Next[i];\n            }\n        }\n        for(int i=0;i<=s.size();i++){\n            Next[sa[i]->begin]=sa[i];\n        }\n        for(int i=0;i<=s.size();i++){\n            sa[i]->next=sa[i]->begin==s.size()?NULL:Next[sa[i]->begin+1];\n        }\n    }\n    \n    //1::greater 0::same -1::less\n    int compare(const ul &saf,const string &str){\n        for(int i=0;i<str.size();i++){\n            if(sa[saf]->begin+i>=s.size()){return -1;}\n            if(s[sa[saf]->begin+i]!=str[i]){return s[sa[saf]->begin+i]<str[i]?-1:1;}\n        }\n        return 0;\n    }\n    \npublic:\n    suffix_array(const string &str):s(str),Rank(str.size()+1),sa(str.size()+1){\n        for(int i=0;i<=str.size();i++){\n            sa[i]=(node*)malloc(sizeof(node));\n        }\n        build();\n    }\n    \n    ll rank(const ul &where) const {return Rank[where];}\n    \n    ul size() const {return sa.size();}\n    \n    const node & operator [] (const ul &where) const {return *sa[where];}\n    \n    //返すのはsuffixの番号\n    ul lower_bound(const string &sub){\n        ll l=0;\n        ll r=s.size();\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            if(compare(m,sub)==-1){l=m+1;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(compare(i,sub)>=0){return i;}\n        }\n        return r+1;\n    }\n    \n    //返すのはsuffixの番号\n    ul upper_bound(const string &sub){\n        ll l=0;\n        ll r=s.size();\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            if(compare(m,sub)<=0){l=m+1;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(compare(i,sub)>0){return i;}\n        }\n        return r+1;\n    }\n    \n    bool match(const string &sub){\n        ll l=0;\n        ll r=s.size();\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            int st=compare(m,sub);\n            if(st==0){return true;}\n            else if(st==-1){l=m+1;}\n            else{r=m-1;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(compare(i,sub)==0){return true;}\n        }\n        return false;\n    }\n};\n\n\nint main(){\n    string t;\n    cin>>t;\n    suffix_array S(t);\n    ll q;\n    cin>>q;\n    while(q--){\n        string p;\n        cin>>p;\n        cout<<S.match(p)<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(string s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int i, const int j) { \n    int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  \n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  \n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      assert(r>l);\n      int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\n\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S 2500005\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\nstruct d{\n  int a,b,c;\n  d(){}\n  d(int A,int B,int C){\n    a=A,b=B,c=C;\n  };\n  bool operator<(const d&r)const{\n    if(a!=r.a)return a<r.a;\n    return b<r.b;\n  }\n};\n\nint n,slen,tlen,r[S];\nchar s[S],t[N];\nd ran[S];\nP a[S];\n\nvoid init(){\n  for(int i=0;i<26;i++)\n    for(int j=0;j<slen;j++)\n      if('a'+i==s[j])\n\tr[j]=i+1;\n\n  int x=1;\n  r[slen]=0;\n  while(1){\n    for(int i=0;i<slen;i++){\n      int o=i+x;\n      if(o>slen)o=slen;\n      ran[i]=d(r[i],r[o],i);\n    }\n    sort(ran,ran+slen);\n    int cnt=0;\n    for(int i=0;i<slen;i++){\n      r[ran[i].c]=cnt;\n      if(ran[i].a==ran[i+1].a&&ran[i].b==ran[i+1].b)\n\tcontinue;\n      cnt++;\n    }\n    if(x>slen)break;\n    x*=2;\n  }\n  for(int i=0;i<slen;i++)a[i]=P(r[i],i);\n  sort(a,a+slen);\n}\n\nbool bynary_search(){\n  int L=0,R=slen;\n  while(L<R){\n    int M=(L+R)/2;\n    if(strncmp(s+a[M].second,t,tlen)<0)L=M+1;\n    else R=M;\n  }\n  if(!strncmp(s+a[L].second,t,tlen))return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s%d\",s,&n);\n  slen=strlen(s);\n  init();  \n  while(n--){\n    scanf(\"%s\",t);\n    tlen=strlen(t);\n    if(bynary_search())printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_N 1005\nusing namespace std;\n/*????¬??????????????????°???????????\\ O(H*W)*/\n/*T????????????U????????´????????´????????¢???*/\ntypedef unsigned long long ull;\nconst ull A=9999973,B=950527; //A:???????´???°, B:?¨?????´???°\n \nint H,W;\nchar T[MAX_N][MAX_N];\null t[MAX_N][MAX_N]; \null t2[MAX_N][MAX_N];\n\nint h,w;\nchar U[1005][1005];\n \nvoid rol_hash2(){\n\n  ull target=0;  //????????¨?????????????????\\\n  for(int i=0; i<h ;i++){\n    ull key=0;\n    for(int j=0; j<w ;j++)key= key * B + U[i][j];\n    target = target * A + key;\n  }\n \n  ull C=1;\n  for(int i=0; i<w ;i++)C*=B;\n   \n  //?¨?????????????????????\\????????????\n  for(int i=0; i<H ;i++){\n    ull key=0;\n    for(int j=0; j<W ;j++){\n      key = key * B + T[i][j];\n      if(j-w >= 0)key -= T[i][j-w] * C;\n      t[i][j] = key;\n      t2[i][j] = t[i][j];\n    }\n  }\n   \n  C=1;\n  for(int i=0; i<h ;i++)C*=A;\n  \n  //???????????????????????\\????????????\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++){\n      if( i ) t[i][j] += t[i-1][j] * A;\n      if(i-h >= 0) t[i][j] -= t2[i-h][j] * C;\n      if(t[i][j] == target)\n        if(i-h+1>=0&&j-w+1>=0)\n\t  printf(\"%d %d\\n\",i-h+1,j-w+1);//???????????§?¨??????????\n    }\n}\n \nint main(){\n  scanf(\"%d %d\",&H,&W);\n  for(int i=0;i<H;i++)scanf(\"%s\",T[i]);\n  scanf(\"%d %d\",&h,&w);\n  for(int i=0;i<h;i++)scanf(\"%s\",U[i]);\n  rol_hash2();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n\n\nusing namespace std;\n\nstring t;\nint q,n,size;\nbool flag;\nint id[70] = {};\n\nint main()\n{\n\tcin >> t >> q;\n\t\n\tfor(int i = 0 ;i < t.size();i++)\n\t{\n\t\tif(t[i] > 'a' && t[i] < 'Z')id[t[i] - 'a']++;\n\t\telse id[52 + t[i] - '0']++;\n\t}\n\t\n\t\n\tfor(int i = 0;i < q ;i++)\n\t{\n\t\tflag = false;\n\t\tint z[70] = {};\n\t\tstring p;\n\t\tcin >> p;\n\t\tsize = p.size();\n\t\t\n\t\tfor(int h = 0 ;h < size;h++)\n\t\t{\n\t\t\tif(t[h] > 'a' && t[h] < 'Z')id[t[h] - 'a']++;\n\t\t\telse z[52 + t[h] - '0']++;\n\t\t}\n\t\t\n\t\tfor(int w = 0;w < 70;w++)\n\t\tif(id[w] < z[w]) flag = true;\n\t\t\n\t\tif(flag)\n\t\t{\n\t\tcout << 0 << endl;\n\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tfor(int j = 0;j < t.size();j++)\n\t\t{\n\t\t\tif(t[j] == p[0])\n\t\t\t{\n\t\t\t\tif(size == 1) \n\t\t\t\t{\n\t\t\t\t\tcout << 1 << endl;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\tfor(int k = 1;k < size;k++)\n\t\t\t\t{\n\t\t\t\t\tif(t[j+k] != p[k]) break;\n\t\t\t\t\tif(k == size -1) \n\t\t\t\t\t{\n\t\t\t\t\t\tcout << 1 << endl;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tif(flag) break;\n\t\t}\n\tif(!flag) cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define MAX 10002\ntypedef unsigned char byte;\nbyte mask[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\n\nint Lv[MAX];\nint n, k;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n    return L_i < L_j;\n}\n\nint main()\n{\n    int A[MAX];\n    char c[MAX];\n    scanf(\"%s\", c);\n    std::string T = std::string(c);\n    n = T.size();\n    byte *t;\n    t = new byte [(n >> 3) + 1];\n\tbool act;\n\tint l, r;\n\n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n\t\n\tbyte bkt[129];\n\tfor(i = 0; i < 129; i++){ bkt[i] = 0; }\n\tfor(i = 0; i < n; i++){ bkt[Lv[i]]++; }\n\tint sum = 0;\n\tfor(i = 0; i < 129; i++){ sum += bkt[i]; bkt[i] = sum; }\n\tfor(i = 0; i < n; i++){ A[bkt[Lv[i]]--] = i; }\n\n    //std::sort(A, A + n, cmp_Lv);\n\n    for(i = 1; i < n; i++){\n        t[i >> 3] = (Lv[A[i]] != Lv[A[i - 1]] ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n    }\n    t[n >> 3] = t[n >> 3] | mask[n & 7];\n\n    Lv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n    }\n\n    k = 1;\n    while(1){\n        if(k > n) break;\n\n        act = true;\n        for(i = 1; i <= n; i++){\n            if(act){\n                if(!!(mask[i & 7] & t[i >> 3])){ continue; }\n                else{ l = i - 1; act = false; }\n            }else{\n                if(!!(mask[i & 7] & t[i >> 3])){\n                    r = i; std::sort(A + l, A + r, cmp); act = true; }\n                    else{ continue; }\n            }\n        }\n\n        for(i = 1; i < n; i++){\n            t[i >> 3] = (cmp(A[i - 1], A[i]) ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n        }\n        t[n >> 3] = t[n >> 3] | mask[n & 7];\n\n        Lv[A[0]] = 0;\n        for(i = 1; i < n; i++){\n            Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n        }\n\n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n\n    char p[1000];\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n\n    A[n] = n;\n\n    while(q){\n        scanf(\"%s\", p);\n        std::string P = std::string(p);\n        left = 0, right = n, exist = false;\n        while(left < right){\n\n            if(n < P.size()){ exist = false; break; }\n\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n\n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nclass Aho_Corasick {\n\tstatic const int var = 62;\t// ??????????¨??????°\n\tstatic int trans(char c) {\n\t\tif ('A' <= c && c <= 'Z') {\n\t\t\treturn c - 'A';\n\t\t}\n\t\tif ('a' <= c && c <= 'z') {\n\t\t\treturn c - 'a' + 26;\n\t\t}\n\t\tif ('0' <= c && c <= '9') {\n\t\t\treturn c - '0' + 52;\n\t\t}\n\t\texit(EXIT_FAILURE);\n\t}\n\tstruct node {\n\t\tnode *no;\n\t\tvector<node*> next;\n\t\tvector<int> matched;\n\t\tnode() : no(nullptr), next(var, nullptr) {}\n\t\t~node() { for (auto ite : next) if (ite != this && ite != nullptr) delete ite; }\n\t};\n\tvector<int> unite(const vector<int>& a, const vector<int>& b) {\n\t\tvector<int> res;\n\t\tset_union(a.begin(), a.end(), b.begin(), b.end(), back_inserter(res));\n\t\treturn res;\n\t}\n\tint K;\n\tnode *root;\npublic:\n\tAho_Corasick(const vector<string>& Ts) : K(Ts.size()), root(new node) {\n\t\tnode *now;\n\t\troot->no = root;\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tauto &T = Ts[i];\n\t\t\tnow = root;\n\t\t\tfor (auto c : T) {\n\t\t\t\tif (now->next[trans(c)] == nullptr) {\n\t\t\t\t\tnow->next[trans(c)] = new node;\n\t\t\t\t}\n\t\t\t\tnow = now->next[trans(c)];\n\t\t\t}\n\t\t\tnow->matched.push_back(i);\n\t\t}\n\t\tqueue<node*> q;\n\t\tfor (int i = 0; i < var; i++) {\n\t\t\tif (root->next[i] == nullptr) {\n\t\t\t\troot->next[i] = root;\n\t\t\t}\n\t\t\telse {\n\t\t\t\troot->next[i]->no = root;\n\t\t\t\tq.push(root->next[i]);\n\t\t\t}\n\t\t}\n\t\twhile (!q.empty()) {\n\t\t\tnow = q.front(); q.pop();\n\t\t\tfor (int i = 0; i < var; i++) {\n\t\t\t\tif (now->next[i] != nullptr) {\n\t\t\t\t\tnode *nx = now->no;\n\t\t\t\t\twhile (nx->next[i] == nullptr) {\n\t\t\t\t\t\tnx = nx->no;\n\t\t\t\t\t}\n\t\t\t\t\tnow->next[i]->no = nx->next[i];\n\t\t\t\t\tnow->next[i]->matched = unite(now->next[i]->matched, nx->next[i]->matched);\n\t\t\t\t\tq.push(now->next[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t~Aho_Corasick() {\n\t\tdelete root;\n\t}\n\tvector<int> count(const string& S) {\n\t\tvector<int> res(K);\n\t\tnode *now = root;\n\t\tfor (auto c : S) {\n\t\t\twhile (now->next[trans(c)] == nullptr) {\n\t\t\t\tnow = now->no;\n\t\t\t}\n\t\t\tnow = now->next[trans(c)];\n\t\t\tfor (auto k : now->matched) {\n\t\t\t\tres[k]++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tstring S;\n\tint M;\n\tcin >> S >> M;\n\tvector<string> C(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> C[i];\n\t}\n\tAho_Corasick aho(C);\n\tauto cnt = aho.count(S);\n\tfor (auto t : cnt) {\n\t\tcout << (t != 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tint n;\n\tstring text;\n\tstring pattern;\n\tcin >> text >> n;\n\n\tfor (int i = 0; i < n; ++i){\n\t\tcin >> pattern;\n\t\tstring::size_type index = text.find(pattern);\n\t\tif (index == std::string::npos) {\n\t\t\tcout << 0 << \"\\n\";\n\t\t} else {\n\t\t\tcout << 1 << \"\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) const { \n    //const int k=lcp(i,j);\n    //const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    const int k=lcp2(i,j,0,(n-max(i,j))*2+1);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  inline bool cmp(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n  \n  \n  inline int lcp2(const int& i, const int& j, const int& l, const int& r) const {\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n  \n};\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  const int n = SZ(a);\n  if(n>1){\n    vector<int> b(a.begin(), a.begin()+n/2);\n    vector<int> c(a.begin()+n/2, a.end());\n    mergesort(b,rh);\n    mergesort(c,rh);\n    for (int i=0,j=0,k=0;i<n;i++){\n      if(k == SZ(c))a[i]=b[j++];\n      else if(j==SZ(b))a[i]=c[k++];\n      else if(rh.cmp(b[j],c[k]))a[i]=b[j++];\n      else a[i] = c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  //sort(ALL(sa),rh);\n  mergesort(sa,rh);\n  //if(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    int c=(a+b)/2;\n    //if(S.compare(sa[c],T.length(),T)<0 )a=c;\n    //else b=c;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  while(n--){\n    cin >> t;\n    cout << contain(s,sa,t) << \"\\n\";\n    //cout << !!rh.find(t) << \"\\n\";\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) { \n    //const int k=lcp(i,j);\n    const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    if(i+k>=n)return 1;\n    if(j+k>=n)return 0;\n    return s[i+k] <= s[j+k];\n    //return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  /*\n  inline int lcp(const int i, const int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n  */\n  inline int lcp2(const int& i, const int& j, const int& l, const int& r){\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\nif(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\n\nstruct PMA{\n    PMA *next[256];\n    Vec matched;\n    PMA(){ fill(next,next+256,(PMA*)0); }\n    ~PMA(){\n\tfor(int i = 0 ; i < 256 ; i++){\n\t    if(next[i]) delete next[i];\n\t}\n    }\n};\n\nVec set_union(const Vec &a,const Vec &b){\n    int i = 0, j = 0, A = a.size(), B = b.size();\n    Vec res;\n    while(i < A && j < B){\n        if(a[i] == b[j]){\n            res.push_back(a[i]);\n            i++; j++;\n        }else if(a[i] > b[j]){\n            res.push_back(b[j++]);\n        }else{\n            res.push_back(a[i++]);\n        }\n    }\n    for( ; i < A ; i++) res.push_back(a[i]);\n    for( ; j < B ; j++) res.push_back(b[j]);\n    return res;\n}\n\nPMA *buildPMA(char pattern[10000][1001],int size){\n    PMA *root = new PMA;\n    for(int i = 0 ; i < size ; i++){\n        PMA *t = root;\n        for(int j = 0 ; pattern[i][j] != '\\0' ; j++){\n            char c = pattern[i][j];\n            if(t->next[c] == NULL) t->next[c] = new PMA;\n            t = t->next[c];\n        }\n        t->matched.push_back(i);\n    }\n    queue<PMA*> Q;\n    for(int i = 1 ; i < 256 ; i++){\n        if(root->next[i]){\n            root->next[i]->next[0] = root;\n            Q.push(root->next[i]);\n        }else{\n            root->next[i] = root;\n        }\n    }\n    while(!Q.empty()){\n        PMA *t = Q.front(); Q.pop();\n        for(int i = 1 ; i < 256 ; i++){\n            if(t->next[i]){\n                PMA *next = t->next[0];\n                while(!next->next[i]) next = next->next[0];\n                t->next[i]->next[0] = next->next[i];\n                t->next[i]->matched =\n                    set_union(t->next[i]->matched,next->next[i]->matched);\n                Q.push(t->next[i]);\n            }\n        }\n    }\n    return root;\n}\n\nvoid match(PMA *pma,const char *s,Vec &res){\n    for(int i = 0 ; s[i] != '\\0' ; i++){\n        int c = s[i];\n        while(!pma->next[c]) pma = pma->next[0];\n        pma = pma->next[c];\n        for(int j = 0 ; j < (int)pma->matched.size() ; j++){\n            res[pma->matched[j]] = 1;\n        }\n    }\n}\n\nchar T[1000001];\nchar P[10000][1001];\n\nint main(){\n    int Q;\n    scanf(\"%s%d\",T,&Q);\n    for(int i = 0 ; i < Q ; i++){\n        scanf(\"%s\",P[i]);\n    }\n    PMA *pma = buildPMA(P,Q);\n    Vec res(Q, 0);\n    match(pma,T,res);\n    for(auto x : res){\n        printf(\"%d\\n\",x);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    sa.clear();\n    lcp.clear();\n    n=S.size();\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    vector<int> r(n+1,0),t(n+1,0);\n    auto compare_sa=[&](const int &i, const int &j){\n      if(r[i]!=r[j]) return r[i]<r[j];\n      else{\n\tint ri=i+k<=n?r[i+k]:-1;\n\tint rj=j+k<=n?r[j+k]:-1;\n\treturn ri<rj;\n      }\n    };\n    \n    n=S.length();\n    for(int i=0;i<=n;i++){\n      sa[i]=i;\n      r[i]=i<n?S[i]:-1;\n    }\n    \n    for(k=1;k<=n;k*=2){\n      sort(sa.begin(),sa.end(),compare_sa);\n      t[sa[0]]=0;\n      for(int i=1;i<=n;i++){\n\tt[sa[i]]=t[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n      }\n      for(int i=0;i<=n;i++){\n\tr[i]=t[i];\n      }\n    }\n  }\n  bool contains(string T){\n    int a=0,b=S.length()+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==(int)S.length()+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n+1);\n    for(int i=0;i<=n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/06/22\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n\n\nusing namespace std;\n\nstring t;\nint q,n,size;\nbool flag;\n\nint main()\n{\n\tcin >> t >> q;\n\t\n\tfor(int i = 0;i < q ;i++)\n\t{\n\t\tstring p;\n\t\tcin >> p;\n\t\tsize = p.size();\n\t\t\n\t\tfor(int j = 0;j < t.size();j++)\n\t\t{\n\t\t\tflag = false;\n\t\t\tif(t[j] == p[0])\n\t\t\t{\n\t\t\t\tif(size == 1) \n\t\t\t\t{\n\t\t\t\t\tcout << 1 << endl;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\tfor(int k = 1;k < size;k++)\n\t\t\t\t{\n\t\t\t\t\tif(t[j+k] != p[k]) break;\n\t\t\t\t\tif(k == size -1) \n\t\t\t\t\t{\n\t\t\t\t\t\tcout << 1 << endl;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tif(flag) break;\n\t\t}\n\tif(!flag) cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nstruct SuffixArray\n{\n    int sz;\n    string s;\n    vector<int> rank,sa;\n    // vector<int> lcp,lcp_rank;\n\n    SuffixArray(string str){\n        s=str;\n        sz=str.length();\n        rank.resize(sz+1);\n        sa.resize(sz+1);\n        // lcp.resize(sz+1);\n        // lcp_rank.resize(sz+1);\n        build();\n        // build_lcp();\n    }\n\n    void build(){\n        for(int i=0;i<=sz;i++){\n            sa[i] = i;\n            rank[i] = i < sz ? s[i] : -1;\n        }\n\n        int k;\n        auto compare = [&](int i, int j) {\n            if (rank[i] != rank[j]) return rank[i] < rank[j];\n            else {\n                int ri = i + k <= sz ? rank[i + k] : -1;\n                int rj = j + k <= sz ? rank[j + k] : -1;\n                return ri < rj;\n            }\n        };\n\n        vector<int> tmp(sz+1);\n        for(k=1;k<=sz;k*=2){\n            sort(sa.begin(),sa.end(),compare);\n            tmp[sa[0]] = 0;\n            for(int i=1;i<=sz;i++){\n                tmp[sa[i]] = tmp[sa[i-1]] + (compare(sa[i-1],sa[i]) ? 1 : 0);\n            }\n            for(int i=0;i<=sz;i++){\n                rank[i] = tmp[i];\n            }\n        }\n    }\n    // s縺荊繧貞性繧?縺?\n    bool contains(string t){\n        int l=0,r=sz;\n        while(r-l>1){\n            int mid=(l+r)/2;\n            if(s.substr(sa[mid],t.length())<t) l=mid;\n            else r=mid;\n        }\n        return s.substr(sa[r],t.size()) ==t;\n    }\n    /*\n    void build_lcp(){\n        for(int i=0;i<=sz;i++) lcp_rank[sa[i]]=i;\n        int h=0;\n        lcp[0]=0;\n        for(int i=0;i<sz;i++){\n            int j=sa[rank[i]-1];\n\n            if(h>0) h--;\n            for(;j+h<sz && i+h<sz;h++){\n                if(s[j+h] != s[i+h]) break;\n            }\n            lcp[rank[i]-1]=h;\n        }\n    }\n    */\n};\n\nint main(){\n    string s;\n    cin>>s;\n    int n;\n    cin>>n;\n    SuffixArray sa(s);\n    for(int i=0;i<n;++i){\n        string sc;\n        cin>>sc;\n        if(sa.contains(sc))cout<<\"1\"<<endl;\n        else cout<<\"0\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <unordered_map>\n#include <vector>\n#include <string.h>\n#include <set>\n\nusing namespace std;\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> void printvec(const vector<T>& v) {\n  for (auto x : v) { cout << x << \" \"; }\n  cout << endl;\n}\ntemplate<class T> void printtree(const vector< vector<T> >& tree) {\n  for (long long i = 0; i < tree.size(); ++i) {\n    cout << i + 1 << \": \"; printvec(tree[i]);\n  }\n}\ntemplate<class T, class U> void printmap(const map<T, U>& mp) {\n  for (auto x : mp) { cout << x.first << \"=>\" << x.second << endl; }\n}\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define all(s) s.begin(), s.end()\n#define sz(x) (ll)(x).size()\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> triple;\ntypedef double D;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n\nconst ll INF = 1e9;\nconst ll MOD = 1000000007;  // 1e9 + 7\n\n// SuffixArray\nstruct SuffixArray {\n  vector< int > SA;\n  const string s;\n\n  SuffixArray(const string &str) : s(str) {\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](int a, int b) {\n      return s[a] == s[b] ? a > b : s[a] < s[b];\n    });\n    vector< int > classes(s.size()), c(s.begin(), s.end()), cnt(s.size());\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const {\n    return SA[k];\n  }\n\n  size_t size() const {\n    return s.size();\n  }\n\n  bool lt_substr(const string &t, int si = 0, int ti = 0) {\n    int sn = (int) s.size(), tn = (int) t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return true;\n      if(s[si] > t[ti]) return false;\n      ++si, ++ti;\n    }\n    return si >= sn && ti < tn;\n  }\n\n  int lower_bound(const string &t) {\n    int low = -1, high = (int) SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) / 2;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return high;\n  }\n\n  pair< int, int > lower_upper_bound(string &t) {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = (int) SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) / 2;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return {idx, high};\n  }\n\n  void output() {\n    for(int i = 0; i < size(); i++) {\n      cout << i << \": \" << s.substr(SA[i]) << endl;\n    }\n  }\n};\n\nstruct LongestCommonPrefixArray {\n  const SuffixArray &SA;\n  vector< int > LCP, rank;\n\n  LongestCommonPrefixArray(const SuffixArray &SA) : SA(SA), LCP(SA.size()) {\n    rank.resize(SA.size());\n    for(int i = 0; i < SA.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    for(int i = 0, h = 0; i < SA.size(); i++) {\n      if(rank[i] + 1 < SA.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < SA.size() && SA.s[i + h] == SA.s[j + h]; ++h);\n        LCP[rank[i] + 1] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const {\n    return LCP[k];\n  }\n\n  size_t size() const {\n    return LCP.size();\n  }\n\n  void output() {\n    for(int i = 0; i < size(); i++) {\n      cout << i << \": \" << LCP[i] << \" \" << SA.s.substr(SA[i]) << endl;\n    }\n  }\n};\n\nint main(int argc, char** argv) {\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ios_base::sync_with_stdio(false);\n  //cout << setprecision(10) << fixed;\n\n  string s;\n  cin >> s;\n  SuffixArray sa(s);\n  ll q;\n  cin >> q;\n  while(q--) {\n    string t;\n    cin >> t;\n    pair<int,int> p = sa.lower_upper_bound(t);\n    if (p.first != p.second) { // found\n      cout << 1 << endl;\n    } else {\n      cout << 0 << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n//construct SA by SA-IS O(N)\n#include<string>\n#include<vector>\nstruct SA{\n\tstring s;\n\tvector<int>sa;\n\tSA(const string&s_):s(s_)\n\t{\n\t\tsa=build(vector<int>(s.begin(),s.end()),256);\n\t}\n\tvector<int>induced_sort(const vector<int>&S,const vector<int>&id,const vector<bool>&SL,vector<int>last)\n\t{\n\t\tvector<int>first(last);\n\t\tvector<int>ret(id.size());\n\t\tret[0]=id[0];\n\t\tfor(int i=0;i<id.size();i++)\n\t\t{\n\t\t\tif(id[i]>=1&&!SL[id[i]-1])\n\t\t\t{\n\t\t\t\tret[first[S[id[i]-1]-1]++]=id[i]-1;\n\t\t\t}\n\t\t\telse if(ret[i]>=1&&!SL[ret[i]-1])\n\t\t\t{\n\t\t\t\tret[first[S[ret[i]-1]-1]++]=ret[i]-1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=id.size();i--;)\n\t\t{\n\t\t\tif(ret[i]>=1&&SL[ret[i]-1])\n\t\t\t{\n\t\t\t\tret[--last[S[ret[i]-1]]]=ret[i]-1;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tvector<int>build(vector<int>S,int maxval)\n\t{\n\t\tif(S.size()==1)\n\t\t{\n\t\t\treturn(vector<int>){1,0};\n\t\t}\n\t\tS.push_back(0);\n\t\tvector<int>cnt(maxval,0);\n\t\tvector<bool>SL(S.size());//S=>true,L=>false\n\t\tfor(int i=S.size();i--;)\n\t\t{\n\t\t\tcnt[S[i]]+=1;\n\t\t\tSL[i]=i+1==S.size()||S[i]<S[i+1]||S[i]==S[i+1]&&SL[i+1];\n\t\t}\n\t\tfor(int i=1;i<maxval;i++)cnt[i]+=cnt[i-1];\n\t\tvector<int>last(cnt);\n\t\tvector<int>id(S.size());\n\t\tvector<int>is_LMS(S.size());\n\t\tint LMScnt=0;\n\t\tfor(int i=1;i<S.size();i++)\n\t\t{\n\t\t\tif(!SL[i-1]&&SL[i])\n\t\t\t{\n\t\t\t\tis_LMS[i]=1;\n\t\t\t\tid[--cnt[S[i]]]=i;\n\t\t\t\tLMScnt+=1;\n\t\t\t}\n\t\t}\n\t\tid=induced_sort(S,id,SL,last);\n\t\tint LMSsub=1;\n\t\tint pre=-1;\n\t\tis_LMS[id[0]]=LMSsub++;\n\t\tfor(int i=1;i<id.size();i++)\n\t\t{\n\t\t\tif(is_LMS[id[i]])\n\t\t\t{\n\t\t\t\tif(pre>=0&&S[pre]==S[id[i]])\n\t\t\t\t{\n\t\t\t\t\tint k;\n\t\t\t\t\tfor(k=1;S[pre+k]==S[id[i]+k]&&!is_LMS[pre+k]&&!is_LMS[id[i]+k];k++);\n\t\t\t\t\tLMSsub-=S[pre+k]==S[id[i]+k]&&is_LMS[pre+k]&&is_LMS[id[i]+k];\n\t\t\t\t}\n\t\t\t\tpre=id[i];\n\t\t\t\tis_LMS[id[i]]=LMSsub++;\n\t\t\t}\n\t\t}\n\t\tvector<int>newstr(LMScnt);\n\t\tvector<int>rev(LMScnt);\n\t\tint counter=0;\n\t\tfor(int i=0;i<S.size();i++)\n\t\t{\n\t\t\tif(is_LMS[i])\n\t\t\t{\n\t\t\t\tnewstr[counter]=is_LMS[i];\n\t\t\t\trev[counter]=i;\n\t\t\t\tcounter+=1;\n\t\t\t}\n\t\t}\n\t\tvector<int>sortedLMS=build(newstr,LMSsub);\n\t\tid.assign(S.size(),0);\n\t\tfor(int i=1;i<sortedLMS.size();i++)\n\t\t{\n\t\t\tint I=rev[sortedLMS[i]];\n\t\t\tid[cnt[S[I]]++]=I;\n\t\t}\n\t\treturn induced_sort(S,id,SL,last);\n\t}\n\tint operator[](int i){return sa[i];}\n\tint lower_bound(const string&t)\n\t{\n\t\tint L=-1,R=sa.size();\n\t\twhile(R-L>1)\n\t\t{\n\t\t\tint M=L+R>>1;\n\t\t\tif(s.compare(sa[M],t.size(),t)>=0)R=M;\n\t\t\telse L=M;\n\t\t}\n\t\treturn R;\n\t}\n\tint upper_bound(const string&t)\n\t{\n\t\tint L=-1,R=sa.size();\n\t\twhile(R-L>1)\n\t\t{\n\t\t\tint M=L+R>>1;\n\t\t\tif(s.compare(sa[M],t.size(),t)<=0)L=M;\n\t\t\telse R=M;\n\t\t}\n\t\treturn R;\n\t}\n\tbool contain(const string&t)\n\t{\n\t\tint id=lower_bound(t);\n\t\treturn id<sa.size()&&s.compare(sa[id],t.size(),t)==0;\n\t}\n\tint size(){return sa.size();}\n};\nmain()\n{\n\tstring T;\n\tcin>>T;\n\tSA X(T);\n\tint Q;cin>>Q;\n\tfor(;Q--;)\n\t{\n\t\tstring s;cin>>s;\n\t\tcout<<X.contain(s)<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n \n#define REP(i,n) for(int i=0;i<n;i++)\n \nusing namespace std;\n \nint n, k;\nstring s;\nvector<int> order;\nvector<int> tmp;\nvector<int> sa;\n \nbool compare_sa(const int &i, const int &j)\n{\n  if(order[i] != order[j]) return order[i] < order[j];\n  else\n  {\n    int ri = i + k <= n ? order[i+k] : -1;\n    int rj = j + k <= n ? order[j+k] : -1;\n    return ri < rj;\n  }\n}\n \nvoid construct_sa()\n{\n  for(int i = 0; i <= n; i++)\n  {\n    sa[i] = i;\n    order[i] = i < n ? s[i] : -1;\n  }\n  for(k = 1; k <= n; k*=2)\n  {\n    sort(sa.begin(),sa.end(),compare_sa);\n    tmp[sa[0]] = 0;\n    for(int i = 1; i <= n; i++)\n      tmp[sa[i]] = tmp[sa[i-1]] + (compare_sa(sa[i-1],sa[i])?1:0);\n    for(int i = 0; i <= n; i++)\n      order[i] = tmp[i];\n  }\n}\n \nvoid init()\n{\n  n = s.size();\n  order.resize(n+1);\n  tmp.resize(n+1);\n  sa.resize(n+1);\n  construct_sa();\n}\n \nbool contain(string t)\n{\n  int l=0, r=n;\n  while(r-l>1)\n  {\n    int m = (l+r)/2;\n    if(s.compare(sa[m],t.size(),t)<0) l = m;\n    else r = m;\n  }\n  return s.compare(sa[r],t.size(),t) == 0;\n}\n \nint main()\n{\n  cin >> s;\n  string t;\n  int q; cin >> q;\n  init();\n  construct_sa();\n  REP(i,q)\n  {\n     cin >> t;\n     cout << contain(t) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nclass SuffixArray{\n\tprivate:\n\t\tint n;\n\t\tvector<int> rank;\n\tpublic:\n\t\tstring s;\n\t\tvector<int> idx;\n\t\tSuffixArray(string& s) : n(s.size()), rank(s.size() + 1), s(s), idx(s.size() + 1) {\n\t\t\trep(i,n + 1){\n\t\t\t\tidx[i] = i;\n\t\t\t\trank[i] = i < n ? s[i] : -1;\n\t\t\t}\n\n\t\t\tint k;\n\t\t\tauto comp = [&](const int i, const int j) -> bool {\n\t\t\t\tif(rank[i] != rank[j]) return rank[i] < rank[j];\n\t\t\t\telse{\n\t\t\t\t\tint ri = i + k <= n ? rank[i + k] : -1;\n\t\t\t\t\tint rj = j + k <= n ? rank[j + k] : -1;\n\t\t\t\t\treturn ri < rj;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvector<int> tmp(n + 1);\n\t\t\tfor (k = 1; k <= n; k*=2) {\n\t\t\t\tsort(all(idx), comp);\n\n\t\t\t\ttmp[idx[0]] = 0;\n\t\t\t\trange(i,1,n + 1){\n\t\t\t\t\ttmp[idx[i]] = tmp[idx[i - 1]] + (comp(idx[i - 1], idx[i]) ? 1 : 0);\n\t\t\t\t}\n\t\t\t\trank = tmp;\n\t\t\t}\n\t\t}\n\t\tbool contain(string& t){\n\t\t\tint right = n, left = 0;\n\t\t\twhile(right - left > 1){\n\t\t\t\tint mid = (right + left) / 2;\n\t\t\t\tif(s.substr(idx[mid], t.size()) < t) left = mid;\n\t\t\t\telse right = mid;\n\t\t\t}\n\t\t\treturn s.substr(idx[right], t.size()) == t;\n\t\t}\n};\n\nint main(){\n\tstring s;\n\tint n;\n\tcin >> s >> n;\n\n\tSuffixArray suf(s);\n\trep(i,n){\n\t\tstring a;\n\t\tcin >> a;\n\t\tcout << suf.contain(a) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rank Rank\n\nusing namespace std;\n\nconst int N=1e6+10;\n\nint n,k;\nint sa[N];\nint rank[N];\nint tmp[N];\n\nstring S,T;\n\nbool cmp(int i,int j)\n{\n    if(rank[i]!=rank[j]) return rank[i]<rank[j];\n    else\n    {\n        int ri=i+k<=n?rank[i+k]:-1;\n        int rj=j+k<=n?rank[j+k]:-1;\n        return ri<rj;\n    }\n}\n\nvoid getSa()\n{\n    n=S.length();\n\n    for(int i=0;i<=n;i++)\n    {\n        sa[i]=i;\n        rank[i]=i<n?S[i]:-1;\n    }\n\n    for(k=1;k<=n;k<<=1)\n    {\n        sort(sa,sa+n+1,cmp);\n\n        tmp[sa[0]]=0;\n        for(int i=1;i<=n;i++)\n        {\n            tmp[sa[i]]=tmp[sa[i-1]]+(cmp(sa[i-1],sa[i])?1:0);\n        }\n        for(int i=0;i<=n;i++) rank[i]=tmp[i];\n    }\n}\n\nbool contain()\n{\n    int l=0,r=S.length();\n    while(r-l>1)\n    {\n        int mid=(l+r)>>1;\n        if(S.compare(sa[mid],T.length(),T)<0) l=mid;\n        else r=mid;\n    }\n    return S.compare(sa[r],T.length(),T)==0;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin>>S;\n\n    int number;\n\n    cin>>number;\n\n    getSa();\n\n    while(number--)\n    {\n        cin>>T;\n        cout<<contain()<<endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    //const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    //const int k=lcp2(i,j,0,(n-max(i,j))*2+1);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  inline bool cmp(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    //int l=0,r=min(n-i,n-j)+1;\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n  \n  /*\n  inline int lcp2(const int& i, const int& j, const int& l, const int& r){\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n  */\n};\n\nvoid quicksort(vector<int> &a, const int& l, const int& r, const RollingHash &rh) {\n  if (rh.cmp(a[l],a[r])) {\n    int p = a[(l+r)/2];\n    int i = l-1, j = r+1;\n    while (1) {\n      while (a[++i] < p);\n      while (a[--j] > p);\n      if (i >= j) break;\n      swap(a[i], a[j]);\n    }\n    quicksort(a, l, i-1,rh);\n    quicksort(a, j+1, r,rh);\n  }\n}\nvoid quicksort(vector<int> &a, const RollingHash& rh) {\n  quicksort(a, 0, a.size()-1,rh);\n}\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  int n = a.size();\n  if (n > 1) {\n    vector<int> b(a.begin(), a.begin() + n/2);\n    vector<int> c(a.begin() + n/2, a.end());\n    mergesort(b,rh);\n    mergesort(c,rh);\n    for (int i = 0, j = 0, k = 0; i < n; ++i)\n      if (k == c.size())      a[i] = b[j++];\n      else if (j == b.size()) a[i] = c[k++];\n      else if (rh.cmp(b[j],c[k]))   a[i] = b[j++];\n      else                    a[i] = c[k++];\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  //sort(ALL(sa),rh);\n  //quicksort(sa,rh);\n  mergesort(sa,rh);\nif(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nclass suffix_array{\n    void create_begin_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        int sum=0;\n        for(int i=0;i<bucket.size();i++){bucket[i]+=sum;swap(sum,bucket[i]);}\n    }\n\n    void create_end_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        for(int i=1;i<bucket.size();i++)bucket[i]+=bucket[i-1];\n    }\n\n    void induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_begin_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(sa[i]>0&&is_l[sa[i]-1])sa[bucket[v[sa[i]-1]]++]=sa[i]-1;\n    }\n\n    void invert_induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_end_bucket(v,bucket);\n        for(int i=v.size()-1;i>=0;i--)if(sa[i]>0&&!is_l[sa[i]-1])sa[--bucket[v[sa[i]-1]]]=sa[i]-1;\n    }\n\n    vector<int>sa_is(vector<int>v,int mv){\n        if(v.size()==1)return vector<int>(1,0);\n\n        vector<int>is_l(v.size());\n        vector<int>bucket(mv+1);\n        vector<int>sa(v.size(),-1);\n        auto is_lms=[&](int x)->bool{return x>0&&is_l[x-1]&&!is_l[x];};\n\n        is_l[v.size()-1]=0;\n        for(int i=v.size()-2;i>=0;i--)is_l[i]=v[i]>v[i+1]||(v[i]==v[i+1]&&is_l[i+1]);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(is_lms(i))sa[--bucket[v[i]]]=i;\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n\n        int cur=0;\n        vector<int>order(v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))order[i]=cur++;\n\n        vector<int>next_v(cur);\n        cur=-1;\n        int prev=-1;\n        for(int i=0;i<v.size();i++){\n            if(!is_lms(sa[i]))continue;\n            bool diff=false;\n            for(int d=0;d<v.size();d++){\n                if(prev==-1||v[sa[i]+d]!=v[prev+d]||is_l[sa[i]+d]!=is_l[prev+d]){\n                    diff=true;\n                    break;\n                }\n                else if(d>0&&is_lms(sa[i]+d))break;\n            }\n            if(diff){cur++;prev=sa[i];}\n            next_v[order[sa[i]]]=cur;\n        }\n\n        vector<int>re_order(next_v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))re_order[order[i]]=i;\n        vector<int>next_sa=sa_is(next_v,cur);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<sa.size();i++)sa[i]=-1;\n        for(int i=next_sa.size()-1;i>=0;i--)sa[--bucket[v[re_order[next_sa[i]]]]]=re_order[next_sa[i]];\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n        return sa;\n    }\n\n    vector<int>sa_is(string &s){\n        vector<int>v(s.size()+1);\n        for(int i=0;i<s.size();i++)v[i]=s[i];\n        sa=sa_is(v,*max_element(v.begin(),v.end()));\n    }\n\n    void construct_lcp(){\n        lcp.resize(s.size());\n        rank.resize(s.size()+1);\n        int n=s.size();\n        for(int i=0;i<=n;i++)rank[sa[i]]=i;\n        int h=0;\n        lcp[0]=0;\n        for(int i=0;i<n;i++){\n            int j=sa[rank[i]-1];\n\n            if(h>0)h--;\n            for(;j+h<n&&i+h<n;h++){\n                if(s[j+h]!=s[i+h])break;\n            }\n            lcp[rank[i]-1]=h;\n        }\n    }\n\n    class sparse_table{\n        vector<vector<int> >st;\n    public:\n        void init(vector<int>&v){\n            int b;\n            for(b=0;(1<<b)<=v.size();b++);\n            st.assign(b,vector<int>(1<<b));\n            for(int i=0;i<v.size();i++)st[0][i]=v[i];\n            return;\n            for(int i=1;i<b;i++){\n                for(int j=0;j+(1<<i)<=(1<<b);j++){\n                    st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);\n                }\n            }\n        }\n        int get_min(int l,int r){\n            assert(l<r);\n            int b=32-__builtin_clz(r-l)-1;\n            return min(st[b][l],st[b][r-(1<<b)]);\n        }\n        sparse_table(){}\n        sparse_table(vector<int>&v){init(v);}\n    };\n    sparse_table st;\npublic:\n    string s;\n    vector<int>sa,lcp,rank;\n    void init(string &t){\n        s=t;\n        sa_is(s);\n        construct_lcp();\n        st.init(lcp);\n    }\n    suffix_array(string &t){init(t);}\n    suffix_array(){}\n\n    bool contain(string &t){\n        int lb=0,ub=s.size();\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            if(s.compare(sa[mid],t.size(),t)<0)lb=mid;\n            else ub=mid;\n        }\n        return s.compare(sa[ub],t.size(),t)==0;\n    }\n\n    int get_lcp(int i,int j){\n        if(rank[i]>rank[j])swap(i,j);\n        return st.get_min(rank[i],rank[j]);\n    }\n};\n\nsigned main(){\n    string s;cin>>s;\n    suffix_array sa(s);\n    int q;cin>>q;\n    while(q--){\n        string t;\n        cin>>t;\n        cout<<sa.contain(t)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nstruct node{\n\tint fail;\n\tbool vis;\n\tunordered_map<char,int> nxt;\n};\n\nvector<node> trie;\n\nstring input(){\n\tstatic char buf[1000010];\n\tbuf[0] = 0;\n\tscanf(\"%s\", buf);\n\treturn buf;\n}\n\nint main(){\n\ttrie.reserve(1000010);\n\n\ttrie.emplace_back();\n\ttrie[0].fail = -1;\n\n\tstring t = input();\n\tint q;\n\tscanf(\"%d\", &q);\n\tvector<int> idx(q);\n\tfor(int i = 0; i < q; ++i){\n\t\tstring p = input();\n\t\tint u = 0;\n\t\tfor(char c : p){\n\t\t\tif(!trie[u].nxt.count(c)){\n\t\t\t\ttrie[u].nxt.emplace(c, trie.size());\n\t\t\t\ttrie.emplace_back();\n\t\t\t}\n\t\t\tu = trie[u].nxt[c];\n\t\t}\n\t\tidx[i] = u;\n\t}\n\n\tvector<int> bfs;\n\tbfs.push_back(0);\n\tint k = 0;\n\twhile(k < (int)bfs.size()){\n\t\tint u = bfs[k++];\n\t\tfor(const auto &pr : trie[u].nxt){\n\t\t\tchar c = pr.first;\n\t\t\tint v = pr.second;\n\t\t\tbfs.push_back(v);\n\n\t\t\tint f = trie[u].fail;\n\t\t\twhile(f >= 0 && !trie[f].nxt.count(c)){\n\t\t\t\tf = trie[f].fail;\n\t\t\t}\n\t\t\ttrie[v].fail = f >= 0 ? trie[f].nxt[c] : 0;\n\t\t}\n\t}\n\n\tint r = 0;\n\tfor(char c : t){\n\t\twhile(r >= 0 && !trie[r].nxt.count(c)){\n\t\t\tr = trie[r].fail;\n\t\t}\n\t\tr = r >= 0 ? trie[r].nxt[c] : 0;\n\t\ttrie[r].vis = true;\n\t}\n\n\tfor(int i = bfs.size(); --i; ){\n\t\tint u = bfs[i];\n\t\tif(trie[u].vis){\n\t\t\ttrie[trie[u].fail].vis = true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < q; ++i){\n\t\tprintf(\"%d\\n\", +trie[idx[i]].vis);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nstatic const int NUM_CHILDREN = 0x100;\nstatic const char MIN_CHAR = 'a';\n\nclass Trie {\npublic:\n    vector<int> nums;\n    bool visited;\n    Trie *next[NUM_CHILDREN];\n    Trie() : visited(false) {\n        fill(next, next + NUM_CHILDREN, (Trie*)0);\n    }\n};\n\nvoid construct(Trie *trie, const vector<string> &strings) {\n    rep(i, strings.size()) {\n        Trie *p = trie;\n        for (auto c : strings[i]) {\n            if (!p->next[c]) p->next[c] = new Trie;\n            p = p->next[c];\n        }\n        p->nums.emplace_back(i);\n    }\n}\n\nvoid dump(Trie* p, string s) {\n    if (!p->nums.empty()) {\n        cerr << \"s = \" << s << \", nums = {\";\n        for (auto num : p->nums) {\n            cerr << num << \", \";\n        }\n        cerr << endl;\n    }\n    for (int i = 0; i < NUM_CHILDREN; ++i) {\n        if (p->next[i]) {\n            dump(p->next[i], s + char(i));\n        }\n    }\n}\n\nvoid search(Trie* trie, const string &s, vector<bool> &exist) {\n    // cerr << \"s = \" << s << endl;\n    Trie *p = trie;\n    for (auto c : s) {\n        if (!p->next[c]) return;\n        p = p->next[c];\n        // cerr << \"c = \" << c << endl;\n        if (!p->visited && !p->nums.empty()) {\n            // cerr << \"s = \" << s << \", c = \" << c << endl;\n            p->visited = true;\n            for (auto num : p->nums) {\n                exist[num] = true;\n            }\n        }\n    }\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    string s;\n    cin >> s;\n    int q;\n    cin >> q;\n    vector<string> strings(q);\n    rep(i, q) cin >> strings[i];\n\n    Trie *trie = new Trie;\n\n    construct(trie, strings);\n\n    // dump(trie, \"\");\n\n    vector<bool> exist(q);\n\n    rep(i, s.size()) {\n        search(trie, s.substr(i), exist);\n    }\n\n    rep(i, q) {\n        cout << exist[i] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n　　　  ∧＿∧　やあ\n　　 （´・ω・｀)　　　　　/　　　　　ようこそ、バーボンハウスへ。\n　　 ／∇y:::::＼　　　 [￣]　　　　　このテキーラはサービスだから、まず飲んで落ち着いて欲しい。\n　　 |:⊃:|:::::|　　　|──|\n￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣|　うん、「また」なんだ。済まない。\n￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣|￣　  仏の顔もって言うしね、謝って許してもらおうとも思っていない。\n￣￣￣￣￣￣￣￣￣￣￣￣￣￣／|\n　　　　∇　∇　∇　∇　　　／.／|　　　でも、この提出を見たとき、君は、きっと言葉では言い表せない\n　　　　┴　┴　┴　┴　／ ／　  |　　　「ときめき」みたいなものを感じてくれたと思う。\n￣￣￣￣￣￣￣￣￣￣|／　　  |　　　殺伐としたコンテストの中で、そういう気持ちを忘れないで欲しい\n￣￣￣￣￣￣￣￣￣￣　　　　 |　　　そう思って、この提出を投げたんだ。\n　　　(⊆⊇)　(⊆⊇)　(⊆⊇)　　|\n　    ||　　 ||　　||　　|　　　 じゃあ、判定を聞こうか。\n　　.／|＼　／|＼ ／|＼\n*/\n\n#include <iostream>\n#include <cstdlib>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n#define fst first\n#define snd second\n#define mp make_pair\n#define ALL(obj) (obj).begin(),(obj).end()\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n) \n#define SIZE(x) ((int)(x).size())\n#define debug(x) cerr << #x << \" -> \" << x << \" (line:\" << __LINE__ << \")\" << '\\n';\n#define debugpair(x, y) cerr << \"(\" << #x << \", \" << #y << \") -> (\" << x << \", \" << y << \") (line:\" << __LINE__ << \")\" << '\\n';\ntypedef long long lint;\ntypedef pair<int, int> pint;\ntypedef pair<lint, lint> plint;\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> matrix;\ntypedef priority_queue<lint> p_que;\ntypedef priority_queue<lint, vector<lint>, greater<lint>> p_que_rev;\nconst lint INF = INT_MAX;\nconst lint LINF = LLONG_MAX;\nconst lint MOD = 1000000000 + 7;\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\nconst int di[]{0, -1, 0, 1, -1, -1, 1, 1};\nconst int dj[]{1, 0, -1, 0, 1, -1, -1, 1};\n\nlint gcd(lint a, lint b) {\n    lint r;\n    while (b != 0) {\n        r = a % b;\n        a = b; \n        b = r;\n    }\n    return a;\n}\n\nlint lcm(lint a, lint b) {\n    return (a / gcd(a, b)) * b;\n}\n\nlint power(lint x, lint n, lint mod = MOD) {\n    lint ret = 1;\n    while(n > 0) {\n        if(n & 1){\n            (ret *= x) %= mod;\n        }\n        (x *= x) %= mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\nvector<lint> make_power(int n, lint base){\n    lint num = 1;\n    vector<lint> ret;\n    for (int i=0; i<=n; ++i){\n        ret.push_back(num);\n        num *= base;\n    }\n    return ret;\n}\n\nstruct SuffixArray {\n    const string s;\n    vector<int> SuffixArr;\n    vector<int> lcp;\n\n    SuffixArray(const string str) : s(str){\n        construct_suffix_array();\n        construct_lcp();\n    }\n\n    // Suffix Array の構築\n    void construct_suffix_array(){\n        const int len = s.length();\n        vector<int> tmp(len, 0);\n        vector<int> rank(len, 0);\n        int k;\n\n        SuffixArr.resize(len);\n        rank.resize(len);\n\n        for (int i = 0; i < len; ++i){\n            SuffixArr[i] = i;\n            rank[i] = s[i];\n        }\n\n        // ソート比較用関数 ([&] は変数の参照キャプチャ)\n        auto compare_sa = [&](int i, int j){\n            if(rank[i] != rank[j]){\n                return rank[i] < rank[j];\n            }\n            int ri = (i + k < len) ? rank[i + k] : -1;\n            int rj = (j + k < len) ? rank[j + k] : -1;\n            return ri < rj;\n        };\n\n        for (k = 1; k <= len; k *= 2){\n            sort(SuffixArr.begin(), SuffixArr.end(), compare_sa);\n            tmp[SuffixArr[0]] = 0;\n            for (int i = 1; i < len; ++i){\n                int c = compare_sa(SuffixArr[i - 1], SuffixArr[i]) ? 1 : 0;\n                tmp[SuffixArr[i]] = tmp[SuffixArr[i - 1]] + c;\n            }\n            for(int i = 0; i < len; ++i){\n                rank[i] = tmp[i];\n            }\n        }\n    }\n\n    // 高さ配列の構築\n    void construct_lcp(){\n        int l = s.length();\n        vector<int> rank(l);\n        lcp.resize(l);\n        for (int i = 0; i < l; ++i){\n            rank[SuffixArr[i]] = i;\n            lcp[i] = 0;\n        }\n        for(int i = 0, h = 0; i < l; i++) {\n            if(rank[i] + 1 < l) {\n                for(int j = SuffixArr[rank[i] + 1]; max(i, j) + h < SuffixArr.size() && s[i + h] == s[j + h]; ++h);\n                lcp[rank[i] + 1] = h;\n                if(h > 0){\n                    --h;\n                }\n            }\n        }\n        return;\n    }\n\n    // S の s_idx 文字目からの文字列と, P の p_idx 文字目からの文字列の比較\n    bool substr_less_than(const string p, int s_idx = 0, int p_idx = 0){\n        int len_s = s.length();\n        int len_p = p.length();\n        while(s_idx < len_s && p_idx < len_p){\n            if(s[s_idx] < p[p_idx]){\n                return true;\n            }\n            else if(s[s_idx] > p[p_idx]){\n                return false;\n            }\n            s_idx++;\n            p_idx++;\n        }\n        return (s_idx >= len_s) && (p_idx < len_p);\n    }\n\n    pair<int, int> lower_upper_bound(string p){\n        int lb, ub;\n        auto binary_search = [&](int lo, int hi){\n            while(hi - lo > 1){\n                int mid = (hi + lo) / 2;\n                if(substr_less_than(p, SuffixArr[mid])){\n                    lo = mid;\n                }\n                else {\n                    hi = mid;\n                }\n            }\n            return hi;\n        };\n        // lower_bound\n        lb = binary_search(-1, s.length());\n        // upper_bound\n        p.back()++;\n        ub = binary_search(lb - 1, s.length());\n        return make_pair(lb, ub);\n    }\n\n    void show_output(){\n        for(int i = 0; i < s.length(); ++i){\n            cout << i << \" : lcp -> \" << lcp[i] << \", suffix -> \" << s.substr(SuffixArr[i]) << endl;\n        }\n    }\n};\n\n// validated from ALDS1_14_D\nvoid solve(){\n    string s;\n    int q;\n    string p;\n    cin >> s;\n    cin >> q;\n    SuffixArray SA(s);\n    int n = SA.SuffixArr.size();\n    REP(loop, q){\n        cin >> p;\n        auto lb_ub = SA.lower_upper_bound(p);\n        cout << (lb_ub.fst != lb_ub.snd) << endl;\n    }\n    return;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\n#define NUM 48\nusing namespace std;\n\nint T_char_count[128] = {0},P_char_count[128];\nint T_Chain[128][128];\n\nclass LocRecord{\n\npublic:\n\t//?????¢???????¢????\n\tLocRecord(){\n\t\tlocationTable = new int**[128];\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tlocationTable[i] = new int*[128];\n\t\t\tfor(int k = 0; k < 128; k++){\n\t\t\t\tif(T_Chain[i][k] > 0){\n\t\t\t\t\tlocationTable[i][k] = new int[T_Chain[i][k]+1];\n\t\t\t\t\tfor(int p = 0; p < T_Chain[i][k]+1; p++){\n\t\t\t\t\t\tlocationTable[i][k][p] = -1;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tlocationTable[i][k] = new int[2];\n\t\t\t\t\tfor(int p = 0; p < 2; p++){\n\t\t\t\t\t\tlocationTable[i][k][p] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinit();\n\t}\n\n\t//-1?????£??\\\n\tvoid init(){\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tfor(int k = 0; k < 128; k++){\n\t\t\t\tindex[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init_index(char first,char second){\n\t\tindex[first][second] = 0;\n\t}\n\n\tvoid regist_loc(char first,char second,int location){\n\t\tlocationTable[first][second][index[first][second]] = location;\n\t\tindex[first][second]++;\n\t}\n\n\tint next_loc(char first,char second){\n\t\tint ret = locationTable[first][second][index[first][second]];\n\t\tindex[first][second]++;\n\t\treturn ret;\n\t}\n\nprivate:\n\tint*** locationTable;\n\tint index[128][128];\n};\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn hashValue < arg.hashValue;\n\t};\n\tInfo(int arg_id,ull arg_hashValue){\n\t\tid = arg_id;\n\t\thashValue = arg_hashValue;\n\t}\n\n\tint id;\n\tull hashValue;\n};\n\nint main(){\n\n\tfor(int i = 0; i < 128; i++){\n\t\tT_char_count[i] = 0;\n\t\tfor(int k = 0; k < 128; k++){\n\t\t\tT_Chain[i][k] = 0;\n\t\t}\n\t}\n\n\tint T_length;\n\n\tchar* T = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tchar pre = T[0];\n\tT_char_count[T[0]]++;\n\n\tfor(T_length = 1; T[T_length] != '\\0';T_length++){\n\t\tT_char_count[T[T_length]]++;\n\t\tT_Chain[pre][T[T_length]]++;\n\t\tpre = T[T_length];\n\t}\n\n\tLocRecord locRecord;\n\tlocRecord.init();\n\n\n\tpre = T[0];\n\t//T[i]????????????i??§???????????¨????¨????\n\tfor(int i = 1; i < T_length; i++){\n\t\tlocRecord.regist_loc(pre,T[i],i-1);\n\t\tpre = T[i];\n\t}\n\n\tull* HASH = new ull[T_length+1];\n\tull* P = new ull[T_length+1];\n\n\tHASH[0] = 0;\n\tP[0] = 1;\n\n\t//T??????????????\\???????±???????\n\tfor(int i = 1; i <= T_length; i++){\n\t\tHASH[i] = T[i-1] + HASH[i-1]*MOD;\n\t\tP[i] = P[i-1]*MOD;\n\t}\n\n\tvector<Info> V[75][75][1001];\n\tvector<int> LENG[75][75];\n\n\tint Q,S_length,left,P_char_count[128];\n\tscanf(\"%d\",&Q);\n\n\tbool check[Q];\n\n\tfor(int i = 0; i < Q; i++)check[i] = false;\n\n\tchar S[1001];\n\tull S_HASH[1001],S_value,T_value,D;\n\tbool FLG,isExist;\n\n\n\t//Q??¶??????????????\\???????¨????\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",S);\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tP_char_count[i] = 0;\n\t\t}\n\n\t\tfor(S_length = 0;S[S_length] != '\\0';S_length++){\n\t\t\tP_char_count[S[S_length]]++;\n\t\t}\n\n\t\tFLG = true;\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tif(T_char_count[i] < P_char_count[i]){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG)continue;\n\n\t\tif(S_length == 1){\n\t\t\tcheck[loop] = true;\n\t\t\tcontinue;\n\t\t}\n\n\n\n\t\tS_HASH[0] = 0;\n\t\tfor(int i = 1; i <= S_length; i++){\n\t\t\tS_HASH[i] = S[i-1] + S_HASH[i-1]*MOD;\n\t\t}\n\n\t\tS_value = S_HASH[S_length];\n\n\t\tV[S[0]-NUM][S[1]-NUM][S_length].push_back(Info(loop,S_value));\n\n\t\t//??????????????????????????????\n\t\tisExist = false;\n\t\tfor(int a = 0; a < LENG[S[0]-NUM][S[1]-NUM].size();a++){\n\t\t\tif(LENG[S[0]-NUM][S[1]-NUM][a] == S_length){\n\t\t\t\tisExist = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!isExist){\n\t\t\t LENG[S[0]-NUM][S[1]-NUM].push_back(S_length);\n\t\t}\n\t}\n\n\t//????????????????????????\n\tfor(int a = 48; a <= 122; a++){\n\t\tfor(int b = 48; b <= 122; b++)sort(LENG[a-NUM][b-NUM].begin(),LENG[a-NUM][b-NUM].end());\n\t}\n\n\t//???????????\\?????????????????????\n\tfor(int a = 48; a <= 122; a++){\n\t\tfor(int b = 48; b <= 122; b++){\n\t\t\tfor(int i = 0; i < LENG[a-NUM][b-NUM].size();i++){\n\t\t\t\tsort(V[a-NUM][b-NUM][LENG[a-NUM][b-NUM][i]].begin(),V[a-NUM][b-NUM][LENG[a-NUM][b-NUM][i]].end());\n\t\t\t}\n\t\t}\n\t}\n\n\tint calc_left,calc_right,calc_m,tmp_len;\n\n\tfor(int first_word = 48; first_word <= 122; first_word++){\n\t\tfor(int second_word = 48; second_word <= 122;second_word++){\n\t\t\tfor(int i = 0; i < LENG[first_word-NUM][second_word-NUM].size();i++){\n\n\t\t\t\tlocRecord.init_index(first_word,second_word);\n\t\t\t\ttmp_len = LENG[first_word-NUM][second_word-NUM][i];\n\n\t\t\t\twhile((left = locRecord.next_loc(first_word,second_word)) != -1){\n\t\t\t\t\tif(left+tmp_len-1 >= T_length)break;\n\n\t\t\t\t\tT_value = HASH[left+tmp_len]-HASH[left]*P[tmp_len];\n\n\t\t\t\t\t//2?????¢?´¢\n\t\t\t\t\tcalc_left = 0;\n\t\t\t\t\tcalc_right = V[first_word-NUM][second_word-NUM][tmp_len].size()-1;\n\t\t\t\t\tcalc_m = (calc_left+calc_right)/2;\n\n\t\t\t\t\twhile(calc_left <= calc_right){\n\t\t\t\t\t\tif(V[first_word-NUM][second_word-NUM][tmp_len][calc_m].hashValue == T_value){\n\t\t\t\t\t\t\tcheck[V[first_word-NUM][second_word-NUM][tmp_len][calc_m].id] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(V[first_word-NUM][second_word-NUM][tmp_len][calc_m].hashValue < T_value){\n\t\t\t\t\t\t\t\tcalc_left = calc_m+1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tcalc_right = calc_m-1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcalc_m = (calc_left+calc_right)/2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tif(check[i])printf(\"1\\n\");\n\t\telse{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n\n#pragma warning(disable: 4996)\n\nusing namespace std;\n\nint Q; char STR1[1000001], STR2[1001];\n\nvector<int> ptr[62];\n\nconst char strings[63] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890\";\n\nint main()\n{\n\tscanf(\"%s\", &STR1);\n\n\tfor (int i = 0; i < strlen(STR1); i++)\n\t{\n\t\tfor (int j = 0; j < 62; j++)\n\t\t{\n\t\t\tif (STR1[i] == strings[j])\n\t\t\t{\n\t\t\t\tptr[j].push_back(i); break;\n\t\t\t}\n\t\t}\n\t}\n\n\tscanf(\"%d\", &Q);\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%s\", STR2);\n\n\t\tint code_;\n\t\tint size_;\n\n\t\tfor (int j = 0; j < 62; j++)\n\t\t{\n\t\t\tif (STR2[0] == strings[j])\n\t\t\t{\n\t\t\t\tsize_ = ptr[j].size();\n\n\t\t\t\tcode_ = j;\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 0; j < size_; j++)\n\t\t{\n\t\t\tint ptr_ = ptr[code_][j];\n\n\t\t\tbool ok = false;\n\n\t\t\tif (ptr[code_][j] + strlen(STR2) <= strlen(STR1))\n\t\t\t{\n\t\t\t\tok = true;\n\n\t\t\t\tfor (int k = 0; k < strlen(STR2); k++)\n\t\t\t\t{\n\t\t\t\t\tif (STR1[ptr_ + k] != STR2[k])\n\t\t\t\t\t{\n\t\t\t\t\t\tok = false; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ok)\n\t\t\t{\n\t\t\t\tprintf(\"1\\n\");\n\n\t\t\t\tgoto Exit;\n\t\t\t}\n\n\t\t\tif (j + 1 >= size_)\n\t\t\t{\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (size_ == 0)\n\t\t{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\n\tExit:;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint n, k;\nstring s;\nvector<int> order;\nvector<int> tmp;\nvector<int> sa;\n\nbool compare_sa(const int &i, const int &j)\n{\n  if(order[i] != order[j]) return order[i] < order[j];\n  else\n  {\n    int ri = i + k <= n ? order[i+k] : -1;\n    int rj = j + k <= n ? order[j+k] : -1;\n    return ri < rj;\n  }\n}\n\nvoid construct_sa()\n{\n  for(int i = 0; i <= n; i++)\n  {\n    sa[i] = i;\n    order[i] = i < n ? s[i] : -1;\n  }\n  for(k = 1; k <= n; k*=2)\n  {\n    sort(sa.begin(),sa.end(),compare_sa);\n    tmp[sa[0]] = 0;\n    for(int i = 1; i <= n; i++)\n      tmp[sa[i]] = tmp[sa[i-1]] + (compare_sa(sa[i-1],sa[i])?1:0);\n    for(int i = 0; i <= n; i++)\n      order[i] = tmp[i];\n  }\n}\n\nvoid init()\n{\n  n = s.size();\n  order.resize(n+1);\n  tmp.resize(n+1);\n  sa.resize(n+1);\n  construct_sa();\n}\n\nbool contain(string t)\n{\n  int l=0, r=n;\n  while(r-l>1)\n  {\n    int m = (l+r)/2;\n    if(s.compare(sa[m],t.size(),t)<0) l = m;\n    else r = m;\n  }\n  return s.compare(sa[r],t.size(),t) == 0;\n}\n\nint main(){\n\n\tcin >> s;\n\tstring t;\n\tint q ; cin >> q;\n\tinit();\n\tconstruct_sa ();\n\tfor (int i = 0; i < q; ++i)\n\t {\n\t \tcin >> t;\n\t \tcout << contain(t) << endl;\n\t } \n\t return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n/2+n%2,b[2*nb],c[2*nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==nc)a[i]=b[j++];\n      else if(j==nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[2*n];\n  REP(i,n)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[2000000];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    S.push_back('$');\n    vector<int> c(n+1,0),ord(n+1,0);\n    for(int i=0;i<=n;i++) ord[i]=n-i;\n    sort(ord.begin(),ord.end(),[&](int a,int b){return S[a]<S[b];});\n    for(int i=0;i<=n;i++){\n      sa[i]=ord[i];\n      c[i]=S[i];\n    }\n    vector<int> r(n+1),cnt(n+1),s(n+1);\n    for(int len=1;len<=n;len*=2){\n      for(int i=0;i<=n;i++){\n\tr[i]=c[i];\n\tcnt[i]=i;\n\ts[i]=sa[i];\n      }\n      for(int i=0;i<=n;i++){\n\t c[sa[i]] =\n\t   i>0&&\n\t   r[sa[i- 1]]==r[sa[i]] &&\n\t   sa[i-1]+len<=n &&\n\t   r[sa[i-1]+len/2]==r[sa[i]+len/2]\n\t   ?c[sa[i - 1]]:i;\n      }\n      for(int i=0;i<=n;i++){\n\tint s1=s[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n+1);\n    for(int i=0;i<=n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n\nusing namespace std;\n\nstring S, T; int Q; char STR[1000005];\n\nint main()\n{\n\tscanf(\"%s%d\", STR, &Q);\n\n\tS = STR;\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%s\", STR);\n\n\t\tT = STR;\n\n\t\tprintf(\"%d\", S.find(STR) != string::npos ? 1 : 0);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\ntemplate<typename T>\nclass PMA {\nprivate:\n    uint32_t id = 0;\n    uint32_t pattern = 0;\n\npublic:\n    struct Node {\n        uint32_t id;\n        vector<uint32_t> accept;\n        unordered_map<T, Node*> children;\n        Node *failure = nullptr;\n    };\n\n    Node *root;\n\n    int32_t insert(const vector<T> &vec) {\n        Node *node = root;\n        for (T v : vec) {\n            auto itr = node->children.find(v);\n            if (itr != node->children.end()) {\n                node = itr->second;\n            } else {\n                node->children[v] = new Node;\n                node->children[v]->id = id++;\n                node = node->children[v];\n            }\n        }\n\n        node->accept.push_back(pattern++);\n\n        return node->id;\n    }\n\n    Node *transition(Node *node, T v) {\n        while (node != nullptr) {\n            auto itr = node->children.find(v);\n            if (itr != node->children.end()) {\n                return itr->second;\n            } else {\n                node = node->failure;\n            }\n        }\n        return root;\n    }\n\n    void link_failure() {\n        queue<Node*> tovisit;\n        tovisit.push(root);\n        while (!tovisit.empty()) {\n            Node *node = tovisit.front();\n            tovisit.pop();\n\n            for (auto p : node->children) {\n                T v = p.first;\n                Node *child = p.second;\n\n                child->failure = transition(node->failure, v);\n                for (uint32_t a : child->failure->accept) child->accept.push_back(a);\n\n                tovisit.push(child);\n            }\n        }\n        return;\n    }\n\n    PMA() {\n        root = new Node;\n        root->id = id++;\n    }\n};\n\nint main() {\n    vector<uint8_t> T;\n    string temp;\n    cin >> temp;\n    T = vector<uint8_t>(temp.begin(), temp.end());\n\n    int32_t Q;\n    cin >> Q;\n\n    vector<vector<uint8_t>> P(Q);\n    for (int32_t i = 0; i < Q; i++) {\n        string temp;\n        cin >> temp;\n        P[i] = vector<uint8_t>(temp.begin(), temp.end());\n    }\n\n    PMA<uint8_t> pma;\n    for (vector<uint8_t> vec : P) pma.insert(vec);\n    pma.link_failure();\n\n    vector<bool> result(Q, false);\n    PMA<uint8_t>::Node *node = pma.root;\n    for (uint8_t c : T) {\n        node = pma.transition(node, c);\n        for (uint32_t a : node->accept) result[a] = true;\n    }\n\n    for (bool b : result) cout << (b ? \"1\" : \"0\") << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 1000005\n\n//Suffix_Array\n//O(|T|log|S|) S??????????????????T????????????????????????????´¢\n#define rank A\nint n,Len;\nint rank[MAX_N+1];\nint tmp[MAX_N+1];\n\n//(rank[i],rank[i+k])??¨(rank[j],rank[j+k])?????????\nbool compare_sa(int i,int j){\n  if(rank[i]!=rank[j])return rank[i]<rank[j];\n  int ri=i+Len<=n?rank[i+Len]:-1;\n  int rj=j+Len<=n?rank[j+Len]:-1;\n  return ri<rj;\n}\n\n//?????????S?????\\?°??????????????§????\nvoid construct_sa(string S,int *sa){\n  n=S.length();\n  //?????????????????????????????????????????????????????????\n  for(int i=0;i<=n;i++){\n    sa[i]=i;\n    rank[i]=i<n?S[i]:-1;\n  }\n  //k????????????????????????????????????????????¨???????????????2k????????§?????????\n  for(Len=1;Len<=n;Len*=2){\n    sort(sa,sa+n+1,compare_sa);\n    //?????£??????tmp????¬?????????????????¨?????????????rank?????£??\\\n    tmp[sa[0]]=0;\n    for(int i=1;i<=n;i++)\n      tmp[sa[i]]=tmp[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n    for(int i=0;i<=n;i++)rank[i]=tmp[i];\n  }\n}\n\n//S??????????????????T????????????????????????????´¢??????\nbool contain(string S,int *sa,string T){\n  int left=0,right=S.length();\n  while(right-left>1){\n    int mid=(left+right)/2;\n    if(S.compare(sa[mid],T.length(),T)<0)left=mid;\n    else right=mid;\n  }\n  return S.compare(sa[right],T.length(),T)==0;\n}\n\nstring t,p;\nint q,sa[MAX_N];\nint main(){\n  cin>>t;\n  construct_sa(t,sa);\n  cin>>q;\n  while(q--){\n    cin>>p;\n    if(contain(t,sa,p))cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint n, k;\nstring s;\nvector<int> order;\nvector<int> tmp;\nvector<int> sa;\n\nbool compare_sa(const int &i, const int &j)\n{\n  if(order[i] != order[j]) return order[i] < order[j];\n  else\n  {\n    int ri = i + k <= n ? order[i+k] : -1;\n    int rj = j + k <= n ? order[j+k] : -1;\n    return ri < rj;\n  }\n}\n\nvoid construct_sa()\n{\n  for(int i = 0; i <= n; i++)\n  {\n    sa[i] = i;\n    order[i] = i < n ? s[i] : -1;\n  }\n  for(k = 1; k <= n; k*=2)\n  {\n    sort(sa.begin(),sa.end(),compare_sa);\n    tmp[sa[0]] = 0;\n    for(int i = 1; i <= n; i++)\n      tmp[sa[i]] = tmp[sa[i-1]] + (compare_sa(sa[i-1],sa[i])?1:0);\n    for(int i = 0; i <= n; i++)\n      order[i] = tmp[i];\n  }\n}\n\nvoid init()\n{\n  n = s.size();\n  order.resize(n+1);\n  tmp.resize(n+1);\n  sa.resize(n+1);\n  construct_sa();\n}\n\nbool contain(string t)\n{\n  int l=0, r=n;\n  while(r-l>1)\n  {\n    int m = (l+r)/2;\n    if(s.compare(sa[m],t.size(),t)<0) l = m;\n    else r = m;\n  }\n  return s.compare(sa[r],t.size(),t) == 0;\n}\n\nint main()\n{\n  cin >> s;\n  string t;\n  int q; cin >> q;\n  init();\n  construct_sa();\n  REP(i,q)\n  {\n     cin >> t;\n     cout << contain(t) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\ntypedef unsigned long long int ull;\n\nclass RollingHash{\npublic:\n  RollingHash(std::string _s):s(_s){};\n  std::vector<int> search(std::string p);\n  \nprivate:\n  ull PatternHash(std::string s);\n  void Hashing(int m);\n  std::string s;\n  std::vector<ull> rh;//???????????\\??????????´??????????vector\n  int length = 0;//?¨???¶???????????????????????\\??????????????????\n};\n\n\nstd::vector<int> RollingHash::search(std::string p){\n  if(p.length() != length){\n    Hashing(p.length());\n    length = p.length();\n  }\n  ull pHash = PatternHash(p);\n  std::vector<int> res;\n  for (int i = 0; i < s.length() - length + 1; i++) {\n    if(pHash == rh[i]){\n      res.push_back(i);\n    }\n  }\n  return res;\n}\n\null RollingHash::PatternHash(std::string s){\n  ull base = 1e9 + 7, res = 0;\n  for (int i = 0; i < s.length(); i++) {\n    res *= base;\n    res += s[i];\n  }\n  return res;\n}\n\nvoid RollingHash::Hashing(int m){\n  rh.clear();\n  int n = s.length();\n  if(n < m)return;\n  rh.resize(n - m + 1, 0);\n  ull base = 1e9 + 7, t = 1;\n  for (int i = m - 1; i >= 0; i--) {\n    rh[0] += t*s[i];\n    t *= base;\n  }\n  for (int i = 1; i <= n - m; i++) {\n    rh[i] = rh[i - 1]*base + s[i + m - 1] - s[i - 1]*t;\n  }\n}\n\nint main(){\n  string s, t;\n  int q;\n  std::cin >> s >> q;\n  RollingHash rh(s);\n  for (int i = 0; i < q; i++) {\n    std::cin >> t;\n    vector<int> ans = rh.search(t);\n    if(ans.size() == 0){\n      std::cout << 0 << std::endl;\n    }else{\n      std::cout << 1 << std::endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\nbool bm_search(const string &s, const string &w);\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string t, p;\n    t.reserve(1000001);\n    p.reserve(1001);\n    int n;\n    getline(cin, t);\n    cin>>n;\n    cin.ignore();\n    for(int i=0; i<n; i++) {\n        getline(cin, p);\n        if(bm_search(t, p)) cout<<\"1\\n\";\n        else cout<<\"0\\n\";\n    }\n    return 0;\n}\n\nbool bm_search(const std::string &s, const std::string &w)\n{\n    int sl=s.length(), wl=w.length();\n    static int t[128];\n    for(int i=0; i<128; i++) t[i]=wl+1;\n    for(int i=0; i<wl; i++) t[w[i]]=wl-i;\n    int lim=sl-wl, i=0;\n    while(i<=lim) {\n        if(memcmp(s.data()+i, w.data(), wl)==0) return true;\n        i+=t[s[i+wl]];\n    }\n    return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n#define rep(i,n) for (ll i=0;i<(n);++i)\n#define rep2(i,a,b) for (ll i=(a);i<(b);++i)\n#define debug(x) cout << #x << '=' << x << endl\n#define all(v) (v).begin(),(v).end()\nconst ll MOD=1e9+7;\n//const ll MOD=998244353;\nconst ll INF=1e9;\nconst ll IINF=1e18;\nconst double EPS=1e-8;\nconst double pi=acos(-1);\n\ntemplate<class T> inline bool chmin(T &a,T b){\n    if (a>b){a=b; return true;}\n    return false;\n}\ntemplate<class T> inline bool chmax(T &a,T b){\n    if (a<b){a=b; return true;}\n    return false;\n}\n\nstruct SuffixArray{\n    string s;\n    vector<int> sa,rev;\n    SuffixArray(const string &S):s(S){\n        int n=s.size();\n        s.push_back('$');\n        sa.resize(n+1);\n        iota(all(sa),0);\n        sort(all(sa),[&](int a,int b){\n            if (s[a]==s[b]) return a>b;\n            return s[a]<s[b];\n        });\n        vector<int> cs(n+1,0),rs(n+1),cnt(n+1);\n        rep(i,n+1) rs[i]=(int)s[i];\n        for (int k=1;k<=n;k*=2){\n            rep(i,n+1){\n                cs[sa[i]]=i;\n                if (i&&rs[sa[i-1]]==rs[sa[i]]\n                &&sa[i-1]+k<=n&&rs[sa[i-1]+k/2]\n                ==rs[sa[i]+k/2]) cs[sa[i]]=cs[sa[i-1]];\n            }\n            iota(all(cnt),0);\n            copy(all(sa),rs.begin());\n            rep(i,n+1){\n                int sl=rs[i]-k;\n                if (sl>=0) sa[cnt[cs[sl]]++]=sl;\n            }\n            cs.swap(rs);\n        }\n        rev.resize(n+1);\n        rep(i,n+1) rev[sa[i]]=i;\n    }\n    int operator[](int i){\n        return sa[i];\n    }\n    bool lt_substr(string &t,int si,int ti){\n        int sn=s.size(),tn=t.size();\n        while(si<sn&&ti<tn){\n            if (s[si]<t[ti]) return 1;\n            if (s[si]>t[ti]) return 0;\n            ++si,++ti;\n        }\n        return si==sn&&ti<tn;\n    }\n    int lower_bound(string &t){\n        int l=0,r=s.size();\n        while(l+1<r){\n            int m=(l+r)>>1;\n            if (lt_substr(t,sa[m],0)) l=m;\n            else r=m;\n        }\n        return r;\n    }\n    int upper_bound(string &t){\n        ++t.back();\n        int res=lower_bound(t);\n        --t.back();\n        return res;\n    }\n    int count(string &T){\n        return upper_bound(T)-lower_bound(T);\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string T; int Q; cin >> T >> Q;\n    SuffixArray SA(T);\n    rep(i,Q){\n        string P; cin >> P;\n        cout << (SA.count(P)>0) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\n\n#define fi(x) get<0>(x)\n#define se(x) get<1>(x)\n\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\ntypedef vector<pll> vpl;\n\nstring t;\nstring p;\nlli q;\n\nvll sa;\nvll tmp;\nvpl rnk;\n\nint main(){\n    cin >> t;\n    sa = vll(t.size());rnk = vpl(t.size());tmp = vll(t.size());\n    for(lli i = 0;i < t.size();i++) sa[i] = i;\n    for(lli i = 0;i < t.size();i++) fi(rnk[i]) = t[i];\n    for(lli k = 1;k < 2*t.size();k *= 2){\n        sort(sa.begin(),sa.end(),[](lli a,lli b){\n            return rnk[a] < rnk[b];\n        });\n        for(lli i = 1;i < sa.size();i++){\n            tmp[sa[i]] = tmp[sa[i-1]];\n            if(rnk[sa[i]] != rnk[sa[i-1]]) tmp[sa[i]]++;\n        }\n        for(lli i = 0;i < sa.size();i++){\n            fi(rnk[sa[i]]) = tmp[sa[i]];\n        }\n        for(lli i = 0;i < sa.size();i++){\n            if(sa[i]+k < t.size()) se(rnk[sa[i]]) = fi(rnk[sa[i]+k]);\n            else se(rnk[sa[i]]) = -1;\n        }\n    }\n    cin >> q;\n    for(lli i = 0;i < q;i++){\n        cin >> p;\n        lli lwrbnd = *lower_bound(sa.begin(),sa.end(),p,[](lli a,string s){\n            if(t.size() < a + s.size()) return true;\n            return t.compare(a,s.size(),s) < 0;\n        });\n        if(t.size() >= lwrbnd + p.size() && t.compare(lwrbnd,p.size(),p) == 0) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nstruct SubstrMatching{\n    int n;\n    string s;\n    vector<int> sa, lcp, lcp_table;\n    SubstrMatching(string s) : s(s), n(s.size()){\n        sa_is();\n        lcp_build();\n    }\n    vector<int> induced_sort(vector<int> v, int k){\n        if(v.size() == k){\n            vector<int> ret(v.size());\n            for(int i = 0; i < v.size(); ++i)\n                ret[v[i]] = i;\n            return ret;\n        }\n        vector<int> type(v.size(), 1);\n        for(int i = v.size() - 2; i >= 0; --i)\n            type[i] = (v[i] == v[i + 1] ? type[i + 1] : v[i] < v[i + 1]);\n        vector<int> lms;\n        vector<vector<int>> lms_str;\n        for(int i = 0; i < v.size() - 1; ++i){\n            if(!lms_str.empty())\n                lms_str.back().emplace_back(v[i + 1]);\n            if(!type[i] && type[i + 1]){\n                lms_str.emplace_back(1, v[i + 1]);\n                type[i + 1] = 2 + lms.size();\n                lms.emplace_back(i + 1);\n            }\n        }\n        vector<int> v_cnt(k, 0);\n        for(auto x : v)\n            ++v_cnt[x];\n        vector<int> bin(k + 1, v.size());\n        for(int i = 0, idx = 0; i < k; ++i){\n            bin[i] = idx;\n            idx += v_cnt[i];\n        }\n        auto calc = [&](auto& seed){\n            vector<int> cnt(k, 0);\n            vector<int> sa_v(v.size(), -1);\n            for(auto i : seed){\n                int ch = v[i];\n                sa_v[bin[ch + 1] - cnt[ch] - 1] = i;\n                ++cnt[ch];\n            }\n            cnt.assign(k, 0);\n            for(int i = 0; i < v.size(); ++i){\n                int nex = sa_v[i] - 1;\n                if(nex >= 0 && type[nex] == 0){\n                    int ch = v[nex];\n                    sa_v[bin[ch] + cnt[ch]] = nex;\n                    ++cnt[ch];\n                }\n            }\n            cnt.assign(k, 0);\n\n            for(int i = v.size() - 1; i >= 0; --i){\n                int nex = sa_v[i] - 1;\n                if(nex < 0 || !type[nex])\n                    continue;\n                if(nex >= 0 && type[nex]){\n                    int ch = v[nex];\n                    sa_v[bin[ch + 1] - cnt[ch] - 1] = nex;\n                    ++cnt[ch];\n                }\n            }\n            return sa_v;\n        };\n        auto ret_sa = calc(lms);\n        int m = lms.size();\n        vector<int> lms_idx;\n        for(int i = 0; i < v.size(); ++i){\n            if(type[ret_sa[i]] >= 2)\n                lms_idx.emplace_back(type[ret_sa[i]] - 2);\n        }\n        int lms_cnt = 0;\n        vector<int> lms_id(m, -100);\n        for(int i = 0; i < m; ++i){\n            if(i && lms_str[lms_idx[i - 1]] != lms_str[lms_idx[i]])\n                ++lms_cnt;\n            lms_id[lms_idx[i]] = lms_cnt + 0;\n        }\n        vector<int> ret_seed = induced_sort(lms_id, lms_cnt + 1);\n        vector<int> seed(m, 0);\n        for(int i = 0; i < m; ++i)\n            seed[i] = lms[ret_seed[m - i - 1]];\n        ret_sa = calc(seed);\n        return ret_sa;\n    }\n    void sa_is(){\n        unordered_set<char> c_uset;\n        for(int i = 0; i < n; ++i)\n            c_uset.insert(s[i]);\n        set<char> c_set;\n        for(auto c : c_uset)\n            c_set.insert(c);\n        unordered_map<int, int> c_idx;\n        int k = 1;\n        for(auto c : c_set)\n            c_idx[c] = k++;\n        vector<int> v(n + 1, 0);\n        for(int i = 0; i < n; ++i)\n            v[i] = c_idx[s[i]];\n        sa = induced_sort(v, k);\n    }\n    void lcp_build(){\n        vector<int> sa_inv(n + 1);\n        for(int i = 0; i <= n; ++i)\n            sa_inv[sa[i]] = i;\n        lcp.assign(n + 1, 0);\n        for(int i = 0, p = 0; i <= n; ++i){\n            if(sa_inv[i] == n)\n                continue;\n            for(; i + p < n && sa[sa_inv[i] + 1] + p < n && s[i + p] == s[sa[sa_inv[i] + 1] + p]; ++p);\n            lcp[sa_inv[i]] = p;\n            if(p > 0)\n                --p;\n        }\n        int siz = 1;\n        for(; siz <= n; siz *= 2);\n        lcp_table.resize(2 * siz, -1);\n        for(int i = 0; i < n; ++i)\n            lcp_table[i + siz] = lcp[i];\n        for(int i = siz - 1; i > 0; --i)\n            lcp_table[i] = min(lcp_table[i << 1], lcp_table[(i << 1) | 1]);\n    }\n    int match_len(string& t){\n        int l = 0, r = lcp_table.size() / 2;\n        int l_lcp = 0;\n        int idx = 1;\n        while(r - l > 1){\n            int mid = (l + r) >> 1;\n            int m_lcp = lcp_table[idx <<= 1];\n            if(m_lcp == lcp_table[0])\n                r = mid;\n            else if(l_lcp < m_lcp){\n                l = mid;\n                ++idx;\n            }\n            else if(l_lcp > m_lcp)\n                r = mid;\n            else{\n                for(m_lcp = l_lcp; m_lcp < t.size() && sa[mid] + m_lcp < s.size() && t[m_lcp] == s[sa[mid] + m_lcp]; ++m_lcp);\n                if(sa[mid] + m_lcp == s.size() || m_lcp == t.size() || s[sa[mid] + m_lcp] < t[m_lcp]){\n                    l_lcp = m_lcp;\n                    l = mid;\n                    ++idx;\n                }else{\n                    r = mid;\n                }\n            }\n        }\n        return l_lcp;\n    }\n    bool contains(string& t){\n        return match_len(t) == t.size();\n    }\n    int lower_bound(string& t){\n        int l = 0, r = lcp_table.size() / 2;\n        int l_lcp = 0;\n        int idx = 1;\n        while(r - l > 1){\n            int mid = (l + r) >> 1;\n            int m_lcp = lcp_table[idx <<= 1];\n\n            if(m_lcp == lcp_table[0])\n                r = mid;\n            else if(l_lcp < m_lcp){\n                l = mid;\n                ++idx;\n            }\n            else if(l_lcp > m_lcp)\n                r = mid;\n            else{\n                for(m_lcp = l_lcp; m_lcp < t.size() && sa[mid] + m_lcp < s.size() && t[m_lcp] == s[sa[mid] + m_lcp]; ++m_lcp);\n                if(sa[mid] + m_lcp == s.size() || m_lcp == t.size() || s[sa[mid] + m_lcp] < t[m_lcp]){\n                    l_lcp = m_lcp;\n                    l = mid;\n                    ++idx;\n                }else{\n                    r = mid;\n                }\n            }\n        }\n        return r;\n    }\n    pair<int,int> find(string t){\n        --t.back();\n        auto l = lower_bound(t);\n        ++t.back();\n        auto r = lower_bound(t);\n        return make_pair(l, r);\n    }\n};\n\n\nsigned main(){\n    string s, t;\n    cin >> s;\n    SubstrMatching p(s);\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i){\n        cin >> t;\n        printf(\"%d\\n\", p.contains(t));\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring S,T;\nstring V[1000][100];\nint main(){\n\tint q,a,b,c;\n\tb=S.size();\n\tcin>>S;\n\ta=min(b,100);\n\tfor(int i=1;i<100;i++){\n\t\tfor(int j=0;j<b-i;j++){\n\t\t\tV[j][i]=S.substr(j,i);\n\t\t}\n\t}\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>T;\n\t\tc=T.size();\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(V[j][c]==T){\n\t\t\t\tcout<<\"1\"<<endl;\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t}\n\t\tcout<<\"0\"<<endl;\n\t\tExit:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }  \n};\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  const int n = SZ(a);\n  if(n>1){\n    vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(b,rh), mergesort(c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==SZ(c))a[i]=b[j++];\n      else if(j==SZ(b))a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  //sort(ALL(sa),rh);\n  mergesort(sa,rh);\n  //if(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    //if(S.compare(sa[c],T.length(),T)<0 )a=c;\n    //else b=c;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000000];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\nint checkTable[10000]={0};\n\nstruct LocInfo{\n\tchar* pointer;\n\tint pattern_index;\n\tbool used;\n};\n\nstruct Node{\n\tNode(){\n\t\tnum_of_outputed_info=num_of_finish_info=0;\n\t\texitstFLG=false;\n\t}\n\tvector<LocInfo> finish_info_bank;\n\tint num_of_finish_info;\n\tint num_of_outputed_info;\n\tbool exitstFLG;\n};\n\nint charNUM(char ch){\n\tif(ch>='0'&&ch<'9'){\n\t\treturn ch-48;\n\t}else if(ch>='A'&&ch<='Z'){\n\t\treturn ch-55;\n\t}else{\n\t\treturn ch-61;\n\t}\n}\n\nint main(){\n\n\tNode** nodes = new Node*[1000];\n\tfor(int i=0;i<1000;i++){\n\t\tnodes[i]=new Node[62];\n\t}\n\tchar* T = new char[1000001];\n\tint Q,T_length=0,index,limit;\n\tscanf(\"%s\",T);\n\tscanf(\"%d\",&Q);\n\tchar** P = new char*[Q];\n\tfor(int i=0;i<Q;i++){\n\t\tP[i]=new char[1001];\n\t\tscanf(\"%s\",P[i]);\n\n\t\tindex=0;\n\t\twhile(P[i][index+1]!='\\0'){\n\t\t\tnodes[index][charNUM(P[i][index])].exitstFLG=true;\n\t\t\tindex++;\n\t\t}\n\t\tLocInfo info;\n\t\tinfo.pointer=P[i];\n\t\tinfo.pattern_index=i;\n\t\tinfo.used=false;\n\t\tnodes[index][charNUM(P[i][index])].exitstFLG=true;\n\t\tnodes[index][charNUM(P[i][index])].finish_info_bank.push_back(info);\n\t\tnodes[index][charNUM(P[i][index])].num_of_finish_info++;\n\t}\n\n\tfor(int i=0;T[i]!='\\0';i++)T_length++;\n\tchar tmp[1001];\n\tfor(int i=0;i<T_length;i++){\n\t\tfor(int k=0;k<1001;k++)tmp[k]='\\0';\n\t\tfor(int k=0;T[i+k]!='\\0'&&k<1000;k++){\n\t\t\ttmp[k]=T[i+k];\n\t\t\tif(nodes[k][charNUM(T[i+k])].exitstFLG==true){\n\t\t\t\tif((limit=nodes[k][charNUM(T[i+k])].num_of_finish_info)>0){\n\n\t\t\t\t\tfor(int search=0;search<limit;search++){\n\t\t\t\t\t\tif(nodes[k][charNUM(T[i+k])].finish_info_bank[search].used==false&&strcmp(nodes[k][charNUM(T[i+k])].finish_info_bank[search].pointer,tmp)==0){\n\t\t\t\t\t\t\tcheckTable[nodes[k][charNUM(T[i+k])].finish_info_bank[search].pattern_index]=1;\n\t\t\t\t\t\t\tnodes[k][charNUM(T[i+k])].finish_info_bank[search].used=true;\n\t\t\t\t\t\t\tif(++nodes[k][charNUM(T[i+k])].num_of_outputed_info==nodes[k][charNUM(T[i+k])].num_of_finish_info){\n\t\t\t\t\t\t\t\tnodes[k][charNUM(T[i+k])].num_of_finish_info=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<Q;i++){\n\t\tif(checkTable[i]==0)printf(\"0\\n\");\n\t\telse{\n\t\t\tprintf(\"1\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n\n\nusing namespace std;\n\nstring t;\nint q,n,size;\nbool flag;\nint id[70] = {};\n\nint main()\n{\n\tcin >> t >> q;\n\t\n\tfor(int i = 0 ;i < t.size();i++)\n\t{\n\t\tif(t[i] > 'a' && t[i] < 'Z')id[t[i] - 'a']++;\n\t\telse id[52 + t[i] - '0']++;\n\t}\n\t\n\t\n\tfor(int i = 0;i < q ;i++)\n\t{\n\t\tflag = false;\n\t\tint z[70] = {};\n\t\tstring p;\n\t\tcin >> p;\n\t\tsize = p.size();\n\t\t\n\t\tfor(int h = 0 ;h < size;h++)\n\t\t{\n\t\t\tif(t[h] > 'a' && t[h] < 'Z')id[t[h] - 'a']++;\n\t\t\telse z[52 + t[h] - '0']++;\n\t\t}\n\t\t\n\t\tfor(int w = 0;w < 70;w++)\n\t\tif(id[w] != z[w]) flag = true;\n\t\t\n\t\tif(flag) continue;\n\n\t\t\n\t\tfor(int j = 0;j < t.size();j++)\n\t\t{\n\t\t\tif(t[j] == p[0])\n\t\t\t{\n\t\t\t\tif(size == 1) \n\t\t\t\t{\n\t\t\t\t\tcout << 1 << endl;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\tfor(int k = 1;k < size;k++)\n\t\t\t\t{\n\t\t\t\t\tif(t[j+k] != p[k]) break;\n\t\t\t\t\tif(k == size -1) \n\t\t\t\t\t{\n\t\t\t\t\t\tcout << 1 << endl;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tif(flag) break;\n\t\t}\n\tif(!flag) cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, k;\nstring s;\nvector<int> order;\nvector<int> tmp;\nvector<int> sa;\n\nbool compare_sa(const int &i, const int &j)\n{\n  if(order[i] != order[j]) return order[i] < order[j];\n  else\n  {\n    int ri = i + k <= n ? order[i+k] : -1;\n    int rj = j + k <= n ? order[j+k] : -1;\n    return ri < rj;\n  }\n}\n\nvoid construct_sa()\n{\n  for(int i = 0; i <= n; i++)\n  {\n    sa[i] = i;\n    order[i] = i < n ? s[i] : -1;\n  }\n  for(k = 1; k <= n; k*=2)\n  {\n    sort(sa.begin(),sa.end(),compare_sa);\n    tmp[sa[0]] = 0;\n    for(int i = 1; i <= n; i++)\n      tmp[sa[i]] = tmp[sa[i-1]] + (compare_sa(sa[i-1],sa[i])?1:0);\n    for(int i = 0; i <= n; i++)\n      order[i] = tmp[i];\n  }\n}\n\nvoid init()\n{\n  n = s.size();\n  order.resize(n+1);\n  tmp.resize(n+1);\n  sa.resize(n+1);\n  construct_sa();\n}\n\nbool contain(string t)\n{\n  int l=0, r=n;\n  while(r-l>1)\n  {\n    int m = (l+r)/2;\n    if(s.compare(sa[m],t.size(),t)<0) l = m;\n    else r = m;\n  }\n  return s.compare(sa[r],t.size(),t) == 0;\n}\n\nint main(){\n\n\tcin >> s;\n\tstring t;\n\tint q ; cin >> q;\n\tinit();\n\tconstruct_sa ();\n\tfor (int i = 0; i < count; ++i)\n\t {\n\t \tcin >> t;\n\t \tcout << contain(t) << endl;\n\t } \n\t return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct SuffixArray {\n    const string s;\n    vector<int> SuffixArr;\n    vector<int> lcp;\n\n    SuffixArray(const string str) : s(str){\n        construct_suffix_array();\n        construct_lcp();\n    }\n\n    // Suffix Array の構築\n    void construct_suffix_array(){\n        const int len = s.length();\n        vector<int> tmp(len, 0);\n        vector<int> rank(len, 0);\n        int k;\n\n        SuffixArr.resize(len);\n        rank.resize(len);\n\n        for (int i = 0; i < len; ++i){\n            SuffixArr[i] = i;\n            rank[i] = s[i];\n        }\n\n        // ソート比較用関数 ([&] は変数の参照キャプチャ)\n        auto compare_sa = [&](int i, int j){\n            if(rank[i] != rank[j]){\n                return rank[i] < rank[j];\n            }\n            int ri = (i + k < len) ? rank[i + k] : -1;\n            int rj = (j + k < len) ? rank[j + k] : -1;\n            return ri < rj;\n        };\n\n        for (k = 1; k <= len; k *= 2){\n            sort(SuffixArr.begin(), SuffixArr.end(), compare_sa);\n            tmp[SuffixArr[0]] = 0;\n            for (int i = 1; i < len; ++i){\n                int c = compare_sa(SuffixArr[i - 1], SuffixArr[i]) ? 1 : 0;\n                tmp[SuffixArr[i]] = tmp[SuffixArr[i - 1]] + c;\n            }\n            for(int i = 0; i < len; ++i){\n                rank[i] = tmp[i];\n            }\n        }\n    }\n\n    // 高さ配列の構築\n    void construct_lcp(){\n        int l = s.length();\n        vector<int> rank(l);\n        lcp.resize(l);\n        for (int i = 0; i < l; ++i){\n            rank[SuffixArr[i]] = i;\n            lcp[i] = 0;\n        }\n        for(int i = 0, h = 0; i < l; i++) {\n            if(rank[i] + 1 < l) {\n                for(int j = SuffixArr[rank[i] + 1]; max(i, j) + h < SuffixArr.size() && s[i + h] == s[j + h]; ++h);\n                lcp[rank[i] + 1] = h;\n                if(h > 0){\n                    --h;\n                }\n            }\n        }\n        return;\n    }\n\n    // S の s_idx 文字目からの文字列と, P の p_idx 文字目からの文字列の比較\n    bool substr_less_than(const string &p, int s_idx = 0, int p_idx = 0){\n        int len_s = s.length();\n        int len_p = p.length();\n        while(s_idx < len_s && p_idx < len_p){\n            if(s[s_idx] < p[p_idx]){\n                return true;\n            }\n            else if(s[s_idx] > p[p_idx]){\n                return false;\n            }\n            s_idx++;\n            p_idx++;\n        }\n        return (s_idx >= len_s) && (p_idx < len_p);\n    }\n\n    pair<int, int> lower_upper_bound(string p){\n        int lb, ub;\n        auto binary_search = [&](int lo, int hi){\n            while(hi - lo > 1){\n                int mid = (hi + lo) / 2;\n                if(substr_less_than(p, SuffixArr[mid])){\n                    lo = mid;\n                }\n                else {\n                    hi = mid;\n                }\n            }\n            return hi;\n        };\n        // lower_bound\n        lb = binary_search(-1, s.length());\n        // upper_bound\n        p.back()++;\n        ub = binary_search(lb - 1, s.length());\n        return make_pair(lb, ub);\n    }\n\n    void show_output(){\n        for(int i = 0; i < s.length(); ++i){\n            cout << i << \" : lcp -> \" << lcp[i] << \", suffix -> \" << s.substr(SuffixArr[i]) << endl;\n        }\n    }\n};\n\nstruct RollingHash {\n    typedef long long lint;\n    const string str;\n    const lint base, mod;\n    vector<lint> hash, pw;\n\n    RollingHash(const string &s, lint h=1000000007, lint b=1009) : str(s), mod(h), base(b){\n        int l = s.length();\n        hash.assign(l+1, 0);\n        pw.assign(l+1, 0);\n        pw[0] = 1;\n        for (int i=0; i<l; ++i){\n            pw[i+1] = pw[i] * base % mod;\n            hash[i+1] = (hash[i] * base + s[i]) % mod;\n        }\n    }\n\n    lint const get_hash(int l, int r) {\n        return ((hash[r] - hash[l] * pw[r-l]) % mod + mod) % mod;\n    }\n};\n\nint main(void) {\n    string S;\n    cin >> S;\n    int N;\n    cin >> N;\n    // vector<string> P(N);\n    SuffixArray SA(S);\n    for(int i=0; i<N; i++) {\n        // cin >> P.at(i);\n        // int n = P.size();\n        string P;\n        cin >> P;\n        auto p = SA.lower_upper_bound(P);\n        if(p.first == p.second) {\n            cout << 0 << endl;\n        } else {\n            cout << 1 << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint T_char_count[128] = {0},T_max_succeed_count[128] = {0};\n\nclass LocRecord{\n\npublic:\n\tLocRecord(){\n\t\tlocationTable = new int*[128];\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}\n\t\t}\n\n\t}\n\n\tvoid init(){\n\n\t\tint limit;\n\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][T_char_count[i]] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][T_char_count[i]] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][T_char_count[i]] = -1;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tvoid init_index(){\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t}\n\n\tvoid regist_loc(int ch, int location){\n\t\tlocationTable[ch][index[ch]] = location;\n\t\tindex[ch]++;\n\t}\n\n\tint next_loc(int ch){\n\t\tint ret = locationTable[ch][index[ch]];\n\t\tindex[ch]++;\n\t\treturn ret;\n\t}\n\nprivate:\n\tint** locationTable;\n\tint index[128];\n};\n\nvoid Tcompress(int compressed_array[],char base_array[],int& compressed_length){\n\n    int comp_index = 0,count = 0;\n    char ch = base_array[0];\n\n    for(int i = 0; base_array[i] != '\\0';){\n\n        if(ch == base_array[i]){\n            count++;\n            T_char_count[ch]++;\n            if(base_array[i+1] == '\\0'){\n            \tT_max_succeed_count[ch] = std::max(T_max_succeed_count[ch],count);\n                if(count >= 4){\n                    compressed_array[comp_index-2] = -1;\n                    compressed_array[comp_index-1] = count;\n                }else{\n                    compressed_array[comp_index++] = ch;\n                }\n            }else{\n                if(count <= 3){\n                    compressed_array[comp_index++] = ch;\n                }\n            }\n            i++;\n        }else{\n        \tT_max_succeed_count[ch] = std::max(T_max_succeed_count[ch],count);\n            if(count >= 4){\n                compressed_array[comp_index-2] = -1;\n                compressed_array[comp_index-1] = count;\n            }\n            count = 0;\n            ch = base_array[i];\n        }\n    }\n    compressed_length = comp_index;\n}\n\nint Pcompress(int compressed_array[],char base_array[],int P_char_count[],int& multFLG,int P_max_succeed_count[]){\n\n    int comp_index = 0,count = 0;\n    char ch = base_array[0];\n\n    for(int i = 0; base_array[i] != '\\0';){\n\n    \tif(ch == base_array[i]){\n            count++;\n            P_char_count[ch]++;\n            if(base_array[i+1] == '\\0'){\n            \tP_max_succeed_count[ch] = std::max(P_max_succeed_count[ch],count);\n                if(count >= 4){\n                    compressed_array[comp_index-2] = -1;\n                    compressed_array[comp_index-1] = count;\n                }else{\n                    compressed_array[comp_index++] = ch;\n                }\n            }else{\n                if(count <= 3){\n                    compressed_array[comp_index++] = ch;\n                }\n            }\n            i++;\n        }else{\n        \tP_max_succeed_count[ch] = std::max(P_max_succeed_count[ch],count);\n            if(count >= 4){\n                compressed_array[comp_index-2] = -1;\n                compressed_array[comp_index-1] = count;\n            }\n            count = 0;\n            ch = base_array[i];\n            multFLG = 1;\n        }\n    }\n    return comp_index;\n}\n\nint main(){\n    int T_comp_index,P_comp_index,comp_T_length,tmp,Q,P_length,P_char_count[128],div_tmp;\n\n    char* T = new char[1000001];\n    int* compressedT = new int[1000001];\n\n    char P[1001];\n\n    scanf(\"%s\",T);\n    Tcompress(compressedT,T,comp_T_length);\n\n    //printf(\"Tmaxsuceedcount[i] %d:Tmaxsuceedcount[o] %d\\n\",T_max_succeed_count['i'],T_max_succeed_count['o']);return 0;\n\n    LocRecord loc_record;\n    loc_record.init();\n\n    /*for(int i = 0; i < comp_T_length; i++){\n    \tprintf(\"compressedT[%d]:%c\\n\",i,compressedT[i]);\n    }\n    return 0;*/\n\n    scanf(\"%d\",&Q);\n    int* possibilityTable = new int[Q];\t//0??????????????§?????? 1:???????????£??? 2:????????§??????\n    int** compressedP = new int*[Q];\n\n\tint* comp_P_length = new int[Q];\n\tint* leftsuceedFLG = new int[Q];\t//1????????£?¶?\n\tint* rightsuceedFLG = new int[Q];\t//1????????£?¶?\n\tint* multFLG = new int[Q];\t//1???????????°\n\tint* most_right = new int[Q];\t//?????????????????????ASCII?????????\n\tint** P_max_succeed_count = new int*[Q];\n\tint** moveLength = new int*[Q];//Q????????§?????????????????????????????????Q???????§??????¨?????????\n\n\tloc_record.regist_loc(compressedT[0],0);\n\tfor(int i = 1; i < comp_T_length; i++){\n\t if(compressedT[i] != -1 && compressedT[i-1] != -1){\n\t\t loc_record.regist_loc(compressedT[i],i);\n\t }\n\t}\n\n\n\t// loc_record.deBug();return 0;\n\t /*int buf_fix;\n\t loc_record.init_index();\n\t while((buf_fix = loc_record.next_loc('b')) != -1 &&  buf_fix  != 0){\n\t\tif('b' != compressedT[buf_fix]){\n\t\t\tprintf(\"b??¨??????%c????????????????????????\\n\",compressedT[buf_fix]);\n\t\t}\n\t }\n\t return 0;*/\n\n\n    for(int i = 0; i < Q; i++){\n    \tscanf(\"%s\",P);\n\n    \tP_length = 0;\n    \tmoveLength[i] = new int[128];\n\t\tP_max_succeed_count[i] = new int[128];\n\t\tfor(int k = 0; k < 128; k++){\n\t\t\tP_max_succeed_count[i][k] = 0;\n\t\t\tmoveLength[i][k] = -1;\n\t\t\tP_char_count[k] = 0; //P???????????°????????????????????????????????????\n\t\t}\n\t\tmultFLG[i] = leftsuceedFLG[i] = rightsuceedFLG[i] = possibilityTable[i] = 0;\n\n\n\t\t//P?????§???????????????????????°????????´??°???????????????\n    \tfor(int k = 0; P[k] != '\\0'; k++) P_length++;\t//P???????????°?????°??????\n    \tcompressedP[i] = new int[P_length];\t//P????????????????????¢???????????????\n    \tcomp_P_length[i] = Pcompress(compressedP[i],P,P_char_count,multFLG[i],P_max_succeed_count[i]); //??§???&??????????????´?????°???????????????&????????????????????????????????????\n    \tfor(int k = 0; k < 128; k++){\n    \t\tif((T_char_count[k] < P_char_count[k]) || (T_max_succeed_count[k] < P_max_succeed_count[i][k])){\t//?????´????????????????°?????????¨???P????????´???????????????????????????????????????????????´?????°??\\????????????????????????????????????\n    \t\t\tpossibilityTable[i] = 2;\t//?????????P?????£?¶???????????????\\??????T??§??£?¶????????????????????????????\n    \t\t\tbreak;\n    \t\t}\n    \t}\n\n\n    \tif(multFLG[i] == 0 && possibilityTable[i] == 0) possibilityTable[i] = 1;\t//1?¨??????§??????????????°?????´?????°?????????????????????????????????????????????????????§??£?¶??????°????????????????????£????????????????´¢?????????\n\n    \tif(possibilityTable[i] == 0){\t//?????´??????????????§??????????????????????§??????¨?????????????????????????????£?¶?????????°????????????\n\n    \t\tmost_right[i] = P[P_length-1];\n    \t\tif(comp_P_length[i] > 2 && compressedP[i][comp_P_length[i]-2] == -1){\n    \t\t\trightsuceedFLG[i] = 1;\n    \t\t}\n    \t\t//1????????§?????´??????????????\\????????????????????´??§?????\\??????????????????????????§?????????2????????\\???\n    \t\tif(compressedP[i][1] == -1){\n    \t\t    leftsuceedFLG[i] = 1;\n    \t\t}\n    \t}\n    }\n\n    //printf(\"Pmaxsuceedcount[0][i] %d:Pmaxsuceedcount[0][o] %d\\n\",P_max_succeed_count[0]['i'],P_max_succeed_count[0]['o']);\n    //printf(\"Pmaxsuceedcount[1][i] %d:Pmaxsuceedcount[1][o] %d\\n\",P_max_succeed_count[1]['i'],P_max_succeed_count[1]['o']);return 0;\n\n\n    /*for(int i = 0; i < comp_P_length[0]; i++){\n    \tprintf(\"compressedP[%d] = %c\\n\",i,compressedP[0][i]);\n    }*/\n\n    /*for(int i = 0; i < 128; i++){\n    \tprintf(\"%c:%d\\n\",i,moveLength[0][i]);\n    }\n    return 0;\n*/\n    for(int i = 0; i < Q; i++){\n    \tif(possibilityTable[i] == 2){\t//?????´??????????????§???????????´???\n    \t\tprintf(\"0\\n\");\n    \t}else if(possibilityTable[i] == 1){\t//???????????£?????´???\n    \t\tprintf(\"1\\n\");\n    \t}else{\n\t\t\tloc_record.init_index();\n\t\t\tT_comp_index = loc_record.next_loc(most_right[i]);\n\t\t\t//printf(\"most_right???%c??§T_comp_index???????????????%d\\n\",most_right[i],T_comp_index);\n\t\t\t//printf(\"%c???????????´???%d\\n\",most_right[i],first_appeard[most_right[i]]);return 0;\n\t\t\t//printf(\"???????????°???%d\\n\",rightsuceedFLG[i]);return 0;\n\t\t\t//printf(\"???????????°???%d\\n\",leftsuceedFLG[i]);return 0;\n\n\t\t\twhile(T_comp_index < comp_T_length){\n\t\t\t\t\ttmp = T_comp_index;\n\t\t\t\t\tP_comp_index = comp_P_length[i]-1;\n\t\t\t\t\t//printf(\"????????????????????????%d\\n\",comp_P_length[i]);return 0;\n\t\t\t\t\t//printf(\"??????????§???????%c\\n\",compressedT[T_comp_index]);\n\n\t\t\t\t\twhile(P_comp_index >= 0 && tmp >= 0){\n\n\t\t\t\t\t\t//printf(\"P_comp_index:%d,tmp:%d\\n\",P_comp_index,tmp);\n\t\t\t\t\t\tif(tmp == T_comp_index){\n\t\t\t\t\t\t\tif(rightsuceedFLG[i] == 1){\t//compressedP??????????????§??????????????????????????????compressedP?????§?????°?????????????????´???\n\t\t\t\t\t\t\t\tif((tmp < comp_T_length - 2) && (compressedT[tmp+1] == -1) && (compressedT[tmp+2] >= compressedP[i][comp_P_length[i]-1])){\n\t\t\t\t\t\t\t\t\ttmp -= 1;\n\t\t\t\t\t\t\t\t\tP_comp_index -= 3;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\t//P??????????????§???????????????????????´???\n\t\t\t\t\t\t\t\tif((tmp < comp_T_length - 2) && (compressedT[tmp+1] == -1)){\t//T??????????????§????????????????????´???<<compressedT[tmp] == most_right[i]??§????????????>>\n\t\t\t\t\t\t\t\t\tif(compressedP[i][P_comp_index] != compressedP[i][P_comp_index-1]){\t//P????????????1?????????????????? <<?????°?????????2????????\\???>>\n\t\t\t\t\t\t\t\t\t\ttmp--;\n\t\t\t\t\t\t\t\t\t\tP_comp_index--;\n\t\t\t\t\t\t\t\t\t}else if((compressedP[i][P_comp_index] == compressedP[i][P_comp_index-1]) && (compressedP[i][P_comp_index-1] != compressedP[i][P_comp_index-2])){\n\t\t\t\t\t\t\t\t\t\ttmp--;\t//P????????????2???????????´???<<?????°?¨????????????????2???????????´??????3????????\\???>>\n\t\t\t\t\t\t\t\t\t\tP_comp_index -= 2;\n\t\t\t\t\t\t\t\t\t}else{\t//P????????????3???????????´???\n\t\t\t\t\t\t\t\t\t\ttmp--;\n\t\t\t\t\t\t\t\t\t\tP_comp_index -= 3;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}else{\t//T??????????????§????????????????????´???\n\t\t\t\t\t\t\t\t\t//printf(\"?????????OK\\n\");\n\t\t\t\t\t\t\t\t\ttmp--;\n\t\t\t\t\t\t\t\t\tP_comp_index--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(leftsuceedFLG[i] == 1 && P_comp_index == 2){\t//??????????????????????????§?????????????????????Pmost_left?????§?????°??????????????????????????\\???????????´???\n\t\t\t\t\t\t\tif((tmp > 1) && (compressedT[tmp-1] == -1) && (compressedT[tmp] >= compressedP[i][P_comp_index]) && (compressedP[i][0] == compressedT[tmp-2])){\t//T??????????????§????????????????????´???\n\t\t\t\t\t\t\t\ttmp -= 3;\n\t\t\t\t\t\t\t\tP_comp_index -= 3;\n\t\t\t\t\t\t\t}else{\t//T??????????????§???????????????????????´???\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if((leftsuceedFLG[i] == 0) && (P_comp_index == 2) && (compressedP[i][2] == compressedP[i][1]) && (compressedP[i][1] == compressedP[i][0])){ //??????????????????????????§??????????????????????????????3????????£?¶??????´???\n\t\t\t\t\t\t\tif((tmp >= 2) && (compressedT[tmp-1] == -1) && (compressedT[tmp-2] == compressedP[i][0])){ //T??????????????§?????????????????????????????´\n\t\t\t\t\t\t\t\ttmp -= 3;\n\t\t\t\t\t\t\t\tP_comp_index -= 3;\n\t\t\t\t\t\t\t}else if(compressedP[i][P_comp_index] == compressedT[tmp] && tmp > 1 && compressedT[tmp] == compressedT[tmp-1] && compressedT[tmp-1] == compressedT[tmp-2]){ //T???????????????????????´\n\t\t\t\t\t\t\t\ttmp -= 3;\n\t\t\t\t\t\t\t\tP_comp_index -= 3;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if((leftsuceedFLG[i] == 0) && (P_comp_index == 1) && (compressedP[i][1] == compressedP[i][0])){\t//??????????????????????????§??????????????????????????????2????????£?¶??????´???\n\t\t\t\t\t\t\t//printf(\"?????§???????????????2??£?¶?\\n\");\n\t\t\t\t\t\t\tif((tmp >= 2) && (compressedT[tmp-1] == -1) && (compressedT[tmp-2] == compressedP[i][0])){ //T?????§?????????????????????????????´\n\t\t\t\t\t\t\t\ttmp -= 3;\n\t\t\t\t\t\t\t\tP_comp_index -= 2;\n\t\t\t\t\t\t\t}else if((compressedP[i][P_comp_index] == compressedT[tmp]) && (tmp > 1)  && (compressedT[tmp-1] != -1) && (compressedT[tmp-2] != -1) && (compressedT[tmp] == compressedT[tmp-1])){\n\t\t\t\t\t\t\t\ttmp -= 2;\n\t\t\t\t\t\t\t\tP_comp_index -= 2;\n\t\t\t\t\t\t\t}else if((compressedP[i][P_comp_index] == compressedT[tmp]) && (tmp == 1)  && (compressedT[tmp-1] != -1) && (compressedT[tmp] == compressedT[tmp-1])){\n\t\t\t\t\t\t\t\ttmp -= 2;\n\t\t\t\t\t\t\t\tP_comp_index -= 2;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}else if((leftsuceedFLG[i] == 0) && (P_comp_index == 0) && (tmp >= 2) && (compressedT[tmp-1] == -1) //??????????????????????????§??????????????????????????????1???????????????T??????????????§???\n\t\t\t\t\t\t\t\t&& (compressedT[tmp-2] == compressedP[i][P_comp_index])){\n\t\t\t\t\t\t\ttmp -= 3;\n\t\t\t\t\t\t\tP_comp_index--;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(compressedP[i][P_comp_index] == compressedT[tmp]){\n\t\t\t\t\t\t\t\ttmp -= 1;\n\t\t\t\t\t\t\t\tP_comp_index--;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t//printf(\"?????£?????????%c??¨%c\\n\",compressedP[i][P_comp_index],compressedT[tmp]);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(P_comp_index == -1){\n\t\t\t\t\t\tprintf(\"1\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*int shishimaru;\n\t\t\t\t\tfor(shishimaru = T_comp_index + 1; shishimaru < comp_T_length && compressedT[shishimaru] != most_right[i]; shishimaru++){\n\n\t\t\t\t\t}\n\t\t\t\t\tT_comp_index = shishimaru;*/\n\n\t\t\t\t\tdiv_tmp = loc_record.next_loc(most_right[i]);\n\t\t\t\t\t//printf(\"?¬????%d\\n\",div_tmp);\n\t\t\t\t\tif(div_tmp == -1){\t//??????compressedT???most_right????????´???????????´???\n\t\t\t\t\t\tprintf(\"0\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tT_comp_index = div_tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif(T_comp_index >= comp_T_length){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t}\n\n    \t} //????????????????????§???????????´???????????¬??§\n    }\t//for???????????¬??§\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\nint n,sa[1<<20],r[1<<20],tmp[1<<20];\nchar s[1<<20];\nint k;\nbool comp(int i,int j)\n{\n\tif(r[i]!=r[j])return r[i]<r[j];\n\telse\n\t{\n\t\tint ri=i+k<=n?r[i+k]:-1;\n\t\tint rj=j+k<=n?r[j+k]:-1;\n\t\treturn ri<rj;\n\t}\n}\nvoid construct()\n{\n\tn=strlen(s);\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tsa[i]=i;\n\t\tr[i]=i<n?s[i]:-1;\n\t}\n\tfor(k=1;k<=n;k*=2)\n\t{\n\t\tsort(sa,sa+n+1,comp);\n\t\ttmp[sa[0]]=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\ttmp[sa[i]]=tmp[sa[i-1]]+comp(sa[i-1],sa[i]);\n\t\t}\n\t\tfor(int i=0;i<=n;i++)r[i]=tmp[i];\n\t}\n}\nchar t[1010];\nint T;\nint c(int i)\n{\n\tint j=0;\n\tfor(;j<T&&s[i+j]==t[j];j++);\n\treturn j<T?t[j]-s[i+j]:0;\n}\nbool func()\n{\n\tint f=0,l=n+1;\n\twhile(l-f>1)\n\t{\n\t\tint m=(f+l)/2;\n\t\tif(c(sa[m])<0)l=m;\n\t\telse f=m;\n\t}\n\treturn c(sa[f])==0;\n}\nmain()\n{\n\tgets(s);\n\tint p;scanf(\"%d\\n\",&p);\n\tconstruct();\n\tfor(;gets(t);)\n\t{\n\t\tT=strlen(t);\n\t\tputs(func()?\"1\":\"0\");\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct node{\n\tint fail;\n\tbool vis;\n\tmap<char,int> nxt;\n};\n\nvector<node> trie;\n\nstring input(){\n\tstatic char buf[1000010];\n\tbuf[0] = 0;\n\tscanf(\"%s\", buf);\n\treturn buf;\n}\n\nint main(){\n\ttrie.emplace_back();\n\ttrie[0].fail = -1;\n\n\tstring t = input();\n\tint q;\n\tscanf(\"%d\", &q);\n\tvector<int> idx(q);\n\tfor(int i = 0; i < q; ++i){\n\t\tstring p = input();\n\t\tint u = 0;\n\t\tfor(char c : p){\n\t\t\tif(!trie[u].nxt.count(c)){\n\t\t\t\ttrie[u].nxt.emplace(c, trie.size());\n\t\t\t\ttrie.emplace_back();\n\t\t\t}\n\t\t\tu = trie[u].nxt[c];\n\t\t}\n\t\tidx[i] = u;\n\t}\n\n\tvector<int> bfs;\n\tbfs.push_back(0);\n\tint k = 0;\n\twhile(k < (int)bfs.size()){\n\t\tint u = bfs[k++];\n\t\tfor(const auto &pr : trie[u].nxt){\n\t\t\tchar c = pr.first;\n\t\t\tint v = pr.second;\n\t\t\tbfs.push_back(v);\n\n\t\t\tint f = trie[u].fail;\n\t\t\twhile(f >= 0 && !trie[f].nxt.count(c)){\n\t\t\t\tf = trie[f].fail;\n\t\t\t}\n\t\t\ttrie[v].fail = f >= 0 ? trie[f].nxt[c] : 0;\n\t\t}\n\t}\n\n\tint r = 0;\n\tfor(char c : t){\n\t\twhile(r >= 0 && !trie[r].nxt.count(c)){\n\t\t\tr = trie[r].fail;\n\t\t}\n\t\tr = r >= 0 ? trie[r].nxt[c] : 0;\n\t\ttrie[r].vis = true;\n\t}\n\n\tfor(int i = bfs.size(); i--; ){\n\t\tint u = bfs[i];\n\t\tif(trie[u].vis){\n\t\t\ttrie[trie[u].fail].vis = true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < q; ++i){\n\t\tprintf(\"%d\\n\", +trie[idx[i]].vis);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//\n// ?????¢\n// XCode??§???EOF??\\??????Ctrl+D\n// ?\\???Alt+\\\n// ans???????§?INT?????????2,147,483,647????¶????????????¨??????????????§long long?????£???????????????????????????\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////\n//\n//\n////////////////////////////////////////\n\n//#define debug //*******************************************************************************************************************************************\n#ifdef debug\n#include <chrono>\n#endif\n\n#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstring> //memcpy\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <map>\n//#include <unordered_map> //hash func.\n#include <fstream> //ifstream, ofstream\n#include <iterator> //insert_iterator::inserter\n\n\n//#define NDEBUG //If NDEBUG is defined before #include <cassert>, assert will be ignored. You had better define NDEBUG when u submit the code.\n#include <cassert> //assert\n\nusing namespace std;\n\n\n#define dout cout\n//If u wanna output to a text file instead of standard output, plz define OUTPUTFILE.\n//#define OUTPUTFILE \"output.txt\" //*******************************************************************************************************************************************\n#ifdef OUTPUTFILE\n#define dout outputfile\nofstream outputfile(OUTPUTFILE);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n\n#define din cin\n//If u wanna input from a text file instead of standard input, plz define INPUTFROMTEXTFILE???.\n//#define INPUTFILE \"input.txt\" //*******************************************************************************************************************************************\n#ifdef INPUTFILE\n#define din inputfile\nifstream inputfile(INPUTFILE);\n#endif\n\n#define scan(A) scanf(\"%d\", &(A))\n#define disp(A) dout << #A << \" = \" << setw(3) << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \"\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n//#define dispAll(A,n) cout << #A << \" = \"; rep(j, 0, (n)) {cout << setw(3) << A[j] << \" \";} cout << endl\n\n#define sign(x) ((x)>0)-((x)<0) //x<0: -1, x=0: 0, x>0: +1\n#define p(i) (i)/2\n#define l(i) (i)*2\n#define r(i) (i)*2+1\n\nint dx[] = {1,-1, 0, 0, 1, 1,-1,-1}; //???????????????????????????????¨??????????????????????????????????\nint dy[] = {0, 0,-1, 1,-1, 1, 1,-1};\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef unsigned long ull;\n\nconst int INF = (int)2e9+10;\nconst ll INF_LL = (ll)9e18-1LL; //Be careful for overflow.\nconst ull INF_ULL = (ull)1e19-1ULL;\nconst int NONE = -1;\nconst ll MOD = (ll)1e9+7; //??§???????´???°?????£??¨??¨????????°????????????10???7??????\n\nconst int N_MAX = 1000010; //num of vertex or element\nconst int M_MAX = 10010; //num of edge\nconst int DATA_MAX = 1010;\n\nint N;\n\nchar T[N_MAX];\nchar* P[M_MAX];\nvi placeOfP[M_MAX];\n\n\nstruct PMA { //Pattern Matching Automaton\n#ifdef debug\n    string str = \"\";\n#endif\n    PMA* next[128]; //next[0] = failure link\n    vi accept;\n    \n    PMA() { fill(next, next+128, (PMA*)0); }\n};\n\n\nvi set_union(const vi &a, const vi &b) {\n    vi res;\n    set_union(a.begin(), a.end(), b.begin(), b.end(), back_inserter(res) );\n    return res;\n}\n\n\n\nPMA* buildPMA(char* P[], int numOfP) {\n    PMA* root = new PMA;\n#ifdef debug\n    root->str = \"root \";\n#endif\n    \n    //construct PMA according to P[i]\n    rep(i,0,numOfP) {\n        PMA* t = root;\n        \n        for (int j=0; P[i][j]; j++) {\n            char c = P[i][j];\n            if(t->next[c]==NULL) {\n                t->next[c] = new PMA;\n#ifdef debug\n                t->next[c]->str = t->str + c;\n#endif\n            }\n            t = t->next[c];\n        }\n        \n        t->accept.push_back(i);\n    }\n    \n    \n    //make failure link for all node using BFS\n    queue<PMA*> Q;\n    \n    //failure link of root's child ---> root\n    rep(c,'0','z'+1) {\n        if(root->next[c]!=NULL) {\n            root->next[c]->next[0] = root;\n            Q.push(root->next[c]);\n        }\n        else root->next[c] = root; //all other character except for P[] ---> root\n    }\n    \n    //BFS\n    while(!Q.empty()) {\n        \n        PMA* now = Q.front(); Q.pop();\n        \n        rep(c,'0','z'+1) {\n            if(now->next[c]!=NULL) {\n                Q.push(now->next[c]);\n                \n                PMA* failure = now->next[0];\n                while(failure->next[c]==NULL) failure = failure->next[0]; //c??????????????????????????§failure link?????????\n                \n                now->next[c]->next[0] = failure->next[c]; //now->next[c]???failure link?????????\n                now->next[c]->accept = set_union(now->next[c]->accept, failure->next[c]->accept); //now->next[c]????????????????????????failure link?????????????????????????¶????\n            }\n        }\n    }\n    \n    return root;\n}\n\n\n\nvoid match(PMA* v, char *text, vi result[]) {\n    \n    int lenT = strlen(text);\n    \n    rep(i,0,lenT) {\n        char c = text[i];\n        \n        while(v->next[c]==NULL) {\n            v = v->next[0];\n        }\n        \n        v = v->next[c];\n        \n        rep(j,0,v->accept.size()) {\n            result[v->accept[j]].push_back(i+1-strlen(P[v->accept[j]]));\n        }\n    }\n    \n    return;\n}\n\n\n#ifdef debug\nvoid display_DFS(PMA* r) {\n    \n    dout << \"-----\\n\";\n    disp(r->str);\n    \n    dout << \"accept = \";\n    rep(i,0,r->accept.size()) {\n        dout << r->accept[i] << \" \";\n    }\n    dout << endl;\n    \n    rep(c,'0','z'+1) {\n        if(r->next[c]!=NULL && r->next[c]!=r) {\n            display_DFS(r->next[c]);\n        }\n    }\n}\n#endif\n\nint main() {\n    \n    //cin, cout????????????  ?????¨??????cin?????????????????¨??¨cin??§???scanf?????????????????¨??¨scanf??§??±?????????????????????\n    cin.tie(0); //cin??¨cout??????????????????\n    ios::sync_with_stdio(false); //iostream??¨stdio??????????????????\n    \n    //read input data\n    scanf(\"%s\", T);\n    \n    int Q;\n    scanf(\"%d \", &Q);\n    rep(i,0,Q) {\n        P[i] = (char *)malloc(sizeof(char)*DATA_MAX);\n        scanf(\"%s\", P[i]);\n    }\n    \n#ifdef debug\n    disp(T);\n    disp(strlen(T));\n    rep(i,0,Q) { disP(P[i]); disp(strlen(P[i])); }\n#endif\n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //start timer\n    auto startTime = chrono::system_clock::now();\n#endif\n    //------------------------------------------------------------------------------------------\n    \n    \n    //Aho-Corasick Algorithm\n    PMA* root = buildPMA(P, Q);\n    \n#ifdef debug\n    display_DFS(root);\n#endif\n    \n    \n    match(root, T, placeOfP);\n    \n#ifdef debug\n    dout << \"=====================================\\n\";\n    rep(i,0,Q) {\n        disP(P[i]); dout << \" : \";\n        rep(j,0,placeOfP[i].size()) {\n            disP(placeOfP[i][j]);\n        }\n        dout << endl;\n    }\n    dout << \"=====================================\\n\";\n#endif\n    \n    rep(i,0,Q) {\n        printf(\"%d\\n\", placeOfP[i].size()!=0);\n    }\n    \n    \n\n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //stop timer\n    auto endTime = chrono::system_clock::now();\n    auto dur = endTime - startTime;\n    auto msec = chrono::duration_cast<chrono::milliseconds>(dur).count();\n    dout << fixed << setprecision(4) << (double)msec/1000 << \" sec \\n\";\n#endif\n    //------------------------------------------------------------------------------------------\n    \n#ifdef INPUTFILE\n    inputfile.close();\n#endif\n    \n#ifdef OUTPUTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\nusing lint = long long int;\nlong long int INF = 1001001001001001LL;\nint inf = 1000000007;\nlong long int MOD = 1000000007LL;\ndouble PI = 3.1415926535897932;\n\ntemplate<typename T1,typename T2>inline void chmin(T1 &a,const T2 &b){if(a>b) a=b;}\ntemplate<typename T1,typename T2>inline void chmax(T1 &a,const T2 &b){if(a<b) a=b;}\n\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n\n/* do your best */\n// 引用：https://ei1333.github.io/luzhiled/snippets/string/suffix-array.html\n\n// 構築 O(N log N)\nstruct SuffixArray {\n  vector< int > SA;\n  const string s;\n\n  SuffixArray(const string &str) : s(str) {\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](int a, int b) {\n      return s[a] == s[b] ? a > b : s[a] < s[b];\n    });\n    vector< int > classes(s.size()), c(s.begin(), s.end()), cnt(s.size());\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const {\n    return SA[k];\n  }\n\n  size_t size() const {\n    return s.size();\n  }\n\n  bool lt_substr(const string &t, int si = 0, int ti = 0) {\n    int sn = (int) s.size(), tn = (int) t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return true;\n      if(s[si] > t[ti]) return false;\n      ++si, ++ti;\n    }\n    return si >= sn && ti < tn;\n  }\n\n  int lower_bound(const string &t) {\n    int low = -1, high = (int) SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) / 2;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return high;\n  }\n\n  pair< int, int > lower_upper_bound(string &t) {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = (int) SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) / 2;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return {idx, high};\n  }\n\n  void output() {\n    for(int i = 0; i < size(); i++) {\n      cout << i << \": \" << s.substr(SA[i]) << \" \" << SA[i] << endl;\n    }\n  }\n};\n\nstruct LongestCommonPrefixArray {\n  const SuffixArray &SA;\n  vector< int > LCP, rank;\n\n  LongestCommonPrefixArray(const SuffixArray &SA) : SA(SA), LCP(SA.size()) {\n    rank.resize(SA.size());\n    for(int i = 0; i < SA.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    for(int i = 0, h = 0; i < SA.size(); i++) {\n      if(rank[i] + 1 < SA.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < SA.size() && SA.s[i + h] == SA.s[j + h]; ++h);\n        LCP[rank[i] + 1] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const {\n    return LCP[k];\n  }\n\n  size_t size() const {\n    return LCP.size();\n  }\n\n  void output() {\n    for(int i = 0; i < size(); i++) {\n      cout << i << \": \" << LCP[i] << \" \" << SA.s.substr(SA[i]) << endl;\n    }\n  }\n};\n\nbool match(string &s, string &t) {\n  assert(s.size() >= t.size());\n  for (int i = 0; i < t.size(); i++) {\n    if (s[i] != t[i]) return false;\n  }\n  return true;\n}\n\nint main() {\n  \n  string s; cin >> s;\n  SuffixArray sa(s);\n  // 二分探索を用いて，O(m log n) m は検索文字列の長さ\n  int q; cin >> q;\n  while (q--) {\n    string t; cin >> t;\n    auto range = sa.lower_upper_bound(t); \n    cout << (range.first != range.second) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<complex>\n#include<typeinfo>\nusing namespace std;\n\nvector<bool> match(20000, false);\n\nstruct Node{\n    string pat;\n    map<char, int> child;\n    int fail;\n    bool blue;\n    vector<int> patternNum;\n};\n\nbool mapElementCheck(map<char, int> &child, char &c){\n    return child.find(c) != child.end();\n}\n\nvoid concatStringVector(vector<string> &v1, vector<string> &v2){\n    v1.insert(v1.begin(), v2.begin(), v2.end());\n}\n\nvoid concatIntVector(vector<int> &v1, vector<int> &v2){\n    v1.insert(v1.begin(), v2.begin(), v2.end());\n}\n\nvoid printNode(Node &n){\n    cout << endl << \"pat: \" << n.pat << endl;\n    cout << \"child: \" << endl;\n    for (map<char, int>::iterator itr = (n.child).begin();itr!=(n.child).end();itr++){\n        cout << itr->first << \" \" << itr->second << endl;\n    }\n    cout <<\"fail: \" << n.fail << endl;\n    cout << \"blue: \" << n.blue << endl;\n    cout << \"patternNum: \" <<endl;\n    for (int i=0;i<(n.patternNum).size();i++){\n        cout << (n.patternNum)[i] << endl;\n    }\n    cout << endl;\n    return;\n}\n\nvoid insert(vector<Node> &nodes, string &S, int patternNum){\n    int now = 0;\n    for (int i=0;i<S.size();i++){\n        map<char, int>& mp = nodes[now].child;\n        if(mp.find(S[i]) == mp.end()){\n            Node n;\n            n.pat = nodes[now].pat + string(1, S[i]);\n            nodes.push_back(n);\n            (nodes[now].child)[S[i]] = nodes.size()-1;\n            now = nodes.size()-1;\n        }else{\n            now = mp[S[i]];\n        }\n        if(i == S.size()-1){\n                nodes[now].blue = true;\n                (nodes[now].patternNum).push_back(patternNum);\n            }else{\n                nodes[now].blue = false;\n            }\n    }\n    return;\n}\n\nvoid makeFailure(vector<Node> &nodes){\n    queue< pair<int, int> > qu;\n    qu.push(make_pair(0, 0));\n    while(!qu.empty()){\n        pair<int, int> now = qu.front();\n        qu.pop();\n        for (map<char, int>::iterator itr = (nodes[now.first].child).begin();itr!=(nodes[now.first].child).end();itr++){\n            qu.push(make_pair( itr->second, now.first));\n        }\n        if(now.second == 0 || now.first == 0){\n            nodes[now.first].fail = 0;\n        }else{\n            string tmpStr = (nodes[now.first]).pat;\n            char last = tmpStr[tmpStr.size()-1];\n            int ances = nodes[now.second].fail;\n            bool b1 = false;\n            while((nodes[ances].child).find(last) == (nodes[ances].child).end()){\n                if (ances == 0){\n                    b1 = true;\n                    break;\n                }\n                ances = nodes[ances].fail;\n            }\n            if(b1){\n                nodes[now.first].fail = 0;\n            }else{\n                nodes[now.first].fail = (nodes[ances].child)[last];\n                concatIntVector(nodes[now.first].patternNum, nodes[nodes[now.first].fail].patternNum);\n            }\n        }\n    }\n}\n\nvector<Node> makePMA(vector<string> &P){\n    vector<Node> nodes;\n    Node n0;\n    n0.blue = false;\n    nodes.push_back(n0);\n    for (int i=0;i<P.size();i++){\n        insert(nodes, P[i], i);\n    }\n    makeFailure(nodes);\n    return nodes;\n}\n\nvoid PMASesch(vector<Node> &PMA, string &P){\n    int now = 0;\n    for (int i=0;i<P.size();i++){\n        if(!mapElementCheck(PMA[now].child, P[i])){\n            while(!mapElementCheck(PMA[now].child, P[i])){\n                if(now == 0) break;\n                now = PMA[now].fail;\n            }\n        }\n        if (mapElementCheck(PMA[now].child, P[i])){\n            now = (PMA[now].child)[P[i]];\n            for (int j=0;j<(PMA[now].patternNum).size();j++){\n                match[(PMA[now].patternNum)[j]] = true;\n            }\n        }else{\n            now = 0;\n        }\n    }\n}\n\nint main(){\n    string T;\n    cin >> T;\n    int Q;\n    cin >> Q;\n    vector<string> P;\n    string tmp;\n    for (int i=0;i<Q;i++){\n        cin >> tmp;\n        P.push_back(tmp);\n    }\n    vector<Node> PMA = makePMA(P);\n    /*\n    for (int i=0;i<PMA.size();i++){\n        printNode(PMA[i]);\n    }\n    cout << \"makePMA: end\" << endl;\n    */\n    PMASesch(PMA, T);\n    /*\n    cout << \"searchPMA: end\" << endl;\n    */\n    for (int i=0;i<Q;i++){\n        cout << match[i] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(string s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int i, const int j) { \n    int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  \n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  \n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    if(10000 < s.size())assert(false);\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\n\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(string s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  bool operator()(int i, int j) { \n    int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  \n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  \n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  sort(ALL(sa),rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    scanf(\" %s\",&t[0]);\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nclass SuffixArray\n{\nprivate:\n  int n, k;\n  string s;\n  vector<int> rank;\n  vector<int> tmp;\n  bool compare_sa(const int &i, const int &j)\n  {\n    if(rank[i] != rank[j]) return rank[i] < rank[j];\n    else\n    {\n      int ri = i + k <= n ? rank[i+k] : -1;\n      int rj = j + k <= n ? rank[j+k] : -1;\n      return ri < rj;\n    }\n  }\n  void construct_sa()\n  {\n    for(int i = 0; i <= n; i++)\n    {\n      sa[i] = i;\n      rank[i] = i < n ? s[i] : -1;\n    }\n    for(k = 1; k <= n; k*=2)\n    {\n      sort(sa.begin(),sa.end(),*this);\n      tmp[sa[0]] = 0;\n      for(int i = 1; i <= n; i++)\n        tmp[sa[i]] = tmp[sa[i-1]] + (compare_sa(sa[i-1],sa[i])?1:0);\n      for(int i = 0; i <= n; i++)\n        rank[i] = tmp[i];\n    }\n  }\npublic:\n  vector<int> sa;\n  bool operator() (const int &i, const int &j) const\n  {\n    if(rank[i] != rank[j]) return rank[i] < rank[j];\n    else\n    {\n      int ri = i + k <= n ? rank[i+k] : -1;\n      int rj = j + k <= n ? rank[j+k] : -1;\n      return ri < rj;\n    }\n  }\n  SuffixArray(string s):s(s)\n  {\n    n = s.size();\n    rank.resize(n+1);\n    tmp.resize(n+1);\n    sa.resize(n+1);\n    construct_sa();\n  }\n\n  bool contain(string t)\n  {\n    int l=0, r=n;\n    while(r-l>1)\n    {\n      int m = (l+r)/2;\n      if(s.compare(sa[m],t.size(),t)<0) l = m;\n      else r = m;\n    }\n    return s.compare(sa[r],t.size(),t) == 0;\n  }\n};\n\nint main()\n{\n  string s, t; cin >> s;\n  auto sa = SuffixArray(s);\n  int q; cin >> q;\n  REP(i,q)\n  {\n    cin >> t;\n    cout << sa.contain(t) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstring S; string U;\nvector<string>T; int N;\nint main() {\n\tcin >> S >> N;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tint L = S.size() - i;\n\t\tif (L > 1000)L = 1000;\n\t\tT.push_back(S.substr(i, L));\n\t}\n\tsort(T.begin(), T.end());\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> U;\n\t\tint pos = lower_bound(T.begin(), T.end(), U) - T.begin();\n\t\tstring V;\n\t\tif (pos < N) { V = T[pos].substr(0, U.size()); }\n\t\tif (U == V) { cout << \"1\" << endl; }\n\t\telse { cout << \"0\" << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n/2+n%2,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==nc)a[i]=b[j++];\n      else if(j==nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  /*\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n  */\n  int sa[rh.n+1];\n  REP(i,rh.n+1)sa[i]=i;\n  mergesort(rh.n+1,sa,rh);\n  vector<int>res(rh.n+1);\n  REP(i,rh.n+1)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    sa.clear();\n    sa.resize(n+1,0);\n    S.push_back('$');\n    iota(sa.begin(),sa.end(),0);\n    sort(sa.begin(),sa.end(),\n\t [&](int a,int b){\n\t   if(S[a]==S[b]) return a>b;\n\t   return S[a]<S[b];\n\t });\n    vector<int> c(n+1,0),r(n+1),cnt(n+1),s(n+1);\n    for(int i=0;i<=n;i++) r[i]=S[i];\n    for(int len=1;len<=n;len*=2){\n      for(int i=0;i<=n;i++){\n\t c[sa[i]]=\n\t   i>0 &&\n\t   r[sa[i-1]]==r[sa[i]] &&\n\t   sa[i-1]+len<=n &&\n\t   r[sa[i-1]+len/2]==r[sa[i]+len/2] ?\n\t   c[sa[i-1]]:i;\n      }\n      iota(cnt.begin(),cnt.end(),0);\n      copy(sa.begin(),sa.end(),r.begin());\n      for(int i=0;i<=n;i++){\n\tint s1=r[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n      c.swap(r);\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    lcp.clear();\n    lcp.resize(n+1,0);\n    vector<int> r2(n+1);\n    for(int i=0;i<=n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "// +-------------------------------\n// | Suffix Array Library Ver.1.2\n// | Author: square1001\n// | Required:\n// |   #include <string>\n// |   #include <vector>\n// |   #include <algorithm>\n// |   using namespace std;\n// +-------------------------------\n\n// +-------------------------------\n// | CEB --> Create End Bucket\n// | ISort --> Induced Sort\n// | IISort --> Invert Induced Sort\n// +-------------------------------\n\n// ------ Required ------ //\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// ------ Function ------ //\ninline unsigned int __builtin_clz(unsigned int x) { unsigned long r; _BitScanReverse(&r, x); return 31 - r; }\n\n// ------ Suffix Array ------ //\nclass SuffixArray {\n\tvoid CEB(vector<int> &v, vector<int> &b) {\n\t\tint vs = v.size(), bs = b.size();\n\t\tfill(b.begin(), b.end(), 0);\n\t\tfor (int i = 0; i < vs; i++) b[v[i]]++;\n\t\tfor (int i = 1; i < bs; i++) b[i] += b[i - 1];\n\t}\n\tvoid ISort(vector<int> &v, vector<int> &SA, int mv, vector<int> &b, vector<int> &isL) {\n\t\tint vs = v.size(), bs = b.size();\n\t\tfill(b.begin(), b.end(), 0);\n\t\tfor (int i = 0; i < vs; i++) b[v[i]]++;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < bs; i++) b[i] += sum, swap(sum, b[i]);\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (SA[i] > 0 && isL[SA[i] - 1]) SA[b[v[SA[i] - 1]]++] = SA[i] - 1;\n\t\t}\n\t}\n\tvoid IISort(vector<int> &v, vector<int> &SA, int mv, vector<int> &b, vector<int> &isL) {\n\t\tCEB(v, b);\n\t\tfor (int i = v.size() - 1; i >= 0; i--) {\n\t\t\tif (SA[i] > 0 && !isL[SA[i] - 1]) SA[--b[v[SA[i] - 1]]] = SA[i] - 1;\n\t\t}\n\t}\n\tvector<int>SA_IS(vector<int> v, int mv) {\n\t\tint vs = v.size();\n\t\tif (vs == 1) return vector<int>(1, 0);\n\t\tvector<int> isL(vs), b(mv + 1), SA(vs, -1), ord(vs);\n\t\tauto isLMS = [&](int x)->bool { return x > 0 && isL[x - 1] && !isL[x]; };\n\t\tfor (int i = vs - 2; i >= 0; i--) isL[i] = (v[i] > v[i + 1]) || (v[i] == v[i + 1] && isL[i + 1]);\n\t\tCEB(v, b);\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) SA[--b[v[i]]] = i;\n\t\t}\n\t\tISort(v, SA, mv, b, isL);\n\t\tIISort(v, SA, mv, b, isL);\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) ord[i] = cur++;\n\t\t}\n\t\tvector<int> nxv(cur);\n\t\tcur = -1;\n\t\tint prev = -1;\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (!isLMS(SA[i])) continue;\n\t\t\tbool diff = false;\n\t\t\tfor (int d = 0; d < vs; d++) {\n\t\t\t\tif (prev == -1 || v[SA[i] + d] != v[prev + d] || isL[SA[i] + d] != isL[prev + d]) {\n\t\t\t\t\tdiff = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (d && isLMS(SA[i] + d))break;\n\t\t\t}\n\t\t\tif (diff) cur++, prev = SA[i];\n\t\t\tnxv[ord[SA[i]]] = cur;\n\t\t}\n\t\tvector<int> reord(nxv.size());\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) reord[ord[i]] = i;\n\t\t}\n\t\tvector<int> nxSA = SA_IS(nxv, cur);\n\t\tCEB(v, b);\n\t\tfor (int i = 0; i < SA.size(); i++) SA[i] = -1;\n\t\tfor (int i = nxSA.size() - 1; i >= 0; i--) {\n\t\t\tSA[--b[v[reord[nxSA[i]]]]] = reord[nxSA[i]];\n\t\t}\n\t\tISort(v, SA, mv, b, isL);\n\t\tIISort(v, SA, mv, b, isL);\n\t\treturn SA;\n\t}\n\tvector<int>SA_IS(string s) {\n\t\tvector<int> v(s.size() + 1);\n\t\tfor (int i = 0; i < s.size(); i++) v[i] = s[i] + 1;\n\t\treturn SA_IS(v, *max_element(v.begin(), v.end()));\n\t}\n\tvector<int>construct_lcp(string &s, vector<int> &sa) {\n\t\tvector<int> lcp, rank(s.size() + 1);\n\t\tint n = s.size(), h = 0;\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (s[j + h] != s[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\npublic:\n\tstring s;\n\tvector<int> sa, lcp;\n\tvoid init(string &T) {\n\t\ts = T;\n\t\tsa = SA_IS(s);\n\t}\n\tSuffixArray(string &t) { init(t); }\n\tSuffixArray() {}\n\tbool contain(string &t) {\n\t\tint a = 0, b = s.size();\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (s.compare(sa[c], t.size(), t) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn s.compare(sa[b], t.size(), t) == 0;\n\t}\n};"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nclass SA_IS\n{\nprivate:\n    using byte = unsigned char;\n    byte mask[8] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };\n    #define tget(i) !!(t[(i)>>3]&mask[(i)&7])\n    #define tset(i, b) t[(i)>>3]=(b) ? (mask[(i)&7]|t[(i)>>3]) : ((~mask[(i)&7])&t[(i)>>3])\n    #define chr(i) (cs==sizeof(int)?((int*)s)[i]:((byte *)s)[i])\n    #define isLMS(i) (i>0 && tget(i) && !tget(i-1))\n    void getBuckets(byte *s, int *bkt, int n, int K, int cs, bool end=true){\n        fill(bkt, bkt + K + 1, 0);\n        for(int i = 0; i < n; i++){\n            bkt[chr(i)]++;\n        }\n        for(int i = 0,tmp = 0; i < K+1; i++){\n            tmp += bkt[i];\n            bkt[i] = end ? tmp : tmp - bkt[i];\n        }\n    }\n    void induceSAl(byte *t, byte *s, int *bkt, int n, int K, int cs){\n        getBuckets(s, bkt, n, K, cs, false);\n        for(int i = 0; i < n; i++){\n            if(sa[i]>0 && !tget(sa[i]-1)){\n                sa[bkt[chr(sa[i]-1)]++] = sa[i]-1;\n            }\n        }\n    }\n    void induceSAs(byte *t, byte *s, int *bkt, int n, int K, int cs){\n        getBuckets(s, bkt, n, K, cs, true);\n        for(int i = n-1; i >= 0; i--){\n            if(sa[i] > 0 && tget(sa[i]-1)){\n                sa[--bkt[chr(sa[i]-1)]] = sa[i]-1;\n            }\n        }\n    }\n    void solve(byte *s, int n, int K=128, int cs=1){\n        byte t[(n >> 3)+1];\n        int bkt[K+1], n1 = 0, name = 0;\n        tset(n-2, 0), tset(n-1, 1);\n        for(int i = n - 3; i >=0; i--){\n            tset(i, (chr(i)<chr(i+1) || (chr(i)==chr(i+1) && tget(i+1))));\n        }\n        getBuckets(s, bkt, n, K, cs);\n        fill(sa, sa+n, -1);\n        for(int i = 1; i < n; i++){\n            if(isLMS(i)){\n                sa[--bkt[chr(i)]] = i;\n            }\n        }\n        induceSAl(t, s, bkt, n, K, cs);\n        induceSAs(t, s, bkt, n, K, cs);\n        for(int i = 0; i < n; i++){\n            if(isLMS(sa[i])){\n                sa[n1++] = sa[i];\n            }\n        }\n        fill(sa + n1, sa + n, -1);\n        for(int i = 0, tmp = -1; i < n1; i++){\n            int pos = sa[i], diff = false;\n            for(int d = 0; d < n && !diff; d++){\n                diff = chr(pos+d) != chr(tmp+d) || tget(pos+d) != tget(tmp+d);\n                if(!diff && d && (isLMS(pos+d) || isLMS(tmp+d))) break;\n            }\n            if(diff){\n                name++, tmp = pos;\n            }\n            sa[n1+((pos - (pos & 1)) >> 1)] = name - 1;\n        }\n        int* s1 = sa + n - n1;\n        for(int i = n - 1,j = n - 1; i >= n1; i--){\n            if(sa[i] >= 0){\n                sa[j--] = sa[i];\n            }\n        }\n        if(name < n1){\n            solve((byte*)s1, n1, name - 1, sizeof(int));\n        }else{\n            for(int i = 0; i < n1; i++){\n                sa[s1[i]] = i;\n            }\n        }\n        getBuckets(s, bkt, n, K, cs);\n        for(int i = 1, j = 0; i < n; i++){\n            if(isLMS(i)){\n                s1[j++] = i;\n            }\n        }\n        for(int i = 0; i < n1; i++){\n            sa[i] = s1[sa[i]];\n        }\n        fill(sa + n1, sa + n, -1);\n        for(int i = n1 - 1; i >= 0; i--){\n          int tmp = sa[i];\n          sa[i] = -1, sa[--bkt[chr(tmp)]] = tmp;\n        }\n        induceSAl(t, s, bkt, n, K, cs);\n        induceSAs(t, s, bkt, n, K, cs);\n    }\npublic:\n    bool contain(const string& T){\n        string SS = string((char*)S);\n        int a = 0, b = sz;\n        while(b - a > 1){\n            int c = (a + b) / 2;\n            if(SS.compare(sa[c], T.length(), T) < 0){\n                a = c;\n            }else{\n                b = c;\n            }\n        }\n        return SS.compare(sa[b], T.length(), T) == 0;\n    }\n    byte* S;\n    int sz;\n    int* sa;\n    SA_IS(string& arg){\n        sz = (int)arg.size();\n        sa = new int[sz+1];\n        S = (byte*)arg.c_str();\n        solve(S, sz+1);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    SA_IS sa(s);\n    int n;\n    cin >> n;\n    rep(i,n){\n        string t;\n        cin >> t;\n        cout << sa.contain(t) << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\n\nstruct PMA{\n    PMA *next[256];\n    Vec matched;\n    PMA(){ fill(next,next+256,(PMA*)0); }\n};\n\nVec set_union(const Vec &a,const Vec &b){\n    int i = 0, j = 0, A = a.size(), B = b.size();\n    Vec res;\n    while(i < A && j < B){\n        if(a[i] == b[j]){\n            res.push_back(a[i]);\n            i++; j++;\n        }else if(a[i] > b[j]){\n            res.push_back(b[j++]);\n        }else{\n            res.push_back(a[i++]);\n        }\n    }\n    for( ; i < A ; i++) res.push_back(a[i]);\n    for( ; j < B ; j++) res.push_back(b[j]);\n    return res;\n}\n\nPMA *buildPMA(char *pattern[],int size){\n    PMA *root = new PMA;\n    for(int i = 0 ; i < size ; i++){\n        PMA *t = root;\n        for(int j = 0 ; pattern[i][j] != '\\0' ; j++){\n            char c = pattern[i][j];\n            if(t->next[c] == NULL) t->next[c] = new PMA;\n            t = t->next[c];\n        }\n        t->matched.push_back(i);\n    }\n    queue<PMA*> Q;\n    for(int i = 1 ; i < 256 ; i++){\n        if(root->next[i]){\n            root->next[i]->next[0] = root;\n            Q.push(root->next[i]);\n        }else{\n            root->next[i] = root;\n        }\n    }\n    while(!Q.empty()){\n        PMA *t = Q.front(); Q.pop();\n        for(int i = 1 ; i < 256 ; i++){\n            if(t->next[i]){\n                PMA *next = t->next[0];\n                while(!next->next[i]) next = next->next[0];\n                t->next[i]->next[0] = next->next[i];\n                t->next[i]->matched =\n                    set_union(t->next[i]->matched,next->next[i]->matched);\n                Q.push(t->next[i]);\n            }\n        }\n    }\n    return root;\n}\n\nvoid match(PMA *pma,const char *s,Vec &res){\n    for(int i = 0 ; s[i] != '\\0' ; i++){\n        int c = s[i];\n        while(!pma->next[c]) pma = pma->next[0];\n        pma = pma->next[c];\n        for(int j = 0 ; j < (int)pma->matched.size() ; j++){\n            res[pma->matched[j]] = 1;\n        }\n    }\n}\n\nchar T[1000001];\nchar *P[10000];\n\nint main(){\n    int Q;\n    scanf(\"%s%d\",T,&Q);\n    for(int i = 0 ; i < Q ; i++){\n        P[i] = new char;\n        scanf(\"%s\",P[i]);\n    }\n    PMA *pma = buildPMA(P,Q);\n    Vec res(Q, 0);\n    match(pma,T,res);\n    for(auto x : res){\n        printf(\"%d\\n\",x);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    S.push_back('$');\n    vector<int> c(n+1,0),ord(n+1,0);\n    for(int i=0;i<=n;i++) ord[i]=n-i;\n    sort(ord.begin(),ord.end(),[&](int a,int b){return S[a]<S[b];});\n    for(int i=0;i<=n;i++){\n      sa[i]=ord[i];\n      c[i]=S[i];\n    }\n    for(int len=1;len<=n;len*=2){\n      vector<int> r=c;\n      for(int i=0;i<=n;i++){\n\t c[sa[i]] =\n\t   i > 0 &&\n\t   r[sa[i - 1]] == r[sa[i]] &&\n\t   sa[i - 1] + len <= n &&\n\t   r[sa[i - 1] + len / 2] == r[sa[i] + len / 2]\n\t   ? c[sa[i - 1]] : i;\n      }\n      vector<int> cnt(n+1);\n      for(int i=0;i<=n;i++) cnt[i]=i;\n      vector<int> s=sa;\n      for(int i=0;i<=n;i++){\n\tint s1=s[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n+1);\n    for(int i=0;i<=n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    //assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\nusing namespace std;\nstring S, T;\nint main() {\n\tint q,sum;\n\tcin >> S;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tsum = 0;\n\t\tcin >> T;\n\t\tif (S.size() >= T.size()) {\n\t\t\tfor (int i = 0; i <= S.size() - T.size(); i++) {\n\t\t\t\tif(i>=100 && q>=10000){\n\t\t\t\t\tgoto Exit2;\n\t\t\t\t}\n\t\t\t\tif (T == S.substr(i, T.size())) {\n\t\t\t\t\tcout << \"1\" << endl;\n\t\t\t\t\tgoto Exit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tExit2:;\n\t\tcout << \"0\" << endl;\n\tExit:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nclass suffix_array{\n    void create_begin_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        int sum=0;\n        for(int i=0;i<bucket.size();i++){bucket[i]+=sum;swap(sum,bucket[i]);}\n    }\n\n    void create_end_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        for(int i=1;i<bucket.size();i++)bucket[i]+=bucket[i-1];\n    }\n\n    void induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_begin_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(sa[i]>0&&is_l[sa[i]-1])sa[bucket[v[sa[i]-1]]++]=sa[i]-1;\n    }\n\n    void invert_induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_end_bucket(v,bucket);\n        for(int i=v.size()-1;i>=0;i--)if(sa[i]>0&&!is_l[sa[i]-1])sa[--bucket[v[sa[i]-1]]]=sa[i]-1;\n    }\n\n    vector<int>sa_is(vector<int>v,int mv){\n        if(v.size()==1)return vector<int>(1,0);\n\n        vector<int>is_l(v.size());\n        vector<int>bucket(mv+1);\n        vector<int>sa(v.size(),-1);\n        auto is_lms=[&](int x)->bool{return x>0&&is_l[x-1]&&!is_l[x];};\n\n        is_l[v.size()-1]=0;\n        for(int i=v.size()-2;i>=0;i--)is_l[i]=v[i]>v[i+1]||(v[i]==v[i+1]&&is_l[i+1]);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(is_lms(i))sa[--bucket[v[i]]]=i;\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n\n        int cur=0;\n        vector<int>order(v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))order[i]=cur++;\n\n        vector<int>next_v(cur);\n        cur=-1;\n        int prev=-1;\n        for(int i=0;i<v.size();i++){\n            if(!is_lms(sa[i]))continue;\n            bool diff=false;\n            for(int d=0;d<v.size();d++){\n                if(prev==-1||v[sa[i]+d]!=v[prev+d]||is_l[sa[i]+d]!=is_l[prev+d]){\n                    diff=true;\n                    break;\n                }\n                else if(d>0&&is_lms(sa[i]+d))break;\n            }\n            if(diff){cur++;prev=sa[i];}\n            next_v[order[sa[i]]]=cur;\n        }\n\n        vector<int>re_order(next_v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))re_order[order[i]]=i;\n        vector<int>next_sa=sa_is(next_v,cur);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<sa.size();i++)sa[i]=-1;\n        for(int i=next_sa.size()-1;i>=0;i--)sa[--bucket[v[re_order[next_sa[i]]]]]=re_order[next_sa[i]];\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n        return sa;\n    }\n\n    vector<int>sa_is(string &s){\n        vector<int>v(s.size()+1);\n        for(int i=0;i<s.size();i++)v[i]=s[i];\n        sa=sa_is(v,*max_element(v.begin(),v.end()));\n    }\n\n    void construct_lcp(){\n        lcp.resize(s.size());\n        rank.resize(s.size()+1);\n        int n=s.size();\n        for(int i=0;i<=n;i++)rank[sa[i]]=i;\n        int h=0;\n        lcp[0]=0;\n        for(int i=0;i<n;i++){\n            int j=sa[rank[i]-1];\n\n            if(h>0)h--;\n            for(;j+h<n&&i+h<n;h++){\n                if(s[j+h]!=s[i+h])break;\n            }\n            lcp[rank[i]-1]=h;\n        }\n    }\n\n    class sparse_table{\n        vector<vector<int> >st;\n    public:\n        void init(vector<int>&v){\n            int b;\n            for(b=0;(1<<b)<=v.size();b++);\n            return;\n            st.assign(b,vector<int>(1<<b));\n            for(int i=0;i<v.size();i++)st[0][i]=v[i];\n            for(int i=1;i<b;i++){\n                for(int j=0;j+(1<<i)<=(1<<b);j++){\n                    st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);\n                }\n            }\n        }\n        int get_min(int l,int r){\n            assert(l<r);\n            int b=32-__builtin_clz(r-l)-1;\n            return min(st[b][l],st[b][r-(1<<b)]);\n        }\n        sparse_table(){}\n        sparse_table(vector<int>&v){init(v);}\n    };\n    sparse_table st;\npublic:\n    string s;\n    vector<int>sa,lcp,rank;\n    void init(string &t){\n        s=t;\n        sa_is(s);\n        construct_lcp();\n        st.init(lcp);\n    }\n    suffix_array(string &t){init(t);}\n    suffix_array(){}\n\n    bool contain(string &t){\n        int lb=0,ub=s.size();\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            if(s.compare(sa[mid],t.size(),t)<0)lb=mid;\n            else ub=mid;\n        }\n        return s.compare(sa[ub],t.size(),t)==0;\n    }\n\n    int get_lcp(int i,int j){\n        if(rank[i]>rank[j])swap(i,j);\n        return st.get_min(rank[i],rank[j]);\n    }\n};\n\nsigned main(){\n    string s;cin>>s;\n    suffix_array sa(s);\n    int q;cin>>q;\n    while(q--){\n        string t;\n        cin>>t;\n        cout<<sa.contain(t)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) { \n    const int k=lcp(i,j);\n    //const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    //const int k=lcp2(i,j,0,(n-max(i,j))*2+1);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  \n  inline bool cmp(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    //const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    //const int k=lcp2(i,j,0,(n-max(i,j))*2+1);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n  \n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    //int l=0,r=min(n-i,n-j)+1;\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n  \n  /*\n  inline int lcp2(const int& i, const int& j, const int& l, const int& r){\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n  */\n};\n\nvoid quicksort(vector<int> &a, const int& l, const int& r, const RollingHash &rh) {\n  if (rh.cmp(l,r)) {\n    int p = a[(l+r)/2];\n    int i = l-1, j = r+1;\n    while (1) {\n      while (a[++i] < p);\n      while (a[--j] > p);\n      if (i >= j) break;\n      swap(a[i], a[j]);\n    }\n    quicksort(a, l, i-1,rh);\n    quicksort(a, j+1, r,rh);\n  }\n}\nvoid quicksort(vector<int> &a, const RollingHash& rh) {\n  quicksort(a, 0, a.size()-1,rh);\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  //sort(ALL(sa),rh);\n  quicksort(sa,rh);\nif(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\nclass suffix_array{\nprivate:\n    typedef unsigned long ul;\n    \n    struct node{\n        ll begin;\n        ll Rank;\n        node* next;\n        \n        inline bool operator < (const node &N) const {\n            if(Rank==N.Rank){\n                return (next==NULL?-1:next->Rank)<(N.next==NULL?-1:N.next->Rank);\n            }\n            return Rank<N.Rank;\n        }\n        \n        node(ll begin=0,ll Rank=0,node* next=NULL):begin(begin),Rank(Rank),next(next){}\n    };\n    \n    inline static bool pointer_cmp(node* &a,node* &b){return (*a)<(*b);}\n    \n    vector<node*> sa;\n    vector<ll> Rank;\n    const string s;\n    \n    void build(){\n        for(int i=0;i<s.size();i++){\n            *sa[i]={i,s[i],sa[i+1]};\n        }\n        sa[s.size()]->begin=s.size();\n        sa[s.size()]->Rank=-1;\n        sa[s.size()]->next=NULL;\n        vector<node*> Next(s.size()+1);\n        for(ll k=1;k<=s.size();k<<=1){\n            sort(sa.begin(),sa.end(),pointer_cmp);\n            Rank[sa[0]->begin]=0;\n            Next[0]=(sa[0]->next==NULL?NULL:sa[0]->next->next);\n            for(int i=1;i<=s.size();i++){\n                Rank[sa[i]->begin]=Rank[sa[i-1]->begin]+(*sa[i-1]<*sa[i]?1:0);\n                Next[i]=(sa[i]->next==NULL?NULL:sa[i]->next->next);\n            }\n            for(int i=0;i<=s.size();i++){\n                sa[i]->Rank=Rank[sa[i]->begin];\n                sa[i]->next=Next[i];\n            }\n        }\n        for(int i=0;i<=s.size();i++){\n            Next[sa[i]->begin]=sa[i];\n        }\n        for(int i=0;i<=s.size();i++){\n            sa[i]->next=sa[i]->begin==s.size()?NULL:Next[sa[i]->begin+1];\n        }\n    }\n    \n    //1::greater 0::same -1::less\n    int compare(const ul &saf,const string &str){\n        for(int i=0;i<str.size();i++){\n            if(sa[saf]->begin+i>=s.size()){return -1;}\n            if(s[sa[saf]->begin+i]!=str[i]){return s[sa[saf]->begin+i]<str[i]?-1:1;}\n        }\n        return 0;\n    }\n    \npublic:\n    suffix_array(const string &str):s(str),Rank(str.size()+1),sa(str.size()+1){\n        for(int i=0;i<=str.size();i++){\n            sa[i]=(node*)malloc(sizeof(node));\n        }\n        build();\n    }\n    \n    ll rank(const ul &where) const {return Rank[where];}\n    \n    ul size() const {return sa.size();}\n    \n    const node & operator [] (const ul &where) const {return *sa[where];}\n    \n    //返すのはsuffixの番号\n    ul lower_bound(const string &sub){\n        ll l=0;\n        ll r=s.size();\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            if(compare(m,sub)==-1){l=m+1;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(compare(i,sub)>=0){return i;}\n        }\n        return r+1;\n    }\n    \n    //返すのはsuffixの番号\n    ul upper_bound(const string &sub){\n        ll l=0;\n        ll r=s.size();\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            if(compare(m,sub)<=0){l=m+1;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(compare(i,sub)>0){return i;}\n        }\n        return r+1;\n    }\n    \n    bool match(const string &sub){\n        ll l=0;\n        ll r=s.size();\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            int st=compare(m,sub);\n            if(st==0){return true;}\n            else if(st==-1){l=m+1;}\n            else{r=m-1;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(compare(i,sub)==0){return true;}\n        }\n        return false;\n    }\n};\n\n\nint main(){\n    string t;\n    cin>>t;\n    suffix_array S(t);\n    ll q;\n    cin>>q;\n    while(q--){\n        string p;\n        cin>>p;\n        cout<<S.match(p)<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef Suffix_array_hpp\n#define Suffix_array_hpp\n\n#include <algorithm>\n#include <vector>\n#include <numeric>\n\ntemplate <class str_type>\nclass suffix_array\n{\n    static constexpr size_t npos = -1;\n    const str_type str;\n    std::vector<size_t> ary, rank;\n\npublic:\n    using value_type = typename str_type::value_type;\n\n    operator std::vector<size_t>() const { return ary; }\n\n    std::vector<size_t>::const_iterator begin() const { return ary.begin(); }\n    std::vector<size_t>::const_iterator end() const { return ary.end(); }\n\n    size_t operator[](size_t i) const { return ary[i]; }\n\n    const str_type &string() const { return str; }\n\n    size_t size() const { return str.size(); }\n\n    suffix_array(const str_type &_str) : str(_str), ary(str.size()), rank(str.size())\n    {\n        std::iota(ary.begin(), ary.end(), 0);\n        std::sort(ary.begin(), ary.end(), [&](size_t i, size_t j){return str[i] < str[j];});\n\n        for(size_t r{1}, c{}, *ptr{&ary.front()}, *tmp{ptr}; c != str.size(); ++r, ptr = tmp)\n            while(c != str.size() && str[*ptr] == str[*tmp])\n                ++c, rank[*tmp++] = r;\n\n        for(size_t k{1}; k < str.size(); k <<= 1)\n        {\n            auto comp = [&](size_t i, size_t j) -> bool\n            {\n                if(rank[i] != rank[j]) return rank[i] < rank[j];\n                return (i + k < str.size() ? rank[i + k] : 0) < (j + k < str.size() ? rank[j + k] : 0);\n            };\n            std::sort(ary.begin(), ary.end(), comp);\n\n            std::vector<size_t> next_rank(str.size());\n            for(size_t r{1}, c{}, *ptr{&ary.front()}, *tmp{ptr}; c != str.size(); ++r, ptr = tmp)\n                while(c != str.size() && !comp(*ptr, *tmp))\n                    ++c, next_rank[*tmp++] = r;\n            rank.swap(next_rank);\n        }\n    }\n\n    size_t find(const str_type &key) const\n    {\n        using std::begin; using std::end;\n\n        size_t lower{npos}, upper{str.size()};\n        while(upper - lower > 1)\n        {\n            size_t mid{(lower + upper) >> 1};\n            bool less{};\n            for(auto i{begin(str) + ary[mid]}, j{begin(key)}; j != end(key); ++i, ++j)\n            {\n                if(i == end(str) || *i < *j)\n                {\n                    less = true;\n                    break;\n                }\n                if(*i > *j) break;\n            }\n            (less ? lower : upper) = mid;\n        }\n\n        if(upper == str.size()) return npos;\n        for(auto i{begin(str) + ary[upper]}, j{begin(key)}; j != end(key); ++i, ++j)\n            if(i == end(str) || *i != *j)\n                return npos;\n        return ary[upper];\n    }\n}; // class suffix_array\n\n#endif // Suffix_array_hpp\n\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nmain()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    string str; cin>>str;\n    suffix_array<string> sa(str);\n\n    int Q;\n    for(cin>>Q; Q--; )\n    {\n        string s; cin>>s;\n        cout << bool(~sa.find(s)) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\n\ntypedef struct SAManberMyers_ {\n  string s;\n  vector<int> rank;\n  vector<int> tmp;\n  vector<int> sa;\n  int n, k;\n  SAManberMyers_(string ss){\n    s = ss;\n    n = s.size();\n    rank.resize(n + 1);\n    tmp.resize(n + 1);\n    sa.resize(n + 1);\n    k = 0;\n\n    // construct suffix array\n    construct();\n  }\n  bool comp(const int &a, const int &b){\n    if(rank[a] != rank[b])return rank[a] < rank[b];\n    int ra = a + k <= n ? rank[a + k] : -1;\n    int rb = b + k <= n ? rank[b + k] : -1;\n    return ra < rb;\n  }\n  void construct(){\n    for(int i = 0; i <= n; i++){\n      sa[i] = i;\n      rank[i] = i < n ? s[i] : -1;\n    }\n\n    for(k = 1; k <= n; k *= 2){\n      sort(sa.begin(), sa.end(), [this] (const int &a, const int &b) {return comp(a, b);});\n\n      tmp[sa[0]] = 0;\n      for(int i = 1; i <= n; i++){\n        tmp[sa[i]] = tmp[sa[i-1]] + (comp(sa[i-1], sa[i]) ? 1 : 0);\n      }\n      for(int i = 0; i <= n; i++){\n        rank[i] = tmp[i];\n      }\n    }\n  }\n} SAManberMyers;\n\nvector<int> sa_search_(SAManberMyers &sa, string s, string t){\n  vector<int> res;\n  t += \"$\";\n  s += \"$\";\n  int ld = -1;\n  int rd = sa.sa.size() - 1;\n  while(rd - ld > 1){\n    int md = (rd + ld) / 2;\n    if(s.substr(sa.sa[md]) < t)ld = md;\n    else rd = md;\n  }\n  t = t.substr(0, t.size() - 1);\n  while(rd < sa.sa.size()){\n    if(s.substr(sa.sa[rd], t.size()) != t)break;\n    res.push_back(sa.sa[rd]);\n    rd++;\n  }\n  sort(res.begin(), res.end());\n  return res;\n}\n\nvector<int> sa_search(string s, string t){\n  SAManberMyers sa(s);\n  vector<int> res = sa_search_(sa, s, t);\n  return res;\n}\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  SAManberMyers sa(s);\n  int q;\n  cin >> q;\n  rep(i, q){\n    string p;\n    cin >> p;\n    auto res = sa_search_(sa, s, p);\n    if(sz(res) >= 1)cout << 1 << endl;\n    else cout << 0 << endl;\n  }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint Q, doubles, lengths, dat[1000009], tmp[1000009], arrays[1000009]; string S, T;\nbool compare_suffix(int i, int j) {\n\tif (dat[i] == dat[j]) {\n\t\tint ri = (i + doubles <= lengths ? dat[i + doubles] : -1);\n\t\tint rj = (j + doubles <= lengths ? dat[j + doubles] : -1);\n\t\treturn ri < rj;\n\t}\n\treturn dat[i] < dat[j];\n}\nvoid suffix_array() {\n\tlengths = S.size();\n\tfor (int i = 0; i <= lengths; i++) arrays[i] = i, dat[i] = i < lengths ? S[i] : -1;\n\tfor (doubles = 1; doubles <= lengths; doubles <<= 1) {\n\t\tsort(arrays.begin(), arrays.begin() + lengths + 1, compare_suffix);\n\t\ttmp[arrays[0]] = 0;\n\t\tfor (int i = 1; i <= lengths; i++) tmp[arrays[i]] = tmp[arrays[i - 1]] + (compare_suffix(arrays[i - 1], arrays[i]) ? 1 : 0);\n\t\tfor (int i = 0; i <= lengths; i++) dat[i] = tmp[i];\n\t}\n}\nstring S, T; int Q;\nint main() {\n\tcin >> S >> Q;\n\tsuffix_array(S);\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> T;\n\t\tint l = 0, r = sa.size(); bool flag = false;\n\t\twhile (r - l > 1) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tstring S1 = S.substr(sa[m], T.size());\n\t\t\tif (S1 == T) {\n\t\t\t\tflag = true; break;\n\t\t\t}\n\t\t\tif (S1 < T) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tprintf(flag ? \"1\\n\" : \"0\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <numeric>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint Q; string s; vector<int> sa; vector<unsigned long long> p, h;\nunsigned long long gethash(int l, int r) {\n\treturn h[r] - h[l] * p[r - l];\n}\nint lcp(int x, int y) {\n\tint l = 0, r = min(s.size() - x, s.size() - y) + 1;\n\twhile (r - l > 1) {\n\t\tint m = (l + r) >> 1;\n\t\tif (gethash(x, x + m) == gethash(y, y + m)) l = m;\n\t\telse r = m;\n\t}\n\treturn l;\n}\nbool compare_sa(int i, int j) {\n\tint k = lcp(i, j);\n\tif (i + k >= s.size()) return true;\n\tif (j + k >= s.size()) return false;\n\treturn s[i + k] <= s[j + k];\n}\nbool contain(string &t) {\n\tint a = 0, b = s.size();\n\twhile (b - a > 1) {\n\t\tint c = (a + b) >> 1;\n\t\tif (s.compare(sa[c], t.size(), t) < 0) a = c;\n\t\telse b = c;\n\t}\n\treturn s.compare(sa[b], t.size(), t) == 0;\n}\nint main() {\n\tcin >> s >> Q;\n\tp.resize(s.size() + 1); p[0] = 1;\n\th.resize(s.size() + 1);\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tp[i + 1] = p[i] * 265;\n\t\th[i + 1] = h[i] * 265 + s[i];\n\t}\n\tsa.resize(s.size() + 1);\n\tiota(sa.begin(), sa.end(), 0);\n\tsort(sa.begin(), sa.end(), compare_sa);\n\tfor (int i = 0; i < Q; i++) {\n\t\tstring t; cin >> t;\n\t\tcout << contain(t) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n\n#define MAX_N 1000005\n\nusing namespace std;\n\n\nint n,k;\nint rank[MAX_N + 1];\nint tmp[MAX_N + 1];\nint sa[MAX_N + 1];\n\n\nbool compare_sa(int i, int j)\n{\n\tif(rank[i] != rank[j]) \n\t{\n\t\treturn rank[i] < rank[j];\n\t}\n\telse\n\t{\n\tint ri =( i + k <= n )? rank[i + k] : -1;\n\tint rj =( j + k <= n )? rank[j + k] : -1;\n\treturn ri < rj;\n\t}\n}\n\nvoid construct_sa(string s,int* sa)\n{\n\tn = s.length();\n\t\n\tfor(int i = 0; i <= n;i++)\n\t{\n\t\tsa[i] = i;\n\t\trank[i] = i < n ? s[i] : -1;\n\t}\n\t\n\tfor(k = 1;k <= n ; k *= 2)\n\t{\n\t\tsort(sa,sa + n + 1,compare_sa);\n\t\t\n\t\ttmp[sa[0]] = 0;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\ttmp[sa[i]] = tmp[sa[i -1]] + (compare_sa(sa[i - 1],sa[i]) ? 1 : 0);\n\t\t}\n\t\tfor(int i = 0;i <= n;i++)\n\t\t{\n\t\t\trank[i] = tmp[i];\n\t\t}\n\t}\n}\n\nbool contain(string s,int* sa, string t)\n{\n\tint a = 0,b = s.length();\n\twhile(b - a > 1)\n\t{\n\t\tint c = (a + b) / 2;\n\t\t\n\t\tif(s.compare(sa[c],t.length(),t) < 0) a = c;\n\t\telse b = c;\n\t}\n\t\n\treturn (s.compare(sa[b], t.length(),t) == 0);\n\t\n}\n\n\nint main()\n{\n\tstring S;\n\tint N;\n\t\n\t\n\tcin >> S; \n\tcin >> N;\n\t\n\tconstruct_sa(S,sa);\n\t\n\tfor(int i = 0 ;i < N;i++)\n\t{\n\t\tstring T;\n\t\tcin >> T;\n\t\tif(contain(S,sa,T)) cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\n#define NUM 48\nusing namespace std;\n\nint T_char_count[128] = {0},P_char_count[128];\n\nclass LocRecord{\n\npublic:\n\t//?????¢???????¢????\n\tLocRecord(){\n\t\tlocationTable = new int*[128];\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t}\n\n\t//-1?????£??\\\n\tvoid init(){\n\t\tint limit;\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init_index(){\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t}\n\n\tvoid regist_loc(int ch, int location){\n\t\tlocationTable[ch][index[ch]] = location;\n\t\tindex[ch]++;\n\t}\n\n\tint next_loc(int ch){\n\t\tint ret = locationTable[ch][index[ch]];\n\t\tindex[ch]++;\n\t\treturn ret;\n\t}\n\nprivate:\n\tint** locationTable;\n\tint index[128];\n};\n\nint main(){\n\n\tfor(int i = 0; i < 128; i++)T_char_count[i] = 0;\n\n\tint length;\n\n\tchar* T = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tfor(length = 0; T[length] != '\\0';length++){\n\t\tT_char_count[T[length]]++;\n\t}\n\n\tLocRecord locRecord;\n\tlocRecord.init();\n\n\t//T[i]????????????i??§???????????¨????¨????\n\tfor(int i = 0; i < length; i++){\n\t\tlocRecord.regist_loc(T[i],i);\n\t}\n\n\tull* HASH = new ull[length+1];\n\tull* P = new ull[length+1];\n\n\tHASH[0] = 0;\n\tP[0] = 1;\n\n\t//T??????????????\\???????±???????\n\tfor(int i = 1; i <= length; i++){\n\t\tHASH[i] = T[i-1] + HASH[i-1]*MOD;\n\t\tP[i] = P[i-1]*MOD;\n\t}\n\n\tint Q,S_length,left,P_char_count[128];\n\tscanf(\"%d\",&Q);\n\n\tchar S[1001];\n\tull S_HASH[1001],S_value,T_value;\n\tbool FLG;\n\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",S);\n\n\t\tfor(int i = 48; i < 122; i++){\n\t\t\tP_char_count[i] = 0;\n\t\t}\n\n\t\tfor(S_length = 0;S[S_length] != '\\0';S_length++){\n\t\t\tP_char_count[S[S_length]]++;\n\t\t}\n\n\t\tFLG = true;\n\n\t\tfor(int i = 48; i < 122; i++){\n\t\t\tif(T_char_count[i] < P_char_count[i]){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG)continue;\n\n\n\t\tS_HASH[0] = 0;\n\t\tfor(int i = 1; i <= S_length; i++){\n\t\t\tS_HASH[i] = S[i-1] + S_HASH[i-1]*MOD;\n\t\t}\n\n\t\tS_value = S_HASH[S_length];\n\n\t\tlocRecord.init_index();\n\n\t\tFLG = false;\n\n\t\twhile((left = locRecord.next_loc(S[0])) != -1){\n\t\t\tif(left+S_length-1>=length)break;\n\n\t\t\tT_value = HASH[left+S_length]-HASH[left]*P[S_length];\n\n\t\t\tif(T_value == S_value){\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(FLG){\n\t\t\tprintf(\"1\\n\");\n\t\t}else{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct node{\n\tint fail;\n\tbool vis;\n\tmap<char,int> nxt;\n};\n\nvector<node> trie;\n\nstring input(){\n\tstatic char buf[1000010];\n\tbuf[0] = 0;\n\tscanf(\"%s\", buf);\n\treturn buf;\n}\n\nint main(){\n\ttrie.reserve(1000010);\n\n\ttrie.emplace_back();\n\ttrie[0].fail = -1;\n\n\tstring t = input();\n\tint q;\n\tscanf(\"%d\", &q);\n\tvector<int> idx(q);\n\tfor(int i = 0; i < q; ++i){\n\t\tstring p = input();\n\t\tint u = 0;\n\t\tfor(char c : p){\n\t\t\tif(!trie[u].nxt.count(c)){\n\t\t\t\ttrie[u].nxt.emplace(c, trie.size());\n\t\t\t\ttrie.emplace_back();\n\t\t\t}\n\t\t\tu = trie[u].nxt[c];\n\t\t}\n\t\tidx[i] = u;\n\t}\n\n\tvector<int> bfs;\n\tbfs.push_back(0);\n\tint k = 0;\n\twhile(k < (int)bfs.size()){\n\t\tint u = bfs[k++];\n\t\tfor(const auto &pr : trie[u].nxt){\n\t\t\tchar c = pr.first;\n\t\t\tint v = pr.second;\n\t\t\tbfs.push_back(v);\n\n\t\t\tint f = trie[u].fail;\n\t\t\twhile(f >= 0 && !trie[f].nxt.count(c)){\n\t\t\t\tf = trie[f].fail;\n\t\t\t}\n\t\t\ttrie[v].fail = f >= 0 ? trie[f].nxt[c] : 0;\n\t\t}\n\t}\n\n\tint r = 0;\n\tfor(char c : t){\n\t\twhile(r >= 0 && !trie[r].nxt.count(c)){\n\t\t\tr = trie[r].fail;\n\t\t}\n\t\tr = r >= 0 ? trie[r].nxt[c] : 0;\n\t\ttrie[r].vis = true;\n\t}\n\n\tfor(int i = bfs.size(); i--; ){\n\t\tint u = bfs[i];\n\t\tif(trie[u].vis && trie[u].fail >= 0){\n\t\t\ttrie[trie[u].fail].vis = true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < q; ++i){\n\t\tprintf(\"%d\\n\", +trie[idx[i]].vis);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define INF 1 << 30\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntypedef complex<double> dcomplex;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\nll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\n\nint n;\nstring s;\n\nbool solve(string t)\n{\n  int m = t.size();\n  map<char,int> f;\n  REP(i,m) f[t[i]] = m-1-i;\n  int p = m-1;\n  while(p<n)\n  {\n    int k = m-1;\n    //cerr << p << \" \" << s[p] << endl;\n    while(k >= 0 && t[k] == s[p]) {k--; p--;}\n    if(k == -1) return true;\n    else\n    {\n      if(f.find(s[p])==f.end()) p += m;\n      else p += max(f[s[p]],m-k);\n    }\n  }\n  return false;\n}\n\nint main()\n{\n  cin >> s;\n  n = s.size();\n  int q; cin >> q;\n  REP(i,q)\n  {\n    string t; cin >> t;\n    cout << solve(t) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n\nusing namespace std;\n\nstring S; int Q; char STR[1005];\n\nint main()\n{\n\tcin >> S >> Q;\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%s\", STR);\n\n\t\tprintf(\"%d\\n\", S.find(STR) != string::npos ? 1 : 0);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nclass suffix_array{\n    void create_begin_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        int sum=0;\n        for(int i=0;i<bucket.size();i++){bucket[i]+=sum;swap(sum,bucket[i]);}\n    }\n\n    void create_end_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        for(int i=1;i<bucket.size();i++)bucket[i]+=bucket[i-1];\n    }\n\n    void induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_begin_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(sa[i]>0&&is_l[sa[i]-1])sa[bucket[v[sa[i]-1]]++]=sa[i]-1;\n    }\n\n    void invert_induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_end_bucket(v,bucket);\n        for(int i=v.size()-1;i>=0;i--)if(sa[i]>0&&!is_l[sa[i]-1])sa[--bucket[v[sa[i]-1]]]=sa[i]-1;\n    }\n\n    vector<int>sa_is(vector<int>v,int mv){\n        if(v.size()==1)return vector<int>(1,0);\n\n        vector<int>is_l(v.size());\n        vector<int>bucket(mv+1);\n        vector<int>sa(v.size(),-1);\n        auto is_lms=[&](int x)->bool{return x>0&&is_l[x-1]&&!is_l[x];};\n\n        is_l[v.size()-1]=0;\n        for(int i=v.size()-2;i>=0;i--)is_l[i]=v[i]>v[i+1]||(v[i]==v[i+1]&&is_l[i+1]);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(is_lms(i))sa[--bucket[v[i]]]=i;\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n\n        int cur=0;\n        vector<int>order(v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))order[i]=cur++;\n\n        vector<int>next_v(cur);\n        cur=-1;\n        int prev=-1;\n        for(int i=0;i<v.size();i++){\n            if(!is_lms(sa[i]))continue;\n            bool diff=false;\n            for(int d=0;d<v.size();d++){\n                if(prev==-1||v[sa[i]+d]!=v[prev+d]||is_l[sa[i]+d]!=is_l[prev+d]){\n                    diff=true;\n                    break;\n                }\n                else if(d>0&&is_lms(sa[i]+d))break;\n            }\n            if(diff){cur++;prev=sa[i];}\n            next_v[order[sa[i]]]=cur;\n        }\n\n        vector<int>re_order(next_v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))re_order[order[i]]=i;\n        vector<int>next_sa=sa_is(next_v,cur);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<sa.size();i++)sa[i]=-1;\n        for(int i=next_sa.size()-1;i>=0;i--)sa[--bucket[v[re_order[next_sa[i]]]]]=re_order[next_sa[i]];\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n        return sa;\n    }\n\n    vector<int>sa_is(string &s){\n        vector<int>v(s.size()+1);\n        for(int i=0;i<s.size();i++)v[i]=s[i];\n        sa=sa_is(v,*max_element(v.begin(),v.end()));\n    }\n\n    void construct_lcp(){\n        lcp.resize(s.size());\n        rank.resize(s.size()+1);\n        int n=s.size();\n        for(int i=0;i<=n;i++)rank[sa[i]]=i;\n        int h=0;\n        lcp[0]=0;\n        for(int i=0;i<n;i++){\n            int j=sa[rank[i]-1];\n\n            if(h>0)h--;\n            for(;j+h<n&&i+h<n;h++){\n                if(s[j+h]!=s[i+h])break;\n            }\n            lcp[rank[i]-1]=h;\n        }\n    }\n\n    class sparse_table{\n        vector<vector<int> >st;\n    public:\n        void init(vector<int>&v){\n            int b;\n            for(b=0;(1<<b)<=v.size();b++);\n            st.assign(b,vector<int>(1<<b));return;\n            for(int i=0;i<v.size();i++)st[0][i]=v[i];\n\n            for(int i=1;i<b;i++){\n                for(int j=0;j+(1<<i)<=(1<<b);j++){\n                    st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);\n                }\n            }\n        }\n        int get_min(int l,int r){\n            assert(l<r);\n            int b=32-__builtin_clz(r-l)-1;\n            return min(st[b][l],st[b][r-(1<<b)]);\n        }\n        sparse_table(){}\n        sparse_table(vector<int>&v){init(v);}\n    };\n    sparse_table st;\npublic:\n    string s;\n    vector<int>sa,lcp,rank;\n    void init(string &t){\n        s=t;\n        sa_is(s);\n        construct_lcp();\n        st.init(lcp);\n    }\n    suffix_array(string &t){init(t);}\n    suffix_array(){}\n\n    bool contain(string &t){\n        int lb=0,ub=s.size();\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            if(s.compare(sa[mid],t.size(),t)<0)lb=mid;\n            else ub=mid;\n        }\n        return s.compare(sa[ub],t.size(),t)==0;\n    }\n\n    int get_lcp(int i,int j){\n        if(rank[i]>rank[j])swap(i,j);\n        return st.get_min(rank[i],rank[j]);\n    }\n};\n\nsigned main(){\n    string s;cin>>s;\n    suffix_array sa(s);\n    int q;cin>>q;\n    while(q--){\n        string t;\n        cin>>t;\n        cout<<sa.contain(t)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_N 1000000\ntypedef unsigned long long ull;\nusing namespace std;\n\nint n, k;\nint Rank[MAX_N + 1];\nint tmp[MAX_N + 1];\n\nbool Compare_SA(int i, int j) {\n\tif (Rank[i] != Rank[j]) return Rank[i] < Rank[j];\n\telse {\n\t\tint ri = i + k <= n ? Rank[i + k] : -1;\n\t\tint rj = j + k <= n ? Rank[j + k] : -1;\n\t\treturn ri < rj;\n\t}\n}\n\nvoid Construct_SA(const string &S, vector<int> &SA) {\n\tn = S.length();\n\tSA = vector<int>(n + 1);\n\n\tfor (int i = 0; i <= n;i++) {\n\t\tSA[i] = i;\n\t\tRank[i] = i < n ? S[i] : -1;\n\t}\n\n\tfor (k = 1; k <= n; k *= 2) {\n\t\tsort(SA.begin(), SA.end(), Compare_SA);\n\n\t\ttmp[SA[0]] = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\ttmp[SA[i]] = tmp[SA[i - 1]] + (Compare_SA(SA[i - 1], SA[i]) ? 1 : 0);\n\t\t}\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tRank[i] = tmp[i];\n\t\t}\n\t}\n}\n\nbool Contain(const string &S, const vector<int> &SA, const string &T) {\n\tint a = 0, b = S.length();\n\twhile (b - a > 1) {\n\t\tint c = (a + b) / 2;\n\t\tif (S.compare(SA[c], T.length(), T) < 0) a = c;\n\t\telse b = c;\n\t}\n\treturn S.compare(SA[b], T.length(), T) == 0;\n}\n\nint main()\n{\n\tint Q;\n\tstring T, P;\n\tvector<int> SA;\n\tcin.sync_with_stdio(false);\n\tcin >> T;\n\tConstruct_SA(T, SA);\n\tcin >> Q;\n\twhile (Q--) {\n\t\tcin >> P;\n\t\tcout << Contain(T, SA, P) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct list_node {\n\tint val;\n\tlist_node *next;\n\tlist_node(int v) : val(v), next(nullptr) {}\n};\n\nstruct singlylist {\n\tlist_node *front, *back;\n\tsinglylist() : front(nullptr), back(nullptr) {}\n};\n\nvoid push_back_val(singlylist& s, int val) {\n\tif (!s.front) {\n\t\ts.front = s.back = new list_node(val);\n\t\treturn;\n\t}\n\ts.back->next = new list_node(val);\n\ts.back = s.back->next;\n}\n\nvoid connect(singlylist& s, singlylist& t) {\n\tif (!s.front) {\n\t\ts.front = t.front = new list_node(-1);\n\t\treturn;\n\t}\n\ts.back->next = t.front;\n}\n\nstruct node {\n\tnode *fail;\n\tunordered_map<char, node*> next;\n\tsinglylist ok;\n\tnode() : fail(nullptr) {}\n};\n\nnode* getnext(node* p, char c) {\n\twhile (p->next.count(c) == 0) p = p->fail;\n\treturn p->next[c];\n}\n\nclass aho_corasick {\n\tvector<int> unite(const vector<int>& a, const vector<int>& b) {\n\t\tvector<int> res;\n\t\tset_union(a.begin(), a.end(), b.begin(), b.end(), back_inserter(res));\n\t\treturn res;\n\t}\n\tint K;\n\tnode *root;\npublic:\n\taho_corasick(const vector<string>& Ts) : K(Ts.size()), root(new node) {\n\t\tnode *now;\n\t\troot->fail = root;\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tauto &T = Ts[i];\n\t\t\tnow = root;\n\t\t\tfor (auto c : T) {\n\t\t\t\tif (now->next[c] == nullptr) {\n\t\t\t\t\tnow->next[c] = new node;\n\t\t\t\t}\n\t\t\t\tnow = now->next[c];\n\t\t\t}\n\t\t\tpush_back_val(now->ok, i);\n\t\t}\n\t\tqueue<node*> q;\n\t\tfor (auto p : root->next) {\n\t\t\tif (p.second) {\n\t\t\t\tp.second->fail = root;\n\t\t\t\tq.push(p.second);\n\t\t\t}\n\t\t}\n\t\twhile (!q.empty()) {\n\t\t\tnow = q.front(); q.pop();\n\t\t\tfor (auto p : now->next) {\n\t\t\t\tif (p.second) {\n\t\t\t\t\tnode *nx = now->fail;\n\t\t\t\t\twhile (nx != root && !nx->next.count(p.first)) {\n\t\t\t\t\t\tnx = nx->fail;\n\t\t\t\t\t}\n\t\t\t\t\tif (!nx->next.count(p.first)) nx->next[p.first] = root;\n\t\t\t\t\tp.second->fail = nx->next[p.first];\n\t\t\t\t\tconnect(p.second->ok, nx->next[p.first]->ok);\n\t\t\t\t\tq.push(p.second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tnode* getroot() const {\n\t\treturn root;\n\t}\n\tvector<int> count(const string& S) const {\n\t\tvector<int> res(K);\n\t\tnode *now = root;\n\t\tfor (auto c : S) {\n\t\t\tnow = getnext(now, c);\n\t\t\tfor (auto it = now->ok.front; it; it = it->next) if (it->val != -1) res[it->val] = 1;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tstring T;\n\tcin >> T;\n\tint Q;\n\tcin >> Q;\n\tvector<string> P(Q);\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> P[i];\n\t}\n\taho_corasick ac(P);\n\tauto res = ac.count(T);\n\tfor (auto b : res) {\n\t\tprintf(\"%d\\n\", b);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\nconst int MAX = 1000002;\n\nint Lv[MAX];\nint n, k;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n    return L_i < L_j;\n}\n\nint main()\n{\n    int A[MAX], newLv[MAX];\n    char t[MAX];\n    scanf(\"%s\", t);\n    std::string T = t;\n    n = T.size();\n\n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n    std::sort(A, A + n, cmp_Lv);\n\n    newLv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        newLv[A[i]] = newLv[A[i - 1]] + (Lv[A[i]] != Lv[A[i - 1]] ? 1 : 0);\n    }\n    for(i = 0; i < n; i++){ Lv[i] = newLv[i]; }\n\n    k = 1;\n    while(1){\n        if(k > n) break;\n\n        std::sort(A, A + n, cmp);\n        newLv[A[0]] = 0;\n        for(i = 1; i < n; i++){ newLv[A[i]] = newLv[A[i - 1]] + (cmp(A[i - 1], A[i]) ? 1 : 0); }\n        for(i = 0; i < n; i++){ Lv[i] = newLv[i]; }\n\n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n\n    char p[1000];\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n\n    A[n] = n;\n\n    while(q){\n        scanf(\"%s\", p);\n        std::string P = p;\n        left = 0, right = n, exist = false;\n        while(left < right){\n\n            if(n < P.size()){ exist = false; break; }\n\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n\n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <numeric>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, Q, sa[1000009]; string s; unsigned long long p[1000009], h[1000009];\nunsigned long long gethash(int l, int r) {\n\treturn h[r] - h[l] * p[r - l];\n}\nint lcp(int x, int y) {\n\tint l = 0, r = min(N - x, N - y) + 1;\n\twhile (r - l > 1) {\n\t\tint m = (l + r) >> 1;\n\t\tif (gethash(x, x + m) == gethash(y, y + m)) l = m;\n\t\telse r = m;\n\t}\n\treturn l;\n}\nbool compare_sa(int i, int j) {\n\tint k = lcp(i, j);\n\tif (i + k >= N) return true;\n\tif (j + k >= N) return false;\n\treturn s[i + k] <= s[j + k];\n}\nbool contain(string &t) {\n\tint a = 0, b = N;\n\twhile (b - a > 1) {\n\t\tint c = (a + b) >> 1;\n\t\tif (s.compare(sa[c], t.size(), t) < 0) a = c;\n\t\telse b = c;\n\t}\n\treturn s.compare(sa[b], t.size(), t) == 0;\n}\nint main() {\n\tcin >> s >> Q; N = s.size();\n\tp[0] = 1;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tp[i + 1] = p[i] * 257;\n\t\th[i + 1] = h[i] * 257 + s[i];\n\t}\n\tiota(sa, sa + N + 1, 0);\n\tsort(sa, sa + N + 1, compare_sa);\n\tfor (int i = 0; i < Q; i++) {\n\t\tstring t; cin >> t;\n\t\tcout << contain(t) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)),pow(n+1),phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-i+1;\n    while(l+1<r) {\n      const int m=(l+r)>>1;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nint L[1000000],R[1000000];\n\ninline void merge(int *A, const int left, const int mid, const int right, const RollingHash &rh){\n  const int n1 = mid - left, n2 = right - mid;\n  REP(i,n1)L[i]=A[left+i];\n  REP(i,n2)R[i]=A[mid+i];\n  for(int k =left,i=0,j=0;k<right;k++){\n    if(n2<=j)A[k]=L[i++];\n    else if(n1<=i)A[k]=R[j++];\n    else A[k]=rh(L[i],R[j])?L[i++]:R[j++];\n  }\n}\n\nvoid mergeSort(int *A,const int left,const int right, const RollingHash &rh){\n  if(left+1<right){\n    const int mid = (left+right)>>1;\n    mergeSort(A,left,mid, rh);\n    mergeSort(A,mid,right, rh);\n    merge(A,left,mid,right, rh);\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergeSort(sa,0,n,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n\n#define MAX_N 100000000\n\nusing namespace std;\n\nint n,k;\nint rank[MAX_N + 1];\nint tmp[MAX_N + 1];\n\n\nbool compare_sa(int i, int j)\n{\n\tif(rank[i] != rank[j]) \n\t{\n\t\treturn rank[i] < rank[j];\n\t}\n\telse\n\t{\n\tint ri = i + k <= n ? rank[i + k] : -1;\n\tint rj = j + k <= n ? rank[j + k] : -1;\n\treturn ri < rj;\n\t}\n}\n\n\nvoid construct_sa(string s,int *sa)\n{\n\tn = s.length();\n\t\n\n\tfor(int i = 0; i <= n;i++)\n\t{\n\t\tsa[i] = i;\n\t\trank[i] = i < n ? s[i] : -1;\n\t}\n\t\n\n\tfor(k = 1;k <= n ; k *= 2)\n\t{\n\t\tsort(sa,sa + n + 1,compare_sa);\n\t\t\n                tmp[sa[0]] = 0;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\ttmp[sa[i]] = tmp[sa[i -1]] + (compare_sa(sa[i - 1],sa[i]) ? 1 : 0);\n\t\t}\n\t\tfor(int i = 0;i <= n;i++)\n\t\t{\n\t\t\trank[i] = tmp[i];\n\t\t}\n\t}\n}\n\nbool contain(string s,int *sa, string t)\n{\n\tint a = 0,b = s.length();\n\twhile(b - a > 1)\n\t{\n\t\tint c = (a + b) / 2;\n\t\t\n\t\tif(s.compare(sa[c],t.length(),t) < 0) a = c;\n\t\telse b = c;\n\t}\n\t\n\treturn (s.compare(sa[b], t.length(),t) == 0);\n\t\n}\n\n\nint main()\n{\n\tstring S;\n\tint N,sa[MAX_N];\n\t\n\t\n\tcin >> S >> N;\n\t\n\tconstruct_sa(S,sa);\n\t\n\tfor(int i = 0 ;i < N;i++)\n\t{\n\t\tstring T;\n\t\tcin >> T;\n\t\tif(contain(S,sa,T)) cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s;\n\tcin>>s;\n\ts+='$';\n\tint n=s.size();\n\tvector<int>suff(n);\n\tiota(suff.begin(),suff.end(),0);\n\t{\n\t\tconst char *str=s.c_str();\n\t\tsort(suff.begin(),suff.end(),[&](int a,int b){\n\t\t\treturn strcmp(str+a,str+b)<0;\n\t\t});\n\t}\n\tvector<pair<char,int>>sorted(n);\n\tfor(int i=0;i<n;i++)sorted[i]={s[(suff[i]-1+n)%n],i};\n\tsort(sorted.begin(),sorted.end());\n\n\tint T;\n\tfor(cin>>T;T--;){\n\t\tstring q;\n\t\tcin>>q;\n\t\tint start=0,stop=n,idx=q.size()-1;\n\t\tfor(;idx>=0;idx--){\n\t\t\tpair<char,int> ql={q[idx],start},qr={q[idx],stop};\n\t\t\tstart=lower_bound(sorted.begin(),sorted.end(),ql)-sorted.begin();\n\t\t\tstop=lower_bound(sorted.begin(),sorted.end(),qr)-sorted.begin();\n\t\t\tif(start==stop)break;\n\t\t}\n\t\tif(idx<0){\n\t\t\t//for(;start<stop;start++)printf(\"%d\\n\",suff[start]);\n\t\t\tputs(\"1\");\n\t\t}else{\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s,q;\n\tcin>>s;\n\ts+='$';\n\tint n=s.size();\n\tvector<int>suff(n);\n\tiota(suff.begin(),suff.end(),0);\n\t{\n\t\tconst char *str=s.c_str();\n\t\tsort(suff.begin(),suff.end(),[&](int a,int b){\n\t\t\treturn strcmp(str+a,str+b);\n\t\t});\n\t}\n\tvector<pair<char,int>>sorted(n);\n\tfor(int i=0;i<n;i++)sorted[i]={s[(suff[i]-1+n)%n],i};\n\tsort(sorted.begin(),sorted.end());\n\n\tint T;\n\tfor(cin>>T;T--;){\n\t\tstring q;\n\t\tcin>>q;\n\t\tint start=0,stop=n,idx=q.size()-1;\n\t\tfor(;idx>=0;idx--){\n\t\t\tpair<char,int> ql={q[idx],start},qr={q[idx],stop};\n\t\t\tstart=lower_bound(sorted.begin(),sorted.end(),ql)-sorted.begin();\n\t\t\tstop=lower_bound(sorted.begin(),sorted.end(),qr)-sorted.begin();\n\t\t\tif(start==stop)break;\n\t\t}\n\t\tif(idx<0){\n\t\t\t//for(;start<stop;start++)printf(\"%d\\n\",suff[start]);\n\t\t\tputs(\"1\");\n\t\t}else{\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }  \n};\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  const int n = SZ(a);\n  if(n>1){\n    vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(b,rh), mergesort(c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==SZ(c))a[i]=b[j++];\n      else if(j==SZ(b))a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  //sort(ALL(sa),rh);\n  mergesort(sa,rh);\n  //if(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    //if(S.compare(sa[c],T.length(),T)<0 )a=c;\n    //else b=c;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  //cin.ignore();\n  char str[1000000];\n  while(n--){\n    //cin >> t;\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << contain(s,sa,t) << \"\\n\";\n    //cout << !!rh.find(t) << \"\\n\";\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n/*\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n-nb,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k>=nc)a[i]=b[j++];\n      else if(j>=nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n*/\nint L[1000000],R[1000000];\n\nvoid merge(int *A, const int left, const int mid, const int right, const RollingHash &rh){\n  int n1 = mid - left, n2 = right - mid;\n  REP(i,n1)L[i]=A[left+i];\n  REP(i,n2)R[i]=A[mid+i];\n  for(int k =left,i=0,j=0;k<right;k++){\n    if(n2<=j)A[k]=L[i++];\n    else if(n1<=i)A[k]=R[j++];\n    else A[k]=rh(L[i],R[j])?L[i++]:R[j++];\n  }\n}\n\nvoid mergeSort(int *A,const int left,const int right, const RollingHash &rh){\n  if(left+1<right){\n    const int mid = (left+right)/2;\n    mergeSort(A,left,mid, rh);\n    mergeSort(A,mid,right, rh);\n    merge(A,left,mid,right, rh);\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  //mergesort(n,sa,rh);\n  mergeSort(sa,0,n,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int mb=n/2,mc=n/2+n%2,b[mb],c[mc];\n    REP(i,mb)b[i]=a[i];\n    REP(i,mc)c[i]=a[mb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(mb,b,rh), mergesort(mc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==mc)a[i]=b[j++];\n      else if(j==mb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,rh.n+1)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000000];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nusing i64=int64_t;\n\nvector<int> suffix_array(const string &s){\n    const int n=s.size();\n    vector<int> rank(n+1),sa(n+1),tmp(n+1);\n    for(int i=0; i<=n; ++i){\n        sa[i]=i;\n        rank[i]=i<n?s[i]:-1;\n    }\n    for(int k=1; k<=n; k*=2){\n        auto compare=[&](int i,int j){\n            if(rank[i]!=rank[j]) return rank[i]<rank[j];\n            else{\n                int ri=i+k<=n?rank[i+k]:-1;\n                int rj=j+k<=n?rank[j+k]:-1;\n                return ri<rj;\n            }\n        };\n        sort(sa.begin(),sa.end(),compare);\n        tmp[sa[0]]=0;\n        for(int i=1; i<=n; ++i){\n            tmp[sa[i]]=tmp[sa[i-1]]+(compare(sa[i-1],sa[i])?1:0);\n        }\n        for(int i=0; i<=n; ++i){\n            rank[i]=tmp[i];\n        }\n    }\n    return sa;\n}\n\nint lower_bound(const string& s,const vector<int>& sa,const string t){\n    int lb=0,ub=sa.size();\n    while(ub-lb>1){\n        int m=(lb+ub)/2;\n        if(s.substr(sa[m],t.size())>=t) ub=m;\n        else lb=m;\n    }\n    return ub;\n}\n\nint upper_bound(const string& s,const vector<int>& sa,const string t){\n    int lb=0,ub=sa.size();\n    while(ub-lb>1){\n        int m=(lb+ub)/2;\n        if(s.substr(sa[m],t.size())>t) ub=m;\n        else lb=m;\n    }\n    return ub;\n}\n\nvoid solve(){\n    string S;\n    int q;\n    cin >> S >> q;\n    auto sa=suffix_array(S);\n    cerr << sa << endl;\n    rep(i,0,q){\n        string T;\n        cin >> T;\n        if(upper_bound(S,sa,T)-lower_bound(S,sa,T)>=1) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S 2500005\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\nstruct d{\n  int a,b,c;\n  d(){}\n  d(int A,int B,int C){\n    a=A,b=B,c=C;\n  };\n  bool operator<(const d&r)const{\n    if(a!=r.a)return a<r.a;\n    return b<r.b;\n  }\n};\n\nint n,slen,tlen,r[S];\nchar s[S],t[N];\nd ran[S];\nP a[S];\n\nvoid init(){\n  for(int i=0;i<slen;i++)r[i]=s[i];\n  int x=1;\n  r[slen]=0;\n  while(1){\n    for(int i=0;i<slen;i++){\n      int o=i+x;\n      if(o>slen)o=slen;\n      ran[i]=d(r[i],r[o],i);\n    }\n    sort(ran,ran+slen);\n    int cnt=1;\n    for(int i=0;i<slen;i++){\n      r[ran[i].c]=cnt;\n      if(ran[i].a==ran[i+1].a&&ran[i].b==ran[i+1].b)\n\tcontinue;\n      cnt++;\n    }\n    if(x>slen)break;\n    x*=2;\n  }\n  for(int i=0;i<slen;i++)a[i]=P(r[i],i);\n  sort(a,a+slen);\n}\n\nbool bynary_search(){\n  int L=0,R=slen;\n  while(L<R){\n    int M=(L+R)/2;\n    if(strncmp(s+a[M].second,t,tlen)<0)L=M+1;\n    else R=M;\n  }\n  if(!strncmp(s+a[L].second,t,tlen))return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s%d\",s,&n);\n  slen=strlen(s);\n  init();  \n  while(n--){\n    scanf(\"%s\",t);\n    tlen=strlen(t);\n    if(bynary_search())printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nstruct SuffixArray{\n  string s;\n  vector<int> sa,rev;\n\n  SuffixArray(){}\n  SuffixArray(const string &S):s(S){\n    int n=s.size();\n    s.push_back('$');\n    sa.resize(n+1);\n    iota(sa.begin(),sa.end(),0);\n    sort(sa.begin(),sa.end(),\n         [&](int a,int b){\n           if(s[a]==s[b]) return a>b;\n           return s[a]<s[b];\n         });\n    vector<int> c(n+1,0),r(n+1),cnt(n+1);\n    for(int i=0;i<=n;i++) r[i]=s[i];\n    for(int len=1;len<=n;len*=2){\n      for(int i=0;i<=n;i++){\n        c[sa[i]]=i;\n        if(i>0 &&\n           r[sa[i-1]]==r[sa[i]] &&\n           sa[i-1]+len<=n &&\n           r[sa[i-1]+len/2]==r[sa[i]+len/2]) c[sa[i]]=c[sa[i-1]];\n      }\n      iota(cnt.begin(),cnt.end(),0);\n      copy(sa.begin(),sa.end(),r.begin());\n      for(int i=0;i<=n;i++){\n        int s1=r[i]-len;\n        if(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n      c.swap(r);\n    }\n    rev.resize(n+1);\n    for(int i=0;i<=n;i++) rev[sa[i]]=i;\n  }\n  int operator[](int i) const{return sa[i];}\n\n  bool lt_substr(string &t,int si,int ti){\n    int sn=s.size(),tn=t.size();\n    while(si<sn&&ti<tn){\n      if(s[si]<t[ti]) return 1;\n      if(s[si]>t[ti]) return 0;\n      si++;ti++;\n    }\n    return si==sn&&ti<tn;\n  }\n\n  int lower_bound(string& t){\n    int l=0,r=s.size();\n    while(l+1<r){\n      int m=(l+r)>>1;\n      if(lt_substr(t,sa[m],0)) l=m;\n      else r=m;\n    }\n    return r;\n  }\n\n  int upper_bound(string& t){\n    t.back()++;\n    int res=lower_bound(t);\n    t.back()--;\n    return res;\n  }\n\n  // O(|T|*log|S|)\n  int count(string& T){\n    return upper_bound(T)-lower_bound(T);\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  string t;\n  cin>>t;\n  int q;\n  cin>>q;\n  SuffixArray sa(t);\n  while(q--){\n    string p;\n    cin>>p;\n    cout<<!!sa.count(p)<<\"\\n\";\n  }\n  cout<<flush;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define MAX 1000002\ntypedef unsigned char byte;\nbyte mask[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\n\nint Lv[MAX];\nint n, k;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n    return L_i < L_j;\n}\n\nint main()\n{\n    int A[MAX];\n    char c[MAX];\n    scanf(\"%s\", c);\n    std::string T = std::string(c);\n    n = T.size();\n    byte *t;\n    t = new byte [(n >> 3) + 1];\n\n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n    std::sort(A, A + n, cmp_Lv);\n\n    for(i = 1; i < n; i++){\n        t[i >> 3] = (Lv[A[i]] != Lv[A[i - 1]] ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n    }\n\n    Lv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]); \n    }\n\n    k = 1;\n    while(1){\n        if(k > n) break;\n\n        std::sort(A, A + n, cmp);\n \n        for(i = 1; i < n; i++){\n            t[i >> 3] = (cmp(A[i - 1], A[i]) ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n        }\n        Lv[A[0]] = 0;\n        for(i = 1; i < n; i++){\n            Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n        }\n\n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n\n    char p[1000];\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n\n    A[n] = n;\n\n    while(q){\n        scanf(\"%s\", p);\n        std::string P = std::string(p);\n        left = 0, right = n, exist = false;\n        while(left < right){\n\n            if(n < P.size()){ exist = false; break; }\n\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n\n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct SA{\n  int n,k;\n  string S;\n  vector<int> r,r2,t,sa;\n  SA(){}\n  SA(string S):S(S){init();}\n  void init(){\n    n=S.size();\n    r.resize(n+1,0);\n    r2.resize(n+1,0);\n    t.resize(n+1,0);\n    sa.resize(n+1,0);\n    constract_sa();\n  }\n  bool compare_sa(int i,int j){\n    if(r[i]!=r[j]) return r[i]<r[j];\n    else{\n      int ri=i+k<=n?r[i+k]:-1;\n      int rj=j+k<=n?r[j+k]:-1;\n      return ri<rj;\n    }\n  }\n  void constract_sa(){\n    n=S.length();\n    for(int i=0;i<=n;i++){\n      sa[i]=i;\n      r[i]=i<n?S[i]:-1;\n    }\n    for(k=1;k<=n;k*=2){\n      sort(sa.begin(),sa.end(),[&](const int &i, const int &j){\n\t  if(r[i]!=r[j]) return r[i]<r[j];\n\t  else{\n\t    int ri=i+k<=n?r[i+k]:-1;\n\t    int rj=j+k<=n?r[j+k]:-1;\n\t    return ri<rj;\n\t  }\n\t});\n      t[sa[0]]=0;\n      for(int i=1;i<=n;i++){\n\tt[sa[i]]=t[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n      }\n      for(int i=0;i<=n;i++){\n\tr[i]=t[i];\n      }\n    }\n  }\n  bool contains(string T){\n    int a=0,b=S.length()+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      //cout<<a<<\" \"<<b<<\" \"<<c<<endl;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==(int)S.length()+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n};\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SA sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 2e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nclass SuffixArray {\nprivate:\n    string s;\n    int n;\n    vector<int> rank;\n    vector<int> sa;\npublic:\n    SuffixArray(string _s) : s(_s) {\n        n = s.size();\n        rank.resize(n + 1);\n        sa.resize(n + 1);\n        construct();\n    }\n    void construct() {\n        for (int i = 0; i <= n; ++i) {\n            sa[i] = i;\n            rank[i] = i < n ? s[i] : -1;\n        }\n\n        int k;\n        auto compare = [&](int i, int j) {\n            if (rank[i] != rank[j]) return rank[i] < rank[j];\n            else {\n                int ri = i + k <= n ? rank[i + k] : -1;\n                int rj = j + k <= n ? rank[j + k] : -1;\n                return ri < rj;\n            }\n        };\n\n        vector<int> tmp(n + 1);\n        for (k = 1; k <= n; k *= 2) {\n            sort(sa.begin(), sa.end(), compare);\n\n            tmp[sa[0]] = 0;\n            for (int i = 1; i <= n; ++i) {\n                tmp[sa[i]] = tmp[sa[i - 1]] + (compare(sa[i - 1], sa[i]) ? 1 : 0);\n            }\n            for (int i = 0; i <= n; ++i) {\n                rank[i] = tmp[i];\n            }\n        }\n    }\n    bool contain(string t) {\n        int l = 0, r = n;\n        while (r - l > 1) {\n            int m = (l + r) / 2;\n            if (s.substr(sa[m], t.size()) < t) l = m;\n            else r = m;\n        }\n        return s.substr(sa[r], t.size()) == t;\n    }\n    void print() {\n        for (int i = 0; i < n; ++i) {\n            cerr << s.substr(sa[i]) << endl;\n        }\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    string s;\n    cin >> s;\n    SuffixArray suf(s);\n    // suf.print();\n    int q;\n    cin >> q;\n    rep(i, q) {\n        string t;\n        cin >> t;\n        cout << suf.contain(t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int i, const int j) { \n    //const int k=lcp(i,j);\n    const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    if(i+k>=n)return 1;\n    if(j+k>=n)return 0;\n    return s[i+k] <= s[j+k];\n    //return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int b, const int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  /*\n  inline int lcp(const int i, const int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n  */\n  int lcp2(const int& i, const int& j, const int& l, const int& r){\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\nif(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nstatic const int NUM_CHILDREN = 26;\nstatic const char MIN_CHAR = 'a';\n\nstruct Trie {\n    vector<int> nums;\n    bool visited;\n    Trie *next[NUM_CHILDREN];\n    Trie() : visited(false) {\n        fill(next, next + NUM_CHILDREN, (Trie*)0);\n    }\n};\n\nvoid construct(Trie *trie, const vector<string> &strings) {\n    rep(i, strings.size()) {\n        Trie *p = trie;\n        for (auto c : strings[i]) {\n            int idx = c - MIN_CHAR;\n            if (!p->next[idx]) p->next[idx] = new Trie;\n            p = p->next[idx];\n        }\n        p->nums.emplace_back(i);\n    }\n}\n\nvoid dump(Trie* p, string s) {\n    if (!p->nums.empty()) {\n        cerr << \"s = \" << s << \", nums = {\";\n        for (auto num : p->nums) {\n            cerr << num << \", \";\n        }\n        cerr << endl;\n    }\n    for (int i = 0; i < NUM_CHILDREN; ++i) {\n        if (p->next[i]) {\n            dump(p->next[i], s + char(i + MIN_CHAR));\n        }\n    }\n}\n\nvoid search(Trie* trie, const string &s, vector<bool> &exist) {\n    // cerr << \"s = \" << s << endl;\n    Trie *p = trie;\n    for (auto c : s) {\n        int idx = c - MIN_CHAR;\n        if (!p->next[idx]) return;\n        p = p->next[idx];\n        // cerr << \"c = \" << c << endl;\n        if (!p->visited && !p->nums.empty()) {\n            // cerr << \"s = \" << s << \", c = \" << c << endl;\n            p->visited = true;\n            for (auto num : p->nums) {\n                exist[num] = true;\n            }\n        }\n    }\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    string s;\n    cin >> s;\n    int q;\n    cin >> q;\n    vector<string> strings(q);\n    rep(i, q) cin >> strings[i];\n\n    Trie *trie = new Trie;\n\n    construct(trie, strings);\n\n    // dump(trie, \"\");\n\n    vector<bool> exist(q);\n\n    rep(i, s.size()) {\n        search(trie, s.substr(i), exist);\n    }\n\n    rep(i, q) {\n        cout << exist[i] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nclass SuffixArrayInducedSorting\n{\nprivate:\n    static constexpr int encode(const int c) { return c == '$' ? 0 : 'a' <= c and c <= 'z' ? c - 'a' + 1 : 'A' <= c and c <= 'Z' ? c - 'A' + 27 : c - '0' + 53; }\n    static constexpr char decode(const int n) { return (n == 0 ? '$' : 'a' + n - 1); }\n    enum class Type : char {\n        L = 0,\n        S = 1,\n        LMS = 2,\n    };\n\npublic:\n    SuffixArrayInducedSorting(const string& s, const int kind_) : N(s.size() + 1), kind{kind_ + 1}, S(s.size() + 1, 0), type(N), next(N, 1), bucket(kind), num(kind, 0), head(kind, 0), tail(kind, 0)\n    {\n        for (int i = 0; i < s.size(); i++) {\n            S[i] = encode(s[i]);\n        }\n        initializeData();\n        sortLMS();\n    }\n    SuffixArrayInducedSorting(const vector<int>& s, const int kind_) : N(s.size() + 1), kind{kind_ + 1}, S(s), type(N), next(N, 1), bucket(kind), num(kind, 0), head(kind, 0), tail(kind, 0)\n    {\n        S.push_back(0);\n        initializeData();\n        sortLMS();\n    }\n    void debugPrint() const\n    {\n        for (int i = 0; i < N; i++) {\n            cout << decode(S[i]);\n        }\n        cout << endl;\n        for (int i = 0; i < N; i++) {\n            cout << (type[i] == Type::L ? \"L\" : \"S\");\n        }\n        cout << endl;\n        for (int i = 0; i < N; i++) {\n            cout << (type[i] == Type::LMS ? \"@\" : \" \");\n        }\n        cout << endl;\n        for (int i = 0; i < kind; i++) {\n            if (bucket[i].empty())\n                continue;\n            cout << \"[\" << decode(i) << \"]:\\n\";\n            for (const int p : bucket[i]) {\n                cout << \"  \" << p << endl;\n            }\n        }\n    }\n\n    vector<int> getSuffixArray() const\n    {\n        vector<int> ans(N - 1);\n        for (int pos = 0, i = 1; i < kind; i++) {  // 番兵以外\n            for (const int p : bucket[i]) {\n                ans[pos++] = p;\n            }\n        }\n        return ans;\n    }\n\nprivate:\n    void initializeData()\n    {\n        for (const int i : S) {\n            num[i]++;\n        }\n        for (int i = 0; i < kind; i++) {\n            bucket[i].resize(num[i], -1);\n            tail[i] = num[i] - 1;\n        }\n        type[N - 1] = Type::S;\n        for (int i = N - 2; i >= 0; i--) {\n            type[i] = (S[i] != S[i + 1] ? (S[i] < S[i + 1] ? Type::S : Type::L) : type[i + 1]);\n            if (type[i] == Type::L and type[i + 1] == Type::S) {\n                type[i + 1] = Type::LMS;\n                LMS.push_back(i + 1);\n            }\n        }\n        for (int pos = N - 1, i = N - 2; i >= 0; i--) {\n            next[i] = pos;\n            if (type[i] == Type::LMS) {\n                pos = i;\n            }\n        }\n    }\n\n    void sortLMS()\n    {\n        for (const int l : LMS) {\n            insertTail(l);\n        }\n        induce();\n        vector<int> lms;\n        for (int i = 0; i < kind; i++) {\n            for (const int p : bucket[i]) {\n                if (type[p] == Type::LMS) {\n                    lms.push_back(p);\n                }\n            }\n        }\n        const int size = lms.size();\n        vector<int> order(N / 2 + 1, 0);\n        int number = 1;\n        order[N / 2] = 1;\n        bool same = false;\n        for (int i = 1; i < size; i++) {\n            const int l1 = lms[i - 1];\n            const int r1 = next[l1];\n            const int l2 = lms[i];\n            const int r2 = next[l2];\n            if (r1 - l1 == r2 - l2 and vector<int>(S.begin() + l1, S.begin() + r1 + 1) == vector<int>(S.begin() + l2, S.begin() + r2 + 1)) {\n                same = true;\n            } else {\n                number++;\n            }\n            order[l2 / 2] = number;\n        }\n        if (same) {\n            vector<int> s(size);\n            for (int p = 0, i = 0; i <= N / 2; i++) {\n                if (order[i] > 0) {\n                    s[p++] = order[i];\n                }\n            }\n            const vector<int> sorted = SuffixArrayInducedSorting{s, number}.getSuffixArray();\n            for (int i = 0; i < kind; i++) {\n                head[i] = 0;\n                tail[i] = num[i] - 1;\n            }\n            for (int i = size - 1; i >= 0; i--) {\n                insertTail(LMS[size - 1 - sorted[i]]);\n            }\n            induce();\n        } else {\n            for (int i = 0; i < kind; i++) {\n                head[i] = 0;\n                tail[i] = num[i] - 1;\n            }\n            for (int i = size - 1; i >= 0; i--) {\n                insertTail(lms[i]);\n            }\n            induce();\n        }\n    }\n\n    void induce()\n    {\n        for (int i = 0; i < kind; i++) {\n            for (int j = 0; j < head[i]; j++) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] == Type::L) {\n                    insertHead(p - 1);\n                }\n            }\n            for (int j = tail[i] + 1; j < num[i]; j++) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] == Type::L) {\n                    insertHead(p - 1);\n                }\n            }\n        }\n        for (int i = 1; i < kind; i++) {  // 番兵以外\n            tail[i] = num[i] - 1;\n        }\n        for (int i = kind - 1; i >= 0; i--) {\n            for (int j = num[i] - 1; j > tail[i]; j--) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] != Type::L) {\n                    insertTail(p - 1);\n                }\n            }\n            for (int j = head[i] - 1; j >= 0; j--) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] != Type::L) {\n                    insertTail(p - 1);\n                }\n            }\n        }\n    }\n    void insertHead(const int i) { bucket[S[i]][head[S[i]]++] = i; }\n    void insertTail(const int i) { bucket[S[i]][tail[S[i]]--] = i; }\n\n    const int N;\n    const int kind;\n    vector<int> S;               // O(N)\n    vector<Type> type;           // O(N)\n    vector<int> next;            // O(N)\n    vector<vector<int>> bucket;  // O(N)\n    vector<int> num;             // O(K)\n    vector<int> head;            // O(K)\n    vector<int> tail;            // O(K)\n    vector<int> LMS;             // O(N)\n};\n\nint main()\n{\n    string s;\n    cin >> s;\n    const int size = s.size();\n    const vector<int> sa = SuffixArrayInducedSorting(s, 79).getSuffixArray();\n    int N;\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        string p;\n        cin >> p;\n        const int psize = p.size();\n        int inf = -1;\n        int sup = size - psize;\n        while (sup - inf > 1) {\n            const int mid = (sup + inf) / 2;\n            const bool ok = s.substr(mid, mid + psize) < p;\n            if (ok) {\n                inf = mid;\n            } else {\n                sup = mid;\n            }\n        }\n        bool ans = true;\n        for (int i = 0; i < psize; i++) {\n            if (s[i + sup] != p[i]) {\n                ans = false;\n                break;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<(b);i++)\n#define erep(i,a,b) for(int i=a;i<=(int)(b);i++)\n#define per(i,a,b) for(int i=(b)-1;i>(a);i--)\n#define eper(i,a,b) for(int i=((int)(a));i>=b;i--)\n#define pb push_back\n#define mp make_pair\n#define INF (1<<30)-1\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\n\nstring s;\nint main() {\n ios::sync_with_stdio ( false );\n cin.tie ( 0 );\n    int n; \n    cin >> s >> n;\n    rep(i, 0, n) {\n        string x; \n        cin >> x;\n        if (s.find(x) == -1) cout << 0 << endl;\n        else cout << 1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_REP(_1, _2, _3, NAME, ...) NAME\n#define rep(...) GET_REP(__VA_ARGS__, irep, _rep)(__VA_ARGS__)\n#define rep1(...) GET_REP(__VA_ARGS__, irep1, _rep1)(__VA_ARGS__)\n#define _rep(i, n) irep (i, 0, n)\n#define _rep1(i, n) irep1(i, 1, n)\n#define irep(i, a, n) for (int i = a; i < (int)(n); ++i)\n#define irep1(i, a, n) for (int i = a; i <= (int)(n); ++i)\n#define rrep(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define rrep1(i, n) for (int i = (int)(n); i >= 1; --i)\n#define allrep(X, x) for (auto &&X : x)\n#define all(x) (x).begin(), (x).end()\n#ifdef LOCAL\n  #include \"../../Lib/cout_container.hpp\"\n  #define debug(x) cerr << #x \" => \" << x << endl\n#else\n  #define debug(x) 0\n#endif\nusing lint = long long;\nconstexpr int    INF  = 1 << 30;\nconstexpr lint   INFL = 1LL << 62;\nconstexpr int    MOD  = (int)1e9 + 7;\nconstexpr double EPS  = 1e-9;\nusing namespace std;\nnamespace { struct INIT { INIT() { cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } INIT; }\n\nclass SuffixArray {\n  template <typename T>\n  class RangeMinmaxQuery {\n    template <typename C>\n    struct Compare { bool operator()(const C &a, const C &b) const { return a < b; } };\n    template <typename S>\n    class SparseTable {\n      Compare<S> comp;\n      vector<vector<int>> st;\n      vector<int> lookup;\n      vector<S>   origin;\n\n      public:\n      SparseTable(void) {}\n      SparseTable(const vector<S> &v) { init(v); }\n      void init(const vector<S> &v) {\n        origin = v;\n        int lg_size = 0, v_size = v.size();\n        while ((1 << lg_size) <= v_size) ++lg_size;\n        st.assign((1 << lg_size), vector<int>(lg_size));\n        for (int i = 0; i < v_size; ++i) st[i][0] = i;\n        for (int j = 1; j < lg_size; ++j) {\n          for (int i = 0; i + (1 << j) <= (1 << lg_size); ++i) {\n            int l = st[i][j - 1], r = st[i + (1 << (j - 1))][j - 1];\n            st[i][j] = comp(v[r], v[l]) ? r : l;\n          }\n        }\n        lookup.assign(v_size + 1, 0);\n        for (int i = 2; i <= v_size; ++i) lookup[i] = lookup[i >> 1] + 1;\n      }\n      S query(int l, int r) const {\n        int lg_size = lookup[r - l];\n        S   lret = origin[st[l][lg_size]], rret = origin[st[r - (1 << lg_size)][lg_size]];\n        return comp(rret, lret) ? rret : lret;\n      }\n      int query_index(int l, int r) const {\n        int lg_size = lookup[r - l];\n        int lidx = st[l][lg_size], ridx = st[r - (1 << lg_size)][lg_size];\n        return comp(origin[ridx], origin[lidx]) ? ridx : lidx;\n      }\n      int size(void) const { return st.size(); }\n    };\n    Compare<T> comp;\n    int v_size, bl_size, bl_num;\n    SparseTable<pair<T, int>> st;\n    vector<int> bit;\n    vector<T>   origin;\n    static int lsb(const unsigned bit) {\n      static constexpr int table[32] = {0,  1,  28, 2,  29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4,  8,\n                                        31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6,  11, 5,  10, 9};\n      return table[((bit & -bit) * 0x077CB531) >> 27];\n    }\n    int block_query(const int l, const int r, const int bl_n) const {\n      int bl_l = bl_size * bl_n, x = bit[r] & ~((1 << (l - bl_l)) - 1);\n      return x ? bl_l + lsb(x) : r;\n    }\n\n    public:\n    RangeMinmaxQuery(void) {}\n    RangeMinmaxQuery(const vector<T> &v) { init(v); }\n    void init(const vector<T> &v) {\n      origin = v, v_size = v.size(), bl_size = 0;\n      while ((1 << bl_size) < v_size) ++bl_size;\n      bl_size = max(1, bl_size >> 1);\n      bl_num  = (v_size + bl_size - 1) / bl_size;\n      vector<pair<T, int>> bl_v(bl_num, {numeric_limits<T>::max(), INT_MAX});\n      for (int i = 0, j = 0; i < v_size; ++i, j = i / bl_size) if (comp(v[i], bl_v[j].first)) bl_v[j] = {v[i], i};\n      st.init(move(bl_v));\n      bit.assign(v_size, 0);\n      for (int i = 0, l = 0; i < bl_num; ++i, l += bl_size) {\n        vector<int> helper(bl_size), inc(bl_size);\n        for (int j = 0, now = -1, r = min(bl_size, v_size - l); j < r; ++j) {\n          while (now >= 0 && !comp(v[l + inc[now]], v[l + j])) --now;\n          helper[j]  = now >= 0 ? inc[now] : -1;\n          inc[++now] = j;\n        }\n        for (int j = 0, r = min(bl_size, v_size - l); j < r; ++j) bit[l + j] = helper[j] >= 0 ? bit[l + helper[j]] | (1 << helper[j]) : 0;\n      }\n    }\n    T   query(const int l, const int r) const { return origin[query_index(l, r)]; }\n    int query_index(int l, int r) const {\n      int lbl_n = l / bl_size, rbl_n = --r / bl_size, lbl_p = l % bl_size, rbl_p = r % bl_size;\n      if (lbl_n == rbl_n) return block_query(l, r, lbl_n);\n      int lret = lbl_p > 0 ? block_query(l, l - lbl_p + bl_size - 1, lbl_n++) : l;\n      int rlet = rbl_p < bl_size - 1 ? block_query(r - rbl_p, r, rbl_n--) : r;\n      int ret  = comp(origin[rlet], origin[lret]) ? rlet : lret;\n      if (lbl_n <= rbl_n) {\n        pair<T, int> mret = st.query(lbl_n, rbl_n + 1);\n        if (comp(mret.first, origin[ret])) ret = mret.second;\n      }\n      return ret;\n    }\n    int size(void) const { return v_size; }\n  };\n  vector<int>::iterator arr;\n  vector<int> string_to_vector(const string &s) const { return vector<int>(s.begin(), s.end()); }\n  bool lms(const int i, const vector<bool> &ltype) const { return i > 0 && !ltype[i] && ltype[i - 1]; }\n  vector<int> get_count(const vector<int>::const_iterator &str, const int len, const int chnum) const {\n    vector<int> cnt(chnum + 1);\n    for (int i = 0; i < len; ++i) ++cnt[str[i]];\n    return cnt;\n  }\n  vector<int> get_buckets(const vector<int> &cnt, const bool back) const {\n    int clen = cnt.size(), sum = 1;\n    vector<int> buckets(clen);\n    for (int i = 0; i < clen; ++i) {\n      sum += cnt[i];\n      buckets[i] = back ? sum : sum - cnt[i];\n    }\n    return buckets;\n  }\n  void induced_sort_ls(const vector<int>::const_iterator &str, const int len, const vector<bool> &ltype, const vector<int> &cnt, vector<int> &buckets) {\n    int prev;\n    buckets = get_buckets(cnt, false);\n    for (int i = 0; i < len; ++i) {\n      if ((prev = arr[i] - 1) >= 0 && ltype[prev]) arr[buckets[str[prev]]++] = prev;\n    }\n    buckets = get_buckets(cnt, true);\n    for (int i = len - 1; i >= 0; --i) {\n      if ((prev = arr[i] - 1) >= 0 && !ltype[prev]) arr[--buckets[str[prev]]] = prev;\n    }\n  }\n  void sa_is(const vector<int>::const_iterator &str, int len, const int chmax) {\n    fill(arr, arr + len, -1);\n    vector<bool> ltype(len);\n    ltype[len - 2] = true;\n    for (int i = len - 3; i >= 0; --i) ltype[i] = str[i] > str[i + 1] || (str[i] == str[i + 1] && ltype[i + 1] == true);\n    vector<int> cnt = get_count(str, len - 1, chmax), buckets = get_buckets(cnt, true);\n    arr[0] = len - 1;\n    for (int i = 1; i < len - 1; ++i) if (lms(i, ltype)) arr[--buckets[str[i]]] = i;\n    induced_sort_ls(str, len, ltype, cnt, buckets);\n    int lms_num = 0, now = -1, prev = -1, name = -1, mid = len / 2;\n    for (int i = 0; i < len; ++i) if (lms(arr[i], ltype)) arr[lms_num++] = arr[i];\n    fill(arr + lms_num, arr + len, -1);\n    for (int i = 0; i < lms_num; ++i) {\n      prev = now; now  = arr[i];\n      for (int nowp = now, prevp = prev; nowp < len && prevp < len; ++nowp, ++prevp) {\n        int lmscheck = (lms(nowp, ltype)) + lms(prevp, ltype);\n        if (prev == -1 || str[nowp] != str[prevp] || lmscheck & 1) { ++name; break; }\n        if (lmscheck && nowp > now) break;\n      }\n      arr[lms_num + now / 2] = name;\n    }\n    for (int i = len - 1, j = i; i >= lms_num; --i) if (arr[i] >= 0) arr[j--] = arr[i];\n    vector<int>::iterator arr2 = arr + len - lms_num;\n    if (lms_num == name + 1) {\n      for (int i = 0; i < lms_num; ++i) arr[arr2[i]] = i;\n    } else {\n      sa_is(arr2, lms_num, name);\n    }\n    for (int i = 0, j = 0; i < len; ++i) if (lms(i, ltype)) arr2[j++] = i;\n    for (int i = 0; i < lms_num; ++i) arr[i] = arr2[arr[i]];\n    fill(arr + lms_num, arr + len, -1);\n    buckets = get_buckets(cnt, true);\n    for (int i = lms_num - 1; i > 0; --i) {\n      int x = arr[i];\n      arr[i] = -1;\n      arr[--buckets[str[x]]] = x;\n    }\n    induced_sort_ls(str, len, ltype, cnt, buckets);\n  }\n  void init_lcp(const vector<int> &v) {\n    const int len = sa.size() - 1;\n    lcp.assign(len + 1, 0);\n    lcp[len] = len;\n    vector<int> rank(len + 1);\n    for (int i = 0; i <= len; ++i) rank[sa[i]] = i;\n    int h = 0;\n    for (int now = 0; now < len; ++now) {\n      int prev = sa[rank[now] - 1];\n      if (h > 0) --h;\n      for (; now + h < len && prev + h < len && v[now + h] == v[prev + h]; ++h);\n      lcp[rank[now] - 1] = h;\n    }\n    rmq.init(lcp);\n  }\n  pair<int, int> direct_compare(const vector<int> &v, int pos, int h = 0) const {\n    int olen = intv.size() - pos - 1, vlen = v.size(), comp;\n    pos += h;\n    for (int r = min(olen, vlen); h < r && intv[pos] == v[h]; ++h, ++pos);\n    if (h == vlen) comp = -1;\n    else if (h == olen) comp = 1;\n    else comp = (intv[pos] < v[h]) - (intv[pos] > v[h]);\n    return {comp, h};\n  }\n  RangeMinmaxQuery<int> rmq;\n\n  public:\n  vector<int> sa, lcp, intv;\n\n  SuffixArray(void) {}\n  SuffixArray(const string &s) { init(s); }\n  SuffixArray(vector<int> &v) { init(v); }\n  void init(const string &s) { init(string_to_vector(s), 127); }\n  void init(const vector<int> &v, int maxnum = 0) {\n    intv = v;\n    intv.push_back(-1);\n    sa.resize(intv.size());\n    arr = sa.begin();\n    sa_is(intv.begin(), intv.size(), (maxnum ? maxnum : *max_element(intv.begin(), intv.end())) + 1);\n    init_lcp(intv);\n  }\n  int lower_bound(const string &s) const { return lower_bound(string_to_vector(s)); }\n  int lower_bound(const vector<int> &v) const {\n    int l = 0, r = intv.size(), m = (l + r) / 2, h1, h2;\n    pair<int, int> comp = direct_compare(v, sa[m]);\n    if (comp.first > 0) l = m, h1 = comp.second;\n    else r = m, h1 = 0;\n    while (r - l > 1) {\n      m = (l + r) / 2, h2 = rmq.query(l, m);\n      if (h1 < h2) l = m;\n      else if (h1 > h2) r = m;\n      else {\n        comp = direct_compare(v, sa[m], h1);\n        if (comp.first > 0) l = m, h1 = comp.second;\n        else if (comp.first < 0) r = m;\n        else { r = m; break; }\n      }\n    }\n    return r;\n  }\n  int upper_bound(const string &s) const { vector<int> v = string_to_vector(s); return upper_bound(v); }\n  int upper_bound(vector<int> &v) const {\n    ++v.back();\n    int upper = lower_bound(v);\n    --v.back();\n    return upper;\n  }\n  vector<int> search(const string &s) const { return search(s); }\n  vector<int> search(vector<int> &v) const { return vector<int>(sa.begin() + lower_bound(v), sa.begin() + upper_bound(v)); }\n  int operator[](int x) const { return sa[x]; }\n  int size(void) const { return sa.size(); }\n};\n\nint main(void) {\n  string t;\n  int q;\n  cin >> t >> q;\n  vector<string> p(q);\n  rep (i, q) cin >> p[i];\n  SuffixArray sa(t);\n  rep (i, q) cout << (sa.lower_bound(p[i]) != sa.upper_bound(p[i])) << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\n#define NUM 48\nusing namespace std;\n\nint T_char_count[128] = {0},P_char_count[128];\n\nclass LocRecord{\n\npublic:\n\t//?????¢???????¢????\n\tLocRecord(){\n\t\tlocationTable = new int*[128];\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t}\n\n\t//-1?????£??\\\n\tvoid init(){\n\t\tint limit;\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init_index(){\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t}\n\n\tvoid regist_loc(int ch, int location){\n\t\tlocationTable[ch][index[ch]] = location;\n\t\tindex[ch]++;\n\t}\n\n\tint next_loc(int ch){\n\t\tint ret = locationTable[ch][index[ch]];\n\t\tindex[ch]++;\n\t\treturn ret;\n\t}\n\nprivate:\n\tint** locationTable;\n\tint index[128];\n};\n\nint main(){\n\n\tfor(int i = 0; i < 128; i++)T_char_count[i] = 0;\n\n\tint length;\n\n\tchar* T = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tfor(length = 0; T[length] != '\\0';length++){\n\t\tT_char_count[T[length]]++;\n\t}\n\n\tLocRecord locRecord;\n\tlocRecord.init();\n\n\t//T[i]????????????i??§???????????¨????¨????\n\tfor(int i = 0; i < length; i++){\n\t\tlocRecord.regist_loc(T[i],i);\n\t}\n\n\tull* HASH = new ull[length+1];\n\tull* P = new ull[length+1];\n\n\tHASH[0] = 0;\n\tP[0] = 1;\n\n\t//T??????????????\\???????±???????\n\tfor(int i = 1; i <= length; i++){\n\t\tHASH[i] = T[i-1] + HASH[i-1]*MOD;\n\t\tP[i] = P[i-1]*MOD;\n\t}\n\n\tint Q,S_length,left,P_char_count[128];\n\tscanf(\"%d\",&Q);\n\n\tchar S[1001];\n\tull S_HASH[1001],S_value,T_value;\n\tbool FLG;\n\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",S);\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tP_char_count[i] = 0;\n\t\t}\n\n\t\tfor(S_length = 0;S[S_length] != '\\0';S_length++){\n\t\t\tP_char_count[S[S_length]]++;\n\t\t}\n\n\t\tFLG = true;\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tif(T_char_count[i] < P_char_count[i]){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG)continue;\n\n\n\t\tS_HASH[0] = 0;\n\t\tfor(int i = 1; i <= S_length; i++){\n\t\t\tS_HASH[i] = S[i-1] + S_HASH[i-1]*MOD;\n\t\t}\n\n\t\tS_value = S_HASH[S_length];\n\n\t\tlocRecord.init_index();\n\n\t\tFLG = false;\n\n\t\twhile((left = locRecord.next_loc(S[0])) != -1){\n\t\t\tif(left+S_length-1>=length)break;\n\n\t\t\tif(T[left+S_length-1] != S[S_length-1])continue;\n\n\t\t\tT_value = HASH[left+S_length]-HASH[left]*P[S_length];\n\n\t\t\tif(T_value == S_value){\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(FLG){\n\t\t\tprintf(\"1\\n\");\n\t\t}else{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass SA{\npublic:\n  string S;\n  int n;\n  vector<int> sa;\n  \n  SA():n(-1){}\n  SA(string S):S(S),n(S.size()),sa(n){  \n    vector<int> rnk(n);\n    vector<int> tmp(n);\n    for(int i=0;i<n;i++) sa[i]=i;\n    for(int i=0;i<n;i++) rnk[i] = S[i];\n    \n    //k文字についてソートされているところから、2k文字でソート\n    for(int Len=1;Len<=n;Len*=2){\n      \n      //(rnk[i],rnk[i+k])と(rnk[j],rnk[j+k])を比較\n      auto compare_sa=[&](const int &i,const int &j){\n        if(rnk[i]!=rnk[j])return rnk[i]<rnk[j];\n        int ri=i+Len<n?rnk[i+Len]:-1;\n        int rj=j+Len<n?rnk[j+Len]:-1;\n        return ri<rj;\n      };\n      \n      sort(sa.begin(),sa.end(),compare_sa);\n\n      //いったんtmpに次のランクを計算して、rnkに代入\n      for(int i=1;i<n;i++)\n        tmp[sa[i]] = tmp[sa[i-1]] + compare_sa(sa[i-1],sa[i]);\n      rnk = tmp;\n    }\n  }\n\n  int lower_bound(string T){\n    assert(n >= 0);\n    int L=-1,R=S.length();\n    while(L+1<R){\n      int M = (L+R)/2;\n      S.compare(sa[M],T.size(),T)<0? L = M:R = M;\n    }\n    return R;\n  } \n\n  int upper_bound(string T){return lower_bound(T+char('z'+ 1));} \n  int count(string T){return upper_bound(T) - lower_bound(T);};\n};\n\nint main(){\n  string s;\n  cin>>s;\n  SA sa(s);\n  \n  int q;\n  cin>>q;\n  while(q--){\n    string t;\n    cin>>t;\n    int ans = sa.count(t) != 0;\n    printf(\"%d\\n\",ans);\n  }\n  \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ull unsigned long long\nusing namespace std;\null B=100000007;\nint h[1001]={};\nset<ull> s[1001];\nvoid contain(string b,int n){\n  int bl=b.size();\n  \n  ull t=1;\n  for(int i=0;i<n;i++)t*=B;\n\n  ull bh=0;\n  for(int i=0;i<n;i++)bh=bh*B+b[i];\n\n  for(int i=0;i+n<=bl;i++){\n    s[n].insert(bh);\n    if(i+n<bl)bh=bh*B+b[i+n]-b[i]*t;\n  }\n  return;\n}\n\nint main(){\n  int n;\n  string b;\n  cin>>b>>n;\n  for(int i=0;i<n;i++){\n    string a;\n    cin>>a;\n    int al=a.size();\n    if(al>b.size()){\n      cout<<'0'<<endl;\n      continue;\n    }\n    if(h[al]==0){\n      contain(b,al);\n      h[al]=1;\n    }\n    ull ah=0;\n    for(int j=0;j<al;j++)ah=ah*B+a[j];\n    cout<<s[al].count(ah)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define INF 1 << 30\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntypedef complex<double> dcomplex;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\nll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\n\nint n;\nstring s;\n\nbool solve(string t)\n{\n  int m = t.size();\n  map<char,int> f;\n  DOWN(i,m-1,0) f[t[i]] = i;\n  int p = m-1;\n  while(p<n)\n  {\n    int k = m-1;\n    while(k >= 0 && t[k] == s[p]) {k--; p--;}\n    if(k == -1) return true;\n    else p += max(f[s[p]],m-k+1);\n  }\n  return false;\n}\n\nint main()\n{\n  cin >> s;\n  n = s.size();\n  int q; cin >> q;\n  REP(i,q)\n  {\n    string t; cin >> t;\n    cout << solve(t) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\nint *Lv;\nint n, k;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n    return L_i < L_j;\n}\n\nint main()\n{\n    int *A, *newLv;\n    std::string T;\n    std::cin >> T;\n    n = T.size();\n\n    A = new int [n + 1]; Lv = new int [n + 1]; newLv = new int [n + 1];\n\n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n    std::sort(A, A + n, cmp_Lv);\n\n    newLv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        newLv[A[i]] = newLv[A[i - 1]] + (Lv[A[i]] != Lv[A[i - 1]] ? 1 : 0);\n    }\n    for(i = 0; i < n; i++){ Lv[i] = newLv[i]; }\n\n    k = 1;\n    while(1){\n        if(k > n) break;\n\n        std::sort(A, A + n, cmp);\n        newLv[A[0]] = 0;\n        for(i = 1; i < n; i++){ newLv[A[i]] = newLv[A[i - 1]] + (cmp(A[i - 1], A[i]) ? 1 : 0); }\n        for(i = 0; i < n; i++){ Lv[i] = newLv[i]; }\n\n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n\n    delete [] Lv; delete [] newLv;\n\n\tstd::string P;\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n\n    A[n] = n;\n\n    while(q){\n        cin >> P;\n        left = 0, right = n, exist = false;\n        while(left < right){\n\n            if(n < P.size()){ exist = false; break; }\n\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n\n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n\tdelete [] A;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nclass SuffixArrayInducedSorting\n{\nprivate:\n    static constexpr int encode(const int c) { return c == '$' ? 0 : 'a' <= c and c <= 'z' ? c - 'a' + 1 : 'A' <= c and c <= 'Z' ? c - 'A' + 27 : c - '0' + 53; }\n    static constexpr char decode(const int n) { return (n == 0 ? '$' : 'a' + n - 1); }\n    enum class Type : char {\n        L = 0,\n        S = 1,\n        LMS = 2,\n    };\n\npublic:\n    SuffixArrayInducedSorting(const string& s, const int kind_) : N(s.size() + 1), kind{kind_ + 1}, S(s.size() + 1, 0), type(N), next(N, 1), bucket(kind), num(kind, 0), head(kind, 0), tail(kind, 0)\n    {\n        for (int i = 0; i < s.size(); i++) {\n            S[i] = encode(s[i]);\n        }\n        initializeData();\n        sortLMS();\n    }\n    SuffixArrayInducedSorting(const vector<int>& s, const int kind_) : N(s.size() + 1), kind{kind_ + 1}, S(s), type(N), next(N, 1), bucket(kind), num(kind, 0), head(kind, 0), tail(kind, 0)\n    {\n        S.push_back(0);\n        initializeData();\n        sortLMS();\n    }\n    void debugPrint() const\n    {\n        for (int i = 0; i < N; i++) {\n            cout << decode(S[i]);\n        }\n        cout << endl;\n        for (int i = 0; i < N; i++) {\n            cout << (type[i] == Type::L ? \"L\" : \"S\");\n        }\n        cout << endl;\n        for (int i = 0; i < N; i++) {\n            cout << (type[i] == Type::LMS ? \"@\" : \" \");\n        }\n        cout << endl;\n        for (int i = 0; i < kind; i++) {\n            if (bucket[i].empty())\n                continue;\n            cout << \"[\" << decode(i) << \"]:\\n\";\n            for (const int p : bucket[i]) {\n                cout << \"  \" << p << endl;\n            }\n        }\n    }\n\n    vector<int> getSuffixArray() const\n    {\n        vector<int> ans(N - 1);\n        for (int pos = 0, i = 1; i < kind; i++) {  // 番兵以外\n            for (const int p : bucket[i]) {\n                ans[pos++] = p;\n            }\n        }\n        return ans;\n    }\n\nprivate:\n    void initializeData()\n    {\n        for (const int i : S) {\n            num[i]++;\n        }\n        for (int i = 0; i < kind; i++) {\n            bucket[i].resize(num[i], -1);\n            tail[i] = num[i] - 1;\n        }\n        type[N - 1] = Type::S;\n        for (int i = N - 2; i >= 0; i--) {\n            type[i] = (S[i] != S[i + 1] ? (S[i] < S[i + 1] ? Type::S : Type::L) : type[i + 1]);\n            if (type[i] == Type::L and type[i + 1] == Type::S) {\n                type[i + 1] = Type::LMS;\n                LMS.push_back(i + 1);\n            }\n        }\n        for (int pos = N - 1, i = N - 2; i >= 0; i--) {\n            next[i] = pos;\n            if (type[i] == Type::LMS) {\n                pos = i;\n            }\n        }\n    }\n\n    void sortLMS()\n    {\n        for (const int l : LMS) {\n            insertTail(l);\n        }\n        induce();\n        vector<int> lms;\n        for (int i = 0; i < kind; i++) {\n            for (const int p : bucket[i]) {\n                if (type[p] == Type::LMS) {\n                    lms.push_back(p);\n                }\n            }\n        }\n        const int size = lms.size();\n        vector<int> order(N / 2 + 1, 0);\n        int number = 1;\n        order[N / 2] = 1;\n        bool same = false;\n        for (int i = 1; i < size; i++) {\n            const int l1 = lms[i - 1];\n            const int r1 = next[l1];\n            const int l2 = lms[i];\n            const int r2 = next[l2];\n            if (r1 - l1 == r2 - l2 and vector<int>(S.begin() + l1, S.begin() + r1 + 1) == vector<int>(S.begin() + l2, S.begin() + r2 + 1)) {\n                same = true;\n            } else {\n                number++;\n            }\n            order[l2 / 2] = number;\n        }\n        if (same) {\n            vector<int> s(size);\n            for (int p = 0, i = 0; i <= N / 2; i++) {\n                if (order[i] > 0) {\n                    s[p++] = order[i];\n                }\n            }\n            const vector<int> sorted = SuffixArrayInducedSorting{s, number}.getSuffixArray();\n            for (int i = 0; i < kind; i++) {\n                head[i] = 0;\n                tail[i] = num[i] - 1;\n            }\n            for (int i = size - 1; i >= 0; i--) {\n                insertTail(LMS[size - 1 - sorted[i]]);\n            }\n            induce();\n        } else {\n            for (int i = 0; i < kind; i++) {\n                head[i] = 0;\n                tail[i] = num[i] - 1;\n            }\n            for (int i = size - 1; i >= 0; i--) {\n                insertTail(lms[i]);\n            }\n            induce();\n        }\n    }\n\n    void induce()\n    {\n        for (int i = 0; i < kind; i++) {\n            for (int j = 0; j < head[i]; j++) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] == Type::L) {\n                    insertHead(p - 1);\n                }\n            }\n            for (int j = tail[i] + 1; j < num[i]; j++) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] == Type::L) {\n                    insertHead(p - 1);\n                }\n            }\n        }\n        for (int i = 1; i < kind; i++) {  // 番兵以外\n            tail[i] = num[i] - 1;\n        }\n        for (int i = kind - 1; i >= 0; i--) {\n            for (int j = num[i] - 1; j > tail[i]; j--) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] != Type::L) {\n                    insertTail(p - 1);\n                }\n            }\n            for (int j = head[i] - 1; j >= 0; j--) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] != Type::L) {\n                    insertTail(p - 1);\n                }\n            }\n        }\n    }\n    void insertHead(const int i) { bucket[S[i]][head[S[i]]++] = i; }\n    void insertTail(const int i) { bucket[S[i]][tail[S[i]]--] = i; }\n\n    const int N;\n    const int kind;\n    vector<int> S;               // O(N)\n    vector<Type> type;           // O(N)\n    vector<int> next;            // O(N)\n    vector<vector<int>> bucket;  // O(N)\n    vector<int> num;             // O(K)\n    vector<int> head;            // O(K)\n    vector<int> tail;            // O(K)\n    vector<int> LMS;             // O(N)\n};\n\nint main()\n{\n    string s;\n    cin >> s;\n    const int size = s.size();\n    const vector<int> sa = SuffixArrayInducedSorting(s, 79).getSuffixArray();\n    int N;\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        string p;\n        cin >> p;\n        const int psize = p.size();\n        int inf = -1;\n        int sup = size;\n        while (sup - inf > 1) {\n            const int mid = (sup + inf) / 2;\n            const bool ok = s.substr(sa[mid], psize) < p;\n            if (ok) {\n                inf = mid;\n            } else {\n                sup = mid;\n            }\n        }\n        const bool ans = s.substr(sa[sup], psize) == p;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//\n// ?????¢\n// XCode??§???EOF??\\??????Ctrl+D\n// ?\\???Alt+\\\n// ans???????§?INT?????????2,147,483,647????¶????????????¨??????????????§long long?????£???????????????????????????\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////\n//ALDS1_14_D:   Multiple String Matching\n//Aho-Corasick????????????????????????MLE??????TLE?????£????????§???\n//Suffix-Array????????????\n////////////////////////////////////////\n\n//#define debug //*******************************************************************************************************************************************\n#ifdef debug\n#include <chrono>\n#endif\n\n#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstring> //memcpy\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <map>\n//#include <unordered_map> //hash func.\n#include <fstream> //ifstream, ofstream\n#include <iterator> //insert_iterator::inserter\n\n\n//#define NDEBUG //If NDEBUG is defined before #include <cassert>, assert will be ignored. You had better define NDEBUG when u submit the code.\n#include <cassert> //assert\n\nusing namespace std;\n\n\n#define dout cout\n//If u wanna output to a text file instead of standard output, plz define OUTPUTFILE.\n//#define OUTPUTFILE \"output.txt\" //*******************************************************************************************************************************************\n#ifdef OUTPUTFILE\n#define dout outputfile\nofstream outputfile(OUTPUTFILE);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n\n#define din cin\n//If u wanna input from a text file instead of standard input, plz define INPUTFROMTEXTFILE???.\n//#define INPUTFILE \"input.txt\" //*******************************************************************************************************************************************\n#ifdef INPUTFILE\n#define din inputfile\nifstream inputfile(INPUTFILE);\n#endif\n\n#define scan(A) scanf(\"%d\", &(A))\n#define disp(A) dout << #A << \" = \" << setw(3) << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \"\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n//#define dispAll(A,n) cout << #A << \" = \"; rep(j, 0, (n)) {cout << setw(3) << A[j] << \" \";} cout << endl\n\n#define sign(x) ((x)>0)-((x)<0) //x<0: -1, x=0: 0, x>0: +1\n#define p(i) (i)/2\n#define l(i) (i)*2\n#define r(i) (i)*2+1\n\nint dx[] = {1,-1, 0, 0, 1, 1,-1,-1}; //???????????????????????????????¨??????????????????????????????????\nint dy[] = {0, 0,-1, 1,-1, 1, 1,-1};\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef unsigned long ull;\n\nconst int INF = (int)2e9+10;\nconst ll INF_LL = (ll)9e18-1LL; //Be careful for overflow.\nconst ull INF_ULL = (ull)1e19-1ULL;\nconst int NONE = -1;\nconst ll MOD = (ll)1e9+7; //??§???????´???°?????£??¨??¨????????°????????????10???7??????\n\nconst int N_MAX = 1000010; //num of vertex or element\nconst int M_MAX = 10010; //num of edge\nconst int DATA_MAX = 1010;\n\nint N;\n\nchar T[N_MAX];\nint SA[N_MAX];\nint Rank[N_MAX];\nint tmp[N_MAX];\nint k;\n\nint Q;\nchar* P[M_MAX];\nvi placeOfP[M_MAX];\n\n#ifdef debug\nchar subT[N_MAX];\n#endif\n\nbool compare_sa(int i, int j) { //compare Rank(i, i+k) & Rank(j, j+k)\n    \n    if(Rank[i]!=Rank[j]) return Rank[i] < Rank[j];\n    else {\n        int rank_i = (i+k<N ? Rank[i+k] : -1);\n        int rank_j = (j+k<N ? Rank[j+k] : -1);\n        return rank_i < rank_j;\n    }\n    \n}\n\n\n\n#ifdef debug\nvoid subStr(int i, int k) { //subT = T[i ... i+k]\n    strncpy(subT, T+i, k);\n    subT[k] = '\\0';\n}\n\n\n\nvoid display() {\n    dout << \"-----\\n\";\n    disp(k);\n    \n    \n    rep(i,0,N) {\n        \n        dout << \" i = \";\n        disP(i);\n        dout << \" : SA[i] = \";\n        disP(SA[i]);\n        dout << \" ( \";\n        subStr(SA[i],k); disP(subT);\n        dout << \" ) , Rank = \";\n        disP(Rank[SA[i]]);\n        dout << endl;\n    }\n    \n    dout << \"-----\\n\";\n    dout << \"  i  Rank[i]   Rank[i+k]\\n\";\n    rep(i,0,N) {\n        disP(i);\n        disP(Rank[i]);\n        dout << \" ( \";\n        subStr(i, k); disP(subT);\n        dout << \" ) \";\n        disP( i+k < N ? Rank[i+k] : -1);\n        dout << \" ( \";\n        subStr(i+k, k); disP(subT);\n        dout << \" ) \";\n        dout << endl;\n    }\n}\n#endif\n\n\n\n\nvoid construct_sa() {\n    \n    //initialize\n    k = 1;\n    rep(i,0,N) {\n        SA[i] = i;\n        Rank[i] = T[i]; //k=1?????¨??????Rank[i]=ASCII Code of T[i]\n    }\n    \n    for(k=1; k<N; k*=2) {\n#ifdef debug\n        display();\n#endif\n        \n        sort(SA, SA+N, compare_sa);\n        \n    \n        tmp[ SA[0] ] = 0;\n        rep(i,1,N) {\n            tmp[ SA[i] ] = tmp[ SA[i-1] ] + compare_sa(SA[i-1], SA[i]); //1?????????k???????????§???Rank?????????????????°????????????????¬????????????§???Rank??????????????????\n        }\n        \n        rep(i,0,N) Rank[i] = tmp[i]; //??????????????§?????§????¬????k(=2k)???Rank????¨???????????????????\n        \n    }\n    \n}\n\n\nvoid binarySearch_P_from_SA() {\n\n    rep(i,0,Q) {\n        \n        int lenP = strlen(P[i]);\n        \n        int left = 0;\n        int right = N-1;\n        int mid;\n        \n        while(left <= right) {\n            mid = left + (right - left) / 2;\n            \n            if( strncmp(P[i],T+SA[mid],lenP) == 0 ) {\n                placeOfP[i].push_back(SA[mid]);\n                break;\n            }\n            else if(strncmp(P[i],T+SA[mid],lenP) < 0) right = mid - 1;\n            else left = mid + 1;\n        }\n        \n        //just for curiosity\n        int k = mid - 1;\n        while( k>0 && strncmp(P[i],T+SA[k],lenP) == 0 ) {\n            placeOfP[i].push_back(SA[k]);\n            k--;\n        }\n        \n        k = mid + 1;\n        while( k<N && strncmp(P[i],T+SA[k],lenP) == 0 ) {\n            placeOfP[i].push_back(SA[k]);\n            k++;\n        }\n        \n    }\n    \n}\n\n\n\n\nint main() {\n    \n    //cin, cout????????????  ?????¨??????cin?????????????????¨??¨cin??§???scanf?????????????????¨??¨scanf??§??±?????????????????????\n    cin.tie(0); //cin??¨cout??????????????????\n    ios::sync_with_stdio(false); //iostream??¨stdio??????????????????\n    \n    //read input data\n    scanf(\"%s\", T);\n    N = strlen(T);\n    \n    scanf(\"%d \", &Q);\n    rep(i,0,Q) {\n        P[i] = (char *)malloc(sizeof(char)*DATA_MAX);\n        scanf(\"%s\", P[i]);\n    }\n    \n#ifdef debug\n    disp(T);\n    disp(N);\n    rep(i,0,Q) { disP(P[i]); disp(strlen(P[i])); }\n#endif\n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //start timer\n    auto startTime = chrono::system_clock::now();\n#endif\n    //------------------------------------------------------------------------------------------\n    \n    \n    //Suffix-Array Algorithm\n    construct_sa();\n    \n    binarySearch_P_from_SA();\n    \n    \n    \n    \n    \n    \n#ifdef debug\n    dout << \"=====================================\\n\";\n    rep(i,0,Q) {\n        disP(P[i]); dout << \" : \";\n        rep(j,0,placeOfP[i].size()) {\n            disP(placeOfP[i][j]);\n        }\n        dout << endl;\n    }\n    dout << \"=====================================\\n\";\n#endif\n    \n    rep(i,0,Q) {\n        printf(\"%d\\n\", placeOfP[i].size()!=0);\n    }\n    \n    \n\n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //stop timer\n    auto endTime = chrono::system_clock::now();\n    auto dur = endTime - startTime;\n    auto msec = chrono::duration_cast<chrono::milliseconds>(dur).count();\n    dout << fixed << setprecision(4) << (double)msec/1000 << \" sec \\n\";\n#endif\n    //------------------------------------------------------------------------------------------\n    \n#ifdef INPUTFILE\n    inputfile.close();\n#endif\n    \n#ifdef OUTPUTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) { \n    //const int k=lcp(i,j);\n    const int k=lcp2(i,j,0,max(n-i,n-j)+1);\n    if(i+k>=n)return 1;\n    if(j+k>=n)return 0;\n    return s[i+k] <= s[j+k];\n    //return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  /*\n  inline int lcp(const int i, const int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n  */\n  inline int lcp2(const int& i, const int& j, const int& l, const int& r){\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\nif(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cassert>\n\nusing namespace std;\n\nstruct AhoCorasick {\n\n  static const int ALPHABET_SIZE = 2, root=0;\n\n  int N; // num of node\n\n  struct Node {\n    int parent, link;\n    int child[ALPHABET_SIZE], next[ALPHABET_SIZE];\n    char ch; //from parent\n    bool leaf;\n\n    Node():parent(0),link(0),ch('\\0'),leaf(false){\n      link=-1;\n      fill(child,child+ALPHABET_SIZE,-1);\n      fill(next,next+ALPHABET_SIZE,-1);\n    }\n  };\n\n  vector<Node> nodes;\n\n  AhoCorasick(int maxNodes):N(1),nodes(maxNodes){\n    nodes[root].link = root;\n    nodes[root].parent = -1;\n  }\n\n  void addString(string s) {\n    int cur = 0, sl=s.size();\n    for(int i=0;i<sl;i++){\n      char ch = s[i];\n      int c = ch - '0';\n      if(!~nodes[cur].child[c]){\n\tnodes[N].parent = cur;\n\tnodes[N].ch = ch;\n\tnodes[cur].child[c] = N++;\n      }\n      cur = nodes[cur].child[c];\n    }\n    nodes[cur].leaf = true;\n  }\n\n  int link(int id) {\n    Node node = nodes[id];\n    if(node.link == -1){\n      if(!node.parent)node.link=root;\n      else node.link=trans(link(node.parent),node.ch);\n    }\n    return node.link;\n  }\n\n  int trans(int id, char ch) {\n    int c = ch - '0';\n    Node node = nodes[id];\n    if(!~node.next[c]){\n      if(~node.child[c])node.next[c]=node.child[c];\n      else if(!id)node.next[c]=root;\n      else node.next[c]=trans(link(id),ch);\n    }\n    return node.next[c];\n  }\n};\n\ntypedef pair<int,int> pii;\n\nvector<pii> bakerBird(const vector<string>&T, const vector<string>&pattern){\n  int pl=pattern.size(),tl=T.size(),pil=pattern[0].size();\n  AhoCorasick aho(1000000);\n\n  for(int i=0;i<pl;i++){\n    aho.addString(pattern[i]);\n  }\n   \n\n  vector<int>acc;\n  for(int i=0;i<pl;i++){\n    int node = 0;\n    for(int j=0;j<pil;j++){\n      node = aho.trans(node, pattern[i][j]);\n      if(aho.nodes[node].leaf)acc.push_back(node);\n    }\n  }\n\n  const int til = T[0].size();\n    \n  vector<vector<int> >td(til);\n  for(int i=0;i<tl;i++){\n    int node = 0;\n    for(int j=0;j<til;j++){\n      node = aho.trans(node, T[i][j]);\n      td[til-j-1].push_back(node);\n    }\n  }\n\n  vector<pii>res;\n  int tl2=acc.size(),sl=acc.size()+tl+1;\n  vector<int>a(acc.size()+tl+2,-1);\n    \n  for(int i=0;i<til;i++){\n    vector<int>s=acc;\n    s.push_back(-1);\n    for(int j=0;j<til;j++)s.push_back(td[i][j]);\n    for(int k=0,j=-1;k<sl;a[++k]=++j)while(j>=0 && s[k]!=s[j])j=a[j];\n    for(int k=tl2+1;k<=sl;k++){\n      if(a[k]==tl2)res.push_back(pii(k-tl2*2-1,til-i-pil));\n    }\n  }\n  return res;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n  \n  int h,w,r,c;\n  \n  cin >> h >> w;\n  vector<string>s(h);\n  for(int i=0;i<h;i++)cin >> s[i];\n  \n  cin >> r >> c;\n  vector<string>t(r);\n  for(int i=0;i<r;i++)cin >> t[i];\n  \n  vector<pii>res=bakerBird(s,t);\n  sort(res.begin(),res.end());\n\n  for(int i=0;i<res.size();i++)\n    cout << res[i].first << \" \" << res[i].second << \"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n\nusing namespace std;\n\n#define NUM 48\n\nint checkTable[10000]={0};\n\nclass Node{\npublic:\n\tNode(){\n\t\tch=0;\n\t\tnum_of_child=num_of_end_str=0;\n\t\tparent=0,nodes=0;\n\t\tcameFLG=false;\n\t\ttable=new int[128-NUM];\n\t\tfor(int i=48;i<=122;i++)table[i-NUM]=0;\n\t}\n\n\tvoid addSTR(char str[],int index,int ptn_index){\n\t\tch=str[index];\n\t\tif(str[index+1]=='\\0'){\n\t\t\tend_str.push_back(ptn_index);\n\t\t\tnum_of_end_str++;\n\t\t}else{\n\t\t\tif(num_of_child==0){\n\t\t\t\tnodes=new Node*[128-NUM];\n\t\t\t}\n\t\t\tif(table[str[index+1]-NUM]==0){\n\t\t\t\tnodes[str[index+1]-NUM]=new Node();\n\t\t\t\ttable[str[index+1]-NUM]=1;\n\t\t\t}\n\t\t\tnum_of_child++;\n\t\t\tnodes[str[index+1]-NUM]->parent=this;\n\t\t\tnodes[str[index+1]-NUM]->addSTR(str,index+1,ptn_index);\n\t\t}\n\t}\n\tbool searchSTR(char str[],int index){\n\t\tif(!cameFLG){\n\t\t\tfor(int i=0;i<num_of_end_str;i++)checkTable[end_str[i]]=1;\n\t\t\tcameFLG=true;\n\t\t}\n\t\tif(num_of_child==0){\n\t\t\tif(parent != 0){\n\t\t\t\tNode* tmp=this->parent;\n\t\t\t\ttmp->num_of_child--;\n\t\t\t\ttmp->table[this->ch-NUM]=0;\n\t\t\t\twhile(tmp->parent!=0&&tmp->num_of_child==0){\n\t\t\t\t\ttmp->parent->num_of_child--;\n\t\t\t\t\ttmp->parent->table[tmp->ch-NUM]=0;\n\t\t\t\t\ttmp=tmp->parent;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}else{\n\t\t\tif(str[index+1]=='\\0')return true;\n\t\t\telse{\n\t\t\t\tif(table[str[index+1]-NUM]==1){\n\t\t\t\t\treturn nodes[str[index+1]-NUM]->searchSTR(str,index+1);\n\t\t\t\t}else{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint num_of_child;\n\tint num_of_end_str;\n\tvector<int> end_str;\n\tNode** nodes;\n\tNode* parent;\n\tint* table;\n\tchar ch;\n\tbool cameFLG;\n};\n\n\nclass MotherNode{\npublic:\n\tMotherNode(){\n\t\tmotherNode = new Node*[128-NUM];\n\t\tfor(int i=48;i<=122;i++){\n\t\t\tmotherNode[i-NUM]=new Node();\n\t\t}\n\t}\n\tvoid addSTR(char str[],int ptn_index){\n\t\tmotherNode[str[0]-NUM]->addSTR(str,0,ptn_index);\n\t}\n\tbool searchSTR(char str[]){\n\t\treturn motherNode[str[0]-NUM]->searchSTR(str,0);\n\t}\nprivate:\n\tNode** motherNode;\n};\n\nint main(){\n\n\tchar* T = new char[1000001];\n\tint Q,T_length=0;\n\tscanf(\"%s\",T);\n\tscanf(\"%d\",&Q);\n\tchar* P = new char[1001];\n\tMotherNode motherNode;\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\"%s\",P);\n\t\tmotherNode.addSTR(P,i);\n\t}\n\tfor(int i=0;T[i]!='\\0';i++)T_length++;\n\tchar tmp[1001];\n\tfor(int i=0;i<T_length;i++){\n\t\tfor(int k=0;k<1001;k++)tmp[k]='\\0';\n\t\tfor(int k=0;T[i+k]!='\\0'&&k<1000;k++){\n\t\t\ttmp[k]=T[i+k];\n\t\t\tif(motherNode.searchSTR(tmp)==false)break;\n\t\t}\n\t}\n\n\tfor(int i=0;i<Q;i++){\n\t\tif(checkTable[i]==0)printf(\"0\\n\");\n\t\telse{\n\t\t\tprintf(\"1\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\nusing namespace std;\n \nint main(){\n    string T, P;\n    long Q;\n    cin >> T >> Q;\n    for (long j = 0; j < Q; j++){\n        cin >> P;\n        long flag = 0;\n        if (T.size() < P.size()){\n            printf(\"0\\n\");\n            continue;\n        }\n        else\n        for (long i = 0; i < T.size() - P.size() + 1; i++){\n            if (T[i] == P[0]){\n                if (T.substr(i, P.size()) == P) flag = 1;\n            }\n        }\n        if (flag) printf(\"1\\n\");\n        else printf(\"0\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_N 1000000\ntypedef unsigned long long ull;\nusing namespace std;\n\nint n, k;\nint Rank[MAX_N + 1];\nint tmp[MAX_N + 1];\n\nbool Compare_SA(int i, int j) {\n\tif (Rank[i] != Rank[j]) return Rank[i] < Rank[j];\n\telse {\n\t\tint ri = i + k <= n ? Rank[i + k] : -1;\n\t\tint rj = j + k <= n ? Rank[j + k] : -1;\n\t\treturn ri < rj;\n\t}\n}\n\nvoid Construct_SA(const string &S, vector<int> &SA) {\n\tn = S.length();\n\tSA = vector<int>(n + 1);\n\n\tfor (int i = 0; i <= n;i++) {\n\t\tSA[i] = i;\n\t\tRank[i] = i < n ? S[i] : -1;\n\t}\n\n\tfor (k = 1; k <= n; k *= 2) {\n\t\tsort(SA.begin(), SA.end(), Compare_SA);\n\n\t\ttmp[SA[0]] = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\ttmp[SA[i]] = tmp[SA[i - 1]] + (Compare_SA(SA[i - 1], SA[i]) ? 1 : 0);\n\t\t}\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tRank[i] = tmp[i];\n\t\t}\n\t}\n}\n\nbool Contain(const string &S, const vector<int> &SA, const string &T) {\n\tint a = 0, b = S.length();\n\twhile (b - a > 1) {\n\t\tint c = (a + b) / 2;\n\t\tif (S.compare(SA[c], T.length(), T) < 0) a = c;\n\t\telse b = c;\n\t}\n\treturn S.compare(SA[b], T.length(), T) == 0;\n}\n\nint main()\n{\n\tint Q;\n\tstring T, P;\n\tvector<int> SA;\n\tcin >> T;\n\tConstruct_SA(T, SA);\n\tcin >> Q;\n\twhile (Q--) {\n\t\tcin >> P;\n\t\tcout << Contain(T, SA, P) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\n\n#define fi(x) get<0>(x)\n#define se(x) get<1>(x)\n\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\ntypedef vector<pll> vpl;\n\nstring t;\nstring p;\nlli q;\n\nvll sa;\nvll tmp;\nvpl rnk;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> t;\n    sa = vll(t.size());rnk = vpl(t.size());tmp = vll(t.size());\n    for(lli i = 0;i < t.size();i++) sa[i] = i;\n    for(lli i = 0;i < t.size();i++) fi(rnk[i]) = t[i];\n    for(lli k = 1;k < t.size();k *= 2){\n        sort(sa.begin(),sa.end(),[](lli a,lli b){\n            return rnk[a] < rnk[b];\n        });\n        for(lli i = 1;i < sa.size();i++){\n            tmp[sa[i]] = tmp[sa[i-1]];\n            if(rnk[sa[i]] != rnk[sa[i-1]]) tmp[sa[i]]++;\n        }\n        for(lli i = 0;i < sa.size();i++){\n            fi(rnk[sa[i]]) = tmp[sa[i]];\n        }\n        for(lli i = 0;i < sa.size();i++){\n            if(sa[i]+k < t.size()) se(rnk[sa[i]]) = fi(rnk[sa[i]+k]);\n            else se(rnk[sa[i]]) = -1;\n        }\n    }\n    sort(sa.begin(),sa.end(),[](lli a,lli b){\n        return rnk[a] < rnk[b];\n    });\n    //for(lli i = 0;i < sa.size();i++) cout << sa[i] << endl;\n    /*\n    for(lli i = 0;i < sa.size();i++){\n        for(lli j = sa[i];j < t.size();j++) cout << t[j];\n        cout << endl;\n    }\n    */\n    cin >> q;\n    for(lli i = 0;i < q;i++){\n        cin >> p;\n        auto from = sa.begin();\n        auto to = sa.end();\n        for(lli i = 0;i < p.size();i++){\n            from = lower_bound(from,to,p[i],[i](lli x,char c){\n                if(x+i >= t.size()) return false;\n                return t[x+i] < c;\n            });\n            to = lower_bound(from,to,p[i],[i](lli x,char c){\n                if(x+i >= t.size()) return false;\n                return t[x+i] < c+1;\n            });\n            //cout << from-sa.begin() << \" \" << to-sa.begin() << endl;\n        }\n        if(to-from > 0) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<stdio.h>\n\n#define A 1995455101 // large prime number.\n#define B 1995455447 // large prime number, bigger than A.\n\nint main()\n{\n    string T; cin >> T; int len_T = T.size();\n    string P;           int len_P;\n    long long *has_T, *has_P;\n    has_T = new long long [len_T];\n    has_P = new long long [10001];\n    long long last_has;\n\n    long long h; int i;  // hash coding.\n    h = 0;\n    for(i = 0; i < len_T; i++){ h = (h * A + T[i]) % B; has_T[i] = h; }\n    long long power, x, y, z;\n\n    int q;\n    cin >> q;\n    while(q){\n        cin >> P; len_P = P.size();\n\n        h = 0;\n        for(i = 0; i < len_P; i++){ h = (h * A + P[i]) % B; has_P[i] = h; }\n        last_has = has_P[len_P - 1];\n\n        // A^{len_P} Mod B.\n        x = A, y = len_P, z = 1;\n        for( ; y; y /= 2){\n            if((y & 1) != 0){ z = (z * x) % B; }\n            x = (x * x) % B;\n        }\n        power = z;\n\n        for(i = len_P - 1; i < len_T; i++){\n            if(has_T[i] == ((i >= len_P ? has_T[i - len_P] : 0) * power + last_has) % B){\n                printf(\"%d\\n\", 1); break;\n            }\n        }\n        if(i == len_T){ printf(\"%d\\n\", 0); }\n        q--;\n    };\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/////////////////////////////////////////////////////////\n//\n//  ~/Izumi_Chiharu/c/temp.cpp file\n//  Last Updated: 2018-06-17 ...Maybe\n//\n//    I hope you adding this code to the setting file\n//    alias g++='g++ -std=c++1y -DDEBUG_LOCAL'\n//\n//  My sweet heart Chiharu Izumi\n//\n/////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid print_Qbey(){cout<<\n\"           H                                           M#5J~d              \"  <<endl<<\n\"         Hm.?WMM                                   MMB^ .Z  d              \"  <<endl<<\n\"         MZS.` ?7WMM                             M#=`` (!`` d              \"  <<endl<<\n\"         HP?X,```  ?TMM                       MMY! ` .d: `` d              \"  <<endl<<\n\"         Hb;<U,`````` (TMM                 HM ^ ``` .V>_` `.W              \"  <<endl<<\n\"           ;><?n. `` ````?WHHMMHHHMMMMMM MMY```` ` (3<< `` .M              \"  <<endl<<\n\"         HN<>>>?W,`` `` ` (77!~`  ```~!?7'``` `` .d>>><``  .M              \"  <<endl<<\n\"          M2<>>>>?n.`` `` `` `` ``` `` ```` `` `.X>1++< `` (H              \"  <<endl<<\n\"          MK<>>>>+?S.``` `` ```` ``` ``` `` `` .Z``` ?4-.` jM              \"  <<endl<<\n\"           N2><+d=(Y^ `` `` ` ` ` ` `` `` `` `` T~.`````?=(dM              \"  <<endl<<\n\"           MR;JY~`~``` `` `` ``` ``` `` `` `` ``` u, `` `` 7M              \"  <<endl<<\n\"            NV!_`` `` `` ```` ``` `` `` `` ``` ``` C& ` ```` TMM           \"  <<endl<<\n\"           MY.(-`` ` `` ``  `` ` `` `` `` `` ``  `` (n ` ` ``` 7M          \"  <<endl<<\n\"         HMD-(D`` ``` `` ``` `` `` `` `` `` ` ``` ```(n ` `` `` (WM        \"  <<endl<<\n\"         M _(d```` `` ``` ``` ``` `` `` `` ``` ``` `` .b.`` `` ```?MH      \"  <<endl<<\n\"        MM!_(%` `` `` `` ` ` `` `` `` ``` `` `` ` `` ` (l`` ``````` TMH    \"  <<endl<<\n\"       H#>__d:`` .JXVS, ``` `` ` `` `` `.JXWH&.``` ```` O; `` ` ` `` -WM   \"  <<endl<<\n\"       M%.~(k ``.HXH[ dr ```` ``` `` `` dWWN- u. `` ``` ,M,``` ``` ``` ?MMM\"  <<endl<<\n\"      MF_~~($`` .WXMMWX$ ` ``` `` ``` ` dXM HHK````` `` ,HN-``````````.-=jg\"  <<endl<<\n\"MMMMHMY.~~~(R ``` 799Y!```` ``` `` `` `` ?UUUY!`` ````` (M N, `` ```.Z3J=``\"  <<endl<<\n\"gaJJdD.~~::_X|`````````````` `````` `` ` ``` ````` ``` .H  MN,``` .Yiv! ```\"  <<endl<<\n\"   MD_:~:~:~(T.`````````` ``` ` ` ````` ``` ``` ``````.M     N, .Ziv!`` ._~\"  <<endl<<\n\" MM'_:::::::~(N+.`````````` .`.(.` .` ``` ```` ```` .dM       NZ1v! .-_~~``\"  <<endl<<\n\" #:(::::::::~(HMNa..  ``````_?!`?7! `` ````  ...-(+7WMM     HM3(b _:<``..`.\"  <<endl<<\n\"=_;::::::::<(H    MMHaJ--_--........-.__~~~~(&v7<~``` ?MM   M>gM9h,_.......\"  <<endl<<\n\";;;;;;;:;::(drWM          HHmgggg&gzOtOzz<<~~~~~_`` ``` ?MMMH+ggM Mm-......\"  <<endl<<\n\"e<>>;>>;;><dMMJM                  Nc_~~~~~~~~~~_ ``  ` `` 7H&-...?THNe-_._(\"  <<endl<<\n\",4m+>>>>>>j MM(W                   N-~~~~~~~~:_`` ``` ` ``  ?7UHHqqHWHMm+__\"  <<endl<<\n\"vX+vT4k&&dMMD!+M                   MR_~~~~~:_````` ```` ````````` ````  ?We\"  <<endl<<\n\"???zTwiJ-(((JdM                    MK_~~~~:_``` ` ` ` `` ` ` ` ``` ```````?\"  <<endl<<\n\"1uukgHM                            MH_~~~_``` `` ``` `` `` `` ` `` ` `  ```\"  <<endl<<\n\"CugM                                N;~~:_ ` `` `` ``` `` ````` ``` ``` ` `\"  <<endl<<\n\"H                                   M[~~~_4, `   ` `` `` ``  ``` `` `` ``` \"  <<endl<<\n\"                                    Hb~~~~~?n  (: `` `` `` `` ` ` `` `` ```\"  <<endl<<\n\"                                    Hb~~~~~~(4,J_ `` ```  ```` ``` `` `` ` \"  <<endl<<\n\"                                     N-~~~~~~(MM_` `` ` (}  `` `` `` `` ```\"  <<endl<<\n\"                                     Mr_~~~~~(HH: `` `` j!`` `` `` `` `` ``\"  <<endl<<\n\"                                     Mb~~~~~~(WH:`` `` .Z `` `` `` ``` `` `\"  <<endl<<\n\"                                      N:~~~~~(WM{ `` ` .H+.. `` `  .``` `` \"  <<endl;}\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n//#define int long long\n\n#define _overload3(_1,_2,_3,name,...) name\n#define _REP(i,n) REAP(i,0,n)\n#define REAP(i,a,b) for(int i=int(a);i<int(b);++i)\n#define REP(...) _overload3(__VA_ARGS__,REAP,_REP,)(__VA_ARGS__)\n\n#define _REPR(i,n) REAPR(i,n,0)\n#define REAPR(i,a,b) for(int i=int(a-1);i>=int(b);--i)\n#define REPR(...) _overload3(__VA_ARGS__,REAPR,_REPR,)(__VA_ARGS__)\n\n#define ALL(a) a.begin(),a.end()\n#define rALL(a) a.rbegin(),a.rend()\n\n#define coutALL(a) {int loop_coutALL=0;for(auto e:a) cout<<(loop_coutALL++?\" \":\"\")<<e; cout<<endl;}\n#define coutYN(a) cout<<(a?\"Yes\":\"No\")<<endl;\n#define coutyn(a) cout<<(a?\"yes\":\"no\")<<endl;\n\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n\nconst int INF=1145141919;\nconst int MOD=(int)1e9+7;\nconst double EPS=1e-12;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const int dx[]={-1,-1,-1,0,1,1,1,0},dy[]={-1,0,1,1,1,0,-1,-1};\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\n\ntypedef pair<int,int> pii;\ntypedef pair<int,string> pis;\ntypedef pair<string,int> psi;\ntypedef pair<string,string> pss;\n\ntypedef long long ll;\n\ntemplate<class T> ll upper(T n,T m){return (n+m-1)/m;};\ntemplate<class T> ll rounding(T n){return (long double)n+0.5;};\n\ninline int qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a;a=1ll*a*a;}while(b>>=1);return ans;}\ninline int qp(int a,ll b,int mo){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\n\nstruct Arithmetic{Arithmetic(){cin.tie(0);ios::sync_with_stdio(0);cout<<fixed<<setprecision(20);}};\n\n//#define DEBUG_LOCAL\n\n#ifdef DEBUG_LOCAL\ntemplate<typename T> void deb(T a){cerr<<\"deb: \"<<a<<\"ですねぇ！\"<<endl;}\n#define debl {cerr<<\"debug: \"<<__LINE__<<\"行目だよーんおほほ\"<<endl;}\nvoid what_cr(){cout<<__GCC_ATOMIC_CHAR16_T_LOCK_FREE<<\" ←なんだろーこの数字？\"<<endl;}\nvoid t_t(){cout\n    <<endl\n    <<\"------------------------\"<<endl\n    <<\"| Presented by         |\"<<\" Compiled \"<<__FILE__<<endl\n    <<\"| \"<<__DATE__<<\" \"<<__TIME__<<\" |\"<<endl\n    <<\"|        Chiharu Izumi |\"<<\"      to get the AC :)\"<<endl\n    <<\"------------------------\"<<endl;\n}\n#else\ntemplate<typename T>void deb(T a){}\n#define debl ;\nvoid what_cr(){}void t_t(){}\n#endif\n\nint n,k;\nint ran[1000001],tmp[1000001];\n\nbool comp_sa(int i,int j){\n\n  if(ran[i]!=ran[j]) return ran[i]<ran[j];\n\n  else {\n\n    int ri=i+k<=n?ran[i+k]:-1;\n    int rj=j+k<=n?ran[j+k]:-1;\n\n    return ri<rj;\n\n  }\n\n}\n\nvoid make_sa(string s,int sa[]){\n\n  n=s.size();\n\n  REP(i,n+1){\n\n    sa[i]=i;\n    ran[i]=i<n?s[i]:-1;\n\n  }\n\n  for(k=1;k<=n;k*=2){\n\n    sort(sa,sa+n+1,comp_sa);\n\n    tmp[sa[0]]=0;\n    REP(i,n+1) tmp[sa[i]]=tmp[sa[i-1]]+comp_sa(sa[i-1],sa[i]);\n    REP(i,n+1) ran[i]=tmp[i];\n\n  }\n\n}\n\nbool find_t(string s,int sa[],string t){\n\n  int l=0,r=s.size();\n  for(;r-l>1;){\n    int m=(l+r)/2;\n    if(s.compare(sa[m],t.size(),t)<0) l=m;\n    else r=m;\n  }\n\n  return !s.compare(sa[r],t.size(),t);\n\n}\n\nsigned main(){\n\n  Arithmetic Exception;\n\n  int m,sa[1000001];\n  string s;\n  cin>>s>>m;\n\n  make_sa(s,sa);\n\n  REP(i,m){\n\n    string t;\n    cin>>t;\n    cout<<find_t(s,sa,t)<<endl;\n\n  }\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    S.push_back('$');\n    vector<int> c(n+1,0),ord(n+1,0);\n    for(int i=0;i<=n;i++) ord[i]=n-i;\n    sort(ord.begin(),ord.end(),[&](int a,int b){return S[a]<S[b];});\n    \n    for(int i=0;i<=n;i++){\n      sa[i]=ord[i];\n      c[i]=S[i];\n    }\n    \n    for(int len=1;len<=n;len*=2){\n      vector<int> r=c;\n      for(int i=0;i<=n;i++){\n\t c[sa[i]] = i > 0 && r[sa[i - 1]] == r[sa[i]] && sa[i - 1] + len < n && r[sa[i - 1] + len / 2] == r[sa[i] + len / 2] ? c[sa[i - 1]] : i;\n      }\n      vector<int> cnt(n+1);\n      for(int i=0;i<=n;i++) cnt[i]=i;\n      vector<int> s=sa;\n      for(int i=0;i<=n;i++){\n\tint s1=s[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n);\n    for(int i=0;i<n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    //assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\n#define NUM 48\nusing namespace std;\n\nint T_char_count[128] = {0},P_char_count[128];\n\nclass LocRecord{\n\npublic:\n\t//?????¢???????¢????\n\tLocRecord(){\n\t\tlocationTable = new int*[128];\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t}\n\n\t//-1?????£??\\\n\tvoid init(){\n\t\tint limit;\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init_index(){\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t}\n\n\tvoid regist_loc(int ch, int location){\n\t\tlocationTable[ch][index[ch]] = location;\n\t\tindex[ch]++;\n\t}\n\n\tint next_loc(int ch){\n\t\tint ret = locationTable[ch][index[ch]];\n\t\tindex[ch]++;\n\t\treturn ret;\n\t}\n\nprivate:\n\tint** locationTable;\n\tint index[128];\n};\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\treturn hashValue < arg.hashValue;\n\t};\n\n\tvector<int> id;\n\tull hashValue;\n};\n\nint main(){\n\n\tfor(int i = 0; i < 128; i++){\n\t\tT_char_count[i] = 0;\n\t}\n\n\tint T_length;\n\n\tchar* T = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tfor(T_length = 0; T[T_length] != '\\0';T_length++){\n\t\tT_char_count[T[T_length]]++;\n\t}\n\n\tLocRecord locRecord;\n\tlocRecord.init();\n\n\t//T[i]????????????i??§???????????¨????¨????\n\tfor(int i = 0; i < T_length; i++){\n\t\tlocRecord.regist_loc(T[i],i);\n\t}\n\n\tull* HASH = new ull[T_length+1];\n\tull* P = new ull[T_length+1];\n\n\tHASH[0] = 0;\n\tP[0] = 1;\n\n\t//T??????????????\\???????±???????\n\tfor(int i = 1; i <= T_length; i++){\n\t\tHASH[i] = T[i-1] + HASH[i-1]*MOD;\n\t\tP[i] = P[i-1]*MOD;\n\t}\n\n\n\tvector<Info> V[75][1001]; //V[????????????][??????] = ???????????????????????\\???\n\tvector<int> LENG[75]; //LENG[????????????] = ??????????????????\n\n\tint Q,S_length,left,P_char_count[128];\n\tscanf(\"%d\",&Q);\n\n\tbool check[Q];\n\n\tfor(int i = 0; i < Q; i++)check[i] = false;\n\n\tchar S[1001];\n\tull S_HASH[1001],S_value,T_value,D;\n\tbool FLG,isExist;\n\n\t//Q??¶??????????????\\???????¨????\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",S);\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tP_char_count[i] = 0;\n\t\t}\n\n\t\tfor(S_length = 0;S[S_length] != '\\0';S_length++){\n\t\t\tP_char_count[S[S_length]]++;\n\t\t}\n\n\t\tFLG = true;\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tif(T_char_count[i] < P_char_count[i]){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG)continue;\n\n\t\tif(S_length == 1){\n\t\t\tcheck[loop] = true;\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tS_HASH[0] = 0;\n\t\tfor(int i = 1; i <= S_length; i++){\n\t\t\tS_HASH[i] = S[i-1] + S_HASH[i-1]*MOD;\n\t\t}\n\n\t\tS_value = S_HASH[S_length];\n\n\t\t//???????????\\?????????????????????????????????\n\t\tisExist = false;\n\t\tfor(int a = 0; a < V[S[0]-NUM][S_length].size();a++){\n\t\t\tif(V[S[0]-NUM][S_length][a].hashValue == S_value){\n\t\t\t\tV[S[0]-NUM][S_length][a].id.push_back(loop); //?????????????????\\?????§?????°???id???????????????\n\t\t\t\tisExist = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!isExist){\n\t\t\tInfo new_info;\n\t\t\tnew_info.hashValue = S_value;\n\t\t\tnew_info.id.push_back(loop);\n\t\t\tV[S[0]-NUM][S_length].push_back(new_info);\n\t\t}\n\n\t\tisExist = false;\n\t\tfor(int a = 0; a < LENG[S[0]-NUM].size();a++){\n\t\t\tif(LENG[S[0]-NUM][a] == S_length){\n\t\t\t\tisExist = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!isExist){\n\t\t\tLENG[S[0]-NUM].push_back(S_length);\n\t\t}\n\t}\n\n\t//??????????????????sort\n\tfor(int i = 48; i <= 122; i++)sort(LENG[i-NUM].begin(),LENG[i-NUM].end());\n\t//hashValue????????????sort\n\tfor(int i = 48; i <= 122; i++){\n\t\tfor(int b = 0; b < LENG[i-NUM].size();b++){\n\t\t\tsort(V[i-NUM][LENG[i-NUM][b]].begin(),V[i-NUM][LENG[i-NUM][b]].end());\n\t\t}\n\t}\n\n\tint calc_length,calc_left,calc_right,calc_m,tmp_len;;\n\n\tfor(int word = 48; word <= 122; word++){\n\t\tfor(int i = 0; i < LENG[word-NUM].size();i++){\n\n\t\t\tlocRecord.init_index();\n\t\t\tcalc_length = LENG[word-NUM][i];\n\n\t\t\twhile((left = locRecord.next_loc(word)) != -1){\n\t\t\t\tif(left+calc_length-1 >= T_length)break;\n\n\t\t\t\tT_value = HASH[left+calc_length]-HASH[left]*P[calc_length];\n\n\t\t\t\tcalc_left = 0;\n\t\t\t\tcalc_right = V[word-NUM][calc_length].size()-1;\n\t\t\t\tcalc_m = (calc_left+calc_right)/2;\n\n\t\t\t\twhile(calc_left <= calc_right){\n\t\t\t\t\tif(V[word-NUM][calc_length][calc_m].hashValue == T_value){\n\t\t\t\t\t\tfor(int p = 0; p < V[word-NUM][calc_length][calc_m].id.size();p++){\n\t\t\t\t\t\t\tcheck[V[word-NUM][calc_length][calc_m].id[p]] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(V[word-NUM][calc_length][calc_m].hashValue < T_value){\n\t\t\t\t\t\t\tcalc_left = calc_m+1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcalc_right = calc_m-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcalc_m = (calc_left+calc_right)/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tif(check[i])printf(\"1\\n\");\n\t\telse{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nclass SuffixArray{\n    void CreateBeginBucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        int sum=0;\n        for(int i=0;i<bucket.size();i++){bucket[i]+=sum;swap(sum,bucket[i]);}\n    }\n\n    void CreateEndBucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        for(int i=1;i<bucket.size();i++)bucket[i]+=bucket[i-1];\n    }\n\n    void InducedSort(vector<int>&v,vector<int>&SA,int mv,vector<int>&bucket,vector<int>&isL){\n        CreateBeginBucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(SA[i]>0&&isL[SA[i]-1])SA[bucket[v[SA[i]-1]]++]=SA[i]-1;\n    }\n\n    void InvertInducedSort(vector<int>&v,vector<int>&SA,int mv,vector<int>&bucket,vector<int>&isL){\n        CreateEndBucket(v,bucket);\n        for(int i=v.size()-1;i>=0;i--)if(SA[i]>0&&!isL[SA[i]-1])SA[--bucket[v[SA[i]-1]]]=SA[i]-1;\n    }\n\n    vector<int>SA_IS(vector<int>v,int mv){\n        if(v.size()==1)return vector<int>(1,0);\n\n        vector<int>isL(v.size());\n        vector<int>bucket(mv+1);\n        vector<int>SA(v.size(),-1);\n        auto isLMS=[&](int x)->bool{return x>0&&isL[x-1]&&!isL[x];};\n\n        isL[v.size()-1]=0;\n        for(int i=v.size()-2;i>=0;i--)isL[i]=v[i]>v[i+1]||(v[i]==v[i+1]&&isL[i+1]);\n        CreateEndBucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(isLMS(i))SA[--bucket[v[i]]]=i;\n        InducedSort(v,SA,mv,bucket,isL);\n        InvertInducedSort(v,SA,mv,bucket,isL);\n\n        int cur=0;\n        vector<int>ord(v.size());\n        for(int i=0;i<v.size();i++)if(isLMS(i))ord[i]=cur++;\n\n        vector<int>nxv(cur);\n        cur=-1;\n        int prev=-1;\n        for(int i=0;i<v.size();i++){\n            if(!isLMS(SA[i]))continue;\n            bool diff=false;\n            for(int d=0;d<v.size();d++){\n                if(prev==-1||v[SA[i]+d]!=v[prev+d]||isL[SA[i]+d]!=isL[prev+d]){\n                    diff=true;\n                    break;\n                }\n                else if(d>0&&isLMS(SA[i]+d))break;\n            }\n            if(diff){cur++;prev=SA[i];}\n            nxv[ord[SA[i]]]=cur;\n        }\n\n        vector<int>reord(nxv.size());\n        for(int i=0;i<v.size();i++)if(isLMS(i))reord[ord[i]]=i;\n        vector<int>nxSA=SA_IS(nxv,cur);\n        CreateEndBucket(v,bucket);\n        for(int i=0;i<SA.size();i++)SA[i]=-1;\n        for(int i=nxSA.size()-1;i>=0;i--)SA[--bucket[v[reord[nxSA[i]]]]]=reord[nxSA[i]];\n        InducedSort(v,SA,mv,bucket,isL);\n        InvertInducedSort(v,SA,mv,bucket,isL);\n        return SA;\n    }\n\n    vector<int>SA_IS(string s){\n        vector<int>v(s.size()+1);\n        for(int i=0;i<s.size();i++)v[i]=s[i]+1;\n        return SA_IS(v,*max_element(v.begin(),v.end()));\n    }\n\n    vector<int>construct_lcp(string &s,vector<int>&sa){\n        vector<int>lcp,rank(s.size()+1);\n        int n=s.size();\n        for(int i=0;i<=n;i++)rank[sa[i]]=i;\n\n        int h=0;\n        lcp[0]=0;\n        for(int i=0;i<n;i++){\n            int j=sa[rank[i]-1];\n\n            if(h>0)h--;\n            for(;j+h<n&&i+h<n;h++){\n                if(s[j+h]!=s[i+h])break;\n            }\n            lcp[rank[i]-1]=h;\n        }\n        return lcp;\n    }\n\n    class SparseTable{\n        vector<vector<int> >st;\n    public:\n        void init(vector<int>vec){\n            int b;\n            for(b=0;(1<<b)<vec.size();b++);\n            st.assign(b,vector<int>(1<<b));\n            for(int i=0;i<vec.size();i++)st[0][i]=vec[i];\n\n            for(int i=1;i<b;i++){\n                for(int j=0;j+(1<<i)<=(1<<b);j++){\n                    st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);\n                }\n            }\n        }\n        int GetMin(int l,int r){\n            assert(l<r);\n            int b=32-__builtin_clz(r-l)-1;\n            return min(st[b][l],st[b][r-(1<<b)]);\n        }\n        SparseTable(){}\n        SparseTable(vector<int>vec){init(vec);}\n    };\n    SparseTable st;\npublic:\n    string s;\n    vector<int>sa,lcp;\n    void init(string &T){\n        s=T;\n        sa=SA_IS(s);\n        //lcp=construct_lcp(s,sa);cout<<\"malta\"<<endl;\n        //st.init(lcp);cout<<\"ok\"<<endl;\n    }\n    SuffixArray(string &t){init(t);}\n    SuffixArray(){}\n\n    bool contain(string &t){\n        int a=0,b=s.size();\n        while(b-a>1){\n            int c=(a+b)/2;\n            if(s.compare(sa[c],t.size(),t)<0)a=c;\n            else b=c;\n        }\n        return s.compare(sa[b],t.size(),t)==0;\n    }\n};\n\nsigned main(){\n    string S,T;\n    int Q;\n    cin>>S>>Q;\n    SuffixArray SA(S);\n\n    while(Q--){\n        cin>>T;\n        cout<<SA.contain(T)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    sa.clear();\n    sa.resize(n+1,0);\n    S.push_back('$');\n    iota(sa.begin(),sa.end(),0);\n    sort(sa.begin(),sa.end(),\n\t [&](int a,int b){\n\t   if(S[a]==S[b]) return a>b;\n\t   return S[a]<S[b];\n\t });\n    vector<int> c(n+1,0),r(n+1),cnt(n+1),s(n+1);\n    for(int i=0;i<=n;i++) r[i]=S[i];\n    for(int len=1;len<=n;len*=2){\n      for(int i=0;i<=n;i++){\n\t c[sa[i]]=\n\t   i>0 &&\n\t   r[sa[i-1]]==r[sa[i]] &&\n\t   sa[i-1]+len<=n &&\n\t   r[sa[i-1]+len/2]==r[sa[i]+len/2] ?\n\t   c[sa[i-1]]:i;\n      }\n      iota(cnt.begin(),cnt.end(),0);\n      copy(sa.begin(),sa.end(),r.begin());\n      for(int i=0;i<=n;i++){\n\tint s1=r[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n      c.swap(r);\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  pair<int,int> count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\tif(S.compare(sa[c],tl,T)<0||\n\t   (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n\telse b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return make_pair(0,0);\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return make_pair(b[0],a[1]+1);\n  }\n  \n  void build_lcp(){\n    lcp.clear();\n    lcp.resize(n+1,0);\n    vector<int> r2(n+1);\n    for(int i=0;i<=n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  pair<int,int> count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return make_pair(0,0);\n\n    return make_pair(b[0],a[1]+1);\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1000000000 + 7;\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nstruct SuffixArray {\n    int n, k;\n    string text;\n    vector<int> sa;\n    vector<int> rank;\n    vector<int> lcp;\n\n    SuffixArray (const string &s)\n    : text(s), n(s.size()), sa(n + 1), rank(n + 1), lcp(n)\n    {}\n\n    bool comp(int i, int j) {\n        if (rank[i] != rank[j]) return rank[i] < rank[j];\n        int ri = i + k <= n ? rank[i + k] : -1;\n        int rj = j + k <= n ? rank[j + k] : -1;\n        return ri < rj;\n    }\n\n    void construct_sa() {\n        for (int i = 0; i <= n; i++) {\n            sa[i] = i;\n            rank[i] = i < n ? text[i] : -1;\n        }\n\n        for (k = 1; k <= n; k *= 2) {\n            sort(sa.begin(), sa.end(), [&](const int& i, const int& j) {return comp(i, j);});\n\n            vector<int> tmp(n + 1);\n            tmp[sa[0]] = 0;\n            for (int i = 1; i <= n; i++) {\n                tmp[sa[i]] = tmp[sa[i - 1]] + (comp(sa[i - 1], sa[i]) ? 1 : 0);\n            }\n\n            for (int i = 0; i <= n; i++) {\n                rank[i] = tmp[i];\n            }\n        }\n    }\n\n    void construct_lcp () {\n        int h = 0;\n        lcp[0] = 0;\n        for (int i = 0; i < n; i++) {\n            int j = sa[rank[i] - 1];\n            if (h > 0) h--;\n            for (; j + h < n && i + h < n; h++) {\n                if (text[j + h] != text[i + h]) break;\n            }\n            lcp[rank[i] - 1] = h;\n        }\n    }\n\n    int low_bd(const string &pt) {\n        int l = 0, r = n + 1;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val < 0) l = m;\n            else r = m;\n        }\n        return r;\n    }\n\n    int up_bd(const string &pt) {\n        int l = 1, r = n + 1;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val <= 0) l = m;\n            else r = m;\n        }\n        return r;\n    }\n\n    bool match(const string &pt) {\n        int idx = low_bd(pt);\n        if (idx == sa.size()) return false;\n        return text.compare(sa[idx], pt.length(), pt) == 0 ? true : false;\n    }\n\n    int count(const string &pt) {\n        int l_idx = low_bd(pt);\n        if (l_idx == sa.size()) return 0;\n        if (text.compare(sa[l_idx], pt.length(), pt) != 0) return 0;\n        int r_idx = up_bd(pt);\n        return r_idx - l_idx;\n    }\n};\n\nstring t;\nint q;\nstring p[1000];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> t;\n    cin >> q;\n    rep(i, q) cin >> p[i];\n    SuffixArray suf(t);\n    suf.construct_sa();\n    rep(i, q) {\n        cout << suf.match(p[i]) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nclass SuffixArrayInducedSorting\n{\nprivate:\n    static constexpr int encode(const int c) { return c == '$' ? 0 : '0' <= c and c <= '9' ? c - '0' + 1 : 'A' <= c and c <= 'Z' ? c - 'A' + 11 : c - 'a' + 37; }\n    static constexpr char decode(const int n) { return (n == 0 ? '$' : n <= 10 ? '0' + n - 1 : n <= 36 ? 'A' + n - 11 : 'a' + n - 37); }\n    enum class Type : char {\n        L = 0,\n        S = 1,\n        LMS = 2,\n    };\n\npublic:\n    SuffixArrayInducedSorting(const string& s, const int kind_) : N(s.size() + 1), kind{kind_ + 1}, S(s.size() + 1, 0), type(N), next(N, 1), bucket(kind), num(kind, 0), head(kind, 0), tail(kind, 0)\n    {\n        for (int i = 0; i < s.size(); i++) {\n            S[i] = encode(s[i]);\n        }\n        initializeData();\n        sortLMS();\n    }\n    SuffixArrayInducedSorting(const vector<int>& s, const int kind_) : N(s.size() + 1), kind{kind_ + 1}, S(s), type(N), next(N, 1), bucket(kind), num(kind, 0), head(kind, 0), tail(kind, 0)\n    {\n        S.push_back(0);\n        initializeData();\n        sortLMS();\n    }\n    void debugPrint() const\n    {\n        for (int i = 0; i < N; i++) {\n            cout << decode(S[i]);\n        }\n        cout << endl;\n        for (int i = 0; i < N; i++) {\n            cout << (type[i] == Type::L ? \"L\" : \"S\");\n        }\n        cout << endl;\n        for (int i = 0; i < N; i++) {\n            cout << (type[i] == Type::LMS ? \"@\" : \" \");\n        }\n        cout << endl;\n        for (int i = 0; i < kind; i++) {\n            if (bucket[i].empty())\n                continue;\n            cout << \"[\" << decode(i) << \"]:\\n\";\n            for (const int p : bucket[i]) {\n                cout << \"  \" << p << endl;\n            }\n        }\n    }\n\n    vector<int> getSuffixArray() const\n    {\n        vector<int> ans(N - 1);\n        for (int pos = 0, i = 1; i < kind; i++) {  // 番兵以外\n            for (const int p : bucket[i]) {\n                ans[pos++] = p;\n            }\n        }\n        return ans;\n    }\n\nprivate:\n    void initializeData()\n    {\n        for (const int i : S) {\n            num[i]++;\n        }\n        for (int i = 0; i < kind; i++) {\n            bucket[i].resize(num[i], -1);\n            tail[i] = num[i] - 1;\n        }\n        type[N - 1] = Type::S;\n        for (int i = N - 2; i >= 0; i--) {\n            type[i] = (S[i] != S[i + 1] ? (S[i] < S[i + 1] ? Type::S : Type::L) : type[i + 1]);\n            if (type[i] == Type::L and type[i + 1] == Type::S) {\n                type[i + 1] = Type::LMS;\n                LMS.push_back(i + 1);\n            }\n        }\n        for (int pos = N - 1, i = N - 2; i >= 0; i--) {\n            next[i] = pos;\n            if (type[i] == Type::LMS) {\n                pos = i;\n            }\n        }\n    }\n\n    void sortLMS()\n    {\n        for (const int l : LMS) {\n            insertTail(l);\n        }\n        induce();\n        vector<int> lms;\n        for (int i = 0; i < kind; i++) {\n            for (const int p : bucket[i]) {\n                if (type[p] == Type::LMS) {\n                    lms.push_back(p);\n                }\n            }\n        }\n        const int size = lms.size();\n        vector<int> order(N / 2 + 1, 0);\n        int number = 1;\n        order[N / 2] = 1;\n        bool same = false;\n        for (int i = 1; i < size; i++) {\n            const int l1 = lms[i - 1];\n            const int r1 = next[l1];\n            const int l2 = lms[i];\n            const int r2 = next[l2];\n            if (r1 - l1 == r2 - l2 and vector<int>(S.begin() + l1, S.begin() + r1 + 1) == vector<int>(S.begin() + l2, S.begin() + r2 + 1)) {\n                same = true;\n            } else {\n                number++;\n            }\n            order[l2 / 2] = number;\n        }\n        if (same) {\n            vector<int> s(size);\n            for (int p = 0, i = 0; i <= N / 2; i++) {\n                if (order[i] > 0) {\n                    s[p++] = order[i];\n                }\n            }\n            const vector<int> sorted = SuffixArrayInducedSorting{s, number}.getSuffixArray();\n            for (int i = 0; i < kind; i++) {\n                head[i] = 0;\n                tail[i] = num[i] - 1;\n            }\n            for (int i = size - 1; i >= 0; i--) {\n                insertTail(LMS[size - 1 - sorted[i]]);\n            }\n            induce();\n        } else {\n            for (int i = 0; i < kind; i++) {\n                head[i] = 0;\n                tail[i] = num[i] - 1;\n            }\n            for (int i = size - 1; i >= 0; i--) {\n                insertTail(lms[i]);\n            }\n            induce();\n        }\n    }\n\n    void induce()\n    {\n        for (int i = 0; i < kind; i++) {\n            for (int j = 0; j < head[i]; j++) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] == Type::L) {\n                    insertHead(p - 1);\n                }\n            }\n            for (int j = tail[i] + 1; j < num[i]; j++) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] == Type::L) {\n                    insertHead(p - 1);\n                }\n            }\n        }\n        for (int i = 1; i < kind; i++) {  // 番兵以外\n            tail[i] = num[i] - 1;\n        }\n        for (int i = kind - 1; i >= 0; i--) {\n            for (int j = num[i] - 1; j > tail[i]; j--) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] != Type::L) {\n                    insertTail(p - 1);\n                }\n            }\n            for (int j = head[i] - 1; j >= 0; j--) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] != Type::L) {\n                    insertTail(p - 1);\n                }\n            }\n        }\n    }\n    void insertHead(const int i) { bucket[S[i]][head[S[i]]++] = i; }\n    void insertTail(const int i) { bucket[S[i]][tail[S[i]]--] = i; }\n\n    const int N;\n    const int kind;\n    vector<int> S;               // O(N)\n    vector<Type> type;           // O(N)\n    vector<int> next;            // O(N)\n    vector<vector<int>> bucket;  // O(N)\n    vector<int> num;             // O(K)\n    vector<int> head;            // O(K)\n    vector<int> tail;            // O(K)\n    vector<int> LMS;             // O(N)\n};\n\nint main()\n{\n    string s;\n    cin >> s;\n    const int size = s.size();\n    const SuffixArrayInducedSorting sais(s, 63);\n    const vector<int> sa = sais.getSuffixArray();\n    int N;\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        string p;\n        cin >> p;\n        const int psize = p.size();\n        int inf = -1;\n        int sup = size;\n        while (sup - inf > 1) {\n            const int mid = (sup + inf) / 2;\n            const bool ok = s.substr(sa[mid]) < p;\n            if (ok) {\n                inf = mid;\n            } else {\n                sup = mid;\n            }\n        }\n        const bool ans = sup == size ? false : s.substr(sa[sup], psize) == p;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    S.push_back('$');\n    iota(sa.begin(),sa.end(),0);\n    sort(sa.begin(),sa.end(),\n\t [&](int a,int b){\n\t   if(S[a]==S[b]) return a>b;\n\t   return S[a]<S[b];\n\t });\n    vector<int> c(n+1),r(n+1),cnt(n+1),s(n+1);\n    for(int i=0;i<=n;i++) r[i]=S[i];\n    for(int len=1;len<=n;len*=2){\n      for(int i=0;i<=n;i++){\n\t c[sa[i]]=\n\t   i>0 &&\n\t   r[sa[i-1]]==r[sa[i]] &&\n\t   sa[i-1]+len<=n &&\n\t   r[sa[i-1]+len/2]==r[sa[i]+len/2] ?\n\t   c[sa[i-1]]:i;\n      }\n      iota(cnt.begin(),cnt.end(),0);\n      copy(sa.begin(),sa.end(),s.begin());\n      for(int i=0;i<=n;i++){\n\tint s1=c[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n      c.swap(r);\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n+1);\n    for(int i=0;i<=n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tint n;\n\tstring text;\n\tstring pattern;\n\tcin >> text >> n;\n\n\tfor (int i = 0; i < n; ++i){\n\t\tcin >> pattern;\n\t\tstring::size_type index = text.find(pattern);\n\t\tif (index == std::string::npos) {\n\t\t\tcout << 0 << \"\\n\";\n\t\t} else {\n\t\t\tcout << 1 << \"\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<functional>\nusing namespace std;\n#define MAX_N 1100000\nint Rank[MAX_N], x[MAX_N];\nint SA[MAX_N]; string S, T; int V;\nbool Compare(int p, int q) {\n\tif (Rank[p] < Rank[q])return true;\n\tif (Rank[p] > Rank[q])return false;\n\tint D1 = -1, D2 = -1;\n\tif (p + V <= S.size())D1 = Rank[p + V];\n\tif (q + V <= S.size())D2 = Rank[q + V];\n\tif (D1 < D2)return true;\n\treturn false;\n}\nvoid Build() {\n\tfor (int i = 0; i < S.size(); i++) { SA[i] = i; Rank[i] = S[i]; }\n\tSA[S.size()] = S.size(); Rank[S.size()] = -1;\n\tfor (V = 1; V <= S.size(); V *= 2) {\n\t\tsort(SA, SA + S.size() + 1, Compare);\n\t\tx[SA[0]] = 0;\n\t\tfor (int i = 1; i <= S.size(); i++) {\n\t\t\tx[SA[i]] = x[SA[i - 1]] + Compare(SA[i - 1], SA[i]);\n\t\t}\n\t\tfor (int i = 0; i <= S.size(); i++)Rank[i] = x[i];\n\t}\n}\nint hantei(int C, string &V2) {\n\tint H = min(S.size() - C, V2.size());\n\tfor (int i = 0; i < H; i++) {\n\t\tif (S[i + C] < V2[i])return -1;\n\t\tif (S[i + C] > V2[i])return 1;\n\t}\n\treturn 0;\n}\nint main() {\n\tcin >> S; int Q; cin >> Q; Build();\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> T; int L = 0, R = S.size() + 1, M;\n\t\twhile (L + 1 < R) {\n\t\t\tM = (L + R) / 2;\n\t\t\tif (hantei(SA[M], T) <= 0)L = M;\n\t\t\telse { R = M; }\n\t\t}\n\t\tif (hantei(SA[L], T) == 0)cout << \"1\" << endl;\n\t\telse cout << \"0\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\nbool kmp_search(const string &s, const string &w, int *t);\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string t, p;\n    t.reserve(1000001);\n    p.reserve(1001);\n    int jt[1001];\n    int n;\n    getline(cin, t);\n    cin>>n;\n    cin.ignore();\n    for(int i=0; i<n; i++) {\n        getline(cin, p);\n        if(kmp_search(t, p, jt)) cout<<\"1\\n\";\n        else cout<<\"0\\n\";\n    }\n    return 0;\n}\n\nbool kmp_search(const string &s, const string &w, int *t)\n{\n    int i=2, j=0;\n    t[0]=0;\n    t[1]=0;\n    int sl=s.length(), wl=w.length();\n    while(i<=wl) {\n        if(w[i-1]==w[j]) t[i++]=++j;\n        else if(j>0)j=t[j];\n        else t[i++]=0;\n    }\n    int p=0;\n    i=0;\n    while(p<=sl) {\n        if(w[i]==s[p]) {\n            ++p;\n            ++i;\n            if(i==wl) {\n                return true;\n            }\n        } else {\n            if(i==0) ++p;\n            i=t[i];\n        }\n    }\n    return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nclass suffix_array{\n    void create_begin_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        int sum=0;\n        for(int i=0;i<bucket.size();i++){bucket[i]+=sum;swap(sum,bucket[i]);}\n    }\n\n    void create_end_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        for(int i=1;i<bucket.size();i++)bucket[i]+=bucket[i-1];\n    }\n\n    void induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_begin_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(sa[i]>0&&is_l[sa[i]-1])sa[bucket[v[sa[i]-1]]++]=sa[i]-1;\n    }\n\n    void invert_induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_end_bucket(v,bucket);\n        for(int i=v.size()-1;i>=0;i--)if(sa[i]>0&&!is_l[sa[i]-1])sa[--bucket[v[sa[i]-1]]]=sa[i]-1;\n    }\n\n    vector<int>sa_is(vector<int>v,int mv){\n        if(v.size()==1)return vector<int>(1,0);\n\n        vector<int>is_l(v.size());\n        vector<int>bucket(mv+1);\n        vector<int>sa(v.size(),-1);\n        auto is_lms=[&](int x)->bool{return x>0&&is_l[x-1]&&!is_l[x];};\n\n        is_l[v.size()-1]=0;\n        for(int i=v.size()-2;i>=0;i--)is_l[i]=v[i]>v[i+1]||(v[i]==v[i+1]&&is_l[i+1]);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(is_lms(i))sa[--bucket[v[i]]]=i;\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n\n        int cur=0;\n        vector<int>order(v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))order[i]=cur++;\n\n        vector<int>next_v(cur);\n        cur=-1;\n        int prev=-1;\n        for(int i=0;i<v.size();i++){\n            if(!is_lms(sa[i]))continue;\n            bool diff=false;\n            for(int d=0;d<v.size();d++){\n                if(prev==-1||v[sa[i]+d]!=v[prev+d]||is_l[sa[i]+d]!=is_l[prev+d]){\n                    diff=true;\n                    break;\n                }\n                else if(d>0&&is_lms(sa[i]+d))break;\n            }\n            if(diff){cur++;prev=sa[i];}\n            next_v[order[sa[i]]]=cur;\n        }\n\n        vector<int>re_order(next_v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))re_order[order[i]]=i;\n        vector<int>next_sa=sa_is(next_v,cur);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<sa.size();i++)sa[i]=-1;\n        for(int i=next_sa.size()-1;i>=0;i--)sa[--bucket[v[re_order[next_sa[i]]]]]=re_order[next_sa[i]];\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n        return sa;\n    }\n\n    vector<int>sa_is(string &s){\n        vector<int>v(s.size()+1);\n        for(int i=0;i<s.size();i++)v[i]=s[i];\n        sa=sa_is(v,*max_element(v.begin(),v.end()));\n    }\n\n    void construct_lcp(){\n        lcp.resize(s.size());\n        rank.resize(s.size()+1);\n        int n=s.size();\n        for(int i=0;i<=n;i++)rank[sa[i]]=i;\n        int h=0;\n        lcp[0]=0;\n        for(int i=0;i<n;i++){\n            int j=sa[rank[i]-1];\n\n            if(h>0)h--;\n            for(;j+h<n&&i+h<n;h++){\n                if(s[j+h]!=s[i+h])break;\n            }\n            lcp[rank[i]-1]=h;\n        }\n    }\n\n    class sparse_table{\n        vector<vector<int> >st;\n    public:\n        void init(vector<int>&v){\n            int b;\n            for(b=0;(1<<b)<v.size();b++);\n            st.assign(b,vector<int>(1<<b));\n            for(int i=0;i<v.size();i++)st[0][i]=v[i];\n\n            for(int i=1;i<b;i++){\n                for(int j=0;j+(1<<i)<=(1<<b);j++){\n                    st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);\n                }\n            }\n        }\n        int get_min(int l,int r){\n            assert(l<r);\n            int b=32-__builtin_clz(r-l)-1;\n            return min(st[b][l],st[b][r-(1<<b)]);\n        }\n        sparse_table(){}\n        sparse_table(vector<int>&v){init(v);}\n    };\n    sparse_table st;\npublic:\n    string s;\n    vector<int>sa,lcp,rank;\n    void init(string &t){\n        s=t;\n        sa_is(s);\n        construct_lcp();\n        st.init(lcp);\n    }\n    suffix_array(string &t){init(t);}\n    suffix_array(){}\n\n    bool contain(string &t){\n        int lb=0,ub=s.size();\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            if(s.compare(sa[mid],t.size(),t)<0)lb=mid;\n            else ub=mid;\n        }\n        return s.compare(sa[ub],t.size(),t)==0;\n    }\n\n    int get_lcp(int i,int j){\n        if(rank[i]>rank[j])swap(i,j);\n        return st.get_min(rank[i],rank[j]);\n    }\n};\n\nsigned main(){\n    string s;cin>>s;\n    suffix_array sa(s);\n    int q;cin>>q;\n    while(q--){\n        string t;\n        cin>>t;\n        cout<<sa.contain(t)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) { \n    //const int k=lcp(i,j);\n    //const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    const int k=lcp2(i,j,0,n-max(i,j)+1);\n    if(i+k>=n)return 1;\n    if(j+k>=n)return 0;\n    return s[i+k] <= s[j+k];\n    //return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  /*\n  inline int lcp(const int i, const int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n  */\n  inline int lcp2(const int& i, const int& j, const int& l, const int& r){\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\nif(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nclass SuffixArray {\n\tvoid CEB(vector<int> &v, vector<int> &b) {\n\t\tint vs = v.size(), bs = b.size();\n\t\tfill(b.begin(), b.end(), 0);\n\t\tfor (int i = 0; i < vs; i++) b[v[i]]++;\n\t\tfor (int i = 1; i < bs; i++) b[i] += b[i - 1];\n\t}\n\tvoid ISort(vector<int> &v, vector<int> &SA, int mv, vector<int> &b, vector<int> &isL) {\n\t\tint vs = v.size(), bs = b.size();\n\t\tfill(b.begin(), b.end(), 0);\n\t\tfor (int i = 0; i < vs; i++) b[v[i]]++;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < bs; i++) b[i] += sum, swap(sum, b[i]);\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (SA[i] > 0 && isL[SA[i] - 1]) SA[b[v[SA[i] - 1]]++] = SA[i] - 1;\n\t\t}\n\t}\n\tvoid IISort(vector<int> &v, vector<int> &SA, int mv, vector<int> &b, vector<int> &isL) {\n\t\tCEB(v, b);\n\t\tfor (int i = v.size() - 1; i >= 0; i--) {\n\t\t\tif (SA[i] > 0 && !isL[SA[i] - 1]) SA[--b[v[SA[i] - 1]]] = SA[i] - 1;\n\t\t}\n\t}\n\tvector<int>SA_IS(vector<int> v, int mv) {\n\t\tint vs = v.size();\n\t\tif (vs == 1) return vector<int>(1, 0);\n\t\tvector<int> isL(vs), b(mv + 1), SA(vs, -1), ord(vs);\n\t\tauto isLMS = [&](int x)->bool { return x > 0 && isL[x - 1] && !isL[x]; };\n\t\tfor (int i = vs - 2; i >= 0; i--) isL[i] = (v[i] > v[i + 1]) || (v[i] == v[i + 1] && isL[i + 1]);\n\t\tCEB(v, b);\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) SA[--b[v[i]]] = i;\n\t\t}\n\t\tISort(v, SA, mv, b, isL);\n\t\tIISort(v, SA, mv, b, isL);\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) ord[i] = cur++;\n\t\t}\n\t\tvector<int> nxv(cur);\n\t\tcur = -1;\n\t\tint prev = -1;\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (!isLMS(SA[i])) continue;\n\t\t\tbool diff = false;\n\t\t\tfor (int d = 0; d < vs; d++) {\n\t\t\t\tif (prev == -1 || v[SA[i] + d] != v[prev + d] || isL[SA[i] + d] != isL[prev + d]) {\n\t\t\t\t\tdiff = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (d && isLMS(SA[i] + d))break;\n\t\t\t}\n\t\t\tif (diff) cur++, prev = SA[i];\n\t\t\tnxv[ord[SA[i]]] = cur;\n\t\t}\n\t\tvector<int> reord(nxv.size());\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) reord[ord[i]] = i;\n\t\t}\n\t\tvector<int> nxSA = SA_IS(nxv, cur);\n\t\tCEB(v, b);\n\t\tfor (int i = 0; i < SA.size(); i++) SA[i] = -1;\n\t\tfor (int i = nxSA.size() - 1; i >= 0; i--) {\n\t\t\tSA[--b[v[reord[nxSA[i]]]]] = reord[nxSA[i]];\n\t\t}\n\t\tISort(v, SA, mv, b, isL);\n\t\tIISort(v, SA, mv, b, isL);\n\t\treturn SA;\n\t}\n\tvector<int>SA_IS(string s) {\n\t\tvector<int> v(s.size() + 1);\n\t\tfor (int i = 0; i < s.size(); i++) v[i] = s[i] + 1;\n\t\treturn SA_IS(v, *max_element(v.begin(), v.end()));\n\t}\npublic:\n\tstring s;\n\tvector<int> sa;\n\tvoid init(string &T) {\n\t\ts = T;\n\t\tsa = SA_IS(s);\n\t}\n\tSuffixArray(string &t) { init(t); }\n\tSuffixArray() {}\n\tbool contain(string &t) {\n\t\tint a = 0, b = s.size();\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (s.compare(sa[c], t.size(), t) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn s.compare(sa[b], t.size(), t) == 0;\n\t}\n};\nint q; string s, t;\nint main() {\n\tcin >> s >> q;\n\tSuffixArray v(s);\n\tfor(int i = 0; i < q; i++) {\n\t\tcin >> t;\n\t\tcout << (v.contain(t) ? 1 : 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) { \n    //const int k=lcp(i,j);\n    //const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    const int k=lcp2(i,j,0,(n-max(i,j))*2+1);\n    if(i+k>=n)return 1;\n    if(j+k>=n)return 0;\n    return s[i+k] <= s[j+k];\n    //return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e){\n    assert(b<e);\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  /*\n  inline int lcp(const int i, const int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n  */\n  \n  inline int lcp2(const int& i, const int& j, const int& l, const int& r){\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\nif(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\nusing namespace std;\nstring S, T;\nint main() {\n\tint q,sum;\n\tcin >> S;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tsum = 0;\n\t\tcin >> T;\n\t\tif (S.size() >= T.size()) {\n\t\t\tfor (int i = 0; i <= S.size() - T.size(); i++) {\n\t\t\t\tif (T == S.substr(i, T.size())) {\n\t\t\t\t\tcout << \"1\" << endl;\n\t\t\t\t\tgoto Exit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"0\" << endl;\n\tExit:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n/*\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n-nb,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k>=nc)a[i]=b[j++];\n      else if(j>=nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n*/\n\nint L[1000000],R[1000000];\n\ninline void merge(int *A, const int left, const int mid, const int right, const RollingHash &rh){\n  const int n1 = mid - left, n2 = right - mid;\n  REP(i,n1)L[i]=A[left+i];\n  REP(i,n2)R[i]=A[mid+i];\n  for(int k =left,i=0,j=0;k<right;k++){\n    if(n2<=j)A[k]=L[i++];\n    else if(n1<=i)A[k]=R[j++];\n    else A[k]=rh(L[i],R[j])?L[i++]:R[j++];\n  }\n}\n\nvoid mergeSort(int *A,const int left,const int right, const RollingHash &rh){\n  if(left+1<right){\n    const int mid = (left+right)>>1;\n    mergeSort(A,left,mid, rh);\n    mergeSort(A,mid,right, rh);\n    merge(A,left,mid,right, rh);\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  //mergesort(n,sa,rh);\n  mergeSort(sa,0,n,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\n#define NUM 48\nusing namespace std;\n\nint T_char_count[128] = {0},P_char_count[128];\nint T_Chain[128][128];\n\nclass LocRecord{\n\npublic:\n\t//?????¢???????¢????\n\tLocRecord(){\n\t\tlocationTable = new int**[128];\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tlocationTable[i] = new int*[128];\n\t\t\tfor(int k = 0; k < 128; k++){\n\t\t\t\tif(T_Chain[i][k] > 0){\n\t\t\t\t\tlocationTable[i][k] = new int[T_Chain[i][k]+1];\n\t\t\t\t\tfor(int p = 0; p < T_Chain[i][k]+1; p++){\n\t\t\t\t\t\tlocationTable[i][k][p] = -1;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tlocationTable[i][k] = new int[2];\n\t\t\t\t\tfor(int p = 0; p < 2; p++){\n\t\t\t\t\t\tlocationTable[i][k][p] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinit();\n\t}\n\n\t//-1?????£??\\\n\tvoid init(){\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tfor(int k = 0; k < 128; k++){\n\t\t\t\tindex[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init_index(char first,char second){\n\t\tindex[first][second] = 0;\n\t}\n\n\tvoid regist_loc(char first,char second,int location){\n\t\tlocationTable[first][second][index[first][second]] = location;\n\t\tindex[first][second]++;\n\t}\n\n\tint next_loc(char first,char second){\n\t\tint ret = locationTable[first][second][index[first][second]];\n\t\tindex[first][second]++;\n\t\treturn ret;\n\t}\n\nprivate:\n\tint*** locationTable;\n\tint index[128][128];\n};\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\t\t\treturn length < arg.length;\n\t};\n\tInfo(int arg_length,int arg_id,ull arg_hashValue){\n\t\tlength = arg_length;\n\t\tid = arg_id;\n\t\thashValue = arg_hashValue;\n\t}\n\n\tint length,id;\n\tull hashValue;\n};\n\nint main(){\n\n\tfor(int i = 0; i < 128; i++){\n\t\tT_char_count[i] = 0;\n\t\tfor(int k = 0; k < 128; k++){\n\t\t\tT_Chain[i][k] = 0;\n\t\t}\n\t}\n\n\tint T_length;\n\n\tchar* T = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tchar pre = T[0];\n\tT_char_count[T[0]]++;\n\n\tfor(T_length = 1; T[T_length] != '\\0';T_length++){\n\t\tT_char_count[T[T_length]]++;\n\t\tT_Chain[pre][T[T_length]]++;\n\t\tpre = T[T_length];\n\t}\n\n\tLocRecord locRecord;\n\tlocRecord.init();\n\n\n\tpre = T[0];\n\t//T[i]????????????i??§???????????¨????¨????\n\tfor(int i = 1; i < T_length; i++){\n\t\tlocRecord.regist_loc(pre,T[i],i-1);\n\t\tpre = T[i];\n\t}\n\n\tull* HASH = new ull[T_length+1];\n\tull* P = new ull[T_length+1];\n\n\tHASH[0] = 0;\n\tP[0] = 1;\n\n\t//T??????????????\\???????±???????\n\tfor(int i = 1; i <= T_length; i++){\n\t\tHASH[i] = T[i-1] + HASH[i-1]*MOD;\n\t\tP[i] = P[i-1]*MOD;\n\t}\n\n\n\tvector<Info> V[128][128];\n\n\tint Q,S_length,left,P_char_count[128];\n\tscanf(\"%d\",&Q);\n\n\tbool check[Q];\n\n\tfor(int i = 0; i < Q; i++)check[i] = false;\n\n\tchar S[1001];\n\tull S_HASH[1001],S_value,T_value,D;\n\tbool FLG;\n\n\n\t//Q??¶??????????????\\???????¨????\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",S);\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tP_char_count[i] = 0;\n\t\t}\n\n\t\tfor(S_length = 0;S[S_length] != '\\0';S_length++){\n\t\t\tP_char_count[S[S_length]]++;\n\t\t}\n\n\t\tFLG = true;\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tif(T_char_count[i] < P_char_count[i]){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG)continue;\n\n\t\tif(S_length == 1){\n\t\t\tcheck[loop] = true;\n\t\t\tcontinue;\n\t\t}\n\n\n\n\t\tS_HASH[0] = 0;\n\t\tfor(int i = 1; i <= S_length; i++){\n\t\t\tS_HASH[i] = S[i-1] + S_HASH[i-1]*MOD;\n\t\t}\n\n\t\tS_value = S_HASH[S_length];\n\n\t\tV[S[0]][S[1]].push_back(Info(S_length,loop,S_value));\n\t}\n\n\tint calc_length;\n\n\tfor(int first_word = 48; first_word <= 122; first_word++){\n\t\tfor(int second_word = 48; second_word <= 122;second_word++){\n\t\t\tfor(int i = 0; i < V[first_word][second_word].size();i++){\n\n\t\t\t\tlocRecord.init_index(first_word,second_word);\n\n\t\t\t\tcalc_length = V[first_word][second_word][i].length;\n\t\t\t\tS_value = V[first_word][second_word][i].hashValue;\n\n\t\t\t\tD = P[calc_length];\n\n\t\t\t\twhile((left = locRecord.next_loc(first_word,second_word)) != -1){\n\t\t\t\t\tif(left+calc_length-1 >= T_length)break;\n\n\t\t\t\t\tT_value = HASH[left+calc_length]-HASH[left]*D;\n\n\t\t\t\t\tif(T_value == S_value){\n\t\t\t\t\t\tcheck[V[first_word][second_word][i].id] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tif(check[i])printf(\"1\\n\");\n\t\telse{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n\nusing namespace std;\n\nstring S, T; int Q; char STR[1000005];\n\nint main()\n{\n\tscanf(\"%s%d\", STR, &Q);\n\n\tS = STR;\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%s\", STR);\n\n\t\tprintf(\"%d\", S.find(STR) != string::npos ? 1 : 0);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\nstruct suffix_array {\n  int n;\n  vector<int> x;\n  suffix_array(const char *s) : n(strlen(s)), x(n) { \n    vector<int> r(n), t(n); \n    for (int i = 0; i < n; ++i) r[x[i] = i] = s[i];\n    for (int h = 1; t[n-1] != n-1; h *= 2) {\n      auto cmp = [&](int i, int j) {\n        if (r[i] != r[j]) return r[i] < r[j];\n        return i+h < n && j+h < n ? r[i+h] < r[j+h] : i > j;\n      };\n      sort(x.begin(), x.end(), cmp);\n      for (int i = 0; i+1 < n; ++i) t[i+1] = t[i] + cmp(x[i], x[i+1]);\n      for (int i = 0; i < n; ++i)   r[x[i]] = t[i];\n    }\n  }\n  int operator[](int i) const { return x[i]; }\n};\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  string T; cin >> T;\n  int Q; cin >> Q;\n  suffix_array sary(T.c_str());\n  // REP(i,T.size()) {\n  //   DEBUG(T.substr(sary[i]));\n  // }\n  while(Q--) {\n    string P; cin >> P;\n    int lb = -1, ub = T.size() - 1;\n    while(ub - lb > 1) {\n      int mid = (lb + ub) / 2;\n      bool flag = sary[mid] + (int)P.size() <= (int)T.size();\n      for(int i = 0; i < (int)P.size() && sary[mid] + i < (int)T.size(); i++) {\n        if(T[sary[mid] + i] < P[i]) flag = false;\n      }\n      if(flag) ub = mid;\n      else lb = mid;\n    }\n    bool flag = sary[ub] + (int)P.size() <= (int)T.size();\n    if(flag) {\n      REP(i,P.size()) {\n        if(T[sary[ub] + i] != P[i]) flag = false;\n      }\n      cout << (int)flag << endl;\n    }\n    else {\n      cout << 0 << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nnamespace SA{\n    const int MAX=1000000;\n    int N,K;\n    int tmp[MAX+1],rank[MAX+1];\n    bool compare_sa(int i,int j){\n        if(rank[i]!=rank[j])return rank[i]<rank[j];\n        else{\n            int ri=(i+K<=N)?rank[i+K]:-1;\n            int rj=(j+K<=N)?rank[j+K]:-1;\n            return ri<rj;\n        }\n    }\n\n    vector<int> construct_sa(string S){\n        N=S.size();\n        vector<int>sa(N+1);\n        for(int i=0;i<=N;i++)sa[i]=i;\n        for(int i=0;i<=N;i++){\n            rank[i]=i==N?-1:S[i];\n        }\n\n        for(K=1;K<=N;K*=2){\n            sort(sa.begin(),sa.end(),compare_sa);\n            tmp[sa[0]]=0;\n            for(int i=1;i<=N;i++){\n                tmp[sa[i]]=tmp[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n            }\n            for(int i=0;i<=N;i++)rank[i]=tmp[i];\n        }\n        return sa;\n    }\n\n    bool contain(string &S,vector<int>&sa,string &T){\n        int a=0,b=S.size();\n        while(b-a>1){\n            int c=(a+b)/2;\n            if(S.compare(sa[c],T.size(),T)<0)a=c;\n            else b=c;\n        }\n        return S.compare(sa[b],T.size(),T)==0;\n    }\n}\n\nsigned main(){\n    string S;\n    vint sa;\n    int Q;\n    cin>>S;\n    sa=SA::construct_sa(S);\n    cin>>Q;\n    while(Q--){\n        string T;\n        cin>>T;\n        if(SA::contain(S,sa,T))cout<<1<<endl;\n        else cout<<0<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nclass SuffixArray {\n\tvoid CEB(vector<int> &v, vector<int> &b) {\n\t\tint vs = v.size(), bs = b.size();\n\t\tfill(b.begin(), b.end(), 0);\n\t\tfor (int i = 0; i < vs; i++) b[v[i]]++;\n\t\tfor (int i = 1; i < bs; i++) b[i] += b[i - 1];\n\t}\n\tvoid ISort(vector<int> &v, vector<int> &SA, int mv, vector<int> &b, vector<int> &isL) {\n\t\tint vs = v.size(), bs = b.size();\n\t\tfill(b.begin(), b.end(), 0);\n\t\tfor (int i = 0; i < vs; i++) b[v[i]]++;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < bs; i++) b[i] += sum, swap(sum, b[i]);\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (SA[i] > 0 && isL[SA[i] - 1]) SA[b[v[SA[i] - 1]]++] = SA[i] - 1;\n\t\t}\n\t}\n\tvoid IISort(vector<int> &v, vector<int> &SA, int mv, vector<int> &b, vector<int> &isL) {\n\t\tCEB(v, b);\n\t\tfor (int i = v.size() - 1; i >= 0; i--) {\n\t\t\tif (SA[i] > 0 && !isL[SA[i] - 1]) SA[--b[v[SA[i] - 1]]] = SA[i] - 1;\n\t\t}\n\t}\n\tvector<int>SA_IS(vector<int> v, int mv) {\n\t\tint vs = v.size();\n\t\tif (vs == 1) return vector<int>(1, 0);\n\t\tvector<int> isL(vs), b(mv + 1), SA(vs, -1), ord(vs);\n\t\tauto isLMS = [&](int x)->bool { return x > 0 && isL[x - 1] && !isL[x]; };\n\t\tfor (int i = vs - 2; i >= 0; i--) isL[i] = (v[i] > v[i + 1]) || (v[i] == v[i + 1] && isL[i + 1]);\n\t\tCEB(v, b);\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) SA[--b[v[i]]] = i;\n\t\t}\n\t\tISort(v, SA, mv, b, isL);\n\t\tIISort(v, SA, mv, b, isL);\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) ord[i] = cur++;\n\t\t}\n\t\tvector<int> nxv(cur);\n\t\tcur = -1;\n\t\tint prev = -1;\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (!isLMS(SA[i])) continue;\n\t\t\tbool diff = false;\n\t\t\tfor (int d = 0; d < vs; d++) {\n\t\t\t\tif (prev == -1 || v[SA[i] + d] != v[prev + d] || isL[SA[i] + d] != isL[prev + d]) {\n\t\t\t\t\tdiff = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (d && isLMS(SA[i] + d))break;\n\t\t\t}\n\t\t\tif (diff) cur++, prev = SA[i];\n\t\t\tnxv[ord[SA[i]]] = cur;\n\t\t}\n\t\tvector<int> reord(nxv.size());\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) reord[ord[i]] = i;\n\t\t}\n\t\tvector<int> nxSA = SA_IS(nxv, cur);\n\t\tCEB(v, b);\n\t\tfor (int i = 0; i < SA.size(); i++) SA[i] = -1;\n\t\tfor (int i = nxSA.size() - 1; i >= 0; i--) {\n\t\t\tSA[--b[v[reord[nxSA[i]]]]] = reord[nxSA[i]];\n\t\t}\n\t\tISort(v, SA, mv, b, isL);\n\t\tIISort(v, SA, mv, b, isL);\n\t\treturn SA;\n\t}\n\tvector<int>SA_IS(string s) {\n\t\tvector<int> v(s.size() + 1);\n\t\tfor (int i = 0; i < s.size(); i++) v[i] = s[i] + 1;\n\t\treturn SA_IS(v, *max_element(v.begin(), v.end()));\n\t}\npublic:\n\tstring s;\n\tvector<int> sa;\n\tvoid init(string &T) {\n\t\ts = T;\n\t\tsa = SA_IS(s);\n\t}\n\tSuffixArray(string &t) { init(t); }\n\tSuffixArray() {}\n\tbool contain(string &t) {\n\t\tint a = 0, b = s.size();\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (s.compare(sa[c], t.size(), t) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn s.compare(sa[b], t.size(), t) == 0;\n\t}\n};\nint q; string s, t;\nint main() {\n\tcin >> s >> q;\n\tSuffixArray v(s);\n\tfor(int i = 0; i < q; i++) {\n\t\tcin >> t;\n\t\tcout << (v.contain(t) ? 1 : 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) { \n    //const int k=lcp(i,j);\n    //const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    const int k=lcp2(i,j,0,(n-max(i,j))*2+1);\n    if(i+k>=n)return 1;\n    if(j+k>=n)return 0;\n    return s[i+k] <= s[j+k];\n    //return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  /*\n  inline int lcp(const int i, const int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n  */\n  inline int lcp2(const int& i, const int& j, const int& l, const int& r){\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\nif(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx2\")\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\nstruct SAComp{\n\tconst int h,*g;\n\tSAComp(const int h, const int* g) : h(h), g(g) {}\n\tbool operator()(const int a, const int b){\n\t\treturn a == b ? false : g[a] != g[b] ? g[a] < g[b] : g[a+h] < g[b+h];\n\t}\n};\nvector<int> buildSA(const string &t){\n\tint n=t.size();\n\tint g[n],b[n];\n\tvector<int>suff(n);\n\tfor(int i=0;i<n;i++)suff[i]=i,g[i]=t[i];\n\tb[0]=b[n-1]=0;\n\tsort(suff.begin(),suff.end(),SAComp(0,g));\n\tfor(int h=1;b[n-1]!=n-1;h<<=1){\n\t\tSAComp comp(h,g);\n\t\tsort(suff.begin(),suff.end(),comp);\n\t\tfor(int i=0;i<n-1;i++)b[i+1]=b[i]+comp(suff[i],suff[i+1]);\n\t\tfor(int i=0;i<n;i++)g[suff[i]]=b[i];\n\t}\n\treturn suff;\n}\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s;\n\tcin>>s;\n\ts+='$';\n\tint n=s.size();\n\tvector<int>suff=buildSA(s);\n\tvector<pair<char,int>>sorted(n);\n\tfor(int i=0;i<n;i++)sorted[i]={s[(suff[i]-1+n)%n],i};\n\tsort(sorted.begin(),sorted.end());\n\n\tint T;\n\tfor(cin>>T;T--;){\n\t\tstring q;\n\t\tcin>>q;\n\t\tint start=0,stop=n,idx=q.size()-1;\n\t\tfor(;idx>=0;idx--){\n\t\t\tpair<char,int> ql={q[idx],start},qr={q[idx],stop};\n\t\t\tstart=lower_bound(sorted.begin(),sorted.end(),ql)-sorted.begin();\n\t\t\tstop=lower_bound(sorted.begin(),sorted.end(),qr)-sorted.begin();\n\t\t\tif(start==stop)break;\n\t\t}\n\t\tif(idx<0){\n\t\t\t//{vector<int>v;for(;start<stop;start++)v.push_back(suff[start]);sort(v.begin(),v.end());for(auto &e:v)printf(\"%d\\n\",e);}\n\t\t\tputs(\"1\");\n\t\t}else{\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct SA{\n  int n,k;\n  string S;\n  vector<int> r,r2,t,sa;\n  SA(){}\n  SA(string S):S(S){init();}\n  void init(){\n    n=S.size();\n    r.resize(n+1,0);\n    r2.resize(n+1,0);\n    t.resize(n+1,0);\n    sa.resize(n+1,0);\n    constract_sa();\n  }\n  bool compare_sa(int i,int j){\n    if(r[i]!=r[j]) return r[i]<r[j];\n    else{\n      int ri=i+k<=n?r[i+k]:-1;\n      int rj=j+k<=n?r[j+k]:-1;\n      return ri<rj;\n    }\n  }\n  void constract_sa(){\n    n=S.length();\n    for(int i=0;i<=n;i++){\n      sa[i]=i;\n      r[i]=i<n?S[i]:-1;\n    }\n    for(k=1;k<=n;k*=2){\n      sort(sa.begin(),sa.end(),[&](const int &i, const int &j){\n\t  if(r[i]!=r[j]) return r[i]<r[j];\n\t  else{\n\t    int ri=i+k<=n?r[i+k]:-1;\n\t    int rj=j+k<=n?r[j+k]:-1;\n\t    return ri<rj;\n\t  }\n\t});\n      t[sa[0]]=0;\n      for(int i=1;i<=n;i++){\n\tt[sa[i]]=t[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n      }\n      for(int i=0;i<=n;i++){\n\tr[i]=t[i];\n      }\n    }\n  }\n  bool contains(string T){\n    int a=0,b=S.length()+1;\n    while(b-a>1){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n};\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SA sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    //printf(\"%lld\\n\",(int)sa.contains(P));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n#include<cstdlib>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow, *phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow = (ull *)malloc(n+1);\n    phash = (ull *)malloc(n+1);\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }  \n};\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  const int n = SZ(a);\n  if(n>1){\n    vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(b,rh), mergesort(c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==SZ(c))a[i]=b[j++];\n      else if(j==SZ(b))a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  mergesort(sa,rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000000];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    S.push_back('$');\n    vector<int> c(n+1,0),ord(n+1,0);\n    for(int i=0;i<=n;i++) ord[i]=n-i;\n    sort(ord.begin(),ord.end(),[&](int a,int b){return S[a]<S[b];});\n    \n    for(int i=0;i<=n;i++){\n      sa[i]=ord[i];\n      c[i]=S[i];\n    }\n    \n    for(int len=1;len<=n;len*=2){\n      vector<int> r=c;\n      for(int i=0;i<=n;i++){\n\t c[sa[i]] = i > 0 && r[sa[i - 1]] == r[sa[i]] && sa[i - 1] + len <= n && r[sa[i - 1] + len / 2] == r[sa[i] + len / 2] ? c[sa[i - 1]] : i;\n      }\n      vector<int> cnt(n+1);\n      for(int i=0;i<=n;i++) cnt[i]=i;\n      vector<int> s=sa;\n      for(int i=0;i<=n;i++){\n\tint s1=s[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n);\n    for(int i=0;i<n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    //assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\nusing namespace std;\n\nstruct P {\n  map<char,P*> next;\n  P(){}\n  void add(char* str){\n    P* tar=this;\n    while(*str){\n      P** lpnx;\n      if(*(lpnx=&(tar->next[*str]))==NULL) *lpnx=new P();\n      tar=*lpnx; ++str;\n    }\n  }\n  int find (char* str) {\n    P* tar=this;\n    while(*str){\n      P** lpnx;\n      if(*(lpnx=&(tar->next[*str]))==NULL) return 0;\n      tar=*lpnx; ++str;\n    }\n    return 1;\n  }\n};\n\nint main () {\n  string s;int q;cin>>s>>q;\n  P* root=new P();char* str=(char*)s.c_str();\n  int len=s.size();\n  for(int i=0;i<len;++i,++str)\n    root->add(str);\n  for(int i=0;i<q;++i){\n    string t;cin>>t;\n    cout<<root->find((char*)t.c_str())<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = int;\nusing ULL = unsigned long long;\nlong long MOD = 1000000000 + 7;\nconstexpr long long INF = numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourd; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\n\nLL h, w, n, m, k, t, s, p,q, last, cnt, sum, ans, dp[100], a[20000], b[20000];\nstring str, ss;\nbool f[1100];\nchar c;\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nstruct Edge { LL to, cost; };\nvector<Edge>vec[100];\nvector<LL>v;\npair<string, LL>sa[1000000];\nmap<string, vector<LL>>ma;\nmultiset<LL>st;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nvoid compare() {\n\tstring ss = \"\";\n\tsa[0] = make_pair(ss, str.size());\n\tfor(int i=0;i<str.size();i++) {\n\t\tss = str[str.size() - i - 1] + ss;\n\t\tsa[i + 1] = make_pair(ss, str.size() - i - 1);\n\t}\n\tsort(sa, sa + str.size() + 1);\n}\nint main() {\n\tcin >> str;\n\tcompare();\n\tcin >> q;\n\trep(i, q) {\n\t\tcin >> ss;\n\t\tint l = 0, r = str.size();\n\t\twhile (r - l>1)\n\t\t{\n\t\t\tint m = (l + r) / 2;\n\t\t\tif (str.compare(sa[m].sec, ss.size(), ss)<0) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tcout << (str.compare(sa[r].sec, ss.size(), ss) == 0) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\n\n#define fi(x) get<0>(x)\n#define se(x) get<1>(x)\n\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\ntypedef vector<pll> vpl;\n\nstring t;\nstring p;\nlli q;\n\nvll sa;\nvll tmp;\nvll rnk_;\nvll rnk;\n\n\n\nint main(){\n    cin >> t;\n    sa = vll(t.size());rnk = vll(t.size()),rnk_ = vll(t.size());tmp = vll(t.size());\n    for(lli i = 0;i < t.size();i++) sa[i] = i;\n    for(lli i = 0;i < t.size();i++) rnk[i] = t[i];\n    sort(sa.begin(),sa.end(),[](lli a,lli b){\n        return rnk[a] < rnk[b];\n    });\n    for(lli k = 1;k < 2*t.size();k *= 2){\n        lli from = 0;\n        lli to = 0;\n        do{\n            from = to;\n            while(to < rnk.size() && rnk[sa[from]] == rnk[sa[to]]) to++;\n            for(lli i = from;i < to;i++) rnk_[sa[i]] = sa[i]+k < rnk.size() ? rnk[sa[i]+k] : -1;\n            sort(sa.begin()+from,sa.begin()+to,[](lli a,lli b){\n                return rnk_[a] < rnk_[b];\n            });\n        }while(to < sa.size());\n        tmp[sa[0]] = 0;\n        for(lli i = 1;i < sa.size();i++){\n            lli c = 1;\n            if(rnk[sa[i-1]] == rnk[sa[i]] && rnk_[sa[i-1]] == rnk_[sa[i]]) c = 0;\n            tmp[sa[i]] = tmp[sa[i-1]] + c;\n\n        }\n        for(lli i = 0;i < sa.size();i++){\n            rnk[sa[i]] = tmp[sa[i]];\n        }\n    }\n    sort(sa.begin(),sa.end(),[](lli a,lli b){\n        return rnk[a] < rnk[b];\n    });\n    //for(lli i = 0;i < sa.size();i++) cout << sa[i] << endl;\n    /*\n    for(lli i = 0;i < sa.size();i++){\n        for(lli j = sa[i];j < t.size();j++) cout << t[j];\n        cout << endl;\n    }\n    */\n    \n    cin >> q;\n    for(lli i = 0;i < q;i++){\n        cin >> p;\n        auto from = sa.begin();\n        auto to = sa.end();\n        for(lli i = 0;i < p.size();i++){\n            from = lower_bound(from,to,p[i],[i](lli x,char c){\n                if(x+i >= t.size()) return false;\n                return t[x+i] < c;\n            });\n            to = lower_bound(from,to,p[i],[i](lli x,char c){\n                if(x+i >= t.size()) return false;\n                return t[x+i] < c+1;\n            });\n            //cout << from-sa.begin() << \" \" << to-sa.begin() << endl;\n        }\n        if(to-from > 0) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nclass SuffixArray {\n\tvoid CEB(vector<int> &v, vector<int> &b) {\n\t\tint vs = v.size(), bs = b.size();\n\t\tfill(b.begin(), b.end(), 0);\n\t\tfor (int i = 0; i < vs; i++) b[v[i]]++;\n\t\tfor (int i = 1; i < bs; i++) b[i] += b[i - 1];\n\t}\n\tvoid ISort(vector<int> &v, vector<int> &SA, int mv, vector<int> &b, vector<int> &isL) {\n\t\tint vs = v.size(), bs = b.size();\n\t\tfill(b.begin(), b.end(), 0);\n\t\tfor (int i = 0; i < vs; i++) b[v[i]]++;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < bs; i++) b[i] += sum, swap(sum, b[i]);\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (SA[i] > 0 && isL[SA[i] - 1]) SA[b[v[SA[i] - 1]]++] = SA[i] - 1;\n\t\t}\n\t}\n\tvoid IISort(vector<int> &v, vector<int> &SA, int mv, vector<int> &b, vector<int> &isL) {\n\t\tCEB(v, b);\n\t\tfor (int i = v.size() - 1; i >= 0; i--) {\n\t\t\tif (SA[i] > 0 && !isL[SA[i] - 1]) SA[--b[v[SA[i] - 1]]] = SA[i] - 1;\n\t\t}\n\t}\n\tvector<int>SA_IS(vector<int> v, int mv) {\n\t\tint vs = v.size();\n\t\tif (vs == 1) return vector<int>(1, 0);\n\t\tvector<int> isL(vs), b(mv + 1), SA(vs, -1), ord(vs);\n\t\tauto isLMS = [&](int x)->bool { return x > 0 && isL[x - 1] && !isL[x]; };\n\t\tfor (int i = vs - 2; i >= 0; i--) isL[i] = (v[i] > v[i + 1]) || (v[i] == v[i + 1] && isL[i + 1]);\n\t\tCEB(v, b);\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) SA[--b[v[i]]] = i;\n\t\t}\n\t\tISort(v, SA, mv, b, isL);\n\t\tIISort(v, SA, mv, b, isL);\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) ord[i] = cur++;\n\t\t}\n\t\tvector<int> nxv(cur);\n\t\tcur = -1;\n\t\tint prev = -1;\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (!isLMS(SA[i])) continue;\n\t\t\tbool diff = false;\n\t\t\tfor (int d = 0; d < vs; d++) {\n\t\t\t\tif (prev == -1 || v[SA[i] + d] != v[prev + d] || isL[SA[i] + d] != isL[prev + d]) {\n\t\t\t\t\tdiff = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (d && isLMS(SA[i] + d))break;\n\t\t\t}\n\t\t\tif (diff) cur++, prev = SA[i];\n\t\t\tnxv[ord[SA[i]]] = cur;\n\t\t}\n\t\tvector<int> reord(nxv.size());\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) reord[ord[i]] = i;\n\t\t}\n\t\tvector<int> nxSA = SA_IS(nxv, cur);\n\t\tCEB(v, b);\n\t\tfor (int i = 0; i < SA.size(); i++) SA[i] = -1;\n\t\tfor (int i = nxSA.size() - 1; i >= 0; i--) {\n\t\t\tSA[--b[v[reord[nxSA[i]]]]] = reord[nxSA[i]];\n\t\t}\n\t\tISort(v, SA, mv, b, isL);\n\t\tIISort(v, SA, mv, b, isL);\n\t\treturn SA;\n\t}\n\tvector<int>SA_IS(string s) {\n\t\tvector<int> v(s.size() + 1);\n\t\tfor (int i = 0; i < s.size(); i++) v[i] = s[i] + 1;\n\t\treturn SA_IS(v, *max_element(v.begin(), v.end()));\n\t}\n\tvector<int>construct_lcp(string &s, vector<int> &sa) {\n\t\tvector<int> lcp, rank(s.size() + 1);\n\t\tint n = s.size(), h = 0;\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (s[j + h] != s[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\npublic:\n\tstring s;\n\tvector<int> sa, lcp;\n\tvoid init(string &T) {\n\t\ts = T;\n\t\tsa = SA_IS(s);\n\t}\n\tSuffixArray(string &t) { init(t); }\n\tSuffixArray() {}\n\tbool contain(string &t) {\n\t\tint a = 0, b = s.size();\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (s.compare(sa[c], t.size(), t) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn s.compare(sa[b], t.size(), t) == 0;\n\t}\n};\nint q; string s, t;\nint main() {\n\tcin >> s >> q;\n\tSuffixArray v(s);\n\tfor(int i = 0; i < q; i++) {\n\t\tcin >> t;\n\t\tcout << (v.contain(t) ? 1 : 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define MAX 1000002\ntypedef unsigned char byte;\nbyte mask[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\n\nint Lv[MAX];\nint n, k;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n    return L_i < L_j;\n}\n\nint main()\n{\n    int A[MAX];\n    char c[MAX];\n    scanf(\"%s\", c);\n    std::string T = std::string(c);\n    n = T.size();\n    byte *t;\n    t = new byte [(n >> 3) + 1];\n\tbool act;\n\tint l, r;\n\n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n    std::sort(A, A + n, cmp_Lv);\n\n    for(i = 1; i < n; i++){\n        t[i >> 3] = (Lv[A[i]] != Lv[A[i - 1]] ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n    }\n    t[n >> 3] = t[n >> 3] | mask[n & 7];\n\n    Lv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n    }\n\n    k = 1;\n    while(1){\n        if(k > n) break;\n\n        act = true;\n        for(i = 1; i <= n; i++){\n            if(act){\n                if(!!(mask[i & 7] & t[i >> 3])){ continue; }\n                else{ l = i - 1; act = false; }\n            }else{\n                if(!!(mask[i & 7] & t[i >> 3])){\n                    r = i; std::sort(A + l, A + r, cmp); act = true; }\n                    else{ continue; }\n            }\n        }\n\n        for(i = 1; i < n; i++){\n            t[i >> 3] = (cmp(A[i - 1], A[i]) ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n        }\n        t[n >> 3] = t[n >> 3] | mask[n & 7];\n\n        Lv[A[0]] = 0;\n        for(i = 1; i < n; i++){\n            Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n        }\n\n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n\n    char p[1000];\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n\n    A[n] = n;\n\n    while(q){\n        scanf(\"%s\", p);\n        std::string P = std::string(p);\n        left = 0, right = n, exist = false;\n        while(left < right){\n\n            if(n < P.size()){ exist = false; break; }\n\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n\n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1000000000 + 7;\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nstruct SuffixArray {\n    int n, k;\n    string text;\n    vector<int> sa;\n    vector<int> rank;\n    vector<int> lcp;\n\n    SuffixArray (const string &s)\n    : text(s), n(s.size()), sa(n + 1), rank(n + 1), lcp(n)\n    {}\n\n    bool comp(int i, int j) {\n        if (rank[i] != rank[j]) return rank[i] < rank[j];\n        int ri = i + k <= n ? rank[i + k] : -1;\n        int rj = j + k <= n ? rank[j + k] : -1;\n        return ri < rj;\n    }\n\n    void construct_sa() {\n        for (int i = 0; i <= n; i++) {\n            sa[i] = i;\n            rank[i] = i < n ? text[i] : -1;\n        }\n\n        for (k = 1; k <= n; k *= 2) {\n            sort(sa.begin(), sa.end(), [&](const int& i, const int& j) {return comp(i, j);});\n\n            vector<int> tmp(n + 1);\n            tmp[sa[0]] = 0;\n            for (int i = 1; i <= n; i++) {\n                tmp[sa[i]] = tmp[sa[i - 1]] + (comp(sa[i - 1], sa[i]) ? 1 : 0);\n            }\n\n            for (int i = 0; i <= n; i++) {\n                rank[i] = tmp[i];\n            }\n        }\n    }\n\n    void construct_lcp () {\n        int h = 0;\n        lcp[0] = 0;\n        for (int i = 0; i < n; i++) {\n            int j = sa[rank[i] - 1];\n            if (h > 0) h--;\n            for (; j + h < n && i + h < n; h++) {\n                if (text[j + h] != text[i + h]) break;\n            }\n            lcp[rank[i] - 1] = h;\n        }\n    }\n\n    inline int low_bd(const string &pt) {\n        int l = 0, r = n + 1;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val < 0) l = m;\n            else r = m;\n        }\n        return r;\n    }\n\n    int up_bd(const string &pt) {\n        int l = 1, r = n + 1;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val <= 0) l = m;\n            else r = m;\n        }\n        return r;\n    }\n\n    bool match(const string &pt) {\n        int idx = low_bd(pt);\n        if (idx == sa.size()) return false;\n        return text.compare(sa[idx], pt.length(), pt) == 0 ? true : false;\n    }\n\n    int count(const string &pt) {\n        int l_idx = low_bd(pt);\n        if (l_idx == sa.size()) return 0;\n        if (text.compare(sa[l_idx], pt.length(), pt) != 0) return 0;\n        int r_idx = up_bd(pt);\n        return r_idx - l_idx;\n    }\n};\n\nstring t;\nint q;\nstring p[10000];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> t;\n    cin >> q;\n    rep(i, q) cin >> p[i];\n    SuffixArray suf(t);\n    suf.construct_sa();\n    rep(i, q) {\n        if (suf.match(p[i])) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define MAX 10002\ntypedef unsigned char byte;\nbyte mask[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\n\nint Lv[MAX];\nint n, k;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n    return L_i < L_j;\n}\n\nint main()\n{\n    int A[MAX];\n    char c[MAX];\n    scanf(\"%s\", c);\n    std::string T = std::string(c);\n    n = T.size();\n    byte *t;\n    t = new byte [(n >> 3) + 1];\n\tbool act;\n\tint l, r;\n\n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n    std::sort(A, A + n, cmp_Lv);\n\n    for(i = 1; i < n; i++){\n        t[i >> 3] = (Lv[A[i]] != Lv[A[i - 1]] ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n    }\n\tt[n >> 3] = t[n >> 3] | mask[n & 7];\n\n    Lv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n    }\n\n    k = 1;\n    while(1){\n        if(k > n) break;\n\n\n        //std::sort(A, A + n, cmp);\n\t\n\t\tact = true;\n\t\tfor(i = 1; i <= n; i++){\n\t\t\tif(act){\n\t\t\t\tif(!!(mask[i & 7] & t[i >> 3])){ continue; }\n\t\t\t\telse{ l = i - 1; act = false; }\n\t\t\t}else{\n\t\t\t\tif(!!(mask[i & 7] & t[i >> 3])){\n\t\t\t\t\tr = i; std::sort(A + l, A + r, cmp); act = true; }\n\t\t\t\telse{ continue; }\n\t\t\t}\n\t\t}\n\n\n \n        for(i = 1; i < n; i++){\n            t[i >> 3] = (cmp(A[i - 1], A[i]) ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n        }\n\t\tt[n >> 3] = t[n >> 3] | mask[n & 7];\n\n        Lv[A[0]] = 0;\n        for(i = 1; i < n; i++){\n            Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n        }\n\n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n\n    char p[1000];\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n\n    A[n] = n;\n\n    while(q){\n        scanf(\"%s\", p);\n        std::string P = std::string(p);\n        left = 0, right = n, exist = false;\n        while(left < right){\n\n            if(n < P.size()){ exist = false; break; }\n\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n\n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) { \n    const int k=lcp(i,j);\n    //const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    //const int k=lcp2(i,j,0,(n-max(i,j))*2+1);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e){\n    assert(b<e);\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j){\n    //int l=0,r=min(n-i,n-j)+1;\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n  \n  /*\n  inline int lcp2(const int& i, const int& j, const int& l, const int& r){\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n  */\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\nif(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring S,T;\nstring V[1000][100];\nint main(){\n\tint q,a,b,c;\n\tb=S.size();\n\tcin>>S;\n\ta=min(b,100);\n\tfor(int i=1;i<100;i++){\n\t\tfor(int j=0;j<=b-i;j++){\n\t\t\tV[j][i]=S.substr(j,i);\n\t\t}\n\t}\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>T;\n\t\tc=T.size();\n\t\tfor(int j=0;j<b-c;j++){\n\t\t\tif(V[j][c]==T){\n\t\t\t\tcout<<\"1\"<<endl;\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t}\n\t\tcout<<\"0\"<<endl;\n\t\tExit:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<stdio.h>\n\n#define A 1995455101 // large prime number.\n#define B 1995455447 // large prime number, bigger than A.\n\nint main()\n{\n\tchar T[1000000]; scanf(\"%s\", T); int len_T = 0; while(T[len_T]){ len_T++; };\n    char P[1000];                    int len_P;\n    long long *has_T, *has_P;\n    has_T = new long long [len_T];\n    has_P = new long long [10001];\n    long long last_has;\n\n    long long h; int i;  // hash coding.\n    h = 0;\n    for(i = 0; i < len_T; i++){ h = (h * A + T[i]) % B; has_T[i] = h; }\n\n\tlong long pow[1001]; // pow[i] = A^i mod B.\n\tpow[0] = 1;\n\tfor(i = 1; i < 1001; i++){ pow[i] = (pow[i - 1] * A) % B; }\n\n    int q;\n    scanf(\"%d\", &q);\n    while(q){\n\t\tscanf(\"%s\", P); len_P = 0; while(P[len_P]){ len_P++; };\n\n        h = 0;\n        for(i = 0; i < len_P; i++){ h = (h * A + P[i]) % B; has_P[i] = h; }\n        last_has = has_P[len_P - 1];\n\n        for(i = len_P - 1; i < len_T; i++){\n            if(has_T[i] == ((i >= len_P ? has_T[i - len_P] : 0) * pow[len_P] + last_has) % B){\n                printf(\"%d\\n\", 1); break;\n            }\n        }\n        if(i == len_T){ printf(\"%d\\n\", 0); }\n        q--;\n    };\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n#include <vector>\n#include <deque>\n\nusing namespace std;\n\n#define isLMS(i) (i > 0 && t[i] && !t[i - 1])\n\n// find the start or end of each bucket\ntemplate <typename T> void getBuckets(T* s, int* bkt, int n, int K, bool end) {\n    int sum = 0;\n    for (int i = 0; i <= K; i++)\n        bkt[i] = 0; // clear all buckets\n    for (int i = 0; i < n; i++)\n        bkt[s[i]]++; // compute the size of each bucket\n    for (int i = 0; i <= K; i++) {\n        sum += bkt[i];\n        bkt[i] = end ? sum : sum - bkt[i];\n    }\n}\n\n// compute SAl\ntemplate <typename T>\nvoid induceSAl(std::vector<bool>& t, int* SA, T* s, int* bkt, int n, int K) {\n    getBuckets(s, bkt, n, K, false); // find starts of buckets\n    for (int i = 0; i < n; i++) {\n        int j = SA[i] - 1;\n        if (j >= 0 && !t[j])\n            SA[bkt[s[j]]++] = j;\n    }\n}\n\n// compute SAs\ntemplate <typename T>\nvoid induceSAs(std::vector<bool>& t, int* SA, T* s, int* bkt, int n, int K) {\n    getBuckets(s, bkt, n, K, true); // find ends of buckets\n    for (int i = n - 1; i >= 0; i--) {\n        int j = SA[i] - 1;\n        if (j >= 0 && t[j])\n            SA[--bkt[s[j]]] = j;\n    }\n}\n\n// find the suffix array SA of s[0..n-1] in {1..K}^n\n// require s[n-1]=0 (the sentinel!), n>=2\n// use a working space (excluding s and SA) of at most 2.25n+O(1) for a constant\n// alphabet\ntemplate <typename T> void SA_IS(T* s, int* SA, int n, int K) {\n\n    std::vector<bool> t(n);\n\n    // Classify the type of each character\n    t[n - 2] = 0;\n    t[n - 1] = 1; // the sentinel must be in s1, important!!!\n    for (int i = n - 3; i >= 0; i--)\n        t[i] = (s[i] < s[i + 1] || (s[i] == s[i + 1] && t[i + 1] == 1)) ? 1 : 0;\n\n    // stage 1: reduce the problem by at least 1/2\n    // sort all the S-substrings\n    int* bkt = (int*)malloc(sizeof(int) * (K + 1)); // bucket array\n    getBuckets(s, bkt, n, K, true);                  // find ends of buckets\n    for (int i = 0; i < n; i++)\n        SA[i] = -1;\n    for (int i = 1; i < n; i++)\n        if (isLMS(i))\n            SA[--bkt[s[i]]] = i;\n\n    induceSAl(t, SA, s, bkt, n, K);\n    induceSAs(t, SA, s, bkt, n, K);\n    free(bkt);\n\n    // compact all the sorted substrings into the first n1 items of SA\n    // 2*n1 must be not larger than n (proveable)\n    int n1 = 0;\n    for (int i = 0; i < n; i++)\n        if (isLMS(SA[i]))\n            SA[n1++] = SA[i];\n\n    // find the lexicographic names of all substrings\n    for (int i = n1; i < n; i++)\n        SA[i] = -1; // init the name array buffer\n    int name = 0, prev = -1;\n    for (int i = 0; i < n1; i++) {\n        int pos = SA[i];\n        bool diff = false;\n        for (int d = 0; d < n; d++)\n            if (prev == -1 || s[pos + d] != s[prev + d] ||\n                t[pos + d] != t[prev + d]) {\n                diff = true;\n                break;\n            }\n            else if (d > 0 && (isLMS(pos + d) || isLMS(prev + d)))\n                break;\n        if (diff) {\n            name++;\n            prev = pos;\n        }\n        pos = (pos % 2 == 0) ? pos / 2 : (pos - 1) / 2;\n        SA[n1 + pos] = name - 1;\n    }\n    for (int i = n - 1, j = n - 1; i >= n1; i--)\n        if (SA[i] >= 0)\n            SA[j--] = SA[i];\n\n    // stage 2: solve the reduced problem\n    // recurse if names are not yet unique\n    int* SA1 = SA, * s1 = SA + n - n1;\n    if (name < n1)\n        SA_IS(s1, SA1, n1, name - 1);\n    else // generate the suffix array of s1 directly\n        for (int i = 0; i < n1; i++)\n            SA1[s1[i]] = i;\n\n    // stage 3: induce the result for the original problem\n    bkt = (int*)malloc(sizeof(int) * (K + 1)); // bucket array\n    // put all left-most S characters into their buckets\n    getBuckets(s, bkt, n, K, true); // find ends of buckets\n    for (int i = 1, j = 0; i < n; i++)\n        if (isLMS(i))\n            s1[j++] = i; // get p1\n    for (int i = 0; i < n1; i++)\n        SA1[i] = s1[SA1[i]]; // get index in s\n    for (int i = n1; i < n; i++)\n        SA[i] = -1; // init SA[n1..n-1]\n    for (int i = n1 - 1; i >= 0; i--) {\n        int j = SA[i];\n        SA[i] = -1;\n        SA[--bkt[s[j]]] = j;\n    }\n    induceSAl(t, SA, s, bkt, n, K);\n    induceSAs(t, SA, s, bkt, n, K);\n    free(bkt);\n    //free(t);\n}\n\n\nbool starts_with(const char* target, const char* pattern) {\n    for (;;) {\n        if (*target != *pattern) return false;\n        ++target;\n        ++pattern;\n        if (!*pattern) return true;\n    }\n}\n\nint compare(const char* target, const char* pattern) {\n    for (;;) {\n        if (*target != *pattern) {\n            if (*target > * pattern) return 1;\n            else return -1;\n        }\n        ++target;\n        ++pattern;\n        if (!*pattern) return 0;\n    }\n}\n\nbool search(string t, int* SA, int n, string p) {\n    int lower = 0;              // 探索範囲の下限の添字\n    int upper = n - 1;  // 探索範囲の上限の添字\n\n\n    const char* target = t.c_str();\n    const char* pattern = p.c_str();\n    while (lower <= upper) {  // 上限と下限が逆転したら終わり\n\n        // 中央の位置を求める\n        int mid = (lower + upper) / 2;\n\n        int n = SA[mid];\n        \n        int ret = compare(target + n, pattern);\n        if (ret == 0) {\n            return true;\n        }\n        if (ret < 0) {\n            lower = mid + 1;  // 次は中央より後ろを調べるため、下限を変更\n        }\n        else {\n            upper = mid - 1;  // 次は中央より手前を調べるため、上限を変更\n        }\n    }\n\n    return false;\n}\n\nint SA[1000002];\nint main() {\n#if 0\n    unsigned char s[100] = \"mmiissiissiippii\";\n    SA_IS(s, SA, 17, 128);\n    assert(SA[0] == 16);\n    assert(SA[1] == 15);\n    assert(SA[2] == 14);\n    assert(SA[3] == 10);\n    assert(SA[4] == 6);\n    assert(SA[5] == 2);\n    assert(SA[6] == 11);\n    assert(SA[7] == 7);\n    assert(SA[8] == 3);\n    assert(SA[9] == 1);\n    assert(SA[10] == 0);\n    assert(SA[11] == 13);\n    assert(SA[12] == 12);\n    assert(SA[13] == 9);\n    assert(SA[14] == 5);\n    assert(SA[15] == 8);\n    assert(SA[16] == 4);\n\n    // #=> [16, 15, 14, 10, 6, 2, 11, 7, 3, 1, 0, 13, 12, 9, 5, 8, 4]\n\n    assert(starts_with(\"mmiissiissiippii\", \"mmiissiissiippii\"));\n    assert(starts_with(\"mmiissiissiippii\", \"mmiissiissi\"));\n    assert(!starts_with(\"miissiissiippii\", \"mmiissiissi\"));\n#endif\n#if 0\n    pair<string, vector<ptrdiff_t>> sara_string_test_data[] = {\n      { \"mmiissiissiippii\",\n        { 15, 14, 10, 6, 2, 11, 7, 3, 1, 0, 13, 12, 9, 5, 8, 4 } },\n      { \"mmiissiippiissii\",\n        { 15, 14, 6, 10, 2, 7, 11, 3, 1, 0, 9, 8, 13, 5, 12, 4 } },\n      { \"abracadabra\", { 10, 7, 0, 3, 5, 8, 1, 4, 6, 9, 2 } },\n      { \"aeadacab\", { 6, 4, 2, 0, 7, 5, 3, 1 } },\n      { \"abracadabra0AbRa4Cad14abra\",\n        { 11, 20, 16, 21, 12, 17, 14, 25, 10, 15, 22, 7, 0, 3, 18, 5, 13, 23, 8, 1,\n          4, 19, 6, 24, 9, 2} }\n    };\n#endif\n\n#if 1\n    string t;\n    cin >> t;\n\n    SA_IS((unsigned char*)t.c_str(), SA, t.size() + 1, 128);\n\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; ++i) {\n        string x;\n        cin >> x;\n        cout << search(t, SA, t.size() + 1, x) << endl;\n    }\n#endif\n    //std::cout << \"Hello World!\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// #include {{{\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <chrono>\n#include <cmath>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <forward_list>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#ifdef LOCAL\n#include <fmt/format.h>\n#include <fmt/ostream.h>\n#endif\n\nusing namespace std;\n// }}}\n\n// type {{{\nusing  i8 =   int8_t;\nusing  u8 =  uint8_t;\nusing i16 =  int16_t;\nusing u16 = uint16_t;\nusing i32 =  int32_t;\nusing u32 = uint32_t;\nusing i64 =  int64_t;\nusing u64 = uint64_t;\n\nusing i128 =  __int128_t;\nusing u128 = __uint128_t;\n\ntemplate<typename T>\nusing MaxHeap = priority_queue<T, vector<T>, less<T>>;\ntemplate<typename T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\n// }}}\n\n// hide {{{\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-const-variable\"\n#endif\n// }}}\n\n// 適宜調整\nconstexpr bool AUTOFLUSH = false;\n\nconstexpr int IOS_PREC = 12;\n\nconstexpr int INF_I32 =             1'010'000'000;\nconstexpr i64 INF_I64 = 1'010'000'000'000'000'000LL;\n\nconstexpr auto   INF = INF_I64;\nconstexpr double EPS = 1e-12;\n\nconstexpr i64 MOD = 1'000'000'007;\n\n// hide {{{\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n// }}}\n\n// util {{{\nconstexpr i32 I32_MAX = numeric_limits<i32>::max();\nconstexpr i32 I32_MIN = numeric_limits<i32>::min();\n\nconstexpr i64 I64_MAX = numeric_limits<i64>::max();\nconstexpr i64 I64_MIN = numeric_limits<i64>::min();\n\nconstexpr double PI = 3.14159265358979323846;\n\ntemplate<typename F>\nclass RecursiveFunc {\npublic:\n    RecursiveFunc(F&& f) : f_(f) {}\n\n    template<typename... Args>\n    decltype(auto) operator()(Args&&... args) const {\n        return f_(*this, forward<Args>(args)...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<typename F>\nauto RECURSIVE(F&& f) {\n    return RecursiveFunc<decay_t<F>>(forward<F>(f));\n}\n\ntemplate<typename T>\nint GETBIT(T x, int i) { return (x>>i) & 1; }\ntemplate<typename T>\nT SETBIT(T x, int i) { return x | (T(1)<<i); }\ntemplate<typename T>\nT CLEARBIT(T x, int i) { return x & ~(T(1)<<i); }\n\ntemplate<typename T>\nconstexpr const T& MAX(const T& x, const T& y) { return std::max(x, y); }\ntemplate<typename T, typename Comp>\nconstexpr const T& MAX(const T& x, const T& y, Comp comp) { return std::max(x, y, comp); }\ntemplate<typename T>\nconstexpr T MAX(initializer_list<T> ilist) { return std::max(ilist); }\ntemplate<typename T, typename Comp>\nconstexpr T MAX(initializer_list<T> ilist, Comp comp) { return std::max(ilist, comp); }\n\ntemplate<typename T>\nconstexpr const T& MIN(const T& x, const T& y) { return std::min(x, y); }\ntemplate<typename T, typename Comp>\nconstexpr const T& MIN(const T& x, const T& y, Comp comp) { return std::min(x, y, comp); }\ntemplate<typename T>\nconstexpr T MIN(initializer_list<T> ilist) { return std::min(ilist); }\ntemplate<typename T, typename Comp>\nconstexpr T MIN(initializer_list<T> ilist, Comp comp) { return std::min(ilist, comp); }\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    static_assert(is_signed<T>::value, \"ABS(): argument must be signed\");\n    return x < 0 ? -x : x;\n}\n\ntemplate<typename T>\nconstexpr T abs_diff(T x, T y) {\n    return x < y ? y-x : x-y;\n}\n\ntemplate<typename T>\nconstexpr bool is_odd(T x)  { return x % 2 != 0; }\ntemplate<typename T>\nconstexpr bool is_even(T x) { return x % 2 == 0; }\n\ntemplate<typename T>\nconstexpr bool parity_same(T x, T y) {\n    return (is_odd(x) && is_odd(y)) || (is_even(x) && is_even(y));\n}\n\ntemplate<typename T>\nconstexpr int cmp(T x, T y) { return (y < x) - (x < y); }\n\ntemplate<typename T>\nconstexpr int sgn(T x) { return cmp(x, T(0)); }\n\nconstexpr i64 ipow(i64 a, i64 b) {\n    assert(b >= 0);\n    i64 res(1);\n    for(i64 i = 0; i < b; ++i)\n        res *= a;\n    return res;\n}\n\npair<i64,i64> divmod(i64 a, i64 b) {\n    return make_pair(a/b, a%b);\n}\n\nconstexpr i64 div_ceil(i64 a, i64 b) {\n    return a/b + (((a<0)^(b>0)) && (a%b));\n}\n\nconstexpr i64 div_floor(i64 a, i64 b) {\n    return a/b - (((a>0)^(b>0)) && (a%b));\n}\n\nconstexpr i64 modulo(i64 a, i64 b) {\n    assert(0 < b);\n    i64 r = a % b;\n    return r >= 0 ? r : r+b;\n}\n\ntemplate<typename T>\nconstexpr T CLAMP(T x, T lo, T hi) {\n    assert(lo <= hi);\n    if(x < lo)\n        return lo;\n    else if(hi < x)\n        return hi;\n    else\n        return x;\n}\n\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n    if(xmax < x) {\n        xmax = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T>\nconstexpr int SIZE(const T& c) {\n    return static_cast<int>(c.size());\n}\n\ntemplate<typename T, size_t N>\nconstexpr int SIZE(const T (&)[N]) {\n    return static_cast<int>(N);\n}\n\ntemplate<typename InputIt, typename T>\nint argfind(InputIt first, InputIt last, const T& x) {\n    auto it = find(first, last, x);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nint argmax(InputIt first, InputIt last) {\n    auto it = max_element(first, last);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nint argmin(InputIt first, InputIt last) {\n    auto it = min_element(first, last);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nbool alltrue(InputIt first, InputIt last) {\n    return all_of(first, last, [](bool b) { return b; });\n}\n\ntemplate<typename InputIt>\nbool anytrue(InputIt first, InputIt last) {\n    return any_of(first, last, [](bool b) { return b; });\n}\n\ntemplate<typename InputIt>\nbool allfalse(InputIt first, InputIt last) {\n    return !anytrue(first, last);\n}\n\ntemplate<typename InputIt>\nbool anyfalse(InputIt first, InputIt last) {\n    return !alltrue(first, last);\n}\n\n// hash {{{\ntemplate<typename T>\nstruct myhash {\n    size_t operator()(const T& x) const {\n        hash<T> h;\n        return h(x);\n    }\n};\n\ntemplate<typename T>\nsize_t myhash_value(const T& x) {\n    return hash<T>()(x);\n}\n\ntemplate<typename T>\nvoid myhash_combine(size_t& seed, const T& x) {\n    seed ^= myhash_value(x) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n}\n\ntemplate<typename T1, typename T2>\nstruct myhash<pair<T1,T2>> {\n    size_t operator()(const pair<T1,T2>& p) const {\n        size_t seed = 0;\n        myhash_combine(seed, p.first);\n        myhash_combine(seed, p.second);\n        return seed;\n    }\n};\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\nvoid TUPLEHASH(size_t&, const tuple<TS...>&) {}\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\nvoid TUPLEHASH(size_t& seed, const tuple<TS...>& t) {\n    myhash_combine(seed, get<I>(t));\n    TUPLEHASH<I+1, TS...>(seed, t);\n}\n\ntemplate<typename... TS>\nstruct myhash<tuple<TS...>> {\n    size_t operator()(const tuple<TS...>& t) const {\n        size_t seed = 0;\n        TUPLEHASH(seed, t);\n        return seed;\n    }\n};\n\ntemplate<typename Seq>\nvoid SEQHASH(size_t& seed, const Seq& v) {\n    for(const auto& e : v)\n        myhash_combine(seed, e);\n}\n\ntemplate<typename T>\nstruct myhash<vector<T>> {\n    size_t operator()(const vector<T>& v) const {\n        size_t seed = 0;\n        SEQHASH(seed, v);\n        return seed;\n    }\n};\n\ntemplate<typename T, size_t N>\nstruct myhash<array<T,N>> {\n    size_t operator()(const array<T,N>& v) const {\n        size_t seed = 0;\n        SEQHASH(seed, v);\n        return seed;\n    }\n};\n\ntemplate<typename T>\nusing HashSet = unordered_set<T,myhash<T>>;\n\ntemplate<typename K, typename V>\nusing HashMap = unordered_map<K,V,myhash<K>>;\n\ntemplate<typename T>\nusing HashMultiSet = unordered_multiset<T,myhash<T>>;\n\ntemplate<typename K, typename V>\nusing HashMultiMap = unordered_multimap<K,V,myhash<K>>;\n// }}}\n\ntemplate<typename T, typename... Args>\nvoid vec_emplace_front(vector<T>& v, Args&&... args) {\n    v.emplace(begin(v), args...);\n}\n\ntemplate<typename K, typename V>\npair<typename map<K,V>::iterator, bool> insert_or_assign(map<K,V>& m, const K& k, const V& v) {\n    auto it = m.lower_bound(k);\n    if(it != end(m) && !m.key_comp()(k,it->first)) {\n        it->second = v;\n        return make_pair(it, false);\n    }\n    else {\n        auto it_ins = m.insert(it, make_pair(k,v));\n        return make_pair(it_ins, true);\n    }\n}\n\ntemplate<typename K, typename V>\npair<typename HashMap<K,V>::iterator, bool>\ninsert_or_assign(HashMap<K,V>& m, const K& k, const V& v) {\n    auto it = m.find(k);\n    if(it != end(m)) {\n        it->second = v;\n        return make_pair(it, false);\n    }\n    else {\n        auto it_ins = m.insert(it, make_pair(k,v));\n        return make_pair(it_ins, true);\n    }\n}\n\ntemplate<typename T>\nstring TO_STRING(const T& x) {\n    ostringstream out;\n    out << x;\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n    ostringstream out;\n    while(first != last) {\n        out << *first++;\n        if(first != last)\n            out << sep;\n    }\n    return out.str();\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename T>\nvoid UNIQ(T& c) {\n    c.erase(unique(begin(c), end(c)), end(c));\n}\n\ntemplate<typename T, typename F>\nenable_if_t<rank<T>::value==0> ARRAY_FOREACH(T& e, F f) {\n    f(e);\n}\n\ntemplate<typename Array, typename F>\nenable_if_t<rank<Array>::value!=0> ARRAY_FOREACH(Array& ary, F f) {\n    for(auto& e : ary)\n        ARRAY_FOREACH(e, f);\n}\n\ntemplate<typename Array, typename U>\nenable_if_t<rank<Array>::value!=0> ARRAY_FILL(Array& ary, const U& v) {\n    ARRAY_FOREACH(ary, [&v](auto& elem) { elem = v; });\n}\n\ntemplate<typename T>\nT POP_BACK(vector<T>& que) {\n    T x = que.back(); que.pop_back();\n    return x;\n}\n\ntemplate<typename T>\nT POP_BACK(deque<T>& que) {\n    T x = que.back(); que.pop_back();\n    return x;\n}\n\ntemplate<typename T>\nT POP_FRONT(deque<T>& que) {\n    T x = que.front(); que.pop_front();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(stack<T,C>& stk) {\n    T x = stk.top(); stk.pop();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(queue<T,C>& que) {\n    T x = que.front(); que.pop();\n    return x;\n}\n\ntemplate<typename T, typename Cont, typename Cmp>\nT POP(priority_queue<T,Cont,Cmp>& que) {\n    T x = que.top(); que.pop();\n    return x;\n}\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef LOCAL\n    if(!cin) assert(false);\n#endif\n}\n\ntemplate<typename T>\nvoid RD(vector<T>& v, int n) {\n    v.reserve(n);\n    for(int i = 0; i < n; ++i) {\n        T e; RD(e);\n        v.emplace_back(e);\n    }\n}\n\ntemplate<typename T, size_t N>\nvoid RD(array<T,N>& v) {\n    for(size_t i = 0; i < N; ++i) {\n        RD(v[i]);\n    }\n}\n\n// 出力 {{{\n// FPRINTSEQ {{{\ntemplate<typename InputIt>\nostream& FPRINTSEQ(ostream& out, InputIt first, InputIt last) {\n    while(first != last) {\n        out << *first++;\n        if(first != last)\n            out << ' ';\n    }\n    return out;\n}\ntemplate<typename InputIt>\nostream& PRINTSEQ(InputIt first, InputIt last) {\n    return FPRINTSEQ(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTSEQ(InputIt first, InputIt last) {\n#ifdef LOCAL\n    FPRINTSEQ(cerr, first, last);\n#endif\n    return cerr;\n}\n// }}}\n\n// 1次元生配列 {{{\ntemplate<typename T, size_t N>\nostream& FPRINTARRAY1(ostream& out, const T (&c)[N]) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\ntemplate<typename T, size_t N>\nostream& PRINTARRAY1(const T (&c)[N]) {\n    return FPRINTARRAY1(cout, c);\n}\ntemplate<typename T, size_t N>\nostream& DPRINTARRAY1(const T (&c)[N]) {\n#ifdef LOCAL\n    FPRINTARRAY1(cerr, c);\n#endif\n    return cerr;\n}\n// }}}\n\n// 2次元生配列 {{{\ntemplate<typename T, size_t N1, size_t N2>\nostream& FPRINTARRAY2(ostream& out, const T (&c)[N1][N2]) {\n    out << '\\n';\n    for(const auto& e : c) {\n        FPRINTARRAY1(out, e) << '\\n';\n    }\n    return out;\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& PRINTARRAY2(const T (&c)[N1][N2]) {\n    return FPRINTARRAY2(cout, c);\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& DPRINTARRAY2(const T (&c)[N1][N2]) {\n#ifdef LOCAL\n    FPRINTARRAY2(cerr, c);\n#endif\n    return cerr;\n}\n// }}}\n\n// 非mapコンテナ {{{\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\n// 特別扱い\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T>>& c) {\n    out << '\\n';\n    for(const auto& e : c) {\n        out << e << '\\n';\n    }\n    return out;\n}\n\n// 特別扱い\nostream& operator<<(ostream& out, const vector<string>& c) {\n    out << '\\n';\n    for(const string& e : c) {\n        out << e << '\\n';\n    }\n    return out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const deque<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const set<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const HashSet<T>& c) {\n    return out << set<T>(begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const multiset<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const HashMultiSet<T>& c) {\n    return out << multiset<T>(begin(c), end(c));\n}\n\ntemplate<typename T, size_t N>\nostream& operator<<(ostream& out, const array<T,N>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n// }}}\n\n// mapコンテナ {{{\ntemplate<typename InputIt>\nostream& FPRINTMAP(ostream& out, InputIt first, InputIt last) {\n    out << \"{\\n\";\n    for(auto it = first; it != last; ++it) {\n        out << \"  \" << it->first << \" : \" << it->second << '\\n';\n    }\n    out << \"}\\n\";\n    return out;\n}\ntemplate<typename InputIt>\nostream& PRINTMAP(InputIt first, InputIt last) {\n    return FPRINTMAP(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTMAP(InputIt first, InputIt last) {\n#ifdef LOCAL\n    FPRINTMAP(cerr, first, last);\n#endif\n    return cerr;\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const map<K,V>& c) {\n    return FPRINTMAP(out, begin(c), end(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const HashMap<K,V>& c) {\n    return out << map<K,V>(begin(c), end(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const multimap<K,V>& c) {\n    return FPRINTMAP(out, begin(c), end(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const HashMultiMap<K,V>& c) {\n    return out << multimap<K,V>(begin(c), end(c));\n}\n// }}}\n\n// stack/queue/priority_queue {{{\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, stack<T,C> c) {\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, queue<T,C> c) {\n    while(!c.empty()) {\n        out << c.front();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename Cont, typename Cmp>\nostream& operator<<(ostream& out, priority_queue<T,Cont,Cmp> c) {\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n// }}}\n\n// pair/tuple {{{\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p) {\n    return out << '(' << p.first << ',' << p.second << ')';\n}\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\nostream& FPRINTTUPLE(ostream& out, const tuple<TS...>&) {\n    if(sizeof...(TS) == 0)\n        out << '(';\n    return out << ')';\n}\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\nostream& FPRINTTUPLE(ostream& out, const tuple<TS...>& t) {\n    if(I == 0)\n        out << '(';\n    else\n        out << ',';\n    out << get<I>(t);\n    return FPRINTTUPLE<I+1, TS...>(out, t);\n}\n\ntemplate<typename... TS>\nostream& operator<<(ostream& out, const tuple<TS...>& t) {\n    return FPRINTTUPLE(out, t);\n}\n// }}}\n\n// PRINT {{{\nostream& FPRINT(ostream& out) { return out; }\n\ntemplate<typename T, typename... TS>\nostream& FPRINT(ostream& out, const T& x, const TS& ...args) {\n    out << x;\n    if(sizeof...(args))\n        out << ' ';\n    return FPRINT(out, args...);\n}\n\ntemplate<typename... TS>\nostream& FPRINTLN(ostream& out, const TS& ...args) {\n    FPRINT(out, args...);\n    return out << '\\n';\n}\n\ntemplate<typename... TS>\nostream& PRINT(const TS& ...args) {\n    return FPRINT(cout, args...);\n}\n\ntemplate<typename... TS>\nostream& PRINTLN(const TS& ...args) {\n    return FPRINTLN(cout, args...);\n}\n\ntemplate<typename... TS>\nostream& DPRINT(const TS& ...args) {\n#ifdef LOCAL\n    FPRINT(cerr, args...);\n#endif\n    return cerr;\n}\n\ntemplate<typename... TS>\nostream& DPRINTLN(const TS& ...args) {\n#ifdef LOCAL\n    FPRINTLN(cerr, args...);\n#endif\n    return cerr;\n}\n// }}}\n// }}}\n\nvoid FLUSH() {\n    cout.flush();\n}\n\n[[noreturn]] void EXIT() {\n#ifdef LOCAL\n    cout.flush();\n    cerr.flush();\n#else\n    FLUSH();\n#endif\n    //quick_exit(0); // does not work on codeforces\n    _Exit(0);\n}\n\nstruct IoInit {\n    IoInit() {\n#ifndef LOCAL\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n#endif\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef LOCAL\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} IOINIT;\n\n#define FOR(i, start, end) for(i64 i = (start); i < (end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cc) { return (f)(begin(cc), end(cc), ## __VA_ARGS__); })(c))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(forward<decltype(args)>(args)...); })\n\n#define DBG(x) DPRINTLN('L', __LINE__, ':', #x, ':', (x))\n\n#define PAIR make_pair\n#define TUPLE make_tuple\n// }}}\n\ntemplate<typename RandomIt>\nclass SuffixArray {\npublic:\n    SuffixArray(RandomIt first, RandomIt last)\n        : first_(first), last_(last), sa_(distance(first,last)) {\n        const int n = SIZE(sa_);\n\n        ALL(iota, sa_, 0);\n        ALL(sort, sa_, [first](int i, int j) {\n            return *(first+i) < *(first+j);\n        });\n\n        vector<int> rnk(n);\n        rnk[sa_[0]] = 0;\n        FOR(i, 1, n) {\n            rnk[sa_[i]] = rnk[sa_[i-1]];\n            if(*(first+sa_[i-1]) < *(first+sa_[i]))\n                ++rnk[sa_[i]];\n        }\n\n        vector<int> tmp(n);\n        for(int k = 1; k < n; k *= 2) {\n            auto les = [n, k, &rnk](int i, int j) {\n                if(rnk[i] != rnk[j]) return rnk[i] < rnk[j];\n                int ri = i+k < n ? rnk[i+k] : -1;\n                int rj = j+k < n ? rnk[j+k] : -1;\n                return ri < rj;\n            };\n            ALL(sort, sa_, les);\n\n            tmp[sa_[0]] = 0;\n            FOR(i, 1, n) {\n                tmp[sa_[i]] = tmp[sa_[i-1]];\n                if(les(sa_[i-1], sa_[i]))\n                    ++tmp[sa_[i]];\n            }\n            swap(rnk, tmp);\n        }\n    }\n\n    template<typename ForwardIt>\n    int find(ForwardIt first, ForwardIt last) {\n        if(first == last) return 0;\n\n        const int n = SIZE(sa_);\n        const int m = distance(first, last);\n\n        // インデックスなので普通オーバーフローは起こらないはず\n        int lo = 0;\n        int hi = n;\n        while(lo+1 < hi) {\n            int mid = (lo+hi) / 2;\n            auto it1 = first_ + sa_[mid];\n            auto it2 = n - sa_[mid] < m ? last_ : it1 + m;\n            if(lexicographical_compare(first, last, it1, it2))\n                hi = mid;\n            else\n                lo = mid;\n        }\n        if(n - sa_[lo] < m) return -1;\n        return equal(first, last, first_+sa_[lo]) ? sa_[lo] : -1;\n    }\n\nprivate:\n    RandomIt first_;\n    RandomIt last_;\n    vector<int> sa_;\n};\n\ntemplate<typename RandomIt>\nauto make_suffix_array(RandomIt first, RandomIt last) {\n    return SuffixArray<RandomIt>(first, last);\n}\n\nstring T;\n\nvoid solve() {\n    auto sa = ALL(make_suffix_array, T);\n\n    int Q; RD(Q);\n    REP(_, Q) {\n        string p; RD(p);\n        PRINTLN(ALL(sa.find, p) != -1 ? 1 : 0);\n    }\n}\n\nsigned main(signed /*argc*/, char** /*argv*/) {\n    RD(T);\n\n    \n\n    solve();\n\n    EXIT();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <map>\n#include <new>\n#include <deque>\n#include <functional>\nusing namespace std;\n \ntemplate <class T>\nstruct myalloc{\n\tusing value_type = T;\n \n\tstatic const int num = 70;\n\tstatic int k;\n\tstatic deque<vector<char>> dq;\n \n\tmyalloc(){}\n\ttemplate <class U>\n\tmyalloc(const myalloc<U> &){}\n \n\tT* allocate(size_t n){\n\t\tif(k >= num || dq.empty()){\n\t\t\tdq.emplace_back(num * sizeof(T));\n\t\t\tk = 0;\n\t\t}\n\t\treturn reinterpret_cast<T*>(&dq.back()[k++ * sizeof(T)]);\n\t}\n \n\tvoid deallocate(T*, size_t){}\n};\n \ntemplate <class T>\nint myalloc<T>::k;\ntemplate <class T>\ndeque<vector<char>> myalloc<T>::dq;\n \nstruct node{\n\tint fail;\n\tbool vis;\n\tmap<char,int,less<char>,myalloc<char>> nxt;\n};\n \n \nstring input(){\n\tstatic char buf[1000010];\n\tbuf[0] = 0;\n\tscanf(\"%s\", buf);\n\treturn buf;\n}\n \nint main(){\n\tvector<node> trie(1);\n\ttrie[0].fail = -1;\n\n\ttrie.reserve(1000010);\n \n\tstring t = input();\n\tint q;\n\tscanf(\"%d\", &q);\n\tvector<int> idx(q);\n\tfor(int i = 0; i < q; ++i){\n\t\tstring p = input();\n\t\tint u = 0;\n\t\tfor(char c : p){\n\t\t\tif(!trie[u].nxt.count(c)){\n\t\t\t\ttrie[u].nxt.emplace(c, trie.size());\n\t\t\t\ttrie.emplace_back();\n\t\t\t}\n\t\t\tu = trie[u].nxt[c];\n\t\t}\n\t\tidx[i] = u;\n\t}\n \n\tvector<int> bfs;\n\tbfs.push_back(0);\n\tint k = 0;\n\twhile(k < (int)bfs.size()){\n\t\tint u = bfs[k++];\n\t\tfor(const auto &pr : trie[u].nxt){\n\t\t\tchar c = pr.first;\n\t\t\tint v = pr.second;\n\t\t\tbfs.push_back(v);\n \n\t\t\tint f = trie[u].fail;\n\t\t\twhile(f >= 0 && !trie[f].nxt.count(c)){\n\t\t\t\tf = trie[f].fail;\n\t\t\t}\n\t\t\ttrie[v].fail = f >= 0 ? trie[f].nxt[c] : 0;\n\t\t}\n\t}\n \n\tint r = 0;\n\tfor(char c : t){\n\t\twhile(r >= 0 && !trie[r].nxt.count(c)){\n\t\t\tr = trie[r].fail;\n\t\t}\n\t\tr = r >= 0 ? trie[r].nxt[c] : 0;\n\t\ttrie[r].vis = true;\n\t}\n \n\tfor(int i = bfs.size(); --i; ){\n\t\tint u = bfs[i];\n\t\tif(trie[u].vis){\n\t\t\ttrie[trie[u].fail].vis = true;\n\t\t}\n\t}\n \n\tfor(int i = 0; i < q; ++i){\n\t\tprintf(\"%d\\n\", +trie[idx[i]].vis);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    sa.clear();\n    sa.resize(n+1,0);\n    S.push_back('$');\n    iota(sa.begin(),sa.end(),0);\n    sort(sa.begin(),sa.end(),\n\t [&](int a,int b){\n\t   if(S[a]==S[b]) return a>b;\n\t   return S[a]<S[b];\n\t });\n    vector<int> c(n+1,0),r(n+1),cnt(n+1),s(n+1);\n    for(int i=0;i<=n;i++) r[i]=S[i];\n    for(int len=1;len<=n;len*=2){\n      for(int i=0;i<=n;i++){\n\t c[sa[i]]=\n\t   i>0 &&\n\t   r[sa[i-1]]==r[sa[i]] &&\n\t   sa[i-1]+len<=n &&\n\t   r[sa[i-1]+len/2]==r[sa[i]+len/2] ?\n\t   c[sa[i-1]]:i;\n      }\n      iota(cnt.begin(),cnt.end(),0);\n      copy(sa.begin(),sa.end(),r.begin());\n      for(int i=0;i<=n;i++){\n\tint s1=r[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n      c.swap(r);\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  pair<int,int> count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\tif(S.compare(sa[c],tl,T)<0||\n\t   (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n\telse b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return make_pair(0,0);\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return make_pair(b[0],a[1]+1);\n  }\n  \n  void build_lcp(){\n    lcp.clear();\n    lcp.resize(n+1,0);\n    vector<int> r2(n+1);\n    for(int i=0;i<=n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  pair<int,int> count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return make_pair(0,0);\n\n    return make_pair(b[0],a[1]+1);\n  }\n};\n//END CUT HERE\n\n\n//*//\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    auto tmp=sa.count2(P);\n    printf(\"%d\\n\",tmp.first!=tmp.second);\n    //assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n//*/\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/\n\n/*/\nchar buf[1145141];\nsigned main(){\n  int n;\n  scanf(\"%d\",&n);\n  int m;\n  scanf(\"%d\",&m);\n  scanf(\"%s\",buf);\n  string s(buf);\n  SuffixArray sa(s);\n  string t=\"I\";\n  for(int i=0;i<n;i++) t=t+\"OI\";\n  auto tmp=sa.count(t);\n  printf(\"%d\\n\",tmp.second-tmp.first);\n  return 0;\n}\n//*/\n/*\n  verified on 2017/10/20\nhttp://joi2009ho.contest.atcoder.jp/tasks/joi2009ho_a\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\nchar str[1000001];\nint k, len;\nint sa[1000001], Rank[1000001], temp[1000001];\n\nbool compare_sa(int i, int j) {\n    if (Rank[i] == Rank[j]) {\n        int t1 = -1, t2 = -1;\n        if (i + k <= len) {\n            t1 = Rank[i + k];\n        }\n        if (j + k <= len) {\n            t2 = Rank[j + k];\n        }\n        return t1 < t2;\n    }\n    else {\n        return Rank[i] < Rank[j];\n    }\n}\n\nvoid construct_sa() {\n    for (int i = 0; i <= len; i++) {\n        sa[i] = i;\n        if (i == len) {\n            Rank[i] = -1;\n        }\n        else {\n            Rank[i] = str[i];\n        }\n    }\n\n    for (k = 1; k <= len; k *= 2) {\n        sort(sa, sa + len + 1, compare_sa);\n        \n        temp[sa[0]] = 0;\n        for (int i = 1; i <= len; i++) {\n            temp[sa[i]] = temp[sa[i - 1]] + compare_sa(sa[i - 1], sa[i]);\n        }\n        for (int i = 0; i <= len; i++) {\n            Rank[i] = temp[i];\n        }\n    }\n}\n\nint main() {\n    cin >> str;\n    len = strlen(str);\n\n    construct_sa();\n\n    int n, tlen;\n    char t[1001];\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> t;\n        tlen = strlen(t);\n        int left = 0, right = len + 1, pivot;\n        while (left + 1 < right) {\n            pivot = (left + right) / 2;\n\n            if (strncmp(str + sa[pivot], t, tlen) <= 0) {\n                left = pivot;\n            }\n            else {\n                right = pivot;\n            }\n        }\n        cout << (strncmp(str + sa[pivot], t, tlen) == 0) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <unordered_map>\n#include <climits>\n#include <set>\n#include <unordered_set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <complex>\n#include <regex>\n#include <locale>\n#include <random>\n#include <type_traits>\n\nusing namespace std;\n\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\nusing LL = long long;\n\n//------------------------------------------\n//------------------------------------------\n\n/// @details n (logn)^2\nclass Suffix_Array {\nprivate:\n    int n;\n\n    /// @brief |S[0:]|=n\n    /// @brief |S[n:]|=0\n    string S;\n\n    /// @brief 0-index\n    /// @details SA[j] = S[i:]の接尾辞の昇順ソートされた元の位置i\n    /// @details SA[0] = \"\"\n    vector<int> SA;\n\n    /// @brief 0-index\n    /// @details rank[SA[j]] = kのrank分かっている時の2kのrank比較 元の位置S[(i=SA[j]):]のランク\n    vector<int> rank;\n\n    /// @details rank計算用\n    vector<int> tmp;\n\n    bool lb_substr(const string &pat, int si = 0, int ti = 0) {\n        int sn = n;\n        int tn = pat.size();\n        while (si < sn && ti < tn) {\n            if (S[si] < pat[ti]) return true;\n            if (S[si] > pat[ti]) return false;\n            ++si, ++ti;\n        }\n        return si >= sn && ti < tn;\n    }\n\npublic:\n\n    Suffix_Array(const string s) {\n        S = s;\n        n = s.size();\n        SA = vector<int>(n + 1);\n        rank = vector<int>(n + 1);\n        tmp = vector<int>(n + 1);\n        construct();\n    }\n\n    void construct() {\n\n        int k = 1;\n\n        /// @param i 元の文字列Sの位置i S[i:]\n        /// @param j 元の文字列Sの位置j S[j:]\n        auto comp = [&](int i, int j) {\n            if (rank[i] != rank[j]) return rank[i] < rank[j];\n            else {\n                int ri = i + k <= n ? rank[i + k] : -1;\n                int rj = j + k <= n ? rank[j + k] : -1;\n                return ri < rj;\n            }\n        };\n\n        for (int i = 0; i <= n; i++) {\n            SA[i] = i;\n            rank[i] = i < n ? S[i] : -1;\n        }\n\n        for (k = 1; k <= n; k *= 2) {\n            sort(SA.begin(), SA.end(), comp);\n\n            tmp[SA[0]] = 0;\n            for (int i = 1; i <= n; i++) tmp[SA[i]] = tmp[SA[i - 1]] + (comp(SA[i - 1], SA[i]) ? 1 : 0);\n            for (int i = 0; i <= n; i++) rank[i] = tmp[i];\n        }\n    }\n\n    /// @param pat Sに含まれるか調べる文字列パターン\n    /// @brief O(|pat|log|S|)\n    bool contain(const string &pat) {\n        int low = 0;\n        int high = n;\n        while (high - low > 1) {\n            int c = (low + high) / 2;\n            if (S.compare(SA[c], pat.length(), pat) < 0) low = c; // S[SA[c]:] < T\n            else high = c; // S[SA[c]:] >= T\n        }\n        return S.compare(SA[high], pat.length(), pat) == 0;\n    }\n\n    /// @param pat 文字列パターン\n    /// @details 1 ~ n 正常(0は空文字)\n    /// @details n + 1 .end()\n    /// @details SA[high:]が下限\n    int lower_bound(const string &pat) {\n        int low = 0;\n        int high = n + 1;\n        while (high - low > 1) {\n            int mid = (low + high) / 2;\n            if (lb_substr(pat, SA[mid])) low = mid;\n            else high = mid;\n        }\n        return high;\n    }\n\n    /// @param pat 文字列パターン\n    /// @details 1 ~ n 正常(0は空文字)\n    /// @details n + 1 .end()\n    /// @details SA[:high)が上限\n    int upper_bound(string &pat) {\n        int low = 0;\n        int high = n + 1;\n        pat.back()++;\n        while (high - low > 1) {\n            int mid = (low + high) / 2;\n            if (lb_substr(pat, SA[mid])) low = mid;\n            else high = mid;\n        }\n        pat.back()--;\n        return high;\n    }\n\n    vector<int> get_SA() const {\n        return SA;\n    }\n\n    string get_S() const {\n        return S;\n    }\n\n    void show_SA() {\n        printf(\"alphabetical order\\n\");\n        printf(\"i :\");\n        for (int i = 0; i <= n; i++)printf(\"%3d\", i);\n        printf(\"\\n\");\n        printf(\"SA:\");\n        for (int i = 0; i <= n; i++)printf(\"%3d\", SA[i]);\n        printf(\"\\n\");\n        printf(\"L :\");\n        for (int i = 0; i <= n; i++)printf(\"%3d\", n - SA[i]);\n        printf(\"\\n\\n\");\n    }\n\n};\n\nclass Longest_Common_Prefix_Array {\nprivate:\n    int n;\n    const Suffix_Array &suffixArray;\n\n    /// @param LCP[i] = SAでi,i+1番目に小さい文字列の最長共通接頭辞\n    vector<int> LCP;\n\n    /// @param rank[i] = S[i:]の文字列はSAで何番目に小さいか\n    vector<int> rank;\n\npublic:\n    Longest_Common_Prefix_Array(const Suffix_Array &suffixArray)\n            : suffixArray(suffixArray) {\n        n = suffixArray.get_S().size();\n        LCP = vector<int>(n + 1);\n        rank = vector<int>(n + 1);\n        construct();\n    }\n\n    void construct() {\n        const vector<int> &SA = suffixArray.get_SA();\n        const string S = suffixArray.get_S();\n        for (int i = 0; i <= n; i++) rank[SA[i]] = i;\n\n        //S[i:]と S[i:]より文字列順で1小さい文字列とのlcp長\n        int h = 0;\n\n        //0番目に小さい文字列は\"\"より、0\n        LCP[0] = 0;\n\n        // Sの先頭|S[i:]|=nから\n        for (int i = 0; i < n; i++) {\n\n            //S[i:]より1小さい文字列のS上の位置\n            int j = SA[rank[i] - 1];\n\n            if (h > 0) h--;\n\n            //後ろが一致してるだけ増やす\n            while (j + h < n && i + h < n) {\n                if (S[j + h] != S[i + h]) break;\n                h++;\n            }\n\n            LCP[rank[i] - 1] = h;\n        }\n    }\n\n    vector<int> get_LCP() {\n        return LCP;\n    }\n\n    int operator[](int k) const {\n        return LCP[k];\n    }\n\n    void show() {\n        printf(\"alphabetical order\\n\");\n        printf(\"i :\");\n        for (int i = 0; i <= n; i++)printf(\"%3d\", i);\n        printf(\"\\n\");\n        printf(\"LC:\");\n        for (int i = 0; i <= n; i++)printf(\"%3d\", LCP[i]);\n        printf(\"\\n\\n\");\n    }\n\n    void all_show() {\n        const vector<int> &SA = suffixArray.get_SA();\n        printf(\"alphabetical order\\n\");\n        printf(\"i :\");\n        for (int i = 0; i <= n; i++)printf(\"%3d\", i);\n        printf(\"\\n\");\n        printf(\"SA:\");\n        for (int i = 0; i <= n; i++)printf(\"%3d\", SA[i]);\n        printf(\"\\n\");\n        printf(\"LC:\");\n        for (int i = 0; i <= n; i++)printf(\"%3d\", LCP[i]);\n        printf(\"\\n\\n\");\n    }\n\n};\n\nint main() {\n\n//    int N;\n//    cin >> N;\n\n    string S;\n    cin >> S;\n\n    Suffix_Array suffixArray(S);\n//    Longest_Common_Prefix_Array longestCommonPrefixArray(suffixArray);\n//\n//    longestCommonPrefixArray.all_show();\n\n    int Q;\n    cin >> Q;\n\n    while (Q--) {\n        string p;\n        cin >> p;\n        if(suffixArray.contain(p)) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nnamespace SA{\n    const int MAX=1000000;\n    int N,K;\n    int tmp[MAX+1],rank[MAX+1];\n    bool compare_sa(int i,int j){\n        if(rank[i]!=rank[j])return rank[i]<rank[j];\n        else{\n            int ri=(i+K<=N)?rank[i+K]:-1;\n            int rj=(j+K<=N)?rank[j+K]:-1;\n            return ri<rj;\n        }\n    }\n\n    vector<int> construct_sa(string S){\n        N=S.size();\n        vector<int>sa(N+1);\n        for(int i=0;i<=N;i++)sa[i]=i;\n        for(int i=0;i<=N;i++){\n            rank[i]=i==N?-1:S[i];\n        }\n\n        for(K=1;K<=N;K*=2){\n            sort(sa.begin(),sa.end(),compare_sa);\n            tmp[sa[0]]=0;\n            for(int i=1;i<=N;i++){\n                tmp[sa[i]]=tmp[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n            }\n            for(int i=0;i<=N;i++)rank[i]=tmp[i];\n        }\n        return sa;\n    }\n}\n\n\nbool exist(string T){\n\n\n    /*\n    int lb=0,ub=S.size();\n    while(ub-lb>1){\n        int mid=(ub+lb)/2;\n        if(S.substr(sa[mid],min(S.size()-mid,T.size()))<T)lb=mid;\n        else ub=mid;\n    }\n    if(ub<=S.size()&&S.size()-sa[ub]>=T.size()&&S.substr(sa[ub],T.size())==T)return true;\n    return false;\n    */\n}\n\nbool contain(string &S,vint &sa,string &T){\n    int a=0,b=S.size();\n    while(b-a>1){\n        int c=(a+b)/2;\n        if(S.compare(sa[c],T.size(),T)<0)a=c;\n        else b=c;\n    }\n    return S.compare(sa[b],T.size(),T)==0;\n}\n\nsigned main(){\n    string S;\n    vint sa;\n    int Q;\n    cin>>S;\n    sa=SA::construct_sa(S);\n    cin>>Q;\n\n    while(Q--){\n        string T;cin>>T;\n        if(contain(S,sa,T))cout<<1<<endl;\n        else cout<<0<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint Q, doubles, lengths, dat[1000009], tmp[1000009], arrays[1000009]; string S, T;\nbool compare_suffix(int i, int j) {\n\tif (dat[i] == dat[j]) {\n\t\tint ri = (i + doubles <= lengths ? dat[i + doubles] : -1);\n\t\tint rj = (j + doubles <= lengths ? dat[j + doubles] : -1);\n\t\treturn ri < rj;\n\t}\n\treturn dat[i] < dat[j];\n}\nvoid suffix_array() {\n\tlengths = S.size();\n\tfor (int i = 0; i <= lengths; i++) arrays[i] = i, dat[i] = i < lengths ? S[i] : -1;\n\tfor (doubles = 1; doubles <= lengths; doubles <<= 1) {\n\t\tsort(arrays, arrays + lengths + 1, compare_suffix);\n\t\ttmp[arrays[0]] = 0;\n\t\tfor (int i = 1; i <= lengths; i++) tmp[arrays[i]] = tmp[arrays[i - 1]] + (compare_suffix(arrays[i - 1], arrays[i]) ? 1 : 0);\n\t\tfor (int i = 0; i <= lengths; i++) dat[i] = tmp[i];\n\t}\n}\nint main() {\n\tcin >> S >> Q;\n\tsuffix_array();\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> T;\n\t\tint l = 0, r = S.size() + 1, f = 0;\n\t\twhile (r - l > 1) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tstring S1 = S.substr(arrays[m], T.size());\n\t\t\tif (S1 == T) { f = 1; break; }\n\t\t\tif (S1 < T) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tprintf(\"%d\\n\", f);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 1000005\n\n//Suffix_Array\n//O(|T|log|S|) S??????????????????T????????????????????????????´¢\n#define rank A\nint n,Len;\nint rank[MAX_N+1];\nint tmp[MAX_N+1];\n\n//(rank[i],rank[i+k])??¨(rank[j],rank[j+k])?????????\nbool compare_sa(int i,int j){\n  if(rank[i]!=rank[j])return rank[i]<rank[j];\n  int ri=i+Len<=n?rank[i+Len]:-1;\n  int rj=j+Len<=n?rank[j+Len]:-1;\n  return ri<rj;\n}\n\n//?????????S?????\\?°??????????????§????\nvoid construct_sa(string S,int *sa){\n  n=S.length();\n  //?????????????????????????????????????????????????????????\n  for(int i=0;i<=n;i++){\n    sa[i]=i;\n    rank[i]=i<n?S[i]:-1;\n  }\n  //k????????????????????????????????????????????¨???????????????2k????????§?????????\n  for(Len=1;Len<=n;Len*=2){\n    sort(sa,sa+n+1,compare_sa);\n    //?????£??????tmp????¬?????????????????¨?????????????rank?????£??\\\n    tmp[sa[0]]=0;\n    for(int i=1;i<=n;i++)\n      tmp[sa[i]]=tmp[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n    for(int i=0;i<=n;i++)rank[i]=tmp[i];\n  }\n}\n\n//S??????????????????T????????????????????????????´¢??????\nbool contain(string S,int *sa,string T){\n  int left=0,right=S.length();\n  while(right-left>1){\n    int mid=(left+right)/2;\n    if(S.compare(sa[mid],T.length(),T)<0)left=mid;\n    else right=mid;\n  }\n  return S.compare(sa[right],T.length(),T)==0;\n}\n\n\nstring t,p;\nint q,sa[MAX_N];\nint main(){\n  cin>>t;\n  construct_sa(t,sa);\n  cin>>q;\n  while(q--){\n    cin>>p;\n    if(contain(t,sa,p))cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\nconst ull B= 100000007;\null thash[1001];\null BB[1001];\nstring T;\nint bl;\n\nbool contain(string a){\n\tint al=a.length();\n\tull t;\n\t//B???al???????¨????\n\t/*\n\tull t=1;\n\tfor(int i=0;i<al;i++) t*=B;\n\t*/\n\t//a??¨b????????????al???????????¢?????????????????\\???????¨????\n\tull ah=0,bh=0;\n\tfor(int i=0;i<al;i++) ah=ah*B+a[i];\n\t//for(int i=0;i<al;i++) bh=bh*B+b[i];\n\t\n\t//b?????´????????????????????????????????????????????\\???????????§??????\n\tbh=thash[al];\n\tt=BB[al];\n\tfor(int i=0;i+al<=bl;i++){\n\t\tif(ah==bh) return true;\n\t\tbh=bh*B+T[i+al]-T[i]*t;\n\t}\n\treturn false;\n}\n\nint main(){\n\tint k;\n\tbool ans;\n\tstring P;\n\t\n\tcin>>T;\n\tbl=T.length();\n\t\n\tthash[0]=0;\n\tfor(int i=1;i<=1000;i++) thash[i]=thash[i-1]*B+T[i-1];\n\tBB[0]=1;\n\tfor(int i=1;i<=1000;i++) BB[i]=BB[i-1]*B;\n\t\n\tscanf(\"%d\",&k);\n\tfor(int i=0;i<k;i++){\n\t\tcin>>P;\n\t\tif(T.size()>=P.size()){\n\t\t\tans=contain(P); //P???T?????????????????????????\n\t\t\tif(ans) printf(\"1\\n\");\n\t\t\telse printf(\"0\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <numeric>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint Q; string s; vector<unsigned long long> p, h;\nunsigned long long gethash(int l, int r) {\n\treturn h[r] - h[l] * p[r - l];\n}\nint lcp(int x, int y) {\n\tint l = 0, r = min(s.size() - x, s.size() - y) + 1;\n\twhile (r - l > 1) {\n\t\tint m = (l + r) >> 1;\n\t\tif (gethash(x, x + m) == gethash(y, y + m)) l = m;\n\t\telse r = m;\n\t}\n\treturn l;\n}\nbool compare_sa(int i, int j) {\n\tint k = lcp(i, j);\n\tif (i + k >= s.size()) return true;\n\tif (j + k >= s.size()) return false;\n\treturn s[i + k] <= s[j + k];\n}\nint main() {\n\tcin >> s >> Q;\n\tvector<int> l(Q + 2); l[1] = s.size();\n\tfor (int i = 0; i < Q; i++) {\n\t\tstring t;\n\t\tcin >> t; s += t;\n\t\tl[i + 2] = l[i + 1] + t.size();\n\t}\n\tp.resize(s.size() + 1); p[0] = 1;\n\th.resize(s.size() + 1);\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tp[i + 1] = p[i] * 257;\n\t\th[i + 1] = h[i] * 257 + s[i];\n\t}\n\tvector<int> sa(s.size());\n\tiota(sa.begin(), sa.end(), 0);\n\tsort(sa.begin(), sa.end(), compare_sa);\n\tvector<int> sa_inv(s.size());\n\tfor (int i = 0; i < s.size(); i++) sa_inv[sa[i]] = i;\n\tvector<int> v;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (sa[i] < l[1]) v.push_back(i);\n\t}\n\tfor (int i = 0; i < Q; i++) {\n\t\tint w = sa_inv[l[i + 1]];\n\t\tint ptr = lower_bound(v.begin(), v.end(), w) - v.begin();\n\t\tbool flag = false;\n\t\tfor (int j = -1; j <= 0; j++) {\n\t\t\tint pos = ptr + j;\n\t\t\tif (0 <= pos && pos < v.size()) {\n\t\t\t\tif (lcp(sa[v[pos]], l[i + 1]) >= l[i + 2] - l[i + 1]) flag = true;\n\t\t\t}\n\t\t}\n\t\tcout << flag << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<long long mod=1000000007,long long roll=82371827>\nclass suffix_array{\nprivate:\n    ll mod_pow(ll a,ll x){\n        if(a==0){return 0;}\n        ll ret=1;\n        while(x>0){\n            if(x&1){(ret*=a)%=mod;}\n            (a*=a)%=mod;\n            x>>=1;\n        }\n        return ret;\n    }\n    \n    typedef unsigned long ul;\n    \n    struct node{\n        ll begin;\n        ll Rank;\n        node* next;\n        \n        inline bool operator < (const node &N) const {\n            if(Rank==N.Rank){\n                return (next==NULL?-1:next->Rank)<(N.next==NULL?-1:N.next->Rank);\n            }\n            return Rank<N.Rank;\n        }\n        \n        node(ll begin=0,ll Rank=0,node* next=NULL):begin(begin),Rank(Rank),next(next){}\n    };\n    \n    static bool pointer_cmp(node* &a,node* &b){return (*a)<(*b);}\n    \n    vector<node*> sa;\n    vector<ll> Rank;\n    vector<ll> Hash;\n    const string s;\n    \n    void build(){\n        for(int i=0;i<s.size();i++){\n            *sa[i]={i,s[i],sa[i+1]};\n        }\n        sa[s.size()]->begin=s.size();\n        sa[s.size()]->Rank=-1;\n        sa[s.size()]->next=NULL;\n        vector<node*> Next(s.size()+1);\n        for(ll k=1;k<=s.size();k<<=1){\n            sort(sa.begin(),sa.end(),pointer_cmp);\n            Rank[sa[0]->begin]=0;\n            Next[0]=(sa[0]->next==NULL?NULL:sa[0]->next->next);\n            for(int i=1;i<=s.size();i++){\n                Rank[sa[i]->begin]=Rank[sa[i-1]->begin]+(*sa[i-1]<*sa[i]?1:0);\n                Next[i]=(sa[i]->next==NULL?NULL:sa[i]->next->next);\n            }\n            for(int i=0;i<=s.size();i++){\n                sa[i]->Rank=Rank[sa[i]->begin];\n                sa[i]->next=Next[i];\n            }\n        }\n        for(int i=0;i<=s.size();i++){\n            Next[sa[i]->begin]=sa[i];\n        }\n        for(int i=0;i<=s.size();i++){\n            sa[i]->next=sa[i]->begin==s.size()?NULL:Next[sa[i]->begin+1];\n        }\n    }\n    \n    //1::greater 0::same -1::less\n    int compare(const ul &saf,const vector<ll> &str){\n        /*\n        if(s[sa[saf]->begin]!=str[1]){return s[sa[saf]->begin]<str[1]?-1:1;}\n        ll l=1,r=min((ll)str.size()-1,(ll)s.size()-sa[saf]->begin)-1;\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            if(hash(sa[saf]->begin,sa[saf]->begin+m)==str[m+1]){l=m+1;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(hash(sa[saf]->begin,sa[saf]->begin+i)!=str[i+1]){return hash(sa[saf]->begin+i,sa[saf]->begin+i)<(str[i+1]+mod-str[i]*roll%mod)%mod?-1:1;}\n        }\n        return str.size()-1>s.size()-sa[saf]->begin?1:0;\n         */\n        ll where=diff(saf,str);\n        if(where-sa[saf]->begin==str.size()-1){return 0;}\n        if(where>=s.size()){return -1;}\n        return s[where]<(str[where]+mod-str[where]*roll%mod)%mod?-1:1;\n    }\n    \n    ul diff(const ul &saf,const vector<ll> &str){\n        if(s[sa[saf]->begin]!=str[1]){return 0;}\n        ll l=1,r=min((ll)str.size()-1,(ll)s.size()-sa[saf]->begin)-1;\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            if(hash(sa[saf]->begin,sa[saf]->begin+m)==str[m+1]){l=m+1;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(hash(sa[saf]->begin,sa[saf]->begin+i)!=str[i+1]){return i;}\n        }\n        return min((ll)str.size()-1,(ll)s.size()-sa[saf]->begin);\n    }\n    \n    bool is_in(const ul &saf,const vector<ll> &str){\n        return sa[saf]->begin+str.size()<=Hash.size() && str.back()==hash(sa[saf]->begin,sa[saf]->begin+str.size()-2);\n    }\n    \npublic:\n    suffix_array(const string &str):s(str),Rank(str.size()+1),sa(str.size()+1),Hash(str.size()+1,0){\n        for(int i=1;i<Hash.size();i++){\n            Hash[i]=Hash[i-1]*roll%mod+s[i-1];\n            Hash[i]%=mod;\n        }\n        for(int i=0;i<=s.size();i++){\n            sa[i]=(node*)malloc(sizeof(node));\n        }\n        build();\n    }\n    \n    ~suffix_array(){\n        for(int i=0;i<=s.size();i++){free(sa[i]);}\n    }\n    \n    ll rank(const ul &where) const {return Rank[where];}\n    \n    ul size() const {return sa.size();}\n    \n    const node & operator [] (const ul &where) const {return *sa[where];}\n    \n    ll hash(ll where){return Hash[where+1];}\n    \n    ll hash(ll l,ll r){return (Hash[r+1]+mod-Hash[l]*mod_pow(roll,r-l+1)%mod)%mod;}\n    \n    //返すのはsuffixの番号\n    ul lower_bound(const string &sub){\n        vector<ll> H(sub.size()+1,0);\n        for(int i=1;i<H.size();i++){\n            H[i]=H[i-1]*roll%mod+sub[i-1];\n            H[i]%=mod;\n        }\n        ll l=0;\n        ll r=s.size();\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            if(compare(m,H)==-1){l=m+1;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(compare(i,H)>=0){return i;}\n        }\n        return r+1;\n    }\n    \n    //返すのはsuffixの番号\n    ul upper_bound(const string &sub){\n        vector<ll> H(sub.size()+1,0);\n        for(int i=1;i<H.size();i++){\n            H[i]=H[i-1]*roll%mod+sub[i-1];\n            H[i]%=mod;\n        }\n        ll l=0;\n        ll r=s.size();\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            if(compare(m,H)<=0){l=m+1;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(compare(i,H)>0){return i;}\n        }\n        return r+1;\n    }\n    \n    bool match(const string &sub){\n        vector<ll> H(sub.size()+1,0);\n        for(int i=1;i<H.size();i++){\n            H[i]=H[i-1]*roll%mod+sub[i-1];\n            H[i]%=mod;\n        }\n        ll l=0;\n        ll r=s.size();\n        while(r-l>10){\n            ll m=l+(r-l)/2;\n            int st=compare(m,H);\n            if(st==0){return true;}\n            else if(st==-1){l=m+1;}\n            else{r=m-1;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(is_in(i,H)){return true;}\n        }\n        return false;\n    }\n};\n\n\nint main(){\n    string t;\n    cin>>t;\n    suffix_array<1000000007,82371827> S(t);\n    ll q;\n    cin>>q;\n    while(q--){\n        string p;\n        cin>>p;\n        cout<<S.match(p)<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <numeric>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint Q; string s; vector<int> sa; vector<unsigned long long> p, h;\nunsigned long long gethash(int l, int r) {\n\treturn h[r] - h[l] * p[r - l];\n}\nint lcp(int x, int y) {\n\tint l = 0, r = min(s.size() - x, s.size() - y) + 1;\n\twhile (r - l > 1) {\n\t\tint m = (l + r) >> 1;\n\t\tif (gethash(x, x + m) == gethash(y, y + m)) l = m;\n\t\telse r = m;\n\t}\n\treturn l;\n}\nbool compare_sa(int i, int j) {\n\tint k = lcp(i, j);\n\tif (i + k >= s.size()) return true;\n\tif (j + k >= s.size()) return false;\n\treturn s[i + k] <= s[j + k];\n}\nbool contain(string &t) {\n\tint a = 0, b = s.size() - 1;\n\twhile (b - a > 1) {\n\t\tint c = (a + b) / 2;\n\t\tif (s.compare(sa[c], t.size(), t) < 0) a = c;\n\t\telse b = c;\n\t}\n\treturn s.compare(sa[b], t.size(), t) == 0;\n}\nint main() {\n\tcin >> s >> Q;\n\tp.resize(s.size() + 1); p[0] = 1;\n\th.resize(s.size() + 1);\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tp[i + 1] = p[i] * 265;\n\t\th[i + 1] = h[i] * 265 + s[i];\n\t}\n\tsa.resize(s.size());\n\tiota(sa.begin(), sa.end(), 0);\n\tsort(sa.begin(), sa.end(), compare_sa);\n\tvector<int> sa_inv(s.size());\n\tfor (int i = 0; i < s.size(); i++) sa_inv[sa[i]] = i;\n\tvector<int> v;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (sa[i] < s.size()) v.push_back(i);\n\t}\n\tfor (int i = 0; i < Q; i++) {\n\t\tstring t; cin >> t;\n\t\tcout << contain(t) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=1000000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(string s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  bool operator()(int i, int j) { \n    int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  \n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  \n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  sort(ALL(sa),rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n// #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n//    int dx[8]={0,1,0,-1,1,1,-1,-1};\n  //  int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                        \n\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==0)return b;\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nll extgcd(ll a, ll b, ll &x, ll &y) {\n    if (b == 0ll) {\n        x = 1ll;\n        y = 0ll;\n        return a;\n    }\n    ll d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n} \n                                \n                int pr[220010];\n                int inv[220010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tinv[ert]=beki(pr[ert],mod-2,mod);\n                \t\n                \tfor(int i=ert-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    //mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\t   \n       \n                               //----------------kokomade tenpure------------\n\nint a[10020]={};\nstruct SAIS{\n\tprivate:\n\tpublic:\n/*\nSA  LCP\n10    0   $\n 9    1   a$\n 5    1   aabba$\n 0    2   ababbaabba$\n 6    4   abba$\n 2    0   abbaabba$\n 8    2   ba$\n 4    2   baabba$\n 1    1   babbaabba$\n 7    3   bba$\n 3    0** bbaabba$\n\t\n\tSAとrankを作るときは\n\tmake_suffix_array_string(string s);\n\t(rankはSAの逆写像)\n\t\n\t\n\tLCPもいるときは\n\tmake_suffix_array_string\n\tのあとで\n\tmake_lcp\n\t\n\t\n*/\n\tstring STR;\n\tvector<int> S;\n\tvector<int> SL;\n\t// L-type = 0\n\t// S-type = 1\n\t// LMS-type =2\n\tvector<pa> haba;\n\tvector<int> SA;\n\tvector<int> rank;\n\tvector<int> LCP;\n\tint mojisu;\n\tint len;\n\t\n\tvoid make_suffix_array_string(string str){\n\t\tSTR=str;\n\t\tset<char> setc;\n\t\tmap<char,int> mapc;\n\t\tfor(auto c:str)setc.insert(c);\n\t\tint cnt=1;\n\t\tfor(auto it=setc.begin();it!=setc.end();it++){\n\t\t\tmapc[*it]=cnt;\n\t\t\tcnt++;\n\t\t}\n\t\tfor(auto c:str)S.pb(mapc[c]);\n\t\tmojisu=cnt;\n\t\tS.pb(0);\n\t\tmake_suffix_array_naibu();\n\t}\n\t\n\tvoid make_suffix_array_saiki(vector<int> ve,int max_valu){\n\t\tS=ve;\n\t\tS.pb(0);\n\t\tmojisu=max_valu+1;\n\t\tmake_suffix_array_naibu();\n\t}\n\t\n\t\n\tvoid make_suffix_array_naibu(){\n\t\tint cnt=mojisu;\n\t\tlen=S.size();\n\t\t\n\t\tvector<int> kosuu(cnt,0);\n\t\tfor(auto c:S)kosuu[c]++;\n\t\t\n\t\thaba.pb({0,0});\n\t\tfor(int i=1;i<cnt;i++){\n\t\t\thaba.pb({haba.back().second+1,haba.back().second+kosuu[i]});\n\t\t}\n\t\t\n\t\t///////////////\n\t\t//S,L,LMSを判定\n\t\t// L-type   = 0\n\t\t// S-type   = 1\n\t\t// LMS-type <0: LMS-substrの長さ＊－１\n\t\t///////////////\n\n\t\tSL.resize(len);\n\t\tfor(int i=len-1;i>=0;i--){\n\t\t\tif(i==len-1){\n\t\t\t\tSL[i]=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(S[i]<S[i+1]) SL[i]=1;\n\t\t\t\telse if(S[i]>S[i+1])SL[i]=0;\n\t\t\t\telse{\n\t\t\t\t\tSL[i]=SL[i+1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint LMS_num=0;\n\t\tvector<int> LMS;\n\t\tvector<int> LMS_id(len,0);\n\t\tint rt=0;\n\t\tfor(int i=1;i<len;i++)if(SL[i-1]==0 &&SL[i]==1){\n\t\t\tLMS.pb(i);\n\t\t\tLMS_id[i]=rt;\n\t\t\tLMS_num++;\n\t\t\trt++;\n\t\t}\n\t\tfor(int i=0;i<LMS_num-1;i++){\n\t\t\tSL[LMS[i]]=-(LMS[i+1]-LMS[i]+1);\n\t\t}\n\t\tSL[len-1]=-1;\n\t\t/*\n\t\tfor(int i=0;i<len;i++)cout<<SL[i]<<\" \";\n\t\tcout<<endl;\n\t\t*/\n\t\tfor(int i=0;i<len;i++)SA.pb(-1);\n\t\tvector<int> pos(cnt,0);\n\t\tfor(int c=0;c<len;c++)if(SL[c]<0){\n\t\t\t\n\t\t\tSA[haba[S[c]].second-pos[S[c]]]=c;\n\t\t\tpos[S[c]]++;\n\t\t}\n\t\t///////////////\n\t\t// \n\t\t// \n\t\t// 最初のinduced sort\n\t\t// \n\t\t///////////////\n\t\t\n\t\t\n\t\tinduced_sort(SA,len,cnt);\n\t\t\n\t//\tcout<<\"d\"<<endl;\n\t\t///////////////\n\t\t// \n\t\t// \n\t\t// LMSの重複チェック\n\t\t// \n\t\t///////////////\n\t\t\n\t\tvector<pa> lms_sub_order;\n\t\tint mae_ind;\n\t\tfor(int i=0;i<len;i++)if(SL[SA[i]]<0){\n\t\t\tif(i==0){\n\t\t\t\tlms_sub_order.pb({SA[i],1});\n\t\t\t\t\n\t\t\t}\n\t\t\telse if(lms_sub_order.back().second==1){\n\t\t\t\tlms_sub_order.pb({SA[i],2});\n\t\t\t}\n\t\t\telse if(SL[SA[mae_ind]]!=SL[SA[i]]){\n\t\t\t\tlms_sub_order.pb({SA[i],lms_sub_order.back().second+1});\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint lmslen= -SL[SA[mae_ind]];\n\t\t\t\tbool bo=true;\n\t\t\t\tfor(int j=0;j<lmslen;j++){\n\t\t\t\t\tif(S[SA[mae_ind]+j]!=S[SA[i]+j]){\n\t\t\t\t\t\tbo=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(bo)lms_sub_order.pb({SA[i],lms_sub_order.back().second});\n\t\t\t\telse lms_sub_order.pb({SA[i],lms_sub_order.back().second+1});\n\t\t\t}\n\t\t\tmae_ind=i;\n\t\t}\n\t//\tfor(auto v:lms_sub_order)cout<<v.first<<\" \"<<v.second<<endl;\n\t//\tcout<<endl;\n\t\t\tfor(int i=0;i<cnt;i++)pos[i]=0;\n\t\t\tfor(int i=0;i<len;i++)SA[i]=-1;\n\t\t\n\t\tif(LMS_num==lms_sub_order.back().second){\n\t\t\tfor(int i=LMS_num-1;i>=0;i--){\n\t\t\t\tint c=lms_sub_order[i].first;\n\t\t\t\tSA[haba[S[c]].second-pos[S[c]]]=c;\n\t\t\t\tpos[S[c]]++;\n\t\t\t}\n\t\n\t\t}\n\t\telse{\n\t\t\tvector<int> rec((int)LMS.size());\n\t\t\tfor(int i=0;i<LMS_num;i++){\n\t\t\t\trec[LMS_id[lms_sub_order[i].first]]=lms_sub_order[i].second;\n\t\t\t}\n\t\t\tSAIS ss_naibu;\n\t\t\tss_naibu.make_suffix_array_saiki(rec,lms_sub_order.back().second);\n\t\t\t\n\t\t\tfor(int i=LMS_num;i>0;i--){\n\t\t\t\tint c=LMS[ss_naibu.SA[i]];\n\t\t\t\tSA[haba[S[c]].second-pos[S[c]]]=c;\n\t\t\t\tpos[S[c]]++;\n\t\t\t}\n\t\t}\n\n\t\t\tinduced_sort(SA,len,cnt);\n\t\trank.resize(len);\n\t\tfor(int i=0;i<len;i++)rank[SA[i]]=i;\n\t\t\treturn;\n\t}\n\t\n\tvoid induced_sort(vector<int> &ve, int len,int cnt){\n\t\tvector<int> ue(cnt,0);\n\t\tfor(int i=0;i<len;i++){\n\t\t\tif(ve[i]==-1) continue;\n\t\t\tif(ve[i]==0) continue;\n\t\t\tif(SL[ve[i]-1]==0){\n\t\t\t\tve[haba[S[ve[i]-1]].first+ue[S[ve[i]-1]]]=ve[i]-1;\n\t\t\t\tue[S[ve[i]-1]]++;\n\t\t\t}\n\t\t\tif(SL[ve[i]]<0 && i>0) ve[i]=-1;\n\t\t}\n\t\tfor(int i=0;i<cnt;i++)ue[i]=0;\n\t\t\n\t\tfor(int i=len-1;i>=0;i--){\n\t\t\tif(ve[i]==-1) continue;\n\t\t\tif(ve[i]==0) continue;\n\t\t\tif(SL[ve[i]-1]!=0){\n\t\t\t\tve[haba[S[ve[i]-1]].second-ue[S[ve[i]-1]]]=ve[i]-1;\n\t\t\t\tue[S[ve[i]-1]]++;\n\t\t\t}\n\t\t}\n\t\tfor(auto v:ve)if(v==-1)assert(0);\n\t}\n\t\n\tvoid make_lcp(){\n\t\tLCP.resize(len);\n\t\tint h=0;\n\t\tLCP[0]=0;\n\t\tfor(int i=0;i<len-1;i++){\n\t\t\tint j=SA[rank[i]-1];\n\t\t\tif(h>0)h--;\n\t\t\tfor(;j+h<len-1&& i+h<len-1;h++){\n\t\t\t\tif(S[j+h]!=S[i+h])break;\n\t\t\t}\n\t\t\tLCP[rank[i]-1]=h;\n\t\t}\n\t//\tfor(int i=0;i<len;i++)cout<<LCP[i]<<endl;\n\t\treturn;\n\t}\n\t\n\tint lower_bound(string p){// 文字列の場合のみ　pは非空\n\t\tint m=p.length();\n\t\tint ue=len,si=0,me;\n\t\twhile(ue-si>1){\n\t\t\tme=(ue+si)/2;\n\t\t\tif(STR.compare(SA[me],m,p)<0)si=me;\n\t\t\telse ue=me;\n\t\t}\n\t\treturn ue;\n\t}\n\t\n\tbool exist(string p){\n\t\tint l=p.length();\n\t\tint id=lower_bound(p);\n\t\treturn p==STR.substr(SA[id],l);\n\t}\n\tpa range(string p){// pを含む半壊区間 [l,r)  l==r なら存在なし\n\t\t\t\treturn {lower_bound(p),lower_bound(p+'{')};\n\t}\n};\nSAIS ss;\nmap<string,int> ma;\nint moto[100020];\nsigned main(){\n\n\t\t  cin.tie(0);\n\tios::sync_with_stdio(false);\n\t\nstring s;\n\tcin>>s;\n\tss.make_suffix_array_string(s);\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++)moto[i]=-1;\n\tfor(int i=0;i<n;i++){\n//\t\tif(i%1000==0) cout<<i<<endl;\n\t\tstring t;\n\t\tcin>>t;\n\t//\tpa z=ss.range(t);\n\t\tss.exist(t);\n\t\tcout<<ss.exist(t)<<endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\n\n#define fi(x) get<0>(x)\n#define se(x) get<1>(x)\n\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\ntypedef vector<pll> vpl;\n\nstring t;\nstring p;\nlli q;\n\nvll sa;\nvll tmp;\nvpl rnk;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> t;\n    sa = vll(t.size());rnk = vpl(t.size());tmp = vll(t.size());\n    for(lli i = 0;i < t.size();i++) sa[i] = i;\n    for(lli i = 0;i < t.size();i++) fi(rnk[i]) = t[i];\n    for(lli k = 1;k < t.size();k *= 2){\n        sort(sa.begin(),sa.end(),[](lli a,lli b){\n            return rnk[a] < rnk[b];\n        });\n        for(lli i = 1;i < sa.size();i++){\n            tmp[sa[i]] = tmp[sa[i-1]];\n            if(rnk[sa[i]] != rnk[sa[i-1]]) tmp[sa[i]]++;\n        }\n        for(lli i = 0;i < sa.size();i++){\n            fi(rnk[sa[i]]) = tmp[sa[i]];\n        }\n        for(lli i = 0;i < sa.size();i++){\n            if(sa[i]+k < t.size()) se(rnk[sa[i]]) = fi(rnk[sa[i]+k]);\n            else se(rnk[sa[i]]) = -1;\n        }\n    }\n    sort(sa.begin(),sa.end(),[](lli a,lli b){\n        return rnk[a] < rnk[b];\n    });\n    cin >> q;\n    for(lli i = 0;i < q;i++){\n        cin >> p;\n        lli lwrbnd = *lower_bound(sa.begin(),sa.end(),p,[](lli a,string s){\n            //if(t.size() < a + s.size()) return true;\n            return t.compare(a,min((lli)s.size(),(lli)(t.size()-a)),s) < 0;\n        });\n        if(t.size() >= lwrbnd+p.size() && t.compare(lwrbnd,p.size(),p) == 0) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct suffix_array{\n    int n;\n    vector <int> x;\n    suffix_array(const char *s) : n(strlen(s)),x(n){\n        vector<int> r(n),t(n);\n        for (int i = 0; i < n; ++i) r[x[i] = i] = s[i];\n        for (int h = 1; t[n-1] != n-1 ; h *= 2) {\n            auto cmp = [&](int i,int j){\n                if(r[i] != r[j]) return r[i] < r[j];\n                return i + h < n && j + h < n ? r[i+h] < r[j+h] : i >j;\n            };\n            sort(x.begin(),x.end(),cmp);\n            for (int i = 0; i + 1 < n ; ++i)  t[i + 1] = t[i] + cmp(x[i],x[i+1]);\n            for (int i = 0; i < n; ++i)  r[x[i]] = t[i];\n        }\n    }\n    int operator[] (int i) const {return x[i];}\n};\n\nbool contain(const string &S, int *sa, const string &T) {\n    int lb = -1, ub = S.size() - 1;\n    while(ub -lb > 1){\n        int mid = (lb + ub )/ 2;\n        if(S.compare(sa[mid], T.size(), T) >= 0) ub = mid;\n        else lb = mid;\n    }\n    return S.compare(sa[ub], T.size(), T) == 0;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    string T; cin >> T;\n    int Q; cin >> Q;\n    suffix_array sary(T.c_str());\n    while(Q--){\n        string P; cin >> P;\n        cout << (contain(T,sary.x.data(),P) ? 1 : 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n-nb,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k>=nc)a[i]=b[j++];\n      else if(j>=nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    build_sa();\n    //build_lcp();\n    //build_rmq();\n  }\n  void build_sa(){\n    S.push_back('$');\n    vector<int> c(n+1,0),ord(n+1,0);\n    for(int i=0;i<=n;i++) ord[i]=n-i;\n    sort(ord.begin(),ord.end(),[&](int a,int b){return S[a]<S[b];});\n    for(int i=0;i<=n;i++){\n      sa[i]=ord[i];\n      c[i]=S[i];\n    }\n    for(int len=1;len<=n;len*=2){\n      vector<int> r=c;\n      for(int i=0;i<=n;i++){\n\t c[sa[i]] =\n\t   i > 0 &&\n\t   r[sa[i - 1]] == r[sa[i]] &&\n\t   sa[i - 1] + len <= n &&\n\t   r[sa[i - 1] + len / 2] == r[sa[i] + len / 2]\n\t   ? c[sa[i - 1]] : i;\n      }\n      vector<int> cnt(n+1);\n      for(int i=0;i<=n;i++) cnt[i]=i;\n      vector<int> s=sa;\n      for(int i=0;i<=n;i++){\n\tint s1=s[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n);\n    for(int i=0;i<n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    //assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\n\nstruct PMA{\n    PMA *next[256];\n    Vec matched;\n    PMA(){ fill(next,next+256,(PMA*)0); }\n};\n\nVec set_union(const Vec &a,const Vec &b){\n    int i = 0, j = 0, A = a.size(), B = b.size();\n    Vec res;\n    while(i < A && j < B){\n        if(a[i] == b[j]){\n            res.push_back(a[i]);\n            i++; j++;\n        }else if(a[i] > b[j]){\n            res.push_back(b[j++]);\n        }else{\n            res.push_back(a[i++]);\n        }\n    }\n    for( ; i < A ; i++) res.push_back(a[i]);\n    for( ; j < B ; j++) res.push_back(b[j]);\n    return res;\n}\n\nPMA *buildPMA(char *pattern[],int size){\n    PMA *root = new PMA;\n    for(int i = 0 ; i < size ; i++){\n        PMA *t = root;\n        for(int j = 0 ; pattern[i][j] != '\\0' ; j++){\n            char c = pattern[i][j];\n            if(t->next[c] == NULL) t->next[c] = new PMA;\n            t = t->next[c];\n        }\n        t->matched.push_back(i);\n    }\n    queue<PMA*> Q;\n    for(int i = 1 ; i < 256 ; i++){\n        if(root->next[i]){\n            root->next[i]->next[0] = root;\n            Q.push(root->next[i]);\n        }else{\n            root->next[i] = root;\n        }\n    }\n    while(!Q.empty()){\n        PMA *t = Q.front(); Q.pop();\n        for(int i = 1 ; i < 256 ; i++){\n            if(t->next[i]){\n                PMA *next = t->next[0];\n                while(!next->next[i]) next = next->next[0];\n                t->next[i]->next[0] = next->next[i];\n                t->next[i]->matched =\n                    set_union(t->next[i]->matched,next->next[i]->matched);\n                Q.push(t->next[i]);\n            }\n        }\n    }\n    return root;\n}\n\nvoid match(PMA *pma,const char *s,Vec &res){\n    for(int i = 0 ; s[i] != '\\0' ; i++){\n        int c = s[i];\n        while(!pma->next[c]) pma = pma->next[0];\n        pma = pma->next[c];\n        for(int j = 0 ; j < (int)pma->matched.size() ; j++){\n            res[pma->matched[j]] = 1;\n        }\n    }\n}\n\nchar T[1000001];\nchar *P[10000];\n\nint main(){\n    int Q;\n    scanf(\"%s%d\",T,&Q);\n    for(int i = 0 ; i < Q ; i++){\n        P[i] = new char;\n        scanf(\"%s\",P[i]);\n    }\n    PMA *pma = buildPMA(P,Q);\n    Vec res(Q, 0);\n    match(pma,T,res);\n    for(auto x : res){\n        printf(\"%d\\n\",x);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nclass Aho_Corasick {\n\tstruct node {\n\t\tnode *no;\n\t\tvector<node*> next;\n\t\tvector<int> matched;\n\t\tnode() : no(nullptr), next(128, nullptr) {}\n\t\t~node() { for (auto ite : next) if (ite != nullptr) delete ite; }\n\t};\n\tvector<int> unite(const vector<int>& a, const vector<int>& b) {\n\t\tvector<int> res;\n\t\tset_union(a.begin(), a.end(), b.begin(), b.end(), back_inserter(res));\n\t\treturn res;\n\t}\n\tint K;\n\tnode *root;\npublic:\n\tAho_Corasick(const vector<string>& Ts) : K(Ts.size()), root(new node) {\n\t\tnode *now;\n\t\troot->no = root;\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tauto &T = Ts[i];\n\t\t\tnow = root;\n\t\t\tfor (auto c : T) {\n\t\t\t\tif (now->next[c] == nullptr) {\n\t\t\t\t\tnow->next[c] = new node;\n\t\t\t\t}\n\t\t\t\tnow = now->next[c];\n\t\t\t}\n\t\t\tnow->matched.push_back(i);\n\t\t}\n\t\tqueue<node*> q;\n\t\tfor (int i = 0; i < 128; i++) {\n\t\t\tif (root->next[i] == nullptr) {\n\t\t\t\troot->next[i] = root;\n\t\t\t}\n\t\t\telse {\n\t\t\t\troot->next[i]->no = root;\n\t\t\t\tq.push(root->next[i]);\n\t\t\t}\n\t\t}\n\t\twhile (!q.empty()) {\n\t\t\tnow = q.front(); q.pop();\n\t\t\tfor (int i = 0; i < 128; i++) {\n\t\t\t\tif (now->next[i] != nullptr) {\n\t\t\t\t\tnode *nx = now->no;\n\t\t\t\t\twhile (nx->next[i] == nullptr) {\n\t\t\t\t\t\tnx = nx->no;\n\t\t\t\t\t}\n\t\t\t\t\tnow->next[i]->no = nx->next[i];\n\t\t\t\t\tnow->next[i]->matched = unite(now->next[i]->matched, nx->next[i]->matched);\n\t\t\t\t\tq.push(now->next[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> count(const string& S) {\n\t\tvector<int> res(K);\n\t\tnode *now = root;\n\t\tfor (auto c : S) {\n\t\t\twhile (now->next[c] == nullptr) {\n\t\t\t\tnow = now->no;\n\t\t\t}\n\t\t\tnow = now->next[c];\n\t\t\tfor (auto k : now->matched) {\n\t\t\t\tres[k]++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tstring S;\n\tint M;\n\tcin >> S >> M;\n\tvector<string> C(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> C[i];\n\t}\n\tAho_Corasick aho(C);\n\tauto cnt = aho.count(S);\n\tfor (auto t : cnt) {\n\t\tcout << (t != 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct SA{\n  int n,k;\n  string S;\n  vector<int> r,r2,t,sa,lcp;\n  SA(){}\n  SA(string S):S(S){init();}\n  void init(){\n    n=S.size();\n    r.resize(n+1,0);\n    r2.resize(n+1,0);\n    t.resize(n+1,0);\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    constract_sa();\n  }\n  bool compare_sa(int i,int j){\n    if(r[i]!=r[j]) return r[i]<r[j];\n    else{\n      int ri=i+k<=n?r[i+k]:-1;\n      int rj=j+k<=n?r[j+k]:-1;\n      return ri<rj;\n    }\n  }\n  void constract_sa(){\n    n=S.length();\n    for(int i=0;i<=n;i++){\n      sa[i]=i;\n      r[i]=i<n?S[i]:-1;\n    }\n    for(k=1;k<=n;k*=2){\n      sort(sa.begin(),sa.end(),[&](const int &i, const int &j){\n\t  if(r[i]!=r[j]) return r[i]<r[j];\n\t  else{\n\t    int ri=i+k<=n?r[i+k]:-1;\n\t    int rj=j+k<=n?r[j+k]:-1;\n\t    return ri<rj;\n\t  }\n\t});\n      t[sa[0]]=0;\n      for(int i=1;i<=n;i++){\n\tt[sa[i]]=t[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n      }\n      for(int i=0;i<=n;i++){\n\tr[i]=t[i];\n      }\n    }\n  }\n  bool contains(string T){\n    int a=0,b=S.length()+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==(int)S.length()+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  void constract_lcp(){\n    for(int i=0;i<=n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n \n \n  int count(string T,RMQ &rmq){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(b[i]-a[i]>1){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SA sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)(sa.count(P)!=0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n// ------ Function ------ //\ninline unsigned int __builtin_clz(unsigned int x) { unsigned long r; _BitScanReverse(&r, x); return 31 - r; }\n// ------ Sparse Table ------ //\nclass SparseTable {\n\tvector<vector<int> >st;\npublic:\n\tvoid init(vector<int>vec) {\n\t\tint b;\n\t\tfor (b = 0; (1 << b)<vec.size(); b++);\n\t\tst.assign(b, vector<int>(1 << b));\n\t\tfor (int i = 0; i<vec.size(); i++)st[0][i] = vec[i];\n\n\t\tfor (int i = 1; i<b; i++) {\n\t\t\tfor (int j = 0; j + (1 << i) <= (1 << b); j++) {\n\t\t\t\tst[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n\t\t\t}\n\t\t}\n\t}\n\tint GetMin(int l, int r) {\n\t\tint b = 32 - __builtin_clz(r - l) - 1;\n\t\treturn min(st[b][l], st[b][r - (1 << b)]);\n\t}\n\tSparseTable() {}\n\tSparseTable(vector<int>vec) { init(vec); }\n};\n\n// ------ Suffix Array ------ //\nclass SuffixArray {\n\tvoid CreateBeginBucket(vector<int>&v, vector<int>&bucket) {\n\t\tfill(bucket.begin(), bucket.end(), 0);\n\t\tfor (int i = 0; i<v.size(); i++)bucket[v[i]]++;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i<bucket.size(); i++) { bucket[i] += sum; swap(sum, bucket[i]); }\n\t}\n\tvoid CreateEndBucket(vector<int>&v, vector<int>&bucket) {\n\t\tfill(bucket.begin(), bucket.end(), 0);\n\t\tfor (int i = 0; i<v.size(); i++)bucket[v[i]]++;\n\t\tfor (int i = 1; i<bucket.size(); i++)bucket[i] += bucket[i - 1];\n\t}\n\tvoid InducedSort(vector<int>&v, vector<int>&SA, int mv, vector<int>&bucket, vector<int>&isL) {\n\t\tCreateBeginBucket(v, bucket);\n\t\tfor (int i = 0; i<v.size(); i++)if (SA[i]>0 && isL[SA[i] - 1])SA[bucket[v[SA[i] - 1]]++] = SA[i] - 1;\n\t}\n\tvoid InvertInducedSort(vector<int>&v, vector<int>&SA, int mv, vector<int>&bucket, vector<int>&isL) {\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = v.size() - 1; i >= 0; i--)if (SA[i]>0 && !isL[SA[i] - 1])SA[--bucket[v[SA[i] - 1]]] = SA[i] - 1;\n\t}\n\tvector<int>SA_IS(vector<int>v, int mv) {\n\t\tif (v.size() == 1)return vector<int>(1, 0);\n\t\tvector<int>isL(v.size());\n\t\tvector<int>bucket(mv + 1);\n\t\tvector<int>SA(v.size(), -1);\n\t\tauto isLMS = [&](int x)->bool {return x>0 && isL[x - 1] && !isL[x]; };\n\t\tisL[v.size() - 1] = 0;\n\t\tfor (int i = v.size() - 2; i >= 0; i--)isL[i] = v[i]>v[i + 1] || (v[i] == v[i + 1] && isL[i + 1]);\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))SA[--bucket[v[i]]] = i;\n\t\tInducedSort(v, SA, mv, bucket, isL);\n\t\tInvertInducedSort(v, SA, mv, bucket, isL);\n\t\tint cur = 0;\n\t\tvector<int>ord(v.size());\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))ord[i] = cur++;\n\t\tvector<int>nxv(cur);\n\t\tcur = -1;\n\t\tint prev = -1;\n\t\tfor (int i = 0; i<v.size(); i++) {\n\t\t\tif (!isLMS(SA[i]))continue;\n\t\t\tbool diff = false;\n\t\t\tfor (int d = 0; d<v.size(); d++) {\n\t\t\t\tif (prev == -1 || v[SA[i] + d] != v[prev + d] || isL[SA[i] + d] != isL[prev + d]) {\n\t\t\t\t\tdiff = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (d>0 && isLMS(SA[i] + d))break;\n\t\t\t}\n\t\t\tif (diff) { cur++; prev = SA[i]; }\n\t\t\tnxv[ord[SA[i]]] = cur;\n\t\t}\n\t\tvector<int>reord(nxv.size());\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))reord[ord[i]] = i;\n\t\tvector<int>nxSA = SA_IS(nxv, cur);\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = 0; i<SA.size(); i++)SA[i] = -1;\n\t\tfor (int i = nxSA.size() - 1; i >= 0; i--)SA[--bucket[v[reord[nxSA[i]]]]] = reord[nxSA[i]];\n\t\tInducedSort(v, SA, mv, bucket, isL);\n\t\tInvertInducedSort(v, SA, mv, bucket, isL);\n\t\treturn SA;\n\t}\n\tvector<int>SA_IS(string s) {\n\t\tvector<int>v(s.size() + 1);\n\t\tfor (int i = 0; i<s.size(); i++)v[i] = s[i] + 1;\n\t\treturn SA_IS(v, *max_element(v.begin(), v.end()));\n\t}\n\tvector<int>construct_lcp(string &s, vector<int>&sa) {\n\t\tvector<int>lcp, rank(s.size() + 1);\n\t\tint n = s.size();\n\t\tfor (int i = 0; i <= n; i++)rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tlcp[0] = 0;\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h>0)h--;\n\t\t\tfor (; j + h<n&&i + h<n; h++) {\n\t\t\t\tif (s[j + h] != s[i + h])break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n\tSparseTable st;\npublic:\n\tstring s;\n\tvector<int>sa, lcp;\n\tvoid init(string &T) {\n\t\ts = T;\n\t\tsa = SA_IS(s);\n\t}\n\tSuffixArray(string &t) { init(t); }\n\tSuffixArray() {}\n\tbool contain(string &t) {\n\t\tint a = 0, b = s.size();\n\t\twhile (b - a>1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (s.compare(sa[c], t.size(), t)<0)a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn s.compare(sa[b], t.size(), t) == 0;\n\t}\n};\nint q; string s, t;\nint main() {\n\tcin >> s >> q;\n\tSuffixArray v(s);\n\tfor(int i = 0; i < q; i++) {\n\t\tcin >> t;\n\t\tcout << (v.contain(t) ? 1 : 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define each(it,c) for(__typeof(c.begin()) it=c.begin(); it!=c.end(); it++)\n#define INF 1<<30\n#define mp make_pair\n#define pb push_back\n\ntypedef vector<int> vi;\n\ntypedef long long ll;\n\nbool has(map <char, int> m,char c){\n\tif (m.find(c) == m.end()) return false;\n\telse return true;\n}\n\nint bm(string t,string p){\n\tint i,j;\n\tint n = t.size();\n\tint m = p.size();\n\tmap <char,int> skip;\n\trep(k,m){\n\t\tskip[p[k]] = m-k-1;\n\t}\n\n\tfor(i=m-1,j=m-1;j>0;i--,j--){\n\t\twhile(t[i]!=p[j]){\n\t\t\tint x = (has(skip,t[i])) ? skip[t[i]] : m;\n\t\t\ti += ( (m-j > x) ? m-j : x );\n\t\t\tif(i>=n) return -1;\n\t\t\tj = m-1;\n\t\t}\n\t}\n\treturn i;\n}\n\nint main(){\n\tstring t;\n\tcin>>t;\n\tint n; cin>>n;\n\trep(i,n){\n\t\tstring p;\n\t\tcin>>p;\n\t\tint ans = bm(t,p);\n\t\tif(ans!=-1) cout<<1<<endl;\n\t\telse cout<<0<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int inf = 1e7;\n\nint n;\nstring t;\nint q;\nstring p[10000];\nint sa[20][1000000];\nint isa[1000000];\nint lcp[2 << 20];\n\nint stu(int i, int x, int k, int l, int r){\n\tif(r <= i || i < l){\n\t\treturn lcp[k];\n\t}\n\tif(i <= l && r <= i + 1){\n\t\treturn lcp[k] = x;\n\t}\n\tint m = (l + r) / 2;\n\treturn lcp[k] = min(\n\t\tstu(i, x, 2 * k + 1, l, m),\n\t\tstu(i, x, 2 * k + 2, m, r)\n\t);\n}\nvoid stu(int i, int x){\n\tstu(i, x, 0, 0, n - 1);\n}\n\nint rmq(int a, int b, int k, int l, int r){\n\tif(r <= a || b <= l){\n\t\treturn inf;\n\t}\n\tif(a <= l && r <= b){\n\t\treturn lcp[k];\n\t}\n\tint m = (l + r) / 2;\n\treturn min(\n\t\trmq(a, b, 2 * k + 1, l, m),\n\t\trmq(a, b, 2 * k + 2, m ,r)\n\t);\n}\nint rmq(int a, int b){\n\treturn rmq(a, b, 0, 0, n - 1);\n}\n\nvoid pp(){\n\tstring v = t;\n\tsort(v.begin(), v.end());\n\trep(i, n){\n\t\tsa[0][i] = lower_bound(v.begin(), v.end(), t[i]) - v.begin();\n\t}\n\tfor(int i = 1; i <= 19; ++i){\n\t\tint k = 1 << i - 1;\n\t\tvector<P> s;\n\t\trep(j, n){\n\t\t\ts.push_back(P(sa[i - 1][j], j + k < n ? sa[i - 1][j + k] : -1));\n\t\t}\n\t\tvector<P> v = s;\n\t\tsort(v.begin(), v.end());\n\t\trep(j, n){\n\t\t\tsa[i][j] = lower_bound(v.begin(), v.end(), s[j]) - v.begin();\n\t\t}\n\t}\n\n\trep(i, n){\n\t\tisa[sa[19][i]] = i;\n\t}\n\n\tint l = 0;\n\trep(i, n){\n\t\tint r = sa[19][i];\n\t\tif(r == n - 1){\n\t\t\tl = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tint j = isa[r + 1];\n\t\twhile(i + l < n && j + l < n && t[i + l] == t[j + l]){\n\t\t\t++l;\n\t\t}\n\t\tstu(r, l);\n\t\tl = max(l - 1, 0);\n\t}\n}\n\nbool srch(const string& p){\n\tint m = p.size();\n\n\tint h = 0;\n\twhile(isa[0] + h < n && h < m && t[isa[0] + h] == p[h]){\n\t\t++h;\n\t}\n\n\tint l = 0;\n\tint r = n;\n\tbool b = true;\n\twhile(r - l > 1){\n\t\tint k = (l + r) / 2;\n\t\tif(b){\n\t\t\tint c = rmq(l, k);\n\t\t\tif(c > h){\n\t\t\t\tl = k;\n\t\t\t}\n\t\t\telse if(c < h){\n\t\t\t\tr = k;\n\t\t\t\th = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(isa[k] + h < n && h < m && t[isa[k] + h] == p[h]){\n\t\t\t\t\t++h;\n\t\t\t\t}\n\t\t\t\tif(isa[k] + h == n){\n\t\t\t\t\tl = k;\n\t\t\t\t}\n\t\t\t\telse if(h == m){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(t[isa[k] + h] < p[h]){\n\t\t\t\t\t\tl = k;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tr = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint c = rmq(k, r);\n\t\t\tif(c > h){\n\t\t\t\tr = k;\n\t\t\t}\n\t\t\telse if(c < h){\n\t\t\t\tl = k;\n\t\t\t\th = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(isa[k] + h < n && h < m && t[isa[k] + h] == p[h]){\n\t\t\t\t\t++h;\n\t\t\t\t}\n\t\t\t\tif(isa[k] + h == n){\n\t\t\t\t\tl = k;\n\t\t\t\t}\n\t\t\t\telse if(h == m){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(t[isa[k] + h] < p[h]){\n\t\t\t\t\t\tl = k;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tr = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tb = l == k;\n\t}\n\treturn h == m;\n}\n\nint main(){\n\tcin >> t >> q;\n\tn = t.size();\n\trep(i, q){\n\t\tcin >> p[i];\n\t}\n\n\tpp();\n\n\trep(i, q){\n\t\tcout << srch(p[i]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    //const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    //const int k=lcp2(i,j,0,(n-max(i,j))*2+1);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  inline bool cmp(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    //int l=0,r=min(n-i,n-j)+1;\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n  \n  /*\n  inline int lcp2(const int& i, const int& j, const int& l, const int& r){\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n  */\n};\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  const int n = SZ(a);\n  if(n>1){\n    vector<int> b(a.begin(), a.begin()+n/2);\n    vector<int> c(a.begin()+n/2, a.end());\n    mergesort(b,rh);\n    mergesort(c,rh);\n    for (int i=0,j=0,k=0;i<n;i++){\n      if(k == SZ(c))a[i]=b[j++];\n      else if(j==SZ(b))a[i]=c[k++];\n      else if(rh.cmp(b[j],c[k]))a[i]=b[j++];\n      else a[i] = c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  //sort(ALL(sa),rh);\n  mergesort(sa,rh);\n  //if(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    int c=(a+b)/2;\n    if(S.compare(sa[c],T.length(),T)<0 )a=c;\n    else b=c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  while(n--){\n    cin >> t;\n    cout << contain(s,sa,t) << \"\\n\";\n    //cout << !!rh.find(t) << \"\\n\";\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> P;\n\nconst int inf = 1e7;\n\nint n;\nstring t;\nint q;\nstring p[10000];\nint sa[11][1000000];\nint isa[1000000];\nint lcp[1 << 21];\n\nint stu(int i, int x, int k, int l, int r){\n\tif(r <= i || i < l){\n\t\treturn lcp[k];\n\t}\n\tif(i <= l && r <= i + 1){\n\t\treturn lcp[k] = x;\n\t}\n\tint m = (l + r) / 2;\n\treturn lcp[k] = min(\n\t\tstu(i, x, 2 * k + 1, l, m),\n\t\tstu(i, x, 2 * k + 2, m, r)\n\t);\n}\nvoid stu(int i, int x){\n\tstu(i, x, 0, 0, n - 1);\n}\n\nint rmq(int a, int b, int k, int l, int r){\n\tif(r <= a || b <= l){\n\t\treturn inf;\n\t}\n\tif(a <= l && r <= b){\n\t\treturn lcp[k];\n\t}\n\tint m = (l + r) / 2;\n\treturn min(\n\t\trmq(a, b, 2 * k + 1, l, m),\n\t\trmq(a, b, 2 * k + 2, m ,r)\n\t);\n}\nint rmq(int a, int b){\n\treturn rmq(a, b, 0, 0, n - 1);\n}\n\nvoid pp(){\n\tstring v = t;\n\tsort(v.begin(), v.end());\n\trep(i, n){\n\t\tsa[0][i] = lower_bound(v.begin(), v.end(), t[i]) - v.begin();\n\t}\n\tfor(int i = 1; i <= 10; ++i){\n\t\tint k = 1 << i - 1;\n\t\tvector<P> s(n);\n\t\trep(j, n){\n\t\t\ts[j] = P(ll(sa[i - 1][j]) << 20 | (j + k < n ? sa[i - 1][j + k] + 1 : 0), j);\n\t\t}\n\t\tsort(s.begin(), s.end());\n\t\trep(j, n){\n\t\t\tsa[i][s[j].second] = j == 0 || s[j - 1].first < s[j].first ? j : sa[i][s[j - 1].second];\n\t\t}\n\t}\n\n\trep(i, n){\n\t\tisa[sa[10][i]] = i;\n\t}\n\n\tint l = 0;\n\trep(i, n){\n\t\tint r = sa[10][i];\n\t\tif(r == n - 1){\n\t\t\tl = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tint j = isa[r + 1];\n\t\twhile(l < 1 << 10 && i + l < n && j + l < n && t[i + l] == t[j + l]){\n\t\t\t++l;\n\t\t}\n\t\tstu(r, l);\n\t\tl = max(l - 1, 0);\n\t}\n}\n\nbool srch(const string& p){\n\tint m = p.size();\n\n\tint h = 0;\n\twhile(isa[0] + h < n && h < m && t[isa[0] + h] == p[h]){\n\t\t++h;\n\t}\n\n\tint l = 0;\n\tint r = n;\n\tbool b = true;\n\twhile(r - l > 1){\n\t\tint k = (l + r) / 2;\n\t\tif(b){\n\t\t\tint c = rmq(l, k);\n\t\t\tif(c > h){\n\t\t\t\tl = k;\n\t\t\t}\n\t\t\telse if(c < h){\n\t\t\t\tr = k;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(isa[k] + h < n && h < m && t[isa[k] + h] == p[h]){\n\t\t\t\t\t++h;\n\t\t\t\t}\n\t\t\t\tif(isa[k] + h == n){\n\t\t\t\t\tl = k;\n\t\t\t\t}\n\t\t\t\telse if(h == m){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(t[isa[k] + h] < p[h]){\n\t\t\t\t\t\tl = k;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tr = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint c = rmq(k, r);\n\t\t\tif(c > h){\n\t\t\t\tr = k;\n\t\t\t}\n\t\t\telse if(c < h){\n\t\t\t\tl = k;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(isa[k] + h < n && h < m && t[isa[k] + h] == p[h]){\n\t\t\t\t\t++h;\n\t\t\t\t}\n\t\t\t\tif(isa[k] + h == n){\n\t\t\t\t\tl = k;\n\t\t\t\t}\n\t\t\t\telse if(h == m){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(t[isa[k] + h] < p[h]){\n\t\t\t\t\t\tl = k;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tr = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tb = l == k;\n\t}\n\treturn isa[l] + m <= n && string(t, isa[l], m) == p;\n}\n\nint main(){\n\tcin >> t >> q;\n\tn = t.size();\n\trep(i, q){\n\t\tcin >> p[i];\n\t}\n\n\tpp();\n\n\trep(i, q){\n\t\tcout << srch(p[i]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\n\n#define fi(x) get<0>(x)\n#define se(x) get<1>(x)\n\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\ntypedef vector<pll> vpl;\n\nstring t;\nstring p;\nlli q;\n\nvll sa;\nvll tmp;\nvpl rnk;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> t;\n    sa = vll(t.size());rnk = vpl(t.size());tmp = vll(t.size());\n    for(lli i = 0;i < t.size();i++) sa[i] = i;\n    for(lli i = 0;i < t.size();i++) fi(rnk[i]) = t[i];\n    for(lli k = 1;k < 2*t.size();k *= 2){\n        sort(sa.begin(),sa.end(),[](lli a,lli b){\n            return rnk[a] < rnk[b];\n        });\n        for(lli i = 1;i < sa.size();i++){\n            tmp[sa[i]] = tmp[sa[i-1]];\n            if(rnk[sa[i]] != rnk[sa[i-1]]) tmp[sa[i]]++;\n        }\n        for(lli i = 0;i < sa.size();i++){\n            fi(rnk[sa[i]]) = tmp[sa[i]];\n        }\n        for(lli i = 0;i < sa.size();i++){\n            if(sa[i]+k < t.size()) se(rnk[sa[i]]) = fi(rnk[sa[i]+k]);\n            else se(rnk[sa[i]]) = -1;\n        }\n    }\n    cin >> q;\n    for(lli i = 0;i < q;i++){\n        cin >> p;\n        lli lwrbnd = *lower_bound(sa.begin(),sa.end(),p,[](lli a,string s){\n            //if(t.size() < a + s.size()) return true;\n            return t.compare(a,min((lli)s.size(),(lli)(t.size()-a)),s) < 0;\n        });\n        if(t.size() >= lwrbnd+p.size() && t.compare(lwrbnd,p.size(),p) == 0) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int B=999999937;\nconst int P=1000000007;\n\nvoid gen_hash(const string &s,vector<long long> &hash){\n\tlong long c=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tc=(c*B+s[i])%P;\n\t\thash[i]=c;\n\t}\n}\nlong long pow_binary_mod(long long x,long long y,long long mod){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%mod;\n\t\tx=x*x%mod;\n\t}\n\treturn z;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s;\n\tcin>>s;\n\tint ls=s.size();\n\tvector<long long> v(ls),hsh(10001);\n\tgen_hash(s,v);\n\n\tint T;\n\tfor(cin>>T;T--;){\n\t\tstring q;\n\t\tcin>>q;\n\t\tint lq=q.size();\n\t\tgen_hash(q,hsh);\n\t\tlong long hash=hsh[lq-1];\n\t\tlong long Brev=pow_binary_mod(B,lq,P);\n\t\tvector<int> r;\n\t\tint i=lq-1;\n\t\tfor(;i<ls;i++){\n\t\t\tif(v[i]==((i>=lq?v[i-lq]:0)*Brev+hash)%P){\n\t\t\t\tr.push_back(i-lq+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!r.empty()){\n\t\t\t//for(int i=0;i<r.size();i++)printf(\"%d\\n\",r[i]);\n\t\t\tputs(\"1\");\n\t\t}else{\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region templates\n//C\n#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#if __cplusplus >= 201103L\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdalign>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing i8  = std::int8_t;\nusing i16 = std::int16_t;\nusing i32 = std::int32_t;\nusing i64 = std::int64_t;\nusing u8  = std::uint8_t;\nusing u16 = std::uint16_t;\nusing u32 = std::uint32_t;\nusing u64 = std::uint64_t;\nusing f32 = float;\nusing f64 = double;\nusing vi32  = std::vector<i32>;\nusing vu32  = std::vector<u32>;\nusing vi64  = std::vector<i64>;\nusing vu64  = std::vector<u64>;\nusing vvi32 = std::vector<vi32>;\nusing vvu32 = std::vector<vu32>;\nusing vvi64 = std::vector<vi64>;\nusing vvu64 = std::vector<vu64>;\nusing pi32  = std::pair<i32,i32>;\nusing pi64  = std::pair<i64,i64>;\n\n#define FOR(i,a,b) for(i64 i=(a), i##_len=(b); i<i##_len; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPS(i,n) for(i64 i=1LL; i<=static_cast<i64>(n); ++i)\n#define RFOR(i,a,b) for(i64 i=(a), i##_len=(b); i>i##_len; --i)\n#define RFORS(i,n) RFOR(i,n,0)\n\n#define ALL(obj) (obj).begin(),(obj).end()\n#define CLR(ar,val) memset(ar, val, sizeof(ar))\n#define SZ(obj) (static_cast<i32>(obj.size()))\n#define cauto const auto&\n#define pb push_back\n#define mp make_pair\n\nconst i32 dx[4]={1,0,-1,0};\nconst i32 dy[4]={0,1,0,-1};\nconst i32 INF32 = 0x3F3F3F3F;\nconst i64 INF64 = 0x3F3F3F3F3F3F3F3F;\n\ntemplate<class T> inline bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\nclass range {\nprivate:\n    struct I {\n        i32 x;\n        i32 operator*() { return x; }\n        bool operator!=(I& lhs) { return x<lhs.x; }\n        void operator++() { ++x; }\n    };\n    I i,n;\npublic:\n    explicit range(int n) : i({0}), n({n}) { }\n    range(int i,int n) : i({i}), n({n}) { }\n    I& begin() { return i; }\n    I& end() { return n; }\n};\n\nstruct IoSetup {\n    IoSetup() {\n        std::cin.tie(nullptr);\n        std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(10);\n        std::cerr << std::fixed << std::setprecision(10);\n    }\n};/// cin,coutを使うときは iosetup をここにつける\n\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first >> p.second;return is; }\ntemplate<typename A, typename B> std::ostream &operator<<(std::ostream &os, const std::pair<A, B>& p) { os << p.first << ' ' << p.second;return os; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for(T& in : v) is >> in; return is; }\ntemplate<typename T> std::ostream &operator<<(std::ostream &os, const std::vector<T> &v) { for(i32 i = 0; i < SZ(v); i++) os << v[i] << (i+1 != SZ(v) ? \" \" : \"\"); return os; }\n#pragma endregion\n\n#pragma region Suffix-Array\n\nstruct SuffixArray {\n    vi32 SA;\n    const std::string s;\n\n    SuffixArray(const std::string& str) : s(str) {\n        SA.resize(SZ(s));\n        std::iota(ALL(SA), 0);\n        std::sort(ALL(SA), [&](i32 a, i32 b) { return s[a] == s[b] ? a > b : s[a] < s[b]; });\n        vi32 classes(SZ(s)), c(ALL(s)), cnt(SZ(s));\n        for (i32 len = 1; len < SZ(s); len <<= 1) {\n            for (i32 i = 0; i < SZ(s); i++) {\n                if (i > 0 && c[SA[i-1]] == c[SA[i]] && SA[i-1] + len < SZ(s) && c[SA[i-1] + len / 2] == c[SA[i] +len / 2]) {\n                    classes[SA[i]] = classes[SA[i-1]];\n                } else {\n                    classes[SA[i]] = i;\n                }\n            }\n            std::iota(ALL(cnt), 0);\n            std::copy(ALL(SA), begin(c));\n\n            for (i32 i = 0; i < SZ(s); i++) {\n                int s1 = c[i] - len;\n                if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n            }\n            classes.swap(c);\n        }\n    }\n\n    i32 operator[](i32 k) const {\n        return SA[k];\n    }\n\n    size_t size() const {\n        return s.size();\n    }\n\n    bool lt_substr(const std::string& t, i32 si = 0, i32 ti = 0) {\n        i32 sn = SZ(s), tn = SZ(t);\n        while(si < sn && ti < tn) {\n            if(s[si] < t[ti]) return true;\n            if(s[si] > t[ti]) return false;\n            ++si, ++ti;\n        }\n        return si >= sn && ti < tn;\n    }\n\n    i32 lower_bound(const std::string& t) {\n        i32 low = -1, high = SZ(SA);\n        while (high - low > 1) {\n            i32 mid = (low + high) / 2;\n            if (lt_substr(t, SA[mid])) low = mid;\n            else high = mid;\n        }\n        return high;\n    }\n\n    pi32 lower_upper_bound(std::string& t) {\n        i32 idx = lower_bound(t);\n        i32 low = idx - 1, high = SZ(SA);\n        t.back()++;\n        while(high - low > 1) {\n            int mid = (low + high) / 2;\n            if (lt_substr(t, SA[mid])) low = mid;\n            else high = mid;\n        }\n        t.back()--;\n        return {idx, high};\n    }\n\n    void output() {\n        for(i32 i = 0; i < SZ(s); i++) {\n          std::cout << i << \": \" << s.substr(SA[i]) << std::endl;\n        }\n    }\n};\n\n#pragma endregion\n\n#pragma region Longest Common Prefix Array\n\nstruct LongestCommonPrefixArray {\n    const SuffixArray& SA;\n    vi32 LCP, rank;\n\n    LongestCommonPrefixArray(const SuffixArray& SA) : SA(SA), LCP(SA.size()) {\n        rank.resize(SA.size());\n        for (i32 i = 0; i < SA.size(); i++) {\n            rank[SA[i]] = i;\n        }\n        for (i32 i = 0, h = 0; i < SA.size(); i++) {\n            if (rank[i] + 1 < SA.size()) {\n                for(i32 j = SA[rank[i] + 1]; std::max(i, j) + h < SA.size() && SA.s[i + h] == SA.s[j + h]; ++h);\n                LCP[rank[i] + 1] = h;\n                if(h > 0) --h;\n            }\n        }\n    }\n\n    i32 operator[](i32 k) const {\n      return LCP[k];\n    }\n\n    size_t size() const {\n        return LCP.size();\n    }\n\n    void output() {\n        for(i32 i = 0; i < size(); i++) {\n            std::cout << i << \": \" << LCP[i] << \" \" << SA.s.substr(SA[i]) << std::endl;\n        }\n    }\n};\n\n#pragma endregion\n\ni32 main() {\n    /* https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/14/ALDS1_14_D */\n    using namespace std;\n    \n    string s; cin >> s;\n    i32 Q; cin >> Q;\n\n    SuffixArray sa(s);\n\n    while (Q--) {\n        string t; cin >> t;\n        auto range = sa.lower_upper_bound(t);\n        cout << (range.first != range.second) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <sstream>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n#define rrep(i, a) RREP(i, a, 0)\n#define RREP(i, a, b) for(int i = a; i >= b; --i)\n#define repll(i, a) REPLL(i, 0, a)\n#define REPLL(i, a, b) for(ll i = a; i < b; ++i)\n#define rrepll(i, a) RREPLL(i, a, 0)\n#define RREPLL(i, a, b) for(ll i = a; i >= b; --i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<int, P> PP;\nconst double PI = 3.14159265358979323846;\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+18 + 10;\n\nconst int max = 1000005;\n\nstd::string text;\nint textSize, k = 1;\nint rank[max + 1], tmp[max + 1], sa[max + 1];\n\nbool compare_sa(int i, int j){\n\tif (rank[i] != rank[j])return rank[i] < rank[j];\n\telse {\n\t\tint ri = (i + k <= textSize ? rank[i + k] : -1);\n\t\tint rj = (j + k <= textSize ? rank[j + k] : -1);\n\t\treturn ri < rj;\n\t}\n}\n\nvoid construct_sa(){\n\ttextSize = text.size();\n\trep(i, textSize + 1){\n\t\tsa[i] = i;\n\t\trank[i] = (i < textSize ? text[i] : -1);\n\t}\n\n\tfor (; k <= textSize; k *= 2){\n\t\tstd::sort(sa, sa + textSize + 1, compare_sa);\n\n\t\ttmp[sa[0]] = 0;\n\t\tREP(j, 1, textSize + 1)tmp[sa[j]] = tmp[sa[j - 1]] + (compare_sa(sa[j - 1], sa[j]) ? 1 : 0);\n\t\trep(j, textSize + 1)rank[j] = tmp[j];\n\t}\n}\n\nbool find(std::string t){\n\tint l = 0, r = text.size();\n\twhile (l <= r){\n\t\tint m = (l + r) / 2;\n\t\tif (text.compare(sa[m], t.size(), t) < 0)l = m + 1;\n\t\telse r = m - 1;\n\t}\n\treturn (text.compare(sa[r + 1], t.size(), t) == 0);\n}\n\nint n;\n\nint main(){\n\tstd::cin >> text >> n;\n\tconstruct_sa();\n\trep(i, n){\n\t\tchar str[1005];\n\t\tscanf(\"%s\", &str);\n\t\tprintf(\"%d\\n\", (find(str) ? 1 : 0));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\n#define NUM 48\nusing namespace std;\n\nint T_char_count[128] = {0},P_char_count[128];\n\nclass LocRecord{\n\npublic:\n\t//?????¢???????¢????\n\tLocRecord(){\n\t\tlocationTable = new int*[128];\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t}\n\n\t//-1?????£??\\\n\tvoid init(){\n\t\tint limit;\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init_index(){\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t}\n\n\tvoid regist_loc(int ch, int location){\n\t\tlocationTable[ch][index[ch]] = location;\n\t\tindex[ch]++;\n\t}\n\n\tint next_loc(int ch){\n\t\tint ret = locationTable[ch][index[ch]];\n\t\tindex[ch]++;\n\t\treturn ret;\n\t}\n\nprivate:\n\tint** locationTable;\n\tint index[128];\n};\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\t\t\treturn length < arg.length;\n\t};\n\tInfo(){\n\t\tlength = id = -1;\n\t\thashValue = 0;\n\t}\n\tInfo(int arg_length,int arg_id,ull arg_hashValue){\n\t\tlength = arg_length;\n\t\tid = arg_id;\n\t\thashValue = arg_hashValue;\n\t}\n\n\tint length,id;\n\tull hashValue;\n};\n\nint main(){\n\n\tfor(int i = 0; i < 128; i++)T_char_count[i] = 0;\n\n\tint T_length;\n\n\tchar* T = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tfor(T_length = 0; T[T_length] != '\\0';T_length++){\n\t\tT_char_count[T[T_length]]++;\n\t}\n\n\tLocRecord locRecord;\n\tlocRecord.init();\n\n\t//T[i]????????????i??§???????????¨????¨????\n\tfor(int i = 0; i < T_length; i++){\n\t\tlocRecord.regist_loc(T[i],i);\n\t}\n\n\tull* HASH = new ull[T_length+1];\n\tull* P = new ull[T_length+1];\n\n\tHASH[0] = 0;\n\tP[0] = 1;\n\n\t//T??????????????\\???????±???????\n\tfor(int i = 1; i <= T_length; i++){\n\t\tHASH[i] = T[i-1] + HASH[i-1]*MOD;\n\t\tP[i] = P[i-1]*MOD;\n\t}\n\n\n\tvector<Info> V[128];\n\n\tint Q,S_length,left,P_char_count[128];\n\tscanf(\"%d\",&Q);\n\n\tbool check[Q];\n\n\tfor(int i = 0; i < Q-1; i++)check[i] = false;\n\n\tchar S[1001];\n\tull S_HASH[1001],S_value,T_value,D;\n\tbool FLG;\n\n\t//Q??¶??????????????\\???????¨????\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",S);\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tP_char_count[i] = 0;\n\t\t}\n\n\t\tfor(S_length = 0;S[S_length] != '\\0';S_length++){\n\t\t\tP_char_count[S[S_length]]++;\n\t\t}\n\n\t\tFLG = true;\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tif(T_char_count[i] < P_char_count[i]){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG)continue;\n\n\n\t\tS_HASH[0] = 0;\n\t\tfor(int i = 1; i <= S_length; i++){\n\t\t\tS_HASH[i] = S[i-1] + S_HASH[i-1]*MOD;\n\t\t}\n\n\t\tS_value = S_HASH[S_length];\n\n\t\tV[S[0]].push_back(Info(S_length,loop,S_value));\n\t}\n\n\tint calc_length;\n\n\tfor(int word = 48; word <= 122; word++){\n\t\tfor(int i = 0; i < V[word].size();i++){\n\n\t\t\tlocRecord.init_index();\n\n\t\t\tcalc_length = V[word][i].length;\n\t\t\tS_value = V[word][i].hashValue;\n\n\t\t\tD = P[calc_length];\n\n\t\t\twhile((left = locRecord.next_loc(word)) != -1){\n\t\t\t\tif(left+calc_length-1 >= T_length)break;\n\n\t\t\t\tT_value = HASH[left+calc_length]-HASH[left]*D;\n\n\t\t\t\tif(T_value == S_value){\n\t\t\t\t\tcheck[V[word][i].id] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tif(check[i])printf(\"1\\n\");\n\t\telse{\n\t\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nclass SuffixArray {\n    const ll n;\n    const string str;\n    vector<ll> sa, lcp;\npublic:\n    SuffixArray(const string& s) : str(s), n(s.size()) {}\n    vector<ll> make_sa() {\n        sa.assign(n+1, 0);\n        rep(i, n+1) sa[i] = i;\n        vector<ll> rank(all(str));\n        rank.pb(-1);\n        auto f = [&](ll idx, ll len) {\n            return idx + len <= n ? rank[idx+len] : -1;\n        };\n        for (ll k = 1; k <= n; k <<= 1) {\n            auto compare = [&](ll a, ll b) {\n                if (rank[a] != rank[b]) return rank[a] < rank[b];\n                else return f(a, k) < f(b, k);\n            };\n            sort(all(sa), compare);\n            vector<ll> nrank(n+1, 0);\n            rep(i, 1, n+1) {\n                nrank[sa[i]] = nrank[sa[i-1]] + compare(sa[i-1], sa[i]);\n            }\n            rank = nrank;\n        }\n        return sa;\n    }\n    vector<ll> make_lcp() {\n        assert(sa.size() > 0);\n        lcp.assign(sa.size(), 0);\n        vector<ll> rank(n+1);\n        rep(i, n+1) rank[sa[i]] = i;\n        ll h = 0;\n        rep(i, n) {\n            if (h > 0) --h;\n            assert(rank[i] > 0);\n            for (ll j = sa[rank[i]-1]; j + h < n && i + h < n; h++) {\n                if (str[j+h] != str[i+h]) break;\n            }\n            lcp[rank[i]-1] = h;\n        }\n        return lcp;\n    }\n    vector<ll> search(const string& s) {\n        assert(lcp.size() > 0);\n        ll l = -1, r = -1;\n        {\n            ll lb = 0, ub = n+1;\n            while (ub - lb > 1) {\n                ll mid = (lb + ub) / 2;\n                if (str.substr(sa[mid], s.size()) >= s) {\n                    ub = mid;\n                }\n                else {\n                    lb = mid;\n                }\n            }\n            l = ub;\n        }\n        {\n            ll lb = 0, ub = n+1;\n            while (ub - lb > 1) {\n                ll mid = (lb + ub) / 2;\n                if (str.substr(sa[mid], s.size()) > s) {\n                    ub = mid;\n                }\n                else {\n                    lb = mid;\n                }\n            }\n            r = ub;\n        }\n        vector<ll> res;\n        if (str.substr(sa[l], s.size()) == s) {\n            rep(i, l, r) {\n                res.pb(sa[i]);\n            }\n        }\n        return res;\n    }\n};\n// s[mid...] > t ?\nll compare(const string& s, const ll base, const string& t) {\n    rep(i, t.size()) {\n        if (base + i >= s.size()) return -1;\n        if (s[base + i] != t[i]) return s[base+i] > t[i] ? 1 : -1;\n    }\n    return 0;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string S; cin >> S;\n    SuffixArray Sa(S);\n    vector<ll> sa = Sa.make_sa();\n    ll Q; cin >> Q;\n    rep(q, Q) {\n        string s; cin >> s;\n        ll lb = 0, ub = S.size();\n        bool flag = true;\n        while (flag) {\n            ll mid = (ub + lb) / 2;\n            // if (S.substr(sa[mid]) >= s) {\n            if ( compare(S, sa[mid], s) >= 0 ) {\n                ub = mid;\n            }\n            else {\n                lb = mid;\n            }\n            if (ub - lb <= 1) flag = false;\n        }\n        // if (S.substr(sa[ub], s.size()) == s) cout << 1 << endl;\n        if (compare(S, sa[ub], s) == 0) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int MAX = 30;\n\nint encode(char c){\n\t\treturn 0 + c - 'a';\n\n\tassert(false && \"invalid string\");\n}\n\nstruct Node{\n\tint nxt[MAX+1];\t\t\t// 次のalphabeteのノード番号\n\tint exist;\t\t\t\t// 子ども以下に存在する文字列の数の合計\n\tvector<int> accept;\t\t// その文字列id\n\tNode() : exist(0){memset(nxt, -1, sizeof(nxt));}\n};\n\nclass Trie{\n\tprivate:\n\t\tvoid updateDirect(int node,int id){\n\t\t\tac.emplace_back(node);\n\t\t\tnodes[node].accept.emplace_back(id);\n\t\t}\n\t\tvoid updateChild(int node,int child,int id){\n\t\t\t++nodes[node].exist;\n\t\t}\n\t\tvoid add(const string &str,int str_index,int node_index,int id){\n\t\t\tif(str_index == str.size())\n\t\t\t\tupdateDirect(node_index, id);\n\t\t\telse{\n\t\t\t\tconst int c = encode(str[str_index]);\n\t\t\t\tif(nodes[node_index].nxt[c] == -1) {\n\t\t\t\t\tnodes[node_index].nxt[c] = (int) nodes.size();\n\t\t\t\t\tnodes.emplace_back(Node());\n\t\t\t\t}\n\t\t\t\tadd(str, str_index + 1, nodes[node_index].nxt[c], id);\n\t\t\t\tupdateChild(node_index, nodes[node_index].nxt[c], id);\n\t\t\t}\n\t\t}\n\t\tvoid add(const string &str,int id){add(str, 0, 0, id);}\n\tpublic:\n\t\tvector<Node>nodes;\n\t\tvector<int> ac; // ac[i] := i番目のパターンを受理する状態番号\n\t\tint root;\n\t\tTrie() : root(0){nodes.emplace_back(Node());}\n\t\tvoid add(const string &str){add(str, nodes[0].exist);}\n\t\tint size(){return (nodes[0].exist);}\n\t\tint nodesize(){return ((int) nodes.size());}\n};\n\nclass AhoCorasick : public Trie{\n\tpublic: \n\t\tstatic const int FAIL = MAX;\n\t\tvector<int> correct;\n\t\tAhoCorasick() : Trie() {}\n\n\t\tvoid build(){\n\t\t\tcorrect.resize(nodes.size());\n\t\t\trep(i,nodes.size())correct[i]=(int)nodes[i].accept.size();\n\n\t\t\tqueue<int> que;\n\t\t\trep(i,MAX+1){\n\t\t\t\tif(~nodes[0].nxt[i]) {\n\t\t\t\t\tnodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n\t\t\t\t\tque.emplace(nodes[0].nxt[i]);\n\t\t\t\t}else nodes[0].nxt[i] = 0;\n\t\t\t}\n\t\t\twhile(!que.empty()) {\n\t\t\t\tNode now = nodes[que.front()];\n\t\t\t\tcorrect[que.front()] += correct[now.nxt[FAIL]];\n\t\t\t\tque.pop();\n\t\t\t\trep(i,MAX){\n\t\t\t\t\tif(now.nxt[i] == -1) continue;\n\t\t\t\t\tint fail = now.nxt[FAIL];\n\t\t\t\t\twhile(nodes[fail].nxt[i] == -1) {\n\t\t\t\t\t\tfail = nodes[fail].nxt[FAIL];\n\t\t\t\t\t}\n\t\t\t\t\tnodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n\n\t\t\t\t\tauto &u = nodes[now.nxt[i]].accept;\n\t\t\t\t\tauto &v = nodes[nodes[fail].nxt[i]].accept;\n\t\t\t\t\tvector<int> accept;\n\t\t\t\t\tset_union(all(u),all(v),back_inserter(accept));\n\t\t\t\t\tu=accept;\n\t\t\t\t\tque.emplace(now.nxt[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// result := 各パターンがそれぞれ何度マッチしたか\n\t\tint match(const string &str,vector<int> &result,int now=0){\n\t\t\tresult.assign(size(),0);\n\t\t\tint count=0;\n\t\t\tfor(auto &c:str) {\n\t\t\t\twhile(nodes[now].nxt[encode(c)]==-1)now=nodes[now].nxt[FAIL];\n\t\t\t\tnow = nodes[now].nxt[encode(c)];\n\t\t\t\tcount += correct[now];\n\t\t\t\tfor(auto &v:nodes[now].accept)result[v]++;\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\t\tint next(int now,char c){\n\t\t\twhile(nodes[now].nxt[encode(c)]==-1)now=nodes[now].nxt[FAIL];\n\t\t\treturn nodes[now].nxt[encode(c)];\n\t\t}\n};\n\nint main(){\n\tstring s;\n\tint n;\n\tcin >> s >> n;\n\n\tAhoCorasick aho;\n\trep(i,n){\n\t\tstring a;\n\t\tcin >> a;\n\t\taho.add(a);\n\t}\n\tvector<int> res;\n\taho.build();\n\taho.match(s, res);\n\tfor(auto i : res) cout << (i == 0 ? 0 : 1) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring S,T;\nstring V[50000][80];\nint main(){\n\tint q,a,b,c;\n\tcin>>S;\n\tb=S.size();\n\ta=min(b,100);\n\tfor(int i=1;i<100;i++){\n\t\tfor(int j=0;j<=b-i;j++){\n\t\t\tV[j][i]=S.substr(j,i);\n\t\t}\n\t}\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>T;\n\t\tc=T.size();\n\t\tfor(int j=0;j<=b-c;j++){\n\t\t\tif(V[j][c]==T){\n\t\t\t\tcout<<\"1\"<<endl;\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t}\n\t\tcout<<\"0\"<<endl;\n\t\tExit:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n\nusing namespace std;\n\nstring S; int Q; char STR[1000005];\n\nint main()\n{\n\tscanf(\"%s%d\", STR, &Q);\n\n\tS = STR;\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%s\", STR);\n\n\t\tprintf(\"%d\\n\", S.find(STR) != string::npos ? 1 : 0);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(string s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  bool operator()(int i, int j) { \n    int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  \n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  \n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  sort(ALL(sa),rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  if(100000 < s.size())assert(false);\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\nclass suffix_array{\nprivate:\n    typedef unsigned long ul;\n    \n    struct node{\n        ll begin;\n        ll Rank;\n        node* next;\n        \n        bool operator < (const node &N) const {\n            if(Rank==N.Rank){\n                return (next==NULL?-1:next->Rank)<(N.next==NULL?-1:N.next->Rank);\n            }\n            return Rank<N.Rank;\n        }\n        \n        node(ll begin=0,ll Rank=0,node* next=NULL):begin(begin),Rank(Rank),next(next){}\n    };\n    \n    vector<node> sa;\n    vector<ll> Rank;\n    const string s;\n    \n    void build(){\n        for(int i=0;i<s.size();i++){\n            sa[i]={i,s[i],&sa[i+1]};\n        }\n        sa[s.size()].begin=s.size();\n        sa[s.size()].Rank=-1;\n        for(ll k=1;k<=s.size();k<<=1){\n            sort(sa.begin(),sa.end());\n            Rank[sa[0].begin]=0;\n            for(int i=1;i<=s.size();i++){\n                Rank[sa[i].begin]=Rank[sa[i-1].begin]+(sa[i-1]<sa[i]?1:0);\n            }\n            for(int i=0;i<=s.size();i++){\n                sa[i].Rank=Rank[sa[i].begin];\n                if(sa[i].next!=NULL){\n                    sa[i].next=sa[i].next->next;\n                }\n            }\n        }\n    }\n    \n    //1::greater 0::same -1::less\n    int compare(const ul &saf,const string &str){\n        for(int i=0;i<str.size();i++){\n            if(sa[saf].begin+i>=s.size()){return -1;}\n            if(s[sa[saf].begin+i]!=str[i]){return s[sa[saf].begin+i]<str[i]?-1:1;}\n        }\n        return 0;\n    }\n    \npublic:\n    suffix_array(const string &str):s(str),Rank(str.size()+1),sa(str.size()+1){build();}\n    \n    ll rank(const ul &where) const {return Rank[where];}\n    \n    node suffix(const ul &n) const {return sa[n];}\n    \n    ul size() const {return sa.size();}\n    \n    const node & operator [] (const ul &where) const {return sa[where];}\n    \n    //返すのはsuffixの番号\n    ul lower_bound(const string &sub){\n        ll l=0;\n        ll r=s.size();\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            if(compare(m,sub)==-1){l=m+1;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(compare(i,sub)>=0){return i;}\n        }\n        return r+1;\n    }\n    \n    //返すのはsuffixの番号\n    ul upper_bound(const string &sub){\n        ll l=0;\n        ll r=s.size();\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            if(compare(m,sub)<=0){l=m+1;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(compare(i,sub)>0){return i;}\n        }\n        return r+1;\n    }\n    \n    bool match(const string &sub){\n        ll l=0;\n        ll r=s.size();\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            int st=compare(m,sub);\n            if(st==0){return true;}\n            else if(st==-1){l=m+1;}\n            else{r=m-1;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(compare(i,sub)==0){return true;}\n        }\n        return false;\n    }\n};\n\n\n\n\n\n\nint main(){\n    string t;\n    cin>>t;\n    suffix_array S(t);\n    ll q;\n    cin>>q;\n    while(q--){\n        string p;\n        cin>>p;\n        cout<<S.match(p)<<endl;\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nstatic const int NUM_CHILDREN = 26;\nstatic const char MIN_CHAR = 'a';\n\nstruct Trie {\n    int num;\n    Trie *next[NUM_CHILDREN];\n    Trie() : num(-1) {\n        fill(next, next + NUM_CHILDREN, (Trie*)0);\n    }\n};\n\nvoid construct(Trie *trie, const vector<string> &strings) {\n    rep(i, strings.size()) {\n        Trie *p = trie;\n        for (auto c : strings[i]) {\n            int idx = c - MIN_CHAR;\n            if (!p->next[idx]) p->next[idx] = new Trie;\n            p = p->next[idx];\n        }\n        p->num = i;\n    }\n}\n\nvoid dump(Trie* p, string s) {\n    if (p->num != -1) cerr << s << endl;\n    for (int i = 0; i < NUM_CHILDREN; ++i) {\n        if (p->next[i]) {\n            dump(p->next[i], s + char(i + MIN_CHAR));\n        }\n    }\n}\n\nvoid search(Trie* trie, const string &s, vector<bool> &exist) {\n    Trie *p = trie;\n    for (auto c : s) {\n        if (p->num != -1) exist[p->num] = true;\n        int idx = c - MIN_CHAR;\n        if (!p->next[idx]) return;\n        p = p->next[idx];\n    }\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    string s;\n    cin >> s;\n    int q;\n    cin >> q;\n    vector<string> strings(q);\n    rep(i, q) cin >> strings[i];\n\n    Trie *trie = new Trie;\n\n    construct(trie, strings);\n\n    // dump(trie, \"\");\n\n    vector<bool> exist(q);\n\n    rep(i, s.size()) {\n        search(trie, s.substr(i), exist);\n    }\n\n    rep(i, q) {\n        cout << exist[i] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define VARNAME(x) #x\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nconstexpr ll MOD = 1000000007LL;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n\n\n\ninline bool match(const string& s, const string& p, const vector<int>& sa)\n{\n    const int size = s.size();\n    const int psize = p.size();\n    int inf = -1;\n    int sup = size;\n    while (sup - inf > 1) {\n        const int mid = (inf + sup) / 2;\n        if (s.substr(sa[mid], psize) < p) {\n            inf = mid;\n        } else {\n            sup = mid;\n        }\n    }\n    return sup == size ? false : p == s.substr(sa[sup], psize);\n}\n\n\n\nclass SuffixArray\n{\nprivate:\n    // static constexpr int encode(const int c) { return c == '$' ? 0 : c - 'a' + 1; }\n    // static constexpr char decode(const int n) { return (n == 0 ? '$' : 'a' + n - 1); }\n    static constexpr int encode(const int c) { return c == '$' ? 0 : c <= '9' ? 1 + c - '0' : c <= 'Z' ? 11 + c - 'A' : 37 + c - 'a'; }\n    static constexpr char decode(const int n) { return n == 0 ? '$' : n <= 10 ? '0' + n - 1 : n <= 36 ? 'A' + n - 11 : 'a' * n - 37; }\n    enum class Type : char\n    {\n        L = 0,\n        S = 1,\n        LMS = 2,\n    };\n\npublic:\n    SuffixArray(const string& s, const int kind_) : N(s.size() + 1), kind{kind_ + 1}, S(s.size() + 1, 0), type(N), next(N, 1), bucket(kind), num(kind, 0), head(kind, 0), tail(kind, 0)\n    {\n        for (int i = 0; i < s.size(); i++) {\n            S[i] = encode(s[i]);\n        }\n        initializeData();\n        sortLMS();\n    }\n    SuffixArray(const vector<int>& s, const int kind_) : N(s.size() + 1), kind{kind_ + 1}, S(s), type(N), next(N, 1), bucket(kind), num(kind, 0), head(kind, 0), tail(kind, 0)\n    {\n        S.push_back(0);\n        initializeData();\n        sortLMS();\n    }\n    void debugPrint() const\n    {\n        for (int i = 0; i < N; i++) {\n            cout << decode(S[i]);\n        }\n        cout << endl;\n        for (int i = 0; i < N; i++) {\n            cout << (type[i] == Type::L ? \"L\" : \"S\");\n        }\n        cout << endl;\n        for (int i = 0; i < N; i++) {\n            cout << (type[i] == Type::LMS ? \"@\" : \" \");\n        }\n        cout << endl;\n        for (int i = 0; i < kind; i++) {\n            if (bucket[i].empty()) continue;\n            cout << \"[\" << decode(i) << \"]:\\n\";\n            for (const int p : bucket[i]) {\n                cout << \"  \" << p << endl;\n            }\n        }\n    }\n\n    vector<int> getSuffixArray() const\n    {\n        vector<int> ans(N - 1);\n        for (int pos = 0, i = 1; i < kind; i++) {  // 番兵以外\n            for (const int p : bucket[i]) {\n                ans[pos++] = p;\n            }\n        }\n        return ans;\n    }\n\nprivate:\n    void initializeData()\n    {\n        for (const int i : S) {\n            num[i]++;\n        }\n        for (int i = 0; i < kind; i++) {\n            bucket[i].resize(num[i], -1);\n            tail[i] = num[i] - 1;\n        }\n        type[N - 1] = Type::S;\n        for (int i = N - 2; i >= 0; i--) {\n            type[i] = (S[i] != S[i + 1] ? (S[i] < S[i + 1] ? Type::S : Type::L) : type[i + 1]);\n            if (type[i] == Type::L and type[i + 1] == Type::S) {\n                type[i + 1] = Type::LMS;\n                LMS.push_back(i + 1);\n            }\n        }\n        for (int pos = N - 1, i = N - 2; i >= 0; i--) {\n            next[i] = pos;\n            if (type[i] == Type::LMS) {\n                pos = i;\n            }\n        }\n    }\n\n    void sortLMS()\n    {\n        for (const int l : LMS) {\n            insertTail(l);\n        }\n        induce();\n        vector<int> lms;\n        for (int i = 0; i < kind; i++) {\n            for (const int p : bucket[i]) {\n                if (type[p] == Type::LMS) {\n                    lms.push_back(p);\n                }\n            }\n        }\n        const int size = lms.size();\n        vector<int> order(N / 2 + 1, 0);\n        int number = 1;\n        order[N / 2] = 1;\n        bool same = false;\n        for (int i = 1; i < size; i++) {\n            const int l1 = lms[i - 1];\n            const int r1 = next[l1];\n            const int l2 = lms[i];\n            const int r2 = next[l2];\n            if (r1 - l1 == r2 - l2 and vector<int>(S.begin() + l1, S.begin() + r1 + 1) == vector<int>(S.begin() + l2, S.begin() + r2 + 1)) {\n                same = true;\n            } else {\n                number++;\n            }\n            order[l2 / 2] = number;\n        }\n        if (same) {\n            vector<int> s(size);\n            for (int p = 0, i = 0; i <= N / 2; i++) {\n                if (order[i] > 0) {\n                    s[p++] = order[i];\n                }\n            }\n            const vector<int> sorted = SuffixArray{s, number}.getSuffixArray();\n            for (int i = 0; i < kind; i++) {\n                head[i] = 0;\n                tail[i] = num[i] - 1;\n            }\n            for (int i = size - 1; i >= 0; i--) {\n                insertTail(LMS[size - 1 - sorted[i]]);\n            }\n            induce();\n        } else {\n            for (int i = 0; i < kind; i++) {\n                head[i] = 0;\n                tail[i] = num[i] - 1;\n            }\n            for (int i = size - 1; i >= 0; i--) {\n                insertTail(lms[i]);\n            }\n            induce();\n        }\n    }\n\n    void induce()\n    {\n        for (int i = 0; i < kind; i++) {\n            for (int j = 0; j < head[i]; j++) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] == Type::L) {\n                    insertHead(p - 1);\n                }\n            }\n            for (int j = tail[i] + 1; j < num[i]; j++) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] == Type::L) {\n                    insertHead(p - 1);\n                }\n            }\n        }\n        for (int i = 1; i < kind; i++) {  // 番兵以外\n            tail[i] = num[i] - 1;\n        }\n        for (int i = kind - 1; i >= 0; i--) {\n            for (int j = num[i] - 1; j > tail[i]; j--) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] != Type::L) {\n                    insertTail(p - 1);\n                }\n            }\n            for (int j = head[i] - 1; j >= 0; j--) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] != Type::L) {\n                    insertTail(p - 1);\n                }\n            }\n        }\n    }\n    void insertHead(const int i) { bucket[S[i]][head[S[i]]++] = i; }\n    void insertTail(const int i) { bucket[S[i]][tail[S[i]]--] = i; }\n\n    const int N;\n    const int kind;\n    vector<int> S;               // O(N)\n    vector<Type> type;           // O(N)\n    vector<int> next;            // O(N)\n    vector<vector<int>> bucket;  // O(N)\n    vector<int> num;             // O(K)\n    vector<int> head;            // O(K)\n    vector<int> tail;            // O(K)\n    vector<int> LMS;             // O(N)\n};\n\n\n\n// Problem: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n// Status: Accepted\n\nint main()\n{\n    string S;\n    cin >> S;\n    const auto sa = SuffixArray{S, 62}.getSuffixArray();\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; q++) {\n        string P;\n        cin >> P;\n        cout << (match(S, P, sa) ? 1 : 0) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    S.push_back('$');\n    vector<int> c(n+1,0),ord(n+1,0);\n    for(int i=0;i<=n;i++) ord[i]=n-i;\n    sort(ord.begin(),ord.end(),[&](int a,int b){return S[a]<S[b];});\n    return;\n    for(int i=0;i<=n;i++){\n      sa[i]=ord[i];\n      c[i]=S[i];\n    }\n    \n    for(int len=1;len<=n;len*=2){\n      vector<int> r=c;\n      for(int i=0;i<=n;i++){\n\t c[sa[i]] =\n\t   i > 0 &&\n\t   r[sa[i - 1]] == r[sa[i]] &&\n\t   sa[i - 1] + len <= n &&\n\t   r[sa[i - 1] + len / 2] == r[sa[i] + len / 2]\n\t   ? c[sa[i - 1]] : i;\n      }\n      vector<int> cnt(n+1);\n      for(int i=0;i<=n;i++) cnt[i]=i;\n      vector<int> s=sa;\n      for(int i=0;i<=n;i++){\n\tint s1=s[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n);\n    for(int i=0;i<n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  return 0;\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    //assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct SA{\n  int n,k;\n  string S;\n  vector<int> r,r2,t,sa,lcp;\n  SA(){}\n  SA(string S):S(S){init();}\n  void init(){\n    n=S.size();\n    r.resize(n+1,0);\n    r2.resize(n+1,0);\n    t.resize(n+1,0);\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    constract_sa();\n  }\n  bool compare_sa(int i,int j){\n    if(r[i]!=r[j]) return r[i]<r[j];\n    else{\n      int ri=i+k<=n?r[i+k]:-1;\n      int rj=j+k<=n?r[j+k]:-1;\n      return ri<rj;\n    }\n  }\n  void constract_sa(){\n    n=S.length();\n    for(int i=0;i<=n;i++){\n      sa[i]=i;\n      r[i]=i<n?S[i]:-1;\n    }\n    for(k=1;k<=n;k*=2){\n      sort(sa.begin(),sa.end(),[&](const int &i, const int &j){\n\t  if(r[i]!=r[j]) return r[i]<r[j];\n\t  else{\n\t    int ri=i+k<=n?r[i+k]:-1;\n\t    int rj=j+k<=n?r[j+k]:-1;\n\t    return ri<rj;\n\t  }\n\t});\n      t[sa[0]]=0;\n      for(int i=1;i<=n;i++){\n\tt[sa[i]]=t[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n      }\n      for(int i=0;i<=n;i++){\n\tr[i]=t[i];\n      }\n    }\n  }\n  bool contains(string T){\n    int a=0,b=S.length()+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==(int)S.length()+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  void constract_lcp(){\n    for(int i=0;i<=n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n \n \n  int count(string T,RMQ &rmq){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(b[i]-a[i]>1){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SA sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  string T;\n  int Q;\n  cin>>T;\n  cin>>Q;\n  int flag[Q]={0};\n  string P[Q];\n  for(int i=0;i<Q;i++)\n    cin>>P[i];\n  for(int i=0;i<Q;i++){\n    for(int j=0;j<=T.size()-P[i].size();j++){\n      if(T.size()<P[i].size())\n\tbreak;\n      if(P[i]==T.substr(j,P[i].size())){\n\tflag[i]=1;\n\tbreak;\n      }\n    }\n  }\n  for(int i=0;i<Q;i++)\n    cout<<flag[i]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint Rank[1000005];\nint Tmp[1000005];\nint kc,len;\n\nbool compare_sa(int i,int j){\n  return\n    Rank[i]!=Rank[j]?\n    Rank[i]<Rank[j]:\n    (i+kc<=len?Rank[i+kc]:-1)<(j+kc<=len?Rank[j+kc]:-1);\n}\n\nvoid construct_sa(char* S,int *sa){\n  len=strlen(S);\n  for(int i=0;i<=len;i++){\n    sa[i]=i;\n    Rank[i]=i<len?S[i]:-1;\n  }\n  for(kc=1;kc<=len;kc*=2){\n    sort(sa,sa+len+1,compare_sa);\n    Tmp[sa[0]]=0;\n    for(int i=1;i<=len;i++){\n      Tmp[sa[i]]=Tmp[sa[i-1]]+compare_sa(sa[i-1],sa[i]);\n    }\n    for(int i=0;i<=len;i++)Rank[i]=Tmp[i];\n  }\n}\n\n\nint n,m;\nchar str[1000005];\nchar t[1000005];\nint sa[1000005];\n\nint main(){\n  scanf(\"%s\",str);\n  n=strlen(str);\n  construct_sa(str,sa);\n  scanf(\"%d\",&m);\n  while(m--){\n    scanf(\"%s\",t);\n    int k=strlen(t);\n    int l=0,r=n+1,m;\n    while(l+1<r){\n      m=(l+r)/2;\n      if(strncmp(str+sa[m],t,k)<=0)l=m;\n      else r=m;\n    }\n    printf(\"%d\\n\",(strncmp(str+sa[l],t,k)==0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\nint main() {\n\tstring T; cin >> T;\n\tint Q; cin >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tstring P; cin >> P;\n\t\tif (T.find(P) == string::npos)\n\t\t\tcout << 0 << endl;\n\t\telse\n\t\t\tcout << 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  inline bool cmp(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k > n ? true : j+k > n ? false : s[i+k] <= s[j+k];\n  }\n  \n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }  \n};\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  const int n = SZ(a);\n  if(n>1){\n    vector<int> b(a.begin(), a.begin()+n/2);\n    vector<int> c(a.begin()+n/2, a.end());\n    mergesort(b,rh);\n    mergesort(c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==SZ(c))a[i]=b[j++];\n      else if(j==SZ(b))a[i]=c[k++];\n      else if(rh.cmp(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  //sort(ALL(sa),rh);\n  mergesort(sa,rh);\n  //if(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    //if(S.compare(sa[c],T.length(),T)<0 )a=c;\n    //else b=c;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  while(n--){\n    cin >> t;\n    cout << contain(s,sa,t) << \"\\n\";\n    //cout << !!rh.find(t) << \"\\n\";\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \ntemplate<class T>\nstruct SparseTable{\n\tvector<T> st[21];\n\tvoid Init(int N,vector<T> &data){\n\t\tst[0].resize(N);\n\t\tint h = 1;\n\t\twhile ((1 << h) < N){\n\t\t\tst[h].resize(N - (1 << h) + 1);\n\t\t\th++;\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tst[0][i] = data[i];\n\t\t}\n\t\tfor(int j=1;j<=h;j++){\n\t\t\tfor(int i=0;i<N-(1<<j)+1;i++){\n\t\t\t\tst[j][i] = min(st[j-1][i],st[j-1][i + (1 << (j - 1))]);\n\t\t\t}\n\t\t}\n\t}\n\tinline int TopBit(int t){\n\t\treturn 31-__builtin_clz(t);\n\t}\n\tT GetMin(int b,int e){\n        e++;\n\t\tint diff = TopBit(e-b);\n\t\treturn min(st[diff][b], st[diff][e - (1 << diff)]);\n\t}\n};\nstruct StringManager{\n\tconst vector<int> S;\n\tconst int maxChar;\n\tconst int N;\n\tvector<int> SuffixArray;\n\tvector<int> LCPArray;\n\tSparseTable<int> LCARMQ;\n\tStringManager(const vector<int>& data_,int c)\n        : S(data_), maxChar(c), N(data_.size()) {\n    }\n\tstatic vector<int> StringToIntArray(string s){\n\t\tvector<int> ans(s.length());\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tans[i] = s[i] - 'a';\n\t\t}\n\t\treturn ans;\n\t}\n\tStringManager(string s)\n        : S(StringToIntArray(s)), maxChar(26), N(s.length()) {\n    }\n\tvoid SAIS(){\n\t\t//文字列を格納\n\t\tvector<int> Sbuffer(N*2+10);\n\t\t//S-typeかL-typeか\n\t\tvector<bool> SLbuffer(N*2+10);\n\t\t//LMS−typeなら何番目か\n\t\tvector<int> rLMSbuffer(N*2+10);\n\t\t//LMS−typeの場所\n\t\tvector<int> LMSbuffer(N+100);\n\t\t//Binの境界をを格納\n\t\tvector<int> Binbuffer(maxChar+N+100);\n\t\t//Binをどこまでうめたか必要な時に使う\n\t\tvector<int> BinPointerbuffer(maxChar+N+100);\n\t\tvector<tuple<int,int,int,int,int,int>> WorkInformation(100);\n\t\tvector<int> Ansbuffer(N*2+10,-1);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tSbuffer[i] = S[i]+1;\n\t\t}\n\t\tSbuffer[N] = 0;\n\t\tWorkInformation[0] = make_tuple(0,0,0,maxChar+1,N+1,0);\n\t\tint WorkPointer = 0;\n\t\twhile(WorkPointer >= 0){\n\t\t\tconst int Spointer = get<0>(WorkInformation[WorkPointer]);\n\t\t\tconst int Binpointer = get<1>(WorkInformation[WorkPointer]);\n\t\t\tconst int LMSpointer = get<2>(WorkInformation[WorkPointer]);\n\t\t\tconst int CharNum = get<3>(WorkInformation[WorkPointer]);\n\t\t\tconst int SLength = get<4>(WorkInformation[WorkPointer]);\n\t\t\tint LMSnum = get<5>(WorkInformation[WorkPointer]);\n\t\t\tWorkPointer--;\n\t\t\t//最初に問題を解く時\n\t\t\tif(LMSnum == 0){\n\t\t\t\t//S-typeかL-typeかを計算\n\t\t\t\tSLbuffer[Spointer+SLength-1] = true;\n\t\t\t\tfor(int i=SLength-2;i>=0;i--){\n\t\t\t\t\tif(Sbuffer[Spointer+i] < Sbuffer[Spointer+i+1]){\n\t\t\t\t\t\tSLbuffer[Spointer+i] = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(Sbuffer[Spointer+i] > Sbuffer[Spointer+i+1]){\n\t\t\t\t\t\tSLbuffer[Spointer+i] = false;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tSLbuffer[Spointer+i] = SLbuffer[Spointer+i+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//LMS-typeを格納\n\t\t\t\tfor(int i=1;i<SLength;i++){\n\t\t\t\t\tif(SLbuffer[Spointer+i] && !SLbuffer[Spointer+i-1]){\n\t\t\t\t\t\tLMSbuffer[LMSpointer+LMSnum] = i;\n\t\t\t\t\t\tLMSnum++;\n\t\t\t\t\t\trLMSbuffer[Spointer+i] = LMSnum;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//Binbufferを計算\n\t\t\t\tfor(int i=0;i<SLength;i++){\n\t\t\t\t\tBinbuffer[Binpointer+Sbuffer[Spointer+i]+1]++;\n\t\t\t\t}\n\t\t\t\tfor(int i=1;i<CharNum;i++){\n\t\t\t\t\tBinbuffer[Binpointer+i+1] += Binbuffer[Binpointer+i];\n\t\t\t\t}\n\t\t\t\t//LMS-typeをそれぞれのbinごとに後ろから入れていく　同時に頭文字が同じLMSが存在するか確認\n\t\t\t\tfor(int i=0;i<CharNum;i++){\n\t\t\t\t\tBinPointerbuffer[Binpointer+i] = Binbuffer[Binpointer+i+1]-1;\n\t\t\t\t}\n\t\t\t\tbool SameTopCharacterLMSExist = false;\n\t\t\t\tfor(int i=0;i<LMSnum;i++){\n\t\t\t\t\tint ch = Sbuffer[Spointer+LMSbuffer[LMSpointer+i]];\n\t\t\t\t\tAnsbuffer[Spointer+BinPointerbuffer[Binpointer+ch]] = LMSbuffer[LMSpointer+i];\n\t\t\t\t\tSameTopCharacterLMSExist |= BinPointerbuffer[Binpointer+ch] != Binbuffer[Binpointer+ch+1]-1;\n\t\t\t\t\tBinPointerbuffer[Binpointer+ch]--;\n\t\t\t\t}\n\t\t\t\t//LMS-typeを基にL-typeを入れていく\n\t\t\t\tfor(int i=0;i<CharNum;i++){\n\t\t\t\t\tBinPointerbuffer[Binpointer+i] = Binbuffer[Binpointer+i];\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<SLength;i++){\n\t\t\t\t\tint v = Ansbuffer[Spointer+i];\n\t\t\t\t\tif(v > 0){\n\t\t\t\t\t\tif(!SLbuffer[Spointer+v-1]){\n\t\t\t\t\t\t\tint ch = Sbuffer[Spointer+v-1];\n\t\t\t\t\t\t\tAnsbuffer[Spointer+BinPointerbuffer[Binpointer+ch]] = v-1;\n\t\t\t\t\t\t\tBinPointerbuffer[Binpointer+ch]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//L-typeを基にS-typeを入れていく\n\t\t\t\tfor(int i=0;i<CharNum;i++){\n\t\t\t\t\tBinPointerbuffer[Binpointer+i] = Binbuffer[Binpointer+i+1]-1;\n\t\t\t\t}\n\t\t\t\tfor(int i=SLength-1;i>=0;i--){\n\t\t\t\t\tint v = Ansbuffer[Spointer+i];\n\t\t\t\t\tif(v != 0){\n\t\t\t\t\t\tif(SLbuffer[Spointer+v-1]){\n\t\t\t\t\t\t\tint ch = Sbuffer[Spointer+v-1];\n\t\t\t\t\t\t\tAnsbuffer[Spointer+BinPointerbuffer[Binpointer+ch]] = v-1;\n\t\t\t\t\t\t\tBinPointerbuffer[Binpointer+ch]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//LMS-typeの順番が間違っている可能性のある時\n\t\t\t\tif(SameTopCharacterLMSExist){\n\t\t\t\t\tint newSpointer = Spointer+SLength;\n\t\t\t\t\t//新しい文字列を作る\n\t\t\t\t\tint beforeLMSString = -1;\n\t\t\t\t\tint LMSStringKind = -1;\n\t\t\t\t\tfor(int i=0;i<SLength;i++){\n\t\t\t\t\t\tint v = Ansbuffer[Spointer+i];\n\t\t\t\t\t\tif(rLMSbuffer[Spointer+v] != 0){\n\t\t\t\t\t\t\tint afterLMSString = rLMSbuffer[Spointer+v]-1;\n\t\t\t\t\t\t\t//種類が違うか判断　最初はダミー文字で他と一致しないことに注意\n\t\t\t\t\t\t\tif(LMSStringKind > 0){\n\t\t\t\t\t\t\t\tint beforeLMSStringF = LMSbuffer[LMSpointer+beforeLMSString];\n\t\t\t\t\t\t\t\tint beforeLMSStringT = LMSbuffer[LMSpointer+beforeLMSString+1];\n\t\t\t\t\t\t\t\tint afterLMSStringF = LMSbuffer[LMSpointer+afterLMSString];\n\t\t\t\t\t\t\t\tint afterLMSStringT = LMSbuffer[LMSpointer+afterLMSString+1];\n\t\t\t\t\t\t\t\tif(beforeLMSStringT - beforeLMSStringF == afterLMSStringT - afterLMSStringF){\n\t\t\t\t\t\t\t\t\tint c = beforeLMSStringT - beforeLMSStringF;\n\t\t\t\t\t\t\t\t\tfor(int i=0;i<=c;i++){\n\t\t\t\t\t\t\t\t\t\tif(Sbuffer[Spointer+beforeLMSStringF+i] != Sbuffer[Spointer+afterLMSStringF+i]){\n\t\t\t\t\t\t\t\t\t\t\tLMSStringKind++;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tLMSStringKind--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tLMSStringKind++;\n\t\t\t\t\t\t\tSbuffer[newSpointer+rLMSbuffer[Spointer+v]-1] = LMSStringKind;\n\t\t\t\t\t\t\tbeforeLMSString = afterLMSString;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tLMSStringKind++;\n\t\t\t\t\tWorkInformation[WorkPointer+1] = make_tuple(Spointer,Binpointer,LMSpointer,CharNum,SLength,LMSnum);\n\t\t\t\t\tWorkInformation[WorkPointer+2] = make_tuple(Spointer+SLength,Binpointer+CharNum+1,LMSpointer+LMSnum,LMSStringKind,LMSnum,0);\n\t\t\t\t\tWorkPointer += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//再帰から戻った後\n\t\t\telse{\n\t\t\t\tint newSpointer = Spointer+SLength;\n\t\t\t\t//Ansbufferを初期化\n\t\t\t\tfor(int i=Spointer;i<newSpointer;i++){\n\t\t\t\t\tAnsbuffer[i] = -1;\n\t\t\t\t}\n\t\t\t\t//LMS-typeをそれぞれのbinごとに後ろから入れていく\n\t\t\t\tfor(int i=0;i<CharNum;i++){\n\t\t\t\t\tBinPointerbuffer[Binpointer+i] = Binbuffer[Binpointer+i+1]-1;\n\t\t\t\t}\n\t\t\t\tfor(int i=LMSnum-1;i>=0;i--){\n\t\t\t\t\tint ch = Sbuffer[Spointer+LMSbuffer[LMSpointer+Ansbuffer[newSpointer+i]]];\n\t\t\t\t\tAnsbuffer[Spointer+BinPointerbuffer[Binpointer+ch]] = LMSbuffer[LMSpointer+Ansbuffer[newSpointer+i]];\n\t\t\t\t\tBinPointerbuffer[Binpointer+ch]--;\n\t\t\t\t}\n\t\t\t\t//LMS-typeを基にL-typeを入れていく\n\t\t\t\tfor(int i=0;i<CharNum;i++){\n\t\t\t\t\tBinPointerbuffer[Binpointer+i] = Binbuffer[Binpointer+i];\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<SLength;i++){\n\t\t\t\t\tint v = Ansbuffer[Spointer+i];\n\t\t\t\t\tif(v > 0){\n\t\t\t\t\t\tif(!SLbuffer[Spointer+v-1]){\n\t\t\t\t\t\t\tint ch = Sbuffer[Spointer+v-1];\n\t\t\t\t\t\t\tAnsbuffer[Spointer+BinPointerbuffer[Binpointer+ch]] = v-1;\n\t\t\t\t\t\t\tBinPointerbuffer[Binpointer+ch]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//L-typeを基にS-typeを入れていく\n\t\t\t\tfor(int i=0;i<CharNum;i++){\n\t\t\t\t\tBinPointerbuffer[Binpointer+i] = Binbuffer[Binpointer+i+1]-1;\n\t\t\t\t}\n\t\t\t\tfor(int i=SLength-1;i>=0;i--){\n\t\t\t\t\tint v = Ansbuffer[Spointer+i];\n\t\t\t\t\tif(v != 0){\n\t\t\t\t\t\tif(SLbuffer[Spointer+v-1]){\n\t\t\t\t\t\t\tint ch = Sbuffer[Spointer+v-1];\n\t\t\t\t\t\t\tAnsbuffer[Spointer+BinPointerbuffer[Binpointer+ch]] = v-1;\n\t\t\t\t\t\t\tBinPointerbuffer[Binpointer+ch]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSuffixArray.resize(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tSuffixArray[i] = Ansbuffer[i+1];\n\t\t}\n\t}\n\tvoid CalculateLCP(){\n\t\tif(SuffixArray.size() == 0){\n\t\t\tSAIS();\n\t\t}\n\t\tvector<int> rSuffixrray(N);\n\t\tLCPArray.resize(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\trSuffixrray[SuffixArray[i]] = i;\n\t\t}\n\t\tint lcp = 0;\n\t\tfor(int p=0;p<N;p++){\n\t\t\tint i = rSuffixrray[p];\n\t\t\tif(i > 0){\n\t\t\t\twhile(p+lcp < N && SuffixArray[i-1]+lcp < N && S[p+lcp] == S[SuffixArray[i-1]+lcp]){\n\t\t\t\t\tlcp++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlcp = 0;\n\t\t\t}\n\t\t\tLCPArray[i] = lcp;\n\t\t\tif(lcp > 0){\n\t\t\t\tlcp--;\n\t\t\t}\n\t\t}\n\t\tLCARMQ.Init(N,LCPArray);\n\t}\n\t//SuffixArray[x]とSuffixArray[y]のLCA x < y\n\tint LCP(int x,int y){\n\t\treturn LCARMQ.GetMin(x+1,y);\n\t}\n\tint find(string s){\n\t\treturn find(StringToIntArray(s));\n\t}\n\tint find(vector<int> key){\n\t\tint M = key.size();\n\t\tint bf = 0;\n\t\tint bl = N-1;\n\t\t//どこまでkeyと一致していると言えるか\n\t\tint bfkey = 0;//これはbfの1個左と\n\t\tint blkey = 0;\n\t\twhile(blkey < M && SuffixArray[bl]+blkey < N && key[blkey] == S[SuffixArray[bl]+blkey]){\n\t\t\tblkey++;\n\t\t}\n\t\tif(blkey == M){\n\t\t\treturn SuffixArray[bl];\n\t\t}\n\t\tif(SuffixArray[bl]+blkey == N || S[SuffixArray[bl]+blkey] < key[blkey]){\n\t\t\treturn -1;\n\t\t}\n\t\twhile(bf != bl){\n\t\t\tint bc = (bf+bl)/2;\n\t\t\tint bfbc = LCP(bf-1,bc);\n\t\t\tint blbc = LCP(bc,bl);\n\t\t\tif(bfbc >= blbc){\n\t\t\t\tif(bfkey < bfbc){\n\t\t\t\t\tbf = bc+1;\n\t\t\t\t}\n\t\t\t\telse if(bfkey > bfbc){\n\t\t\t\t\tbl = bc;\n\t\t\t\t\tblkey = bfbc;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint bckey = bfkey;\n\t\t\t\t\twhile(bckey < M && SuffixArray[bc]+bckey < N && key[bckey] == S[SuffixArray[bc]+bckey]){\n\t\t\t\t\t\tbckey++;\n\t\t\t\t\t}\n\t\t\t\t\tif(bckey == M){\n\t\t\t\t\t\treturn SuffixArray[bc];\n\t\t\t\t\t}\n\t\t\t\t\tif(SuffixArray[bc]+bckey == N || S[SuffixArray[bc]+bckey] < key[bckey]){\n\t\t\t\t\t\tbf = bc+1;\n\t\t\t\t\t\tbfkey = bckey;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tbl = bc;\n\t\t\t\t\t\tblkey = bckey;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(blkey < blbc){\n\t\t\t\t\tbl = bc;\n\t\t\t\t}\n\t\t\t\telse if(blkey > blbc){\n\t\t\t\t\tbf = bc+1;\n\t\t\t\t\tbfkey = blbc;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint bckey = blkey;\n\t\t\t\t\twhile(bckey < M && SuffixArray[bc]+bckey < N && key[bckey] == S[SuffixArray[bc]+bckey]){\n\t\t\t\t\t\tbckey++;\n\t\t\t\t\t}\n\t\t\t\t\tif(bckey == M){\n\t\t\t\t\t\treturn bc;\n\t\t\t\t\t}\n\t\t\t\t\tif(SuffixArray[bc]+bckey == N || S[SuffixArray[bc]+bckey] < key[bckey]){\n\t\t\t\t\t\tbf = bc+1;\n\t\t\t\t\t\tbfkey = bckey;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tbl = bc;\n\t\t\t\t\t\tblkey = bckey;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(blkey == M){\n\t\t\treturn SuffixArray[bl];\n\t\t}\n\t\telse{\n\t\t\treturn -1;\n\t\t}\n\t}\n};\nvoid Calc(){\n\tstring s = res();\n\tvector<int> ss(s.length());\n\tfor(int i=0;i<s.length();i++){\n\t\tif('a' <= s[i] && s[i] <= 'z'){\n\t\t\tss[i] = s[i] - 'a' + 10;\n\t\t}\n\t\telse{\n\t\t\tss[i] = s[i] - '0';\n\t\t}\n\t}\n\tStringManager S(ss,36);\n\tint Q = rei();\n\tS.CalculateLCP();\n\tfor(int query=0;query<Q;query++){\n\t\tstring qs = res();\n\t\tvector<int> qss(qs.length());\n\t\tfor(int i=0;i<qs.length();i++){\n\t\t\tif('a' <= qs[i] && qs[i] <= 'z'){\n\t\t\t\tqss[i] = qs[i] - 'a' + 10;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tqss[i] = qs[i] - '0';\n\t\t\t}\n\t\t}\n\t\tif(S.find(qss) == -1){\n\t\t\tcout << \"0\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"1\" << endl;\n\t\t}\n\t}\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstring S; string U;\nvector<string>T; int N;\nint main() {\n\tcin >> S >> N;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tint L = S.size() - i;\n\t\tif (L > 1000)L = 1000;\n\t\tT.push_back(S.substr(i, L));\n\t}\n\tsort(T.begin(), T.end());\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> U;\n\t\tint pos = lower_bound(T.begin(), T.end(), U) - T.begin();\n\t\tstring V;\n\t\tif (pos < T.size() && U.size() <= T[pos].size()) { V = T[pos].substr(0, U.size()); }\n\t\tif (U == V) { cout << \"1\" << endl; }\n\t\telse { cout << \"0\" << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntemplate<typename S_Iter, typename SA_Iter>\nvoid induceSAL(S_Iter S_begin, S_Iter S_end, SA_Iter SA_begin, SA_Iter SA_end, const vector<bool> &t, uint32_t buckets_size) {\n    int32_t n = S_end - S_begin;\n    vector<int32_t> buckets(buckets_size+1, 0);\n    for (auto itr = S_begin; itr != S_end; itr++) buckets[*itr]++;\n\n    int32_t sum = 0;\n    for (uint32_t i = 0; i < buckets.size(); i++) {\n        sum += buckets[i];\n        buckets[i] = sum - buckets[i];\n    }\n\n    if (!t[n-1]) SA_begin[buckets[S_begin[n-1]]++] = n-1;\n\n    for (int32_t i = 0; i < n; i++) {\n        if (SA_begin[i] > 0 && !t[SA_begin[i]-1]) SA_begin[buckets[S_begin[SA_begin[i]-1]]++] = SA_begin[i]-1;\n    }\n\n    return;\n}\n\ntemplate<typename S_Iter, typename SA_Iter>\nvoid induceSAS(S_Iter S_begin, S_Iter S_end, SA_Iter SA_begin, SA_Iter SA_end, const vector<bool> &t, uint32_t buckets_size) {\n    int32_t n = S_end - S_begin;\n    vector<int32_t> buckets(buckets_size+1, 0);\n    for (auto itr = S_begin; itr != S_end; itr++) buckets[*itr]++;\n    partial_sum(buckets.begin(), buckets.end(), buckets.begin());\n\n    for (int32_t i = n-1; i > 0; i--) {\n        if (SA_begin[i] > 0 && t[SA_begin[i]-1]) SA_begin[--buckets[S_begin[SA_begin[i]-1]]] = SA_begin[i]-1;\n    }\n\n    return;\n}\n\ntemplate<typename S_Iter, typename SA_Iter>\nvoid SA_IS(S_Iter S_begin, S_Iter S_end, SA_Iter SA_begin, SA_Iter SA_end, uint32_t buckets_size) {\n    int32_t n = S_end - S_begin;\n    fill(SA_begin, SA_end, -1);\n\n    // classify the type of each character\n    // true <=> S-type\n    vector<bool> t(n);\n    for (int32_t i = n; i >= 0; i--) {\n        t[i] = S_begin[i] < S_begin[i+1] || (S_begin[i] == S_begin[i+1] && t[i+1]);\n    }\n\n    auto is_lms = [&t](int32_t i){return i > 0 && !t[i-1] && t[i];};\n\n    // sort all the S-substrings\n    vector<int32_t> buckets(buckets_size+1, 0);\n    for (auto itr = S_begin; itr != S_end; itr++) buckets[*itr]++;\n    partial_sum(buckets.begin(), buckets.end(), buckets.begin());\n    for (int32_t i = 0; i < n; i++) {\n        if (is_lms(i)) SA_begin[--buckets[S_begin[i]]] = i;\n    }\n    induceSAL(S_begin, S_end, SA_begin, SA_end, t, buckets_size);\n    induceSAS(S_begin, S_end, SA_begin, SA_end, t, buckets_size);\n\n    // compact all the sorted substrings into the first nl items of SA\n    auto lms_end = remove_if(SA_begin, SA_end, [is_lms](int32_t x){return !is_lms(x);});\n    fill(lms_end, SA_end, -1);\n    int32_t nl = lms_end - SA_begin;\n\n    // find the lexicographic names of substrings\n    int32_t name = 0;\n    for (auto itr = SA_begin; itr != lms_end; itr++) {\n        if (itr == SA_begin) {\n            lms_end[*itr/2] = name;\n        } else {\n            int32_t cur = *itr, prev = *(itr - 1);\n            bool miss = S_begin[cur] != S_begin[prev] || t[cur] != t[prev];\n            if (!miss) do {\n                ++cur; ++prev;\n                miss |= cur == n ||\n                        prev == n ||\n                        S_begin[cur] != S_begin[prev] ||\n                        t[cur] != t[prev];\n            } while (!miss && !(cur > 0 && !t[cur-1] && t[cur]) && !(prev > 0 && !t[prev-1] && t[prev]));\n\n            if (miss) ++name;\n            lms_end[*itr/2] = name;\n        }\n    }\n    remove_if(reverse_iterator<decltype(SA_end)>(SA_end), reverse_iterator<decltype(SA_begin)>(SA_begin) - nl, [](int32_t i) {return i < 0;});\n\n    // solve the reduced problem\n    auto S1_begin = SA_end - nl, S1_end = SA_end;\n    auto SA1_begin = SA_begin, SA1_end = SA_begin + nl;\n    if (name + 1 < nl) {\n        SA_IS(S1_begin, S1_end, SA1_begin, SA1_end, nl);\n    } else {\n        for (int32_t i = 0; i < nl; i++) {\n            SA1_begin[S1_begin[i]] = i;\n        }\n    }\n\n    // induce the result for the original problem\n    fill(buckets.begin(), buckets.end(), 0);\n    for (auto itr = S_begin; itr != S_end; itr++) buckets[*itr]++;\n    partial_sum(buckets.begin(), buckets.end(), buckets.begin());\n\n    for (int32_t i = 1, j = 0; i < n; i++) {\n        if (is_lms(i)) S1_begin[j++] = i;\n    }\n    for (int32_t i = 0; i < nl; i++) SA1_begin[i] = S1_begin[SA1_begin[i]];\n    fill(lms_end, SA_end, -1);\n    for (int32_t i = nl-1; i >= 0; i--) {\n        int32_t j = SA_begin[i];\n        SA_begin[i] = -1;\n        SA_begin[--buckets[S_begin[j]]] = j;\n    }\n    induceSAL(S_begin, S_end, SA_begin, SA_end, t, buckets_size);\n    induceSAS(S_begin, S_end, SA_begin, SA_end, t, buckets_size);\n\n    return;\n}\n\nint main() {\n    char tmp[1000000];\n    scanf(\"%s\", tmp);\n    string T = tmp;\n\n    int32_t Q;\n    scanf(\"%d\", &Q);\n\n    vector<int32_t> SA(T.length());\n    SA_IS(T.begin(), T.end(), SA.begin(), SA.end(), 'z');\n\n    for (int32_t i = 0; i < Q; i++) {\n        char tmp[1000];\n        scanf(\"%s\", tmp);\n        string P = tmp;\n\n        auto itr_lb = lower_bound(SA.begin(), SA.end(), 0, [&T, &P](uint32_t i, uint32_t j) {return T.compare(i, T.length()-i, P) < 0;});\n\n        if (*itr_lb <= T.length() - P.length() && T.substr(*itr_lb, P.length()) == P) {\n            printf(\"1\\n\");\n        } else {\n            printf(\"0\\n\");\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <numeric>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, Q, sa[1000009]; string s; unsigned long long p[1000009], h[1000009];\nint lcp(int x, int y) {\n\tint l = 0, r = min(N - x, N - y) + 1;\n\twhile (r - l > 1) {\n\t\tint m = (l + r) >> 1;\n\t\tif (h[x + m] - x[h] * p[m] == h[y + m] - h[y] * p[m]) l = m;\n\t\telse r = m;\n\t}\n\treturn l;\n}\nbool compare_sa(int i, int j) {\n\tint k = lcp(i, j);\n\tif (i + k >= N) return true;\n\tif (j + k >= N) return false;\n\treturn s[i + k] <= s[j + k];\n}\nbool contain(string &t) {\n\tint a = 0, b = N;\n\twhile (b - a > 1) {\n\t\tint c = (a + b) >> 1;\n\t\tif (s.compare(sa[c], t.size(), t) < 0) a = c;\n\t\telse b = c;\n\t}\n\treturn s.compare(sa[b], t.size(), t) == 0;\n}\nint main() {\n\tcin >> s >> Q; N = s.size();\n\tp[0] = 1;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tp[i + 1] = p[i] * 257;\n\t\th[i + 1] = h[i] * 257 + s[i];\n\t}\n\tiota(sa, sa + N + 1, 0);\n\tsort(sa, sa + N + 1, compare_sa);\n\tfor (int i = 0; i < Q; i++) {\n\t\tstring t; cin >> t;\n\t\tcout << contain(t) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int i, const int j) { \n    int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n  \n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  \n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  \n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\n\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint Rank[1000005];\nint Tmp[1000005];\nint kc,len;\n\nbool compare_sa(int i,int j){\n  return\n    Rank[i]!=Rank[j]?\n    Rank[i]<Rank[j]:\n    (i+kc<=len?Rank[i+kc]:-1)<(j+kc<=len?Rank[j+kc]:-1);\n}\n\nvoid construct_sa(char* S,int *sa){\n  len=strlen(S);\n  for(int i=0;i<=len;i++){\n    sa[i]=i;\n    Rank[i]=i<len?S[i]:-1;\n  }\n  for(kc=1;kc<=len;kc*=2){\n    sort(sa,sa+len+1,compare_sa);\n    Tmp[sa[0]]=0;\n    for(int i=1;i<=len;i++){\n      Tmp[sa[i]]=Tmp[sa[i-1]]+compare_sa(sa[i-1],sa[i]);\n    }\n    for(int i=0;i<=len;i++)Rank[i]=Tmp[i];\n  }\n}\n\n\nint n,m;\nchar str[1000005];\nchar t[1000005];\nint sa[1000005];\n\nint main(){\n  scanf(\"%s\",str);\n  n=strlen(str);\n  construct_sa(str,sa);\n  scanf(\"%d\",&m);\n  while(m--){\n    scanf(\"%s\",t);\n    int k=strlen(t);\n    int l=0,r=n+1,m;\n    while(l+1<r){\n      m=(l+r)/2;\n      if(strncmp(str+sa[m],t,k)<=0)l=m;\n      else r=m;\n    }\n    printf(\"%d\\n\",(strncmp(str+sa[l],t,k)==0));\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) { \n    //const int k=lcp(i,j);\n    const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    if(i+k>=n)return 1;\n    if(j+k>=n)return 0;\n    return s[i+k] <= s[j+k];\n    //return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  /*\n  inline int lcp(const int i, const int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n  */\n  inline int lcp2(const int& i, const int& j, const int& l, const int& r){\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\nif(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nnamespace SA{\n    const int MAX=1000000;\n    int N,K;\n    int tmp[MAX+1],rank[MAX+1];\n    bool compare_sa(int i,int j){\n        if(rank[i]!=rank[j])return rank[i]<rank[j];\n        else{\n            int ri=(i+K<=N)?rank[i+K]:-1;\n            int rj=(j+K<=N)?rank[j+K]:-1;\n            return ri<rj;\n        }\n    }\n\n    vector<int> construct_sa(string S){\n        N=S.size();\n        vector<int>sa(N+1);\n        for(int i=0;i<=N;i++)sa[i]=i;\n        for(int i=0;i<=N;i++){\n            rank[i]=i==N?-1:S[i];\n        }\n\n        for(K=1;K<=N;K*=2){\n            sort(sa.begin(),sa.end(),compare_sa);\n            tmp[sa[0]]=0;\n            for(int i=1;i<=N;i++){\n                tmp[sa[i]]=tmp[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n            }\n            for(int i=0;i<=N;i++)rank[i]=tmp[i];\n        }\n        return sa;\n    }\n}\n\n\nbool exist(string &S,vint &sa,string &T){\n    int a=0,b=S.size();\n    while(b-a>1){\n        int c=(a+b)/2;\n        if(S.substr(sa[c],S.size()-sa[c])<T)a=c;\n        else b=c;\n    }\n    return S.substr(sa[b],min(S.size()-sa[b],T.size()))==T;\n}\n\nbool contain(string &S,vint &sa,string &T){\n    int a=0,b=S.size();\n    while(b-a>1){\n        int c=(a+b)/2;\n        if(S.compare(sa[c],T.size(),T)<0)a=c;\n        else b=c;\n    }\n    return S.compare(sa[b],T.size(),T)==0;\n}\n\nsigned main(){\n    string S;\n    vint sa;\n    int Q;\n    cin>>S;\n    sa=SA::construct_sa(S);\n    cin>>Q;\n\n    while(Q--){\n        string T;cin>>T;\n        if(contain(S,sa,T))cout<<1<<endl;\n        else cout<<0<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<complex>\n#include<typeinfo>\nusing namespace std;\n\nstruct Node{\n    Node* child[256];\n    vector<int> output;\n    Node(){\n        memset(child, 0, sizeof(child));\n    }\n};\n\nvoid concatIntVector(vector<int> &v1, vector<int> &v2){\n    v1.insert(v1.begin(), v2.begin(), v2.end());\n}\n\nNode* makePMA(vector<string> &P){\n    Node* root = new Node;\n    root->child[0] = 0;\n    Node* now;\n    for (int i=0;i<P.size();i++){\n        now = root;\n        for (int j=0;j<P[i].size();j++){\n            if(now->child[(int)P[i][j]] == 0){\n                now->child[(int)P[i][j]] = new Node;\n            }\n            now = now->child[(int)P[i][j]];\n        }\n        now->output.push_back(i);\n    }\n\n    queue<Node*> qu;\n    for(int i=1;i<256;i++){\n        if(root->child[i]){\n            root->child[i]->child[0] = root;\n            qu.push(root->child[i]);\n        }else{\n            root->child[i] = root;\n        }\n    }\n    while(!qu.empty()){\n        now = qu.front();qu.pop();\n        for(int i=1;i<256;i++){\n            if(now->child[i]){\n                Node* fail = now->child[0];\n                while(!fail->child[i]){\n                    fail = fail->child[0];\n                }\n                now->child[i]->child[0] = fail->child[i];\n                concatIntVector(now->child[i]->output, fail->child[i]->output);\n                qu.push(now->child[i]);\n            }\n        }\n    }\n    return root;\n}\n\n\nvoid searchPMA(Node* &root, string &T, vector<bool> &res){\n    Node* now = root;\n    for (int i=0;i<T.size();i++){\n        while(!now->child[(int)T[i]]){\n            now = now->child[0];\n        }\n        now = now->child[(int)T[i]];\n        for (int j=0;j<(now->output).size();j++){\n            res[(now->output)[j]] = true;\n        }\n    }\n    return;\n}\n\nint main(){\n    string T;\n    cin >> T;\n    int Q;\n    cin >> Q;\n    vector<string> P;\n    string tmp;\n    for (int i=0;i<Q;i++){\n        cin >> tmp;\n        P.push_back(tmp);\n    }\n    Node* root = makePMA(P);\n    vector<bool> res(Q, false);\n    searchPMA(root, T, res);\n    for (int i=0;i<res.size();i++){\n        cout << res[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(string s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  bool operator()(int i, int j) { \n    int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  \n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  \n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  sort(ALL(sa),rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  while(n--){\n    scanf(\"%s\",&t[0]);\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string t, p;\n    int n;\n    getline(cin, t);\n    int lt=t.length();\n    cin>>n;\n    cin.ignore();\n    for(int i=0; i<n; i++) {\n        getline(cin, p);\n        int lp=p.length();\n        int j;\n        for(j=0; j<=lt-lp; j++) {\n            if(memcmp(t.data()+j, p.data(), lp)==0) {\n                cout<<\"1\\n\";\n                break;\n            }\n        }\n        if(j>lt-lp) cout<<\"0\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <boost/algorithm/searching/knuth_morris_pratt.hpp>\n\nint main(){\n    size_t pos;\n    int n;\n\tstd::string T;\n\tstd::cin >> T;\n\tstd::cin >> n;\n    std::string T = \"BANNANABANANAN\";\n    for(int i=0;i<n;i++){\n    \tstd::string P;\n    \tcin >> P;\n    \tstd::string::const_iterator search_result;\n    \tsearch_result = boost::algorithm::boyer_moore_search(T.begin(), T.end(),P.begin(), P.end());\n    \tif(search_result - T.begin() >= 0){\n    \t\tprintf(\"1\\n\");\n\t\t}else{\n   \t\t \tprintf(\"0\\n\");\n   \t\t}\n   \t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string& S):S(S){init();}\n  void init(){\n    n=S.length();\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    sa.clear();\n    sa.resize(n+1,0);\n    S.push_back('$');\n    iota(sa.begin(),sa.end(),0);\n    sort(sa.begin(),sa.end(),\n\t [&](int a,int b){\n\t   if(S[a]==S[b]) return a>b;\n\t   return S[a]<S[b];\n\t });\n    vector<int> c(n+1,0),r(n+1),cnt(n+1),s(n+1);\n    for(int i=0;i<=n;i++) r[i]=S[i];\n    for(int len=1;len<=n;len*=2){\n      for(int i=0;i<=n;i++){\n\t c[sa[i]]=\n\t   i>0 &&\n\t   r[sa[i-1]]==r[sa[i]] &&\n\t   sa[i-1]+len<=n &&\n\t   r[sa[i-1]+len/2]==r[sa[i]+len/2] ?\n\t   c[sa[i-1]]:i;\n      }\n      iota(cnt.begin(),cnt.end(),0);\n      copy(sa.begin(),sa.end(),r.begin());\n      for(int i=0;i<=n;i++){\n\tint s1=r[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n      c.swap(r);\n    }\n    S.pop_back();\n  }\n  \n  // O(|T|*log|S|)\n  pair<int,int> count(string& T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\tif(S.compare(sa[c],tl,T)<0||\n\t   (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n\telse b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return make_pair(0,0);\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return make_pair(b[0],a[1]+1);\n  }\n  \n  bool contains(string& T){\n    auto tmp=count(T);\n    return tmp.first!=tmp.second;\n  }\n  \n  void build_lcp(){\n    lcp.clear();\n    lcp.resize(n+1,0);\n    vector<int> r2(n+1);\n    for(int i=0;i<=n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  pair<int,int> count2(string& T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return make_pair(0,0);\n\n    return make_pair(b[0],a[1]+1);\n  }\n\n  bool contains2(string& T){\n    auto tmp=count2(T);\n    return tmp.first!=tmp.second;\n  }\n};\n//END CUT HERE\n\n\n//*//\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%d\\n\",sa.contains2(P));\n    //assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n//*/\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/\n\n/*/\nchar buf[1145141];\nsigned main(){\n  int n;\n  scanf(\"%d\",&n);\n  int m;\n  scanf(\"%d\",&m);\n  scanf(\"%s\",buf);\n  string s(buf);\n  SuffixArray sa(s);\n  string t=\"I\";\n  for(int i=0;i<n;i++) t=t+\"OI\";\n  auto tmp=sa.count(t);\n  printf(\"%d\\n\",tmp.second-tmp.first);\n  return 0;\n}\n//*/\n/*\n  verified on 2017/10/20\nhttp://joi2009ho.contest.atcoder.jp/tasks/joi2009ho_a\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring S,T;\nstring V[100000][1000];\nint main(){\n\tint q,a,b,c;\n\tcin>>S;\n\tb=S.size();\n\ta=min(b,100);\n\tfor(int i=1;i<100;i++){\n\t\tfor(int j=0;j<=b-i;j++){\n\t\t\tV[j][i]=S.substr(j,i);\n\t\t}\n\t}\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>T;\n\t\tc=T.size();\n\t\tfor(int j=0;j<=b-c;j++){\n\t\t\tif(V[j][c]==T){\n\t\t\t\tcout<<\"1\"<<endl;\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t}\n\t\tcout<<\"0\"<<endl;\n\t\tExit:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef debug\n#include <chrono>\n#endif\n\n#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstring> //memcpy\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <map>\n//#include <unordered_map> //hash func.\n#include <fstream> //ifstream, ofstream\n\n//#define NDEBUG //If NDEBUG is defined before #include <cassert>, assert will be ignored. You had better define NDEBUG when u submit the code.\n#include <cassert> //assert\n\nusing namespace std;\n\n\n#define dout cout\n//If u wanna output to a text file instead of standard output, plz define OUTPUTFILE.\n//#define OUTPUTFILE \"output.txt\" //*******************************************************************************************************************************************\n#ifdef OUTPUTFILE\n#define dout outputfile\nofstream outputfile(OUTPUTFILE);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n\n#define din cin\n//If u wanna input from a text file instead of standard input, plz define INPUTFROMTEXTFILE???.\n//#define INPUTFILE \"input.txt\" //*******************************************************************************************************************************************\n#ifdef INPUTFILE\n#define din inputfile\nifstream inputfile(INPUTFILE);\n#endif\n\n#define scan(A) scanf(\"%d\", &(A))\n#define disp(A) dout << #A << \" = \" << setw(3) << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \"\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n//#define dispAll(A,n) cout << #A << \" = \"; rep(j, 0, (n)) {cout << setw(3) << A[j] << \" \";} cout << endl\n\n#define sign(x) ((x)>0)-((x)<0) //x<0: -1, x=0: 0, x>0: +1\n#define p(i) (i)/2\n#define l(i) (i)*2\n#define r(i) (i)*2+1\n\nint dx[] = {1,-1, 0, 0, 1, 1,-1,-1}; //???????????????????????????????¨??????????????????????????????????\nint dy[] = {0, 0,-1, 1,-1, 1, 1,-1};\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef unsigned long ull;\n\nconst int INF = (int)2e9+10;\nconst ll INF_LL = (ll)9e18-1LL; //Be careful for overflow.\nconst ull INF_ULL = (ull)1e19-1ULL;\nconst int NONE = -1;\nconst ll MOD = (ll)1e9+7; //??§???????´???°?????£??¨??¨????????°????????????10???7??????\n\nconst int N_MAX = 1000010; //num of vertex or element\nconst int M_MAX = 100000; //num of edge\nconst int DATA_MAX = 1000000010;\n\nint N;\n\nchar T[N_MAX];\n\nconst int P_LEN_MAX = 1010;\nchar P[10010][P_LEN_MAX];\n\nint hashTable_T[P_LEN_MAX][N_MAX]; //????????????lenP????????????T??????????????\\???\n\n\nint main() {\n    \n    //cin, cout????????????  ?????¨??????cin?????????????????¨??¨cin??§???scanf?????????????????¨??¨scanf??§??±?????????????????????\n    cin.tie(0); //cin??¨cout??????????????????\n    ios::sync_with_stdio(false); //iostream??¨stdio??????????????????\n    \n    //read input data\n    int i = 0;\n    while(1) {\n        scanf(\"%c\", &T[i]);\n        if(T[i]=='\\n') { T[i] = '\\0'; break; }\n        else i++;\n    }\n    \n    int Q;\n    scanf(\"%d \", &Q);\n    rep(i,0,Q) {\n        int j = 0;\n        while(1) {\n            scanf(\"%c\", &P[i][j]);\n            if(P[i][j]=='\\n') { P[i][j] = '\\0'; break; }\n            else j++;\n        }\n    }\n    \n#ifdef debug\n    disp(T);\n    disp(strlen(T));\n    rep(i,0,Q) { disp(P[i]); disp(strlen(P[i])); }\n#endif\n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //start timer\n    auto startTime = chrono::system_clock::now();\n#endif\n    //------------------------------------------------------------------------------------------\n    \n    \n    \n    //find P[i] among T by Rabin-Karp Algorithm (using Rolling Hash)\n    \n    int lenT = strlen(T);\n    const int B = 10007;\n    \n    //calc. hashTable_T[][]\n    rep(lenP,1,P_LEN_MAX+1) {\n        \n        int BpowLenP = 1;\n        rep(k,0,lenP) BpowLenP *= B;\n        \n        hashTable_T[lenP][0] = 0;\n        rep(k,0,lenP) hashTable_T[lenP][0] = hashTable_T[lenP][0] * B + T[k];\n        \n        rep(j,1,lenT-lenP+1) {\n            hashTable_T[lenP][j] = hashTable_T[lenP][j-1] * B - T[j-1] * BpowLenP + T[j-1+lenP];\n        }\n    }\n    \n    \n    rep(i,0,Q) {\n        int lenP = strlen(P[i]);\n        \n        int hashP = 0;\n        rep(k,0,lenP) hashP = hashP * B + P[i][k];\n        \n        \n        bool found = false;\n        rep(j,0,lenT-lenP+1) {\n            if(hashP == hashTable_T[lenP][j]) {\n                found = true;\n                break;\n            }\n        }\n        \n        printf(\"%d\\n\", found);\n        \n    }\n\n    \n    \n    \n    \n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //stop timer\n    auto endTime = chrono::system_clock::now();\n    auto dur = endTime - startTime;\n    auto msec = chrono::duration_cast<chrono::milliseconds>(dur).count();\n    dout << fixed << setprecision(4) << (double)msec/1000 << \" sec \\n\";\n#endif\n    //------------------------------------------------------------------------------------------\n    \n#ifdef INPUTFILE\n    inputfile.close();\n#endif\n    \n#ifdef OUTPUTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    //const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    //const int k=lcp2(i,j,0,(n-max(i,j))*2+1);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  inline bool cmp(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    //int l=0,r=min(n-i,n-j)+1;\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n  \n  /*\n  inline int lcp2(const int& i, const int& j, const int& l, const int& r){\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n  */\n};\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  const int n = SZ(a);\n  if(n>1){\n    vector<int> b(a.begin(), a.begin()+n/2);\n    vector<int> c(a.begin()+n/2, a.end());\n    mergesort(b,rh);\n    mergesort(c,rh);\n    for (int i=0,j=0,k=0;i<n;i++){\n      if(k == SZ(c))a[i]=b[j++];\n      else if(j==SZ(b))a[i]=c[k++];\n      else if(rh.cmp(b[j],c[k]))a[i]=b[j++];\n      else a[i] = c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  //sort(ALL(sa),rh);\n  mergesort(sa,rh);\n  //if(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    int c=(a+b)/2;\n    if(S.compare(sa[c],T.length(),T)<0 )a=c;\n    else b=c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\n#define NUM 48\nusing namespace std;\n\nint T_char_count[128] = {0},P_char_count[128];\nint T_Chain[128][128];\n\nclass LocRecord{\n\npublic:\n\t//?????¢???????¢????\n\tLocRecord(){\n\t\tlocationTable = new int**[128];\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tlocationTable[i] = new int*[128];\n\t\t\tfor(int k = 0; k < 128; k++){\n\t\t\t\tif(T_Chain[i][k] > 0){\n\t\t\t\t\tlocationTable[i][k] = new int[T_Chain[i][k]+1];\n\t\t\t\t\tfor(int p = 0; p < T_Chain[i][k]+1; p++){\n\t\t\t\t\t\tlocationTable[i][k][p] = -1;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tlocationTable[i][k] = new int[2];\n\t\t\t\t\tfor(int p = 0; p < 2; p++){\n\t\t\t\t\t\tlocationTable[i][k][p] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinit();\n\t}\n\n\t//-1?????£??\\\n\tvoid init(){\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tfor(int k = 0; k < 128; k++){\n\t\t\t\tindex[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init_index(char first,char second){\n\t\tindex[first][second] = 0;\n\t}\n\n\tvoid regist_loc(char first,char second,int location){\n\t\tlocationTable[first][second][index[first][second]] = location;\n\t\tindex[first][second]++;\n\t}\n\n\tint next_loc(char first,char second){\n\t\tint ret = locationTable[first][second][index[first][second]];\n\t\tindex[first][second]++;\n\t\treturn ret;\n\t}\n\nprivate:\n\tint*** locationTable;\n\tint index[128][128];\n};\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\t\t\treturn length < arg.length;\n\t};\n\tInfo(int arg_length,int arg_id,ull arg_hashValue){\n\t\tlength = arg_length;\n\t\tid = arg_id;\n\t\thashValue = arg_hashValue;\n\t}\n\n\tint length,id;\n\tull hashValue;\n};\n\nint main(){\n\n\tfor(int i = 0; i < 128; i++){\n\t\tT_char_count[i] = 0;\n\t\tfor(int k = 0; k < 128; k++){\n\t\t\tT_Chain[i][k] = 0;\n\t\t}\n\t}\n\n\tint T_length;\n\n\tchar* T = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tchar pre = T[0];\n\tT_char_count[T[0]]++;\n\n\tfor(T_length = 1; T[T_length] != '\\0';T_length++){\n\t\tT_char_count[T[T_length]]++;\n\t\tT_Chain[pre][T[T_length]]++;\n\t\tpre = T[T_length];\n\t}\n\n\tLocRecord locRecord;\n\tlocRecord.init();\n\n\n\tpre = T[0];\n\t//T[i]????????????i??§???????????¨????¨????\n\tfor(int i = 1; i < T_length; i++){\n\t\tlocRecord.regist_loc(pre,T[i],i-1);\n\t\tpre = T[i];\n\t}\n\n\tull* HASH = new ull[T_length+1];\n\tull* P = new ull[T_length+1];\n\n\tHASH[0] = 0;\n\tP[0] = 1;\n\n\t//T??????????????\\???????±???????\n\tfor(int i = 1; i <= T_length; i++){\n\t\tHASH[i] = T[i-1] + HASH[i-1]*MOD;\n\t\tP[i] = P[i-1]*MOD;\n\t}\n\n\n\tvector<Info> V[128][128];\n\n\tint Q,S_length,left,P_char_count[128];\n\tscanf(\"%d\",&Q);\n\n\tbool check[Q];\n\n\tfor(int i = 0; i < Q; i++)check[i] = false;\n\n\tchar S[1001];\n\tull S_HASH[1001],S_value,T_value,D;\n\tbool FLG;\n\n\n\t//Q??¶??????????????\\???????¨????\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",S);\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tP_char_count[i] = 0;\n\t\t}\n\n\t\tfor(S_length = 0;S[S_length] != '\\0';S_length++){\n\t\t\tP_char_count[S[S_length]]++;\n\t\t}\n\n\t\tFLG = true;\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tif(T_char_count[i] < P_char_count[i]){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG)continue;\n\n\t\tif(S_length == 1){\n\t\t\tcheck[loop] = true;\n\t\t\tcontinue;\n\t\t}\n\n\n\n\t\tS_HASH[0] = 0;\n\t\tfor(int i = 1; i <= S_length; i++){\n\t\t\tS_HASH[i] = S[i-1] + S_HASH[i-1]*MOD;\n\t\t}\n\n\t\tS_value = S_HASH[S_length];\n\n\t\tV[S[0]][S[1]].push_back(Info(S_length,loop,S_value));\n\t}\n\n\tint calc_length;\n\n\tfor(int first_word = 48; first_word <= 122; first_word++){\n\t\tfor(int second_word = 48; second_word <= 122;second_word++){\n\t\t\tfor(int i = 0; i < V[first_word][second_word].size();i++){\n\n\t\t\t\tlocRecord.init_index(first_word,second_word);\n\n\t\t\t\tcalc_length = V[first_word][second_word][i].length;\n\t\t\t\tS_value = V[first_word][second_word][i].hashValue;\n\n\t\t\t\tD = P[calc_length];\n\n\t\t\t\twhile((left = locRecord.next_loc(first_word,second_word)) != -1){\n\t\t\t\t\tif(left+calc_length-1 >= T_length)break;\n\n\t\t\t\t\t//T_value = HASH[left+calc_length]-HASH[left]*D;\n\n\t\t\t\t\tif(HASH[left+calc_length]-HASH[left]*D == S_value){\n\t\t\t\t\t\tcheck[V[first_word][second_word][i].id] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tif(check[i])printf(\"1\\n\");\n\t\telse{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct SuffixArray {\n    unsigned int n = 0;\n    string S;\n    vector<int> sa, lcp, rev;\n\n    SuffixArray() = default;\n\n    explicit SuffixArray(string &S) : S(S) { init(); }\n\n    void init() {\n        n = S.length();\n        S.push_back('$');\n        build_sa();\n        build_lcp();\n        build_rmq();\n    }\n\n    void build_sa() {\n        sa.clear();\n        sa.resize(n + 1, 0);\n        iota(sa.begin(), sa.end(), 0);\n        sort(sa.begin(), sa.end(),\n             [&](int a, int b) {\n                 if (S[a] == S[b]) return a > b;\n                 return S[a] < S[b];\n             });\n        vector<int> c(n + 1, 0), r(n + 1), cnt(n + 1), s(n + 1);\n        for (int i = 0; i <= n; i++) r[i] = S[i];\n        for (int len = 1; len <= n; len *= 2) {\n            for (int i = 0; i <= n; i++) {\n                c[sa[i]] =\n                        i > 0 &&\n                        r[sa[i - 1]] == r[sa[i]] &&\n                        sa[i - 1] + len <= n &&\n                        r[sa[i - 1] + len / 2] == r[sa[i] + len / 2] ?\n                        c[sa[i - 1]] : i;\n            }\n            iota(cnt.begin(), cnt.end(), 0);\n            copy(sa.begin(), sa.end(), r.begin());\n            for (int i = 0; i <= n; i++) {\n                int s1 = r[i] - len;\n                if (s1 >= 0) sa[cnt[c[s1]]++] = s1;\n            }\n            c.swap(r);\n        }\n    }\n\n    bool lt_substr(string &T, int si = 0, int ti = 0) {\n        int sn = S.size();\n        int tn = T.size();\n        while (si < sn && ti < tn) {\n            if (S[si] < T[ti]) return true;\n            if (S[si] > T[ti]) return false;\n            si++;\n            ti++;\n        }\n        return si >= sn && ti < tn;\n    }\n\n    int lower_bound(string &T) {\n        int low = 0, high = n + 1;\n        while (low + 1 < high) {\n            int mid = (low + high) / 2;\n            if (lt_substr(T, sa[mid], 0)) low = mid;\n            else high = mid;\n        }\n        return high;\n    }\n\n    int upper_bound(string &T) {\n        T.back()++;\n        int res = lower_bound(T);\n        T.back()--;\n        return res;\n    }\n\n    // O(|T|*log|S|)\n    int count(string &T) {\n        return upper_bound(T) - lower_bound(T);\n    }\n\n    void build_lcp() {\n        lcp.assign(n, 0);\n        rev.assign(n + 1, 0);\n        for (int i = 0; i <= n; i++) rev[sa[i]] = i;\n        int h = 0;\n        lcp[0] = 0;\n        for (int i = 0; i < n; i++) {\n            int j = sa[rev[i] - 1];\n            if (h > 0) h--;\n            for (; j + h < n && i + h < n; h++) {\n                if (S[j + h] != S[i + h]) break;\n            }\n            lcp[rev[i] - 1] = h;\n        }\n    }\n\n    int get_lcp(int p, string &T, int d) {\n        int i = 0;\n        int len = min((int) T.length() - d, (int) S.length() - p - d);\n        while (i < len && S[p + d + i] == T[d + i]) i++;\n        return i;\n    }\n\n    struct RMQ {\n        vector<vector<int> > dat;\n        vector<int> ht;\n\n        void init(int n) {\n            int h = 1;\n            while ((1 << h) < n) h++;\n            dat.assign(h, vector<int>(n));\n            ht.assign(n + 1, 0);\n            for (int j = 2; j <= n; j++) ht[j] = ht[j >> 1] + 1;\n        }\n\n        void build(int n, vector<int> &v) {\n            int h = 1;\n            while ((1 << h) < n) h++;\n            for (int j = 0; j < n; j++) dat[0][j] = v[j];\n            for (int i = 1, p = 1; i < h; i++, p <<= 1)\n                for (int j = 0; j < n; j++)\n                    dat[i][j] = min(dat[i - 1][j],\n                                    dat[i - 1][min(j + p, n - 1)]);\n        };\n\n        int query(int a, int b) {\n            if (a > b) swap(a, b);\n            int l = b - a;\n            return min(dat[ht[l]][a], dat[ht[l]][b - (1 << ht[l])]);\n        }\n    };\n\n    RMQ rmq;\n\n    void build_rmq() {\n        rmq.init(n);\n        rmq.build(n, lcp);\n    }\n\n    int lower_bound2(string &T) {\n        int sl = S.length();\n        int tl = T.length();\n        if (lt_substr(T, sa[sl - 1], 0)) return sl;\n        int p = tl;\n        int low = 0, high = sl - 1;\n        int l = get_lcp(sa[low], T, 0);\n        int r = get_lcp(sa[high], T, 0);\n        while (low + 1 < high) {\n            int mid = (low + high) / 2;\n            int k;\n            if (l >= r) {\n                int m = rmq.query(low, mid);\n                if (m < l) {\n                    high = mid, r = m;\n                    continue;\n                }\n                k = l + get_lcp(sa[mid], T, l);\n            } else {\n                int m = rmq.query(mid, high);\n                if (m < r) {\n                    low = mid, l = m;\n                    continue;\n                }\n                k = r + get_lcp(sa[mid], T, r);\n            }\n            if (k == p) high = mid, r = k;\n            else if (S[sa[mid] + k] < T[k]) low = mid, l = k;\n            else high = mid, r = k;\n        }\n\n        return high;\n    }\n\n    int upper_bound2(string &T) {\n        T.back()++;\n        int res = lower_bound2(T);\n        T.back()--;\n        return res;\n    }\n\n    // O(|T|+log|S|)\n    int count2(string &T) {\n        return upper_bound2(T) - lower_bound2(T);\n    }\n};\n\n\nint main() {\n    string T;\n    cin >> T;\n    SuffixArray sa(T);\n\n    int q;\n    cin >> q;\n    while (q--) {\n        string P;\n        cin >> P;\n\n        (sa.count2(P) != 0) ? (cout << 1) : (cout << 0);\n        cout << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstruct charnode {\n    vector<int> index;\n    map<char, charnode> child;\n    charnode() :index(), child() {}\n};\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string t, temp;\n    int n;\n    charnode wordlist;\n    getline(cin, t);\n    cin>>n;\n    cin.ignore();\n    for(int i=0; i<n; i++) {\n        getline(cin, temp);\n        charnode *p=&wordlist;\n        for(int j=0, len=temp.length(); j<len; j++) {\n            p=&(p->child[temp[j]]);\n        }\n        p->index.push_back(i);\n    }\n    int res[10000]={};\n    int len=t.length();\n    for(int i=0; i<len; i++) {\n        charnode *p=&wordlist;\n        for(int j=i; j<len; j++) {\n            map<char, charnode>::iterator it=p->child.find(t[j]);\n            if(it==p->child.end()) break;\n            p=&(it->second);\n            for(vector<int>::iterator t = p->index.begin(); t!=p->index.end(); ++t) {\n                res[*t]=1;\n            }\n        }\n    }\n    for(int i=0; i<n; i++) cout<<res[i]<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nstruct SAComp{\n\tconst int h;const char *g;\n\tSAComp(const int h, const char* g) : h(h), g(g) {}\n\tbool operator()(const int a, const int b){\n\t\treturn a == b ? false : g[a] != g[b] ? g[a] < g[b] : g[a+h] < g[b+h];\n\t}\n};\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s;\n\tcin>>s;\n\ts+='$';\n\tint n=s.size();\n\tvector<int>suff(n);\n\tiota(suff.begin(),suff.end(),0);\n\t{\n\t\tconst char *str=s.c_str();\n\t\tsort(suff.begin(),suff.end(),SAComp(0,str));\n\t}\n\tvector<pair<char,int>>sorted(n);\n\tfor(int i=0;i<n;i++)sorted[i]={s[(suff[i]-1+n)%n],i};\n\tsort(sorted.begin(),sorted.end());\n\n\tint T;\n\tfor(cin>>T;T--;){\n\t\tstring q;\n\t\tcin>>q;\n\t\tint start=0,stop=n,idx=q.size()-1;\n\t\tfor(;idx>=0;idx--){\n\t\t\tpair<char,int> ql={q[idx],start},qr={q[idx],stop};\n\t\t\tstart=lower_bound(sorted.begin(),sorted.end(),ql)-sorted.begin();\n\t\t\tstop=lower_bound(sorted.begin(),sorted.end(),qr)-sorted.begin();\n\t\t\tif(start==stop)break;\n\t\t}\n\t\tif(idx<0){\n\t\t\t//{vector<int>v;for(;start<stop;start++)v.push_back(suff[start]);sort(v.begin(),v.end());for(auto &e:v)printf(\"%d\\n\",e);}\n\t\t\tputs(\"1\");\n\t\t}else{\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_SuffixArray\n#define ___Class_SuffixArray\n\n#include <string>\n#include <vector>\n#include <algorithm>\n\nclass SuffixArray {\n\tvoid CreateBeginBucket(std::vector<int>&v, std::vector<int>&bucket) {\n\t\tfill(bucket.begin(), bucket.end(), 0);\n\t\tfor (int i = 0; i < v.size(); i++) bucket[v[i]]++;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < bucket.size(); i++) { bucket[i] += sum; std::swap(sum, bucket[i]); }\n\t}\n\tvoid CreateEndBucket(std::vector<int>&v, std::vector<int>&bucket) {\n\t\tfill(bucket.begin(), bucket.end(), 0);\n\t\tfor (int i = 0; i < v.size(); i++) bucket[v[i]]++;\n\t\tfor (int i = 1; i < bucket.size(); i++) bucket[i] += bucket[i - 1];\n\t}\n\tvoid InducedSort(std::vector<int>&v, std::vector<int>&SA, int mv, std::vector<int>&bucket, std::vector<int>&isL) {\n\t\tCreateBeginBucket(v, bucket);\n\t\tfor (int i = 0; i<v.size(); i++)if (SA[i]>0 && isL[SA[i] - 1])SA[bucket[v[SA[i] - 1]]++] = SA[i] - 1;\n\t}\n\tvoid InvertInducedSort(std::vector<int>&v, std::vector<int>&SA, int mv, std::vector<int>&bucket, std::vector<int>&isL) {\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = v.size() - 1; i >= 0; i--)if (SA[i]>0 && !isL[SA[i] - 1])SA[--bucket[v[SA[i] - 1]]] = SA[i] - 1;\n\t}\n\tstd::vector<int>SA_IS(std::vector<int>v, int mv) {\n\t\tif (v.size() == 1)return std::vector<int>(1, 0);\n\t\tstd::vector<int>isL(v.size());\n\t\tstd::vector<int>bucket(mv + 1);\n\t\tstd::vector<int>SA(v.size(), -1);\n\t\tauto isLMS = [&](int x)->bool {return x>0 && isL[x - 1] && !isL[x]; };\n\t\tisL[v.size() - 1] = 0;\n\t\tfor (int i = v.size() - 2; i >= 0; i--)isL[i] = v[i]>v[i + 1] || (v[i] == v[i + 1] && isL[i + 1]);\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))SA[--bucket[v[i]]] = i;\n\t\tInducedSort(v, SA, mv, bucket, isL);\n\t\tInvertInducedSort(v, SA, mv, bucket, isL);\n\t\tint cur = 0;\n\t\tstd::vector<int>ord(v.size());\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))ord[i] = cur++;\n\t\tstd::vector<int>nxv(cur);\n\t\tcur = -1;\n\t\tint prev = -1;\n\t\tfor (int i = 0; i<v.size(); i++) {\n\t\t\tif (!isLMS(SA[i]))continue;\n\t\t\tbool diff = false;\n\t\t\tfor (int d = 0; d<v.size(); d++) {\n\t\t\t\tif (prev == -1 || v[SA[i] + d] != v[prev + d] || isL[SA[i] + d] != isL[prev + d]) {\n\t\t\t\t\tdiff = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (d>0 && isLMS(SA[i] + d))break;\n\t\t\t}\n\t\t\tif (diff) { cur++; prev = SA[i]; }\n\t\t\tnxv[ord[SA[i]]] = cur;\n\t\t}\n\t\tstd::vector<int>reord(nxv.size());\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))reord[ord[i]] = i;\n\t\tstd::vector<int>nxSA = SA_IS(nxv, cur);\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = 0; i<SA.size(); i++)SA[i] = -1;\n\t\tfor (int i = nxSA.size() - 1; i >= 0; i--)SA[--bucket[v[reord[nxSA[i]]]]] = reord[nxSA[i]];\n\t\tInducedSort(v, SA, mv, bucket, isL);\n\t\tInvertInducedSort(v, SA, mv, bucket, isL);\n\t\treturn SA;\n\t}\n\tstd::vector<int>SA_IS(std::string s) {\n\t\tstd::vector<int>v(s.size() + 1);\n\t\tfor (int i = 0; i<s.size(); i++)v[i] = s[i] + 1;\n\t\treturn SA_IS(v, *max_element(v.begin(), v.end()));\n\t}\n\tstd::vector<int>construct_lcp(std::string &s, std::vector<int>&sa) {\n\t\tstd::vector<int> lcp, rank(s.size() + 1);\n\t\tint n = s.size();\n\t\tfor (int i = 0; i <= n; i++)rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tlcp[0] = 0;\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h>0) h--;\n\t\t\tfor (; j + h<n&&i + h<n; h++) {\n\t\t\t\tif (s[j + h] != s[i + h])break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\npublic:\n\tstd::string s;\n\tstd::vector<int> sa, lcp;\n\tSuffixArray() {};\n\tSuffixArray(std::string &t) : s(t), sa(SA_IS(t)) {};\n};\n\n#endif\n\n#include <string>\n#include <cassert>\n#include <iostream>\nusing namespace std;\nstring s;\nint main() {\n\tcin >> s;\n\tSuffixArray x(s);\n\tvector<int> sa_inv(s.size() + 1);\n\tfor (int i = 0; i < s.size(); i++) sa_inv[x.sa[i]] = i;\n\tint ret = 0;\n\tfor (int i = 1; i < s.size(); i++) {\n\t\tif (sa_inv[i - 1] < sa_inv[i]) ret++;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S 2100005\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\nstruct d{\n  int a,b,c;\n  d(){}\n  d(int A,int B,int C){\n    a=A,b=B,c=C;\n  };\n  bool operator<(const d&r)const{\n    if(a!=r.a)return a<r.a;\n    return b<r.b;\n  }\n};\n\nint n,slen,tlen,r[S];\nchar s[S],t[N];\nd ran[S];\nP a[S];\n\nvoid init(){\n  for(int i=0;i<26;i++)\n    for(int j=0;j<slen;j++)\n      if('a'+i==s[j])r[j]=i+1;\n  int x=1;\n  while(x<slen){\n    for(int i=0;i<slen;i++){\n      int a=i+x;\n      if(a>slen)a=slen;\n      ran[i]=d(r[i],r[a],i);\n    }\n    sort(ran,ran+slen);\n    int cnt=1;\n    for(int i=0;i<slen;i++){\n      r[ran[i].c]=cnt;\n      if(ran[i].a==ran[i+1].a&&ran[i].b==ran[i+1].b)\n\tcontinue;\n      cnt++;\n    }\n    x*=2;\n  }\n  for(int i=0;i<slen;i++)a[i]=P(r[i],i);\n  sort(a,a+slen);\n}\n\nbool bynary_search(){\n  int L=0,R=slen;\n  while(L<R){\n    int M=(L+R)/2;\n    if(strncmp(s+a[M].second,t,tlen)<0)L=M+1;\n    else R=M;\n  }\n  if(!strncmp(s+a[L].second,t,tlen))return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s%d\",s,&n);\n  slen=strlen(s);\n  init();  \n  while(n--){\n    scanf(\"%s\",t);\n    tlen=strlen(t);\n    if(bynary_search())printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <string>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nunsigned char mask[] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };\n#define tget(i) ( (t[(i)/8]&mask[(i)%8]) ? 1 : 0 )\n#define tset(i, b) t[(i)/8]=(b) ? (mask[(i)%8]|t[(i)/8]) : ((~mask[(i)%8])&t[(i)/8])\n#define chr(i) (cs==sizeof(int)?((int*)s)[i]:((unsigned char *)s)[i])\n#define isLMS(i) (i>0 && tget(i) && !tget(i-1))\n\n// find the start or end of each bucket\nvoid getBuckets(unsigned char *s, int *bkt, int n, int K, int cs, bool end) {\n    int i, sum = 0;\n    for (i = 0; i <= K; i++)\n        bkt[i] = 0; // clear all buckets\n    for (i = 0; i < n; i++)\n        bkt[chr(i)]++; // compute the size of each bucket\n    for (i = 0; i <= K; i++) {\n        sum += bkt[i];\n        bkt[i] = end ? sum : sum - bkt[i];\n    }\n}\n// compute SAl\nvoid induceSAl(unsigned char *t, int *SA, unsigned char *s, int *bkt, int n, int K, int cs, bool end) {\n    int i, j;\n    getBuckets(s, bkt, n, K, cs, end); // find starts of buckets\n    for (i = 0; i < n; i++) {\n        j = SA[i] - 1;\n        if (j >= 0 && !tget(j))\n            SA[bkt[chr(j)]++] = j;\n    }\n}\n// compute SAs\nvoid induceSAs(unsigned char *t, int *SA, unsigned char *s, int *bkt, int n, int K, int cs, bool end) {\n    int i, j;\n    getBuckets(s, bkt, n, K, cs, end); // find ends of buckets\n    for (i = n - 1; i >= 0; i--) {\n        j = SA[i] - 1;\n        if (j >= 0 && tget(j))\n            SA[--bkt[chr(j)]] = j;\n    }\n}\n\n// find the suffix array SA of s[0..n-1] in {1..K}^n\n// require s[n-1]=0 (the sentinel!), n>=2\n// use a working space (excluding s and SA) of at most 2.25n+O(1) for a constant alphabet\nvoid SA_IS(unsigned char *s, int *SA, int n, int K, int cs) {\n    int i, j;\n    unsigned char *t = (unsigned char *) malloc(n / 8 + 1); // LS-type array in bits\n    // Classify the type of each character\n    tset(n-2, 0);\n    tset(n-1, 1); // the sentinel must be in s1, important!!!\n    for (i = n - 3; i >= 0; i--)\n        tset(i, (chr(i)<chr(i+1) || (chr(i)==chr(i+1) && tget(i+1)==1))?1:0);\n    // stage 1: reduce the problem by at least 1/2\n    // sort all the S-substrings\n    int *bkt = (int *) malloc(sizeof(int) * (K + 1)); // bucket array\n    getBuckets(s, bkt, n, K, cs, true); // find ends of buckets\n    for (i = 0; i < n; i++)\n        SA[i] = -1;\n    for (i = 1; i < n; i++)\n        if (isLMS(i))\n            SA[--bkt[chr(i)]] = i;\n    induceSAl(t, SA, s, bkt, n, K, cs, false);\n    induceSAs(t, SA, s, bkt, n, K, cs, true);\n    free(bkt);\n    // compact all the sorted substrings into the first n1 items of SA\n    // 2*n1 must be not larger than n (proveable)\n    int n1 = 0;\n    for (i = 0; i < n; i++)\n        if (isLMS(SA[i]))\n            SA[n1++] = SA[i];\n    // find the lexicographic names of all substrings\n    for (i = n1; i < n; i++)\n        SA[i] = -1; // init the name array buffer\n    int name = 0, prev = -1;\n    for (i = 0; i < n1; i++) {\n        int pos = SA[i];\n        bool diff = false;\n        for (int d = 0; d < n; d++)\n            if (prev == -1 || chr(pos+d) != chr(prev+d) || tget(pos+d) != tget(prev+d)) {\n                diff = true;\n                break;\n            } else if (d > 0 && (isLMS(pos+d) || isLMS(prev+d)))\n                break;\n        if (diff) {\n            name++;\n            prev = pos;\n        }\n        pos = (pos % 2 == 0) ? pos / 2 : (pos - 1) / 2;\n        SA[n1 + pos] = name - 1;\n    }\n    for (i = n - 1, j = n - 1; i >= n1; i--)\n        if (SA[i] >= 0)\n            SA[j--] = SA[i];\n    // stage 2: solve the reduced problem\n    // recurse if names are not yet unique\n    int *SA1 = SA, *s1 = SA + n - n1;\n    if (name < n1)\n        SA_IS((unsigned char*) s1, SA1, n1, name - 1, sizeof(int));\n    else\n        // generate the suffix array of s1 directly\n        for (i = 0; i < n1; i++)\n            SA1[s1[i]] = i;\n    // stage 3: induce the result for the original problem\n    bkt = (int *) malloc(sizeof(int) * (K + 1)); // bucket array\n    // put all left-most S characters into their buckets\n    getBuckets(s, bkt, n, K, cs, true); // find ends of buckets\n    for (i = 1, j = 0; i < n; i++)\n        if (isLMS(i))\n            s1[j++] = i; // get p1\n    for (i = 0; i < n1; i++)\n        SA1[i] = s1[SA1[i]]; // get index in s\n    for (i = n1; i < n; i++)\n        SA[i] = -1; // init SA[n1..n-1]\n    for (i = n1 - 1; i >= 0; i--) {\n        j = SA[i];\n        SA[i] = -1;\n        SA[--bkt[chr(j)]] = j;\n    }\n    induceSAl(t, SA, s, bkt, n, K, cs, false);\n    induceSAs(t, SA, s, bkt, n, K, cs, true);\n    free(bkt);\n    free(t);\n}\n\nconst int maxn = 1000100;\nint sa[maxn];\nint lcp[maxn];\nint pos[maxn];\nunsigned char *s;\nint n;\n\nvoid calc_lcp() {\n    for (int i = 0; i < n+1; i++)\n        pos[sa[i]] = i;\n    for (int i = 0, h = 0; i < n+1; i++) {\n        if (pos[i] < n ) {\n            for (int j = sa[pos[i] + 1]; s[i + h] == s[j + h]; ++h)\n                ;\n            lcp[pos[i]] = h;\n            if (h > 0)\n                --h;\n        }\n    }\n}\n/*\n str=\"abcab\" n=5\n SA_IS(str,sa,n+1,256,1)\n calc_lcp()\n sa={5,3,0,4,1,2}\n str.subtring(sa)={\"\",\"ab\",\"abcab\",\"b\",\"bcab\",\"cab\"}\n lcp={0,2,0,1,0,0}\n pos={2,4,5,1,3,0}\n*/\n\npair<int,int> longest_repeated_substring(int overlap){\n    //overlap=1 non-overlapping , overlap=0 overlap allowed\n    int maxl=0,maxidx=-1;\n    for(int i=1;i<n+1;i++){\n        if(lcp[i]>maxl) {\n            if(overlap && abs(sa[i]-sa[i-1])<lcp[i]) continue;\n            maxl=lcp[i];\n            maxidx=sa[i];\n        }\n    }\n    if(maxidx==-1) return make_pair(-1,-1);\n    return make_pair(maxidx,maxl);\n}\npair<pair<int,int>,int> longest_k_repeated_substring(string str,int k){\n    k--;\n    for (int i = 0; i < n+1; i++)\n        pos[sa[i]] = i;\n    int maxl=0,maxidx=-1,rightmostidx=0;\n    for (int i = 0, h = 0; i < n+1; i++) {\n        if (pos[i] < n +1-k) {\n            for (int j = sa[pos[i] + k]; s[i + h] == s[j + h]; ++h)\n                ;\n            if(h>=maxl){\n                if(h>maxl) rightmostidx=sa[pos[i] + k];\n                maxl=h;\n                maxidx=i;\n                if(rightmostidx<sa[pos[i] + k]) rightmostidx=sa[pos[i] + k];\n            }\n            //cout<<i<<\" \"<<h<<\" \"<<str.substr(i,h)<<maxl<<\" \"<<str.substr(maxidx,maxl)<<\" \"<<rightmostidx<<endl;\n\n            if (h > 0)\n                --h;\n        }\n    }\n    if(maxidx==-1) return make_pair(make_pair(-1,-1),-1);\n    return make_pair(make_pair(rightmostidx,maxidx),maxl);\n}\npair<pair<int,int>,pair<int,int> > longest_common_substring(string str1,string str2){\n    string str=str1+\" \"+str2;\n    s = (unsigned char*) str.c_str();\n    n = (int)str.size();\n    SA_IS(s, sa, n + 1, 256, 1);\n    calc_lcp();\n    pair<int,int> p=longest_repeated_substring(0);\n    int indx2=sa[pos[p.first]+1];\n    //cout<<str.substr(p.first,p.second)<<\" \"<<str.substr(indx2,p.second)<<endl;\n    if((p.first<str1.length()&&indx2<str1.length())||(p.first>str1.length()&&indx2>str1.length()) || str.substr(p.first,p.second)!=str.substr(indx2,p.second)) {\n                return make_pair(make_pair(0,0),p);\n    }\n    return make_pair(p,make_pair(indx2,p.second));\n}\n\npair<int,int> smallest_lex_rotation(string str){\n    \n    str=str+str;\n    s = (unsigned char*) str.c_str();\n    \n    n = (int)str.size();\n    SA_IS(s, sa, n + 1, 256, 1);\n    for(int i=1;i<n+1;i++){\n        //cout<<str.substr(sa[i])<<\" \"<<sa[i]<<\"\\n\";\n    }\n    \n    int minval=maxn;\n    for(int i=0;i<n+1;i++){\n        if(sa[i]<=n/2){\n            while(i<n && sa[i]<=n/2 && str.substr(sa[i],n/2)==str.substr(sa[i+1],n/2)){\n                if(minval>sa[i]) minval=sa[i];\n                //printf(\"i %d\\n\",i);\n                i++;\n            }\n            return make_pair(sa[i],n/2);\n        }\n    }\n    \n    return make_pair(-1,n/2);\n}\n\nlong count_distinct_substrings(string str){\n    s = (unsigned char*) str.c_str();\n    n = (int)str.size();\n    SA_IS(s, sa, n + 1, 256, 1);\n    calc_lcp();\n    long count=0;\n    for(int i=1;i<n+1;i++) count+=n-sa[i]-lcp[i];\n    return count;\n}\n\npair<int,int> longest_palindromic_substring(string str){\n    string revstr=string(str.rbegin(),str.rend());\n    return longest_common_substring(str, revstr).first;\n}\n\nbool contain(string str, int *sa, string T){\n    int a = 0, b = str.length();\n    while( b - a > 1 ){\n        int c = (a + b ) / 2;\n        if ( str.compare(sa[c], T.length(), T) < 0 ) a = c;\n        else b = c;\n    }\n    return str.compare(sa[b], T.length(), T) == 0;\n}\n\n\nint main() {\n    string str;\n    cin>>str;\n    s = (unsigned char*) str.c_str();\n    n = (int)str.size();\n    SA_IS(s, sa, n + 1, 256, 1);\n    int t;\n    cin>>t;\n    while(t--){\n    \tstring pat;\n    \tcin>>pat;\n    \tcout<<contain(str,sa,pat)<<\"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int B=999999937;\nconst int P=1000000007;\n\nvector<long long> gen_hash(const string &s){\n\tvector<long long> hash(s.size());\n\tlong long c=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tc=(c*B+s[i])%P;\n\t\thash[i]=c;\n\t}\n\treturn hash;\n}\nlong long pow_binary_mod(long long x,long long y,long long mod){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%mod;\n\t\tx=x*x%mod;\n\t}\n\treturn z;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s;\n\tcin>>s;\n\tint ls=s.size();\n\tvector<long long> v=gen_hash(s);\n\n\tint T;\n\tfor(cin>>T;T--;){\n\t\tstring q;\n\t\tcin>>q;\n\t\tint lq=q.size();\n\t\tlong long hash=gen_hash(q)[lq-1];\n\t\tlong long Brev=pow_binary_mod(B,lq,P);\n\t\tvector<int> r;\n\t\tint i=lq-1;\n\t\tfor(;i<ls;i++){\n\t\t\tif(v[i]==((i>=lq?v[i-lq]:0)*Brev+hash)%P){\n\t\t\t\tr.push_back(i-lq+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!r.empty()){\n\t\t\t//for(int i=0;i<r.size();i++)printf(\"%d\\n\",r[i]);\n\t\t\tputs(\"1\");\n\t\t}else{\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string.h>\nusing namespace std;\n\n#define TEXT_T_MAX 1000000 \n#define TEXT_P_MAX 1000\n\nbool searchText(const char t1[], const char t2[]);\nbool compareText(const char *t1, char const *t2, int len);\n\nint main (void)\n{\n\tchar t[TEXT_T_MAX + 1] = \"\\0\";\n\tcin >> t;\n\tint\tq;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tchar p[TEXT_P_MAX + 1] = \"\\0\";\n\t\tcin >> p;\n\t\tcout << (int)searchText(t, p) << endl;\n\t}\n\n\treturn 0;\t\n}\n\nbool searchText(const char t1[], const char t2[])\n{\n\tint t1_len = strlen(t1);\n\tint t2_len = strlen(t2);\n\n\tif (t1_len < t2_len) return false;\n\n\tfor (int i = 0; i + t2_len < t1_len; i++) {\n\t\tif (compareText(&t1[i], t2, t2_len)) return true;\n\t}\n\treturn false;\n}\n\nbool compareText(const char *t1, const char *t2, int len)\n{\n\tfor (int i = 0; i < len; i++) {\n\t\tif (*(t1 + i) != *(t2 + i)) return false;\n\t}\n\treturn true;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\nint n,sa[1<<20],r[1<<20],tmp[1<<20];\nchar s[1<<20];\nint k;\nbool comp(int i,int j)\n{\n\tif(r[i]!=r[j])return r[i]<r[j];\n\telse\n\t{\n\t\tint ri=i+k<=n?r[i+k]:-1;\n\t\tint rj=j+k<=n?r[j+k]:-1;\n\t\treturn ri<rj;\n\t}\n}\nvoid construct()\n{\n\tn=strlen(s);\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tsa[i]=i;\n\t\tr[i]=i<n?s[i]:-1;\n\t}\n\tfor(k=1;k<=n;k*=2)\n\t{\n\t\tsort(sa,sa+n+1,comp);\n\t\ttmp[sa[0]]=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\ttmp[sa[i]]=tmp[sa[i-1]]+comp(sa[i-1],sa[i]);\n\t\t}\n\t\tfor(int i=0;i<=n;i++)r[i]=tmp[i];\n\t}\n}\nchar t[1010];\nint T;\nint c(int i)\n{\n\tint j=0;\n\tfor(;j<T&&s[i+j]==t[j];j++);\n\treturn j<T?t[j]-s[i+j]:0;\n}\nbool func()\n{\n\tint f=0,l=n+1;\n\twhile(l-f>1)\n\t{\n\t\tint m=(f+l)/2;\n\t\tif(c(sa[m])<0)l=m;\n\t\telse f=m;\n\t}\n\treturn c(sa[f])==0;\n}\nmain()\n{\n\tint p;scanf(\"%s\\n%d\\n\",s,&p);\n\tconstruct();\n\tfor(;~scanf(\"%s\\n\",t);)\n\t{\n\t\tT=strlen(t);\n\t\tputs(func()?\"1\":\"0\");\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct RMQ{\n  int n;\n  vector<int> dat;\n  const int def=INT_MAX;\n  RMQ(){}\n  RMQ(int n_){init(n_);}\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,def);\n    }\n  void update(int k,int a){\n    k+=n-1;\n    dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  int query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return def;\n    if(a<=l&&r<=b) return dat[k];\n    else{\n      int vl=query(a,b,k*2+1,l,(l+r)/2);\n      int vr=query(a,b,k*2+2,(l+r)/2,r);\n      return min(vl,vr);\n    }\n  }\n  int query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n};\n\nstruct SA{\n  int n,k;\n  string S;\n  vector<int> r,r2,t,sa,lcp;\n  SA(){}\n  SA(string S):S(S){init();}\n  void init(){\n    n=S.size();\n    r.clear();\n    r2.clear();\n    t.clear();\n    sa.clear();\n    lcp.clear();\n    r.resize(n+1,0);\n    r2.resize(n+1,0);\n    t.resize(n+1,0);\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    constract_sa();\n  }\n  bool compare_sa(int i,int j){\n    if(r[i]!=r[j]) return r[i]<r[j];\n    else{\n      int ri=i+k<=n?r[i+k]:-1;\n      int rj=j+k<=n?r[j+k]:-1;\n      return ri<rj;\n    }\n  }\n  void constract_sa(){\n    n=S.length();\n    for(int i=0;i<=n;i++){\n      sa[i]=i;\n      r[i]=i<n?S[i]:-1;\n    }\n    for(k=1;k<=n;k*=2){\n      sort(sa.begin(),sa.end(),[&](const int &i, const int &j){\n\t  if(r[i]!=r[j]) return r[i]<r[j];\n\t  else{\n\t    int ri=i+k<=n?r[i+k]:-1;\n\t    int rj=j+k<=n?r[j+k]:-1;\n\t    return ri<rj;\n\t  }\n\t});\n      t[sa[0]]=0;\n      for(int i=1;i<=n;i++){\n\tt[sa[i]]=t[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n      }\n      for(int i=0;i<=n;i++){\n\tr[i]=t[i];\n      }\n    }\n  }\n  void constract_lcp(){\n    for(int i=0;i<=n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  bool contains(string T){\n    int a=0,b=S.length()+1;\n    while(b-a>1){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\tif(S.compare(sa[c],tl,T)<0||\n\t   (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n\telse b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n\n  int count(string T,RMQ &rmq){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(b[i]-a[i]>1){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n  \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n  \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n  \n    return a[1]-b[0]+1;\n  }\n};\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SA sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\nstruct d{\n  int a,b,c;\n  d(){}\n  d(int A,int B,int C){\n    a=A,b=B,c=C;\n  };\n  bool operator<(const d&r)const{\n    if(a!=r.a)return a<r.a;\n    return b<r.b;\n  }\n};\n\nint n,slen,tlen,r[N];\nchar s[N],t[N];\nd ran[N];\nP a[N];\n\nvoid init(){\n  for(int i=0;i<26;i++)\n    for(int j=0;j<slen;j++)\n      if('a'+i==s[j])r[j]=i+1;\n  int x=1;\n  while(x<slen){\n    for(int i=0;i<slen;i++){\n      int a=i+x;\n      if(a>slen)a=slen;\n      ran[i]=d(r[i],r[a],i);\n    }\n    sort(ran,ran+slen);\n    int cnt=1;\n    for(int i=0;i<slen;i++){\n      r[ran[i].c]=cnt;\n      if(ran[i].a==ran[i+1].a&&ran[i].b==ran[i+1].b)\n\tcontinue;\n      cnt++;\n    }\n    x*=2;\n  }\n  for(int i=0;i<slen;i++)a[i]=P(r[i],i);\n  sort(a,a+slen);\n}\n\nbool bynary_search(){\n  int L=0,R=slen;\n  while(L<R){\n    int M=(L+R)/2;\n    if(strncmp(s+a[M].second,t,tlen)<0)L=M+1;\n    else R=M;\n  }\n  if(!strncmp(s+a[L].second,t,tlen))return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s%d\",s,&n);\n  slen=strlen(s);\n  init();  \n  while(n--){\n    scanf(\"%s\",t);\n    tlen=strlen(t);\n    if(bynary_search())printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nchar T[1000001],P[10001];\nint n,m; // T:text, P:pattern, n:T's length, m:P's length\nint F[10001]; // Prefix Function\n\nvoid Prefix_Table(char P[], int m){\n\tint i=1,j=0;\n\tF[0] = 0;\n\twhile(i<m){\n\t\tif(P[i] == P[j]){\n\t\t\tF[i] = j+1;\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\telse if(j>0)\n\t\t\tj=F[j-1];\n\t\telse{ F[i] = 0;\n\t\t\ti++;\n\t\t}\n\t}\n}\n\nint KMP(char T[], int n, char P[], int m){\n\tint i=0,j=0;\n\tPrefix_Table(P,m);\n\twhile(i<n){\n\t\tif(T[i]==P[j]){\n\t\t\tif(j==m-1)\n\t\t\t\treturn 1;\n\t\t\telse{\n\t\t\ti++;\n\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\telse if(j>0)\n\t\t\tj=F[j-1];\n\t\telse i++;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint num;\n\tscanf(\"%s\",T);\n\tscanf(\"%d\",&num);\n\tfor(int i=1;i<=num;i++){\n\t\tscanf(\"%s\",P);\n\t\tn = strlen(T); m = strlen(P);\n\t\tif(KMP(T,n,P,m)) printf(\"1\\n\");\n\t\telse printf(\"0\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n\nbool solve(string T, string P, int len_T, int len_P)\n{\n    int k = 0;\n    int x, y;\n\n    if(len_T < len_P) return false;\n\n    while(k <= len_T - len_P){\n        for(x = len_P - 1; x >= 0; x--){\n            if(P[x] != T[k + x]) break;\n        }\n        if(x < 0) return true;\n        for(y = x; y >= 0; y--){\n            if(P[y] == T[k + x]) break;\n        }\n        k += x - y;\n    };\n    return false;\n}\n\nint main()\n{\n    string T, P; int q;\n    cin >> T >> q;\n    int n = T.size();\n    int m;\n\n    while(q){\n        cin >> P;\n        m = P.size();\n        cout << solve(T, P, n, m) << endl;\n        q--;\n    };\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto& x:c){cout<<x<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nclass SuffixArray{\n\tvector<int> InducedSort(vector<int>& str,int char_num,vector<int>& type,vector<int>& lms){\n\t\tint N=str.size();\n\t\tvector<int> SA(N,-1),bin(char_num+1,0);\n\t\tREP(i,N) bin[str[i]+1]++;\n\t\tREP(i,char_num)\tbin[i+1] += bin[i];\n\n\t\tmap<int,int> count;\n\t\tfor(int i=lms.size()-1;i>=0;i--){\n\t\t\tint ch = str[lms[i]];\n\t\t\tSA[bin[ch+1]-1-count[ch]] = lms[i];\n\t\t\tcount[ch]++;\n\t\t}\n\n\t\tcount.clear();\n\t\tREP(i,N){\n\t\t\tif(SA[i]>0 && type[SA[i]-1]!=0){\n\t\t\t\tint ch = str[SA[i]-1];\n\t\t\t\tSA[bin[ch]+count[ch]] = SA[i]-1;\n\t\t\t\tcount[ch]++;\n\t\t\t}\n\t\t}\n\n\t\tcount.clear();\n\t\tfor(int i=N-1;i>=0;i--){\n\t\t\tif(SA[i]>0 && type[SA[i]-1]!=1){\n\t\t\t\tint ch = str[SA[i]-1];\n\t\t\t\tSA[bin[ch+1]-1-count[ch]] = SA[i]-1;\n\t\t\t\tcount[ch]++;\n\t\t\t}\n\t\t}\n\t\treturn SA;\n\t}\n\n\tvector<int> SAIS(vector<int> str,int char_num){\n\t\tconstexpr int S=0,L=1;\n\t\tif(str.size()==1){\n\t\t\tvector<int> ret(1,0);\n\t\t\treturn ret;\n\t\t}\n\t\tint N=str.size();\n\n\t\tvector<int> type(N);\n\t\ttype[N-1] = S;\n\t\tfor(int i=N-2;i>=0;i--){\n\t\t\tif(str[i]<str[i+1]) type[i] = S;\n\t\t\telse if(str[i]>str[i+1]) type[i] = L;\n\t\t\telse type[i] = type[i+1];\n\t\t}\n\n\t\tauto isLMS = [&](int i){return (i>0 && type[i-1]==L && type[i]==S);};\n\t\tvector<int> lms;\n\t\tREP(i,N){\n\t\t\tif(isLMS(i)) lms.push_back(i);\n\t\t}\n\n\t\tauto SA = InducedSort(str,char_num,type,lms);\n\t\tvector<int> newSA;\n\t\tREP(i,N){\n\t\t\tif(isLMS(SA[i])) newSA.push_back(SA[i]);\n\t\t}\n\t\tswap(SA,newSA);\n\n\t\tmap<int,int> nums;\n\t\tint num = 0;\n\t\tnums[SA[0]] = num;\n\n\t\tfor(int i=0,ei=SA.size()-1;i<ei;i++){\n\t\t\tint left=SA[i],right=SA[i+1];\n\t\t\tbool diff = false;\n\t\t\tfor(int d=0;d<N;d++){\n\t\t\t\tif(str[left+d]!=str[right+d] || isLMS(left+d)!=isLMS(right+d)){\n\t\t\t\t\tdiff = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(d>0 && (isLMS(left+d) || isLMS(right+d))){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(diff) num++;\n\t\t\tnums[right] = num;\n\t\t}\n\n\t\tvector<int> new_lms;\n\t\tfor(auto& x:nums) new_lms.push_back(x.second);\n\n\t\tif(num+1<new_lms.size()){\n\t\t\tSA = SAIS(new_lms,num+1);\n\t\t}\n\t\telse{\n\t\t\tnewSA.clear();\n\t\t\tnewSA.resize(num+1);\n\t\t\tREP(i,num+1) newSA[new_lms[i]] = i;\n\t\t\tswap(SA,newSA);\n\t\t}\n\t\tfor(int i=0,ei=lms.size();i<ei;i++){\n\t\t\tnew_lms[i] = lms[SA[i]];\n\t\t}\n\t\tSA = InducedSort(str,char_num,type,new_lms);\n\n\t\treturn SA;\n\t}\n\tvector<int> Construct(int char_num){\n\t\tint N=S.size();\n\t\tvector<int> V(N);\n\t\tREP(i,N) V[i] = S[i];\n\t\tV.push_back(0);\n\t\treturn SAIS(V,char_num);\n\t}\npublic:\n\tSuffixArray(const string& str,int char_num):S(str){\n\t\tsuffix = Construct(char_num);\n\t\tSN = suffix.size();\n\t}\n\tbool Search(const string& T){\n\t\tint N=T.size();\n\t\tauto left=suffix.begin(),right=suffix.end()-1;\n\t\tauto middle=left+distance(left,right)/2;\n\t\twhile(distance(left,right)>1){\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif((*middle)+i>=SN){\n\t\t\t\t\tleft = middle;\n\t\t\t\t\tmiddle=left+distance(left,right)/2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(S[*middle+i]<T[i]){\n\t\t\t\t\tleft = middle;\n\t\t\t\t\tmiddle=left+distance(left,right)/2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(S[*middle+i]>T[i]){\n\t\t\t\t\tright = middle;\n\t\t\t\t\tmiddle=left+distance(left,right)/2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(i==N-1){\n\t\t\t\t\tright = middle;\n\t\t\t\t\tmiddle=left+distance(left,right)/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool exist = true;\n\t\tif(SN-(*right)<N){\n\t\t\texist = false;\n\t\t}\n\t\telse{\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(S[*right+i]!=T[i]){\n\t\t\t\t\texist = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn exist;\n\t}\nprivate:\n\tstring S;\n\tvector<int> suffix;\n\tint SN;\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring S=in<string>();\n\tSuffixArray suffix_array(S,256);\n\n\tint Q=in();\n\tREP(n,Q){\n\t\tstring T=in<string>();\n\t\tout(suffix_array.Search(T)?1:0);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n/*\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n-nb,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k>=nc)a[i]=b[j++];\n      else if(j>=nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n*/\nint L[1000000],R[1000000];\n\ninline void merge(int *A, const int left, const int mid, const int right, const RollingHash &rh){\n  int n1 = mid - left, n2 = right - mid;\n  REP(i,n1)L[i]=A[left+i];\n  REP(i,n2)R[i]=A[mid+i];\n  for(int k =left,i=0,j=0;k<right;k++){\n    if(n2<=j)A[k]=L[i++];\n    else if(n1<=i)A[k]=R[j++];\n    else A[k]=rh(L[i],R[j])?L[i++]:R[j++];\n  }\n}\n\nvoid mergeSort(int *A,const int left,const int right, const RollingHash &rh){\n  if(left+1<right){\n    const int mid = (left+right)/2;\n    mergeSort(A,left,mid, rh);\n    mergeSort(A,mid,right, rh);\n    merge(A,left,mid,right, rh);\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  //mergesort(n,sa,rh);\n  mergeSort(sa,0,n,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <assert.h>\n#include <iomanip>\n#include <bitset>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <functional>\n#include <fstream>\n#include <random>\n\n#define LEN(x) (long long)(x.size())\n#define FOR(i, a, n) for(int i=(a);i<(n); ++i)\n#define FOE(i, a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v, x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT_COUNT(bit) (__builtin_popcount(bit))\n\ntypedef long long LL;\ntemplate<typename T> std::vector<T> make_v(size_t a){return std::vector<T>(a);}\ntemplate<typename T,typename... Ts> auto make_v(size_t a, Ts... ts){ return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}    // C++14\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value==0>::type fill_v(T &t,const V &v){t=v;}\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value!=0>::type fill_v(T &t,const V &v){for(auto &e:t) fill_v(e,v);}\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\nvoid print() { std::cout << std::endl; }\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) { std::cout << head; if (sizeof...(tail) != 0) {std::cout << \" \";} print(std::forward<Tail>(tail)...); }\ntemplate <class T> void print(std::vector<T> &v) {for (auto& a : v) { std::cout << a; if (&a != &v.back()) {std::cout << \" \";} }std::cout << std::endl;}\ntemplate <class T> void print(std::vector<std::vector<T>> &vv) { for (auto& v : vv) { print(v); }}\nvoid debug() { std::cerr << std::endl; }\ntemplate <class Head, class... Tail> void debug(Head&& head, Tail&&... tail) { std::cerr << head; if (sizeof...(tail) != 0) {std::cerr << \" \";} print(std::forward<Tail>(tail)...); }\ntemplate <class T> void debug(std::vector<T> &v) {for (auto& a : v) { std::cerr << a; if (&a != &v.back()) {std::cerr << \" \";} }std::cerr << std::endl;}\ntemplate <class T> void debug(std::vector<std::vector<T>> &vv) { for (auto& v : vv) { print(v); }}\ninline bool inside(long long y, long long x, long long H, long long W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\nbool is_bit_on(const unsigned long long bit, const unsigned int i) { return (bit >> i) & 1u; }\nunsigned long long bit_set(const unsigned long long bit, const unsigned int i, const unsigned int b) {\n    assert(b == 0 or b == 1);\n    if (b == 0) { return bit & ~(1ull << i); }\n    else        {return bit | (1ull << i); }\n}\n\n// 初項s交差d長さnの数列の和\nlong long sum_of_arithmetic_progression(long long s, long long d, long long n) {\n    return n * (2 * s + (n - 1) * d) / 2;\n}\n\n// xが2の階乗かどうか判定\nbool is_power_of_two(long long x) {\n    return !(x & (x - 1));\n}\n\nlong long gcd(long long a, long long b) {\n    if (b == 0) { return a; }\n    return gcd(b, a % b);\n}\n\nlong long gcd(std::vector<long long> &v) {\n    long long ans = v[0];\n    for (int i = 1; i < (int) v.size(); ++i) {\n        ans = gcd(ans, v[i]);\n    }\n    return ans;\n}\n\nlong long lcm(long long a, long long b) {\n    long long g = gcd(a, b);\n    return a / g * b;\n}\n\nconst int INF = 1u << 30u;  // 1,073,741,824\nconst long long LINF = 1ull << 60u;\nconst double EPS = 1e-9;\nconst long double PI = acos(-1.0);\nconst std::vector<int> dy2 = {0, 1}, dx2 = {1, 0};\nconst std::vector<int> dy4 = {0, 1, 0, -1}, dx4 = {1, 0, -1, 0};\nconst std::vector<int> dy8 = {0, -1, 0, 1, 1, -1, -1, 1}, dx8 = {1, 0, -1, 0, 1, 1, -1, -1};\n\ntemplate<class T> class SparseTable {\n    const int n;\n    std::vector<std::vector<long long>> table1, table2;\n    std::vector<long long> lookup1, lookup2;\n\npublic:\n    SparseTable(int n) : n(n) {};\n\n    void build(const std::vector<T> &line) {\n        this->build(line, this->table1, this->lookup1, 1);\n        this->build(line, this->table2, this->lookup2, -1);\n    }\n\n    // v[l, r)の最小値\n    long long range_minimum_query(const int l, const int r) const {\n        const int b = this->lookup1[r - l];\n        return std::min(this->table1[b][l], this->table1[b][r - (1u << (unsigned int)b)]);\n    }\n\n    // v[l, r)の最大値\n    long long range_maximum_query(const int l, const int r) const {\n        const int b = this->lookup2[r - l];\n        return -std::min(this->table2[b][l], this->table2[b][r - (1u << (unsigned int)b)]);\n    }\n\n\nprivate:\n    void build(const std::vector<T> &line, std::vector<std::vector<long long>> &table, std::vector<long long> &lookup, int fix) {\n        int b = 0;\n        while((int)(1u << (unsigned int)b) <= this->n) {\n            ++b;\n        }\n        table.resize(b, std::vector<long long>(1u << (unsigned int)b));\n        for (int i = 0; i < this->n; i++) {\n            table[0][i] = line[i] * fix;\n        }\n\n        for (int i = 1; i < b; i++) {\n            for (int j = 0; j + (1u << (unsigned int)i) <= (1u << (unsigned int)b); j++) {\n                table[i][j] = std::min(table[i - 1][j], table[i - 1][j + (1u << (unsigned int)(i - 1))]);\n            }\n        }\n\n        lookup.resize(this->n + 1);\n        for(int i = 2; i < (int)lookup.size(); i++) {\n            lookup[i] = lookup[(unsigned int)i >> 1u] + 1;\n        }\n    }\n};\n\nclass SuffixArray {\nprivate:\n    int n;\n    int k;\n    std::vector<int> rank;\n    SparseTable<int> sparse_table;\n\npublic:\n    const std::string s;\n    std::vector<int> sa;\n    std::vector<int> lcp;\n\npublic:\n    SuffixArray(const std::string &s) : n(s.size()), sparse_table((int)s.size() + 1), s(s) {\n        this->sa.resize(n + 1, 0);\n        this->lcp.resize(n + 1, 0);\n        this->rank.resize(n + 1, 0);\n    }\n\n    // O(n log^2 n)\n    void build_suffix_array() {\n        this->construct_sa();\n        this->construct_lcp();\n    }\n\n    void build_sparse_table() {\n        this->sparse_table.build(this->sa);\n    }\n    \n    // sがpatternを含んでいるか\n    // O(|pattern| log |S|)\n    bool contain(const std::string &pattern) const {\n        return this->contain(pattern, 0, this->n);\n    }\n\n    // s[left, right)がpatternを含んでいるか\n    // O(|pattern| log |S|)\n    bool contain(const std::string &pattern, int left, int right) const {\n        assert(left >= 0);\n        assert(right <= this->n);\n        assert(left < right);\n\n        const int pattern_size = pattern.length();\n        while (right - left > 1) {\n            int c = (left + right) / 2;\n            // Sのsa[c]文字目から|pattern|文字をpatternを比較\n            if (this->s.compare(this->sa[c], pattern_size, pattern) < 0) {\n                left = c;\n            }\n            else {\n                right = c;\n            }\n        }\n\n        return this->s.compare(this->sa[right], pattern_size, pattern) == 0;\n    }\n\n    // s上にpatternが何回出現するか(重なりを許す)\n    bool count(const std::string &pattern) const {\n        // return find_last(pattern) - find_first(pattern);\n        return false;\n    }\n\n    // s上で最初にpatternが出現する位置(0-index)\n    int find_first(const std::string &pattern) const {\n        const auto l = this->lower_bound_sa(pattern);\n        const auto u = this->upper_bound_sa(pattern);\n        if (l == -1 or u == -1) {\n            return -1;\n        }\n        return this->sparse_table.range_minimum_query(l, u + 1);\n    }\n\n    // s上で最後にpatternが出現する位置(0-index)\n    int find_last(const std::string &pattern) const {\n        const auto l = this->lower_bound_sa(pattern);\n        const auto u = this->upper_bound_sa(pattern);\n        if (l == -1 or u == -1) {\n            return -1;\n        }\n        return this->sparse_table.range_maximum_query(l, u + 1);\n    }\n\n    // sa上で最初にpatternが現れる位置\n    int lower_bound_sa(const std::string &pattern) const {\n        const int pattern_size = pattern.size();\n\n        int left = -1, right = n;\n        while (right - left > 1) {\n            int c = (left + right) / 2;\n            int ret = this->s.compare(this->sa[c], pattern_size, pattern);\n            // patternが大きい\n            if (ret >= 0) {\n                right = c;\n            }\n            else {\n                left = c;\n            }\n        }\n        if (this->s.compare(this->sa[right], pattern_size, pattern) == 0) {\n            return right;\n        }\n        return -1;\n    }\n\n    // sa上で最後にpatternが現れる位置\n    int upper_bound_sa(const std::string &pattern) const {\n        const int pattern_size = pattern.size();\n\n        int left = -1, right = this->n + 1;\n        while (right - left > 1) {\n            int c = (left + right) / 2;\n            int ret = this->s.compare(this->sa[c], pattern_size, pattern);\n            // patternが小さい\n            if (ret <= 0) {\n                left = c;\n            }\n            else {\n                right = c;\n            }\n        }\n\n        if (this->s.compare(this->sa[left], pattern_size, pattern) == 0) {\n            return left;\n        }\n        return -1;\n    }\n\n    void debug() {\n        std::cout << \"idx lcp sa sa[i]\" << std::endl;\n        for (int i = 0; i <= n; ++i) {\n            std::cout << i << \" \" << lcp[i] << \" \" << sa[i] << \" \" << s.substr(sa[i]) << std::endl;\n        }\n    }\n\nprivate:\n    struct compare {\n        compare(const SuffixArray &sa) : sa(sa) {}\n        const SuffixArray &sa;\n\n        // (rank[i], rank[i + k])と(rank[j], rank[j + k])を比較\n        bool operator()(const int &i, const int &j) const {\n            if (sa.rank[i] != sa.rank[j]) {\n                return sa.rank[i] < sa.rank[j];\n            }\n            else {\n                const int ri = i + sa.k <= sa.n ? sa.rank[i + sa.k] : -1;\n                const int rj = j + sa.k <= sa.n ? sa.rank[j + sa.k] : -1;\n                return ri < rj;\n            }\n        }\n    };\n\n    void construct_sa() {\n        std::vector<int> tmp(this->n + 1, 0);\n\n        for (int i = 0; i <= this->n; i++) {\n            this->sa[i] = i;\n            this->rank[i] = i < this->n ? this->s[i] : -1;\n        }\n        // k文字についてソートされているところから、2k文字でソートする\n        for (this->k = 1; this->k <= this->n; this->k *= 2) {\n            std::sort(this->sa.begin(), this->sa.end(), compare(*this));\n            // いったんtmpに次のランクを計算し、それからrankに移す\n            tmp[this->sa[0]] = 0;\n            for (int i = 1; i <= this->n; i++) {\n                tmp[this->sa[i]] = tmp[this->sa[i - 1]] + (compare(*this).operator()(this->sa[i - 1], this->sa[i]) ? 1 : 0);\n            }\n            for (int i = 0; i <= this->n; i++) {\n                this->rank[i] = tmp[i];\n            }\n        }\n    }\n\n    void construct_lcp() {\n        for (int i = 0; i <= this->n; i++) {\n            this->rank[this->sa[i]] = i;\n        }\n        int h = 0;\n        this->lcp[0] = 0;\n        for (int i = 0; i < this->n; i++) {\n            // 文字列中での位置iの接尾辞と、接尾辞配列中でその1つ前の接尾辞のLCPを求める\n            int j = this->sa[this->rank[i] - 1];\n            // hを先頭の分1減らし、後ろが一致しているだけ増やす\n            if (h > 0) {\n                h--;\n            }\n            for (; j + h < this->n and i + h < this->n; h++) {\n                if (this->s[j + h] != this->s[i + h]) {\n                    break;\n                }\n            }\n            this->lcp[this->rank[i] - 1] = h;\n        }\n    }\n};\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    string T;\n    cin >> T;\n\n    SuffixArray sa(T);\n    sa.build_suffix_array();\n\n    int Q;\n    cin >> Q;\n    for (int i = 0; i < Q; ++i) {\n        string P;\n        cin >> P;\n\n        if (sa.contain(P)) {\n            cout << 1 << endl;\n        }\n        else {\n            cout << 0 << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\n#define NUM 48\nusing namespace std;\n\nint T_char_count[128] = {0},P_char_count[128];\n\nclass LocRecord{\n\npublic:\n\t//?????¢???????¢????\n\tLocRecord(){\n\t\tlocationTable = new int*[128];\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t}\n\n\t//-1?????£??\\\n\tvoid init(){\n\t\tint limit;\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init_index(){\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t}\n\n\tvoid regist_loc(int ch, int location){\n\t\tlocationTable[ch][index[ch]] = location;\n\t\tindex[ch]++;\n\t}\n\n\tint next_loc(int ch){\n\t\tint ret = locationTable[ch][index[ch]];\n\t\tindex[ch]++;\n\t\treturn ret;\n\t}\n\nprivate:\n\tint** locationTable;\n\tint index[128];\n};\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\t\t\treturn length < arg.length;\n\t};\n\tInfo(int arg_length,int arg_id,ull arg_hashValue){\n\t\tlength = arg_length;\n\t\tid = arg_id;\n\t\thashValue = arg_hashValue;\n\t\tused = false;\n\t}\n\n\tint length,id;\n\tull hashValue;\n\tbool used;\n};\n\nint main(){\n\n\tfor(int i = 0; i < 128; i++)T_char_count[i] = 0;\n\n\tint T_length;\n\n\tchar* T = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tfor(T_length = 0; T[T_length] != '\\0';T_length++){\n\t\tT_char_count[T[T_length]]++;\n\t}\n\n\tLocRecord locRecord;\n\tlocRecord.init();\n\n\t//T[i]????????????i??§???????????¨????¨????\n\tfor(int i = 0; i < T_length; i++){\n\t\tlocRecord.regist_loc(T[i],i);\n\t}\n\n\tull* HASH = new ull[T_length+1];\n\tull* P = new ull[T_length+1];\n\n\tHASH[0] = 0;\n\tP[0] = 1;\n\n\t//T??????????????\\???????±???????\n\tfor(int i = 1; i <= T_length; i++){\n\t\tHASH[i] = T[i-1] + HASH[i-1]*MOD;\n\t\tP[i] = P[i-1]*MOD;\n\t}\n\n\n\tvector<Info> V[128];\n\n\tint Q,S_length,left,P_char_count[128];\n\tscanf(\"%d\",&Q);\n\n\tbool check[Q];\n\n\tfor(int i = 0; i < Q; i++)check[i] = false;\n\n\tchar S[1001];\n\tull S_HASH[1001],S_value,T_value,D;\n\tbool FLG;\n\n\t//Q??¶??????????????\\???????¨????\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",S);\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tP_char_count[i] = 0;\n\t\t}\n\n\t\tfor(S_length = 0;S[S_length] != '\\0';S_length++){\n\t\t\tP_char_count[S[S_length]]++;\n\t\t}\n\n\t\tFLG = true;\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tif(T_char_count[i] < P_char_count[i]){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG)continue;\n\n\n\t\tS_HASH[0] = 0;\n\t\tfor(int i = 1; i <= S_length; i++){\n\t\t\tS_HASH[i] = S[i-1] + S_HASH[i-1]*MOD;\n\t\t}\n\n\t\tS_value = S_HASH[S_length];\n\n\t\tV[S[0]].push_back(Info(S_length,loop,S_value));\n\t}\n\n\tint calc_length;\n\n\tfor(int word = 48; word <= 122; word++){\t//vector????????????\n\n\t\tif(V[word].size() == 0)continue;\n\n\t\tlocRecord.init_index();\n\n\t\twhile((left = locRecord.next_loc(word)) != -1){ //??´???????????????\n\t\t\tfor(int i = 0; i < V[word].size();i++){ //?????????????????????\n\t\t\t\tif(V[word][i].used)continue;\n\n\t\t\t\tcalc_length = V[word][i].length;\n\t\t\t\tS_value = V[word][i].hashValue;\n\n\t\t\t\tif(left+calc_length-1 >= T_length)break;\n\n\t\t\t\tT_value = HASH[left+calc_length]-HASH[left]*P[calc_length];\n\n\t\t\t\tif(T_value == S_value){\n\t\t\t\t\tcheck[V[word][i].id] = true;\n\t\t\t\t\tV[word][i].used = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tif(check[i])printf(\"1\\n\");\n\t\telse{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct RMQ{\n  int n;\n  vector<int> dat;\n  const int def=INT_MAX;\n  RMQ(){}\n  RMQ(int n_){init(n_);}\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,def);\n    }\n  void update(int k,int a){\n    k+=n-1;\n    dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  int query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return def;\n    if(a<=l&&r<=b) return dat[k];\n    else{\n      int vl=query(a,b,k*2+1,l,(l+r)/2);\n      int vr=query(a,b,k*2+2,(l+r)/2,r);\n      return min(vl,vr);\n    }\n  }\n  int query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n};\n\nstruct SA{\n  int n,k;\n  string S;\n  vector<int> r,r2,t,sa,lcp;\n  SA(){}\n  SA(string S):S(S){init();}\n  void init(){\n    n=S.size();\n    r.clear();\n    r2.clear();\n    t.clear();\n    sa.clear();\n    lcp.clear();\n    r.resize(n+1,0);\n    r2.resize(n+1,0);\n    t.resize(n+1,0);\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    constract_sa();\n  }\n  bool compare_sa(int i,int j){\n    if(r[i]!=r[j]) return r[i]<r[j];\n    else{\n      int ri=i+k<=n?r[i+k]:-1;\n      int rj=j+k<=n?r[j+k]:-1;\n      return ri<rj;\n    }\n  }\n  void constract_sa(){\n    n=S.length();\n    for(int i=0;i<=n;i++){\n      sa[i]=i;\n      r[i]=i<n?S[i]:-1;\n    }\n    for(k=1;k<=n;k*=2){\n      sort(sa.begin(),sa.end(),[&](const int &i, const int &j){\n\t  if(r[i]!=r[j]) return r[i]<r[j];\n\t  else{\n\t    int ri=i+k<=n?r[i+k]:-1;\n\t    int rj=j+k<=n?r[j+k]:-1;\n\t    return ri<rj;\n\t  }\n\t});\n      t[sa[0]]=0;\n      for(int i=1;i<=n;i++){\n\tt[sa[i]]=t[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n      }\n      for(int i=0;i<=n;i++){\n\tr[i]=t[i];\n      }\n    }\n  }\n  void constract_lcp(){\n    for(int i=0;i<=n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  bool contains(string T){\n    int a=0,b=S.length()+1;\n    while(b-a>1){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\tif(S.compare(sa[c],tl,T)<0||\n\t   (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n\telse b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n\n  int count(string T,RMQ &rmq){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(b[i]-a[i]>1){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n  \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n  \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n  \n    return a[1]-b[0]+1;\n  }\n};\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SA sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\n\nstruct PMA{\n    PMA *next[256];\n    Vec matched;\n    PMA(){ fill(next,next+256,(PMA*)0); }\n};\n\nVec set_union(const Vec &a,const Vec &b){\n    int i = 0, j = 0, A = a.size(), B = b.size();\n    Vec res;\n    while(i < A && j < B){\n\tif(a[i] == b[j]){\n\t    res.push_back(a[i]);\n\t    i++; j++;\n\t}else if(a[i] > b[j]){\n\t    res.push_back(b[j++]);\n\t}else{\n\t    res.push_back(a[i++]);\n\t}\n    }\n    for( ; i < A ; i++) res.push_back(a[i]);\n    for( ; j < B ; j++) res.push_back(b[j]);\n    return res;\n}\n\nPMA *buildPMA(char *pattern[],int size){\n    PMA *root = new PMA;\n    for(int i = 0 ; i < size ; i++){\n\tPMA *t = root;\n\tfor(int j = 0 ; pattern[i][j] != '\\0' ; j++){\n\t    char c = pattern[i][j];\n\t    if(t->next[c] == NULL) t->next[c] = new PMA;\n\t    t = t->next[c];\n\t}\n\tt->matched.push_back(i);\n    }\n    queue<PMA*> Q;\n    for(int i = 'a' ; i <= 'z' ; i++){\n\tif(root->next[i]){\n\t    root->next[i]->next[0] = root;\n\t    Q.push(root->next[i]);\n\t}else{\n\t    root->next[i] = root;\n\t}\n    }\n    while(!Q.empty()){\n\tPMA *t = Q.front(); Q.pop();\n\tfor(int i = 'a' ; i <= 'z' ; i++){\n\t    if(t->next[i]){\n\t\tPMA *next = t->next[0];\n\t\twhile(!next->next[i]) next = next->next[0];\n\t\tt->next[i]->next[0] = next->next[i];\n\t\tt->next[i]->matched =\n\t\t    set_union(t->next[i]->matched,next->next[i]->matched);\n\t\tQ.push(t->next[i]);\n\t    }\n\t}\n    }\n    return root;\n}\n\nvoid match(PMA *pma,const char *s,Vec &res){\n    for(int i = 0 ; s[i] != '\\0' ; i++){\n\tint c = s[i];\n\twhile(!pma->next[c]) pma = pma->next[0];\n\tpma = pma->next[c];\n\tfor(int j = 0 ; j < (int)pma->matched.size() ; j++){\n\t    res[pma->matched[j]] = 1;\n\t}\n    }\n}\n\nchar T[1000001];\nchar *P[10000];\n\nint main(){\n    int Q;\n    scanf(\"%s%d\",T,&Q);\n    for(int i = 0 ; i < Q ; i++){\n\tP[i] = new char[1001];\n\tscanf(\"%s\",P[i]);\n    }\n    PMA *pma = buildPMA(P,Q);\n    Vec res(Q);\n    match(pma,T,res);\n    for(auto x : res){\n\tprintf(\"%d\\n\",x);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstdlib>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define REPV(i, v, n) for (int i=0,tmp=v;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define DWN(i, b, a) for (int i=int(b-1);i>=int(a);--i)\n\nusing namespace std;\n\ntypedef unsigned char byte;\n\nbyte mask[] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };\n#define tget(i) !!(t[(i)>>3]&mask[(i)&7])\n#define tset(i, b) t[(i)>>3]=(b) ? (mask[(i)&7]|t[(i)>>3]) : ((~mask[(i)&7])&t[(i)>>3])\n#define chr(i) (cs==sizeof(int)?((int*)s)[i]:((byte *)s)[i])\n#define isLMS(i) (i>0 && tget(i) && !tget(i-1))\n\nvoid getBuckets(byte *s, int *bkt, int n, int K, int cs, bool end=true){\n  fill(bkt, bkt + K + 1, 0);\n  REP(i,n)bkt[chr(i)]++;\n  REPV(i, 0, K+1)tmp += bkt[i], bkt[i] = end ? tmp : tmp - bkt[i];\n}\n\nvoid induceSAl(byte *t, int *SA, byte *s, int *bkt, int n, int K, int cs, bool end=false){\n  getBuckets(s, bkt, n, K, cs, end);\n  REP(i,n)if(SA[i]>0 && !tget(SA[i]-1)) SA[ bkt[chr(SA[i]-1)]++ ] = SA[i]-1;\n}\n\nvoid induceSAs(byte *t, int *SA, byte *s, int *bkt, int n, int K, int cs, bool end=true){\n  getBuckets(s, bkt, n, K, cs, end);\n  DWN(i,n,0)if(SA[i]>0 && tget(SA[i]-1))SA[--bkt[chr(SA[i]-1)]] = SA[i]-1;\n}\n\nvoid SA_IS(byte *s, int *SA, int n, int K=128, int cs=1) {\n  byte t[(n >> 3) + 1];\n  int bkt[K + 1],n1=0,name=0;\n\n  tset(n-2, 0), tset(n-1, 1);\n  DWN(i,n-2,0)tset(i, (chr(i)<chr(i+1) || (chr(i)==chr(i+1) && tget(i+1))));\n  getBuckets(s, bkt, n, K, cs);\n  fill(SA, SA+n, -1);\n  FOR(i,1,n)if(isLMS(i))SA[--bkt[chr(i)]] = i;\n\n  induceSAl(t, SA, s, bkt, n, K, cs);\n  induceSAs(t, SA, s, bkt, n, K, cs);\n\n  REP(i,n)if(isLMS(SA[i]))SA[n1++] = SA[i];\n  fill(SA + n1, SA + n, -1);\n\n  REPV(i,-1,n1){\n    int pos = SA[i], diff = false;\n    for(int d = 0; d < n && !diff; d++){\n      diff = chr(pos+d) != chr(tmp+d) || tget(pos+d) != tget(tmp+d);\n      if(!diff && d && (isLMS(pos+d) || isLMS(tmp+d)))break;\n    }\n    if(diff)name++,tmp=pos;\n    SA[ n1 + ((pos - (pos & 1)) >> 1) ] = name - 1;\n  }\n  int *s1 = SA + n - n1;\n  for(int i=n-1,j=n-1;i>=n1;i--)if(SA[i]>=0)SA[j--]=SA[i];\n  if(name < n1)SA_IS((byte*)s1, SA, n1, name - 1, sizeof(int));\n  else REP(i,n1)SA[s1[i]]=i;\n\n  getBuckets(s, bkt, n, K, cs);\n  for(int i = 1, j = 0; i < n; i++)if(isLMS(i))s1[j++] = i;\n  REP(i,n1)SA[i]=s1[SA[i]];\n  fill(SA + n1, SA + n, -1);\n\n  DWN(i,n1,0){\n    int tmp = SA[i];\n    SA[i] = -1, SA[--bkt[chr(tmp)]] = tmp;\n  }\n  induceSAl(t, SA, s, bkt, n, K, cs);\n  induceSAs(t, SA, s, bkt, n, K, cs);\n}\n\nconst int maxn = 1000001;\nint n,sa[maxn];\n\nbool contain(string S, int *sa, string T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nchar a[maxn],b[maxn];\n\nint main(void){\n  int q;\n  scanf(\"%s\", a);\n  string s = string(a);\n  SA_IS((byte*) s.c_str(), sa, s.size()+1);\n\n  scanf(\"%d\", &q);\n  while(q--){\n    scanf(\"%s\", b);\n    if(contain(s, sa, string(b))) printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n,0);\n    lcp.resize(n,0);\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    vector<int> c(n,0),ord(n,0);\n    for(int i=0;i<n;i++) ord[i]=n-1-i;\n    sort(ord.begin(),ord.end(),[&](int a,int b){return S[a]<S[b];});\n    \n    for(int i=0;i<n;i++){\n      sa[i]=ord[i];\n      c[i]=S[i];\n    }\n    \n    for(int len=1;len<n;len*=2){\n      vector<int> r=c;\n      for(int i=0;i<n;i++){\n\t c[sa[i]] = i > 0 && r[sa[i - 1]] == r[sa[i]] && sa[i - 1] + len < n && r[sa[i - 1] + len / 2] == r[sa[i] + len / 2] ? c[sa[i - 1]] : i;\n      }\n      vector<int> cnt(n);\n      for(int i=0;i<n;i++) cnt[i]=i;\n      vector<int> s=sa;\n      for(int i=0;i<n;i++){\n\tint s1=s[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n    }\n  }\n  bool contains(string T){\n    int a=0,b=S.length()+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==(int)S.length()+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n+1);\n    for(int i=0;i<=n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf INT_MAX\n#define INF LLONG_MAX\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n#define int ll\n#define vi vector<int>\n#define IP pair<int,P>\n#define PI pair<P,int>\n#define PP pair<P,P>\n#define Yes(f){cout<<(f?\"Yes\":\"No\")<<endl;}\n#define YES(f){cout<<(f?\"YES\":\"NO\")<<endl;}\nint Madd(int x,int y) {return (x+y)%M;}\nint Msub(int x,int y) {return (x-y+M)%M;}\nint Mmul(int x,int y) {return (x*y)%M;}\n\n\nstruct SuffixArray {\n  vector< int > SA;\n  const string s;\n\n  SuffixArray(const string &str) : s(str) {\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](int a, int b) {\n      return s[a] == s[b] ? a > b : s[a] < s[b];\n    });\n    vector< int > classes(s.size()), c(s.begin(), s.end()), cnt(s.size());\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const {\n    return SA[k];\n  }\n\n  size_t size() const {\n    return s.size();\n  }\n\n  bool lt_substr(const string &t, int si = 0, int ti = 0) {\n    int sn = (int) s.size(), tn = (int) t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return true;\n      if(s[si] > t[ti]) return false;\n      ++si, ++ti;\n    }\n    return si >= sn && ti < tn;\n  }\n\n  int lower_bound(const string &t) {\n    int low = -1, high = (int) SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) / 2;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return high;\n  }\n\n  pair< int, int > lower_upper_bound(string &t) {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = (int) SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) / 2;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return {idx, high};\n  }\n\n  void output() {\n    for(int i = 0; i < size(); i++) {\n      cout << i << \": \" << s.substr(SA[i]) << endl;\n    }\n  }\n};\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout<<fixed<<setprecision(20);\n\n  string s;\n  cin>>s;\n  int q;\n  cin>>q;\n  SuffixArray sa(s);\n  while(q--){\n    string t;\n    cin>>t;\n    P range = sa.lower_upper_bound(t);\n    cout<<(range.F!=range.S)<<endl;\n  }\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring sa[1000000], p;\nint plen;\n\nbool binary_search(int left, int right) {\n    if (left > right) {\n        return false;\n    }\n    int pivot = (left + right) / 2;\n\n    if (p == sa[pivot].substr(0, plen)) {\n        return true;\n    }\n    else if (p < sa[pivot]) {\n        return binary_search(left, pivot - 1);\n    }\n    else {\n        return binary_search(pivot + 1, right);\n    }\n}\n\nint main() {\n    int len, n;\n    string str;\n    \n    cin >> str;\n    len = str.size();\n\n    for (int i = 0; i < len; i++) {\n        sa[i] = str.substr(i);\n    }\n    sort(sa, sa + len);\n\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> p;\n        plen = p.size();\n        cout << binary_search(0, len - 1) << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring S,T;\nstring V[100000][100];\nint main(){\n\tint q,a,b;\n\tb=S.size();\n\tcin>>S;\n\ta=min(b,100);\n\tfor(int i=1;i<100;i++){\n\t\tfor(int j=0;j<S.size()-i;j++){\n\t\t\tV[j][i]=S.substr(j,i);\n\t\t}\n\t}\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>T;\n\t\tfor(int j=0;j<S.size()-T.size();j++){\n\t\t\tif(V[j][T.size()]==T){\n\t\t\t\tcout<<\"1\"<<endl;\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t}\n\t\tcout<<\"0\"<<endl;\n\t\tExit:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n\n\nint main() {\n\tint n;\n\tstring text;\n\tstring pattern;\n\tcin >> text >> n;\n\n\tfor (int i = 0; i < n; ++i){\n\t\tcin >> pattern;\n\t\tstring::size_type index = text.find(pattern);\n\t\tif (index == std::string::npos) {\n\t\t\tcout << 0 << endl;\n\t\t} else {\n\t\t\tcout << 1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n/2+n%2,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==nc)a[i]=b[j++];\n      else if(j==nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nusing namespace std;\n\nbool solve(string T, string P)\n{\n\tint ft[100000];\n\tft[0] = -1;\n\tft[1] = 0;\n\tfor (int i = 2, j = 0; i <= P.size();)\n\t{\n\t\tif (P[i - 1] == P[j])\n\t\t{\n\t\t\tft[i++] = ++j;\n\t\t}\n\t\telse if (j > 0)\n\t\t{\n\t\t\tj = ft[j];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tft[i++] = 0;\n\t\t}\n\t}\n\n\tint i = 0, j = 0;\n\twhile (i < T.size())\n\t{\n\t\tif (T[i] == P[j])\n\t\t{\n\t\t\ti++;\n\t\t\tj++;\n\n\t\t\tif (j == P.size())\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse if (j == 0)\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tj = ft[j];\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\tstring T;\n\tint Q;\n\n\tcin >> T;\n\tcin >> Q;\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tstring P;\n\t\tcin >> P;\n\t\tprintf(solve(T, P) ? \"1\\n\" : \"0\\n\");\n\t}\n\n\treturn 0;\n}\n\n/*int main()\n{\n\tstring T, P;\n\tcin >> T >> P;\n\n\tint ft[100000];\n\tft[0] = 0;\n\tfor (int i = 1, j = 0; i < P.size(); i++)\n\t{\n\t\tif (P[i] != P[j])\n\t\t{\n\t\t\tft[i] = 0;\n\t\t\tj = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tft[i] = ++j;\n\t\t}\n\t}\n\n\tint i = 0, j = 0;\n\twhile (i < T.size())\n\t{\n\t\tif (T[i] == P[j])\n\t\t{\n\t\t\ti++;\n\t\t\tj++;\n\n\t\t\tif (j == P.size())\n\t\t\t{\n\t\t\t\tcout << i - P.size() << endl;\n\t\t\t\tj = ft[j - 1];\n\t\t\t}\n\t\t}\n\t\telse if (j == 0)\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tj = ft[j - 1];\n\t\t}\n\t}\n\n\treturn 0;\n}*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\n\n#define fi(x) get<0>(x)\n#define se(x) get<1>(x)\n\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\ntypedef vector<pll> vpl;\n\nstring t;\nstring p;\nlli q;\n\nvll sa;\nvll tmp;\nvll rnk_;\nvll rnk;\n\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> t;\n    sa = vll(t.size());rnk = vll(t.size()),rnk_ = vll(t.size());tmp = vll(t.size());\n    for(lli i = 0;i < t.size();i++) sa[i] = i;\n    for(lli i = 0;i < t.size();i++) rnk[i] = t[i];\n    sort(sa.begin(),sa.end(),[](lli a,lli b){\n        return rnk[a] < rnk[b];\n    });\n    for(lli k = 1;k < t.size();k *= 2){\n        lli from = 0;\n        lli to = 0;\n        lli j = 0;\n        do{\n            from = to;\n            while(rnk[sa[from]] == rnk[sa[to]]) to++;\n            for(lli i = from;i < to;i++) rnk_[sa[i]] = sa[i]+k < sa.size() ? rnk[sa[i]+k] : -1;\n            sort(sa.begin()+from,sa.begin()+to,[](lli a,lli b){\n                return rnk_[a] < rnk_[b];\n            });\n        }while(to < sa.size());\n        tmp[sa[0]] = 0;\n        for(lli i = 1;i < sa.size();i++){\n            lli c = 1;\n            if(rnk[sa[i-1]] == rnk[sa[i]] && rnk_[sa[i-1]] == rnk_[sa[i]]) c = 0;\n            tmp[sa[i]] = tmp[sa[i-1]] + c;\n\n        }\n        for(lli i = 0;i < sa.size();i++){\n            rnk[sa[i]] = tmp[sa[i]];\n        }\n    }\n    sort(sa.begin(),sa.end(),[](lli a,lli b){\n        return rnk[a] < rnk[b];\n    });\n    //for(lli i = 0;i < sa.size();i++) cout << sa[i] << endl;\n    /*\n    for(lli i = 0;i < sa.size();i++){\n        for(lli j = sa[i];j < t.size();j++) cout << t[j];\n        cout << endl;\n    }\n    */\n    \n    cin >> q;\n    for(lli i = 0;i < q;i++){\n        cin >> p;\n        auto from = sa.begin();\n        auto to = sa.end();\n        for(lli i = 0;i < p.size();i++){\n            from = lower_bound(from,to,p[i],[i](lli x,char c){\n                if(x+i >= t.size()) return false;\n                return t[x+i] < c;\n            });\n            to = lower_bound(from,to,p[i],[i](lli x,char c){\n                if(x+i >= t.size()) return false;\n                return t[x+i] < c+1;\n            });\n            //cout << from-sa.begin() << \" \" << to-sa.begin() << endl;\n        }\n        if(to-from > 0) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    //return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n    return i+k >= n ? 0 : j+k >= n ? 1 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n/2+n%2,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==nc)a[i]=b[j++];\n      else if(j==nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  /*\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n  */\n  int sa[rh.n+1];\n  REP(i,rh.n+1)sa[i]=i;\n  sort(sa,sa+rh.n+1,rh);\n  vector<int>res(rh.n+1);\n  REP(i,rh.n+1)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nclass SuffixArrayInducedSorting\n{\nprivate:\n    static constexpr int encode(const int c) { return c == '$' ? 0 : 'a' <= c and c <= 'z' ? c - 'a' + 1 : 'A' <= c and c <= 'Z' ? c - 'A' + 27 : c - '0' + 53; }\n    static constexpr char decode(const int n) { return (n == 0 ? '$' : 'a' + n - 1); }\n    enum class Type : char {\n        L = 0,\n        S = 1,\n        LMS = 2,\n    };\n\npublic:\n    SuffixArrayInducedSorting(const string& s, const int kind_) : N(s.size() + 1), kind{kind_ + 1}, S(s.size() + 1, 0), type(N), next(N, 1), bucket(kind), num(kind, 0), head(kind, 0), tail(kind, 0)\n    {\n        for (int i = 0; i < s.size(); i++) {\n            S[i] = encode(s[i]);\n        }\n        initializeData();\n        sortLMS();\n    }\n    SuffixArrayInducedSorting(const vector<int>& s, const int kind_) : N(s.size() + 1), kind{kind_ + 1}, S(s), type(N), next(N, 1), bucket(kind), num(kind, 0), head(kind, 0), tail(kind, 0)\n    {\n        S.push_back(0);\n        initializeData();\n        sortLMS();\n    }\n    void debugPrint() const\n    {\n        for (int i = 0; i < N; i++) {\n            cout << decode(S[i]);\n        }\n        cout << endl;\n        for (int i = 0; i < N; i++) {\n            cout << (type[i] == Type::L ? \"L\" : \"S\");\n        }\n        cout << endl;\n        for (int i = 0; i < N; i++) {\n            cout << (type[i] == Type::LMS ? \"@\" : \" \");\n        }\n        cout << endl;\n        for (int i = 0; i < kind; i++) {\n            if (bucket[i].empty())\n                continue;\n            cout << \"[\" << decode(i) << \"]:\\n\";\n            for (const int p : bucket[i]) {\n                cout << \"  \" << p << endl;\n            }\n        }\n    }\n\n    vector<int> getSuffixArray() const\n    {\n        vector<int> ans(N - 1);\n        for (int pos = 0, i = 1; i < kind; i++) {  // 番兵以外\n            for (const int p : bucket[i]) {\n                ans[pos++] = p;\n            }\n        }\n        return ans;\n    }\n\nprivate:\n    void initializeData()\n    {\n        for (const int i : S) {\n            num[i]++;\n        }\n        for (int i = 0; i < kind; i++) {\n            bucket[i].resize(num[i], -1);\n            tail[i] = num[i] - 1;\n        }\n        type[N - 1] = Type::S;\n        for (int i = N - 2; i >= 0; i--) {\n            type[i] = (S[i] != S[i + 1] ? (S[i] < S[i + 1] ? Type::S : Type::L) : type[i + 1]);\n            if (type[i] == Type::L and type[i + 1] == Type::S) {\n                type[i + 1] = Type::LMS;\n                LMS.push_back(i + 1);\n            }\n        }\n        for (int pos = N - 1, i = N - 2; i >= 0; i--) {\n            next[i] = pos;\n            if (type[i] == Type::LMS) {\n                pos = i;\n            }\n        }\n    }\n\n    void sortLMS()\n    {\n        for (const int l : LMS) {\n            insertTail(l);\n        }\n        induce();\n        vector<int> lms;\n        for (int i = 0; i < kind; i++) {\n            for (const int p : bucket[i]) {\n                if (type[p] == Type::LMS) {\n                    lms.push_back(p);\n                }\n            }\n        }\n        const int size = lms.size();\n        vector<int> order(N / 2 + 1, 0);\n        int number = 1;\n        order[N / 2] = 1;\n        bool same = false;\n        for (int i = 1; i < size; i++) {\n            const int l1 = lms[i - 1];\n            const int r1 = next[l1];\n            const int l2 = lms[i];\n            const int r2 = next[l2];\n            if (r1 - l1 == r2 - l2 and vector<int>(S.begin() + l1, S.begin() + r1 + 1) == vector<int>(S.begin() + l2, S.begin() + r2 + 1)) {\n                same = true;\n            } else {\n                number++;\n            }\n            order[l2 / 2] = number;\n        }\n        if (same) {\n            vector<int> s(size);\n            for (int p = 0, i = 0; i <= N / 2; i++) {\n                if (order[i] > 0) {\n                    s[p++] = order[i];\n                }\n            }\n            const vector<int> sorted = SuffixArrayInducedSorting{s, number}.getSuffixArray();\n            for (int i = 0; i < kind; i++) {\n                head[i] = 0;\n                tail[i] = num[i] - 1;\n            }\n            for (int i = size - 1; i >= 0; i--) {\n                insertTail(LMS[size - 1 - sorted[i]]);\n            }\n            induce();\n        } else {\n            for (int i = 0; i < kind; i++) {\n                head[i] = 0;\n                tail[i] = num[i] - 1;\n            }\n            for (int i = size - 1; i >= 0; i--) {\n                insertTail(lms[i]);\n            }\n            induce();\n        }\n    }\n\n    void induce()\n    {\n        for (int i = 0; i < kind; i++) {\n            for (int j = 0; j < head[i]; j++) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] == Type::L) {\n                    insertHead(p - 1);\n                }\n            }\n            for (int j = tail[i] + 1; j < num[i]; j++) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] == Type::L) {\n                    insertHead(p - 1);\n                }\n            }\n        }\n        for (int i = 1; i < kind; i++) {  // 番兵以外\n            tail[i] = num[i] - 1;\n        }\n        for (int i = kind - 1; i >= 0; i--) {\n            for (int j = num[i] - 1; j > tail[i]; j--) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] != Type::L) {\n                    insertTail(p - 1);\n                }\n            }\n            for (int j = head[i] - 1; j >= 0; j--) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] != Type::L) {\n                    insertTail(p - 1);\n                }\n            }\n        }\n    }\n    void insertHead(const int i) { bucket[S[i]][head[S[i]]++] = i; }\n    void insertTail(const int i) { bucket[S[i]][tail[S[i]]--] = i; }\n\n    const int N;\n    const int kind;\n    vector<int> S;               // O(N)\n    vector<Type> type;           // O(N)\n    vector<int> next;            // O(N)\n    vector<vector<int>> bucket;  // O(N)\n    vector<int> num;             // O(K)\n    vector<int> head;            // O(K)\n    vector<int> tail;            // O(K)\n    vector<int> LMS;             // O(N)\n};\n\nint main()\n{\n    string s;\n    cin >> s;\n    const int size = s.size();\n    const vector<int> sa = SuffixArrayInducedSorting(s, 79).getSuffixArray();\n    int N;\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        string p;\n        cin >> p;\n        const int psize = p.size();\n        int inf = -1;\n        int sup = size;\n        while (sup - inf > 1) {\n            const int mid = (sup + inf) / 2;\n            const bool ok = s.substr(sa[mid], psize) < p;\n            if (ok) {\n                inf = mid;\n            } else {\n                sup = mid;\n            }\n        }\n        const bool ans = sup == size ? false : s.substr(sa[sup], psize) == p;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\nusing namespace std;\nstring S, T;\nint main() {\n\tint q,sum;\n\tcin >> S;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tsum = 0;\n\t\tcin >> T;\n\t\tif (S.size() >= T.size()) {\n\t\t\tfor (int i = 0; i <= S.size() - T.size(); i++) {\n\t\t\t\tif(i>=100 && q>=1000){\n\t\t\t\t\tgoto Exit2;\n\t\t\t\t}\n\t\t\t\tif (T == S.substr(i, T.size())) {\n\t\t\t\t\tcout << \"1\" << endl;\n\t\t\t\t\tgoto Exit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tExit2:;\n\t\tcout << \"0\" << endl;\n\tExit:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)),pow(n+1),phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(l+1<r) {\n      const int m=(l+r)>>1;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nint L[1000000],R[1000000];\n\ninline void merge(int *A, const int left, const int mid, const int right, const RollingHash &rh){\n  const int n1 = mid - left, n2 = right - mid;\n  REP(i,n1)L[i]=A[left+i];\n  REP(i,n2)R[i]=A[mid+i];\n  for(int k =left,i=0,j=0;k<right;k++){\n    if(n2<=j)A[k]=L[i++];\n    else if(n1<=i)A[k]=R[j++];\n    else A[k]=rh(L[i],R[j])?L[i++]:R[j++];\n  }\n}\n\nvoid mergeSort(int *A,const int left,const int right, const RollingHash &rh){\n  if(left+1<right){\n    const int mid = (left+right)>>1;\n    mergeSort(A,left,mid, rh);\n    mergeSort(A,mid,right, rh);\n    merge(A,left,mid,right, rh);\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergeSort(sa,0,n,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring S,T;\nstring V[100000][100];\nint main(){\n\tint q,a,b;\n\tb=S.size();\n\tcin>>S;\n\ta=min(b,100);\n\tfor(int i=1;i<100;i++){\n\t\tfor(int j=0;j<=S.size()-j;j++){\n\t\t\tV[j][i]=S.substr(j,i);\n\t\t}\n\t}\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>T;\n\t\tfor(int j=0;j<S.size()-T.size();j++){\n\t\t\tif(V[j][T.size()]==T){\n\t\t\t\tcout<<\"yes\"<<endl;\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t}\n\t\tcout<<\"no\"<<endl;\n\t\tExit:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\n#define NUM 48\nusing namespace std;\n\nint T_char_count[128] = {0},P_char_count[128];\n\nclass LocRecord{\n\npublic:\n\t//?????¢???????¢????\n\tLocRecord(){\n\t\tlocationTable = new int*[128];\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t}\n\n\t//-1?????£??\\\n\tvoid init(){\n\t\tint limit;\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init_index(){\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t}\n\n\tvoid regist_loc(int ch, int location){\n\t\tlocationTable[ch][index[ch]] = location;\n\t\tindex[ch]++;\n\t}\n\n\tint next_loc(int ch){\n\t\tint ret = locationTable[ch][index[ch]];\n\t\tindex[ch]++;\n\t\treturn ret;\n\t}\n\nprivate:\n\tint** locationTable;\n\tint index[128];\n};\n\nint main(){\n\n\tfor(int i = 0; i < 128; i++)T_char_count[i] = 0;\n\n\tint length;\n\n\tchar* T = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tfor(length = 0; T[length] != '\\0';length++){\n\t\tT_char_count[T[length]]++;\n\t}\n\n\tLocRecord locRecord;\n\tlocRecord.init();\n\n\t//T[i]????????????i??§???????????¨????¨????\n\tfor(int i = 0; i < length; i++){\n\t\tlocRecord.regist_loc(T[i],i);\n\t}\n\n\tull* HASH = new ull[length+1];\n\tull* P = new ull[length+1];\n\n\tHASH[0] = 0;\n\tP[0] = 1;\n\n\t//T??????????????\\???????±???????\n\tfor(int i = 1; i <= length; i++){\n\t\tHASH[i] = T[i-1] + HASH[i-1]*MOD;\n\t\tP[i] = P[i-1]*MOD;\n\t}\n\n\tint Q,S_length,left,P_char_count[128];\n\tscanf(\"%d\",&Q);\n\n\tchar S[1001];\n\tull S_HASH[1001],S_value,T_value;\n\tbool FLG;\n\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",S);\n\n\t\t/*for(int i = 0; i < 128; i++){\n\t\t\tP_char_count[i] = 0;\n\t\t}\n\n\t\tfor(S_length = 0;S[S_length] != '\\0';S_length++){\n\t\t\tP_char_count[S[S_length]]++;\n\t\t}\n\n\t\tFLG = true;\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tif(T_char_count[i] < P_char_count[i]){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG)continue;*/\n\n\n\t\tS_HASH[0] = 0;\n\t\tfor(int i = 1; i <= S_length; i++){\n\t\t\tS_HASH[i] = S[i-1] + S_HASH[i-1]*MOD;\n\t\t}\n\n\t\tS_value = S_HASH[S_length];\n\n\t\tlocRecord.init_index();\n\n\t\tFLG = false;\n\n\t\twhile((left = locRecord.next_loc(S[0])) != -1){\n\t\t\tif(left+S_length-1>=length)break;\n\n\t\t\tT_value = HASH[left+S_length]-HASH[left]*P[S_length];\n\n\t\t\tif(T_value == S_value){\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(FLG){\n\t\t\tprintf(\"1\\n\");\n\t\t}else{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define MAX 1000002\n\nint Lv[MAX], A[MAX], newLv[MAX];\nint n, k;\nstd::string T;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n\tif(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n\tint L_i = (i + k >= n ? -1 : Lv[i + k]);\n\tint L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n\treturn L_i < L_j;\n}\n\nint main()\n{\n\tstd::cin >> T;\n\tn = T.size();\n\n\tint i;\n\tfor(i = 0; i < n; i++){ A[i] = i; }\n\tfor(i = 0; i < n; i++){ Lv[i] = T[i]; }\n\tstd::sort(A, A + n, cmp_Lv);\n\n\tnewLv[A[0]] = 0;\n\tfor(i = 1; i < n; i++){\n\t\tnewLv[A[i]] = newLv[A[i - 1]] + (Lv[A[i]] != Lv[A[i - 1]] ? 1 : 0);\n\t}\n\tfor(i = 0; i < n; i++){ Lv[i] = newLv[i]; }\n\n\tk = 1;\n\twhile(1){\n\t\tif(k > n) break;\n\n\t\tstd::sort(A, A + n, cmp);\n\t\tnewLv[A[0]] = 0;\n\t\tfor(i = 1; i < n; i++){ newLv[A[i]] = newLv[A[i - 1]] + (cmp(A[i - 1], A[i]) ? 1 : 0); }\n\t\tfor(i = 0; i < n; i++){ Lv[i] = newLv[i]; }\n\n\t\tif(Lv[A[n - 1]] == n - 1) break;\n\t\tk <<= 1;\n\t};\n\n\tstd::string P;\n\tint q, left, right, mid, crit;\n\tbool exist;\n\tscanf(\"%d\", &q);\n\n\tA[n] = n;\n\n\twhile(q){\n\t\tstd::cin >> P;\n\t\tleft = 0, right = n, exist = false;\n\t\twhile(left < right){\n\n\t\t\tif(n < P.size()){ exist = false; break; }\n\n\t\t\tmid = (left + right) / 2;\n\t\t\tcrit = T.compare(A[mid], P.size(), P);\n\n\t\t\tif(crit > 0){ right = mid; }\n\t\t\telse if(crit < 0){ left = mid + 1; }\n\t\t\telse{ exist = true; break; }\n\t\t};\n\t\tif(T.compare(A[right], P.size(), P) == 0) exist = true;\n\t\tif(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n\t\tq--;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1e9 + 7;\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\nconst ull BASE = 1e9 + 7;\n\nstruct SuffixArray {\n    int n, k;\n    vector<int> sa;\n    vector<int> rank;\n    vector<int> lcp;\n\n    SuffixArray (const string &s)\n    : n(s.size()), sa(n + 1), rank(n + 1), lcp(n)\n    {}\n\n    bool comp(int i, int j) {\n        if (rank[i] != rank[j]) return rank[i] < rank[j];\n        int ri = i + k <= n ? rank[i + k] : -1;\n        int rj = j + k <= n ? rank[j + k] : -1;\n        return ri < rj;\n    }\n\n    void construct_sa(const string &s) {\n        for (int i = 0; i <= n; i++) {\n            sa[i] = i;\n            rank[i] = i < n ? s[i] : -1;\n        }\n\n        for (k = 1; k <= n; k *= 2) {\n            sort(sa.begin(), sa.end(), [&](const int& i, const int& j) {return comp(i, j);});\n\n            vector<int> tmp(n + 1);\n            tmp[sa[0]] = 0;\n            for (int i = 1; i <= n; i++) {\n                tmp[sa[i]] = tmp[sa[i - 1]] + (comp(sa[i - 1], sa[i]) ? 1 : 0);\n            }\n\n            for (int i = 0; i <= n; i++) {\n                rank[i] = tmp[i];\n            }\n        }\n    }\n\n    void construct_lcp (const string &s) {\n        int h = 0;\n        lcp[0] = 0;\n        for (int i = 0; i < n; i++) {\n            int j = sa[rank[i] - 1];\n            if (h > 0) h--;\n            for (; j + h < n && i + h < n; h++) {\n                if (s[j + h] != s[i + h]) break;\n            }\n            lcp[rank[i] - 1] = h;\n        }\n    }\n\n    bool match(const string &text, const string &pt) {\n        int l = 0, r = n;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val < 0) l = m;\n            else r = m;\n        }\n        return text.compare(sa[r], pt.length(), pt) == 0 ? true : false;\n    }\n\n    int count(const string &text, const string &pt) {\n        int l = 0, r = n;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val < 0) l = m;\n            else r = m;\n        }\n        int l_idx = r;\n        if (text.compare(sa[l_idx], pt.length(), pt) != 0) return 0;\n\n        l = 0, r = n + 1;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val <= 0) l = m;\n            else r = m;\n        }\n        int r_idx = l;\n        return r_idx - l_idx + 1;\n    }\n};\n\nstring t;\nint q;\nstring p[10000];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> t;\n    cin >> q;\n    rep(i, q) cin >> p[i];\n    SuffixArray suf(t);\n    suf.construct_sa(t);\n    rep(i, q) {\n        if (suf.count(t, p[i])) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nclass StringSearch {\n\tconst int n;\n\tstring S;\n\tvector<int> SA, Rank;\npublic:\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), SA(n + 1), Rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tSA[i] = i;\n\t\t\tRank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\treturn Rank[i] != Rank[j] ? (Rank[i] < Rank[j]) : (i + k <= n ? Rank[i + k] : -1) < (j + k <= n ? Rank[j + k] : -1);\n\t\t\t};\n\n\t\t\tsort(SA.begin(), SA.end(), Compare_SA);\n\n\t\t\ttmp[SA[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[SA[i]] = tmp[SA[i - 1]] + (Compare_SA(SA[i - 1], SA[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tRank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(SA[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(SA[b], T.length(), T) == 0;\n\t}\n};\n\nint main()\n{\n\tint Q;\n\tstring T, P;\n\tcin.sync_with_stdio(false);\n\tcin >> T;\n\tStringSearch SS(T);\n\tcin >> Q;\n\twhile (Q--) {\n\t\tcin >> P;\n\t\tcout << SS.Contain(P) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nbool CheckString(std::string A, std::string B) {\n\tfor (unsigned int i = 0; i < A.size(); ++i) {\n\t\tif (A[i] == B[0] && A.substr(i, B.size()) == B) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main(void) {\n\tstd::ios_base::sync_with_stdio(false);\n\tstd::string T;\n\tint Q;\n\tstd::cin >> T >> Q;\n\tstd::vector<std::string>P(Q);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tstd::cin >> P[i];\n\t}\n\tfor (int i = 0; i < Q; ++i) {\n\t\tstd::cout << CheckString(T, P[i]) << std::endl;\n\t}\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> Q;\n\nint n;\nchar s[1000001];\nint q;\nchar t[1001];\nint a[1000000];\nint b[1000000];\n\ninline int comp(char* s, int x, char* t, int y){\n\tint i = 0;\n\twhile(i < x && i < y){\n\t\tif(s[i] > t[i]){\n\t\t\treturn 1;\n\t\t}\n\t\telse if(s[i] < t[i]){\n\t\t\treturn -1;\n\t\t}\n\t\t++i;\n\t}\n\treturn x - y;\n}\n\nint main(){\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\t\n\tvector<P> v;\n\trep(i, n){\n\t\tv.push_back(P(s[i], i));\n\t}\n\tsort(v.begin(), v.end());\n\ta[v[0].second] = 0;\n\trep(i, n - 1){\n\t\ta[v[i + 1].second] = a[v[i].second] + (v[i].first != v[i + 1].first);\n\t}\n\n\trep(i, 20){\n\t\tvector<Q> v;\n\t\trep(j, n){\n\t\t\tif(j + (1 << i) < n){\n\t\t\t\tv.push_back(Q(P(a[j], a[j + (1 << i)]), j));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tv.push_back(Q(P(a[j], -1), j));\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\ta[v[0].second] = 0;\n\t\trep(j, n - 1){\n\t\t\ta[v[j + 1].second] = a[v[j].second] + (v[j].first != v[j + 1].first);\n\t\t}\n\t}\n\n\trep(i, n){\n\t\tb[a[i]] = i;\n\t}\n\t\n\tscanf(\"%d\", &q);\n\trep(i, q){\n\t\tscanf(\"%s\", t);\n\t\tint k = strlen(t);\n\t\tint l = 0, r = n;\n\t\twhile(r - l > 1){\n\t\t\tint m = (l + r) / 2;\n\t\t\tif(comp(s + b[m], min(k, n - b[m]), t, k)  <= 0){\n\t\t\t\tl = m;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr = m;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", comp(s + b[l], min(k, n - b[l]), t, k) == 0);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    S.push_back('$');\n    vector<int> c(n+1,0),ord(n+1,0);\n    for(int i=0;i<=n;i++) ord[i]=n-i;\n    return;\n    sort(ord.begin(),ord.end(),[&](int a,int b){return S[a]<S[b];});\n    return;\n    for(int i=0;i<=n;i++){\n      sa[i]=ord[i];\n      c[i]=S[i];\n    }\n    \n    for(int len=1;len<=n;len*=2){\n      vector<int> r=c;\n      for(int i=0;i<=n;i++){\n\t c[sa[i]] =\n\t   i > 0 &&\n\t   r[sa[i - 1]] == r[sa[i]] &&\n\t   sa[i - 1] + len <= n &&\n\t   r[sa[i - 1] + len / 2] == r[sa[i] + len / 2]\n\t   ? c[sa[i - 1]] : i;\n      }\n      vector<int> cnt(n+1);\n      for(int i=0;i<=n;i++) cnt[i]=i;\n      vector<int> s=sa;\n      for(int i=0;i<=n;i++){\n\tint s1=s[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n);\n    for(int i=0;i<n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  return 0;\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    //assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=(ull *)malloc(n+1);\n    phash=(ull *)malloc(n+1);\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }  \n};\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  const int n = SZ(a);\n  if(n>1){\n    vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(b,rh), mergesort(c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==SZ(c))a[i]=b[j++];\n      else if(j==SZ(b))a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  mergesort(sa,rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000000];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <utility>\n#include <string>\nusing namespace std;\n\n#define MAX_T 1000000\n#define MAX_P 1000\n#define MAX_Q 10000\n\nbool str_match(std::string,std::string);\n\nint main(){\n    std::string str;\n    std::string ptn;\n\n    getline(cin, str);\n\n    int n;\n    int result[MAX_Q];\n    string nl;\n    cin >> n;\n    getline(cin,nl);\n    for(int times = 0; times < n; times++){\n        getline(cin, ptn);\n        if(str_match(str,ptn)){result[times] = 1;}\n        else{result[times] = 0;}\n    }\n    for(int i = 0; i < n; i++){\n        cout << result[i] << \"\\n\";\n    }\n\n}\n\nbool str_match(std::string str,std::string ptn){\n    bool matched = true;\n\n    int i = 0;\n    while(i < str.length()){\n        matched = true;\n        for(int j = 0; j < ptn.length(); j++){\n            if(str[i+j] != ptn[j]){\n                matched = false;\n                break;\n            }\n        }\n        if(matched) break;\n        i++;\n    }\n\n    \n    return matched;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S 2500005\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\nstruct d{\n  int a,b,c;\n  d(){}\n  d(int A,int B,int C){\n    a=A,b=B,c=C;\n  };\n  bool operator<(const d&r)const{\n    if(a!=r.a)return a<r.a;\n    return b<r.b;\n  }\n};\n \nint n,slen,tlen,r[S];\nchar s[S],t[N];\nd ran[S];\nP a[S];\n \nvoid init(){\n  for(int i=0;i<26;i++)\n    for(int j=0;j<slen;j++)\n      if('a'+i==s[j])r[j]=i+1;\n  int x=1;\n  while(x<slen){\n    for(int i=0;i<slen;i++){\n      int a=i+x;\n      if(a>slen)a=slen;\n      ran[i]=d(r[i],r[a],i);\n    }\n    sort(ran,ran+slen);\n    int cnt=1;\n    for(int i=0;i<slen;i++){\n      r[ran[i].c]=cnt;\n      if(ran[i].a==ran[i+1].a&&ran[i].b==ran[i+1].b)\n    continue;\n      cnt++;\n    }\n    x*=2;\n  }\n  for(int i=0;i<slen;i++)a[i]=P(r[i],i);\n  sort(a,a+slen);\n}\n \nbool bynary_search(){\n  int L=0,R=slen;\n  while(L<R){\n    int M=(L+R)/2;\n    if(strncmp(s+a[M].second,t,tlen)<0)L=M+1;\n    else R=M;\n  }\n  if(!strncmp(s+a[L].second,t,tlen))return true;\n  return false;\n}\n \nint main(){\n  scanf(\"%s%d\",s,&n);\n  slen=strlen(s);\n  init();  \n  while(n--){\n    scanf(\"%s\",t);\n    tlen=strlen(t);\n    if(bynary_search())printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\nusing namespace std;\n\nstruct P {\n  map<char,P*> next;\n  P(){}\n  void add(char* str){\n    P* tar=this;\n    while(*str){\n      P** lpnx;\n      if(*(lpnx=&(tar->next[*str]))==NULL) *lpnx=new P();\n      tar=*lpnx;\n      ++str;\n    }\n  }\n  int find (char* str) {\n    P* tar=this;\n    while(*str){\n      P** lpnx;\n      if(*(lpnx=&(tar->next[*str]))==NULL) return 0;\n      tar=*lpnx; ++str;\n    }\n    return 1;\n  }\n};\n\nint main () {\n  string s;int q;cin>>s>>q;\n  P* root=new P();char* str=(char*)s.c_str();\n  int len=s.size()-1;\n  for(int i=0;i<len;++i,++str)\n    root->add(str);\n  for(int i=0;i<q;++i){\n    string t;cin>>t;\n    cout<<root->find((char*)t.c_str())<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\n#define NUM 48\nusing namespace std;\n\nint T_char_count[128] = {0},P_char_count[128];\nint T_Chain[128][128];\n\nclass LocRecord{\n\npublic:\n\t//?????¢???????¢????\n\tLocRecord(){\n\t\tlocationTable = new int**[128];\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tlocationTable[i] = new int*[128];\n\t\t\tfor(int k = 0; k < 128; k++){\n\t\t\t\tif(T_Chain[i][k] > 0){\n\t\t\t\t\tlocationTable[i][k] = new int[T_Chain[i][k]+1];\n\t\t\t\t\tfor(int p = 0; p < T_Chain[i][k]+1; p++){\n\t\t\t\t\t\tlocationTable[i][k][p] = -1;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tlocationTable[i][k] = new int[2];\n\t\t\t\t\tfor(int p = 0; p < 2; p++){\n\t\t\t\t\t\tlocationTable[i][k][p] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinit();\n\t}\n\n\t//-1?????£??\\\n\tvoid init(){\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tfor(int k = 0; k < 128; k++){\n\t\t\t\tindex[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init_index(char first,char second){\n\t\tindex[first][second] = 0;\n\t}\n\n\tvoid regist_loc(char first,char second,int location){\n\t\tlocationTable[first][second][index[first][second]] = location;\n\t\tindex[first][second]++;\n\t}\n\n\tint next_loc(char first,char second){\n\t\tint ret = locationTable[first][second][index[first][second]];\n\t\tindex[first][second]++;\n\t\treturn ret;\n\t}\n\nprivate:\n\tint*** locationTable;\n\tint index[128][128];\n};\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\t\t\treturn length < arg.length;\n\t};\n\tInfo(int arg_length,int arg_id,ull arg_hashValue){\n\t\tlength = arg_length;\n\t\tid = arg_id;\n\t\thashValue = arg_hashValue;\n\t}\n\n\tint length,id;\n\tull hashValue;\n};\n\nint main(){\n\n\tfor(int i = 0; i < 128; i++){\n\t\tT_char_count[i] = 0;\n\t\tfor(int k = 0; k < 128; k++){\n\t\t\tT_Chain[i][k] = 0;\n\t\t}\n\t}\n\n\tint T_length;\n\n\tchar* T = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tchar pre = T[0];\n\tT_char_count[T[0]]++;\n\n\tfor(T_length = 1; T[T_length] != '\\0';T_length++){\n\t\tT_char_count[T[T_length]]++;\n\t\tT_Chain[pre][T[T_length]]++;\n\t\tpre = T[T_length];\n\t}\n\n\tLocRecord locRecord;\n\tlocRecord.init();\n\n\n\tpre = T[0];\n\t//T[i]????????????i??§???????????¨????¨????\n\tfor(int i = 1; i < T_length; i++){\n\t\tlocRecord.regist_loc(pre,T[i],i-1);\n\t\tpre = T[i];\n\t}\n\n\tull* HASH = new ull[T_length+1];\n\tull* P = new ull[T_length+1];\n\n\tHASH[0] = 0;\n\tP[0] = 1;\n\n\t//T??????????????\\???????±???????\n\tfor(int i = 1; i <= T_length; i++){\n\t\tHASH[i] = T[i-1] + HASH[i-1]*MOD;\n\t\tP[i] = P[i-1]*MOD;\n\t}\n\n\n\tvector<Info> V[128][128];\n\tvector<int> LENG[128][128];\n\n\tint Q,S_length,left,P_char_count[128];\n\tscanf(\"%d\",&Q);\n\n\tbool check[Q];\n\n\tfor(int i = 0; i < Q; i++)check[i] = false;\n\n\tchar S[1001];\n\tull S_HASH[1001],S_value,T_value,D;\n\tbool FLG,isExist;\n\n\n\t//Q??¶??????????????\\???????¨????\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",S);\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tP_char_count[i] = 0;\n\t\t}\n\n\t\tfor(S_length = 0;S[S_length] != '\\0';S_length++){\n\t\t\tP_char_count[S[S_length]]++;\n\t\t}\n\n\t\tFLG = true;\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tif(T_char_count[i] < P_char_count[i]){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG)continue;\n\n\t\tif(S_length == 1){\n\t\t\tcheck[loop] = true;\n\t\t\tcontinue;\n\t\t}\n\n\n\n\t\tS_HASH[0] = 0;\n\t\tfor(int i = 1; i <= S_length; i++){\n\t\t\tS_HASH[i] = S[i-1] + S_HASH[i-1]*MOD;\n\t\t}\n\n\t\tS_value = S_HASH[S_length];\n\n\t\tV[S[0]][S[1]].push_back(Info(S_length,loop,S_value));\n\n\t\tisExist = false;\n\t\tfor(int i = 0; i < LENG[S[0]][S[1]].size();i++){\n\t\t\tif(LENG[S[0]][S[1]][i] == S_length){\n\t\t\t\tisExist = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!isExist){\n\t\t\tLENG[S[0]][S[1]].push_back(S_length);\n\t\t}\n\t}\n\n\tint calc_length,calc_left,calc_right,calc_m;\n\n\tvector<ull> TEMP[1001];\n\n\tfor(int first_word = 48; first_word <= 122; first_word++){\n\t\tfor(int second_word = 48; second_word <= 122;second_word++){\n\t\t\tfor(int i = 0; i < LENG[first_word][second_word].size();i++){\n\t\t\t\tcalc_length = LENG[first_word][second_word][i];\n\t\t\t\tTEMP[calc_length].clear();\n\n\t\t\t\tlocRecord.init_index(first_word,second_word);\n\n\t\t\t\t//???????????\\?????????????¨????????????????\n\t\t\t\twhile((left = locRecord.next_loc(first_word,second_word)) != -1){\n\t\t\t\t\tif(left+calc_length-1 >= T_length)break;\n\n\t\t\t\t\tTEMP[calc_length].push_back(HASH[left+calc_length]-HASH[left]*P[calc_length]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//???????????\\??????sort\n\t\t\tfor(int i = 0; i < LENG[first_word][second_word].size();i++)sort(TEMP[LENG[first_word][second_word][i]].begin(),TEMP[LENG[first_word][second_word][i]].end());\n\n\t\t\tfor(int i = 0; i < V[first_word][second_word].size();i++){\n\n\t\t\t\tcalc_length = V[first_word][second_word][i].length;\n\t\t\t\tS_value = V[first_word][second_word][i].hashValue;\n\n\t\t\t\tcalc_left = 0;\n\t\t\t\tcalc_right = TEMP[calc_length].size()-1;\n\t\t\t\tcalc_m = (calc_left+calc_right)/2;\n\t\t\t\twhile(calc_left <= calc_right){\n\n\t\t\t\t\tif(TEMP[calc_length][calc_m] == S_value){\n\t\t\t\t\t\tcheck[V[first_word][second_word][i].id] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(TEMP[calc_length][calc_m] < S_value){\n\t\t\t\t\t\t\tcalc_left = calc_m+1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcalc_right = calc_m-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcalc_m = (calc_left+calc_right)/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tif(check[i])printf(\"1\\n\");\n\t\telse{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=(n+1)/2,nc=n-nb,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k>=nc)a[i]=b[j++];\n      else if(j>=nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n\nint Rank[1000005];\nint Tmp[1000005];\nint kc,len;\n\nbool compare_sa(int i,int j){\n  if(Rank[i]!=Rank[j])return Rank[i]<Rank[j];\n  else{\n    int ri=i+kc<=len?Rank[i+kc]:-1;\n    int rj=j+kc<=len?Rank[j+kc]:-1;\n    return ri<rj;\n  }\n}\n\nvoid construct_sa(char* S,int *sa){\n  len=strlen(S);\n  for(int i=0;i<=len;i++){\n    sa[i]=i;\n    Rank[i]=i<len?S[i]:-1;\n  }\n  for(kc=1;kc<=len;kc*=2){\n    sort(sa,sa+len+1,compare_sa);\n    Tmp[sa[0]]=0;\n    for(int i=1;i<=len;i++){\n      Tmp[sa[i]]=Tmp[sa[i-1]]+compare_sa(sa[i-1],sa[i]);\n    }\n    for(int i=0;i<=len;i++)Rank[i]=Tmp[i];\n  }\n}\n\n\nint n,m;\nchar str[1000005];\nchar t[1000005];\nint sa[1000005];\n\nint main(){\n  scanf(\"%s\",str);\n  n=strlen(str);\n  construct_sa(str,sa);\n  scanf(\"%d\",&m);\n  while(m--){\n    scanf(\"%s\",t);\n    int k=strlen(t);\n    int l=0,r=n+1,m;\n    while(l+1<r){\n      m=(l+r)/2;\n      if(strncmp(str+sa[m],t,k)<=0)l=m;\n      else r=m;\n    }\n    printf(\"%d\\n\",(strncmp(str+sa[l],t,k)==0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cassert>\nusing namespace std;\n\nconst int ALPH = 256;\nstruct SuffixArray {\nprivate:\n    string s;\n    vector<int> rec, cnt;\n    int len, cnt_size;\npublic:\n    SuffixArray(string s_) : s(s_) {\n        s += \"$\"; // 辞書順で最も小さいダミー文字\n        len = s.length();\n        cnt_size = max(ALPH, len); cnt.resize(cnt_size);\n        rec = getArray();\n    }\n\n    void dump_array(vector<int> &indices, vector<int> &classes) {\n        fprintf(stderr, \"# debug\\n\");\n        fprintf(stderr, \"# indices:\");\n        for(int i=0; i<len; i++) fprintf(stderr, \" %d\", indices[i]);\n        fprintf(stderr, \"\\n\");\n        fprintf(stderr, \"# classes:\");\n        for(int i=0; i<len; i++) fprintf(stderr, \" %d\", classes[i]);\n        fprintf(stderr, \"\\n\");\n    }\n    \n    vector<int> getArray() {\n        vector<int> indices(len), prev_idx(len);\n        vector<int> classes(len), prev_cls(len);\n        vector<int> tmp_val(len);\n\n        // k == 0 はカウントソートのみ\n        for(int i=0; i<len; i++) {\n            cnt[ s[i] ]++;\n        }\n        for(int i=1; i<cnt_size; i++) {\n            cnt[i] += cnt[i-1];\n        }\n        for(int i=len-1; i>=0; i--) {\n            indices[ --cnt[ s[i] ] ] = i;\n        }\n        for(int i=1; i<len; i++) {\n            int pena = (s[ indices[i] ] != s[ indices[i-1] ]);\n            classes[ indices[i] ] = classes[ indices[i-1] ] + pena;\n        }\n        \n        for(int k=0; (1 << k) < len; k++) {\n            swap(indices, prev_idx);\n            swap(classes, prev_cls);\n            for(int i=0; i<len; i++) {\n                // 後半だけソート済みにしたものを indices に代入\n                prev_idx[i] = prev_idx[i] - (1 << k);\n                if(prev_idx[i] < 0) prev_idx[i] += len;\n                tmp_val[i] = prev_cls[ prev_idx[i] ];\n            }\n\n            // 前半についてカウントソート\n            fill(cnt.begin(), cnt.end(), (int)0);\n            for(int i=0; i<len; i++) {\n                cnt[ tmp_val[i] ]++;\n            }\n            for(int i=1; i<cnt_size; i++) {\n                cnt[i] += cnt[i-1];\n            }\n            for(int i=len-1; i>=0; i--) {\n                indices[ --cnt[ tmp_val[i] ] ] = prev_idx[i];\n            }\n            classes[ indices[0] ] = 0;\n            for(int i=1; i<len; i++) {\n                int shift = (1 << k);\n                pair<int, int> pre(prev_cls[ indices[i-1] ], prev_cls[ (indices[i-1] + shift) % len ]);\n                pair<int, int> cur(prev_cls[ indices[i  ] ], prev_cls[ (indices[i  ] + shift) % len ]);\n                int pena = (pre != cur);\n                classes[ indices[i] ] = classes[ indices[i-1] ] + pena;\n            }\n        }\n        return indices;\n    }\n\n    int size() {\n        return rec.size();\n    }\n    int get(int idx) {\n        assert(0 <= idx and idx < size());\n        return rec[idx];\n    }\n    // パターン文字列 p は、idx 番目に小さい接尾辞に比べて大きいか？\n    bool is_greater(string &p, int idx) {\n        idx = get(idx);\n        int N = size(), M = p.size(), x, y;\n        for(x=idx, y=0; x<N and y<M; x++, y++) {\n            if(s[x] < p[y]) return true;\n            if(s[x] > p[y]) return false;\n        }\n        return x >= N and y < M;\n    }\n};\n\nint search_by_sa(SuffixArray &sa, string &p) {\n    int N = sa.size(), ansL, ansR;\n\n    int lb = 0, ub = N;\n    while(ub - lb > 1) {\n        int mid = (ub + lb) / 2;\n        if(sa.is_greater(p, mid)) lb = mid;\n        else ub = mid;\n    }\n    ansL = ub;\n\n    p.back()++;\n    \n    lb = 0, ub = N;\n    while(ub - lb > 1) {\n        int mid = (ub + lb) / 2;\n        if(sa.is_greater(p, mid)) lb = mid;\n        else ub = mid;\n    }\n    ansR = ub;\n    p.back()--;\n\n    return ansR - ansL;\n}\n\nint main() {\n    string s; cin >> s;\n    SuffixArray sa(s);\n\n    int N; scanf(\"%d\", &N);\n    for(int i=0; i<N; i++) {\n        char buf[1024]; scanf(\"%s\", buf);\n        string p = buf;\n        if(search_by_sa(sa, p) > 0) {\n            puts(\"1\");\n        }\n        else {\n            puts(\"0\");\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nclass suffix_array{\n    void create_begin_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        int sum=0;\n        for(int i=0;i<bucket.size();i++){bucket[i]+=sum;swap(sum,bucket[i]);}\n    }\n\n    void create_end_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        for(int i=1;i<bucket.size();i++)bucket[i]+=bucket[i-1];\n    }\n\n    void induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_begin_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(sa[i]>0&&is_l[sa[i]-1])sa[bucket[v[sa[i]-1]]++]=sa[i]-1;\n    }\n\n    void invert_induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_end_bucket(v,bucket);\n        for(int i=v.size()-1;i>=0;i--)if(sa[i]>0&&!is_l[sa[i]-1])sa[--bucket[v[sa[i]-1]]]=sa[i]-1;\n    }\n\n    vector<int>sa_is(vector<int>v,int mv){\n        if(v.size()==1)return vector<int>(1,0);\n\n        vector<int>is_l(v.size());\n        vector<int>bucket(mv+1);\n        vector<int>sa(v.size(),-1);\n        auto is_lms=[&](int x)->bool{return x>0&&is_l[x-1]&&!is_l[x];};\n\n        is_l[v.size()-1]=0;\n        for(int i=v.size()-2;i>=0;i--)is_l[i]=v[i]>v[i+1]||(v[i]==v[i+1]&&is_l[i+1]);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(is_lms(i))sa[--bucket[v[i]]]=i;\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n\n        int cur=0;\n        vector<int>order(v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))order[i]=cur++;\n\n        vector<int>next_v(cur);\n        cur=-1;\n        int prev=-1;\n        for(int i=0;i<v.size();i++){\n            if(!is_lms(sa[i]))continue;\n            bool diff=false;\n            for(int d=0;d<v.size();d++){\n                if(prev==-1||v[sa[i]+d]!=v[prev+d]||is_l[sa[i]+d]!=is_l[prev+d]){\n                    diff=true;\n                    break;\n                }\n                else if(d>0&&is_lms(sa[i]+d))break;\n            }\n            if(diff){cur++;prev=sa[i];}\n            next_v[order[sa[i]]]=cur;\n        }\n\n        vector<int>re_order(next_v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))re_order[order[i]]=i;\n        vector<int>next_sa=sa_is(next_v,cur);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<sa.size();i++)sa[i]=-1;\n        for(int i=next_sa.size()-1;i>=0;i--)sa[--bucket[v[re_order[next_sa[i]]]]]=re_order[next_sa[i]];\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n        return sa;\n    }\n\n    vector<int>sa_is(string &s){\n        vector<int>v(s.size()+1);\n        for(int i=0;i<s.size();i++)v[i]=s[i];\n        sa=sa_is(v,*max_element(v.begin(),v.end()));\n    }\n\n    void construct_lcp(){\n        lcp.resize(s.size());\n        rank.resize(s.size()+1);\n        int n=s.size();\n        for(int i=0;i<=n;i++)rank[sa[i]]=i;\n        int h=0;\n        lcp[0]=0;\n        for(int i=0;i<n;i++){\n            int j=sa[rank[i]-1];\n\n            if(h>0)h--;\n            for(;j+h<n&&i+h<n;h++){\n                if(s[j+h]!=s[i+h])break;\n            }\n            lcp[rank[i]-1]=h;\n        }\n    }\n\n    class sparse_table{\n        vector<vector<int> >st;\n    public:\n        void init(vector<int>&v){\n            int b;\n            for(b=0;(1<<b)<=v.size();b++);\n            st.resize(b);for(int i=0;i<b;i++)st[i].resize(1<<b);\n            for(int i=0;i<v.size();i++)st[0][i]=v[i];\n\n            for(int i=1;i<b;i++){\n                for(int j=0;j+(1<<i)<=(1<<b);j++){\n                    st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);\n                }\n            }\n        }\n        int get_min(int l,int r){\n            assert(l<r);\n            int b=32-__builtin_clz(r-l)-1;\n            return min(st[b][l],st[b][r-(1<<b)]);\n        }\n        sparse_table(){}\n        sparse_table(vector<int>&v){init(v);}\n    };\n    sparse_table st;\npublic:\n    string s;\n    vector<int>sa,lcp,rank;\n    void init(string &t){\n        s=t;\n        sa_is(s);\n        construct_lcp();\n        st.init(lcp);\n    }\n    suffix_array(string &t){init(t);}\n    suffix_array(){}\n\n    bool contain(string &t){\n        int lb=0,ub=s.size();\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            if(s.compare(sa[mid],t.size(),t)<0)lb=mid;\n            else ub=mid;\n        }\n        return s.compare(sa[ub],t.size(),t)==0;\n    }\n\n    int get_lcp(int i,int j){\n        if(rank[i]>rank[j])swap(i,j);\n        return st.get_min(rank[i],rank[j]);\n    }\n};\n\nsigned main(){\n    string s;cin>>s;\n    suffix_array sa(s);\n    int q;cin>>q;\n    while(q--){\n        string t;\n        cin>>t;\n        cout<<sa.contain(t)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nclass SuffixArray {\n\tvoid CEB(vector<int> &v, vector<int> &b) {\n\t\tint vs = v.size(), bs = b.size();\n\t\tfill(b.begin(), b.end(), 0);\n\t\tfor (int i = 0; i < vs; i++) b[v[i]]++;\n\t\tfor (int i = 1; i < bs; i++) b[i] += b[i - 1];\n\t}\n\tvoid ISort(vector<int> &v, vector<int> &SA, int mv, vector<int> &b, vector<int> &isL) {\n\t\tint vs = v.size(), bs = b.size();\n\t\tfill(b.begin(), b.end(), 0);\n\t\tfor (int i = 0; i < vs; i++) b[v[i]]++;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < bs; i++) b[i] += sum, swap(sum, b[i]);\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (SA[i] > 0 && isL[SA[i] - 1]) SA[b[v[SA[i] - 1]]++] = SA[i] - 1;\n\t\t}\n\t}\n\tvoid IISort(vector<int> &v, vector<int> &SA, int mv, vector<int> &b, vector<int> &isL) {\n\t\tCEB(v, b);\n\t\tfor (int i = v.size() - 1; i >= 0; i--) {\n\t\t\tif (SA[i] > 0 && !isL[SA[i] - 1]) SA[--b[v[SA[i] - 1]]] = SA[i] - 1;\n\t\t}\n\t}\n\tvector<int>SA_IS(vector<int> v, int mv) {\n\t\tint vs = v.size();\n\t\tif (vs == 1) return vector<int>(1, 0);\n\t\tvector<int> isL(vs), b(mv + 1), SA(vs, -1), ord(vs);\n\t\tauto isLMS = [&](int x)->bool { return x > 0 && isL[x - 1] && !isL[x]; };\n\t\tfor (int i = vs - 2; i >= 0; i--) isL[i] = (v[i] > v[i + 1]) || (v[i] == v[i + 1] && isL[i + 1]);\n\t\tCEB(v, b);\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) SA[--b[v[i]]] = i;\n\t\t}\n\t\tISort(v, SA, mv, b, isL);\n\t\tIISort(v, SA, mv, b, isL);\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) ord[i] = cur++;\n\t\t}\n\t\tvector<int> nxv(cur);\n\t\tcur = -1;\n\t\tint prev = -1;\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (!isLMS(SA[i])) continue;\n\t\t\tbool diff = false;\n\t\t\tfor (int d = 0; d < vs; d++) {\n\t\t\t\tif (prev == -1 || v[SA[i] + d] != v[prev + d] || isL[SA[i] + d] != isL[prev + d]) {\n\t\t\t\t\tdiff = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (d && isLMS(SA[i] + d))break;\n\t\t\t}\n\t\t\tif (diff) cur++, prev = SA[i];\n\t\t\tnxv[ord[SA[i]]] = cur;\n\t\t}\n\t\tvector<int> reord(nxv.size());\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) reord[ord[i]] = i;\n\t\t}\n\t\tvector<int> nxSA = SA_IS(nxv, cur);\n\t\tCEB(v, b);\n\t\tfor (int i = 0; i < SA.size(); i++) SA[i] = -1;\n\t\tfor (int i = nxSA.size() - 1; i >= 0; i--) {\n\t\t\tSA[--b[v[reord[nxSA[i]]]]] = reord[nxSA[i]];\n\t\t}\n\t\tISort(v, SA, mv, b, isL);\n\t\tIISort(v, SA, mv, b, isL);\n\t\treturn SA;\n\t}\n\tvector<int>SA_IS(string s) {\n\t\tvector<int> v(s.size() + 1);\n\t\tfor (int i = 0; i < s.size(); i++) v[i] = s[i] + 1;\n\t\treturn SA_IS(v, *max_element(v.begin(), v.end()));\n\t}\n\tvector<int>construct_lcp(string &s, vector<int> &sa) {\n\t\tvector<int> lcp, rank(s.size() + 1);\n\t\tint n = s.size(), h = 0;\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (s[j + h] != s[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\npublic:\n\tstring s;\n\tvector<int> sa, lcp;\n\tvoid init(string &T) {\n\t\ts = T;\n\t\tsa = SA_IS(s);\n\t}\n\tSuffixArray(string &t) { init(t); }\n\tSuffixArray() {}\n\tbool contain(string &t) {\n\t\tint a = 0, b = s.size();\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (s.compare(sa[c], t.size(), t) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn s.compare(sa[b], t.size(), t) == 0;\n\t}\n};\nint q; string s, t;\nint main() {\n\tcin >> s >> q;\n\tSuffixArray v(s);\n\tfor(int i = 0; i < q; i++) {\n\t\tcin >> t;\n\t\tcout << (v.contain(t) ? 1 : 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint n, k;\nstring s;\nvector<int> order;\nvector<int> tmp;\nvector<int> sa;\n\nbool compare_sa(const int &i, const int &j)\n{\n  if(order[i] != order[j]) return order[i] < order[j];\n  else\n  {\n    int ri = i + k <= n ? order[i+k] : -1;\n    int rj = j + k <= n ? order[j+k] : -1;\n    return ri < rj;\n  }\n}\n\nvoid construct_sa()\n{\n  for(int i = 0; i <= n; i++)\n  {\n    sa[i] = i;\n    order[i] = i < n ? s[i] : -1;\n  }\n  for(k = 1; k <= n; k*=2)\n  {\n    sort(sa.begin(),sa.end(),compare_sa);\n    tmp[sa[0]] = 0;\n    for(int i = 1; i <= n; i++)\n      tmp[sa[i]] = tmp[sa[i-1]] + (compare_sa(sa[i-1],sa[i])?1:0);\n    for(int i = 0; i <= n; i++)\n      order[i] = tmp[i];\n  }\n}\n\nvoid init()\n{\n  n = s.size();\n  order.resize(n+1);\n  tmp.resize(n+1);\n  sa.resize(n+1);\n  construct_sa();\n}\n\nbool contain(string t)\n{\n  int l=0, r=n;\n  while(r-l>1)\n  {\n    int m = (l+r)/2;\n    if(s.compare(sa[m],t.size(),t)<0) l = m;\n    else r = m;\n  }\n  return s.compare(sa[r],t.size(),t) == 0;\n}\n\nint main(){\n\n\tcin >> s;\n\tstring t;\n\tint q ; cin >> q;\n\tinit();\n\tconstruct_sa ();\n\tfor (int i = 0; i < q; ++i)\n\t {\n\t \tcin >> t;\n\t \tcout << contain(t) << endl;\n\t } \n\t return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nnamespace SA{\n    const int MAX=1000000;\n    int N,K;\n    int tmp[MAX+1],rank[MAX+1];\n    bool compare_sa(int i,int j){\n        if(rank[i]!=rank[j])return rank[i]<rank[j];\n        else{\n            int ri=(i+K<=N)?rank[i+K]:-1;\n            int rj=(j+K<=N)?rank[j+K]:-1;\n            return ri<rj;\n        }\n    }\n\n    vector<int> construct_sa(string S){\n        N=S.size();\n        vector<int>sa(N+1);\n        for(int i=0;i<=N;i++)sa[i]=i;\n        for(int i=0;i<=N;i++){\n            rank[i]=i==N?-1:S[i];\n        }\n\n        for(K=1;K<=N;K*=2){\n            sort(sa.begin(),sa.end(),compare_sa);\n            tmp[sa[0]]=0;\n            for(int i=1;i<=N;i++){\n                tmp[sa[i]]=tmp[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n            }\n            for(int i=0;i<=N;i++)rank[i]=tmp[i];\n        }\n        return sa;\n    }\n}\n\nstring S;\nvint sa;\nint Q;\n\nbool exist(string T){\n\n\n    /*\n    int lb=0,ub=S.size();\n    while(ub-lb>1){\n        int mid=(ub+lb)/2;\n        if(S.substr(sa[mid],min(S.size()-mid,T.size()))<T)lb=mid;\n        else ub=mid;\n    }\n    if(ub<=S.size()&&S.size()-sa[ub]>=T.size()&&S.substr(sa[ub],T.size())==T)return true;\n    return false;\n    */\n}\n\nbool contain(string &S,vint &sa,string &T){\n    int a=0,b=S.size();\n    while(b-a>1){\n        int c=(a+b)/2;\n        if(S.compare(sa[c],T.size(),T)<0)a=c;\n        else b=c;\n    }\n    return S.compare(sa[b],T.size(),T)==0;\n}\n\nsigned main(){\n    cin>>S;\n    sa=SA::construct_sa(S);\n    cin>>Q;\n\n    rep(i,sa.size())cout<<S.substr(sa[i],S.size()-sa[i])<<endl;\n\n    while(Q--){\n        string T;cin>>T;\n        if(contain(S,sa,T))cout<<1<<endl;\n        else cout<<0<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    build_sa();\n    //build_lcp();\n    //build_rmq();\n  }\n  void build_sa(){\n    \n    S.push_back('$');\n    vector<int> c(n+1,0),ord(n+1,0);\n    for(int i=0;i<=n;i++) ord[i]=n-i;\n    return;\n    sort(ord.begin(),ord.end(),[&](int a,int b){return S[a]<S[b];});\n    return;\n    for(int i=0;i<=n;i++){\n      sa[i]=ord[i];\n      c[i]=S[i];\n    }\n    \n    for(int len=1;len<=n;len*=2){\n      vector<int> r=c;\n      for(int i=0;i<=n;i++){\n\t c[sa[i]] =\n\t   i > 0 &&\n\t   r[sa[i - 1]] == r[sa[i]] &&\n\t   sa[i - 1] + len <= n &&\n\t   r[sa[i - 1] + len / 2] == r[sa[i] + len / 2]\n\t   ? c[sa[i - 1]] : i;\n      }\n      vector<int> cnt(n+1);\n      for(int i=0;i<=n;i++) cnt[i]=i;\n      vector<int> s=sa;\n      for(int i=0;i<=n;i++){\n\tint s1=s[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n);\n    for(int i=0;i<n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  return 0;\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    //assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\ntemplate<typename T>\nclass PMA {\nprivate:\n    uint32_t id = 0;\n    uint32_t accepted = 1;\n\npublic:\n    struct Node {\n        uint32_t id;\n        uint32_t accepted = 0;\n        unordered_map<T, Node*> children;\n        Node *failure = nullptr;\n    };\n\n    Node *root;\n\n    int32_t insert(const vector<T> &vec) {\n        Node *node = root;\n        for (T v : vec) {\n            auto itr = node->children.find(v);\n            if (itr != node->children.end()) {\n                node = itr->second;\n            } else {\n                node->children[v] = new Node;\n                node->children[v]->id = id++;\n                node = node->children[v];\n            }\n        }\n\n        node->accepted = accepted++;\n\n        return node->id;\n    }\n\n    Node *transition(Node *node, T v) {\n        while (node != nullptr) {\n            auto itr = node->children.find(v);\n            if (itr != node->children.end()) {\n                return itr->second;\n            } else {\n                node = node->failure;\n            }\n        }\n        return root;\n    }\n\n    void link_failure() {\n        queue<Node*> tovisit;\n        tovisit.push(root);\n        while (!tovisit.empty()) {\n            Node *node = tovisit.front();\n            tovisit.pop();\n\n            for (auto p : node->children) {\n                T v = p.first;\n                Node *child = p.second;\n\n                child->failure = transition(node->failure, v);\n\n                tovisit.push(child);\n            }\n        }\n        return;\n    }\n\n    PMA() {\n        root = new Node;\n        root->id = id++;\n    }\n};\n\nint main() {\n    vector<uint8_t> T;\n    string temp;\n    cin >> temp;\n    T = vector<uint8_t>(temp.begin(), temp.end());\n\n    int32_t Q;\n    cin >> Q;\n\n    vector<vector<uint8_t>> P(Q);\n    for (int32_t i = 0; i < Q; i++) {\n        string temp;\n        cin >> temp;\n        P[i] = vector<uint8_t>(temp.begin(), temp.end());\n    }\n\n    PMA<uint8_t> pma;\n    for (vector<uint8_t> vec : P) pma.insert(vec);\n    pma.link_failure();\n\n    vector<bool> result(Q, false);\n    PMA<uint8_t>::Node *node = pma.root;\n    for (uint8_t c : T) {\n        node = pma.transition(node, c);\n        if (node->accepted > 0) result[node->accepted-1] = true;\n    }\n\n    for (bool b : result) cout << (b ? \"1\" : \"0\") << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n\n  RollingHash(string s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  bool operator()(int i, int j) {\n    int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }\n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n\n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  sort(ALL(sa),rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  while(n--){\n    cin >> t;\n    cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define V vector<long long>\n#define VV vector<vector<long long>>\n#define rep(i,n) for(ll (i)=0;(i)<(n);++(i))\nusing namespace std;\n\nstruct suffix_array{\n\n    int n,logn;\n    string s;\n    vector<int> rank,sa,lcp;\n\n    suffix_array(string &str):s(str){\n        build_suffix_array();\n        build_lcp();\n    }\n\n    void build_suffix_array(){\n        n=s.size();\n        logn=floor(log2(n));\n        rank.resize(n);\n        sa.resize(n);\n        for(int i=0;i<n;++i){\n            rank[i]=s[i];\n            sa[i]=i;\n        }\n        for(int k=0;k<=logn;++k){\n            auto comp=[&](int a,int b){\n                if(rank[a]!=rank[b])return rank[a]<rank[b];\n                a=(a+(1<<k)<n)?rank[a+(1<<k)]:-1;\n                b=(b+(1<<k)<n)?rank[b+(1<<k)]:-1;\n                return a<b;\n            };\n            sort(sa.begin(),sa.end(),comp);\n            vector<int> tmp=rank;\n            tmp[sa[0]]=0;\n            for(int i=1;i<n;++i)tmp[sa[i]]=tmp[sa[i-1]]+comp(sa[i-1],sa[i]);\n            rank=tmp;\n        }\n    }\n\n    void build_lcp(){\n        vector<int> tmp(n);\n        for(int i=0;i<n;++i){\n            tmp[sa[i]]=i;\n        }\n        int h=0;\n        lcp.resize(n);\n        for(int i=0;i<n;++i){\n            if(tmp[i]==0){\n                lcp[0]=0;\n                if(h>0)h--;\n                continue;\n            }\n            int j=sa[tmp[i]-1];\n            if(h>0)h--;\n            for(;i+h<n&&j+h<n;++h){\n                if(s[i+h]!=s[j+h])break;\n            }\n            lcp[tmp[i]]=h;\n        }\n    }\n\n    int compare(string t,int s_idx=0,int t_idx=0){\n        while(s_idx<s.size()&&t_idx<t.size()){\n            if(s[s_idx]<t[t_idx]){\n                return 1;\n            }else if(s[s_idx]>t[t_idx]){\n                return -1;\n            }\n            s_idx++;\n            t_idx++;\n        }\n        if(t_idx>=t.size()){\n            return 0;\n        }else{\n            if(s_idx>=s.size()){\n                return 1;\n            }else{\n                return -1;\n            }\n        }\n    }\n\n    int lower_bound(string t){\n        int l=0;\n        int r=n-1;\n        while(l<=r){\n            int mid=l+(r-l)/2;\n            if(compare(t,sa[mid])>0){\n                l=mid+1;\n            }else{\n                r=mid-1;\n            }\n        }\n        return l;\n    }\n\n    int upper_bound(string t){\n        int l=0;\n        int r=n-1;\n        while(l<=r){\n            int mid=l+(r-l)/2;\n            if(compare(t,sa[mid])>=0){\n                l=mid+1;\n            }else{\n                r=mid-1;\n            }\n        }\n        return l;\n    }\n\n    int operator[](int k)const{\n        return sa[k];\n    }\n\n    int size()const{\n        return n;\n    }\n\n};\n\nll num(ll a){\n    return a*(a+1)/2;\n}\n\nint main(){\n    string s;\n    cin>>s;\n    suffix_array sa(s);\n    ll n;\n    cin>>n;\n    rep(i,n){\n        string t;\n        cin>>t;\n        cout<<(sa.upper_bound(t)!=sa.lower_bound(t))<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring S,T;\nstring V[1000][100];\nint main(){\n\tint q,a,b,c;\n\tb=S.size();\n\tcin>>S;\n\ta=min(b,100);\n\tfor(int i=1;i<100;i++){\n\t\tfor(int j=0;j<=b-i;j++){\n\t\t\tV[j][i]=S.substr(j,i);\n\t\t}\n\t}\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>T;\n\t\tc=T.size();\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(V[j][c]==T){\n\t\t\t\tcout<<\"1\"<<endl;\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t}\n\t\tcout<<\"0\"<<endl;\n\t\tExit:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n,0);\n    lcp.resize(n,0);\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    vector<int> c(n,0),ord(n,0);\n    for(int i=0;i<n;i++) ord[i]=n-1-i;\n    sort(ord.begin(),ord.end(),[&](int a,int b){return S[a]<S[b];});\n    \n    for(int i=0;i<n;i++){\n      sa[i]=ord[i];\n      c[i]=S[i];\n    }\n    \n    for(int len=1;len<n;len*=2){\n      vector<int> r=c;\n      for(int i=0;i<n;i++){\n\t c[sa[i]] = i > 0 && r[sa[i - 1]] == r[sa[i]] && sa[i - 1] + len < n && r[sa[i - 1] + len / 2] == r[sa[i] + len / 2] ? c[sa[i - 1]] : i;\n      }\n      vector<int> cnt(n);\n      for(int i=0;i<n;i++) cnt[i]=i;\n      vector<int> s=sa;\n      for(int i=0;i<n;i++){\n\tint s1=s[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n    }\n  }\n  bool contains(string T){\n    int a=0,b=S.length()+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==(int)S.length()+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n);\n    for(int i=0;i<n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nclass suffix_array{\n    void create_begin_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        int sum=0;\n        for(int i=0;i<bucket.size();i++){bucket[i]+=sum;swap(sum,bucket[i]);}\n    }\n\n    void create_end_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        for(int i=1;i<bucket.size();i++)bucket[i]+=bucket[i-1];\n    }\n\n    void induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_begin_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(sa[i]>0&&is_l[sa[i]-1])sa[bucket[v[sa[i]-1]]++]=sa[i]-1;\n    }\n\n    void invert_induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_end_bucket(v,bucket);\n        for(int i=v.size()-1;i>=0;i--)if(sa[i]>0&&!is_l[sa[i]-1])sa[--bucket[v[sa[i]-1]]]=sa[i]-1;\n    }\n\n    vector<int>sa_is(vector<int>v,int mv){\n        if(v.size()==1)return vector<int>(1,0);\n\n        vector<int>is_l(v.size());\n        vector<int>bucket(mv+1);\n        vector<int>sa(v.size(),-1);\n        auto is_lms=[&](int x)->bool{return x>0&&is_l[x-1]&&!is_l[x];};\n\n        is_l[v.size()-1]=0;\n        for(int i=v.size()-2;i>=0;i--)is_l[i]=v[i]>v[i+1]||(v[i]==v[i+1]&&is_l[i+1]);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(is_lms(i))sa[--bucket[v[i]]]=i;\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n\n        int cur=0;\n        vector<int>order(v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))order[i]=cur++;\n\n        vector<int>next_v(cur);\n        cur=-1;\n        int prev=-1;\n        for(int i=0;i<v.size();i++){\n            if(!is_lms(sa[i]))continue;\n            bool diff=false;\n            for(int d=0;d<v.size();d++){\n                if(prev==-1||v[sa[i]+d]!=v[prev+d]||is_l[sa[i]+d]!=is_l[prev+d]){\n                    diff=true;\n                    break;\n                }\n                else if(d>0&&is_lms(sa[i]+d))break;\n            }\n            if(diff){cur++;prev=sa[i];}\n            next_v[order[sa[i]]]=cur;\n        }\n\n        vector<int>re_order(next_v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))re_order[order[i]]=i;\n        vector<int>next_sa=sa_is(next_v,cur);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<sa.size();i++)sa[i]=-1;\n        for(int i=next_sa.size()-1;i>=0;i--)sa[--bucket[v[re_order[next_sa[i]]]]]=re_order[next_sa[i]];\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n        return sa;\n    }\n\n    vector<int>sa_is(string &s){\n        vector<int>v(s.size()+1);\n        for(int i=0;i<s.size();i++)v[i]=s[i];\n        sa=sa_is(v,*max_element(v.begin(),v.end()));\n    }\n\n    void construct_lcp(){\n        lcp.resize(s.size());\n        rank.resize(s.size()+1);\n        int n=s.size();\n        for(int i=0;i<=n;i++)rank[sa[i]]=i;\n        int h=0;\n        lcp[0]=0;\n        for(int i=0;i<n;i++){\n            int j=sa[rank[i]-1];\n\n            if(h>0)h--;\n            for(;j+h<n&&i+h<n;h++){\n                if(s[j+h]!=s[i+h])break;\n            }\n            lcp[rank[i]-1]=h;\n        }\n    }\n\n    class sparse_table{\n        vector<vector<int> >st;\n    public:\n        void init(vector<int>&v){\n            int b;\n            for(b=0;(1<<b)<=v.size();b++);\n            vector<int>tmp(1<<b);\n            st.assign(b,tmp);\n            for(int i=0;i<v.size();i++)st[0][i]=v[i];\n\n            for(int i=1;i<b;i++){\n                for(int j=0;j+(1<<i)<=(1<<b);j++){\n                    st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);\n                }\n            }\n        }\n        int get_min(int l,int r){\n            assert(l<r);\n            int b=32-__builtin_clz(r-l)-1;\n            return min(st[b][l],st[b][r-(1<<b)]);\n        }\n        sparse_table(){}\n        sparse_table(vector<int>&v){init(v);}\n    };\n    sparse_table st;\npublic:\n    string s;\n    vector<int>sa,lcp,rank;\n    void init(string &t){\n        s=t;\n        sa_is(s);\n        construct_lcp();\n        st.init(lcp);\n    }\n    suffix_array(string &t){init(t);}\n    suffix_array(){}\n\n    bool contain(string &t){\n        int lb=0,ub=s.size();\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            if(s.compare(sa[mid],t.size(),t)<0)lb=mid;\n            else ub=mid;\n        }\n        return s.compare(sa[ub],t.size(),t)==0;\n    }\n\n    int get_lcp(int i,int j){\n        if(rank[i]>rank[j])swap(i,j);\n        return st.get_min(rank[i],rank[j]);\n    }\n};\n\nsigned main(){\n    string s;cin>>s;\n    suffix_array sa(s);\n    int q;cin>>q;\n    while(q--){\n        string t;\n        cin>>t;\n        cout<<sa.contain(t)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ull unsigned long long\nusing namespace std;\null B=100000007;\n\nint contain(string a,string b){\n  int al=a.size(),bl=b.size();\n  if(al>bl)return 0;\n  \n  ull t=1;\n  for(int i=0;i<al;i++)t*=B;\n\n  int ah=0,bh=0;\n  for(int i=0;i<al;i++)ah=ah*B+a[i];\n  for(int i=0;i<al;i++)bh=bh*B+b[i];\n\n  for(int i=0;i+al<=bl;i++){\n    if(ah==bh)return 1;\n    if(i+al<bl)bh=bh*B+b[i+al]-b[i]*t;\n  }\n  return 0;\n}\n\nint main(){\n  int n;\n  string b;\n  cin>>b>>n;\n  for(int i=0;i<n;i++){\n    string a;\n    cin>>a;\n    cout<<contain(a,b)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 1000005\n\n//Suffix_Array\n//O(|T|log|S|) S??????????????????T????????????????????????????´¢\n#define rank A\nint n,Len;\nint rank[MAX_N+1];\nint tmp[MAX_N+1];\n\n//(rank[i],rank[i+k])??¨(rank[j],rank[j+k])?????????\nbool compare_sa(int i,int j){\n  if(rank[i]!=rank[j])return rank[i]<rank[j];\n  int ri=i+Len<=n?rank[i+Len]:-1;\n  int rj=j+Len<=n?rank[j+Len]:-1;\n  return ri<rj;\n}\n\n//?????????S?????\\?°??????????????§????\nvoid construct_sa(string S,int *sa){\n  n=S.length();\n  //?????????????????????????????????????????????????????????\n  for(int i=0;i<=n;i++){\n    sa[i]=i;\n    rank[i]=i<n?S[i]:-1;\n  }\n  //k????????????????????????????????????????????¨???????????????2k????????§?????????\n  for(Len=1;Len<=n;Len*=2){\n    sort(sa,sa+n+1,compare_sa);\n    //?????£??????tmp????¬?????????????????¨?????????????rank?????£??\\\n    tmp[sa[0]]=0;\n    for(int i=1;i<=n;i++)\n      tmp[sa[i]]=tmp[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n    for(int i=0;i<=n;i++)rank[i]=tmp[i];\n  }\n}\n\n//S??????????????????T????????????????????????????´¢??????\nbool contain(string S,int *sa,string T){\n  int left=0,right=S.length();\n  while(right-left>1){\n    int mid=(left+right)/2;\n    if(S.compare(sa[mid],T.length(),T)<0)left=mid;\n    else right=mid;\n  }\n  return S.compare(sa[right],T.length(),T)==0;\n}\n\nstring t,p;\nint q,sa[MAX_N];\nint main(){\n  cin>>t;\n  construct_sa(t,sa);\n  cin>>q;\n  while(q--){\n    cin>>p;\n    if(contain(t,sa,p))printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\n\n#define fi(x) get<0>(x)\n#define se(x) get<1>(x)\n\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\ntypedef vector<pll> vpl;\n\nstring t;\nstring p;\nlli q;\n\nvll sa;\nvll tmp;\nvpl rnk;\n\nint main(){\n    cin >> t;\n    sa = vll(t.size());rnk = vpl(t.size());tmp = vll(t.size());\n    for(lli i = 0;i < t.size();i++) sa[i] = i;\n    for(lli i = 0;i < t.size();i++) fi(rnk[i]) = t[i];\n    for(lli k = 1;k < 2*t.size();k *= 2){\n        sort(sa.begin(),sa.end(),[](lli a,lli b){\n            return rnk[a] < rnk[b];\n        });\n        for(lli i = 1;i < sa.size();i++){\n            tmp[sa[i]] = tmp[sa[i-1]];\n            if(rnk[sa[i]] != rnk[sa[i-1]]) tmp[sa[i]]++;\n        }\n        for(lli i = 0;i < sa.size();i++){\n            fi(rnk[sa[i]]) = tmp[sa[i]];\n        }\n        for(lli i = 0;i < sa.size();i++){\n            if(sa[i]+k < t.size()) se(rnk[sa[i]]) = fi(rnk[sa[i]+k]);\n            else se(rnk[sa[i]]) = -1;\n        }\n    }\n    cin >> q;\n    for(lli i = 0;i < q;i++){\n        cin >> p;\n        lli lwrbnd = *lower_bound(sa.begin(),sa.end(),p,[](lli a,string s){\n            if(t.size() < a + s.size()) return false;\n            return t.compare(a,s.size(),s) < 0;\n        });\n        if(t.size() >= lwrbnd + p.size() && t.compare(lwrbnd,p.size(),p) == 0) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\n\nvector<int> SuffixArray;\n\nvector<int> SA_IS(vector<int> str, int var) {\n    if(str.size() == 1) {\n        vector<int> ret(1,0);\n        return ret;\n    }\n    str.push_back(0);\n    int si = str.size();\n    vector<int> st(var, 0), en(var, 0);\n    vector<int> SL(si, 0); //s..0, l..1\n    vector<int> SA(si, -1);\n    vector<int> LMS;\n    vector<int> is_LMS(si, -1);\n    rep(i,str.size()) en[str[i]]++;\n    for(int i = 1; i < var; i++) en[i] += en[i-1];\n    for(int i = 1; i < var; i++) st[i] = en[i-1];\n    SL[str.size()-1] = 0;\n    for(int i = str.size()-2; i >= 0; i--) {\n        if(str[i] == str[i+1]) {\n            SL[i] = SL[i+1];\n            continue;\n        }\n        if(str[i] > str[i+1]) SL[i] = 1;\n        else SL[i] = 0;\n    }\n    for(int i = 1; i < str.size(); i++) {\n        if(SL[i] == 0 && SL[i-1] == 1) {\n            SA[--en[str[i]]] = i;\n            LMS.push_back(i);\n            is_LMS[i] = 1;\n        }\n    }\n    rep(i,var-1) en[i] = st[i+1];\n    en[var-1] = str.size();\n\n    rep(i,str.size()) if(SA[i] > 0 && SL[SA[i]-1] == 1) { SA[st[str[SA[i]-1]]++] = SA[i]-1; }\n    st[0] = 0;\n    for(int i = 1; i < var; i++) st[i] = en[i-1];\n\n    for(int i = 1; i < str.size(); i++) if(SA[i] != -1 && SL[SA[i]] == 0) { SA[i] = -1; }\n\n    for(int i = str.size()-1; i >= 1; i--) if(SA[i] > 0 && SL[SA[i]-1] == 0) { SA[--en[str[SA[i]-1]]] = SA[i]-1; }\n    rep(i,var-1) en[i] = st[i+1];\n    en[var-1] = str.size();\n\n    int counter = 0;\n    vector<int> pre_sa, new_sa;\n    rep(i,SA.size()) if(is_LMS[SA[i]] != -1) {\n        is_LMS[SA[i]] = ++counter;\n\n        new_sa.clear();\n        for(int j = SA[i]; j < SA.size(); j++) {\n            new_sa.push_back(str[j]);\n            if(j != SA[i] && is_LMS[j] != -1) {\n                break;\n            }\n        }\n        if(pre_sa == new_sa) {\n            is_LMS[SA[i]] = --counter;\n        }\n        pre_sa = new_sa;\n    }\n\n    vector<int> new_str;\n    vector<int> rev((int)LMS.size()+1, 0);\n    counter = 0;\n    rep(i,is_LMS.size()) {\n        if(is_LMS[i] != -1) {\n            new_str.push_back(is_LMS[i]);\n            rev[counter++] = i;\n        }\n    }\n    vector<int> rec = SA_IS(new_str, new_str.size()+1);\n\n    rep(i,SA.size()) SA[i] = -1;\n\n    for(int i = rec.size()-1; i >= 0; i--) { SA[--en[str[rev[rec[i]]]]] = rev[rec[i]]; }\n    rep(i,var-1) en[i] = st[i+1];\n    en[var-1] = str.size();\n\n    rep(i,str.size()) if(SA[i] > 0 && SL[SA[i]-1] == 1) { SA[st[str[SA[i]-1]]++] = SA[i]-1; }\n\n    for(int i = 1; i < str.size(); i++) if(SA[i] != -1 && SL[SA[i]] == 0) { SA[i] = -1; }\n\n    for(int i = str.size()-1; i >= 1; i--) if(SA[i] > 0 && SL[SA[i]-1] == 0) { SA[--en[str[SA[i]-1]]] = SA[i]-1; }\n\n    SA.erase(SA.begin());\n    return SA;\n}\n\nstring t;\nint q;\n\nbool it_substr(int saidx, const vector<int> &text, const vector<int> &pt) {\n  int len = pt.size();\n  int n = t.size();\n  len = min(len, n - SuffixArray[saidx]);\n  int st = SuffixArray[saidx];\n  int d = 0;\n  rep(i, len) {\n    d++;\n    if (text[st+i] < pt[i]) return true;\n    else if (text[st+i] > pt[i]) return false;\n  }\n  if (st + d < n) {\n    return false;\n  }\n  else {\n    if (d < (int)pt.size()) return true;\n    else return false;\n  }\n}\n\nbool match(const vector<int> &text, const vector<int> &pt) {\n    int n = t.size();\n    int l = -1, r = n;\n    while (r - l > 1) {\n        int m = (r + l) / 2;\n        if (it_substr(m, text, pt)) l = m;\n        else r = m;\n    }\n    if (r == n) return false;\n    //cerr << r << endl;\n    int st = SuffixArray[r];\n    if (st + (int)pt.size() > n) return false;\n    rep(i, pt.size()) {\n      if (pt[i] != text[st+i]) return false;\n    }\n    return true;\n}\n\nmap<char, int> trans;\nint trans_counter = 0;\n\nvector<int> string_to_nums(string& s) {\n  rep(i, s.size()) {\n    if (trans.find(s[i]) != trans.end()) continue;\n    trans[s[i]] = ++trans_counter;\n  }\n  vector<int> ret;\n  rep(i, s.size()) {\n    ret.push_back(trans[s[i]]);\n  }\n  return ret;\n}\n\n\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n  cin >> t;\n  cin >> q;\n  vector<int> words = string_to_nums(t);\n  SuffixArray = SA_IS(words, 256);\n  rep(i, q) {\n    string p;\n    cin >> p;\n    vector<int> pwords = string_to_nums(p);\n    if (match(words, pwords)) cout << 1 << endl;\n    else cout << 0 << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int mb=n/2+n%2,mc=n/2,b[mb],c[mc];\n    REP(i,mb)b[i]=a[i];\n    REP(i,mc)c[i]=a[mb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(mb,b,rh), mergesort(mc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==mc)a[i]=b[j++];\n      else if(j==mb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,rh.n+1)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000000];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <sstream>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n#define rrep(i, a) RREP(i, a, 0)\n#define RREP(i, a, b) for(int i = a; i >= b; --i)\n#define repll(i, a) REPLL(i, 0, a)\n#define REPLL(i, a, b) for(ll i = a; i < b; ++i)\n#define rrepll(i, a) RREPLL(i, a, 0)\n#define RREPLL(i, a, b) for(ll i = a; i >= b; --i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<int, P> PP;\nconst double PI = 3.14159265358979323846;\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+18 + 10;\n\nclass RollingHash{\nprivate:\n\tstatic const ull B = (ull)1e+8 + 7;\n\n\tstd::string text;\n\tint texSize;\n\tstd::vector<ull> pow, phash;\n\n\tinline ull TextHash(int s, int e){\n\t\treturn phash[e] - phash[s] * pow[e - s];\n\t}\n\npublic:\n\tRollingHash(std::string tex) :text(tex), texSize(text.size()), pow(texSize + 1), phash(texSize + 1){\n\t\tpow[0] = 1;\n\t\tphash[0] = 0;\n\t\trep(i, texSize){\n\t\t\tphash[i + 1] = phash[i] * B + text[i];\n\t\t\tpow[i + 1] = pow[i] * B;\n\t\t}\n\t}\n\n\tbool find(std::string pat){\n\t\tint patSize = pat.size();\n\t\tif (patSize > texSize)return false;\n\n\t\tull patHash = 0;\n\t\trep(i, patSize)patHash = patHash * B + pat[i];\n\n\t\trep(i, texSize - patSize + 1){\n\t\t\tif (TextHash(i, i + patSize) == patHash){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint n;\n\nint main(){\n\tstd::string a;\n\tstd::cin >> a >> n;\n\n\tRollingHash rh(a);\n\n\trep(i, n){\n\t\tchar b[1005];\n\t\tscanf(\"%s\", &b);\n\t\tprintf(\"%d\\n\", (rh.find(b) ? 1 : 0));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tString t = scan.next();\n\t\tStringIndex si = new StringIndex(t, false);\n\n\t\tint q = scan.nextInt();\n\t\tfor (int i = 0; i < q; i++)\n\t\t\tif (si.isExist(scan.next(), t))\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"0\");\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass StringIndex {\n\tclass StIdx {\n\t\tint pos;\n\t\tchar ch;\n\n\t\tpublic StIdx(int i, char c) {\n\t\t\tpos = i;\n\t\t\tch = c;\n\t\t}\n\t}\n\n\tList<StIdx> idx = new ArrayList<StIdx>();\n\tint[] seq;\n\tint compLen = 1;\n\n\tclass strIndexComp implements Comparator<StIdx> {\n\n\t\t@Override\n\t\tpublic int compare(StIdx o1, StIdx o2) {\n\t\t\tif (compLen == 1)\n\t\t\t\tif (o1.ch > o2.ch)\n\t\t\t\t\treturn 1;\n\t\t\t\telse if (o1.ch == o2.ch)\n\t\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\n\t\t\tif (seq[o1.pos] > seq[o2.pos])\n\t\t\t\treturn 1;\n\t\t\tif (seq[o1.pos] == seq[o2.pos]) {\n\t\t\t\tint npos1 = o1.pos + compLen / 2;\n\t\t\t\tint npos2 = o2.pos + compLen / 2;\n\t\t\t\tint nseq1 = 0, nseq2 = 0;\n\t\t\t\tif (npos1 < seq.length)\n\t\t\t\t\tnseq1 = seq[npos1];\n\t\t\t\tif (npos2 < seq.length)\n\t\t\t\t\tnseq2 = seq[npos2];\n\t\t\t\tif (nseq1 > nseq2)\n\t\t\t\t\treturn 1;\n\t\t\t\telse if (nseq1 == nseq2)\n\t\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tboolean debug;\n\n\tpublic StringIndex(String t, boolean d) {\n\t\tdebug = d;\n\n\t\tseq = new int[t.length()];\n\t\tfor (int i = 0; i < t.length(); i++)\n\t\t\tidx.add(new StIdx(i, t.charAt(i)));\n\n\t\tfor (compLen = 1; compLen < idx.size(); compLen *= 2) {\n\t\t\tCollections.sort(idx, new strIndexComp());\n\n\t\t\tseq[idx.get(0).pos] = 1;\n\t\t\tfor (int i = 1; i < idx.size(); i++) {\n\t\t\t\tstrIndexComp cmp = new strIndexComp();\n\t\t\t\tif (cmp.compare(idx.get(i - 1), idx.get(i)) == 0)\n\t\t\t\t\tseq[idx.get(i).pos] = seq[idx.get(i - 1).pos];\n\t\t\t\telse\n\t\t\t\t\tseq[idx.get(i).pos] = seq[idx.get(i - 1).pos] + 1;\n\t\t\t}\n\n\t\t\tif (debug) {\n\t\t\t\tSystem.out.println(\"--------------------\");\n\t\t\t\tfor (int i = 0; i < idx.size(); i++)\n\t\t\t\t\tSystem.out.println(i + \"\\t\" + seq[idx.get(i).pos] + \"\\t\" + idx.get(i).pos + \"\\t\"\n\t\t\t\t\t\t\t+ t.substring(idx.get(i).pos));\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic boolean isExist(String p, String t) {\n\t\tint low = 0, hi = idx.size() - 1;\n\t\treturn (findBin(p, t, low, hi));\n\t}\n\n\tprivate boolean findBin(String p, String t, int low, int hi) {\n\t\tif (low > hi)\n\t\t\treturn false;\n\t\tint i = low + (hi - low) / 2;\n\t\tint r = p.compareTo(t.substring(idx.get(i).pos, idx.get(i).pos + p.length()));\n\t\tSystem.out.println(t.substring(idx.get(i).pos, idx.get(i).pos + p.length()));\n\t\tif (r == 0)\n\t\t\treturn true;\n\t\telse if (r < 0)\n\t\t\treturn findBin(p, t, low, i - 1);\n\t\telse\n\t\t\treturn findBin(p, t, i + 1, hi);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\n#define NUM 48\nusing namespace std;\n\nint T_char_count[128] = {0},P_char_count[128];\nint T_Chain[128][128];\n\nclass LocRecord{\n\npublic:\n\t//?????¢???????¢????\n\tLocRecord(){\n\t\tlocationTable = new int**[128];\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tlocationTable[i] = new int*[128];\n\t\t\tfor(int k = 0; k < 128; k++){\n\t\t\t\tif(T_Chain[i][k] > 0){\n\t\t\t\t\tlocationTable[i][k] = new int[T_Chain[i][k]+1];\n\t\t\t\t\tfor(int p = 0; p < T_Chain[i][k]+1; p++){\n\t\t\t\t\t\tlocationTable[i][k][p] = -1;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tlocationTable[i][k] = new int[2];\n\t\t\t\t\tfor(int p = 0; p < 2; p++){\n\t\t\t\t\t\tlocationTable[i][k][p] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinit();\n\t}\n\n\t//-1?????£??\\\n\tvoid init(){\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tfor(int k = 0; k < 128; k++){\n\t\t\t\tindex[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init_index(char first,char second){\n\t\tindex[first][second] = 0;\n\t}\n\n\tvoid regist_loc(char first,char second,int location){\n\t\tlocationTable[first][second][index[first][second]] = location;\n\t\tindex[first][second]++;\n\t}\n\n\tint next_loc(char first,char second){\n\t\treturn locationTable[first][second][index[first][second]++];\n\t\t/*index[first][second]++;\n\t\treturn ret;*/\n\t}\n\nprivate:\n\tint*** locationTable;\n\tint index[128][128];\n};\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\t\t\treturn length < arg.length;\n\t};\n\tInfo(int arg_length,int arg_id,ull arg_hashValue){\n\t\tlength = arg_length;\n\t\tid = arg_id;\n\t\thashValue = arg_hashValue;\n\t}\n\n\tint length,id;\n\tull hashValue;\n};\n\nint main(){\n\n\tfor(int i = 0; i < 128; i++){\n\t\tT_char_count[i] = 0;\n\t\tfor(int k = 0; k < 128; k++){\n\t\t\tT_Chain[i][k] = 0;\n\t\t}\n\t}\n\n\tint T_length;\n\n\tchar* T = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tchar pre = T[0];\n\tT_char_count[T[0]]++;\n\n\tfor(T_length = 1; T[T_length] != '\\0';T_length++){\n\t\tT_char_count[T[T_length]]++;\n\t\tT_Chain[pre][T[T_length]]++;\n\t\tpre = T[T_length];\n\t}\n\n\tLocRecord locRecord;\n\tlocRecord.init();\n\n\n\tpre = T[0];\n\t//T[i]????????????i??§???????????¨????¨????\n\tfor(int i = 1; i < T_length; i++){\n\t\tlocRecord.regist_loc(pre,T[i],i-1);\n\t\tpre = T[i];\n\t}\n\n\tull* HASH = new ull[T_length+1];\n\tull* P = new ull[T_length+1];\n\n\tHASH[0] = 0;\n\tP[0] = 1;\n\n\t//T??????????????\\???????±???????\n\tfor(int i = 1; i <= T_length; i++){\n\t\tHASH[i] = T[i-1] + HASH[i-1]*MOD;\n\t\tP[i] = P[i-1]*MOD;\n\t}\n\n\n\tvector<Info> V[128][128];\n\n\tint Q,S_length,left,P_char_count[128];\n\tscanf(\"%d\",&Q);\n\n\tbool check[Q];\n\n\tfor(int i = 0; i < Q; i++)check[i] = false;\n\n\tchar S[1001];\n\tull S_HASH[1001],S_value,T_value,D;\n\tbool FLG;\n\n\n\t//Q??¶??????????????\\???????¨????\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",S);\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tP_char_count[i] = 0;\n\t\t}\n\n\t\tfor(S_length = 0;S[S_length] != '\\0';S_length++){\n\t\t\tP_char_count[S[S_length]]++;\n\t\t}\n\n\t\tFLG = true;\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tif(T_char_count[i] < P_char_count[i]){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG)continue;\n\n\t\tif(S_length == 1){\n\t\t\tcheck[loop] = true;\n\t\t\tcontinue;\n\t\t}\n\n\n\n\t\tS_HASH[0] = 0;\n\t\tfor(int i = 1; i <= S_length; i++){\n\t\t\tS_HASH[i] = S[i-1] + S_HASH[i-1]*MOD;\n\t\t}\n\n\t\tS_value = S_HASH[S_length];\n\n\t\tV[S[0]][S[1]].push_back(Info(S_length,loop,S_value));\n\t}\n\n\tint calc_length;\n\n\tfor(int first_word = 48; first_word <= 122; first_word++){\n\t\tfor(int second_word = 48; second_word <= 122;second_word++){\n\t\t\tfor(int i = 0; i < V[first_word][second_word].size();i++){\n\n\t\t\t\tlocRecord.init_index(first_word,second_word);\n\n\t\t\t\tcalc_length = V[first_word][second_word][i].length;\n\t\t\t\tS_value = V[first_word][second_word][i].hashValue;\n\n\t\t\t\tD = P[calc_length];\n\n\t\t\t\twhile((left = locRecord.next_loc(first_word,second_word)) != -1){\n\t\t\t\t\tif(left+calc_length-1 >= T_length)break;\n\n\t\t\t\t\t//T_value = HASH[left+calc_length]-HASH[left]*D;\n\n\t\t\t\t\tif(HASH[left+calc_length]-HASH[left]*D == S_value){\n\t\t\t\t\t\tcheck[V[first_word][second_word][i].id] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tif(check[i])printf(\"1\\n\");\n\t\telse{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n/2+n%2,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==nc)a[i]=b[j++];\n      else if(j==nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  /*\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n  */\n  int sa[rh.n+1];\n  REP(i,rh.n+1)sa[i]=i;\n  sort(sa,sa+rh.n+1,rh);\n  vector<int>res(rh.n+1);\n  REP(i,rh.n+1)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define show(x) cerr << #x << \" = \" << x << endl;\nclass SuffixArrayInducedSorting\n{\nprivate:\n    static constexpr int encode(const int c) { return c == '$' ? 0 : 'a' <= c and c <= 'z' ? c - 'a' + 1 : 'A' <= c and c <= 'Z' ? c - 'A' + 27 : c - '0' + 53; }\n    static constexpr char decode(const int n) { return (n == 0 ? '$' : 'a' + n - 1); }\n    enum class Type : char {\n        L = 0,\n        S = 1,\n        LMS = 2,\n    };\n\npublic:\n    SuffixArrayInducedSorting(const string& s, const int kind_) : N(s.size() + 1), kind{kind_ + 1}, S(s.size() + 1, 0), type(N), next(N, 1), bucket(kind), num(kind, 0), head(kind, 0), tail(kind, 0)\n    {\n        for (int i = 0; i < s.size(); i++) {\n            S[i] = encode(s[i]);\n        }\n        initializeData();\n        sortLMS();\n    }\n    SuffixArrayInducedSorting(const vector<int>& s, const int kind_) : N(s.size() + 1), kind{kind_ + 1}, S(s), type(N), next(N, 1), bucket(kind), num(kind, 0), head(kind, 0), tail(kind, 0)\n    {\n        S.push_back(0);\n        initializeData();\n        sortLMS();\n    }\n    void debugPrint() const\n    {\n        for (int i = 0; i < N; i++) {\n            cout << decode(S[i]);\n        }\n        cout << endl;\n        for (int i = 0; i < N; i++) {\n            cout << (type[i] == Type::L ? \"L\" : \"S\");\n        }\n        cout << endl;\n        for (int i = 0; i < N; i++) {\n            cout << (type[i] == Type::LMS ? \"@\" : \" \");\n        }\n        cout << endl;\n        for (int i = 0; i < kind; i++) {\n            if (bucket[i].empty())\n                continue;\n            cout << \"[\" << decode(i) << \"]:\\n\";\n            for (const int p : bucket[i]) {\n                cout << \"  \" << p << endl;\n            }\n        }\n    }\n\n    vector<int> getSuffixArray() const\n    {\n        vector<int> ans(N - 1);\n        for (int pos = 0, i = 1; i < kind; i++) {  // 番兵以外\n            for (const int p : bucket[i]) {\n                ans[pos++] = p;\n            }\n        }\n        return ans;\n    }\n\nprivate:\n    void initializeData()\n    {\n        for (const int i : S) {\n            num[i]++;\n        }\n        for (int i = 0; i < kind; i++) {\n            bucket[i].resize(num[i], -1);\n            tail[i] = num[i] - 1;\n        }\n        type[N - 1] = Type::S;\n        for (int i = N - 2; i >= 0; i--) {\n            type[i] = (S[i] != S[i + 1] ? (S[i] < S[i + 1] ? Type::S : Type::L) : type[i + 1]);\n            if (type[i] == Type::L and type[i + 1] == Type::S) {\n                type[i + 1] = Type::LMS;\n                LMS.push_back(i + 1);\n            }\n        }\n        for (int pos = N - 1, i = N - 2; i >= 0; i--) {\n            next[i] = pos;\n            if (type[i] == Type::LMS) {\n                pos = i;\n            }\n        }\n    }\n\n    void sortLMS()\n    {\n        for (const int l : LMS) {\n            insertTail(l);\n        }\n        induce();\n        vector<int> lms;\n        for (int i = 0; i < kind; i++) {\n            for (const int p : bucket[i]) {\n                if (type[p] == Type::LMS) {\n                    lms.push_back(p);\n                }\n            }\n        }\n        const int size = lms.size();\n        vector<int> order(N / 2 + 1, 0);\n        int number = 1;\n        order[N / 2] = 1;\n        bool same = false;\n        for (int i = 1; i < size; i++) {\n            const int l1 = lms[i - 1];\n            const int r1 = next[l1];\n            const int l2 = lms[i];\n            const int r2 = next[l2];\n            if (r1 - l1 == r2 - l2 and vector<int>(S.begin() + l1, S.begin() + r1 + 1) == vector<int>(S.begin() + l2, S.begin() + r2 + 1)) {\n                same = true;\n            } else {\n                number++;\n            }\n            order[l2 / 2] = number;\n        }\n        if (same) {\n            vector<int> s(size);\n            for (int p = 0, i = 0; i <= N / 2; i++) {\n                if (order[i] > 0) {\n                    s[p++] = order[i];\n                }\n            }\n            const vector<int> sorted = SuffixArrayInducedSorting{s, number}.getSuffixArray();\n            for (int i = 0; i < kind; i++) {\n                head[i] = 0;\n                tail[i] = num[i] - 1;\n            }\n            for (int i = size - 1; i >= 0; i--) {\n                insertTail(LMS[size - 1 - sorted[i]]);\n            }\n            induce();\n        } else {\n            for (int i = 0; i < kind; i++) {\n                head[i] = 0;\n                tail[i] = num[i] - 1;\n            }\n            for (int i = size - 1; i >= 0; i--) {\n                insertTail(lms[i]);\n            }\n            induce();\n        }\n    }\n\n    void induce()\n    {\n        for (int i = 0; i < kind; i++) {\n            for (int j = 0; j < head[i]; j++) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] == Type::L) {\n                    insertHead(p - 1);\n                }\n            }\n            for (int j = tail[i] + 1; j < num[i]; j++) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] == Type::L) {\n                    insertHead(p - 1);\n                }\n            }\n        }\n        for (int i = 1; i < kind; i++) {  // 番兵以外\n            tail[i] = num[i] - 1;\n        }\n        for (int i = kind - 1; i >= 0; i--) {\n            for (int j = num[i] - 1; j > tail[i]; j--) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] != Type::L) {\n                    insertTail(p - 1);\n                }\n            }\n            for (int j = head[i] - 1; j >= 0; j--) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] != Type::L) {\n                    insertTail(p - 1);\n                }\n            }\n        }\n    }\n    void insertHead(const int i) { bucket[S[i]][head[S[i]]++] = i; }\n    void insertTail(const int i) { bucket[S[i]][tail[S[i]]--] = i; }\n\n    const int N;\n    const int kind;\n    vector<int> S;               // O(N)\n    vector<Type> type;           // O(N)\n    vector<int> next;            // O(N)\n    vector<vector<int>> bucket;  // O(N)\n    vector<int> num;             // O(K)\n    vector<int> head;            // O(K)\n    vector<int> tail;            // O(K)\n    vector<int> LMS;             // O(N)\n};\n\nint main()\n{\n    string s;\n    cin >> s;\n    const int size = s.size();\n    const vector<int> sa = SuffixArrayInducedSorting(s, 79).getSuffixArray();\n    int N;\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        string p;\n        cin >> p;\n        const int psize = p.size();\n        int inf = -1;\n        int sup = size;\n        while (sup - inf > 1) {\n            const int mid = (sup + inf) / 2;\n            const bool ok = s.substr(sa[mid], psize) < p;\n            if (ok) {\n                inf = mid;\n            } else {\n                sup = mid;\n            }\n        }\n        const bool ans = s.substr(sa[sup], psize) == p;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) const { \n    //const int k=lcp(i,j);\n    //const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    const int k=lcp2(i,j,0,(n-max(i,j))*2+1);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  inline bool cmp(const int& i, const int& j) const { \n    //const int k=lcp(i,j);\n    const int k=lcp2(i,j,0,(n-max(i,j))*2+1);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n  \n  \n  inline int lcp2(const int& i, const int& j, const int& l, const int& r) const {\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n  \n};\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  const int n = SZ(a);\n  if(n>1){\n    vector<int> b(a.begin(), a.begin()+n/2);\n    vector<int> c(a.begin()+n/2, a.end());\n    mergesort(b,rh);\n    mergesort(c,rh);\n    for (int i=0,j=0,k=0;i<n;i++){\n      if(k == SZ(c))a[i]=b[j++];\n      else if(j==SZ(b))a[i]=c[k++];\n      else if(rh.cmp(b[j],c[k]))a[i]=b[j++];\n      else a[i] = c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  //sort(ALL(sa),rh);\n  mergesort(sa,rh);\n  //if(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    int c=(a+b)/2;\n    if(S.compare(sa[c],T.length(),T)<0 )a=c;\n    else b=c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  while(n--){\n    cin >> t;\n    cout << contain(s,sa,t) << \"\\n\";\n    //cout << !!rh.find(t) << \"\\n\";\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair< P , int > PP;\n\nvoid suffixArray(char* s,vector<int> &res2){\n  \n  int len=strlen(s);\n  vector<int> res(len+1);\n  vector< PP > tmp(len+1);\n  res2=vector<int>(len+1);\n  \n  for(int i=0;i<=len;i++)res[i]=s[i];\n  \n  for(int k=1;k<=len;k*=2){\n    \n    for(int i=0;i<=len;i++){\n      tmp[i].first.first=res[i];\n      tmp[i].first.second=(i+k<=len?res[i+k]:0);\n      tmp[i].second=i;\n    }\n    sort(tmp.begin(),tmp.end());\n    int C=0;\n    for(int i=0;i<=len;i++){\n      int id=tmp[i].second;\n      if(i&& (tmp[i-1].first<tmp[i].first))C++;\n      res[id]=C;\n    }\n  }\n\n  //  vector<int> res2(len+1);\n  for(int i=0;i<=len;i++)res2[ res[i] ]=i;\n  return res2;\n}\n\nchar s[1000005];\nchar t[1000005];\nint main(){\n  scanf(\"%s\",s);\n  vector<int> ans;\n  suffixArray(s,ans);\n\n  int Q;\n  scanf(\"%d\",&Q);\n  \n  while(Q--){\n    scanf(\"%s\",t);\n    int len=strlen(t);\n    int l=0,r=ans.size(),m;\n    while(r-l>1){\n      m=(l+r)/2;\n      if( strncmp( s+ans[m] , t ,len ) <=0 )l=m;\n      else r=m;\n    }\n    if(strncmp(s+ans[l],t,len)==0)printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  \n  /*\n  for(int i=0;i<(int)ans.size();i++){\n    printf(\"%d %s\\n\",ans[i], (s+ans[i]) );\n  }\n  */\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nclass suffix_array{\n    void create_begin_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        int sum=0;\n        for(int i=0;i<bucket.size();i++){bucket[i]+=sum;swap(sum,bucket[i]);}\n    }\n\n    void create_end_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        for(int i=1;i<bucket.size();i++)bucket[i]+=bucket[i-1];\n    }\n\n    void induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_begin_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(sa[i]>0&&is_l[sa[i]-1])sa[bucket[v[sa[i]-1]]++]=sa[i]-1;\n    }\n\n    void invert_induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_end_bucket(v,bucket);\n        for(int i=v.size()-1;i>=0;i--)if(sa[i]>0&&!is_l[sa[i]-1])sa[--bucket[v[sa[i]-1]]]=sa[i]-1;\n    }\n\n    vector<int>sa_is(vector<int>v,int mv){\n        if(v.size()==1)return vector<int>(1,0);\n\n        vector<int>is_l(v.size());\n        vector<int>bucket(mv+1);\n        vector<int>sa(v.size(),-1);\n        auto is_lms=[&](int x)->bool{return x>0&&is_l[x-1]&&!is_l[x];};\n\n        is_l[v.size()-1]=0;\n        for(int i=v.size()-2;i>=0;i--)is_l[i]=v[i]>v[i+1]||(v[i]==v[i+1]&&is_l[i+1]);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(is_lms(i))sa[--bucket[v[i]]]=i;\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n\n        int cur=0;\n        vector<int>order(v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))order[i]=cur++;\n\n        vector<int>next_v(cur);\n        cur=-1;\n        int prev=-1;\n        for(int i=0;i<v.size();i++){\n            if(!is_lms(sa[i]))continue;\n            bool diff=false;\n            for(int d=0;d<v.size();d++){\n                if(prev==-1||v[sa[i]+d]!=v[prev+d]||is_l[sa[i]+d]!=is_l[prev+d]){\n                    diff=true;\n                    break;\n                }\n                else if(d>0&&is_lms(sa[i]+d))break;\n            }\n            if(diff){cur++;prev=sa[i];}\n            next_v[order[sa[i]]]=cur;\n        }\n\n        vector<int>re_order(next_v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))re_order[order[i]]=i;\n        vector<int>next_sa=sa_is(next_v,cur);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<sa.size();i++)sa[i]=-1;\n        for(int i=next_sa.size()-1;i>=0;i--)sa[--bucket[v[re_order[next_sa[i]]]]]=re_order[next_sa[i]];\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n        return sa;\n    }\n\n    vector<int>sa_is(string &s){\n        vector<int>v(s.size()+1);\n        for(int i=0;i<s.size();i++)v[i]=s[i];\n        sa=sa_is(v,*max_element(v.begin(),v.end()));\n    }\n\n    void construct_lcp(){\n        lcp.resize(s.size());\n        rank.resize(s.size()+1);\n        int n=s.size();\n        for(int i=0;i<=n;i++)rank[sa[i]]=i;\n        int h=0;\n        lcp[0]=0;\n        for(int i=0;i<n;i++){\n            int j=sa[rank[i]-1];\n\n            if(h>0)h--;\n            for(;j+h<n&&i+h<n;h++){\n                if(s[j+h]!=s[i+h])break;\n            }\n            lcp[rank[i]-1]=h;\n        }\n    }\n\n    class sparse_table{\n        vector<vector<int> >st;\n    public:\n        void init(vector<int>&v){\n            int b;\n            for(b=0;(1<<b)<v.size();b++);\n            st.assign(b,vector<int>(1<<b));\n            for(int i=0;i<v.size();i++)st[0][i]=v[i];\n\n            for(int i=1;i<b;i++){\n                for(int j=0;j+(1<<i)<=(1<<b);j++){\n                    st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);\n                }\n            }\n        }\n        int get_min(int l,int r){\n            assert(l<r);\n            int b=32-__builtin_clz(r-l)-1;\n            return min(st[b][l],st[b][r-(1<<b)]);\n        }\n        sparse_table(){}\n        sparse_table(vector<int>&v){init(v);}\n    };\n    sparse_table st;\npublic:\n    string s;\n    vector<int>sa,lcp,rank;\n    void init(string &t){\n        s=t;\n        sa_is(s);\n        //construct_lcp();\n        //st.init(lcp);\n    }\n    suffix_array(string &t){init(t);}\n    suffix_array(){}\n\n    bool contain(string &t){\n        int lb=0,ub=s.size();\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            if(s.compare(sa[mid],t.size(),t)<0)lb=mid;\n            else ub=mid;\n        }\n        return s.compare(sa[ub],t.size(),t)==0;\n    }\n\n    int get_lcp(int i,int j){\n        if(rank[i]>rank[j])swap(i,j);\n        return st.get_min(rank[i],rank[j]);\n    }\n};\n\nsigned main(){\n    string s;cin>>s;\n    suffix_array sa(s);\n    int q;cin>>q;\n    while(q--){\n        string t;\n        cin>>t;\n        cout<<sa.contain(t)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\n\nstruct PMA{\n    PMA *next[256];\n    Vec matched;\n    PMA(){ fill(next,next+256,(PMA*)0); }\n    ~PMA(){\n\tfor(int i = 0 ; i < 256 ; i++){\n\t    if(next[i]) delete next[i];\n\t}\n\tmatched.clear();\n    }\n};\n\nVec set_union(const Vec &a,const Vec &b){\n    int i = 0, j = 0, A = a.size(), B = b.size();\n    Vec res;\n    while(i < A && j < B){\n        if(a[i] == b[j]){\n            res.push_back(a[i]);\n            i++; j++;\n        }else if(a[i] > b[j]){\n            res.push_back(b[j++]);\n        }else{\n            res.push_back(a[i++]);\n        }\n    }\n    for( ; i < A ; i++) res.push_back(a[i]);\n    for( ; j < B ; j++) res.push_back(b[j]);\n    return res;\n}\n\nPMA *buildPMA(char *pattern[],int size){\n    PMA *root = new PMA;\n    for(int i = 0 ; i < size ; i++){\n        PMA *t = root;\n        for(int j = 0 ; pattern[i][j] != '\\0' ; j++){\n            char c = pattern[i][j];\n            if(t->next[c] == (PMA*)0) t->next[c] = new PMA;\n            t = t->next[c];\n        }\n        t->matched.push_back(i);\n    }\n    queue<PMA*> Q;\n    for(int i = 1 ; i < 256 ; i++){\n        if(root->next[i]){\n            root->next[i]->next[0] = root;\n            Q.push(root->next[i]);\n        }else{\n            root->next[i] = root;\n        }\n    }\n    while(!Q.empty()){\n        PMA *t = Q.front(); Q.pop();\n        for(int i = 1 ; i < 256 ; i++){\n            if(t->next[i]){\n                PMA *next = t->next[0];\n                while(!next->next[i]) next = next->next[0];\n                t->next[i]->next[0] = next->next[i];\n                t->next[i]->matched =\n                    set_union(t->next[i]->matched,next->next[i]->matched);\n                Q.push(t->next[i]);\n            }\n        }\n    }\n    return root;\n}\n\nvoid match(PMA *pma,const char *s,Vec &res){\n    for(int i = 0 ; s[i] != '\\0' ; i++){\n        int c = s[i];\n        while(!pma->next[c]) pma = pma->next[0];\n        pma = pma->next[c];\n        for(int j = 0 ; j < (int)pma->matched.size() ; j++){\n            res[pma->matched[j]] = 1;\n        }\n    }\n}\n\nchar T[1000001];\nchar *P[10000];\n\nint main(){\n    int Q;\n    scanf(\"%s%d\",T,&Q);\n    for(int i = 0 ; i < Q ; i++){\n        P[i] = new char;\n        scanf(\"%s\",P[i]);\n    }\n    PMA *pma = buildPMA(P,Q);\n    Vec res(Q,0);\n    match(pma,T,res);\n    for(int i = 0 ; i < (int)res.size() ; i++){\n\tprintf(\"%d\\n\",res[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//ALDS1_14_D\n#include <iostream>\n#include <string>\n#include <stdlib.h>\n#include <stdio.h>\nusing namespace std;\n\nint main(){\n\tstring T, P;\n\tint Q, check;\n\n\tcin>>T;\n\tcin>>Q;\n\n\tfor(int i=0;i<Q;i++){\n\t\tcin>>P;\n\t\tcheck = 0;\n\t\t\n\t\tif(T.length() >= P.length())\n\t\t\tfor(int j=0;j<=T.length()-P.length();j++)\n\t\t\t\tif(T.substr(j, P.length()) == P){\n\t\t\t\t\tcheck++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\tprintf(\"%d\\n\", check);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include <cstdlib>  \n#include <math.h>\n#include <cmath>\n#include<complex>\n#include<cctype>\n#include<string>\n#include<set>\n#include<iomanip>\n#include <map>\n#include<algorithm>\n#include <functional>\n#include<vector>\n#include<climits>\n#include<stack>\n#include<queue>\n#include<bitset>\n#include <deque>\n#include <climits>\n#include <typeinfo>\n#include <utility> \nusing namespace std;\nusing Complex = complex<double>;\nusing ll = long long;\ntemplate<typename T>using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst ll inf = 1145141919810364364LL;\ndouble PI = acos(-1.0);\n#define all(x) (x).begin(),(x).end()\n#define puts(x) cout << x << endl\n#define rep(i,m,n) for(ll i = m;i < n;++i)\n#define pb push_back\n#define fore(i,a) for(auto &i:a)\n#define rrep(i,m,n) for(ll i = m;i >= n;--i)\n\n\n\n//segmenttree(min)\nstruct Segmenttree {\n\tstatic const int N = 1 << 20;\n\tvector<ll>seg;\n\tvector<ll>idx;\n\tvoid st(ll p, ll v) {\n\t\tp += N - 1;\n\t\tseg[p] = v;\n\t\tidx[p] = p - N + 1;\n\t\twhile (p > 0) {\n\t\t\tp = (p - 1) / 2;\n\t\t\tseg[p] = min(seg[2 * p + 1], seg[2 * p + 2]);\n\t\t\tif (seg[2 * p + 1] > seg[2 * p + 2])idx[p] = idx[2 * p + 2];\n\t\t\telse if (seg[2 * p + 1] < seg[2 * p + 2])idx[p] = idx[2 * p + 1];\n\t\t\telse idx[p] = min(idx[2 * p + 1], idx[2 * p + 2]);\n\t\t}\n\t}\n\tpair<ll, ll> query(ll l, ll r, ll a, ll b, ll k) {\n\t\tif (r <= a || b <= l)return { inf,inf };\n\t\tif (l <= a && b <= r)return { seg[k],idx[k] };\n\t\tll m = (a + b) / 2;\n\t\tauto p1 = query(l, r, a, m, 2 * k + 1);\n\t\tauto p2 = query(l, r, m, b, 2 * k + 2);\n\t\tif (p1.first < p2.first) return p1;\n\t\telse if (p1.first > p2.first)return p2;\n\t\telse return { p1.first,min(p1.second,p2.second) };\n\t}\n\n\tvoid init() {\n\t\tseg.resize(2 * N);\n\t\tidx.resize(2 * N);\n\t\tfor (int i = 0; i < 2 * N; i++)seg[i] = inf;\n\t}\n\t//[l,r]\n\tll get(int l, int r) {\n\t\treturn query(l, r + 1, 0, N, 0).first;\n\t}\n\tll getidx(int l, int r) {\n\t\treturn query(l, r + 1, 0, N, 0).second;\n\t}\n\tpair<ll, ll>getp(int l, int r) {\n\t\treturn query(l, r + 1, 0, N, 0);\n\t}\n};\n\n//suffix array\nstruct suffixarray {\n\tvector<int>rk, rklcp, tmp, sa, lcp;\n\tint n, k;\n\tstring str;\t\t\n\tSegmenttree seg = Segmenttree();\n\n\tint compare_sa(int i, int j) {\n\t\tif (rk[i] != rk[j])return rk[i] < rk[j];\n\t\telse {\n\t\t\tint ri = i + k <= n ? rk[i + k] : -1;\n\t\t\tint rj = j + k <= n ? rk[j + k] : -1;\n\t\t\treturn ri < rj;\n\t\t}\n\t}\n\n\n\tvoid construct_sa(string S) {\n\t\tstr = S;\n\t\tn = str.size();\n\t\trk.resize(n + 1);\n\t\trklcp.resize(n + 1);\n\t\ttmp.resize(n + 1);\n\t\tsa.resize(n + 1);\n\t\tlcp.resize(n + 1);\n\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trk[i] = i < n ? str[i] : -1;\n\t\t}\n\t\tfor (k = 1; k <= n; k *= 2) {\n\t\t\tsort(all(sa), [&](int i, int j) {\n\t\t\t\tif (rk[i] != rk[j])return rk[i] < rk[j];\n\t\t\t\telse {\n\t\t\t\t\tint ri = i + k <= n ? rk[i + k] : -1;\n\t\t\t\t\tint rj = j + k <= n ? rk[j + k] : -1;\n\t\t\t\t\treturn ri < rj;\n\t\t\t\t}\n\t\t\t});\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (compare_sa(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++)rk[i] = tmp[i];\n\t\t}\n\t\tconstruct_lcp();\n\t}\n\n\n\tvoid construct_lcp() {\n\t\tfor (int i = 0; i <= n; i++)rklcp[sa[i]] = i;\n\t\tint h = 0;\n\t\tlcp[0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rklcp[i] - 1];\n\t\t\tif (h > 0)h--;\n\t\t\twhile (j + h < n && i + h < n) {\n\t\t\t\tif (str[j + h] != str[i + h])break;\n\t\t\t\th++;\n\t\t\t}\n\t\t\tlcp[rklcp[i] - 1] = h;\n\t\t}\n\t\tseg.init();\n\t\tfor (int i = 0; i < n; i++)seg.st(i, lcp[i]);\n\t}\n\n\tpair<int, int> get_lcp(string T, int si, int offset) {\n\t\tint i = offset;\n\t\tsi += offset;\n\t\twhile (i < T.size() && si < n) {\n\t\t\tif (T[i] != str[si]) {\n\t\t\t\treturn { i,T[i] - str[si] };\n\t\t\t}\n\t\t\ti++;\n\t\t\tsi++;\n\t\t}\n\t\treturn { i,0 };\n\t}\n\n\tint search(string T) {\n\t\tint ok = 0, ng = n + 1;\n\t\tint Llcp = 0;\n\t\twhile (ng - ok > 1) {\n\t\t\tint mid = (ok + ng) / 2;\n\t\t\tint nlcp = seg.get(ok,mid-1);\n\t\t\tif (Llcp < nlcp)ok = mid;\n\t\t\telse if (Llcp > nlcp)ng = mid;\n\t\t\telse {\n\t\t\t\tauto p = get_lcp(T, sa[mid], Llcp);\n\t\t\t\tif (p.second >= 0) {\n\t\t\t\t\tok = mid;\n\t\t\t\t\tLlcp = p.first;\n\t\t\t\t}\n\t\t\t\telse ng = mid;\n\t\t\t}\n\t\t}\n\t\treturn get_lcp(T,sa[ok],Llcp).first == T.size();\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tstring T;\n\tcin >> T;\n\n\tsuffixarray sa;\n\tsa.construct_sa(T);\n\n\tint Q;\n\tcin >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tstring P;\n\t\tcin >> P;\n\t\tputs(sa.search(P));\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int i, const int j) { \n    //const int k=lcp(i,j);\n    const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    if(i+k>=n)return 1;\n    if(j+k>=n)return 0;\n    return s[i+k] <= s[j+k];\n    //return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int b, const int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  /*\n  inline int lcp(const int i, const int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n  */\n  int lcp2(const int i, const int j, const int l, const int r){\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\n\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int inf = 1e7;\n\nint n;\nstring t;\nint q;\nstring p[10000];\nint sa[20][1000000];\nint isa[1000000];\nint lcp[2 << 20];\n\nint stu(int i, int x, int k, int l, int r){\n\tif(r <= i || i < l){\n\t\treturn lcp[k];\n\t}\n\tif(i <= l && r <= i + 1){\n\t\treturn lcp[k] = x;\n\t}\n\tint m = (l + r) / 2;\n\treturn lcp[k] = min(\n\t\tstu(i, x, 2 * k + 1, l, m),\n\t\tstu(i, x, 2 * k + 2, m, r)\n\t);\n}\nvoid stu(int i, int x){\n\tstu(i, x, 0, 0, n - 1);\n}\n\nint rmq(int a, int b, int k, int l, int r){\n\tif(r <= a || b <= l){\n\t\treturn inf;\n\t}\n\tif(a <= l && r <= b){\n\t\treturn lcp[k];\n\t}\n\tint m = (l + r) / 2;\n\treturn min(\n\t\trmq(a, b, 2 * k + 1, l, m),\n\t\trmq(a, b, 2 * k + 2, m ,r)\n\t);\n}\nint rmq(int a, int b){\n\treturn rmq(a, b, 0, 0, n - 1);\n}\n\nvoid pp(){\n\tstring v = t;\n\tsort(v.begin(), v.end());\n\trep(i, n){\n\t\tsa[0][i] = lower_bound(v.begin(), v.end(), t[i]) - v.begin();\n\t}\n\tfor(int i = 1; i <= 19; ++i){\n\t\tint k = 1 << i - 1;\n\t\tvector<P> s;\n\t\trep(j, n){\n\t\t\ts.push_back(P(sa[i - 1][j], j + k < n ? sa[i - 1][j + k] : -1));\n\t\t}\n\t\tvector<P> v = s;\n\t\tsort(v.begin(), v.end());\n\t\trep(j, n){\n\t\t\tsa[i][j] = lower_bound(v.begin(), v.end(), s[j]) - v.begin();\n\t\t}\n\t}\n\n\trep(i, n){\n\t\tisa[sa[19][i]] = i;\n\t}\n\n\tint l = 0;\n\trep(i, n){\n\t\tint r = sa[19][i];\n\t\tif(r == n - 1){\n\t\t\tl = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tint j = isa[r + 1];\n\t\twhile(i + l < n && j + l < n && t[i + l] == t[j + l]){\n\t\t\t++l;\n\t\t}\n\t\tstu(r, l);\n\t\tl = max(l - 1, 0);\n\t}\n}\n\nbool srch(const string& p){\n\tint m = p.size();\n\n\tint h = 0;\n\twhile(isa[0] + h < n && h < m && t[isa[0] + h] == p[h]){\n\t\t++h;\n\t}\n\n\tint l = 0;\n\tint r = n;\n\tbool b = true;\n\twhile(r - l > 1){\n\t\tint k = (l + r) / 2;\n\t\tif(b){\n\t\t\tint c = rmq(l, k);\n\t\t\tif(c > h){\n\t\t\t\tl = k;\n\t\t\t}\n\t\t\telse if(c < h){\n\t\t\t\tr = k;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(isa[k] + h < n && h < m && t[isa[k] + h] == p[h]){\n\t\t\t\t\t++h;\n\t\t\t\t}\n\t\t\t\tif(isa[k] + h == n){\n\t\t\t\t\tl = k;\n\t\t\t\t}\n\t\t\t\telse if(h == m){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(t[isa[k] + h] < p[h]){\n\t\t\t\t\t\tl = k;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tr = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint c = rmq(k, r);\n\t\t\tif(c > h){\n\t\t\t\tr = k;\n\t\t\t}\n\t\t\telse if(c < h){\n\t\t\t\tl = k;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(isa[k] + h < n && h < m && t[isa[k] + h] == p[h]){\n\t\t\t\t\t++h;\n\t\t\t\t}\n\t\t\t\tif(isa[k] + h == n){\n\t\t\t\t\tl = k;\n\t\t\t\t}\n\t\t\t\telse if(h == m){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(t[isa[k] + h] < p[h]){\n\t\t\t\t\t\tl = k;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tr = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tb = l == k;\n\t}\n\treturn isa[l] + m <= n && string(t, isa[l], m) == p;\n}\n\nint main(){\n\tcin >> t >> q;\n\tn = t.size();\n\trep(i, q){\n\t\tcin >> p[i];\n\t}\n\n\tpp();\n\n\trep(i, q){\n\t\tcout << srch(p[i]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    build_sa();\n    //build_lcp();\n    //build_rmq();\n  }\n  void build_sa(){\n    sa.clear();\n    sa.resize(n+1,0);\n    S.push_back('$');\n    iota(sa.begin(),sa.end(),0);\n    sort(sa.begin(),sa.end(),\n\t [&](int a,int b){\n\t   if(S[a]==S[b]) return a>b;\n\t   return S[a]<S[b];\n\t });\n    vector<int> c(n+1,0),r(n+1),cnt(n+1),s(n+1);\n    for(int i=0;i<=n;i++) r[i]=S[i];\n    for(int len=1;len<=n;len*=2){\n      for(int i=0;i<=n;i++){\n\t c[sa[i]]=\n\t   i>0 &&\n\t   r[sa[i-1]]==r[sa[i]] &&\n\t   sa[i-1]+len<=n &&\n\t   r[sa[i-1]+len/2]==r[sa[i]+len/2] ?\n\t   c[sa[i-1]]:i;\n      }\n      iota(cnt.begin(),cnt.end(),0);\n      copy(sa.begin(),sa.end(),r.begin());\n      for(int i=0;i<=n;i++){\n\tint s1=r[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n      c.swap(r);\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    lcp.clear();\n    lcp.resize(n+1,0);\n    vector<int> r2(n+1);\n    for(int i=0;i<=n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    //assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define MAX 1000002\ntypedef unsigned char byte;\nbyte mask[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\n\nint Lv[MAX];\nint n, k;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n    return L_i < L_j;\n}\n\nint main()\n{\n    int A[MAX];\n    std::string T;\n    std::cin >> T;\n    n = T.size();\n\tbyte *t;\n\tt = new byte [(n >> 3) + 1];\n\n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n    std::sort(A, A + n, cmp_Lv);\n\n\tfor(i = 1; i < n; i++){\n\t\tt[i >> 3] = (Lv[A[i]] != Lv[A[i - 1]] ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n\t}\n\n    Lv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n    }\n\n    k = 1;\n    while(1){\n        if(k > n) break;\n\n        std::sort(A, A + n, cmp);\n\n\t\tfor(i = 1; i < n; i++){\n\t\t\tt[i >> 3] = (cmp(A[i - 1], A[i]) ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n\t\t}\n\t\tLv[A[0]] = 0;\n\t\tfor(i = 1; i < n; i++){\n\t\t\tLv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n\t\t}\n\n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n\n    std::string P;\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n\n    A[n] = n;\n\n    while(q){\n        std::cin >> P;\n        left = 0, right = n, exist = false;\n        while(left < right){\n\n            if(n < P.size()){ exist = false; break; }\n\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n\n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint Q, doubles, lengths, dat[1000009], tmp[1000009], arrays[1000009]; string S, T;\nbool compare_suffix(int i, int j) {\n\tif (dat[i] == dat[j]) {\n\t\tint ri = (i + doubles <= lengths ? dat[i + doubles] : -1);\n\t\tint rj = (j + doubles <= lengths ? dat[j + doubles] : -1);\n\t\treturn ri < rj;\n\t}\n\treturn dat[i] < dat[j];\n}\nvoid suffix_array() {\n\tlengths = S.size();\n\tfor (int i = 0; i <= lengths; i++) arrays[i] = i, dat[i] = i < lengths ? S[i] : -1;\n\tfor (doubles = 1; doubles <= lengths; doubles <<= 1) {\n\t\tsort(arrays, arrays + lengths + 1, compare_suffix);\n\t\ttmp[arrays[0]] = 0;\n\t\tfor (int i = 1; i <= lengths; i++) tmp[arrays[i]] = tmp[arrays[i - 1]] + (compare_suffix(arrays[i - 1], arrays[i]) ? 1 : 0);\n\t\tfor (int i = 0; i <= lengths; i++) dat[i] = tmp[i];\n\t}\n}\nint main() {\n\tcin >> S >> Q;\n\tsuffix_array(S);\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> T;\n\t\tint l = 0, r = S.size() + 1; bool flag = false;\n\t\twhile (r - l > 1) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tstring S1 = S.substr(arrays[m], T.size());\n\t\t\tif (S1 == T) {\n\t\t\t\tflag = true; break;\n\t\t\t}\n\t\t\tif (S1 < T) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tprintf(flag ? \"1\\n\" : \"0\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1<<20\nusing namespace std;\n\nstruct P{\n  int a,b,idx;\n  P(){a=b=idx=0;}\n  P(int a,int b,int idx):a(a),b(b),idx(idx){};\n  bool operator < (const P &A) const{\n    if(a!=A.a) return a<A.a;\n    return b<A.b;\n  }\n};\n\nchar ch[N];\nP r[N];\nint n;\n\nvector<int> Sort(){\n    vector <int> R(n+1),res(n+1);\n  \n  for(int i=0;i<=n;i++) R[i]=ch[i];\n  \n  for(int i=1;i<=n;i*=2){\n    for(int j=0;j<=n;j++)r[j]=P(R[j],(j+i<=n)? R[j+i]:0,j);\n    sort(r,r+n+1);\n    R[r[0].idx]=0;\n    for(int j=1,C=0;j<=n;j++){\n      if(r[j-1]<r[j]) C++;\n      R[r[j].idx]=C;\n    }\n  }\n  for(int i=0;i<=n;i++) res[R[i]]=i;\n  return res;\n}\n\nint check(vector <int> &a,char *x){\n  int L=0,M,R=n,m=strlen(x);\n  while(L<R){\n    M=(L+R)/2;\n    if(strncmp(ch+a[M],x,m)<0)L=M+1;\n    else R=M;\n  }\n  return strncmp(ch+a[L],x,m)==0;\n}\n\nint main(){\n  scanf(\"%s\",ch);\n  n=strlen(ch);\n  int q;\n  cin>>q;\n  vector <int> Rank=Sort();\n  char a[1001];\n\n  while(q--){\n    scanf(\"%s\",a);\n    printf(\"%d\\n\",check(Rank,a));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\n\nstruct SuffixArray {\n\tint n, k;\n\tstring s;\n\tvector<int> ord, tmp, left;\n\tSuffixArray(const string &s) :s(s), n(s.size()), ord(n + 1), tmp(n + 1), left(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tleft[i] = i;\n\t\t\tord[i] = i < n ? s[i] : -1;\n\t\t}\n\t\tauto compare = [&](int i, int j) {\n\t\t\tif (ord[i] != ord[j])return ord[i] < ord[j];\n\t\t\telse {\n\t\t\t\tint ri = i + k <= n ? ord[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? ord[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t}\n\t\t};\n\t\tfor (k = 1; k <= n; k *= 2) {\n\t\t\tsort(left.begin(), left.end(), compare);\n\t\t\ttmp[left[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[left[i]] = tmp[left[i - 1]] + (compare(left[i - 1], left[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tord = tmp;\n\t\t}\n\t}\n\tint search(const string &pattern) {\n\t\tint ng = 0, ok = n + 1;\n\t\twhile (ng + 1 < ok) {\n\t\t\tint m = (ng + ok) / 2;\n\t\t\tif (s.compare(left[m], pattern.size(), pattern) >= 0)\n\t\t\t\tok = m;\n\t\t\telse\n\t\t\t\tng = m;\n\t\t}\n\t\tif (ok == n + 1)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn s.compare(left[ok], pattern.size(), pattern) == 0 ? ok : -1;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring T; cin >> T;\n\tint Q; cin >> Q;\n\tSuffixArray sa(T);\n\trep(i, 0, Q) {\n\t\tstring P; cin >> P;\n\t\tcout << (sa.search(P) != -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <numeric>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint Q; string s; vector<unsigned long long> p, h;\nunsigned long long gethash(int l, int r) {\n\treturn h[r] - h[l] * p[r - l];\n}\nint lcp(int x, int y) {\n\tint l = 0, r = min(s.size() - x, s.size() - y) + 1;\n\twhile (r - l > 1) {\n\t\tint m = (l + r) >> 1;\n\t\tif (gethash(x, x + m) == gethash(y, y + m)) l = m;\n\t\telse r = m;\n\t}\n\treturn l;\n}\nbool compare_sa(int i, int j) {\n\tint k = lcp(i, j);\n\tif (i + k >= s.size()) return true;\n\tif (j + k >= s.size()) return false;\n\treturn s[i + k] <= s[j + k];\n}\nint main() {\n\tcin >> s >> Q;\n\tvector<int> l(Q + 2); l[1] = s.size();\n\tfor (int i = 0; i < Q; i++) {\n\t\tstring t;\n\t\tcin >> t; s += t;\n\t\tl[i + 2] = l[i + 1] + t.size();\n\t}\n\tp.resize(s.size() + 1); p[0] = 1;\n\th.resize(s.size() + 1);\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tp[i + 1] = p[i] * 257;\n\t\th[i + 1] = h[i] * 257 + s[i];\n\t}\n\tvector<int> sa(s.size());\n\tiota(sa.begin(), sa.end(), 0);\n\tsort(sa.begin(), sa.end(), compare_sa);\n\tvector<int> sa_inv(s.size());\n\tfor (int i = 0; i < s.size(); i++) sa_inv[sa[i]] = i;\n\tvector<int> v;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (sa[i] < l[1]) v.push_back(i);\n\t}\n\tfor (int i = 0; i < Q; i++) {\n\t\tint w = sa_inv[l[i + 1]];\n\t\tint ptr = lower_bound(v.begin(), v.end(), w) - v.begin();\n\t\tbool flag = false;\n\t\tfor (int j = -1; j <= 0; j++) {\n\t\t\tint pos = ptr + j;\n\t\t\tif (0 <= pos && pos < v.size()) {\n\t\t\t\tif (min(l[1] - sa[v[pos]], lcp(sa[v[pos]], l[i + 1])) >= l[i + 2] - l[i + 1]) flag = true;\n\t\t\t}\n\t\t}\n\t\tcout << flag << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define VARNAME(x) #x\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nconstexpr ll MOD = 1000000007LL;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n\n\n\ninline bool match(const string& s, const string& p, const vector<int>& sa)\n{\n    const int size = s.size();\n    const int psize = p.size();\n    int inf = -1;\n    int sup = size;\n    while (sup - inf > 1) {\n        const int mid = (inf + sup) / 2;\n        if (s.substr(sa[mid], psize) < p) {\n            inf = mid;\n        } else {\n            sup = mid;\n        }\n    }\n    return sup == size ? false : p == s.substr(sa[sup], psize);\n}\n\n\n\nclass SuffixArray\n{\nprivate:\n    // static constexpr int encode(const int c) { return c == '$' ? 0 : c - 'a' + 1; }\n    // static constexpr char decode(const int n) { return (n == 0 ? '$' : 'a' + n - 1); }\n    static constexpr int encode(const int c) { return c == '$' ? 0 : c <= '9' ? 1 + c - '0' : c <= 'Z' ? 11 + c - 'A' : 37 + c - 'a'; }\n    static constexpr char decode(const int n) { return n == 0 ? '$' : n <= 10 ? '0' + n - 1 : n <= 36 ? 'A' + n - 11 : 'a' * n - 37; }\n    enum class Type : char\n    {\n        L = 0,\n        S = 1,\n        LMS = 2,\n    };\n\npublic:\n    SuffixArray(const string& s, const int kind_) : N(s.size() + 1), kind{kind_ + 1}, S(s.size() + 1, 0), type(N), next(N, 1), bucket(kind), num(kind, 0), head(kind, 0), tail(kind, 0)\n    {\n        for (int i = 0; i < s.size(); i++) {\n            S[i] = encode(s[i]);\n        }\n        initializeData();\n        sortLMS();\n    }\n    SuffixArray(const vector<int>& s, const int kind_) : N(s.size() + 1), kind{kind_ + 1}, S(s), type(N), next(N, 1), bucket(kind), num(kind, 0), head(kind, 0), tail(kind, 0)\n    {\n        S.push_back(0);\n        initializeData();\n        sortLMS();\n    }\n    void debugPrint() const\n    {\n        for (int i = 0; i < N; i++) {\n            cout << decode(S[i]);\n        }\n        cout << endl;\n        for (int i = 0; i < N; i++) {\n            cout << (type[i] == Type::L ? \"L\" : \"S\");\n        }\n        cout << endl;\n        for (int i = 0; i < N; i++) {\n            cout << (type[i] == Type::LMS ? \"@\" : \" \");\n        }\n        cout << endl;\n        for (int i = 0; i < kind; i++) {\n            if (bucket[i].empty()) continue;\n            cout << \"[\" << decode(i) << \"]:\\n\";\n            for (const int p : bucket[i]) {\n                cout << \"  \" << p << endl;\n            }\n        }\n    }\n\n    vector<int> getSuffixArray() const\n    {\n        vector<int> ans(N - 1);\n        for (int pos = 0, i = 1; i < kind; i++) {  // 番兵以外\n            for (const int p : bucket[i]) {\n                ans[pos++] = p;\n            }\n        }\n        return ans;\n    }\n\nprivate:\n    void initializeData()\n    {\n        for (const int i : S) {\n            num[i]++;\n        }\n        for (int i = 0; i < kind; i++) {\n            bucket[i].resize(num[i], -1);\n            tail[i] = num[i] - 1;\n        }\n        type[N - 1] = Type::S;\n        for (int i = N - 2; i >= 0; i--) {\n            type[i] = (S[i] != S[i + 1] ? (S[i] < S[i + 1] ? Type::S : Type::L) : type[i + 1]);\n            if (type[i] == Type::L and type[i + 1] == Type::S) {\n                type[i + 1] = Type::LMS;\n                LMS.push_back(i + 1);\n            }\n        }\n        for (int pos = N - 1, i = N - 2; i >= 0; i--) {\n            next[i] = pos;\n            if (type[i] == Type::LMS) {\n                pos = i;\n            }\n        }\n    }\n\n    void sortLMS()\n    {\n        for (const int l : LMS) {\n            insertTail(l);\n        }\n        induce();\n        vector<int> lms;\n        for (int i = 0; i < kind; i++) {\n            for (const int p : bucket[i]) {\n                if (type[p] == Type::LMS) {\n                    lms.push_back(p);\n                }\n            }\n        }\n        const int size = lms.size();\n        vector<int> order(N / 2 + 1, 0);\n        int number = 1;\n        order[N / 2] = 1;\n        bool same = false;\n        for (int i = 1; i < size; i++) {\n            const int l1 = lms[i - 1];\n            const int r1 = next[l1];\n            const int l2 = lms[i];\n            const int r2 = next[l2];\n            if (r1 - l1 == r2 - l2 and vector<int>(S.begin() + l1, S.begin() + r1 + 1) == vector<int>(S.begin() + l2, S.begin() + r2 + 1)) {\n                same = true;\n            } else {\n                number++;\n            }\n            order[l2 / 2] = number;\n        }\n        if (same) {\n            vector<int> s(size);\n            for (int p = 0, i = 0; i <= N / 2; i++) {\n                if (order[i] > 0) {\n                    s[p++] = order[i];\n                }\n            }\n            const vector<int> sorted = SuffixArray{s, number}.getSuffixArray();\n            for (int i = 0; i < kind; i++) {\n                head[i] = 0;\n                tail[i] = num[i] - 1;\n            }\n            for (int i = size - 1; i >= 0; i--) {\n                insertTail(LMS[size - 1 - sorted[i]]);\n            }\n            induce();\n        } else {\n            for (int i = 0; i < kind; i++) {\n                head[i] = 0;\n                tail[i] = num[i] - 1;\n            }\n            for (int i = size - 1; i >= 0; i--) {\n                insertTail(lms[i]);\n            }\n            induce();\n        }\n    }\n\n    void induce()\n    {\n        for (int i = 0; i < kind; i++) {\n            for (int j = 0; j < head[i]; j++) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] == Type::L) {\n                    insertHead(p - 1);\n                }\n            }\n            for (int j = tail[i] + 1; j < num[i]; j++) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] == Type::L) {\n                    insertHead(p - 1);\n                }\n            }\n        }\n        for (int i = 1; i < kind; i++) {  // 番兵以外\n            tail[i] = num[i] - 1;\n        }\n        for (int i = kind - 1; i >= 0; i--) {\n            for (int j = num[i] - 1; j > tail[i]; j--) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] != Type::L) {\n                    insertTail(p - 1);\n                }\n            }\n            for (int j = head[i] - 1; j >= 0; j--) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] != Type::L) {\n                    insertTail(p - 1);\n                }\n            }\n        }\n    }\n    void insertHead(const int i) { bucket[S[i]][head[S[i]]++] = i; }\n    void insertTail(const int i) { bucket[S[i]][tail[S[i]]--] = i; }\n\n    const int N;\n    const int kind;\n    vector<int> S;               // O(N)\n    vector<Type> type;           // O(N)\n    vector<int> next;            // O(N)\n    vector<vector<int>> bucket;  // O(N)\n    vector<int> num;             // O(K)\n    vector<int> head;            // O(K)\n    vector<int> tail;            // O(K)\n    vector<int> LMS;             // O(N)\n};\n\n\n\n// Problem: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n// Status: Accepted\n\nint main()\n{\n    string S;\n    cin >> S;\n    const auto sa = SuffixArray{S, 62}.getSuffixArray();\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; q++) {\n        string P;\n        cin >> P;\n        cout << (match(S, P, sa) ? 1 : 0) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <string>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nunsigned char mask[] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };\n#define tget(i) ( (t[(i)/8]&mask[(i)%8]) ? 1 : 0 )\n#define tset(i, b) t[(i)/8]=(b) ? (mask[(i)%8]|t[(i)/8]) : ((~mask[(i)%8])&t[(i)/8])\n#define chr(i) (cs==sizeof(int)?((int*)s)[i]:((unsigned char *)s)[i])\n#define isLMS(i) (i>0 && tget(i) && !tget(i-1))\n\n// find the start or end of each bucket\nvoid getBuckets(unsigned char *s, int *bkt, int n, int K, int cs, bool end) {\n    int i, sum = 0;\n    for (i = 0; i <= K; i++)\n        bkt[i] = 0; // clear all buckets\n    for (i = 0; i < n; i++)\n        bkt[chr(i)]++; // compute the size of each bucket\n    for (i = 0; i <= K; i++) {\n        sum += bkt[i];\n        bkt[i] = end ? sum : sum - bkt[i];\n    }\n}\n// compute SAl\nvoid induceSAl(unsigned char *t, int *SA, unsigned char *s, int *bkt, int n, int K, int cs, bool end) {\n    int i, j;\n    getBuckets(s, bkt, n, K, cs, end); // find starts of buckets\n    for (i = 0; i < n; i++) {\n        j = SA[i] - 1;\n        if (j >= 0 && !tget(j))\n            SA[bkt[chr(j)]++] = j;\n    }\n}\n// compute SAs\nvoid induceSAs(unsigned char *t, int *SA, unsigned char *s, int *bkt, int n, int K, int cs, bool end) {\n    int i, j;\n    getBuckets(s, bkt, n, K, cs, end); // find ends of buckets\n    for (i = n - 1; i >= 0; i--) {\n        j = SA[i] - 1;\n        if (j >= 0 && tget(j))\n            SA[--bkt[chr(j)]] = j;\n    }\n}\n\n// find the suffix array SA of s[0..n-1] in {1..K}^n\n// require s[n-1]=0 (the sentinel!), n>=2\n// use a working space (excluding s and SA) of at most 2.25n+O(1) for a constant alphabet\nvoid SA_IS(unsigned char *s, int *SA, int n, int K, int cs) {\n    int i, j;\n    unsigned char *t = (unsigned char *) malloc(n / 8 + 1); // LS-type array in bits\n    // Classify the type of each character\n    tset(n-2, 0);\n    tset(n-1, 1); // the sentinel must be in s1, important!!!\n    for (i = n - 3; i >= 0; i--)\n        tset(i, (chr(i)<chr(i+1) || (chr(i)==chr(i+1) && tget(i+1)==1))?1:0);\n    // stage 1: reduce the problem by at least 1/2\n    // sort all the S-substrings\n    int *bkt = (int *) malloc(sizeof(int) * (K + 1)); // bucket array\n    getBuckets(s, bkt, n, K, cs, true); // find ends of buckets\n    for (i = 0; i < n; i++)\n        SA[i] = -1;\n    for (i = 1; i < n; i++)\n        if (isLMS(i))\n            SA[--bkt[chr(i)]] = i;\n    induceSAl(t, SA, s, bkt, n, K, cs, false);\n    induceSAs(t, SA, s, bkt, n, K, cs, true);\n    free(bkt);\n    // compact all the sorted substrings into the first n1 items of SA\n    // 2*n1 must be not larger than n (proveable)\n    int n1 = 0;\n    for (i = 0; i < n; i++)\n        if (isLMS(SA[i]))\n            SA[n1++] = SA[i];\n    // find the lexicographic names of all substrings\n    for (i = n1; i < n; i++)\n        SA[i] = -1; // init the name array buffer\n    int name = 0, prev = -1;\n    for (i = 0; i < n1; i++) {\n        int pos = SA[i];\n        bool diff = false;\n        for (int d = 0; d < n; d++)\n            if (prev == -1 || chr(pos+d) != chr(prev+d) || tget(pos+d) != tget(prev+d)) {\n                diff = true;\n                break;\n            } else if (d > 0 && (isLMS(pos+d) || isLMS(prev+d)))\n                break;\n        if (diff) {\n            name++;\n            prev = pos;\n        }\n        pos = (pos % 2 == 0) ? pos / 2 : (pos - 1) / 2;\n        SA[n1 + pos] = name - 1;\n    }\n    for (i = n - 1, j = n - 1; i >= n1; i--)\n        if (SA[i] >= 0)\n            SA[j--] = SA[i];\n    // stage 2: solve the reduced problem\n    // recurse if names are not yet unique\n    int *SA1 = SA, *s1 = SA + n - n1;\n    if (name < n1)\n        SA_IS((unsigned char*) s1, SA1, n1, name - 1, sizeof(int));\n    else\n        // generate the suffix array of s1 directly\n        for (i = 0; i < n1; i++)\n            SA1[s1[i]] = i;\n    // stage 3: induce the result for the original problem\n    bkt = (int *) malloc(sizeof(int) * (K + 1)); // bucket array\n    // put all left-most S characters into their buckets\n    getBuckets(s, bkt, n, K, cs, true); // find ends of buckets\n    for (i = 1, j = 0; i < n; i++)\n        if (isLMS(i))\n            s1[j++] = i; // get p1\n    for (i = 0; i < n1; i++)\n        SA1[i] = s1[SA1[i]]; // get index in s\n    for (i = n1; i < n; i++)\n        SA[i] = -1; // init SA[n1..n-1]\n    for (i = n1 - 1; i >= 0; i--) {\n        j = SA[i];\n        SA[i] = -1;\n        SA[--bkt[chr(j)]] = j;\n    }\n    induceSAl(t, SA, s, bkt, n, K, cs, false);\n    induceSAs(t, SA, s, bkt, n, K, cs, true);\n    free(bkt);\n    free(t);\n}\n\nconst int maxn = 1000010;\nint sa[maxn];\nint lcp[maxn];\nint pos[maxn];\nunsigned char *s;\nint n;\n\nvoid calc_lcp() {\n    for (int i = 0; i < n+1; i++)\n        pos[sa[i]] = i;\n    for (int i = 0, h = 0; i < n+1; i++) {\n        if (pos[i] < n ) {\n            for (int j = sa[pos[i] + 1]; s[i + h] == s[j + h]; ++h)\n                ;\n            lcp[pos[i]] = h;\n            if (h > 0)\n                --h;\n        }\n    }\n}\n/*\n str=\"abcab\" n=5\n SA_IS(str,sa,n+1,256,1)\n calc_lcp()\n sa={5,3,0,4,1,2}\n str.subtring(sa)={\"\",\"ab\",\"abcab\",\"b\",\"bcab\",\"cab\"}\n lcp={0,2,0,1,0,0}\n pos={2,4,5,1,3,0}\n*/\n\npair<int,int> longest_repeated_substring(int overlap){\n    //overlap=1 non-overlapping , overlap=0 overlap allowed\n    int maxl=0,maxidx=-1;\n    for(int i=1;i<n+1;i++){\n        if(lcp[i]>maxl) {\n            if(overlap && abs(sa[i]-sa[i-1])<lcp[i]) continue;\n            maxl=lcp[i];\n            maxidx=sa[i];\n        }\n    }\n    if(maxidx==-1) return make_pair(-1,-1);\n    return make_pair(maxidx,maxl);\n}\npair<pair<int,int>,int> longest_k_repeated_substring(string str,int k){\n    k--;\n    for (int i = 0; i < n+1; i++)\n        pos[sa[i]] = i;\n    int maxl=0,maxidx=-1,rightmostidx=0;\n    for (int i = 0, h = 0; i < n+1; i++) {\n        if (pos[i] < n +1-k) {\n            for (int j = sa[pos[i] + k]; s[i + h] == s[j + h]; ++h)\n                ;\n            if(h>=maxl){\n                if(h>maxl) rightmostidx=sa[pos[i] + k];\n                maxl=h;\n                maxidx=i;\n                if(rightmostidx<sa[pos[i] + k]) rightmostidx=sa[pos[i] + k];\n            }\n            //cout<<i<<\" \"<<h<<\" \"<<str.substr(i,h)<<maxl<<\" \"<<str.substr(maxidx,maxl)<<\" \"<<rightmostidx<<endl;\n\n            if (h > 0)\n                --h;\n        }\n    }\n    if(maxidx==-1) return make_pair(make_pair(-1,-1),-1);\n    return make_pair(make_pair(rightmostidx,maxidx),maxl);\n}\npair<pair<int,int>,pair<int,int> > longest_common_substring(string str1,string str2){\n    string str=str1+\" \"+str2;\n    s = (unsigned char*) str.c_str();\n    n = (int)str.size();\n    SA_IS(s, sa, n + 1, 256, 1);\n    calc_lcp();\n    pair<int,int> p=longest_repeated_substring(0);\n    int indx2=sa[pos[p.first]+1];\n    //cout<<str.substr(p.first,p.second)<<\" \"<<str.substr(indx2,p.second)<<endl;\n    if((p.first<str1.length()&&indx2<str1.length())||(p.first>str1.length()&&indx2>str1.length()) || str.substr(p.first,p.second)!=str.substr(indx2,p.second)) {\n                return make_pair(make_pair(0,0),p);\n    }\n    return make_pair(p,make_pair(indx2,p.second));\n}\n\npair<int,int> smallest_lex_rotation(string str){\n    \n    str=str+str;\n    s = (unsigned char*) str.c_str();\n    \n    n = (int)str.size();\n    SA_IS(s, sa, n + 1, 256, 1);\n    for(int i=1;i<n+1;i++){\n        //cout<<str.substr(sa[i])<<\" \"<<sa[i]<<\"\\n\";\n    }\n    \n    int minval=maxn;\n    for(int i=0;i<n+1;i++){\n        if(sa[i]<=n/2){\n            while(i<n && sa[i]<=n/2 && str.substr(sa[i],n/2)==str.substr(sa[i+1],n/2)){\n                if(minval>sa[i]) minval=sa[i];\n                //printf(\"i %d\\n\",i);\n                i++;\n            }\n            return make_pair(sa[i],n/2);\n        }\n    }\n    \n    return make_pair(-1,n/2);\n}\n\nlong count_distinct_substrings(string str){\n    s = (unsigned char*) str.c_str();\n    n = (int)str.size();\n    SA_IS(s, sa, n + 1, 256, 1);\n    calc_lcp();\n    long count=0;\n    for(int i=1;i<n+1;i++) count+=n-sa[i]-lcp[i];\n    return count;\n}\n\npair<int,int> longest_palindromic_substring(string str){\n    string revstr=string(str.rbegin(),str.rend());\n    return longest_common_substring(str, revstr).first;\n}\n\nbool contain(string str, int *sa, string T){\n    int a = 0, b = str.length();\n    while( b - a > 1 ){\n        int c = (a + b ) / 2;\n        if ( str.compare(sa[c], T.length(), T) < 0 ) a = c;\n        else b = c;\n    }\n    return str.compare(sa[b], T.length(), T) == 0;\n}\n\n\nint main() {\n    //string str = \"abac\";\n        std::ios::sync_with_stdio(false);\n    freopen(\"/Users/vigneshm/Documents/codespace/code/input.txt\",\"r\",stdin);\n    freopen(\"/Users/vigneshm/Documents/codespace/code/output.txt\",\"w\",stdout);\n    string str;\n    int k,t;\n    cin>>t;\n    while(t-->0){\n        cin>>str>>k;\n        s = (unsigned char*) str.c_str();\n        n = (int)str.size();\n        SA_IS(s, sa, n + 1, 256, 1);\n        pair<pair<int,int>,int> p=longest_k_repeated_substring(str, k);\n        if(p.second==0) cout<<\"HATE\\n\";\n        else cout<<p.second<<\" \"<<p.first.first+p.first.second+1<<\"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint Q, doubles, lengths, dat[1000009], tmp[1000009], arrays[1000009]; string S, T;\ninline bool compare_suffix(int i, int j) {\n\tif (dat[i] == dat[j]) {\n\t\tint ri = (i + doubles <= lengths ? dat[i + doubles] : -1);\n\t\tint rj = (j + doubles <= lengths ? dat[j + doubles] : -1);\n\t\treturn ri < rj;\n\t}\n\treturn dat[i] < dat[j];\n}\nvoid suffix_array() {\n\tlengths = S.size();\n\tfor (int i = 0; i <= lengths; i++) arrays[i] = i, dat[i] = i < lengths ? S[i] : -1;\n\tfor (doubles = 1; doubles <= lengths; doubles <<= 1) {\n\t\tsort(arrays, arrays + lengths + 1, compare_suffix);\n\t\ttmp[arrays[0]] = 0;\n\t\tfor (int i = 1; i <= lengths; i++) tmp[arrays[i]] = tmp[arrays[i - 1]] + (compare_suffix(arrays[i - 1], arrays[i]) ? 1 : 0);\n\t\tfor (int i = 0; i <= lengths; i++) dat[i] = tmp[i];\n\t}\n}\nint main() {\n\tcin >> S >> Q;\n\tsuffix_array();\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> T;\n\t\tint l = 0, r = S.size() + 1, f = 0;\n\t\twhile (r - l > 1) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tstring S1 = S.substr(arrays[m], T.size());\n\t\t\tif (S1 == T) { f = 1; break; }\n\t\t\tif (S1 < T) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tprintf(\"%d\\n\", f);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nstring S; int Q; char STR[1005];\n\nint main()\n{\n\tcin >> S >> Q; cout << string::npos << endl;\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%s\", STR);\n\n\t\tprintf(\"%d\\n\", S.find(STR) != string::npos ? 1 : 0);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> Q;\n\nint n;\nstring s;\nint a[1000000];\nint b[1000000];\n\nint main(){\n\tcin >> s;\n\tn = s.size();\n\t\n\tvector<P> v;\n\trep(i, n){\n\t\tv.push_back(P(s[i], i));\n\t}\n\tsort(v.begin(), v.end());\n\ta[v[0].second] = 0;\n\trep(i, n - 1){\n\t\ta[v[i + 1].second] = a[v[i].second] + (v[i].first != v[i + 1].first);\n\t}\n\n\trep(i, 20){\n\t\tvector<Q> v;\n\t\trep(j, n){\n\t\t\tif(j + (1 << i) < n){\n\t\t\t\tv.push_back(Q(P(a[j], a[j + (1 << i)]), j));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tv.push_back(Q(P(a[j], -1), j));\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\ta[v[0].second] = 0;\n\t\trep(j, n - 1){\n\t\t\ta[v[j + 1].second] = a[v[j].second] + (v[j].first != v[j + 1].first);\n\t\t}\n\t}\n\n\trep(i, n){\n\t\tb[a[i]] = i;\n\t}\n\t\n\tint q;\n\tcin >> q;\n\trep(i, q){\n\t\tstring t;\n\t\tcin >> t;\n\t\tint l = 0, r = n;\n\t\twhile(r - l > 1){\n\t\t\tint m = (l + r) / 2;\n\t\t\tif(string(s, b[m], min((int)t.size(), n - b[m])) <= t){\n\t\t\t\tl = m;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr = m;\n\t\t\t}\n\t\t}\n\t\tcout << int(string(s, b[l], min((int)t.size(), n - b[l])) == t) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nclass SuffixArray{\n    void CreateBeginBucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        int sum=0;\n        for(int i=0;i<bucket.size();i++){bucket[i]+=sum;swap(sum,bucket[i]);}\n    }\n\n    void CreateEndBucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        for(int i=1;i<bucket.size();i++)bucket[i]+=bucket[i-1];\n    }\n\n    void InducedSort(vector<int>&v,vector<int>&SA,int mv,vector<int>&bucket,vector<int>&isL){\n        CreateBeginBucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(SA[i]>0&&isL[SA[i]-1])SA[bucket[v[SA[i]-1]]++]=SA[i]-1;\n    }\n\n    void InvertInducedSort(vector<int>&v,vector<int>&SA,int mv,vector<int>&bucket,vector<int>&isL){\n        CreateEndBucket(v,bucket);\n        for(int i=v.size()-1;i>=0;i--)if(SA[i]>0&&!isL[SA[i]-1])SA[--bucket[v[SA[i]-1]]]=SA[i]-1;\n    }\n\n    vector<int>SA_IS(vector<int>v,int mv){\n        if(v.size()==1)return vector<int>(1,0);\n\n        vector<int>isL(v.size());\n        vector<int>bucket(mv+1);\n        vector<int>SA(v.size(),-1);\n        auto isLMS=[&](int x)->bool{return x>0&&isL[x-1]&&!isL[x];};\n\n        isL[v.size()-1]=0;\n        for(int i=v.size()-2;i>=0;i--)isL[i]=v[i]>v[i+1]||(v[i]==v[i+1]&&isL[i+1]);\n        CreateEndBucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(isLMS(i))SA[--bucket[v[i]]]=i;\n        InducedSort(v,SA,mv,bucket,isL);\n        InvertInducedSort(v,SA,mv,bucket,isL);\n\n        int cur=0;\n        vector<int>ord(v.size());\n        for(int i=0;i<v.size();i++)if(isLMS(i))ord[i]=cur++;\n\n        vector<int>nxv(cur);\n        cur=-1;\n        int prev=-1;\n        for(int i=0;i<v.size();i++){\n            if(!isLMS(SA[i]))continue;\n            bool diff=false;\n            for(int d=0;d<v.size();d++){\n                if(prev==-1||v[SA[i]+d]!=v[prev+d]||isL[SA[i]+d]!=isL[prev+d]){\n                    diff=true;\n                    break;\n                }\n                else if(d>0&&isLMS(SA[i]+d))break;\n            }\n            if(diff){cur++;prev=SA[i];}\n            nxv[ord[SA[i]]]=cur;\n        }\n\n        vector<int>reord(nxv.size());\n        for(int i=0;i<v.size();i++)if(isLMS(i))reord[ord[i]]=i;\n        vector<int>nxSA=SA_IS(nxv,cur);\n        CreateEndBucket(v,bucket);\n        for(int i=0;i<SA.size();i++)SA[i]=-1;\n        for(int i=nxSA.size()-1;i>=0;i--)SA[--bucket[v[reord[nxSA[i]]]]]=reord[nxSA[i]];\n        InducedSort(v,SA,mv,bucket,isL);\n        InvertInducedSort(v,SA,mv,bucket,isL);\n        return SA;\n    }\n\n    vector<int>SA_IS(string s){\n        vector<int>v(s.size()+1);\n        for(int i=0;i<s.size();i++)v[i]=s[i]+1;\n        return SA_IS(v,*max_element(v.begin(),v.end()));\n    }\n\n    vector<int>construct_lcp(string &s,vector<int>&sa){\n        vector<int>lcp,rank(s.size()+1);\n        int n=s.size();\n        for(int i=0;i<=n;i++)rank[sa[i]]=i;\n\n        int h=0;\n        lcp[0]=0;\n        for(int i=0;i<n;i++){\n            int j=sa[rank[i]-1];\n\n            if(h>0)h--;\n            for(;j+h<n&&i+h<n;h++){\n                if(s[j+h]!=s[i+h])break;\n            }\n            lcp[rank[i]-1]=h;\n        }\n        return lcp;\n    }\n\n    class SparseTable{\n        vector<vector<int> >st;\n    public:\n        void init(vector<int>vec){\n            int b;\n            for(b=0;(1<<b)<vec.size();b++);\n            st.assign(b,vector<int>(1<<b));\n            for(int i=0;i<vec.size();i++)st[0][i]=vec[i];\n\n            for(int i=1;i<b;i++){\n                for(int j=0;j+(1<<i)<=(1<<b);j++){\n                    st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);\n                }\n            }\n        }\n        int GetMin(int l,int r){\n            assert(l<r);\n            int b=32-__builtin_clz(r-l)-1;\n            return min(st[b][l],st[b][r-(1<<b)]);\n        }\n        SparseTable(){}\n        SparseTable(vector<int>vec){init(vec);}\n    };\n    SparseTable st;\npublic:\n    string s;\n    vector<int>sa,lcp;\n    void init(string &T){\n        s=T;\n        sa=SA_IS(s);\n        //lcp=construct_lcp(s,sa);cout<<\"malta\"<<endl;\n        //st.init(lcp);cout<<\"ok\"<<endl;\n    }\n    SuffixArray(string &t){init(t);}\n    SuffixArray(){}\n\n    bool contain(string &t){\n        int a=0,b=s.size();\n        while(b-a>1){\n            int c=(a+b)/2;\n            if(s.compare(sa[c],t.size(),t)<0)a=c;\n            else b=c;\n        }\n        return s.compare(sa[b],t.size(),t)==0;\n    }\n};\n\nsigned main(){\n    string S,T;\n    int Q;\n    cin>>S>>Q;\n    SuffixArray SA(S);\n\n    while(Q--){\n        cin>>T;\n        cout<<SA.contain(T)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct node {\n\tnode *fail;\n\tunordered_map<char, node*> next;\n\tvector<int> ok;\n\tnode() : fail(nullptr) {}\n};\n\nnode* getnext(node* p, char c) {\n\twhile (p->next.count(c) == 0) p = p->fail;\n\treturn p->next[c];\n}\n\nclass aho_corasick {\n\tvector<int> unite(const vector<int>& a, const vector<int>& b) {\n\t\tvector<int> res;\n\t\tset_union(a.begin(), a.end(), b.begin(), b.end(), back_inserter(res));\n\t\treturn res;\n\t}\n\tint K;\n\tnode *root;\npublic:\n\taho_corasick(const vector<string>& Ts) : K(Ts.size()), root(new node) {\n\t\tnode *now;\n\t\troot->fail = root;\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tauto &T = Ts[i];\n\t\t\tnow = root;\n\t\t\tfor (auto c : T) {\n\t\t\t\tif (now->next[c] == nullptr) {\n\t\t\t\t\tnow->next[c] = new node;\n\t\t\t\t}\n\t\t\t\tnow = now->next[c];\n\t\t\t}\n\t\t\tnow->ok.push_back(i);\n\t\t}\n\t\tqueue<node*> q;\n\t\tfor (auto p : root->next) {\n\t\t\tif (p.second) {\n\t\t\t\tp.second->fail = root;\n\t\t\t\tq.push(p.second);\n\t\t\t}\n\t\t}\n\t\twhile (!q.empty()) {\n\t\t\tnow = q.front(); q.pop();\n\t\t\tfor (auto p : now->next) {\n\t\t\t\tif (p.second) {\n\t\t\t\t\tnode *nx = now->fail;\n\t\t\t\t\twhile (nx != root && !nx->next.count(p.first)) {\n\t\t\t\t\t\tnx = nx->fail;\n\t\t\t\t\t}\n\t\t\t\t\tif (!nx->next.count(p.first)) nx->next[p.first] = root;\n\t\t\t\t\tp.second->fail = nx->next[p.first];\n\t\t\t\t\tp.second->ok = unite(p.second->ok, nx->next[p.first]->ok);\n\t\t\t\t\tq.push(p.second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tnode* getroot() const {\n\t\treturn root;\n\t}\n\tvector<int> count(const string& S) const {\n\t\tvector<int> res(K);\n\t\tnode *now = root;\n\t\tfor (auto c : S) {\n\t\t\tnow = getnext(now, c);\n\t\t\tfor (auto k : now->ok) res[k] = 1;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tstring T;\n\tcin >> T;\n\tint Q;\n\tcin >> Q;\n\tvector<string> P(Q);\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> P[i];\n\t}\n\taho_corasick ac(P);\n\tauto res = ac.count(T);\n\tfor (auto b : res) {\n\t\tprintf(\"%d\\n\", b);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct SuffixArray{\n\tstring s;\n\tvector<int> sa;\n\n\tint operator[](int i) const{ return sa[i]; }\n\n\tSuffixArray(const string &t) : s(t),sa(s.size() + 1){\n\t\ts += '$';\n\t\tint n = s.size();\n\t\tiota(sa.begin(),sa.end(),0);\n\t\tsort(sa.begin(),sa.end(),[&](int a,int b){ return s[a] < s[b]; });\n\t\tvector<int> rnk(s.begin(),s.end()),cnt(n),nxt(n);\n\t\tfor(int k = 1;k < n;k <<= 1){\n\t\t\tnxt[sa[0]] = 0;\n\t\t\tfor(int i = 1;i < n;i++){\n\t\t\t\tnxt[sa[i]] = (rnk[sa[i - 1]] == rnk[sa[i]]\n\t\t\t\t&& rnk[(sa[i - 1] + k / 2) % n] == rnk[(sa[i] + k / 2) % n])\n\t\t\t\t? nxt[sa[i - 1]] : i;\n\t\t\t}\n\t\t\trnk.swap(nxt);\n\n\t\t\tiota(cnt.begin(),cnt.end(),0);\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tint s1 = (sa[i] - k + n) % n;\n\t\t\t\tnxt[cnt[rnk[s1]]++] = s1;\n\t\t\t}\n\t\t\tsa.swap(nxt);\n\t\t}\n\t}\n\n\tinline int lower_bound(const string &t) const{\n\t\treturn partition_point(sa.begin(),sa.end(),[&](int x){\n\t\t\treturn s.compare(x,t.length(),t) < 0;\n\t\t}) - sa.begin();\n\t}\n\n\tint upper_bound(string &t) const{\n\t\tt.back()++;\n\t\tint ret = lower_bound(t);\n\t\tt.back()--;\n\t\treturn ret;\n\t}\n\n\tinline int count(string &t) const{\n\t\treturn upper_bound(t) - lower_bound(t);\n\t}\n};\n\nsigned main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tstring t;\n\tint q;\n\tcin >> t >> q;\n\tSuffixArray sa(t);\n\tfor(int i = 0;i < q;i++){\n\t\tstring p;\n\t\tcin >> p;\n\t\tcout << !!sa.count(p) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<vector>\nusing namespace std;\n#define INT(x) int x; scanf(\"%d\",&x)\n#define INPUT(x) scanf(\"%d\",&x)\n#define REP1(x,n) for(int x = 0; x < n; x++)\n#define REP2(x,s,e) for(int x = s; x <= e; x++)\n#define BR printf(\"\\n\")\n#define INF 2000000000\n#define Mod 1000000007\n\ntypedef long long ll;\n\nchar S[1000001];\n\nint pow_mod_c(ll c,ll p,ll q,ll m){\n    ll x = 1;\n    while (q > 0) {\n        if(q&1){\n            x = (x*p)%m;\n        }\n        p = (p*p)%m;\n        q >>= 1;\n    }\n    return (x*c)%m;\n}\n\nll initRH(char S[],ll n){\n    ll digit = 1;\n    ll x = 0;\n    REP1(i,n){\n        x = (x+(digit*S[n-1-i])%Mod)%Mod;\n        digit = (digit*128)%Mod;\n    }\n    return x;\n}\n\nstruct val_i {\n    ll val,i,n;\n};\n\nval_i shift(val_i k){\n    k.val = (Mod + k.val - pow_mod_c(S[k.i],128,k.n-1,Mod))%Mod;\n    k.val = (k.val*128)%Mod;\n    k.val = (k.val + S[k.i + k.n])%Mod;\n    k.i = k.i + 1;\n    return k;\n}\n\nbool rec(char s[]){\n    int N = strlen(S);\n    int n = strlen(s);\n    \n    ll ss = initRH(s,n);\n    val_i K;\n    K.val = initRH(S,n);\n    K.i = 0;\n    K.n = n;\n    \n    if (K.val == ss) return 1;\n    \n    REP1(i,N-n){\n        K = shift(K);\n        if(K.val == ss) return 1;\n    }\n    \n    return 0;\n}\n\nint main(){\n    cin >> S;\n    INT(Q);\n    REP1(i,Q){\n        char ss[1001];\n        scanf(\"%s\",ss);\n        printf(\"%d\\n\",rec(ss));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\n#define NUM 48\nusing namespace std;\n\nint T_char_count[128] = {0},P_char_count[128],T_max_succeed[128],P_max_succeed[128];\n\nclass LocRecord{\n\npublic:\n\t//?????¢???????¢????\n\tLocRecord(){\n\t\tlocationTable = new int*[128];\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t}\n\n\t//-1?????£??\\\n\tvoid init(){\n\t\tint limit;\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init_index(){\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t}\n\n\tvoid regist_loc(int ch, int location){\n\t\tlocationTable[ch][index[ch]] = location;\n\t\tindex[ch]++;\n\t}\n\n\tint next_loc(int ch){\n\t\tint ret = locationTable[ch][index[ch]];\n\t\tindex[ch]++;\n\t\treturn ret;\n\t}\n\nprivate:\n\tint** locationTable;\n\tint index[128];\n};\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\t\t\treturn length < arg.length;\n\t};\n\tInfo(int arg_length,int arg_id,ull arg_hashValue){\n\t\tlength = arg_length;\n\t\tid = arg_id;\n\t\thashValue = arg_hashValue;\n\t}\n\n\tint length,id;\n\tull hashValue;\n};\n\nint main(){\n\n\tfor(int i = 0; i < 128; i++){\n\t\tT_char_count[i] = 0;\n\t\tT_max_succeed[i] = 0;\n\t}\n\n\tint T_length;\n\n\tchar* T = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tchar pre = ':';\n\tint count = 1;\n\n\tfor(T_length = 0; T[T_length] != '\\0';T_length++){\n\t\tT_char_count[T[T_length]]++;\n\t\tif(pre == T[T_length]){\n\t\t\tcount++;\n\t\t\tif(T[T_length+1] == '\\0'){\n\t\t\t\tT_max_succeed[pre] = max(T_max_succeed[pre],count);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tT_max_succeed[pre] = max(T_max_succeed[pre],count);\n\t\t\tcount = 1;\n\t\t}\n\t\tpre = T[T_length];\n\t}\n\n\tLocRecord locRecord;\n\tlocRecord.init();\n\n\t//T[i]????????????i??§???????????¨????¨????\n\tfor(int i = 0; i < T_length; i++){\n\t\tlocRecord.regist_loc(T[i],i);\n\t}\n\n\tull* HASH = new ull[T_length+1];\n\tull* P = new ull[T_length+1];\n\n\tHASH[0] = 0;\n\tP[0] = 1;\n\n\t//T??????????????\\???????±???????\n\tfor(int i = 1; i <= T_length; i++){\n\t\tHASH[i] = T[i-1] + HASH[i-1]*MOD;\n\t\tP[i] = P[i-1]*MOD;\n\t}\n\n\n\tvector<Info> V[128];\n\n\tint Q,S_length,left,P_char_count[128];\n\tscanf(\"%d\",&Q);\n\n\tbool check[Q];\n\n\tfor(int i = 0; i < Q; i++)check[i] = false;\n\n\tchar S[1001];\n\tull S_HASH[1001],S_value,T_value,D;\n\tbool FLG;\n\n\t//Q??¶??????????????\\???????¨????\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",S);\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tP_char_count[i] = 0;\n\t\t\tP_max_succeed[i] = 0;\n\t\t}\n\n\t\tpre = ':';\n\t\tcount = 1;\n\t\tfor(S_length = 0;S[S_length] != '\\0';S_length++){\n\t\t\tP_char_count[S[S_length]]++;\n\t\t\tif(pre == S[S_length]){\n\t\t\t\tcount++;\n\t\t\t\tif(S[S_length+1] == '\\0'){\n\t\t\t\t\tP_max_succeed[pre] = max(P_max_succeed[pre],count);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tP_max_succeed[pre] = max(P_max_succeed[pre],count);\n\t\t\t\tcount = 1;\n\t\t\t}\n\n\t\t\tpre = S[S_length];\n\t\t}\n\n\t\tFLG = true;\n\n\t\tcount = 0;\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tif(P_char_count[i] > 0)count++;\n\t\t\tif(T_char_count[i] < P_char_count[i] || T_max_succeed[i] < P_max_succeed[i]){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG)continue;\n\n\t\tif(S_length == 1){\n\t\t\tcheck[loop] = true;\n\t\t\tcontinue;\n\t\t}\n\t\tif(count == 1){\n\t\t\tcheck[loop] = true;\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tS_HASH[0] = 0;\n\t\tfor(int i = 1; i <= S_length; i++){\n\t\t\tS_HASH[i] = S[i-1] + S_HASH[i-1]*MOD;\n\t\t}\n\n\t\tS_value = S_HASH[S_length];\n\n\t\tV[S[0]].push_back(Info(S_length,loop,S_value));\n\t}\n\n\tint calc_length;\n\n\tfor(int word = 48; word <= 122; word++){\n\t\tfor(int i = 0; i < V[word].size();i++){\n\n\t\t\tlocRecord.init_index();\n\n\t\t\tcalc_length = V[word][i].length;\n\t\t\tS_value = V[word][i].hashValue;\n\n\t\t\tD = P[calc_length];\n\n\t\t\twhile((left = locRecord.next_loc(word)) != -1){\n\t\t\t\tif(left+calc_length-1 >= T_length)break;\n\n\t\t\t\tT_value = HASH[left+calc_length]-HASH[left]*D;\n\n\t\t\t\tif(T_value == S_value){\n\t\t\t\t\tcheck[V[word][i].id] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tif(check[i])printf(\"1\\n\");\n\t\telse{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef debug\n#include <chrono>\n#endif\n\n#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstring> //memcpy\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <map>\n//#include <unordered_map> //hash func.\n#include <fstream> //ifstream, ofstream\n\n//#define NDEBUG //If NDEBUG is defined before #include <cassert>, assert will be ignored. You had better define NDEBUG when u submit the code.\n#include <cassert> //assert\n\nusing namespace std;\n\n\n#define dout cout\n//If u wanna output to a text file instead of standard output, plz define OUTPUTFILE.\n//#define OUTPUTFILE \"output.txt\" //*******************************************************************************************************************************************\n#ifdef OUTPUTFILE\n#define dout outputfile\nofstream outputfile(OUTPUTFILE);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n\n#define din cin\n//If u wanna input from a text file instead of standard input, plz define INPUTFROMTEXTFILE???.\n//#define INPUTFILE \"input.txt\" //*******************************************************************************************************************************************\n#ifdef INPUTFILE\n#define din inputfile\nifstream inputfile(INPUTFILE);\n#endif\n\n#define scan(A) scanf(\"%d\", &(A))\n#define disp(A) dout << #A << \" = \" << setw(3) << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \"\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n//#define dispAll(A,n) cout << #A << \" = \"; rep(j, 0, (n)) {cout << setw(3) << A[j] << \" \";} cout << endl\n\n#define sign(x) ((x)>0)-((x)<0) //x<0: -1, x=0: 0, x>0: +1\n#define p(i) (i)/2\n#define l(i) (i)*2\n#define r(i) (i)*2+1\n\nint dx[] = {1,-1, 0, 0, 1, 1,-1,-1}; //???????????????????????????????¨??????????????????????????????????\nint dy[] = {0, 0,-1, 1,-1, 1, 1,-1};\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef unsigned long ull;\n\nconst int INF = (int)2e9+10;\nconst ll INF_LL = (ll)9e18-1LL; //Be careful for overflow.\nconst ull INF_ULL = (ull)1e19-1ULL;\nconst int NONE = -1;\nconst ll MOD = (ll)1e9+7; //??§???????´???°?????£??¨??¨????????°????????????10???7??????\n\nconst int N_MAX = 1000; //num of vertex or element\nconst int M_MAX = 100000; //num of edge\nconst int DATA_MAX = 1000000010;\n\nint N;\n\nchar T[N_MAX];\n\nconst int P_LEN_MAX = 1010;\nchar P[10010][P_LEN_MAX];\n\nint hashTable_T[P_LEN_MAX][N_MAX]; //????????????lenP????????????T??????????????\\???\n\n\nint main() {\n    \n    //cin, cout????????????  ?????¨??????cin?????????????????¨??¨cin??§???scanf?????????????????¨??¨scanf??§??±?????????????????????\n    cin.tie(0); //cin??¨cout??????????????????\n    ios::sync_with_stdio(false); //iostream??¨stdio??????????????????\n    \n    //read input data\n    int i = 0;\n    while(1) {\n        scanf(\"%c\", &T[i]);\n        if(T[i]=='\\n') { T[i] = '\\0'; break; }\n        else i++;\n    }\n    \n    int Q;\n    scanf(\"%d \", &Q);\n    rep(i,0,Q) {\n        int j = 0;\n        while(1) {\n            scanf(\"%c\", &P[i][j]);\n            if(P[i][j]=='\\n') { P[i][j] = '\\0'; break; }\n            else j++;\n        }\n    }\n    \n#ifdef debug\n    disp(T);\n    disp(strlen(T));\n    rep(i,0,Q) { disp(P[i]); disp(strlen(P[i])); }\n#endif\n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //start timer\n    auto startTime = chrono::system_clock::now();\n#endif\n    //------------------------------------------------------------------------------------------\n    \n    \n    \n    //find P[i] among T by Rabin-Karp Algorithm (using Rolling Hash)\n    \n    int lenT = strlen(T);\n    const int B = 10007;\n    \n    //calc. hashTable_T[][]\n    rep(lenP,1,P_LEN_MAX+1) {\n        \n        int BpowLenP = 1;\n        rep(k,0,lenP) BpowLenP *= B;\n        \n        hashTable_T[lenP][0] = 0;\n        rep(k,0,lenP) hashTable_T[lenP][0] = hashTable_T[lenP][0] * B + T[k];\n        \n        rep(j,1,lenT-lenP+1) {\n            hashTable_T[lenP][j] = hashTable_T[lenP][j-1] * B - T[j-1] * BpowLenP + T[j-1+lenP];\n        }\n    }\n    \n    \n    rep(i,0,Q) {\n        int lenP = strlen(P[i]);\n        \n        int hashP = 0;\n        rep(k,0,lenP) hashP = hashP * B + P[i][k];\n        \n        \n        bool found = false;\n        rep(j,0,lenT-lenP+1) {\n            if(hashP == hashTable_T[lenP][j]) {\n                found = true;\n                break;\n            }\n        }\n        \n        printf(\"%d\\n\", found);\n        \n    }\n\n    \n    \n    \n    \n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //stop timer\n    auto endTime = chrono::system_clock::now();\n    auto dur = endTime - startTime;\n    auto msec = chrono::duration_cast<chrono::milliseconds>(dur).count();\n    dout << fixed << setprecision(4) << (double)msec/1000 << \" sec \\n\";\n#endif\n    //------------------------------------------------------------------------------------------\n    \n#ifdef INPUTFILE\n    inputfile.close();\n#endif\n    \n#ifdef OUTPUTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\nusing namespace std;\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s,q;\n\tcin>>s;\n\ts+='$';\n\tint n=s.size();\n\tvector<int>suff(n);\n\tiota(suff.begin(),suff.end(),0);\n\t{\n\t\tconst char *str=s.c_str();\n\t\tsort(suff.begin(),suff.end(),[&](int a,int b){\n\t\t\treturn strcmp(str+a,str+b);\n\t\t});\n\t}\n\tvector<pair<char,int>>sorted(n);\n\tfor(int i=0;i<n;i++)sorted[i]={s[(suff[i]-1+n)%n],i};\n\tsort(sorted.begin(),sorted.end());\n\n\tint T;\n\tfor(cin>>T;T--;){\n\t\tstring q;\n\t\tcin>>q;\n\t\tint start=0,stop=n,idx=q.size()-1;\n\t\tfor(;idx>=0;idx--){\n\t\t\tpair<char,int> ql={q[idx],start},qr={q[idx],stop};\n\t\t\tstart=lower_bound(sorted.begin(),sorted.end(),ql)-sorted.begin();\n\t\t\tstop=lower_bound(sorted.begin(),sorted.end(),qr)-sorted.begin();\n\t\t\tif(start==stop)break;\n\t\t}\n\t\tif(idx<0){\n\t\t\t//for(;start<stop;start++)printf(\"%d\\n\",suff[start]);\n\t\t\tputs(\"1\");\n\t\t}else{\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cassert>\nusing namespace std;\n\nconst int ALPH = 256;\nstruct SuffixArray {\nprivate:\n    string s;\n    vector<int> rec, cnt;\n    int len, cnt_size;\npublic:\n    SuffixArray(string s_) : s(s_) {\n        s += \"$\"; // 辞書順で最も小さいダミー文字\n        len = s.length();\n        cnt_size = max(ALPH, len); cnt.resize(cnt_size);\n        rec = getArray();\n    }\n\n    void dump_array(vector<int> &indices, vector<int> &classes) {\n        fprintf(stderr, \"# debug\\n\");\n        fprintf(stderr, \"# indices:\");\n        for(int i=0; i<len; i++) fprintf(stderr, \" %d\", indices[i]);\n        fprintf(stderr, \"\\n\");\n        fprintf(stderr, \"# classes:\");\n        for(int i=0; i<len; i++) fprintf(stderr, \" %d\", classes[i]);\n        fprintf(stderr, \"\\n\");\n    }\n    \n    vector<int> getArray() {\n        vector<int> indices(len), prev_idx(len);\n        vector<int> classes(len), prev_cls(len);\n        vector<int> tmp_val(len);\n\n        // k == 0 はカウントソートのみ\n        for(int i=0; i<len; i++) {\n            cnt[ s[i] ]++;\n        }\n        for(int i=1; i<cnt_size; i++) {\n            cnt[i] += cnt[i-1];\n        }\n        for(int i=len-1; i>=0; i--) {\n            indices[ --cnt[ s[i] ] ] = i;\n        }\n        for(int i=1; i<len; i++) {\n            int pena = (s[ indices[i] ] != s[ indices[i-1] ]);\n            classes[ indices[i] ] = classes[ indices[i-1] ] + pena;\n        }\n        // dump_array(indices, classes);\n        \n        for(int k=0; (1 << k) < len; k++) {\n            swap(indices, prev_idx);\n            swap(classes, prev_cls);\n            for(int i=0; i<len; i++) {\n                // 後半だけソート済みにしたものを indices に代入\n                prev_idx[i] = prev_idx[i] - (1 << k);\n                if(prev_idx[i] < 0) prev_idx[i] += len;\n                tmp_val[i] = prev_cls[ prev_idx[i] ];\n            }\n\n            // 前半についてカウントソート\n            fill(cnt.begin(), cnt.end(), (int)0);\n            for(int i=0; i<len; i++) {\n                cnt[ tmp_val[i] ]++;\n            }\n            for(int i=1; i<cnt_size; i++) {\n                cnt[i] += cnt[i-1];\n            }\n            for(int i=len-1; i>=0; i--) {\n                indices[ --cnt[ tmp_val[i] ] ] = prev_idx[i];\n            }\n            classes[ indices[0] ] = 0;\n            for(int i=1; i<len; i++) {\n                int shift = (1 << k);\n                pair<int, int> pre(prev_cls[ indices[i-1] ], prev_cls[ (indices[i-1] + shift) % len ]);\n                pair<int, int> cur(prev_cls[ indices[i  ] ], prev_cls[ (indices[i  ] + shift) % len ]);\n                int pena = (pre != cur);\n                classes[ indices[i] ] = classes[ indices[i-1] ] + pena;\n            }   \n            // dump_array(indices, classes);\n        }\n        return indices;\n    }\n\n    int size() {\n        return rec.size();\n    }\n    int get(int idx) {\n        assert(0 <= idx and idx < size());\n        return rec[idx];\n    }\n    // パターン文字列 p は、idx 番目に小さい接尾辞に比べて大きいか？\n    bool is_greater(string &p, int idx) {\n        idx = get(idx);\n        int N = size(), M = p.size(), x, y;\n        for(x=idx, y=0; x<N and y<M; x++, y++) {\n            if(s[x] < p[y]) return true;\n            if(s[x] > p[y]) return false;\n        }\n        return x >= N and y < M;\n    }\n};\n\nint search_by_sa(SuffixArray &sa, string &p) {\n    int N = sa.size(), ansL, ansR;\n\n    int lb = 0, ub = N;\n    while(ub - lb > 1) {\n        int mid = (ub + lb) / 2;\n        if(sa.is_greater(p, mid)) lb = mid;\n        else ub = mid;\n    }\n    ansL = ub;\n\n    p.back()++;\n    cout << p << endl;\n    lb = 0, ub = N;\n    while(ub - lb > 1) {\n        int mid = (ub + lb) / 2;\n        if(sa.is_greater(p, mid)) lb = mid;\n        else ub = mid;\n    }\n    ansR = ub;\n    p.back()--;\n\n    return ansR - ansL;\n}\n\nint main() {\n    string s; cin >> s;\n    SuffixArray sa(s);\n\n    for(int i=0; i<=s.length(); i++) {\n        cout << s.substr(sa.get(i)) << endl;\n    }\n\n    int N; cin >> N;\n    for(int i=0; i<N; i++) {\n        string p; cin >> p;\n        if(search_by_sa(sa, p) > 0) {\n            cout << 1 << endl;\n        }\n        else {\n            cout << 0 << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<chrono>\n#include<unistd.h>\nusing namespace std;\n\n#define MAX 1100000\n#define MAX_P 1100\n#define LIMITX 10\n\nstring T, P;\nint Tsize, Psize;\npair<int,int> cont[MAX];\npair<int,int> contp;\nbool flag;\n\nclass index{\n\tpublic:\n\tint in, len = 0, tlen = 0;\n\tinline bool operator< (const index right ) {\n\t\tint rl = Tsize-right.in, ll = Tsize-in;\n\t\tint ma = rl<ll?rl:ll, s = 0;\n\t\tif(T[in] == T[right.in])s = min(cont[in].second-in,cont[right.in].second-right.in) + 1;\n\t\tfor(int i = s; i < ma; i++){\n\t\t\tif(T[in+i] < T[right.in+i]) return true;\n\t\t\tif(T[in+i] > T[right.in+i]) return false;\n\t\t}\n\t\treturn ll<rl;\n\t}\n\tinline bool operator< (const string right ) {\n\t\tint rl = Psize, ll = Tsize-in, ma = (ll<rl?ll:rl), s = 0;\n\t\t\tif(T[in] == right[0])s = min(cont[in].second-in,contp.second) + 1;\n\t\tfor(int i = s; i < ma; i++){\n\t\t\tif(T[in+i] < right[i]) return true;\n\t\t\tif(T[in+i] > right[i]) return false;\n\t\t}\n\t\treturn ll<rl;\n\t}\n\ttemplate<typename U>\n\tinline bool operator=(const U& ohter){\n\t\tin = ohter;\n\t}\n};\nindex in, in2;\nvector<index> SA;\n\nchar slect_pivot_m(int low, int high, int n){\n\tchar a = T[SA[low].in+n], b = T[SA[(low+high)/2].in+n], c = T[SA[high].in+n];\n\tif(a > b) swap(a,b);\n\tif(b > c){\n\t\tb = c;\n\t\tif(a > b) b = a;\n\t}\n\treturn b;\n}\n\nvoid multikey_quicksort(int low, int high, int n){\n\tif(high-low <= LIMITX){\n\t\tsort(SA.begin()+low,SA.begin()+high+1);\n\t} else {\n\t\tchar pivot = slect_pivot_m(low,high,n);\n\t\tint i, j, m1, m2;\n\t\ti = m1 = low;\n\t\tj = m2 = high;\n\t\twhile(true){\n\t\t\twhile(i <= j){\n\t\t\t\tchar k;\n\t\t\t\tk = T[SA[i].in+n];\n\t\t\t\tif(k > pivot) break;\n\t\t\t\tif(k == pivot){\n\t\t\t\t\tswap(SA[i],SA[m1]);\n\t\t\t\t\tm1++;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\twhile(i <= j){\n\t\t\t\tchar k;\n\t\t\t\tk = T[SA[j].in+n];\n\t\t\t\tif(k < pivot) break;\n\t\t\t\tif(k == pivot){\n\t\t\t\t\tswap(SA[j],SA[m2]);\n\t\t\t\t\tm2--;\n\t\t\t\t}\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tif(i > j) break;\n\t\t\tswap(SA[i],SA[j]);\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\tfor(int k = 0, mi = min(m1-low,i-m1); k < mi; k++ ){\n\t\t\tswap(SA[low+k],SA[j-k]);\n\t\t}\n\t\tm1 = low + (i - m1);\n\t\tfor(int k = 0, mi = min(high-m2,m2-j); k < mi; k++ ){\n\t\t\tswap(SA[i+k],SA[high-k]);\n\t\t}\n\t\tm2 = high - (m2- j) + 1;\n\t\tif(low < m1)multikey_quicksort(low,m1-1,n);\n\t\tif(m1 < m2 && T[SA[m2].in+n] != '\\0') multikey_quicksort(m1,m2-1,n+1);\n\t\tif(m2 <= high)multikey_quicksort(m2,high,n);\n\t}\n}\n\nvoid init(){\n\tint size = Tsize, count = 0;\n\tfor(int i = 0,j = size-1; i < size; i++,j--){\n\t\tindex temp; temp = i;\n\t\tSA.push_back(temp);\n\t\tif(i&&T[i-1] == T[i]){\n\t\t\tcont[i].first = cont[i-1].first;\n\t\t} else cont[i].first = i,count++;\n\t\tif(j != size-1&&T[j] == T[j+1]){\n\t\t\tcont[j].second = cont[j+1].second;\n\t\t}else cont[j].second = j;\n\t}\n\tif(count <= 100)sort(SA.begin(),SA.end());\n\telse multikey_quicksort(0, Tsize-1,0);\n\n}\n\nbool equal(string str, index com){\n\tint len = str.size(), clen = Tsize - com.in;\n\tif(len > clen) return false;\n\tfor(int i = 0; i < len; i++){\n\t\tif(str[i] != T[com.in+i]) return false;\n\t}\n\treturn true;\n}\n\nbool solve(string str){\n\tdecltype(SA)::iterator it = lower_bound(SA.begin(),SA.end(),str);\n\tif(it == SA.end())return false;\n\telse return equal(str,*it);\n}\n\nint main(){\n\tint Q, p;\n\tcin>>T;\n\tT += '\\0';\n\tTsize = T.size()-1;\n\tinit();\n\tcin>>Q;\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tcin>>P;\n\t\tPsize = P.size();\n\t\tfor(int k = 0,j = Psize-1; k < Psize; k++,j--){\n\t\t\tif(k&&P[k-1] == P[k]){\n\t\t\t\tcontp.first = contp.first;\n\t\t\t} else contp.first = k;\n\t\t\tif(j != Psize-1&&P[j] == P[j+1]){\n\t\t\t\tcontp.second = contp.second;\n\t\t\t}else contp.second = j;\n\t\t}\n\t\tcout<<solve(P)<<endl;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Benri { Benri() { std::cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(12);}} benri;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing pii = pair<int, int>;\nusing vll = vector<long long>;\nusing pll = pair<ll, ll>;\nusing ull = unsigned long long;\n\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\n//constexpr int INF = 1001001001;\nconstexpr ll INF = 1001001001001001001ll;\nconstexpr double EPS = 1e-10;\nusing number = long long;\n\n\nstruct SuffixArray {\n    vector< int > SA;\n    const string s;\n\n    SuffixArray(const string &str) : s(str) {\n        SA.resize(s.size());\n        iota(begin(SA), end(SA), 0);\n        sort(begin(SA), end(SA), [&](int a, int b) {\n            return s[a] == s[b] ? a > b : s[a] < s[b];\n        });\n        vector< int > classes(s.size()), c(s.begin(), s.end()), cnt(s.size());\n        for (int len = 1; len < s.size(); len <<= 1) {\n            for (int i = 0; i < s.size(); i++) {\n                if (i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n                    classes[SA[i]] = classes[SA[i - 1]];\n                } else {\n                    classes[SA[i]] = i;\n                }\n            }\n            iota(begin(cnt), end(cnt), 0);\n            copy(begin(SA), end(SA), begin(c));\n            for (int i = 0; i < s.size(); i++) {\n                int s1 = c[i] - len;\n                if (s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n            }\n            classes.swap(c);\n        }\n    }\n\n    int operator[](int k) const {\n        return SA[k];\n    }\n\n    size_t size() const {\n        return s.size();\n    }\n\n    bool lt_substr(const string &t, int si = 0, int ti = 0) {\n        int sn = (int) s.size(), tn = (int) t.size();\n        while (si < sn && ti < tn) {\n            if (s[si] < t[ti]) return true;\n            if (s[si] > t[ti]) return false;\n            ++si, ++ti;\n        }\n        return si >= sn && ti < tn;\n    }\n\n    int lower_bound(const string &t) {\n        int low = -1, high = (int) SA.size();\n        while (high - low > 1) {\n            int mid = (low + high) / 2;\n            if (lt_substr(t, SA[mid])) low = mid;\n            else high = mid;\n        }\n        return high;\n    }\n\n    pair< int, int > lower_upper_bound(string &t) {\n        int idx = lower_bound(t);\n        int low = idx - 1, high = (int) SA.size();\n        t.back()++;\n        while (high - low > 1) {\n            int mid = (low + high) / 2;\n            if (lt_substr(t, SA[mid])) low = mid;\n            else high = mid;\n        }\n        t.back()--;\n        return {idx, high};\n    }\n\n    void output() {\n        for (int i = 0; i < size(); i++) {\n            cout << i << \": \" << s.substr(SA[i]) << endl;\n        }\n    }\n};\n\nint main() {\n  string S;\n  int Q;\n\n  cin >> S;\n  SuffixArray sa(S);\n  cin >> Q;\n  while(Q--) {\n    string T;\n    cin >> T;\n    auto range = sa.lower_upper_bound(T);\n    cout << (range.first != range.second) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring S,T;\nstring V[50000][30];\nint main(){\n\tint q,a,b,c;\n\tcin>>S;\n\tb=S.size();\n\ta=min(b,100);\n\tfor(int i=1;i<100;i++){\n\t\tfor(int j=0;j<=b-i;j++){\n\t\t\tV[j][i]=S.substr(j,i);\n\t\t}\n\t}\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>T;\n\t\tc=T.size();\n\t\tfor(int j=0;j<=b-c;j++){\n\t\t\tif(V[j][c]==T){\n\t\t\t\tcout<<\"1\"<<endl;\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t}\n\t\tcout<<\"0\"<<endl;\n\t\tExit:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(string s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  bool operator()(int i, int j) { \n    int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  \n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  \n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  sort(ALL(sa),rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  while(n--){\n    cin >> t;\n    scanf(\" %s\",&t[0]);\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\ntypedef unsigned long long int ull;\n\nconst ull B=1e9+7;\nconst int MAXa=1000;\nconst int MAXs=1000000;\n\null shash[MAXa][MAXs];\n\nvoid makehash(string s)\n{\n\tint sl=s.length();\n\tfor(int i=0;i<sl;i++)shash[0][i]=s[i];\n\t\n\tfor(int i=1;i<MAXa;i++)\n\t{\n\t\tfor(int j=0;j<sl-i;j++)\n\t\t{\n\t\t\tshash[i][j]=shash[i-1][j]*B+s[i+j];\n\t\t}\n\t}\n\treturn;\n}\n\nbool check(string s,string a)\n{\n\tull ahash=0;\n\tint al=a.length(),sl=s.length();\n\tfor(int i=0;i<al;i++)ahash=ahash*B+a[i];\n\t\n\tfor(int i=0;i<=sl-al;i++)if(shash[al-1][i]==ahash)return true;\n\treturn false;\n}\n\nint main()\n{\n\tstring s;cin>>s;\n\tmakehash(s);\n\tint n;cin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tstring a;cin>>a;\n\t\tcout<<check(s,a)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  //ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)),pow(n+1),phash(n+1){\n    //pow=new ull[n+1];\n    //phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  //~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)>>1;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nint L[1000000],R[1000000];\n\ninline void merge(int *A, const int left, const int mid, const int right, const RollingHash &rh){\n  const int n1 = mid - left, n2 = right - mid;\n  REP(i,n1)L[i]=A[left+i];\n  REP(i,n2)R[i]=A[mid+i];\n  for(int k =left,i=0,j=0;k<right;k++){\n    if(n2<=j)A[k]=L[i++];\n    else if(n1<=i)A[k]=R[j++];\n    else A[k]=rh(L[i],R[j])?L[i++]:R[j++];\n  }\n}\n\nvoid mergeSort(int *A,const int left,const int right, const RollingHash &rh){\n  if(left+1<right){\n    const int mid = (left+right)>>1;\n    mergeSort(A,left,mid, rh);\n    mergeSort(A,mid,right, rh);\n    merge(A,left,mid,right, rh);\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergeSort(sa,0,n,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    S.push_back('$');\n    vector<int> c(n+1,0),ord(n+1,0);\n    for(int i=0;i<=n;i++) ord[i]=n-i;\n    sort(ord.begin(),ord.end(),[&](int a,int b){return S[a]<S[b];});\n    \n    for(int i=0;i<=n;i++){\n      sa[i]=ord[i];\n      c[i]=S[i];\n    }\n    \n    for(int len=1;len<=n;len*=2){\n      vector<int> r=c;\n      for(int i=0;i<=n;i++){\n\t c[sa[i]] = i > 0 && r[sa[i - 1]] == r[sa[i]] && sa[i - 1] + len < n && r[sa[i - 1] + len / 2] == r[sa[i] + len / 2] ? c[sa[i - 1]] : i;\n      }\n      vector<int> cnt(n+1);\n      for(int i=0;i<=n;i++) cnt[i]=i;\n      vector<int> s=sa;\n      for(int i=0;i<=n;i++){\n\tint s1=s[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n);\n    for(int i=0;i<n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\n#define NUM 48\nusing namespace std;\n\nint T_char_count[128] = {0},P_char_count[128];\n\nclass LocRecord{\n\npublic:\n\t//?????¢???????¢????\n\tLocRecord(){\n\t\tlocationTable = new int*[128];\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t}\n\n\t//-1?????£??\\\n\tvoid init(){\n\t\tint limit;\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init_index(){\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t}\n\n\tvoid regist_loc(int ch, int location){\n\t\tlocationTable[ch][index[ch]] = location;\n\t\tindex[ch]++;\n\t}\n\n\tint next_loc(int ch){\n\t\tint ret = locationTable[ch][index[ch]];\n\t\tindex[ch]++;\n\t\treturn ret;\n\t}\n\nprivate:\n\tint** locationTable;\n\tint index[128];\n};\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\treturn hashValue < arg.hashValue;\n\t};\n\tInfo(int arg_id,ull arg_hashValue){\n\t\tid = arg_id;\n\t\thashValue = arg_hashValue;\n\t}\n\n\tint id;\n\tull hashValue;\n};\n\nint main(){\n\n\tfor(int i = 0; i < 128; i++){\n\t\tT_char_count[i] = 0;\n\t}\n\n\tint T_length;\n\n\tchar* T = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tfor(T_length = 0; T[T_length] != '\\0';T_length++){\n\t\tT_char_count[T[T_length]]++;\n\t}\n\n\tLocRecord locRecord;\n\tlocRecord.init();\n\n\t//T[i]????????????i??§???????????¨????¨????\n\tfor(int i = 0; i < T_length; i++){\n\t\tlocRecord.regist_loc(T[i],i);\n\t}\n\n\tull* HASH = new ull[T_length+1];\n\tull* P = new ull[T_length+1];\n\n\tHASH[0] = 0;\n\tP[0] = 1;\n\n\t//T??????????????\\???????±???????\n\tfor(int i = 1; i <= T_length; i++){\n\t\tHASH[i] = T[i-1] + HASH[i-1]*MOD;\n\t\tP[i] = P[i-1]*MOD;\n\t}\n\n\n\tvector<Info> V[75][1001]; //V[????????????][??????] = ???????????????????????\\???\n\tvector<int> LENG[75]; //LENG[????????????] = ??????????????????\n\n\tint Q,S_length,left,P_char_count[128];\n\tscanf(\"%d\",&Q);\n\n\tbool check[Q];\n\n\tfor(int i = 0; i < Q; i++)check[i] = false;\n\n\tchar S[1001];\n\tull S_HASH[1001],S_value,T_value,D;\n\tbool FLG,isExist;\n\n\t//Q??¶??????????????\\???????¨????\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",S);\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tP_char_count[i] = 0;\n\t\t}\n\n\t\tfor(S_length = 0;S[S_length] != '\\0';S_length++){\n\t\t\tP_char_count[S[S_length]]++;\n\t\t}\n\n\t\tFLG = true;\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tif(T_char_count[i] < P_char_count[i]){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG)continue;\n\n\t\tif(S_length == 1){\n\t\t\tcheck[loop] = true;\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tS_HASH[0] = 0;\n\t\tfor(int i = 1; i <= S_length; i++){\n\t\t\tS_HASH[i] = S[i-1] + S_HASH[i-1]*MOD;\n\t\t}\n\n\t\tS_value = S_HASH[S_length];\n\n\t\t//???????????\\?????????????????????????????????\n\t\tisExist = false;\n\t\tfor(int a = 0; a < V[S[0]-NUM][S_length].size();a++){\n\t\t\tif(V[S[0]-NUM][S_length][a].hashValue == S_value){\n\t\t\t\tisExist = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!isExist){\n\t\t\tV[S[0]-NUM][S_length].push_back(Info(loop,S_value));\n\t\t}\n\n\t\tisExist = false;\n\t\tfor(int a = 0; a < LENG[S[0]-NUM].size();a++){\n\t\t\tif(LENG[S[0]-NUM][a] == S_length){\n\t\t\t\tisExist = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!isExist){\n\t\t\tLENG[S[0]-NUM].push_back(S_length);\n\t\t}\n\t}\n\n\t//??????????????????sort\n\tfor(int i = 48; i <= 122; i++)sort(LENG[i-NUM].begin(),LENG[i-NUM].end());\n\t//hashValue????????????sort\n\tfor(int i = 48; i <= 122; i++){\n\t\tfor(int b = 0; b < LENG[i-NUM].size();b++){\n\t\t\tsort(V[i-NUM][LENG[i-NUM][b]].begin(),V[i-NUM][LENG[i-NUM][b]].end());\n\t\t}\n\t}\n\n\tint calc_length,calc_left,calc_right,calc_m,tmp_len;;\n\n\tfor(int word = 48; word <= 122; word++){\n\t\tfor(int i = 0; i < LENG[word-NUM].size();i++){\n\n\t\t\tlocRecord.init_index();\n\t\t\tcalc_length = LENG[word-NUM][i];\n\n\t\t\twhile((left = locRecord.next_loc(word)) != -1){\n\t\t\t\tif(left+calc_length-1 >= T_length)break;\n\n\t\t\t\tT_value = HASH[left+calc_length]-HASH[left]*P[calc_length];\n\n\t\t\t\tcalc_left = 0;\n\t\t\t\tcalc_right = V[word-NUM][calc_length].size()-1;\n\t\t\t\tcalc_m = (calc_left+calc_right)/2;\n\n\t\t\t\twhile(calc_left <= calc_right){\n\t\t\t\t\tif(V[word-NUM][calc_length][calc_m].hashValue == T_value){\n\t\t\t\t\t\tcheck[V[word-NUM][calc_length][calc_m].id] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(V[word-NUM][calc_length][calc_m].hashValue < T_value){\n\t\t\t\t\t\t\tcalc_left = calc_m+1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcalc_right = calc_m-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tif(check[i])printf(\"1\\n\");\n\t\telse{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define ALL(obj) (obj).begin(),(obj).end()\n#define RALL(obj) (obj).rbegin(),(obj).rend()\n#define REP(i, n) for(int i = 0; i < int(n); i++)\n#define FOR(i,n,m) for(int i = int(n); i < int(m); i++)\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 1e9 + 7;\nconst int INF = MOD - 1;\nconst ll LLINF = 4e18;\n\n// <O(NlogN),O(1)>\ntemplate< typename T >\nstruct SparseTable {\n    using Func = function<T(T, T)>;\n    vector< vector< T > > st;\n    vector< int > lookup;\n    Func F;// min or max\n\n    SparseTable() {}\n    SparseTable(const vector< T > &v, Func F) : F(F) {\n        int b = 0;\n        while ((1 << b) <= v.size()) ++b;\n        st.assign(b, vector< T >(1 << b));\n        REP(i, v.size()) st[0][i] = v[i];\n        FOR(i, 1, b) for (int j = 0; j + (1 << i) <= (1 << b); j++) st[i][j] = F(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n        lookup.resize(v.size() + 1);\n        FOR(i, 2, lookup.size()) lookup[i] = lookup[i >> 1] + 1;\n    }\n\n    // [l,r)\n    inline T rmq(int l, int r) {\n        int b = lookup[r - l];\n        return F(st[b][l], st[b][r - (1 << b)]);\n    }\n};\n\nstruct SuffixArray {\nprivate:\n    vector< int > SA, LCP;\n    vector<int> rank;// rank[i]:s[i:]のSAのindex\n    string s;\n    SparseTable<int> st;\n\n    // 比較関数 s[si:] < t[ti:]\n    bool lt_substr(string& t, int si = 0, int ti = 0)\n    {\n        int sn = s.size(), tn = t.size();\n        while (si < sn && ti < tn) {\n            if (s[si] < t[ti]) return (true);\n            if (s[si] > t[ti]) return (false);\n            ++si, ++ti;\n        }\n        return (si >= sn && ti < tn);\n    }\n\n    // prefixがtの辞書順最小\n    // O(|t|log|S|)\n    int lower_bound(string& t)\n    {\n        int low = -1, high = SA.size();\n        while (high - low > 1) {\n            int mid = (low + high) >> 1;\n            if (lt_substr(t, SA[mid])) low = mid;\n            else high = mid;\n        }\n        return high;\n    }\n\n    // [first,second) のprefixがt\n    // O(|t|log|S|)\n    pair<int, int> lower_upper_bound(string& t) {\n        int idx = lower_bound(t);\n        int low = idx - 1, high = SA.size();\n        t.back()++;\n        while (high - low > 1) {\n            int mid = (low + high) >> 1;\n            if (lt_substr(t, SA[mid])) low = mid;\n            else high = mid;\n        }\n        t.back()--;\n        return {idx, high};\n    }\npublic:\n\n    SuffixArray(const string& str) : s(str)\n    {\n        SA.resize(s.size());\n        iota(begin(SA), end(SA), 0);\n        sort(begin(SA), end(SA), [&](const int& a, const int& b)\n        {\n            if (s[a] == s[b]) return(a > b);\n            return (s[a] < s[b]);\n        });\n        vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n        for (int i = 0; i < s.size(); i++) {\n            c[i] = s[i];\n        }\n        for (int len = 1; len < s.size(); len <<= 1) {\n            for (int i = 0; i < s.size(); i++) {\n                if (i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n                    classes[SA[i]] = classes[SA[i - 1]];\n                }\n                else {\n                    classes[SA[i]] = i;\n                }\n            }\n            iota(begin(cnt), end(cnt), 0);\n            copy(begin(SA), end(SA), begin(c));\n            for (int i = 0; i < s.size(); i++) {\n                int s1 = c[i] - len;\n                if (s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n            }\n            classes.swap(c);\n        }\n    }\n\n    int count(string &t) {\n        pair<int, int> p = lower_upper_bound(t);\n        return p.second - p.first;\n    }\n\n    // s中のtの位置 \n    // 順番は適当 ソートしてない\n    vector<int> find(string &t) {\n        vector<int> v;\n        pair<int, int> p = lower_upper_bound(t);\n        FOR(i, p.first, p.second) {\n            v.push_back(SA[i]);\n        }\n        return v;\n    }\n\n    void print_sa() {\n        REP(i, s.size()) cout << i << \": \" << s.substr(SA[i]) << endl;\n    }\n\n    // O(|S|)\n    void build_lcp() {\n        rank.resize(s.size());\n        REP(i, s.size()) rank[SA[i]] = i;\n        LCP.resize(s.size());\n        LCP[0] = 0;\n        for (int i = 0, h = 0; i < s.size(); i++) {\n            if (rank[i] + 1 < s.size()) {\n                for (int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n                LCP[rank[i] + 1] = h;\n                if (h > 0) --h;\n            }\n        }\n        st = SparseTable<int>(LCP, [](int x, int y) {return min(x, y); });\n    }\n\n    void print_lcp() {\n        cout << \"No.\\tLCP\\tsuffix\" << endl;\n        cout << \"----------------------\" << endl;\n        REP(i, s.size()) cout << i << \":\\t\" << LCP[i] << \"\\t\" << s.substr(SA[i]) << endl;\n    }\n\n    // s[a:]とs[b:]のLCP\n    int get_lcp(int a, int b) {\n        return st.rmq(min(rank[a], rank[b]) + 1, max(rank[a], rank[b]) + 1);\n    }\n};\n\nint main() {\n    string s; cin >> s;\n    SuffixArray sa(s);\n    int q; cin >> q;\n    REP(i, q) {\n        string t; cin >> t;\n        cout << (sa.count(t) ? 1:0 ) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vl = vector<ll>;\nusing vll = vector<vector<ll>>;\nusing pii = pair<int,int>;\n#define FOR(i,a,b) for(ll i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(obj) (obj).begin(), (obj).end()\nconst double PI = acos(-1);\nconst double EPS = 1e-10;\nconst ll MOD = 1e9+7;\nvoid cioacc(){//accelerate cin/cout\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\nvector<string> make_suffix_array(string s){\n  vector<string> res;\n  REP(i,(ll)s.size()+1){\n    string tmp(s.begin()+i,s.end());\n    res.push_back(tmp);\n  }\n  sort(ALL(res));\n  return res;\n}\nint main(){//naive suffix array\n  string t;\n  int n;\n  cin >> t >> n;\n  auto suf = make_suffix_array(t);\n  REP(i,n){\n    string q;\n    cin >> q;\n    size_t sz = q.size();\n    auto itr = lower_bound(ALL(suf),q);\n    bool flag = false;\n    do{\n      if(itr==suf.end()) break;\n      string cut(itr -> begin(),(itr->begin())+min(sz,itr->size()));\n      if(cut==q){\n        cout << 1 << endl;\n        flag = true;\n        break;\n      } else if(cut > q){\n        break;\n      }\n      ++itr;\n    }while(true);\n    if(!flag) cout << 0 << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <map>\n#include <new>\n#include <deque>\n#include <functional>\nusing namespace std;\n\ntemplate <class T>\nstruct myalloc{\n\tusing value_type = T;\n\n\tstatic const int num = 1024;\n\tstatic int k;\n\tstatic deque<vector<char>> dq;\n\n\tmyalloc(){}\n\ttemplate <class U>\n\tmyalloc(const myalloc<U> &){}\n\n\tT* allocate(size_t n){\n\t\tif(k >= num || dq.empty()){\n\t\t\tdq.emplace_back(num * sizeof(T));\n\t\t\tk = 0;\n\t\t}\n\t\treturn reinterpret_cast<T*>(&dq.back()[k++ * sizeof(T)]);\n\t}\n\n\tvoid deallocate(T*, size_t){}\n};\n\ntemplate <class T>\nint myalloc<T>::k;\ntemplate <class T>\ndeque<vector<char>> myalloc<T>::dq;\n\nstruct node{\n\tint fail;\n\tbool vis;\n\tmap<char,int,less<char>,myalloc<char>> nxt;\n};\n\nvector<node> trie;\n\nstring input(){\n\tstatic char buf[1000010];\n\tbuf[0] = 0;\n\tscanf(\"%s\", buf);\n\treturn buf;\n}\n\nint main(){\n\ttrie.reserve(1000010);\n\n\ttrie.emplace_back();\n\ttrie[0].fail = -1;\n\n\tstring t = input();\n\tint q;\n\tscanf(\"%d\", &q);\n\tvector<int> idx(q);\n\tfor(int i = 0; i < q; ++i){\n\t\tstring p = input();\n\t\tint u = 0;\n\t\tfor(char c : p){\n\t\t\tif(!trie[u].nxt.count(c)){\n\t\t\t\ttrie[u].nxt.emplace(c, trie.size());\n\t\t\t\ttrie.emplace_back();\n\t\t\t}\n\t\t\tu = trie[u].nxt[c];\n\t\t}\n\t\tidx[i] = u;\n\t}\n\n\tvector<int> bfs;\n\tbfs.push_back(0);\n\tint k = 0;\n\twhile(k < (int)bfs.size()){\n\t\tint u = bfs[k++];\n\t\tfor(const auto &pr : trie[u].nxt){\n\t\t\tchar c = pr.first;\n\t\t\tint v = pr.second;\n\t\t\tbfs.push_back(v);\n\n\t\t\tint f = trie[u].fail;\n\t\t\twhile(f >= 0 && !trie[f].nxt.count(c)){\n\t\t\t\tf = trie[f].fail;\n\t\t\t}\n\t\t\ttrie[v].fail = f >= 0 ? trie[f].nxt[c] : 0;\n\t\t}\n\t}\n\n\tint r = 0;\n\tfor(char c : t){\n\t\twhile(r >= 0 && !trie[r].nxt.count(c)){\n\t\t\tr = trie[r].fail;\n\t\t}\n\t\tr = r >= 0 ? trie[r].nxt[c] : 0;\n\t\ttrie[r].vis = true;\n\t}\n\n\tfor(int i = bfs.size(); --i; ){\n\t\tint u = bfs[i];\n\t\tif(trie[u].vis){\n\t\t\ttrie[trie[u].fail].vis = true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < q; ++i){\n\t\tprintf(\"%d\\n\", +trie[idx[i]].vis);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\n\n#define fi(x) get<0>(x)\n#define se(x) get<1>(x)\n\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\ntypedef vector<pll> vpl;\n\nstring t;\nstring p;\nlli q;\n\nvll sa;\nvll tmp;\nvpl rnk;\n\nint main(){\n    cin >> t;\n    sa = vll(t.size());rnk = vpl(t.size());tmp = vll(t.size());\n    for(lli i = 0;i < t.size();i++) sa[i] = i;\n    for(lli i = 0;i < t.size();i++) fi(rnk[i]) = t[i];\n    for(lli k = 1;k < 2*t.size();k *= 2){\n        sort(sa.begin(),sa.end(),[](lli a,lli b){\n            return rnk[a] < rnk[b];\n        });\n        for(lli i = 1;i < sa.size();i++){\n            tmp[sa[i]] = tmp[sa[i-1]];\n            if(rnk[sa[i]] != rnk[sa[i-1]]) tmp[sa[i]]++;\n        }\n        for(lli i = 0;i < sa.size();i++){\n            fi(rnk[sa[i]]) = tmp[sa[i]];\n        }\n        for(lli i = 0;i < sa.size();i++){\n            if(sa[i]+k < t.size()) se(rnk[sa[i]]) = fi(rnk[sa[i]+k]);\n            else se(rnk[sa[i]]) = -1;\n        }\n    }\n    cin >> q;\n    for(lli i = 0;i < q;i++){\n        cin >> p;\n        lli lwrbnd = *lower_bound(sa.begin(),sa.end(),p,[](lli a,string s){\n            //if(t.size() < a + s.size()) return true;\n            return t.compare(a,min((lli)s.size(),(lli)(t.size()-a)),s) < 0;\n        });\n        if(t.size() >= lwrbnd+p.size() && t.compare(lwrbnd,p.size(),p) == 0) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n\n#pragma warning(disable: 4996)\n\nusing namespace std;\n\nint Q; char STR1[1000001], STR2[1001];\n\nvector<int> ptr[62];\n\nconst char strings[63] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890\";\n\nint main()\n{\n\tscanf(\"%s\", &STR1);\n\n\tfor (int i = 0; i < strlen(STR1); i++)\n\t{\n\t\tfor (int j = 0; j < 62; j++)\n\t\t{\n\t\t\tif (STR1[i] == strings[j])\n\t\t\t{\n\t\t\t\tptr[j].push_back(i); break;\n\t\t\t}\n\t\t}\n\t}\n\n\tscanf(\"%d\", &Q);\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%s\", STR2);\n\n\t\tint code_;\n\t\tint size_;\n\n\t\tfor (int j = 0; j < 62; j++)\n\t\t{\n\t\t\tif (STR2[0] == strings[j])\n\t\t\t{\n\t\t\t\tsize_ = ptr[j].size();\n\n\t\t\t\tcode_ = j;\n\t\t\t}\n\t\t}\n\n\t\tint finds = 0;\n\n\t\tfor (int j = 0; j < size_; j++)\n\t\t{\n\t\t\tint ptr_ = ptr[code_][j];\n\n\t\t\tif (ptr[code_][j] + strlen(STR2) < strlen(STR1))\n\t\t\t{\n\t\t\t\tfinds++;\n\n\t\t\t\tfor (int k = 0; k < strlen(STR2); k++)\n\t\t\t\t{\n\t\t\t\t\tif (STR1[ptr_ + k] != STR2[k])\n\t\t\t\t\t{\n\t\t\t\t\t\tgoto Exit1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (finds)\n\t\t\t{\n\t\t\t\tprintf(\"1\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t}\n\n\t\t\tgoto Exit2;\n\n\t\tExit1:;\n\t\t}\n\n\t\tprintf(\"0\\n\");\n\n\tExit2:;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <sstream>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n#define rrep(i, a) RREP(i, a, 0)\n#define RREP(i, a, b) for(int i = a; i >= b; --i)\n#define repll(i, a) REPLL(i, 0, a)\n#define REPLL(i, a, b) for(ll i = a; i < b; ++i)\n#define rrepll(i, a) RREPLL(i, a, 0)\n#define RREPLL(i, a, b) for(ll i = a; i >= b; --i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<int, P> PP;\nconst double PI = 3.14159265358979323846;\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+18 + 10;\n\nconst int max = 1000005;\n\nstd::string text;\nint textSize, k = 1;\nint rank[max + 1], tmp[max + 1], sa[max + 1];\n\nbool compare_sa(int i, int j){\n\tif (rank[i] != rank[j])return rank[i] < rank[j];\n\telse {\n\t\tint ri = (i + k <= textSize ? rank[i + k] : -1);\n\t\tint rj = (j + k <= textSize ? rank[j + k] : -1);\n\t\treturn ri < rj;\n\t}\n}\n\nvoid construct_sa(){\n\ttextSize = text.size();\n\trep(i, textSize + 1){\n\t\tsa[i] = i;\n\t\trank[i] = (i < textSize ? text[i] : -1);\n\t}\n\n\tfor (; k <= textSize; k *= 2){\n\t\tstd::sort(sa, sa + textSize + 1, compare_sa);\n\n\t\ttmp[sa[0]] = 0;\n\t\tREP(j, 1, textSize + 1)tmp[sa[j]] = tmp[sa[j - 1]] + (compare_sa(sa[j - 1], sa[j]) ? 1 : 0);\n\t\trep(j, textSize + 1)rank[j] = tmp[j];\n\t}\n}\n\nbool find(std::string t){\n\tint l = 0, r = text.size();\n\twhile (l <= r){\n\t\tint m = (l + r) / 2;\n\t\tif (text.compare(sa[m], t.size(), t) < 0)l = m + 1;\n\t\telse r = m - 1;\n\t}\n\treturn (text.compare(sa[r + 1], t.size(), t) == 0);\n}\n\nint n;\n\nint main(){\n\tstd::cin >> text >> n;\n\tconstruct_sa();\n\trep(i, n){\n\t\tstd::string str;\n\t\tstd::cin >> str;\n\t\tstd::cout << (find(str) ? 1 : 0) << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define MAX 1000002\n\nint Lv[MAX], A[MAX], newLv[MAX];\nint n, k;\nstring T;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n\tif(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n\tint L_i = (i + k >= n ? -1 : Lv[i + k]);\n\tint L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n\treturn L_i < L_j;\n}\n\nint main()\n{\n\tstd::cin >> T;\n\tn = T.size();\n\n\tint i;\n\tfor(i = 0; i < n; i++){ A[i] = i; }\n\tfor(i = 0; i < n; i++){ Lv[i] = T[i]; }\n\tsort(A, A + n, cmp_Lv);\n\n\tnewLv[A[0]] = 0;\n\tfor(i = 1; i < n; i++){\n\t\tnewLv[A[i]] = newLv[A[i - 1]] + (Lv[A[i]] != Lv[A[i - 1]] ? 1 : 0);\n\t}\n\tfor(i = 0; i < n; i++){ Lv[i] = newLv[i]; }\n\n\tk = 1;\n\twhile(1){\n\t\tif(k > n) break;\n\n\t\tsort(A, A + n, cmp);\n\t\tnewLv[A[0]] = 0;\n\t\tfor(i = 1; i < n; i++){ newLv[A[i]] = newLv[A[i - 1]] + (cmp(A[i - 1], A[i]) ? 1 : 0); }\n\t\tfor(i = 0; i < n; i++){ Lv[i] = newLv[i]; }\n\n\t\tif(Lv[A[n - 1]] == n - 1) break;\n\t\tk <<= 1;\n\t};\n\n\tstring P;\n\tint q, left, right, mid, crit;\n\tbool exist;\n\tscanf(\"%d\", &q);\n\n\tA[n] = n;\n\n\twhile(q){\n\t\tstd::cin >> P;\n\t\tleft = 0, right = n, exist = false;\n\t\twhile(left < right){\n\n\t\t\tif(n < P.size()){ exist = false; break; }\n\n\t\t\tmid = (left + right) / 2;\n\t\t\tcrit = T.compare(A[mid], P.size(), P);\n\n\t\t\tif(crit > 0){ right = mid; }\n\t\t\telse if(crit < 0){ left = mid + 1; }\n\t\t\telse{ exist = true; break; }\n\t\t};\n\t\tif(T.compare(A[right], P.size(), P) == 0) exist = true;\n\t\tif(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n\t\tq--;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\n\nstruct PMA{\n    PMA *next[256];\n    Vec matched;\n    PMA(){ fill(next,next+256,(PMA*)0); }\n    ~PMA(){\n\tfor(int i = 0 ; i < 256 ; i++){\n\t    if(next[i]) delete next[i];\n\t}\n    }\n};\n\nVec set_union(const Vec &a,const Vec &b){\n    int i = 0, j = 0, A = a.size(), B = b.size();\n    Vec res;\n    while(i < A && j < B){\n        if(a[i] == b[j]){\n            res.push_back(a[i]);\n            i++; j++;\n        }else if(a[i] > b[j]){\n            res.push_back(b[j++]);\n        }else{\n            res.push_back(a[i++]);\n        }\n    }\n    for( ; i < A ; i++) res.push_back(a[i]);\n    for( ; j < B ; j++) res.push_back(b[j]);\n    return res;\n}\n\nPMA *buildPMA(string pattern[10000],int size){\n    PMA *root = new PMA;\n    for(int i = 0 ; i < size ; i++){\n        PMA *t = root;\n        for(int j = 0 ; j < (int)pattern[i].size() ; j++){\n            char c = pattern[i][j];\n            if(t->next[c] == (PMA*)0) t->next[c] = new PMA;\n            t = t->next[c];\n        }\n        t->matched.push_back(i);\n    }\n    queue<PMA*> Q;\n    for(int i = 1 ; i < 256 ; i++){\n        if(root->next[i]){\n            root->next[i]->next[0] = root;\n            Q.push(root->next[i]);\n        }else{\n            root->next[i] = root;\n        }\n    }\n    while(!Q.empty()){\n        PMA *t = Q.front(); Q.pop();\n        for(int i = 1 ; i < 256 ; i++){\n            if(t->next[i]){\n                PMA *next = t->next[0];\n                while(!next->next[i]) next = next->next[0];\n                t->next[i]->next[0] = next->next[i];\n                t->next[i]->matched =\n                    set_union(t->next[i]->matched,next->next[i]->matched);\n                Q.push(t->next[i]);\n            }\n        }\n    }\n    return root;\n}\n\nvoid match(PMA *pma,string &s,Vec &res){\n    for(int i = 0 ; i < (int)s.size() ; i++){\n        int c = s[i];\n        while(!pma->next[c]) pma = pma->next[0];\n        pma = pma->next[c];\n        for(int j = 0 ; j < (int)pma->matched.size() ; j++){\n            res[pma->matched[j]] = 1;\n        }\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(0);\n    \n    int Q;\n    string T,P[10000];\n    cin >> T >> Q;\n    for(int i = 0 ; i < Q ; i++){\n\tcin >> P[i];\n    }\n    PMA *pma = buildPMA(P,Q);\n    Vec res(Q,0);\n    match(pma,T,res);\n    for(int i = 0 ; i < (int)res.size() ; i++){\n\tcout << res[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n/2+n%2,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==nc)a[i]=b[j++];\n      else if(j==nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  //mergesort(n,sa,rh);\n  for(int i=0;i<n;i++){\n    for(int j=n-1;j>i;j--){\n      if(rh(sa[j],sa[j-1]))swap(sa[j-1],sa[j]);\n    }\n  }\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int i, const int j) { \n    //const int k=lcp(i,j);\n    const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int b, const int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  /*\n  inline int lcp(const int i, const int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n  */\n  int lcp2(const int i, const int j, const int l, const int r){\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n);\n  REP(i,rh.n)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\n\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1000000000 + 7;\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nstruct SuffixArray {\n    int n, k;\n    string text;\n    vector<int> sa;\n    vector<int> rank;\n    vector<int> lcp;\n\n    SuffixArray (const string &s)\n    : text(s), n(s.size()), sa(n + 1), rank(n + 1), lcp(n)\n    {}\n\n    bool comp(int i, int j) {\n        if (rank[i] != rank[j]) return rank[i] < rank[j];\n        int ri = i + k <= n ? rank[i + k] : -1;\n        int rj = j + k <= n ? rank[j + k] : -1;\n        return ri < rj;\n    }\n\n    void construct_sa() {\n        for (int i = 0; i <= n; i++) {\n            sa[i] = i;\n            rank[i] = i < n ? text[i] : -1;\n        }\n\n        for (k = 1; k <= n; k *= 2) {\n            sort(sa.begin(), sa.end(), [&](const int& i, const int& j) {return comp(i, j);});\n\n            vector<int> tmp(n + 1);\n            tmp[sa[0]] = 0;\n            for (int i = 1; i <= n; i++) {\n                tmp[sa[i]] = tmp[sa[i - 1]] + (comp(sa[i - 1], sa[i]) ? 1 : 0);\n            }\n\n            for (int i = 0; i <= n; i++) {\n                rank[i] = tmp[i];\n            }\n        }\n    }\n\n    void construct_lcp () {\n        int h = 0;\n        lcp[0] = 0;\n        for (int i = 0; i < n; i++) {\n            int j = sa[rank[i] - 1];\n            if (h > 0) h--;\n            for (; j + h < n && i + h < n; h++) {\n                if (text[j + h] != text[i + h]) break;\n            }\n            lcp[rank[i] - 1] = h;\n        }\n    }\n\n    int low_bd(const string &pt) {\n        int l = 0, r = n + 1;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val < 0) l = m;\n            else r = m;\n        }\n        return r;\n    }\n\n    int up_bd(const string &pt) {\n        int l = 1, r = n + 1;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val <= 0) l = m;\n            else r = m;\n        }\n        return r;\n    }\n\n    bool match(const string &pt) {\n        int idx = low_bd(pt);\n        if (idx == sa.size()) return false;\n        return text.compare(sa[idx], pt.length(), pt) == 0 ? true : false;\n    }\n\n    int count(const string &pt) {\n        int l_idx = low_bd(pt);\n        if (l_idx == sa.size()) return 0;\n        if (text.compare(sa[l_idx], pt.length(), pt) != 0) return 0;\n        int r_idx = up_bd(pt);\n        return r_idx - l_idx;\n    }\n};\n\nstring t;\nint q;\nstring p[10000];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> t;\n    cin >> q;\n    rep(i, q) cin >> p[i];\n    SuffixArray suf(t);\n    suf.construct_sa();\n    rep(i, q) {\n        if (suf.match(p[i])) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S 1000005\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\nstruct d{\n  int a,b,c;\n  d(){}\n  d(int A,int B,int C){\n    a=A,b=B,c=C;\n  };\n  bool operator<(const d&r)const{\n    if(a!=r.a)return a<r.a;\n    return b<r.b;\n  }\n};\n\nint n,slen,tlen,r[S];\nchar s[S],t[N];\nd ran[S];\nP a[S];\n\nvoid init(){\n  for(int i=0;i<26;i++)\n    for(int j=0;j<slen;j++)\n      if('a'+i==s[j])r[j]=i+1;\n  int x=1;\n  while(x<slen){\n    for(int i=0;i<slen;i++){\n      int a=i+x;\n      if(a>slen)a=slen;\n      ran[i]=d(r[i],r[a],i);\n    }\n    sort(ran,ran+slen);\n    int cnt=1;\n    for(int i=0;i<slen;i++){\n      r[ran[i].c]=cnt;\n      if(ran[i].a==ran[i+1].a&&ran[i].b==ran[i+1].b)\n\tcontinue;\n      cnt++;\n    }\n    x*=2;\n  }\n  for(int i=0;i<slen;i++)a[i]=P(r[i],i);\n  sort(a,a+slen);\n}\n\nbool bynary_search(){\n  int L=0,R=slen+1;\n  while(L<R){\n    int M=(L+R)/2;\n    if(strncmp(s+a[M].second,t,tlen)<0)L=M+1;\n    else R=M;\n  }\n  if(!strncmp(s+a[L].second,t,tlen))return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s%d\",s,&n);\n  slen=strlen(s);\n  init();  \n  while(n--){\n    scanf(\"%s\",t);\n    tlen=strlen(t);\n    if(bynary_search())printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cassert>\nusing namespace std;\n\nconst int ALPH = 256;\nstruct SuffixArray {\nprivate:\n    string s;\n    vector<int> rec, cnt;\n    int len, cnt_size;\npublic:\n    SuffixArray(string s_) : s(s_) {\n        s += \"$\"; // 辞書順で最も小さいダミー文字\n        len = s.length();\n        cnt_size = max(ALPH, len); cnt.resize(cnt_size);\n        rec = getArray();\n    }\n\n    void dump_array(vector<int> &indices, vector<int> &classes) {\n        fprintf(stderr, \"# debug\\n\");\n        fprintf(stderr, \"# indices:\");\n        for(int i=0; i<len; i++) fprintf(stderr, \" %d\", indices[i]);\n        fprintf(stderr, \"\\n\");\n        fprintf(stderr, \"# classes:\");\n        for(int i=0; i<len; i++) fprintf(stderr, \" %d\", classes[i]);\n        fprintf(stderr, \"\\n\");\n    }\n    \n    vector<int> getArray() {\n        vector<int> indices(len), prev_idx(len);\n        vector<int> classes(len), prev_cls(len);\n        vector<int> tmp_val(len);\n\n        // k == 0 はカウントソートのみ\n        for(int i=0; i<len; i++) {\n            cnt[ s[i] ]++;\n        }\n        for(int i=1; i<cnt_size; i++) {\n            cnt[i] += cnt[i-1];\n        }\n        for(int i=len-1; i>=0; i--) {\n            indices[ --cnt[ s[i] ] ] = i;\n        }\n        for(int i=1; i<len; i++) {\n            int pena = (s[ indices[i] ] != s[ indices[i-1] ]);\n            classes[ indices[i] ] = classes[ indices[i-1] ] + pena;\n        }\n        // dump_array(indices, classes);\n        \n        for(int k=0; (1 << k) < len; k++) {\n            swap(indices, prev_idx);\n            swap(classes, prev_cls);\n            for(int i=0; i<len; i++) {\n                // 後半だけソート済みにしたものを indices に代入\n                prev_idx[i] = prev_idx[i] - (1 << k);\n                if(prev_idx[i] < 0) prev_idx[i] += len;\n                tmp_val[i] = prev_cls[ prev_idx[i] ];\n            }\n\n            // 前半についてカウントソート\n            fill(cnt.begin(), cnt.end(), (int)0);\n            for(int i=0; i<len; i++) {\n                cnt[ tmp_val[i] ]++;\n            }\n            for(int i=1; i<cnt_size; i++) {\n                cnt[i] += cnt[i-1];\n            }\n            for(int i=len-1; i>=0; i--) {\n                indices[ --cnt[ tmp_val[i] ] ] = prev_idx[i];\n            }\n            classes[ indices[0] ] = 0;\n            for(int i=1; i<len; i++) {\n                int shift = (1 << k);\n                pair<int, int> pre(prev_cls[ indices[i-1] ], prev_cls[ (indices[i-1] + shift) % len ]);\n                pair<int, int> cur(prev_cls[ indices[i  ] ], prev_cls[ (indices[i  ] + shift) % len ]);\n                int pena = (pre != cur);\n                classes[ indices[i] ] = classes[ indices[i-1] ] + pena;\n            }   \n            // dump_array(indices, classes);\n        }\n        return indices;\n    }\n\n    int size() {\n        return rec.size();\n    }\n    int get(int idx) {\n        assert(0 <= idx and idx < size());\n        return rec[idx];\n    }\n    // パターン文字列 p は、idx 番目に小さい接尾辞に比べて大きいか？\n    bool is_greater(string &p, int idx) {\n        idx = get(idx);\n        int N = size(), M = p.size(), x, y;\n        for(x=idx, y=0; x<N and y<M; x++, y++) {\n            if(s[x] < p[y]) return true;\n            if(s[x] > p[y]) return false;\n        }\n        return x >= N and y < M;\n    }\n};\n\nint search_by_sa(SuffixArray &sa, string &p) {\n    int N = sa.size(), ansL, ansR;\n\n    int lb = 0, ub = N;\n    while(ub - lb > 1) {\n        int mid = (ub + lb) / 2;\n        if(sa.is_greater(p, mid)) lb = mid;\n        else ub = mid;\n    }\n    ansL = ub;\n\n    p.back()++;\n    cout << p << endl;\n    lb = 0, ub = N;\n    while(ub - lb > 1) {\n        int mid = (ub + lb) / 2;\n        if(sa.is_greater(p, mid)) lb = mid;\n        else ub = mid;\n    }\n    ansR = ub;\n    p.back()--;\n\n    return ansR - ansL;\n}\n\nint main() {\n    string s; cin >> s;\n    SuffixArray sa(s);\n\n    /*\n    for(int i=0; i<=s.length(); i++) {\n        cout << s.substr(sa.get(i)) << endl;\n    }\n    */\n\n    int N; cin >> N;\n    for(int i=0; i<N; i++) {\n        string p; cin >> p;\n        if(search_by_sa(sa, p) > 0) {\n            cout << 1 << endl;\n        }\n        else {\n            cout << 0 << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) const { \n    //const int k=lcp(i,j);\n    //const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    const int k=lcp2(i,j,0,(n-max(i,j))*2+1);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  inline bool cmp(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n  \n  \n  inline int lcp2(const int& i, const int& j, const int& l, const int& r) const {\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n  \n};\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  const int n = SZ(a);\n  if(n>1){\n    vector<int> b(a.begin(), a.begin()+n/2);\n    vector<int> c(a.begin()+n/2, a.end());\n    mergesort(b,rh);\n    mergesort(c,rh);\n    for (int i=0,j=0,k=0;i<n;i++){\n      if(k == SZ(c))a[i]=b[j++];\n      else if(j==SZ(b))a[i]=c[k++];\n      else if(rh.cmp(b[j],c[k]))a[i]=b[j++];\n      else a[i] = c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  //sort(ALL(sa),rh);\n  mergesort(sa,rh);\n  //if(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    int c=(a+b)/2;\n    if(S.compare(sa[c],T.length(),T)<0 )a=c;\n    else b=c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  while(n--){\n    cin >> t;\n    cout << contain(s,sa,t) << \"\\n\";\n    //cout << !!rh.find(t) << \"\\n\";\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=(ull *)malloc(2*n+1);\n    phash=(ull *)malloc(2*n+1);\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }  \n};\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  const int n = SZ(a);\n  if(n>1){\n    vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(b,rh), mergesort(c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==SZ(c))a[i]=b[j++];\n      else if(j==SZ(b))a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  mergesort(sa,rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000000];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nnamespace SA{\n    const int MAX=100000;\n    int N,K;\n    int tmp[MAX+1],rank[MAX+1];\n    bool compare_sa(int i,int j){\n        if(rank[i]!=rank[j])return rank[i]<rank[j];\n        else{\n            int ri=(i+K<=N)?rank[i+K]:-1;\n            int rj=(j+K<=N)?rank[j+K]:-1;\n            return ri<rj;\n        }\n    }\n\n    vector<int> construct_sa(string S){\n        N=S.size();\n        vector<int>sa(N+1);\n        for(int i=0;i<=N;i++)sa[i]=i;\n        for(int i=0;i<=N;i++){\n            rank[i]=i==N?-1:S[i];\n        }\n\n        for(K=1;K<=N;K*=2){\n            sort(sa.begin(),sa.end(),compare_sa);\n            tmp[sa[0]]=0;\n            for(int i=1;i<=N;i++){\n                tmp[sa[i]]=tmp[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n            }\n            for(int i=0;i<=N;i++)rank[i]=tmp[i];\n        }\n        return sa;\n    }\n}\n\nstring S;\nvint sa;\nint Q;\n\nbool exist(string T){\n\n\n    /*\n    int lb=0,ub=S.size();\n    while(ub-lb>1){\n        int mid=(ub+lb)/2;\n        if(S.substr(sa[mid],min(S.size()-mid,T.size()))<T)lb=mid;\n        else ub=mid;\n    }\n    if(ub<=S.size()&&S.size()-sa[ub]>=T.size()&&S.substr(sa[ub],T.size())==T)return true;\n    return false;\n    */\n}\n\nbool contain(string &S,vint &sa,string &T){\n    int a=0,b=S.size();\n    while(b-a>1){\n        int c=(a+b)/2;\n        if(S.compare(sa[c],T.size(),T)<0)a=c;\n        else b=c;\n    }\n    return S.compare(sa[b],T.size(),T)==0;\n}\n\nsigned main(){\n    cin>>S;\n    sa=SA::construct_sa(S);\n    cin>>Q;\n\n    rep(i,sa.size())cout<<S.substr(sa[i],S.size()-sa[i])<<endl;\n\n    while(Q--){\n        string T;cin>>T;\n        if(contain(S,sa,T))cout<<1<<endl;\n        else cout<<0<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nclass SA_IS\n{\nprivate:\n    using byte = unsigned char;\n    byte mask[8] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };\n    #define tget(i) !!(t[(i)>>3]&mask[(i)&7])\n    #define tset(i, b) t[(i)>>3]=(b) ? (mask[(i)&7]|t[(i)>>3]) : ((~mask[(i)&7])&t[(i)>>3])\n    #define chr(i) (cs==sizeof(int)?((int*)s)[i]:((byte *)s)[i])\n    #define isLMS(i) (i>0 && tget(i) && !tget(i-1))\n    void getBuckets(byte *s, int *bkt, int n, int K, int cs, bool end=true){\n        fill(bkt, bkt + K + 1, 0);\n        for(int i = 0; i < n; i++){\n            bkt[chr(i)]++;\n        }\n        for(int i = 0,tmp = 0; i < K+1; i++){\n            tmp += bkt[i];\n            bkt[i] = end ? tmp : tmp - bkt[i];\n        }\n    }\n    void induceSAl(byte *t, byte *s, int *bkt, int n, int K, int cs){\n        getBuckets(s, bkt, n, K, cs, false);\n        for(int i = 0; i < n; i++){\n            if(sa[i]>0 && !tget(sa[i]-1)){\n                sa[bkt[chr(sa[i]-1)]++] = sa[i]-1;\n            }\n        }\n    }\n    void induceSAs(byte *t, byte *s, int *bkt, int n, int K, int cs){\n        getBuckets(s, bkt, n, K, cs, true);\n        for(int i = n-1; i >= 0; i--){\n            if(sa[i] > 0 && tget(sa[i]-1)){\n                sa[--bkt[chr(sa[i]-1)]] = sa[i]-1;\n            }\n        }\n    }\n    void solve(byte *s, int n, int K=128, int cs=1){\n        byte t[(n >> 3)+1];\n        int bkt[K+1], n1 = 0, name = 0;\n        tset(n-2, 0), tset(n-1, 1);\n        for(int i = n - 3; i >=0; i--){\n            tset(i, (chr(i)<chr(i+1) || (chr(i)==chr(i+1) && tget(i+1))));\n        }\n        getBuckets(s, bkt, n, K, cs);\n        fill(sa, sa+n, -1);\n        for(int i = 1; i < n; i++){\n            if(isLMS(i)){\n                sa[--bkt[chr(i)]] = i;\n            }\n        }\n        induceSAl(t, s, bkt, n, K, cs);\n        induceSAs(t, s, bkt, n, K, cs);\n        for(int i = 0; i < n; i++){\n            if(isLMS(sa[i])){\n                sa[n1++] = sa[i];\n            }\n        }\n        fill(sa + n1, sa + n, -1);\n        for(int i = 0, tmp = -1; i < n1; i++){\n            int pos = sa[i], diff = false;\n            for(int d = 0; d < n && !diff; d++){\n                diff = chr(pos+d) != chr(tmp+d) || tget(pos+d) != tget(tmp+d);\n                if(!diff && d && (isLMS(pos+d) || isLMS(tmp+d))) break;\n            }\n            if(diff){\n                name++, tmp = pos;\n            }\n            sa[n1+((pos - (pos & 1)) >> 1)] = name - 1;\n        }\n        int* s1 = sa + n - n1;\n        for(int i = n - 1,j = n - 1; i >= n1; i--){\n            if(sa[i] >= 0){\n                sa[j--] = sa[i];\n            }\n        }\n        if(name < n1){\n            solve((byte*)s1, n1, name - 1, sizeof(int));\n        }else{\n            for(int i = 0; i < n1; i++){\n                sa[s1[i]] = i;\n            }\n        }\n        getBuckets(s, bkt, n, K, cs);\n        for(int i = 1, j = 0; i < n; i++){\n            if(isLMS(i)){\n                s1[j++] = i;\n            }\n        }\n        for(int i = 0; i < n1; i++){\n            sa[i] = s1[sa[i]];\n        }\n        fill(sa + n1, sa + n, -1);\n        for(int i = n1 - 1; i >= 0; i--){\n          int tmp = sa[i];\n          sa[i] = -1, sa[--bkt[chr(tmp)]] = tmp;\n        }\n        induceSAl(t, s, bkt, n, K, cs);\n        induceSAs(t, s, bkt, n, K, cs);\n    }\npublic:\n    bool contain(const string& T){\n        int a = 0, b = sz;\n        while(b - a > 1){\n            int c = (a + b) / 2;\n            if(CS.compare(sa[c], T.length(), T) < 0){\n                a = c;\n            }else{\n                b = c;\n            }\n        }\n        return CS.compare(sa[b], T.length(), T) == 0;\n    }\n    string CS;\n    byte* S;\n    int sz;\n    int* sa;\n    SA_IS(string& arg){\n        CS = arg;\n        sz = (int)arg.size();\n        sa = new int[sz+1];\n        S = (byte*)arg.c_str();\n        solve(S, sz+1);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    SA_IS sa(s);\n    int n;\n    cin >> n;\n    rep(i,n){\n        string t;\n        cin >> t;\n        cout << sa.contain(t) << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nstatic const int NUM_CHILDREN = 26;\nstatic const char MIN_CHAR = 'a';\n\nstruct Trie {\n    vector<int> nums;\n    bool visited;\n    Trie *next[NUM_CHILDREN];\n    Trie() : visited(false) {\n        fill(next, next + NUM_CHILDREN, (Trie*)0);\n    }\n};\n\nvoid construct(Trie *trie, const vector<string> &strings) {\n    rep(i, strings.size()) {\n        Trie *p = trie;\n        for (auto c : strings[i]) {\n            int idx = c - MIN_CHAR;\n            if (!p->next[idx]) p->next[idx] = new Trie;\n            p = p->next[idx];\n        }\n        p->nums.emplace_back(i);\n    }\n}\n\nvoid dump(Trie* p, string s) {\n    if (!p->nums.empty()) {\n        cerr << \"s = \" << s << \", nums = {\";\n        for (auto num : p->nums) {\n            cerr << num << \", \";\n        }\n        cerr << endl;\n    }\n    for (int i = 0; i < NUM_CHILDREN; ++i) {\n        if (p->next[i]) {\n            dump(p->next[i], s + char(i + MIN_CHAR));\n        }\n    }\n}\n\nvoid search(Trie* trie, const string &s, vector<bool> &exist) {\n    // cerr << \"s = \" << s << endl;\n    Trie *p = trie;\n    for (auto c : s) {\n        int idx = c - MIN_CHAR;\n        if (!p->next[idx]) return;\n        p = p->next[idx];\n        // cerr << \"c = \" << c << endl;\n        if (!p->visited && !p->nums.empty()) {\n            // cerr << \"s = \" << s << \", c = \" << c << endl;\n            p->visited = true;\n            for (auto num : p->nums) {\n                exist[num] = true;\n            }\n        }\n    }\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    string s;\n    cin >> s;\n    int q;\n    cin >> q;\n    vector<string> strings(q);\n    rep(i, q) cin >> strings[i];\n\n    Trie *trie = new Trie;\n\n    construct(trie, strings);\n\n    // dump(trie, \"\");\n\n    vector<bool> exist(q);\n\n    rep(i, s.size()) {\n        search(trie, s.substr(i), exist);\n    }\n\n    rep(i, q) {\n        cout << exist[i] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstdio>\n#include<cmath>\n#include<deque>\n#include<numeric>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<limits>\n#include<functional>\n#include<unordered_set>\n#include<iomanip>\n#include<cassert>\n#include<regex>\n#include<bitset>\n#include<complex>\n#include<chrono>\n#include<random>\n#define rep(i,a) for(int i=(int)0;i<(int)a;++i)\n#define rrep(i,a) for(int i=(int)a-1;i>=0;--i)\n#define REP(i,a,b) for(int i=(int)a;i<(int)b;++i)\n#define RREP(i,a,b) for(int i=(int)a-1;i>=b;--i)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(),x.end()\nusing ll=long long;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll INF = 1LL << 60;\n\nll gcd(ll n, ll m) {\n\tll tmp;\n\twhile (m!=0) {\n\t\ttmp = n % m;\n\t\tn = m;\n\t\tm = tmp;\n\t}\n\treturn n;\n}\n\nll lcm(ll n, ll m) {\n\treturn abs(n) / gcd(n, m)*abs(m);//gl=xy\n}\n \ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n \nusing namespace std;\n\nstruct SuffixArray{\n  const string str;\n  vector<int>sa;//接尾辞配列\n  vector<int>rank;//何番目に小さいか\n  vector<int>tmp;\n\n  SuffixArray(const string& s):str(s){//構築 O(N(log N)^2)\n    int n=s.size();\n    int k=1;\n    sa=vector<int>(n+1);\n    rank=vector<int>(n+1);\n    tmp=vector<int>(n+1);\n\n    for(int i=0;i<=n;++i){\n      sa[i]=i;//1文字から構築\n      rank[i]=i<n?str[i]:-1;//ランクは文字コードに\n    }\n    auto comp=[&](int i,int j){//(rank[i],rank[i+k])と(rank[j],rank[j+k])を比較\n      if(rank[i]!=rank[j])return rank[i]<rank[j];\n      else return (i+k<=n?rank[i+k]:-1)<(j+k<=n?rank[j+k]:-1);\n    };\n    for(k=1;k<=n;k*=2){//k文字ソートされているところから2k文字でソートする\n      sort(sa.begin(),sa.end(),comp);\n\n      tmp[sa[0]]=0;\n      for(int i=1;i<=n;++i)tmp[sa[i]]=tmp[sa[i-1]]+(comp(sa[i-1],sa[i])?1:0);\n      for(int i=0;i<=n;i++)rank[i]=tmp[i];\n    }\n  }\n\n  bool search(const string& t){\n    int a=0,b=str.size();\n    while(b-a>1){\n      int c=(a+b)/2;\n      if(str.compare(sa[c],t.size(),t)<0)a=c;//strのsa[c]文字目から|T|文字目までとTを比較\n      else b=c;\n    }\n    return str.compare(sa[b],t.size(),t)==0;\n  }\n};\n\nvoid solve(){\n  string s;\n  cin>>s;\n  SuffixArray sa(s);\n  int q;\n  cin>>q;\n  while(q--){\n    string t;\n    cin>>t;\n    if(sa.search(t))cout<<1<<\"\\n\";\n    else cout<<0<<\"\\n\";\n  }\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n  cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n  solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nll n,k;\nvector<ll> Rank;\nvector<ll> tmp;\nvector<ll> sa;\nstring str;\n\n\nbool less_cmp(ll a,const string &s){\n    for(ll i=a;i<a+s.size();i++){\n        if(i>=n){return true;}\n        if(str[i]!=s[i-a]){return str[i]<s[i-a];}\n    }\n    return false;\n}\n\nbool equal_cmp(ll a,const string &s){\n    for(ll i=0;i<s.size();i++){\n        if(i+a>=n){return false;}\n        if(str[i+a]!=s[i]){return false;}\n    }\n    return true;\n}\n\nbool cmp(ll i,ll j){\n    if(Rank[i]!=Rank[j]){return Rank[i]<Rank[j];}\n    return (i+k<=n?Rank[i+k]:-1)<(i+j<=n?Rank[j+k]:-1);\n}\n\nvoid build(const string &s){\n    n=s.size();\n    sa.resize(n+1);\n    Rank.resize(n+1);\n    tmp.resize(n+1);\n    for(int i=0;i<=n;i++){\n        sa[i]=i;\n        Rank[i]=i<n?s[i]:-1;\n    }\n    for(k=1;k<=n;k++){\n        sort(sa.begin(),sa.end(),cmp);\n        tmp[sa[0]]=0;\n        for(int i=1;i<=n;i++){\n            tmp[sa[i]]=tmp[sa[i-1]]+(cmp(sa[i-1],sa[i])?1:0);\n        }\n        for(int i=0;i<=n;i++){\n            Rank[i]=tmp[i];\n        }\n    }\n}\n\n\nbool search(const string &s){\n    ll l=0,r=n;\n    while(r-l>=10){\n        ll m=l+(r-l)/2;\n        if(less_cmp(sa[m],s)){l=m+1;}\n        else{r=m;}\n    }\n    for(ll i=l;i<=r;i++){\n        if(equal_cmp(sa[i],s)){return true;}\n    }\n    return false;\n}\n\n\n\n\nint main(){\n    cin>>str;\n    build(str);\n    ll q;\n    cin>>q;\n    while(q--){\n        string p;\n        cin>>p;\n        cout<<search(p)<<endl;\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <bitset>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#define IINF 10e8\n#define INF 1<<30\n#define MOD 1000000007\n#define mod 1000000007\n#define REP(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define REPE(i, a, n) for (ll i = a; i <= (ll)(n); i++)\n#define Endl endl\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define eb emplace_back\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define siz(x) (ll)(x).size()\n#define PI acos(-1.0)\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef long double ld;\ntypedef pair<int,int>Pin;\ntypedef pair<ll,ll>Pll;\ntemplate<class T> using V=vector<T>;\nlong long GCD(long long a, long long b) {return b?GCD(b,a%b):a;}\nlong long LCM(long long a, long long b) {return a/GCD(a,b)*b;}\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nint ddx[8]={-1,0,1,0,1,1,-1,-1};\nint ddy[8]={0,-1,0,1,1,-1,1,-1};\nll cmp(pair<ll,ll>a,pair<ll,ll> b){\n        if(a.se!=b.se)\n        return a.se<b.se;\n        else\n        return a.fi<b.fi;\n}\n//----------------------------------------------------------------------\nint n,k;\nint rank_[1000010];\nint tmp[1000010];\nbool compare_sa(int i,int j){\n    if(rank_[i]!=rank_[j])return rank_[i]<rank_[j];\n    else{\n        int ri=i+k<=n?rank_[i+k]:-1;\n        int rj=j+k<=n?rank_[j+k]:-1;\n        return ri<rj;\n    }\n}\nvoid construct_sa(string S,int *sa){\n    n=S.length();\n    for(int i=0;i<=n;i++){\n        sa[i]=i;\n        rank_[i]=i<n?S[i]:-1;\n    }\n    for(k=1;k<=n;k*=2){\n        sort(sa,sa+n+1,compare_sa);\n\n        tmp[sa[0]]=0;\n        for(int i=1;i<=n;i++){\n            tmp[sa[i]]=tmp[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n        }\n        for(int i=0;i<=n;i++){\n            rank_[i]=tmp[i];\n        }\n    }\n}\n\nbool contain(string S, int *sa, string T){\n    int a=0,b=S.length();\n    while(b-a>1){\n        int c=(a+b)/2;\n        if(S.compare(sa[c],T.length(),T)<0)a=c;\n        else b=c;\n    }\n    return S.compare(sa[b],T.length(),T)==0;\n}\n//----------------------------------------------------------------------\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------  \n    //ll begin_time=clock();\n    //-------------------------------\n    string S;cin>>S;\n    int *sa=new int[S.length()+1];\n    construct_sa(S,sa);\n    int cnt;cin>>cnt;\n    while(cnt--){\n        string T;cin>>T;\n        cout<<contain(S,sa,T)<<endl;\n    }\n    \n    //-------------------------------  \n    //ll end_time=clock();cout<<\"time=\"<<end_time-begin_time<<\"ms\"<<endl;\n    //-------------------------------\n    return 0;\n}\n//----------------------------------------------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\ntypedef unsigned long long int ull;\n\nclass RollingHash{\npublic:\n  RollingHash(std::string _s):s(_s){};\n  std::vector<int> search(std::string p);\n  \nprivate:\n  ull PatternHash(std::string s);\n  void Hashing(int m);\n  std::string s;\n  std::vector<ull> rh;//???????????\\??????????´??????????vector\n  int length = 0;//?¨???¶???????????????????????\\??????????????????\n};\n\n\nstd::vector<int> RollingHash::search(std::string p){\n  if(p.length() != length){\n    Hashing(p.length());\n    length = p.length();\n  }\n  ull pHash = PatternHash(p);\n  std::vector<int> res;\n  for (int i = 0; i < s.length() - length + 1; i++) {\n    if(pHash == rh[i]){\n      res.push_back(i);\n    }\n  }\n  return res;\n}\n\null RollingHash::PatternHash(std::string s){\n  ull base = 1e9 + 7, res = 0;\n  for (int i = 0; i < s.length(); i++) {\n    res *= base;\n    res += s[i];\n  }\n  return res;\n}\n\nvoid RollingHash::Hashing(int m){\n  rh.clear();\n  int n = s.length();\n  if(n < m)return;\n  rh.resize(n - m + 1, 0);\n  ull base = 1e9 + 7, t = 1;\n  for (int i = m - 1; i >= 0; i--) {\n    rh[0] += t*s[i];\n    t *= base;\n  }\n  for (int i = 1; i <= n - m; i++) {\n    rh[i] = rh[i - 1]*base + s[i + m - 1] - s[i - 1]*t;\n  }\n}\n\nint main(){\n  string s, t;\n  int q;\n  std::cin >> s >> q;\n  RollingHash rh(s);\n  for (int i = 0; i < q; i++) {\n    std::cin >> t;\n    vector<int> ans = rh.search(t);\n    if(ans.size() == 0){\n      std::cout << 0 << std::endl;\n    }else{\n      std::cout << 1 << std::endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n/2+n%2,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==nc)a[i]=b[j++];\n      else if(j==nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  /*\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n  */\n  int sa[rh.n+2];\n  REP(i,rh.n+1)sa[i]=i;\n  sort(sa,sa+rh.n+1,rh);\n  vector<int>res(rh.n+1);\n  REP(i,rh.n+1)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl codeforces\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pii = std::pair<int, int>;\nusing tii = std::tuple<int, int, int>;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, std::size_t s, Tail... tail) { auto v = std::move(make_v(init, tail...)); return vec<decltype(v)>(s, v); }\ntemplate <typename T, std::size_t Head, std::size_t ...Tail> struct multi_dem_array { using type = std::array<typename multi_dem_array<T, Tail...>::type, Head>; };\ntemplate <typename T, std::size_t Head> struct multi_dem_array<T, Head> { using type = std::array<T, Head>; };\ntemplate <typename T, std::size_t ...Args> using mdarray = typename multi_dem_array<T, Args...>::type;\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n\nnamespace strings {\n\nclass SuffixArray {\n    vec<ll> sa, beg_idx;\n    std::string s__;\n    const std::size_t alp = 256;\n\n    vec<ll> build_init() {\n        vec<ll> cls(sa.size());\n        beg_idx = vec<ll>(std::max<ll>(sa.size(), alp) + 2, 0);\n        for (char c : s__) beg_idx[c + 1]++;\n        for (ll i = 0; i + 1 < beg_idx.size(); i++) beg_idx[i + 1] += beg_idx[i];\n        for (ll i = 0; i < size(); i++) {\n            char c = s__[i];\n            sa[beg_idx[c]++] = i;\n        }\n        \n        ll max_cls = 0;\n        for (ll i = 0; i < size(); i++) {\n            if (i) {\n                char c1 = s__[sa[i - 1]];\n                char c2 = s__[sa[i]];\n                max_cls += (c1 != c2);\n            }\n            cls[sa[i]] = max_cls;\n        }\n        return cls;\n    }\n\n    void build_step(ll len, vec<ll> &cls) {\n        vec<ll> buf(cls.size());\n        for (ll i = 0; i < sa.size(); i++) {\n            auto idx = sa[i] - len / 2;\n            if (idx < 0) idx = sa.size() + idx;\n            buf[i] = idx;\n        }\n        std::fill(ALL(beg_idx), 0);\n        for (ll i = 0; i < size(); i++) beg_idx[cls[i] + 1]++;\n        for (ll i = 0; i + 1 < beg_idx.size(); i++) beg_idx[i + 1] += beg_idx[i];\n        for (ll i = 0; i < size(); i++) {\n            ll b = buf[i];\n            ll c = cls[b];\n            sa[beg_idx[c]++] = b;\n        }\n\n        auto get_cls = [&](ll idx) {\n            ll fst = cls[idx];\n            ll snd_idx = idx + len / 2;\n            return std::make_pair(fst, cls[snd_idx % sa.size()]);\n        };\n\n        ll max_cls = 0;\n        for (ll i = 0; i < size(); i++) {\n            if (i) {\n                ll cur = sa[i];\n                ll pre = sa[i - 1];\n                max_cls += get_cls(cur) != get_cls(pre);\n            }\n            buf[sa[i]] = max_cls;\n        }\n        cls = std::move(buf);\n    }\n\n    ll lower_bound_ok(const std::string &oth) const {\n        ll ok = 0, ng = size();\n        while (abs(ok - ng) > 1) {\n            ll mid = (ok + ng) / 2;\n            (comp(oth, sa[mid], 0) == -1 ? ok : ng) = mid;\n        }\n        return ok + 1;\n    }\n\n    ll upper_bound_ok(const std::string &oth) const {\n        ll ok = 0, ng = size();\n        while (abs(ok - ng) > 1) {\n            ll mid = (ok + ng) / 2;\n            (comp(oth, sa[mid], 0) <= 0 ? ok : ng) = mid;\n        }\n        return ok + 1;\n    }\n\n    ll lower_bound(const std::string &oth, ll comped) const {\n        if (0 <= comped) return 0;\n        return lower_bound_ok(oth);\n    }\n\n    ll upper_bound(const std::string &oth, ll comped) const {\n        if (comped == 0) return 1;\n        if (comped == 1) return 0;\n        return upper_bound_ok(oth);\n    }\n\n    ll ceil_pow2(ll n) {\n        ll ret = 1;\n        while (ret < n) ret *= 2;\n        return ret;\n    }\n\npublic:\n    SuffixArray(std::string str) : s__(str) {\n        auto tmp = s__;\n        s__ += static_cast<char>(0);\n        ll pow2 = ceil_pow2(s__.size());\n        ll diff = pow2 - s__.size();\n        s__ += std::string(diff, 0); \n        sa.resize(pow2);\n        auto cls = std::move(build_init());\n        for (ll len = 2; len < size(); len *= 2) build_step(len, cls);\n        std::reverse(ALL(sa));\n        sa.erase(sa.end() - (pow2 - tmp.size()), sa.end());\n        std::reverse(ALL(sa));\n        s__ = std::move(tmp);\n    }\n\n    ll operator [](ll idx) const {\n        return sa[idx];\n    }\n\n    size_t size() const {\n        return sa.size();\n    }\n\n    const std::string& str() const {\n        return s__;\n    }\n\n    // -1 : str < oth\n    //  0 : str == oth\n    //  1 : str > oth\n    ll comp(const std::string &oth, ll s, ll t) const {\n        for (; s < size() && t < oth.size(); s++, t++) {\n            if (s__[s] == oth[t]) continue;\n            return (s__[s] < oth[t] ? -1 : 1);\n        }\n        if (s == size() && t == oth.size()) return 0;\n        else return (s < size() ? 1 : -1);\n    }\n\n    ll lower_bound(const std::string &oth) const {\n        return lower_bound(oth, comp(oth, sa[0], 0));\n    }\n\n    ll upper_bound(const std::string &oth) const {\n        return upper_bound(oth, comp(oth, sa[0], 0));\n    }\n};\n\n}\n\nint main() {\n    std::string t;\n    std::cin >> t;\n    strings::SuffixArray sa(t);\n\n    ll q;\n    std::cin >> q;\n\n    auto query = [&](const std::string &p) {\n        ll l = sa.lower_bound(p);\n        if (l == sa.size()) return false;\n        ll si = sa[l], pi = 0;\n        for (; si < t.size() && pi < p.size(); si++, pi++) if (t[si] != p[pi]) return false;\n        return pi == p.size();\n    };\n\n    while (q--) {\n        std::string p;\n        std::cin >> p;\n        std::cout << (query(p) ? 1 : 0) << '\\n';\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int mb=n/2,mc=n/2+n%2,b[mb],c[mc];\n    REP(i,mb)b[i]=a[i];\n    REP(i,mc)c[i]=a[mb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(mb,b,rh), mergesort(mc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==mc)a[i]=b[j++];\n      else if(j==mb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,rh.n+1)sa[i]=i;\n  mergesort(n-1,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000000];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n\nusing namespace std;\n\n#define NUM 48\n\nint checkTable[10000]={0};\n\nclass Node{\npublic:\n\tNode(){\n\t\tch=0;\n\t\tnum_of_child=num_of_end_str=0;\n\t\tparent=0;\n\t\tcameFLG=false;\n\t\ttable=new int[128-NUM];\n\t\tfor(int i=48;i<=122;i++)table[i-NUM]=-1;\n\t}\n\n\tvoid addSTR(char str[],int ptn_index){\n\t\tint index=0;\n\t\tNode* tmp=this;\n\t\twhile(true){\n\t\t\tif(str[index+1]=='\\0'){\n\t\t\t\ttmp->end_str.push_back(ptn_index);\n\t\t\t\ttmp->num_of_end_str++;\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tif(tmp->table[str[index+1]-NUM]==-1){\n\t\t\t\t\tNode* new_node=new Node();\n\t\t\t\t\tnew_node->parent=tmp;\n\t\t\t\t\tnew_node->ch=str[index+1];\n\t\t\t\t\ttmp->nodes.push_back(new_node);\n\t\t\t\t\ttmp->table[str[index+1]-NUM]=tmp->num_of_child;\n\t\t\t\t\ttmp->num_of_child++;\n\t\t\t\t}\n\t\t\t\ttmp=tmp->nodes[tmp->table[str[index+1]-NUM]];\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n\tbool searchSTR(char str[],int index){\n\t\tNode* tmp=this;\n\t\twhile(true){\n\t\t\tif(!tmp->cameFLG){\n\t\t\t\tfor(int i=0;i<tmp->num_of_end_str;i++)checkTable[tmp->end_str[i]]=1;\n\t\t\t\ttmp->cameFLG=true;\n\t\t\t}\n\t\t\tif(tmp->num_of_child==0){\n\t\t\t\tif(tmp->parent != 0){\n\t\t\t\t\tNode* parent=tmp->parent;\n\t\t\t\t\tparent->num_of_child--;\n\t\t\t\t\tparent->table[tmp->ch-NUM]=-1;\n\t\t\t\t\twhile(parent->parent!=0&&parent->num_of_child==0){\n\t\t\t\t\t\tparent->parent->num_of_child--;\n\t\t\t\t\t\tparent->parent->table[parent->ch-NUM]=-1;\n\t\t\t\t\t\tparent=parent->parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\tif(str[index+1]=='\\0')return true;\n\t\t\t\telse{\n\t\t\t\t\tif(tmp->table[str[index+1]-NUM]!=-1){\n\t\t\t\t\t\ttmp=tmp->nodes[tmp->table[str[index+1]-NUM]];\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\t//must not reach here.\n\t}\n\tint num_of_child;\n\tint num_of_end_str;\n\tvector<int> end_str;\n\tvector<Node*> nodes;\n\tNode* parent;\n\tint* table;\n\tchar ch;\n\tbool cameFLG;\n};\n\n\n\nclass MotherNode{\npublic:\n\tMotherNode(){\n\t\tmotherNode = new Node*[128-NUM];\n\t\tfor(int i=48;i<=122;i++){\n\t\t\tmotherNode[i-NUM]=new Node();\n\t\t\tmotherNode[i-NUM]->ch=i;\n\t\t}\n\t}\n\tvoid addSTR(char str[],int ptn_index){\n\t\tmotherNode[str[0]-NUM]->addSTR(str,ptn_index);\n\t}\n\tbool searchSTR(char str[]){\n\t\treturn motherNode[str[0]-NUM]->searchSTR(str,0);\n\t}\nprivate:\n\tNode** motherNode;\n};\n\nint main(){\n\n\tchar* T = new char[1000001];\n\tint Q,T_length=0;\n\tscanf(\"%s\",T);\n\tscanf(\"%d\",&Q);\n\tchar* P = new char[1001];\n\tMotherNode motherNode;\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\"%s\",P);\n\t\tmotherNode.addSTR(P,i);\n\t}\n\tfor(int i=0;T[i]!='\\0';i++)T_length++;\n\tchar tmp[1001];\n\tfor(int i=0;i<T_length;i++){\n\t\tfor(int k=0;k<1001;k++)tmp[k]='\\0';\n\t\tfor(int k=0;T[i+k]!='\\0'&&k<1000;k++){\n\t\t\ttmp[k]=T[i+k];\n\t\t\tif(motherNode.searchSTR(tmp)==false)break;\n\t\t}\n\t}\n\tfor(int i=0;i<Q;i++){\n\t\tif(checkTable[i]==0)printf(\"0\\n\");\n\t\telse{\n\t\t\tprintf(\"1\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n#include<cstdlib>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow, *phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow = (ull*)malloc(n+1);\n    phash = (ull*)malloc(n+1);\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  //~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }  \n};\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  const int n = SZ(a);\n  if(n>1){\n    vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(b,rh), mergesort(c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==SZ(c))a[i]=b[j++];\n      else if(j==SZ(b))a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  mergesort(sa,rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000000];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, k;\nstring s;\nvector<int> order;\nvector<int> tmp;\nvector<int> sa;\n\nbool compare_sa(const int &i, const int &j)\n{\n  if(order[i] != order[j]) return order[i] < order[j];\n  else\n  {\n    int ri = i + k <= n ? order[i+k] : -1;\n    int rj = j + k <= n ? order[j+k] : -1;\n    return ri < rj;\n  }\n}\n\nvoid construct_sa()\n{\n  for(int i = 0; i <= n; i++)\n  {\n    sa[i] = i;\n    order[i] = i < n ? s[i] : -1;\n  }\n  for(k = 1; k <= n; k*=2)\n  {\n    sort(sa.begin(),sa.end(),compare_sa);\n    tmp[sa[0]] = 0;\n    for(int i = 1; i <= n; i++)\n      tmp[sa[i]] = tmp[sa[i-1]] + (compare_sa(sa[i-1],sa[i])?1:0);\n    for(int i = 0; i <= n; i++)\n      order[i] = tmp[i];\n  }\n}\n\nvoid init()\n{\n  n = s.size();\n  order.resize(n+1);\n  tmp.resize(n+1);\n  sa.resize(n+1);\n  construct_sa();\n}\n\nbool contain(string t)\n{\n  int l=0, r=n;\n  while(r-l>1)\n  {\n    int m = (l+r)/2;\n    if(s.compare(sa[m],t.size(),t)<0) l = m;\n    else r = m;\n  }\n  return s.compare(sa[r],t.size(),t) == 0;\n}\n\nint main(){\n\n\tcin >> s;\n\tstring t;\n\tint q ; cin >> q;\n\tinit();\n\tconstruct_sa ();\n\tfor (int i = 0; i < q; ++i)\n\t {\n\t \tcin >> t;\n\t \tcout << contain(t) << endl;\n\t } \n\t return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nclass SuffixArrayInducedSorting\n{\nprivate:\n    static constexpr int encode(const int c) { return c == '$' ? 0 : '0' <= c and c <= '9' ? c - '0' + 1 : 'A' <= c and c <= 'Z' ? c - 'A' + 11 : c - 'a' + 37; }\n    static constexpr char decode(const int n) { return (n == 0 ? '$' : n <= 10 ? '0' + n - 1 : n <= 36 ? 'A' + n - 11 : 'a' + n - 37); }\n    enum class Type : char {\n        L = 0,\n        S = 1,\n        LMS = 2,\n    };\n\npublic:\n    SuffixArrayInducedSorting(const string& s, const int kind_) : N(s.size() + 1), kind{kind_ + 1}, S(s.size() + 1, 0), type(N), next(N, 1), bucket(kind), num(kind, 0), head(kind, 0), tail(kind, 0)\n    {\n        for (int i = 0; i < s.size(); i++) {\n            S[i] = encode(s[i]);\n        }\n        initializeData();\n        sortLMS();\n    }\n    SuffixArrayInducedSorting(const vector<int>& s, const int kind_) : N(s.size() + 1), kind{kind_ + 1}, S(s), type(N), next(N, 1), bucket(kind), num(kind, 0), head(kind, 0), tail(kind, 0)\n    {\n        S.push_back(0);\n        initializeData();\n        sortLMS();\n    }\n    void debugPrint() const\n    {\n        for (int i = 0; i < N; i++) {\n            cout << decode(S[i]);\n        }\n        cout << endl;\n        for (int i = 0; i < N; i++) {\n            cout << (type[i] == Type::L ? \"L\" : \"S\");\n        }\n        cout << endl;\n        for (int i = 0; i < N; i++) {\n            cout << (type[i] == Type::LMS ? \"@\" : \" \");\n        }\n        cout << endl;\n        for (int i = 0; i < kind; i++) {\n            if (bucket[i].empty())\n                continue;\n            cout << \"[\" << decode(i) << \"]:\\n\";\n            for (const int p : bucket[i]) {\n                cout << \"  \" << p << endl;\n            }\n        }\n    }\n\n    vector<int> getSuffixArray() const\n    {\n        vector<int> ans(N - 1);\n        for (int pos = 0, i = 1; i < kind; i++) {  // 番兵以外\n            for (const int p : bucket[i]) {\n                ans[pos++] = p;\n            }\n        }\n        return ans;\n    }\n\nprivate:\n    void initializeData()\n    {\n        for (const int i : S) {\n            num[i]++;\n        }\n        for (int i = 0; i < kind; i++) {\n            bucket[i].resize(num[i], -1);\n            tail[i] = num[i] - 1;\n        }\n        type[N - 1] = Type::S;\n        for (int i = N - 2; i >= 0; i--) {\n            type[i] = (S[i] != S[i + 1] ? (S[i] < S[i + 1] ? Type::S : Type::L) : type[i + 1]);\n            if (type[i] == Type::L and type[i + 1] == Type::S) {\n                type[i + 1] = Type::LMS;\n                LMS.push_back(i + 1);\n            }\n        }\n        for (int pos = N - 1, i = N - 2; i >= 0; i--) {\n            next[i] = pos;\n            if (type[i] == Type::LMS) {\n                pos = i;\n            }\n        }\n    }\n\n    void sortLMS()\n    {\n        for (const int l : LMS) {\n            insertTail(l);\n        }\n        induce();\n        vector<int> lms;\n        for (int i = 0; i < kind; i++) {\n            for (const int p : bucket[i]) {\n                if (type[p] == Type::LMS) {\n                    lms.push_back(p);\n                }\n            }\n        }\n        const int size = lms.size();\n        vector<int> order(N / 2 + 1, 0);\n        int number = 1;\n        order[N / 2] = 1;\n        bool same = false;\n        for (int i = 1; i < size; i++) {\n            const int l1 = lms[i - 1];\n            const int r1 = next[l1];\n            const int l2 = lms[i];\n            const int r2 = next[l2];\n            if (r1 - l1 == r2 - l2 and vector<int>(S.begin() + l1, S.begin() + r1 + 1) == vector<int>(S.begin() + l2, S.begin() + r2 + 1)) {\n                same = true;\n            } else {\n                number++;\n            }\n            order[l2 / 2] = number;\n        }\n        if (same) {\n            vector<int> s(size);\n            for (int p = 0, i = 0; i <= N / 2; i++) {\n                if (order[i] > 0) {\n                    s[p++] = order[i];\n                }\n            }\n            const vector<int> sorted = SuffixArrayInducedSorting{s, number}.getSuffixArray();\n            for (int i = 0; i < kind; i++) {\n                head[i] = 0;\n                tail[i] = num[i] - 1;\n            }\n            for (int i = size - 1; i >= 0; i--) {\n                insertTail(LMS[size - 1 - sorted[i]]);\n            }\n            induce();\n        } else {\n            for (int i = 0; i < kind; i++) {\n                head[i] = 0;\n                tail[i] = num[i] - 1;\n            }\n            for (int i = size - 1; i >= 0; i--) {\n                insertTail(lms[i]);\n            }\n            induce();\n        }\n    }\n\n    void induce()\n    {\n        for (int i = 0; i < kind; i++) {\n            for (int j = 0; j < head[i]; j++) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] == Type::L) {\n                    insertHead(p - 1);\n                }\n            }\n            for (int j = tail[i] + 1; j < num[i]; j++) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] == Type::L) {\n                    insertHead(p - 1);\n                }\n            }\n        }\n        for (int i = 1; i < kind; i++) {  // 番兵以外\n            tail[i] = num[i] - 1;\n        }\n        for (int i = kind - 1; i >= 0; i--) {\n            for (int j = num[i] - 1; j > tail[i]; j--) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] != Type::L) {\n                    insertTail(p - 1);\n                }\n            }\n            for (int j = head[i] - 1; j >= 0; j--) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] != Type::L) {\n                    insertTail(p - 1);\n                }\n            }\n        }\n    }\n    void insertHead(const int i) { bucket[S[i]][head[S[i]]++] = i; }\n    void insertTail(const int i) { bucket[S[i]][tail[S[i]]--] = i; }\n\n    const int N;\n    const int kind;\n    vector<int> S;               // O(N)\n    vector<Type> type;           // O(N)\n    vector<int> next;            // O(N)\n    vector<vector<int>> bucket;  // O(N)\n    vector<int> num;             // O(K)\n    vector<int> head;            // O(K)\n    vector<int> tail;            // O(K)\n    vector<int> LMS;             // O(N)\n};\n\nint main()\n{\n    string s;\n    cin >> s;\n    const int size = s.size();\n    const vector<int> sa = SuffixArrayInducedSorting(s, 63).getSuffixArray();\n    int N;\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        string p;\n        cin >> p;\n        const int psize = p.size();\n        int inf = -1;\n        int sup = size;\n        while (sup - inf > 1) {\n            const int mid = (sup + inf) / 2;\n            const bool ok = s.substr(sa[mid], psize) < p;\n            if (ok) {\n                inf = mid;\n            } else {\n                sup = mid;\n            }\n        }\n        const bool ans = sup == size ? false : s.substr(sa[sup], psize) == p;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// This file is a \"Hello, world!\" in C++ language by GCC for wandbox.\n#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash\n{\n    vector<ull> hash,pow;\n    RollingHash(string s, ull _b=1000000007)\n    {\n        _b = _b;\n        int sz = s.length();\n        hash.assign(sz+1,0);\n        pow.assign(sz+1,0);\n\n        pow[0]=1;\n        for(int i=0;i<sz;i++){\n            pow[i+1]=pow[i]*_b;\n        }\n        for(int i=0;i<sz;i++){\n            hash[i+1]=(hash[i]+s[i])*_b;\n        }\n    }\n    // s[l]s[l+1]....s[r-1]縺ョ繝上ャ繧キ繝・蛟、繧貞叙蠕励☆繧?\n    // 蜊企幕蛹コ髢?\n    ull get(int l,int r){\n        return (hash[r]-hash[l]*pow[r-l]);\n    }\n};\n#define rep(i,n) for(int i=0;i<n;i++)\nint main()\n{\n    string t;\n    cin>>t;\n    int q;\n    cin>>q;\n    RollingHash hash(t);\n    unordered_set<ull> s;\n    rep(i,t.size()){\n        rep(j,min(1000,(int)t.size()-i)){\n            s.insert(hash.get(i,i+j+1));\n        }\n    }\n    rep(i,q){\n        string p;\n        cin>>p;\n        cout<<s.count(RollingHash(p).get(0,p.size()))<<endl;\n    }\n}\n\n// GCC reference:\n//   https://gcc.gnu.org/\n\n// C++ language references:\n//   https://msdn.microsoft.com/library/3bstk3k5.aspx\n//   http://www.cplusplus.com/\n//   https://isocpp.org/\n//   http://www.open-std.org/jtc1/sc22/wg21/\n\n// Boost libraries references:\n//   http://www.boost.org/doc/"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint Q, doubles, lengths, dat[1000009], tmp[1000009], arrays[1000009]; string S, T;\nbool compare_suffix(int i, int j) {\n\tif (dat[i] == dat[j]) {\n\t\tint ri = (i + doubles <= lengths ? dat[i + doubles] : -1);\n\t\tint rj = (j + doubles <= lengths ? dat[j + doubles] : -1);\n\t\treturn ri < rj;\n\t}\n\treturn dat[i] < dat[j];\n}\nvoid suffix_array() {\n\tlengths = S.size();\n\tfor (int i = 0; i <= lengths; i++) arrays[i] = i, dat[i] = i < lengths ? S[i] : -1;\n\tfor (doubles = 1; doubles <= lengths; doubles <<= 1) {\n\t\tsort(arrays, arrays + lengths + 1, compare_suffix);\n\t\ttmp[arrays[0]] = 0;\n\t\tfor (int i = 1; i <= lengths; i++) tmp[arrays[i]] = tmp[arrays[i - 1]] + (compare_suffix(arrays[i - 1], arrays[i]) ? 1 : 0);\n\t\tfor (int i = 0; i <= lengths; i++) dat[i] = tmp[i];\n\t}\n}\nint main() {\n\tcin >> S >> Q;\n\tsuffix_array();\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> T;\n\t\tint l = 0, r = S.size() + 1; bool flag = false;\n\t\twhile (r - l > 1) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tstring S1 = S.substr(arrays[m], T.size());\n\t\t\tif (S1 == T) {\n\t\t\t\tflag = true; break;\n\t\t\t}\n\t\t\tif (S1 < T) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tprintf(flag ? \"1\\n\" : \"0\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\n \nint Rank[1000005];\nint Tmp[1000005];\nint kc,len;\n \nbool compare_sa(int i,int j){\n  return\n    Rank[i]!=Rank[j]?\n    Rank[i]<Rank[j]:\n    (i+kc<=len?Rank[i+kc]:-1)<(j+kc<=len?Rank[j+kc]:-1);\n}\n \nvoid construct_sa(char* S,int *sa){\n  len=strlen(S);\n  for(int i=0;i<=len;i++){\n    sa[i]=i;\n    Rank[i]=i<len?S[i]:-1;\n  }\n  for(kc=1;kc<=len;kc*=2){\n    sort(sa,sa+len+1,compare_sa);\n    Tmp[sa[0]]=0;\n    for(int i=1;i<=len;i++){\n      Tmp[sa[i]]=Tmp[sa[i-1]]+compare_sa(sa[i-1],sa[i]);\n    }\n    for(int i=0;i<=len;i++)Rank[i]=Tmp[i];\n  }\n}\n \n \nint n,m;\nchar str[1000005];\nchar t[1000005];\nint sa[1000005];\n \nint main(){\n  scanf(\"%s\",str);\n  n=strlen(str);\n  construct_sa(str,sa);\n  scanf(\"%d\",&m);\n  while(m--){\n    scanf(\"%s\",t);\n    int k=strlen(t);\n    int l=0,r=n+1,m;\n    while(l+1<r){\n      m=(l+r)/2;\n      if(strncmp(str+sa[m],t,k)<=0)l=m;\n      else r=m;\n    }\n    printf(\"%d\\n\",(strncmp(str+sa[l],t,k)==0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    S.push_back('$');\n    vector<int> c(n+1,0),ord(n+1,0);\n    for(int i=0;i<=n;i++) ord[i]=n-i;\n    sort(ord.begin(),ord.end(),[&](int a,int b){return S[a]<S[b];});\n    for(int i=0;i<=n;i++){\n      sa[i]=ord[i];\n      c[i]=S[i];\n    }\n    vector<int> r(n+1),cnt(n+1);\n    for(int len=1;len<=n;len*=2){\n      for(int i=0;i<=n;i++) r[i]=c[i];\n      for(int i=0;i<=n;i++){\n\t c[sa[i]] =\n\t   i>0&&\n\t   r[sa[i- 1]]==r[sa[i]] &&\n\t   sa[i-1]+len<=n &&\n\t   r[sa[i-1]+len/2]==r[sa[i]+len/2]\n\t   ?c[sa[i - 1]]:i;\n      }\n      for(int i=0;i<=n;i++) cnt[i]=i;\n      vector<int> s=sa;\n      for(int i=0;i<=n;i++){\n\tint s1=s[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n+1);\n    for(int i=0;i<=n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint n, k;\nint rnk[1000001];\nint tmp[1000001];\n\nbool compare_sa(int i, int j){\n    if(rnk[i] != rnk[j]){\n        return rnk[i] < rnk[j];\n    }else{\n        int ri = i+k <= n ? rnk[i+k] : -1;\n        int rj = j+k <= n ? rnk[j+k] : -1;\n        return ri < rj;\n    }\n}\n\nvoid construct_sa(string s, int *sa){\n    n = s.length();\n    for(int i = 0; i <= n; i++){\n        sa[i] = i;\n        rnk[i] = i < n ? s[i] : -1;\n    }\n    for(k = 1; k <= n; k *= 2){\n        sort(sa, sa+n+1, compare_sa);\n        tmp[sa[0]] = 0;\n        for(int i = 1; i <= n; i++){\n            tmp[sa[i]] = tmp[sa[i-1]] + (compare_sa(sa[i-1], sa[i]) ? 1 : 0);\n        }\n        for(int i = 0; i <= n; i++){\n            rnk[i] = tmp[i];\n        }\n    }\n}\n\nbool contain(string s, int *sa, string t){\n    int a = 0, b = s.length();\n    while(b - a > 1){\n        int c = (a+b)/2;\n        if(s.compare(sa[c], t.length(), t) < 0) a = c;\n        else    b = c;\n    }\n    return s.compare(sa[b], t.length(), t) == 0;\n}\n\nint main(){\n    string s;\n    cin >> s;\n    n = s.length();\n    int sa[n];\n    construct_sa(s, sa);\n    int q;\n    cin >> q;\n    while(q-- > 0){\n        string t;\n        cin >> t;\n        cout << contain(s, sa, t) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define each(it,c) for(__typeof(c.begin()) it=c.begin(); it!=c.end(); it++)\n#define INF 1<<30\n#define mp make_pair\n#define pb push_back\n\ntypedef vector<int> vi;\n\ntypedef long long ll;\n\nbool has(map <char, int> m,char c){\n\tif (m.find(c) == m.end()) return false;\n\telse return true;\n}\n\nint bm(string t,string p){\n\tint i,j;\n\tint n = t.size();\n\tint m = p.size();\n\tmap <char,int> skip;\n\trep(k,m-1){\n\t\tskip[p[k]] = m-k-1;\n\t}\n\n\tfor(i=m-1,j=m-1;j>=0;i--,j--){\n\t\twhile(t[i]!=p[j]){\n\t\t\tint x = (has(skip,t[i])) ? skip[t[i]] : m;\n\t\t\ti += ( (m-j > x) ? m-j : x );\n\t\t\tif(i>=n) return -1;\n\t\t\tj = m-1;\n\t\t}\n\t}\n\treturn i+1;\n}\n\nint main(){\n\tstring t;\n\tcin>>t;\n\tint n; cin>>n;\n\trep(i,n){\n\t\tstring p;\n\t\tcin>>p;\n\t\tint ans = bm(t,p);\n\t\t//cout<<ans<<endl;\n\t\tif(ans!=-1) cout<<1<<endl;\n\t\telse cout<<0<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    //return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n    return i+k < n ? 1 : j+k < n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n/2+n%2,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==nc)a[i]=b[j++];\n      else if(j==nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  /*\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n  */\n  int sa[rh.n+1];\n  REP(i,rh.n+1)sa[i]=i;\n  sort(sa,sa+rh.n+1,rh);\n  vector<int>res(rh.n+1);\n  REP(i,rh.n+1)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S 2500005\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\nstruct d{\n  int a,b,c;\n  d(){}\n  d(int A,int B,int C){\n    a=A,b=B,c=C;\n  };\n  bool operator<(const d&r)const{\n    if(a!=r.a)return a<r.a;\n    return b<r.b;\n  }\n};\n \nint n,slen,tlen,r[S];\nchar s[S],t[N];\nd ran[S];\nP a[S];\n \nvoid init(){\n  for(int i=0;i<26;i++)\n    for(int j=0;j<slen;j++)\n      if('a'+i==s[j])r[j]=i+1;\n  int x=1;\n  r[slen]=0;\n  while(x<slen){\n    for(int i=0;i<slen;i++){\n      int a=i+x;\n      if(a>slen)a=slen;\n      ran[i]=d(r[i],r[a],i);\n    }\n    sort(ran,ran+slen);\n    int cnt=1;\n    for(int i=0;i<slen;i++){\n      r[ran[i].c]=cnt;\n      if(ran[i].a==ran[i+1].a&&ran[i].b==ran[i+1].b)\n    continue;\n      cnt++;\n    }\n    x*=2;\n  }\n  for(int i=0;i<slen;i++)a[i]=P(r[i],i);\n  sort(a,a+slen);\n}\n \nbool bynary_search(){\n  int L=0,R=slen;\n  while(L<R){\n    int M=(L+R)/2;\n    if(strncmp(s+a[M].second,t,tlen)<0)L=M+1;\n    else R=M;\n  }\n  if(!strncmp(s+a[L].second,t,tlen))return true;\n  return false;\n}\n \nint main(){\n  scanf(\"%s%d\",s,&n);\n  slen=strlen(s);\n  init();  \n  while(n--){\n    scanf(\"%s\",t);\n    tlen=strlen(t);\n    if(bynary_search())printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstring S; string U;\nvector<string>T; int N;\nint main() {\n\tcin >> S >> N;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tint L = S.size() - i;\n\t\tif (L > 200)L = 200;\n\t\tT.push_back(S.substr(i, L));\n\t}\n\tsort(T.begin(), T.end());\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> U; if (U.size() >= 200) { U = U.substr(0, 200); }\n\t\tint pos = lower_bound(T.begin(), T.end(), U) - T.begin();\n\t\tstring V;\n\t\tif (pos < T.size() && U.size() <= T[pos].size()) { V = T[pos].substr(0, U.size()); }\n\t\tif (U == V) { cout << \"1\" << endl; }\n\t\telse { cout << \"0\" << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nclass suffix_array{\n    void create_begin_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        int sum=0;\n        for(int i=0;i<bucket.size();i++){bucket[i]+=sum;swap(sum,bucket[i]);}\n    }\n\n    void create_end_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        for(int i=1;i<bucket.size();i++)bucket[i]+=bucket[i-1];\n    }\n\n    void induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_begin_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(sa[i]>0&&is_l[sa[i]-1])sa[bucket[v[sa[i]-1]]++]=sa[i]-1;\n    }\n\n    void invert_induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_end_bucket(v,bucket);\n        for(int i=v.size()-1;i>=0;i--)if(sa[i]>0&&!is_l[sa[i]-1])sa[--bucket[v[sa[i]-1]]]=sa[i]-1;\n    }\n\n    vector<int>sa_is(vector<int>v,int mv){\n        if(v.size()==1)return vector<int>(1,0);\n\n        vector<int>is_l(v.size());\n        vector<int>bucket(mv+1);\n        vector<int>sa(v.size(),-1);\n        auto is_lms=[&](int x)->bool{return x>0&&is_l[x-1]&&!is_l[x];};\n\n        is_l[v.size()-1]=0;\n        for(int i=v.size()-2;i>=0;i--)is_l[i]=v[i]>v[i+1]||(v[i]==v[i+1]&&is_l[i+1]);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(is_lms(i))sa[--bucket[v[i]]]=i;\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n\n        int cur=0;\n        vector<int>order(v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))order[i]=cur++;\n\n        vector<int>next_v(cur);\n        cur=-1;\n        int prev=-1;\n        for(int i=0;i<v.size();i++){\n            if(!is_lms(sa[i]))continue;\n            bool diff=false;\n            for(int d=0;d<v.size();d++){\n                if(prev==-1||v[sa[i]+d]!=v[prev+d]||is_l[sa[i]+d]!=is_l[prev+d]){\n                    diff=true;\n                    break;\n                }\n                else if(d>0&&is_lms(sa[i]+d))break;\n            }\n            if(diff){cur++;prev=sa[i];}\n            next_v[order[sa[i]]]=cur;\n        }\n\n        vector<int>re_order(next_v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))re_order[order[i]]=i;\n        vector<int>next_sa=sa_is(next_v,cur);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<sa.size();i++)sa[i]=-1;\n        for(int i=next_sa.size()-1;i>=0;i--)sa[--bucket[v[re_order[next_sa[i]]]]]=re_order[next_sa[i]];\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n        return sa;\n    }\n\n    vector<int>sa_is(string &s){\n        vector<int>v(s.size()+1);\n        for(int i=0;i<s.size();i++)v[i]=s[i];\n        sa=sa_is(v,*max_element(v.begin(),v.end()));\n    }\n\n    void construct_lcp(){\n        lcp.resize(s.size());\n        rank.resize(s.size()+1);\n        int n=s.size();\n        for(int i=0;i<=n;i++)rank[sa[i]]=i;\n        int h=0;\n        lcp[0]=0;\n        for(int i=0;i<n;i++){\n            int j=sa[rank[i]-1];\n\n            if(h>0)h--;\n            for(;j+h<n&&i+h<n;h++){\n                if(s[j+h]!=s[i+h])break;\n            }\n            lcp[rank[i]-1]=h;\n        }\n    }\n\n    class sparse_table{\n        vector<vector<int> >st;\n    public:\n        void init(vector<int>&v){\n            int b;\n            for(b=0;(1<<b)<=v.size();b++);\n            st.assign(b,vector<int>(1<<b,0));\n            for(int i=0;i<v.size();i++)st[0][i]=v[i];\n\n            for(int i=1;i<b;i++){\n                for(int j=0;j+(1<<i)<=(1<<b);j++){\n                    st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);\n                }\n            }\n        }\n        int get_min(int l,int r){\n            assert(l<r);\n            int b=32-__builtin_clz(r-l)-1;\n            return min(st[b][l],st[b][r-(1<<b)]);\n        }\n        sparse_table(){}\n        sparse_table(vector<int>&v){init(v);}\n    };\n    sparse_table st;\npublic:\n    string s;\n    vector<int>sa,lcp,rank;\n    void init(string &t){\n        s=t;\n        sa_is(s);\n        construct_lcp();\n        st.init(lcp);\n    }\n    suffix_array(string &t){init(t);}\n    suffix_array(){}\n\n    bool contain(string &t){\n        int lb=0,ub=s.size();\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            if(s.compare(sa[mid],t.size(),t)<0)lb=mid;\n            else ub=mid;\n        }\n        return s.compare(sa[ub],t.size(),t)==0;\n    }\n\n    int get_lcp(int i,int j){\n        if(rank[i]>rank[j])swap(i,j);\n        return st.get_min(rank[i],rank[j]);\n    }\n};\n\nsigned main(){\n    string s;cin>>s;\n    suffix_array sa(s);\n    int q;cin>>q;\n    while(q--){\n        string t;\n        cin>>t;\n        cout<<sa.contain(t)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n\n#pragma warning(disable: 4996)\n\nusing namespace std;\n\nint Q; char STR1[1000001], STR2[1001];\n\nvector<int> ptr[62];\n\nconst char strings[63] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890\";\n\nint main()\n{\n\tscanf(\"%s\", &STR1);\n\n\tfor (int i = 0; i < strlen(STR1); i++)\n\t{\n\t\tfor (int j = 0; j < 62; j++)\n\t\t{\n\t\t\tif (STR1[i] == strings[j])\n\t\t\t{\n\t\t\t\tptr[j].push_back(i); break;\n\t\t\t}\n\t\t}\n\t}\n\n\tscanf(\"%d\", &Q);\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%s\", STR2);\n\n\t\tint code_;\n\t\tint size_;\n\n\t\tfor (int j = 0; j < 62; j++)\n\t\t{\n\t\t\tif (STR2[0] == strings[j])\n\t\t\t{\n\t\t\t\tsize_ = ptr[j].size();\n\n\t\t\t\tcode_ = j;\n\t\t\t}\n\t\t}\n\n\t\tint finds = 0;\n\n\t\tfor (int j = 0; j < size_; j++)\n\t\t{\n\t\t\tint ptr_ = ptr[code_][j];\n\n\t\t\tif (ptr[code_][j] + strlen(STR2) <= strlen(STR1))\n\t\t\t{\n\t\t\t\tfinds++;\n\n\t\t\t\tfor (int k = 0; k < strlen(STR2); k++)\n\t\t\t\t{\n\t\t\t\t\tif (STR1[ptr_ + k] != STR2[k])\n\t\t\t\t\t{\n\t\t\t\t\t\tgoto Exit1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (finds)\n\t\t\t{\n\t\t\t\tprintf(\"1\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t}\n\n\t\t\tgoto Exit2;\n\n\t\tExit1:;\n\t\t}\n\n\t\tprintf(\"0\\n\");\n\n\tExit2:;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<complex>\n#include<typeinfo>\nusing namespace std;\n\nvector<bool> match(20000, false);\n\nstruct Node{\n    string pat;\n    map<char, int> child;\n    int fail;\n    vector<string> output;\n    bool blue;\n    vector<int> patternNum;\n};\n\nbool mapElementCheck(map<char, int> &child, char &c){\n    return child.find(c) != child.end();\n}\n\nvoid concatStringVector(vector<string> &v1, vector<string> &v2){\n    v1.insert(v1.begin(), v2.begin(), v2.end());\n}\n\nvoid concatIntVector(vector<int> &v1, vector<int> &v2){\n    v1.insert(v1.begin(), v2.begin(), v2.end());\n}\n\nvoid printNode(Node &n){\n    cout << endl << \"pat: \" << n.pat << endl;\n    cout << \"child: \" << endl;\n    for (map<char, int>::iterator itr = (n.child).begin();itr!=(n.child).end();itr++){\n        cout << itr->first << \" \" << itr->second << endl;\n    }\n    cout <<\"fail: \" << n.fail << endl;\n    cout << \"output: \" <<endl;\n    for (int i=0;i<(n.output).size();i++){\n        cout << (n.output)[i] << endl;\n    }\n    cout << \"blue: \" << n.blue << endl;\n    cout << \"patternNum: \" <<endl;\n    for (int i=0;i<(n.patternNum).size();i++){\n        cout << (n.patternNum)[i] << endl;\n    }\n    cout << endl;\n    return;\n}\n\nvoid insert(vector<Node> &nodes, string &S, int patternNum){\n    int now = 0;\n    for (int i=0;i<S.size();i++){\n        map<char, int>& mp = nodes[now].child;\n        if(mp.find(S[i]) == mp.end()){\n            Node n;\n            n.pat = nodes[now].pat + string(1, S[i]);\n            nodes.push_back(n);\n            (nodes[now].child)[S[i]] = nodes.size()-1;\n            now = nodes.size()-1;\n        }else{\n            now = mp[S[i]];\n        }\n        if(i == S.size()-1){\n                nodes[now].blue = true;\n                (nodes[now].output).push_back(nodes[now].pat);\n                (nodes[now].patternNum).push_back(patternNum);\n            }else{\n                nodes[now].blue = false;\n            }\n    }\n    return;\n}\n\nvoid makeFailure(vector<Node> &nodes){\n    queue< pair<int, int> > qu;\n    qu.push(make_pair(0, 0));\n    while(!qu.empty()){\n        pair<int, int> now = qu.front();\n        qu.pop();\n        for (map<char, int>::iterator itr = (nodes[now.first].child).begin();itr!=(nodes[now.first].child).end();itr++){\n            qu.push(make_pair( itr->second, now.first));\n        }\n        if(now.second == 0 || now.first == 0){\n            nodes[now.first].fail = 0;\n        }else{\n            string tmpStr = (nodes[now.first]).pat;\n            char last = tmpStr[tmpStr.size()-1];\n            int ances = nodes[now.second].fail;\n            bool b1 = false;\n            while((nodes[ances].child).find(last) == (nodes[ances].child).end()){\n                if (ances == 0){\n                    b1 = true;\n                    break;\n                }\n                ances = nodes[ances].fail;\n            }\n            if(b1){\n                nodes[now.first].fail = 0;\n            }else{\n                nodes[now.first].fail = (nodes[ances].child)[last];\n                concatStringVector(nodes[now.first].output, nodes[nodes[now.first].fail].output);\n                concatIntVector(nodes[now.first].patternNum, nodes[nodes[now.first].fail].patternNum);\n            }\n        }\n        if(!(nodes[nodes[now.first].fail].output).empty()){\n\n        }\n    }\n}\n\nvector<Node> makePMA(vector<string> &P){\n    vector<Node> nodes;\n    Node n0;\n    n0.blue = false;\n    nodes.push_back(n0);\n    for (int i=0;i<P.size();i++){\n        insert(nodes, P[i], i);\n    }\n    makeFailure(nodes);\n    return nodes;\n}\n\nvoid PMASesch(vector<Node> &PMA, string &P){\n    int now = 0;\n    for (int i=0;i<P.size();i++){\n        if(!mapElementCheck(PMA[now].child, P[i])){\n            while(!mapElementCheck(PMA[now].child, P[i])){\n                if(now == 0) break;\n                now = PMA[now].fail;\n            }\n        }\n        if (mapElementCheck(PMA[now].child, P[i])){\n            now = (PMA[now].child)[P[i]];\n            for (int j=0;j<(PMA[now].patternNum).size();j++){\n                match[(PMA[now].patternNum)[j]] = true;\n            }\n        }else{\n            now = 0;\n        }\n    }\n}\n\nint main(){\n    string T;\n    cin >> T;\n    int Q;\n    cin >> Q;\n    vector<string> P;\n    string tmp;\n    for (int i=0;i<Q;i++){\n        cin >> tmp;\n        P.push_back(tmp);\n    }\n    vector<Node> PMA = makePMA(P);\n    /*\n    for (int i=0;i<PMA.size();i++){\n        printNode(PMA[i]);\n    }\n    cout << \"makePMA: end\" << endl;\n    */\n    PMASesch(PMA, T);\n    /*\n    cout << \"searchPMA: end\" << endl;\n    */\n    for (int i=0;i<Q;i++){\n        cout << match[i] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n#define size_t int\n\nstruct SuffixArray {\n    string s;\n    size_t n;\n    vector<size_t> sarray, rank;\n    SuffixArray(string s): s(s), n(s.length()) {\n        sarray.assign(n+1, 0);\n        rank.assign(n+1, 0);\n\n        for (size_t i=0; i<=n; ++i) {\n            sarray[i] = i;\n            rank[i] = i<n? s[i]:-1;\n        }\n\n        vector<size_t> tmp(n+1);\n        for (size_t k=1; k<=n; k<<=1) {\n            auto comp=[&, k](size_t i, size_t j)->bool {\n                if (rank[i] != rank[j])\n                    return rank[i] < rank[j];\n\n                int ri=i+k<=n? rank[i+k]:-1;\n                int rj=j+k<=n? rank[j+k]:-1;\n                return ri < rj;\n            };\n            sort(sarray.begin(), sarray.end(), comp);\n                \n            for (size_t i=1; i<=n; ++i)\n                tmp[sarray[i]] = tmp[sarray[i-1]]+comp(sarray[i-1], sarray[i]);\n\n            for (size_t i=0; i<=n; ++i)\n                rank[i] = tmp[i];\n        }\n    }\n    bool is_substr(string t) {\n        size_t lb=0, ub=s.length();\n        while (ub-lb > 1) {\n            size_t mid=(lb+ub)>>1;\n            (s.compare(sarray[mid], t.length(), t)<0? lb:ub) = mid;\n        }\n        return !s.compare(sarray[ub], t.length(), t);\n    }\n};\n\nint main() {\n    char buf[1<<20];\n    scanf(\"%s\", buf);\n    string T(buf);\n\n    SuffixArray sa(T);\n\n    size_t Q;\n    scanf(\"%d\", &Q);\n\n    for (size_t i=0; i<Q; ++i) {\n        scanf(\"%s\", buf);\n        string P(buf);\n\n        printf(\"%d\\n\", sa.is_substr(P));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\n\n#define fi(x) get<0>(x)\n#define se(x) get<1>(x)\n\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\ntypedef vector<pll> vpl;\n\nstring t;\nstring p;\nlli q;\n\nvll sa;\nvll tmp;\nvpl rnk;\n\nint main(){\n    cin >> t;\n    sa = vll(t.size());rnk = vpl(t.size());tmp = vll(t.size());\n    for(lli i = 0;i < t.size();i++) sa[i] = i;\n    for(lli i = 0;i < t.size();i++) fi(rnk[i]) = t[i];\n    for(lli k = 1;k < 2*t.size();k *= 2){\n        sort(sa.begin(),sa.end(),[](lli a,lli b){\n            return rnk[a] < rnk[b];\n        });\n        for(lli i = 1;i < sa.size();i++){\n            tmp[sa[i]] = tmp[sa[i-1]];\n            if(rnk[sa[i]] != rnk[sa[i-1]]) tmp[sa[i]]++;\n        }\n        for(lli i = 0;i < sa.size();i++){\n            fi(rnk[sa[i]]) = tmp[sa[i]];\n        }\n        for(lli i = 0;i < sa.size();i++){\n            if(sa[i]+k < t.size()) se(rnk[sa[i]]) = fi(rnk[sa[i]+k]);\n            else se(rnk[sa[i]]) = -1;\n        }\n    }\n    //for(lli i = 0;i < sa.size();i++) cout << sa[i] << endl;\n    cin >> q;\n    for(lli i = 0;i < q;i++){\n        /*\n        lli x;\n        cin >> p >> x;\n        cout << t.compare(x,p.size(),p) << endl;\n        continue;\n        */\n        cin >> p;\n        lli lwrbnd = *lower_bound(sa.begin(),sa.end(),p,[](lli a,string s){\n            return t.compare(a,s.size(),s) < 0;\n        });\n        //cout << \"lwrbnd=\" << lwrbnd << endl;\n        if(t.compare(lwrbnd,p.size(),p) == 0) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    S.push_back('$');\n    vector<int> c(n+1,0),ord(n+1,0);\n    for(int i=0;i<=n;i++) ord[i]=n-i;\n    sort(ord.begin(),ord.end(),[&](int a,int b){return S[a]<S[b];});\n    \n    for(int i=0;i<=n;i++){\n      sa[i]=ord[i];\n      c[i]=S[i];\n    }\n    \n    for(int len=1;len<=n;len*=2){\n      vector<int> r=c;\n      for(int i=0;i<=n;i++){\n\t c[sa[i]] = i > 0 && r[sa[i - 1]] == r[sa[i]] && sa[i - 1] + len <= n && r[sa[i - 1] + len / 2] == r[sa[i] + len / 2] ? c[sa[i - 1]] : i;\n      }\n      vector<int> cnt(n+1);\n      for(int i=0;i<=n;i++) cnt[i]=i;\n      vector<int> s=sa;\n      for(int i=0;i<=n;i++){\n\tint s1=s[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n);\n    for(int i=0;i<n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  return 0;\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    //assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <iostream>\n#include <queue>\n#include <unordered_set>\nusing namespace std;\n\nstruct TrieNode {\n  int is_word = 0, depth = 0;\n  vector<int> word_indices;\n  TrieNode *suf = nullptr, *out = nullptr, *parent = nullptr;\n  char last = '\\0';\n  TrieNode *adj[36];\n  TrieNode(int depth, TrieNode *parent) : depth(depth), parent(parent) {\n    fill_n(adj, 36, nullptr);\n  }\n  TrieNode() { fill_n(adj, 36, nullptr); }\n\n  TrieNode *GetNeighbor(char c) { return adj[getidx(c)]; }\n\n  static int getidx(char c) {\n    int to_ret = isalpha(c) ? (c - 'a') : (26 + c - '0');\n    assert(to_ret >= 0 && to_ret <= 35);\n    return to_ret;\n  }\n};\n\nusing np = TrieNode *;\n\n// Adds edges for the given string to the given trie\n// i is the index of the string in the overall input\nvoid BuildTrie(np cur, string &s, int i) {\n  for (int j = 0; j < s.size(); ++j) {\n    np neighborptr = cur->GetNeighbor(s[j]);\n    if (!neighborptr) {\n      cur->adj[TrieNode::getidx(s[j])] = new TrieNode(cur->depth + 1, cur);\n    }\n    cur = cur->GetNeighbor(s[j]);\n    cur->last = s[j];\n  }\n  cur->is_word = 1;\n  cur->word_indices.push_back(i);\n}\n\n// Adds suffix and output edges to the given trie\n// Suffix edges:\n// A *suffix edge* goes to the longest proper suffix of the current node's\n// string that is also in the trie\n//\n// The root has no suffix edges\n// Nodes one away from the root have suffix edge back to the root\n// Node at least two away from the root with string wa:\n// cur=suf(w)\n// while(cur!=root and cur doesn't have an a-edge)\n//   cur=suf(cur)\n// post: cur has an a-edge or cur=root\n// if(cur has an a-edge) suf(wa)=cur->adj[a]\n// else /* cur=root */ suf(wa)=cur\n//\n// Output edges:\n// An *output edge* goes to the longest proper suffix of the current node's\n// string\n// that is a word in the dictionary\n//\n// cur=suf(w)\n// while(cur is not null and cur is not a word)\n//   cur=suf(cur)\n// out(w)=cur  // two cases: either cur is null, or cur is the longest word\n// that is a proper suffix of w\nvoid AddEdges(np root) {\n  // BFS from root\n  queue<np> to_visit;\n  to_visit.push(root);\n  while (!to_visit.empty()) {\n    np cur = to_visit.front();\n    to_visit.pop();\n    if (cur->depth == 1) {\n      cur->suf = root;\n    } else if (cur->depth > 1) {\n      np sufcur = cur->parent->suf;\n      while (sufcur != root && !sufcur->GetNeighbor(cur->last))\n        sufcur = sufcur->suf;\n      if (np neighbor = sufcur->GetNeighbor(cur->last)) {\n        cur->suf = neighbor;\n      } else {\n        cur->suf = root;\n      }\n    }\n    np outcur = cur->suf;\n    while (outcur && !outcur->is_word)\n      outcur = outcur->suf;\n    cur->out = outcur;\n\n    for (int i = 0; i < 36; ++i)\n      if (cur->adj[i])\n        to_visit.push(cur->adj[i]);\n  }\n}\n\nint main() {\n  string T;\n  cin >> T;\n  int q;\n  cin >> q;\n  np root = new TrieNode;\n  string p;\n  for (int i = 0; cin >> p; ++i)\n    BuildTrie(root, p, i);\n  AddEdges(root);\n\n  np cur = root;\n  unordered_set<int> matched;\n  for (char c : T) {\n    while (cur != root && !cur->GetNeighbor(c))\n      cur = cur->suf;\n    if (np out = cur->GetNeighbor(c))\n      cur = out;\n    if (cur->is_word)\n      matched.insert(cur->word_indices.begin(), cur->word_indices.end());\n    np outcur = cur->out;\n    while (outcur) {\n      matched.insert(outcur->word_indices.begin(), outcur->word_indices.end());\n      outcur = outcur->out;\n    }\n  }\n  for (int i = 0; i < q; ++i)\n    cout << matched.count(i) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macro\n#pragma region Basic\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i < i##_len; i++)\n#define FORD(i, a, b) for (int i = (a), i##_len = (b); i > i##_len; i--)\n#define FORR(t, a) for (auto t : a)\n#define ALL(x) (x).begin(), (x).end()  // sortなどの引数を省略したい\n#define GET(i, j) get<j>(i)\n#define MT(x, ...) make_tuple(x, __VA_ARGS__)\n#define SZ(x) ((int)(x).size())\n#define ZERO(x) memset(x, 0, sizeof(x))\n#define FILL(x, y) memset(x, y, sizeof(x))\n#define PB push_back\n#ifdef _DEBUG\n#define PRE_COMMAND             \\\n    std::cin.rdbuf(in.rdbuf()); \\\n    cout << fixed << setprecision(15);\n#else\n#define PRE_COMMAND cout << fixed << setprecision(15);\n#endif\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\ntemplate <class T>\nauto MAX(T& seq) {\n    return *max_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto MIN(T& seq) {\n    return *min_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto SUM(T& seq) {\n    T temp{0};\n    auto& temp2 = temp[0];\n    return accumulate(seq.begin(), seq.end(), temp2);\n}\ntemplate <class T>\nvoid SORT(T& seq) {\n    sort(seq.begin(), seq.end());\n}\ntemplate <class T, class S>\nvoid SORT(T& seq, S& sort_order) {\n    sort(seq.begin(), seq.end(), sort_order);\n}\ntemplate <class T>\nvoid SORTR(vector<T>& seq) {\n    sort(seq.begin(), seq.end(), greater<T>());\n}\ntemplate <class T>\nvoid CHMAX(T& a, const T& b) {\n    if (a < b) { a = b; }\n}\ntemplate <class T>\nvoid CHMIN(T& a, const T& b) {\n    if (b < a) { a = b; }\n}\ntemplate <class T>\nset<T> VECTOR_2_SET(vector<T>& v) {\n    set<T> s;\n    for (auto ele : v) { s.insert(ele); }\n    return s;\n}\ntemplate <class T>\nvector<T> SET_2_VECTOR(set<T>& s) {\n    vector<T> v;\n    for (auto ele : s) { v.push_back(ele); }\n    return v;\n}\ntemplate <class T, class S, class R>\nlong long pow(T n_0, S k_0, R mod_0) {\n    long long n = n_0;\n    long long k = k_0;\n    long long mod = mod_0;\n    long long now = 1;\n    while (true) {\n        if (k & 1) { now = now * n % mod; }\n        k >>= 1;\n        if (k == 0) { return now; }\n        n = (n * n) % mod;\n    }\n}\n#pragma endregion Basic\n#pragma region overload\ntemplate <class T, class S>\nvoid operator+=(vector<T>& l, S& r) {\n    for (auto i : r) { l.push_back(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(set<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(multiset<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvector<T> operator+(vector<T>& l, S& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T>\nvector<T> operator+(const vector<T> l, const vector<T>& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nset<T> operator+(set<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nset<T> operator+(const set<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nmultiset<T> operator+(multiset<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nmultiset<T> operator+(const multiset<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\nstring operator+(const string l, const string& r) {\n    string str = l;\n    str += r;\n    return str;\n}\nstring operator*(const string l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r; i++) { str += l; }\n    return str;\n}\n#pragma endregion overload\n#pragma region Input\ntemplate <class Head>\nvoid INPUT(vector<Head>& head);\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head);\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t);\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t);\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t);\ntemplate <class Head>\nvoid INPUT(Head& head);\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail);\n//本体\ntemplate <class Head>\nvoid INPUT(vector<Head>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t) {\n    cin >> get<0>(t);\n}\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t) {\n    cin >> get<0>(t) >> get<1>(t);\n}\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t);\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t);\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);\n}\ntemplate <class Head>\nvoid INPUT(Head& head) {\n    cin >> head;\n}\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail) {\n    INPUT(head);\n    INPUT((tail)...);\n}\n#pragma endregion Input\n#pragma region Print\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t);\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t);\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t);\ntemplate <class Head>\nvoid PRINT2(vector<Head> head);\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head);\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head);\ntemplate <class Head>\nvoid PRINT2(Head head);\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail);\ntemplate <class Head>\nvoid PRINT(Head head);\ntemplate <class... Head>\nvoid PRINT(Head... head);\ntemplate <int N, class Head>\nvoid PRINT(Head head);\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t) {\n    PRINT2(get<0>(t));\n}\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t) {\n    PRINT2(get<0>(t), get<1>(t));\n}\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t));\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t));\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t), get<4>(t));\n}\ntemplate <class Head>\nvoid PRINT2(vector<Head> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(Head head) {\n    cout << head;\n}\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail) {\n    PRINT2(head);\n    cout << \" \";\n    PRINT2((tail)...);\n}\ntemplate <class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\ntemplate <class... Head>\nvoid PRINT(Head... head) {\n    PRINT2((head)...);\n    cout << endl;\n}\ntemplate <int N, class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\n#pragma endregion Print\n#pragma endregion Macro\n\nstruct SA_IS {\n    string str;\n    int length;\n    vector<int> suffix_array;\n\n    SA_IS(string temp) {\n        str = temp;\n        length = (int)(str.size());\n        vector<char> t(str.begin(), str.end());\n        t.push_back('$');\n        suffix_array = induced_sort(t);\n    }\n\n    template <class T>\n    vector<char> categorize(vector<T>& s) {\n        int n = (int)s.size();\n        vector<char> L_S(n);\n        L_S[n - 1] = 'S';\n        for (int i = n - 2; i >= 0; i--) {\n            if (s[i] < s[i + 1]) {\n                L_S[i] = 'S';\n            } else if (s[i] > s[i + 1]) {\n                L_S[i] = 'L';\n            } else {\n                L_S[i] = L_S[i + 1];\n            }\n        }\n        for (int i = 1; i < n; i++) {\n            if (L_S[i] == 'S' && L_S[i - 1] == 'L') { L_S[i] = 'M'; }\n        }\n        return L_S;\n    }\n\n    template <class T>\n    void bucket_sort(vector<T>& s, vector<int>& bucket, vector<char>& cat,\n                     map<T, array<int, 3>>& LSM, vector<int>& is_sort) {\n        int n = (int)(cat.size());\n        int t;\n        if ((int)is_sort.size() > 0) {\n            // ソートしたMをバケツに突っ込む。そのうち置き換える\n            for (int temp : is_sort) {\n                bucket[LSM[s[temp]][2]] = temp;\n                LSM[s[temp]][2]--;\n            }\n        } else {\n            // M-typeを入れる。\n            for (int i = 0; i < n; i++) {\n                if (cat[i] == 'M') {\n                    bucket[LSM[s[i]][2]] = i;\n                    LSM[s[i]][2]--;\n                }\n            }\n        }\n        // L-typeを入れる。\n        for (int i = 0; i < n; i++) {\n            t = bucket[i] - 1;\n            if (t >= 0) {\n                if (cat[t] == 'L') {\n                    bucket[LSM[s[t]][0]] = t;\n                    LSM[s[t]][0]++;\n                }\n            }\n        }\n        // S-typeを入れる。\n        for (int i = n - 1; i >= 0; i--) {\n            t = bucket[i] - 1;\n            if (t >= 0) {\n                if (cat[t] != 'L') {\n                    bucket[LSM[s[t]][1]] = t;\n                    LSM[s[t]][1]--;\n                }\n            }\n        }\n    }\n\n    template <class T>\n    vector<int> induced_sort(vector<T>& s) {\n        int t, t2, before, after;  // temp変数\n        T c;                   // temp変数\n        int n = (int)s.size();\n        vector<int> bucket(n, -1), bucket_pre(n, -1);\n        if (n == 1) {\n            bucket = {0};\n            return bucket;\n        }\n        // 出てくる回数を記録\n        map<T, int> counter;\n        for (int i = 0; i < n; i++) {\n            c = s[i];\n            if (counter.find(c) == counter.end()) {\n                counter[c] = 1;\n            } else {\n                counter[c]++;\n            }\n        }\n        // バケツに入れる場所を記録するmap\n        map<T, array<int, 3>> LSM, LSM_pre;\n        int sum_count = 0;\n        for (tuple<T, int> temp : counter) {\n            tie(c, t) = temp;\n            LSM[c][0] = sum_count, sum_count += t;\n            LSM[c][1] = sum_count - 1;\n            LSM[c][2] = sum_count - 1;\n        }\n        LSM_pre = LSM;\n        // L,S,Mに分類\n        vector<char> cat = categorize(s);\n        // 一旦バケットソートでMの順序を決定する\n        vector<int> M_rec(0);\n        map<int, int> M_map;\n        bucket_sort(s, bucket_pre, cat, LSM_pre, M_rec);\n        M_map[bucket_pre[0]] = 0;\n        t = 0;\n        before = n - 1;\n        for (int i = 1; i < n; i++) {\n            if (cat[bucket_pre[i]] != 'M') { continue; }\n            after = bucket_pre[i];\n            t2 = 0;\n            while (true) {\n                if (s[before] < s[after + t2]) {\n                    t++;\n                    break;\n                }\n                t2++;\n                before++;\n                if (before == n) {\n                    t++;\n                    break;\n                }\n                if (cat[before] == 'M') {\n                    if (cat[after + t2] != 'M') { t++; }\n                    break;\n                }\n            }\n            M_map[after] = t;\n            before = after;\n        }\n        for (auto temp : M_map) { M_rec.push_back(get<1>(temp)); }\n        int m = (int)M_rec.size();\n        // Mのリストを作る\n        vector<int> M_list;\n        for (int i = 0; i < n; i++) {\n            if (cat[i] == 'M') { M_list.push_back(i); }\n        }\n        // Mについて、再帰的にinduced_sortを行う\n        vector<int> is_sort(m);\n        if (m > 0) {\n            vector<int> is = induced_sort(M_rec);\n            for (int i = 0; i < m; i++) { is_sort[m - i - 1] = M_list[is[i]]; }\n        }\n        bucket_sort(s, bucket, cat, LSM, is_sort);\n        return bucket;\n    }\n    // 0→'<', 1→'>', 2→'=='\n    int smaller(string& s, int& temp) {\n        int t = suffix_array[temp];\n        int n = (int)(s.size()), m = length - t, i = 0;\n        while (true) {\n            if (i == n) { return 2; }\n            if (i == m) { return 0; }\n            if (s[i] < str[t + i]) {\n                return 1;\n            } else if (s[i] > str[t + i]) {\n                return 0;\n            } else {\n                i++;\n            }\n        }\n    }\n    // 存在するかどうか\n    bool find(string& s) {\n        int ok = 0, ng = length;\n        while (abs(ok - ng) > 1) {\n            int mid = (ok + ng) / 2, v = smaller(s, mid);\n            if (v == 0) {\n                ok = mid;\n            } else if (v == 1) {\n                ng = mid;\n            } else {\n                return true;\n            }\n        }\n        if (smaller(s, ok) == 2 || smaller(s, ng) == 2) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n};\n\nint main() {\n    PRE_COMMAND\n    int n;\n    string s, t;\n    INPUT(s, n);\n    SA_IS sa(s);\n    REP(i, n) {\n        INPUT(t);\n        PRINT(sa.find(t));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//ALDS1_14_D\n#include <iostream>\n#include <string>\n#include <stdlib.h>\n#include <stdio.h>\nusing namespace std;\n\nint main(){\n\tstring T, P;\n\tint Q, check;\n\n\tcin>>T;\n\tcin>>Q;\n\n\tfor(int i=0;i<Q;i++){\n\t\tcin>>P;\n\t\tcheck = 0;\n\t\t\n\t\tif(T.length() >= P.length())\n\t\t\tfor(int j=0;j<=T.length()-P.length();j++)\n\t\t\t\tif(T.substr(j, P.length()) == P){\n\t\t\t\t\tcheck++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\tprintf(\"%d\\n\", i);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(string s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int i, const int j) { \n    int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n  \n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  \n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  \n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  if(100000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\n\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  inline bool cmp(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k > n ? true : j+k > n ? false : s[i+k] < s[j+k];\n  }\n  \n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }  \n};\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  const int n = SZ(a);\n  if(n>1){\n    vector<int> b(a.begin(), a.begin()+n/2);\n    vector<int> c(a.begin()+n/2, a.end());\n    mergesort(b,rh);\n    mergesort(c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==SZ(c))a[i]=b[j++];\n      else if(j==SZ(b))a[i]=c[k++];\n      else if(rh.cmp(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\nvoid quickSort(vector<int>& a, int low, int high) {\n  if (low > high)return;\n  int separator = a[(low + high)/2];\n  int i = low;\n  int j = high;\n  while (i <= j) {\n    while (a[i] < separator)i++;\n    while (a[j] > separator)j--;\n    if (i <= j) {\n      swap(a[i++],a[j++]);\n    }\n  }\n  quickSort(a, low, j);\n  quickSort(a, i, high);\n}\n\nvoid quicksort(vector<int> &a, int l, int r, const RollingHash& rh) {\n  if (l < r) {\n    int m = (l+r)/2;\n    int i = l-1, j = r+1;\n    while (1) {\n      //while (a[++i] < p);\n      while (rh.cmp(++i,m));\n      while (rh.cmp(m,--j));\n      if (i >= j) break;\n      swap(a[i], a[j]);\n    }\n    quicksort(a, l, i-1, rh);\n    quicksort(a, j+1, r, rh);\n  }\n}\nvoid quicksort(vector<int> &a, const RollingHash& rh) {\n  quicksort(a, 0, a.size()-1, rh);\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  //sort(ALL(sa),rh);\n  //mergesort(sa,rh);\n  quicksort(sa,rh);\n  //if(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    int c=(a+b)/2;\n    //if(S.compare(sa[c],T.length(),T)<0 )a=c;\n    //else b=c;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  while(n--){\n    cin >> t;\n    cout << contain(s,sa,t) << \"\\n\";\n    //cout << !!rh.find(t) << \"\\n\";\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\n\nstruct PMA{\n    PMA *next[256];\n    Vec matched;\n    PMA(){ fill(next,next+256,(PMA*)0); }\n    ~PMA(){\n\tfor(int i = 0 ; i < 256 ; i++){\n\t    if(next[i]) delete next[i];\n\t}\n    }\n};\n\nVec set_union(const Vec &a,const Vec &b){\n    int i = 0, j = 0, A = a.size(), B = b.size();\n    Vec res;\n    while(i < A && j < B){\n        if(a[i] == b[j]){\n            res.push_back(a[i]);\n            i++; j++;\n        }else if(a[i] > b[j]){\n            res.push_back(b[j++]);\n        }else{\n            res.push_back(a[i++]);\n        }\n    }\n    for( ; i < A ; i++) res.push_back(a[i]);\n    for( ; j < B ; j++) res.push_back(b[j]);\n    return res;\n}\n\nPMA *buildPMA(char pattern[10000][1001],int size){\n    PMA *root = new PMA;\n    for(int i = 0 ; i < size ; i++){\n        PMA *t = root;\n        for(int j = 0 ; pattern[i][j] != '\\0' ; j++){\n            char c = pattern[i][j];\n            if(t->next[c] == NULL) t->next[c] = new PMA;\n            t = t->next[c];\n        }\n        t->matched.push_back(i);\n    }\n    queue<PMA*> Q;\n    for(int i = 1 ; i < 256 ; i++){\n        if(root->next[i]){\n            root->next[i]->next[0] = root;\n            Q.push(root->next[i]);\n        }else{\n            root->next[i] = root;\n        }\n    }\n    while(!Q.empty()){\n        PMA *t = Q.front(); Q.pop();\n        for(int i = 1 ; i < 256 ; i++){\n            if(t->next[i]){\n                PMA *next = t->next[0];\n                while(!next->next[i]) next = next->next[0];\n                t->next[i]->next[0] = next->next[i];\n                t->next[i]->matched =\n                    set_union(t->next[i]->matched,next->next[i]->matched);\n                Q.push(t->next[i]);\n            }\n        }\n    }\n    return root;\n}\n\nvoid match(PMA *pma,const char *s,Vec &res){\n    for(int i = 0 ; s[i] != '\\0' ; i++){\n        int c = s[i];\n        while(!pma->next[c]) pma = pma->next[0];\n        pma = pma->next[c];\n        for(int j = 0 ; j < (int)pma->matched.size() ; j++){\n            res[pma->matched[j]] = 1;\n        }\n    }\n}\n\nchar T[1000001];\nchar P[10000][1001];\n\nint main(){\n    int Q;\n    scanf(\"%s%d\",T,&Q);\n    for(int i = 0 ; i < Q ; i++){\n        scanf(\"%s\",P[i]);\n    }\n    PMA *pma = buildPMA(P,Q);\n    Vec res(Q, 0);\n    match(pma,T,res);\n    for(auto x : res){\n        printf(\"%d\\n\",x);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\n// KMP?????? O(N)\nvector<int> build_kmp(const string &s){\n  int n = s.size();\n  vector<int> a(n+1, -1);\n  int j = -1;\n  rep(i,n){\n    while(j>=0 && s[i]!=s[j]) j = a[j];\n    j++;\n    if(s[i+1]==s[j]) a[i+1] = a[j];\n    else a[i+1]=j;\n  }\n  return a;\n}\n\nbool kmp_match(const string &txt, const string &pat, const vector<int> &skip){\n  int n = txt.size();\n  int m = pat.size();\n  vector<int> ret;\n  int j = 0;\n  rep(i,n){\n    while(j>-1 && txt[i] != pat[j]) j = skip[j];\n    j++;\n    if(j==m){\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  string t;\n  int q;\n  cin>>t>>q;\n\n  rep(_,q){\n    string p;\n    cin>>p;\n    auto skip = build_kmp(p);\n    cout << kmp_match(t, p, skip) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    string T, P;\n    int Tlen, Plen, n;\n\n    cin >> T >> n;\n    Tlen = T.size();\n\n    while (n--) {\n        cin >> P;\n        Plen = P.size();\n        if (Tlen < Plen) {\n            cout << \"0\\n\";\n        }\n        for (int i = 0; i <= Tlen - Plen; i++) {\n            if (T[i] == P[0]) {\n                if (P == T.substr(i, Plen)) {\n                    cout << \"1\\n\";\n                    break;\n                }\n            }\n            if (i == Tlen - Plen) {\n                cout << \"0\\n\";\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring S,T;\nstring V[10000][100];\nint main(){\n\tint q,a,b,c;\n\tcin>>S;\n\tb=S.size();\n\ta=min(b,100);\n\tfor(int i=1;i<100;i++){\n\t\tfor(int j=0;j<=b-i;j++){\n\t\t\tV[j][i]=S.substr(j,i);\n\t\t}\n\t}\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>T;\n\t\tc=T.size();\n\t\tfor(int j=0;j<=b-c;j++){\n\t\t\tif(V[j][c]==T){\n\t\t\t\tcout<<\"1\"<<endl;\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t}\n\t\tcout<<\"0\"<<endl;\n\t\tExit:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n/*\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n-nb,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k>=nc)a[i]=b[j++];\n      else if(j>=nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n*/\n#define INF (1<<29)\nint L[1000000],R[1000000];\n\ninline void merge(int *A, const int left, const int mid, const int right, const RollingHash &rh){\n  int n1 = mid - left, n2 = right - mid;\n  REP(i,n1)L[i]=A[left+i];\n  REP(i,n2)R[i]=A[mid+i];\n  L[n1]=R[n2]=INF;\n  for(int k =left,i=0,j=0;k<right;k++){\n    //if(n2<=j)A[k]=L[i++];\n    //else if(n1<=i)A[k]=R[j++];\n    //else\n      A[k]=rh(L[i],R[j])?L[i++]:R[j++];\n  }\n}\n\nvoid mergeSort(int *A,const int left,const int right, const RollingHash &rh){\n  if(left+1<right){\n    const int mid = (left+right)/2;\n    mergeSort(A,left,mid, rh);\n    mergeSort(A,mid,right, rh);\n    merge(A,left,mid,right, rh);\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  //mergesort(n,sa,rh);\n  mergeSort(sa,0,n,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\nstruct suffix_array {\n  int n;\n  vector<int> x;\n  suffix_array(const char *s) : n(strlen(s)), x(n) { \n    vector<int> r(n), t(n); \n    for (int i = 0; i < n; ++i) r[x[i] = i] = s[i];\n    for (int h = 1; t[n-1] != n-1; h *= 2) {\n      auto cmp = [&](int i, int j) {\n        if (r[i] != r[j]) return r[i] < r[j];\n        return i+h < n && j+h < n ? r[i+h] < r[j+h] : i > j;\n      };\n      sort(x.begin(), x.end(), cmp);\n      for (int i = 0; i+1 < n; ++i) t[i+1] = t[i] + cmp(x[i], x[i+1]);\n      for (int i = 0; i < n; ++i)   r[x[i]] = t[i];\n    }\n  }\n  int operator[](int i) const { return x[i]; }\n};\n\nbool contain(const string &S, int *sa, const string &T) {\n  int lb = -1, ub = S.size() - 1;\n  while(ub - lb > 1) {\n    int mid = (lb + ub) / 2;\n    if(S.compare(sa[mid], T.size(), T) >= 0) ub = mid;\n    else lb = mid;\n  }\n  return S.compare(sa[ub], T.size(), T) == 0;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  string T; cin >> T;\n  int Q; cin >> Q;\n  suffix_array sary(T.c_str());\n  while(Q--) {\n    string P; cin >> P;\n    cout << (contain(T, sary.x.data(), P) ? 1 : 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\n#define NUM 48\nusing namespace std;\n\nint T_char_count[128] = {0},P_char_count[128];\n\nclass LocRecord{\n\npublic:\n\t//?????¢???????¢????\n\tLocRecord(){\n\t\tlocationTable = new int*[128];\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t}\n\n\t//-1?????£??\\\n\tvoid init(){\n\t\tint limit;\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init_index(){\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t}\n\n\tvoid regist_loc(int ch, int location){\n\t\tlocationTable[ch][index[ch]] = location;\n\t\tindex[ch]++;\n\t}\n\n\tint next_loc(int ch){\n\t\tint ret = locationTable[ch][index[ch]];\n\t\tindex[ch]++;\n\t\treturn ret;\n\t}\n\nprivate:\n\tint** locationTable;\n\tint index[128];\n};\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\t\t\treturn length < arg.length;\n\t};\n\tInfo(int arg_length,int arg_id,ull arg_hashValue){\n\t\tlength = arg_length;\n\t\tid = arg_id;\n\t\thashValue = arg_hashValue;\n\t}\n\n\tint length,id;\n\tull hashValue;\n};\n\nint main(){\n\n\tfor(int i = 0; i < 128; i++)T_char_count[i] = 0;\n\n\tint T_length;\n\n\tchar* T = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tfor(T_length = 0; T[T_length] != '\\0';T_length++){\n\t\tT_char_count[T[T_length]]++;\n\t}\n\n\tLocRecord locRecord;\n\tlocRecord.init();\n\n\t//T[i]????????????i??§???????????¨????¨????\n\tfor(int i = 0; i < T_length; i++){\n\t\tlocRecord.regist_loc(T[i],i);\n\t}\n\n\tull* HASH = new ull[T_length+1];\n\tull* P = new ull[T_length+1];\n\n\tHASH[0] = 0;\n\tP[0] = 1;\n\n\t//T??????????????\\???????±???????\n\tfor(int i = 1; i <= T_length; i++){\n\t\tHASH[i] = T[i-1] + HASH[i-1]*MOD;\n\t\tP[i] = P[i-1]*MOD;\n\t}\n\n\n\tvector<Info> V[128];\n\n\tint Q,S_length,left,P_char_count[128];\n\tscanf(\"%d\",&Q);\n\n\tbool check[Q];\n\n\tfor(int i = 0; i < Q; i++)check[i] = false;\n\n\tchar S[1001];\n\tull S_HASH[1001],S_value,T_value,D;\n\tbool FLG;\n\n\t//Q??¶??????????????\\???????¨????\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",S);\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tP_char_count[i] = 0;\n\t\t}\n\n\t\tfor(S_length = 0;S[S_length] != '\\0';S_length++){\n\t\t\tP_char_count[S[S_length]]++;\n\t\t}\n\n\t\tFLG = true;\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tif(T_char_count[i] < P_char_count[i]){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG)continue;\n\n\n\t\tS_HASH[0] = 0;\n\t\tfor(int i = 1; i <= S_length; i++){\n\t\t\tS_HASH[i] = S[i-1] + S_HASH[i-1]*MOD;\n\t\t}\n\n\t\tS_value = S_HASH[S_length];\n\n\t\tV[S[0]].push_back(Info(S_length,loop,S_value));\n\t}\n\n\tint calc_length;\n\n\tfor(int word = 48; word <= 122; word++){\n\t\tfor(int i = 0; i < V[word].size();i++){\n\n\t\t\tlocRecord.init_index();\n\n\t\t\tcalc_length = V[word][i].length;\n\t\t\tS_value = V[word][i].hashValue;\n\n\t\t\tD = P[calc_length];\n\n\t\t\twhile((left = locRecord.next_loc(word)) != -1){\n\t\t\t\tif(left+calc_length-1 >= T_length)break;\n\n\t\t\t\tT_value = HASH[left+calc_length]-HASH[left]*D;\n\n\t\t\t\tif(T_value == S_value){\n\t\t\t\t\tcheck[V[word][i].id] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tif(check[i])printf(\"1\\n\");\n\t\telse{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n#include<cstdlib>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow, *phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow = (ull *)malloc(n+1);\n    phash = (ull *)malloc(n+1);\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }  \n};\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  const int n = SZ(a);\n  if(n>1){\n    vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(b,rh), mergesort(c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==SZ(c))a[i]=b[j++];\n      else if(j==SZ(b))a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  mergesort(sa,rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000000];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nvector<int> dat;\nvector<int> tmp;\n\nint doubles, lengths;\n\nbool compare_suffix(int i, int j)\n{\n\tif (dat[i] == dat[j])\n\t{\n\t\tint ri = (i + doubles <= lengths ? dat[i + doubles] : -1);\n\t\tint rj = (j + doubles <= lengths ? dat[j + doubles] : -1);\n\n\t\treturn ri < rj;\n\t}\n\n\treturn dat[i] < dat[j];\n}\n\nvector<int> suffix_array(string S)\n{\n\tlengths = S.size();\n\n\tvector<int> arrays(lengths + 1);\n\n\tdat.resize(lengths + 1);\n\ttmp.resize(lengths + 1);\n\n\tfor (int i = 0; i <= lengths; i++)\n\t{\n\t\tarrays[i] = i;\n\n\t\tdat[i] = i < lengths ? S[i] : -1;\n\t}\n\n\tfor (doubles = 1; doubles <= lengths; doubles <<= 1)\n\t{\n\t\tsort(arrays.begin(), arrays.begin() + lengths + 1, compare_suffix);\n\n\t\ttmp[arrays[0]] = 0;\n\n\t\tfor (int i = 1; i <= lengths; i++)\n\t\t{\n\t\t\ttmp[arrays[i]] = tmp[arrays[i - 1]] + (compare_suffix(arrays[i - 1], arrays[i]) ? 1 : 0);\n\t\t}\n\n\t\tfor (int i = 0; i <= lengths; i++)\n\t\t{\n\t\t\tdat[i] = tmp[i];\n\t\t}\n\t}\n\n\treturn arrays;\n}\n\nint main()\n{\n\tstring S, T; int Q;\n\t\n\twhile (true)\n\t{\n\t\tchar c = getchar();\n\n\t\tif (c == '\\n') break;\n\n\t\tS += c;\n\t}\n\n\tscanf(\"%d\", &Q); getchar();\n\n\tvector<int> sa = suffix_array(S);\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tT = \"\";\n\n\t\twhile (true)\n\t\t{\n\t\t\tchar c = getchar();\n\n\t\t\tif (c == '\\n') break;\n\n\t\t\tT += c;\n\t\t}\n\n\t\tint l = 0;\n\t\tint r = sa.size();\n\n\t\tbool flag = false;\n\n\t\twhile (r - l > 1)\n\t\t{\n\t\t\tint m = (l + r) / 2;\n\n\t\t\tstring S1 = S.substr(sa[m], T.size());\n\n\t\t\tif (S1 == T)\n\t\t\t{\n\t\t\t\tflag = true; break;\n\t\t\t}\n\t\t\t\n\t\t\tif (S1 < T)\n\t\t\t{\n\t\t\t\tl = m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = m;\n\t\t\t}\n\t\t}\n\n\t\tif (flag)\n\t\t{\n\t\t\tprintf(\"1\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp,rev;\n  SuffixArray(){}\n  SuffixArray(string& S):S(S){init();}\n  void init(){\n    n=S.length();\n    S.push_back('$');\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    sa.clear();\n    sa.resize(n+1,0);\n    iota(sa.begin(),sa.end(),0);\n    sort(sa.begin(),sa.end(),\n\t [&](int a,int b){\n\t   if(S[a]==S[b]) return a>b;\n\t   return S[a]<S[b];\n\t });\n    vector<int> c(n+1,0),r(n+1),cnt(n+1),s(n+1);\n    for(int i=0;i<=n;i++) r[i]=S[i];\n    for(int len=1;len<=n;len*=2){\n      for(int i=0;i<=n;i++){\n\t c[sa[i]]=\n\t   i>0 &&\n\t   r[sa[i-1]]==r[sa[i]] &&\n\t   sa[i-1]+len<=n &&\n\t   r[sa[i-1]+len/2]==r[sa[i]+len/2] ?\n\t   c[sa[i-1]]:i;\n      }\n      iota(cnt.begin(),cnt.end(),0);\n      copy(sa.begin(),sa.end(),r.begin());\n      for(int i=0;i<=n;i++){\n\tint s1=r[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n      c.swap(r);\n    }\n  }\n  \n  bool lt_substr(string &T,int si=0,int ti=0){\n    int sn=S.size(),tn=T.size();\n    while(si<sn&&ti<tn){\n      if(S[si]<T[ti]) return 1;\n      if(S[si]>T[ti]) return 0;\n      si++;ti++;\n    }\n    return si>=sn&&ti<tn;\n  }\n  \n  int lower_bound(string& T){\n    int low=0,high=n+1;\n    while(low+1<high){\n      int mid=(low+high)/2;\n      if(lt_substr(T,sa[mid],0)) low=mid;\n      else high=mid;\n    }\n    return high;\n  }\n  \n  int upper_bound(string& T){\n    T.back()++;\n    int res=lower_bound(T);\n    T.back()--;\n    return res;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string& T){\n    return upper_bound(T)-lower_bound(T);\n  }\n  \n  void build_lcp(){\n    lcp.assign(n,0);\n    rev.assign(n+1,0);\n    for(int i=0;i<=n;i++) rev[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[rev[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[rev[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n  \n  struct RMQ{\n    vector<vector<int> > dat;\n    vector<int> ht;\n    \n    void init(int n){\n      int h=1;\n      while((1<<h)<n) h++;\n      dat.assign(h,vector<int>(n));\n      ht.assign(n+1,0);\n      for(int j=2;j<=n;j++) ht[j]=ht[j>>1]+1;\n    }\n    \n    void build(int n,vector<int> &v){\n      int h=1;\n      while((1<<h)<n) h++;\n      for(int j=0;j<n;j++) dat[0][j]=v[j];\n      for(int i=1,p=1;i<h;i++,p<<=1)\n\tfor(int j=0;j<n;j++)\n\t  dat[i][j]=min(dat[i-1][j],dat[i-1][min(j+p,n-1)]);\n    };\n    \n    int query(int a,int b){\n      if(a>b) swap(a,b);\n      int l=b-a;\n      return min(dat[ht[l]][a],dat[ht[l]][b-(1<<ht[l])]);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n\n  int lower_bound2(string &T){\n    int sl=S.length(),tl=T.length();\n    if(lt_substr(T,sa[sl-1],0)) return sl;\n    int p=tl;\n    int low=0,high=sl-1;\n    int l=getlcp(sa[low],T,0);\n    int r=getlcp(sa[high],T,0);\n    while(low+1<high){\n      int mid=(low+high)/2;\n      int k;\n      if(l>=r){\n\tint m=rmq.query(low,mid);\n\tif(m<l){\n\t  high=mid,r=m;\n\t  continue;\n\t}\n\tk=l+getlcp(sa[mid],T,l);\n      }else{\n\tint m=rmq.query(mid,high);\n\tif(m<r){\n\t  low=mid,l=m;\n\t  continue;\n\t}\n\tk=r+getlcp(sa[mid],T,r);\n      }\n      if(k==p) high=mid,r=k;\n      else if(S[sa[mid]+k]<T[k]) low=mid,l=k;\n      else high=mid,r=k;\n    }\n\t\t\t\t \n    return high;\n  }\n\n  int upper_bound2(string &T){\n    T.back()++;\n    int res=lower_bound2(T);\n    T.back()--;\n    return res;\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string& T){\n    return  upper_bound2(T)-lower_bound2(T);\n  }\n};\n\nint main(){\n\tstring a;\n\tcin>>a;\n\tSuffixArray S(a);\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tcin>>a;\n\t\tif(S.count2(a))cout<<1<<endl;\n\t\telse cout<<0<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    //return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n    return i+k >= n ? 0 : j+k >= n ? 1 : s[i+k] < s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n/2+n%2,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==nc)a[i]=b[j++];\n      else if(j==nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  /*\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n  */\n  int sa[rh.n+1];\n  REP(i,rh.n+1)sa[i]=i;\n  sort(sa,sa+rh.n+1,rh);\n  vector<int>res(rh.n+1);\n  REP(i,rh.n+1)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n-nb,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    //REP(i,nc)c[i]=a[nb+i];\n    for(int i=nb;i<=nc;i++)c[i-nb]=a[i-1];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k>=nc)a[i]=b[j++];\n      else if(j>=nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<stdio.h>\n\n#define A 1995455101 // large prime number.\n#define B 1995455447 // large prime number, bigger than A.\n\nint main()\n{\n    string T; cin >> T; int len_T = T.size();\n    string P;           int len_P;\n    long long *has_T, *has_P;\n    has_T = new long long [len_T];\n    has_P = new long long [10001];\n    long long last_has;\n\n    long long h; int i;  // hash coding.\n    h = 0;\n    for(i = 0; i < len_T; i++){ h = (h * A + T[i]) % B; has_T[i] = h; }\n\n\tlong long pow[1001]; // pow[i] = A^i mod B.\n\tpow[0] = 1;\n\tfor(i = 1; i < 1001; i++){ pow[i] = (pow[i - 1] * A) % B; }\n\n    int q;\n    cin >> q;\n    while(q){\n        cin >> P; len_P = P.size();\n\n        h = 0;\n        for(i = 0; i < len_P; i++){ h = (h * A + P[i]) % B; has_P[i] = h; }\n        last_has = has_P[len_P - 1];\n\n        for(i = len_P - 1; i < len_T; i++){\n            if(has_T[i] == ((i >= len_P ? has_T[i - len_P] : 0) * pow[len_P] + last_has) % B){\n                printf(\"%d\\n\", 1); break;\n            }\n        }\n        if(i == len_T){ printf(\"%d\\n\", 0); }\n        q--;\n    };\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//\n// ?????¢\n// XCode??§???EOF??\\??????Ctrl+D\n// ?\\???Alt+\\\n// ans???????§?INT?????????2,147,483,647????¶????????????¨??????????????§long long?????£???????????????????????????\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////\n//ALDS1_14_D:   Multiple String Matching\n//Aho-Corasick????????????????????????MLE??????TLE?????£????????§???\n//Suffix-Array????????????\n////////////////////////////////////////\n\n//#define debug //*******************************************************************************************************************************************\n#ifdef debug\n#include <chrono>\n#endif\n\n#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstring> //memcpy\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <map>\n//#include <unordered_map> //hash func.\n#include <fstream> //ifstream, ofstream\n#include <iterator> //insert_iterator::inserter\n\n\n//#define NDEBUG //If NDEBUG is defined before #include <cassert>, assert will be ignored. You had better define NDEBUG when u submit the code.\n#include <cassert> //assert\n\nusing namespace std;\n\n\n#define dout cout\n//If u wanna output to a text file instead of standard output, plz define OUTPUTFILE.\n//#define OUTPUTFILE \"output.txt\" //*******************************************************************************************************************************************\n#ifdef OUTPUTFILE\n#define dout outputfile\nofstream outputfile(OUTPUTFILE);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n\n#define din cin\n//If u wanna input from a text file instead of standard input, plz define INPUTFROMTEXTFILE???.\n//#define INPUTFILE \"input.txt\" //*******************************************************************************************************************************************\n#ifdef INPUTFILE\n#define din inputfile\nifstream inputfile(INPUTFILE);\n#endif\n\n#define scan(A) scanf(\"%d\", &(A))\n#define disp(A) dout << #A << \" = \" << setw(3) << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \"\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n//#define dispAll(A,n) cout << #A << \" = \"; rep(j, 0, (n)) {cout << setw(3) << A[j] << \" \";} cout << endl\n\n#define sign(x) ((x)>0)-((x)<0) //x<0: -1, x=0: 0, x>0: +1\n#define p(i) (i)/2\n#define l(i) (i)*2\n#define r(i) (i)*2+1\n\nint dx[] = {1,-1, 0, 0, 1, 1,-1,-1}; //???????????????????????????????¨??????????????????????????????????\nint dy[] = {0, 0,-1, 1,-1, 1, 1,-1};\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef unsigned long ull;\n\nconst int INF = (int)2e9+10;\nconst ll INF_LL = (ll)9e18-1LL; //Be careful for overflow.\nconst ull INF_ULL = (ull)1e19-1ULL;\nconst int NONE = -1;\nconst ll MOD = (ll)1e9+7; //??§???????´???°?????£??¨??¨????????°????????????10???7??????\n\nconst int N_MAX = 1000010; //num of vertex or element\nconst int M_MAX = 10010; //num of edge\nconst int DATA_MAX = 1010;\n\nint N;\n\nchar T[N_MAX];\nint SA[N_MAX];\nint Rank[N_MAX];\nint tmp[N_MAX];\nint k;\n\nint Q;\nchar* P[M_MAX];\nvi placeOfP[M_MAX];\n\n#ifdef debug\nchar subT[N_MAX];\n#endif\n\nbool compare_sa(int i, int j) { //compare Rank(i, i+k) & Rank(j, j+k)\n    \n    if(Rank[i]!=Rank[j]) return Rank[i] < Rank[j];\n    else {\n        int rank_i = (i+k<N ? Rank[i+k] : -1);\n        int rank_j = (j+k<N ? Rank[j+k] : -1);\n        return rank_i < rank_j;\n    }\n    \n}\n\n\n\n#ifdef debug\nvoid subStr(int i, int k) { //subT = T[i ... i+k]\n    strncpy(subT, T+i, k);\n    subT[k] = '\\0';\n}\n\n\n\nvoid display() {\n    dout << \"-----\\n\";\n    disp(k);\n    \n    \n    rep(i,0,N) {\n        \n        dout << \" i = \";\n        disP(i);\n        dout << \" : SA[i] = \";\n        disP(SA[i]);\n        dout << \" ( \";\n        subStr(SA[i],k); disP(subT);\n        dout << \" ) , Rank = \";\n        disP(Rank[SA[i]]);\n        dout << endl;\n    }\n    \n    dout << \"-----\\n\";\n    dout << \"  i  Rank[i]   Rank[i+k]\\n\";\n    rep(i,0,N) {\n        disP(i);\n        disP(Rank[i]);\n        dout << \" ( \";\n        subStr(i, k); disP(subT);\n        dout << \" ) \";\n        disP( i+k < N ? Rank[i+k] : -1);\n        dout << \" ( \";\n        subStr(i+k, k); disP(subT);\n        dout << \" ) \";\n        dout << endl;\n    }\n}\n#endif\n\n\n\n\nvoid construct_sa() {\n    \n    //initialize\n    k = 1;\n    rep(i,0,N) {\n        SA[i] = i;\n        Rank[i] = T[i]; //k=1?????¨??????Rank[i]=ASCII Code of T[i]\n    }\n    \n    for(k=1; k<N; k*=2) {\n#ifdef debug\n        display();\n#endif\n        \n        sort(SA, SA+N, compare_sa);\n        \n    \n        tmp[ SA[0] ] = 0;\n        rep(i,1,N) {\n            tmp[ SA[i] ] = tmp[ SA[i-1] ] + compare_sa(SA[i-1], SA[i]); //1?????????k???????????§???Rank?????????????????°????????????????¬????????????§???Rank??????????????????\n        }\n        \n        rep(i,0,N) Rank[i] = tmp[i]; //??????????????§?????§????¬????k(=2k)???Rank????¨???????????????????\n        \n    }\n    \n}\n\n\nvoid binarySearch_P_from_SA() {\n\n    rep(i,0,Q) {\n        \n        int lenP = strlen(P[i]);\n        \n        int left = 0;\n        int right = N-1;\n        int mid;\n        \n        while(left <= right) {\n            mid = left + (right - left) / 2;\n            \n            if( strncmp(P[i],T+SA[mid],lenP) == 0 ) {\n                placeOfP[i].push_back(1);\n                break;\n            }\n            else if(strncmp(P[i],T+SA[mid],lenP) < 0) right = mid - 1;\n            else left = mid + 1;\n        }\n        \n    }\n    \n}\n\n\n\n\nint main() {\n    \n    //cin, cout????????????  ?????¨??????cin?????????????????¨??¨cin??§???scanf?????????????????¨??¨scanf??§??±?????????????????????\n    cin.tie(0); //cin??¨cout??????????????????\n    ios::sync_with_stdio(false); //iostream??¨stdio??????????????????\n    \n    //read input data\n    scanf(\"%s\", T);\n    N = strlen(T);\n    \n    scanf(\"%d \", &Q);\n    rep(i,0,Q) {\n        P[i] = (char *)malloc(sizeof(char)*DATA_MAX);\n        scanf(\"%s\", P[i]);\n    }\n    \n#ifdef debug\n    disp(T);\n    disp(N);\n    rep(i,0,Q) { disP(P[i]); disp(strlen(P[i])); }\n#endif\n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //start timer\n    auto startTime = chrono::system_clock::now();\n#endif\n    //------------------------------------------------------------------------------------------\n    \n    \n    //Suffix-Array Algorithm\n    construct_sa();\n    \n    binarySearch_P_from_SA();\n    \n    \n    \n    \n    \n    \n#ifdef debug\n    dout << \"=====================================\\n\";\n    rep(i,0,Q) {\n        disP(P[i]); dout << \" : \";\n        rep(j,0,placeOfP[i].size()) {\n            disP(placeOfP[i][j]);\n        }\n        dout << endl;\n    }\n    dout << \"=====================================\\n\";\n#endif\n    \n    rep(i,0,Q) {\n        printf(\"%d\\n\", placeOfP[i].size()!=0);\n    }\n    \n    \n\n    \n    \n    //------------------------------------------------------------------------------------------\n#ifdef debug\n    //stop timer\n    auto endTime = chrono::system_clock::now();\n    auto dur = endTime - startTime;\n    auto msec = chrono::duration_cast<chrono::milliseconds>(dur).count();\n    dout << fixed << setprecision(4) << (double)msec/1000 << \" sec \\n\";\n#endif\n    //------------------------------------------------------------------------------------------\n    \n#ifdef INPUTFILE\n    inputfile.close();\n#endif\n    \n#ifdef OUTPUTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    build_sa();\n    //build_lcp();\n    //build_rmq();\n  }\n  void build_sa(){\n    S.push_back('$');\n    vector<int> c(n+1,0),ord(n+1,0);\n    for(int i=0;i<=n;i++) ord[i]=n-i;\n    sort(ord.begin(),ord.end(),[&](int a,int b){return S[a]<S[b];});\n    for(int i=0;i<=n;i++){\n      sa[i]=ord[i];\n      c[i]=S[i];\n    }\n    for(int len=1;len<=n;len*=2){\n      vector<int> r=c;\n      for(int i=0;i<=n;i++){\n\t c[sa[i]] =\n\t   i > 0 &&\n\t   r[sa[i - 1]] == r[sa[i]] &&\n\t   sa[i - 1] + len <= n &&\n\t   r[sa[i - 1] + len / 2] == r[sa[i] + len / 2]\n\t   ? c[sa[i - 1]] : i;\n      }\n      vector<int> cnt(n+1);\n      for(int i=0;i<=n;i++) cnt[i]=i;\n      vector<int> s=sa;\n      for(int i=0;i<=n;i++){\n\tint s1=s[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n);\n    for(int i=0;i<n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  return 0;\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    //assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\n\nclass SuffixArray{\n    string s;\n    vector<int> sort_idx, rev;\npublic:\n    // 接尾辞配列を作る\n    SuffixArray(const string &str) : s(str) {\n        int n = s.size();\n        s.push_back('$');\n        sort_idx.resize(n+1);\n        iota(sort_idx.begin(), sort_idx.end(), 0);\n        // 辞書順に並び変えたときのインデックス記録\n        sort(sort_idx.begin(), sort_idx.end(),\n            [&](int a,int b){\n                if(s[a] == s[b]){\n                    return a > b;\n                }\n                return s[a] < s[b];\n            });\n        vector<int> c(n+1), r(n+1), cnt(n+1);\n        for(int i = 0; i <= n; i++){\n            r[i] = s[i];\n        }\n        for(int len = 1; len <= n; len *= 2){\n            for(int i = 0; i <= n; ++i){\n                c[sort_idx[i]] = i;\n                if(i > 0 && r[sort_idx[i-1]] ==r[sort_idx[i]] \n                    && sort_idx[i-1] + len <= n \n                    && r[sort_idx[i-1]+len/2] == r[sort_idx[i]+len/2]){\n                    \n                    c[sort_idx[i]]=c[sort_idx[i-1]];\n                }\n            }\n            iota(cnt.begin(), cnt.end(), 0);\n            copy(sort_idx.begin(), sort_idx.end(), r.begin());\n            for(int i = 0; i <= n; ++i){\n                int s1 = r[i] - len;\n                if(s1 >= 0){\n                    sort_idx[cnt[c[s1]]++]=s1;\n                }\n            }\n            c.swap(r);\n        }\n        rev.resize(n+1);\n        for(int i = 0; i <= n; ++i){\n            rev[sort_idx[i]] = i;\n        }\n    }\n\n    int operator[](int i) const { return sort_idx[i]; }\n\n    // s の中に t があるかどうか\n    bool find(string &t, int s_idx, int t_idx){\n        int s_len = s.size();\n        int t_len = t.size();\n        while(s_idx < s_len && t_idx < t_len){\n            if(s[s_idx] < t[t_idx]){\n                return true;\n            }\n            if(s[s_idx] > t[t_idx]){\n                return false;\n            }\n            s_idx++; t_idx++;\n        }\n        return s_idx == s_len && t_idx < t_len;\n    }\n\n    int lower_bound(string& t){\n        int left = 0;\n        int right = s.size();\n        while(left+1 < right){\n            int mid = (left + right) >> 1;\n            if(find(t, sort_idx[mid], 0)){\n                left = mid;\n            }\n            else{\n                right = mid;\n            }\n        }\n        return right;\n    }\n\n    int upper_bound(string& t){\n        t.back()++;\n        int res = lower_bound(t);\n        t.back()--;\n        return res;\n    }\n\n    int count(string& T){\n        return upper_bound(T) - lower_bound(T);\n    }\n};\n\n\nint main(){\n    \n    string t;\n    int q;\n    cin >> t >> q;\n    \n    SuffixArray sort_idx(t);\n    for(int i = 0; i < q; ++i){\n        string p;\n        cin >> p;\n        if(sort_idx.count(p) > 0){\n            cout << 1 << endl;\n        }\n        else{\n            cout << 0 << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define each(it,c) for(__typeof(c.begin()) it=c.begin(); it!=c.end(); it++)\n#define INF 1<<30\n#define mp make_pair\n#define pb push_back\n\ntypedef vector<int> vi;\n\ntypedef long long ll;\n\nint kmp(string t,string p){\n\tint i,j;\n\tint n = t.size();\n\tint m = p.size();\n\tvi nx(m+1,0);\n\tnx[0] = -1;\n\tfor(i=0,j=-1;i<m;i++,j++,nx[i]=j){\n\t\twhile((j>=0)&&(p[i]!=p[j])) j = nx[j];\n\t}\n\n\tfor(i=0,j=0; j<m && i<n; i++,j++){\n\t\twhile((j>=0)&&(t[i]!=p[j])) j = nx[j];\n\t}\n\n\tif(j==m) return i-m;\n\telse return -1;\n}\n\nint main(){\n\tstring t;\n\tcin>>t;\n\tint n; cin>>n;\n\trep(i,n){\n\t\tstring p;\n\t\tcin>>p;\n\t\tint ans = kmp(t,p);\n\t\tif(ans!=-1) cout<<1<<endl;\n\t\telse cout<<0<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\nusing namespace std;\nstring S, T;\nint main() {\n\tint q;\n\tcin >> S;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> T;\n\t\tif (S.size() >= T.size()) {\n\t\t\tfor (int i = 0; i <= S.size() - T.size(); i++) {\n\t\t\t\tif (T == S.substr(i, T.size())) {\n\t\t\t\t\tprintf(\"%d\\n\", i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] < s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }  \n};\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  const int n = SZ(a);\n  if(n>1){\n    vector<int> b(a.begin(), a.begin()+n/2);\n    vector<int> c(a.begin()+n/2, a.end());\n    mergesort(b,rh);\n    mergesort(c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==SZ(c))a[i]=b[j++];\n      else if(j==SZ(b))a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\n  //mergesort(sa,rh);\n  //if(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    //if(S.compare(sa[c],T.length(),T)<0 )a=c;\n    //else b=c;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  while(n--){\n    cin >> t;\n    cout << contain(s,sa,t) << \"\\n\";\n    //cout << !!rh.find(t) << \"\\n\";\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define MAX 10002\ntypedef unsigned char byte;\nbyte mask[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\n\nint Lv[MAX];\nint n, k;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n    return L_i < L_j;\n}\n\nint main()\n{\n    int A[MAX];\n    char c[MAX];\n    scanf(\"%s\", c);\n    std::string T = std::string(c);\n    n = T.size();\n    byte *t;\n    t = new byte [(n >> 3) + 1];\n\tbool act;\n\tint l, r;\n\n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n\t\n\tbyte bkt[129];\n\tfor(i = 0; i < 129; i++){ bkt[i] = 0; }\n\tfor(i = 0; i < n; i++){ bkt[Lv[i]]++; }\n\tbkt[0] = 0;\n\tfor(i = 0; i < 129; i++){ bkt[i] += bkt[i - 1]; }\n\tfor(i = 0; i < n; i++){ A[bkt[Lv[i]]--] = i; }\n\n    //std::sort(A, A + n, cmp_Lv);\n\n    for(i = 1; i < n; i++){\n        t[i >> 3] = (Lv[A[i]] != Lv[A[i - 1]] ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n    }\n    t[n >> 3] = t[n >> 3] | mask[n & 7];\n\n    Lv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n    }\n\n    k = 1;\n    while(1){\n        if(k > n) break;\n\n        act = true;\n        for(i = 1; i <= n; i++){\n            if(act){\n                if(!!(mask[i & 7] & t[i >> 3])){ continue; }\n                else{ l = i - 1; act = false; }\n            }else{\n                if(!!(mask[i & 7] & t[i >> 3])){\n                    r = i; std::sort(A + l, A + r, cmp); act = true; }\n                    else{ continue; }\n            }\n        }\n\n        for(i = 1; i < n; i++){\n            t[i >> 3] = (cmp(A[i - 1], A[i]) ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n        }\n        t[n >> 3] = t[n >> 3] | mask[n & 7];\n\n        Lv[A[0]] = 0;\n        for(i = 1; i < n; i++){\n            Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n        }\n\n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n\n    char p[1000];\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n\n    A[n] = n;\n\n    while(q){\n        scanf(\"%s\", p);\n        std::string P = std::string(p);\n        left = 0, right = n, exist = false;\n        while(left < right){\n\n            if(n < P.size()){ exist = false; break; }\n\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n\n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n\n  RollingHash(string s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  bool operator()(int i, int j) {\n    int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }\n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n\n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  sort(ALL(sa),rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  while(n--){\n    cin >> t;\n    cout << contain(s,sa,t) << \"\\n\";\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    build_sa();\n    //build_lcp();\n    //build_rmq();\n  }\n  void build_sa(){\n    vector<int> c(n+1,0),ord(n+1,0);\n    for(int i=0;i<=n;i++) ord[i]=n-i;\n    sort(ord.begin(),ord.end(),[&](int a,int b){return S[a]<S[b];});\n    \n    for(int i=0;i<=n;i++){\n      sa[i]=ord[i];\n      c[i]=i<n?S[i]:-1;\n    }\n    \n    for(int len=1;len<=n;len*=2){\n      vector<int> r=c;\n      for(int i=0;i<=n;i++){\n\t c[sa[i]] = i > 0 && r[sa[i - 1]] == r[sa[i]] && sa[i - 1] + len < n && r[sa[i - 1] + len / 2] == r[sa[i] + len / 2] ? c[sa[i - 1]] : i;\n      }\n      vector<int> cnt(n+1);\n      for(int i=0;i<=n;i++) cnt[i]=i;\n      vector<int> s=sa;\n      for(int i=0;i<=n;i++){\n\tint s1=s[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n    }\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n);\n    for(int i=0;i<n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    //assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S 1000005\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\nstruct d{\n  int a,b,c;\n  d(){}\n  d(int A,int B,int C){\n    a=A,b=B,c=C;\n  };\n  bool operator<(const d&r)const{\n    if(a!=r.a)return a<r.a;\n    return b<r.b;\n  }\n};\n\nint n,slen,tlen,r[S];\nchar s[S],t[N];\nd ran[S];\nP a[S];\n\nvoid init(){\n  for(int i=0;i<26;i++)\n    for(int j=0;j<slen;j++)\n      if('a'+i==s[j])r[j]=i+1;\n  int x=1;\n  while(x<slen){\n    for(int i=0;i<slen;i++){\n      int a=i+x;\n      if(a>slen)a=slen;\n      ran[i]=d(r[i],r[a],i);\n    }\n    sort(ran,ran+slen);\n    int cnt=1;\n    for(int i=0;i<slen;i++){\n      r[ran[i].c]=cnt;\n      if(ran[i].a==ran[i+1].a&&ran[i].b==ran[i+1].b)\n\tcontinue;\n      cnt++;\n    }\n    x*=2;\n  }\n  for(int i=0;i<slen;i++)a[i]=P(r[i],i);\n  sort(a,a+slen+1);\n}\n\nbool bynary_search(){\n  int L=0,R=slen;\n  while(L<R){\n    int M=(L+R)/2;\n    if(strncmp(s+a[M].second,t,tlen)<0)L=M+1;\n    else R=M;\n  }\n  if(!strncmp(s+a[L].second,t,tlen))return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s%d\",s,&n);\n  slen=strlen(s);\n  init();  \n  while(n--){\n    scanf(\"%s\",t);\n    tlen=strlen(t);\n    if(bynary_search())printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\nusing namespace std;\nstring S, T;\nint main() {\n\tint q,sum;\n\tcin >> S;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tsum = 0;\n\t\tcin >> T;\n\t\tif (S.size() >= T.size()) {\n\t\t\tfor (int i = 0; i <= S.size() - T.size(); i++) {\n\t\t\t\tif(i>=100){\n\t\t\t\t\tgoto Exit2;\n\t\t\t\t}\n\t\t\t\tif (T == S.substr(i, T.size())) {\n\t\t\t\t\tcout << \"1\" << endl;\n\t\t\t\t\tgoto Exit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tExit2:;\n\t\tcout << \"0\" << endl;\n\tExit:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nclass StringSearch {\n\tconst int n;\n\tstring S;\n\tvector<int> SA, Rank;\npublic:\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), SA(n + 1), Rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tSA[i] = i;\n\t\t\tRank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (Rank[i] != Rank[j]) return Rank[i] < Rank[j];\n\t\t\t\telse {\n\t\t\t\t\tint ri = i + k <= n ? Rank[i + k] : -1;\n\t\t\t\t\tint rj = j + k <= n ? Rank[j + k] : -1;\n\t\t\t\t\treturn ri < rj;\n\t\t\t\t}\n\t\t\t};\n\t\t\tsort(SA.begin(), SA.end(), Compare_SA);\n\n\t\t\ttmp[SA[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[SA[i]] = tmp[SA[i - 1]] + (Compare_SA(SA[i - 1], SA[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tRank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(SA[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(SA[b], T.length(), T) == 0;\n\t}\n};\n\nint main()\n{\n\tint Q;\n\tstring T, P;\n\tcin.sync_with_stdio(false);\n\tcin >> T;\n\tStringSearch SS(T);\n\tcin >> Q;\n\twhile (Q--) {\n\t\tcin >> P;\n\t\tcout << SS.Contain(P) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n\nusing namespace std;\n\nstring S; int Q; char STR[1005];\n\nint main()\n{\n\tcin >> S >> Q;\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%s\", STR);\n\n\t\tprintf(\"%d\\n\", S.find(STR) != -1 ? 1 : 0);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nstruct SuffixArray {\n  int N, k;\n  string S;\n  vector<int> sa, rank, tmp;\n  vector<int> lcp, rank_lcp;\n  SuffixArray(string S) : S(S) {\n    N = S.size();\n    sa.resize(N+1), rank.resize(N+1), tmp.resize(N+1);\n    construct();\n  }\n\n  void construct() {\n    for (int i = 0; i <= N; i++) {\n      sa[i] = i;\n      rank[i] = i < N ? S[i] : -1;\n    }\n\n    function<bool(int, int)> compare = [&](int i, int j) {\n      if (rank[i] != rank[j]) {\n        return rank[i] < rank[j];\n      } else {\n        int ri = i + k <= N ? rank[i + k] : -1;\n        int rj = j + k <= N ? rank[j + k] : -1;\n        return ri < rj;\n      }\n    };\n    for (k = 1; k <= N; k *= 2) {\n      sort(sa.begin(), sa.end(), compare);\n\n      tmp[sa[0]] = 0;\n      for (int i = 1; i <= N; i++) {\n        tmp[sa[i]] = tmp[sa[i-1]] + (compare(sa[i-1], sa[i]) ? 1 : 0);\n      }\n      for (int i = 0; i <= N; i++) rank[i] = tmp[i];\n    }\n  }\n\n  bool contain(string T) {\n    int left = 0, right = N;\n    while (left + 1 < right) {\n      int mid = (left + right) / 2;\n      (S.compare(sa[mid], T.length(), T) < 0 ? left : right) = mid;\n    }\n    return S.compare(sa[right], T.length(), T) == 0;\n  }\n\n  void construct_lcp() {\n    lcp.resize(N), rank_lcp.resize(N+1);\n    for (int i = 0; i <= N; i++) rank_lcp[sa[i]] = i;\n\n    int h = 0;\n    lcp[0] = 0;\n    for (int i = 0; i < N; i++) {\n      int j = sa[rank[i] - 1];\n\n      if (h > 0) h--;\n      for (; j + h < N and i + h < N; h++) {\n        if (S[j + h] != S[i + h]) break;\n      }\n\n      lcp[rank[i] - 1] = h;\n    }\n  }\n};\n\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  string T; cin >> T;\n  SuffixArray sa(T);\n  int Q; cin >> Q;\n  REP(_, Q) {\n    string P; cin >> P;\n    cout << sa.contain(P) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n-nb,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    //REP(i,nc)c[i]=a[nb+i];\n    for(int i=nb;i<nc;i++)c[i-nb]=a[i-1];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k>=nc)a[i]=b[j++];\n      else if(j>=nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define MAX 10002\ntypedef unsigned char byte;\nbyte mask[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\n\nint Lv[MAX];\nint n, k;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n    return L_i < L_j;\n}\n\nint main()\n{\n    int A[MAX];\n    char c[MAX];\n    scanf(\"%s\", c);\n    std::string T = std::string(c);\n    n = T.size();\n    byte *t;\n    t = new byte [(n >> 3) + 1];\n\tbool act;\n\tint l, r;\n\n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n\n    int bkt[129];\n    for(i = 0; i < 129; i++){ bkt[i] = 0; }\n    for(i = 0; i < n; i++){ bkt[Lv[i]]++; }\n    int sum = 0;\n    for(i = 0; i < 129; i++){ sum += bkt[i]; bkt[i] = sum; }\n    for(i = 0; i < n; i++){ A[--bkt[Lv[i]]] = i; }\n\n    //std::sort(A, A + n, cmp_Lv);\n\n    for(i = 1; i < n; i++){\n        t[i >> 3] = (Lv[A[i]] != Lv[A[i - 1]] ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n    }\n    t[n >> 3] = t[n >> 3] | mask[n & 7];\n\n    Lv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n    }\n\n    k = 1;\n    while(1){\n        if(k > n) break;\n\n        act = true;\n        for(i = 1; i <= n; i++){\n            if(act){\n                if(!!(mask[i & 7] & t[i >> 3])){ continue; }\n                else{ l = i - 1; act = false; }\n            }else{\n                if(!!(mask[i & 7] & t[i >> 3])){\n                    r = i; std::sort(A + l, A + r, cmp); act = true; }\n                    else{ continue; }\n            }\n        }\n\n        for(i = 1; i < n; i++){\n            t[i >> 3] = (cmp(A[i - 1], A[i]) ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n        }\n        t[n >> 3] = t[n >> 3] | mask[n & 7];\n\n        Lv[A[0]] = 0;\n        for(i = 1; i < n; i++){\n            Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n        }\n\n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n\n    char p[1000];\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n\n    A[n] = n;\n\n    while(q){\n        scanf(\"%s\", p);\n        std::string P = std::string(p);\n        left = 0, right = n, exist = false;\n        while(left < right){\n\n            if(n < P.size()){ exist = false; break; }\n\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n\n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int B=999999937;\nconst int P=1000000007;\n\nvector<long long> gen_hash(const string &s){\n\tvector<long long> hash(s.size());\n\tlong long c=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tc=(c*B+s[i])%P;\n\t\thash[i]=c;\n\t}\n\treturn hash;\n}\nlong long pow_binary_mod(long long x,long long y,long long mod){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%mod;\n\t\tx=x*x%mod;\n\t}\n\treturn z;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s;\n\tcin>>s;\n\tvector<long long> v=gen_hash(s);\n\n\tint T;\n\tfor(cin>>T;T--;){\n\t\tstring q;\n\t\tcin>>q;\n\t\tlong long hash=gen_hash(q)[q.size()-1];\n\t\tlong long Brev=pow_binary_mod(B,q.size(),P);\n\t\t//vector<int> r;\n\t\tint i=q.size()-1;\n\t\tfor(;i<s.size();i++){\n\t\t\tif(v[i]==((i==q.size()-1?0:v[i-q.size()])*Brev)%P)break;//r.push_back(i-q.size()+1);\n\t\t}\n\t\tif(i<s.size()){\n\t\t\t//for(int i=0;i<r.size();i++)printf(\"%d\\n\",r[i]);\n\t\t\tputs(\"1\");\n\t\t}else{\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nstruct SAComp{\n\tconst int h,*g;\n\tSAComp(const int h, const int* g) : h(h), g(g) {}\n\tbool operator()(const int a, const int b){\n\t\treturn a == b ? false : g[a] != g[b] ? g[a] < g[b] : g[a+h] < g[b+h];\n\t}\n};\nvector<int> buildSA(string &t){\n\tint n=t.size();\n\tint g[n],b[n];\n\tvector<int>suff(n);\n\tfor(int i=0;i<n;i++)suff[i]=i,g[i]=t[i];\n\tb[0]=b[n-1]=0;\n\tsort(suff.begin(),suff.end(),SAComp(0,g));\n\tfor(int h=1;b[n-1]!=n-1;h<<=1){\n\t\tSAComp comp(h,g);\n\t\tsort(suff.begin(),suff.end(),comp);\n\t\tfor(int i=0;i<n-1;i++)b[i+1]=b[i]+comp(suff[i],suff[i+1]);\n\t\tfor(int i=0;i<n;i++)g[suff[i]]=b[i];\n\t}\n\treturn suff;\n}\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s;\n\tcin>>s;\n\ts+='$';\n\tint n=s.size();\n\tvector<int>suff=buildSA(s);\n\tvector<pair<char,int>>sorted(n);\n\tfor(int i=0;i<n;i++)sorted[i]={s[(suff[i]-1+n)%n],i};\n\tsort(sorted.begin(),sorted.end());\n\n\tint T;\n\tfor(cin>>T;T--;){\n\t\tstring q;\n\t\tcin>>q;\n\t\tint start=0,stop=n,idx=q.size()-1;\n\t\tfor(;idx>=0;idx--){\n\t\t\tpair<char,int> ql={q[idx],start},qr={q[idx],stop};\n\t\t\tstart=lower_bound(sorted.begin(),sorted.end(),ql)-sorted.begin();\n\t\t\tstop=lower_bound(sorted.begin(),sorted.end(),qr)-sorted.begin();\n\t\t\tif(start==stop)break;\n\t\t}\n\t\tif(idx<0){\n\t\t\t//{vector<int>v;for(;start<stop;start++)v.push_back(suff[start]);sort(v.begin(),v.end());for(auto &e:v)printf(\"%d\\n\",e);}\n\t\t\tputs(\"1\");\n\t\t}else{\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair< P , int > PP;\n\nvector<int> suffixArray(char* s){\n  \n  int len=strlen(s);\n  vector<int> res(len+1);\n  vector< PP > tmp(len+1);\n  \n  for(int i=0;i<=len;i++)res[i]=s[i];\n  \n  for(int k=1;k<=len;k*=2){\n    \n    for(int i=0;i<=len;i++){\n      tmp[i].first.first=res[i];\n      tmp[i].first.second=(i+k<=len?res[i+k]:0);\n      tmp[i].second=i;\n    }\n    sort(tmp.begin(),tmp.end());\n    int C=0;\n    for(int i=0;i<=len;i++){\n      int id=tmp[i].second;\n      if(i&& (tmp[i-1].first<tmp[i].first))C++;\n      res[id]=C;\n    }\n  }\n\n  vector<int> res2(len+1);\n  for(int i=0;i<=len;i++)res2[ res[i] ]=i;\n  return res2;\n}\n\nchar s[1000005];\nchar t[1000005];\nint main(){\n  scanf(\"%s\",s);\n  vector<int> ans=suffixArray(s);\n\n  int Q;\n  scanf(\"%d\",&Q);\n  \n  while(Q--){\n    scanf(\"%s\",t);\n    int len=strlen(t);\n    int l=0,r=ans.size(),m;\n    while(r-l>1){\n      m=(l+r)/2;\n      if( strncmp( s+ans[m] , t ,len ) <=0 )l=m;\n      else r=m;\n    }\n    if(strncmp(s+ans[l],t,len)==0)printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  \n  /*\n  for(int i=0;i<(int)ans.size();i++){\n    printf(\"%d %s\\n\",ans[i], (s+ans[i]) );\n  }\n  */\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nclass SuffixArray {\npublic:\n  string &s;\n  vector<int> sa;\n  int n;\n  SuffixArray(string &str) : s(str){\n    n = s.size();\n  }\n  void construct_sa(){\n    sa.resize(n+1);\n    vector<int> rank(n+1);\n    rep(i,n+1){\n      sa[i]=i;\n      rank[i] = (i<n)?s[i]:(-1);\n    }\n    for(int k=1; k<=n; k*=2){\n      function<bool(int,int)> comp = [&](int i, int j){\n        if(rank[i]!=rank[j]) return rank[i]<rank[j];\n        int ri = (i+k<=n)?(rank[i+k]):-1;\n        int rj = (j+k<=n)?(rank[j+k]):-1;\n        return ri < rj;\n      };\n      sort(all(sa), comp);\n      vector<int> tmp(n+1,0);\n      tmp[sa[0]]=0;\n      repl(i,1,n+1){\n        tmp[sa[i]] = tmp[sa[i-1]];\n        if(comp(sa[i-1], sa[i])) tmp[sa[i]]++;\n      }\n      swap(tmp, rank);\n    }\n  }\n  bool contain(const string &t){\n    int m = t.size();\n    int l = 0, r = n;\n    while(r-l>1){\n      int mid = (r+l)/2;\n      if(s.compare(sa[mid], m, t) < 0) l = mid;\n      else r = mid;\n    }\n    return s.compare(sa[r], m, t) == 0;\n  }\n};\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0); cout.tie(0);\n  string t;\n  int q;\n  cin>>t>>q;\n\n  SuffixArray sa(t);\n  sa.construct_sa();\n\n  rep(_,q){\n    string p;\n    cin>>p;\n    cout << sa.contain(p) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <unordered_map> \n#include <unordered_set>\n#include <functional>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\ntypedef tuple<int, int, int> T;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\n// 入力文字列は vector<int> 型に直し、後ろに番兵として存在しない小さな値(0 とか)を追加すること\n\n// suffix array, LCP array を O(N) で構築する。\n// 部分文字列の検索は、クエリの文字数を M として O(M + log(N)) である。\n\nbool isLMS(vector<int> &t, int i){\n\treturn i > 0 && t[i - 1] == 'L' && t[i] == 'S';\n}\n\nvector<int> inducedSort(vector<int> &s, int k, vector<int> &t, vector<int> &seed){\n\tvector<int> sa(s.size(), -1);\n\t// 文字 c で始まる文字列は、sa の bin[c] ~ bin[c + 1] - 1 番目に入る\n\tvector<int> bin(k + 1);\n\tfor(int c : s){\n\t\tbin[c + 1] += 1;\n\t}\n\tfor(int i = 0; i < k; i++){\n\t\tbin[i + 1] += bin[i];\n\t}\n\t// LMS 型の文字列のインデックスを、sa の bin[c] ~ bin[c + 1] - 1 番目に後ろの方から入れる\n\tvector<int> cnt(k, 0);\n\treverse(seed.begin(), seed.end());\n\tfor(int i : seed){\n\t\tint c = s[i];\n\t\tsa[bin[c + 1] - 1 - cnt[c]] = i;\n\t\tcnt[c] += 1;\n\t}\n\t// L 型の文字列のインデックスを、sa の先頭から埋めていく\n\tcnt.clear();\n\tcnt.resize(k, 0);\n\tfor(int pos = 0; pos < sa.size(); pos++){\n\t\tint i = sa[pos];\n\t\tif(i == -1 || i == 0 || t[i - 1] == 'S'){\n\t\t\tcontinue;\n\t\t}\n\t\tint c = s[i - 1];\n\t\tsa[bin[c] + cnt[c]] = i - 1;\n\t\tcnt[c] += 1;\n\t}\n\t// S 型の文字列のインデックスを、sa の後ろ側から埋めていく。LMS 型は上書きされる\n\tcnt.clear();\n\tcnt.resize(k, 0);\n\tfor(int pos = sa.size() - 1; pos >= 0; pos--){\n\t\tint i = sa[pos];\n\t\tif(i == -1 || i == 0 || t[i - 1] == 'L'){\n\t\t\tcontinue;\n\t\t}\n\t\tint c = s[i - 1];\n\t\tsa[bin[c + 1] - 1 - cnt[c]] = i - 1;\n\t\tcnt[c] += 1;\n\t}\n\treturn sa;\n}\n\nvector<int> saIs(vector<int> &s, int k){\n\t// L 型と S 型の文字列を分類\n\tvector<int> t(s.size());\n\tt[s.size() - 1] = 'S';\n\tfor(int i = s.size() - 2; i >= 0; i--){\n\t\tif(s[i] < s[i + 1]){\n\t\t\tt[i] = 'S';\n\t\t}else if(s[i] > s[i + 1]){\n\t\t\tt[i] = 'L';\n\t\t}else{\n\t\t\tt[i] = t[i + 1];\n\t\t}\n\t}\n\t// LMS 型の文字列のインデックスを取り出す\n\tvector<int> lmss, seed;\n\tfor(int i = 0; i < s.size(); i++){\n\t\tif(isLMS(t, i)){\n\t\t\tlmss.push_back(i);\n\t\t\tseed.push_back(i);\n\t\t}\n\t}\n\t// seed から sa を構築し、LMS 型の文字列の辞書順を取得\n\tvector<int> sa = inducedSort(s, k, t, seed);\n\tvector<int> sa_;\n\tfor(int i : sa){\n\t\tif(isLMS(t, i)){\n\t\t\tsa_.push_back(i);\n\t\t}\n\t}\n\tsa = sa_;\n\t// LMS 間の部分文字列を、辞書順を保った数字に置き換える\n\tvector<int> nums(s.size() + 1, -1);\n\tnums[sa[0]] = 0;\n\tint num = 0;\n\tfor(int pos = 0; pos < sa.size() - 1; pos++){\n\t\tint i = sa[pos], j = sa[pos + 1];\n\t\tbool diff = false;\n\t\tfor(int d = 0; d < s.size(); d++){\n\t\t\tif(s[i + d] != s[j + d] || isLMS(t, i + d) != isLMS(t, j + d)){\n\t\t\t\tdiff = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(d > 0 && (isLMS(t, i + d) || isLMS(t, j + d))){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(diff){\n\t\t\tnum += 1;\n\t\t}\n\t\tnums[j] = num;\n\t}\n\tvector<int> nums_;\n\tfor(int i : nums){\n\t\tif(i >= 0){\n\t\t\tnums_.push_back(i);\n\t\t}\n\t}\n\tnums = nums_;\n\t// 辞書順を保った数字に重複がある場合、再帰\n\t// そうでない場合、LMS 部分文字列(seed) の正しい順序を求められる\n\tvector<int> seedOrder;\n\tif(num + 1 < nums.size()){\n\t\tseedOrder = saIs(nums, num + 1);\n\t}else{\n\t\tseedOrder.resize(nums.size());\n\t\tfor(int i = 0; i < nums.size(); i++){\n\t\t\tseedOrder[nums[i]] = i;\n\t\t}\n\t}\n\tseed.clear();\n\tfor(int i : seedOrder){\n\t\tseed.push_back(lmss[i]);\n\t}\n\t// 正しい seed で sa を求める\n\tsa = inducedSort(s, k, t, seed);\n\treturn sa;\n}\n\nvector<int> LCP(vector<int> &s, vector<int> &sa){\n\t// rnk[i] : S[i:] は sa の中で何番目か\n\tvector<int> rnk(sa.size());\n\tfor(int i = 0; i < sa.size(); i++){\n\t\trnk[sa[i]] = i;\n\t}\n\t// S[i:] と S[sa[rnk[i] + 1]:] の lcp を求める\n\tvector<int> lcpArray(sa.size());\n\tint lcp = 0;\n\tfor(int i = 0; i < sa.size(); i++){\n\t\tint index = rnk[i];\n\t\tif(index == sa.size() - 1){\n\t\t\tlcp = 0;\n\t\t\tlcpArray[index] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tint pos1 = sa[index];\n\t\tint pos2 = sa[index + 1];\n\t\twhile(s[pos1 + lcp] == s[pos2 + lcp]){\n\t\t\tlcp += 1;\n\t\t}\n\t\tlcpArray[index] = lcp;\n\t\tlcp = max(lcp - 1, 0);\n\t}\n\treturn lcpArray;\n}\n\nint const TREE_SIZE = (1 << 21);\n\nclass SegTree{\n\tpublic:\n\t// コンストラクタ\n\tSegTree(std::function<long long int(long long int, long long int)> monoidFunc_, long long int invalidValue_){\n\t\tmonoidFunc = monoidFunc_;\n\t\tinvalidValue = invalidValue_;\n\t}\n\t// 値の初期化\n\tvoid init(long long int initValue){\n\t\tfor(int i = 0; i < TREE_SIZE; i++){\n\t\t\tsegTree[i] = initValue;\n\t\t}\n\t}\n\t// a番目(0-indexed)をwに変更する O(log N)\n\tvoid change(int a, long long int w){\n\t\tchange_(a + 1, w);\n\t}\n\t// 区間 [a, b] (0-indexed)の値を求める O(log N)\n\tlong long int query(int a, int b){\n\t\treturn query_(a + 1, b + 2, 1, 0, TREE_SIZE / 2);\n\t}\n\tprivate:\n\tfunction<long long int(long long int, long long int)> monoidFunc;\n\tlong long int invalidValue;\n\tlong long int segTree[TREE_SIZE]; // 1-indexed\n\n\t// a番目をwに変更する O(log N)\n\tvoid change_(int a, long long int w){\n\t\ta += TREE_SIZE / 2;\n\t\tsegTree[a] = w;\n\t\tfor(int x = a / 2; x > 0; x /= 2){\n\t\t\tsegTree[x] = monoidFunc(segTree[2 * x], segTree[2 * x + 1]);\n\t\t}\n\t}\n\t// 区間 [a, b) の値を求める O(log N)\n\t// query(a, b, 1, 0, TREE_SIZE / 2) のように呼ぶ\n\tlong long int query_(int a, int b, int index, int l, int r){\n\t\tif(r <= a || b <= l){\n\t\t\treturn invalidValue;\n\t\t}\n\t\tif(a <= l && r <= b){\n\t\t\treturn segTree[index];\n\t\t}\n\t\treturn monoidFunc(query_(a, b, index * 2, l, (l + r) / 2), query_(a, b, index * 2 + 1, (l + r) / 2, r));\n\t}\n};\n\nlong long int func(long long int a, long long int b){\n\treturn min(a, b);\n}\nSegTree segTree(func, INF);\n\n// 文字列 T の中に文字列 P が出現する位置を一つ返す\n// 存在しない場合、-1 を返す\nint findPos(string &T, string &P, vector<int> &sa, vector<int> &lcpArray){\n\tint pos = 0;\n\t// [L, R) に存在する、とおく\n\tint L = 0, R = sa.size();\n\twhile(R - L > 1){\n\t\twhile(P[pos] == T[sa[L] + pos]){\n\t\t\tpos += 1;\n\t\t}\n\t\tint M = (L + R) / 2;\n\t\tint lcp = segTree.query(L, M - 1);\n\t\tif(pos > lcp){\n\t\t\tR = M;\n\t\t}else if(pos < lcp){\n\t\t\tL = M;\n\t\t}else{\n\t\t\tbool flag = true;\n\t\t\tfor(int i = pos; i < P.size(); i++){\n\t\t\t\tif(P[i] != T[sa[M] + i]){\n\t\t\t\t\tflag = (P[i] > T[sa[M] + i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tL = M;\n\t\t\t}else{\n\t\t\t\tR = M;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < P.size(); i++){\n\t\tif(P[i] != T[sa[L] + i]){\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn L;\n}\n\nint main(){\n\tstring T;\n\tcin >> T;\n\tvector<int> vs;\n\tfor(int c : T){\n\t\tvs.push_back(c);\n\t}\n\tvs.push_back(0);\n\tvector<int> sa = saIs(vs, 256);\n\tvector<int> lcpArray = LCP(vs, sa);\n\t/*\n\tfor(int i = 0; i < sa.size(); i++){\n\t\tcout << i << \" \" << sa[i] << \" \" << lcpArray[i] << \" \" << T.substr(sa[i]) << endl;\n\t}\n\t*/\n\tsegTree.init(INF);\n\tfor(int i = 0; i < lcpArray.size(); i++){\n\t\tsegTree.change(i, lcpArray[i]);\n\t}\n\t// Q 回のクエリに対し、文字列 T の中に文字列 P が出現するかどうかを判定する\n\tint Q;\n\tcin >> Q;\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tstring P;\n\t\tcin >> P;\n\t\tcout << (findPos(T, P, sa, lcpArray) >= 0) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint Rank[1000005];\nint Tmp[1000005];\nint kc, len;\n\nbool compare_sa(int i, int j) {\n    return\n        Rank[i] != Rank[j] ? Rank[i] < Rank[j] :\n        (i + kc <= len ? Rank[i+kc] : -1) < (j + kc <= len ? Rank[j+kc] : -1);\n}\n\nvoid construct_sa(char* S, int *sa) {\n    len = strlen(S);\n    for(int i = 0; i <= len; i++) {\n        sa[i] = i;\n        Rank[i] = i < len ? S[i] : -1;\n    }\n    for(kc = 1; kc <= len; kc *= 2) {\n        sort(sa, sa + len + 1, compare_sa);\n        Tmp[sa[0]] = 0;\n        for(int i = 1; i <= len; i++) {\n            Tmp[sa[i]] = Tmp[sa[i-1]] + compare_sa(sa[i - 1], sa[i]);\n        }\n        for(int i = 0; i <= len; i++) Rank[i] = Tmp[i];\n    }\n}\n\nint n, m;\nchar str[1000005];\nchar t[1000005];\nint sa[1000005];\n\nint main() {\n    scanf(\"%s\", str);\n    n = strlen(str);\n    construct_sa(str, sa);\n    scanf(\"%d\", &m);\n    \n    while(m--) {\n        scanf(\"%s\", t);\n        int k = strlen(t);\n        int l = 0, r = n + 1, m;\n        while(l + 1 < r) {\n            m = (l + r) / 2;\n            if(strncmp(str + sa[m], t, k) <= 0) l = m;\n            else r = m;\n        }\n        printf(\"%d\\n\", (strncmp(str + sa[l], t, k) == 0));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define MAX 1000002\n\nint Lv[MAX];\nint n, k;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n    return L_i < L_j;\n}\n\nint main()\n{\n    int A[MAX], newLv[MAX];\n    std::string T;\n    std::cin >> T;\n    n = T.size();\n\n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n    std::sort(A, A + n, cmp_Lv);\n\n    newLv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        newLv[A[i]] = newLv[A[i - 1]] + (Lv[A[i]] != Lv[A[i - 1]] ? 1 : 0);\n    }\n    for(i = 0; i < n; i++){ Lv[i] = newLv[i]; }\n\n    k = 1;\n    while(1){\n        if(k > n) break;\n\n        std::sort(A, A + n, cmp);\n        newLv[A[0]] = 0;\n        for(i = 1; i < n; i++){ newLv[A[i]] = newLv[A[i - 1]] + (cmp(A[i - 1], A[i]) ? 1 : 0); }\n        for(i = 0; i < n; i++){ Lv[i] = newLv[i]; }\n\n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n\n    std::string P;\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n\n    A[n] = n;\n\n    while(q){\n        std::cin >> P;\n        left = 0, right = n, exist = false;\n        while(left < right){\n\n            if(n < P.size()){ exist = false; break; }\n\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n\n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1e9 + 7;\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\nconst ull BASE = 1e9 + 7;\n\nstruct SuffixArray {\n    int n, k;\n    vector<int> sa;\n    vector<int> rank;\n    vector<int> lcp;\n\n    SuffixArray (const string &s)\n    : n(s.size()), sa(n + 1), rank(n + 1), lcp(n)\n    {}\n\n    bool comp(int i, int j) {\n        if (rank[i] != rank[j]) return rank[i] < rank[j];\n        int ri = i + k <= n ? rank[i + k] : -1;\n        int rj = j + k <= n ? rank[j + k] : -1;\n        return ri < rj;\n    }\n\n    void construct_sa(const string &s) {\n        for (int i = 0; i <= n; i++) {\n            sa[i] = i;\n            rank[i] = i < n ? s[i] : -1;\n        }\n\n        for (k = 1; k <= n; k *= 2) {\n            sort(sa.begin(), sa.end(), [&](const int& i, const int& j) {return comp(i, j);});\n\n            vector<int> tmp(n + 1);\n            tmp[sa[0]] = 0;\n            for (int i = 1; i <= n; i++) {\n                tmp[sa[i]] = tmp[sa[i - 1]] + (comp(sa[i - 1], sa[i]) ? 1 : 0);\n            }\n\n            for (int i = 0; i <= n; i++) {\n                rank[i] = tmp[i];\n            }\n        }\n    }\n\n    void construct_lcp (const string &s) {\n        int h = 0;\n        lcp[0] = 0;\n        for (int i = 0; i < n; i++) {\n            int j = sa[rank[i] - 1];\n            if (h > 0) h--;\n            for (; j + h < n && i + h < n; h++) {\n                if (s[j + h] != s[i + h]) break;\n            }\n            lcp[rank[i] - 1] = h;\n        }\n    }\n\n    bool match(const string &text, const string &pt) {\n        int l = 0, r = n;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val < 0) l = m;\n            else r = m;\n        }\n        return text.compare(sa[r], pt.length(), pt) == 0 ? true : false;\n    }\n\n    int count(const string &text, const string &pt) {\n        int l = 0, r = n;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val < 0) l = m;\n            else r = m;\n        }\n        int l_idx = r;\n        if (text.compare(sa[l_idx], pt.length(), pt) != 0) return 0;\n\n        l = 0, r = n + 1;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val <= 0) l = m;\n            else r = m;\n        }\n        int r_idx = l;\n        return r_idx - l_idx + 1;\n    }\n};\n\nstring t;\nint q;\nstring p[10000];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> t;\n    cin >> q;\n    rep(i, q) cin >> p[i];\n    SuffixArray suf(t);\n    suf.construct_sa(t);\n    rep(i, q) {\n        if (suf.match(t, p[i])) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define INF 1<<30\n#define mp make_pair\n#define pb push_back\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<pair<int, int> > vp;\ntypedef map<int,int> mpii;\n\ntypedef long long ll;\n\n#define join(a,b) a.insert(a.end(),b.begin(),b.end())\ntypedef vector< pair<string ,pair<int,int> > > vpsii;\n\nconst int MAX_ALP = 26;\nconst int MAX_SIZE = 10000000 + 7;\n\nstruct Node{\n    vi go; //next path\n    char c; //state\n    int f; //failure path\n    bool b; //match;\n    vector<string> text; //state string\n    Node(){\n        c = ' ';\n        f = -1;\n        b = false;\n        go.resize(MAX_ALP,-1);\n    }\n};\n\nvector<Node> G;\nint sz = 1;\n\nint idx(char c){\n    return c - 'a';\n}\n\nvoid make_trie(vector<string> W){\n    int ws = W.size();\n    int now = 0;\n    int sz = 1;\n    rep(i,ws){\n        now = 0;\n        string s = W[i];\n        rep(k,s.length()){\n            if(G[now].go[idx(s[k])] == -1){\n                Node node;\n                node.c = s[k];\n                G.pb(node);\n                G[now].go[idx(s[k])] = sz;\n                now = sz++;\n            }\n            else{\n                now = G[now].go[idx(s[k])];\n            }\n            if(k+1==s.length()){\n                G[now].text.pb(s);\n                G[now].b = true;\n            }\n        }\n    }\n}\n\nint back_failure(int t,char c){\n    while(G[t].go[c]==-1){\n        t = G[t].f;\n    }\n    return G[t].go[c];\n}\n\nvoid make_failure(){\n    queue<int> que;\n    //root\n    rep(i,MAX_ALP){\n        int nx = G[0].go[i];\n        if(nx!=-1){\n            G[nx].f = 0;\n            que.push(nx);\n        }\n        else{\n            G[0].go[i] = 0;\n        }\n    }\n    //other\n    while(!que.empty()){\n        int now = que.front();\n        que.pop();\n        rep(i,MAX_ALP){\n            if(G[now].go[i]!=-1){\n                que.push(G[now].go[i]);\n                int p = back_failure(G[now].f,i);\n                int s = G[now].go[i];\n                G[s].f = p;\n                if(G[p].b){\n                    G[s].b = true;\n                    join(G[s].text,G[p].text);\n                }\n            }\n        }\n    }\n}\n\nvpsii match(string st){\n    vpsii ret;\n    int now = 0;\n    rep(i,st.length()){\n        int id = idx(st[i]);\n        while(G[now].go[id]==-1){\n            now = G[now].f;\n        }\n        now = G[now].go[id];\n        rep(k,G[now].text.size()){\n            string s = G[now].text[k];\n            ret.pb(mp(s,mp((i+1)-s.length(),i)));\n        }\n    }\n    return ret;\n}\n\nint main(){\n    string text; cin>>text;\n    int n; cin>>n;\n    Node root;\n    root.c = '*';\n    root.f = 0;\n    G.pb(root);\n    vector<string> words(n);\n    rep(i,n) cin>>words[i];\n    make_trie(words);\n    make_failure();\n    vpsii ans = match(text);\n    set<string> s;\n    rep(i,ans.size()) s.insert(ans[i].first);\n    rep(i,words.size()){\n        if(s.find(words[i]) != s.end()) cout<<1<<endl;\n        else cout<<0<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n/2+n%2,b[2*nb],c[2*nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==nc)a[i]=b[j++];\n      else if(j==nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[2000000];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntemplate<typename S_Iter, typename SA_Iter>\nvoid induceSAL(S_Iter S_begin, S_Iter S_end, SA_Iter SA_begin, SA_Iter SA_end, const vector<bool> &t, uint32_t buckets_size) {\n    int32_t n = S_end - S_begin;\n    vector<int32_t> buckets(buckets_size+1, 0);\n    for (auto itr = S_begin; itr != S_end; itr++) buckets[*itr]++;\n\n    int32_t sum = 0;\n    for (uint32_t i = 0; i < buckets.size(); i++) {\n        sum += buckets[i];\n        buckets[i] = sum - buckets[i];\n    }\n\n    if (!t[n-1]) SA_begin[buckets[S_begin[n-1]]++] = n-1;\n\n    for (int32_t i = 0; i < n; i++) {\n        if (SA_begin[i] > 0 && !t[SA_begin[i]-1]) SA_begin[buckets[S_begin[SA_begin[i]-1]]++] = SA_begin[i]-1;\n    }\n\n    return;\n}\n\ntemplate<typename S_Iter, typename SA_Iter>\nvoid induceSAS(S_Iter S_begin, S_Iter S_end, SA_Iter SA_begin, SA_Iter SA_end, const vector<bool> &t, uint32_t buckets_size) {\n    int32_t n = S_end - S_begin;\n    vector<int32_t> buckets(buckets_size+1, 0);\n    for (auto itr = S_begin; itr != S_end; itr++) buckets[*itr]++;\n    partial_sum(buckets.begin(), buckets.end(), buckets.begin());\n\n    for (int32_t i = n-1; i > 0; i--) {\n        if (SA_begin[i] > 0 && t[SA_begin[i]-1]) SA_begin[--buckets[S_begin[SA_begin[i]-1]]] = SA_begin[i]-1;\n    }\n\n    return;\n}\n\ntemplate<typename S_Iter, typename SA_Iter>\nvoid SA_IS(S_Iter S_begin, S_Iter S_end, SA_Iter SA_begin, SA_Iter SA_end, uint32_t buckets_size) {\n    int32_t n = S_end - S_begin;\n    fill(SA_begin, SA_end, -1);\n\n    // classify the type of each character\n    // true <=> S-type\n    vector<bool> t(n);\n    for (int32_t i = n; i >= 0; i--) {\n        t[i] = S_begin[i] < S_begin[i+1] || (S_begin[i] == S_begin[i+1] && t[i+1]);\n    }\n\n    auto is_lms = [&t](int32_t i){return i > 0 && !t[i-1] && t[i];};\n\n    // sort all the S-substrings\n    vector<int32_t> buckets(buckets_size+1, 0);\n    for (auto itr = S_begin; itr != S_end; itr++) buckets[*itr]++;\n    partial_sum(buckets.begin(), buckets.end(), buckets.begin());\n    for (int32_t i = 0; i < n; i++) {\n        if (is_lms(i)) SA_begin[--buckets[S_begin[i]]] = i;\n    }\n    induceSAL(S_begin, S_end, SA_begin, SA_end, t, buckets_size);\n    induceSAS(S_begin, S_end, SA_begin, SA_end, t, buckets_size);\n\n    // compact all the sorted substrings into the first nl items of SA\n    auto lms_end = remove_if(SA_begin, SA_end, [is_lms](int32_t x){return !is_lms(x);});\n    fill(lms_end, SA_end, -1);\n    int32_t nl = lms_end - SA_begin;\n\n    // find the lexicographic names of substrings\n    int32_t name = 0;\n    for (auto itr = SA_begin; itr != lms_end; itr++) {\n        if (itr == SA_begin) {\n            lms_end[*itr/2] = name;\n        } else {\n            int32_t cur = *itr, prev = *(itr - 1);\n            bool miss = S_begin[cur] != S_begin[prev] || t[cur] != t[prev];\n            if (!miss) do {\n                ++cur; ++prev;\n                miss |= cur == n ||\n                        prev == n ||\n                        S_begin[cur] != S_begin[prev] ||\n                        t[cur] != t[prev];\n            } while (!miss && !(cur > 0 && !t[cur-1] && t[cur]) && !(prev > 0 && !t[prev-1] && t[prev]));\n\n            if (miss) ++name;\n            lms_end[*itr/2] = name;\n        }\n    }\n    remove_if(reverse_iterator<decltype(SA_end)>(SA_end), reverse_iterator<decltype(SA_begin)>(SA_begin) - nl, [](int32_t i) {return i < 0;});\n\n    // solve the reduced problem\n    auto S1_begin = SA_end - nl, S1_end = SA_end;\n    auto SA1_begin = SA_begin, SA1_end = SA_begin + nl;\n    if (name + 1 < nl) {\n        SA_IS(S1_begin, S1_end, SA1_begin, SA1_end, nl);\n    } else {\n        for (int32_t i = 0; i < nl; i++) {\n            SA1_begin[S1_begin[i]] = i;\n        }\n    }\n\n    // induce the result for the original problem\n    fill(buckets.begin(), buckets.end(), 0);\n    for (auto itr = S_begin; itr != S_end; itr++) buckets[*itr]++;\n    partial_sum(buckets.begin(), buckets.end(), buckets.begin());\n\n    for (int32_t i = 1, j = 0; i < n; i++) {\n        if (is_lms(i)) S1_begin[j++] = i;\n    }\n    for (int32_t i = 0; i < nl; i++) SA1_begin[i] = S1_begin[SA1_begin[i]];\n    fill(lms_end, SA_end, -1);\n    for (int32_t i = nl-1; i >= 0; i--) {\n        int32_t j = SA_begin[i];\n        SA_begin[i] = -1;\n        SA_begin[--buckets[S_begin[j]]] = j;\n    }\n    induceSAL(S_begin, S_end, SA_begin, SA_end, t, buckets_size);\n    induceSAS(S_begin, S_end, SA_begin, SA_end, t, buckets_size);\n\n    return;\n}\n\nint main() {\n    char tmp[1000000];\n    scanf(\"%s\", tmp);\n    string T = tmp;\n\n    int32_t Q;\n    scanf(\"%d\", &Q);\n\n    vector<int32_t> SA(T.length());\n    SA_IS(T.begin(), T.end(), SA.begin(), SA.end(), 'z');\n\n    for (int32_t i = 0; i < Q; i++) {\n        char tmp[1000];\n        scanf(\"%s\", tmp);\n        string P = tmp;\n\n        auto itr_lb = lower_bound(SA.begin(), SA.end(), P, [T](uint32_t i, string s) {return T.substr(i, T.length()-i) < s;});\n        auto itr_ub = upper_bound(itr_lb, SA.end(), P, [T](string s, uint32_t i) {return s < T.substr(i, T.length()-i).substr(0, s.length());});\n\n        printf(\"%d\\n\", itr_ub - itr_lb > 0 ? 1 : 0);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<complex>\n#include<typeinfo>\nusing namespace std;\n\nstruct Node{\n    string pat;\n    map<char, int> child;\n    int fail;\n    vector<string> output;\n    bool blue;\n};\n\nbool mapElementCheck(map<char, int> &child, char c){\n    return child.find(c) != child.end();\n}\n\nvoid concatStringVector(vector<string> &v1, vector<string> &v2){\n    v1.insert(v1.begin(), v2.begin(), v2.end());\n}\n\nvoid printNode(Node &n){\n    cout << endl << \"pat: \" << n.pat << endl;\n    cout << \"child: \" << endl;\n    for (map<char, int>::iterator itr = (n.child).begin();itr!=(n.child).end();itr++){\n        cout << itr->first << \" \" << itr->second << endl;\n    }\n    cout <<\"fail: \" << n.fail << endl;\n    cout << \"output: \" <<endl;\n    for (int i=0;i<(n.output).size();i++){\n        cout << (n.output)[i] << endl;\n    }\n    cout << \"blue: \" << n.blue << endl << endl;\n    return;\n}\n\nvoid insert(vector<Node> &nodes, string &S){\n    int now = 0;\n    for (int i=0;i<S.size();i++){\n        map<char, int>& mp = nodes[now].child;\n        if(mp.find(S[i]) == mp.end()){\n            Node n;\n            n.pat = nodes[now].pat + string(1, S[i]);\n            nodes.push_back(n);\n            (nodes[now].child)[S[i]] = nodes.size()-1;\n            now = nodes.size()-1;\n        }else{\n            now = mp[S[i]];\n        }\n        if(i == S.size()-1){\n                nodes[now].blue = true;\n                (nodes[now].output).push_back(nodes[now].pat);\n            }else{\n                nodes[now].blue = false;\n            }\n    }\n    return;\n}\n\nvoid makeFailure(vector<Node> &nodes){\n    queue< pair<int, int> > qu;\n    qu.push(make_pair(0, 0));\n    while(!qu.empty()){\n        pair<int, int> now = qu.front();\n        qu.pop();\n        for (map<char, int>::iterator itr = (nodes[now.first].child).begin();itr!=(nodes[now.first].child).end();itr++){\n            qu.push(make_pair( itr->second, now.first));\n        }\n        if(now.second == 0 || now.first == 0){\n            nodes[now.first].fail = 0;\n        }else{\n            string tmpStr = (nodes[now.first]).pat;\n            char last = tmpStr[tmpStr.size()-1];\n            int ances = nodes[now.second].fail;\n            bool b1 = false;\n            while((nodes[ances].child).find(last) == (nodes[ances].child).end()){\n                if (ances == 0){\n                    b1 = true;\n                    break;\n                }\n                ances = nodes[ances].fail;\n            }\n            if(b1){\n                nodes[now.first].fail = 0;\n            }else{\n                nodes[now.first].fail = (nodes[ances].child)[last];\n                (nodes[now.first].output).insert((nodes[now.first].output).end(), (nodes[nodes[now.first].fail].output).begin(), (nodes[nodes[now.first].fail].output).end());\n            }\n        }\n        if(!(nodes[nodes[now.first].fail].output).empty()){\n\n        }\n    }\n}\n\nvector<Node> makePMA(vector<string> &P){\n    vector<Node> nodes;\n    Node n0;\n    n0.blue = false;\n    nodes.push_back(n0);\n    for (int i=0;i<P.size();i++){\n        insert(nodes, P[i]);\n    }\n    makeFailure(nodes);\n    return nodes;\n}\n\nvector<string> PMASesch(vector<Node> &PMA, string &P){\n    vector<string> res;\n    int now = 0;\n    for (int i=0;i<P.size();i++){\n        if(!mapElementCheck(PMA[now].child, P[i])){\n            while(!mapElementCheck(PMA[now].child, P[i])){\n                if(now == 0) break;\n                now = PMA[now].fail;\n            }\n        }\n        if (mapElementCheck(PMA[now].child, P[i])){\n            now = (PMA[now].child)[P[i]];\n            concatStringVector(res, PMA[now].output);\n        }else{\n            now = 0;\n        }\n    }\n    return res;\n}\n\nint main(){\n    string T;\n    cin >> T;\n    int Q;\n    cin >> Q;\n    vector<bool> match(Q, false);\n    vector<string> P;\n    map<string, int> M;\n    string tmp;\n    for (int i=0;i<Q;i++){\n        cin >> tmp;\n        P.push_back(tmp);\n        M[tmp] = i;\n    }\n    vector<Node> PMA = makePMA(P);\n    vector<string> res = PMASesch(PMA, T);\n\n    for (int i=0;i<res.size();i++){\n        match[M[res[i]]] = true;\n    }\n\n    for (int i=0;i<match.size();i++){\n        cout << match[i] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    build_sa();\n    //build_lcp();\n    //build_rmq();\n  }\n  void build_sa(){\n    sa.clear();\n    sa.resize(n+1,0);\n    S.push_back('$');\n    iota(sa.begin(),sa.end(),0);\n    sort(sa.begin(),sa.end(),\n\t [&](int a,int b){\n\t   if(S[a]==S[b]) return a>b;\n\t   return S[a]<S[b];\n\t });\n    return;\n    vector<int> c(n+1,0),r(n+1),cnt(n+1),s(n+1);\n    for(int i=0;i<=n;i++) r[i]=S[i];\n    for(int len=1;len<=n;len*=2){\n      for(int i=0;i<=n;i++){\n\t c[sa[i]]=\n\t   i>0 &&\n\t   r[sa[i-1]]==r[sa[i]] &&\n\t   sa[i-1]+len<=n &&\n\t   r[sa[i-1]+len/2]==r[sa[i]+len/2] ?\n\t   c[sa[i-1]]:i;\n      }\n      iota(cnt.begin(),cnt.end(),0);\n      copy(sa.begin(),sa.end(),s.begin());\n      for(int i=0;i<=n;i++){\n\tint s1=c[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n      c.swap(r);\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    lcp.clear();\n    lcp.resize(n+1,0);\n    vector<int> r2(n+1);\n    for(int i=0;i<=n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    //assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int B=999999937;\nconst int P=1000000007;\n\nvector<long long> gen_hash(const string &s){\n\tvector<long long> hash(s.size());\n\tlong long c=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tc=(c*B+s[i])%P;\n\t\thash[i]=c;\n\t}\n\treturn hash;\n}\nlong long pow_binary_mod(long long x,long long y,long long mod){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%mod;\n\t\tx=x*x%mod;\n\t}\n\treturn z;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s;\n\tcin>>s;\n\tvector<long long> v=gen_hash(s);\n\n\tint T;\n\tfor(cin>>T;T--;){\n\t\tstring q;\n\t\tcin>>q;\n\t\tlong long hash=gen_hash(q)[q.size()-1];\n\t\tlong long Brev=pow_binary_mod(B,q.size(),P);\n\t\t//vector<int> r;\n\t\tint i=q.size()-1;\n\t\tfor(;i<s.size();i++){\n\t\t\tlong long h=((v[i]-(i==q.size()-1?0:v[i-q.size()])*Brev)%P+P)%P;\n\t\t\tif(h==hash)break;//r.push_back(i-q.size()+1);\n\t\t}\n\t\tif(i<s.size()){\n\t\t\t//for(int i=0;i<r.size();i++)printf(\"%d\\n\",r[i]);\n\t\t\tputs(\"1\");\n\t\t}else{\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n\n\nusing namespace std;\n\nstring t;\nint q,n,size;\nbool flag;\n\nint main()\n{\n\tcin >> t >> q;\n\t\n\tfor(int i = 0;i < q ;i++)\n\t{\n\t\tstring p;\n\t\tcin >> p;\n\t\tsize = p.size();\n\t\t\n\t\tfor(int j = 0;j < t.size();j++)\n\t\t{\n\t\t\tflag = false;\n\t\t\tif(t[j] == p[0])\n\t\t\t{\n\t\t\t\tfor(int k = 1;k < size;k++)\n\t\t\t\t{\n\t\t\t\t\tif(t[j+k] != p[k]) break;\n\t\t\t\t\tif(k == size -1) \n\t\t\t\t\t{\n\t\t\t\t\t\tcout << 1 << endl;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tif(flag) break;\n\t\t}\n\tif(!flag) cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring S,T;\nstring V[100000][100];\nint main(){\n\tint q,a,b,c;\n\tcin>>S;\n\tb=S.size();\n\ta=min(b,100);\n\tfor(int i=1;i<100;i++){\n\t\tfor(int j=0;j<=b-i;j++){\n\t\t\tV[j][i]=S.substr(j,i);\n\t\t}\n\t}\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>T;\n\t\tc=T.size();\n\t\tfor(int j=0;j<=b-c;j++){\n\t\t\tif(V[j][c]==T){\n\t\t\t\tcout<<\"1\"<<endl;\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t}\n\t\tcout<<\"0\"<<endl;\n\t\tExit:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nvoid buildSA(const string& s, VI& sa, VI& rank){\n  int N = SZ(s);\n  vector<int> tmp(N+1);\n  sa.assign(N+1, 0);\n  rank.assign(N+1, 0);\n  for(int i=0;i<N+1;++i) sa[i] = i, rank[i] = (i < N? s[i]: -1);\n\n  int h;\n  auto comp = [&](int x, int y){\n\treturn rank[x]!=rank[y]? rank[x] < rank[y]\n\t: (x+h<=N?rank[x+h]:-1) < (y+h<=N?rank[y+h]:-1);\n  };\n  for(h=1;h<=N;h*=2){\n\tsort(sa.begin(), sa.end(), comp);\n\ttmp[sa[0]] = 0;\n\tfor(int i=1;i<=N;++i)\n\t  tmp[sa[i]] = tmp[sa[i-1]] + (comp(sa[i-1], sa[i])?1:0);\n\tfor(int i=0;i<=N;++i)\n\t  rank[i] = tmp[i];\n  }\n}\n\nint findSA(const string& t, const string& p, const vector<int>& sa){\n  int a = 0, b = SZ(t), m = SZ(p);\n  while(a < b) {\n    int c = (a + b) / 2;\n    if(strncmp(t.c_str()+sa[c], p.c_str(), m) < 0)\n\t  a = c+1;\n\telse\n\t  b = c;\n  }\n  return strncmp(t.c_str()+sa[a], p.c_str(), m) == 0 ? sa[a] : -1;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  string text;\n  cin >> text;\n  VI sa, rank;\n  buildSA(text, sa, rank);\n  \n  int Q; cin >> Q;\n  while(Q--){\n\tstring p;\n\tcin >> p;\n\tcout << (findSA(text, p, sa) != -1) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\n#define NUM 48\nusing namespace std;\n\nint T_char_count[128] = {0},P_char_count[128];\n\nclass LocRecord{\n\npublic:\n\t//?????¢???????¢????\n\tLocRecord(){\n\t\tlocationTable = new int*[128];\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t}\n\n\t//-1?????£??\\\n\tvoid init(){\n\t\tint limit;\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init_index(){\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t}\n\n\tvoid regist_loc(int ch, int location){\n\t\tlocationTable[ch][index[ch]] = location;\n\t\tindex[ch]++;\n\t}\n\n\tint next_loc(int ch){\n\t\tint ret = locationTable[ch][index[ch]];\n\t\tindex[ch]++;\n\t\treturn ret;\n\t}\n\nprivate:\n\tint** locationTable;\n\tint index[128];\n};\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\treturn hashValue < arg.hashValue;\n\t};\n\tInfo(int arg_id,ull arg_hashValue){\n\t\tid = arg_id;\n\t\thashValue = arg_hashValue;\n\t}\n\n\tint id;\n\tull hashValue;\n};\n\nint main(){\n\n\tfor(int i = 0; i < 128; i++){\n\t\tT_char_count[i] = 0;\n\t}\n\n\tint T_length;\n\n\tchar* T = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tfor(T_length = 0; T[T_length] != '\\0';T_length++){\n\t\tT_char_count[T[T_length]]++;\n\t}\n\n\tLocRecord locRecord;\n\tlocRecord.init();\n\n\t//T[i]????????????i??§???????????¨????¨????\n\tfor(int i = 0; i < T_length; i++){\n\t\tlocRecord.regist_loc(T[i],i);\n\t}\n\n\tull* HASH = new ull[T_length+1];\n\tull* P = new ull[T_length+1];\n\n\tHASH[0] = 0;\n\tP[0] = 1;\n\n\t//T??????????????\\???????±???????\n\tfor(int i = 1; i <= T_length; i++){\n\t\tHASH[i] = T[i-1] + HASH[i-1]*MOD;\n\t\tP[i] = P[i-1]*MOD;\n\t}\n\n\n\tvector<Info> V[75][1001]; //V[????????????][??????] = ???????????????????????\\???\n\tvector<int> LENG[75]; //LENG[????????????] = ??????????????????\n\n\tint Q,S_length,left,P_char_count[128];\n\tscanf(\"%d\",&Q);\n\n\tbool check[Q];\n\n\tfor(int i = 0; i < Q; i++)check[i] = false;\n\n\tchar S[1001];\n\tull S_HASH[1001],S_value,T_value,D;\n\tbool FLG,isExist;\n\n\t//Q??¶??????????????\\???????¨????\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",S);\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tP_char_count[i] = 0;\n\t\t}\n\n\t\tfor(S_length = 0;S[S_length] != '\\0';S_length++){\n\t\t\tP_char_count[S[S_length]]++;\n\t\t}\n\n\t\tFLG = true;\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tif(T_char_count[i] < P_char_count[i]){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG)continue;\n\n\t\tif(S_length == 1){\n\t\t\tcheck[loop] = true;\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tS_HASH[0] = 0;\n\t\tfor(int i = 1; i <= S_length; i++){\n\t\t\tS_HASH[i] = S[i-1] + S_HASH[i-1]*MOD;\n\t\t}\n\n\t\tS_value = S_HASH[S_length];\n\n\t\t//???????????\\?????????????????????????????????\n\t\tisExist = false;\n\t\tfor(int a = 0; a < V[S[0]-NUM][S_length].size();a++){\n\t\t\tif(V[S[0]-NUM][S_length][a].hashValue == S_value){\n\t\t\t\tisExist = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!isExist){\n\t\t\tV[S[0]-NUM][S_length].push_back(Info(loop,S_value));\n\t\t}\n\n\t\tisExist = false;\n\t\tfor(int a = 0; a < LENG[S[0]-NUM].size();a++){\n\t\t\tif(LENG[S[0]-NUM][a] == S_length){\n\t\t\t\tisExist = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!isExist){\n\t\t\tLENG[S[0]-NUM].push_back(S_length);\n\t\t}\n\t}\n\n\t//??????????????????sort\n\tfor(int i = 48; i <= 122; i++)sort(LENG[i-NUM].begin(),LENG[i-NUM].end());\n\t//hashValue????????????sort\n\tfor(int i = 48; i <= 122; i++){\n\t\tfor(int b = 0; b < LENG[i-NUM].size();b++){\n\t\t\tsort(V[i-NUM][LENG[i-NUM][b]].begin(),V[i-NUM][LENG[i-NUM][b]].end());\n\t\t}\n\t}\n\n\tint calc_length,calc_left,calc_right,calc_m,tmp_len;;\n\n\tfor(int word = 48; word <= 122; word++){\n\t\tfor(int i = 0; i < LENG[word-NUM].size();i++){\n\n\t\t\tlocRecord.init_index();\n\t\t\tcalc_length = LENG[word-NUM][i];\n\n\t\t\twhile((left = locRecord.next_loc(word)) != -1){\n\t\t\t\tif(left+calc_length-1 >= T_length)break;\n\n\t\t\t\tT_value = HASH[left+calc_length]-HASH[left]*P[calc_length];\n\n\t\t\t\tcalc_left = 0;\n\t\t\t\tcalc_right = V[word-NUM][calc_length].size()-1;\n\t\t\t\tcalc_m = (calc_left+calc_right)/2;\n\n\t\t\t\twhile(calc_left <= calc_right){\n\t\t\t\t\tif(V[word-NUM][calc_length][calc_m].hashValue == T_value){\n\t\t\t\t\t\tcheck[V[word-NUM][calc_length][calc_m].id] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(V[word-NUM][calc_length][calc_m].hashValue < T_value){\n\t\t\t\t\t\t\tcalc_left = calc_m+1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcalc_right = calc_m-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcalc_m = (calc_left+calc_right)/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tif(check[i])printf(\"1\\n\");\n\t\telse{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct SA{\n  int n,k;\n  string S;\n  vector<int> r,r2,t,sa,lcp;\n  SA(){}\n  SA(string S):S(S){init();}\n  void init(){\n    n=S.size();\n    r.resize(n+1,0);\n    r2.resize(n+1,0);\n    t.resize(n+1,0);\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    construct_sa();\n    construct_lcp();\n    construct_rmq();\n  }\n  bool compare_sa(int i,int j){\n    if(r[i]!=r[j]) return r[i]<r[j];\n    else{\n      int ri=i+k<=n?r[i+k]:-1;\n      int rj=j+k<=n?r[j+k]:-1;\n      return ri<rj;\n    }\n  }\n  void construct_sa(){\n    n=S.length();\n    for(int i=0;i<=n;i++){\n      sa[i]=i;\n      r[i]=i<n?S[i]:-1;\n    }\n    for(k=1;k<=n;k*=2){\n      sort(sa.begin(),sa.end(),[&](const int &i, const int &j){\n\t  if(r[i]!=r[j]) return r[i]<r[j];\n\t  else{\n\t    int ri=i+k<=n?r[i+k]:-1;\n\t    int rj=j+k<=n?r[j+k]:-1;\n\t    return ri<rj;\n\t  }\n\t});\n      t[sa[0]]=0;\n      for(int i=1;i<=n;i++){\n\tt[sa[i]]=t[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n      }\n      for(int i=0;i<=n;i++){\n\tr[i]=t[i];\n      }\n    }\n  }\n  bool contains(string T){\n    int a=0,b=S.length()+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==(int)S.length()+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void construct_lcp(){\n    for(int i=0;i<=n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);construct(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void construct(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void construct_rmq(){\n    rmq.init(n);\n    rmq.construct(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SA sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\n#define ln '\\n'\nconstexpr long long MOD = 1000000007LL;\n//constexpr long long MOD = 998244353LL;\ntypedef long long ll;\ntypedef unsigned long long ull; \ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true;} return false; }\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\ntemplate<class C>\nstruct SuffixAutomaton{\n\tstruct State{\n\t\tint len,link;\n\t\tmap<C,int>nex;\n\t\tState(int len,int link):len(len),link(link){}\n\t};\n\n\tvector<State>st;\n\tint last;\n\n\tSuffixAutomaton():last(0){\n\t\tst.emplace_back(0,-1);\n\t}\n\n\tint process(C c,int cur=-1){\n\t\tif(cur==-1){\n\t\t\tcur=last;\n\t\t}\n\n\t\tif(st[cur].nex.count(c)){\n\t\t\tint q=st[cur].nex[c];\n\t\t\tif(st[q].len==st[cur].len+1){\n\t\t\t\treturn last=q;\n\t\t\t}\n\t\t\tint clone=st.size();\n\t\t\tst.push_back(st[q]);\n\t\t\tst[clone].len=st[q].len+1;\n\t\t\tst[q].link=clone;\n\t\t\twhile(cur!=-1&&st[cur].nex[c]==q){\n\t\t\t\tst[cur].nex[c]=clone;\n\t\t\t\tcur=st[cur].link;\n\t\t\t}\n\t\t\treturn last=clone;\n\t\t}\n\n\t\tint nex=st.size();\n\t\tst.emplace_back(st[cur].len+1,0);\n\t\tint p=cur;\n\t\twhile(p!=-1&&!st[p].nex.count(c)){\n\t\t\tst[p].nex[c]=nex;\n\t\t\tp=st[p].link;\n\t\t}\n\t\tif(p==-1){\n\t\t\treturn last=nex;\n\t\t}\n\n\t\tint q=st[p].nex[c];\n\t\tif(st[p].len+1==st[q].len){\n\t\t\tst[nex].link=q;\t\n\t\t}\n\t\telse{\n\t\t\tint clone=st.size();\n\t\t\tst.push_back(st[q]);\n\t\t\tst[clone].len=st[p].len+1;\n\n\t\t\tst[q].link=st[nex].link=clone;\n\t\t\twhile(p!=-1&&st[p].nex[c]==q){\n\t\t\t\tst[p].nex[c]=clone;\n\t\t\t\tp=st[p].link;\n\t\t\t}\n\t\t}\n\t\treturn last=nex;\n\t}\n\n\t\n\tvector<int>calcTopologicalOrder(){\n\t\tvector<int>ord;\n\t\tvector<int>deg(st.size());\n\t\tfor(int i=0;i<st.size();i++){\n\t\t\tfor(auto &p:st[i].nex)deg[p.second]++;\n\t\t}\n\t\tqueue<int>que;\n\t\tque.push(0);\n\t\twhile(que.size()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tord.push_back(v);\n\t\t\tfor(auto &p:st[v].nex){\n\t\t\t\tif(--deg[p.second]==0)que.push(p.second);\n\t\t\t}\n\t\t}\n\t\treturn ord;\n\t}\n\n\tvector<int>calcTreeOrder(){\n\t\tvector<int>ord;\n\n\t\tvector<vector<int>>G(st.size());\n\t\tfor(int i=1;i<st.size();i++)G[st[i].link].push_back(i);\n\t\tqueue<int>que;\n\t\tque.push(0);\n\t\twhile(que.size()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tord.push_back(v);\n\t\t\tfor(auto u:G[v])que.push(u);\n\t\t}\n\t\treturn ord;\n\t}\n\tint64_t countDistinctSubstrings(){\n\t\tauto ord=calcTopologicalOrder();\n\t\tvector<int64_t>dp(st.size());dp[0]=1;\n\t\tfor(auto id:ord){\n\t\t\tfor(auto &p:st[id].nex)dp[p.se]+=dp[id];\n\t\t}\n\t\treturn accumulate(all(dp),0ll)-1;\n\t}\n};\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    string S; cin >> S;\n    int N = S.size();\n\n    SuffixAutomaton<char> SA;\n    rep(i,N) SA.process(S[i]);\n    int Q; cin >> Q;\n    while (Q--) {\n        string T; cin >> T;\n        int M = T.size();\n        int cur = 0;\n        rep(i,M) {\n            if (!SA.st[cur].nex.count(T[i])) {\n                cout << 0 << ln;\n                cur = -1;\n                break;\n            } else {\n                cur = SA.st[cur].nex[T[i]];\n            }\n        }\n        if (cur != -1) cout << 1 << ln;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nclass SuffixArray {\n\tvoid CEB(vector<int> &v, vector<int> &b) {\n\t\tfill(b.begin(), b.end(), 0);\n\t\tfor (int i = 0; i < v.size(); i++) b[v[i]]++;\n\t\tfor (int i = 1; i < b.size(); i++) b[i] += b[i - 1];\n\t}\n\tvoid ISort(vector<int> &v, vector<int> &SA, int mv, vector<int> &b, vector<int> &isL) {\n\t\tfill(b.begin(), b.end(), 0);\n\t\tfor (int i = 0; i < v.size(); i++) b[v[i]]++;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < b.size(); i++) b[i] += sum, swap(sum, b[i]);\n\t\tfor (int i = 0; i < v.size(); i++) {\n\t\t\tif (SA[i] > 0 && isL[SA[i] - 1]) SA[b[v[SA[i] - 1]]++] = SA[i] - 1;\n\t\t}\n\t}\n\tvoid IISort(vector<int> &v, vector<int> &SA, int mv, vector<int> &b, vector<int> &isL) {\n\t\tCEB(v, b);\n\t\tfor (int i = v.size() - 1; i >= 0; i--) {\n\t\t\tif (SA[i] > 0 && !isL[SA[i] - 1]) SA[--b[v[SA[i] - 1]]] = SA[i] - 1;\n\t\t}\n\t}\n\tvector<int>SA_IS(vector<int> v, int mv) {\n\t\tint vs = v.size();\n\t\tif (vs == 1) return vector<int>(1, 0);\n\t\tvector<int> isL(vs), b(mv + 1), SA(vs, -1), ord(vs);\n\t\tauto isLMS = [&](int x)->bool { return x > 0 && isL[x - 1] && !isL[x]; };\n\t\tfor (int i = vs - 2; i >= 0; i--) isL[i] = (v[i] > v[i + 1]) || (v[i] == v[i + 1] && isL[i + 1]);\n\t\tCEB(v, b);\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) SA[--b[v[i]]] = i;\n\t\t}\n\t\tISort(v, SA, mv, b, isL);\n\t\tIISort(v, SA, mv, b, isL);\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) ord[i] = cur++;\n\t\t}\n\t\tvector<int> nxv(cur);\n\t\tcur = -1;\n\t\tint prev = -1;\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (!isLMS(SA[i])) continue;\n\t\t\tbool diff = false;\n\t\t\tfor (int d = 0; d < vs; d++) {\n\t\t\t\tif (prev == -1 || v[SA[i] + d] != v[prev + d] || isL[SA[i] + d] != isL[prev + d]) {\n\t\t\t\t\tdiff = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (d && isLMS(SA[i] + d))break;\n\t\t\t}\n\t\t\tif (diff) cur++, prev = SA[i];\n\t\t\tnxv[ord[SA[i]]] = cur;\n\t\t}\n\t\tvector<int> reord(nxv.size());\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) reord[ord[i]] = i;\n\t\t}\n\t\tvector<int> nxSA = SA_IS(nxv, cur);\n\t\tCEB(v, b);\n\t\tfor (int i = 0; i < SA.size(); i++) SA[i] = -1;\n\t\tfor (int i = nxSA.size() - 1; i >= 0; i--) {\n\t\t\tSA[--b[v[reord[nxSA[i]]]]] = reord[nxSA[i]];\n\t\t}\n\t\tISort(v, SA, mv, b, isL);\n\t\tIISort(v, SA, mv, b, isL);\n\t\treturn SA;\n\t}\n\tvector<int>SA_IS(string s) {\n\t\tvector<int> v(s.size() + 1);\n\t\tfor (int i = 0; i < s.size(); i++) v[i] = s[i] + 1;\n\t\treturn SA_IS(v, *max_element(v.begin(), v.end()));\n\t}\n\tvector<int>construct_lcp(string &s, vector<int> &sa) {\n\t\tvector<int> lcp, rank(s.size() + 1);\n\t\tint n = s.size(), h = 0;\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (s[j + h] != s[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\npublic:\n\tstring s;\n\tvector<int> sa, lcp;\n\tvoid init(string &T) {\n\t\ts = T;\n\t\tsa = SA_IS(s);\n\t}\n\tSuffixArray(string &t) { init(t); }\n\tSuffixArray() {}\n\tbool contain(string &t) {\n\t\tint a = 0, b = s.size();\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (s.compare(sa[c], t.size(), t) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn s.compare(sa[b], t.size(), t) == 0;\n\t}\n};\nint q; string s, t;\nint main() {\n\tcin >> s >> q;\n\tSuffixArray v(s);\n\tfor(int i = 0; i < q; i++) {\n\t\tcin >> t;\n\t\tcout << (v.contain(t) ? 1 : 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint main()\n{\n    string t;\n    cin >> t;\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; i++){\n        string p;\n        cin >> p;\n        if(t.find(p) == string::npos) cout << 0 << endl;\n        else cout << 1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\n#define NUM 48\nusing namespace std;\n\nint T_char_count[128] = {0},P_char_count[128];\n\nclass LocRecord{\n\npublic:\n\t//?????¢???????¢????\n\tLocRecord(){\n\t\tlocationTable = new int*[128];\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t}\n\n\t//-1?????£??\\\n\tvoid init(){\n\t\tint limit;\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init_index(){\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t}\n\n\tvoid regist_loc(int ch, int location){\n\t\tlocationTable[ch][index[ch]] = location;\n\t\tindex[ch]++;\n\t}\n\n\tint next_loc(int ch){\n\t\tint ret = locationTable[ch][index[ch]];\n\t\tindex[ch]++;\n\t\treturn ret;\n\t}\n\nprivate:\n\tint** locationTable;\n\tint index[128];\n};\n\nint main(){\n\n\tfor(int i = 0; i < 128; i++)T_char_count[i] = 0;\n\n\tint length;\n\n\tchar* T = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tfor(length = 0; T[length] != '\\0';length++){\n\t\tT_char_count[T[length]]++;\n\t}\n\n\tLocRecord locRecord;\n\tlocRecord.init();\n\n\t//T[i]????????????i??§???????????¨????¨????\n\tfor(int i = 0; i < length; i++){\n\t\tlocRecord.regist_loc(T[i],i);\n\t}\n\n\tull* HASH = new ull[length+1];\n\tull* P = new ull[length+1];\n\n\tHASH[0] = 0;\n\tP[0] = 1;\n\n\t//T??????????????\\???????±???????\n\tfor(int i = 1; i <= length; i++){\n\t\tHASH[i] = T[i-1] + HASH[i-1]*MOD;\n\t\tP[i] = P[i-1]*MOD;\n\t}\n\n\tint Q,S_length,left,P_char_count[128];\n\tscanf(\"%d\",&Q);\n\n\tchar S[1001];\n\tull S_HASH[1001],S_value,T_value,D;\n\tbool FLG;\n\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",S);\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tP_char_count[i] = 0;\n\t\t}\n\n\t\tfor(S_length = 0;S[S_length] != '\\0';S_length++){\n\t\t\tP_char_count[S[S_length]]++;\n\t\t}\n\n\t\tFLG = true;\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tif(T_char_count[i] < P_char_count[i]){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG)continue;\n\n\n\t\tS_HASH[0] = 0;\n\t\tfor(int i = 1; i <= S_length; i++){\n\t\t\tS_HASH[i] = S[i-1] + S_HASH[i-1]*MOD;\n\t\t}\n\n\t\tS_value = S_HASH[S_length];\n\n\t\tlocRecord.init_index();\n\n\t\tFLG = false;\n\n\t\tD = P[S_length];\n\n\t\twhile((left = locRecord.next_loc(S[0])) != -1){\n\t\t\tif(left+S_length-1>=length)break;\n\n\t\t\tif(HASH[left+S_length]-HASH[left]*D == S_value){\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(FLG){\n\t\t\tprintf(\"1\\n\");\n\t\t}else{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct SuffixArray {\n    string s;\n    size_t n;\n    vector<size_t> sarray, rank;\n    SuffixArray(string s): s(s), n(s.length()) {\n        sarray.assign(n+1, 0);\n        rank.assign(n+1, 0);\n\n        for (size_t i=0; i<=n; ++i) {\n            sarray[i] = i;\n            rank[i] = i<n? s[i]:-1;\n        }\n\n        vector<size_t> tmp(n+1);\n        for (size_t k=1; k<=n; k<<=1) {\n            auto comp=[&, k](size_t i, size_t j)->bool {\n                if (rank[i] != rank[j])\n                    return rank[i] < rank[j];\n\n                int ri=i+k<=n? rank[i+k]:-1;\n                int rj=j+k<=n? rank[j+k]:-1;\n                return ri < rj;\n            };\n            sort(sarray.begin(), sarray.end(), comp);\n                \n            for (size_t i=1; i<=n; ++i)\n                tmp[sarray[i]] = tmp[sarray[i-1]]+comp(sarray[i-1], sarray[i]);\n\n            for (size_t i=0; i<=n; ++i)\n                rank[i] = tmp[i];\n        }\n    }\n    bool is_substr(string t) {\n        size_t lb=0, ub=s.length();\n        while (ub-lb > 1) {\n            size_t mid=(lb+ub)/2;\n            (s.compare(sarray[mid], t.length(), t)<0? lb:ub) = mid;\n        }\n        return !s.compare(sarray[ub], t.length(), t);\n    }\n};\n\nint main() {\n    char buf[1<<20];\n    scanf(\"%s\", buf);\n    string T(buf);\n\n    SuffixArray sa(T);\n\n    size_t Q;\n    scanf(\"%zu\", &Q);\n\n    for (size_t i=0; i<Q; ++i) {\n        scanf(\"%s\", buf);\n        string P(buf);\n\n        printf(\"%d\\n\", sa.is_substr(P));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\n\n#define fi(x) get<0>(x)\n#define se(x) get<1>(x)\n\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\ntypedef vector<pll> vpl;\n\nstring t;\nstring p;\nlli q;\n\nvll sa;\nvll tmp;\nvpl rnk;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> t;\n    sa = vll(t.size());rnk = vpl(t.size());tmp = vll(t.size());\n    for(lli i = 0;i < t.size();i++) sa[i] = i;\n    for(lli i = 0;i < t.size();i++) fi(rnk[i]) = t[i];\n    for(lli k = 1;k < t.size();k *= 2){\n        sort(sa.begin(),sa.end(),[](lli a,lli b){\n            return rnk[a] < rnk[b];\n        });\n        for(lli i = 1;i < sa.size();i++){\n            tmp[sa[i]] = tmp[sa[i-1]];\n            if(rnk[sa[i]] != rnk[sa[i-1]]) tmp[sa[i]]++;\n        }\n        for(lli i = 0;i < sa.size();i++){\n            fi(rnk[sa[i]]) = tmp[sa[i]];\n        }\n        for(lli i = 0;i < sa.size();i++){\n            if(sa[i]+k < t.size()) se(rnk[sa[i]]) = fi(rnk[sa[i]+k]);\n            else se(rnk[sa[i]]) = -1;\n        }\n    }\n    sort(sa.begin(),sa.end(),[](lli a,lli b){\n        return rnk[a] < rnk[b];\n    });\n    //for(lli i = 0;i < sa.size();i++) cout << sa[i] << endl;\n    cin >> q;\n    for(lli i = 0;i < q;i++){\n        cin >> p;\n        auto from = sa.begin();\n        auto to = sa.end();\n        for(lli i = 0;i < p.size();i++){\n            from = lower_bound(from,to,p[i],[i](lli x,char c){\n                if(x+i >= t.size()) return false;\n                return t[x+i] < c;\n            });\n            to = upper_bound(from,to,p[i],[i](lli x,char c){\n                if(x+i >= t.size()) return false;\n                return t[x+i] < c;\n            });\n            //cout << *from << \" \" << *to << endl;\n        }\n        if(to-from > 0) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int B=1073741783;\nconst int P=1073741789;\n\nvoid gen_hash(const string &s,vector<long long> &hash){\n\tlong long c=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tc=(c*B+s[i])%P;\n\t\thash[i]=c;\n\t}\n}\nlong long pow_binary_mod(long long x,long long y,long long mod){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=z*x%mod;\n\t\tx=x*x%mod;\n\t}\n\treturn z;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s;\n\tcin>>s;\n\tint ls=s.size();\n\tvector<long long> v(ls),hsh(10001);\n\tgen_hash(s,v);\n\n\tint T;\n\tfor(cin>>T;T--;){\n\t\tstring q;\n\t\tcin>>q;\n\t\tint lq=q.size();\n\t\tgen_hash(q,hsh);\n\t\tlong long hash=hsh[lq-1];\n\t\tlong long Brev=pow_binary_mod(B,lq,P);\n\t\tvector<int> r;\n\t\tint i=lq-1;\n\t\tfor(;i<ls;i++){\n\t\t\tif(v[i]==((i>=lq?v[i-lq]:0)*Brev+hash)%P){\n\t\t\t\tr.push_back(i-lq+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!r.empty()){\n\t\t\t//for(int i=0;i<r.size();i++)printf(\"%d\\n\",r[i]);\n\t\t\tputs(\"1\");\n\t\t}else{\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) { \n    const int k=lcp(i,j);\n    //const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    //const int k=lcp2(i,j,0,(n-max(i,j))*2+1);\n    if(i+k>=n)return 1;\n    if(j+k>=n)return 0;\n    return s[i+k] <= s[j+k];\n    //return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e){\n    assert(b<e);\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j){\n    //int l=0,r=min(n-i,n-j)+1;\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n  \n  /*\n  inline int lcp2(const int& i, const int& j, const int& l, const int& r){\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n  */\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\nif(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1000000000 + 7;\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nstruct SuffixArray {\n    int n, k;\n    string text;\n    vector<int> sa;\n    vector<int> rank;\n    vector<int> lcp;\n\n    SuffixArray (const string &s)\n    : text(s), n(s.size()), sa(n + 1), rank(n + 1), lcp(n)\n    {}\n\n    bool comp(int i, int j) {\n        if (rank[i] != rank[j]) return rank[i] < rank[j];\n        int ri = i + k <= n ? rank[i + k] : -1;\n        int rj = j + k <= n ? rank[j + k] : -1;\n        return ri < rj;\n    }\n\n    void construct_sa() {\n        for (int i = 0; i <= n; i++) {\n            sa[i] = i;\n            rank[i] = i < n ? text[i] : -1;\n        }\n\n        for (k = 1; k <= n; k *= 2) {\n            sort(sa.begin(), sa.end(), [&](const int& i, const int& j) {return comp(i, j);});\n\n            vector<int> tmp(n + 1);\n            tmp[sa[0]] = 0;\n            for (int i = 1; i <= n; i++) {\n                tmp[sa[i]] = tmp[sa[i - 1]] + (comp(sa[i - 1], sa[i]) ? 1 : 0);\n            }\n\n            for (int i = 0; i <= n; i++) {\n                rank[i] = tmp[i];\n            }\n        }\n    }\n\n    void construct_lcp () {\n        int h = 0;\n        lcp[0] = 0;\n        for (int i = 0; i < n; i++) {\n            int j = sa[rank[i] - 1];\n            if (h > 0) h--;\n            for (; j + h < n && i + h < n; h++) {\n                if (text[j + h] != text[i + h]) break;\n            }\n            lcp[rank[i] - 1] = h;\n        }\n    }\n\n    int low_bd(const string &pt) {\n        int l = 0, r = n + 1;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val < 0) l = m;\n            else r = m;\n        }\n        return r;\n    }\n\n    int up_bd(const string &pt) {\n        int l = 1, r = n + 1;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val <= 0) l = m;\n            else r = m;\n        }\n        return r;\n    }\n\n    bool match(const string &pt) {\n        int l = 0, r = n;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val < 0) l = m;\n            else r = m;\n        }\n        return text.compare(sa[r], pt.length(), pt) == 0 ? true : false;\n    }\n\n    int count(const string &pt) {\n        int l_idx = low_bd(pt);\n        if (l_idx == sa.size()) return 0;\n        if (text.compare(sa[l_idx], pt.length(), pt) != 0) return 0;\n        int r_idx = up_bd(pt);\n        return r_idx - l_idx;\n    }\n};\n\nstring t;\nint q;\nstring p[10000];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> t;\n    cin >> q;\n    rep(i, q) cin >> p[i];\n    SuffixArray suf(t);\n    suf.construct_sa();\n    rep(i, q) {\n        if (suf.match(p[i])) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n \n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define REPV(i, v, n) for (int i=0,tmp=v;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define DWN(i, b, a) for (int i=int(b-1);i>=int(a);--i)\n \nusing namespace std;\n \ntypedef unsigned char byte;\n \nbyte mask[] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };\n#define tget(i) !!(t[(i)>>3]&mask[(i)&7])\n#define tset(i, b) t[(i)>>3]=(b) ? (mask[(i)&7]|t[(i)>>3]) : ((~mask[(i)&7])&t[(i)>>3])\n#define chr(i) (cs==sizeof(int)?((int*)s)[i]:((byte *)s)[i])\n#define isLMS(i) (i>0 && tget(i) && !tget(i-1))\n \nvoid getBuckets(byte *s, int *bkt, int n, int K, int cs, bool end=true){\n  fill(bkt, bkt + K + 1, 0);\n  REP(i,n)bkt[chr(i)]++;\n  REPV(i, 0, K+1)tmp += bkt[i], bkt[i] = end ? tmp : tmp - bkt[i];\n}\n \nvoid induceSAl(byte *t, int *SA, byte *s, int *bkt, int n, int K, int cs, bool end=false){\n  getBuckets(s, bkt, n, K, cs, end);\n  REP(i,n)if(SA[i]>0 && !tget(SA[i]-1)) SA[ bkt[chr(SA[i]-1)]++ ] = SA[i]-1;\n}\n \nvoid induceSAs(byte *t, int *SA, byte *s, int *bkt, int n, int K, int cs, bool end=true){\n  getBuckets(s, bkt, n, K, cs, end);\n  DWN(i,n,0)if(SA[i]>0 && tget(SA[i]-1))SA[--bkt[chr(SA[i]-1)]] = SA[i]-1;\n}\n \nvoid SA_IS(byte *s, int *SA, int n, int K=128, int cs=1) {\n  byte t[(n >> 3) + 1];\n  int bkt[K + 1],n1=0,name=0;\n   \n  tset(n-2, 0), tset(n-1, 1);\n  DWN(i,n-2,0)tset(i, (chr(i)<chr(i+1) || (chr(i)==chr(i+1) && tget(i+1))));\n  getBuckets(s, bkt, n, K, cs);\n  fill(SA, SA+n, -1);\n  FOR(i,1,n)if(isLMS(i))SA[--bkt[chr(i)]] = i;\n \n  induceSAl(t, SA, s, bkt, n, K, cs);\n  induceSAs(t, SA, s, bkt, n, K, cs);\n   \n  REP(i,n)if(isLMS(SA[i]))SA[n1++] = SA[i];\n  fill(SA + n1, SA + n, -1);\n \n  REPV(i,-1,n1){\n    int pos = SA[i], diff = false;\n    for(int d = 0; d < n && !diff; d++){\n      diff = chr(pos+d) != chr(tmp+d) || tget(pos+d) != tget(tmp+d);\n      if(!diff && d && (isLMS(pos+d) || isLMS(tmp+d)))break;\n    }\n    if(diff)name++,tmp=pos;\n    SA[ n1 + ((pos - (pos & 1)) >> 1) ] = name - 1;\n  }\n  int *s1 = SA + n - n1;\n  for(int i=n-1,j=n-1;i>=n1;i--)if(SA[i]>=0)SA[j--]=SA[i];\n  if(name < n1)SA_IS((byte*)s1, SA, n1, name - 1, sizeof(int));\n  else REP(i,n1)SA[s1[i]]=i;\n   \n  getBuckets(s, bkt, n, K, cs);\n  for(int i = 1, j = 0; i < n; i++)if(isLMS(i))s1[j++] = i;\n  REP(i,n1)SA[i]=s1[SA[i]];\n  fill(SA + n1, SA + n, -1);\n \n  DWN(i,n1,0){\n    int tmp = SA[i];\n    SA[i] = -1, SA[--bkt[chr(tmp)]] = tmp;\n  }\n  induceSAl(t, SA, s, bkt, n, K, cs);\n  induceSAs(t, SA, s, bkt, n, K, cs);\n}\n \nconst int maxn = 1000001;\nint n,sa[maxn];\n \nbool contain(string S, int *sa, string T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n \nchar a[maxn],b[maxn];\n \nint main(void){\n  int q;\n  scanf(\"%s\", a);\n  string s = string(a);\n  SA_IS((byte*) s.c_str(), sa, s.size()+1);\n \n  scanf(\"%d\", &q);\n  while(q--){\n    scanf(\"%s\", b);\n    if(contain(s, sa, string(b))) printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint Rank[1000005];\nint Tmp[1000005];\nint kc,len;\n\nbool compare_sa(int i,int j){\n  return\n    Rank[i]!=Rank[j]?\n    Rank[i]<Rank[j]:\n    (i+kc<=len?Rank[i+kc]:-1)<(j+kc<=len?Rank[j+kc]:-1);\n}\n\nvoid construct_sa(char* S,int *sa){\n  len=strlen(S);\n  for(int i=0;i<=len;i++){\n    sa[i]=i;\n    Rank[i]=i<len?S[i]:-1;\n  }\n  for(kc=1;kc<=len;kc*=2){\n    sort(sa,sa+len+1,compare_sa);\n    Tmp[sa[0]]=0;\n    for(int i=1;i<=len;i++){\n      Tmp[sa[i]]=Tmp[sa[i-1]]+compare_sa(sa[i-1],sa[i]);\n    }\n    for(int i=0;i<=len;i++)Rank[i]=Tmp[i];\n  }\n}\n\n\nint n,m;\nchar str[1000005];\nchar t[1000005];\nint sa[1000005];\n\nint main(){\n  scanf(\"%s\",str);\n  n=strlen(str);\n  construct_sa(str,sa);\n  scanf(\"%d\",&m);\n  while(m--){\n    scanf(\"%s\",t);\n    int k=strlen(t);\n    int l=0,r=n+1,m;\n    while(l+1<r){\n      m=(l+r)/2;\n      if(strncmp(str+sa[m],t,k)<=0)l=m;\n      else r=m;\n    }\n    printf(\"%d\\n\",(strncmp(str+sa[l],t,k)==0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1000000000 + 7;\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nstruct SuffixArray {\n    int n, k;\n    string text;\n    vector<int> sa;\n    vector<int> rank;\n    vector<int> lcp;\n\n    SuffixArray (const string &s)\n    : text(s), n(s.size()), sa(n + 1), rank(n + 1), lcp(n)\n    {}\n\n    bool comp(int i, int j) {\n        if (rank[i] != rank[j]) return rank[i] < rank[j];\n        int ri = i + k <= n ? rank[i + k] : -1;\n        int rj = j + k <= n ? rank[j + k] : -1;\n        return ri < rj;\n    }\n\n    void construct_sa() {\n        for (int i = 0; i <= n; i++) {\n            sa[i] = i;\n            rank[i] = i < n ? text[i] : -1;\n        }\n\n        for (k = 1; k <= n; k *= 2) {\n            sort(sa.begin(), sa.end(), [&](const int& i, const int& j) {return comp(i, j);});\n\n            vector<int> tmp(n + 1);\n            tmp[sa[0]] = 0;\n            for (int i = 1; i <= n; i++) {\n                tmp[sa[i]] = tmp[sa[i - 1]] + (comp(sa[i - 1], sa[i]) ? 1 : 0);\n            }\n\n            for (int i = 0; i <= n; i++) {\n                rank[i] = tmp[i];\n            }\n        }\n    }\n\n    void construct_lcp () {\n        int h = 0;\n        lcp[0] = 0;\n        for (int i = 0; i < n; i++) {\n            int j = sa[rank[i] - 1];\n            if (h > 0) h--;\n            for (; j + h < n && i + h < n; h++) {\n                if (text[j + h] != text[i + h]) break;\n            }\n            lcp[rank[i] - 1] = h;\n        }\n    }\n\n    int low_bd(const string &pt) {\n        int l = 0, r = n + 1;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val < 0) l = m;\n            else r = m;\n        }\n        return r;\n    }\n\n    int up_bd(const string &pt) {\n        int l = 1, r = n + 1;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val <= 0) l = m;\n            else r = m;\n        }\n        return r;\n    }\n\n    bool match(const string &pt) {\n        int idx = low_bd(pt);\n        if (idx == sa.size()) return false;\n        return text.compare(sa[idx], pt.length(), pt) == 0 ? true : false;\n    }\n\n    int count(const string &pt) {\n        int l_idx = low_bd(pt);\n        if (l_idx == sa.size()) return 0;\n        if (text.compare(sa[l_idx], pt.length(), pt) != 0) return 0;\n        int r_idx = up_bd(pt);\n        return r_idx - l_idx;\n    }\n};\n\nstring t;\nint q;\nstring p[10000];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> t;\n    cin >> q;\n    rep(i, q) cin >> p[i];\n    SuffixArray suf(t);\n    suf.construct_sa();\n    rep(i, q) {\n        cout << suf.match(p[i]) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(string s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  bool operator()(int i, int j) { \n    int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  \n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  \n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nlong long MOD = 1000000000 + 7;\nconstexpr long long INF = numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourd; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\n\nLL h, w, n, m, k, t, s, p,q, last, cnt, sum, ans, dp[100], a[20000], b[20000];\nstring str, ss;\nbool f[1100];\nchar c;\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nstruct Edge { LL to, cost; };\nvector<Edge>vec[100];\nvector<LL>v;\npair<string, LL>sa[1000000];\nmap<string, vector<LL>>ma;\nmultiset<LL>st;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nvoid compare() {\n\tstring ss = \"\";\n\tsa[0] = make_pair(ss, str.size());\n\tfor(int i=0;i<str.size();i++) {\n\t\tss = str[i] + ss;\n\t\tsa[i + 1] = make_pair(ss, str.size() - i - 1);\n\t}\n\tsort(sa, sa + str.size() + 1);\n}\nint main() {\n\tcin >> str;\n\tcompare();\n\tcin >> q;\n\trep(i, q) {\n\t\tcin >> ss;\n\t\tint l = 0, r = str.size();\n\t\twhile (r - l>1)\n\t\t{\n\t\t\tint m = (l + r) / 2;\n\t\t\tif (str.compare(sa[m].sec, ss.size(), ss)<0) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tcout << (str.compare(sa[r].sec, ss.size(), ss) == 0) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    build_sa();\n    //build_lcp();\n    //build_rmq();\n  }\n  void build_sa(){\n    S.push_back('$');\n    vector<int> c(n+1,0),ord(n+1,0);\n    for(int i=0;i<=n;i++) ord[i]=n-i;\n    sort(ord.begin(),ord.end(),[&](int a,int b){return S[a]<S[b];});\n    return;\n    for(int i=0;i<=n;i++){\n      sa[i]=ord[i];\n      c[i]=S[i];\n    }\n    \n    for(int len=1;len<=n;len*=2){\n      vector<int> r=c;\n      for(int i=0;i<=n;i++){\n\t c[sa[i]] =\n\t   i > 0 &&\n\t   r[sa[i - 1]] == r[sa[i]] &&\n\t   sa[i - 1] + len <= n &&\n\t   r[sa[i - 1] + len / 2] == r[sa[i] + len / 2]\n\t   ? c[sa[i - 1]] : i;\n      }\n      vector<int> cnt(n+1);\n      for(int i=0;i<=n;i++) cnt[i]=i;\n      vector<int> s=sa;\n      for(int i=0;i<=n;i++){\n\tint s1=s[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n);\n    for(int i=0;i<n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  return 0;\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    //assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nvoid induced_sort(vector<int> &vec, int val_range, vector<int> &SA, vector<bool> &sl, vector<int> &lms_idx){\n    vector<int> l(val_range, 0), r(val_range, 0);\n    for(int c: vec){\n        if(c+1 < val_range) ++l[c+1];\n        ++r[c];\n    }\n    partial_sum(l.begin(), l.end(), l.begin());\n    partial_sum(r.begin(), r.end(), r.begin());\n\n    fill(SA.begin(), SA.end(), -1);\n\n    for(int i=lms_idx.size()-1; i>=0; --i){\n        SA[--r[vec[lms_idx[i]]]] = lms_idx[i];\n    }\n\n    for(int i: SA)if(i >= 1 && sl[i-1]){\n        SA[l[vec[i-1]]++] = i-1;\n    }\n\n    fill(r.begin(), r.end(), 0);\n    for(int c: vec) ++r[c];\n    partial_sum(r.begin(), r.end(), r.begin());\n    for(int k=SA.size()-1, i=SA[k]; k>=1; --k, i=SA[k])if(i >= 1 && !sl[i-1]){\n        SA[--r[vec[i-1]]] = i-1;\n    }\n}\n\nvector<int> SA_IS(vector<int> &vec, int val_range){\n    const int n = vec.size();\n    vector<int> SA(n), lms_idx;\n    vector<bool> sl(n);\n\n    sl[n-1] = false;\n    for(int i=n-2; i>=0; --i){\n        sl[i] = (vec[i] > vec[i+1] || (vec[i] == vec[i+1] && sl[i+1]));\n        if(sl[i] && !sl[i+1]) lms_idx.push_back(i+1);\n    }\n    reverse(lms_idx.begin(), lms_idx.end());\n\n    induced_sort(vec, val_range, SA, sl, lms_idx);\n\n    vector<int> new_lms_idx(lms_idx.size()), lms_vec(lms_idx.size());\n    for(int i=0, k=0; i<n; ++i)if(!sl[SA[i]] && SA[i] >= 1 && sl[SA[i]-1]){\n        new_lms_idx[k++] = SA[i];\n    }\n\n    int cur = 0;\n    SA[n-1] = cur;\n    for(size_t k=1; k<new_lms_idx.size(); ++k){\n        int i = new_lms_idx[k-1], j = new_lms_idx[k];\n        if(vec[i] != vec[j]){\n            SA[j] = ++cur;\n            continue;\n        }\n        bool flag = false;\n        for(int a=i+1, b=j+1; ; ++a, ++b){\n            if(vec[a] != vec[b]){\n                flag = true;\n                break;\n            }\n            if((!sl[a] && sl[a-1]) || (!sl[b] && sl[b-1])){\n                flag = !((!sl[a] && sl[a-1]) && (!sl[b] && sl[b-1]));\n                break;\n            }\n        }\n        SA[j] = (flag ? ++cur : cur);\n    }\n    for(size_t i=0; i<lms_idx.size(); ++i){\n        lms_vec[i] = SA[lms_idx[i]];\n    }\n\n    if(cur+1 < (int)lms_idx.size()){\n        auto lms_SA = SA_IS(lms_vec, cur+1);\n\n        for(size_t i=0; i<lms_idx.size(); ++i){\n            new_lms_idx[i] = lms_idx[lms_SA[i]];\n        }\n    }\n\n    induced_sort(vec, val_range, SA, sl, new_lms_idx);\n\n    return SA;\n}\n\nvector<int> suffix_array(string &s){\n    s += '$';\n    vector<int> vec(s.size());\n    for(int i=0; i<s.size(); ++i) vec[i] = s[i];\n    auto SA = SA_IS(vec, 128);\n    SA.erase(SA.begin());\n    return SA;\n}\n\nstruct BWT{\n    int n, width;\n    string bwt;\n    vector<int> cnt_smaller, SA;\n    vector<vector<int>> cnt;\n\n    BWT(string s, int w): n(s.size()+1), width(w){\n        SA = suffix_array(s);\n        s += '$';\n        SA.insert(SA.begin(), n-1);\n        bwt.resize(n);\n        for(int i=0; i<n; ++i){\n            bwt[i] = (SA[i] == 0 ? s[n-1] : s[SA[i]-1]);\n        }\n\n        cnt_smaller.resize(128, 0);\n        cnt.resize(128);\n        for(int i=0; i<128; ++i) cnt[i].resize((n+1)/width+1, 0);\n        vector<int> table(128, 0);\n        for(int i=0; i<n; ++i){\n            if(bwt[i]+1 < 128) ++cnt_smaller[bwt[i]+1];\n            ++table[bwt[i]];\n            if((i+1)%width == 0){\n                for(int c=0; c<128; ++c) cnt[c][(i+1)/width] = table[c];\n            }\n        }\n        partial_sum(cnt_smaller.begin(), cnt_smaller.end(), cnt_smaller.begin());\n    }\n\n    int get_cnt(int c, int k){\n        int ret = cnt[c][k/width];\n        for(int i=k/width*width; i<k; ++i) ret += (bwt[i] == c);\n        return ret;\n    }\n\n    bool find(string &s){\n        int l = 0, r = n;\n        for(int i=s.size()-1; i>=0; --i){\n            l = cnt_smaller[s[i]] + get_cnt(s[i], l);\n            r = cnt_smaller[s[i]] + get_cnt(s[i], r);\n            if(l == r) return false;\n        }\n        return true;\n    }\n};\n\nint main(){\n    string t; int q;\n    cin >> t >> q;\n    BWT bwt(t, 10);\n    while(q--){\n        string p;\n        cin >> p;\n        printf(\"%d\\n\", bwt.find(p));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(string s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  bool operator()(int i, int j) { \n    int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  \n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  \n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  sort(ALL(sa),rh);\n  if(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef vector<int> V;\n\nconst int inf = 1e7;\n\nint n;\nstring t;\nint q;\nstring p[10000];\nint sa[20][1000000];\nint isa[1000000];\nint lcp[2 << 20];\n\nint stu(int i, int x, int k, int l, int r){\n\tif(r <= i || i < l){\n\t\treturn lcp[k];\n\t}\n\tif(i <= l && r <= i + 1){\n\t\treturn lcp[k] = x;\n\t}\n\tint m = (l + r) / 2;\n\treturn lcp[k] = min(\n\t\tstu(i, x, 2 * k + 1, l, m),\n\t\tstu(i, x, 2 * k + 2, m, r)\n\t);\n}\nvoid stu(int i, int x){\n\tstu(i, x, 0, 0, n - 1);\n}\n\nint rmq(int a, int b, int k, int l, int r){\n\tif(r <= a || b <= l){\n\t\treturn inf;\n\t}\n\tif(a <= l && r <= b){\n\t\treturn lcp[k];\n\t}\n\tint m = (l + r) / 2;\n\treturn min(\n\t\trmq(a, b, 2 * k + 1, l, m),\n\t\trmq(a, b, 2 * k + 2, m ,r)\n\t);\n}\nint rmq(int a, int b){\n\treturn rmq(a, b, 0, 0, n - 1);\n}\n\nV rs(vector<P>& v){\n\tvector<V> a(n + 1, V());\n\trep(i, n){\n\t\ta[v[i].second + 1].push_back(i);\n\t}\n\tvector<V> b(n, V());\n\tfor(V& x: a){\n\t\tfor(int i: x){\n\t\t\tb[v[i].first].push_back(i);\n\t\t}\n\t}\n\tV c(n);\n\tint cnt = 0;\n\tfor(V& x: b){\n\t\trep(i, x.size()){\n\t\t\tc[x[i]] = i == 0 || v[x[i - 1]].second < v[x[i]].second ? cnt : c[x[i - 1]];\n\t\t\t++cnt;\n\t\t}\n\t}\n\treturn c;\n}\n\nvoid pp(){\n\tstring v = t;\n\tsort(v.begin(), v.end());\n\trep(i, n){\n\t\tsa[0][i] = lower_bound(v.begin(), v.end(), t[i]) - v.begin();\n\t}\n\tfor(int i = 1; i <= 19; ++i){\n\t\tint k = 1 << i - 1;\n\t\tvector<P> s;\n\t\trep(j, n){\n\t\t\ts.push_back(P(sa[i - 1][j], j + k < n ? sa[i - 1][j + k] : -1));\n\t\t}\n\t\tV v = rs(s);\n\t\trep(j, n){\n\t\t\tsa[i][j] = v[j];\n\t\t}\n\t\t/*\n\t\tvector<P> v = s;\n\t\tsort(v.begin(), v.end());\n\t\trep(j, n){\n\t\t\tsa[i][j] = lower_bound(v.begin(), v.end(), s[j]) - v.begin();\n\t\t}\n\t\t*/\n\t}\n\n\trep(i, n){\n\t\tisa[sa[19][i]] = i;\n\t}\n\n\tint l = 0;\n\trep(i, n){\n\t\tint r = sa[19][i];\n\t\tif(r == n - 1){\n\t\t\tl = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tint j = isa[r + 1];\n\t\twhile(i + l < n && j + l < n && t[i + l] == t[j + l]){\n\t\t\t++l;\n\t\t}\n\t\tstu(r, l);\n\t\tl = max(l - 1, 0);\n\t}\n}\n\nbool srch(const string& p){\n\tint m = p.size();\n\n\tint h = 0;\n\twhile(isa[0] + h < n && h < m && t[isa[0] + h] == p[h]){\n\t\t++h;\n\t}\n\n\tint l = 0;\n\tint r = n;\n\tbool b = true;\n\twhile(r - l > 1){\n\t\tint k = (l + r) / 2;\n\t\tif(b){\n\t\t\tint c = rmq(l, k);\n\t\t\tif(c > h){\n\t\t\t\tl = k;\n\t\t\t}\n\t\t\telse if(c < h){\n\t\t\t\tr = k;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(isa[k] + h < n && h < m && t[isa[k] + h] == p[h]){\n\t\t\t\t\t++h;\n\t\t\t\t}\n\t\t\t\tif(isa[k] + h == n){\n\t\t\t\t\tl = k;\n\t\t\t\t}\n\t\t\t\telse if(h == m){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(t[isa[k] + h] < p[h]){\n\t\t\t\t\t\tl = k;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tr = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint c = rmq(k, r);\n\t\t\tif(c > h){\n\t\t\t\tr = k;\n\t\t\t}\n\t\t\telse if(c < h){\n\t\t\t\tl = k;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(isa[k] + h < n && h < m && t[isa[k] + h] == p[h]){\n\t\t\t\t\t++h;\n\t\t\t\t}\n\t\t\t\tif(isa[k] + h == n){\n\t\t\t\t\tl = k;\n\t\t\t\t}\n\t\t\t\telse if(h == m){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(t[isa[k] + h] < p[h]){\n\t\t\t\t\t\tl = k;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tr = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tb = l == k;\n\t}\n\treturn isa[l] + m <= n && string(t, isa[l], m) == p;\n}\n\nint main(){\n\tcin >> t >> q;\n\tn = t.size();\n\trep(i, q){\n\t\tcin >> p[i];\n\t}\n\n\tpp();\n\n\trep(i, q){\n\t\tcout << srch(p[i]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define MAX 1000002\n\nint Lv[MAX], A[MAX], newLv[MAX];\nint n, k;\nstring T;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n\tif(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n\tint L_i = (i + k >= n ? -1 : Lv[i + k]);\n\tint L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n\treturn L_i < L_j;\n}\n\nint main()\n{\n\tstd::cin >> T;\n\tn = T.size();\n\n\tint i;\n\tfor(i = 0; i < n; i++){ A[i] = i; }\n\tfor(i = 0; i < n; i++){ Lv[i] = T[i]; }\n\tsort(A, A + n, cmp_Lv);\n\n\tnewLv[A[0]] = 0;\n\tfor(i = 1; i < n; i++){\n\t\tnewLv[A[i]] = newLv[A[i - 1]] + (Lv[A[i]] != Lv[A[i - 1]] ? 1 : 0);\n\t}\n\tfor(i = 0; i < n; i++){ Lv[i] = newLv[i]; }\n\n\tk = 1;\n\twhile(1){\n\t\tif(k > n) break;\n\n\t\tsort(A, A + n, cmp);\n\t\tnewLv[A[0]] = 0;\n\t\tfor(i = 1; i < n; i++){ newLv[A[i]] = newLv[A[i - 1]] + (cmp(A[i - 1], A[i]) ? 1 : 0); }\n\t\tfor(i = 0; i < n; i++){ Lv[i] = newLv[i]; }\n\n\t\tif(Lv[A[n - 1]] == n - 1) break;\n\t\tk <<= 1;\n\t};\n\n\tstring P;\n\tint q, left, right, mid, crit;\n\tbool exist;\n\tscanf(\"%d\", &q);\n\n\tA[n] = n;\n\n\twhile(q){\n\t\tstd::cin >> P;\n\t\tleft = 0, right = n, exist = false;\n\t\twhile(left < right){\n\n\t\t\tif(n < P.size()){ exist = false; break; }\n\n\t\t\tmid = (left + right) / 2;\n\t\t\tcrit = T.compare(A[mid], P.size(), P);\n\n\t\t\tif(crit > 0){ right = mid; }\n\t\t\telse if(crit < 0){ left = mid + 1; }\n\t\t\telse{ exist = true; break; }\n\t\t};\n\t\tif(T.compare(A[right], P.size(), P) == 0) exist = true;\n\t\tif(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n\t\tq--;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(string s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int i, const int j) { \n    int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n  \n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  \n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  \n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\n\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S 1000005\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\nstruct d{\n  int a,b,c;\n  d(){}\n  d(int A,int B,int C){\n    a=A,b=B,c=C;\n  };\n  bool operator<(const d&r)const{\n    if(a!=r.a)return a<r.a;\n    return b<r.b;\n  }\n};\n\nint n,slen,tlen,r[S];\nchar s[S],t[N];\nd ran[S];\nP a[S];\n\nvoid init(){\n  for(int i=0;i<26;i++)\n    for(int j=0;j<slen;j++)\n      if('a'+i==s[j])r[j]=i+1;\n  r[slen]=0;\n  int x=1;\n  while(x<slen){\n    for(int i=0;i<=slen;i++){\n      int a=i+x;\n      if(a>slen)a=slen;\n      ran[i]=d(r[i],r[a],i);\n    }\n    sort(ran,ran+slen);\n    int cnt=1;\n    for(int i=0;i<=slen;i++){\n      r[ran[i].c]=cnt;\n      if(ran[i].a==ran[i+1].a&&ran[i].b==ran[i+1].b)\n\tcontinue;\n      cnt++;\n    }\n    x*=2;\n  }\n  for(int i=0;i<=slen;i++)a[i]=P(r[i],i);\n  sort(a,a+slen+1);\n}\n\nbool bynary_search(){\n  int L=0,R=slen+1;\n  while(L<R){\n    int M=(L+R)/2;\n    if(strncmp(s+a[M].second,t,tlen)<0)L=M+1;\n    else R=M;\n  }\n  if(!strncmp(s+a[L].second,t,tlen))return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s%d\",s,&n);\n  slen=strlen(s);\n  init();  \n  while(n--){\n    scanf(\"%s\",t);\n    tlen=strlen(t);\n    if(bynary_search())printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n/2+n%2,b[nb+1],c[nc+1];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==nc)a[i]=b[j++];\n      else if(j==nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000000];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\n\nvoid CreateBeginBucket(vector<int>&v,vector<int>&bucket){\n    fill(bucket.begin(),bucket.end(),0);\n    for(int i=0;i<v.size();i++)bucket[v[i]]++;\n    int sum=0;\n    for(int i=0;i<bucket.size();i++){bucket[i]+=sum;swap(sum,bucket[i]);}\n}\n\nvoid CreateEndBucket(vector<int>&v,vector<int>&bucket){\n    fill(bucket.begin(),bucket.end(),0);\n    for(int i=0;i<v.size();i++)bucket[v[i]]++;\n    for(int i=1;i<bucket.size();i++)bucket[i]+=bucket[i-1];\n}\n\nvoid InducedSort(vector<int>&v,vector<int>&SA,int mv,vector<int>&bucket,vector<int>&isL){\n    CreateBeginBucket(v,bucket);\n    for(int i=0;i<v.size();i++)if(SA[i]>0&&isL[SA[i]-1])SA[bucket[v[SA[i]-1]]++]=SA[i]-1;\n}\n\nvoid InvertInducedSort(vector<int>&v,vector<int>&SA,int mv,vector<int>&bucket,vector<int>&isL){\n    CreateEndBucket(v,bucket);\n    for(int i=v.size()-1;i>=0;i--)if(SA[i]>0&&!isL[SA[i]-1])SA[--bucket[v[SA[i]-1]]]=SA[i]-1;\n}\n\nvector<int>SA_IS(vector<int>v,int mv){\n    if(v.size()==1)return vector<int>(1,0);\n\n    vector<int>isL(v.size());\n    vector<int>bucket(mv+1);\n    vector<int>SA(v.size(),-1);\n    auto isLMS=[&](int x)->bool{return x>0&&isL[x-1]&&!isL[x];};\n\n    isL[v.size()-1]=0;\n    for(int i=v.size()-2;i>=0;i--)isL[i]=v[i]>v[i+1]||(v[i]==v[i+1]&&isL[i+1]);\n    CreateEndBucket(v,bucket);\n    for(int i=0;i<v.size();i++)if(isLMS(i))SA[--bucket[v[i]]]=i;\n    InducedSort(v,SA,mv,bucket,isL);\n    InvertInducedSort(v,SA,mv,bucket,isL);\n\n    int cur=0;\n    vector<int>ord(v.size());\n    for(int i=0;i<v.size();i++)if(isLMS(i))ord[i]=cur++;\n\n    vector<int>nxv(cur);\n    cur=-1;\n    int prev=-1;\n    for(int i=0;i<v.size();i++){\n        if(!isLMS(SA[i]))continue;\n        bool diff=false;\n        for(int d=0;d<v.size();d++){\n            if(prev==-1||v[SA[i]+d]!=v[prev+d]||isL[SA[i]+d]!=isL[prev+d]){\n                diff=true;\n                break;\n            }\n            else if(d>0&&isLMS(SA[i]+d))break;\n        }\n        if(diff){cur++;prev=SA[i];}\n        nxv[ord[SA[i]]]=cur;\n    }\n\n    vector<int>reord(nxv.size());\n    for(int i=0;i<v.size();i++)if(isLMS(i))reord[ord[i]]=i;\n    vector<int>nxSA=SA_IS(nxv,cur);\n    CreateEndBucket(v,bucket);\n    for(int i=0;i<SA.size();i++)SA[i]=-1;\n    for(int i=nxSA.size()-1;i>=0;i--)SA[--bucket[v[reord[nxSA[i]]]]]=reord[nxSA[i]];\n    InducedSort(v,SA,mv,bucket,isL);\n    InvertInducedSort(v,SA,mv,bucket,isL);\n    return SA;\n}\n\ntemplate<class T>\nvector<int>SA_IS(T s){\n    vector<int>ss(s.size()+1);\n    for(int i=0;i<s.size();i++)ss[i]=s[i]+1;\n    int mv=*max_element(ss.begin(),ss.end());\n    return SA_IS(ss,mv);\n}\n\nbool contain(string &S,vector<int>&sa,string &T){\n        int a=0,b=S.size();\n        while(b-a>1){\n            int c=(a+b)/2;\n            if(S.compare(sa[c],T.size(),T)<0)a=c;\n            else b=c;\n        }\n        return S.compare(sa[b],T.size(),T)==0;\n}\n\nsigned main(){\n    string s;cin>>s;\n    vector<int>sa=SA_IS(s);\n    int Q;cin>>Q;\n    while(Q--){\n        string t;cin>>t;\n        cout<<contain(s,sa,t)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<set>\n#include<complex>\n#include<typeinfo>\nusing namespace std;\n\nstruct Node{\n    Node* child[256];\n    vector<int> output;\n    Node(){\n        memset(child, 0, sizeof(child));\n    }\n    ~Node(){\n        for(int i = 0; i < 256; i++) if(child[i]) delete child[i];\n    }\n};\n\nvoid concatIntVector(vector<int> &v1, vector<int> &v2){\n    v1.insert(v1.begin(), v2.begin(), v2.end());\n}\n\nvector<int> set_union(vector<int> &a, vector<int> &b) {\n    vector<int> res;\n    set_union(a.begin(), a.end(), b.begin(), b.end(), back_inserter(res));\n    return res;\n}\n\nNode* makePMA(vector<string> &P){\n    Node* root = new Node;\n    root->child[0] = 0;\n    Node* now;\n    for (int i=0;i<P.size();i++){\n        now = root;\n        for (int j=0;j<P[i].size();j++){\n            if(now->child[(int)P[i][j]] == 0){\n                now->child[(int)P[i][j]] = new Node;\n            }\n            now = now->child[(int)P[i][j]];\n        }\n        now->output.push_back(i);\n    }\n\n    queue<Node*> qu;\n    for(int i=1;i<256;i++){\n        if(root->child[i]){\n            root->child[i]->child[0] = root;\n            qu.push(root->child[i]);\n        }else{\n            root->child[i] = root;\n        }\n    }\n    while(!qu.empty()){\n        now = qu.front();qu.pop();\n        for(int i=1;i<256;i++){\n            if(now->child[i]){\n                Node* fail = now->child[0];\n                while(!fail->child[i]){\n                    fail = fail->child[0];\n                }\n                now->child[i]->child[0] = fail->child[i];\n                now->child[i]->output = set_union(now->child[i]->output, fail->child[i]->output);\n                qu.push(now->child[i]);\n            }\n        }\n    }\n    return root;\n}\n\n\nvoid searchPMA(Node* &root, string &T, vector<bool> &res){\n    Node* now = root;\n    for (int i=0;i<T.size();i++){\n        while(!now->child[(int)T[i]]){\n            now = now->child[0];\n        }\n        now = now->child[(int)T[i]];\n        for (int j=0;j<(now->output).size();j++){\n            res[(now->output)[j]] = true;\n        }\n    }\n    return;\n}\n\nint main(){\n    string T;\n    cin >> T;\n    int Q;\n    cin >> Q;\n    vector<string> P;\n    string tmp;\n    for (int i=0;i<Q;i++){\n        cin >> tmp;\n        P.push_back(tmp);\n    }\n    Node* root = makePMA(P);\n    vector<bool> res(Q, false);\n    searchPMA(root, T, res);\n    for (int i=0;i<res.size();i++){\n        cout << res[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define MAX 10002\ntypedef unsigned char byte;\nbyte mask[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\n\nint Lv[MAX];\nint n, k;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n    return L_i < L_j;\n}\n\nint main()\n{\n    int A[MAX];\n    char c[MAX];\n    scanf(\"%s\", c);\n    std::string T = std::string(c);\n    n = T.size();\n    byte *t;\n    t = new byte [(n >> 3) + 1];\n\tbool act;\n\tint l, r;\n\n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n\t\n\tbyte bkt[129];\n\tfor(i = 0; i < n; i++){ bkt[Lv[i]]++; }\n\tbkt[0] = 0;\n\tfor(i = 0; i < 129; i++){ bkt[i] += bkt[i - 1]; }\n\tfor(i = 0; i < n; i++){ A[bkt[Lv[i]]--] = i; }\n\n    //std::sort(A, A + n, cmp_Lv);\n\n    for(i = 1; i < n; i++){\n        t[i >> 3] = (Lv[A[i]] != Lv[A[i - 1]] ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n    }\n    t[n >> 3] = t[n >> 3] | mask[n & 7];\n\n    Lv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n    }\n\n    k = 1;\n    while(1){\n        if(k > n) break;\n\n        act = true;\n        for(i = 1; i <= n; i++){\n            if(act){\n                if(!!(mask[i & 7] & t[i >> 3])){ continue; }\n                else{ l = i - 1; act = false; }\n            }else{\n                if(!!(mask[i & 7] & t[i >> 3])){\n                    r = i; std::sort(A + l, A + r, cmp); act = true; }\n                    else{ continue; }\n            }\n        }\n\n        for(i = 1; i < n; i++){\n            t[i >> 3] = (cmp(A[i - 1], A[i]) ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n        }\n        t[n >> 3] = t[n >> 3] | mask[n & 7];\n\n        Lv[A[0]] = 0;\n        for(i = 1; i < n; i++){\n            Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n        }\n\n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n\n    char p[1000];\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n\n    A[n] = n;\n\n    while(q){\n        scanf(\"%s\", p);\n        std::string P = std::string(p);\n        left = 0, right = n, exist = false;\n        while(left < right){\n\n            if(n < P.size()){ exist = false; break; }\n\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n\n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<vector>\nusing namespace std;\n#define INT(x) int x; scanf(\"%d\",&x)\n#define INPUT(x) scanf(\"%d\",&x)\n#define REP1(x,n) for(int x = 0; x < n; x++)\n#define REP2(x,s,e) for(int x = s; x <= e; x++)\n#define BR printf(\"\\n\")\n#define INF 2000000000\n#define Mod 1000000007\n\nchar S[1000001];\n\nint pow_mod_c(int c,int p,int q,int m){\n    int x = 1;\n    while (q > 0) {\n        if(q&1){\n            x = (x*p)%m;\n        }\n        p = (p*p)%m;\n        q >>= 1;\n    }\n    return (x*c)%m;\n}\n\nint initRH(char S[],int n){\n    int digit = 1;\n    int x = 0;\n    REP1(i,n){\n        x = (x+(digit*S[n-1-i])%Mod)%Mod;\n        digit = (digit*128)%Mod;\n    }\n    return x;\n}\n\nstruct val_i {\n    int val,i,n;\n};\n\nval_i shift(val_i k){\n    k.val = (Mod + k.val - pow_mod_c(S[k.i],128,k.n-1,Mod))%Mod;\n    k.val = (k.val*128)%Mod;\n    k.val = (k.val + S[k.i + k.n])%Mod;\n    k.i = k.i + 1;\n    \n    return k;\n}\n\nbool rec(char s[]){\n    int N = strlen(S);\n    int n = strlen(s);\n    \n    int ss = initRH(s,n);\n    val_i K;\n    K.val = initRH(S,n);\n    K.i = 0;\n    K.n = n;\n    \n    if (K.val == ss) return 1;\n    \n    REP1(i,N-n){\n        K = shift(K);\n        if(K.val == ss) return 1;\n    }\n    \n    return 0;\n}\n\nint main(){\n    cin >> S;\n    INT(Q);\n    REP1(i,Q){\n        char ss[1001];\n        scanf(\"%s\",ss);\n        printf(\"%d\\n\",rec(ss));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n-nb,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k>=nc)a[i]=b[j++];\n      else if(j>=nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s){\n    n=SZ(s);\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }  \n};\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  const int n = SZ(a);\n  if(n>1){\n    vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(b,rh), mergesort(c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==SZ(c))a[i]=b[j++];\n      else if(j==SZ(b))a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  mergesort(sa,rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000000];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <map>\n#include <new>\n#include <deque>\n#include <functional>\nusing namespace std;\n\ntemplate <class T>\nstruct myalloc{\n\tusing value_type = T;\n\n\tstatic const int num = 64;\n\tint k;\n\n\tdeque<vector<char>> dq;\n\tmyalloc() : k(num) {}\n\n\ttemplate <class U>\n\tmyalloc(const myalloc<U> &){}\n\n\tT* allocate(size_t n){\n\t\tif(k >= num){\n\t\t\tdq.emplace_back(num * sizeof(T));\n\t\t\tk = 0;\n\t\t}\n\t\treturn reinterpret_cast<T*>(&dq.back()[k++ * sizeof(T)]);\n\t}\n\n\tvoid deallocate(T*, size_t){}\n};\n\nstruct node{\n\tint fail;\n\tbool vis;\n\tmap<char,int,less<char>,myalloc<char>> nxt;\n};\n\nvector<node> trie;\n\nstring input(){\n\tstatic char buf[1000010];\n\tbuf[0] = 0;\n\tscanf(\"%s\", buf);\n\treturn buf;\n}\n\nint main(){\n\ttrie.reserve(1000010);\n\n\ttrie.emplace_back();\n\ttrie[0].fail = -1;\n\n\tstring t = input();\n\tint q;\n\tscanf(\"%d\", &q);\n\tvector<int> idx(q);\n\tfor(int i = 0; i < q; ++i){\n\t\tstring p = input();\n\t\tint u = 0;\n\t\tfor(char c : p){\n\t\t\tif(!trie[u].nxt.count(c)){\n\t\t\t\ttrie[u].nxt.emplace(c, trie.size());\n\t\t\t\ttrie.emplace_back();\n\t\t\t}\n\t\t\tu = trie[u].nxt[c];\n\t\t}\n\t\tidx[i] = u;\n\t}\n\n\tvector<int> bfs;\n\tbfs.push_back(0);\n\tint k = 0;\n\twhile(k < (int)bfs.size()){\n\t\tint u = bfs[k++];\n\t\tfor(const auto &pr : trie[u].nxt){\n\t\t\tchar c = pr.first;\n\t\t\tint v = pr.second;\n\t\t\tbfs.push_back(v);\n\n\t\t\tint f = trie[u].fail;\n\t\t\twhile(f >= 0 && !trie[f].nxt.count(c)){\n\t\t\t\tf = trie[f].fail;\n\t\t\t}\n\t\t\ttrie[v].fail = f >= 0 ? trie[f].nxt[c] : 0;\n\t\t}\n\t}\n\n\tint r = 0;\n\tfor(char c : t){\n\t\twhile(r >= 0 && !trie[r].nxt.count(c)){\n\t\t\tr = trie[r].fail;\n\t\t}\n\t\tr = r >= 0 ? trie[r].nxt[c] : 0;\n\t\ttrie[r].vis = true;\n\t}\n\n\tfor(int i = bfs.size(); --i; ){\n\t\tint u = bfs[i];\n\t\tif(trie[u].vis){\n\t\t\ttrie[trie[u].fail].vis = true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < q; ++i){\n\t\tprintf(\"%d\\n\", +trie[idx[i]].vis);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nlong long MOD = 1000000000 + 7;\nconstexpr long long INF = numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourd; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\n\nLL h, w, n, m, k, t, s, p,q, last, cnt, sum, ans, dp[100], a[20000], b[20000];\nstring str, ss;\nbool f[1100];\nchar c;\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nstruct Edge { LL to, cost; };\nvector<Edge>vec[100];\nvector<LL>v;\npair<string, LL>sa[1000000];\nmap<string, vector<LL>>ma;\nmultiset<LL>st;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nvoid compare() {\n\tstring ss = \"\";\n\tsa[0] = make_pair(ss, str.size());\n\tfor(int i=0;i<str.size();i++) {\n\t\tss = str[str.size() - i - 1] + ss;\n\t\tsa[i + 1] = make_pair(ss, str.size() - i - 1);\n\t}\n\tsort(sa, sa + str.size() + 1);\n}\nint main() {\n\tcin >> str;\n\tcompare();\n\tcin >> q;\n\trep(i, q) {\n\t\tcin >> ss;\n\t\tint l = 0, r = str.size();\n\t\twhile (r - l>1)\n\t\t{\n\t\t\tint m = (l + r) / 2;\n\t\t\tif (str.compare(sa[m].sec, ss.size(), ss)<0) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tcout << (str.compare(sa[r].sec, ss.size(), ss) == 0) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\n#define NUM 48\nusing namespace std;\n\nint T_char_count[128] = {0},P_char_count[128],T_max_succeed[128],P_max_succeed[128];\n\nclass LocRecord{\n\npublic:\n\t//?????¢???????¢????\n\tLocRecord(){\n\t\tlocationTable = new int*[128];\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tlocationTable[i] = new int[T_char_count[i]+1];\n\t\t\t}else{\n\t\t\t\tlocationTable[i] = new int[2];\n\t\t\t}\n\t\t}\n\t}\n\n\t//-1?????£??\\\n\tvoid init(){\n\t\tint limit;\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tlimit = T_char_count[i];\n\t\t\tif(T_char_count[i] > 0){\n\t\t\t\tindex[i] = 0;\n\t\t\t\tfor(int k = 0; k <= limit; k++){\n\t\t\t\t\tlocationTable[i][k] = -1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tindex[i] = 0;\n\t\t\t\tlocationTable[i][0] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init_index(){\n\t\tfor(int i = 48; i <= 57; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 65; i <= 90; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t\tfor(int i = 97; i <= 122; i++){\n\t\t\tindex[i] = 0;\n\t\t}\n\t}\n\n\tvoid regist_loc(int ch, int location){\n\t\tlocationTable[ch][index[ch]] = location;\n\t\tindex[ch]++;\n\t}\n\n\tint next_loc(int ch){\n\t\tint ret = locationTable[ch][index[ch]];\n\t\tindex[ch]++;\n\t\treturn ret;\n\t}\n\nprivate:\n\tint** locationTable;\n\tint index[128];\n};\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\t\t\treturn length < arg.length;\n\t};\n\tInfo(int arg_length,int arg_id,ull arg_hashValue){\n\t\tlength = arg_length;\n\t\tid = arg_id;\n\t\thashValue = arg_hashValue;\n\t}\n\n\tint length,id;\n\tull hashValue;\n};\n\nint main(){\n\n\tfor(int i = 0; i < 128; i++){\n\t\tT_char_count[i] = 0;\n\t\tT_max_succeed[i] = 0;\n\t}\n\n\tint T_length;\n\n\tchar* T = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tchar pre = ':';\n\tint count = 1;\n\n\tfor(T_length = 0; T[T_length] != '\\0';T_length++){\n\t\tT_char_count[T[T_length]]++;\n\t\tif(pre == T[T_length])count++;\n\t\telse{\n\t\t\tT_max_succeed[pre] = max(T_max_succeed[pre],count);\n\t\t\tcount = 1;\n\t\t}\n\t\tpre = T[T_length];\n\t}\n\n\tLocRecord locRecord;\n\tlocRecord.init();\n\n\t//T[i]????????????i??§???????????¨????¨????\n\tfor(int i = 0; i < T_length; i++){\n\t\tlocRecord.regist_loc(T[i],i);\n\t}\n\n\tull* HASH = new ull[T_length+1];\n\tull* P = new ull[T_length+1];\n\n\tHASH[0] = 0;\n\tP[0] = 1;\n\n\t//T??????????????\\???????±???????\n\tfor(int i = 1; i <= T_length; i++){\n\t\tHASH[i] = T[i-1] + HASH[i-1]*MOD;\n\t\tP[i] = P[i-1]*MOD;\n\t}\n\n\n\tvector<Info> V[128];\n\n\tint Q,S_length,left,P_char_count[128];\n\tscanf(\"%d\",&Q);\n\n\tbool check[Q];\n\n\tfor(int i = 0; i < Q; i++)check[i] = false;\n\n\tchar S[1001];\n\tull S_HASH[1001],S_value,T_value,D;\n\tbool FLG;\n\n\t//Q??¶??????????????\\???????¨????\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",S);\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tP_char_count[i] = 0;\n\t\t\tP_max_succeed[i] = 0;\n\t\t}\n\n\t\tpre = ':';\n\t\tcount = 1;\n\t\tfor(S_length = 0;S[S_length] != '\\0';S_length++){\n\t\t\tP_char_count[S[S_length]]++;\n\t\t\tif(pre == S[S_length]){\n\t\t\t\tcount++;\n\t\t\t}else{\n\t\t\t\tP_max_succeed[pre] = max(P_max_succeed[pre],count);\n\t\t\t\tcount = 1;\n\t\t\t}\n\n\t\t\tpre = S[S_length];\n\t\t}\n\n\t\tFLG = true;\n\n\t\tcount = 0;\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tif(P_char_count[i] > 0)count++;\n\t\t\tif(T_char_count[i] < P_char_count[i] || T_max_succeed[i] < P_max_succeed[i]){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG)continue;\n\n\t\tif(S_length == 1){\n\t\t\tcheck[loop] = true;\n\t\t\tcontinue;\n\t\t}\n\t\tif(count == 1){\n\t\t\tcheck[loop] = true;\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tS_HASH[0] = 0;\n\t\tfor(int i = 1; i <= S_length; i++){\n\t\t\tS_HASH[i] = S[i-1] + S_HASH[i-1]*MOD;\n\t\t}\n\n\t\tS_value = S_HASH[S_length];\n\n\t\tV[S[0]].push_back(Info(S_length,loop,S_value));\n\t}\n\n\tint calc_length;\n\n\tfor(int word = 48; word <= 122; word++){\n\t\tfor(int i = 0; i < V[word].size();i++){\n\n\t\t\tlocRecord.init_index();\n\n\t\t\tcalc_length = V[word][i].length;\n\t\t\tS_value = V[word][i].hashValue;\n\n\t\t\tD = P[calc_length];\n\n\t\t\twhile((left = locRecord.next_loc(word)) != -1){\n\t\t\t\tif(left+calc_length-1 >= T_length)break;\n\n\t\t\t\tT_value = HASH[left+calc_length]-HASH[left]*D;\n\n\t\t\t\tif(T_value == S_value){\n\t\t\t\t\tcheck[V[word][i].id] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tif(check[i])printf(\"1\\n\");\n\t\telse{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ull unsigned int\nusing namespace std;\null B=100000007;\nint h[1001]={};\nvector<ull> v[1001];\nvoid contain(string b,int n){\n  int bl=b.size();\n  \n  ull t=1;\n  for(int i=0;i<n;i++)t*=B;\n\n  ull bh=0;\n  for(int i=0;i<n;i++)bh=bh*B+b[i];\n\n  for(int i=0;i+n<=bl;i++){\n    v[n].push_back(bh);\n    if(i+n<bl)bh=bh*B+b[i+n]-b[i]*t;\n  }\n  sort(v[n].begin(),v[n].end());\n  return;\n}\n\nint main(){\n  int n;\n  string b;\n  cin>>b>>n;\n  for(int i=0;i<n;i++){\n    string a;\n    cin>>a;\n    int al=a.size();\n    if(al>b.size()){\n      cout<<'0'<<endl;\n      continue;\n    }\n    if(h[al]==0){\n      contain(b,al);\n      h[al]=1;\n    }\n    ull ah=0;\n    for(int j=0;j<al;j++)ah=ah*B+a[j];\n    //cout<<\"ah = \"<<ah<<endl;\n    //for(int j=0;j<v[al].size();j++)cout<<\"v[i] = \"<<v[al][j]<<endl;\n    int l=0,m,r=v[al].size(),f=0;\n    while(r>l){\n      m=(l+r)/2;\n      if(v[al][m]==ah){\n\tf=1;\n\tbreak;\n      }else if(v[al][m]>ah)r=m;\n      else l=m+1;\n    }\n    cout<<f<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)///\ntypedef unsigned long long ull;\nstruct RollingHash\n{\n\tvector<ull> hash, pow;\n\tRollingHash(string s, ull _b = 1000000007)\n\t{\n\t\t_b = _b;\n\t\tint sz = s.length();\n\t\thash.assign(sz + 1, 0);\n\t\tpow.assign(sz + 1, 0);\n\n\t\tpow[0] = 1;\n\t\tfor (int i = 0; i < sz; i++) {\n\t\t\tpow[i + 1] = pow[i] * _b;\n\t\t}\n\t\tfor (int i = 0; i < sz; i++) {\n\t\t\thash[i + 1] = (hash[i] + s[i])*_b;\n\t\t}\n\t}\n\t// s[l]s[l+1]....s[r-1]縺ョ繝上ャ繧キ繝・蛟、繧貞叙蠕励☆繧?\n\t// 蜊企幕蛹コ髢?\n\tull get(int l, int r) {\n\t\treturn (hash[r] - hash[l] * pow[r - l]);\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring t;\n\tcin >> t;\n\tRollingHash rht(t);\n\tint q;\n\tcin >> q;\n\tvector<set<ull>> st(1000);\n\tREP(i, q) {\n\t\tstring p;\n\t\tcin >> p;\n\t\tRollingHash rh(p);\n\t\tif (p.size() > t.size()) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (st[p.size() - 1].size() == 0) {\n\n\n\t\t\tREP(j, t.size()-p.size()+1) {\n\t\t\t\tst[p.size() - 1].insert(rht.get(j, j + p.size()));\n\t\t\t}\n\t\t}\n\t\t\n\t\t\tcout << st[p.size() - 1].count(rh.get(0, p.size())) <<\"\\n\";\n\t\t\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <iostream>\n#include <queue>\n#include <unordered_set>\nusing namespace std;\n\nstruct TrieNode {\n  int is_word = 0, depth = 0;\n  vector<int> word_indices;\n  TrieNode *suf = nullptr, *out = nullptr, *parent = nullptr;\n  char last = '\\0';\n  TrieNode *adj[36];\n  TrieNode(int depth, TrieNode *parent) : depth(depth), parent(parent) {\n    TrieNode();\n  }\n  TrieNode() { fill_n(adj, 36, nullptr); }\n\n  TrieNode *GetNeighbor(char c) { return adj[getidx(c)]; }\n\n  static int getidx(char c) { return isalpha(c) ? (c - 'a') : (26 + c - '0'); }\n};\n\nusing np = TrieNode *;\n\n// Adds edges for the given string to the given trie\n// i is the index of the string in the overall input\nvoid BuildTrie(np cur, string &s, int i) {\n  for (int j = 0; j < s.size(); ++j) {\n    np neighborptr = cur->GetNeighbor(s[j]);\n    if (!neighborptr) {\n      cur->adj[TrieNode::getidx(s[j])] = new TrieNode(cur->depth + 1, cur);\n    }\n    cur = cur->GetNeighbor(s[j]);\n    cur->last = s[j];\n  }\n  cur->is_word = 1;\n  cur->word_indices.push_back(i);\n}\n\n// Adds suffix and output edges to the given trie\n// Suffix edges:\n// A *suffix edge* goes to the longest proper suffix of the current node's\n// string that is also in the trie\n//\n// The root has no suffix edges\n// Nodes one away from the root have suffix edge back to the root\n// Node at least two away from the root with string wa:\n// cur=suf(w)\n// while(cur!=root and cur doesn't have an a-edge)\n//   cur=suf(cur)\n// post: cur has an a-edge or cur=root\n// if(cur has an a-edge) suf(wa)=cur->adj[a]\n// else /* cur=root */ suf(wa)=cur\n//\n// Output edges:\n// An *output edge* goes to the longest proper suffix of the current node's\n// string\n// that is a word in the dictionary\n//\n// cur=suf(w)\n// while(cur is not null and cur is not a word)\n//   cur=suf(cur)\n// out(w)=cur  // two cases: either cur is null, or cur is the longest word\n// that is a proper suffix of w\nvoid AddEdges(np root) {\n  // BFS from root\n  queue<np> to_visit;\n  to_visit.push(root);\n  while (!to_visit.empty()) {\n    np cur = to_visit.front();\n    to_visit.pop();\n    if (cur->depth == 1) {\n      cur->suf = root;\n    } else if (cur->depth > 1) {\n      np sufcur = cur->parent->suf;\n      while (sufcur != root && !sufcur->GetNeighbor(cur->last))\n        sufcur = sufcur->suf;\n      if (np neighbor = sufcur->GetNeighbor(cur->last)) {\n        cur->suf = neighbor;\n      } else {\n        cur->suf = root;\n      }\n    }\n    np outcur = cur->suf;\n    while (outcur && !outcur->is_word)\n      outcur = outcur->suf;\n    cur->out = outcur;\n\n    for (int i = 0; i < 36; ++i)\n      if (cur->adj[i])\n        to_visit.push(cur->adj[i]);\n  }\n}\n\nint main() {\n  string T;\n  cin >> T;\n  int q;\n  cin >> q;\n  np root = new TrieNode;\n  string p;\n  for (int i = 0; cin >> p; ++i)\n    BuildTrie(root, p, i);\n  AddEdges(root);\n\n  np cur = root;\n  unordered_set<int> matched;\n  for (char c : T) {\n    while (cur != root && !cur->GetNeighbor(c))\n      cur = cur->suf;\n    if (np out = cur->GetNeighbor(c))\n      cur = out;\n    if (cur->is_word)\n      matched.insert(cur->word_indices.begin(), cur->word_indices.end());\n    np outcur = cur->out;\n    while (outcur) {\n      matched.insert(outcur->word_indices.begin(), outcur->word_indices.end());\n      outcur = outcur->out;\n    }\n  }\n  for (int i = 0; i < q; ++i)\n    cout << matched.count(i) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <boost/algorithm/searching/boyer_moore.hpp>\n\nint main(){\n    size_t pos;\n    int n;\n\tstd::string T;\n\tstd::cin >> T;\n\tstd::cin >> n;\n    for(int i=0;i<n;i++){\n    \tstd::string P;\n    \tstd::cin >> P;\n    \tstd::string::const_iterator search_result;\n    \tsearch_result = boost::algorithm::boyer_moore_search(T.begin(), T.end(),P.begin(), P.end());\n    \tif(search_result < T.end() ){\n    \t\tprintf(\"1\\n\");\n\t\t}else{\n   \t\t \tprintf(\"0\\n\");\n   \t\t}\n   \t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n\n  void output()\n  {\n    for(int i = 0; i < size(); i++) {\n      cout << i << \": \" << s.substr(SA[i]) << endl;\n    }\n  }\n};\n\n\nint main()\n{\n  string S;\n  int Q;\n\n  cin >> S;\n\n  SuffixArray sa;\n  sa.Build_SA(S);\n\n  cin >> Q;\n  while(Q--) {\n    string T;\n    cin >> T;\n    auto get = sa.lower_upper_bound(T);\n    cout << (get.first != get.second) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vl = vector<ll>;\nusing vll = vector<vector<ll>>;\nusing pii = pair<int,int>;\n#define FOR(i,a,b) for(ll i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(obj) (obj).begin(), (obj).end()\nconst double PI = acos(-1);\nconst double EPS = 1e-10;\nconst ll MOD = 1e9+7;\nvoid cioacc(){//accelerate cin/cout\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\nvector<string> make_suffix_array(const &string s){\n  vector<string> res;\n  REP(i,(ll)s.size()+1){\n    string tmp(s.begin()+i,s.end());\n    res.push_back(tmp);\n  }\n  sort(ALL(res));\n  return res;\n}\nint main(){//naive suffix array\n  string t;\n  int n;\n  cin >> t >> n;\n  auto suf = make_suffix_array(t);\n  REP(i,n){\n    string q;\n    cin >> q;\n    size_t sz = q.size();\n    auto itr = lower_bound(ALL(suf),q);\n    bool flag = false;\n    do{\n      if(itr==suf.end()) break;\n      string cut(itr -> begin(),(itr->begin())+min(sz,itr->size()));\n      if(cut==q){\n        cout << 1 << endl;\n        flag = true;\n        break;\n      } else if(cut > q){\n        break;\n      }\n      ++itr;\n    }while(true);\n    if(!flag) cout << 0 << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n#include<cstdlib>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow, *phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow = (ull*)malloc(n+1);\n    phash = (ull*)malloc(n+1);\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }  \n};\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  const int n = SZ(a);\n  if(n>1){\n    vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(b,rh), mergesort(c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==SZ(c))a[i]=b[j++];\n      else if(j==SZ(b))a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  mergesort(sa,rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000000];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nstruct SAComp{\n\tconst int h,*g;\n\tSAComp(const int h, const int* g) : h(h), g(g) {}\n\tbool operator()(const int a, const int b){\n\t\treturn a == b ? false : g[a] != g[b] ? g[a] < g[b] : g[a+h] < g[b+h];\n\t}\n};\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s;\n\tcin>>s;\n\ts+='$';\n\tint n=s.size();\n\tvector<int>suff(n);\n\tiota(suff.begin(),suff.end(),0);\n\t{\n\t\tconst char *str=s.c_str();\n\t\tsort(suff.begin(),suff.end(),SAComp(0,str));\n\t}\n\tvector<pair<char,int>>sorted(n);\n\tfor(int i=0;i<n;i++)sorted[i]={s[(suff[i]-1+n)%n],i};\n\tsort(sorted.begin(),sorted.end());\n\n\tint T;\n\tfor(cin>>T;T--;){\n\t\tstring q;\n\t\tcin>>q;\n\t\tint start=0,stop=n,idx=q.size()-1;\n\t\tfor(;idx>=0;idx--){\n\t\t\tpair<char,int> ql={q[idx],start},qr={q[idx],stop};\n\t\t\tstart=lower_bound(sorted.begin(),sorted.end(),ql)-sorted.begin();\n\t\t\tstop=lower_bound(sorted.begin(),sorted.end(),qr)-sorted.begin();\n\t\t\tif(start==stop)break;\n\t\t}\n\t\tif(idx<0){\n\t\t\t//{vector<int>v;for(;start<stop;start++)v.push_back(suff[start]);sort(v.begin(),v.end());for(auto &e:v)printf(\"%d\\n\",e);}\n\t\t\tputs(\"1\");\n\t\t}else{\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n\tstring T, P;\n\tlong Q;\n\tcin >> T >> Q;\n\tfor (long j = 0; j < Q; j++){\n\t\tcin >> P;\n\t\tlong flag = 0;\n\t\tif (T.size() < P.size()){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor (long i = 0; i < T.size() - P.size() + 1; i++){\n\t\t\tif (T[i] == P[0]){\n\t\t\t\tif (T.substr(i, P.size()) == P) flag = 1;\n\t\t\t}\n\t\t}\n\t\tif (flag) printf(\"1\\n\");\n\t\telse printf(\"0\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nvector<int> dat;\nvector<int> tmp;\n\nint doubles, lengths;\n\nbool compare_suffix(int i, int j)\n{\n\tif (dat[i] == dat[j])\n\t{\n\t\tint ri = (i + doubles <= lengths ? dat[i + doubles] : -1);\n\t\tint rj = (j + doubles <= lengths ? dat[j + doubles] : -1);\n\n\t\treturn ri < rj;\n\t}\n\n\treturn dat[i] < dat[j];\n}\n\nvector<int> suffix_array(string S)\n{\n\tlengths = S.size();\n\n\tvector<int> arrays(lengths + 1);\n\n\tdat.resize(lengths + 1);\n\ttmp.resize(lengths + 1);\n\n\tfor (int i = 0; i <= lengths; i++)\n\t{\n\t\tarrays[i] = i;\n\n\t\tdat[i] = i < lengths ? S[i] : -1;\n\t}\n\n\tfor (doubles = 1; doubles <= lengths; doubles <<= 1)\n\t{\n\t\tsort(arrays.begin(), arrays.begin() + lengths + 1, compare_suffix);\n\n\t\ttmp[arrays[0]] = 0;\n\n\t\tfor (int i = 1; i <= lengths; i++)\n\t\t{\n\t\t\ttmp[arrays[i]] = tmp[arrays[i - 1]] + (compare_suffix(arrays[i - 1], arrays[i]) ? 1 : 0);\n\t\t}\n\n\t\tfor (int i = 0; i <= lengths; i++)\n\t\t{\n\t\t\tdat[i] = tmp[i];\n\t\t}\n\t}\n\n\treturn arrays;\n}\n\nint main()\n{\n\tstring S, T; int Q;\n\t\n\twhile (true)\n\t{\n\t\tchar c = getchar();\n\n\t\tif (c == '\\n') break;\n\n\t\tS += c;\n\t}\n\n\tscanf(\"%d\", &Q);\n\n\tvector<int> sa = suffix_array(S);\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tT = \"\";\n\n\t\twhile (true)\n\t\t{\n\t\t\tchar c = getchar();\n\n\t\t\tif (c == '\\n') break;\n\n\t\t\tT += c;\n\t\t}\n\n\t\tint l = 0;\n\t\tint r = sa.size();\n\n\t\tbool flag = false;\n\n\t\twhile (r - l > 1)\n\t\t{\n\t\t\tint m = (l + r) / 2;\n\n\t\t\tstring S1 = S.substr(sa[m], T.size());\n\n\t\t\tif (S1 == T)\n\t\t\t{\n\t\t\t\tflag = true; break;\n\t\t\t}\n\t\t\t\n\t\t\tif (S1 < T)\n\t\t\t{\n\t\t\t\tl = m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = m;\n\t\t\t}\n\t\t}\n\n\t\tif (flag)\n\t\t{\n\t\t\tprintf(\"1\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int MAX = 26;\n\nint encode(char c){\n\t\treturn 0 + c - 'a';\n\n\tassert(false && \"invalid string\");\n}\n\nstruct Node{\n\tint nxt[MAX+1];\t\t\t// 次のalphabeteのノード番号\n\tint exist;\t\t\t\t// 子ども以下に存在する文字列の数の合計\n\tvector<int> accept;\t\t// その文字列id\n\tNode() : exist(0){memset(nxt, -1, sizeof(nxt));}\n};\n\nclass Trie{\n\tprivate:\n\t\tvoid updateDirect(int node,int id){\n\t\t\tac.emplace_back(node);\n\t\t\tnodes[node].accept.emplace_back(id);\n\t\t}\n\t\tvoid updateChild(int node,int child,int id){\n\t\t\t++nodes[node].exist;\n\t\t}\n\t\tvoid add(const string &str,int str_index,int node_index,int id){\n\t\t\tif(str_index == str.size())\n\t\t\t\tupdateDirect(node_index, id);\n\t\t\telse{\n\t\t\t\tconst int c = encode(str[str_index]);\n\t\t\t\tif(nodes[node_index].nxt[c] == -1) {\n\t\t\t\t\tnodes[node_index].nxt[c] = (int) nodes.size();\n\t\t\t\t\tnodes.emplace_back(Node());\n\t\t\t\t}\n\t\t\t\tadd(str, str_index + 1, nodes[node_index].nxt[c], id);\n\t\t\t\tupdateChild(node_index, nodes[node_index].nxt[c], id);\n\t\t\t}\n\t\t}\n\t\tvoid add(const string &str,int id){add(str, 0, 0, id);}\n\tpublic:\n\t\tvector<Node>nodes;\n\t\tvector<int> ac; // ac[i] := i番目のパターンを受理する状態番号\n\t\tint root;\n\t\tTrie() : root(0){nodes.emplace_back(Node());}\n\t\tvoid add(const string &str){add(str, nodes[0].exist);}\n\t\tint size(){return (nodes[0].exist);}\n\t\tint nodesize(){return ((int) nodes.size());}\n};\n\nclass AhoCorasick : public Trie{\n\tpublic: \n\t\tstatic const int FAIL = MAX;\n\t\tvector<int> correct;\n\t\tAhoCorasick() : Trie() {}\n\n\t\tvoid build(){\n\t\t\tcorrect.resize(nodes.size());\n\t\t\trep(i,nodes.size())correct[i]=(int)nodes[i].accept.size();\n\n\t\t\tqueue<int> que;\n\t\t\trep(i,MAX+1){\n\t\t\t\tif(~nodes[0].nxt[i]) {\n\t\t\t\t\tnodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n\t\t\t\t\tque.emplace(nodes[0].nxt[i]);\n\t\t\t\t}else nodes[0].nxt[i] = 0;\n\t\t\t}\n\t\t\twhile(!que.empty()) {\n\t\t\t\tNode now = nodes[que.front()];\n\t\t\t\tcorrect[que.front()] += correct[now.nxt[FAIL]];\n\t\t\t\tque.pop();\n\t\t\t\trep(i,MAX){\n\t\t\t\t\tif(now.nxt[i] == -1) continue;\n\t\t\t\t\tint fail = now.nxt[FAIL];\n\t\t\t\t\twhile(nodes[fail].nxt[i] == -1) {\n\t\t\t\t\t\tfail = nodes[fail].nxt[FAIL];\n\t\t\t\t\t}\n\t\t\t\t\tnodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n\n\t\t\t\t\tauto &u = nodes[now.nxt[i]].accept;\n\t\t\t\t\tauto &v = nodes[nodes[fail].nxt[i]].accept;\n\t\t\t\t\tvector<int> accept;\n\t\t\t\t\tset_union(all(u),all(v),back_inserter(accept));\n\t\t\t\t\tu=accept;\n\t\t\t\t\tque.emplace(now.nxt[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// result := 各パターンがそれぞれ何度マッチしたか\n\t\tint match(const string &str,vector<int> &result,int now=0){\n\t\t\tresult.assign(size(),0);\n\t\t\tint count=0;\n\t\t\tfor(auto &c:str) {\n\t\t\t\twhile(nodes[now].nxt[encode(c)]==-1)now=nodes[now].nxt[FAIL];\n\t\t\t\tnow = nodes[now].nxt[encode(c)];\n\t\t\t\tcount += correct[now];\n\t\t\t\tfor(auto &v:nodes[now].accept)result[v]++;\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\t\tint next(int now,char c){\n\t\t\twhile(nodes[now].nxt[encode(c)]==-1)now=nodes[now].nxt[FAIL];\n\t\t\treturn nodes[now].nxt[encode(c)];\n\t\t}\n};\n\nint main(){\n\tstring s;\n\tint n;\n\tcin >> s >> n;\n\n\tAhoCorasick aho;\n\trep(i,n){\n\t\tstring a;\n\t\tcin >> a;\n\t\taho.add(a);\n\t}\n\tvector<int> res;\n\taho.build();\n\taho.match(s, res);\n\tfor(auto i : res) cout << (i == 0 ? 0 : 1) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tstring T;\n\tcin >> T;\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tstring P;\n\t\tcin >> P;\n\t\tif((int)T.find(P) >= 0){\n\t\t\tprintf(\"1\\n\");\n\t\t}else{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<complex>\n#include<typeinfo>\nusing namespace std;\n\nstruct Node{\n    string pat;\n    map<char, int> child;\n    int fail;\n    vector<string> output;\n    bool blue;\n};\n\nbool mapElementCheck(map<char, int> &child, char c){\n    return child.find(c) != child.end();\n}\n\nvoid concatStringVector(vector<string> &v1, vector<string> &v2){\n    v1.insert(v1.begin(), v2.begin(), v2.end());\n}\n\nvoid printNode(Node &n){\n    cout << endl << \"pat: \" << n.pat << endl;\n    cout << \"child: \" << endl;\n    for (map<char, int>::iterator itr = (n.child).begin();itr!=(n.child).end();itr++){\n        cout << itr->first << \" \" << itr->second << endl;\n    }\n    cout <<\"fail: \" << n.fail << endl;\n    cout << \"output: \" <<endl;\n    for (int i=0;i<(n.output).size();i++){\n        cout << (n.output)[i] << endl;\n    }\n    cout << \"blue: \" << n.blue << endl << endl;\n    return;\n}\n\nvoid insert(vector<Node> &nodes, string &S){\n    int now = 0;\n    for (int i=0;i<S.size();i++){\n        map<char, int>& mp = nodes[now].child;\n        if(mp.find(S[i]) == mp.end()){\n            Node n;\n            n.pat = nodes[now].pat + string(1, S[i]);\n            nodes.push_back(n);\n            (nodes[now].child)[S[i]] = nodes.size()-1;\n            now = nodes.size()-1;\n        }else{\n            now = mp[S[i]];\n        }\n        if(i == S.size()-1){\n                nodes[now].blue = true;\n                (nodes[now].output).push_back(nodes[now].pat);\n            }else{\n                nodes[now].blue = false;\n            }\n    }\n    return;\n}\n\nvoid makeFailure(vector<Node> &nodes){\n    queue< pair<int, int> > qu;\n    qu.push(make_pair(0, 0));\n    while(!qu.empty()){\n        pair<int, int> now = qu.front();\n        qu.pop();\n        for (map<char, int>::iterator itr = (nodes[now.first].child).begin();itr!=(nodes[now.first].child).end();itr++){\n            qu.push(make_pair( itr->second, now.first));\n        }\n        if(now.second == 0 || now.first == 0){\n            nodes[now.first].fail = 0;\n        }else{\n            string tmpStr = (nodes[now.first]).pat;\n            char last = tmpStr[tmpStr.size()-1];\n            int ances = nodes[now.second].fail;\n            bool b1 = false;\n            while((nodes[ances].child).find(last) == (nodes[ances].child).end()){\n                if (ances == 0){\n                    b1 = true;\n                    break;\n                }\n                ances = nodes[ances].fail;\n            }\n            if(b1){\n                nodes[now.first].fail = 0;\n            }else{\n                nodes[now.first].fail = (nodes[ances].child)[last];\n                (nodes[now.first].output).insert((nodes[now.first].output).end(), (nodes[nodes[now.first].fail].output).begin(), (nodes[nodes[now.first].fail].output).end());\n            }\n        }\n        if(!(nodes[nodes[now.first].fail].output).empty()){\n\n        }\n    }\n}\n\nvector<Node> makePMA(vector<string> &P){\n    vector<Node> nodes;\n    Node n0;\n    n0.blue = false;\n    nodes.push_back(n0);\n    for (int i=0;i<P.size();i++){\n        insert(nodes, P[i]);\n    }\n    makeFailure(nodes);\n    return nodes;\n}\n\nvector<string> PMASesch(vector<Node> &PMA, string &P){\n    vector<string> res;\n    int now = 0;\n    for (int i=0;i<P.size();i++){\n        if(!mapElementCheck(PMA[now].child, P[i])){\n            while(!mapElementCheck(PMA[now].child, P[i])){\n                if(now == 0) break;\n                now = PMA[now].fail;\n            }\n        }\n        if (mapElementCheck(PMA[now].child, P[i])){\n            now = (PMA[now].child)[P[i]];\n            concatStringVector(res, PMA[now].output);\n        }else{\n            now = 0;\n        }\n    }\n    return res;\n}\n\nint main(){\n    string T;\n    cin >> T;\n    int Q;\n    cin >> Q;\n    vector<bool> match(Q, false);\n    vector<string> P;\n    string tmp;\n    for (int i=0;i<Q;i++){\n        cin >> tmp;\n        P.push_back(tmp);\n    }\n    vector<Node> PMA = makePMA(P);\n    vector<string> res = PMASesch(PMA, T);\n\n    for (int i=0;i<res.size();i++){\n        for (int j=0;j<P.size();j++){\n            if(P[j] == res[i]) match[j] = true;\n        }\n    }\n\n    for (int i=0;i<match.size();i++){\n        cout << match[i] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)n; ++i)\n#define FOR(i, a, b) for(int i = a; i < (int)b; ++i)\n#define rrep(i, n) for(int i = ((int)n - 1); i >= 0; --i)\n\nusing ll = long long;\nusing ld = long double;\n\nconst ll INF = 1e18;\nconst int Inf = 1e9;\nconst double EPS = 1e-9;\nconst int MOD = 1e9 + 7;\n\nclass SA_IS {\n    public:\n        SA_IS() {}\n\n        vector<int> construct(string str) {\n            vector<int> s(str.begin(), str.end());\n            return construct(s);\n        }\n\n        vector<int> construct(vector<int> s, const int k = 128) {\n            if (s.size() <= 1) {\n                return s.empty() ? (vector<int>){0} : (vector<int>){1, 0};\n            }\n            s.push_back(0);\n            vector<int> bkt(k, 0);\n            vector<bool> is_stype(s.size());\n\n            // determine S-type or L-type\n            rrep (i, s.size()) {\n                bkt[s[i]]++;\n                is_stype[i] = (i + 1 == s.size()) || (s[i] < s[i + 1]) || (s[i] == s[i + 1] && is_stype[i + 1]); \n            }\n            FOR (i, 1, k) bkt[i] += bkt[i - 1];\n\n            // Induced Sorting with wrong seed\n            vector<int> b(bkt);\n            \n            vector<int> sa(s.size()), is_lms(s.size());\n            int lms_cnt = 0;\n            FOR (i, 1, s.size()) {\n                if (!is_stype[i - 1] && is_stype[i]) {\n                    is_lms[i] = 1;\n                    sa[--bkt[s[i]]] = i;\n                    lms_cnt++;\n                }\n            }\n            \n            sa = inducedSort(s, sa, is_stype, b);\n\n            int lms_substr = 1, pre = -1;\n            is_lms[sa[0]] = lms_substr++;\n            FOR (i, 1, sa.size()) {\n                if (!is_lms[sa[i]]) continue;\n                if (pre >= 0 && s[pre] == s[sa[i]]) {\n                    int k;\n                    for (k = 1; s[pre + k] == s[sa[i] + k] && !is_lms[pre + k] && !is_lms[sa[i] + k]; ++k) ;\n                    lms_substr -= (s[pre + k] == s[sa[i] + k] && is_lms[pre + k] && is_lms[sa[i] + k]);\n                }\n                pre = sa[i];\n                is_lms[sa[i]] = lms_substr++;\n            }\n\n            vector<int> newstr(lms_cnt), rev(lms_cnt);\n            int cnt = 0;\n            rep (i, s.size()) {\n                if (!is_lms[i]) continue;\n                newstr[cnt] = is_lms[i];\n                rev[cnt] = i;\n                cnt++;\n            }\n\n            vector<int> sorted_lms = construct(newstr, lms_substr);\n            sa.assign(s.size(), 0);\n            FOR (i, 1, sorted_lms.size()) {\n                int j = rev[sorted_lms[i]];\n                sa[bkt[s[j]]++] = j;\n            }\n\n            return inducedSort(s, sa, is_stype, b);\n        }\n\n        vector<int> inducedSort(const vector<int>& s, const vector<int>&sa, const vector<bool>& is_stype, vector<int> bkt) {\n            int n = sa.size();\n            vector<int> b(bkt);\n            vector<int> res(n);\n            res[0] = sa[0];\n            rep (i, n) {\n                int j = sa[i] - 1, k = res[i] - 1;\n                if (j >= 0 && !is_stype[j]) res[b[s[j] - 1]++] = j;\n                else if (k >= 0 && !is_stype[k]) res[b[s[k] - 1]++] = k;\n            }\n            rrep (i, n) {\n                int j = res[i] - 1;\n                if (j >= 0 && is_stype[j]) res[--bkt[s[j]]] = j;\n            }\n\n            return res;\n        }\n\n        bool contain(string s, string t, const vector<int>& sa) {\n            int l = 0, r = sa.size(), m;\n            while (r - l > 1) {\n                m = (l + r) / 2;\n                if (s.substr(sa[m], t.size()) <= t) l = m;\n                else r = m;\n            }\n\n            return s.substr(sa[l], t.size()) == t;\n        }\n};\n\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(0);\n    SA_IS sa = SA_IS();\n    string s;\n    int q;\n    cin >> s >> q;\n    vector<int> v = sa.construct(s);\n    rep (i, q) {\n        string t;\n        cin >> t;\n        if (sa.contain(s, t, v)) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    \n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct SuffixArray {\n    string s;\n    size_t n;\n    vector<size_t> sarray;\n    vector<int> rank;\n    SuffixArray(string s): s(s), n(s.length()) {\n        sarray.assign(n+1, 0);\n        rank.assign(n+1, 0);\n\n        for (size_t i=0; i<=n; ++i) {\n            sarray[i] = i;\n            rank[i] = i<n? s[i]:-1;\n        }\n\n        vector<size_t> tmp(n+1);\n        for (size_t k=1; k<=n; k<<=1) {\n            auto comp=[&, k](size_t i, size_t j)->bool {\n                if (rank[i] != rank[j])\n                    return rank[i] < rank[j];\n\n                int ri=i+k<=n? rank[i+k]:-1;\n                int rj=j+k<=n? rank[j+k]:-1;\n                return ri < rj;\n            };\n            sort(sarray.begin(), sarray.end(), comp);\n                \n            for (size_t i=1; i<=n; ++i)\n                tmp[sarray[i]] = tmp[sarray[i-1]]+comp(sarray[i-1], sarray[i]);\n\n            for (size_t i=0; i<=n; ++i)\n                rank[i] = tmp[i];\n        }\n    }\n    bool is_substr(string t) {\n        size_t lb=0, ub=s.length();\n        while (ub-lb > 1) {\n            size_t mid=(lb+ub)>>1;\n            (s.compare(sarray[mid], t.length(), t)<0? lb:ub) = mid;\n        }\n        return !s.compare(sarray[ub], t.length(), t);\n    }\n};\n\nint main() {\n    char buf[1<<20];\n    scanf(\"%s\", buf);\n    string T(buf);\n\n    SuffixArray sa(T);\n\n    size_t Q;\n    scanf(\"%zu\", &Q);\n\n    for (size_t i=0; i<Q; ++i) {\n        scanf(\"%s\", buf);\n        string P(buf);\n\n        printf(\"%d\\n\", sa.is_substr(P));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair< P , int > PP;\n\nint res[1000005];\nPP tmp[1000005];\nint ans[1000005];\n\nvoid suffixArray(char* s){\n  \n  int len=strlen(s);\n  \n  for(int i=0;i<=len;i++)res[i]=s[i];\n  \n  for(int k=1;k<=len;k*=2){\n    \n    for(int i=0;i<=len;i++){\n      tmp[i].first.first=res[i];\n      tmp[i].first.second=(i+k<=len?res[i+k]:0);\n      tmp[i].second=i;\n    }\n    sort(tmp,tmp+len+1);\n    \n    int C=0;\n    for(int i=0;i<=len;i++){\n      int id=tmp[i].second;\n      if(i&& (tmp[i-1].first<tmp[i].first))C++;\n      res[id]=C;\n    }\n  }\n\n  for(int i=0;i<=len;i++)ans[ res[i] ]=i;\n}\n\nchar s[1000005];\nchar t[1000005];\nint main(){\n  scanf(\"%s\",s);\n  int lenS=strlen(s);\n  \n  suffixArray(s);\n\n  int Q;\n  scanf(\"%d\",&Q);\n  \n  while(Q--){\n    scanf(\"%s\",t);\n    int len=strlen(t);\n    int l=0,r=lenS+1,m;\n    while(r-l>1){\n      m=(l+r)/2;\n      if( strncmp( s+ans[m] , t ,len ) <=0 )l=m;\n      else r=m;\n    }\n    if(strncmp(s+ans[l],t,len)==0)printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  \n  /*\n  for(int i=0;i<(int)ans.size();i++){\n    printf(\"%d %s\\n\",ans[i], (s+ans[i]) );\n  }\n  */\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int i, const int j) { \n    //const int k=lcp(i,j);\n    const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    if(i+k>=n)return 1;\n    if(j+k>=n)return 0;\n    return s[i+k] <= s[j+k];\n    //return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int b, const int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  /*\n  inline int lcp(const int i, const int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n  */\n  int lcp2(const int i, const int j, const int l, const int r){\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\nif(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1000000000 + 7;\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nstruct SuffixArray {\n    int n, k;\n    string text;\n    vector<int> sa;\n    vector<int> rank;\n    vector<int> lcp;\n\n    SuffixArray (const string &s)\n    : text(s), n(s.size()), sa(n + 1), rank(n + 1), lcp(n)\n    {}\n\n    bool comp(int i, int j) {\n        if (rank[i] != rank[j]) return rank[i] < rank[j];\n        int ri = i + k <= n ? rank[i + k] : -1;\n        int rj = j + k <= n ? rank[j + k] : -1;\n        return ri < rj;\n    }\n\n    void construct_sa() {\n        for (int i = 0; i <= n; i++) {\n            sa[i] = i;\n            rank[i] = i < n ? text[i] : -1;\n        }\n\n        for (k = 1; k <= n; k *= 2) {\n            sort(sa.begin(), sa.end(), [&](const int& i, const int& j) {return comp(i, j);});\n\n            vector<int> tmp(n + 1);\n            tmp[sa[0]] = 0;\n            for (int i = 1; i <= n; i++) {\n                tmp[sa[i]] = tmp[sa[i - 1]] + (comp(sa[i - 1], sa[i]) ? 1 : 0);\n            }\n\n            for (int i = 0; i <= n; i++) {\n                rank[i] = tmp[i];\n            }\n        }\n    }\n\n    void construct_lcp () {\n        int h = 0;\n        lcp[0] = 0;\n        for (int i = 0; i < n; i++) {\n            int j = sa[rank[i] - 1];\n            if (h > 0) h--;\n            for (; j + h < n && i + h < n; h++) {\n                if (text[j + h] != text[i + h]) break;\n            }\n            lcp[rank[i] - 1] = h;\n        }\n    }\n\n    inline int low_bd(const string &pt) {\n        int l = 0, r = n + 1;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val < 0) l = m;\n            else r = m;\n        }\n        return r;\n    }\n\n    inline int up_bd(const string &pt) {\n        int l = 1, r = n + 1;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val <= 0) l = m;\n            else r = m;\n        }\n        return r;\n    }\n\n    inline bool match(const string &pt) {\n        int idx = low_bd(pt);\n        if (idx == sa.size()) return false;\n        return text.compare(sa[idx], pt.length(), pt) == 0 ? true : false;\n    }\n\n    inline int count(const string &pt) {\n        int l_idx = low_bd(pt);\n        if (l_idx == sa.size()) return 0;\n        if (text.compare(sa[l_idx], pt.length(), pt) != 0) return 0;\n        int r_idx = up_bd(pt);\n        return r_idx - l_idx;\n    }\n};\n\nstring t;\nint q;\nstring p[10000];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> t;\n    cin >> q;\n    rep(i, q) cin >> p[i];\n    SuffixArray suf(t);\n    suf.construct_sa();\n    rep(i, q) {\n        if (suf.match(p[i])) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S 1000005\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\nstruct d{\n  int a,b,c;\n  d(){}\n  d(int A,int B,int C){\n    a=A,b=B,c=C;\n  };\n  bool operator<(const d&r)const{\n    if(a!=r.a)return a<r.a;\n    return b<r.b;\n  }\n};\n\nint n,slen,tlen,r[S];\nchar s[S],t[N];\nd ran[S];\nP a[S];\n\nvoid init(){\n  for(int i=0;i<26;i++)\n    for(int j=0;j<slen;j++)\n      if('a'+i==s[j])r[j]=i+1;\n  int x=1;\n  while(x<slen){\n    for(int i=0;i<slen;i++){\n      int a=i+x;\n      if(a>slen)a=slen;\n      ran[i]=d(r[i],r[a],i);\n    }\n    sort(ran,ran+slen);\n    int cnt=1;\n    for(int i=0;i<slen;i++){\n      r[ran[i].c]=cnt;\n      if(ran[i].a==ran[i+1].a&&ran[i].b==ran[i+1].b)\n\tcontinue;\n      cnt++;\n    }\n    x*=2;\n  }\n  for(int i=0;i<slen;i++)a[i]=P(r[i],i);\n  sort(a,a+slen+1);\n}\n\nbool bynary_search(){\n  int L=0,R=slen;\n  while(L<R){\n    int M=(L+R)/2;\n    if(strncmp(s+a[M].second,t,tlen)<0)L=M+1;\n    else R=M;\n  }\n  if(!strncmp(s+a[L].second,t,tlen))return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s%d\",s,&n);\n  slen=strlen(s);\n  init();  \n  while(n--){\n    scanf(\"%s\",t);\n    tlen=strlen(t);\n    if(bynary_search())printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S 1000005\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\nstruct d{\n  int a,b,c;\n  d(){}\n  d(int A,int B,int C){\n    a=A,b=B,c=C;\n  };\n  bool operator<(const d&r)const{\n    if(a!=r.a)return a<r.a;\n    return b<r.b;\n  }\n};\n\nint n,slen,tlen,r[N];\nchar s[S],t[N];\nd ran[N];\nP a[N];\n\nvoid init(){\n  for(int i=0;i<26;i++)\n    for(int j=0;j<slen;j++)\n      if('a'+i==s[j])r[j]=i+1;\n  int x=1;\n  while(x<slen){\n    for(int i=0;i<slen;i++){\n      int a=i+x;\n      if(a>slen)a=slen;\n      ran[i]=d(r[i],r[a],i);\n    }\n    sort(ran,ran+slen);\n    int cnt=1;\n    for(int i=0;i<slen;i++){\n      r[ran[i].c]=cnt;\n      if(ran[i].a==ran[i+1].a&&ran[i].b==ran[i+1].b)\n\tcontinue;\n      cnt++;\n    }\n    x*=2;\n  }\n  for(int i=0;i<slen;i++)a[i]=P(r[i],i);\n  sort(a,a+slen);\n}\n\nbool bynary_search(){\n  int L=0,R=slen;\n  while(L<R){\n    int M=(L+R)/2;\n    if(strncmp(s+a[M].second,t,tlen)<0)L=M+1;\n    else R=M;\n  }\n  if(!strncmp(s+a[L].second,t,tlen))return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s%d\",s,&n);\n  slen=strlen(s);\n  init();  \n  while(n--){\n    scanf(\"%s\",t);\n    tlen=strlen(t);\n    if(bynary_search())printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint Q, doubles, lengths, dat[1000009], tmp[1000009], arrays[1000009]; string S, T;\nbool compare_suffix(int i, int j) {\n\tif (dat[i] == dat[j]) {\n\t\tint ri = (i + doubles <= lengths ? dat[i + doubles] : -1);\n\t\tint rj = (j + doubles <= lengths ? dat[j + doubles] : -1);\n\t\treturn ri < rj;\n\t}\n\treturn dat[i] < dat[j];\n}\nvoid suffix_array() {\n\tlengths = S.size();\n\tfor (int i = 0; i <= lengths; i++) arrays[i] = i, dat[i] = i < lengths ? S[i] : -1;\n\tfor (doubles = 1; doubles <= lengths; doubles <<= 1) {\n\t\tsort(arrays, arrays + lengths + 1, compare_suffix);\n\t\ttmp[arrays[0]] = 0;\n\t\tfor (int i = 1; i <= lengths; i++) tmp[arrays[i]] = tmp[arrays[i - 1]] + (compare_suffix(arrays[i - 1], arrays[i]) ? 1 : 0);\n\t\tfor (int i = 0; i <= lengths; i++) dat[i] = tmp[i];\n\t}\n}\nint main() {\n\tcin >> S >> Q;\n\tsuffix_array();\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> T;\n\t\tint l = 0, r = S.size() + 1, f = 0;\n\t\twhile (r - l > 1) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tstring S1 = S.substr(arrays[m], T.size());\n\t\t\tif (S1 == T) flag = 1; break;\n\t\t\tif (S1 < T) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tprintf(\"%d\\n\", f);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nclass suffix_array{\n    void create_begin_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        int sum=0;\n        for(int i=0;i<bucket.size();i++){bucket[i]+=sum;swap(sum,bucket[i]);}\n    }\n\n    void create_end_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        for(int i=1;i<bucket.size();i++)bucket[i]+=bucket[i-1];\n    }\n\n    void induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_begin_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(sa[i]>0&&is_l[sa[i]-1])sa[bucket[v[sa[i]-1]]++]=sa[i]-1;\n    }\n\n    void invert_induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_end_bucket(v,bucket);\n        for(int i=v.size()-1;i>=0;i--)if(sa[i]>0&&!is_l[sa[i]-1])sa[--bucket[v[sa[i]-1]]]=sa[i]-1;\n    }\n\n    vector<int>sa_is(vector<int>v,int mv){\n        if(v.size()==1)return vector<int>(1,0);\n\n        vector<int>is_l(v.size());\n        vector<int>bucket(mv+1);\n        vector<int>sa(v.size(),-1);\n        auto is_lms=[&](int x)->bool{return x>0&&is_l[x-1]&&!is_l[x];};\n\n        is_l[v.size()-1]=0;\n        for(int i=v.size()-2;i>=0;i--)is_l[i]=v[i]>v[i+1]||(v[i]==v[i+1]&&is_l[i+1]);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(is_lms(i))sa[--bucket[v[i]]]=i;\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n\n        int cur=0;\n        vector<int>order(v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))order[i]=cur++;\n\n        vector<int>next_v(cur);\n        cur=-1;\n        int prev=-1;\n        for(int i=0;i<v.size();i++){\n            if(!is_lms(sa[i]))continue;\n            bool diff=false;\n            for(int d=0;d<v.size();d++){\n                if(prev==-1||v[sa[i]+d]!=v[prev+d]||is_l[sa[i]+d]!=is_l[prev+d]){\n                    diff=true;\n                    break;\n                }\n                else if(d>0&&is_lms(sa[i]+d))break;\n            }\n            if(diff){cur++;prev=sa[i];}\n            next_v[order[sa[i]]]=cur;\n        }\n\n        vector<int>re_order(next_v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))re_order[order[i]]=i;\n        vector<int>next_sa=sa_is(next_v,cur);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<sa.size();i++)sa[i]=-1;\n        for(int i=next_sa.size()-1;i>=0;i--)sa[--bucket[v[re_order[next_sa[i]]]]]=re_order[next_sa[i]];\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n        return sa;\n    }\n\n    vector<int>sa_is(string &s){\n        vector<int>v(s.size()+1);\n        for(int i=0;i<s.size();i++)v[i]=s[i];\n        sa=sa_is(v,*max_element(v.begin(),v.end()));\n    }\n\n    void construct_lcp(){\n        lcp.resize(s.size());\n        rank.resize(s.size()+1);\n        int n=s.size();\n        for(int i=0;i<=n;i++)rank[sa[i]]=i;\n        int h=0;\n        lcp[0]=0;\n        for(int i=0;i<n;i++){\n            int j=sa[rank[i]-1];\n\n            if(h>0)h--;\n            for(;j+h<n&&i+h<n;h++){\n                if(s[j+h]!=s[i+h])break;\n            }\n            lcp[rank[i]-1]=h;\n        }\n    }\n\n    class sparse_table{\n        vector<vector<int> >st;\n    public:\n        void init(vector<int>&v){\n            int b;\n            for(b=0;(1<<b)<=v.size();b++);\n            st.assign(b,vector<int>(1<<b));\n            for(int i=0;i<v.size();i++)st[0][i]=v[i];\n\n            for(int i=1;i<b;i++){\n                for(int j=0;j+(1<<i)<=(1<<b);j++){\n                    st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);\n                }\n            }\n        }\n        int get_min(int l,int r){\n            assert(l<r);\n            int b=32-__builtin_clz(r-l)-1;\n            return min(st[b][l],st[b][r-(1<<b)]);\n        }\n        sparse_table(){}\n        sparse_table(vector<int>&v){init(v);}\n    };\n    sparse_table st;\npublic:\n    string s;\n    vector<int>sa,lcp,rank;\n    void init(string &t){\n        s=t;\n        sa_is(s);\n        construct_lcp();\n        st.init(lcp);\n    }\n    suffix_array(string &t){init(t);}\n    suffix_array(){}\n\n    bool contain(string &t){\n        int lb=0,ub=s.size();\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            if(s.compare(sa[mid],t.size(),t)<0)lb=mid;\n            else ub=mid;\n        }\n        return s.compare(sa[ub],t.size(),t)==0;\n    }\n\n    int get_lcp(int i,int j){\n        if(rank[i]>rank[j])swap(i,j);\n        return st.get_min(rank[i],rank[j]);\n    }\n};\n\nsigned main(){\n    string s;cin>>s;\n    suffix_array sa(s);\n    int q;cin>>q;\n    while(q--){\n        string t;\n        cin>>t;\n        cout<<sa.contain(t)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst long long B=1000000000000000003LL;\nconst long long P=1000000000000000009LL;\n\nvoid gen_hash(const string &s,vector<long long> &hash){\n\tlong long c=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tc=(c*(__int128_t)B+s[i])%P;\n\t\thash[i]=c;\n\t}\n}\nlong long pow_binary_mod(long long x,long long y,long long mod){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=(__int128_t)z*x%mod;\n\t\tx=(__int128_t)x*x%mod;\n\t}\n\treturn z;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s;\n\tcin>>s;\n\tint ls=s.size();\n\tvector<long long> v(ls),hsh(10001);\n\tgen_hash(s,v);\n\n\tint T;\n\tfor(cin>>T;T--;){\n\t\tstring q;\n\t\tcin>>q;\n\t\tint lq=q.size();\n\t\tgen_hash(q,hsh);\n\t\tlong long hash=hsh[lq-1];\n\t\tlong long Brev=pow_binary_mod(B,lq,P);\n\t\tvector<int> r;\n\t\tint i=lq-1;\n\t\tfor(;i<ls;i++){\n\t\t\tif(v[i]==((i>=lq?v[i-lq]:0)*(__int128_t)Brev+hash)%P){\n\t\t\t\tr.push_back(i-lq+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!r.empty()){\n\t\t\t//for(int i=0;i<r.size();i++)printf(\"%d\\n\",r[i]);\n\t\t\tputs(\"1\");\n\t\t}else{\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1<<20\nusing namespace std;\n\nstruct P{\n  int a,b,idx;\n  P(){a=b=idx=0;}\n  P(int a,int b,int idx):a(a),b(b),idx(idx){};\n  bool operator < (const P &A) const{\n    if(a!=A.a) return a>A.a;\n    return b>A.b;\n  }\n};\n\nchar ch[N];\nP r[N];\nint n;\n\nvector<int> Sort(){\n    vector <int> R(n+1),res(n+1);\n  \n  for(int i=0;i<=n;i++) R[i]=ch[i];\n  \n  for(int i=1;i<=n;i*=2){\n    for(int j=0;j<=n;j++)r[j]=P(R[j],(j+i<=n)? R[j+i]:0,j);\n    sort(r,r+n+1);\n    R[r[0].idx]=n;\n    for(int j=1,C=n;j<=n;j++){\n      if(r[j-1]<r[j]) C--;\n      R[r[j].idx]=C;\n    }\n\n    //    for(int j=0;j<=n;j++)cout<<R[j]<<' ';\n    //\t\t\t   cout<<endl;\n\n  }\n  for(int i=0;i<=n;i++) res[R[i]]=i;\n  return res;\n}\n\nint check(vector <int> &a,char *x){\n  /*\n  cout<<'!'<<endl;\n  for(int i=0;i<n+1;i++){\n    printf(\"%d %s\\n\",a[i],ch+a[i]);\n  }\n  cout<<'!'<<endl;\n  */\n  int L=0,M,R=n;\n  int m=strlen(x);\n\n  while(L<R){\n    M=(L+R)/2;\n    if(strncmp(ch+a[M],x,m)<0)L=M+1;\n    else R=M;\n  }\n\n  return strncmp(ch+a[L],x,m)==0;\n}\n\nint main(){\n  scanf(\"%s\",ch);\n  n=strlen(ch);\n  int q;\n  cin>>q;\n  vector <int> Rank=Sort();\n  char a[1001];\n\n  while(q--){\n    scanf(\"%s\",a);\n    printf(\"%d\\n\",check(Rank,a));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring S,T;\nstring V[50000][500];\nint main(){\n\tint q,a,b,c;\n\tcin>>S;\n\tb=S.size();\n\ta=min(b,100);\n\tfor(int i=1;i<100;i++){\n\t\tfor(int j=0;j<=b-i;j++){\n\t\t\tV[j][i]=S.substr(j,i);\n\t\t}\n\t}\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>T;\n\t\tc=T.size();\n\t\tfor(int j=0;j<=b-c;j++){\n\t\t\tif(V[j][c]==T){\n\t\t\t\tcout<<\"1\"<<endl;\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t}\n\t\tcout<<\"0\"<<endl;\n\t\tExit:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\n\nstruct SuffixArray {\n\tint n, k;\n\tstring s;\n\tvector<int> ord, tmp, left;\n\tSuffixArray(const string &s) :s(s), n(s.size()), ord(n + 1), tmp(n + 1), left(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tleft[i] = i;\n\t\t\tord[i] = i < n ? s[i] : -1;\n\t\t}\n\t\tauto compare = [&](int i, int j) {\n\t\t\tif (ord[i] != ord[j])return ord[i] < ord[j];\n\t\t\telse {\n\t\t\t\tint ri = i + k <= n ? ord[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? ord[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t}\n\t\t};\n\t\tfor (k = 1; k <= n; k *= 2) {\n\t\t\tsort(left.begin(), left.end(), compare);\n\t\t\ttmp[left[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[left[i]] = tmp[left[i - 1]] + (compare(left[i - 1], left[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tord = tmp;\n\t\t}\n\t\tdump(ord, tmp, left);\n\t}\n\tint search(const string &pattern) {\n\t\tint m = pattern.size();\n\t\tauto f = [&](int x) {\n\t\t\tstring t = s.substr(left[x], min(m, n - left[x]));\n\t\t\tdump(x, t);\n\t\t\treturn pattern <= t;\n\t\t};\n\t\tauto binarySearch = [&](int ng, int ok) {\n\t\t\tif (f(ng))return ng;\n\t\t\twhile (ng + 1 < ok) {\n\t\t\t\tint m = (ng + ok) / 2;\n\t\t\t\tif (f(m))\n\t\t\t\t\tok = m;\n\t\t\t\telse\n\t\t\t\t\tng = m;\n\t\t\t}\n\t\t\treturn ok;\n\t\t};\n\t\tint ok = binarySearch(0, n + 1);\n\t\tif (ok > n)\n\t\t\treturn -1;\n\t\telse {\n\t\t\tstring t = s.substr(left[ok], min(m, n - left[ok]));\n\t\t\treturn pattern == t ? left[ok] : -1;\n\t\t}\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring T; cin >> T;\n\tint Q; cin >> Q;\n\tSuffixArray sa(T);\n\trep(i, 0, Q) {\n\t\tstring P; cin >> P;\n\t\tcout << (sa.search(P) != -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n// ------ Function ------ //\ninline unsigned int __builtin_clz(unsigned int x) { unsigned long r; _BitScanReverse(&r, x); return 31 - r; }\n\n// ------ Suffix Array ------ //\nclass SuffixArray {\n\tvoid CreateBeginBucket(vector<int>&v, vector<int>&bucket) {\n\t\tfill(bucket.begin(), bucket.end(), 0);\n\t\tfor (int i = 0; i<v.size(); i++)bucket[v[i]]++;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i<bucket.size(); i++) { bucket[i] += sum; swap(sum, bucket[i]); }\n\t}\n\tvoid CreateEndBucket(vector<int>&v, vector<int>&bucket) {\n\t\tfill(bucket.begin(), bucket.end(), 0);\n\t\tfor (int i = 0; i<v.size(); i++)bucket[v[i]]++;\n\t\tfor (int i = 1; i<bucket.size(); i++)bucket[i] += bucket[i - 1];\n\t}\n\tvoid InducedSort(vector<int>&v, vector<int>&SA, int mv, vector<int>&bucket, vector<int>&isL) {\n\t\tCreateBeginBucket(v, bucket);\n\t\tfor (int i = 0; i<v.size(); i++)if (SA[i]>0 && isL[SA[i] - 1])SA[bucket[v[SA[i] - 1]]++] = SA[i] - 1;\n\t}\n\tvoid InvertInducedSort(vector<int>&v, vector<int>&SA, int mv, vector<int>&bucket, vector<int>&isL) {\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = v.size() - 1; i >= 0; i--)if (SA[i]>0 && !isL[SA[i] - 1])SA[--bucket[v[SA[i] - 1]]] = SA[i] - 1;\n\t}\n\tvector<int>SA_IS(vector<int>v, int mv) {\n\t\tif (v.size() == 1)return vector<int>(1, 0);\n\t\tvector<int>isL(v.size());\n\t\tvector<int>bucket(mv + 1);\n\t\tvector<int>SA(v.size(), -1);\n\t\tauto isLMS = [&](int x)->bool {return x>0 && isL[x - 1] && !isL[x]; };\n\t\tisL[v.size() - 1] = 0;\n\t\tfor (int i = v.size() - 2; i >= 0; i--)isL[i] = v[i]>v[i + 1] || (v[i] == v[i + 1] && isL[i + 1]);\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))SA[--bucket[v[i]]] = i;\n\t\tInducedSort(v, SA, mv, bucket, isL);\n\t\tInvertInducedSort(v, SA, mv, bucket, isL);\n\t\tint cur = 0;\n\t\tvector<int>ord(v.size());\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))ord[i] = cur++;\n\t\tvector<int>nxv(cur);\n\t\tcur = -1;\n\t\tint prev = -1;\n\t\tfor (int i = 0; i<v.size(); i++) {\n\t\t\tif (!isLMS(SA[i]))continue;\n\t\t\tbool diff = false;\n\t\t\tfor (int d = 0; d<v.size(); d++) {\n\t\t\t\tif (prev == -1 || v[SA[i] + d] != v[prev + d] || isL[SA[i] + d] != isL[prev + d]) {\n\t\t\t\t\tdiff = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (d>0 && isLMS(SA[i] + d))break;\n\t\t\t}\n\t\t\tif (diff) { cur++; prev = SA[i]; }\n\t\t\tnxv[ord[SA[i]]] = cur;\n\t\t}\n\t\tvector<int>reord(nxv.size());\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))reord[ord[i]] = i;\n\t\tvector<int>nxSA = SA_IS(nxv, cur);\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = 0; i<SA.size(); i++)SA[i] = -1;\n\t\tfor (int i = nxSA.size() - 1; i >= 0; i--)SA[--bucket[v[reord[nxSA[i]]]]] = reord[nxSA[i]];\n\t\tInducedSort(v, SA, mv, bucket, isL);\n\t\tInvertInducedSort(v, SA, mv, bucket, isL);\n\t\treturn SA;\n\t}\n\tvector<int>SA_IS(string s) {\n\t\tvector<int>v(s.size() + 1);\n\t\tfor (int i = 0; i<s.size(); i++)v[i] = s[i] + 1;\n\t\treturn SA_IS(v, *max_element(v.begin(), v.end()));\n\t}\n\tvector<int>construct_lcp(string &s, vector<int>&sa) {\n\t\tvector<int> lcp, rank(s.size() + 1);\n\t\tint n = s.size();\n\t\tfor (int i = 0; i <= n; i++)rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tlcp[0] = 0;\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h>0) h--;\n\t\t\tfor (; j + h<n&&i + h<n; h++) {\n\t\t\t\tif (s[j + h] != s[i + h])break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\npublic:\n\tstring s;\n\tvector<int> sa, lcp;\n\tvoid init(string &T) {\n\t\ts = T;\n\t\tsa = SA_IS(s);\n\t}\n\tSuffixArray(string &t) { init(t); }\n\tSuffixArray() {}\n\tbool contain(string &t) {\n\t\tint a = 0, b = s.size();\n\t\twhile (b - a>1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (s.compare(sa[c], t.size(), t) < 0)a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn s.compare(sa[b], t.size(), t) == 0;\n\t}\n};"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n\n#pragma warning(disable: 4996)\n\nusing namespace std;\n\nint Q; char STR1[1000001], STR2[1001];\n\nvector<int> ptr[62];\n\nconst char strings[63] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890\";\n\nint main()\n{\n\tscanf(\"%s\", &STR1);\n\n\tfor (int i = 0; i < strlen(STR1); i++)\n\t{\n\t\tfor (int j = 0; j < 62; j++)\n\t\t{\n\t\t\tif (STR1[i] == strings[j])\n\t\t\t{\n\t\t\t\tptr[j].push_back(i); break;\n\t\t\t}\n\t\t}\n\t}\n\n\tscanf(\"%d\", &Q);\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%s\", STR2);\n\n\t\tint code_;\n\t\tint size_;\n\n\t\tfor (int j = 0; j < 62; j++)\n\t\t{\n\t\t\tif (STR2[0] == strings[j])\n\t\t\t{\n\t\t\t\tsize_ = ptr[j].size();\n\n\t\t\t\tcode_ = j;\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 0; j < size_; j++)\n\t\t{\n\t\t\tint ptr_ = ptr[code_][j];\n\n\t\t\tif (ptr[code_][j] + strlen(STR2) < strlen(STR1))\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < strlen(STR2); k++)\n\t\t\t\t{\n\t\t\t\t\tif (STR1[ptr_ + k] != STR2[k])\n\t\t\t\t\t{\n\t\t\t\t\t\tgoto Exit1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintf(\"1\\n\");\n\n\t\t\tgoto Exit2;\n\n\t\tExit1:;\n\t\t}\n\n\t\tprintf(\"0\\n\");\n\n\tExit2:;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<long long mod=1000000007,long long roll=82371827>\nclass suffix_array{\nprivate:\n    ll mod_pow(ll a,ll x){\n        if(a==0){return 0;}\n        ll ret=1;\n        while(x>0){\n            if(x&1){(ret*=a)%=mod;}\n            (a*=a)%=mod;\n            x>>=1;\n        }\n        return ret;\n    }\n    \n    typedef unsigned long ul;\n    \n    struct node{\n        ll begin;\n        ll Rank;\n        node* next;\n        \n        inline bool operator < (const node &N) const {\n            if(Rank==N.Rank){\n                return (next==NULL?-1:next->Rank)<(N.next==NULL?-1:N.next->Rank);\n            }\n            return Rank<N.Rank;\n        }\n        \n        node(ll begin=0,ll Rank=0,node* next=NULL):begin(begin),Rank(Rank),next(next){}\n    };\n    \n    static bool pointer_cmp(node* &a,node* &b){return (*a)<(*b);}\n    \n    vector<node*> sa;\n    vector<ll> Rank;\n    vector<ll> Hash;\n    const string s;\n    \n    void build(){\n        for(int i=0;i<s.size();i++){\n            *sa[i]={i,s[i],sa[i+1]};\n        }\n        sa[s.size()]->begin=s.size();\n        sa[s.size()]->Rank=-1;\n        sa[s.size()]->next=NULL;\n        vector<node*> Next(s.size()+1);\n        for(ll k=1;k<=s.size();k<<=1){\n            sort(sa.begin(),sa.end(),pointer_cmp);\n            Rank[sa[0]->begin]=0;\n            Next[0]=(sa[0]->next==NULL?NULL:sa[0]->next->next);\n            for(int i=1;i<=s.size();i++){\n                Rank[sa[i]->begin]=Rank[sa[i-1]->begin]+(*sa[i-1]<*sa[i]?1:0);\n                Next[i]=(sa[i]->next==NULL?NULL:sa[i]->next->next);\n            }\n            for(int i=0;i<=s.size();i++){\n                sa[i]->Rank=Rank[sa[i]->begin];\n                sa[i]->next=Next[i];\n            }\n        }\n        for(int i=0;i<=s.size();i++){\n            Next[sa[i]->begin]=sa[i];\n        }\n        for(int i=0;i<=s.size();i++){\n            sa[i]->next=sa[i]->begin==s.size()?NULL:Next[sa[i]->begin+1];\n        }\n    }\n    \n    //1::greater 0::same -1::less\n    int compare(const ul &saf,const vector<ll> &str){\n        if(s[sa[saf]->begin]!=str[1]){return s[sa[saf]->begin]<str[1]?-1:1;}\n        ll l=1,r=min((ll)str.size()-1,(ll)s.size()-sa[saf]->begin)-1;\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            if(hash(sa[saf]->begin,sa[saf]->begin+m)==str[m+1]){l=m+1;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(hash(sa[saf]->begin,sa[saf]->begin+i)!=str[i+1]){return hash(sa[saf]->begin+i,sa[saf]->begin+i)<(str[i+1]+mod-str[i]*roll%mod)%mod?-1:1;}\n        }\n        return str.size()-1>s.size()-sa[saf]->begin?1:0;\n    }\n    \n    ul diff(const ul &saf,const vector<ll> &str){\n        if(s[sa[saf]->begin]!=str[1]){return 0;}\n        ll l=1,r=min(str.size()-1,s.size()-sa[saf].begin)-1;\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            if(hash(sa[saf]->begin,sa[saf]->begin+m)==str[m+1]){l=m+1;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(hash(sa[saf]->begin,sa[saf]->begin+i)!=str[i+1]){return i;}\n        }\n        return min(str.size()-1,s.size()-sa[saf].begin);\n    }\n    \n    bool is_in(const ul &saf,const vector<ll> &str){\n        return sa[saf]->begin+str.size()<=Hash.size() && str.back()==hash(sa[saf]->begin,sa[saf]->begin+str.size()-2);\n    }\n    \npublic:\n    suffix_array(const string &str):s(str),Rank(str.size()+1),sa(str.size()+1),Hash(str.size()+1,0){\n        for(int i=1;i<Hash.size();i++){\n            Hash[i]=Hash[i-1]*roll%mod+s[i-1];\n            Hash[i]%=mod;\n        }\n        for(int i=0;i<=s.size();i++){\n            sa[i]=(node*)malloc(sizeof(node));\n        }\n        build();\n    }\n    \n    ~suffix_array(){\n        for(int i=0;i<=s.size();i++){free(sa[i]);}\n    }\n    \n    ll rank(const ul &where) const {return Rank[where];}\n    \n    ul size() const {return sa.size();}\n    \n    const node & operator [] (const ul &where) const {return *sa[where];}\n    \n    ll hash(ll where){return Hash[where+1];}\n    \n    ll hash(ll l,ll r){return (Hash[r+1]+mod-Hash[l]*mod_pow(roll,r-l+1)%mod)%mod;}\n    \n    //返すのはsuffixの番号\n    ul lower_bound(const string &sub){\n        vector<ll> H(sub.size()+1,0);\n        for(int i=1;i<H.size();i++){\n            H[i]=H[i-1]*roll%mod+sub[i-1];\n            H[i]%=mod;\n        }\n        ll l=0;\n        ll r=s.size();\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            if(compare(m,H)==-1){l=m+1;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(compare(i,H)>=0){return i;}\n        }\n        return r+1;\n    }\n    \n    //返すのはsuffixの番号\n    ul upper_bound(const string &sub){\n        vector<ll> H(sub.size()+1,0);\n        for(int i=1;i<H.size();i++){\n            H[i]=H[i-1]*roll%mod+sub[i-1];\n            H[i]%=mod;\n        }\n        ll l=0;\n        ll r=s.size();\n        while(r-l>4){\n            ll m=l+(r-l)/2;\n            if(compare(m,H)<=0){l=m+1;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(compare(i,H)>0){return i;}\n        }\n        return r+1;\n    }\n    \n    bool match(const string &sub){\n        vector<ll> H(sub.size()+1,0);\n        for(int i=1;i<H.size();i++){\n            H[i]=H[i-1]*roll%mod+sub[i-1];\n            H[i]%=mod;\n        }\n        ll l=0;\n        ll r=s.size();\n        while(r-l>10){\n            ll m=l+(r-l)/2;\n            int st=compare(m,H);\n            if(st==0){return true;}\n            else if(st==-1){l=m+1;}\n            else{r=m-1;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(is_in(i,H)){return true;}\n        }\n        return false;\n    }\n};\n\n\nint main(){\n    string t;\n    cin>>t;\n    suffix_array<1000000007,82371827> S(t);\n    ll q;\n    cin>>q;\n    while(q--){\n        string p;\n        cin>>p;\n        cout<<S.match(p)<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define MAX 1000002\n\nint Lv[MAX];\nint n, k;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n    return L_i < L_j;\n}\n\nint main()\n{\n    int A[MAX], newLv[MAX];\n    char t[MAX];\n    scanf(\"%s\", t);\n    std::string T = std::string(t);\n    n = T.size();\n\n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n    std::sort(A, A + n, cmp_Lv);\n\n    newLv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        newLv[A[i]] = newLv[A[i - 1]] + (Lv[A[i]] != Lv[A[i - 1]] ? 1 : 0);\n    }\n    for(i = 0; i < n; i++){ Lv[i] = newLv[i]; }\n\n    k = 1;\n    while(1){\n        if(k > n) break;\n\n        std::sort(A, A + n, cmp);\n        newLv[A[0]] = 0;\n        for(i = 1; i < n; i++){ newLv[A[i]] = newLv[A[i - 1]] + (cmp(A[i - 1], A[i]) ? 1 : 0); }\n        for(i = 0; i < n; i++){ Lv[i] = newLv[i]; }\n\n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n\n    char p[MAX];\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n\n    A[n] = n;\n\n    while(q){\n        scanf(\"%s\", p);\n        std::string P = std::string(p);\n        left = 0, right = n, exist = false;\n        while(left < right){\n\n            if(n < P.size()){ exist = false; break; }\n\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n\n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <map>\n#include <new>\n#include <deque>\n#include <functional>\nusing namespace std;\n \ntemplate <class T>\nstruct myalloc{\n\tusing value_type = T;\n \n\tstatic const int num = 700;\n\tstatic int k;\n\tstatic deque<vector<char>> dq;\n \n\tmyalloc(){}\n\ttemplate <class U>\n\tmyalloc(const myalloc<U> &){}\n \n\tT* allocate(size_t n){\n\t\tif(k >= num || dq.empty()){\n\t\t\tdq.emplace_back(num * sizeof(T));\n\t\t\tk = 0;\n\t\t}\n\t\treturn reinterpret_cast<T*>(&dq.back()[k++ * sizeof(T)]);\n\t}\n \n\tvoid deallocate(T*, size_t){}\n};\n \ntemplate <class T>\nint myalloc<T>::k;\ntemplate <class T>\ndeque<vector<char>> myalloc<T>::dq;\n \nstruct node{\n\tint fail;\n\tbool vis;\n\tmap<char,int,less<char>,myalloc<char>> nxt;\n};\n \nvector<node> trie;\n \nstring input(){\n\tstatic char buf[1000010];\n\tbuf[0] = 0;\n\tscanf(\"%s\", buf);\n\treturn buf;\n}\n \nint main(){\n\ttrie.reserve(1000010);\n \n\ttrie.emplace_back();\n\ttrie[0].fail = -1;\n \n\tstring t = input();\n\tint q;\n\tscanf(\"%d\", &q);\n\tvector<int> idx(q);\n\tfor(int i = 0; i < q; ++i){\n\t\tstring p = input();\n\t\tint u = 0;\n\t\tfor(char c : p){\n\t\t\tif(!trie[u].nxt.count(c)){\n\t\t\t\ttrie[u].nxt.emplace(c, trie.size());\n\t\t\t\ttrie.emplace_back();\n\t\t\t}\n\t\t\tu = trie[u].nxt[c];\n\t\t}\n\t\tidx[i] = u;\n\t}\n \n\tvector<int> bfs;\n\tbfs.push_back(0);\n\tint k = 0;\n\twhile(k < (int)bfs.size()){\n\t\tint u = bfs[k++];\n\t\tfor(const auto &pr : trie[u].nxt){\n\t\t\tchar c = pr.first;\n\t\t\tint v = pr.second;\n\t\t\tbfs.push_back(v);\n \n\t\t\tint f = trie[u].fail;\n\t\t\twhile(f >= 0 && !trie[f].nxt.count(c)){\n\t\t\t\tf = trie[f].fail;\n\t\t\t}\n\t\t\ttrie[v].fail = f >= 0 ? trie[f].nxt[c] : 0;\n\t\t}\n\t}\n \n\tint r = 0;\n\tfor(char c : t){\n\t\twhile(r >= 0 && !trie[r].nxt.count(c)){\n\t\t\tr = trie[r].fail;\n\t\t}\n\t\tr = r >= 0 ? trie[r].nxt[c] : 0;\n\t\ttrie[r].vis = true;\n\t}\n \n\tfor(int i = bfs.size(); --i; ){\n\t\tint u = bfs[i];\n\t\tif(trie[u].vis){\n\t\t\ttrie[trie[u].fail].vis = true;\n\t\t}\n\t}\n \n\tfor(int i = 0; i < q; ++i){\n\t\tprintf(\"%d\\n\", +trie[idx[i]].vis);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define MAX 10002\ntypedef unsigned char byte;\nbyte mask[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\n\nint Lv[MAX];\nint n, k;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n    return L_i < L_j;\n}\n\nint main()\n{\n    int A[MAX];\n    char c[MAX];\n    scanf(\"%s\", c);\n    std::string T = std::string(c);\n    n = T.size();\n    byte *t;\n    t = new byte [(n >> 3) + 1];\n\tbool act;\n\tint l, r;\n\n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n\n    int bkt[129];\n    for(i = 0; i < 129; i++){ bkt[i] = 0; }\n    for(i = 0; i < n; i++){ bkt[Lv[i]]++; }\n    int sum = 0;\n    for(i = 0; i < 129; i++){ sum += bkt[i]; bkt[i] = sum; }\n    for(i = 0; i < n; i++){ A[--bkt[Lv[i]]] = i; }\n\n    //std::sort(A, A + n, cmp_Lv);\n\n    for(i = 1; i < n; i++){\n        t[i >> 3] = (Lv[A[i]] != Lv[A[i - 1]] ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n    }\n    t[n >> 3] = t[n >> 3] | mask[n & 7];\n\n    Lv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n    }\n\n    k = 1;\n    while(1){\n        if(k > n) break;\n\n        act = true;\n        for(i = 1; i <= n; i++){\n            if(act){\n                if(!!(mask[i & 7] & t[i >> 3])){ continue; }\n                else{ l = i - 1; act = false; }\n            }else{\n                if(!!(mask[i & 7] & t[i >> 3])){\n                    r = i; std::sort(A + l, A + r, cmp); act = true; }\n                    else{ continue; }\n            }\n        }\n\n        for(i = 1; i < n; i++){\n            t[i >> 3] = (cmp(A[i - 1], A[i]) ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n        }\n        t[n >> 3] = t[n >> 3] | mask[n & 7];\n\n        Lv[A[0]] = 0;\n        for(i = 1; i < n; i++){\n            Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n        }\n\n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n\n    char p[1000];\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n\n    A[n] = n;\n\n    while(q){\n        scanf(\"%s\", p);\n        std::string P = std::string(p);\n        left = 0, right = n, exist = false;\n        while(left < right){\n\n            if(n < P.size()){ exist = false; break; }\n\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n\n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<functional>\nusing namespace std;\n#define MAX_N 1100000\nint Rank[MAX_N], x[MAX_N];\nint SA[MAX_N]; string S, T; int V;\nbool Compare(int p, int q) {\n\tif (Rank[p] < Rank[q])return true;\n\tif (Rank[p] > Rank[q])return false;\n\tint D1 = -1, D2 = -1;\n\tif (p + V <= S.size())D1 = Rank[p + V];\n\tif (q + V <= S.size())D2 = Rank[q + V];\n\tif (D1 < D2)return true;\n\treturn false;\n}\nvoid Build() {\n\tfor (int i = 0; i < S.size(); i++) { SA[i] = i; Rank[i] = S[i]; }\n\tSA[S.size()] = S.size(); Rank[S.size()] = -1;\n\tfor (V = 1; V <= S.size(); V *= 2) {\n\t\tsort(SA, SA + S.size() + 1, Compare);\n\t\tx[SA[0]] = 0;\n\t\tfor (int i = 1; i <= S.size(); i++) {\n\t\t\tx[SA[i]] = x[SA[i - 1]] + Compare(SA[i - 1], SA[i]);\n\t\t}\n\t\tfor (int i = 0; i <= S.size(); i++)Rank[i] = x[i];\n\t}\n}\nint hantei(int C, string &V2) {\n\tint H = min(S.size() - C, V2.size());\n\tfor (int i = 0; i < H; i++) {\n\t\tif (S[i + C] < V2[i])return -1;\n\t\tif (S[i + C] > V2[i])return 1;\n\t}\n\treturn 0;\n}\nint main() {\n\tcin >> S; S += '!'; int Q; cin >> Q; Build();\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> T; int L = 0, R = S.size() + 1, M;\n\t\twhile (L + 1 < R) {\n\t\t\tM = (L + R) / 2;\n\t\t\tif (hantei(SA[M], T) <= 0)L = M;\n\t\t\telse { R = M; }\n\t\t}\n\t\tif (hantei(SA[L], T) == 0)cout << \"1\" << endl;\n\t\telse cout << \"0\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nnamespace SA{\n    const int MAX=100000;\n    int N,K;\n    int tmp[MAX+1],rank[MAX+1];\n    bool compare_sa(int i,int j){\n        if(rank[i]!=rank[j])return rank[i]<rank[j];\n        else{\n            int ri=(i+K<=N)?rank[i+K]:-1;\n            int rj=(j+K<=N)?rank[j+K]:-1;\n            return ri<rj;\n        }\n    }\n\n    vector<int> construct_sa(string S){\n        N=S.size();\n        vector<int>sa(N+1);\n        for(int i=0;i<=N;i++)sa[i]=i;\n        for(int i=0;i<=N;i++){\n            rank[i]=i==N?-1:S[i];\n        }\n\n        for(K=1;K<=N;K*=2){\n            sort(sa.begin(),sa.end(),compare_sa);\n            tmp[sa[0]]=0;\n            for(int i=1;i<=N;i++){\n                tmp[sa[i]]=tmp[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n            }\n            for(int i=0;i<=N;i++)rank[i]=tmp[i];\n        }\n        return sa;\n    }\n}\n\nstring S;\nvint sa;\nint Q;\n\nbool exist(string T){\n    int lb=0,ub=S.size();\n    while(ub-lb>1){\n        int mid=(ub+lb)/2;\n        if(S.substr(sa[mid],min(S.size()-mid,T.size()))<T)lb=mid;\n        else ub=mid;\n    }\n    if(ub<=S.size()&&S.size()-sa[ub]>=T.size()&&S.substr(sa[ub],T.size())==T)return true;\n    return false;\n}\n\nsigned main(){\n    cin>>S;\n    sa=SA::construct_sa(S);\n    cin>>Q;\n\n    rep(i,sa.size())cout<<S.substr(sa[i],S.size()-sa[i])<<endl;\n\n    while(Q--){\n        string T;cin>>T;\n        if(exist(T))cout<<1<<endl;\n        else cout<<0<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint Q, doubles, lengths, dat[1000009], tmp[1000009], array[1000009]; string S, T;\nbool compare_suffix(int i, int j) {\n    if (dat[i] == dat[j]) {\n        int ri = (i + doubles <= lengths ? dat[i + doubles] : -1);\n        int rj = (j + doubles <= lengths ? dat[j + doubles] : -1);\n        return ri < rj;\n    }\n\treturn dat[i] < dat[j];\n}\nvoid suffix_array() {\n    lengths = S.size();\n    for (int i = 0; i <= lengths; i++) arrays[i] = i, dat[i] = i < lengths ? S[i] : -1;\n    for (doubles = 1; doubles <= lengths; doubles <<= 1) {\n        sort(arrays.begin(), arrays.begin() + lengths + 1, compare_suffix);\n        tmp[arrays[0]] = 0;\n        for (int i = 1; i <= lengths; i++) tmp[arrays[i]] = tmp[arrays[i - 1]] + (compare_suffix(arrays[i - 1], arrays[i]) ? 1 : 0);\n        for (int i = 0; i <= lengths; i++) dat[i] = tmp[i];\n    }\n}\nstring S, T; int Q;\nint main() {\n    cin >> S >> Q;\n    vector<int> sa = suffix_array(S);\n    for (int i = 0; i < Q; i++) {\n        cin >> T;\n        int l = 0, r = sa.size(); bool flag = false;\n        while (r - l > 1) {\n            int m = (l + r) / 2;\n            string S1 = S.substr(sa[m], T.size());\n            if (S1 == T) {\n                flag = true; break;\n            }\n            if (S1 < T) l = m;\n            else r = m;\n        }\n        printf(flag ? \"1\\n\" : \"0\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "from collections import defaultdict\nfrom math import floor, log \n\n\nclass NoMatch(Exception):\n    pass\n\n\nclass IndexMatch:\n    MAX_KEYLEN = 13\n\n    def __init__(self, text):\n        self.text = text\n        self.keylen = self._select_keylen()\n        self._create_index()\n\n    def _select_keylen(self):\n        chars = set(list(self.text))\n        return min(floor(log(len(self.text), len(chars))), self.MAX_KEYLEN)\n\n    def _create_index(self):\n        index = defaultdict(set)\n        particles = set()\n        for i in range(len(self.text)+1):\n            for j in range(max(i-self.keylen, 0), i): \n                if i - j < self.keylen // 2:\n                    particles.add(self.text[j:i])\n                else:\n                    index[self.text[j:i]].add(j)\n        self.index = index\n        self.particles = particles\n\n    def match(self, search_text):\n        def _match(lo, hi):\n            text = search_text[lo:hi]\n            if hi-lo <= self.keylen:\n                return self.index[text]\n\n            mid = (lo + hi) // 2\n            pre = _match(lo, mid)\n            post = _match(mid, hi) \n\n            if len(pre) == 0 or len(post) == 0:\n                raise NoMatch()\n\n            indices = set(i for i in pre if i+mid-lo in post)\n            return indices\n\n        if len(search_text) < self.keylen // 2:\n            return search_text in self.particles\n\n        try:\n            match = _match(0, len(search_text))\n            return len(match) > 0 \n        except NoMatch:\n            return False\n\n\ndef run():\n    s1 = input()\n    n = int(input())\n\n    matcher = IndexMatch(s1)\n    for _ in range(n):\n        s2 = input()\n        if matcher.match(s2):\n            print(1)\n        else:\n            print(0)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\nint *Lv;\nint n, k;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n    return L_i < L_j;\n}\n\nint main()\n{\n    int *A, *newLv;\n    std::string T;\n    std::cin >> T;\n    n = T.size();\n\n    A = new int [n + 1]; Lv = new int [n + 1]; newLv = new int [n + 1];\n\n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n    std::sort(A, A + n, cmp_Lv);\n\n    newLv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        newLv[A[i]] = newLv[A[i - 1]] + (Lv[A[i]] != Lv[A[i - 1]] ? 1 : 0);\n    }\n    for(i = 0; i < n; i++){ Lv[i] = newLv[i]; }\n\n    k = 1;\n    while(1){\n        if(k > n) break;\n\n        std::sort(A, A + n, cmp);\n        newLv[A[0]] = 0;\n        for(i = 1; i < n; i++){ newLv[A[i]] = newLv[A[i - 1]] + (cmp(A[i - 1], A[i]) ? 1 : 0); }\n        for(i = 0; i < n; i++){ Lv[i] = newLv[i]; }\n\n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n\n    delete [] Lv; delete [] newLv;\n\n    char p[1000];\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n\n    A[n] = n;\n\n    while(q){\n        scanf(\"%s\", p);\n        std::string P = std::string(P);\n        left = 0, right = n, exist = false;\n        while(left < right){\n\n            if(n < P.size()){ exist = false; break; }\n\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n\n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n\tdelete [] A;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(string s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  bool operator()(int i, int j) { \n    int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  \n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  \n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  sort(ALL(sa),rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  while(n--){\n    scanf(\" %s\",&t[0]);\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nusing i64=int64_t;\n\nvector<int> suffix_array(const string &s){\n    const int n=s.size();\n    vector<int> rank(n+1),sa(n+1),tmp(n+1);\n    for(int i=0; i<=n; ++i){\n        sa[i]=i;\n        rank[i]=i<n?s[i]:-1;\n    }\n    for(int k=1; k<=n; k*=2){\n        auto compare=[&](int i,int j){\n            if(rank[i]!=rank[j]) return rank[i]<rank[j];\n            else{\n                int ri=i+k<=n?rank[i+k]:-1;\n                int rj=j+k<=n?rank[j+k]:-1;\n                return ri<rj;\n            }\n        };\n        sort(sa.begin(),sa.end(),compare);\n        tmp[sa[0]]=0;\n        for(int i=1; i<=n; ++i){\n            tmp[sa[i]]=tmp[sa[i-1]]+(compare(sa[i-1],sa[i])?1:0);\n        }\n        for(int i=0; i<=n; ++i){\n            rank[i]=tmp[i];\n        }\n    }\n    return sa;\n}\n\nint lower_bound(const string& s,const vector<int>& sa,const string t){\n    int lb=0,ub=sa.size();\n    while(ub-lb>1){\n        int m=(lb+ub)/2;\n        if(s.substr(sa[m],t.size())>=t) ub=m;\n        else lb=m;\n    }\n    return ub;\n}\n\nint upper_bound(const string& s,const vector<int>& sa,const string t){\n    int lb=0,ub=sa.size();\n    while(ub-lb>1){\n        int m=(lb+ub)/2;\n        if(s.substr(sa[m],t.size())>t) ub=m;\n        else lb=m;\n    }\n    return ub;\n}\n\nvoid solve(){\n    string S;\n    int q;\n    cin >> S >> q;\n    auto sa=suffix_array(S);\n    rep(i,0,q){\n        string T;\n        cin >> T;\n        if(upper_bound(S,sa,T)-lower_bound(S,sa,T)>=1) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nstring S; int Q; char STR[1005];\n\nint main()\n{\n\tcin >> S >> Q; cout << string::npos << endl;\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%s\", STR);\n\n\t\tprintf(\"%d\\n\", S.find(STR) != 18446744073709551615LL ? 1 : 0);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define INF 1 << 30\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntypedef complex<double> dcomplex;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\nll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\n\nint n;\nstring s;\n\nbool solve(string t)\n{\n  int m = t.size();\n  map<char,int> f;\n  DOWN(i,m-1,0) f[t[i]] = i;\n  int p = m-1;\n  while(p<n)\n  {\n    int k = m-1;\n    while(k >= 0 && t[k] == s[p]) {k--; p--;}\n    if(k == -1) return true;\n    else\n    {\n      if(f.find(s[p])==f.end()) p += m;\n      else p += max(f[s[p]],m-k);\n    }\n  }\n  return false;\n}\n\nint main()\n{\n  cin >> s;\n  n = s.size();\n  int q; cin >> q;\n  REP(i,q)\n  {\n    string t; cin >> t;\n    cout << solve(t) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s){\n    n=SZ(s);\n    pow=(ull *)malloc(n+1);\n    phash=(ull *)malloc(n+1);\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }  \n};\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  const int n = SZ(a);\n  if(n>1){\n    vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(b,rh), mergesort(c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==SZ(c))a[i]=b[j++];\n      else if(j==SZ(b))a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  mergesort(sa,rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000000];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cassert>\nusing namespace std;\n\nconst int ALPH = 256;\nstruct SuffixArray {\nprivate:\n    string s;\n    vector<int> rec, cnt;\n    int len, cnt_size;\npublic:\n    SuffixArray(string s_) : s(s_) {\n        s += \"$\"; // 辞書順で最も小さいダミー文字\n        len = s.length();\n        cnt_size = max(ALPH, len); cnt.resize(cnt_size);\n        rec = getArray();\n    }\n\n    void dump_array(vector<int> &indices, vector<int> &classes) {\n        fprintf(stderr, \"# debug\\n\");\n        fprintf(stderr, \"# indices:\");\n        for(int i=0; i<len; i++) fprintf(stderr, \" %d\", indices[i]);\n        fprintf(stderr, \"\\n\");\n        fprintf(stderr, \"# classes:\");\n        for(int i=0; i<len; i++) fprintf(stderr, \" %d\", classes[i]);\n        fprintf(stderr, \"\\n\");\n    }\n    \n    vector<int> getArray() {\n        vector<int> indices(len), prev_idx(len);\n        vector<int> classes(len), prev_cls(len);\n        vector<int> tmp_val(len);\n\n        // k == 0 はカウントソートのみ\n        for(int i=0; i<len; i++) {\n            cnt[ s[i] ]++;\n        }\n        for(int i=1; i<cnt_size; i++) {\n            cnt[i] += cnt[i-1];\n        }\n        for(int i=len-1; i>=0; i--) {\n            indices[ --cnt[ s[i] ] ] = i;\n        }\n        for(int i=1; i<len; i++) {\n            int pena = (s[ indices[i] ] != s[ indices[i-1] ]);\n            classes[ indices[i] ] = classes[ indices[i-1] ] + pena;\n        }\n        // dump_array(indices, classes);\n        \n        for(int k=0; (1 << k) < len; k++) {\n            swap(indices, prev_idx);\n            swap(classes, prev_cls);\n            for(int i=0; i<len; i++) {\n                // 後半だけソート済みにしたものを indices に代入\n                prev_idx[i] = prev_idx[i] - (1 << k);\n                if(prev_idx[i] < 0) prev_idx[i] += len;\n                tmp_val[i] = prev_cls[ prev_idx[i] ];\n            }\n\n            // 前半についてカウントソート\n            fill(cnt.begin(), cnt.end(), (int)0);\n            for(int i=0; i<len; i++) {\n                cnt[ tmp_val[i] ]++;\n            }\n            for(int i=1; i<cnt_size; i++) {\n                cnt[i] += cnt[i-1];\n            }\n            for(int i=len-1; i>=0; i--) {\n                indices[ --cnt[ tmp_val[i] ] ] = prev_idx[i];\n            }\n            classes[ indices[0] ] = 0;\n            for(int i=1; i<len; i++) {\n                int shift = (1 << k);\n                pair<int, int> pre(prev_cls[ indices[i-1] ], prev_cls[ (indices[i-1] + shift) % len ]);\n                pair<int, int> cur(prev_cls[ indices[i  ] ], prev_cls[ (indices[i  ] + shift) % len ]);\n                int pena = (pre != cur);\n                classes[ indices[i] ] = classes[ indices[i-1] ] + pena;\n            }   \n            // dump_array(indices, classes);\n        }\n        return indices;\n    }\n\n    int size() {\n        return rec.size();\n    }\n    int get(int idx) {\n        assert(0 <= idx and idx < size());\n        return rec[idx];\n    }\n    // パターン文字列 p は、idx 番目に小さい接尾辞に比べて大きいか？\n    bool is_greater(string &p, int idx) {\n        idx = get(idx);\n        int N = size(), M = p.size(), x, y;\n        for(x=idx, y=0; x<N and y<M; x++, y++) {\n            if(s[x] < p[y]) return true;\n            if(s[x] > p[y]) return false;\n        }\n        return x >= N and y < M;\n    }\n};\n\nint search_by_sa(SuffixArray &sa, string &p) {\n    int N = sa.size(), ansL, ansR;\n\n    int lb = 0, ub = N;\n    while(ub - lb > 1) {\n        int mid = (ub + lb) / 2;\n        if(sa.is_greater(p, mid)) lb = mid;\n        else ub = mid;\n    }\n    ansL = ub;\n\n    p.back()++;\n    \n    lb = 0, ub = N;\n    while(ub - lb > 1) {\n        int mid = (ub + lb) / 2;\n        if(sa.is_greater(p, mid)) lb = mid;\n        else ub = mid;\n    }\n    ansR = ub;\n    p.back()--;\n\n    return ansR - ansL;\n}\n\nint main() {\n    string s; cin >> s;\n    SuffixArray sa(s);\n\n    /*\n    for(int i=0; i<=s.length(); i++) {\n        cout << s.substr(sa.get(i)) << endl;\n    }\n    */\n\n    int N; scanf(\"%d\", &N);\n    for(int i=0; i<N; i++) {\n        char buf[1024]; scanf(\"%s\", buf);\n        string p = buf;\n        if(search_by_sa(sa, p) > 0) {\n            puts(\"1\");\n        }\n        else {\n            puts(\"0\");\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <map>\n#include <new>\n#include <deque>\n#include <functional>\nusing namespace std;\n \ntemplate <class T>\nstruct myalloc{\n\tusing value_type = T;\n \n\tstatic const int num = 700;\n\tstatic int k;\n\tstatic deque<vector<char>> dq;\n \n\tmyalloc(){}\n\ttemplate <class U>\n\tmyalloc(const myalloc<U> &){}\n \n\tT* allocate(size_t n){\n\t\tif(k >= num || dq.empty()){\n\t\t\tdq.emplace_back(num * sizeof(T));\n\t\t\tk = 0;\n\t\t}\n\t\treturn reinterpret_cast<T*>(&dq.back()[k++ * sizeof(T)]);\n\t}\n \n\tvoid deallocate(T*, size_t){}\n};\n \ntemplate <class T>\nint myalloc<T>::k;\ntemplate <class T>\ndeque<vector<char>> myalloc<T>::dq;\n \nstruct node{\n\tint fail;\n\tbool vis;\n\tmap<char,int,less<char>,myalloc<char>> nxt;\n};\n \n \nstring input(){\n\tstatic char buf[1000010];\n\tbuf[0] = 0;\n\tscanf(\"%s\", buf);\n\treturn buf;\n}\n \nint main(){\n\tvector<node> trie(1);\n\ttrie[0].fail = -1;\n\n\ttrie.reserve(1000010);\n \n\tstring t = input();\n\tint q;\n\tscanf(\"%d\", &q);\n\tvector<int> idx(q);\n\tfor(int i = 0; i < q; ++i){\n\t\tstring p = input();\n\t\tint u = 0;\n\t\tfor(char c : p){\n\t\t\tif(!trie[u].nxt.count(c)){\n\t\t\t\ttrie[u].nxt.emplace(c, trie.size());\n\t\t\t\ttrie.emplace_back();\n\t\t\t}\n\t\t\tu = trie[u].nxt[c];\n\t\t}\n\t\tidx[i] = u;\n\t}\n \n\tvector<int> bfs;\n\tbfs.push_back(0);\n\tint k = 0;\n\twhile(k < (int)bfs.size()){\n\t\tint u = bfs[k++];\n\t\tfor(const auto &pr : trie[u].nxt){\n\t\t\tchar c = pr.first;\n\t\t\tint v = pr.second;\n\t\t\tbfs.push_back(v);\n \n\t\t\tint f = trie[u].fail;\n\t\t\twhile(f >= 0 && !trie[f].nxt.count(c)){\n\t\t\t\tf = trie[f].fail;\n\t\t\t}\n\t\t\ttrie[v].fail = f >= 0 ? trie[f].nxt[c] : 0;\n\t\t}\n\t}\n \n\tint r = 0;\n\tfor(char c : t){\n\t\twhile(r >= 0 && !trie[r].nxt.count(c)){\n\t\t\tr = trie[r].fail;\n\t\t}\n\t\tr = r >= 0 ? trie[r].nxt[c] : 0;\n\t\ttrie[r].vis = true;\n\t}\n \n\tfor(int i = bfs.size(); --i; ){\n\t\tint u = bfs[i];\n\t\tif(trie[u].vis){\n\t\t\ttrie[trie[u].fail].vis = true;\n\t\t}\n\t}\n \n\tfor(int i = 0; i < q; ++i){\n\t\tprintf(\"%d\\n\", +trie[idx[i]].vis);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n/2+n%2,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==nc)a[i]=b[j++];\n      else if(j==nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[2000000];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 1000001\n \nint n,k,sa[MAX_N];\nint rank[MAX_N],tmp[MAX_N];\n \nbool compare_sa(int i,int j){\n    if(rank[i] != rank[j]){\n        return rank[i] < rank[j];\n    }else{\n        int ri = i + k <= n ? rank[i+k] : -1;\n        int rj = j + k <= n ? rank[j+k] : -1;\n        return ri < rj;\n    }\n}\n\nvoid construct_sa(string &S,int *sa){\n    n = S.length();\n   \n    for(int i = 0 ; i <= n ; i++){\n        sa[i] = i;\n        rank[i] = i < n ? S[i] : -1;\n    }\n \n    for(k = 1 ; k <= n ; k *= 2){\n        sort(sa,sa+n+1,compare_sa);\n     \n        tmp[sa[0]] = 0;\n        for(int i = 1 ; i <= n ; i++){\n            tmp[sa[i]] = tmp[sa[i-1]] + (compare_sa(sa[i-1],sa[i]) ? 1 : 0);\n        }\n        for(int i = 0 ; i <= n ; i++){\n            rank[i] = tmp[i];\n        }\n    }\n}\n \nbool contain(string &S,int *sa,string &T){\n    int a = 0, b = S.length();\n    while(b - a > 1){\n        int c = (a + b) / 2;\n        if(S.compare(sa[c],T.length(),T) < 0) a = c;\n        else b = c;\n    }\n    return S.compare(sa[b],T.length(),T) == 0;\n}\n \nint main(){\n    ios::sync_with_stdio(0);\n    \n    int Q,l;\n    string S,T;\n    cin >> S >> Q;\n    construct_sa(S,sa);\n    l = S.size();\n    while(Q--){\n        cin >> T;\n        if(l < T.size()){ cout << '0' << '\\n'; continue; }\n        cout << (contain(S,sa,T) ? '1' : '0') << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int i, const int j) { \n    int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n  \n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  \n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  \n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\n\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nbool CheckString(std::string A, std::string B) {\n\tfor (unsigned int i = 0; i < A.size(); ++i) {\n\t\tif (A[i] == B[0] ) {\n\t\t\tstd::string Middle = A.substr(i, B.size());\n\t\t\tif (B.size() > Middle.size()) { break; }\n\t\t\telse if (Middle == B) {\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\treturn false;\n}\nint main(void) {\n\tstd::ios_base::sync_with_stdio(false);\n\tstd::string T;\n\tint Q;\n\tstd::cin >> T >> Q;\n\tstd::vector<std::string>P(Q);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tstd::cin >> P[i];\n\t}\n\tfor (int i = 0; i < Q; ++i) {\n\t\tstd::cout << CheckString(T, P[i]) << std::endl;\n\t}\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\nvector<int> construct_sa(const string& S){\n  vector<int> SA, ranks, tmp;\n  int N = S.length();\n\n  SA.resize(N + 1);\n  ranks.resize(N + 1);\n  tmp.resize(N + 1);\n\n  for(int i = 0; i <= N; i++){\n    SA[i] = i;\n    ranks[i] = (i < N ? S[i] : -1);\n  }\n\n  for(int k = 1; k <= N; k *= 2){\n    auto f = [&](const int& a,const int& b){\n      if(ranks[a] != ranks[b]) return ranks[a] < ranks[b];\n      else{\n        int ra = (a + k <= N ? ranks[a + k] : -1);\n        int rb = (b + k <= N ? ranks[b + k] : -1);\n        return ra < rb;\n      }\n    };\n\n    sort(SA.begin(), SA.end(), f);\n\n    tmp[SA[0]] = 0;\n    for(int i = 1; i <= N; i++){\n      tmp[SA[i]] = tmp[SA[i-1]] + (f(SA[i-1], SA[i]) ? 1 : 0);\n    }\n    for(int i = 0; i <= N; i++){\n      ranks[i] = tmp[i];\n    }\n  }\n  return SA;\n}\n\n//int main(int argc, char **argv){\nint main(){\n  /*if(argc < 3){\n    cerr << \"Few arguments.\" << endl;\n    return 0;\n  }*/\n\n\n  string S;\n  cin>>S;\n  int N=S.size();\n  vector<int> SA=construct_sa(S);\n\n  int Q;\n  cin>>Q;\n  while(Q--){\n    string T;\n    cin>>T;\n    int L=T.size();\n    int l=0,r=N+1;\n    rep(i,L){\n      int nl,nr;\n\n      {\n        int lb=l-1,ub=r;\n        while(ub-lb>1){\n          int mid=(lb+ub)/2;\n          if(SA[mid]+i<N&&S[SA[mid]+i]>=T[i]) ub=mid;\n          else lb=mid;\n        }\n        nl=ub;\n      }\n      {\n        int lb=l-1,ub=r;\n        while(ub-lb>1){\n          int mid=(lb+ub)/2;\n          if(SA[mid]+i<N&&S[SA[mid]+i]>T[i]) ub=mid;\n          else lb=mid;\n        }\n        nr=ub;\n      }\n\n      l=nl; r=nr;\n    }\n\n    if(l!=r)printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n-nb,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==nc)a[i]=b[j++];\n      else if(j==nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  mergesort(n,sa,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef unsigned long long int ull;\n\nconst ull B=1e9+7;//base of hash\n\nbool contain(string s,string a)\n{\n\tint sl=s.length(),al=a.length();\n\tif(sl<al)return false;\n\t\n\tull t=1;\n\tfor(int i=0;i<al;i++)t*=B;\n\t\n\tull sh=0,ah=0;\n\tfor(int i=0;i<al;i++)\n\t{\n\t\tsh=sh*B+s[i];\n\t\tah=ah*B+a[i];\n\t}\n\t\n\tif(sh==ah)return true;\n\t\n\tfor(int i=0;i+al<sl;i++)\n\t{\n\t\tsh=sh*B+s[i+al]-s[i]*t;\n\t\tif(sh==ah)return true;\n\t}\n\t\n\treturn false;\n}\n\nvector<int> match(string s,string a)\n{\n\tint sl=s.length(),al=a.length();\n\tvector<int> ans;\n\tif(sl<al)return ans;\n\tull t=1;\n\tull ah=0,sh=0;\n\tfor(int i=0;i<al;i++)\n\t{\n\t\tsh=sh*B+s[i];\n\t\tah=ah*B+a[i];\n\t\tt*=B;\n\t}\n\t\n\tif(sh==ah)ans.push_back(0);\n\t\n\tfor(int i=0;i+al<sl;i++)\n\t{\n\t\tsh=sh*B+s[i+al]-s[i]*t;\n\t\tif(sh==ah)ans.push_back(i+1);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tstring s;cin>>s;\n\tint n;cin>>n;\n\tstring a;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a;\n\t\tcout<<contain(s,a)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S 2500005\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\nstruct d{\n  int a,b,c;\n  d(){}\n  d(int A,int B,int C){\n    a=A,b=B,c=C;\n  };\n  bool operator<(const d&r)const{\n    if(a!=r.a)return a<r.a;\n    return b<r.b;\n  }\n};\n\nint n,slen,tlen,r[S];\nchar s[S],t[N];\nd ran[S];\nP a[S];\n\nvoid init(){\n  for(int i=0;i<26;i++)\n    for(int j=0;j<slen;j++)\n      if('a'+i==s[j])r[j]=i+1;\n  int x=1;\n  r[slen]=0;\n  while(x<slen){\n    for(int i=0;i<slen;i++){\n      int o=i+x;\n      if(o>slen)o=slen;\n      ran[i]=d(r[i],r[o],i);\n    }\n    sort(ran,ran+slen);\n    int cnt=1;\n    for(int i=0;i<slen;i++){\n      r[ran[i].c]=cnt;\n      if(ran[i].a==ran[i+1].a&&ran[i].b==ran[i+1].b)\n    continue;\n      cnt++;\n    }\n    x*=2;\n  }\n  for(int i=0;i<slen;i++)a[i]=P(r[i],i);\n  sort(a,a+slen);\n}\n\nbool bynary_search(){\n  int L=0,R=slen;\n  while(L<R){\n    int M=(L+R)/2;\n    if(strncmp(s+a[M].second,t,tlen)<0)L=M+1;\n    else R=M;\n  }\n  if(!strncmp(s+a[L].second,t,tlen))return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s%d\",s,&n);\n  slen=strlen(s);\n  init();  \n  while(n--){\n    scanf(\"%s\",t);\n    tlen=strlen(t);\n    if(bynary_search())printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    build_sa();\n    //build_lcp();\n    //build_rmq();\n  }\n  void build_sa(){\n    S.push_back('$');\n    vector<int> c(n+1,0),ord(n+1,0);\n    for(int i=0;i<=n;i++) ord[i]=n-i;\n    sort(ord.begin(),ord.end(),[&](int a,int b){return S[a]<S[b];});\n    for(int i=0;i<=n;i++){\n      sa[i]=ord[i];\n      c[i]=S[i];\n    }\n    vector<int> r(n+1),cnt(n+1),s(n+1);\n    for(int len=1;len<=n;len*=2){\n      for(int i=0;i<=n;i++){\n\tr[i]=c[i];\n\tcnt[i]=i;\n\ts[i]=sa[i];\n      }\n      for(int i=0;i<=n;i++){\n\t c[sa[i]]=\n\t   i>0&&\n\t   r[sa[i-1]]==r[sa[i]] &&\n\t   sa[i-1]+len<=n &&\n\t   r[sa[i-1]+len/2]==r[sa[i]+len/2] ?\n\t   c[sa[i-1]]:i;\n      }\n      for(int i=0;i<=n;i++){\n\tint s1=s[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n+1);\n    for(int i=0;i<=n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    //assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int MAX = 26;\n\nint encode(char c){\n\tif(isdigit(c)){\n\t\treturn  c - '0';\n\t}else if(islower(c)){\n\t\treturn 0 + c - 'a';\n\t}else if(isupper(c)){\n\t\treturn 10 + 26 + c - 'A';\n\t}\n\n\tassert(false && \"invalid string\");\n}\n\nstruct Node{\n\tint nxt[MAX+1];\t\t\t// 次のalphabeteのノード番号\n\tint exist;\t\t\t\t// 子ども以下に存在する文字列の数の合計\n\tvector<int> accept;\t\t// その文字列id\n\tNode() : exist(0){memset(nxt, -1, sizeof(nxt));}\n};\n\nclass Trie{\n\tprivate:\n\t\tvoid updateDirect(int node,int id){\n\t\t\tac.emplace_back(node);\n\t\t\tnodes[node].accept.emplace_back(id);\n\t\t}\n\t\tvoid updateChild(int node,int child,int id){\n\t\t\t++nodes[node].exist;\n\t\t}\n\t\tvoid add(const string &str,int str_index,int node_index,int id){\n\t\t\tif(str_index == str.size())\n\t\t\t\tupdateDirect(node_index, id);\n\t\t\telse{\n\t\t\t\tconst int c = encode(str[str_index]);\n\t\t\t\tif(nodes[node_index].nxt[c] == -1) {\n\t\t\t\t\tnodes[node_index].nxt[c] = (int) nodes.size();\n\t\t\t\t\tnodes.emplace_back(Node());\n\t\t\t\t}\n\t\t\t\tadd(str, str_index + 1, nodes[node_index].nxt[c], id);\n\t\t\t\tupdateChild(node_index, nodes[node_index].nxt[c], id);\n\t\t\t}\n\t\t}\n\t\tvoid add(const string &str,int id){add(str, 0, 0, id);}\n\tpublic:\n\t\tvector<Node>nodes;\n\t\tvector<int> ac; // ac[i] := i番目のパターンを受理する状態番号\n\t\tint root;\n\t\tTrie() : root(0){nodes.emplace_back(Node());}\n\t\tvoid add(const string &str){add(str, nodes[0].exist);}\n\t\tint size(){return (nodes[0].exist);}\n\t\tint nodesize(){return ((int) nodes.size());}\n};\n\nclass AhoCorasick : public Trie{\n\tpublic: \n\t\tstatic const int FAIL = MAX;\n\t\tvector<int> correct;\n\t\tAhoCorasick() : Trie() {}\n\n\t\tvoid build(){\n\t\t\tcorrect.resize(nodes.size());\n\t\t\trep(i,nodes.size())correct[i]=(int)nodes[i].accept.size();\n\n\t\t\tqueue<int> que;\n\t\t\trep(i,MAX+1){\n\t\t\t\tif(~nodes[0].nxt[i]) {\n\t\t\t\t\tnodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n\t\t\t\t\tque.emplace(nodes[0].nxt[i]);\n\t\t\t\t}else nodes[0].nxt[i] = 0;\n\t\t\t}\n\t\t\twhile(!que.empty()) {\n\t\t\t\tNode now = nodes[que.front()];\n\t\t\t\tcorrect[que.front()] += correct[now.nxt[FAIL]];\n\t\t\t\tque.pop();\n\t\t\t\trep(i,MAX){\n\t\t\t\t\tif(now.nxt[i] == -1) continue;\n\t\t\t\t\tint fail = now.nxt[FAIL];\n\t\t\t\t\twhile(nodes[fail].nxt[i] == -1) {\n\t\t\t\t\t\tfail = nodes[fail].nxt[FAIL];\n\t\t\t\t\t}\n\t\t\t\t\tnodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n\n\t\t\t\t\tauto &u = nodes[now.nxt[i]].accept;\n\t\t\t\t\tauto &v = nodes[nodes[fail].nxt[i]].accept;\n\t\t\t\t\tvector<int> accept;\n\t\t\t\t\tset_union(all(u),all(v),back_inserter(accept));\n\t\t\t\t\tu=accept;\n\t\t\t\t\tque.emplace(now.nxt[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// result := 各パターンがそれぞれ何度マッチしたか\n\t\tint match(const string &str,vector<int> &result,int now=0){\n\t\t\tresult.assign(size(),0);\n\t\t\tint count=0;\n\t\t\tfor(auto &c:str) {\n\t\t\t\twhile(nodes[now].nxt[encode(c)]==-1)now=nodes[now].nxt[FAIL];\n\t\t\t\tnow = nodes[now].nxt[encode(c)];\n\t\t\t\tcount += correct[now];\n\t\t\t\tfor(auto &v:nodes[now].accept)result[v]++;\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\t\tint next(int now,char c){\n\t\t\twhile(nodes[now].nxt[encode(c)]==-1)now=nodes[now].nxt[FAIL];\n\t\t\treturn nodes[now].nxt[encode(c)];\n\t\t}\n};\n\nint main(){\n\tstring s;\n\tint n;\n\tcin >> s >> n;\n\n\tAhoCorasick aho;\n\trep(i,n){\n\t\tstring a;\n\t\tcin >> a;\n\t\taho.add(a);\n\t}\n\tvector<int> res;\n\taho.build();\n\taho.match(s, res);\n\tfor(auto i : res) cout << (i == 0 ? 0 : 1) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int i, const int j) { \n    //const int k=lcp(i,j);\n    const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n  \n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n\n  inline ull hash(const int b, const int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  inline int lcp(const int i, const int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n\n  int lcp2(const int i, const int j, const int l, const int r){\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\n\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  string T;\n  int Q;\n  cin>>T;\n  cin>>Q;\n  int flag[Q]={0};\n  string P[Q];\n  for(int i=0;i<Q;i++)\n    cin>>P[i];\n  for(int i=0;i<Q;i++){\n    for(int j=0;j<T.size()-P[i].size();j++){\n      if(P[i]==T.substr(j,P[i].size()))\n\tflag[i]=1;\n    }\n  }\n  for(int i=0;i<Q;i++)\n    cout<<flag[i]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\n#define NUM 48\nusing namespace std;\n\nint T_char_count[128] = {0},P_char_count[128];\nint T_Chain[128][128];\n\nclass LocRecord{\n\npublic:\n\t//?????¢???????¢????\n\tLocRecord(){\n\t\tlocationTable = new int**[128];\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tlocationTable[i] = new int*[128];\n\t\t\tfor(int k = 0; k < 128; k++){\n\t\t\t\tif(T_Chain[i][k] > 0){\n\t\t\t\t\tlocationTable[i][k] = new int[T_Chain[i][k]+1];\n\t\t\t\t\tfor(int p = 0; p < T_Chain[i][k]+1; p++){\n\t\t\t\t\t\tlocationTable[i][k][p] = -1;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tlocationTable[i][k] = new int[2];\n\t\t\t\t\tfor(int p = 0; p < 2; p++){\n\t\t\t\t\t\tlocationTable[i][k][p] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinit();\n\t}\n\n\t//-1?????£??\\\n\tvoid init(){\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tfor(int k = 0; k < 128; k++){\n\t\t\t\tindex[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init_index(char first,char second){\n\t\tindex[first][second] = 0;\n\t}\n\n\tvoid regist_loc(char first,char second,int location){\n\t\tlocationTable[first][second][index[first][second]] = location;\n\t\tindex[first][second]++;\n\t}\n\n\tint next_loc(char first,char second){\n\t\tint ret = locationTable[first][second][index[first][second]];\n\t\tindex[first][second]++;\n\t\treturn ret;\n\t}\n\nprivate:\n\tint*** locationTable;\n\tint index[128][128];\n};\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\t\t\treturn length < arg.length;\n\t};\n\tInfo(int arg_length,int arg_id,ull arg_hashValue){\n\t\tlength = arg_length;\n\t\tid = arg_id;\n\t\thashValue = arg_hashValue;\n\t}\n\n\tint length,id;\n\tull hashValue;\n};\n\nint main(){\n\n\tfor(int i = 0; i < 128; i++){\n\t\tT_char_count[i] = 0;\n\t\tfor(int k = 0; k < 128; k++){\n\t\t\tT_Chain[i][k] = 0;\n\t\t}\n\t}\n\n\tint T_length;\n\n\tchar* T = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tint count = 1;\n\n\tfor(T_length = 0; T[T_length] != '\\0';T_length++){\n\t\tT_char_count[T[T_length]]++;\n\n\t}\n\n\tLocRecord locRecord;\n\tlocRecord.init();\n\n\n\tchar pre = T[0];\n\t//T[i]????????????i??§???????????¨????¨????\n\tfor(int i = 1; i < T_length; i++){\n\t\tlocRecord.regist_loc(pre,T[i],i-1);\n\t\tpre = T[i];\n\t}\n\n\tull* HASH = new ull[T_length+1];\n\tull* P = new ull[T_length+1];\n\n\tHASH[0] = 0;\n\tP[0] = 1;\n\n\t//T??????????????\\???????±???????\n\tfor(int i = 1; i <= T_length; i++){\n\t\tHASH[i] = T[i-1] + HASH[i-1]*MOD;\n\t\tP[i] = P[i-1]*MOD;\n\t}\n\n\n\tvector<Info> V[128][128];\n\n\tint Q,S_length,left,P_char_count[128];\n\tscanf(\"%d\",&Q);\n\n\tbool check[Q];\n\n\tfor(int i = 0; i < Q; i++)check[i] = false;\n\n\tchar S[1001];\n\tull S_HASH[1001],S_value,T_value,D;\n\tbool FLG;\n\n\t//Q??¶??????????????\\???????¨????\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",S);\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tP_char_count[i] = 0;\n\t\t}\n\n\t\tfor(S_length = 0;S[S_length] != '\\0';S_length++){\n\t\t\tP_char_count[S[S_length]]++;\n\t\t}\n\n\t\tFLG = true;\n\n\t\tcount = 0;\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tif(T_char_count[i] < P_char_count[i]){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG)continue;\n\n\t\tif(S_length == 1){\n\t\t\tcheck[loop] = true;\n\t\t\tcontinue;\n\t\t}\n\n\n\n\t\tS_HASH[0] = 0;\n\t\tfor(int i = 1; i <= S_length; i++){\n\t\t\tS_HASH[i] = S[i-1] + S_HASH[i-1]*MOD;\n\t\t}\n\n\t\tS_value = S_HASH[S_length];\n\n\t\tV[S[0]][S[1]].push_back(Info(S_length,loop,S_value));\n\t}\n\n\tint calc_length;\n\n\tfor(int first_word = 48; first_word <= 122; first_word++){\n\t\tfor(int second_word = 48; second_word <= 122;second_word++){\n\t\t\tfor(int i = 0; i < V[first_word][second_word].size();i++){\n\n\t\t\t\tlocRecord.init_index(first_word,second_word);\n\n\t\t\t\tcalc_length = V[first_word][second_word][i].length;\n\t\t\t\tS_value = V[first_word][second_word][i].hashValue;\n\n\t\t\t\tD = P[calc_length];\n\n\t\t\t\twhile((left = locRecord.next_loc(first_word,second_word)) != -1){\n\t\t\t\t\tif(left+calc_length-1 >= T_length)break;\n\n\t\t\t\t\tT_value = HASH[left+calc_length]-HASH[left]*D;\n\n\t\t\t\t\tif(T_value == S_value){\n\t\t\t\t\t\tcheck[V[first_word][second_word][i].id] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tif(check[i])printf(\"1\\n\");\n\t\telse{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ull unsigned long long\nusing namespace std;\null B=100000007;\nint h[1001]={};\nvector<int> v[1000];\nvoid contain(string b,int n){\n  int bl=b.size();\n  \n  ull t=1;\n  for(int i=0;i<n;i++)t*=B;\n\n  int bh=0;\n  for(int i=0;i<n;i++)bh=bh*B+b[i];\n\n  for(int i=0;i+n<=bl;i++){\n    v[n].push_back(bh);\n    if(i+n<bl)bh=bh*B+b[i+n]-b[i]*t;\n  }\n  sort(v[n].begin(),v[n].end());\n  return;\n}\n\nint main(){\n  int n;\n  string b;\n  cin>>b>>n;\n  for(int i=0;i<n;i++){\n    string a;\n    cin>>a;\n    int al=a.size();\n    if(h[al]==0){\n      contain(b,al);\n      h[al]=1;\n    }\n    int ah=0;\n    for(int i=0;i<al;i++)ah=ah*B+a[i];\n    //cout<<\"ah = \"<<ah<<endl;\n    //for(int i=0;i<v[al].size();i++)cout<<\"v[i] = \"<<v[al][i]<<endl;\n    int l=1,m,r=v[al].size(),f=0;\n    while(r-l>1){\n      m=(l+r)/2;\n      if(v[al][m]==ah){\n\tf=1;\n\tbreak;\n      }else if(v[al][m]>ah)r=m;\n      else l=m;\n    }\n    cout<<f<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; i++)\nstatic const int dx[4] = { 0, 1, 0, -1 };\nstatic const int dy[4] = { 1, 0, -1, 0 };\nstatic const char dir[4] = { 'u', 'r', 'd', 'l' };\nstatic const ll INF = 1 << 21;\nstatic const ll MOD = 1e9 + 7;\nclass SuffixArray {\nprivate:\n    int n;\n    vector<int> rank;\npublic:\n    string s;\n    vector<int> idx;\n    SuffixArray(string& s)\n        : n(s.size())\n        , rank(s.size() + 1)\n        , s(s)\n        , idx(s.size() + 1)\n    {\n        rep(i, n + 1)\n        {\n            idx[i] = i;\n            rank[i] = i < n ? s[i] : -1;\n        }\n        int k;\n        auto comp = [&](const int i, const int j) -> bool {\n            if (rank[i] != rank[j]) {\n                return rank[i] < rank[j];\n            } else {\n                int ri = i + k <= n ? rank[i + k] : -1;\n                int rj = j + k <= n ? rank[j + k] : -1;\n                return ri < rj;\n            }\n        };\n\n        vector<int> tmp(n + 1);\n        for (k = 1; k <= n; k *= 2) {\n            sort(idx.begin(), idx.end(), comp);\n\n            tmp[idx[0]] = 0;\n            for (int i = 1; i < n + 1; i++) {\n                tmp[idx[i]] = tmp[idx[i - 1]] + (comp(idx[i - 1], idx[i]) ? 1 : 0);\n            }\n            rank = tmp;\n        }\n    }\n    bool contain(string& t)\n    {\n        int right = n, left = 0;\n        while (right - left > 1) {\n            int mid = (right + left) / 2;\n            if (s.substr(idx[mid], t.size()) < t) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        return s.substr(idx[right], t.size()) == t;\n    }\n};\n\nint main()\n{\n    string T;\n    int Q;\n    cin >> T >> Q;\n\n    SuffixArray suf(T);\n    rep(i, Q)\n    {\n        string P;\n        cin >> P;\n        cout << suf.contain(P) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define MAX 10002\ntypedef unsigned char byte;\nbyte mask[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\n\nint Lv[MAX];\nint n, k;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n    return L_i < L_j;\n}\n\nint main()\n{\n    int A[MAX];\n    char c[MAX];\n    scanf(\"%s\", c);\n    std::string T = std::string(c);\n    n = T.size();\n    byte *t;\n    t = new byte [(n >> 3) + 1];\n\tbool act;\n\tint l, r;\n\n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n\t\n\tbyte bkt[129];\n\tfor(i = 0; i < 129; i++){ bkt[i] = 0; }\n\tfor(i = 0; i < n; i++){ bkt[Lv[i]]++; }\n\tint sum;\n\tfor(i = 0; i < 129; i++){ sum += bkt[i]; bkt[i] = sum; }\n\tfor(i = 0; i < n; i++){ A[bkt[Lv[i]]--] = i; }\n\n    //std::sort(A, A + n, cmp_Lv);\n\n    for(i = 1; i < n; i++){\n        t[i >> 3] = (Lv[A[i]] != Lv[A[i - 1]] ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n    }\n    t[n >> 3] = t[n >> 3] | mask[n & 7];\n\n    Lv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n    }\n\n    k = 1;\n    while(1){\n        if(k > n) break;\n\n        act = true;\n        for(i = 1; i <= n; i++){\n            if(act){\n                if(!!(mask[i & 7] & t[i >> 3])){ continue; }\n                else{ l = i - 1; act = false; }\n            }else{\n                if(!!(mask[i & 7] & t[i >> 3])){\n                    r = i; std::sort(A + l, A + r, cmp); act = true; }\n                    else{ continue; }\n            }\n        }\n\n        for(i = 1; i < n; i++){\n            t[i >> 3] = (cmp(A[i - 1], A[i]) ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n        }\n        t[n >> 3] = t[n >> 3] | mask[n & 7];\n\n        Lv[A[0]] = 0;\n        for(i = 1; i < n; i++){\n            Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n        }\n\n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n\n    char p[1000];\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n\n    A[n] = n;\n\n    while(q){\n        scanf(\"%s\", p);\n        std::string P = std::string(p);\n        left = 0, right = n, exist = false;\n        while(left < right){\n\n            if(n < P.size()){ exist = false; break; }\n\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n\n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair< P , int > PP;\n\nvoid suffixArray(char* s,vector<int> &res2){\n  \n  int len=strlen(s);\n  vector<int> res(len+1);\n  vector< PP > tmp(len+1);\n  res2=vector<int>(len+1);\n  \n  for(int i=0;i<=len;i++)res[i]=s[i];\n  \n  for(int k=1;k<=len;k*=2){\n    \n    for(int i=0;i<=len;i++){\n      tmp[i].first.first=res[i];\n      tmp[i].first.second=(i+k<=len?res[i+k]:0);\n      tmp[i].second=i;\n    }\n    sort(tmp.begin(),tmp.end());\n    int C=0;\n    for(int i=0;i<=len;i++){\n      int id=tmp[i].second;\n      if(i&& (tmp[i-1].first<tmp[i].first))C++;\n      res[id]=C;\n    }\n  }\n\n  //  vector<int> res2(len+1);\n  for(int i=0;i<=len;i++)res2[ res[i] ]=i;\n  //return res2;\n}\n\nchar s[1000005];\nchar t[1000005];\nint main(){\n  scanf(\"%s\",s);\n  vector<int> ans;\n  suffixArray(s,ans);\n\n  int Q;\n  scanf(\"%d\",&Q);\n  \n  while(Q--){\n    scanf(\"%s\",t);\n    int len=strlen(t);\n    int l=0,r=ans.size(),m;\n    while(r-l>1){\n      m=(l+r)/2;\n      if( strncmp( s+ans[m] , t ,len ) <=0 )l=m;\n      else r=m;\n    }\n    if(strncmp(s+ans[l],t,len)==0)printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  \n  /*\n  for(int i=0;i<(int)ans.size();i++){\n    printf(\"%d %s\\n\",ans[i], (s+ans[i]) );\n  }\n  */\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(string s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  bool operator()(int i, int j) { \n    int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  \n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  \n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  sort(ALL(sa),rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  if(10000 < s.size())assert(false);\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define MAX 1000002\ntypedef unsigned char byte;\nbyte mask[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\n\nint Lv[MAX];\nint n, k;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n    return L_i < L_j;\n}\n\nint main()\n{\n    int A[MAX];\n    char c[MAX];\n    scanf(\"%s\", c);\n    std::string T = std::string(c);\n    n = T.size();\n    byte *t;\n    t = new byte [(n >> 3) + 1];\n\tbool act;\n\tint l, r;\n\n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n\t\n\tbyte bkt[129];\n\tfor(i = 0; i < 129; i++){ bkt[i] = 0; }\n\tfor(i = 0; i < n; i++){ bkt[Lv[i]]++; }\n\tint sum = 0;\n\tfor(i = 0; i < 129; i++){ sum += bkt[i]; bkt[i] = sum; }\n\tfor(i = 0; i < n; i++){ A[--bkt[Lv[i]]] = i; }\n\n    //std::sort(A, A + n, cmp_Lv);\n\n\t\n\n\n\n    for(i = 1; i < n; i++){\n        t[i >> 3] = (Lv[A[i]] != Lv[A[i - 1]] ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n    }\n    t[n >> 3] = t[n >> 3] | mask[n & 7];\n\n    Lv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n    }\n\n    k = 1;\n    while(1){\n        if(k > n) break;\n\n        act = true;\n        for(i = 1; i <= n; i++){\n            if(act){\n                if(!!(mask[i & 7] & t[i >> 3])){ continue; }\n                else{ l = i - 1; act = false; }\n            }else{\n                if(!!(mask[i & 7] & t[i >> 3])){\n                    r = i; std::sort(A + l, A + r, cmp); act = true; }\n                    else{ continue; }\n            }\n        }\n\n        for(i = 1; i < n; i++){\n            t[i >> 3] = (cmp(A[i - 1], A[i]) ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n        }\n        t[n >> 3] = t[n >> 3] | mask[n & 7];\n\n        Lv[A[0]] = 0;\n        for(i = 1; i < n; i++){\n            Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n        }\n\n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n\n    char p[1000];\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n\n    A[n] = n;\n\n    while(q){\n        scanf(\"%s\", p);\n        std::string P = std::string(p);\n        left = 0, right = n, exist = false;\n        while(left < right){\n\n            if(n < P.size()){ exist = false; break; }\n\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n\n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1000000000 + 7;\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nstruct SuffixArray {\n    int n, k;\n    string text;\n    vector<int> sa;\n    vector<int> rank;\n    vector<int> lcp;\n\n    SuffixArray (const string &s)\n    : text(s), n(s.size()), sa(n + 1), rank(n + 1), lcp(n)\n    {}\n\n    bool comp(int i, int j) {\n        if (rank[i] != rank[j]) return rank[i] < rank[j];\n        int ri = i + k <= n ? rank[i + k] : -1;\n        int rj = j + k <= n ? rank[j + k] : -1;\n        return ri < rj;\n    }\n\n    void construct_sa() {\n        for (int i = 0; i <= n; i++) {\n            sa[i] = i;\n            rank[i] = i < n ? text[i] : -1;\n        }\n\n        for (k = 1; k <= n; k *= 2) {\n            sort(sa.begin(), sa.end(), [&](const int& i, const int& j) {return comp(i, j);});\n\n            vector<int> tmp(n + 1);\n            tmp[sa[0]] = 0;\n            for (int i = 1; i <= n; i++) {\n                tmp[sa[i]] = tmp[sa[i - 1]] + (comp(sa[i - 1], sa[i]) ? 1 : 0);\n            }\n\n            for (int i = 0; i <= n; i++) {\n                rank[i] = tmp[i];\n            }\n        }\n    }\n\n    void construct_lcp () {\n        int h = 0;\n        lcp[0] = 0;\n        for (int i = 0; i < n; i++) {\n            int j = sa[rank[i] - 1];\n            if (h > 0) h--;\n            for (; j + h < n && i + h < n; h++) {\n                if (text[j + h] != text[i + h]) break;\n            }\n            lcp[rank[i] - 1] = h;\n        }\n    }\n\n    int low_bd(const string &pt) {\n        int l = 0, r = n + 1;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val < 0) l = m;\n            else r = m;\n        }\n        return r;\n    }\n\n    int up_bd(const string &pt) {\n        int l = 1, r = n + 1;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val <= 0) l = m;\n            else r = m;\n        }\n        return r;\n    }\n\n    bool match(const string &pt) {\n        int l = 0, r = n;\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int val = text.compare(sa[m], pt.length(), pt);\n            if (val < 0) l = m;\n            else r = m;\n        }\n        return text.compare(sa[idx], pt.length(), pt) == 0 ? true : false;\n    }\n\n    int count(const string &pt) {\n        int l_idx = low_bd(pt);\n        if (l_idx == sa.size()) return 0;\n        if (text.compare(sa[l_idx], pt.length(), pt) != 0) return 0;\n        int r_idx = up_bd(pt);\n        return r_idx - l_idx;\n    }\n};\n\nstring t;\nint q;\nstring p[10000];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> t;\n    cin >> q;\n    rep(i, q) cin >> p[i];\n    SuffixArray suf(t);\n    suf.construct_sa();\n    rep(i, q) {\n        if (suf.match(p[i])) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define MAX 1000002\n\ntypedef unsigned char byte;\nbyte mask[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\n \nint *Lv;\nint n, k;\n \nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n \nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n \n    return L_i < L_j;\n}\n \nint main()\n{\n    int *A;\n    char c[MAX];\n    scanf(\"%s\", c);\n    std::string T = std::string(c);\n    n = T.size();\n\n\tA = new int[n + 1], Lv = new int [n + 1];\n\n    byte *t;\n    t = new byte [(n >> 3) + 1];\n    bool act;\n    int l, r;\n \n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n \n    int bkt[129];\n    for(i = 0; i < 129; i++){ bkt[i] = 0; }\n    for(i = 0; i < n; i++){ bkt[Lv[i]]++; }\n    int sum = 0;\n    for(i = 0; i < 129; i++){ sum += bkt[i]; bkt[i] = sum; }\n    for(i = 0; i < n; i++){ A[--bkt[Lv[i]]] = i; }\n \n    //std::sort(A, A + n, cmp_Lv);\n \n    for(i = 1; i < n; i++){\n        t[i >> 3] = (Lv[A[i]] != Lv[A[i - 1]] ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n    }\n    t[n >> 3] = t[n >> 3] | mask[n & 7];\n \n    Lv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n    }\n \n    k = 1;\n    while(1){\n        if(k > n) break;\n \n        act = true;\n        for(i = 1; i <= n; i++){\n            if(act){\n                if(!!(mask[i & 7] & t[i >> 3])){ continue; }\n                else{ l = i - 1; act = false; }\n            }else{\n                if(!!(mask[i & 7] & t[i >> 3])){\n                    r = i; std::sort(A + l, A + r, cmp); act = true; }\n                    else{ continue; }\n            }\n        }\n \n        for(i = 1; i < n; i++){\n            t[i >> 3] = (cmp(A[i - 1], A[i]) ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n        }\n        t[n >> 3] = t[n >> 3] | mask[n & 7];\n \n        Lv[A[0]] = 0;\n        for(i = 1; i < n; i++){\n            Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n        }\n \n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n \n    char p[1000];\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n \n    A[n] = n;\n \n    while(q){\n        scanf(\"%s\", p);\n        std::string P = std::string(p);\n        left = 0, right = n, exist = false;\n        while(left < right){\n \n            if(n < P.size()){ exist = false; break; }\n \n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n \n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst long long B=1000000000000000009LL;\nconst long long P=1000000000000000031LL;\n\nvector<long long> gen_hash(const string &s){\n\tvector<long long> hash(s.size());\n\tlong long c=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tc=(c*(__int128_t)B+s[i])%P;\n\t\thash[i]=c;\n\t}\n\treturn hash;\n}\nlong long pow_binary_mod(long long x,long long y,long long mod){\n\tlong long z=1;\n\tfor(;y;y>>=1){\n\t\tif((y&1)!=0)z=(__int128_t)z*x%mod;\n\t\tx=(__int128_t)x*x%mod;\n\t}\n\treturn z;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s;\n\tcin>>s;\n\tvector<long long> v=gen_hash(s);\n\n\tint T;\n\tfor(cin>>T;T--;){\n\t\tstring q;\n\t\tcin>>q;\n\t\tlong long hash=gen_hash(q)[q.size()-1];\n\t\tlong long Brev=pow_binary_mod(B,q.size(),P);\n\t\t//vector<long long> r;\n\t\tint i=q.size()-1;\n\t\tfor(;i<s.size();i++){\n\t\t\tif(v[i]==((i==q.size()-1?0:v[i-q.size()])*(__int128_t)Brev+hash)%P){\n\t\t\t\t//r.push_back(i-q.size()+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(i<s.size()){\n\t\t\t//for(int i=0;i<r.size();i++)printf(\"%d\\n\",r[i]);\n\t\t\tputs(\"1\");\n\t\t}else{\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <unordered_set>\nusing namespace std;\n\nstruct TrieNode {\n  int is_word = 0, depth = 0;\n  vector<int> word_indices;\n  TrieNode *suf = nullptr, *out = nullptr, *parent = nullptr;\n  char last = '\\0';\n  map<char, TrieNode *> adj;\n  TrieNode(int depth, TrieNode *parent) : depth(depth), parent(parent) {}\n  TrieNode() = default;\n};\n\nusing np = TrieNode *;\n\n// Adds edges for the given string to the given trie\n// i is the index of the string in the overall input\nvoid BuildTrie(np cur, string &s, int i) {\n  for (int j = 0; j < s.size(); ++j) {\n    if (!(cur->adj.count(s[j]))) {\n      cur->adj[s[j]] = new TrieNode(cur->depth + 1, cur);\n    }\n    cur = cur->adj[s[j]];\n    cur->last = s[j];\n  }\n  cur->is_word = 1;\n  cur->word_indices.push_back(i);\n}\n\nvoid AddEdges(np root) {\n  // BFS from root\n  queue<np> to_visit;\n  to_visit.push(root);\n  while (!to_visit.empty()) {\n    np cur = to_visit.front();\n    to_visit.pop();\n    if (cur->depth == 1) {\n      cur->suf = root;\n    } else if (cur->depth > 1) {\n      np sufcur = cur->parent->suf;\n      while (sufcur != root && !sufcur->adj.count(cur->last))\n        sufcur = sufcur->suf;\n      if (sufcur->adj.count(cur->last)) {\n        cur->suf = sufcur->adj[cur->last];\n      } else {\n        cur->suf = root;\n      }\n    }\n    np outcur = cur->suf;\n    while (outcur && !outcur->is_word)\n      outcur = outcur->suf;\n    cur->out = outcur;\n\n    for (auto &kv : cur->adj)\n      to_visit.push(kv.second);\n  }\n}\n\nint main() {\n  string T;\n  cin >> T;\n  int q;\n  cin >> q;\n  np root = new TrieNode;\n  string p;\n  for (int i = 0; cin >> p; ++i)\n    BuildTrie(root, p, i);\n  AddEdges(root);\n\n  np cur = root;\n  unordered_set<int> matched;\n  for (char c : T) {\n    while (cur != root && !cur->adj.count(c)) {\n      cur = cur->suf;\n    }\n    if (cur->adj.count(c))\n      cur = cur->adj[c];\n    if (cur->is_word)\n      matched.insert(cur->word_indices.begin(), cur->word_indices.end());\n    np outcur = cur->out;\n    while (outcur) {\n      matched.insert(outcur->word_indices.begin(), outcur->word_indices.end());\n      outcur = outcur->out;\n    }\n  }\n  for (int i = 0; i < q; ++i)\n    cout << matched.count(i) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    string T, P;\n    int Tlen, Plen, n;\n\n    cin >> T >> n;\n    Tlen = T.size();\n\n    while (n--) {\n        cin >> P;\n        Plen = P.size();\n        for (int i = 0; i <= Tlen - Plen; i++) {\n            if (T[i] == P[0]) {\n                if (P == T.substr(i, Plen)) {\n                    cout << \"1\\n\";\n                    break;\n                }\n            }\n            if (i == Tlen - Plen) {\n                cout << \"0\\n\";\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n\nusing namespace std;\n\nstring S, T; int Q, R, A; char STR[1005];\n\nint main()\n{\n\tcin >> S >> Q;\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%s\", STR);\n\n\t\tT = S.substr(0, strlen(STR));\n\n\t\tR = S.size() - strlen(STR);\n\n\t\tA = strlen(STR);\n\n\t\tfor (int j = 0; j <= R; j++)\n\t\t{\n\t\t\tif (j)\n\t\t\t{\n\t\t\t\tT.erase(T.begin());\n\n\t\t\t\tT += S[j + A];\n\t\t\t}\n\n\t\t\tif (strcmp(T.c_str(), STR) == 0)\n\t\t\t{\n\t\t\t\tprintf(\"1\\n\");\n\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"0\\n\");\n\n\tExit:;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <clocale>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(false); cin.tie(0);\n#define FOR(i, s, n) for(int i = (s), i##_len=(n); i < i##_len; ++i)\n#define FORS(i, s, n) for(int i = (s), i##_len=(n); i <= i##_len; ++i)\n#define VFOR(i, s, n) for(int i = (s); i < (n); ++i)\n#define VFORS(i, s, n) for(int i = (s); i <= (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPS(i, n) FORS(i, 0, n)\n#define VREP(i, n) VFOR(i, 0, n)\n#define VREPS(i, n) VFORS(i, 0, n)\n#define RFOR(i, s, n) for(int i = (s), i##_len=(n); i >= i##_len; --i)\n#define RFORS(i, s, n) for(int i = (s), i##_len=(n); i > i##_len; --i)\n#define RREP(i, n) RFOR(i, n, 0)\n#define RREPS(i, n) RFORS(i, n, 0)\n#define ALL(v) (v).begin(), (v).end()\n#define SORT(v) sort(ALL(v))\n#define RSORT(v) sort(ALL(v), greater<decltype(v[0])>())\n#define SZ(x) ((int)(x).size())\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing Pi_i = pair<int, int>;\nusing VB = vector<bool>;\nusing VC = vector<char>;\nusing VD = vector<double>;\nusing VI = vector<int>;\nusing VLL = vector<ll>;\nusing VS = vector<string>;\nusing VSH = vector<short>;\nusing VULL = vector<ull>;\n\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst int NIL = -1;\n\ntemplate<class T, class S>\nbool chmax(T &a, const S &b){\n    if(a < b){\n        a = b; return true;\n    }\n    return false;\n}\ntemplate<class T, class S>\nbool chmin(T &a, const S &b){\n    if(b < a){\n        a = b; return true;\n    }\n    return false;\n}\n\n\nclass suffixArray{\n    string field;\n    VI rank;\n    VI sa;\n    int k;\npublic:\n    suffixArray(string s)\n        : field(s), rank(s.length() + 1), sa(s.length() + 1){\n        construct_sa();\n    }\nprivate:\n    void construct_sa(){\n        int n = field.length();\n        REPS(i, n){\n            sa[i] = i;\n            rank[i] = (i<n ? field[i] : -1);\n        }\n        VI tmp(n + 1);\n        for(k = 1; k <= n; k *= 2){\n            auto comp_sa = [&](int i, int j){\n                if(this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n                int ri = (i+k<=SZ(field) ? this->rank[i+k] : -1);\n                int rj = (j+k<=SZ(field) ? this->rank[j+k] : -1);\n                return ri < rj;\n            };\n            sort(ALL(sa), comp_sa);\n\n            tmp[sa[0]] = 0;\n            FORS(i, 1, n){\n                tmp[sa[i]] = tmp[sa[i-1]] \n                           + (comp_sa(sa[i-1], sa[i]) ? 1 : 0);\n            }\n            REPS(i, n)\n                rank[i] = tmp[i];\n        }\n    }\npublic:\n    bool contain(string purpose){\n        int m = purpose.length();\n        int a = 0, b = field.length();\n        while(b-a > 1){\n            int c = (a+b) / 2;\n            if(field.compare(sa[c], m, purpose) < 0) a = c;\n            else b = c;\n        }\n        return !field.compare(sa[b], m, purpose);\n    }\n};\n\nint main(){\n    string T; cin >> T;\n    suffixArray SA(T);\n    int Q; cin >> Q;\n    REP(i, Q){\n        string P; cin >> P;\n        cout << (SA.contain(P) ? 1 : 0) << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S 2500005\n#define N 1005\nusing namespace std;\ntypedef pair<int,int> P;\nstruct d{\n  int a,b,c;\n  d(){}\n  d(int A,int B,int C){\n    a=A,b=B,c=C;\n  };\n  bool operator<(const d&r)const{\n    if(a!=r.a)return a<r.a;\n    return b<r.b;\n  }\n};\n\nint n,slen,tlen,r[S];\nchar s[S],t[N];\nd ran[S];\nP a[S];\n\nvoid init(){\n  for(int i=0;i<slen;i++)r[i]=s[i];\n  int x=1;\n  r[slen]=0;\n  while(x<slen){\n    for(int i=0;i<slen;i++){\n      int o=i+x;\n      if(o>slen)o=slen;\n      ran[i]=d(r[i],r[o],i);\n    }\n    sort(ran,ran+slen);\n    int cnt=1;\n    for(int i=0;i<slen;i++){\n      r[ran[i].c]=cnt;\n      if(ran[i].a==ran[i+1].a&&ran[i].b==ran[i+1].b)\n\tcontinue;\n      cnt++;\n    }\n    //    if(x>slen)break;\n    x*=2;\n  }\n  for(int i=0;i<slen;i++)a[i]=P(r[i],i);\n  sort(a,a+slen);\n}\n\nbool bynary_search(){\n  int L=0,R=slen;\n  while(L<R){\n    int M=(L+R)/2;\n    if(strncmp(s+a[M].second,t,tlen)<0)L=M+1;\n    else R=M;\n  }\n  if(!strncmp(s+a[L].second,t,tlen))return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s%d\",s,&n);\n  slen=strlen(s);\n  init();  \n  while(n--){\n    scanf(\"%s\",t);\n    tlen=strlen(t);\n    if(bynary_search())printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n\nint main() {\n  std::size_t constexpr prefix_size_max = 10;\n  std::size_t prefix_size = prefix_size_max;\n  std::size_t constexpr index_size_max = 800000; // chosen arbitrarily from the memory limit\n  std::string text;\n  std::getline(std::cin, text);\n  std::map<std::vector<char>, std::vector<size_t>> index;\n  for (std::size_t j = 1; j <= prefix_size_max; ++j) {\n    if (index.size() >= index_size_max) {\n      prefix_size = j - 1;\n      break;\n    }\n    for (std::size_t i = 0; i < text.size(); ++i) {\n      index[std::vector<char>(text.begin() + i, text.begin() + i + j)].push_back(i);\n    }\n  }\n  int numpats;\n  {\n    std::string s;\n    std::getline(std::cin, s);\n    numpats = std::stoi(s);\n  }\n  std::map<std::string, bool> cache;\n  for (int i = 0; i < numpats; ++i) {\n    std::string pat;\n    std::getline(std::cin, pat);\n    bool const found = [&] {\n      auto itcache = cache.find(pat);\n      if (itcache != cache.end())\n        return itcache->second;\n      else {\n        auto const& is = index[std::vector<char>(pat.begin(), pat.begin() + std::min(prefix_size, pat.size()))];\n        auto result = std::any_of(is.begin(), is.end(), [&text, &pat](int i) {\n          auto it = text.begin() + i;\n          if (text.end() - it < pat.size())\n            return false;\n          else\n            return std::equal(it, it + pat.size(), pat.begin(), pat.end());\n        });\n        cache.emplace(pat, result);\n        return result;\n      }\n    }();\n    if (found)\n      std::cout << \"1\\n\";\n    else\n      std::cout << \"0\\n\";\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n,0);\n    lcp.resize(n,0);\n    build_sa();\n    //build_lcp();\n    //build_rmq();\n  }\n  void build_sa(){\n    vector<int> c(n,0),ord(n,0);\n    for(int i=0;i<n;i++) ord[i]=n-1-i;\n    sort(ord.begin(),ord.end(),[&](int a,int b){return S[a]<S[b];});\n    \n    for(int i=0;i<n;i++){\n      sa[i]=ord[i];\n      c[i]=S[i];\n    }\n    \n    for(int len=1;len<n;len*=2){\n      vector<int> r=c;\n      for(int i=0;i<n;i++){\n\t c[sa[i]] = i > 0 && r[sa[i - 1]] == r[sa[i]] && sa[i - 1] + len < n && r[sa[i - 1] + len / 2] == r[sa[i] + len / 2] ? c[sa[i - 1]] : i;\n      }\n      vector<int> cnt(n);\n      for(int i=0;i<n;i++) cnt[i]=i;\n      vector<int> s=sa;\n      for(int i=0;i<n;i++){\n\tint s1=s[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n    }\n  }\n  bool contains(string T){\n    int a=0,b=S.length()+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==(int)S.length()+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n);\n    for(int i=0;i<n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define MAX 10002\ntypedef unsigned char byte;\nbyte mask[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\n\nint Lv[MAX];\nint n, k;\n\nbool cmp_Lv(const int i, const int j){ return Lv[i] < Lv[j]; }\n\nbool cmp(const int i, const int j){\n    if(Lv[i] != Lv[j]){ return Lv[i] < Lv[j]; }\n    int L_i = (i + k >= n ? -1 : Lv[i + k]);\n    int L_j = (j + k >= n ? -1 : Lv[j + k]);\n\n    return L_i < L_j;\n}\n\nint main()\n{\n    int A[MAX];\n    char c[MAX];\n    scanf(\"%s\", c);\n    std::string T = std::string(c);\n    n = T.size();\n    byte *t;\n    t = new byte [(n >> 3) + 1];\n\tbool act;\n\tint l, r;\n\n    int i;\n    for(i = 0; i < n; i++){ A[i] = i; }\n    for(i = 0; i < n; i++){ Lv[i] = T[i]; }\n\t\n\tbyte bkt[129];\n\tfor(i = 0; i < 129; i++){ bkt[i] = 0; }\n\tfor(i = 0; i < n; i++){ bkt[Lv[i]]++; }\n\tint sum = 0;\n\tfor(i = 0; i < 129; i++){ sum += bkt[i]; bkt[i] = sum; }\n\tfor(i = 0; i < n; i++){ A[--bkt[Lv[i]]] = i; }\n\n    //std::sort(A, A + n, cmp_Lv);\n\n\t\n\n\n\n    for(i = 1; i < n; i++){\n        t[i >> 3] = (Lv[A[i]] != Lv[A[i - 1]] ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n    }\n    t[n >> 3] = t[n >> 3] | mask[n & 7];\n\n    Lv[A[0]] = 0;\n    for(i = 1; i < n; i++){\n        Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n    }\n\n    k = 1;\n    while(1){\n        if(k > n) break;\n\n        act = true;\n        for(i = 1; i <= n; i++){\n            if(act){\n                if(!!(mask[i & 7] & t[i >> 3])){ continue; }\n                else{ l = i - 1; act = false; }\n            }else{\n                if(!!(mask[i & 7] & t[i >> 3])){\n                    r = i; std::sort(A + l, A + r, cmp); act = true; }\n                    else{ continue; }\n            }\n        }\n\n        for(i = 1; i < n; i++){\n            t[i >> 3] = (cmp(A[i - 1], A[i]) ? t[i >> 3] | mask[i & 7] : t[i >> 3] & ~mask[i & 7]);\n        }\n        t[n >> 3] = t[n >> 3] | mask[n & 7];\n\n        Lv[A[0]] = 0;\n        for(i = 1; i < n; i++){\n            Lv[A[i]] = Lv[A[i - 1]] + !!(mask[i & 7] & t[i >> 3]);\n        }\n\n        if(Lv[A[n - 1]] == n - 1) break;\n        k <<= 1;\n    };\n\n    char p[1000];\n    int q, left, right, mid, crit;\n    bool exist;\n    scanf(\"%d\", &q);\n\n    A[n] = n;\n\n    while(q){\n        scanf(\"%s\", p);\n        std::string P = std::string(p);\n        left = 0, right = n, exist = false;\n        while(left < right){\n\n            if(n < P.size()){ exist = false; break; }\n\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], P.size(), P);\n\n            if(crit > 0){ right = mid; }\n            else if(crit < 0){ left = mid + 1; }\n            else{ exist = true; break; }\n        };\n        if(T.compare(A[right], P.size(), P) == 0) exist = true;\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vl = vector<ll>;\nusing vll = vector<vector<ll>>;\nusing pii = pair<int,int>;\n#define FOR(i,a,b) for(ll i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(obj) (obj).begin(), (obj).end()\nconst double PI = acos(-1);\nconst double EPS = 1e-10;\nconst ll MOD = 1e9+7;\nvoid cioacc(){//accelerate cin/cout\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\nvector<string> make_suffix_array(const string &s){\n  vector<string> res;\n  REP(i,(ll)s.size()+1){\n    string tmp(s.begin()+i,s.end());\n    res.push_back(tmp);\n  }\n  sort(ALL(res));\n  return res;\n}\nint main(){//naive suffix array\n  string t;\n  int n;\n  cin >> t >> n;\n  auto suf = make_suffix_array(t);\n  REP(i,n){\n    string q;\n    cin >> q;\n    size_t sz = q.size();\n    auto itr = lower_bound(ALL(suf),q);\n    bool flag = false;\n    do{\n      if(itr==suf.end()) break;\n      string cut(itr -> begin(),(itr->begin())+min(sz,itr->size()));\n      if(cut==q){\n        cout << 1 << endl;\n        flag = true;\n        break;\n      } else if(cut > q){\n        break;\n      }\n      ++itr;\n    }while(true);\n    if(!flag) cout << 0 << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstring S; string U;\nvector<string>T; int N;\nint main() {\n\tcin >> S >> N;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tint L = S.size() - i;\n\t\tif (L > 250)L = 250;\n\t\tT.push_back(S.substr(i, L));\n\t}\n\tsort(T.begin(), T.end());\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> U; if (U.size() >= 250) { U = U.substr(0, 250); }\n\t\tint pos = lower_bound(T.begin(), T.end(), U) - T.begin();\n\t\tstring V;\n\t\tif (pos < T.size() && U.size() <= T[pos].size()) { V = T[pos].substr(0, U.size()); }\n\t\tif (U == V) { cout << \"1\" << endl; }\n\t\telse { cout << \"0\" << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> pp;\ntypedef pair<pp,int> P;\nchar t[2500001],p[1001];\nint a[2500001],d[1000001],i;\nP b[1000001];\n\nvoid mk(){\n  for(i=0;t[i]!=0;i++)\n    b[i].f.f=t[i],b[i].s=i;\n  b[i].f.f=0,b[i].s=i;\n\n  for(int j=1;j<=i;j*=2){\n    sort(b,b+i+1);\n    a[b[0].s]=0;\n    for(int k=1,l=0;k<=i;k++)\n      if(b[k-1].f==b[k].f)a[b[k].s]=l;\n      else a[b[k].s]=++l;\n    for(int k=0,o=b[0].s;k<=i;k++,o=b[k].s)\n      b[k]=P(pp(a[o],a[o+j]),o);\n  }\n  sort(b,b+i+1);\n  a[b[0].s]=0;\n  for(int k=1,l=0;k<=i;k++)\n    if(b[k-1].f==b[k].f)a[b[k].s]=l;\n    else a[b[k].s]=++l;\n  for(int j=0;j<=i;j++)d[a[j]]=j;\n}\n\nvoid bs(int n){\n  int l=0,r=i,m;\n  while(l<r){\n    m=(l+r)/2;\n    if(strncmp(t+d[m],p,n)<0)l=m+1;\n    else r=m;\n  }\n  if(strncmp(t+d[l],p,n) ==0 )printf(\"1\\n\");\n  else printf(\"0\\n\");\n}\n\n\nint main(){\n  int q;\n  scanf(\"%s\",t);\n  mk();\n  cin>>q;\n  while(q--&&scanf(\"%s\",p))bs(strlen(p));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  string T;\n  int Q;\n  cin>>T;\n  cin>>Q;\n  int flag[Q]={0};\n  string P[Q];\n  for(int i=0;i<Q;i++){\n    cin>>P[i];\n    for(int j=0;j<=T.size()-P[i].size();j++){\n      if(T.size()<P[i].size())\n\tbreak;\n      if(P[i]==T.substr(j,P[i].size())){\n\tflag[i]=1;\n\tbreak;\n      }\n    }\n  }\n  for(int i=0;i<Q;i++)\n    cout<<flag[i]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\nstring S, T; int Q, R, A; char STR[1005];\n\nint main()\n{\n\tcin >> S >> Q;\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%s\", STR);\n\n\t\tT = S.substr(0, strlen(STR));\n\n\t\tR = S.size() - strlen(STR);\n\n\t\tA = strlen(STR);\n\n\t\tfor (int j = 0; j <= R; j++)\n\t\t{\n\t\t\tif (j)\n\t\t\t{\n\t\t\t\tT.erase(T.begin());\n\n\t\t\t\tT += S[j + A];\n\t\t\t}\n\n\t\t\tif (strcmp(T.c_str(), STR) == 0)\n\t\t\t{\n\t\t\t\tprintf(\"1\\n\");\n\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"0\\n\");\n\n\tExit:;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <unordered_set>\nusing namespace std;\n\nstruct TrieNode {\n  int is_word = 0, depth = 0;\n  vector<int> word_indices;\n  TrieNode *suf = nullptr, *out = nullptr, *parent = nullptr;\n  char last = '\\0';\n  map<char, TrieNode *> adj;\n  TrieNode(int depth, TrieNode *parent) : depth(depth), parent(parent) {}\n  TrieNode() = default;\n\n  string represented_word; // debug\n};\n\nusing np = TrieNode *;\n\n// Adds edges for the given string to the given trie\n// i is the index of the string in the overall input\nvoid BuildTrie(np cur, string &s, int i) {\n  for (int j = 0; j < s.size(); ++j) {\n    if (!(cur->adj.count(s[j]))) {\n      cur->adj[s[j]] = new TrieNode(cur->depth + 1, cur);\n    }\n    cur = cur->adj[s[j]];\n    cur->last = s[j];\n    cur->represented_word = s.substr(0, j + 1);\n  }\n  cur->is_word = 1;\n  cur->word_indices.push_back(i);\n}\n\nvoid AddEdges(np root) {\n  // BFS from root\n  queue<np> to_visit;\n  to_visit.push(root);\n  while (!to_visit.empty()) {\n    np cur = to_visit.front();\n    to_visit.pop();\n    if (cur->depth == 1) {\n      cur->suf = root;\n    } else if (cur->depth > 1) {\n      np sufcur = cur->parent->suf;\n      while (sufcur != root && !sufcur->adj.count(cur->last))\n        sufcur = sufcur->suf;\n      if (sufcur->adj.count(cur->last)) {\n        cur->suf = sufcur->adj[cur->last];\n      } else {\n        cur->suf = root;\n      }\n    }\n    np outcur = cur->suf;\n    while (outcur && !outcur->is_word)\n      outcur = outcur->suf;\n    cur->out = outcur;\n\n    for (auto &kv : cur->adj)\n      to_visit.push(kv.second);\n  }\n}\n\nint main() {\n  string T;\n  cin >> T;\n  int q;\n  cin >> q;\n  np root = new TrieNode;\n  string p;\n  for (int i = 0; cin >> p; ++i)\n    BuildTrie(root, p, i);\n  AddEdges(root);\n\n  np cur = root;\n  unordered_set<int> matched;\n  for (char c : T) {\n    while (cur != root && !cur->adj.count(c)) {\n      cur = cur->suf;\n    }\n    if (cur->adj.count(c))\n      cur = cur->adj[c];\n    if (cur->is_word)\n      matched.insert(cur->word_indices.begin(), cur->word_indices.end());\n    np outcur = cur->out;\n    while (outcur) {\n      matched.insert(outcur->word_indices.begin(), outcur->word_indices.end());\n      outcur = outcur->out;\n    }\n  }\n  for (int i = 0; i < q; ++i)\n    cout << matched.count(i) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1<<20\nusing namespace std;\n\nstruct P{\n  int a,b,idx;\n  P(){a=b=idx=0;}\n  P(int a,int b,int idx):a(a),b(b),idx(idx){};\n  bool operator < (const P &A) const{\n    if(a!=A.a) return a>A.a;\n    return b>A.b;\n  }\n};\n\nchar ch[N];\nP r[N];\n\n\nvector<int> Sort(){\n  int n=strlen(ch);\n  vector <int> R(n+1),res(n+1);\n  \n  for(int i=0;i<=n;i++) R[i]=ch[i];\n  \n  for(int i=1;i<=n;i*=2){\n    for(int j=0;j<=n;j++)r[j]=P(R[j],(j+i<=n)? R[j+i]:0,j);\n    sort(r,r+n+1);\n    R[r[0].idx]=0;\n    for(int j=1,C=0;j<=n;j++){\n      if(r[j-1]<r[j]) C++;\n      R[r[j].idx]=C;\n    }\n  }\n  for(int i=0;i<=n;i++) res[R[i]]=i;\n  return res;\n}\n\nint check(vector <int> &a,char *x){\n  int L=0,M,R=strlen(ch)+1;\n  int m=strlen(x);\n\n  while(L<R){\n    M=(L+R)/2;\n    if(strncmp(ch+a[M],x,m)<=0)R=M;\n    else L=M+1;\n  }\n  return strncmp(ch+a[L],x,m)==0;\n}\n\nint main(){\n  scanf(\"%s\",ch);\n\n  int q;\n  cin>>q;\n  vector <int> Rank=Sort();\n  char a[1001];\n\n  while(q--){\n    scanf(\"%s\",a);\n    printf(\"%d\\n\",check(Rank,a));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct SuffixArray {\n    string s;\n    size_t n;\n    vector<size_t> sarray, rank;\n    SuffixArray(string s): s(s), n(s.length()) {\n        sarray.assign(n+1, 0);\n        rank.assign(n+1, 0);\n\n        for (size_t i=0; i<=n; ++i) {\n            sarray[i] = i;\n            rank[i] = i<n? s[i]:-1;\n        }\n\n        vector<size_t> tmp(n+1);\n        for (size_t k=1; k<=n; k<<=1) {\n            auto comp=[&, k](size_t i, size_t j)->bool {\n                if (rank[i] != rank[j])\n                    return rank[i] < rank[j];\n\n                int ri=i+k<=n? rank[i+k]:-1;\n                int rj=j+k<=n? rank[j+k]:-1;\n                return ri < rj;\n            };\n            sort(sarray.begin(), sarray.end(), comp);\n                \n            for (size_t i=1; i<=n; ++i)\n                tmp[sarray[i]] = tmp[sarray[i-1]]+comp(sarray[i-1], sarray[i]);\n\n            for (size_t i=0; i<=n; ++i)\n                rank[i] = tmp[i];\n        }\n    }\n    bool is_substr(string t) {\n        size_t lb=-1, ub=s.length();\n        while (ub-lb > 1) {\n            size_t mid=(lb+ub)/2;\n            (s.compare(sarray[mid], t.length(), t)<0? lb:ub) = mid;\n        }\n        return !s.compare(sarray[ub], t.length(), t);\n    }\n};\n\nint main() {\n    char buf[1<<20];\n    scanf(\"%s\", buf);\n    string T(buf);\n\n    SuffixArray sa(T);\n\n    size_t Q;\n    scanf(\"%zu\", &Q);\n\n    for (size_t i=0; i<Q; ++i) {\n        scanf(\"%s\", buf);\n        string P(buf);\n\n        printf(\"%d\\n\", sa.is_substr(P));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\nconstexpr long long INF = 1LL << 60;\nconstexpr long long MOD = 1000000007;\ndouble PI = acos(-1.0);\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n#define rep1(i, n) for (ll i = 1; i <= (n); ++i)\n#define rrep(i, n) for (ll i = (n - 1); i >= 0; --i)\n#define perm(c) sort(ALL(c));for(bool c##p=1;c##p;c##p=next_permutation(ALL(c)))\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define pb push_back\n#define to_s to_string\n#define len(v) (ll)v.size()\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define print(x) cout << (x) << '\\n'\n#define drop(x) cout << (x) << '\\n', exit(0)\n#define debug(x) cout << #x << \": \" << (x) << '\\n'\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> tpl;\ntypedef vector<ll> vec;\ntypedef vector<vector<ll>> vec2;\ntypedef vector<vector<vector<ll>>> vec3;\ntemplate<class S, class T> inline bool chmax(S &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class S, class T> inline bool chmin(S &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ninline ll msb(ll v) { return 1 << (31 - __builtin_clzll(v)); }\ninline ll devc(ll x, ll y) { return (x + y - 1) / y; }\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a * (b / gcd(a, b)); }\n \nstruct IoSetup {\n    IoSetup() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(10);\n        cerr << fixed << setprecision(10);\n    }\n} iosetup;\n \ntemplate< typename T1, typename T2 >\nostream &operator << (ostream &os, const pair< T1, T2 > &p) {\n    os << p.first << \" \" << p.second;\n    return os;\n}\n \ntemplate< typename T1, typename T2 >\nistream &operator >> (istream &is, pair< T1, T2 > &p) {\n    is >> p.first >> p.second;\n    return is;\n}\n \ntemplate< typename T1, typename T2, typename T3 >\nostream &operator << (ostream &os, const tuple< T1, T2, T3 > &t) {\n    os << get<0>(t) << \" \" << get<1>(t) << \" \" << get<2>(t);\n    return os;\n}\n \ntemplate< typename T1, typename T2, typename T3 >\nistream &operator >> (istream &is, tuple< T1, T2, T3 > &t) {\n    is >> get<0>(t) >> get<1>(t) >> get<2>(t);\n    return is;\n}\n \ntemplate< typename T >\nostream &operator << (ostream &os, const vector< T > &v){\n    for (int i = 0; i < (int)v.size(); ++i) {\n        os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n    }\n    return os;\n}\n \ntemplate< typename T >\nistream &operator >>  (istream &is, vector< T > &v){\n    for(T &in : v) is >> in;\n    return is;\n}\n\ntemplate< typename T >\nostream &operator << (ostream &os, const set< T > &st){\n    int ct = 0;\n    for(auto& s : st) cout << s << (++ct != st.size() ? \" \" : \"\");\n    return os;\n}\n\ntemplate <typename T>\nconstexpr set<T> &operator|= (set<T> &st1, const set<T> &st2) { \n    for(auto& s : st2) st1.insert(s);\n    return st1; \n}\n\ntemplate <typename T>\nconstexpr set<T> &operator-= (set<T> &st1, const set<T> &st2) {\n    for(auto& s : st2) if(st1.count(s)) st1.erase(s);\n    return st1;\n}\n\ntemplate <typename T>\nconstexpr set<T> &operator&= (set<T> &st1, const set<T> &st2) {\n    auto itr = st1.begin();\n    while(itr != st1.end()){\n        if(!st2.count(*itr)) itr = st1.erase(itr);\n        else ++itr;\n    }\n    return st1;\n}\n\ntemplate <typename T>\nconstexpr set<T> operator| (const set<T> &st1, const set<T> &st2) {\n    set<T> res = st1;\n    res |= st2;\n    return res;\n}\n\ntemplate <typename T>\nconstexpr set<T> operator- (const set<T> &st1, const set<T> &st2) {\n    set<T> res = st1;\n    res -= st2;\n    return res;\n}\n\ntemplate <typename T>\nconstexpr set<T> operator& (const set<T> &st1, const set<T> &st2) {\n    set<T> res = st1;\n    res &= st2;\n    return res;\n}\n\n/*---------------------------------    Tools    ------------------------------------------*/\ntemplate< typename T >\nvector<T> cumsum(const vector<T> &X){\n    vector<T> res(X.size() + 1, 0);\n    for(int i = 0; i < X.size(); ++i) res[i + 1] += res[i] + X[i];\n    return res;\n}\n \ntemplate< typename S, typename T, typename F>\npair<T, T> bisearch(S left, T right, F f) {\n    while(abs(right - left) > 1){\n        T mid = (right + left) / 2;\n        if(f(mid)) right = mid;\n        else left = mid;\n    }\n    return {left, right};\n}\n \ntemplate< typename S, typename T, typename F>\ndouble trisearch(S left, T right, F f, int maxLoop = 90){\n    double low = left, high = right;\n    while(maxLoop--){\n        double mid_left = high / 3 + low * 2 / 3;\n        double mid_right = high * 2 / 3 + low / 3;\n        if(f(mid_left) >= f(mid_right)) low = mid_left;\n        else high = mid_right;\n    }\n    return (low + high) * 0.5;\n}\n\ntemplate< typename F >\nll ternarySearch(ll L, ll R, F f) { //[L, R)\n    ll lo = L - 1, hi = R - 1;\n    while (lo + 1 != hi) {\n        ll mi = (lo + hi) / 2;\n        if (f(mi) <= f(mi + 1)) hi = mi;\n        else lo = mi;\n    }\n    return hi;\n}\n\n//VERIFIED : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\nstruct SuffixArray {\n    int N, k;\n    vector<int> rank;\n    vector<int> sa;\n    vector<int> tmp;\n    string S;\n\n    SuffixArray(const string& S) : S(S), N(S.size()), rank(S.size() + 1), sa(S.size() + 1), tmp(S.size() + 1) {\n        build();\n    }\n\n    int operator[](int i) const{\n        return sa[i];\n    }\n\n    int size() const{\n        return S.size();\n    }\n\n    bool compare(const string &T, int si = 0, int ti = 0){\n        int sn = (int)S.size(), tn = (int)T.size();\n        while(si < sn && ti < tn){ \n            if (S[si] < T[ti]) return true;\n            if (S[si] > T[ti]) return false;\n            ++si, ++ti;\n        }\n        return si >= sn && ti < tn;\n    }\n\n    int lower_bound(const string &T){\n        int low = -1, high = (int)sa.size();\n        while(high - low > 1){ \n            int mid = (low + high) / 2;\n            if(compare(T, sa[mid])) low = mid;\n            else high = mid;\n        }\n        return high;\n    }\n\n    //文字列Tを含む接辞辞のindexの半開区間\n    pair<int, int> lower_upper_bound(string &T){\n        int idx = lower_bound(T);\n        int low = idx - 1, high = (int)sa.size();\n        T.back()++;\n        while(high - low > 1){ \n            int mid = (low + high) / 2;\n            if (compare(T, sa[mid])) low = mid;\n            else high = mid;\n        }\n        T.back()--;\n        return { idx, high };\n    }\n\n    void build(){\n        auto compare_sa = [&](int i, int j) {\n            if (rank[i] != rank[j]) return rank[i] < rank[j];\n            else {\n                int ri = i + k <= N ? rank[i + k] : -1;\n                int rj = j + k <= N ? rank[j + k] : -1;\n                return ri < rj;\n            };\n        };\n\n\n        for (int i = 0; i <= N; ++i) {\n            sa[i] = i;\n            rank[i] = i < N ? S[i] : -1;\n        }\n\n        for (k = 1; k <= N; k *= 2) {\n            sort(ALL(sa), compare_sa);\n\n            tmp[sa[0]] = 0;\n            for (int i = 1; i <= N; ++i) {\n                tmp[sa[i]] = tmp[sa[i - 1]] + (compare_sa(sa[i - 1], sa[i]) ? 1 : 0);\n            }\n            for (int i = 0; i <= N; ++i) {\n                rank[i] = tmp[i];\n            }\n        }\n    }\n};\n\n/*------------------------------- Main Code Here -----------------------------------------*/\n \nint main()\n{\n    string S;\n    cin >> S;\n    SuffixArray SA(S);\n\n    ll Q;\n    cin >> Q;\n    while(Q--){\n        string X;\n        cin >> X;\n        auto res = SA.lower_upper_bound(X);\n        print((res.first != res.second));        \n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//??\\?°???????????????????\n//sa[]?????\\?°?????????´???\n#include<iostream>\n#include<string>\n#include<algorithm>\n\n#define MAX_N 100005\n\nusing namespace std;\n\n\n//?????????+??????????????????\nint n,k;\nint rank[MAX_N + 1];\nint tmp[MAX_N + 1];\n\n\nbool compare_sa(int i, int j)\n{\n\tif(rank[i] != rank[j]) \n\t{\n\t\treturn rank[i] < rank[j];\n\t}\n\telse\n\t{\n\tint ri = i + k <= n ? rank[i + k] : -1;\n\tint rj = j + k <= n ? rank[j + k] : -1;\n\treturn ri < rj;\n\t}\n}\n\n//?????????s?????\\?°??????????????§????\nvoid construct_sa(string s,int* sa)\n{\n\tn = s.length();\n\t\n\t//???????????????????????????????????????????????§??????\n\tfor(int i = 0; i <= n;i++)\n\t{\n\t\tsa[i] = i;\n\t\trank[i] = i < n ? s[i] : -1;\n\t}\n\t\n\t//k????????????????????????????????????????????¨???????????????2k????????§???????????????\n\tfor(k = 1;k <= n ; k *= 2)\n\t{\n\t\tsort(sa,sa + n + 1,compare_sa);\n\t\t\n\t\t//?????£??????tmp?????\\????????????rank????§????\n\t\ttmp[sa[0]] = 0;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\ttmp[sa[i]] = tmp[sa[i -1]] + (compare_sa(sa[i - 1],sa[i]) ? 1 : 0);\n\t\t}\n\t\tfor(int i = 0;i <= n;i++)\n\t\t{\n\t\t\trank[i] = tmp[i];\n\t\t}\n\t}\n}\n\nbool contain(string s,int* sa, string t)\n{\n\tint a = 0,b = s.length();\n\twhile(b - a > 1)\n\t{\n\t\tint c = (a + b) / 2;\n\t\t\n\t\tif(s.compare(sa[c],t.length(),t) < 0) a = c;\n\t\telse b = c;\n\t}\n\t\n\treturn (s.compare(sa[b], t.length(),t) == 0);\n\t\n}\n\n\nint main()\n{\n\tstring S;\n\tint N,sa[MAX_N] = {};\n\t\n\t\n\tcin >> S; \n\tcin >> N;\n\t\n\tconstruct_sa(S,sa);\n\t\n\tfor(int i = 0 ;i < N;i++)\n\t{\n\t\tstring T;\n\t\tcin >> T;\n\t\tif(contain(S,sa,T)) cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//??\\?°???????????????????\n//sa[]?????\\?°?????????´???\n#include<iostream>\n#include<string>\n#include<algorithm>\n\n#define MAX_N 10000000\n\nusing namespace std;\n\n\n//?????????+??????????????????\nint n,k;\nint rank[MAX_N + 1];\nint tmp[MAX_N + 1];\n\n\nbool compare_sa(int i, int j)\n{\n\tif(rank[i] != rank[j]) \n\t{\n\t\treturn rank[i] < rank[j];\n\t}\n\telse\n\t{\n\tint ri = i + k <= n ? rank[i + k] : -1;\n\tint rj = j + k <= n ? rank[j + k] : -1;\n\treturn ri < rj;\n\t}\n}\n\n//?????????s?????\\?°??????????????§????\nvoid construct_sa(string s,int* sa)\n{\n\tn = s.length();\n\t\n\t//???????????????????????????????????????????????§??????\n\tfor(int i = 0; i <= n;i++)\n\t{\n\t\tsa[i] = i;\n\t\trank[i] = i < n ? s[i] : -1;\n\t}\n\t\n\t//k????????????????????????????????????????????¨???????????????2k????????§???????????????\n\tfor(k = 1;k <= n ; k *= 2)\n\t{\n\t\tsort(sa,sa + n + 1,compare_sa);\n\t\t\n\t\t//?????£??????tmp?????\\????????????rank????§????\n\t\ttmp[sa[0]] = 0;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\ttmp[sa[i]] = tmp[sa[i -1]] + (compare_sa(sa[i - 1],sa[i]) ? 1 : 0);\n\t\t}\n\t\tfor(int i = 0;i <= n;i++)\n\t\t{\n\t\t\trank[i] = tmp[i];\n\t\t}\n\t}\n}\n\nbool contain(string s,int* sa, string t)\n{\n\tint a = 0,b = s.length();\n\twhile(b - a > 1)\n\t{\n\t\tint c = (a + b) / 2;\n\t\t\n\t\tif(s.compare(sa[c],t.length(),t) < 0) a = c;\n\t\telse b = c;\n\t}\n\t\n\treturn (s.compare(sa[b], t.length(),t) == 0);\n\t\n}\n\n\nint main()\n{\n\tstring S;\n\tint N,*sa;\n\t\n\t\n\tcin >> S; \n\tcin >> N;\n\t\n\tconstruct_sa(S,sa);\n\t\n\tfor(int i = 0 ;i < N;i++)\n\t{\n\t\tstring T;\n\t\tcin >> T;\n\t\tif(contain(S,sa,T)) cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define INF 1<<30\n#define mp make_pair\n#define pb push_back\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<pair<int, int> > vp;\ntypedef map<int,int> mpii;\n\ntypedef long long ll;\n\n#define join(a,b) a.insert(a.end(),b.begin(),b.end())\ntypedef vector< pair<string ,pair<int,int> > > vpsii;\n\nconst int MAX_ALP = 26 + 26 + 10;\nconst int MAX_SIZE = 10000000 + 7;\n\nstruct Node{\n    vi go; //next path\n    char c; //state\n    int f; //failure path\n    bool b; //match;\n    vector<string> text; //state string\n    Node(){\n        c = ' ';\n        f = -1;\n        b = false;\n        go.resize(MAX_ALP,-1);\n    }\n};\n\nvector<Node> G;\nint sz = 1;\n\nint idx(char c){\n    // abc...xyzABC...XYZ012...789\n    if('a' <= c && c <= 'z') return c - 'a';\n    else if('A' <= c && c <= 'Z') return c - 'A' + 26;\n    else if('0' <= c && c <= '9') return c - '0' + 36;\n    else return -1;\n}\n\nvoid make_trie(vector<string> W){\n    int ws = W.size();\n    int now = 0;\n    int sz = 1;\n    rep(i,ws){\n        now = 0;\n        string s = W[i];\n        rep(k,s.length()){\n            if(G[now].go[idx(s[k])] == -1){\n                Node node;\n                node.c = s[k];\n                G.pb(node);\n                G[now].go[idx(s[k])] = sz;\n                now = sz++;\n            }\n            else{\n                now = G[now].go[idx(s[k])];\n            }\n            if(k+1==s.length()){\n                G[now].text.pb(s);\n                G[now].b = true;\n            }\n        }\n    }\n}\n\nint back_failure(int t,char c){\n    while(G[t].go[c]==-1){\n        t = G[t].f;\n    }\n    return G[t].go[c];\n}\n\nvoid make_failure(){\n    queue<int> que;\n    //root\n    rep(i,MAX_ALP){\n        int nx = G[0].go[i];\n        if(nx!=-1){\n            G[nx].f = 0;\n            que.push(nx);\n        }\n        else{\n            G[0].go[i] = 0;\n        }\n    }\n    //other\n    while(!que.empty()){\n        int now = que.front();\n        que.pop();\n        rep(i,MAX_ALP){\n            if(G[now].go[i]!=-1){\n                que.push(G[now].go[i]);\n                int p = back_failure(G[now].f,i);\n                int s = G[now].go[i];\n                G[s].f = p;\n                if(G[p].b){\n                    G[s].b = true;\n                    join(G[s].text,G[p].text);\n                }\n            }\n        }\n    }\n}\n\nvpsii match(string st){\n    vpsii ret;\n    int now = 0;\n    rep(i,st.length()){\n        int id = idx(st[i]);\n        while(G[now].go[id]==-1){\n            now = G[now].f;\n        }\n        now = G[now].go[id];\n        rep(k,G[now].text.size()){\n            string s = G[now].text[k];\n            ret.pb(mp(s,mp((i+1)-s.length(),i)));\n        }\n    }\n    return ret;\n}\n\nint main(){\n    string text; cin>>text;\n    int n; cin>>n;\n    Node root;\n    root.c = '*';\n    root.f = 0;\n    G.pb(root);\n    vector<string> words(n);\n    rep(i,n) cin>>words[i];\n    make_trie(words);\n    make_failure();\n    vpsii ans = match(text);\n    set<string> s;\n    rep(i,ans.size()) s.insert(ans[i].first);\n    rep(i,words.size()){\n        if(s.find(words[i]) != s.end()) cout<<1<<endl;\n        else cout<<0<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n\tstring T, P;\n\tlong Q;\n\tcin >> T >> Q;\n\tfor (long i = 0; i < Q; i++){\n\t\tcin >> P;\n\t\tlong flag = 0;\n\t\tfor (long j = 0; j < T.size() - P.size() + 1; j++){\n\t\t\tif (T[j] == P[0]){\n\t\t\t\tif (T.substr(j, P.size()) == P){\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag) printf(\"1\\n\");\n\t\telse printf(\"0\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n// ------ Sparse Table ------ //\nclass SparseTable {\n\tvector<vector<int> >st;\npublic:\n\tvoid init(vector<int>vec) {\n\t\tint b;\n\t\tfor (b = 0; (1 << b)<vec.size(); b++);\n\t\tst.assign(b, vector<int>(1 << b));\n\t\tfor (int i = 0; i<vec.size(); i++)st[0][i] = vec[i];\n\n\t\tfor (int i = 1; i<b; i++) {\n\t\t\tfor (int j = 0; j + (1 << i) <= (1 << b); j++) {\n\t\t\t\tst[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n\t\t\t}\n\t\t}\n\t}\n\tint GetMin(int l, int r) {\n\t\tint b = 32 - __builtin_clz(r - l) - 1;\n\t\treturn min(st[b][l], st[b][r - (1 << b)]);\n\t}\n\tSparseTable() {}\n\tSparseTable(vector<int>vec) { init(vec); }\n};\n\n// ------ Suffix Array ------ //\nclass SuffixArray {\n\tvoid CreateBeginBucket(vector<int>&v, vector<int>&bucket) {\n\t\tfill(bucket.begin(), bucket.end(), 0);\n\t\tfor (int i = 0; i<v.size(); i++)bucket[v[i]]++;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i<bucket.size(); i++) { bucket[i] += sum; swap(sum, bucket[i]); }\n\t}\n\tvoid CreateEndBucket(vector<int>&v, vector<int>&bucket) {\n\t\tfill(bucket.begin(), bucket.end(), 0);\n\t\tfor (int i = 0; i<v.size(); i++)bucket[v[i]]++;\n\t\tfor (int i = 1; i<bucket.size(); i++)bucket[i] += bucket[i - 1];\n\t}\n\tvoid InducedSort(vector<int>&v, vector<int>&SA, int mv, vector<int>&bucket, vector<int>&isL) {\n\t\tCreateBeginBucket(v, bucket);\n\t\tfor (int i = 0; i<v.size(); i++)if (SA[i]>0 && isL[SA[i] - 1])SA[bucket[v[SA[i] - 1]]++] = SA[i] - 1;\n\t}\n\tvoid InvertInducedSort(vector<int>&v, vector<int>&SA, int mv, vector<int>&bucket, vector<int>&isL) {\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = v.size() - 1; i >= 0; i--)if (SA[i]>0 && !isL[SA[i] - 1])SA[--bucket[v[SA[i] - 1]]] = SA[i] - 1;\n\t}\n\tvector<int>SA_IS(vector<int>v, int mv) {\n\t\tif (v.size() == 1)return vector<int>(1, 0);\n\t\tvector<int>isL(v.size());\n\t\tvector<int>bucket(mv + 1);\n\t\tvector<int>SA(v.size(), -1);\n\t\tauto isLMS = [&](int x)->bool {return x>0 && isL[x - 1] && !isL[x]; };\n\t\tisL[v.size() - 1] = 0;\n\t\tfor (int i = v.size() - 2; i >= 0; i--)isL[i] = v[i]>v[i + 1] || (v[i] == v[i + 1] && isL[i + 1]);\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))SA[--bucket[v[i]]] = i;\n\t\tInducedSort(v, SA, mv, bucket, isL);\n\t\tInvertInducedSort(v, SA, mv, bucket, isL);\n\t\tint cur = 0;\n\t\tvector<int>ord(v.size());\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))ord[i] = cur++;\n\t\tvector<int>nxv(cur);\n\t\tcur = -1;\n\t\tint prev = -1;\n\t\tfor (int i = 0; i<v.size(); i++) {\n\t\t\tif (!isLMS(SA[i]))continue;\n\t\t\tbool diff = false;\n\t\t\tfor (int d = 0; d<v.size(); d++) {\n\t\t\t\tif (prev == -1 || v[SA[i] + d] != v[prev + d] || isL[SA[i] + d] != isL[prev + d]) {\n\t\t\t\t\tdiff = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (d>0 && isLMS(SA[i] + d))break;\n\t\t\t}\n\t\t\tif (diff) { cur++; prev = SA[i]; }\n\t\t\tnxv[ord[SA[i]]] = cur;\n\t\t}\n\t\tvector<int>reord(nxv.size());\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))reord[ord[i]] = i;\n\t\tvector<int>nxSA = SA_IS(nxv, cur);\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = 0; i<SA.size(); i++)SA[i] = -1;\n\t\tfor (int i = nxSA.size() - 1; i >= 0; i--)SA[--bucket[v[reord[nxSA[i]]]]] = reord[nxSA[i]];\n\t\tInducedSort(v, SA, mv, bucket, isL);\n\t\tInvertInducedSort(v, SA, mv, bucket, isL);\n\t\treturn SA;\n\t}\n\tvector<int>SA_IS(string s) {\n\t\tvector<int>v(s.size() + 1);\n\t\tfor (int i = 0; i<s.size(); i++)v[i] = s[i] + 1;\n\t\treturn SA_IS(v, *max_element(v.begin(), v.end()));\n\t}\n\tvector<int>construct_lcp(string &s, vector<int>&sa) {\n\t\tvector<int>lcp, rank(s.size() + 1);\n\t\tint n = s.size();\n\t\tfor (int i = 0; i <= n; i++)rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tlcp[0] = 0;\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h>0)h--;\n\t\t\tfor (; j + h<n&&i + h<n; h++) {\n\t\t\t\tif (s[j + h] != s[i + h])break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n\tSparseTable st;\npublic:\n\tstring s;\n\tvector<int>sa, lcp;\n\tvoid init(string &T) {\n\t\ts = T;\n\t\tsa = SA_IS(s);\n\t}\n\tSuffixArray(string &t) { init(t); }\n\tSuffixArray() {}\n\tbool contain(string &t) {\n\t\tint a = 0, b = s.size();\n\t\twhile (b - a>1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (s.compare(sa[c], t.size(), t)<0)a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn s.compare(sa[b], t.size(), t) == 0;\n\t}\n};\nint q; string s, t;\nint main() {\n\tcin >> s >> q;\n\tSuffixArray v(s);\n\tfor(int i = 0; i < q; i++) {\n\t\tcin >> t;\n\t\tcout << (v.contain(t) ? 1 : 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nclass SuffixArrayInducedSorting\n{\nprivate:\n    static constexpr int encode(const int c) { return c == '$' ? 0 : 'a' <= c and c <= 'z' ? c - 'a' + 1 : 'A' <= c and c <= 'Z' ? c - 'A' + 27 : c - '0' + 53; }\n    static constexpr char decode(const int n) { return (n == 0 ? '$' : 'a' + n - 1); }\n    enum class Type : char {\n        L = 0,\n        S = 1,\n        LMS = 2,\n    };\n\npublic:\n    SuffixArrayInducedSorting(const string& s, const int kind_) : N(s.size() + 1), kind{kind_ + 1}, S(s.size() + 1, 0), type(N), next(N, 1), bucket(kind), num(kind, 0), head(kind, 0), tail(kind, 0)\n    {\n        for (int i = 0; i < s.size(); i++) {\n            S[i] = encode(s[i]);\n        }\n        initializeData();\n        sortLMS();\n    }\n    SuffixArrayInducedSorting(const vector<int>& s, const int kind_) : N(s.size() + 1), kind{kind_ + 1}, S(s), type(N), next(N, 1), bucket(kind), num(kind, 0), head(kind, 0), tail(kind, 0)\n    {\n        S.push_back(0);\n        initializeData();\n        sortLMS();\n    }\n    void debugPrint() const\n    {\n        for (int i = 0; i < N; i++) {\n            cout << decode(S[i]);\n        }\n        cout << endl;\n        for (int i = 0; i < N; i++) {\n            cout << (type[i] == Type::L ? \"L\" : \"S\");\n        }\n        cout << endl;\n        for (int i = 0; i < N; i++) {\n            cout << (type[i] == Type::LMS ? \"@\" : \" \");\n        }\n        cout << endl;\n        for (int i = 0; i < kind; i++) {\n            if (bucket[i].empty())\n                continue;\n            cout << \"[\" << decode(i) << \"]:\\n\";\n            for (const int p : bucket[i]) {\n                cout << \"  \" << p << endl;\n            }\n        }\n    }\n\n    vector<int> getSuffixArray() const\n    {\n        vector<int> ans(N - 1);\n        for (int pos = 0, i = 1; i < kind; i++) {  // 番兵以外\n            for (const int p : bucket[i]) {\n                ans[pos++] = p;\n            }\n        }\n        return ans;\n    }\n\nprivate:\n    void initializeData()\n    {\n        for (const int i : S) {\n            num[i]++;\n        }\n        for (int i = 0; i < kind; i++) {\n            bucket[i].resize(num[i], -1);\n            tail[i] = num[i] - 1;\n        }\n        type[N - 1] = Type::S;\n        for (int i = N - 2; i >= 0; i--) {\n            type[i] = (S[i] != S[i + 1] ? (S[i] < S[i + 1] ? Type::S : Type::L) : type[i + 1]);\n            if (type[i] == Type::L and type[i + 1] == Type::S) {\n                type[i + 1] = Type::LMS;\n                LMS.push_back(i + 1);\n            }\n        }\n        for (int pos = N - 1, i = N - 2; i >= 0; i--) {\n            next[i] = pos;\n            if (type[i] == Type::LMS) {\n                pos = i;\n            }\n        }\n    }\n\n    void sortLMS()\n    {\n        for (const int l : LMS) {\n            insertTail(l);\n        }\n        induce();\n        vector<int> lms;\n        for (int i = 0; i < kind; i++) {\n            for (const int p : bucket[i]) {\n                if (type[p] == Type::LMS) {\n                    lms.push_back(p);\n                }\n            }\n        }\n        const int size = lms.size();\n        vector<int> order(N / 2 + 1, 0);\n        int number = 1;\n        order[N / 2] = 1;\n        bool same = false;\n        for (int i = 1; i < size; i++) {\n            const int l1 = lms[i - 1];\n            const int r1 = next[l1];\n            const int l2 = lms[i];\n            const int r2 = next[l2];\n            if (r1 - l1 == r2 - l2 and vector<int>(S.begin() + l1, S.begin() + r1 + 1) == vector<int>(S.begin() + l2, S.begin() + r2 + 1)) {\n                same = true;\n            } else {\n                number++;\n            }\n            order[l2 / 2] = number;\n        }\n        if (same) {\n            vector<int> s(size);\n            for (int p = 0, i = 0; i <= N / 2; i++) {\n                if (order[i] > 0) {\n                    s[p++] = order[i];\n                }\n            }\n            const vector<int> sorted = SuffixArrayInducedSorting{s, number}.getSuffixArray();\n            for (int i = 0; i < kind; i++) {\n                head[i] = 0;\n                tail[i] = num[i] - 1;\n            }\n            for (int i = size - 1; i >= 0; i--) {\n                insertTail(LMS[size - 1 - sorted[i]]);\n            }\n            induce();\n        } else {\n            for (int i = 0; i < kind; i++) {\n                head[i] = 0;\n                tail[i] = num[i] - 1;\n            }\n            for (int i = size - 1; i >= 0; i--) {\n                insertTail(lms[i]);\n            }\n            induce();\n        }\n    }\n\n    void induce()\n    {\n        for (int i = 0; i < kind; i++) {\n            for (int j = 0; j < head[i]; j++) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] == Type::L) {\n                    insertHead(p - 1);\n                }\n            }\n            for (int j = tail[i] + 1; j < num[i]; j++) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] == Type::L) {\n                    insertHead(p - 1);\n                }\n            }\n        }\n        for (int i = 1; i < kind; i++) {  // 番兵以外\n            tail[i] = num[i] - 1;\n        }\n        for (int i = kind - 1; i >= 0; i--) {\n            for (int j = num[i] - 1; j > tail[i]; j--) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] != Type::L) {\n                    insertTail(p - 1);\n                }\n            }\n            for (int j = head[i] - 1; j >= 0; j--) {\n                const int p = bucket[i][j];\n                if (p > 0 and type[p - 1] != Type::L) {\n                    insertTail(p - 1);\n                }\n            }\n        }\n    }\n    void insertHead(const int i) { bucket[S[i]][head[S[i]]++] = i; }\n    void insertTail(const int i) { bucket[S[i]][tail[S[i]]--] = i; }\n\n    const int N;\n    const int kind;\n    vector<int> S;               // O(N)\n    vector<Type> type;           // O(N)\n    vector<int> next;            // O(N)\n    vector<vector<int>> bucket;  // O(N)\n    vector<int> num;             // O(K)\n    vector<int> head;            // O(K)\n    vector<int> tail;            // O(K)\n    vector<int> LMS;             // O(N)\n};\n\nint main()\n{\n    string s;\n    cin >> s;\n    const int size = s.size();\n    const vector<int> sa = SuffixArrayInducedSorting(s, 79).getSuffixArray();\n    int N;\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        string p;\n        cin >> p;\n        const int psize = p.size();\n        int inf = -1;\n        int sup = size;\n        while (sup - inf > 1) {\n            const int mid = (sup + inf) / 2;\n            const bool ok = s.substr(sa[mid], psize) < p;\n            if (ok) {\n                inf = mid;\n            } else {\n                sup = mid;\n            }\n        }\n        const bool ans = sup == size ? false : s.substr(sa[sup], psize) == p;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nclass suffix_array {\n    // compare (rank[i], rank[i + k]) and (rank[j], rank[j + k])\n    static bool compare_sa(int n, const vector<int>& rank, int i, int j, int k) {\n        if (rank[i] != rank[j]) return rank[i] < rank[j];\n        int ri = i + k <= n ? rank[i + k] : -1;\n        int rj = j + k <= n ? rank[j + k] : -1;\n        return ri < rj;\n    }\npublic:\n    static vector<int> construct_sa(const string& s) {\n        int n = s.length();\n        vector<int> sa(n + 1), rank(n + 1);\n        for (int i = 0; i <= n; ++i) {\n            sa[i] = i;\n            rank[i] = i < n ? s[i] : -1;\n        }\n        for (int k = 1; k <= n; k <<= 1) {\n            sort(sa.begin(), sa.end(), [&n, &k, &rank](const int& a, const int& b){ return compare_sa(n, rank, a, b, k); });\n\n            vector<int> tmp(n + 1);\n            for (int i = 1; i <= n; ++i)\n                tmp[sa[i]] = tmp[sa[i - 1]] + compare_sa(n, rank, sa[i - 1], sa[i], k);\n            for (int i = 0; i <= n; ++i)\n                rank[i] = tmp[i];\n        }\n        return sa;\n    }\n    static vector<int> construct_lcp(const string& s, const vector<int>& sa) {\n        int n = s.length();\n        vector<int> rank(n + 1), lcp(n + 1);\n        for (int i = 0; i <= n; ++i) rank[sa[i]] = i;\n\n        int h = 0;\n        for (int i = 0; i < n; ++i) {\n            if (h > 0) --h;\n            for (int j = sa[rank[i] - 1]; j + h < n && i + h < n; ++h)\n                if (s[j + h] != s[i + h]) break;\n\n            lcp[rank[i] - 1] = h;\n        }\n        return lcp;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    int q;\n    cin >> s >> q;\n    const char* sc = s.c_str();\n    vector<int> sa = suffix_array::construct_sa(s);\n    for (int i = 0; i < q; ++i) {\n        string t;\n        cin >> t;\n        const char* tc = t.c_str();\n        int l = -1, re = s.length();\n        while (l + 1 < re) {\n            int m = (l + re) / 2;\n            if (strcmp(sc + sa[m], tc) < 0) {\n                l = m;\n            }\n            else {\n                re = m;\n            }\n        }\n        bool ok = true;\n        for (int j = 0; j < (int)t.length(); ++j) {\n            if (s[sa[re] + j] != t[j]) {\n                ok = false;\n                break;\n            }\n        }\n        cout << ok << '\\n';\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    //const int k=lcp2(i,j,0,min(n-i,n-j)+1);\n    //const int k=lcp2(i,j,0,(n-max(i,j))*2+1);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  inline bool cmp(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    //int l=0,r=min(n-i,n-j)+1;\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      //(hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n      if(hash(i,i+m) == hash(j,j+m))l=m;\n      else r=m;\n    }\n    return l;\n  }\n  \n  /*\n  inline int lcp2(const int& i, const int& j, const int& l, const int& r){\n    if(r-l<=1)return l;\n    int m=(l+r)/2;\n    if(hash(i,i+m)==hash(j,j+m))return lcp2(i,j,m,r);\n    return lcp2(i,j,l,m);\n  }\n  */\n};\n\nvoid quicksort(vector<int> &a, const int& l, const int& r, const RollingHash &rh) {\n  if (rh.cmp(a[l],a[r])) {\n    int p = a[(l+r)/2];\n    int i = l-1, j = r+1;\n    while (1) {\n      while (a[++i] < p);\n      while (a[--j] > p);\n      if (i >= j) break;\n      swap(a[i], a[j]);\n    }\n    quicksort(a, l, i-1,rh);\n    quicksort(a, j+1, r,rh);\n  }\n}\nvoid quicksort(vector<int> &a, const RollingHash& rh) {\n  quicksort(a, 0, a.size()-1,rh);\n}\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  int n = a.size();\n  if (n > 1) {\n    vector<int> b(a.begin(), a.begin() + n/2);\n    vector<int> c(a.begin() + n/2, a.end());\n    mergesort(b,rh);\n    mergesort(c,rh);\n    for (int i = 0, j = 0, k = 0; i < n; ++i)\n      if (k == c.size())      a[i] = b[j++];\n      else if (j == b.size()) a[i] = c[k++];\n      else if (rh.cmp(b[j],c[k]))   a[i] = b[j++];\n      else                    a[i] = c[k++];\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  //sort(ALL(sa),rh);\n  //quicksort(sa,rh);\n  mergesort(sa,rh);\n  //if(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nstring S; int Q; char STR[1005];\n\nint main()\n{\n\tcin >> S >> Q; cout << string::npos << endl;\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%s\", STR);\n\n\t\tprintf(\"%d\\n\", S.find(STR) != -1 ? 1 : 0);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  //static const ull p=100000007;\n  static const ull p=100000007;\n  string s;\n  int n;\n  vector<ull> pow, phash;\n  \n  RollingHash(string s) : s(s), n(SZ(s)), pow(n+1), phash(n+1){\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int i, const int j) { \n    int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n  \n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n\n  inline ull hash(int b, int e){\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  \n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  \n  inline int lcp(int i, int j){\n    int l=0,r=min(n-i,n-j)+1;\n    while(r-l>1) {\n      int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  //if(10000 < rh.s.size())assert(false);\n  sort(ALL(sa),rh);\n  if(10000 < rh.s.size())assert(false);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a = 0, b = S.length();\n  while( b - a > 1 ){\n    int c = (a + b ) / 2;\n    if ( S.compare(sa[c], T.length(), T) < 0 ) a = c;\n    else b = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  string s,t;\n  cin >> s;\n\n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    cin >> t;\n    printf(\"%d\\n\",contain(s,sa,t));\n    //cout << !!rh.find(t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 200005\n\nstruct SuffixArray {\n    vector< int > SA;\n    const string s;\n\n    SuffixArray(const string &str) : s(str) {\n        SA.resize(s.size());\n        iota(begin(SA), end(SA), 0);\n        sort(begin(SA), end(SA), [&](int a, int b) {\n        return s[a] == s[b] ? a > b : s[a] < s[b];\n        });\n        vector< int > classes(s.size()), c(s.begin(), s.end()), cnt(s.size());\n        for(int len = 1; len < s.size(); len <<= 1) {\n        for(int i = 0; i < s.size(); i++) {\n            if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n            classes[SA[i]] = classes[SA[i - 1]];\n            } else {\n            classes[SA[i]] = i;\n            }\n        }\n        iota(begin(cnt), end(cnt), 0);\n        copy(begin(SA), end(SA), begin(c));\n        for(int i = 0; i < s.size(); i++) {\n            int s1 = c[i] - len;\n            if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n        }\n        classes.swap(c);\n        }\n    }\n\n    int operator[](int k) const {\n        return SA[k];\n    }\n\n    size_t size() const {\n        return s.size();\n    }\n\n    bool lt_substr(const string &t, int si = 0, int ti = 0) {\n        int sn = (int) s.size(), tn = (int) t.size();\n        while(si < sn && ti < tn) {\n        if(s[si] < t[ti]) return true;\n        if(s[si] > t[ti]) return false;\n        ++si, ++ti;\n        }\n        return si >= sn && ti < tn;\n    }\n\n    int lower_bound(const string &t) {\n        int low = -1, high = (int) SA.size();\n        while(high - low > 1) {\n        int mid = (low + high) / 2;\n        if(lt_substr(t, SA[mid])) low = mid;\n        else high = mid;\n        }\n        return high;\n    }\n\n    pair< int, int > lower_upper_bound(string &t) {\n        int idx = lower_bound(t);\n        int low = idx - 1, high = (int) SA.size();\n        t.back()++;\n        while(high - low > 1) {\n        int mid = (low + high) / 2;\n        if(lt_substr(t, SA[mid])) low = mid;\n        else high = mid;\n        }\n        t.back()--;\n        return {idx, high};\n    }\n\n    void output() {\n        for(int i = 0; i < size(); i++) {\n        cout << i << \": \" << s.substr(SA[i]) << endl;\n        }\n    }\n};\n\nstruct LongestCommonPrefixArray {\n    const SuffixArray &SA;\n    vector< int > LCP, rank;\n\n    LongestCommonPrefixArray(const SuffixArray &SA) : SA(SA), LCP(SA.size()) {\n        rank.resize(SA.size());\n        for(int i = 0; i < SA.size(); i++) {\n        rank[SA[i]] = i;\n        }\n        for(int i = 0, h = 0; i < SA.size(); i++) {\n        if(rank[i] + 1 < SA.size()) {\n            for(int j = SA[rank[i] + 1]; max(i, j) + h < SA.size() && SA.s[i + h] == SA.s[j + h]; ++h);\n            LCP[rank[i] + 1] = h;\n            if(h > 0) --h;\n        }\n        }\n    }\n\n    int operator[](int k) const {\n        return LCP[k];\n    }\n\n    size_t size() const {\n        return LCP.size();\n    }\n\n    void output() {\n        for(int i = 0; i < size(); i++) {\n        cout << i << \": \" << LCP[i] << \" \" << SA.s.substr(SA[i]) << endl;\n        }\n    }\n};\n\n\nint main() {\n    string s;\n    int q;\n\n    cin >> s;\n    SuffixArray sa(s);\n    cin >> q;\n    while(q--) {\n        string t;\n        cin >> t;\n        auto range = sa.lower_upper_bound(t);\n        cout << (range.first != range.second) << endl;\n    }\n    return 0;\n}\n \n \n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nclass SuffixArray {\n\tvoid CEB(vector<int> &v, vector<int> &b) {\n\t\tint vs = v.size(), bs = b.size();\n\t\tfill(b.begin(), b.end(), 0);\n\t\tfor (int i = 0; i < vs; i++) b[v[i]]++;\n\t\tfor (int i = 1; i < bs; i++) b[i] += b[i - 1];\n\t}\n\tvoid ISort(vector<int> &v, vector<int> &SA, int mv, vector<int> &b, vector<int> &isL) {\n\t\tint vs = v.size(), bs = b.size();\n\t\tfill(b.begin(), b.end(), 0);\n\t\tfor (int i = 0; i < vs; i++) b[v[i]]++;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < bs; i++) b[i] += sum, swap(sum, b[i]);\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (SA[i] > 0 && isL[SA[i] - 1]) SA[b[v[SA[i] - 1]]++] = SA[i] - 1;\n\t\t}\n\t}\n\tvoid IISort(vector<int> &v, vector<int> &SA, int mv, vector<int> &b, vector<int> &isL) {\n\t\tCEB(v, b);\n\t\tfor (int i = v.size() - 1; i >= 0; i--) {\n\t\t\tif (SA[i] > 0 && !isL[SA[i] - 1]) SA[--b[v[SA[i] - 1]]] = SA[i] - 1;\n\t\t}\n\t}\n\tvector<int>SA_IS(vector<int> v, int mv) {\n\t\tint vs = v.size();\n\t\tif (vs == 1) return vector<int>(1, 0);\n\t\tvector<int> isL(vs), b(mv + 1), SA(vs, -1), ord(vs);\n\t\tauto isLMS = [&](int x)->bool { return x > 0 && isL[x - 1] && !isL[x]; };\n\t\tfor (int i = vs - 2; i >= 0; i--) isL[i] = (v[i] > v[i + 1]) || (v[i] == v[i + 1] && isL[i + 1]);\n\t\tCEB(v, b);\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) SA[--b[v[i]]] = i;\n\t\t}\n\t\tISort(v, SA, mv, b, isL);\n\t\tIISort(v, SA, mv, b, isL);\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) ord[i] = cur++;\n\t\t}\n\t\tvector<int> nxv(cur);\n\t\tcur = -1;\n\t\tint prev = -1;\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (!isLMS(SA[i])) continue;\n\t\t\tbool diff = false;\n\t\t\tfor (int d = 0; d < vs; d++) {\n\t\t\t\tif (prev == -1 || v[SA[i] + d] != v[prev + d] || isL[SA[i] + d] != isL[prev + d]) {\n\t\t\t\t\tdiff = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (d && isLMS(SA[i] + d))break;\n\t\t\t}\n\t\t\tif (diff) cur++, prev = SA[i];\n\t\t\tnxv[ord[SA[i]]] = cur;\n\t\t}\n\t\tvector<int> reord(nxv.size());\n\t\tfor (int i = 0; i < vs; i++) {\n\t\t\tif (isLMS(i)) reord[ord[i]] = i;\n\t\t}\n\t\tvector<int> nxSA = SA_IS(nxv, cur);\n\t\tCEB(v, b);\n\t\tfor (int i = 0; i < SA.size(); i++) SA[i] = -1;\n\t\tfor (int i = nxSA.size() - 1; i >= 0; i--) {\n\t\t\tSA[--b[v[reord[nxSA[i]]]]] = reord[nxSA[i]];\n\t\t}\n\t\tISort(v, SA, mv, b, isL);\n\t\tIISort(v, SA, mv, b, isL);\n\t\treturn SA;\n\t}\n\tvector<int>SA_IS(string s) {\n\t\tvector<int> v(s.size() + 1);\n\t\tfor (int i = 0; i < s.size(); i++) v[i] = s[i] + 1;\n\t\treturn SA_IS(v, *max_element(v.begin(), v.end()));\n\t}\npublic:\n\tstring s;\n\tvector<int> sa;\n\tvoid init(string &T) {\n\t\ts = T;\n\t\tsa = SA_IS(s);\n\t}\n\tSuffixArray(string &t) { init(t); }\n\tSuffixArray() {}\n\tbool contain(string &t) {\n\t\tint a = 0, b = s.size();\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (s.compare(sa[c], t.size(), t) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn s.compare(sa[b], t.size(), t) == 0;\n\t}\n};\nint q; string s, t;\nint main() {\n\tcin >> s >> q;\n\tSuffixArray v(s);\n\tfor(int i = 0; i < q; i++) {\n\t\tcin >> t;\n\t\tcout << (v.contain(t) ? 1 : 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\n#define NUM 48\nusing namespace std;\n\nint T_char_count[128] = {0},P_char_count[128];\nint T_Chain[128][128];\n\nclass LocRecord{\n\npublic:\n\t//?????¢???????¢????\n\tLocRecord(){\n\t\tlocationTable = new int**[128];\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tlocationTable[i] = new int*[128];\n\t\t\tfor(int k = 0; k < 128; k++){\n\t\t\t\tif(T_Chain[i][k] > 0){\n\t\t\t\t\tlocationTable[i][k] = new int[T_Chain[i][k]+1];\n\t\t\t\t\tfor(int p = 0; p < T_Chain[i][k]+1; p++){\n\t\t\t\t\t\tlocationTable[i][k][p] = -1;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tlocationTable[i][k] = new int[2];\n\t\t\t\t\tfor(int p = 0; p < 2; p++){\n\t\t\t\t\t\tlocationTable[i][k][p] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinit();\n\t}\n\n\t//-1?????£??\\\n\tvoid init(){\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tfor(int k = 0; k < 128; k++){\n\t\t\t\tindex[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init_index(char first,char second){\n\t\tindex[first][second] = 0;\n\t}\n\n\tvoid regist_loc(char first,char second,int location){\n\t\tlocationTable[first][second][index[first][second]] = location;\n\t\tindex[first][second]++;\n\t}\n\n\tint next_loc(char first,char second){\n\t\tint ret = locationTable[first][second][index[first][second]];\n\t\tindex[first][second]++;\n\t\treturn ret;\n\t}\n\nprivate:\n\tint*** locationTable;\n\tint index[128][128];\n};\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\t\t\treturn length < arg.length;\n\t};\n\tInfo(int arg_length,int arg_id,ull arg_hashValue){\n\t\tlength = arg_length;\n\t\tid = arg_id;\n\t\thashValue = arg_hashValue;\n\t}\n\n\tint length,id;\n\tull hashValue;\n};\n\nint main(){\n\n\tfor(int i = 0; i < 128; i++){\n\t\tT_char_count[i] = 0;\n\t\tfor(int k = 0; k < 128; k++){\n\t\t\tT_Chain[i][k] = 0;\n\t\t}\n\t}\n\n\tint T_length;\n\n\tchar* T = new char[1000001];\n\tscanf(\"%s\",T);\n\n\tchar pre = T[0];\n\n\tfor(T_length = 1; T[T_length] != '\\0';T_length++){\n\t\tT_char_count[T[T_length]]++;\n\t\tT_Chain[pre][T[T_length]]++;\n\t\tpre = T[T_length];\n\t}\n\n\tLocRecord locRecord;\n\tlocRecord.init();\n\n\n\tpre = T[0];\n\t//T[i]????????????i??§???????????¨????¨????\n\tfor(int i = 1; i < T_length; i++){\n\t\tlocRecord.regist_loc(pre,T[i],i-1);\n\t\tpre = T[i];\n\t}\n\n\tull* HASH = new ull[T_length+1];\n\tull* P = new ull[T_length+1];\n\n\tHASH[0] = 0;\n\tP[0] = 1;\n\n\t//T??????????????\\???????±???????\n\tfor(int i = 1; i <= T_length; i++){\n\t\tHASH[i] = T[i-1] + HASH[i-1]*MOD;\n\t\tP[i] = P[i-1]*MOD;\n\t}\n\n\n\tvector<Info> V[128][128];\n\n\tint Q,S_length,left,P_char_count[128];\n\tscanf(\"%d\",&Q);\n\n\tbool check[Q];\n\n\tfor(int i = 0; i < Q; i++)check[i] = false;\n\n\tchar S[1001];\n\tull S_HASH[1001],S_value,T_value,D;\n\tbool FLG;\n\n\n\t//Q??¶??????????????\\???????¨????\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%s\",S);\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tP_char_count[i] = 0;\n\t\t}\n\n\t\tfor(S_length = 0;S[S_length] != '\\0';S_length++){\n\t\t\tP_char_count[S[S_length]]++;\n\t\t}\n\n\t\tFLG = true;\n\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tif(T_char_count[i] < P_char_count[i]){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG)continue;\n\n\t\tif(S_length == 1){\n\t\t\tcheck[loop] = true;\n\t\t\tcontinue;\n\t\t}\n\n\n\n\t\tS_HASH[0] = 0;\n\t\tfor(int i = 1; i <= S_length; i++){\n\t\t\tS_HASH[i] = S[i-1] + S_HASH[i-1]*MOD;\n\t\t}\n\n\t\tS_value = S_HASH[S_length];\n\n\t\tV[S[0]][S[1]].push_back(Info(S_length,loop,S_value));\n\t}\n\n\tint calc_length;\n\n\tfor(int first_word = 48; first_word <= 122; first_word++){\n\t\tfor(int second_word = 48; second_word <= 122;second_word++){\n\t\t\tfor(int i = 0; i < V[first_word][second_word].size();i++){\n\n\t\t\t\tlocRecord.init_index(first_word,second_word);\n\n\t\t\t\tcalc_length = V[first_word][second_word][i].length;\n\t\t\t\tS_value = V[first_word][second_word][i].hashValue;\n\n\t\t\t\tD = P[calc_length];\n\n\t\t\t\twhile((left = locRecord.next_loc(first_word,second_word)) != -1){\n\t\t\t\t\tif(left+calc_length-1 >= T_length)break;\n\n\t\t\t\t\tT_value = HASH[left+calc_length]-HASH[left]*D;\n\n\t\t\t\t\tif(T_value == S_value){\n\t\t\t\t\t\tcheck[V[first_word][second_word][i].id] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tif(check[i])printf(\"1\\n\");\n\t\telse{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s){\n    n=SZ(s);\n    pow=(ull *)malloc(2*n+1);\n    phash=(ull *)malloc(2*n+1);\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }  \n};\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  const int n = SZ(a);\n  if(n>1){\n    vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(b,rh), mergesort(c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==SZ(c))a[i]=b[j++];\n      else if(j==SZ(b))a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  mergesort(sa,rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000000];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ull unsigned long long\nusing namespace std;\null B=100000007;\nint h[1001]={};\nvector<ull> v[1001];\nvoid contain(string b,int n){\n  int bl=b.size();\n  \n  ull t=1;\n  for(int i=0;i<n;i++)t*=B;\n\n  ull bh=0;\n  for(int i=0;i<n;i++)bh=bh*B+b[i];\n\n  for(int i=0;i+n<=bl;i++){\n    v[n].push_back(bh);\n    if(i+n<bl)bh=bh*B+b[i+n]-b[i]*t;\n  }\n  sort(v[n].begin(),v[n].end());\n  return;\n}\n\nint main(){\n  int n;\n  string b;\n  cin>>b>>n;\n  for(int i=0;i<n;i++){\n    string a;\n    cin>>a;\n    int al=a.size();\n    if(al>b.size()){\n      cout<<'0'<<endl;\n      continue;\n    }\n    if(h[al]==0){\n      contain(b,al);\n      h[al]=1;\n    }\n    ull ah=0;\n    for(int j=0;j<al;j++)ah=ah*B+a[j];\n    //cout<<\"ah = \"<<ah<<endl;\n    //for(int j=0;j<v[al].size();j++)cout<<\"v[i] = \"<<v[al][j]<<endl;\n    int l=0,m,r=v[al].size(),f=0;\n    while(r>l){\n      m=(l+r)/2;\n      if(v[al][m]==ah){\n\tf=1;\n\tbreak;\n      }else if(v[al][m]>ah)r=m;\n      else l=m+1;\n    }\n    cout<<f<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow, *phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow = (ull*)malloc(n+1);\n    phash = (ull*)malloc(n+1);\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? 1 : j+k >= n ? 0 : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }  \n};\n\nvoid mergesort(vector<int> &a, const RollingHash& rh) {\n  const int n = SZ(a);\n  if(n>1){\n    vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(b,rh), mergesort(c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k==SZ(c))a[i]=b[j++];\n      else if(j==SZ(b))a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  vector<int> sa(rh.n+1);\n  REP(i,rh.n+1)sa[i]=i;\n  mergesort(sa,rh);\n  return sa;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b= SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000000];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<string>\n#include<cstdio>\n#include<algorithm>\n\nstring T;\nint *A, *lev, *new_lev;\nint k, n;\n\nbool cmp_ex(int i, int j)\n{\n    if(T[i] != T[j]){ return lev[i] < lev[j]; }\n    return (i + k < n ? lev[i + k] : -1) < (j + k < n ? lev[j + k] : -1);\n}\n\nint main()\n{\n    int i;\n    scanf(\"%d\", &n);\n    cin >> T;\n\n    A = new int [n + 1];\n    lev = new int [n + 1];\n    new_lev = new int [n + 1];\n\n    for(i = 0; i < n; i++){ A[i] = i; lev[i] = T[i]; }\n    A[n] = n, lev[n] = -1;\n\n    k = 1;\n    while(1){\n        sort(A, A + n + 1, cmp_ex);\n        if((k << 1) > n) break;\n        new_lev[A[0]] = 0;\n        for(i = 0; i < n; i++){ new_lev[A[i + 1]] = new_lev[A[i]] + (cmp_ex(i, i + 1) ? 1 : 0); }\n        for(i = 0; i <= n; i++) lev[i] = new_lev[i];\n        k <<= 1;\n    };\n\n    int q;\n    scanf(\"%d\", &q);\n    string P; int lp, left, right, mid, crit; bool exist;\n\n    while(q){\n        cin >> P;\n        lp = P.size();\n        left = 0; right = n; exist = false;\n        while(left <= right){\n            mid = (left + right) / 2;\n            crit = T.compare(A[mid], lp, P);\n            if(crit > 0){\n                right = mid - 1;\n            }else if(crit < 0){\n                left = mid + 1;\n            }else{\n                exist = true; break;\n            }\n        };\n        if(exist){ printf(\"1\\n\"); }else{ printf(\"0\\n\"); }\n        q--;\n    };\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<functional>\nusing namespace std;\n#define MAX_N 1100000\nint Rank[MAX_N], x[MAX_N];\nint SA[MAX_N]; string S, T; int V;\nbool Compare(int p, int q) {\n\tif (Rank[p] < Rank[q])return true;\n\tif (Rank[p] > Rank[q])return false;\n\tint D1 = -1, D2 = -1;\n\tif (p + V <= S.size())D1 = Rank[p + V];\n\tif (q + V <= S.size())D2 = Rank[q + V];\n\tif (D1 < D2)return true;\n\treturn false;\n}\nvoid Build() {\n\tfor (int i = 0; i < S.size(); i++) { SA[i] = i; Rank[i] = S[i]; }\n\tSA[S.size()] = S.size(); Rank[S.size()] = -1;\n\tfor (V = 1; V <= S.size(); V *= 2) {\n\t\tsort(SA, SA + S.size() + 1, Compare);\n\t\tx[SA[0]] = 0;\n\t\tfor (int i = 1; i <= S.size(); i++) {\n\t\t\tx[SA[i]] = x[SA[i - 1]] + Compare(SA[i - 1], SA[i]);\n\t\t}\n\t\tfor (int i = 0; i <= S.size(); i++)Rank[i] = x[i];\n\t}\n}\nint hantei(int C, string &V2) {\n\tint H = min(S.size() - C, V2.size());\n\tfor (int i = 0; i < H; i++) {\n\t\tif (S[i + C] < V2[i])return -1;\n\t\tif (S[i + C] > V2[i])return 1;\n\t}\n\treturn 0;\n}\nint main() {\n\tcin >> S; int Q; cin >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> T; int L = 0, R = S.size() + 1, M;\n\t\twhile (L + 1 < R) {\n\t\t\tM = (L + R) / 2;\n\t\t\tif (hantei(SA[M], T) <= 0)L = M;\n\t\t\telse { R = M; }\n\t\t}\n\t\tif (hantei(SA[L], T) == 0)cout << \"1\" << endl;\n\t\telse cout << \"0\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> P;\n\nconst int inf = 1e7;\n\nint n;\nstring t;\nint q;\nstring p[10000];\nint sa[11][1000000];\nint isa[1000000];\nint lcp[1 << 21];\n\nint stu(int i, int x, int k, int l, int r){\n\tif(r <= i || i < l){\n\t\treturn lcp[k];\n\t}\n\tif(i <= l && r <= i + 1){\n\t\treturn lcp[k] = x;\n\t}\n\tint m = (l + r) / 2;\n\treturn lcp[k] = min(\n\t\tstu(i, x, 2 * k + 1, l, m),\n\t\tstu(i, x, 2 * k + 2, m, r)\n\t);\n}\nvoid stu(int i, int x){\n\tstu(i, x, 0, 0, n - 1);\n}\n\nint rmq(int a, int b, int k, int l, int r){\n\tif(r <= a || b <= l){\n\t\treturn inf;\n\t}\n\tif(a <= l && r <= b){\n\t\treturn lcp[k];\n\t}\n\tint m = (l + r) / 2;\n\treturn min(\n\t\trmq(a, b, 2 * k + 1, l, m),\n\t\trmq(a, b, 2 * k + 2, m ,r)\n\t);\n}\nint rmq(int a, int b){\n\treturn rmq(a, b, 0, 0, n - 1);\n}\n\nvoid pp(){\n\tstring v = t;\n\tsort(v.begin(), v.end());\n\trep(i, n){\n\t\tsa[0][i] = lower_bound(v.begin(), v.end(), t[i]) - v.begin();\n\t}\n\tfor(int i = 1; i <= 10; ++i){\n\t\tint k = 1 << i - 1;\n\t\tvector<P> s(n);\n\t\trep(j, n){\n\t\t\ts[j] = P(ll(sa[i - 1][j]) << 20 | (j + k < n ? sa[i - 1][j + k] + 1 : 0), j);\n\t\t}\n\t\tsort(s.begin(), s.end());\n\t\trep(j, n){\n\t\t\tsa[i][s[j].second] = i == 10 || j == 0 || s[j - 1].first < s[j].first ? j : sa[i][s[j - 1].second];\n\t\t}\n\t}\n\n\trep(i, n){\n\t\tisa[sa[10][i]] = i;\n\t}\n\n\tint l = 0;\n\trep(i, n){\n\t\tint r = sa[10][i];\n\t\tif(r == n - 1){\n\t\t\tl = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tint j = isa[r + 1];\n\t\twhile(l < 1 << 10 && i + l < n && j + l < n && t[i + l] == t[j + l]){\n\t\t\t++l;\n\t\t}\n\t\tstu(r, l);\n\t\tl = max(l - 1, 0);\n\t}\n}\n\nbool srch(const string& p){\n\tint m = p.size();\n\n\tint h = 0;\n\twhile(isa[0] + h < n && h < m && t[isa[0] + h] == p[h]){\n\t\t++h;\n\t}\n\n\tint l = 0;\n\tint r = n;\n\tbool b = true;\n\twhile(r - l > 1){\n\t\tint k = (l + r) / 2;\n\t\tif(b){\n\t\t\tint c = rmq(l, k);\n\t\t\tif(c > h){\n\t\t\t\tl = k;\n\t\t\t}\n\t\t\telse if(c < h){\n\t\t\t\tr = k;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(isa[k] + h < n && h < m && t[isa[k] + h] == p[h]){\n\t\t\t\t\t++h;\n\t\t\t\t}\n\t\t\t\tif(isa[k] + h == n){\n\t\t\t\t\tl = k;\n\t\t\t\t}\n\t\t\t\telse if(h == m){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(t[isa[k] + h] < p[h]){\n\t\t\t\t\t\tl = k;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tr = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint c = rmq(k, r);\n\t\t\tif(c > h){\n\t\t\t\tr = k;\n\t\t\t}\n\t\t\telse if(c < h){\n\t\t\t\tl = k;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(isa[k] + h < n && h < m && t[isa[k] + h] == p[h]){\n\t\t\t\t\t++h;\n\t\t\t\t}\n\t\t\t\tif(isa[k] + h == n){\n\t\t\t\t\tl = k;\n\t\t\t\t}\n\t\t\t\telse if(h == m){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(t[isa[k] + h] < p[h]){\n\t\t\t\t\t\tl = k;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tr = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tb = l == k;\n\t}\n\treturn isa[l] + m <= n && string(t, isa[l], m) == p;\n}\n\nint main(){\n\tcin >> t >> q;\n\tn = t.size();\n\trep(i, q){\n\t\tcin >> p[i];\n\t}\n\n\tpp();\n\n\trep(i, q){\n\t\tcout << srch(p[i]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// ------ Suffix Array ------ //\nclass SuffixArray {\n\tvoid CreateBeginBucket(vector<int>&v, vector<int>&bucket) {\n\t\tfill(bucket.begin(), bucket.end(), 0);\n\t\tfor (int i = 0; i<v.size(); i++)bucket[v[i]]++;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i<bucket.size(); i++) { bucket[i] += sum; swap(sum, bucket[i]); }\n\t}\n\tvoid CreateEndBucket(vector<int>&v, vector<int>&bucket) {\n\t\tfill(bucket.begin(), bucket.end(), 0);\n\t\tfor (int i = 0; i<v.size(); i++)bucket[v[i]]++;\n\t\tfor (int i = 1; i<bucket.size(); i++)bucket[i] += bucket[i - 1];\n\t}\n\tvoid InducedSort(vector<int>&v, vector<int>&SA, int mv, vector<int>&bucket, vector<int>&isL) {\n\t\tCreateBeginBucket(v, bucket);\n\t\tfor (int i = 0; i<v.size(); i++)if (SA[i]>0 && isL[SA[i] - 1])SA[bucket[v[SA[i] - 1]]++] = SA[i] - 1;\n\t}\n\tvoid InvertInducedSort(vector<int>&v, vector<int>&SA, int mv, vector<int>&bucket, vector<int>&isL) {\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = v.size() - 1; i >= 0; i--)if (SA[i]>0 && !isL[SA[i] - 1])SA[--bucket[v[SA[i] - 1]]] = SA[i] - 1;\n\t}\n\tvector<int>SA_IS(vector<int>v, int mv) {\n\t\tif (v.size() == 1)return vector<int>(1, 0);\n\t\tvector<int>isL(v.size());\n\t\tvector<int>bucket(mv + 1);\n\t\tvector<int>SA(v.size(), -1);\n\t\tauto isLMS = [&](int x)->bool {return x>0 && isL[x - 1] && !isL[x]; };\n\t\tisL[v.size() - 1] = 0;\n\t\tfor (int i = v.size() - 2; i >= 0; i--)isL[i] = v[i]>v[i + 1] || (v[i] == v[i + 1] && isL[i + 1]);\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))SA[--bucket[v[i]]] = i;\n\t\tInducedSort(v, SA, mv, bucket, isL);\n\t\tInvertInducedSort(v, SA, mv, bucket, isL);\n\t\tint cur = 0;\n\t\tvector<int>ord(v.size());\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))ord[i] = cur++;\n\t\tvector<int>nxv(cur);\n\t\tcur = -1;\n\t\tint prev = -1;\n\t\tfor (int i = 0; i<v.size(); i++) {\n\t\t\tif (!isLMS(SA[i]))continue;\n\t\t\tbool diff = false;\n\t\t\tfor (int d = 0; d<v.size(); d++) {\n\t\t\t\tif (prev == -1 || v[SA[i] + d] != v[prev + d] || isL[SA[i] + d] != isL[prev + d]) {\n\t\t\t\t\tdiff = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (d>0 && isLMS(SA[i] + d))break;\n\t\t\t}\n\t\t\tif (diff) { cur++; prev = SA[i]; }\n\t\t\tnxv[ord[SA[i]]] = cur;\n\t\t}\n\t\tvector<int>reord(nxv.size());\n\t\tfor (int i = 0; i<v.size(); i++)if (isLMS(i))reord[ord[i]] = i;\n\t\tvector<int>nxSA = SA_IS(nxv, cur);\n\t\tCreateEndBucket(v, bucket);\n\t\tfor (int i = 0; i<SA.size(); i++)SA[i] = -1;\n\t\tfor (int i = nxSA.size() - 1; i >= 0; i--)SA[--bucket[v[reord[nxSA[i]]]]] = reord[nxSA[i]];\n\t\tInducedSort(v, SA, mv, bucket, isL);\n\t\tInvertInducedSort(v, SA, mv, bucket, isL);\n\t\treturn SA;\n\t}\n\tvector<int>SA_IS(string s) {\n\t\tvector<int>v(s.size() + 1);\n\t\tfor (int i = 0; i<s.size(); i++)v[i] = s[i] + 1;\n\t\treturn SA_IS(v, *max_element(v.begin(), v.end()));\n\t}\n\tvector<int>construct_lcp(string &s, vector<int>&sa) {\n\t\tvector<int> lcp, rank(s.size() + 1);\n\t\tint n = s.size();\n\t\tfor (int i = 0; i <= n; i++)rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tlcp[0] = 0;\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h>0) h--;\n\t\t\tfor (; j + h<n&&i + h<n; h++) {\n\t\t\t\tif (s[j + h] != s[i + h])break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\npublic:\n\tstring s;\n\tvector<int> sa, lcp;\n\tvoid init(string &T) {\n\t\ts = T;\n\t\tsa = SA_IS(s);\n\t}\n\tSuffixArray(string &t) { init(t); }\n\tSuffixArray() {}\n\tbool contain(string &t) {\n\t\tint a = 0, b = s.size();\n\t\twhile (b - a>1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (s.compare(sa[c], t.size(), t) < 0)a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn s.compare(sa[b], t.size(), t) == 0;\n\t}\n};\n\n// ------ Main ------ //\nint q; string s, t;\nint main() {\n\tcin >> s >> q;\n\tSuffixArray v(s);\n\tfor(int i = 0; i < q; i++) {\n\t\tcin >> t;\n\t\tcout << (v.contain(t) ? 1 : 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cassert>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define ALL(A) (A).begin(),(A).end()\n#define SZ(A) int(A.size())\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct RollingHash{\n  static const ull p=100000007;\n  string s;\n  int n;\n  //vector<ull> pow, phash;\n  ull *pow,*phash;\n  \n  RollingHash(const string &s) : s(s), n(SZ(s)){\n    pow=new ull[n+1];\n    phash=new ull[n+1];\n    pow[0]=1,phash[0]=0;\n    REP(i, n) {\n      phash[i+1] = s[i] + phash[i] * p;\n      pow[i+1] = pow[i] * p;\n    }\n  }\n\n  ~RollingHash(){ free(pow), free(phash); }\n\n  inline bool operator()(const int& i, const int& j) const { \n    const int k=lcp(i,j);\n    return i+k >= n ? true : j+k >= n ? false : s[i+k] <= s[j+k];\n  }\n\n  /*\n  static ull hash(const string &t) {\n    ull h=0;\n    REP(i,SZ(t))h=t[i]+h*p;\n    return h;\n  }  \n  */\n\n  inline ull hash(const int& b, const int& e) const {\n    return phash[e]-phash[b]*pow[e-b];\n  }\n  /*\n  inline int find(string t) {\n    int w=t.size(),count=0;\n    if(w > SZ(s))return 0;\n    ull h=hash(t);\n    REP(i,n-w+1)count+=(hash(i,i+w)==h);\n    return count;\n  }\n  */\n  \n  inline int lcp(const int& i, const int& j) const {\n    int l=0,r=n-max(i,j)+1;\n    while(r-l>1) {\n      const int m=(l+r)/2;\n      (hash(i,i+m) == hash(j,j+m) ? l : r) = m;\n    }\n    return l;\n  }\n};\n/*\nvoid mergesort(const int& n,int *a, const RollingHash& rh){\n  if(n>1){\n    int nb=n/2,nc=n-nb,b[nb],c[nc];\n    REP(i,nb)b[i]=a[i];\n    REP(i,nc)c[i]=a[nb+i];\n      //vector<int> b(a.begin(), a.begin()+n/2), c(a.begin()+n/2, a.end());\n    mergesort(nb,b,rh), mergesort(nc,c,rh);\n    for(int i=0,j=0,k=0;i<n;i++){\n      if(k>=nc)a[i]=b[j++];\n      else if(j>=nb)a[i]=c[k++];\n      else if(rh(b[j],c[k]))a[i]=b[j++];\n      else a[i]=c[k++];\n    }\n  }\n}\n*/\nint L[1000000],R[1000000];\n\nvoid merge(int *A, const int left, const int mid, const int right, const RollingHash &rh){\n  int n1 = mid - left, n2 = right - mid;\n  REP(i,n1)L[i]=A[left+i];\n  REP(i,n2)R[i]=A[mid+i];\n  for(int k =left,i=0,j=0;k<right;k++){\n    if(n2<=j)A[k]=L[i++];\n    else if(n1<=i)A[k]=R[j++];\n    else A[k]=rh(L[i],R[i])?L[i++]:R[j++];\n  }\n}\n\nvoid mergeSort(int *A,const int left,const int right, const RollingHash &rh){\n  if(left+1<right){\n    const int mid = (left+right)/2;\n    mergeSort(A,left,mid, rh);\n    mergeSort(A,mid,right, rh);\n    merge(A,left,mid,right, rh);\n  }\n}\n\n//O(n (log n)^2)\nvector<int> suffixArray(const RollingHash &rh){\n  int n=rh.n+1,sa[n];\n  REP(i,n)sa[i]=i;\n  //mergesort(n,sa,rh);\n  mergeSort(sa,0,n,rh);\n  vector<int>res(n);\n  REP(i,n)res[i]=sa[i];\n  return res;\n}\n\nbool contain(const string &S, const vector<int> &sa, const string &T){\n  int a=0, b=SZ(S);\n  while(b-a>1){\n    const int c=(a+b)/2;\n    (S.compare(sa[c],T.length(),T)<0 ? a : b ) = c;\n  }\n  return S.compare(sa[b], T.length(), T) == 0;\n}\n\nint main(void){\n\n  char str[1000002];\n  string s,t;\n  scanf(\"%s\",str);\n  s=str;\n  \n  RollingHash rh=RollingHash(s);\n  vector<int>sa=suffixArray(rh);\n  \n  int n;\n  cin >> n;\n\n  while(n--){\n    scanf(\"%s\",str);\n    t=str;\n    printf(\"%d\\n\",contain(s,sa,t));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct SuffixArray{\n  int n,k;\n  string S;\n  vector<int> sa,lcp;\n  SuffixArray(){}\n  SuffixArray(string S):S(S){init();}\n  void init(){\n    n=S.length();\n    sa.clear();\n    lcp.clear();\n    sa.resize(n+1,0);\n    lcp.resize(n+1,0);\n    build_sa();\n    build_lcp();\n    build_rmq();\n  }\n  void build_sa(){\n    S.push_back('$');\n    vector<int> c(n+1,0),ord(n+1,0);\n    for(int i=0;i<=n;i++) ord[i]=n-i;\n    sort(ord.begin(),ord.end(),[&](int a,int b){return S[a]<S[b];});\n    \n    for(int i=0;i<=n;i++){\n      sa[i]=ord[i];\n      c[i]=S[i];\n    }\n    \n    for(int len=1;len<=n;len*=2){\n      vector<int> r=c;\n      for(int i=0;i<=n;i++){\n\t c[sa[i]] = i > 0 && r[sa[i - 1]] == r[sa[i]] && sa[i - 1] + len <= n && r[sa[i - 1] + len / 2] == r[sa[i] + len / 2] ? c[sa[i - 1]] : i;\n      }\n      vector<int> cnt(n+1);\n      for(int i=0;i<=n;i++) cnt[i]=i;\n      vector<int> s=sa;\n      for(int i=0;i<=n;i++){\n\tint s1=s[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n    }\n    S.pop_back();\n  }\n  bool contains(string T){\n    int a=0,b=n+1;\n    while(a+1<b){\n      int c=(a+b)/2;\n      if(S.compare(sa[c],T.length(),T)<0) a=c;\n      else b=c;\n    }\n    if(b==n+1) b--;\n    return S.compare(sa[b],T.length(),T)==0;\n  }\n  \n  // O(|T|*log|S|)\n  int count(string T){\n    int sl=S.length(),tl=T.length();\n    int a[2],b[2];\n    for(int i=0;i<2;i++){\n      a[i]=0;\n      b[i]=sl;\n      while(a[i]+1<b[i]){\n    int c=(a[i]+b[i])/2;\n    if(S.compare(sa[c],tl,T)<0||\n       (i&&S.compare(sa[c],tl,T)==0)) a[i]=c;\n    else b[i]=c;\n      }\n    }\n    if(S.compare(sa[b[0]],tl,T)!=0) return 0;\n    if(a[1]<sl&&S.compare(sa[a[1]+1],tl,T)==0) a[1]++;\n    if(b[0]> 0&&S.compare(sa[b[0]-1],tl,T)==0) b[0]--;\n    return a[1]-b[0]+1;\n  }\n  \n  void build_lcp(){\n    vector<int> r2(n);\n    for(int i=0;i<n;i++) r2[sa[i]]=i;\n    int h=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  int getlcp(int p,string &T,int d){\n    int i=0;\n    int len=min((int)T.length()-d,(int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    int n;\n    vector<int> dat;\n    const int def=INT_MAX;\n    RMQ(){}\n    RMQ(int n_){init(n_);}\n    RMQ(int n_,vector<int>& a){init(n_);build(n_,a);}\n    void init(int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(int n_, vector<int>& a){\n      for(int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    void update(int k,int a){\n      k+=n-1;\n      dat[k]=a;\n      while(k>0){\n\tk=(k-1)/2;\n\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n      }\n    }\n    int query(int a,int b,int k,int l,int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    int query(int a,int b){\n      return query(a,b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n  \n  // O(|T|+log|S|)\n  int count2(string T){\n    int a[2],b[2];\n    int sl=S.length(),tl=T.length();\n    for(int i=0;i<2;i++){\n      int p,l,r;\n      p=tl;\n      a[i]=0;\n      b[i]=sl;\n      l=getlcp(sa[a[i]],T,0);\n      r=getlcp(sa[b[i]],T,0);\n      while(a[i]+1<b[i]){\n\tint c=(a[i]+b[i])/2;\n\t//cout<<a[i]<<\" \"<<b[i]<<\" \"<<c<<endl;\n\tif(l>=r){\n\t  int m=rmq.query(a[i],c);\n\t  if(m<l) b[i]=c,r=m;\n\t  else{\n\t    int k=l+getlcp(sa[c],T,l);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}else{\n\t  int m=rmq.query(c,b[i]);\n\t  if(m<r) a[i]=c,l=m;\n\t  else{\n\t    int k=r+getlcp(sa[c],T,r);\n\t    if(i){\n\t      if(k==p||S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }else{\n\t      if(k==p) b[i]=c,r=k;\n\t      else if(S[sa[c]+k]<T[k]) a[i]=c,l=k;\n\t      else b[i]=c,r=k;\n\t    }\n\t  }\n\t}\n      }\n    }\n   \n    if(a[1]<sl&&getlcp(sa[a[1]+1],T,0)==tl) a[1]++;\n    if(b[0]> 0&&getlcp(sa[b[0]-1],T,0)==tl) b[0]--;\n   \n    if(getlcp(sa[b[0]],T,0)!=tl) return 0;\n   \n    return a[1]-b[0]+1;\n  }\n};\n//END CUT HERE\n\nchar buf[1000001];\nsigned main(){\n  scanf(\"%s\",buf);\n  string T(buf);\n  SuffixArray sa(T);\n  return 0;\n  int q;\n  scanf(\"%lld\",&q);\n  while(q--){\n    scanf(\"%s\",buf);\n    string P(buf);\n    printf(\"%lld\\n\",(int)sa.contains(P));\n    //assert(sa.count(P)==sa.count2(P));\n  }\n  return 0;\n}\n/*\nverified on 2017/10/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_D\n*/"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint max(int a, int b){\n  if( a > b )\n    return a;\n  return b;\n}\n\nint BM_search(char *T, char *P){\n\n  int shift[256];\n  int i,j,t_len,p_len;\n\n  t_len = strlen(T);\n  p_len = strlen(P);\n\n  for( i = 0 ; i < 256 ; i++ ){\n    shift[i] = p_len;\n  }\n  \n  for( i = 0 ; i < p_len-1 ; i++ ){\n    shift[P[i]] = p_len-i-1;\n  }\n\n  i = p_len;\n\n  while( i < t_len ){\n\n    j = p_len-1;\n\n    while( T[i] == P[j] ){\n\n      if( j == 0 ){\n        return i;\n      }\n\n      i--;\n      j--;\n   \n    }\n\n    i = i+max(shift[T[i]],p_len-j);\n\n\n  }\n\n  return -1;\n\n}\n\nint main(int argc, char const *argv[]) {\n\n  char T[1000001];\n  char P[1001];\n  int i;\n  int n;\n\n  scanf(\"%s\",T);\n  scanf(\"%d\",&n);\n\n  for( i = 0 ; i < n ; i++ ){\n    scanf(\"%s\",P);\n\n    if( BM_search(T,P) == -1 ){\n      printf(\"0\\n\");\n    }else{\n      printf(\"1\\n\");\n    }\n\n  }\n  \n  return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define NOTFOUND 256\n\nvoid Search(char *P,int Plen,char *T,int Tlen,int *MoveP)\n{\n    int i,initMP[NOTFOUND],cnt = 0,j,flg,nflg=0;\n    \n    /* 配列の初期化 */\n    for( i=1 ; i<=Plen ; i++)\n    {\n        if(i-1 < MoveP[(unsigned int)P[Plen-i]])\n        {\n            MoveP[(unsigned int)P[Plen-i]] = i-1;\n            //printf(\"MoveP = %d,\",MoveP[(unsigned int)P[Plen-i]]);\n            initMP[cnt] = (unsigned int)P[Plen-i];\n            cnt++;\n        }\n    }\n    //printf(\"\\n\");\n    \n    /* 変更のよちあり・？？ */\n    for( i=0 ; i<=Tlen-Plen ; i++ )\n    {\n        flg = 0;\n        if(T[Plen+i-1] == P[Plen-1])\n        {\n            for( j=1 ; j<=Plen ; j++)\n            {\n                //printf(\"%c,%c\\n\",T[Plen+i-j],P[Plen-j]);\n                if(T[Plen+i-j] != P[Plen-j])\n                {\n                    flg = 1;\n                    //printf(\"P = %c,i = %d =>\",P[Plen-j],i);\n                    i += MoveP[(unsigned int)P[Plen-j]];\n                    //printf(\"%d,i++%d\\n\",i,MoveP[(unsigned int)P[Plen-j]]);\n                    break;\n                }\n            }\n            if(flg == 0)\n            {\n                printf(\"1\\n\");\n                nflg = 1;\n                break;\n            }\n        }\n    }\n    /* ここまで、確認すべし */\n    \n    if(nflg == 0)\n    {\n        printf(\"0\\n\");\n    }\n    /* MovePを初期化 */\n    for( i=0 ; i<cnt ; i++)\n    {\n        MoveP[initMP[i]] = NOTFOUND;\n    }\n    \n}\n\n\nint main(){\n    int n,i,j,Tlen,Plen,MoveP[NOTFOUND];\n    char T[1000000],P[1000];\n    scanf(\"%s\",T);\n    scanf(\"%d\",&n);\n    Tlen = strlen(T);\n    \n    /* ずらし表の初期化(NOTFOUNDであればPlen分進ませる) */\n    for( i=0 ; i<NOTFOUND ; i++)\n    {\n        MoveP[i] = NOTFOUND;\n    }\n    \n    for( i=0 ; i<n ; i++ )\n    {\n        scanf(\"%s\",P);\n        Plen = strlen(P);\n        Search(P,Plen,T,Tlen,MoveP);\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <float.h>\n#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_T 1000000\n#define MAX_P 1000\n\ntypedef double INT;\nconst INT INT_MAX = (1LL << DBL_MANT_DIG) - 1LL;\nconst INT INT_MIN = - ((1LL << DBL_MANT_DIG) - 1LL);\n\n#define CHECK(n) assert( n >= INT_MIN && n <= INT_MAX );\n\nINT add(INT a, INT b) {\n  INT res = a + b;\n  CHECK(res);\n  return res;\n}\n\nINT mult(INT a, INT b) {\n  INT res = a * b;\n  CHECK(res);\n  return res;\n}\n\nINT sub(INT a, INT b) {\n  INT res = a - b;\n  CHECK(res);\n  assert(a - res == b && res + b == a);\n  return res;\n}\n\nINT mod(INT a, INT b) {\n  INT res = fmod(a, b);\n  if (res < -0.0) res += b;\n  return res;\n}\n\nINT modulo_powered_number(INT base, int power, INT modulo) {\n  if (power == 0) return 1;\n  int max_digit = ceil(log2(power));\n  INT mem[max_digit+1];\n  mem[0] = mod(base, modulo);\n  for (int i = 1; i <= max_digit; ++i)\n    mem[i] = mod(mult(mem[i-1], mem[i-1]), modulo);\n  INT res = 1;\n  for (int i = 0; i <= max_digit; ++i)\n    if (power & (1 << i)) res = mod(mult(res, mem[i]), modulo);\n  return res;\n}\n\nbool isEqual(char *start1, char *end1, char *start2, char *end2) {\n  assert(end1 - start1 == end2 - start2);\n  while (start1 <= end1) {\n    if (*start1 != *start2) return false;\n    ++start1;\n    ++start2;\n  }\n  return true;\n}\n\nint rabinKarpMatcher(char *T, char *P, INT d, INT q) {\n  int n = strlen(T);\n  int m = strlen(P);\n  if (n < m) return 0;\n  --T; // start0 -> start1\n  --P; // start0 -> start1\n  INT h = modulo_powered_number(d, m - 1, q);\n  INT p = 0;\n  INT t[n - m + 1];\n  t[0] = 0;\n  for (int i = 1; i <= m; ++i) { // preprocess\n    p = mod(add(mult(d, p), P[i]), q);\n    t[0] = mod(add(mult(d, t[0]), T[i]), q);\n  }\n  for (int s = 0; s <= n - m; ++s) { // matching\n    if (p == t[s]) {\n      if (isEqual(P+1, P+m, T+s+1, T+s+m)) {\n        //printf(\"pattern match at shift %d\\n\", s);\n        return 1;\n      }\n    }\n    if (s < n - m)\n      t[s+1] =\n        mod(\n          add(\n            mult(d, sub(t[s], mult(T[s+1], h))),\n            T[s+m+1]),\n          q);\n  }\n  return 0;\n}\n\nint main() {\n  assert(DBL_MANT_DIG == 53);\n\n  char *T = (char *)malloc(MAX_T+1);\n  if (T == NULL) {\n    printf(\"memory shortage.\\n\");\n    return 1;\n  }\n\n  scanf(\"%s\", T);\n  int q = 0;\n  scanf(\"%d\", &q);\n\n  char P[MAX_P+1];\n  for (int i = 0; i < q; ++i) {\n    scanf(\"%s\", P);\n    printf(\"%d\\n\", rabinKarpMatcher(T, P, 256, (1 << 25) - 39));\n  }\n  free(T);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N_T 1000001\n#define N_P 1001\n#define BASE 64\n\nint* kmpSearch(char*, char*);\nint* initNext(char*);\n\nint myIndex(char);\n\nint main() {\n  char T[N_T];\n  char P[N_P];\n  int* pos;\n\n  int i;\n  int Q;\n    \n  scanf(\"%s\", T);\n  scanf(\"%d\", &Q);\n  for (i = 0; i < Q; ++i) {\n    scanf(\"%s\", P);\n    pos = kmpSearch(T, P);\n    printf(\"%d\\n\", pos[0]?1:0);\n    free(pos);\n  }\n\n  return 0;\n}\n\nint* kmpSearch(char* T, char* P) {\n  int i, j;\n  int cnt = 0;\n  int M   = strlen(P);\n  int N   = strlen(T);\n  \n  int* next;\n  int* pos;\n\n  //printf(\"%d %d\", M, N);\n  \n  if (N < M) {\n    pos    = (int*)malloc(sizeof(int)*1);\n    pos[0] = 0;\n    return pos;\n  } else {\n    pos = (int*)malloc(sizeof(int)*(N-M+2));\n  }\n  \n  next = initNext(P);  \n  for (i = 0, j = 0; i < N; ++i, ++j) {\n    while ((j >= 0) && (T[i] != P[j])){\n      j = next[j];\n    }\n\n    if (j == M - 1) {\n      cnt++;\n      pos[cnt] = i - M + 1;\n\n      pos[0] = cnt;\n      free(next);\n      return pos;\n      \n      do {\n\tj = next[j];\n      }\twhile ((j >= 0) && (T[i] != P[j]));\n    }\n  }\n  pos[0] = cnt;\n\n  free(next);\n  \n  return pos;\n}\n\nint* initNext(char* P){\n  int i, j;\n  int M = strlen(P);\n  int* next = (int*)malloc(sizeof(int)*(M+1));\n\n  next[0] = -1;\n  for (i = 0, j = -1; i < M; ++i, ++j, next[i] = j) {\n    while ((j >= 0) && (P[i] != P[j])) {\n      j = next[j];\n    }\n  }\n  \n  return next;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<ctype.h>\n#include<limits.h>\n\n#define TMAX 1000001\n#define PMAX 10001\n\nint min(int a,int b){\n if(a > b)return b;\n return a;\n}\n\nint max(int a,int b){\n if(a > b)return a;\n return b;\n}\n\nint tblnum[30];\nint tbllow[30];\nint tblup[30];\n\n\nvoid maketable(char P[]){\n int i;\n int PL=strlen(P);\n\n for(i=0;i<30;i++){\n     tblnum[i]=INT_MAX;\n     tbllow[i]=INT_MAX;\n     tblup[i]=INT_MAX;\n }\n\n for(i=0;i<PL;i++){\n\n     if(isdigit(P[i]))\n        tblnum[P[i]-'0']=min(tblnum[P[i]-'0'],PL-1-i);\n\n     else if(islower(P[i]))\n        tbllow[P[i]-'a']=min(tbllow[P[i]-'a'],PL-1-i);\n\n     else if(isupper(P[i]))\n        tblup[P[i]-'A']=min(tblup[P[i]-'A'],PL-1-i);\n\n }\n\n\n for(i=0;i<30;i++){\n     if(tblnum[i]==INT_MAX)tblnum[i]=PL;\n     if(tbllow[i]==INT_MAX)tbllow[i]=PL;\n     if(tblup[i]==INT_MAX)tblup[i]=PL;\n }\n\n\n return;\n}\n\n\nint WidthCheck(char c){\n\n if(isdigit(c))return tblnum[c-'0'];\n\n if(islower(c))return tbllow[c-'a'];\n\n if(isupper(c))return tblup[c-'A'];\n\n}\n\n\nint main(){\n char T[TMAX];\n char P[PMAX];\n int i,TL,PL,n;\n int end;\n int width;\n int R;\n\n scanf(\"%s\",T);\n\n scanf(\"%d\",&n);\n\n for(i=0;i<n;i++){\n\n     scanf(\"%s\",P);\n     maketable(P);\n\n     TL=strlen(T); PL=strlen(P);\n\n     end=PL-1;\n     while(end < TL){\n\n           for(i=end;i>end-PL;i--){\n\n              if(P[PL-1-(end-i)]!=T[i]){\n                 width=WidthCheck(T[i]);\n                 end=max(end+1,i+width);\n                 break;\n              }\n\n              if(i==end-PL+1){\n                 printf(\"1\\n\");\n                 break;\n              }\n\n           }\n           if(i==end-PL+1)break;\n\n     }\n\n     if(i!=end-PL+1 && end>=TL)printf(\"0\\n\");\n\n }\nreturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N_T 1000001\n#define N_P 1001\n#define BASE 64\n\nint* kmpSearch(char*, char*);\nint* initNext(char*);\n\nint myIndex(char);\n\nint main() {\n  char T[N_T];\n  char P[N_P];\n  int* pos;\n\n  int i;\n  int Q;\n    \n  scanf(\"%s\", T);\n  scanf(\"%d\", &Q);\n  for (i = 0; i < Q; ++i) {\n    scanf(\"%s\", P);\n    pos = kmpSearch(T, P);\n    printf(\"%d\\n\", pos[0]?1:0);\n    free(pos);\n  }\n\n  return 0;\n}\n\nint* kmpSearch(char* T, char* P) {\n  int i, j;\n  int cnt = 0;\n  int M   = strlen(P);\n  int N   = strlen(T);\n  \n  int* next;\n  int* pos;\n\n  //printf(\"%d %d\", M, N);\n  \n  if (N < M) {\n    pos    = (int*)malloc(sizeof(int)*1);\n    pos[0] = 0;\n    return pos;\n  } else {\n    pos = (int*)malloc(sizeof(int)*(N));\n  }\n  \n  next = initNext(P);  \n  for (i = 0, j = 0; i < N; ++i, ++j) {\n    while ((j >= 0) && (T[i] != P[j])){\n      j = next[j];\n    }\n\n    if (j == M - 1) {\n      cnt++;\n      pos[cnt] = i - M + 1;\n\n      do {\n\tj = next[j];\n      }\twhile ((j >= 0) && (T[i] != P[j]));\n    }\n  }\n  pos[0] = cnt;\n\n  free(next);\n  \n  return pos;\n}\n\nint* initNext(char* P){\n  int i, j;\n  int M = strlen(P);\n  int* next = (int*)malloc(sizeof(int)*M*2);\n\n  next[0] = -1;\n  for (i = 0, j = -1; i < M; ++i, ++j, next[i] = j) {\n    while ((j >= 0) && (P[i] != P[j])) {\n      j = next[j];\n    }\n  }\n  \n  return next;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define M 1000000\n#define N 1000\n\nint main(){\n\n int i;\n int j;\n int num;\n int str_length;\n int cmp_length;\n char *str;\n char *cmp;\n\n  str = (char *)malloc(sizeof(char) * M);\n\n  scanf(\"%s\",str);\n  str_length = strlen(str);\n\n  scanf(\"%d\",&num);\n  for(i=0;i<num;i++){\n  cmp = (char *)malloc(sizeof(char) * N);\n  scanf(\"%s\",cmp);\n  cmp_length = strlen(cmp);\n  for(j=0;j<str_length;j++){\n\n  if( strncmp(str+j,cmp,cmp_length) ==0 ){\n  printf(\"1\\n\");\n  break;\n  }\n\n  if(j==str_length-1){\n  printf(\"0\\n\");\n  }\n\n   }\n  free(cmp);\n  }\n\n return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <float.h>\n#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_T 1000000\n#define MAX_P 1000\n\ntypedef double INT;\nconst INT INT_MAX = (1LL << DBL_MANT_DIG) - 1LL;\nconst INT INT_MIN = - ((1LL << DBL_MANT_DIG) - 1LL);\n\n#define CHECK(n) assert( n >= INT_MIN && n <= INT_MAX );\n\nINT add(INT a, INT b) {\n  INT res = a + b;\n  CHECK(res);\n  return res;\n}\n\nINT mult(INT a, INT b) {\n  INT res = a * b;\n  CHECK(res);\n  return res;\n}\n\nINT sub(INT a, INT b) {\n  INT res = a - b;\n  CHECK(res);\n  assert(a - res == b && res + b == a);\n  return res;\n}\n\nINT mod(INT a, INT b) {\n  INT res = fmod(a, b);\n  if (res < -0.0) res += b;\n  return res;\n}\n\nINT modulo_powered_number(INT base, int power, INT modulo) {\n  int max_digit = ceil(log2(power));\n  INT mem[max_digit+1];\n  mem[0] = mod(base, modulo);\n  for (int i = 1; i <= max_digit; ++i)\n    mem[i] = mod(mult(mem[i-1], mem[i-1]), modulo);\n  INT res = 1;\n  for (int i = 0; i <= max_digit; ++i)\n    if (power & (1 << i)) res = mod(mult(res, mem[i]), modulo);\n  return res;\n}\n\nbool isEqual(char *start1, char *end1, char *start2, char *end2) {\n  assert(end1 - start1 == end2 - start2);\n  while (start1 <= end1) {\n    if (*start1 != *start2) return false;\n    ++start1;\n    ++start2;\n  }\n  return true;\n}\n\nint rabinKarpMatcher(char *T, char *P, INT d, INT q) {\n  int n = strlen(T);\n  int m = strlen(P);\n  --T; // start0 -> start1\n  --P; // start0 -> start1\n  INT h = modulo_powered_number(d, m - 1, q);\n  INT p = 0;\n  INT t[n - m + 1];\n  t[0] = 0;\n  for (int i = 1; i <= m; ++i) { // preprocess\n    p = mod(add(mult(d, p), P[i]), q);\n    t[0] = mod(add(mult(d, t[0]), T[i]), q);\n  }\n  for (int s = 0; s <= n - m; ++s) { // matching\n    if (p == t[s]) {\n      if (isEqual(P+1, P+m, T+s+1, T+s+m)) {\n        //printf(\"pattern match at shift %d\\n\", s);\n        return 1;\n      }\n    }\n    if (s < n - m)\n      t[s+1] =\n        mod(\n          add(\n            mult(d, sub(t[s], mult(T[s+1], h))),\n            T[s+m+1]),\n          q);\n  }\n  return 0;\n}\n\nint main() {\n  assert(DBL_MANT_DIG == 53);\n\n  char *T = (char *)malloc(MAX_T+1);\n  if (T == NULL) {\n    printf(\"memory shortage.\\n\");\n    return 1;\n  }\n\n  scanf(\"%s\", T);\n  int q = 0;\n  scanf(\"%d\", &q);\n\n  char P[MAX_P+1];\n  for (int i = 0; i < q; ++i) {\n    //printf(\"i = %d\\n\", i);\n    scanf(\"%s\", P);\n    printf(\"%d\\n\", rabinKarpMatcher(T, P, 256, (1 << 25) - 39));\n  }\n  free(T);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<ctype.h>\n#include<limits.h>\n\n#define TMAX 1000001\n#define PMAX 10001\n\nint min(int a,int b){\n if(a > b)return b;\n return a;\n}\n\nint max(int a,int b){\n if(a > b)return a;\n return b;\n}\n\nint tblnum[30];\nint tbllow[30];\nint tblup[30];\n\n\nvoid maketable(char P[]){\n int i;\n int PL=strlen(P);\n\n for(i=0;i<30;i++){\n     tblnum[i]=INT_MAX;\n     tbllow[i]=INT_MAX;\n     tblup[i]=INT_MAX;\n }\n\n for(i=0;i<PL;i++){\n\n     if(isdigit(P[i]))\n        tblnum[P[i]-'0']=min(tblnum[P[i]-'0'],PL-1-i);\n\n     else if(islower(P[i]))\n        tbllow[P[i]-'a']=min(tbllow[P[i]-'a'],PL-1-i);\n\n     else if(isupper(P[i]))\n        tblup[P[i]-'A']=min(tblup[P[i]-'A'],PL-1-i);\n\n }\n\n\n for(i=0;i<30;i++){\n     if(tblnum[i]==INT_MAX)tblnum[i]=PL;\n     if(tbllow[i]==INT_MAX)tbllow[i]=PL;\n     if(tblup[i]==INT_MAX)tblup[i]=PL;\n }\n\n\n return;\n}\n\n\nint WidthCheck(char c){\n\n if(isdigit(c))return tblnum[c-'0'];\n\n if(islower(c))return tbllow[c-'a'];\n\n if(isupper(c))return tblup[c-'A'];\n\n}\n\n\nint main(){\n char T[TMAX];\n char P[PMAX];\n int i,j,TL,PL,n;\n int end;\n int width;\n int flg;\n\n scanf(\"%s\",T);\n\n scanf(\"%d\",&n);\n\n for(j=0;j<n;j++){\n\n     flg=0;\n     scanf(\"%s\",P);\n     maketable(P);\n\n     TL=strlen(T); PL=strlen(P);\n\n     end=PL-1;\n     while(end < TL){\n\n           for(i=end;i>end-PL;i--){\n\n               if(P[PL-1-(end-i)]!=T[i]){\n                  width=WidthCheck(T[i]);\n                  end=max(end+1,i+width);\n                  break;\n               }\n\n               if(i==end-PL+1){\n                  printf(\"1\\n\");\n                  flg=1;\n                  break;\n               }\n\n            }\n\n            if(flg==1)break;\n     }\n\n     if(flg==0)printf(\"0\\n\");\n\n }\nreturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#define MAX_T 1000000\n#define MAX_P 1000\n\ntypedef unsigned long long INT;\n\nconst INT PRIME = 257;\n\nstatic inline INT mult_prime(INT n) {\n  return n + (n << 8);\n}\n\n// q = 2^64\nint rabinKarpMatcher(char *T, char *P, INT *t, INT *d) {\n  int n = strlen(T);\n  int m = strlen(P);\n  --T; // start0 -> start1\n  --P; // start0 -> start1\n  INT h = 1;\n  for (int i = 0; i <= 11; ++i)\n    if ((m - 1) & (1 << i)) h *= d[i];\n  INT p = 0;\n  t[0] = 0;\n  for (int i = 1; i <= m; ++i) { // preprocess\n    p = mult_prime(p) + P[i]; // mod 2^64\n    t[0] = mult_prime(t[0]) + T[i]; // mod 2^64\n  }\n  for (int s = 0; s <= n - m; ++s) { // matching\n    if (p == t[s]) {\n      //if (strncmp(P+1, T+s+1, m) == 0) {\n      if (1) { // ignore simple check\n        //printf(\"pattern match at shift %d\\n\", s);\n        return 1;\n      }\n    }\n    if (s < n - m)\n      t[s+1] = mult_prime(t[s] - T[s+1] * h) + T[s+m+1]; // mod 2^64\n  }\n  return 0;\n}\n\nint main() {\n  assert(sizeof(INT) == 8);\n\n  // d = [PRIME^1, PRIME^2, PRIME^4, ...]\n  INT d[64];\n  d[0] = PRIME;\n  for (int i = 1; i < 64; ++i)\n    d[i] = d[i-1] * d[i-1];\n\n  char *T = (char *)malloc(MAX_T+1);\n  if (T == NULL) {\n    printf(\"memory shortage.\\n\");\n    return 1;\n  }\n  INT *t = (INT *)malloc((MAX_T+1)*sizeof(INT));\n  if (t == NULL) {\n    printf(\"memory shortage.\\n\");\n    free(T);\n    return 1;\n  }\n\n  scanf(\"%s\", T);\n  int q = 0;\n  scanf(\"%d\", &q);\n\n  char P[MAX_P+1];\n  for (int i = 0; i < q; ++i) {\n    scanf(\"%s\", P);\n    printf(\"%d\\n\", rabinKarpMatcher(T, P, t, d));\n  }\n  free(T);\n  free(t);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define M 1000000\n#define N 1000\n\nint main(){\n\n int i;\n int j;\n int num;\n int str_length;\n int cmp_length;\n char *str;\n char *cmp;\n\n  str = (char *)malloc(sizeof(char) * M);\n  cmp = (char *)malloc(sizeof(char) * N);\n\n  scanf(\"%s\",str);\n  str_length = strlen(str);\n\n  scanf(\"%d\",&num);\n  for(i=0;i<num;i++){\n  scanf(\"%s\",cmp);\n  cmp_length = strlen(cmp);\n  for(j=0;j<str_length;j++){\n\n  if( strncmp(str+j,cmp,cmp_length) ==0 ){\n  printf(\"1\");\n  break;\n  }\n\n  if(j==str_length-1){\n  printf(\"0\");\n  }\n\n   }\n  }\n\n  return 0;"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define NOTFOUND 256\n\nvoid Search(char *P,int Plen,char *T,int Tlen,int *MoveP)\n{\n    int i,initMP[NOTFOUND],cnt = 0,j,flg,nflg=0;\n    \n    /* 配列の初期化 */\n    for( i=1 ; i<=Plen ; i++)\n    {\n        if(i-1 < MoveP[(unsigned int)P[Plen-i]])\n        {\n            MoveP[(unsigned int)P[Plen-i]] = i-1;\n            //printf(\"MoveP = %d,\",MoveP[(unsigned int)P[Plen-i]]);\n            initMP[cnt] = (unsigned int)P[Plen-i];\n            cnt++;\n        }\n    }\n    //printf(\"\\n\");\n    \n    for( i=0 ; i<=Tlen-Plen ; i++ )\n    {\n        flg = 0;\n        if(T[Plen+i-1] == P[Plen-1])\n        {\n            for( j=1 ; j<=Plen ; j++)\n            {\n                //printf(\"%c,%c\\n\",T[Plen+i-j],P[Plen-j]);\n                if(T[Plen+i-j] != P[Plen-j])\n                {\n                    flg = 1;\n                    //printf(\"P = %c,i = %d =>\",P[Plen-j],i);\n                    i += MoveP[(unsigned int)P[Plen-j]];\n                    //printf(\"%d,i++%d\\n\",i,MoveP[(unsigned int)P[Plen-j]]);\n                    break;\n                }\n            }\n            if(flg == 0)\n            {\n                printf(\"1\\n\");\n                nflg = 1;\n                break;\n            }\n        }\n    }\n    \n    if(nflg == 0)\n    {\n        printf(\"0\\n\");\n    }\n    /* MovePを初期化 */\n    for( i=0 ; i<cnt ; i++)\n    {\n        MoveP[initMP[i]] = NOTFOUND;\n    }\n    \n}\n\n\nint main(){\n    int n,i,j,Tlen,Plen,MoveP[NOTFOUND];\n    char T[1000000],P[1000];\n    scanf(\"%s\",T);\n    scanf(\"%d\",&n);\n    Tlen = strlen(T);\n    \n    /* ずらし表の初期化(NOTFOUNDであればPlen分進ませる) */\n    for( i=0 ; i<NOTFOUND ; i++)\n    {\n        MoveP[i] = NOTFOUND;\n    }\n    \n    for( i=0 ; i<n ; i++ )\n    {\n        scanf(\"%s\",P);\n        Plen = strlen(P);\n        Search(P,Plen,T,Tlen,MoveP);\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<ctype.h>\n#include<limits.h>\n\n#define TMAX 1000001\n#define PMAX 10001\n\nint min(int a,int b){\n if(a > b)return b;\n return a;\n}\n\nint max(int a,int b){\n if(a > b)return a;\n return b;\n}\n\nint tblnum[30];\nint tbllow[30];\nint tblup[30];\n\n\nvoid maketable(char P[]){\n int i;\n int PL=strlen(P);\n\n for(i=0;i<30;i++){\n     tblnum[i]=INT_MAX;\n     tbllow[i]=INT_MAX;\n     tblup[i]=INT_MAX;\n }\n\n for(i=0;i<PL;i++){\n\n     if(isdigit(P[i]))\n        tblnum[P[i]-'0']=min(tblnum[P[i]-'0'],PL-1-i);\n\n     else if(islower(P[i]))\n        tbllow[P[i]-'a']=min(tbllow[P[i]-'a'],PL-1-i);\n\n     else if(isupper(P[i]))\n        tblup[P[i]-'A']=min(tblup[P[i]-'A'],PL-1-i);\n\n }\n\n\n for(i=0;i<30;i++){\n     if(tblnum[i]==INT_MAX)tblnum[i]=PL;\n     if(tbllow[i]==INT_MAX)tbllow[i]=PL;\n     if(tblup[i]==INT_MAX)tblup[i]=PL;\n }\n\n\n return;\n}\n\n\nint WidthCheck(char c){\n\n if(isdigit(c))return tblnum[c-'0'];\n\n if(islower(c))return tbllow[c-'a'];\n\n if(isupper(c))return tblup[c-'A'];\n\n}\n\n\nint main(){\n char T[TMAX];\n char P[PMAX];\n int i,j,TL,PL,n;\n int end;\n int width;\n int flg;\n\n scanf(\"%s\",T);\n\n scanf(\"%d\",&n);\n\n for(j=0;j<n;j++){\n\n     flg=0;\n     scanf(\"%s\",P);\n     maketable(P);\n\n     TL=strlen(T); PL=strlen(P);\n\n     end=PL-1;\n     while(end < TL){\n\n           for(i=end;i>end-PL;i--){\n\n               if(P[PL-1-(end-i)]!=T[i]){\n                  width=WidthCheck(T[i]);\n                  end=max(end+1,i+width);\n                  break;\n               }\n\n               if(i==end-PL+1){\n                  printf(\"1\\n\");\n                  flg=1;\n                  break;\n               }\n\n            }\n\n            if(flg==1)break;\n     }\n\n     if(flg==0)printf(\"0\\n\");\n\n }\nreturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_T 1000000\n#define MAX_P 1000\n\nint kmpMatcher(char *t, int tlen, char *p, int plen);\nvoid computePrefixFunction(char *p, int plen, int *pi);\nint main();\n\n/* t, p is start from 1. */\nint kmpMatcher(char *t, int tlen, char *p, int plen) {\n  int n, m;\n  int pi_start_from_0[MAX_P];\n  int *pi = pi_start_from_0 - 1;\n  int q, i;\n\n  n = tlen;\n  m = plen;\n  computePrefixFunction(p, plen, pi);\n  q = 0;\n  for (i = 1; i <= n; i++) {\n    while (q > 0 && p[q+1] != t[i])\n      q = pi[q];\n    if (p[q+1] == t[i])\n      q++;\n    if (q == m) {\n      /* printf(\"pattern is found at shift %d.\\n\", i - m); */\n      return 1;\n      q = pi[q];\n    }\n  }\n  return 0;\n}\n\n/* p, pi is start from 1. */\nvoid computePrefixFunction(char *p, int plen, int *pi) {\n  int m, k, q;\n  m = plen;\n  pi[1] = 0;\n  k = 0;\n  for (q = 2; q <= m; q++) {\n    while (k > 0 && p[k+1] != p[q])\n      k = pi[k];\n    if (p[k+1] == p[q])\n      k++;\n    pi[q] = k;\n  }\n}\n\nint main() {\n  char *t_start_from_0 = (char *)malloc(MAX_T+1);\n  char *t = t_start_from_0 - 1;\n  int tlen = 0;\n  char p_start_from_0[MAX_P+1];\n  char *p = p_start_from_0 - 1;\n  int plen = 0;\n  int q = 0;\n  int i;\n\n  if (t_start_from_0 == NULL) {\n    printf(\"memory shortage.\\n\");\n    return 1;\n  }\n\n  scanf(\"%s\", t_start_from_0);\n  tlen = strlen(t_start_from_0);\n  scanf(\"%d\", &q);\n\n  for (i = 0; i < q; i++) {\n    scanf(\"%s\", p_start_from_0);\n    plen = strlen(p_start_from_0);\n    printf(\"%d\\n\", kmpMatcher(t, tlen, p, plen));\n  }\n\n  free(t_start_from_0);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "\ndef isEqual(T,P):\n    for i in range(len(T)-len(P)+1):\n        if T[i:i+len(P)] == P:\n            return 1\n    return 0\n\nT = input()\nn = int(input())\n\nfor i in range(n):\n    P = input()\n    print(isEqual(T,P))"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define M 1000000\n#define N 1000\n\nint main(){\n\n int i;\n int j;\n int num;\n int str_length;\n int cmp_length;\n char *str;\n char *cmp;\n\n  str = (char *)malloc(sizeof(char) * M);\n  cmp = (char *)malloc(sizeof(char) * N);\n\n  scanf(\"%s\",str);\n  str_length = strlen(str);\n\n  scanf(\"%d\",&num);\n  for(i=0;i<num;i++){\n  cmp = (char *)malloc(sizeof(char) * N);\n  scanf(\"%s\",cmp);\n  cmp_length = strlen(cmp);\n  for(j=0;j<str_length;j++){\n\n  if( strncmp(str+j,cmp,cmp_length) ==0 ){\n  printf(\"1\\n\");\n  break;\n  }\n\n  if(j==str_length-1){\n  printf(\"0\\n\");\n  }\n\n   }\n  free(cmp);\n  }\n\n return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(){\n    char indata[1000000];\n    int i,j,n,in,ln;\n    \n    scanf(\"%s\",indata);\n    scanf(\"%d\",&n);\n    char load[n][1000];\n    for(i=0;i<n;i++)\n        scanf(\"%s\",load[i]);\n    \n    for(i=0;i<n;i++)\n        if(strstr(indata,load[i])!=NULL)printf(\"1\\n\");\n        else printf(\"0\\n\");\n    \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define MAX_T 1000010\n#define MAX_P 1010\n#define max(a, b) ((a) > (b) ? a : b)\n\nchar T[MAX_T];\n\nint search(char P[], int len)\n{\n    int i, j;\n    int pos = len - 1;\n    int Tlen = strlen(T);\n    // pos????¢??????¨\n    int skip[256];\n    for (i = 0; i < 256; i++) {\n        skip[i] = len;\n    }\n    // ????????????????????????????????????????????¨??????????????????????????????\n    for (i = 0; i < len - 1; i++) {\n        skip[P[i]] = len - i - 1;\n        //printf(\"skip[%d] = %d\\n\", P[i], skip[P[i]]);\n    }\n    \n    while (pos < Tlen) {\n        j = len - 1;\n        while (T[pos] == P[j]) {\n            if (j == 0) {\n                return 1;\n            }\n            pos--; j--;\n        }\n        pos += max(skip[T[pos]], len - j);\n    }\n    return 0;\n}\n\nint main()\n{\n    char P[MAX_P];\n    int N;\n    int i;\n    scanf(\"%s\", T);\n    scanf(\"%d\", &N);\n    for (i = 0; i < N; i++) {\n        scanf(\"%s\", P);\n        printf(\"%d\\n\", search(P, strlen(P)));\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N_T 1000001\n#define N_P 1001\n#define BASE 64\n\nint mischarSearch(char*, char*);\nint* initSkip(char*);\n\nint myIndex(char);\n\nint main() {\n  char T[N_T];\n  char P[N_P];\n  int* pos;\n\n  int i;\n  int Q;\n    \n  scanf(\"%s\", T);\n  scanf(\"%d\", &Q);\n  for (i = 0; i < Q; ++i) {\n    scanf(\"%s\", P);\n    printf(\"%d\\n\", mischarSearch(T, P));\n  }\n\n  return 0;\n}\n\nint mischarSearch(char* T, char* P) {\n  int i, j, t;\n  int M = strlen(P);\n  int N = strlen(T);\n\n  int* skip;\n\n  skip = initSkip(P);\n  for (i = M - 1, j = M - 1; j >= 0; i--, j--) {\n    while (T[i] != P[j]) {\n      t  = skip[myIndex(T[i])];\n      i += (M - j > t) ? M - j : t;\n      if (i >= N) {\n\t//return N;\n\treturn 0;\n      }\n      j  = M - 1;\n    }\n  }\n  //return i + 1;\n  return 1;\n}\n\nint* initSkip(char* P) {\n  int i;\n  int M = strlen(P);\n  \n  int* skip;\n\n  skip = (int*)malloc(sizeof(int)*BASE);\n  for (i = 0; i < BASE; ++i) {\n    skip[i] = M;\n  }\n  for (i = 0; i < M; ++i) {\n    skip[myIndex(P[i])] = M - i - 1;\n  }\n\n  return skip;\n}\n\n/*\n  'a' - 'z' :  1-26\n  'A' - 'Z' : 27-52\n  '0' - '9' : 53-62\n */\nint myIndex(char c) {\n  if ('a' <= c && c <= 'z') {\n    return c - 'a' + 1;\n  } else if ('A' <= c && c <= 'Z') {\n    return c - 'A' + 27;\n  } else if ('0' <= c && c <= '9') {\n    return c - '0' + 53;\n  } else {\n    return 0;\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <float.h>\n#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_T 1000000\n#define MAX_P 1000\n\ntypedef double INT;\nconst INT INT_MAX = (1LL << DBL_MANT_DIG) - 1LL;\nconst INT INT_MIN = - ((1LL << DBL_MANT_DIG) - 1LL);\n\n#define CHECK(n) assert( n >= INT_MIN && n <= INT_MAX );\n\nINT add(INT a, INT b) {\n  INT res = a + b;\n  CHECK(res);\n  return res;\n}\n\nINT mult(INT a, INT b) {\n  INT res = a * b;\n  CHECK(res);\n  return res;\n}\n\nINT sub(INT a, INT b) {\n  INT res = a - b;\n  CHECK(res);\n  assert(a - res == b && res + b == a);\n  return res;\n}\n\nINT mod(INT a, INT b) {\n  INT res = fmod(a, b);\n  if (res < -0.0) res += b;\n  return res;\n}\n\nINT modulo_powered_number(INT base, int power, INT modulo) {\n  int max_digit = ceil(log2(power));\n  INT mem[max_digit+1];\n  mem[0] = mod(base, modulo);\n  for (int i = 1; i <= max_digit; ++i)\n    mem[i] = mod(mult(mem[i-1], mem[i-1]), modulo);\n  INT res = 1;\n  for (int i = 0; i <= max_digit; ++i)\n    if (power & (1 << i)) res = mod(mult(res, mem[i]), modulo);\n  return res;\n}\n\nbool isEqual(char *start1, char *end1, char *start2, char *end2) {\n  assert(end1 - start1 == end2 - start2);\n  while (start1 <= end1) {\n    if (*start1 != *start2) return false;\n    ++start1;\n    ++start2;\n  }\n  return true;\n}\n\nint rabinKarpMatcher(char *T, char *P, INT d, INT q) {\n  int n = strlen(T);\n  int m = strlen(P);\n  if (n < m) return 0;\n  --T; // start0 -> start1\n  --P; // start0 -> start1\n  INT h = modulo_powered_number(d, m - 1, q);\n  INT p = 0;\n  INT t[n - m + 1];\n  t[0] = 0;\n  for (int i = 1; i <= m; ++i) { // preprocess\n    p = mod(add(mult(d, p), P[i]), q);\n    t[0] = mod(add(mult(d, t[0]), T[i]), q);\n  }\n  for (int s = 0; s <= n - m; ++s) { // matching\n    if (p == t[s]) {\n      if (isEqual(P+1, P+m, T+s+1, T+s+m)) {\n        //printf(\"pattern match at shift %d\\n\", s);\n        return 1;\n      }\n    }\n    if (s < n - m)\n      t[s+1] =\n        mod(\n          add(\n            mult(d, sub(t[s], mult(T[s+1], h))),\n            T[s+m+1]),\n          q);\n  }\n  return 0;\n}\n\nint main() {\n  assert(DBL_MANT_DIG == 53);\n\n  char *T = (char *)malloc(MAX_T+1);\n  if (T == NULL) {\n    printf(\"memory shortage.\\n\");\n    return 1;\n  }\n\n  scanf(\"%s\", T);\n  int q = 0;\n  scanf(\"%d\", &q);\n\n  char P[MAX_P+1];\n  for (int i = 0; i < q; ++i) {\n    //printf(\"i = %d\\n\", i);\n    scanf(\"%s\", P);\n    printf(\"%d\\n\", rabinKarpMatcher(T, P, 256, (1 << 25) - 39));\n  }\n  free(T);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define M 1000000\n#define N 1000\n\nint main(){\n\n int i;\n int j;\n int num;\n int str_length;\n int cmp_length;\n char *str;\n char *cmp;\n\n  str = (char *)malloc(sizeof(char) * M);\n  cmp = (char *)malloc(sizeof(char) * N);\n\n  scanf(\"%s\",str);\n  str_length = strlen(str);\n\n  scanf(\"%d\",&num);\n  for(i=0;i<num;i++){\n  scanf(\"%s\",cmp);\n  cmp_length = strlen(cmp);\n  for(j=0;j<str_length;j++){\n\n  if( strncmp(str+j,cmp,cmp_length) ==0 ){\n  printf(\"1\");\n  break;\n  }\n\n  if(j==str_length-1){\n  printf(\"0\");\n  }\n\n   }\n  }\n\n return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<ctype.h>\n#include<limits.h>\n\n#define TMAX 1000001\n#define PMAX 10001\n\nint min(int a,int b){\n if(a > b)return b;\n return a;\n}\n\nint max(int a,int b){\n if(a > b)return a;\n return b;\n}\n\nint tblnum[30];\nint tbllow[30];\nint tblup[30];\n\n\nvoid maketable(char P[]){\n int i;\n int PL=strlen(P);\n\n for(i=0;i<30;i++){\n     tblnum[i]=INT_MAX;\n     tbllow[i]=INT_MAX;\n     tblup[i]=INT_MAX;\n }\n\n for(i=0;i<PL;i++){\n\n     if(isdigit(P[i]))\n        tblnum[P[i]-'0']=min(tblnum[P[i]-'0'],PL-1-i);\n\n     else if(islower(P[i]))\n        tbllow[P[i]-'a']=min(tbllow[P[i]-'a'],PL-1-i);\n\n     else if(isupper(P[i]))\n        tblup[P[i]-'A']=min(tblup[P[i]-'A'],PL-1-i);\n\n }\n\n\n for(i=0;i<30;i++){\n     if(tblnum[i]==INT_MAX)tblnum[i]=PL;\n     if(tbllow[i]==INT_MAX)tbllow[i]=PL;\n     if(tblup[i]==INT_MAX)tblup[i]=PL;\n }\n\n\n return;\n}\n\n\nint WidthCheck(char c){\n\n if(isdigit(c))return tblnum[c-'0'];\n\n if(islower(c))return tbllow[c-'a'];\n\n if(isupper(c))return tblup[c-'A'];\n\n}\n\n\nint main(){\n char T[TMAX];\n char P[PMAX];\n int i,j,TL,PL,n;\n int end;\n int width;\n\n scanf(\"%s\",T);\n\n scanf(\"%d\",&n);\n\n for(j=0;j<n;j++){\n\nstart:\n\n     scanf(\"%s\",P);\n     maketable(P);\n\n     TL=strlen(T); PL=strlen(P);\n\n     end=PL-1;\n     while(end < TL){\n\n           for(i=end;i>end-PL;i--){\n\n              if(P[PL-1-(end-i)]!=T[i]){\n                 width=WidthCheck(T[i]);\n                 end=max(end+1,i+width);\n                 break;\n              }\n\n              if(i==end-PL+1){\n                 printf(\"1\\n\");\n                 j++;\n                 goto start;\n              }\n\n           }\n          /* if(i==end-PL+1)break;*/\n\n     }\n\n     if(end>=TL)printf(\"0\\n\");\n\n }\nreturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nint main(int argc, char const *argv[]) {\n\n  char T[2000000];\n  char P[2000];\n  int Q;\n  int i;\n\n  scanf(\"%s\",T);\n  scanf(\"%d\",&Q);\n\n  for( i = 0 ; i < Q ; i++ ){\n\n    scanf(\"%s\",P);\n\n    if( strstr(T,P) != NULL ){\n      printf(\"%d\\n\",1);\n    }else{\n      printf(\"%d\\n\",0); \n    }\n\n\n  }\n\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#define KILO 1000\n#define MEGA (1000*1000)\n\n#define MAX_T (1 * MEGA)\n#define MAX_P (1 * KILO)\n#define MAX_PATTERN_NUMBER (10 * KILO)\n\n#define TYPE_NODE 1\n#define TYPE_LIST 2\n#define TYPE_EDGE 3\n\ntypedef struct node {\n  char type;\n  struct list *end;\n  struct edge_list *edge;\n} NODE;\n\nconst NODE INITIAL_NODE = { TYPE_NODE, NULL, NULL };\n\ntypedef struct list {\n  char type;\n  int index;\n  struct list *next;\n} LIST;\n\nconst LIST INITIAL_LIST = { TYPE_LIST, 0, NULL };\n\ntypedef struct edge_list {\n  char type;\n  char c;\n  struct edge_list *next;\n  struct node *node;\n} EDGE;\n\nconst EDGE INITIAL_EDGE = { TYPE_EDGE, '\\0', NULL, NULL };\n\ntypedef union unit {\n  struct node node;\n  struct list list;\n  struct edge_list edge;\n} UNIT;\n\n//const size_t MEM_MAX = 100;\n//const size_t MEM_MAX = 80 * KILO; // < 200MB\nconst size_t MEM_MAX = 80000 * KILO; // very large\nUNIT *mem = NULL;\nsize_t cnt = 0;\n\nNODE* get_initial_node() {\n  assert(cnt < MEM_MAX);\n  NODE *res = &(mem[cnt++].node);\n  *res = INITIAL_NODE;\n  return res;\n}\n\nLIST* get_initial_list() {\n  assert(cnt < MEM_MAX);\n  LIST *res = &(mem[cnt++].list);\n  *res = INITIAL_LIST;\n  return res;\n}\n\nEDGE* get_initial_edge() {\n  assert(cnt < MEM_MAX);\n  EDGE *res = &(mem[cnt++].edge);\n  *res = INITIAL_EDGE;\n  return res;\n}\n\nNODE *root = NULL;\n\nNODE * make_or_get_next_node(NODE *cur, char c) {\n  //printf(\"make_or_get_next_node(%lx, %c)\\n\", (size_t)cur, c);\n  EDGE *next = cur->edge;\n  if (next == NULL) {\n    next = cur->edge = get_initial_edge();\n    next->c = c;\n    return (next->node = get_initial_node());\n  }\n  while (next->next != NULL && next->c != c) next = next->next;\n  if (next->c != c) {\n    next = next->next = get_initial_edge();\n    next->c = c;\n    return (next->node = get_initial_node());\n  } else {\n    return next->node;\n  }\n}\n\nvoid add_index(NODE *node, int index) {\n  if (node->end == NULL) {\n    node->end = get_initial_list();\n    node->end->index = index;\n  } else {\n    LIST *list = node->end;\n    while (list->next != NULL) list = list->next;\n    list = list->next = get_initial_list();\n    list->index = index;\n  }\n}\n\nvoid add(int index, char *str) {\n  char c = '\\0';\n  NODE *node = root;\n  while ((c = (*(str++))) != '\\0')\n    node = make_or_get_next_node(node, c);\n  add_index(node, index);\n}\n\nvoid match(char *str, char *res) {\n  NODE *node = root;\n  LIST *list = NULL;\n  char c = '\\0';\n  EDGE *edge = NULL;\n  //for (int i = 0; i < 10; ++i) {\n  while (1) {\n    //printf(\"in match: node = %lx\\n\", (size_t)node);\n    assert(node != NULL);\n    if ((list = node->end) != NULL) {\n      while (list != NULL) {\n        res[list->index] = '1';\n        list = list->next;\n      }\n    }\n    if ((c = *(str++)) == '\\0') return;\n    //printf(\"in match: c = %c\\n\", c);\n    edge = node->edge;\n    if (edge == NULL) return;\n    while (edge->c != c) {\n      edge = edge->next;\n      if (edge == NULL) return;\n    }\n    node = edge->node;\n  }\n}\n\nvoid print_tree(NODE *node, int offset) {\n  for (int i = 0; i < offset; ++i) printf(\" \");\n  printf(\"* \");\n  for (LIST *i = node->end; i != NULL; i = i->next) printf(\"%d \", i->index);\n  printf(\"\\n\");\n  for (EDGE *i = node->edge; i != NULL; i = i->next) {\n    for (int j = 0; j < offset; ++j) printf(\" \");\n    printf(\"%c\\n\", i->c);\n    print_tree(i->node, offset + 2);\n  }\n}\n\nvoid print_node(NODE *node) {\n  assert(node->type == TYPE_NODE);\n  printf(\"end-list = %lx, edge-list = %lx\\n\",\n    (size_t)node->end, (size_t)node->edge);\n}\n\nint main() {\n  assert(sizeof(UNIT) <= 24);\n  mem = calloc(MEM_MAX, sizeof(UNIT));\n  assert(mem);\n  char *str = malloc((MAX_T+1) * sizeof(char));\n  assert(str);\n  char *pat = malloc((MAX_P+1) * sizeof(char));\n  assert(pat);\n  char *res = malloc(MAX_PATTERN_NUMBER * sizeof(char));\n  assert(res);\n  for (int i = 0; i < MAX_PATTERN_NUMBER; ++i) res[i] = '0';\n\n  //printf(\"mem = %lx\\n\", (size_t)mem);\n  \n  scanf(\"%s\", str);\n  int q = 0;\n  scanf(\"%d\", &q);\n\n  root = get_initial_node();\n  for (int i = 0; i < q; ++i) {\n    scanf(\"%s\", pat);\n    add(i, pat);\n    //printf(\"i = %d, cnt = %lu\\n\", i, cnt);\n  }\n  //print_tree(root, 0);\n  for (char *s = str; s[0] != '\\0'; ++s) match(s, res);\n  \n  for (int i = 0; i < q; ++i) printf(\"%c\\n\", res[i]);\n\n  free(mem);\n  free(str);\n  free(pat);\n  free(res);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n \n#define MPC 1063\n#define WAR 2000\n \ntypedef struct StringNode{\n    int *str;\n    int leng;\n    int flg;\n    int *num;\n}SNode;\n \nint n,cnt = 0;\n\nint med3(int x, int y, int z)\n{\n    if( x < y )\n    {\n    \tif( y < z )\n    \t{\n    \t\treturn y;\n    \t}\n    \telse if( z < x )\n    \t{\n    \t\treturn x;\n    \t}\n    \telse\n    \t{\n    \t\treturn z;\n    \t}\n    }\n    else\n    {\n    \tif( z < y )\n    \t{\n    \t\treturn y;\n    \t}\n    \telse if( x < z )\n    \t{\n    \t\treturn x;\n    \t}\n    \telse\n    \t{\n    \t\treturn z;\n    \t}\n    }\n}\n\n\nvoid quickSort(SNode A,int p, int r)\n{\n    if(p < r)\n    {\n    \tint i=p, j=r;\n    \tint tmp, pibot = med3( A.str[i], A.str[i+(j-i)/2], A.str[j] );\n    \t//tmp 格納場所　pibot 中央値\n    \twhile(1)\n    \t{\n    \t\twhile( A.str[i] < pibot ) i++;\n    \t\twhile( pibot < A.str[j] ) j--;\n    \t\tif( i >= j ) break;\n\n    \t\ttmp = A.str[i];\n    \t\tA.str[i] = A.str[j];\n    \t\tA.str[j] = tmp;\n    \t\ttmp = A.num[i];\n    \t\tA.num[i] = A.num[j];\n    \t\tA.num[j] = tmp;\n    \t\ti++;\n    \t\tj--;\n    \t}\n        quickSort(A, p, i - 1);\n        quickSort(A, j + 1, r);\n    }\n}\n\nSNode init_Snode(SNode A,int Tlen)\n{\n    A.str = malloc(sizeof(int)*Tlen);\n    A.leng = 0;\n    A.flg = 0;\n    A.num = malloc(sizeof(int)*Tlen);\n    return A;\n}\n\n\n\n/* 対象が検索してる文字と同じかどうか */\n/*void Search(int Tcp[],char T[],char P[], int Pcp,int Tlen,int Plen)\n{\n    int flg = 0,i;\n     \n    //printf(\"Plen = %d,Pcp = %d\\n\",Plen,Pcp);\n    /*    検索 */\n   /* for(i=0;i<=Tlen-Plen;i++)\n    {\n        //printf(\"%2d \",Tcp[i]);\n        if(Tcp[i]==Pcp)\n        {\n            if(strncmp(&T[i],&P[0],Plen)==0)\n            {\n                flg = 1;\n                //printf(\"congrache \\n\");\n                break;\n            }\n        }\n    }\n    if(flg == 1) printf(\"1\\n\");\n    else printf(\"0\\n\");\n}*/\n\n/* quickSort_Ver 検索 2分探索 */\nvoid Search(SNode B,char T[],char P[],int Pcp,int Tlen,int Plen)\n{\n    int i=0,j = Tlen-1,IJ,flg = 0;\n    cnt = 0;\n    //printf(\"pcp = %d\\n\",Pcp);\n    //printf(\"初期値 i = %d,j = %d, \",i,j);\n    \n    /* 2分探索 */\n    while(i <= j)\n    {\n        //cnt ++;\n        //if(100 < cnt) break;\n        IJ = i + (j-i) / 2;\n        //printf(\"IJ = %d \",IJ);\n        if(IJ == 0)\n        {\n            //printf(\"IJ 0 \");\n            if(strncmp(&T[B.num[0]],&P[0],Plen)==0)\n            {\n                flg = 1;\n            }\n            break;\n        }\n        /* hashが同じ場合 */\n        if(B.str[IJ] == Pcp){\n            //printf(\"\\ncongrach ,\");\n            int IJcp = IJ;\n            \n            /* hashが同じでも衝突を起こしている可能性がある為、前後も探す */\n            while(B.str[IJcp] == Pcp)\n            {\n                //printf(\"%d,\",IJcp);\n                if(memcmp(&T[B.num[IJcp]],&P[0],Plen)==0)\n                {\n                    flg = 1;\n                    break;\n                }\n                IJcp -= 1;\n            }\n            if(flg == 1){\n                break;\n            }\n            IJcp = IJ;\n            while(B.str[IJcp] == Pcp)\n            {\n                //printf(\"%d,\",IJcp);\n                if(memcmp(&T[B.num[IJcp]],&P[0],Plen)==0)\n                {\n                    flg = 1;\n                    break;\n                }\n                IJcp += 1;\n            }\n            break;\n        }else if(Pcp < B.str[IJ]){\n            j = IJ-1;\n            //printf(\"j- \");\n        }else if(B.str[IJ] < Pcp){\n            i = IJ+1;\n            //printf(\"i+ \");\n        }\n        \n        //printf(\"i = %d,j = %d,IJ=%d\\n\",i,j,IJ);\n    }\n    if(flg == 1) printf(\"1\\n\");\n    else printf(\"0\\n\");\n    return;\n}\n \n/* hash値を作成*/\nvoid hash(char T[],char P[],int Tlen,int Plen,SNode *SN,int Tcp[])\n{\n    int i,j,Pcp=0,M = MPC;\n    ///Tcp = &SN[Plen].str;\n    //printf(\"Pcp?? = %d ,\",Pcp);\n    \n    /* 検索する対象をhash化 */\n    for(i=0;i<Plen;i++)\n    {\n        Pcp += P[i] * M % WAR;\n        M += M;\n    }\n    \n    //printf(\"Pcp?? = %d ,\",Pcp);\n    \n    //printf(\"SN[%d].flg = %d\\n\",Plen,SN[Plen].flg);\n    \n    /* 一度作成されているhashであれば工程をスキップし、検索に遷移させる */\n    if(SN[Plen].flg == 0){\n        cnt++;\n        \n        //printf(\"chk flg 0\\n\");\n        /* char型をhash化(Plenの長さで調整) */\n        for(i=0;i<=Tlen-Plen;i++)\n        {\n            M = MPC;\n            SN[Plen].str[i] = 0;\n            \n            for(j=0;j<Plen;j++)\n            {\n                SN[Plen].str[i] += (int)T[i+j] * M % WAR;\n                M += M;\n            }\n            SN[Plen].num[i] = i;\n            \n        }\n        SN[Plen].leng = Plen;\n        SN[Plen].flg = 1;\n        \n        quickSort(SN[Plen],0,Tlen-Plen);\n        \n    }\n    //printf(\"Tlen %d\\n\",Tlen);\n    Search(SN[Plen],T,P,Pcp,Tlen-Plen+2,Plen);\n}\n \n \nint main()\n{\n    int i,j,Tlen,Plen,flg;\n    char T[1000000];\n    char P[1000];\n    SNode SN[1001];\n     \n    scanf(\"%s\",T);\n    scanf(\"%d\",&n);\n    Tlen = strlen(T);\n    int *Tcp = malloc(sizeof(int)*Tlen);\n     \n    /* 構造体の初期化 \n    for(i = 0; i<=1000 ; i++)\n    {\n        SN[i] = init_Snode(SN[i],Tlen);\n    }\n    \n    /* 検索 */\n    for(i = 0;i<n;i++)\n    {\n        flg = 0;\n        scanf(\"%s\",P);\n        Plen = strlen(P);\n        \n        if(Plen == 1)\n        {\n             \n            for(j = 0;j<Tlen;j++)\n            {\n                if(T[j]==P[0])\n                {\n                    flg = 1;\n                    break;\n                }\n            }\n             \n            //printf(\"chk1\\n\\n\");\n            if(flg == 1)\n                printf(\"1\\n\");\n             \n            else\n                printf(\"0\\n\");\n                 \n        }\n         \n        else if(Tlen < Plen)\n        {\n            printf(\"0\\n\");\n        }\n         \n        else\n        {\n            if(SN[Plen].flg == 0)\n                SN[Plen] = init_Snode(SN[Plen],Tlen);\n            //printf(\"Tlen = %d,Plen = %d\\n\",Tlen,Plen);\n            hash(T,P,Tlen,Plen,SN,Tcp);\n        }\n    }\n     \n     \n    free(Tcp);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n\tchar t[1000001],p[1001];\n\tint q,i;\n\tscanf(\"%s%d\",t,&q);\n\tfor(i=0;i<q;i++){\n\t\tscanf(\"%s\",p);\n\t\tif(strstr(t,p)==NULL)puts(\"0\");\n\t\telse puts(\"1\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_T 1000000\n#define MAX_P 1000\n\nint main() {\n  char *T = (char *)malloc(MAX_T+1);\n  if (T == NULL) {\n    printf(\"memory shortage.\\n\");\n    return 1;\n  }\n\n  scanf(\"%s\", T);\n  int q = 0;\n  scanf(\"%d\", &q);\n\n  char P[MAX_P+1];\n  for (int i = 0; i < q; ++i) {\n    scanf(\"%s\", P);\n    printf(\"%d\\n\", strstr(T, P) != NULL ? 1 : 0);\n  }\n  free(T);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#define KILO 1000\n#define MEGA (1000*1000)\n\n#define MAX_T (1 * MEGA)\n#define MAX_P (1 * KILO)\n#define MAX_PATTERN_NUMBER (10 * KILO)\n\n#define TYPE_NODE 1\n#define TYPE_LIST 2\n#define TYPE_EDGE 3\n\ntypedef struct node {\n  char type;\n  struct list *end;\n  struct edge_list *edge;\n} NODE;\n\nconst NODE INITIAL_NODE = { TYPE_NODE, NULL, NULL };\n\ntypedef struct list {\n  char type;\n  int index;\n  struct list *next;\n} LIST;\n\nconst LIST INITIAL_LIST = { TYPE_LIST, 0, NULL };\n\ntypedef struct edge_list {\n  char type;\n  char c;\n  struct edge_list *next;\n  struct node *node;\n} EDGE;\n\nconst EDGE INITIAL_EDGE = { TYPE_EDGE, '\\0', NULL, NULL };\n\ntypedef union unit {\n  struct node node;\n  struct list list;\n  struct edge_list edge;\n} UNIT;\n\n//const size_t MEM_MAX = 100;\nconst size_t MEM_MAX = 80 * KILO;\nUNIT *mem = NULL;\nsize_t cnt = 0;\n\nNODE* get_initial_node() {\n  assert(cnt < MEM_MAX);\n  NODE *res = &(mem[cnt++].node);\n  *res = INITIAL_NODE;\n  return res;\n}\n\nLIST* get_initial_list() {\n  assert(cnt < MEM_MAX);\n  LIST *res = &(mem[cnt++].list);\n  *res = INITIAL_LIST;\n  return res;\n}\n\nEDGE* get_initial_edge() {\n  assert(cnt < MEM_MAX);\n  EDGE *res = &(mem[cnt++].edge);\n  *res = INITIAL_EDGE;\n  return res;\n}\n\nNODE *root = NULL;\n\nNODE * make_or_get_next_node(NODE *cur, char c) {\n  //printf(\"make_or_get_next_node(%lx, %c)\\n\", (size_t)cur, c);\n  EDGE *next = cur->edge;\n  if (next == NULL) {\n    next = cur->edge = get_initial_edge();\n    next->c = c;\n    return (next->node = get_initial_node());\n  }\n  while (next->next != NULL && next->c != c) next = next->next;\n  if (next->c != c) {\n    next = next->next = get_initial_edge();\n    next->c = c;\n    return (next->node = get_initial_node());\n  } else {\n    return next->node;\n  }\n}\n\nvoid add_index(NODE *node, int index) {\n  if (node->end == NULL) {\n    node->end = get_initial_list();\n    node->end->index = index;\n  } else {\n    LIST *list = node->end;\n    while (list->next != NULL) list = list->next;\n    list = list->next = get_initial_list();\n    list->index = index;\n  }\n}\n\nvoid add(int index, char *str) {\n  char c = '\\0';\n  NODE *node = root;\n  while ((c = (*(str++))) != '\\0')\n    node = make_or_get_next_node(node, c);\n  add_index(node, index);\n}\n\nvoid match(char *str, char *res) {\n  NODE *node = root;\n  LIST *list = NULL;\n  char c = '\\0';\n  EDGE *edge = NULL;\n  //for (int i = 0; i < 10; ++i) {\n  while (1) {\n    //printf(\"in match: node = %lx\\n\", (size_t)node);\n    assert(node != NULL);\n    if ((list = node->end) != NULL) {\n      while (list != NULL) {\n        res[list->index] = '1';\n        list = list->next;\n      }\n    }\n    if ((c = *(str++)) == '\\0') return;\n    //printf(\"in match: c = %c\\n\", c);\n    edge = node->edge;\n    if (edge == NULL) return;\n    while (edge->c != c) {\n      edge = edge->next;\n      if (edge == NULL) return;\n    }\n    node = edge->node;\n  }\n}\n\nvoid print_tree(NODE *node, int offset) {\n  for (int i = 0; i < offset; ++i) printf(\" \");\n  printf(\"* \");\n  for (LIST *i = node->end; i != NULL; i = i->next) printf(\"%d \", i->index);\n  printf(\"\\n\");\n  for (EDGE *i = node->edge; i != NULL; i = i->next) {\n    for (int j = 0; j < offset; ++j) printf(\" \");\n    printf(\"%c\\n\", i->c);\n    print_tree(i->node, offset + 2);\n  }\n}\n\nvoid print_node(NODE *node) {\n  assert(node->type == TYPE_NODE);\n  printf(\"end-list = %lx, edge-list = %lx\\n\",\n    (size_t)node->end, (size_t)node->edge);\n}\n\nint main() {\n  assert(sizeof(UNIT) <= 24);\n  mem = calloc(MEM_MAX, sizeof(UNIT));\n  assert(mem);\n  char *str = malloc((MAX_T+1) * sizeof(char));\n  assert(str);\n  char *pat = malloc((MAX_P+1) * sizeof(char));\n  assert(pat);\n  char *res = malloc(MAX_PATTERN_NUMBER * sizeof(char));\n  assert(res);\n  for (int i = 0; i < MAX_PATTERN_NUMBER; ++i) res[i] = '0';\n\n  //printf(\"mem = %lx\\n\", (size_t)mem);\n  \n  scanf(\"%s\", str);\n  int q = 0;\n  scanf(\"%d\", &q);\n\n  root = get_initial_node();\n  for (int i = 0; i < q; ++i) {\n    scanf(\"%s\", pat);\n    add(i, pat);\n  }\n  //print_tree(root, 0);\n  for (char *s = str; s[0] != '\\0'; ++s) match(s, res);\n  \n  for (int i = 0; i < q; ++i) printf(\"%c\\n\", res[i]);\n\n  free(mem);\n  free(str);\n  free(pat);\n  free(res);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MPC 1063\n#define WAR 2000\n#define PlenDef 10\n\ntypedef struct StringNode{\n    int *str;\n    /* 配列Tのhashを格納する */\n    int flg;\n    int *num; \n    /* 配列Tの添え字を補完し、クイックソートをしても場所がわかる様にする。 */\n}SNode;\n \nint n;\n\n/* クイックソート用の中央値を返す */\nint med3(int x, int y, int z)\n{\n    if( x < y )\n    {\n        if( y < z )\n        {\n            return y;\n        }\n        else if( z < x )\n        {\n            return x;\n        }\n        else\n        {\n            return z;\n        }\n    }\n    else\n    {\n        if( z < y )\n        {\n            return y;\n        }\n        else if( x < z )\n        {\n            return x;\n        }\n        else\n        {\n            return z;\n        }\n    }\n}\n\n/* クイックソート */\nvoid quickSort(SNode A,int p, int r)\n{\n    if(p < r)\n    {\n        int i=p, j=r;\n        int tmp, pibot = med3( A.str[i], A.str[i+(j-i)/2], A.str[j] );\n        \n        while(1)\n        {\n            while( A.str[i] < pibot ) i++;\n            while( pibot < A.str[j] ) j--;\n            if( i >= j ) break;\n\n            tmp = A.str[i];\n            A.str[i] = A.str[j];\n            A.str[j] = tmp;\n            tmp = A.num[i];\n            A.num[i] = A.num[j];\n            A.num[j] = tmp;\n            i++;\n            j--;\n        }\n        quickSort(A, p, i - 1);\n        quickSort(A, j + 1, r);\n    }\n}\n\nSNode init_Snode(SNode A,int Tlen,int Plen)\n{\n    int TP = Tlen-Plen+1;\n    A.str = malloc(sizeof(int)*TP);\n    A.flg = 0;\n    A.num = malloc(sizeof(int)*TP);\n    return A;\n}\n\n\n/* quickSort_Ver 検索 2分探索 */\nvoid Search(SNode B,char T[],char P[],int Pcp,int Tlen,int Plen)\n{\n    \n    int i=0,j = Tlen-1,IJ,flg = 0;\n    \n    \n    /* 2分探索 */\n    while(i <= j)\n    {        \n        IJ = i + (j-i) / 2;\n        \n        \n        if(IJ == 0)\n        {\n            if(memcmp(&T[B.num[0]],&P[0],Plen)==0)\n            {\n                flg = 1;\n            }\n            break;\n        }\n        \n        /* hashが同じ場合 */\n        if(B.str[IJ] == Pcp){\n            int IJcp = IJ;\n            \n            /* hashが同じでも衝突を起こしている可能性がある為、前後も探す */\n            while(B.str[IJcp] == Pcp)\n            {\n                if(memcmp(&T[B.num[IJcp]],&P[0],Plen)==0)\n                {\n                    flg = 1;\n                    break;\n                }\n                IJcp -= 1;\n            }\n            if(flg == 1){\n                break;\n            }\n            IJcp = IJ;\n            while(B.str[IJcp] == Pcp)\n            {\n                if(memcmp(&T[B.num[IJcp]],&P[0],Plen)==0)\n                {\n                    flg = 1;\n                    break;\n                }\n                IJcp += 1;\n            }\n            break;\n        }\n        else if(Pcp < B.str[IJ])\n        {\n            j = IJ-1;\n        }\n        else if(B.str[IJ] < Pcp)\n        {\n            i = IJ+1;\n        }\n        \n    }\n    if(flg == 1)\n    {\n        printf(\"1\\n\");\n    }\n    else\n    {\n        printf(\"0\\n\");\n    }\n    return;\n}\n \n/* hash値を作成*/\nvoid hash(char T[],char P[],int Tlen,int Plen,int PlenCC,SNode *SN,int Tcp[])\n{\n    \n    int i,j,Pcp=0,M = MPC;\n    \n    \n    /* 検索する対象をhash化 */\n    for(i=0;i<PlenCC;i++)\n    {\n        Pcp += P[i] * M % WAR;\n        M += M;\n    }\n    \n    \n    /* 一度作成されているhashであれば工程をスキップし、検索に遷移させる */\n    if(SN[PlenCC].flg == 0)\n    {\n    \n        /* char型をhash化(Plenの長さで調整) */\n        for(i=0;i<=Tlen-PlenCC;i++)\n        {\n            M = MPC;\n            SN[PlenCC].str[i] = 0;\n            \n            \n            /* 配列Tのhashを作成 */\n            for(j=0;j<PlenCC;j++)\n            {\n                SN[PlenCC].str[i] += (int)T[i+j] * M % WAR;\n                M += M;\n            }\n            SN[PlenCC].num[i] = i;\n            \n        }\n        SN[PlenCC].flg = 1;\n        \n        quickSort(SN[PlenCC],0,Tlen-PlenCC);\n        \n    }\n    \n    Search(SN[PlenCC],T,P,Pcp,Tlen-Plen+2,Plen);\n\n}\n \n \nint main()\n{\n\n    int i,j,Tlen,Plen,TcntPrev = 0,TcntBih = 1,Pcnt = 0;\n    char T[1000000];\n    char P[1000];\n    SNode SN[PlenDef+1];\n     \n    scanf(\"%s\",T);\n    scanf(\"%d\",&n);\n    Tlen = strlen(T);\n    \n    /* Tの文字が前から何個同じか調べる。*/\n    while( TcntPrev<Tlen )\n    {\n        if(T[0] == T[TcntPrev])\n        {\n            TcntPrev++;\n        }\n        else\n            break;\n    }\n    /* Tの文字が後ろから何個同じか調べる。 */\n    while( TcntBih<Tlen)\n    {\n        if(T[Tlen-1] == T[Tlen-TcntBih])\n        {\n            TcntBih++;\n        }\n        else\n            break;\n    }\n    int *Tcp = malloc(sizeof(int)*Tlen);\n\n    \n    /* 最後の1文字だけ違うかどうかを調べている */\n    if(TcntPrev == Tlen-1)\n    {\n        for( i=0 ; i<n ; i++)\n        {\n            Pcnt = 0;\n            scanf(\"%s\",P);\n            Plen = strlen(P);\n            if(Plen == 1)\n            {\n                if(strstr(T,P)==NULL)\n                {\n                    printf(\"0\\n\");\n                }\n                else\n                {\n                    printf(\"1\\n\");\n                }\n            }\n            else\n            {\n            \n                /* パターンが最後の1文字だけ違うかどうかを調べている */\n                while(Pcnt<Plen)\n                {\n                \n                \n                    if(P[0]==P[Pcnt])\n                    {\n                        Pcnt++;\n                    }\n                    else\n                        break;\n                }\n                \n                \n                /* 配列Pが全て同じ文字だった場合はPの0番目だけをstrstr関数で探す */\n                if(Pcnt == Plen)\n                {\n                    if(strstr(T,&P[0])==NULL)\n                    {\n                        printf(\"0\\n\");\n                    }\n                    else\n                    {\n                        printf(\"1\\n\");\n                    }\n                }\n                /* 配列Pの最後の1文字だけ違う場合は最後の文字と最初の文字を調べる */\n                else if(Pcnt == Plen-1)\n                {\n                    if(T[Tlen-1] == P[Plen-1]&&T[0] == P[0])\n                    {\n                        printf(\"1\\n\");\n                    }\n                    else\n                    {\n                        printf(\"0\\n\");\n                    }\n                }\n                /* 配列Pの途中で文字が入っていた場合、配列Tとは絶対に一致しない為0を表示 */\n                else\n                {\n                    printf(\"0\\n\");\n                }\n            }\n        }\n    }\n    /* 配列Tの最初の一文字目だけ違う場合 */\n    else if(TcntBih == Tlen)\n    {\n        for( i=0 ; i<n ; i++)\n        {\n            scanf(\"%s\",P);\n            Plen = strlen(P);\n            Pcnt = 1;\n            \n            while(Pcnt<Plen)\n            {\n                if(P[Plen-1]==P[Plen-Pcnt])\n                {\n                    Pcnt++;\n                }\n                else\n                {\n                    break;\n                }\n            }\n            \n            if(Plen == Pcnt)\n            {\n                if(strstr(T,&P[0])==NULL)\n                {\n                    printf(\"0\\n\");\n                }\n                else\n                {\n                    printf(\"1\\n\");\n                }\n            }\n            else if(Plen-1 == Pcnt)\n            {\n                \n                if(P[0] == T[0] && P[Plen-1] == T[Tlen-1])\n                {\n                    printf(\"1\\n\");\n                }\n                else\n                {\n                    printf(\"0\\n\");\n                }\n            }\n            else\n            {\n                printf(\"0\\n\");\n            }\n        }\n    }\n    /* 上記のどちらでもない場合 */\n    else\n    {\n        for(i = 0;i<n;i++)\n        {\n            scanf(\"%s\",P);\n            Plen = strlen(P);\n            \n            /* 配列Pの長さが1ならばstrstr関数で探す */\n            if(Plen == 1)\n            {\n                if(strstr(T,&P[0])==NULL)\n                {\n                    printf(\"0\\n\");\n                }\n                else\n                {\n                    printf(\"1\\n\");\n                }\n            }\n            \n            /* 配列Pが配列Tよりも大きい場合は一致する事がない */\n            else if(Tlen < Plen)\n            {\n\n                printf(\"0\\n\");\n\n            }\n            \n            /* PlenDefよりも配列Pが大きい場合 */\n            else if(PlenDef <= Plen)\n            {\n                /* 初期化したかどうか */\n                if(SN[PlenDef].flg == 0)\n                    SN[PlenDef] = init_Snode(SN[PlenDef],Tlen,PlenDef);\n    \n                hash(T,P,Tlen,Plen,PlenDef,SN,Tcp);\n\n            }\n            \n            /* 配列Pが1よりも大きくPlenDefよりも小さい場合 */\n            else\n            {\n                \n                /* 初期化したかどうか */\n                if(SN[Plen].flg == 0)\n                    SN[Plen] = init_Snode(SN[Plen],Tlen,Plen);\n    \n\n                hash(T,P,Tlen,Plen,Plen,SN,Tcp);\n    \n            }\n        }\n    }\n    free(Tcp);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ ALDS1_14_D Multiple String Matching\n// 2018.5.9 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#define pc(c) putchar_unlocked(c)\n#else\n#define gc() getchar()\n#define pc(c) putchar(c)\n#endif\n\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nchar text[1000005];\nchar pattern[10005];\nint  next[10005], skip[258];\n\nchar *bmMatch(char *text, int len, char *pattern, int patlen,\n              int *skip, int *next)\n{\n    int i, j;\n\n    i = patlen - 1;\n    while (i < len) {\n        j = patlen - 1;\n        while (j >= 0 && text[i] == pattern[j]) {\n            i--;\n            j--;\n        }\n        if (j < 0) return text + i + 1;\n        if (skip[text[i]] >= next[j]) i += skip[text[i]];\n        else i += next[j];\n    }\n    return NULL;\n}\n\nint bmSkip(int *skip, int slen, char *pattern, int patlen)\n{\n    int j;\n\n    if (slen < 256) return -1;\n    for (j = 0; j < 256; j++) skip[j] = patlen;\n    for (j = 0; j < patlen - 1; j++)\n        skip[pattern[j]] = patlen-1-j;\n    return 0;\n}\n\nint bmNext(int *next, int nlen, char *pattern, int patlen)\n{\n    int  j, k, s;\n    int  *g;\n\n    g = malloc(sizeof(int)*patlen);\n    for (j = 0; j < patlen; j++) next[j] = 2*patlen - 1 - j;\n    j = patlen;\n    for (k = patlen - 1; k >= 0; k--) {\n        g[k] = j;\n        while (j != patlen && pattern[j] != pattern[k]) {\n            next[j] = (next[j] <= patlen-1-k) ? next[j] : patlen-1-k;\n            j = g[j];\n        }\n        j--;\n    }\n    s = j;\n    for (j = 0; j < patlen; j++) {\n        next[j] = (next[j] <= s+patlen-j) ? next[j] : s+patlen-j;\n        if (j >= s) s = g[s];\n    }\n    free(g);\n    return 0;\n}\n\nchar buf[20];\nvoid mypr(int n)\n{\n\tint w = 0;\n\twhile (n) buf[w++] = n%10 + '0', n/=10;\n\twhile (w--) pc(buf[w]);\n\tpc('\\n');\n}\n\nvoid corner(int len)\n{\n\tint i;\n\tif (len < 0) return;\n\tpc('0'), pc('\\n');\n\ti = 0; while (len--) mypr(++i);\n}\n\nint main()\n{\n\tint Q, c, tlen, plen;\n\tint a, fa, b, fb;\n\tchar *pos;\n\n\tfa = 1, pos = text;\n\t*pos++ = a = gc();\n\twhile ((c = gc()) > ' ') {\n\t\t*pos++ = c;\n\t\tif (a != c) fa = 0;\n\t}\n\t*pos = 0; tlen = pos-text;\n\n\tQ = in();\n\twhile (Q--) {\n\t\tfb = 1, pos = pattern;\n\t\t*pos++ = b = gc();\n\t\twhile ((c = gc()) > ' ') {\n\t\t\t*pos++ = c;\n\t\t\tif (b != c) fb = 0;\n\t\t}\n\t\t*pos = 0; plen = pos-pattern;\n\t\n\t\tif (fa && fb && a == b) pc('0'+ (tlen>=plen));\n\t\telse {\n\t\t    bmSkip(skip, 256, pattern, plen);\n\t\t\tbmNext(next, plen, pattern, plen);\n\t \t\tpc('0' + (bmMatch(text, tlen-(pos-text), pattern, plen, skip, next) != NULL));\n\t\t}\n\t\tpc('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define M 1000000\n#define N 1000\n\nint main(){\n\n int i;\n int j;\n int num;\n int str_length;\n int cmp_length;\n char *str;\n char *cmp;\n\n  str = (char *)malloc(sizeof(char) * M);\n  cmp = (char *)malloc(sizeof(char) * N);\n\n  scanf(\"%s\",str);\n  str_length = strlen(str);\n\n  scanf(\"%d\",&num);\n  for(i=0;i<num;i++){\n  scanf(\"%s\",cmp);\n  cmp_length = strlen(cmp);\n  for(j=0;j<str_length;j++){\n\n  if( strncmp(str+j,cmp,cmp_length) ==0 ){\n  printf(\"1\\n\");\n  break;\n  }\n\n  if(j==str_length-1){\n  printf(\"0\\n\");\n  }\n\n   }\n  }\n\n return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n * modified from the pp. 332-333 of the following book:\n *   Programming Contest Challenge Book [2nd ed.] (Language: Japanese)\n *   ISBN: 978-8399-4106-2\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_T 1000000\n#define MAX_P 1000\n\ntypedef unsigned long long ull;\n\nconst ull B = 100000007;\n\n// which is a included in [b]?\nbool contain(char *a, char *b) {\n  int al = strlen(a), bl = strlen(b);\n  if (al > bl) return false;\n  \n  // calculates the [al]-th power of [B]\n  ull t = 1;\n  for (int i = 0; i < al; i++) t *= B;\n  \n  // calculates the hash value for the top [al] characters of [a] and [b]\n  ull ah = 0, bh = 0;\n  for (int i = 0; i < al; i++) ah = ah * B + a[i];\n  for (int i = 0; i < al; i++) bh = bh * B + b[i];\n\n  // checks the hash values with incrementing the place of [b]\n  for (int i = 0; i + al <= bl; i++) {\n    if (ah == bh) return true; // matchs [al] characters of b from [i]\n    if (i + al < bl) bh = bh * B + b[i + al] - b[i] * t;\n  }\n  return false;\n}\n\nint main() {\n  char *T = (char *)malloc((MAX_T)+1);\n  if (T == NULL) {\n    printf(\"memory shortage.\\n\");\n    return 1;\n  }\n  scanf(\"%s\", T);\n\n  int Q = 0;\n  scanf(\"%d\", &Q);\n\n  char P[MAX_P+1];\n\n  for (int i = 0; i < Q; i++) {\n    scanf(\"%s\", P);\n    printf(\"%d\\n\", contain(P, T) ? 1 : 0);\n  }\n\n  free(T);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n// Pattern????????????32????¶?????????¨??????????????????\n\nint BitapSearch(char *,char *);\n\nint main(){\n\n    char Text[1000001];\n    char Pattern[1001];\n    int n;\n    int i;\n\n    scanf(\"%s\",Text);\n    // printf(\"%s\\n\",Text);\n    scanf(\"%d\",&n);\n    // printf(\"%d\\n\",n);\n    for( i = 0 ; i < n ; i++ ){\n\n        scanf(\"%s\",Pattern);\n        // printf(\"%s\\n\",Pattern);\n        \n        if( BitapSearch(Text,Pattern) == 1 ){\n            printf(\"%d\\n\",1);\n        }else{\n            printf(\"%d\\n\",0);\n        }\n    }\n\n    return 0;\n}\n\nint BitapSearch(char *Text, char *Pattern){\n    \n    long long R;\n    long long pattern_mask[CHAR_MAX+1];\n    int i;\n    int m = strlen(Pattern);\n    \n    R = ~1;\n\n    for( i = 0 ; i <= CHAR_MAX ; i++ ){\n        pattern_mask[i] = ~0;\n    }\n    \n    for( i = 0 ; i < m ; i++ ){\n        pattern_mask[Pattern[i]] &= ~(1<<i);\n    }\n\n    for( i = 0 ; Text[i] != '\\0' ; i++ ){\n        R = R|pattern_mask[Text[i]];\n        R = R << 1;\n        if( (R & (1<<m)) == 0 ){\n            return 1;\n        }\n    }\n    \n    return 0;\n    \n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N_T 1000001\n#define N_P 1001\n#define BASE 64\n\nint* kmpSearch(char*, char*);\nint* initNext(char*);\n\nint myIndex(char);\n\nint main() {\n  char T[N_T];\n  char P[N_P];\n  int* pos;\n\n  int i;\n  int Q;\n    \n  scanf(\"%s\", T);\n  scanf(\"%d\", &Q);\n  for (i = 0; i < Q; ++i) {\n    scanf(\"%s\", P);\n    pos = kmpSearch(T, P);\n    printf(\"%d\\n\", pos[0]?1:0);\n    free(pos);\n  }\n\n  return 0;\n}\n\nint* kmpSearch(char* T, char* P) {\n  int i, j;\n  int cnt = 0;\n  int M   = strlen(P);\n  int N   = strlen(T);\n  \n  int* next;\n  int* pos;\n\n  if (N < M) {\n    pos    = (int*)malloc(sizeof(int)*1);\n    pos[0] = 0;\n    return pos;\n  } else {\n    pos = (int*)malloc(sizeof(int)*(N-M+2));\n  }\n  \n  next = initNext(P);  \n  for (i = 0, j = 0; i < N; ++i, ++j) {\n    while ((j >= 0) && (T[i] != P[j])){\n      j = next[j];\n    }\n\n    if (j == M - 1) {\n      cnt++;\n      pos[cnt] = i - M + 1;\n\n      do {\n\tj = next[j];\n      }\twhile ((j >= 0) && (T[i] != P[j]));\n    }\n  }\n  pos[0] = cnt;\n\n  free(next);\n  \n  return pos;\n}\n\nint* initNext(char* P){\n  int i, j;\n  int M = strlen(P);\n  int* next = (int*)malloc(sizeof(int)*M);\n\n  next[0] = -1;\n  for (i = 0, j = -1; i < M; ++i, ++j, next[i] = j) {\n    while ((j >= 0) && (P[i] != P[j])) {\n      j = next[j];\n    }\n  }\n  \n  return next;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint t[10000000], p[100000];\nint check(int i, int q){\n    int j;\n    for(j=1; j<q-1; j++)if(t[j+i]!=p[j])return 0;\n    return 1;\n}\nint main(){\n    int i, j, l=0, q=0, n, count=0;\n    while((t[l++]=getchar())!='\\n'){}\n    scanf(\"%d \", &n);\n    for(j=0; j<n; j++){\n        count=0;\n        q=0;\n        while((p[q++]=getchar())!='\\n'){}\n        for(i=0; i<l-q+1; i++){\n            if(t[i]!=p[0]||t[i+q-2]!=p[q-2])continue;\n            else if(check(i, q-1)){\n                count++;\n                break;\n            }\n        }\n        if(count>0)puts(\"1\");\n        else puts(\"0\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nint*makeSA(char*s,int len){\n\tlen++;\n\tint*SAidx=calloc(len,sizeof(int));\n\tint*ord=calloc(len,sizeof(int));\n\t//1文字目\n\tint cnt1[256]={},cnt2[256]={};\n\tfor(int i=0;i<len;i++)cnt1[s[i]+1]++,cnt2[s[i]+1]|=1;\n\tfor(int i=1;i<256;i++)cnt1[i]+=cnt1[i-1],cnt2[i]+=cnt2[i-1];\n\tfor(int i=0;i<len;i++)SAidx[cnt1[s[i]]++]=i,ord[i]=cnt2[s[i]];\n\t\n\tint*cnt=calloc(len+1,sizeof(int));\n\tint*idx2=calloc(len,sizeof(int));\n\tint*temp=calloc(len,sizeof(int));\n\tfor(int k=1;k<len;k*=2){\n\t\t//2*k文字まで見る\n\t\tfor(int i=0;i<len;i++)cnt[i]=0;\n\t\tfor(int i=0;i<len;i++)cnt[ord[i]+1]++;\n\t\tfor(int i=1;i<len;i++)cnt[i]+=cnt[i-1];\n\t\tfor(int i=0;i<len;i++)idx2[cnt[ord[(SAidx[i]-k+len)%len]]++]=(SAidx[i]-k+len)%len;\n\t\ttemp[idx2[0]]=0;\n\t\tfor(int i=1;i<len;i++)temp[idx2[i]]=temp[idx2[i-1]]+(ord[idx2[i-1]]!=ord[idx2[i]]||ord[(idx2[i-1]+k)%len]!=ord[(idx2[i]+k)%len]);\n\t\tfor(int i=0;i<len;i++)ord[i]=temp[i],SAidx[i]=idx2[i];\n\t}\n\tfree(temp);\n\tfree(idx2);\n\tfree(cnt);\n\tfree(ord);\n\treturn SAidx+1;\n}\nint find(char*t,int tlen,char*s,int slen,int*SAidx){\n\tint l=0,r=slen;\n\twhile(r-l>1){\n\t\tint m=(l+r)/2;\n\t\tint flag=memcmp(s+SAidx[m],t,tlen);\n\t\tif(flag==0)return 1;\n\t\telse if(flag<0)l=m;\n\t\telse r=m;\n\t}\n\treturn !memcmp(s+SAidx[l],t,tlen);\n}\n\nchar s[1000010];\nchar t[1010];\nint main(){\n\tscanf(\"%s\",s);\n\tint n=strlen(s);\n\tint*idx=makeSA(s,n);\n\tint q;\n\tscanf(\"%d\",&q);\n\twhile(q--){\n\t\tscanf(\"%s\",t);\n\t\tputs(find(t,strlen(t),s,n,idx)?\"1\":\"0\");\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ ALDS1_14_D Multiple String Matching\n// 2018.5.9 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#define pc(c) putchar_unlocked(c)\n#else\n#define gc() getchar()\n#define pc(c) putchar(c)\n#endif\n\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nchar text[1000005];\nchar pattern[10005]; int g[10005];\nint  next[10005], skip[258];\n\nint bmMatch(char *text, int len, char *pattern, int patlen,\n              int *skip, int *next)\n{\n    int i, j;\n\n    i = patlen - 1;\n    while (i < len) {\n        j = patlen - 1;\n        while (j >= 0 && text[i] == pattern[j]) i--, j--;\n        if (j < 0) return 1;\n        if (skip[text[i]] >= next[j]) i += skip[text[i]];\n        else i += next[j];\n    }\n    return 0;\n}\n\nint bmSkip(int *skip, int slen, char *pattern, int patlen)\n{\n    int j;\n\n    if (slen < 256) return -1;\n    for (j = 0; j < 256; j++) skip[j] = patlen;\n    for (j = 0; j < patlen - 1; j++) skip[pattern[j]] = patlen-1-j;\n    return 0;\n}\n\nint bmNext(int *next, int nlen, char *pattern, int patlen)\n{\n    int  j, k, s;\n\n    for (j = 0; j < patlen; j++) next[j] = 2*patlen - 1 - j;\n    j = patlen;\n    for (k = patlen - 1; k >= 0; k--) {\n        g[k] = j;\n        while (j != patlen && pattern[j] != pattern[k]) {\n            next[j] = (next[j] <= patlen-1-k) ? next[j] : patlen-1-k;\n            j = g[j];\n        }\n        j--;\n    }\n    s = j;\n    for (j = 0; j < patlen; j++) {\n        next[j] = (next[j] <= s+patlen-j) ? next[j] : s+patlen-j;\n        if (j >= s) s = g[s];\n    }\n    return 0;\n}\n\nint main()\n{\n\tint Q, c, tlen, plen;\n\tint a, fa, b, fb;\n\tchar *pos;\n\n\tfa = 1, pos = text;\n\t*pos++ = a = gc();\n\twhile ((c = gc()) > ' ') {\n\t\t*pos++ = c;\n\t\tif (a != c) fa = 0;\n\t}\n\t*pos = 0; tlen = pos-text;\n\n\tQ = in();\n\twhile (Q--) {\n\t\tfb = 1, pos = pattern;\n\t\t*pos++ = b = gc();\n\t\twhile ((c = gc()) > ' ') {\n\t\t\t*pos++ = c;\n\t\t\tif (b != c) fb = 0;\n\t\t}\n\t\t*pos = 0; plen = pos-pattern;\n\t\n\t\tif (fa && fb && a == b) pc('0'+ (tlen>=plen));\n\t\telse {\n\t\t    bmSkip(skip, 256, pattern, plen);\n\t\t\tbmNext(next, plen, pattern, plen);\n\t \t\tpc('0' + bmMatch(text, tlen-(pos-text), pattern, plen, skip, next));\n\t\t}\n\t\tpc('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N_T 1000001\n#define N_P 1001\n#define BASE 64\n\nint* kmpSearch(char*, char*);\nint* initNext(char*);\n\nint main() {\n  char T[N_T];\n  char P[N_P];\n  int* pos;\n\n  int i;\n  int Q;\n    \n  scanf(\"%s\", T);\n  scanf(\"%d\", &Q);\n  for (i = 0; i < Q; ++i) {\n    scanf(\"%s\", P);\n    pos = kmpSearch(T, P);\n    printf(\"%d\\n\", pos[0]?1:0);\n  }\n\n  return 0;\n}\n\nint* kmpSearch(char* T, char* P) {\n  int i, j;\n  int cnt = 0;\n  int M   = strlen(P);\n  int N   = strlen(T);\n  \n  int* next;\n  int* pos;\n\n  if (N < M) {\n    pos    = (int*)malloc(sizeof(int)*1);\n    pos[0] = 0;\n    return pos;\n  } else {\n    pos = (int*)malloc(sizeof(int)*(N-M+2));\n  }\n  \n  next = initNext(P);  \n  for (i = 0, j = 0; i < N; ++i, ++j) {\n    while ((j >= 0) && (T[i] != P[j])){\n      j = next[j];\n    }\n\n    if (j == M - 1) {\n      cnt++;\n      pos[cnt] = i - M + 1;\n\n      do {\n\tj = next[j];\n      }\twhile ((j >= 0) && (T[i] != P[j]));\n    }\n  }\n  pos[0] = cnt;\n  \n  return pos;\n}\n\nint* initNext(char* P){\n  int i, j;\n  int M = strlen(P);\n  int* next = (int*)malloc(sizeof(int)*M);\n\n  next[0] = -1;\n  for (i = 0, j = -1; i < M; ++i, ++j, next[i] = j) {\n    while ((j >= 0) && (P[i] != P[j])) {\n      j = next[j];\n    }\n  }\n  \n  return next;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ ALDS1_14_D Multiple String Matching\n// 2018.5.13 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#define pc(c) putchar_unlocked(c)\n#else\n#define gc() getchar()\n#define pc(c) putchar(c)\n#endif\n\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\n#define MAX_L 1000005\n\nchar text[MAX_L]; int len;\nchar pattern[10005]; int plen;\nint  sa[MAX_L], rank[MAX_L];\n\n// rank[i]～[i+k] と rank[j]～[j+k] を比較\nint k; // comstruct_sa()内で設定\nint compare_sa(int i, int j)\n{\n\tint ri, rj;\n\t\n\tif (rank[i] != rank[j]) return rank[i] < rank[j];\n\tri = -1; if (i+k <= len) ri = rank[i+k];\n\trj = -1; if (j+k <= len) rj = rank[j+k];\n    return ri < rj;\n}\n\n// for qsort()\nint cmp(int *a, int *b)\n{\n\tint i = *a, j = *b;\n\tint ri, rj;\n\t\n\tif (rank[i] != rank[j]) return rank[i]-rank[j];\n\tri = -1; if (i+k <= len) ri = rank[i+k];\n\trj = -1; if (j+k <= len) rj = rank[j+k];\n    return ri-rj;\n}\n\n// 文字列Sの接尾辞配列saを構築。   len:　strlen(s)\nint tmp[MAX_L];\nvoid construct_sa(char *s, int *sa)\n{\n\tint i;\n\t\n\tfor(i = 0; i <= len; i++) {\n\t\tsa[i] = i;\n\t\trank[i] = -1; if (i < len) rank[i] = s[i];\n\t}\n\t\n\tfor(k = 1; k <= len; k *= 2) {\n\t\tqsort(sa, len+1, sizeof(int), cmp);\n\t\t\n\t\ttmp[sa[0]] = 0;\n\t\tfor(i = 1; i <= len; i++) {\n\t\t\ttmp[sa[i]] = tmp[sa[i-1]]+(compare_sa(sa[i-1], sa[i])? 1: 0);\n\t\t}\n\t\tfor(i = 0; i <= len; i++) rank[i] = tmp[i];\n\t}\n}\n\n// 接尾辞配列を用いた文字列検索　len = strlen(s), plen = strlen(t)\nint contain(char *s, char *t)\n{\n\tint l, r, m;\n\n\tl = 0, r = len;\n\twhile (l+1 < r) {\n\t\tm = (l+r)>>1;\n\t\tif (memcmp(s+sa[m], t, plen) < 0) l = m; else r = m;\n\t}\n\treturn !memcmp(s+sa[r], t, plen);\n}\n\nint main()\n{\n\tint Q;\n\tchar c, *p;\n\n\tp = text;\n\twhile ((c = gc()) > ' ') *p++ = c;\n\t*p = 0;\n\tlen = p-text;\n\n\tconstruct_sa(text, sa);\n\n//for (int i = 0; i <= len; i++) printf(\"[%d] sa %d\\n\", i, sa[i]);\n\n\tQ = in();\n\twhile (Q--) {\n\t\tp = pattern;\n\t\twhile ((c = gc()) > ' ') *p++ = c;\n\t\t*p = 0;\n\t\tplen = p-pattern;\n\n\t\tpc('0' + contain(text, pattern));\n\t\tpc('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N_T 1000001\n#define N_P 1001\n#define BASE 64\n\nint* kmpSearch(char*, char*);\nint* initNext(char*);\n\nint myIndex(char);\n\nint main() {\n  char T[N_T];\n  char P[N_P];\n  int* pos;\n\n  int i;\n  int Q;\n    \n  while (scanf(\"%s\", T) != EOF) {\n    scanf(\"%d\", &Q);\n    for (i = 0; i < Q; ++i) {\n      scanf(\"%s\", P);\n      pos = kmpSearch(T, P);\n      printf(\"%d\\n\", pos[0]?1:0);\n    }\n  }\n\n  return 0;\n}\n\nint* kmpSearch(char* T, char* P) {\n  int i, j;\n  int cnt = 0;\n  int M   = strlen(P);\n  int N   = strlen(T);\n  \n  int* next;\n  int* pos;\n\n  if (N < M) {\n    pos    = (int*)malloc(sizeof(int)*1);\n    pos[0] = 0;\n    return pos;\n  } else {\n    pos = (int*)malloc(sizeof(int)*(N-M+2));\n  }\n  \n  next = initNext(P);  \n  for (i = 0, j = 0; i < N; ++i, ++j) {\n    while ((j >= 0) && (T[i] != P[j])){\n      j = next[j];\n    }\n\n    if (j == M - 1) {\n      cnt++;\n      pos[cnt] = i - M + 1;\n\n      do {\n\tj = next[j];\n      }\twhile ((j >= 0) && (T[i] != P[j]));\n    }\n  }\n  pos[0] = cnt;\n  \n  return pos;\n}\n\nint* initNext(char* P){\n  int i, j;\n  int M = strlen(P);\n  int* next = (int*)malloc(sizeof(int)*M);\n\n  next[0] = -1;\n  for (i = 0, j = -1; i < M; ++i, ++j, next[i] = j) {\n    while ((j >= 0) && (P[i] != P[j])) {\n      j = next[j];\n    }\n  }\n  \n  return next;\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n////#define _USE_MATH_DEFINES\n#include<stdio.h>\n//#include<stdlib.h>\n//#include<math.h>\n#include<string.h>\n//#include<time.h>\n#define P(type,x) fprintf(stdout,\"%\"#type\"\\n\",x)\n\nint main() {\n\tchar T[1000001],P[1000];\n\tint n;\n\tfscanf(stdin, \"%[^\\n]*s\", T),getchar();\n\tfscanf(stdin, \"%d\", &n),getchar();\n\twhile (n--) {\n\t\tfscanf(stdin, \"%[^\\n]*s\", P),getchar();\n\t\tif (strstr(T, P) == NULL) puts(\"0\");\n\t\telse puts(\"1\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(){\n    char indata[1000000];\n    int i,j,n,in,ln;\n    \n    scanf(\"%s\",indata);\n    scanf(\"%d\",&n);\n    char load[1000];\n    for(i=0;i<n;i++){\n        scanf(\"%s\",load);\n        if(strstr(indata,load)!=NULL)printf(\"1\\n\");\n        else printf(\"0\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint main(){\n  int i,n;\n  char T[1000000],P[1000][1000];\n\n  scanf(\"%s\",T);\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)\n    scanf(\"%s\",P[i]);\n\n  for(i=0;i<n;i++){\n    if(strstr(T,P[i]) != NULL)printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(){\n    char indata[1000000];\n    int i,j,n,in,ln;\n    \n    scanf(\"%s\",indata);\n    scanf(\"%d\",&n);\n    char load[1000];\n    for(i=0;i<n;i++){\n        scanf(\"%s\",load);\n        if(strstr(indata,load)==NULL)printf(\"0\\n\");\n        else printf(\"1\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<ctype.h>\n#include<limits.h>\n\n#define TMAX 1000001\n#define PMAX 10001\n\nint min(int a,int b){\n if(a > b)return b;\n return a;\n}\n\nint max(int a,int b){\n if(a > b)return a;\n return b;\n}\n\nint tblnum[30];\nint tbllow[30];\nint tblup[30];\n\n\nvoid maketable(char P[]){\n int i;\n int PL=strlen(P);\n\n for(i=0;i<30;i++){\n     tblnum[i]=INT_MAX;\n     tbllow[i]=INT_MAX;\n     tblup[i]=INT_MAX;\n }\n\n for(i=0;i<PL;i++){\n\n     if(isdigit(P[i]))\n        tblnum[P[i]-'0']=min(tblnum[P[i]-'0'],PL-1-i);\n\n     else if(islower(P[i]))\n        tbllow[P[i]-'a']=min(tbllow[P[i]-'a'],PL-1-i);\n\n     else if(isupper(P[i]))\n        tblup[P[i]-'A']=min(tblup[P[i]-'A'],PL-1-i);\n\n }\n\n\n for(i=0;i<30;i++){\n     if(tblnum[i]==INT_MAX)tblnum[i]=PL;\n     if(tbllow[i]==INT_MAX)tbllow[i]=PL;\n     if(tblup[i]==INT_MAX)tblup[i]=PL;\n }\n\n\n return;\n}\n\n\nint WidthCheck(char c){\n\n if(isdigit(c))return tblnum[c-'0'];\n\n if(islower(c))return tbllow[c-'a'];\n\n if(isupper(c))return tblup[c-'A'];\n\n}\n\n\nint main(){\n char T[TMAX];\n char P[PMAX];\n int i,j,TL,PL,n;\n int end;\n int width;\n\n scanf(\"%s\",T);\n\n scanf(\"%d\",&n);\n\n for(j=0;j<n;j++){\n\n     scanf(\"%s\",P);\n     maketable(P);\n\n     TL=strlen(T); PL=strlen(P);\n\n     end=PL-1;\n     while(end < TL){\n\n           for(i=end;i>end-PL;i--){\n\n              if(P[PL-1-(end-i)]!=T[i]){\n                 width=WidthCheck(T[i]);\n                 end=max(end+1,i+width);\n                 break;\n              }\n\n              if(i==end-PL+1){\n                 printf(\"1\\n\");\n                 break;\n              }\n\n           }\n           if(i==end-PL+1)break;\n\n     }\n\n     if(end>=TL)printf(\"0\\n\");\n\n }\nreturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ ALDS1_14_D Multiple String Matching\n// 2018.5.13 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#define pc(c) putchar_unlocked(c)\n#else\n#define gc() getchar()\n#define pc(c) putchar(c)\n#endif\n\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\n#define MAX_L 1000005\n\nchar text[MAX_L]; int len;\nchar pattern[10005]; int plen;\nint  sa[MAX_L], rank[MAX_L<<1];\n\n// rank[i]～[i+k] と rank[j]～[j+k] を比較\nint k; // comstruct_sa()内で設定\nint compare_sa(int i, int j)\n{\n\tif (rank[i] != rank[j]) return rank[i] < rank[j];\n\treturn rank[i+k] < rank[j+k];\n}\n\n// for qsort()\nint cmp(int *a, int *b)\n{\n\tint i = *a, j = *b;\n\t\n\tif (rank[i] != rank[j]) return rank[i] - rank[j];\n\treturn rank[i+k] - rank[j+k];\n}\n\n// 文字列Sの接尾辞配列saを構築。   len:　strlen(s)\nint tmp[MAX_L];\nvoid construct_sa(char *s, int *sa)\n{\n\tint i;\n\t\n\tmemset(rank, -1, sizeof(rank));\n\tfor(i = 0; i <= len; i++) {\n\t\tsa[i] = i;\n\t\tif (i < len) rank[i] = s[i];\n\t}\n\t\n\tfor(k = 1; k <= len; k *= 2) {\n\t\tqsort(sa, len+1, sizeof(int), cmp);\n\t\t\n\t\ttmp[sa[0]] = 0;\n\t\tfor(i = 1; i <= len; i++) {\n\t\t\ttmp[sa[i]] = tmp[sa[i-1]]+(compare_sa(sa[i-1], sa[i])? 1: 0);\n\t\t}\n\t\tfor(i = 0; i <= len; i++) rank[i] = tmp[i];\n\t}\n}\n\n// 接尾辞配列を用いた文字列検索　len = strlen(s), plen = strlen(t)\nint contain(char *s, char *t)\n{\n\tint l, r, m;\n\n\tl = 0, r = len;\n\twhile (l+1 < r) {\n\t\tm = (l+r)>>1;\n\t\tif (memcmp(s+sa[m], t, plen) < 0) l = m; else r = m;\n\t}\n\treturn !memcmp(s+sa[r], t, plen);\n}\n\nint main()\n{\n\tint Q;\n\tchar c, *p;\n\n\tp = text;\n\twhile ((c = gc()) > ' ') *p++ = c;\n\t*p = 0;\n\tlen = p-text;\n\n\tconstruct_sa(text, sa);\n\n//for (int i = 0; i <= len; i++) printf(\"[%d] sa %d\\n\", i, sa[i]);\n\n\tQ = in();\n\twhile (Q--) {\n\t\tp = pattern;\n\t\twhile ((c = gc()) > ' ') *p++ = c;\n\t\t*p = 0;\n\t\tplen = p-pattern;\n\n\t\tpc('0' + contain(text, pattern));\n\t\tpc('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ ALDS1_14_D Multiple String Matching\n// 2018.5.9 bal4u\n\n#include <stdio.h>\n//#include <stdlib.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#define pc(c) putchar_unlocked(c)\n#else\n#define gc() getchar()\n#define pc(c) putchar(c)\n#endif\n\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nchar text[1000005];\nchar pattern[10005];\nint  next[10005], skip[260], g[10005];\n\nint bmMatch(char *text, int len, char *pattern, int patlen,\n              int *skip, int *next)\n{\n    int i, j;\n\n    i = patlen - 1;\n    while (i < len) {\n        j = patlen - 1;\n        while (j >= 0 && text[i] == pattern[j]) i--, j--;\n        if (j < 0) return 1;\n        if (skip[text[i]] >= next[j]) i += skip[text[i]];\n        else i += next[j];\n    }\n    return 0;\n}\n\nint bmSkip(int *skip, char *pattern, int patlen)\n{\n    int j;\n\n    for (j = 0; j < 256; j++) skip[j] = patlen;\n    for (j = 0; j < patlen - 1; j++) skip[pattern[j]] = patlen-1-j;\n    return 0;\n}\n\nint bmNext(int *next, int nlen, char *pattern, int patlen)\n{\n    int  j, k, s;\n\n    for (j = 0; j < patlen; j++) next[j] = 2*patlen - 1 - j;\n    j = patlen;\n    for (k = patlen - 1; k >= 0; k--) {\n        g[k] = j;\n        while (j != patlen && pattern[j] != pattern[k]) {\n            next[j] = (next[j] <= patlen-1-k) ? next[j] : patlen-1-k;\n            j = g[j];\n        }\n        j--;\n    }\n    s = j;\n    for (j = 0; j < patlen; j++) {\n        next[j] = (next[j] <= s+patlen-j) ? next[j] : s+patlen-j;\n        if (j >= s) s = g[s];\n    }\n    return 0;\n}\n\nint main()\n{\n\tint Q, c, tlen, plen;\n\tchar *p;\n\n\tp = text;\n\twhile ((c = gc()) > ' ') *p++ = c;\n\t*p = 0; tlen = p-text;\n\n\tQ = in();\n\twhile (Q--) {\n\t\tp = pattern;\n\t\twhile ((c = gc()) > ' ') *p++ = c;\n\t\t*p = 0; plen = p-pattern;\n\t\n\t    bmSkip(skip, pattern, plen);\n\t\tbmNext(next, plen, pattern, plen);\n \t\tpc('0' + bmMatch(text, tlen, pattern, plen, skip, next));\n\t\tpc('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint main(){\n  int i,n;\n  char T[100000],P[1000][1000];\n\n  scanf(\"%s\",T);\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)\n    scanf(\"%s\",P[i]);\n\n  for(i=0;i<n;i++){\n    if(strstr(T,P[i]) != NULL)printf(\"1\\n\");\n    else printf(\"0\\n\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_T 1000000\n#define MAX_P 1000\n\n/* p, pi is start from 1. */\nvoid computePrefixFunction(char *p, int plen, char *pi) {\n  int m, k, q;\n  m = plen;\n  pi[1] = 0;\n  k = 0;\n  for (q = 2; q <= m; q++) {\n    while (k > 0 && p[k+1] != p[q])\n      k = pi[k];\n    if (p[k+1] == p[q])\n      k++;\n    pi[q] = k;\n  }\n  pi[m+1] = '\\0';\n}\n\n/* t, p is start from 1. */\nint kmpMatcher(char *t, int tlen, char *p, int plen) {\n  int n, m;\n  char pi_start_from_0[MAX_P+1];\n  char *pi = pi_start_from_0 - 1;\n  int q, i;\n\n  n = tlen;\n  m = plen;\n  computePrefixFunction(p, plen, pi);\n  q = 0;\n  for (i = 1; i <= n; i++) {\n    while (q > 0 && t[q+1] != t[i])\n      q = pi[q];\n    if (p[q+1] == t[i])\n      q++;\n    if (q == m) {\n      /* printf(\"pattern is found at shift %d.\\n\", i - m); */\n      return 1;\n      q = pi[q];\n    }\n  }\n  return 0;\n}\n\nint main() {\n  char *t_start_from_0 = (char *)malloc(MAX_T+1);\n  char *t = t_start_from_0 - 1;\n  int tlen = 0;\n  char p_start_from_0[MAX_P+1];\n  char *p = p_start_from_0 - 1;\n  int plen = 0;\n  int q = 0;\n  int i;\n\n  if (t_start_from_0 == NULL) {\n    printf(\"memory shortage.\\n\");\n    return 1;\n  }\n\n  scanf(\"%s\", t_start_from_0);\n  tlen = strlen(t_start_from_0);\n  scanf(\"%d\", &q);\n  for (i = 0; i < q; i++) {\n    scanf(\"%s\", p_start_from_0);\n    plen = strlen(p_start_from_0);\n    printf(\"%d\\n\", kmpMatcher(t, tlen, p, plen));\n  }\n\n  free(t_start_from_0);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint max(int a, int b){\n  if( a > b )\n    return a;\n  return b;\n}\n\nint BM_search(char *T, char *P){\n\n  int shift[256];\n  int i,j,t_len,p_len;\n\n  t_len = strlen(T);\n  p_len = strlen(P);\n\n  for( i = 0 ; i < 256 ; i++ ){\n    shift[i] = p_len;\n  }\n\n  for( i = 0 ; i < p_len ; i++ ){\n    shift[P[i]] = p_len-i-1;\n  }\n\n  i = p_len-1;\n\n  while( i < t_len ){\n\n    j = p_len-1;\n\n    while( T[i] == P[j] ){\n\n      if( j == 0 ){\n        return i;\n      }\n\n      i--;\n      j--;\n   \n    }\n\n    i = i+max(shift[T[i]],p_len-j);\n\n  }\n\n  return -1;\n\n}\n\nint main(int argc, char const *argv[]) {\n\n  char T[1000001];\n  char P[1001];\n  int i;\n  int n;\n\n  scanf(\"%s\",T);\n  scanf(\"%d\",&n);\n\n  for( i = 0 ; i < n ; i++ ){\n    scanf(\"%s\",P);\n\n    if( BM_search(T,P) == -1 ){\n      printf(\"0\\n\");\n    }else{\n      printf(\"1\\n\");\n    }\n\n  }\n  \n  return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define LEN1 1000001\n#define LEN2 1001\nint main(void)\n{\n  char str1[LEN1],str2[LEN2];\n  char *adr;\n  int i,n;\n  scanf(\"%s\",str1);\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)\n    {\n      scanf(\"%s\",str2);\n      adr=strstr(str1,str2);\n      if(adr==NULL) printf(\"0\\n\");\n      else printf(\"1\\n\");\n    }\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#define KILO 1000\n#define MEGA (1000*1000)\n\n#define MAX_T (1 * MEGA)\n#define MAX_P (1 * KILO)\n#define MAX_PATTERN_NUMBER (10 * KILO)\n\n#define TYPE_NODE 1\n#define TYPE_LIST 2\n#define TYPE_EDGE 3\n\ntypedef struct node {\n  char type;\n  struct list *end;\n  struct edge_list *edge;\n} NODE;\n\nconst NODE INITIAL_NODE = { TYPE_NODE, NULL, NULL };\n\ntypedef struct list {\n  char type;\n  int index;\n  struct list *next;\n} LIST;\n\nconst LIST INITIAL_LIST = { TYPE_LIST, 0, NULL };\n\ntypedef struct edge_list {\n  char type;\n  char c;\n  struct edge_list *next;\n  struct node *node;\n} EDGE;\n\nconst EDGE INITIAL_EDGE = { TYPE_EDGE, '\\0', NULL, NULL };\n\ntypedef union unit {\n  struct node node;\n  struct list list;\n  struct edge_list edge;\n} UNIT;\n\nconst size_t MEM_MAX = 100;\n//const size_t MEM_MAX = 80 * KILO;\nUNIT *mem = NULL;\nsize_t cnt = 0;\n\nNODE* get_initial_node() {\n  assert(cnt < MEM_MAX);\n  NODE *res = &(mem[cnt++].node);\n  *res = INITIAL_NODE;\n  return res;\n}\n\nLIST* get_initial_list() {\n  assert(cnt < MEM_MAX);\n  LIST *res = &(mem[cnt++].list);\n  *res = INITIAL_LIST;\n  return res;\n}\n\nEDGE* get_initial_edge() {\n  assert(cnt < MEM_MAX);\n  EDGE *res = &(mem[cnt++].edge);\n  *res = INITIAL_EDGE;\n  return res;\n}\n\nNODE *root = NULL;\n\nNODE * make_or_get_next_node(NODE *cur, char c) {\n  //printf(\"make_or_get_next_node(%lx, %c)\\n\", (size_t)cur, c);\n  EDGE *next = cur->edge;\n  if (next == NULL) {\n    next = cur->edge = get_initial_edge();\n    next->c = c;\n    return (next->node = get_initial_node());\n  }\n  while (next->next != NULL && next->c != c) next = next->next;\n  if (next->c != c) {\n    next = next->next = get_initial_edge();\n    next->c = c;\n    return (next->node = get_initial_node());\n  } else {\n    return next->node;\n  }\n}\n\nvoid add_index(NODE *node, int index) {\n  if (node->end == NULL) {\n    node->end = get_initial_list();\n    node->end->index = index;\n  } else {\n    LIST *list = node->end;\n    while (list->next != NULL) list = list->next;\n    list = list->next = get_initial_list();\n    list->index = index;\n  }\n}\n\nvoid add(int index, char *str) {\n  char c = '\\0';\n  NODE *node = root;\n  while ((c = (*(str++))) != '\\0')\n    node = make_or_get_next_node(node, c);\n  add_index(node, index);\n}\n\nvoid match(char *str, char *res) {\n  NODE *node = root;\n  LIST *list = NULL;\n  char c = '\\0';\n  EDGE *edge = NULL;\n  for (int i = 0; i < 10; ++i) {\n  //while (1) {\n    //printf(\"in match: node = %lx\\n\", (size_t)node);\n    assert(node != NULL);\n    if ((list = node->end) != NULL) {\n      while (list != NULL) {\n        res[list->index] = '1';\n        list = list->next;\n      }\n    }\n    if ((c = *(str++)) == '\\0') return;\n    //printf(\"in match: c = %c\\n\", c);\n    edge = node->edge;\n    if (edge == NULL) return;\n    while (edge->c != c) {\n      edge = edge->next;\n      if (edge == NULL) return;\n    }\n    node = edge->node;\n  }\n}\n\nvoid print_tree(NODE *node, int offset) {\n  for (int i = 0; i < offset; ++i) printf(\" \");\n  printf(\"* \");\n  for (LIST *i = node->end; i != NULL; i = i->next) printf(\"%d \", i->index);\n  printf(\"\\n\");\n  for (EDGE *i = node->edge; i != NULL; i = i->next) {\n    for (int j = 0; j < offset; ++j) printf(\" \");\n    printf(\"%c\\n\", i->c);\n    print_tree(i->node, offset + 2);\n  }\n}\n\nvoid print_node(NODE *node) {\n  assert(node->type == TYPE_NODE);\n  printf(\"end-list = %lx, edge-list = %lx\\n\",\n    (size_t)node->end, (size_t)node->edge);\n}\n\nint main() {\n  assert(sizeof(UNIT) <= 24);\n  mem = calloc(MEM_MAX, sizeof(UNIT));\n  assert(mem);\n  char *str = malloc((MAX_T+1) * sizeof(char));\n  assert(str);\n  char *pat = malloc((MAX_P+1) * sizeof(char));\n  assert(pat);\n  char *res = malloc(MAX_PATTERN_NUMBER * sizeof(char));\n  assert(res);\n  for (int i = 0; i < MAX_PATTERN_NUMBER; ++i) res[i] = '0';\n\n  //printf(\"mem = %lx\\n\", (size_t)mem);\n  \n  scanf(\"%s\", str);\n  int q = 0;\n  scanf(\"%d\", &q);\n\n  root = get_initial_node();\n  for (int i = 0; i < q; ++i) {\n    scanf(\"%s\", pat);\n    add(i, pat);\n  }\n  //print_tree(root, 0);\n  for (char *s = str; s[0] != '\\0'; ++s) match(s, res);\n  \n  for (int i = 0; i < q; ++i) printf(\"%c\\n\", res[i]);\n\n  free(mem);\n  free(str);\n  free(pat);\n  free(res);\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n    public static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n    \tString str =sc.next();\n    \tint n=sc.nextInt();\n    \tString pi;\n    \tfor(int i=0;i<n;i++){\n    \t\tpi=sc.next();\n    \t\t\tstr=str.concat(\"..\");\n\n    \t\tfor(int j=0;j<str.length()-pi.length();j++){\n    \t\t\tif(str.substring(j, j+pi.length()).equals(pi)){\n    \t\t\t\tSystem.out.println(1);\n    \t\t\t\tbreak;\n    \t\t\t}else if(j==str.length()-pi.length()-1){\n    \t\t\t\tSystem.out.println(0);\n    \t\t\t}\n    \t\t\t\n    \t\t}\n    \t}\n    \t\n    \t\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nclass Main {\n\tfinal static int Code = 40;\n\t\n\tpublic static void main(String[] args)throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tchar[] A, B;\n\t\tboolean find = false;\n\t\t//??\\?????¨??¨??????char???????????£??\\\n\t\tA = br.readLine().toCharArray();\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tB = br.readLine().toCharArray();\n\t\t\t//A??????????????????????????????\n\t\t\tif(A.length < B.length) {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tint t = 0;\n\t\t\tint p = 0;\n\t\t\tint BN = search(Code, B.length);\n\t\n\t\t\tfor(int j = 0; j < B.length; j++){\n\t\t\t\tt = t * Code + A[j];\n\t\t\t\tp = p * Code + B[j];\n\t\t\t}\n\t\t\tfind = Print(t ,p, A, B, BN);\n\t\t\t\n\t\t\tif(find) System.out.println(\"1\");\n\t\t\telse System.out.println(\"0\");\n\t\t}\n\t\treturn;\n\t}\n\n\tpublic static int search(int x, int n){\n\t\tif(n == 0) return 1;\n\t\tint ret = search(x * x, n / 2);\n\t\t//??????????????????AND?????????\n\t\tif((n & 1) == 1) ret *= x;\n\t\treturn ret;\n\t}\n\n\tpublic static boolean Print(int t, int p, char[] A, char[] B, int BN){\n\t\t//t??¨p?????????????????????????????¨???\n\t\tif(t == p) return true;\n\t\tfor(int i = 1; i < A.length - B.length + 1; i++){\n\t\t\tt = t * Code + A[i + B.length - 1] - A[i - 1] * BN;\n\t\t\tif(t == p) return true;\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.PrimitiveIterator;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntUnaryOperator;\n\n\npublic class Main {\n    public static void main(String[] args) {\n        StringBuilder out = new StringBuilder();\n        solve(out);\n        PrintWriter pw = new PrintWriter(System.out);\n        pw.println(out);\n        pw.flush();\n        pw.close();\n    }\n\n    public static void solve(StringBuilder out) {\n        char[] s = In.nc();\n        Matching m = new Matching(s);\n        int q = In.ni();\n        int[] ans = new int[q];\n        for (int i = 0; i < q; i++) {\n            char[] t = In.nc();\n            ans[i] = m.query(t) < 0 ? 0 : 1;\n        }\n        out.append(IntArrays.join(ans, \"\\n\"));\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Ints {\n    private Ints(){}\n\n    public static boolean isPowerOfTwo(int n) {\n        return n != 0 && (-n & n) == n;\n    }\n\n    public static int ceilExponent(int n) {\n        return 31 - Integer.numberOfLeadingZeros(n) + (isPowerOfTwo(n) ? 0 : 1);\n    }\n\n    public static int floorExponent(int n) {\n        return 31 - Integer.numberOfLeadingZeros(n) + (n == 0 ? 1 : 0);\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass In {\n    public static final FastScanner fsc = new FastScanner();\n\n    public static int ni() {\n        return fsc.nextInt();\n    }\n\n    public static char[] nc() {\n        return fsc.next().toCharArray();\n    }\n}\n\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte()) {\n            return buffer[ptr++];\n        } else {\n            return -1;\n        }\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n            ptr++;\n        }\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n            throw new NumberFormatException();\n        }\n        return (int) nl;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass MathUtil{\n    private static final long UNDER32_MASK = 0xffff_ffffl;\n\n    private MathUtil(){}\n\n    public static long int2ToLong(int upper, int lower) {\n        return ((long) upper << Integer.SIZE) | lower;\n    }\n\n    public static int upper32(long l) {\n        return (int) (l >>> Integer.SIZE);\n    }\n\n    public static int lower32(long l) {\n        return (int) (l & UNDER32_MASK);\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n * \n * 1. DESTRUCTIVE methods for int arrays.\n * 2. methods that receives arrays and return some results (except for int arrays).\n */\nclass IntArrays {\n\n    private IntArrays(){}\n\n    public static void map(int[] a, IntUnaryOperator op) {\n        for (int i = 0; i < a.length; i++) {\n            a[i] = op.applyAsInt(a[i]);\n        }\n    }\n\n    public static void filter(int[] src, int[] dst, IntPredicate p) {\n        int idx = 0;\n        for (int e : src) {\n            if (p.test(e)) {\n                dst[idx++] = e;\n            }\n        }\n    }\n\n    public static void filterIndex(int[] dst, int beginIndex, int endIndex, IntPredicate p) {\n        for (int i = beginIndex, idx = 0; i < endIndex; i++) {\n            if (p.test(i)) {\n                dst[idx++] = i;\n            }\n        }\n    }\n\n    public static void filterIndex(int dst[], int endIndex, IntPredicate p) {\n        filterIndex(dst, 0, endIndex, p);\n    }\n\n    public static void accumulate(int[] a, IntBinaryOperator op) {\n        for (int i = 1; i < a.length; i++) {\n            a[i] = op.applyAsInt(a[i - 1], a[i]);\n        }\n    }\n\n    public static void accumulate(int[] a) {\n        for (int i = 1; i < a.length; i++) {\n            a[i] += a[i - 1];\n        }\n    }\n\n    public static String join(int[] a, String sep) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(a[i]);\n            if (i < a.length - 1) {\n                sb.append(sep);\n            }\n        }\n        return sb.toString();\n    }\n}\n\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass IntArrayList implements Iterable<Integer> {\n    private int[] a;\n    private int tail = 0;\n\n    private static final int DEFAULT_SIZE = 64;\n\n    public IntArrayList(int capacity) {\n        this.a = new int[Math.max(1, capacity)];\n    }\n\n    public IntArrayList() {\n        this(DEFAULT_SIZE);\n    }\n\n    public void add(int v) {\n        if (tail == a.length) {\n            resize(2);\n        }\n        a[tail++] = v;\n    }\n\n    public int removeLast() {\n        return a[tail--];\n    }\n\n    public int get(int i) {\n        if (i >= this.tail) {\n            System.err.println(\"Error in IntArrayList::get(\" + i + \"): ArrayIndexOutOfBounds. list size = \" + tail);\n        }\n        return a[i];\n    }\n\n    public void set(int i, int v) {\n        if (i >= this.tail) {\n            System.err.println(\"Error in IntArrayList::set(\" + i + \"): ArrayIndexOutOfBounds. list size = \" + tail);\n        }\n        a[i] = v;\n    }\n\n    private void resize(double grow) {\n        int[] b = new int[(int) Math.ceil(a.length * grow)];\n        System.arraycopy(a, 0, b, 0, a.length);\n        a = b;\n    }\n\n    public int size() {\n        return tail;\n    }\n\n    public int[] toArray() {\n        int[] ret = new int[tail];\n        System.arraycopy(a, 0, ret, 0, tail);\n        return ret;\n    }\n\n    public boolean addIf(int v, IntPredicate p) {\n        if (p.test(v)) {\n            add(v);\n            return true;\n        }\n        return false;\n    }\n\n    public PrimitiveIterator.OfInt iterator() {\n        return new IntArrayListIterator();\n    }\n\n    private class IntArrayListIterator implements PrimitiveIterator.OfInt {\n        private int i = 0;\n\n        public boolean hasNext() {\n            return i < tail;\n        }\n\n        public int nextInt() {\n            return a[i++];\n        }\n    }\n}\n\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n * \n * (NON-DESTRUCTIVE) methods that returns int array.\n */\nclass IntArrayGenerator {\n\n    private IntArrayGenerator(){}\n    \n    public static int[] filled(int n, int init) {\n        int[] ret = new int[n];\n        Arrays.fill(ret, init);\n        return ret;\n    }\n\n    public static int[][] filled(int n, int m, int init) {\n        int[][] ret = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(ret[i], init);\n        }\n        return ret;\n    }\n\n    public static int[] indexToInt(int n, IntUnaryOperator f) {\n        int[] a = new int[n];\n        Arrays.setAll(a, f);\n        return a;\n    }\n\n    public static int[] count(int[] a, int max) {\n        int[] ret = new int[max + 1];\n        for (int i = 0; i < a.length; i++) {\n            ret[a[i]]++;\n        }\n        return ret;\n    }\n\n    public static int[] map(int[] a, IntUnaryOperator f) {\n        int[] b = new int[a.length];\n        Arrays.setAll(b, i -> f.applyAsInt(a[i]));\n        return b;\n    }\n\n    public static int[] filter(int[] a, IntPredicate p) {\n        IntArrayList ret = new IntArrayList();\n        for (int e : a) {\n            ret.addIf(e, p);\n        }\n        return ret.toArray();\n    }\n\n    public static int[] filterIndex(int beginIndex, int endIndex, IntPredicate p) {\n        IntArrayList ret = new IntArrayList();\n        for (int i = beginIndex; i < endIndex; i++) {\n            ret.addIf(i, p);\n        }\n        return ret.toArray();\n    }\n\n    public static int[] filterIndex(int endIndex, IntPredicate p) {\n        return filterIndex(0, endIndex, p);\n    }\n\n    public static int[] accumulate(int[] a, IntBinaryOperator op) {\n        int n = a.length;\n        int[] ret = new int[n];\n        ret[0] = a[0];\n        for (int i = 1; i < n; i++) {\n            ret[i] = op.applyAsInt(ret[i - 1], a[i]);\n        }\n        return ret;\n    }\n\n    public static int[] accumulate(int[] a) {\n        int n = a.length;\n        int[] ret = new int[n];\n        ret[0] = a[0];\n        for (int i = 1; i < n; i++) {\n            ret[i] = ret[i - 1] + a[i];\n        }\n        return ret;\n    }\n}\n\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n * \n * Implements SA-IS (buildSuffixArray Suffix Array in O(n) time.)\n */\nclass SuffixArray {\n    private final int n;\n    private final int[] sa;\n    private final int[] lcp;\n    private final int[] rank;\n\n    public SuffixArray(char[] s) {\n        this.n = s.length;\n        this.sa = new int[n + 1];\n        this.lcp = new int[n + 1];\n        this.rank = new int[n + 1];\n        final int[] t = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            t[i] = s[i];\n        }\n        buildSuffixArray(t);\n        buildRankArray();\n        buildLongestCommonPrefixArray(t);\n    }\n\n    public SuffixArray(String s) {\n        this(s.toCharArray());\n    }\n\n    private SuffixArray(int[] s) {\n        this.n = s.length;\n        this.sa = new int[n + 1];\n        this.lcp = sa; // dummy\n        this.rank = sa; //dummy\n        final int[] t = new int[n + 1];\n        System.arraycopy(s, 0, t, 0, n);\n        buildSuffixArray(t);\n    }\n\n    public int[] getSA() {\n        int[] ret = new int[n];\n        System.arraycopy(sa, 1, ret, 0, n);\n        return ret;\n    }\n\n    public int[] getRank() {\n        int[] ret = new int[n];\n        for (int i = 1; i <= n; i++) {\n            ret[sa[i]] = i - 1;\n        }\n        return ret;\n    }\n\n    public int[] getLCP() {\n        int[] ret = new int[n];\n        System.arraycopy(lcp, 1, ret, 0, n);\n        return ret;\n    }\n\n    private boolean isLms(int i, boolean[] isL) {\n        return i > 0 && isL[i - 1] && !isL[i];\n    }\n\n    private void buildSuffixArray(int[] t) {\n        /**\n         * the number of lms-type.\n         */\n        int lmsNum = 0;\n        final boolean[] isL = new boolean[n + 1];\n        for (int i = n - 1; i >= 0; i--) {\n            isL[i] = t[i + 1] < t[i] || t[i + 1] == t[i] && isL[i + 1];\n            if (isL[i] && !isL[i + 1]) {\n                lmsNum++;\n            }\n        }\n        /**\n         * index of lms's.\n         */\n        int[] lmss = IntArrayGenerator.filterIndex(n + 1, i -> isLms(i, isL));\n        inducedSort(t, isL, lmss);\n        /**\n         * get sorted 'lmss-substring's.\n         */\n        int[] pseudoSortedLmss = IntArrayGenerator.filter(sa, e -> isLms(e, isL));\n        /**\n         * recycle. labeling lms-substrings.\n         */\n        int[] lmsLabels = sa;\n        Arrays.fill(lmsLabels, -1);\n        int label = 1;\n        lmsLabels[pseudoSortedLmss[0]] = label;\n        for (int k = 1; k < lmsNum ; k++) {\n            boolean dif = false;\n            for (int d = 0, i = pseudoSortedLmss[k - 1], j = pseudoSortedLmss[k];; d++, i++, j++) {\n                if (t[i] != t[j] || (isLms(i, isL) ^ isLms(j, isL))) {\n                    dif = true;\n                    break;\n                } else if (d > 0 && isLms(i, isL) && isLms(j, isL)) {\n                    break;\n                }\n            }\n            lmsLabels[pseudoSortedLmss[k]] = dif ? ++label : label;\n        }\n        /**\n         * recycle.\n         */\n        int[] compactLabels = pseudoSortedLmss;\n        IntArrays.filter(lmsLabels, compactLabels, e -> e >= 0);\n        lmsLabels = null;\n        /**\n         * get Suffix Array of lms-substrings.\n         */\n        int[] lmsSA;\n        if (label < lmsNum) {\n            lmsSA = new SuffixArray(compactLabels).getSA();\n        } else {\n            lmsSA = new int[lmsNum];\n            for (int i = 0; i < lmsNum; i++) {\n                lmsSA[compactLabels[i] - 1] = i;\n            }\n        }\n        /**\n         * recycle. an array of completely-sorted lms-substrings.\n         */\n        int[] sortedLmss = lmsSA;\n        for (int i = 0; i < lmsNum; i++) {\n            sortedLmss[i] = lmss[lmsSA[i]];\n        }\n        lmss = null;\n        inducedSort(t, isL, sortedLmss);\n    }\n\n    private void inducedSort(int[] t, boolean[] isL, int[] lmss) {\n        Arrays.fill(sa, -1);\n        /**\n         * the beginnig index of bucket.\n         */\n        final int[] end = IntArrayGenerator.count(t, Math.max(Chars.SIZE, t.length));\n        IntArrays.accumulate(end);\n        /**\n         * put LMS-Type-index on SA. (front <- back)\n         */\n        final int[] inserted = new int[end.length];\n        for (int i = lmss.length - 1; i >= 0; i--) {\n            int c = t[lmss[i]];\n            sa[end[c] - 1 - inserted[c]] = lmss[i];\n            inserted[c]++;\n        }\n        /**\n         * put L-type-index on SA. (front -> back)\n         */\n        Arrays.fill(inserted, 0);\n        for (int i = 0; i <= n; i++) {\n            int pre = sa[i] - 1;\n            if (pre >= 0 && isL[pre]) {\n                int prec = t[pre];\n                sa[end[prec - 1] + inserted[prec]] = pre;\n                inserted[prec]++;\n            }\n        }\n        /**\n         * put S-Type-index on SA. (back -> front)\n         */\n        Arrays.fill(inserted, 0);\n        for (int i = n; i >= 0; i--) {\n            int pre = sa[i] - 1;\n            if (pre >= 0 && !isL[pre]) {\n                int prec = t[pre];\n                sa[end[prec] - 1 - inserted[prec]] = pre;\n                inserted[prec]++;\n            }\n        }\n    }\n\n    private void buildRankArray() {\n        for (int i = 0; i <= n; i++) {\n            rank[sa[i]] = i;\n        }\n    }\n\n    private void buildLongestCommonPrefixArray(int[] t) {\n        for (int i = 0, k = 0; i <= n; i++, k = k > 0 ? k - 1 : k) {\n            int idx = rank[i];\n            if (idx == n) {\n                k = 0;\n                continue;\n            }\n            int j = sa[idx + 1];\n            while (t[i + k] == t[j + k]) {\n                k++;\n            }\n            lcp[idx] = k;\n        }\n    }\n}\n\nclass Matching {\n    private final int n; // the length of S.\n    private final char[] s; // String S.\n    private final int[] sa; // suffix array of S.\n    private final int[] seg; // 1-indexed SegmentTree.\n    private final int btm; // the size of the lowest level of the segTree.\n\n    public Matching(char[] s) {\n        SuffixArray a = new SuffixArray(s);\n        this.n = s.length;\n        this.s = s;\n        this.sa = a.getSA();\n        this.btm = 1 << Ints.ceilExponent(n);\n        this.seg = new int[btm << 1];\n        buildSegTree(a.getLCP());\n    }\n\n    public int query(char[] t) {\n        int l = 0, r = btm;\n        int ltlcp = MathUtil.upper32(lcpAndCmp(t, 0, 0));\n        int k = 1;\n        while (r - l > 1) {\n            int m = (l + r) >> 1;\n            int lmlcp = seg[k << 1];\n            if (lmlcp == Const.IINF || ltlcp > lmlcp) {\n                r = m;\n            } else if (ltlcp < lmlcp) {\n                l = m;\n            } else {\n                long p = lcpAndCmp(t, m, ltlcp);\n                int lcp = MathUtil.upper32(p);\n                int cmp = MathUtil.lower32(p);\n                if (cmp >= 0) {\n                    l = m;\n                    ltlcp = lcp;\n                } else {\n                    r = m;\n                }\n            }\n            k = r == m ? k << 1 : (k << 1) | 1;\n        }\n        return ltlcp == t.length ? l : -1;\n    }\n\n    private long lcpAndCmp(char[] t, int index, int offset) {\n        if (index >= n) {\n            return MathUtil.int2ToLong(offset, -1);\n        }\n        int ti = offset;\n        int si = sa[index] + offset;\n        while (ti < t.length && si < n) {\n            if (t[ti] == s[si]) {\n                ti++;\n                si++;\n            } else {\n                return MathUtil.int2ToLong(ti, t[ti] - s[si]);\n            }\n        }\n        return MathUtil.int2ToLong(ti, 0);\n    }\n\n    private void buildSegTree(int[] lcp) {\n        System.arraycopy(lcp, 0, seg, btm, n);\n        for (int i = btm + n; i < seg.length; i++) {\n            seg[i] = Const.IINF;\n        }\n        for (int i = btm - 1; i >= 1; i--) {\n            seg[i] = Math.min(seg[i << 1], seg[(i << 1) | 1]);\n        }\n    }\n}\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Const {\n    public static final long MOD7 = 1_000_000_007;\n    public static final long MOD9 = 1_000_000_009;\n    public static final long MOD99 = 998_244_353;\n\n    public static final long LINF = Long.MAX_VALUE >> 2;\n    public static final int IINF = Integer.MAX_VALUE >> 1;\n\n    private Const(){}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Chars {\n    public static final int SIZE = 128;\n\n    private Chars(){}\n\n    public static int[] count(char[] s) {\n        int[] cnt = new int[SIZE];\n        int n = s.length;\n        for (int i = 0; i < n; i++) {\n            cnt[s[i]]++;\n        }\n        return cnt;\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tchar[] t = sc.next().toCharArray();\n\t\tSuffixArray sa = new SuffixArray(t);\n\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tString p = sc.next();\n\n\t\t\tif (sa.contains(p.toCharArray())) {\n\t\t\t\tpr.println(\"1\");\n\t\t\t} else {\n\t\t\t\tpr.println(\"0\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class SuffixArray {\n\t\tchar[] s;\n\t\tint n;\n\n\t\tInteger[] sa;\n\t\tint[] rank;\n\t\tint[] rtmp;\n\t\tSaComparator sac;\n\n\t\tint k;\n\n\t\tSuffixArray(char[] str) {\n\t\t\tthis.s = str;\n\t\t\tn = s.length;\n\n\t\t\tsa = new Integer[n + 1];\n\t\t\trank = new int[n + 1];\n\t\t\trtmp = new int[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tsa[i] = i;\n\t\t\t\tif (i < n) {\n\t\t\t\t\trank[i] = s[i];\n\t\t\t\t} else {\n\t\t\t\t\trank[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsac = new SaComparator();\n\n\t\t\tfor (k = 1; k < n; k *= 2) {\n\t\t\t\tArrays.sort(sa, sac);\n\n\t\t\t\trtmp[sa[0]] = rank[sa[0]];\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tif (sac.compare(sa[i - 1], sa[i]) == 0) {\n\t\t\t\t\t\trtmp[sa[i]] = rtmp[sa[i - 1]];\n\t\t\t\t\t} else {\n\t\t\t\t\t\trtmp[sa[i]] = rtmp[sa[i - 1]] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint[] tmp = rtmp;\n\t\t\t\trtmp = rank;\n\t\t\t\trank = tmp;\n\t\t\t}\n\t\t}\n\n\t\tboolean contains(char[] t) {\n\t\t\tint l = 0;\n\t\t\tint r = n;\n\t\t\twhile (r > l) {\n\t\t\t\tint mid = l + (r - l) / 2;\n\t\t\t\tint res = compare(s, mid, t);\n\n\t\t\t\tif (res >= 0) {\n\t\t\t\t\tr = mid;\n\t\t\t\t} else {\n\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn compare(s, l, t) == 0;\n\t\t}\n\n\t\tint compare(char[] s, int mid, char[] t) {\n\t\t\tint m = t.length;\n\n\t\t\tfor (int i = 0; sa[mid] + i < n && i < m; i++) {\n\t\t\t\tint res = s[sa[mid] + i] - t[i];\n\n\t\t\t\tif (res != 0) {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sa[mid] + m < m) {\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tprivate class SaComparator implements Comparator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic int compare(Integer i, Integer j) {\n\t\t\t\tif (rank[i] != rank[j]) {\n\t\t\t\t\treturn Integer.compare(rank[i], rank[j]);\n\t\t\t\t}\n\n\t\t\t\tint ri = i + k <= n ? rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? rank[j + k] : -1;\n\t\t\t\treturn Integer.compare(ri, rj);\n\t\t\t}\n\n\t\t}\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n\t\tpr.close();\n\t\tsc.close();\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t// parseInt from Integer.parseInt()\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t// parseLong from Long.parseLong()\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(PrintStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tfinal boolean DEBUG = false;\n\tint[] rank, tmp;\n\tint n, k;\n\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tString t = scan.next();\n\t\tint q = scan.nextInt();\n\t\tInteger[] sa = new Integer[t.length() + 1];\n\t\trank = new int[t.length() + 1];\n\t\ttmp = new int[t.length() + 1];\n\t\tconstructSA(t.toCharArray(), sa);\n\t\tif (DEBUG)\n\t\t\tSystem.out.println(Arrays.toString(sa));\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tString p = scan.next();\n\t\t\tSystem.out.println(contain(t, sa, p) ? 1 : 0);\n\t\t}\n\t}\n\n\tboolean contain(String s, Integer[] sa, String t) {\n\t\tint a = 0, b = s.length(), subIndex = 0;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tsubIndex = sa[c] + t.length() > s.length() ? s.length() : sa[c] + t.length();\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.print(sa[c] + \" \" + (sa[c] + t.length()));\n\t\t\t\tSystem.out.print(\", cmp: \" + (s.substring(sa[c], subIndex).compareTo(t) < 0));\n\t\t\t\tSystem.out.println(\", str: \" + s.substring(sa[c], subIndex));\n\t\t\t}\n\t\t\tif (s.substring(sa[c], subIndex).compareTo(t) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\tsubIndex = sa[b] + t.length() > s.length() ? s.length() : sa[b] + t.length();\n\t\treturn s.substring(sa[b], subIndex).compareTo(t) == 0;\n\t}\n\n\tboolean compareSA(int i, int j) {\n\t\tif (rank[i] != rank[j]) return rank[i] < rank[j];\n\t\telse {\n\t\t\tint ri = i + k <= n ? rank[i + k] : -1;\n\t\t\tint rj = j + k <= n ? rank[j + k] : -1;\n\t\t\treturn ri < rj;\n\t\t}\n\t}\n\n\tvoid constructSA(char[] s, Integer[] sa) {\n\t\tn = s.length;\n\t\t\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? s[i] : -1;\n\t\t}\n\n\t\tComparator<Integer> compare_sa = new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer i, Integer j) {\n\t\t\t\tif (rank[i] != rank[j]) return rank[i] == rank[j] ? 0 : (rank[i] < rank[j] ? -1 : 1);\n\t\t\t\telse {\n\t\t\t\t\tint ri = i + k <= n ? rank[i + k] : -1;\n\t\t\t\t\tint rj = j + k <= n ? rank[j + k] : -1;\n\t\t\t\t\treturn ri == rj ? 0 : (ri < rj ? -1 : 1);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tfor (k = 1; k <= n; k *= 2) {\n\t\t\tArrays.sort(sa, 0, n + 1, compare_sa);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (compareSA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\trank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n    \tString str =sc.next();\n    \tint n=sc.nextInt();\n    \tString pi;\n    \tfor(int i=0;i<n;i++){\n    \t\tpi=sc.next();\n    \t\t\tstr=str.concat(\"..\");\n\n    \t\tfor(int j=0;j<str.length()-pi.length();j++){\n    \t\t\tif(str.substring(j, j+pi.length()).equals(pi)){\n    \t\t\t\tSystem.out.println(1);\n    \t\t\t\tbreak;\n    \t\t\t}else if(j==str.length()-pi.length()-1){\n    \t\t\t\tSystem.out.println(0);\n    \t\t\t}\n    \t\t\t\n    \t\t}\n    \t}\n    \t\n    \t\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String literal = sc.nextLine();\n        int encount = Integer.parseInt(sc.nextLine());\n        \n        for(int i=0;i<encount;i++){\n        \tString line = sc.nextLine();\n        \tif(line.indexOf(line)==-1){\n        \t\tSystem.out.println(0);\n        \t}else{\n        \t\tSystem.out.println(1);\n        \t}\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tString t = scan.next();\n\t\tStringIndex si = new StringIndex(t, false);\n\n\t\tint q = scan.nextInt();\n\t\tfor(int i = 0; i < q; i++)\n\t\t\tif(si.isExist(scan.next(), t))\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"0\");\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass StringIndex{\n\tclass StIdx{\n\t\tint pos;\n\t\tchar ch;\n\n\t\tpublic StIdx(int i, char c){\n\t\t\tpos = i;\n\t\t\tch = c;\n\t\t}\n\t}\n\n\tList<StIdx> idx = new ArrayList<StIdx>();\n\tint[] seq;\n\tint compLen = 1;\n\tboolean debug;\n\n\tpublic StringIndex(String t, boolean d){\n\t\tdebug = d;\n\n\t\tseq = new int[t.length()];\n\t\tfor(int i = 0; i < t.length(); i++)\n\t\t\tidx.add(new StIdx(i, t.charAt(i)));\n\n\t\tfor(compLen =1; compLen < idx.size() * 2; compLen *= 2){\n\t\t\tCollections.sort(idx, new strIndexComp());\n\n\t\t\tint[] tmp = new int[seq.length];\n\n\t\t\ttmp[idx.get(0).pos] = 1;\n\t\t\tfor(int i = 1; i < tmp.length; i++)\n\t\t\t\tif(idxComp(idx.get(i-1), idx.get(i)) == 0)\n\t\t\t\t\ttmp[idx.get(i).pos] = tmp[idx.get(i-1).pos];\n\t\t\t\telse\n\t\t\t\t\ttmp[idx.get(i).pos] = tmp[idx.get(i-1).pos] + 1;\n\n\t\t\tfor(int i = 0; i < seq.length; i++)\n\t\t\t\tseq[i] = tmp[i];\n\n\t\t\tif(debug){\n\t\t\t\tSystem.out.println(\"------------\");\n\t\t\t\tfor(int i = 0; i < idx.size(); i++)\n\t\t\t\t\tSystem.out.println(i + \"\\t\" + seq[idx.get(i).pos] + \"\\t\" + idx.get(i).pos + \"\\t\"\n\t\t\t\t\t\t+ t.substring(idx.get(i).pos));\n\t\t\t}\n\t\t}\n\t}\n\n\tclass strIndexComp implements Comparator<StIdx>{\n\n\t\t@Override\n\t\tpublic int compare(StIdx o1, StIdx o2){\n\t\t\treturn idxComp(o1, o2);\n\t\t}\n\t}\n\n\tprivate int idxComp(StIdx o1, StIdx o2){\n\t\tif(compLen == 1)\n\t\t\tif(o1.ch > o2.ch)\n\t\t\t\treturn 1;\n\t\t\telse if(o1.ch == o2.ch)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn -1;\n\n\t\t\tif(seq[o1.pos] > seq[o2.pos])\n\t\t\t\treturn 1;\n\t\t\tif(seq[o1.pos] == seq[o2.pos]){\n\t\t\t\tint npos1 = o1.pos + compLen / 2;\n\t\t\t\tint npos2 = o2.pos + compLen / 2;\n\t\t\t\tint nseq1 = 0, nseq2 = 0;\n\t\t\t\tif(npos1 < seq.length)\n\t\t\t\t\tnseq1 = seq[npos1];\n\t\t\t\tif(npos2 < seq.length)\n\t\t\t\t\tnseq2 = seq[npos2];\n\t\t\t\tif(nseq1 > nseq2)\n\t\t\t\t\treturn 1;\n\t\t\t\telse if(nseq1 == nseq2)\n\t\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn -1;\n\t}\n\n\tpublic boolean isExist(String p, String t){\n\t\tint low = 0, hi = idx.size() - 1;\n\t\treturn (findBin(p, t, low, hi));\n\t}\n\n\tprivate boolean findBin(String p, String t, int low, int hi){\n\t\tif(low > hi)\n\t\t\treturn false;\n\t\tint i = low + (hi - low) / 2;\n\t\tint len = p.length();\n\t\tif(len > t.length() - idx.get(i).pos)\n\t\t\tlen = t.length() - idx.get(i).pos;\n\n\t\tint r = p.substring(0, len).compareTo(t.substring(idx.get(i).pos, idx.get(i).pos + len));\n\t\tif(r == 0)\n\t\t\tif(len == p.length())\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn findBin(p, t, i+1, hi);\n\t\telse if(r < 0)\n\t\t\treturn findBin(p, t, low, i-1);\n\t\telse\n\t\t\treturn findBin(p, t, i+1, hi);\n\t}\n}\n\n/*\npublic interface List<E> extends Collection<E>{\n\tdefault void sort(Comparator<? super E> c){\n\t\tfor(int i = 0; size()-1; i++){\n\t\t\tE min = get(i);\n\t\t\tint minIndex = i;\n\t\t\tfor(int j = size(); --j>i;){\n\t\t\t\tE e = get(j);\n\t\t\t\tif(c.compare(min, e) > 0){\n\t\t\t\t\tmin = e;\n\t\t\t\t\tminIndex = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(minIndex != i){\n\t\t\t\tset(minIndex, get(i));\n\t\t\t\tset(i, min);\n\t\t\t}\n\t\t}\n\t}\n}\n//????????????????????????\n*/"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Scanner;\nclass Main {\n  \tpublic static void main(String[] args)throws IOException{\n\t\tScanner scan = new Scanner(System.in);\n\t\tString str1 = scan.next();\n\t\tint n = scan.nextInt();\n\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tString str2 = scan.next();\n\t\t\tint nt = str1.length();\n\t\t\tint np = str2.length();\n\t\t\tboolean check = false;\n\n\t\t\tif(nt < np) return;\n\n\t\t\tfor(int i = 0; i < nt - np + 1; i++){\n\t\t\t\t//?????????????????????????????????????????????????????????????????????\n\t\t\t\tif(str1.charAt(i) == str2.charAt(0) && str1.charAt(i + np - 1) == str2.charAt(np - 1)){\n\t\t\t\t\tif(str1.substring(i, np + i).equals(str2)){\n\t\t\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\t\t\tcheck =true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!check) System.out.println(\"0\");\n\t\t}\n\n\t\treturn;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nclass Main {\n\tfinal static int Code = 10;\n\t\n\tpublic static void main(String[] args)throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tchar[] A, B;\n\t\tboolean find = false;\n\t\t//??\\?????¨??¨??????char???????????£??\\\n\t\tA = br.readLine().toCharArray();\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tB = br.readLine().toCharArray();\n\t\t\t//A??????????????????????????????\n\t\t\tif(A.length < B.length) {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tint t = 0;\n\t\t\tint p = 0;\n\t\t\tint BN = search(Code, B.length);\n\t\n\t\t\tfor(int j = 0; j < B.length; j++){\n\t\t\t\tt = t * Code + A[j];\n\t\t\t\tp = p * Code + B[j];\n\t\t\t}\n\t\t\tfind = Print(t ,p, A, B, BN);\n\t\t\t\n\t\t\tif(find) System.out.println(\"1\");\n\t\t\telse System.out.println(\"0\");\n\t\t}\n\t\treturn;\n\t}\n\n\tpublic static int search(int x, int n){\n\t\tif(n == 0) return 1;\n\t\tint ret = search(x * x, n / 2);\n\t\t//??????????????????AND?????????\n\t\tif((n & 1) == 1) ret *= x;\n\t\treturn ret;\n\t}\n\n\tpublic static boolean Print(int t, int p, char[] A, char[] B, int BN){\n\t\t//t??¨p?????????????????????????????¨???\n\t\tif(t == p) return true;\n\t\tfor(int i = 1; i < A.length - B.length + 1; i++){\n\t\t\tt = t * Code + A[i + B.length - 1] - A[i - 1] * BN;\n\t\t\tif(t == p) return true;\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tString t = scan.next();\n\n\t\tint q = scan.nextInt();\n\t\tString[] p = new String[q];\n\t\tfor (int i = 0; i < q; i++)\n\t\t\tp[i] = scan.next();\n\n\t\tPtFind f = new PtFind(t, p, false);\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass PtFind {\n\tboolean debug;\n\tint _p = 101;\n\tint _m = 100000;\n\n\tpublic PtFind(String t, String[] p, boolean d) {\n\t\tdebug = d;\n\n\t\tboolean[] result = new boolean[p.length];\n\t\tint[] length = new int[p.length];\n\t\tint[] hash = new int[p.length];\n\t\tList<Integer> unresolve = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\tlength[i] = p[i].length();\n\t\t\thash[i] = getHash(p[i], 0, length[i]);\n\t\t\tunresolve.add(i);\n\t\t}\n\n\t\tint[] thash = new int[1001];\n\t\tint[] tcalc = new int[1001];\n\t\tint[] multi = new int[1001];\n\t\tmulti[0] = 1;\n\t\tfor (int i = 1; i < tcalc.length; i++) {\n\t\t\ttcalc[i] = -1;\n\t\t\tmulti[i] = multi[i - 1] * _p;\n\t\t\tmulti[i] %= _m;\n\t\t}\n\t\tfor (int i = 0; i < length.length; i++) {\n\t\t\tint le = length[i];\n\t\t\tif (le < t.length() && tcalc[le] == -1) {\n\t\t\t\ttcalc[le] = 0;\n\t\t\t\tthash[le] = getHash(t, 0, le);\n\t\t\t}\n\t\t}\n\n\t\tfor (int st = 0; st < t.length(); st++) {\n\t\t\tfor (int i = 0; i < length.length; i++) {\n\t\t\t\tif (result[i])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tint le = length[i];\n\t\t\t\tif (st + le > t.length())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (tcalc[le] != st) {\n\t\t\t\t\ttcalc[le] = st;\n\t\t\t\t\tthash[le] = (thash[le] * _p) + t.charAt(st + le - 1);\n\t\t\t\t\tint mn = (t.charAt(st - 1) * multi[le]) % _m;\n\t\t\t\t\tthash[le] = (thash[le] + _m - mn) % _m;\n\t\t\t\t}\n\n\t\t\t\tif (debug)\n\t\t\t\t\tSystem.out.println(p[i] + \"\\t\" + hash[i] + \"\\t\" + t.substring(st, st + le) + \"\\t\" + thash[le]);\n\n\t\t\t\tif (thash[le] == hash[i])\n\t\t\t\t\tif (p[i].equals(t.substring(st, st + le)))\n\t\t\t\t\t\tresult[i] = true;\n\t\t\t}\n\n\t\t}\n\n\t\tfor (int i = 0; i < result.length; i++)\n\t\t\tif (result[i])\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"0\");\n\t}\n\n\tprivate int getHash(String s, int start, int length) {\n\t\tint ret = 0;\n\t\tfor (int i = start; i < start + length; i++) {\n\t\t\tret *= _p;\n\t\t\tret += s.charAt(i);\n\t\t\tret %= _m;\n\t\t}\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\t// write your code here\n        Scanner scanner=new Scanner(System.in);\n        String T=scanner.next();\n        int q=scanner.nextInt();\n        List<char[]> missMatchList=new ArrayList<>();\n        for(int i=0;i<q;i++){\n            if(isConclude(T,scanner.next(),missMatchList)){\n                System.out.println(1);\n            }else{\n                System.out.println(0);\n            }\n        }\n    }\n    public static boolean isConclude(String original, String part,List<char[]> list){\n        char[] originalChars=original.toCharArray();\n        char[] partChars=part.toCharArray();\n        return isConclude(originalChars,partChars,list);\n    }\n    public static boolean isConclude(char[] original, char[] part,List<char[]> list){\n        for(int i=0;i<=original.length-part.length;i++){\n            if(part[0]==original[i]){\n                if(isMatch(original,part,i,list)){\n                    return true;\n                }else{\n                    continue;\n                }\n            }\n        }\n        return false;\n    }\n    public static boolean isMatch(char[] original, char[] part,int index,List<char[]> list){\n        if(list!=null){\n            for(char[] missCase:list){\n                if(part.length>missCase.length){\n                    if(isMatch(part,missCase,0,null)){\n                        return false;\n                    }\n                }\n            }\n        }\n        for(int i=0;i<part.length;i++){\n            if(original[index+i]!=part[i]){\n                list.add(Arrays.copyOfRange(part,0,i+1));\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/**\n * \n */\n\n/**\n * @author kawakami\n *\n */\nclass Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner as = new Scanner(System.in);\n\t\tString str;\n\t\tint n = 0;\n\t\t\n\t\tstr = as.next();\n\t\tn = Integer.parseInt(as.next());\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\t\n\t\t\tif(str.indexOf(as.next()) != -1){\n\t\t\t\t\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\t\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tchar[] inputStr = br.readLine().toCharArray();\n\t\tint wordsNum = Integer.parseInt(br.readLine());\n\t\t\n\t\tHashMap<Integer, ArrayList<Pattern>> arrayMap = new HashMap<Integer, ArrayList<Pattern>>();\n\t\tfor(int i = 1; i <= 3000 ; i++){\n\t\t\tarrayMap.put(i, new ArrayList<Pattern>());\n\t\t}\n\t\t\n\t\tPattern[] patterns = new Pattern[wordsNum];\n\t\tfor(int i = 0; i < wordsNum ; i++){\n\t\t\tchar[] pattern = br.readLine().toCharArray();\n\t\t\t//int index = RKSearcher.indexOf(pattern, inputStr);\n//\t\t\tint index = BMSearcher.indexOf(inputStr, pattern);\n//\t\t\tif(index != -1){\n//\t\t\t\tSystem.out.println(1);\n//\t\t\t}\n//\t\t\telse{\n//\t\t\t\tSystem.out.println(0);\n//\t\t\t}\n\t\t\tPattern tmpPattern = new Pattern(pattern);\n\t\t\tpatterns[i] = tmpPattern;\n\t\t\tarrayMap.get(pattern.length).add(tmpPattern);\n\t\t}\n\t\t//System.out.println(\"MapSize \"+arrayMap.size());\n\t\tfor(int i = 1; i <= arrayMap.size() ; i++){\n\t\t\t//System.out.println(\"i = \"+i);\n\t\t\tArrayList<Pattern> tmplist = arrayMap.get(i);\n\t\t\tif(tmplist.size() > 0){\n\t\t\t\t//System.out.println(\"size \"+tmplist.size());\n\t\t\t\tRKSearcher.indexOf(tmplist, inputStr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < wordsNum ; i++){\n\t\t\tif(patterns[i].exist){\n\t\t\t\tSystem.out.println(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass Pattern {\n\tchar[] pattern;\n\tboolean exist;\n\t\n\tpublic Pattern (char[] pattern){\n\t\tthis.pattern = Arrays.copyOf(pattern, pattern.length);\n\t\tthis.exist = false;\n\t}\n}\n\nclass RKSearcher {\n\tprivate static final long q = 1000000007L;\n\tprivate static final int d = 64;\n\t\n\tpublic static void indexOf(ArrayList<Pattern> pattern, char[] str2){\n\t\tint M = pattern.get(0).pattern.length;\n\t\tint N = str2.length;\n\t\tint patternNum = pattern.size();\n\t\tlong dM = 1;\n\t\tlong[] h1 = new long[patternNum];\n\t\tlong h2 = 0;\n\t\t\n\t\t//?????????????????°???????????????equals???????????°??????\n\t\tif(M == N){\n\t\t\tfor(int i = 0 ; i < patternNum ; i++){\n\t\t\t\tPattern tmpPtn = pattern.get(i);\n\t\t\t\tif(new String(tmpPtn.pattern).equals(new String(str2))){\n\t\t\t\t\ttmpPtn.exist = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttmpPtn.exist = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\telse if (M > N){\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < M ; i++){\n\t\t\tdM = (d*dM)%q;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < M; i++){\n\t\t\t\n\t\t\th2 = (h2*d + index(str2[i])) % q;\n\t\t}\n\t\t\n\t\tfor(int j = 0; j < patternNum ; j++){\n\t\t\tfor(int i = 0; i < M; i++){\n\t\t\t\th1[j] = (h1[j]*d + index(pattern.get(j).pattern[i])) % q;\n\t\t\t}\n\t\t\tif(h1[j] == h2){\n\t\t\t\tpattern.get(j).exist = true;\n\t\t\t}\n//\t\t\tSystem.out.println(\"hash for \"+new String(pattern.get(j).pattern) + \" is \"+h1[j]);\n\t\t}\n\t//\tSystem.out.println(\"first h2 \"+h2);\n\t\t\n\t\tint i;\n\t\tint matched = 0;\n\t\tfor(i = 0; i < N ;i++){\n\t\t\t//System.out.println(\"i = \"+i+\" h1 \"+h1+\" h2 \"+h2);\n\t\t\th2 = (h2 + d*q - index(str2[i])*dM) % q;\n\t\t\tif(i+M >= N){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\th2 = (h2*d + index(str2[i+M])) % q;\n\t\t\tif (i > N-M){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int j = 0; j < patternNum ; j++){\n\t\t\t\t\n\t\t\t\tif(h1[j] == h2 && pattern.get(j).pattern[0] == str2[i+1]){\n\t\t\t\t\tPattern tmpPtn = pattern.get(j);\n\t\t\t\t\t//System.out.print(\"HIT \"+new String(tmpPtn.pattern));\n\t\t\t\t\t//System.out.println(\" STRING \"+new String(Arrays.copyOfRange(str2, i+1, i+M+1)));\n\t\t\t\t\tif(tmpPtn.exist == false){\n\t\t\t\t\t\ttmpPtn.exist = true;\n\t\t\t\t\t\tmatched++;\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\tSystem.out.println(\"UNMATCH \"+new String(pattern.get(j).pattern));\n//\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(matched == patternNum){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn;\n\t}\n\t\n\tpublic static int indexOf(char[] str1, char[] str2){\n\t\tint M = str1.length;\n\t\tint N = str2.length;\n\t\tlong dM = 1;\n\t\tlong h1 = 0;\n\t\tlong h2 = 0;\n\t\t\n\t\t//?????????????????°???????????????equals???????????°??????\n\t\tif(M == N){\n\t\t\tif(new String(str1).equals(new String(str2))){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\telse if (M > N){\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < M ; i++){\n\t\t\tdM = (d*dM)%q;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < M; i++){\n\t\t\th1 = (h1*d + index(str1[i])) % q;\n\t\t\th2 = (h2*d + index(str2[i])) % q;\n\t\t}\n\t\tint i;\n\t\tfor(i = 0; h1 != h2 ;i++){\n\t\t\t//System.out.println(\"i = \"+i+\" h1 \"+h1+\" h2 \"+h2);\n\t\t\th2 = (h2 + d*q - index(str2[i])*dM) % q;\n\t\t\tif(i+M >= N){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\th2 = (h2*d + index(str2[i+M])) % q;\n\t\t\tif (i > N-M){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn i;\n\t}\n\t\n\tprivate static int index(char c){\n\t\t//return c - '0' + 1;\n\t\t//??°??????0~9\n\t\tif(c >=  '0' && c <= '9'){\n\t\t\treturn c - '0';\n\t\t}\n\t\t//?°??????????10~35\n\t\telse if (c >= 'a' && c <= 'z'){\n\t\t\treturn c - 'a' + 10;\n\t\t}\n\t\t//??§?????????36~61\n\t\telse if (c >= 'A' && c <= 'Z'){\n\t\t\treturn c - 'A' + 36;\n\t\t}\n\t\telse {\n\t\t\treturn -1;\n\t\t}\n\t}\n}\n\nclass BMSearcher {\n\tpublic static int indexOf(char[] str1, char[] str2){\n\t\tif (str2.length == 0){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint charTable[] = makeCharTable(str2);\n\t\tint offsetTable[] = makeOffsetTable(str2);\n\t\tfor(int i = str2.length - 1, j; i < str1.length ;){\n\t\t\tfor(j = str2.length - 1; str2[j] == str1[i] ; i--, j--){\n\t\t\t\tif(j == 0){\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ti += Math.max(offsetTable[str2.length - 1 - j], charTable[str1[i]]);\n\t\t\t\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate static int[] makeCharTable(char[] str) {\n\t\tfinal int ALPHABET_SIZE = 256;\n\t\tint[] table = new int[ALPHABET_SIZE];\n\t\tfor(int i = 0; i < table.length ; i++){\n\t\t\ttable[i] = str.length;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\ttable[str[i]] = str.length - 1 - i;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static int[] makeOffsetTable(char[] str){\n\t\tint[] table = new int[str.length];\n\t\tint lastPrefixPosition = str.length;\n\t\tfor(int i = str.length - 1; i >= 0; i--){\n\t\t\tif(isPrefix(str, i + 1)) {\n\t\t\t\tlastPrefixPosition = i + 1;\n\t\t\t}\n\t\t\ttable[str.length - 1 - i] = lastPrefixPosition - i + str.length - 1;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\tint slen = suffixLength(str, i);\n\t\t\ttable[slen] = str.length - 1 - i + slen;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static boolean isPrefix(char[] str, int p){\n\t\tfor (int i = p, j = 0; i < str.length; i++, j++){\n\t\t\tif(str[i] != str[j]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate static int suffixLength(char[] str, int p){\n\t\tint len = 0;\n\t\tfor(int i = p, j = str.length - 1;\n\t\t\t\ti >= 0 && str[i] == str[j]; i--, j--){\n\t\t\tlen += 1;\n\t\t}\n\t\treturn len;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tString t = scan.next();\n\n\t\tint q = scan.nextInt();\n\t\tString[] p = new String[q];\n\t\tfor (int i = 0; i < q; i++)\n\t\t\tp[i] = scan.next();\n\n\t\tPtFind f = new PtFind(t, p, false);\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass PtFind {\n\tboolean debug;\n\n\tpublic PtFind(String t, String[] p, boolean d) {\n\t\tdebug = d;\n\n\t\tboolean[] result = new boolean[p.length];\n\t\tint[] length = new int[p.length];\n\t\tint[] hash = new int[p.length];\n\t\tList<Integer> unresolve = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\tlength[i] = p[i].length();\n\t\t\thash[i] = getHash(p[i], 0, length[i]);\n\t\t\tunresolve.add(i);\n\t\t}\n\n\t\tint[] thash = new int[1001];\n\t\tint[] tcalc = new int[1001];\n\t\tint[] multi = new int[1001];\n\t\tmulti[0] = 1;\n\t\tfor (int i = 1; i < tcalc.length; i++) {\n\t\t\ttcalc[i] = -1;\n\t\t\tmulti[i] = multi[i - 1] * 101;\n\t\t\tmulti[i] %= 100000;\n\t\t}\n\t\tfor (int i = 0; i < length.length; i++) {\n\t\t\tint le = length[i];\n\t\t\tif (tcalc[le] == -1) {\n\t\t\t\ttcalc[le] = 0;\n\t\t\t\tthash[le] = getHash(t, 0, le);\n\t\t\t}\n\t\t}\n\n\t\tfor (int st = 0; st < t.length(); st++) {\n\t\t\tfor (int i = 0; i < length.length; i++) {\n\t\t\t\tif (result[i])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tint le = length[i];\n\t\t\t\tif (st + le >= t.length())\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tif (tcalc[le] != st) {\n\t\t\t\t\ttcalc[le] = st;\n\t\t\t\t\tthash[le] = (thash[le] * 101) + t.charAt(st + le - 1) - t.charAt(st - 1) * multi[le];\n\t\t\t\t}\n\n\t\t\t\tif (thash[le] == hash[i])\n\t\t\t\t\tif (p[i].equals(t.substring(st, st + le)))\n\t\t\t\t\t\tresult[i] = true;\n\t\t\t}\n\n\t\t}\n\n\t\tfor (int i = 0; i < result.length; i++)\n\t\t\tif (result[i])\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"0\");\n\t}\n\n\tprivate int getHash(String s, int start, int length) {\n\t\tint ret = 0;\n\t\tfor (int i = start; i < start + length; i++) {\n\t\t\tret *= 101;\n\t\t\tret += s.charAt(i);\n\t\t\tret %= 100000;\n\t\t}\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tchar[] inputStr = br.readLine().toCharArray();\n\t\tint wordsNum = Integer.parseInt(br.readLine());\n\t\t\n\t\tfor(int i = 0; i < wordsNum ; i++){\n\t\t\tchar[] pattern = br.readLine().toCharArray();\n//\t\t\tint index = RKSearcher.indexOf(pattern, inputStr);\n\t\t\tint index = BMSearcher.indexOf(inputStr, pattern);\n\t\t\tif(index != -1){\n\t\t\t\tSystem.out.println(1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass RKSearcher {\n\tprivate static final long q = 1000000007L;\n\tprivate static final int d = 64;\n\t\n\tpublic static int indexOf(char[] str1, char[] str2){\n\t\tint M = str1.length;\n\t\tint N = str2.length;\n\t\tlong dM = 1;\n\t\tlong h1 = 0;\n\t\tlong h2 = 0;\n\t\t\n\t\t//?????????????????°???????????????equals???????????°??????\n\t\tif(M == N){\n\t\t\tif(new String(str1).equals(new String(str2))){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\telse if (M > N){\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < M ; i++){\n\t\t\tdM = (d*dM)%q;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < M; i++){\n\t\t\th1 = (h1*d + index(str1[i])) % q;\n\t\t\th2 = (h2*d + index(str2[i])) % q;\n\t\t}\n\t\tint i;\n\t\tfor(i = 0; h1 != h2 ;i++){\n\t\t\t//System.out.println(\"i = \"+i+\" h1 \"+h1+\" h2 \"+h2);\n\t\t\th2 = (h2 + d*q - index(str2[i])*dM) % q;\n\t\t\tif(i+M >= N){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\th2 = (h2*d + index(str2[i+M])) % q;\n\t\t\tif (i > N-M){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn i;\n\t}\n\t\n\tprivate static int index(char c){\n\t\t//return c - '0' + 1;\n\t\t//??°??????0~9\n\t\tif(c >=  '0' && c <= '9'){\n\t\t\treturn c - '0';\n\t\t}\n\t\t//?°??????????10~35\n\t\telse if (c >= 'a' && c <= 'z'){\n\t\t\treturn c - 'a' + 10;\n\t\t}\n\t\t//??§?????????36~61\n\t\telse if (c >= 'A' && c <= 'Z'){\n\t\t\treturn c - 'A' + 36;\n\t\t}\n\t\telse {\n\t\t\treturn -1;\n\t\t}\n\t}\n}\n\nclass BMSearcher {\n\tpublic static int indexOf(char[] str1, char[] str2){\n\t\tif (str2.length == 0){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint charTable[] = makeCharTable(str2);\n\t\tint offsetTable[] = makeOffsetTable(str2);\n\t\tfor(int i = str2.length - 1, j; i < str1.length ;){\n\t\t\tfor(j = str2.length - 1; str2[j] == str1[i] ; i--, j--){\n\t\t\t\tif(j == 0){\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ti += Math.max(offsetTable[str2.length - 1 - j], charTable[str1[i]]);\n\t\t\t\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate static int[] makeCharTable(char[] str) {\n\t\tfinal int ALPHABET_SIZE = 256;\n\t\tint[] table = new int[ALPHABET_SIZE];\n\t\tfor(int i = 0; i < table.length ; i++){\n\t\t\ttable[i] = str.length;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\ttable[str[i]] = str.length - 1 - i;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static int[] makeOffsetTable(char[] str){\n\t\tint[] table = new int[str.length];\n\t\tint lastPrefixPosition = str.length;\n\t\tfor(int i = str.length - 1; i >= 0; i--){\n\t\t\tif(isPrefix(str, i + 1)) {\n\t\t\t\tlastPrefixPosition = i + 1;\n\t\t\t}\n\t\t\ttable[str.length - 1 - i] = lastPrefixPosition - i + str.length - 1;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\tint slen = suffixLength(str, i);\n\t\t\ttable[slen] = str.length - 1 - i + slen;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static boolean isPrefix(char[] str, int p){\n\t\tfor (int i = p, j = 0; i < str.length; i++, j++){\n\t\t\tif(str[i] != str[j]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate static int suffixLength(char[] str, int p){\n\t\tint len = 0;\n\t\tfor(int i = p, j = str.length - 1;\n\t\t\t\ti >= 0 && str[i] == str[j]; i--, j--){\n\t\t\tlen += 1;\n\t\t}\n\t\treturn len;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\t// write your code here\n        Scanner scanner=new Scanner(System.in);\n        String T=scanner.next();\n        int q=scanner.nextInt();\n        List<char[]> missMatchList=new ArrayList<>();\n        for(int i=0;i<q;i++){\n            String part=scanner.next();\n            if(isConclude(T,part,missMatchList)){\n                System.out.println(1);\n            }else{\n                missMatchList.add(part.toCharArray());\n                System.out.println(0);\n            }\n        }\n    }\n    public static boolean isConclude(String original, String part,List<char[]> list){\n        char[] originalChars=original.toCharArray();\n        char[] partChars=part.toCharArray();\n        return isConclude(originalChars,partChars,list);\n    }\n    public static boolean isConclude(char[] original, char[] part,List<char[]> list){\n        for(int i=0;i<=original.length-part.length;i++){\n            if(part[0]==original[i]){\n                if(isMatch(original,part,i,list)){\n                    return true;\n                }else{\n                    continue;\n                }\n            }\n        }\n        return false;\n    }\n    public static boolean isMatch(char[] original, char[] part,int index,List<char[]> list){\n        if(list!=null){\n            for(char[] missCase:list){\n                if(part.length>missCase.length){\n                    if(isMatch(part,missCase,0,null)){\n                        return false;\n                    }\n                }\n            }\n        }\n        for(int i=0;i<part.length;i++){\n            if(original[index+i]!=part[i]){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\t// write your code here\n        Scanner scanner=new Scanner(System.in);\n        String T=scanner.next();\n        int q=scanner.nextInt();\n        for(int i=0;i<q;i++){\n            if(isConclude(T,scanner.next())){\n                System.out.println(1);\n            }else{\n                System.out.println(0);\n            }\n        }\n    }\n    public static boolean isConclude(String original, String part){\n        char[] originalChars=original.toCharArray();\n        char[] partChars=part.toCharArray();\n        return isConclude(originalChars,partChars);\n    }\n    public static boolean isConclude(char[] original, char[] part){\n        for(int i=0;i<=original.length-part.length;i++){\n            if(part[0]==original[i]){\n                if(isMatch(original,part,i)){\n                    return true;\n                }else{\n                    continue;\n                }\n            }\n        }\n        return false;\n    }\n    public static boolean isMatch(char[] original, char[] part,int index){\n        for(int i=0;i<part.length;i++){\n            if(original[index+i]!=part[i]) return false;\n        }\n        return true;\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tchar[] inputStr = br.readLine().toCharArray();\n\t\tint wordsNum = Integer.parseInt(br.readLine());\n\t\t\n\t\tfor(int i = 0; i < wordsNum ; i++){\n\t\t\tchar[] pattern = br.readLine().toCharArray();\n\t\t\tint index = RKSearcher.indexOf(pattern, inputStr);\n\t\t\tif(index != -1){\n\t\t\t\tSystem.out.println(1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass RKSearcher {\n\tprivate static final long q = 1000000007L;\n\tprivate static final int d = 64;\n\t\n\tpublic static int indexOf(char[] str1, char[] str2){\n\t\tint M = str1.length;\n\t\tint N = str2.length;\n\t\tlong dM = 1;\n\t\tlong h1 = 0;\n\t\tlong h2 = 0;\n\t\t\n\t\t//?????????????????°???????????????equals???????????°??????\n\t\tif(M == N){\n\t\t\tif(new String(str1).equals(new String(str2))){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\telse if (M > N){\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < M ; i++){\n\t\t\tdM = (d*dM)%q;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < M; i++){\n\t\t\th1 = (h1*d + index(str1[i])) % q;\n\t\t\th2 = (h2*d + index(str2[i])) % q;\n\t\t}\n\t\tint i;\n\t\tfor(i = 0; h1 != h2 ;i++){\n\t\t\t//System.out.println(\"i = \"+i+\" h1 \"+h1+\" h2 \"+h2);\n\t\t\th2 = (h2 + d*q - index(str2[i])*dM) % q;\n\t\t\tif(i+M >= N){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\th2 = (h2*d + index(str2[i+M])) % q;\n\t\t\tif (i > N-M){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn i;\n\t}\n\t\n\tprivate static int index(char c){\n\t\t//return c - '0' + 1;\n\t\t//??°??????0~9\n\t\tif(c >=  '0' && c <= '9'){\n\t\t\treturn c - '0';\n\t\t}\n\t\t//?°??????????10~35\n\t\telse if (c >= 'a' && c <= 'z'){\n\t\t\treturn c - 'a' + 10;\n\t\t}\n\t\t//??§?????????36~61\n\t\telse if (c >= 'A' && c <= 'Z'){\n\t\t\treturn c - 'A' + 36;\n\t\t}\n\t\telse {\n\t\t\treturn -1;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n \npublic class Main{\n    public static void main(String[] args){\n \n        Scanner scan = new Scanner(System.in);\n        String t = scan.next();\n        StringIndex si = new StringIndex(t, false);\n \n        int q = scan.nextInt();\n        for(int i = 0; i < q; i++)\n            if(si.isExist(scan.next(), t))\n                System.out.println(\"1\");\n            else\n                System.out.println(\"0\");\n \n        scan.close();\n        System.exit(0);\n    }\n}\n \nclass StringIndex{\n    class StIdx{\n        int pos;\n        char ch;\n \n        public StIdx(int i, char c){\n            pos = i;\n            ch = c;\n        }\n    }\n \n    List<StIdx> idx = new ArrayList<StIdx>();\n    int[] seq;\n    int compLen = 1;\n    boolean debug;\n \n    public StringIndex(String t, boolean d){\n        debug = d;\n \n        seq = new int[t.length()];\n        for(int i = 0; i < t.length(); i++)\n            idx.add(new StIdx(i, t.charAt(i)));\n \n        for(compLen =1; compLen < idx.size() * 2; compLen *= 2){\n            Collections.sort(idx, new strIndexComp());\n \n            int[] tmp = new int[seq.length];\n \n            tmp[idx.get(0).pos] = 1;\n            for(int i = 1; i < tmp.length; i++)\n                if(idxComp(idx.get(i-1), idx.get(i)) == 0)\n                    tmp[idx.get(i).pos] = tmp[idx.get(i-1).pos];\n                else\n                    tmp[idx.get(i).pos] = tmp[idx.get(i-1).pos] + 1;\n \n            for(int i = 0; i < seq.length; i++)\n                seq[i] = tmp[i];\n \n            if(debug){\n                System.out.println(\"------------\");\n                for(int i = 0; i < idx.size(); i++)\n                    System.out.println(i + \"\\t\" + seq[idx.get(i).pos] + \"\\t\" + idx.get(i).pos + \"\\t\"\n                        + t.substring(idx.get(i).pos));\n            }\n        }\n    }\n \n    class strIndexComp implements Comparator<StIdx>{\n \n        @Override\n        public int compare(StIdx o1, StIdx o2){\n            return idxComp(o1, o2);\n        }\n    }\n \n    private int idxComp(StIdx o1, StIdx o2){\n        if(compLen == 1)\n            if(o1.ch > o2.ch)\n                return 1;\n            else if(o1.ch == o2.ch)\n                return 0;\n            else\n                return -1;\n \n            if(seq[o1.pos] > seq[o2.pos])\n                return 1;\n            if(seq[o1.pos] == seq[o2.pos]){\n                int npos1 = o1.pos + compLen / 2;\n                int npos2 = o2.pos + compLen / 2;\n                int nseq1 = 0, nseq2 = 0;\n                if(npos1 < seq.length)\n                    nseq1 = seq[npos1];\n                if(npos2 < seq.length)\n                    nseq2 = seq[npos2];\n                if(nseq1 > nseq2)\n                    return 1;\n                else if(nseq1 == nseq2)\n                    return 0;\n                else\n                    return -1;\n            }\n            return -1;\n    }\n \n    public boolean isExist(String p, String t){\n        int low = 0, hi = idx.size() - 1;\n        return (findBin(p, t, low, hi));\n    }\n \n    private boolean findBin(String p, String t, int low, int hi){\n        if(low >= hi)\n            return false;\n        int i = low + (hi - low) / 2;\n        int len = p.length();\n        if(len > t.length() - idx.get(i).pos)\n            len = t.length() - idx.get(i).pos;\n \n        int r = p.substring(0, len).compareTo(t.substring(idx.get(i).pos, idx.get(i).pos + len));\n        if(r == 0)\n            if(len == p.length())\n                return true;\n            else\n                return findBin(p, t, i+1, hi);\n        else if(r < 0)\n            return findBin(p, t, low, i-1);\n        else\n            return findBin(p, t, i+1, hi);\n    }\n}\n \n/*\npublic interface List<E> extends Collection<E>{\n    default void sort(Comparator<? super E> c){\n        for(int i = 0; size()-1; i++){\n            E min = get(i);\n            int minIndex = i;\n            for(int j = size(); --j>i;){\n                E e = get(j);\n                if(c.compare(min, e) > 0){\n                    min = e;\n                    minIndex = j;\n                }\n            }\n            if(minIndex != i){\n                set(minIndex, get(i));\n                set(i, min);\n            }\n        }\n    }\n}\n//????????????????????????\n*/"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tString s = sc.next();\n\t\tint n = sc.nextInt();\n\t\tString temp;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\ttemp = sc.next();\n\t\t\tif (s.contains(temp)) {out.println(1);}\n\t\t\telse {out.println(0);}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/**\n * \n */\n\n/**\n * @author kawakami\n *\n */\nclass Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner as = new Scanner(System.in);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint n = 0;\n\t\t\n\t\tsb.append(as.next());\n\t\tn = Integer.parseInt(as.next());\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\t\n\t\t\tif(sb.indexOf(as.next()) != -1){\n\t\t\t\t\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\t\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nclass Main {\n\tfinal static int Code = 2;\n\t\n\tpublic static void main(String[] args)throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tchar[] A, B;\n\t\tboolean find = false;\n\t\t//??\\?????¨??¨??????char???????????£??\\\n\t\tA = br.readLine().toCharArray();\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tB = br.readLine().toCharArray();\n\t\t\t//A??????????????????????????????\n\t\t\tif(A.length < B.length) return;\n\t\n\t\t\tint t = 0;\n\t\t\tint p = 0;\n\t\t\tint BN = search(Code, B.length);\n\t\n\t\t\tfor(int j = 0; j < B.length; j++){\n\t\t\t\tt = t * Code + A[j];\n\t\t\t\tp = p * Code + B[j];\n\t\t\t}\n\t\t\tfind = Print(t ,p, A, B, BN);\n\t\t\t\n\t\t\tif(find) System.out.println(\"1\");\n\t\t\telse System.out.println(\"0\");\n\t\t}\n\t\treturn;\n\t}\n\n\tpublic static int search(int x, int n){\n\t\tif(n == 0) return 1;\n\t\tint ret = search(x * x, n / 2);\n\t\t//??????????????????AND?????????\n\t\tif((n & 1) == 1) ret *= x;\n\t\treturn ret;\n\t}\n\n\tpublic static boolean Print(int t, int p, char[] A, char[] B, int BN){\n\t\t//t??¨p?????????????????????????????¨???\n\t\tif(t == p) return true;\n\t\tfor(int i = 1; i < A.length - B.length + 1; i++){\n\t\t\tt = t * Code + A[i + B.length - 1] - A[i - 1] * BN;\n\t\t\tif(t == p) return true;\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tString t = scan.next();\n\t\tStringIndex si = new StringIndex(t, false);\n\n\t\tint q = scan.nextInt();\n\t\tfor (int i = 0; i < q; i++)\n\t\t\tif (si.isExist(scan.next(), t))\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"0\");\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass StringIndex {\n\tclass StIdx {\n\t\tint pos;\n\t\tchar ch;\n\n\t\tpublic StIdx(int i, char c) {\n\t\t\tpos = i;\n\t\t\tch = c;\n\t\t}\n\t}\n\n\tList<StIdx> idx = new ArrayList<StIdx>();\n\tint[] seq;\n\tint compLen = 1;\n\n\tclass strIndexComp implements Comparator<StIdx> {\n\n\t\t@Override\n\t\tpublic int compare(StIdx o1, StIdx o2) {\n\t\t\treturn idxComp(o1, o2);\n\t\t}\n\t}\n\n\tprivate int idxComp(StIdx o1, StIdx o2) {\n\t\tif (compLen == 1)\n\t\t\tif (o1.ch > o2.ch)\n\t\t\t\treturn 1;\n\t\t\telse if (o1.ch == o2.ch)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn -1;\n\n\t\tif (seq[o1.pos] > seq[o2.pos])\n\t\t\treturn 1;\n\t\tif (seq[o1.pos] == seq[o2.pos]) {\n\t\t\tint npos1 = o1.pos + compLen / 2;\n\t\t\tint npos2 = o2.pos + compLen / 2;\n\t\t\tint nseq1 = 0, nseq2 = 0;\n\t\t\tif (npos1 < seq.length)\n\t\t\t\tnseq1 = seq[npos1];\n\t\t\tif (npos2 < seq.length)\n\t\t\t\tnseq2 = seq[npos2];\n\t\t\tif (nseq1 > nseq2)\n\t\t\t\treturn 1;\n\t\t\telse if (nseq1 == nseq2)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tboolean debug;\n\n\tpublic StringIndex(String t, boolean d) {\n\t\tdebug = d;\n\n\t\tseq = new int[t.length()];\n\t\tfor (int i = 0; i < t.length(); i++)\n\t\t\tidx.add(new StIdx(i, t.charAt(i)));\n\n\t\tfor (compLen = 1; compLen < idx.size() * 2; compLen *= 2) {\n\t\t\tCollections.sort(idx, new strIndexComp());\n\n\t\t\tint[] tmp = new int[seq.length];\n\n\t\t\ttmp[idx.get(0).pos] = 1;\n\t\t\tfor (int i = 1; i < tmp.length; i++)\n\t\t\t\tif (idxComp(idx.get(i - 1), idx.get(i)) == 0)\n\t\t\t\t\ttmp[idx.get(i).pos] = tmp[idx.get(i - 1).pos];\n\t\t\t\telse\n\t\t\t\t\ttmp[idx.get(i).pos] = tmp[idx.get(i - 1).pos] + 1;\n\n\t\t\tfor (int i = 0; i < seq.length; i++)\n\t\t\t\tseq[i] = tmp[i];\n\n\t\t\tif (debug) {\n\t\t\t\tSystem.out.println(\"--------------------\");\n\t\t\t\tfor (int i = 0; i < idx.size(); i++)\n\t\t\t\t\tSystem.out.println(i + \"\\t\" + seq[idx.get(i).pos] + \"\\t\" + idx.get(i).pos + \"\\t\"\n\t\t\t\t\t\t\t+ t.substring(idx.get(i).pos));\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic boolean isExist(String p, String t) {\n\t\tint low = 0, hi = idx.size() - 1;\n\t\treturn (findBin(p, t, low, hi));\n\t}\n\n\tprivate boolean findBin(String p, String t, int low, int hi) {\n\t\tif (low > hi)\n\t\t\treturn false;\n\t\tint i = low + (hi - low) / 2;\n\t\tint len = p.length();\n\t\tif (len > t.length() - idx.get(i).pos)\n\t\t\tlen = t.length() - idx.get(i).pos;\n\n\t\tint r = p.substring(0, len).compareTo(t.substring(idx.get(i).pos, idx.get(i).pos + len));\n\t\tif (r == 0)\n\t\t\tif (len == p.length())\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn findBin(p, t, i + 1, hi);\n\t\telse if (r < 0)\n\t\t\treturn findBin(p, t, low, i - 1);\n\t\telse\n\t\t\treturn findBin(p, t, i + 1, hi);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\t// write your code here\n        Scanner scanner=new Scanner(System.in);\n        String T=scanner.next();\n        int q=scanner.nextInt();\n        List<char[]> missMatchList=new ArrayList<>();\n        for(int i=0;i<q;i++){\n            String part=scanner.next();\n            if(isConclude(T.toCharArray(),part.toCharArray(),missMatchList)){\n                System.out.println(1);\n            }else{\n                missMatchList.add(part.toCharArray());\n                System.out.println(0);\n            }\n        }\n    }\n    public static boolean isConclude(String original, String part,List<char[]> list){\n        char[] originalChars=original.toCharArray();\n        char[] partChars=part.toCharArray();\n        return isConclude(originalChars,partChars,list);\n    }\n    public static boolean isConclude(char[] original, char[] part,List<char[]> list){\n        for(int i=0;i<=original.length-part.length;i++){\n            if(part[0]==original[i]){\n                if(isMatch(original,part,i,list)){\n                    return true;\n                }else{\n                    continue;\n                }\n            }\n        }\n        return false;\n    }\n    public static boolean isMatch(char[] original, char[] part,int index,List<char[]> list){\n        if(list!=null){\n            for(char[] missCase:list){\n                if(part.length>missCase.length){\n                    if(isMatch(part,missCase,0,null)){\n                        return false;\n                    }\n                }\n            }\n        }\n        for(int i=0;i<part.length;i++){\n            if(original[index+i]!=part[i]){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tString t = scan.next();\n\t\tStringIndex si = new StringIndex(t, false);\n\n\t\tint q = scan.nextInt();\n\t\tfor (int i = 0; i < q; i++)\n\t\t\tif (si.isExist(scan.next(), t))\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"0\");\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass StringIndex {\n\tclass StIdx {\n\t\tint pos;\n\t\tchar ch;\n\n\t\tpublic StIdx(int i, char c) {\n\t\t\tpos = i;\n\t\t\tch = c;\n\t\t}\n\t}\n\n\tList<StIdx> idx = new ArrayList<StIdx>();\n\tint[] seq;\n\tint compLen = 1;\n\n\tclass strIndexComp implements Comparator<StIdx> {\n\n\t\t@Override\n\t\tpublic int compare(StIdx o1, StIdx o2) {\n\t\t\treturn idxComp(o1, o2);\n\t\t}\n\t}\n\n\tprivate int idxComp(StIdx o1, StIdx o2) {\n\t\tif (compLen == 1)\n\t\t\tif (o1.ch > o2.ch)\n\t\t\t\treturn 1;\n\t\t\telse if (o1.ch == o2.ch)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn -1;\n\n\t\tif (seq[o1.pos] > seq[o2.pos])\n\t\t\treturn 1;\n\t\tif (seq[o1.pos] == seq[o2.pos]) {\n\t\t\tint npos1 = o1.pos + compLen / 2;\n\t\t\tint npos2 = o2.pos + compLen / 2;\n\t\t\tint nseq1 = 0, nseq2 = 0;\n\t\t\tif (npos1 < seq.length)\n\t\t\t\tnseq1 = seq[npos1];\n\t\t\tif (npos2 < seq.length)\n\t\t\t\tnseq2 = seq[npos2];\n\t\t\tif (nseq1 > nseq2)\n\t\t\t\treturn 1;\n\t\t\telse if (nseq1 == nseq2)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tboolean debug;\n\n\tpublic StringIndex(String t, boolean d) {\n\t\tdebug = d;\n\n\t\tseq = new int[t.length()];\n\t\tfor (int i = 0; i < t.length(); i++)\n\t\t\tidx.add(new StIdx(i, t.charAt(i)));\n\n\t\tfor (compLen = 1; compLen < idx.size(); compLen *= 2) {\n\t\t\tCollections.sort(idx, new strIndexComp());\n\n\t\t\tseq[idx.get(0).pos] = 1;\n\t\t\tfor (int i = 1; i < idx.size(); i++) {\n\t\t\t\tif (idxComp(idx.get(i - 1), idx.get(i)) == 0)\n\t\t\t\t\tseq[idx.get(i).pos] = seq[idx.get(i - 1).pos];\n\t\t\t\telse\n\t\t\t\t\tseq[idx.get(i).pos] = seq[idx.get(i - 1).pos] + 1;\n\t\t\t}\n\n\t\t\tif (debug) {\n\t\t\t\tSystem.out.println(\"--------------------\");\n\t\t\t\tfor (int i = 0; i < idx.size(); i++)\n\t\t\t\t\tSystem.out.println(i + \"\\t\" + seq[idx.get(i).pos] + \"\\t\" + idx.get(i).pos + \"\\t\"\n\t\t\t\t\t\t\t+ t.substring(idx.get(i).pos));\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic boolean isExist(String p, String t) {\n\t\tint low = 0, hi = idx.size() - 1;\n\t\treturn (findBin(p, t, low, hi));\n\t}\n\n\tprivate boolean findBin(String p, String t, int low, int hi) {\n\t\tif (low > hi)\n\t\t\treturn false;\n\t\tint i = low + (hi - low) / 2;\n\t\tint r = p.compareTo(t.substring(idx.get(i).pos, Math.min(idx.get(i).pos + p.length(), t.length())));\n\t\tif (r == 0)\n\t\t\treturn true;\n\t\telse if (r < 0)\n\t\t\treturn findBin(p, t, low, i - 1);\n\t\telse\n\t\t\treturn findBin(p, t, i + 1, hi);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n    \tString str =sc.next();\n    \tint n=sc.nextInt();\n    \tString pi;\n    \tfor(int i=0;i<n;i++){\n    \t\tpi=sc.next();\n    \t\tfor(int j=0;j<str.length()-pi.length();j++){\n    \t\t\tif(str.substring(j, j+pi.length()).equals(pi)){\n    \t\t\t\tSystem.out.println(1);\n    \t\t\t\tbreak;\n    \t\t\t}else if(j==str.length()-pi.length()-1){\n    \t\t\t\tSystem.out.println(0);\n    \t\t\t}\n    \t\t\t\n    \t\t}\n    \t}\n    \t\n    \t\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\n\nclass Main{\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br  = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tString temp = br.readLine();\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tif(temp.contains(br.readLine()))out.println(1);\n\t\t\telse out.println(0);\n\t\t}\n\t\tout.flush();\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tchar[] inputStr = br.readLine().toCharArray();\n\t\tint wordsNum = Integer.parseInt(br.readLine());\n\t\t\n\t\tHashMap<Integer, ArrayList<Pattern>> arrayMap = new HashMap<Integer, ArrayList<Pattern>>();\n\t\tfor(int i = 1; i <= 3000 ; i++){\n\t\t\tarrayMap.put(i, new ArrayList<Pattern>());\n\t\t}\n\t\t\n\t\tPattern[] patterns = new Pattern[wordsNum];\n\t\tfor(int i = 0; i < wordsNum ; i++){\n\t\t\tchar[] pattern = br.readLine().toCharArray();\n\t\t\t//int index = RKSearcher.indexOf(pattern, inputStr);\n//\t\t\tint index = BMSearcher.indexOf(inputStr, pattern);\n//\t\t\tif(index != -1){\n//\t\t\t\tSystem.out.println(1);\n//\t\t\t}\n//\t\t\telse{\n//\t\t\t\tSystem.out.println(0);\n//\t\t\t}\n\t\t\tPattern tmpPattern = new Pattern(pattern);\n\t\t\tpatterns[i] = tmpPattern;\n\t\t\tarrayMap.get(pattern.length).add(tmpPattern);\n\t\t}\n\t\t//System.out.println(\"MapSize \"+arrayMap.size());\n\t\tfor(int i = 1; i <= arrayMap.size() ; i++){\n\t\t\t//System.out.println(\"i = \"+i);\n\t\t\tArrayList<Pattern> tmplist = arrayMap.get(i);\n\t\t\tif(tmplist.size() > 0){\n\t\t\t\t//System.out.println(\"size \"+tmplist.size());\n\t\t\t\tRKSearcher.indexOf(tmplist, inputStr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < wordsNum ; i++){\n\t\t\tif(patterns[i].exist){\n\t\t\t\tSystem.out.println(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass Pattern {\n\tchar[] pattern;\n\tboolean exist;\n\t\n\tpublic Pattern (char[] pattern){\n\t\tthis.pattern = Arrays.copyOf(pattern, pattern.length);\n\t\tthis.exist = false;\n\t}\n}\n\nclass RKSearcher {\n\tprivate static final long q = 1000000007L;\n\tprivate static final int d = 64;\n\t\n\tpublic static void indexOf(ArrayList<Pattern> pattern, char[] str2){\n\t\tint M = pattern.get(0).pattern.length;\n\t\tint N = str2.length;\n\t\tint patternNum = pattern.size();\n\t\tlong dM = 1;\n\t\tlong[] h1 = new long[patternNum];\n\t\tlong h2 = 0;\n\t\t\n\t\t//?????????????????°???????????????equals???????????°??????\n\t\tif(M == N){\n\t\t\tfor(int i = 0 ; i < patternNum ; i++){\n\t\t\t\tPattern tmpPtn = pattern.get(i);\n\t\t\t\tif(new String(tmpPtn.pattern).equals(new String(str2))){\n\t\t\t\t\ttmpPtn.exist = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttmpPtn.exist = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\telse if (M > N){\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < M ; i++){\n\t\t\tdM = (d*dM)%q;\n\t\t}\n\t\t\n\t\tfor(int j = 0; j < patternNum ; j++){\n\t\t\tfor(int i = 0; i < M; i++){\n\t\t\t\th1[j] = (h1[j]*d + index(pattern.get(j).pattern[i])) % q;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < M; i++){\n\t\t\t\n\t\t\th2 = (h2*d + index(str2[i])) % q;\n\t\t}\n\t\t\n\t\tint i;\n\t\tint matched = 0;\n\t\tfor(i = 0; i < N ;i++){\n\t\t\t//System.out.println(\"i = \"+i+\" h1 \"+h1+\" h2 \"+h2);\n\t\t\th2 = (h2 + d*q - index(str2[i])*dM) % q;\n\t\t\tif(i+M >= N){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\th2 = (h2*d + index(str2[i+M])) % q;\n\t\t\tif (i > N-M){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int j = 0; j < patternNum ; j++){\n\t\t\t\t\n\t\t\t\tif(h1[j] == h2){\n\t\t\t\t\tPattern tmpPtn = pattern.get(j);\n\t\t\t\t\t//System.out.println(\"HIT \"+new String(tmpPtn.pattern));\n\t\t\t\t\tif(tmpPtn.exist == false){\n\t\t\t\t\t\ttmpPtn.exist = true;\n\t\t\t\t\t\tmatched++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(matched == patternNum){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn;\n\t}\n\t\n\tpublic static int indexOf(char[] str1, char[] str2){\n\t\tint M = str1.length;\n\t\tint N = str2.length;\n\t\tlong dM = 1;\n\t\tlong h1 = 0;\n\t\tlong h2 = 0;\n\t\t\n\t\t//?????????????????°???????????????equals???????????°??????\n\t\tif(M == N){\n\t\t\tif(new String(str1).equals(new String(str2))){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\telse if (M > N){\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < M ; i++){\n\t\t\tdM = (d*dM)%q;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < M; i++){\n\t\t\th1 = (h1*d + index(str1[i])) % q;\n\t\t\th2 = (h2*d + index(str2[i])) % q;\n\t\t}\n\t\tint i;\n\t\tfor(i = 0; h1 != h2 ;i++){\n\t\t\t//System.out.println(\"i = \"+i+\" h1 \"+h1+\" h2 \"+h2);\n\t\t\th2 = (h2 + d*q - index(str2[i])*dM) % q;\n\t\t\tif(i+M >= N){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\th2 = (h2*d + index(str2[i+M])) % q;\n\t\t\tif (i > N-M){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn i;\n\t}\n\t\n\tprivate static int index(char c){\n\t\t//return c - '0' + 1;\n\t\t//??°??????0~9\n\t\tif(c >=  '0' && c <= '9'){\n\t\t\treturn c - '0';\n\t\t}\n\t\t//?°??????????10~35\n\t\telse if (c >= 'a' && c <= 'z'){\n\t\t\treturn c - 'a' + 10;\n\t\t}\n\t\t//??§?????????36~61\n\t\telse if (c >= 'A' && c <= 'Z'){\n\t\t\treturn c - 'A' + 36;\n\t\t}\n\t\telse {\n\t\t\treturn -1;\n\t\t}\n\t}\n}\n\nclass BMSearcher {\n\tpublic static int indexOf(char[] str1, char[] str2){\n\t\tif (str2.length == 0){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint charTable[] = makeCharTable(str2);\n\t\tint offsetTable[] = makeOffsetTable(str2);\n\t\tfor(int i = str2.length - 1, j; i < str1.length ;){\n\t\t\tfor(j = str2.length - 1; str2[j] == str1[i] ; i--, j--){\n\t\t\t\tif(j == 0){\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ti += Math.max(offsetTable[str2.length - 1 - j], charTable[str1[i]]);\n\t\t\t\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate static int[] makeCharTable(char[] str) {\n\t\tfinal int ALPHABET_SIZE = 256;\n\t\tint[] table = new int[ALPHABET_SIZE];\n\t\tfor(int i = 0; i < table.length ; i++){\n\t\t\ttable[i] = str.length;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\ttable[str[i]] = str.length - 1 - i;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static int[] makeOffsetTable(char[] str){\n\t\tint[] table = new int[str.length];\n\t\tint lastPrefixPosition = str.length;\n\t\tfor(int i = str.length - 1; i >= 0; i--){\n\t\t\tif(isPrefix(str, i + 1)) {\n\t\t\t\tlastPrefixPosition = i + 1;\n\t\t\t}\n\t\t\ttable[str.length - 1 - i] = lastPrefixPosition - i + str.length - 1;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\tint slen = suffixLength(str, i);\n\t\t\ttable[slen] = str.length - 1 - i + slen;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static boolean isPrefix(char[] str, int p){\n\t\tfor (int i = p, j = 0; i < str.length; i++, j++){\n\t\t\tif(str[i] != str[j]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate static int suffixLength(char[] str, int p){\n\t\tint len = 0;\n\t\tfor(int i = p, j = str.length - 1;\n\t\t\t\ti >= 0 && str[i] == str[j]; i--, j--){\n\t\t\tlen += 1;\n\t\t}\n\t\treturn len;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nclass Main {\n\tfinal static int Code = 5;\n\t\n\tpublic static void main(String[] args)throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tchar[] A, B;\n\t\tboolean find = false;\n\t\t//??\\?????¨??¨??????char???????????£??\\\n\t\tA = br.readLine().toCharArray();\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tB = br.readLine().toCharArray();\n\t\t\t//A??????????????????????????????\n\t\t\tif(A.length < B.length) {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tint t = 0;\n\t\t\tint p = 0;\n\t\t\tint BN = search(Code, B.length);\n\t\n\t\t\tfor(int j = 0; j < B.length; j++){\n\t\t\t\tt = t * Code + A[j];\n\t\t\t\tp = p * Code + B[j];\n\t\t\t}\n\t\t\tfind = Print(t ,p, A, B, BN);\n\t\t\t\n\t\t\tif(find) System.out.println(\"1\");\n\t\t\telse System.out.println(\"0\");\n\t\t}\n\t\treturn;\n\t}\n\n\tpublic static int search(int x, int n){\n\t\tif(n == 0) return 1;\n\t\tint ret = search(x * x, n / 2);\n\t\t//??????????????????AND?????????\n\t\tif((n & 1) == 1) ret *= x;\n\t\treturn ret;\n\t}\n\n\tpublic static boolean Print(int t, int p, char[] A, char[] B, int BN){\n\t\t//t??¨p?????????????????????????????¨???\n\t\tif(t == p) return true;\n\t\tfor(int i = 1; i < A.length - B.length + 1; i++){\n\t\t\tt = t * Code + A[i + B.length - 1] - A[i - 1] * BN;\n\t\t\tif(t == p) return true;\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Scanner;\nclass Main {\n  \tpublic static void main(String[] args)throws IOException{\n\t\tScanner scan = new Scanner(System.in);\n\t\tString str1 = scan.next();\n\t\tint n = scan.nextInt();\n\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tString str2 = scan.next();\n\t\t\tint nt = str1.length();\n\t\t\tint np = str2.length();\n\t\t\tboolean check = false;\n\n\t\t\tif(nt < np){\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t\tcontinue;\n\t\t\t};\n\n\t\t\tfor(int i = 0; i < nt - np + 1; i++){\n\t\t\t\t//?????????????????????????????????????????????????????????????????????\n\t\t\t\tif(str1.charAt(i) == str2.charAt(0) && str1.charAt(i + np - 1) == str2.charAt(np - 1)){\n\t\t\t\t\tif(str1.substring(i, np + i).equals(str2)){\n\t\t\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\t\t\tcheck =true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!check) System.out.println(\"0\");\n\t\t}\n\n\t\treturn;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Set;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString strT = br.readLine();\n\t\t\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tString[] strQ = new String[n];\n\t\t\n\t\tconstructSA(strT);\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tstrQ[i] = br.readLine();\n\t\t\t\n\t\t\tif(strT.length() >= strQ[i].length() &&  contain(strT, strQ[i])){\n\t\t\t\tSystem.out.println(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t\t\t\t\n\n\t}\n\t\n\tstatic final int MAX_N = 1000000 + 1;\n\tstatic int rank[] = new int[MAX_N];\n\tstatic int tmp[] = new int[MAX_N];\n\tstatic Integer sa[];// = new Integer[MAX_N];\n\tstatic int n;\n\tstatic int k;\n\t\n\tstatic boolean compareSA(int i, int j, int n, int k){\n\t\tif(rank[i] != rank[j]){\n\t\t\treturn rank[i] < rank[j];\n\t\t}\n\t\telse {\n\t\t\tint ri = i + k <= n ? rank[i + k] : -1;\n\t\t\tint rj = j + k <= n ? rank[j + k] : -1;\n\t\t\treturn ri < rj;\n\t\t}\n\t}\n\t\n\tstatic void constructSA(String s){\n\t\tn = s.length();\n\t\t\n\t\tsa = new Integer[n + 1];\n\t\t\n\t\tfor(int i = 0; i < sa.length; i++){\n\t\t\tsa[i] = 0;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? s.charAt(i) : -1;\n\t\t}\n\t\t\n//\t\tSystem.out.println(sa[0]);\n\t\t\n\t\tfor(k = 1; k <= n; k *= 2){\n//\t\t\tSystem.out.println(\"k = \"+k);\n\t\t\tArrays.sort(sa, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer i, Integer j){\n//\t\t\t\t\tSystem.out.println(i+\" \"+j);\n\t\t\t\t\tif(rank[i] != rank[j]){\n\t\t\t\t\t\treturn rank[i] - rank[j];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint ri = i + k <= n ? rank[i + k] : -1;\n\t\t\t\t\t\tint rj = j + k <= n ? rank[j + k] : -1;\n\t\t\t\t\t\treturn ri - rj;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\ttmp[sa[i]] = tmp[sa[i- 1]] + (compareSA(sa[i - 1], sa[i], n, k) ? 1 : 0);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i <= n; i++){\n\t\t\t\trank[i] = tmp[i];\n\t\t\t}\n\t\t}\n//\t\t\n//\t\tfor(int i = 0; i <= 11; i++){\n//\t\t\tSystem.out.println(\"i = \"+i+\" sa[i] = \"+ sa[i] + \" s.sub = \"+s.substring(sa[i]));\n//\t\t}\n\t\t\n\t}\n\t\n\tstatic boolean contain(String s, String t){\n\t\tint a = 0;\n\t\tint b = s.length();\n\t\twhile(b - a > 1){\n\t\t\tint c = (a + b)/2;\n\t\t\t\n//\t\t\tSystem.out.println(\"sa[c] = \"+sa[c] + \" t.length \" + t.length());\n\t\t\tif((s.substring(sa[c], Math.min(sa[c] + t.length(), s.length()))).compareTo(t) < 0){\n\t\t\t\ta = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb = c;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn (s.substring(sa[b], Math.min(sa[b]+t.length(), s.length()) )).compareTo(t) == 0;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.awt.geom.Point2D;\nimport java.text.DecimalFormat;\nclass Main{\n\tstatic Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\twhile(sc.hasNext()){\n\t\t\tString temp = sc.next();\n\t\t\tint n = sc.nextInt();\n\t\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\t\tif(temp.contains(sc.next()))System.out.println(1);\n\t\t\t\telse System.out.println(0);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tchar[] inputStr = br.readLine().toCharArray();\n\t\tint wordsNum = Integer.parseInt(br.readLine());\n\t\t\n\t\tHashMap<Integer, ArrayList<Pattern>> arrayMap = new HashMap<Integer, ArrayList<Pattern>>();\n\t\tfor(int i = 1; i <= 3000 ; i++){\n\t\t\tarrayMap.put(i, new ArrayList<Pattern>());\n\t\t}\n\t\t\n\t\tPattern[] patterns = new Pattern[wordsNum];\n\t\tfor(int i = 0; i < wordsNum ; i++){\n\t\t\tchar[] pattern = br.readLine().toCharArray();\n\t\t\t//int index = RKSearcher.indexOf(pattern, inputStr);\n//\t\t\tint index = BMSearcher.indexOf(inputStr, pattern);\n//\t\t\tif(index != -1){\n//\t\t\t\tSystem.out.println(1);\n//\t\t\t}\n//\t\t\telse{\n//\t\t\t\tSystem.out.println(0);\n//\t\t\t}\n\t\t\tPattern tmpPattern = new Pattern(pattern);\n\t\t\tpatterns[i] = tmpPattern;\n\t\t\tarrayMap.get(pattern.length).add(tmpPattern);\n\t\t}\n\t\t//System.out.println(\"MapSize \"+arrayMap.size());\n\t\tfor(int i = 1; i <= arrayMap.size() ; i++){\n\t\t\t//System.out.println(\"i = \"+i);\n\t\t\tArrayList<Pattern> tmplist = arrayMap.get(i);\n\t\t\tif(tmplist.size() > 0){\n\t\t\t\t//System.out.println(\"size \"+tmplist.size());\n\t\t\t\tRKSearcher.indexOf(tmplist, inputStr);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < wordsNum ; i++){\n\t\t\tif(patterns[i].exist){\n\t\t\t\tSystem.out.println(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass Pattern {\n\tchar[] pattern;\n\tboolean exist;\n\t\n\tpublic Pattern (char[] pattern){\n\t\tthis.pattern = Arrays.copyOf(pattern, pattern.length);\n\t\tthis.exist = false;\n\t}\n}\n\nclass RKSearcher {\n\tprivate static final long q = 1000000007L;\n\tprivate static final int d = 64;\n\t\n\tpublic static void indexOf(ArrayList<Pattern> pattern, char[] str2){\n\t\tint M = pattern.get(0).pattern.length;\n\t\tint N = str2.length;\n\t\tint patternNum = pattern.size();\n\t\tlong dM = 1;\n\t\tlong[] h1 = new long[patternNum];\n\t\tlong h2 = 0;\n\t\t\n\t\t//?????????????????°???????????????equals???????????°??????\n\t\tif(M == N){\n\t\t\tfor(int i = 0 ; i < patternNum ; i++){\n\t\t\t\tPattern tmpPtn = pattern.get(i);\n\t\t\t\tif(new String(tmpPtn.pattern).equals(new String(str2))){\n\t\t\t\t\ttmpPtn.exist = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttmpPtn.exist = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\telse if (M > N){\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < M ; i++){\n\t\t\tdM = (d*dM)%q;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < M; i++){\n\t\t\t\n\t\t\th2 = (h2*d + index(str2[i])) % q;\n\t\t}\n\t\t\n\t\tfor(int j = 0; j < patternNum ; j++){\n\t\t\tfor(int i = 0; i < M; i++){\n\t\t\t\th1[j] = (h1[j]*d + index(pattern.get(j).pattern[i])) % q;\n\t\t\t}\n\t\t\tif(h1[j] == h2){\n\t\t\t\tpattern.get(j).exist = true;\n\t\t\t}\n//\t\t\tSystem.out.println(\"hash for \"+new String(pattern.get(j).pattern) + \" is \"+h1[j]);\n\t\t}\n\t//\tSystem.out.println(\"first h2 \"+h2);\n\t\t\n\t\tint i;\n\t\tint matched = 0;\n\t\tfor(i = 0; i < N ;i++){\n\t\t\t//System.out.println(\"i = \"+i+\" h1 \"+h1+\" h2 \"+h2);\n\t\t\th2 = (h2 + d*q - index(str2[i])*dM) % q;\n\t\t\tif(i+M >= N){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\th2 = (h2*d + index(str2[i+M])) % q;\n\t\t\tif (i > N-M){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int j = 0; j < patternNum ; j++){\n\t\t\t\t\n\t\t\t\tif(h1[j] == h2){\n\t\t\t\t\tPattern tmpPtn = pattern.get(j);\n//\t\t\t\t\tSystem.out.println(\"HIT \"+new String(tmpPtn.pattern));\n\t\t\t\t\tif(tmpPtn.exist == false){\n\t\t\t\t\t\ttmpPtn.exist = true;\n\t\t\t\t\t\tmatched++;\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\tSystem.out.println(\"UNMATCH \"+new String(pattern.get(j).pattern));\n//\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(matched == patternNum){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn;\n\t}\n\t\n\tpublic static int indexOf(char[] str1, char[] str2){\n\t\tint M = str1.length;\n\t\tint N = str2.length;\n\t\tlong dM = 1;\n\t\tlong h1 = 0;\n\t\tlong h2 = 0;\n\t\t\n\t\t//?????????????????°???????????????equals???????????°??????\n\t\tif(M == N){\n\t\t\tif(new String(str1).equals(new String(str2))){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\telse if (M > N){\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < M ; i++){\n\t\t\tdM = (d*dM)%q;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < M; i++){\n\t\t\th1 = (h1*d + index(str1[i])) % q;\n\t\t\th2 = (h2*d + index(str2[i])) % q;\n\t\t}\n\t\tint i;\n\t\tfor(i = 0; h1 != h2 ;i++){\n\t\t\t//System.out.println(\"i = \"+i+\" h1 \"+h1+\" h2 \"+h2);\n\t\t\th2 = (h2 + d*q - index(str2[i])*dM) % q;\n\t\t\tif(i+M >= N){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\th2 = (h2*d + index(str2[i+M])) % q;\n\t\t\tif (i > N-M){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn i;\n\t}\n\t\n\tprivate static int index(char c){\n\t\t//return c - '0' + 1;\n\t\t//??°??????0~9\n\t\tif(c >=  '0' && c <= '9'){\n\t\t\treturn c - '0';\n\t\t}\n\t\t//?°??????????10~35\n\t\telse if (c >= 'a' && c <= 'z'){\n\t\t\treturn c - 'a' + 10;\n\t\t}\n\t\t//??§?????????36~61\n\t\telse if (c >= 'A' && c <= 'Z'){\n\t\t\treturn c - 'A' + 36;\n\t\t}\n\t\telse {\n\t\t\treturn -1;\n\t\t}\n\t}\n}\n\nclass BMSearcher {\n\tpublic static int indexOf(char[] str1, char[] str2){\n\t\tif (str2.length == 0){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint charTable[] = makeCharTable(str2);\n\t\tint offsetTable[] = makeOffsetTable(str2);\n\t\tfor(int i = str2.length - 1, j; i < str1.length ;){\n\t\t\tfor(j = str2.length - 1; str2[j] == str1[i] ; i--, j--){\n\t\t\t\tif(j == 0){\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ti += Math.max(offsetTable[str2.length - 1 - j], charTable[str1[i]]);\n\t\t\t\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate static int[] makeCharTable(char[] str) {\n\t\tfinal int ALPHABET_SIZE = 256;\n\t\tint[] table = new int[ALPHABET_SIZE];\n\t\tfor(int i = 0; i < table.length ; i++){\n\t\t\ttable[i] = str.length;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\ttable[str[i]] = str.length - 1 - i;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static int[] makeOffsetTable(char[] str){\n\t\tint[] table = new int[str.length];\n\t\tint lastPrefixPosition = str.length;\n\t\tfor(int i = str.length - 1; i >= 0; i--){\n\t\t\tif(isPrefix(str, i + 1)) {\n\t\t\t\tlastPrefixPosition = i + 1;\n\t\t\t}\n\t\t\ttable[str.length - 1 - i] = lastPrefixPosition - i + str.length - 1;\n\t\t}\n\t\tfor(int i = 0; i < str.length - 1; i++){\n\t\t\tint slen = suffixLength(str, i);\n\t\t\ttable[slen] = str.length - 1 - i + slen;\n\t\t}\n\t\treturn table;\n\t}\n\t\n\tprivate static boolean isPrefix(char[] str, int p){\n\t\tfor (int i = p, j = 0; i < str.length; i++, j++){\n\t\t\tif(str[i] != str[j]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate static int suffixLength(char[] str, int p){\n\t\tint len = 0;\n\t\tfor(int i = p, j = str.length - 1;\n\t\t\t\ti >= 0 && str[i] == str[j]; i--, j--){\n\t\t\tlen += 1;\n\t\t}\n\t\treturn len;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nclass Main {\n\tfinal static int Code = 20;\n\t\n\tpublic static void main(String[] args)throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tchar[] A, B;\n\t\tboolean find = false;\n\t\t//??\\?????¨??¨??????char???????????£??\\\n\t\tA = br.readLine().toCharArray();\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tB = br.readLine().toCharArray();\n\t\t\t//A??????????????????????????????\n\t\t\tif(A.length < B.length) {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tint t = 0;\n\t\t\tint p = 0;\n\t\t\tint BN = search(Code, B.length);\n\t\n\t\t\tfor(int j = 0; j < B.length; j++){\n\t\t\t\tt = t * Code + A[j];\n\t\t\t\tp = p * Code + B[j];\n\t\t\t}\n\t\t\tfind = Print(t ,p, A, B, BN);\n\t\t\t\n\t\t\tif(find) System.out.println(\"1\");\n\t\t\telse System.out.println(\"0\");\n\t\t}\n\t\treturn;\n\t}\n\n\tpublic static int search(int x, int n){\n\t\tif(n == 0) return 1;\n\t\tint ret = search(x * x, n / 2);\n\t\t//??????????????????AND?????????\n\t\tif((n & 1) == 1) ret *= x;\n\t\treturn ret;\n\t}\n\n\tpublic static boolean Print(int t, int p, char[] A, char[] B, int BN){\n\t\t//t??¨p?????????????????????????????¨???\n\t\tif(t == p) return true;\n\t\tfor(int i = 1; i < A.length - B.length + 1; i++){\n\t\t\tt = t * Code + A[i + B.length - 1] - A[i - 1] * BN;\n\t\t\tif(t == p) return true;\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nclass Main {\n\tfinal static int Code = 30;\n\t\n\tpublic static void main(String[] args)throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tchar[] A, B;\n\t\tboolean find = false;\n\t\t//??\\?????¨??¨??????char???????????£??\\\n\t\tA = br.readLine().toCharArray();\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tB = br.readLine().toCharArray();\n\t\t\t//A??????????????????????????????\n\t\t\tif(A.length < B.length) {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tint t = 0;\n\t\t\tint p = 0;\n\t\t\tint BN = search(Code, B.length);\n\t\n\t\t\tfor(int j = 0; j < B.length; j++){\n\t\t\t\tt = t * Code + A[j];\n\t\t\t\tp = p * Code + B[j];\n\t\t\t}\n\t\t\tfind = Print(t ,p, A, B, BN);\n\t\t\t\n\t\t\tif(find) System.out.println(\"1\");\n\t\t\telse System.out.println(\"0\");\n\t\t}\n\t\treturn;\n\t}\n\n\tpublic static int search(int x, int n){\n\t\tif(n == 0) return 1;\n\t\tint ret = search(x * x, n / 2);\n\t\t//??????????????????AND?????????\n\t\tif((n & 1) == 1) ret *= x;\n\t\treturn ret;\n\t}\n\n\tpublic static boolean Print(int t, int p, char[] A, char[] B, int BN){\n\t\t//t??¨p?????????????????????????????¨???\n\t\tif(t == p) return true;\n\t\tfor(int i = 1; i < A.length - B.length + 1; i++){\n\t\t\tt = t * Code + A[i + B.length - 1] - A[i - 1] * BN;\n\t\t\tif(t == p) return true;\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nclass Main {\n\tfinal static int Code = 35;\n\t\n\tpublic static void main(String[] args)throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tchar[] A, B;\n\t\tboolean find = false;\n\t\t//??\\?????¨??¨??????char???????????£??\\\n\t\tA = br.readLine().toCharArray();\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tB = br.readLine().toCharArray();\n\t\t\t//A??????????????????????????????\n\t\t\tif(A.length < B.length) {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tint t = 0;\n\t\t\tint p = 0;\n\t\t\tint BN = search(Code, B.length);\n\t\n\t\t\tfor(int j = 0; j < B.length; j++){\n\t\t\t\tt = t * Code + A[j];\n\t\t\t\tp = p * Code + B[j];\n\t\t\t}\n\t\t\tfind = Print(t ,p, A, B, BN);\n\t\t\t\n\t\t\tif(find) System.out.println(\"1\");\n\t\t\telse System.out.println(\"0\");\n\t\t}\n\t\treturn;\n\t}\n\n\tpublic static int search(int x, int n){\n\t\tif(n == 0) return 1;\n\t\tint ret = search(x * x, n / 2);\n\t\t//??????????????????AND?????????\n\t\tif((n & 1) == 1) ret *= x;\n\t\treturn ret;\n\t}\n\n\tpublic static boolean Print(int t, int p, char[] A, char[] B, int BN){\n\t\t//t??¨p?????????????????????????????¨???\n\t\tif(t == p) return true;\n\t\tfor(int i = 1; i < A.length - B.length + 1; i++){\n\t\t\tt = t * Code + A[i + B.length - 1] - A[i - 1] * BN;\n\t\t\tif(t == p) return true;\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tString t = scan.next();\n\n\t\tint q = scan.nextInt();\n\t\tString[] p = new String[q];\n\t\tfor (int i = 0; i < q; i++)\n\t\t\tp[i] = scan.next();\n\n\t\tPtFind f = new PtFind(t, p, false);\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass PtFind {\n\tboolean debug;\n\tint _p = 97;\n\tint _m = 1000000000;\n\tint hash_fault = 0;\n\tint hash_hit = 0;\n\n\tpublic PtFind(String t, String[] p, boolean d) {\n\t\tdebug = d;\n\n\t\tboolean[] result = new boolean[p.length];\n\t\tint[] length = new int[p.length];\n\t\tlong[] hash = new long[p.length];\n\t\tList<Integer> unresolve = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\tlength[i] = p[i].length();\n\t\t\thash[i] = getHash(p[i], 0, length[i]);\n\t\t\tunresolve.add(i);\n\t\t}\n\n\t\tlong[] thash = new long[1001];\n\t\tint[] tcalc = new int[1001];\n\t\tlong[] multi = new long[1001];\n\t\tmulti[0] = 1;\n\t\tfor (int i = 1; i < tcalc.length; i++) {\n\t\t\ttcalc[i] = -1;\n\t\t\tmulti[i] = multi[i - 1] * _p;\n\t\t\tmulti[i] %= _m;\n\t\t}\n\t\tfor (int i = 0; i < length.length; i++) {\n\t\t\tint le = length[i];\n\t\t\tif (le < t.length() && tcalc[le] == -1) {\n\t\t\t\ttcalc[le] = 0;\n\t\t\t\tthash[le] = getHash(t, 0, le);\n\t\t\t}\n\t\t}\n\n\t\tfor (int st = 0; st < t.length(); st++) {\n\t\t\tfor (int i = 0; i < length.length; i++) {\n\t\t\t\tif (result[i])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tint le = length[i];\n\t\t\t\tif (st + le > t.length())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (tcalc[le] != st) {\n\t\t\t\t\ttcalc[le] = st;\n\t\t\t\t\tlong nh = (thash[le] * _p) + t.charAt(st + le - 1) + _m - ((t.charAt(st - 1) * multi[le]) % _m);\n\t\t\t\t\tthash[le] = nh % _m;\n\t\t\t\t\t// thash[le] = (thash[le] * _p) + t.charAt(st + le - 1);\n\t\t\t\t\t// int mn = (t.charAt(st - 1) * multi[le]) % _m;\n\t\t\t\t\t// thash[le] = (thash[le] + _m - mn) % _m;\n\t\t\t\t}\n\n\t\t\t\tif (thash[le] == hash[i]) {\n\t\t\t\t\tif (p[i].equals(t.substring(st, st + le))) {\n\t\t\t\t\t\tresult[i] = true;\n\t\t\t\t\t\thash_hit++;\n\t\t\t\t\t} else\n\t\t\t\t\t\thash_fault++;\n\t\t\t\t\tif (debug)\n\t\t\t\t\t\tSystem.out.println(hash_hit + \" \" + hash_fault + \"\\t\" + result[i] + \"\\t\" + hash[i] + \"\\t\"\n\t\t\t\t\t\t\t\t+ thash[le] + \"\\t\" + p[i] + \"\\t\" + t.substring(st, st + le));\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif (!debug)\n\t\t\tfor (int i = 0; i < result.length; i++)\n\t\t\t\tif (result[i])\n\t\t\t\t\tSystem.out.println(\"1\");\n\t\t\t\telse\n\t\t\t\t\tSystem.out.println(\"0\");\n\t}\n\n\tprivate long getHash(String s, int start, int length) {\n\t\tlong ret = 0;\n\t\tfor (int i = start; i < start + length; i++) {\n\t\t\tret *= _p;\n\t\t\tret += s.charAt(i);\n\t\t\tret %= _m;\n\t\t}\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\nclass Main {\n\tstatic char saisyo = '!';\n\tstatic SC sc=new SC(System.in);\n\tpublic static void main(String[] args) {\n\t\tString source = sc.next();\n\t\tint[] str = new int[source.length()];\n\t\tfor (int i = 0; i < source.length(); i++) {\n\t\t\tstr[i] = source.charAt(i) - saisyo + 1;\n\t\t}\n\t\tint[] result = SAIS(str, 127);\n\t\t//debug(result,\"SuffixArray\");\n\t\tint N=sc.nextInt();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tString s = sc.next();\n\t\t\tif (bisearch(result, str, s)) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t}\n\tpublic static int[] SAIS(int[] s, int spe) {\n\t\tif (s.length == 1) {\n\t\t\treturn new int[] { 0 };\n\t\t} else {\n\t\t\tint len = s.length + 1;\t\t//末尾文字も含めた文字数\n\t\t\tint[] str = new int[len];\n\t\t\tfor (int i = 0; i < s.length; i++) {\n\t\t\t\tstr[i] = s[i];\t\t//受け取った文字列の配列は末尾文字が含まれてないので新規に配列を作って代入する必要がある\n\t\t\t}\n\t\t\tstr[str.length - 1] = 0;\n\t\t\tint[] LS = new int[len];\t\t//L型S型を入れる配列 L=1 S=0\n\t\t\tint[] LMS = new int[len];\t\t//LMSかどうかを入れる配列 LMSなら正の整数 そうでないなら-1\n\t\t\tint[] LMSsublen = new int[len];\t\t//LMS部分文字列の長さを入れる配列\n\t\t\tint[] LMSlist;\t\t//LMSのインデックスのみを入れる配列（LMSの数は元の文字列の長さからわからないので、可変長配列のほうが楽）\n\t\t\tint LMScount = 0;\t//LMSの個数（LMSのみを集めたリストを可変長配列で持てばわざわざインデックス管理をしなくて済む）\n\t\t\tint[] used=new int[len];\t\t//SuffixArrayに入れたかどうかの配列\n\t\t\tArrays.fill(used, 0);\t\t//初期化 使っていると1で使ってないと0を入れる\n\t\t\tSA[] sa=new SA[spe];\t\t//SAがSuffixArrayと入れるインデックスを保持する\n\t\t\tint[] dict=new int[spe];\t//どの文字が何回出てくるかを入れる配列\n\t\t\tfor(int i=0; i<len; i++) {\n\t\t\t\tdict[str[i]]++;\n\t\t\t}\n\t\t\tfor(int i=0; i<spe; i++) {\n\t\t\t\tsa[i]=new SA(dict[i]);\t\t//SuffixArrayの初期化\n\t\t\t}\n\t\t\tArrays.fill(LMS, -1);\n\t\t\tArrays.fill(LMSsublen, 0);\n\t\t\tLS[len - 1] = 0;\t\t//L型かS型の計算\n\t\t\tfor (int i = len - 2; i >= 0; i--) {\t//後ろから見ていく\n\t\t\t\tif (str[i] == str[i + 1]) {\n\t\t\t\t\tLS[i] = LS[i + 1];\t//隣接する2文字が同じなら後ろの文字依存\n\t\t\t\t} else if (str[i] > str[i + 1]) {\n\t\t\t\t\tLS[i] = 1;\t\t//L\n\t\t\t\t} else if (str[i] < str[i + 1]) {\n\t\t\t\t\tLS[i] = 0;\t\t//S\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 1; i < len; i++) {\t\t//LMSを調べる\n\t\t\t\tif (LS[i] == 0 && LS[i - 1] == 1) {\n\t\t\t\t\tLMS[i] = 1;\t\t//LMS\n\t\t\t\t\tLMScount++;\t\t//LMSの数をカウント\n\t\t\t\t} else {\n\t\t\t\t\tLMS[i] = -1;\t//LMSで無いとき-1\n\t\t\t\t}\n\t\t\t}\n\t\t\tLMS[0] = -1;\t//最初の文字はLMSにならない\n\t\t\tLMSlist = new int[LMScount];\t//LMSのみの配列\n\t\t\tint tmpindex = 0;\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tif (LMS[i] == 1) {\n\t\t\t\t\tLMSlist[tmpindex] = i;\t\t//LMSのインデックスのみが入った配列を作る\n\t\t\t\t\ttmpindex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < LMSlist.length; i++) {\t//LMS部分文字列の長さを計算する\n\t\t\t\tif (LMSlist[i] != len - 1) {\n\t\t\t\t\tLMSsublen[LMSlist[i]] = LMSlist[i + 1] - LMSlist[i];\t\t//LMSとLMSの間の長さがLMS部分文字列の長さ\n\t\t\t\t} else {\n\t\t\t\t\tLMSsublen[LMSlist[i]] = 1;\t//最後のLMSは末尾文字のみとし、その長さは1となる\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < LMSlist.length; i++) {\t\t//1ステップ目 LMSを入れる\n\t\t\t\tint index = LMSlist[i];\n\t\t\t\tsa[str[index]].addusirokara(index);\t\t//後ろから見て値を末尾に追加し続ける＝前から見て後ろから前に入れる\n\t\t\t\tused[index] = 1;\t//SuffixArrayに入れたので使用済みフラグを立てる\n\t\t\t}//1ステップ目終わり\n\t\t\tsa=resetindex(sa);\t//配列のインデックスを再計算\n\n\t\t\tfor(int i=0; i<sa.length; i++) {\t//2ステップ目 L型の文字を入れる\n\t\t\t\tfor(int j=0; j<sa[i].size(); j++) {\n\t\t\t\t\tint value=sa[i].get(j)-1;\n\t\t\t\t\tif(value >=0 && used[value] == 0 && LS[value] == 1) {\n\t\t\t\t\t\tused[value]=1;\n\t\t\t\t\t\tsa[ str[value]].addmaekara(value);\t//前から後ろに値を入れる\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsa=resetindex(sa);//3ステップ終わり\n\t\t\tfor(int i=1; i<sa.length; i++) {\t//3ステップ\n\t\t\t\tfor(int j=0; j<sa[i].size(); j++) {\n\t\t\t\t\tint value=sa[i].get(j);\n\t\t\t\t\tif(value >=0 && LMS[value]==1) {\n\t\t\t\t\t\tsa[i].set(j,-1);\t\t//LMSをSuffixArrayから消す\n\t\t\t\t\t\tused[value]=0;\t\t//SuffixArrayからLMSをとったので未使用になった\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t//3ステップ終わり\n\t\t\tfor(int i=sa.length-1; i>=0; i--) {\t\t\t\t//4ステップ\n\t\t\t\tfor(int j=sa[i].size()-1; j>=0; j--) {\n\t\t\t\t\tif(sa[i].get(j)!=-1) {\n\t\t\t\t\t\tint index=sa[i].get(j)-1;\n\t\t\t\t\t\tif(index>=0 && used[index] == 0 && LS[index] ==0) {\n\t\t\t\t\t\t\tsa[str[index]].addusirokara(index);\t//値を後ろから前に入れる\n\t\t\t\t\t\t\tused[index]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsa=resetindex(sa);//4ステップ終わり\n\t\t\tint counter = 0;\n\t\t\tint[] nowsa = new int[1];\t\t//今見ているLMS部分文字列を入れる配列\n\t\t\tint[] oldsa = new int[1];\t\t//1つ前のLMS部分文字列を入れる配列\n\t\t\tint[] LMScounter = new int[len];\n\t\t\tfor(int i=0; i<sa.length; i++) {\n\t\t\t\tfor(int j=0; j<sa[i].size(); j++) {\n\t\t\t\t\tif (LMS[sa[i].get(j)] != -1) {\t\t//LMSだったらそこからLMS部分文字列がはじまる\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\tLMScounter[sa[i].get(j)] = counter;\n\t\t\t\t\t\tnowsa = new int[LMSsublen[sa[i].get(j)] + 1];\t//始まるLMSのインデックスによってLMS部分文字列の長さはわかる\n\t\t\t\t\t\ttmpindex = 0;\t\t//LMS部分文字列のインデックス\n\t\t\t\t\t\tfor (int k = sa[i].get(j); k < len; k++) {\n\t\t\t\t\t\t\tnowsa[tmpindex] = str[k];\n\t\t\t\t\t\t\ttmpindex++;\n\t\t\t\t\t\t\tif (k != sa[i].get(j) && LMS[k] != -1) {\n\t\t\t\t\t\t\t\tbreak;\t\t//次のLMSが来たらLMS部分文字列は完結\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (equals(oldsa, nowsa)) {\t\t//今見ているLMS部分文字列と1つ前が同じなら同じ部分文字列に同じ番号を振る\n\t\t\t\t\t\t\tcounter--;\n\t\t\t\t\t\t\tLMScounter[sa[i].get(j)] = counter;\n\t\t\t\t\t\t}\n\t\t\t\t\t\toldsa = nowsa;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] new_str = new int[LMSlist.length];\n\t\t\tint[] LMSindex = new int[LMSlist.length + 1];\n\n\t\t\tfor (int i = 0; i < LMSlist.length; i++) {\t\t//LMS部分文字列の辞書順を再帰のSAISで求める\n\t\t\t\tnew_str[i] = LMScounter[LMSlist[i]];\n\t\t\t\tLMSindex[i] = LMSlist[i];\n\t\t\t}\n\t\t\tint[] newLMSindex = SAIS(new_str, counter + 1);\n\n\t\t\tsa=resetindex(sa);\n\t\t\tArrays.fill(used,0);\t//全部未使用に戻る\n\t\t\tsa=clear(sa);\t\t\t//新しいLMS部分文字列の辞書順が分かったのでまた入れなおすためにSuffixArrayの初期化\n\n\t\t\tfor (int i = newLMSindex.length - 1; i >= 0; i--) {\t//新1段階目\n\t\t\t\tint value = LMSindex[newLMSindex[i]];\n\t\t\t\tsa[str[value]].addusirokara(value);\n\t\t\t\tused[value]=1;\n\t\t\t}\n\t\t\tsa=resetindex(sa);\n\t\t\t//2ステップ\tこれ以降は上の3ステップ、4ステップと同様\n\t\t\tfor(int i=0; i<sa.length; i++) {\n\t\t\t\tfor(int j=0; j<sa[i].size(); j++) {\n\t\t\t\t\tint value=sa[i].get(j)-1;\n\t\t\t\t\tif(value >=0 && used[value] == 0 && LS[value] == 1) {\n\t\t\t\t\t\tused[value]=1;\n\t\t\t\t\t\tsa[ str[value]].addmaekara(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsa=resetindex(sa);//2ステップ終わり\n\t\t\tfor(int i=1; i<sa.length; i++) {\t//2.5ステップ\n\t\t\t\tfor(int j=0; j<sa[i].size(); j++) {\n\t\t\t\t\tint value=sa[i].get(j);\n\t\t\t\t\tif(value >=0 && LMS[value]>=1) {\n\t\t\t\t\t\tsa[i].set(j,-1);\t\t//戻す\n\t\t\t\t\t\tused[value]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t//2.5ステップ終わり\n\t\t\t//3ステップ\n\t\t\tfor(int i=sa.length-1; i>=0; i--) {\n\t\t\t\tfor(int j=sa[i].size()-1; j>=0; j--) {\n\t\t\t\t\tif(sa[i].get(j)!=-1) {\n\t\t\t\t\t\tint index=sa[i].get(j)-1;\n\t\t\t\t\t\tif(index>=0 && used[index] == 0 && LS[index] ==0) {\n\t\t\t\t\t\t\tsa[str[index]].addusirokara(index);\n\t\t\t\t\t\t\tused[index]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsa=resetindex(sa);//3ステップ終わり\n\t\t\tint[] ret=convert(sa,len-1);\t//末尾文字のインデックスを除く\n\t\t\treturn ret;\n\t\t}\n\t}\n\tstatic boolean equals(int[] a1, int[] a2) {\n\t\tif (a1.length != a2.length) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tfor (int i = 0; i < a1.length; i++) {\n\t\t\t\tif (a1[i] != a2[i]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tstatic SA[] resetindex(SA[] a) {\n\t\tfor(int i=0; i<a.length; i++) {\n\t\t\ta[i].resetindex();\n\t\t}\n\t\treturn a;\n\t}\n\tstatic SA[] clear(SA[] a) {\n\t\tfor(int i=0; i<a.length; i++) {\n\t\t\ta[i].reset();\n\t\t}\n\t\treturn a;\n\t}\n\tstatic class SA{\n\t\tprivate int[] ary;\n\t\tprivate int mae,ato;\n\t\tSA(int volume){\n\t\t\tary=new int[volume];\n\t\t\tArrays.fill(ary,-1);\n\t\t\tmae=0;\n\t\t\tato=ary.length-1;\n\t\t}\n\t\tvoid addmaekara(int value) {\n\t\t\tif(mae<ary.length) {\n\t\t\t\tary[mae] = value;\n\t\t\t\tmae++;\n\t\t\t}\n\t\t}\n\t\tvoid addusirokara(int value) {\n\t\t\tif(ato>=0) {\n\t\t\t\tary[ato] = value;\n\t\t\t\tato--;\n\t\t\t}\n\t\t}\n\t\tvoid resetindex() {\n\t\t\tmae=0;\n\t\t\tato=ary.length-1;\n\t\t}\n\t\tvoid set(int index,int element) {\n\t\t\tary[index] = element;\n\t\t}\n\t\tvoid reset() {\n\t\t\tArrays.fill(ary, -1);\n\t\t\tresetindex();\n\t\t}\n\t\tint get(int index) {\n\t\t\treturn ary[index];\n\t\t}\n\t\tint size() {\n\t\t\treturn ary.length;\n\t\t}\n\t}\n\tstatic int[] convert(SA[] s,int len){\n\t\tint[] ret=new int[len];\n\t\tint counter=0;\n\t\tfor(int i=1; i<s.length; i++) {\n\t\t\tfor(int j=0; j<s[i].size(); j++) {\n\t\t\t\tret[counter]=s[i].get(j);\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic class SC {\n\t\tprivate BufferedReader reader = null;\n\t\tprivate StringTokenizer tokenizer = null;\n\t\tpublic SC(InputStream in) {\n\t\t\treader = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\t\tpublic String next() {\n\t\t\tif (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new UncheckedIOException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n\tstatic void debug(int[] a, String s) {\n\t\tSystem.out.print(s + \"[\");\n\t\tfor (int i = 0; i < a.length - 1; i++) {\n\t\t\tSystem.out.print(a[i] + \",\");\n\t\t}\n\t\tSystem.out.println(a[a.length - 1] + \"]\");\n\t}\n\tstatic boolean bisearch(int[] SA, int[] str, String s) {\n\t\tint[] ksk =new int[s.length()];\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tksk[i] = s.charAt(i) - saisyo + 1;\n\t\t}\n\t\tint min =0;\n\t\tint max =SA.length-1;\n\t\tif (s.length() > SA.length) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\twhile (max - min > 1) {\n\t\t\t\tint mid = min + (max - min) / 2;\n\t\t\t\tint index = SA[mid];\n\t\t\t\tif (index <= SA.length - ksk.length) {\n\t\t\t\t\tboolean icchi = true;\n\t\t\t\t\tfor (int i = 0; i < ksk.length; i++) {\n\t\t\t\t\t\tif (str[index + i] < ksk[i]) {\n\t\t\t\t\t\t\tmin = mid;\n\t\t\t\t\t\t\ticchi = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (str[index + i] > ksk[i]) {\n\t\t\t\t\t\t\tmax = mid;\n\t\t\t\t\t\t\ticchi = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (icchi) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tboolean a = true;\n\t\t\t\t\tfor (int i = index; i < str.length; i++) {\n\t\t\t\t\t\tif (str[i] < ksk[i - index]) {\n\t\t\t\t\t\t\tmin = mid;\n\t\t\t\t\t\t\ta = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (str[i] > ksk[i - index]) {\n\t\t\t\t\t\t\tmax = mid;\n\t\t\t\t\t\t\ta = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (a) {\n\t\t\t\t\t\tmin = mid;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int h = min; h <= max; h++) {\n\t\t\t\tif (SA[h] + s.length() <= SA.length) {\n\t\t\t\t\tboolean a = true;\n\t\t\t\t\tint index = SA[h];\n\t\t\t\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\t\t\t\tif (str[index + i] != ksk[i]) {\n\t\t\t\t\t\t\ta = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (a) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\tstatic boolean bisearch(int[] SA, int[] str, String s,int[] in) {\n\t\tint[] ksk = new int[s.length()];\n\t\tfor(int i=0; i<s.length(); i++) {\n\t\t\tksk[i]=s.charAt(i) - saisyo + 1;\n\t\t}\n\t\tint min = in[ksk[0]-1];\n\t\tint max = in[ksk[0]] -1;\n\t\tif (s.length() > SA.length) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\twhile (max - min > 1) {\n\t\t\t\tint mid = min + (max - min) / 2;\n\t\t\t\tint index = SA[mid];\n\t\t\t\tif (index <= SA.length - ksk.length) {\n\t\t\t\t\tboolean icchi = true;\n\t\t\t\t\tfor (int i = 0; i < ksk.length; i++) {\n\t\t\t\t\t\tif (str[index + i] < ksk[i]) {\n\t\t\t\t\t\t\tmin = mid;\n\t\t\t\t\t\t\ticchi = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (str[index + i] > ksk[i]) {\n\t\t\t\t\t\t\tmax = mid;\n\t\t\t\t\t\t\ticchi = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (icchi) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tboolean a = true;\n\t\t\t\t\tfor (int i = index; i < str.length; i++) {\n\t\t\t\t\t\tif (str[i] < ksk[i - index]) {\n\t\t\t\t\t\t\tmin = mid;\n\t\t\t\t\t\t\ta = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (str[i] > ksk[i - index]) {\n\t\t\t\t\t\t\tmax = mid;\n\t\t\t\t\t\t\ta = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (a) {\n\t\t\t\t\t\tmin = mid;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int h = min; h <= max; h++) {\n\t\t\t\tif (SA[h] + s.length() <= SA.length) {\n\t\t\t\t\tboolean a = true;\n\t\t\t\t\tint index = SA[h];\n\t\t\t\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\t\t\t\tif (str[index + i] != ksk[i]) {\n\t\t\t\t\t\t\ta = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (a) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nclass Main {\n\tfinal static int Code = 37;\n\t\n\tpublic static void main(String[] args)throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tchar[] A, B;\n\t\tboolean find = false;\n\t\t//??\\?????¨??¨??????char???????????£??\\\n\t\tA = br.readLine().toCharArray();\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tB = br.readLine().toCharArray();\n\t\t\t//A??????????????????????????????\n\t\t\tif(A.length < B.length) {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tint t = 0;\n\t\t\tint p = 0;\n\t\t\tint BN = search(Code, B.length);\n\t\n\t\t\tfor(int j = 0; j < B.length; j++){\n\t\t\t\tt = t * Code + A[j];\n\t\t\t\tp = p * Code + B[j];\n\t\t\t}\n\t\t\tfind = Print(t ,p, A, B, BN);\n\t\t\t\n\t\t\tif(find) System.out.println(\"1\");\n\t\t\telse System.out.println(\"0\");\n\t\t}\n\t\treturn;\n\t}\n\n\tpublic static int search(int x, int n){\n\t\tif(n == 0) return 1;\n\t\tint ret = search(x * x, n / 2);\n\t\t//??????????????????AND?????????\n\t\tif((n & 1) == 1) ret *= x;\n\t\treturn ret;\n\t}\n\n\tpublic static boolean Print(int t, int p, char[] A, char[] B, int BN){\n\t\t//t??¨p?????????????????????????????¨???\n\t\tif(t == p) return true;\n\t\tfor(int i = 1; i < A.length - B.length + 1; i++){\n\t\t\tt = t * Code + A[i + B.length - 1] - A[i - 1] * BN;\n\t\t\tif(t == p) return true;\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String literal = sc.nextLine();\n        int encount = Integer.parseInt(sc.nextLine());\n        \n        for(int i=0;i<encount;i++){\n        \tString line = sc.nextLine();\n        \tif(literal.indexOf(line)==-1){\n        \t\tSystem.out.println(0);\n        \t}else{\n        \t\tSystem.out.println(1);\n        \t}\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\n\nclass Main{\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br  = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tString temp = br.readLine();\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tif(temp.contains(br.readLine()))out.println(1);\n\t\t\telse out.println(0);\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuffer sb = new StringBuffer();\n\t\t\n\t\tString str = br.readLine();\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tString temp = br.readLine();\n\t\t\tif(str.contains(temp)){\n\t\t\t\tsb.append(\"1\" + \"\\n\");\n\t\t\t} else {\n\t\t\t\tsb.append(\"0\" + \"\\n\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(sb.toString());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuffer sb = new StringBuffer();\n\t\tString str = br.readLine();\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(str.contains(br.readLine())){\n\t\t\t\tsb.append(\"1\" + \"\\n\");\n\t\t\t}else{\n\t\t\t\tsb.append(\"0\" + \"\\n\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(sb.toString());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tchar[] t = sc.next().toCharArray();\n\t\tSuffixArray sa = new SuffixArray(t);\n\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tString p = sc.next();\n\n\t\t\tif (sa.contains(p.toCharArray())) {\n\t\t\t\tpr.println(\"1\");\n\t\t\t} else {\n\t\t\t\tpr.println(\"0\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class SuffixArray {\n\t\tchar[] s;\n\t\tint n;\n\n\t\tInteger[] sa;\n\t\tint[] rank;\n\t\tint[] rtmp;\n\t\tSaComparator sac;\n\n\t\tint k;\n\n\t\tSuffixArray(char[] str) {\n\t\t\tthis.s = str;\n\t\t\tn = s.length;\n\n\t\t\tsa = new Integer[n + 1];\n\t\t\trank = new int[n + 1];\n\t\t\trtmp = new int[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tsa[i] = i;\n\t\t\t\tif (i < n) {\n\t\t\t\t\trank[i] = s[i];\n\t\t\t\t} else {\n\t\t\t\t\trank[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsac = new SaComparator();\n\n\t\t\tfor (k = 1; k < n; k *= 2) {\n\t\t\t\tArrays.sort(sa, sac);\n\n\t\t\t\trtmp[sa[0]] = rank[sa[0]];\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tif (sac.compare(sa[i - 1], sa[i]) == 0) {\n\t\t\t\t\t\trtmp[sa[i]] = rtmp[sa[i - 1]];\n\t\t\t\t\t} else {\n\t\t\t\t\t\trtmp[sa[i]] = rtmp[sa[i - 1]] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint[] tmp = rtmp;\n\t\t\t\trtmp = rank;\n\t\t\t\trank = tmp;\n\t\t\t}\n\t\t}\n\n\t\tboolean contains(char[] t) {\n\t\t\tint l = 0;\n\t\t\tint r = n;\n\t\t\twhile (r > l) {\n\t\t\t\tint mid = l + (r - l) / 2;\n\t\t\t\tint res = compare(s, mid, t);\n\n\t\t\t\tif (res >= 0) {\n\t\t\t\t\tr = mid;\n\t\t\t\t} else {\n\t\t\t\t\tl = mid + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn compare(s, l, t) == 0;\n\t\t}\n\n\t\tint compare(char[] s, int mid, char[] t) {\n\t\t\tint m = t.length;\n\n\t\t\tfor (int i = 0; sa[mid] + i < n && i < m; i++) {\n\t\t\t\tint res = s[sa[mid] + i] - t[i];\n\n\t\t\t\tif (res != 0) {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sa[mid] + m > n) {\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tprivate class SaComparator implements Comparator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic int compare(Integer i, Integer j) {\n\t\t\t\tif (rank[i] != rank[j]) {\n\t\t\t\t\treturn Integer.compare(rank[i], rank[j]);\n\t\t\t\t}\n\n\t\t\t\tint ri = i + k <= n ? rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? rank[j + k] : -1;\n\t\t\t\treturn Integer.compare(ri, rj);\n\t\t\t}\n\n\t\t}\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n\t\tpr.close();\n\t\tsc.close();\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t// parseInt from Integer.parseInt()\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t// parseLong from Long.parseLong()\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(PrintStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\n \nclass Program\n{\n    static void Main()\n    {\n        string original = Console.ReadLine();\n        int n = int.Parse(Console.ReadLine());\n        for (int i = 0; i < n; i++)\n        {\n            Console.WriteLine(original.Contains(Console.ReadLine()) ? 1 : 0);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\n \nnamespace ALDS1_14_D\n{\n\tclass SuffixArray\n\t{\n\t\tinternal int[] sa, rank, tmp;\n\t\tinternal string S;\n\t\tinternal int n, k;\n\t\t\n\t\tpublic SuffixArray(string SS)\n\t\t{\n\t\t\tS = SS;\n\t\t\tn = S.Length;\n\t\t\tsa = new int[n + 1];\n\t\t\trank = new int[n + 1];\n\t\t\ttmp = new int[n + 1];\n\t\t\tConstruct_SA();\n\t\t}\n\t\t\n\t\tpublic int Compare_SA(int i, int j)\n\t\t{\n\t\t\tif(rank[i] != rank[j]) return rank[i] - rank[j];\n\t\t\t\n\t\t\tint ri = i + k  <= n ? rank[i + k] : -1;\n\t\t\tint rj = j + k <= n ? rank[j + k] : -1;\n\n\t\t\treturn  ri - rj; \n\t\t}\n\t\t\n\t\tpublic void Construct_SA()\n\t\t{\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tsa[i] = i;\n\t\t\t\trank[i] = S[i];\n\t\t\t}\n\t\t\tsa[n] = n; rank[n] = -1;\n\t\t\t\n\t\t\tfor(k = 1; k <= n; k*= 2)\n\t\t\t{\n\t\t\t\tArray.Sort(sa, Compare_SA);\n                \n                tmp[sa[0]] = 0;\n                for (int i = 1; i <= n; i++)\n                {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + ((Compare_SA(sa[i - 1], sa[i]) < 0) ? 1 : 0);\n                }\n                for (int i = 0; i <= n; i++)\n                {\n                    rank[i] = tmp[i];\n                }\n \n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic string Contains(string pattern)\n\t\t{\n\t\t\tint l = 1, r = n + 1;\n\t\t\tint pl = pattern.Length;\n\t\t\t\n\t\t\twhile(l < r)\n\t\t\t{\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\t\n\t\t\t\tstring subStr = (sa[m] + pl >= n) ? S.Substring(sa[m]) : S.Substring(sa[m], pl);\n                    \n                int comp = subStr.CompareTo(pattern);\n                if (comp == 0) return \"1\";\n                \n                if (comp < 0) l = m + 1;\n                else r = m;\n\t\t\t}\n\t\t\treturn \"0\";\n\t\t}\n\t}\n\t\n\t\n    class Program\n    {\n        static void Main(string[] args)\n        {\n        \tvar T = Console.ReadLine();\n        \t\n            SuffixArray SA = new SuffixArray(T);\n            StringBuilder sb = new StringBuilder();\n \n            var Q = int.Parse(Console.ReadLine());\n \n            for (int i = 0; i < Q; i++)\n            {\n                var P = Console.ReadLine();\n \n                sb.AppendLine(SA.Contains(P));\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Text;\n\nnamespace ALDS1_14_D\n{\n    class Program\n    {\n        static StringBuilder sb = new StringBuilder();\n        static string S, T;\n        static int[] sa;\n        static int n, k;\n        static int[] rank, tmp;\n        static int Q;\n\n        static void Main(string[] args)\n        {\n            S = Console.ReadLine();\n            n = S.Length;\n            sa = new int[n + 1];\n            rank = new int[n + 1];\n            tmp = new int[n + 1];\n            construct_sa();\n\n       \n            Q = int.Parse(Console.ReadLine());\n            for (int i = 0; i < Q; i++)\n            {\n                T = Console.ReadLine();\n                sb.AppendLine(contain() ? \"1\" : \"0\");\n            }\n            Console.Write(sb);\n        }\n\n        static bool contain()\n        {\n            int a = 0, b = S.Length + 1;\n            string d = \"\";\n            while (a != b)\n            {              \n                int c = (a + b) / 2;\n\n                //S???sa[c]???????????????|T|????????¨T?????????\n                d = \"\";\n                for (int i = 0; i < T.Length; i++)\n                {\n                    if (sa[c] + i >= S.Length) break;\n                    d += S[sa[c] + i];\n                }\n                \n                int dc = d.CompareTo(T);\n\n                //Console.WriteLine(a + \" \" + b + \" \" + c + \" \" + d +\" \"+ dc);\n                if (dc == 0) return true;\n\n                if (dc < 0) a = c + 1;\n                else b = c; \n            }\n            return false;\n\n        }\n\n        //(rank[i], rank[i + k])??¨(rank[j], rank[j + k])?????????\n      //????????????\n        static bool compare_sa(int i, int j)\n        {\n            if (rank[i] != rank[j]) return rank[i] < rank[j];\n            int ri = i + k <= n ? rank[i + k] : -1;\n            int rj = j + k <= n ? rank[j + k] : -1;\n            return ri < rj;\n        }\n        \n        //?????????S?????\\?°??????????????§????\n        static void construct_sa()\n        {\n            //?????????1???????????????????????????????????????????????°??????\n            for (int i = 0; i <= n; i++)\n            {\n                sa[i] = i;\n                rank[i] = i < n ? S[i] : -1;\n            }\n\n\n            //k????????????????????????????????????????????¨???????????????2k????????§???????????????\n            for (k = 1; k <= n; k *= 2)\n            {\n                sa = sa.OrderBy(s => rank[s]).ThenByDescending(s => sa[s]).ToArray();\n\n                /*Console.WriteLine();\n                Console.WriteLine(0 +\" \" + sa[0]+ \"   \"+rank[sa[0]]);             \n                for (int i = 1; i <= n; i++)\n                {\n                    Console.WriteLine(i  + \" \" + sa[i] + \" \" + S[sa[i]] + \" \" + rank[sa[i]]);\n                }*/\n\n\n\n                //?????£??????tmp????¬?????????????????¨??????????????????????rank????§????\n                tmp[sa[0]] = 0;\n                for (int i = 1; i <= n; i++)\n                {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + (compare_sa(sa[i - 1], sa[i]) ? 1 : 0);\n                }\n                for (int i = 0; i <= n; i++)\n                {\n                    rank[i] = tmp[i];\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class KMP\n    {\n        int[] lps;\n\n        public int IndexOf(string text, string pattern)\n        {\n            int M = pattern.Length;\n            int N = text.Length;\n            int i = 0;\n            int j = 0;\n\n            ComputeLPS(pattern, M);\n\n            while (i < N)\n            {\n                if (pattern[j] == text[i])\n                {\n                    j++;\n                    i++;\n                }\n\n                if (j == M)\n                {\n                    return (i - j);\n                }\n\n                else if (i < N && pattern[j] != text[i])\n                {\n                    if (j != 0) j = lps[j - 1];\n                    else i++;\n                }\n            }\n            return -1;\n        }\n\n        private void ComputeLPS(string pattern, int M)\n        {\n            lps = new int[M];\n            lps[0] = 0;\n\n            int len = 0;\n            int i = 1;\n\n            while (i < M)\n            {\n                if (pattern[i] == pattern[len])\n                {\n                    len++;\n                    lps[i] = len;\n                    i++;\n                }\n                else\n                {\n                    if (len != 0)\n                    {\n                        len = lps[len - 1];\n                    }\n                    else\n                    {\n                        lps[i] = 0;\n                        i++;\n                    }\n                }\n            }\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string text = Console.ReadLine();\n\n            int n = int.Parse(Console.ReadLine());\n\n            StringBuilder sb = new StringBuilder();\n            KMP kmp = new KMP();\n\n            for (int i = 0; i < n; i++)\n            {\n                string pattern = Console.ReadLine();\n\n                int index = kmp.IndexOf(text, pattern);\n\n                sb.AppendLine(index >= 0 ? \"1\" : \"0\");\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Pattern\n    {\n        internal string str;\n        internal int id;\n        internal bool find;\n    }\n\n    class SearchString\n    {\n        readonly int MOD = 1000000007;\n        readonly int C = 407;\n\n        public void SearchStrings(string text, Pattern[] patterns)\n        {\n            Array.Sort(patterns, (a, b) => a.str.Length - b.str.Length);\n\n            int curLen = 0;\n            long[] txtTable = new long[text.Length];\n            long[] patTable;\n\n            for (int i = 0; i < patterns.Length; i++)\n            {\n                string pat = patterns[i].str;\n\n                if (pat.Length > text.Length) continue;\n\n                if (curLen != pat.Length)\n                {\n                    txtTable = GenHash(text, text.Length, pat.Length);\n                    curLen = pat.Length;\n                }\n\n                patTable = GenHash(pat, pat.Length, pat.Length);\n\n                for (int j = 0; j <= text.Length - pat.Length; j++)\n                {\n                    if (txtTable[j] == patTable[0])\n                    {\n                        if (text.Substring(j, pat.Length) == pat)\n                        {\n                            patterns[i].find = true;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            Array.Sort(patterns, (a, b) => a.id - b.id);\n\n            StringBuilder sb = new StringBuilder();\n\n            foreach (var p in patterns)\n            {\n                sb.AppendLine(p.find ? \"1\" : \"0\");\n            }\n            Console.Write(sb);\n        }\n\n        private long[] GenHash(string v, int n, int m)\n        {\n            long[] ret = new long[n];\n\n            long cn = 1;\n\n            for (int i = 0; i < m; i++) cn = (cn * C) % MOD;\n\n            long hs = 0;\n\n            for (int i = 0; i < m; i++) hs = (hs * C + v[i]) % MOD;\n\n            for (int i = 0; i <= n - m; i++)\n            {\n                ret[i] = hs;\n\n                if (i + m < n) hs = (hs * C - v[i] * cn + v[i + m]) % MOD;\n\n                hs = (hs < 0) ? hs + MOD : hs;\n            }\n            return ret;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string text = Console.ReadLine();\n\n            int Q = int.Parse(Console.ReadLine());\n\n            Pattern[] patterns = new Pattern[Q];\n            Pattern temp;\n\n            for (int i = 0; i < Q; i++)\n            {\n                temp.str = Console.ReadLine();\n                temp.id = i;\n                temp.find = false;\n\n                patterns[i] = temp;\n            }\n\n            SearchString SS = new SearchString();\n            SS.SearchStrings(text, patterns);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Text;\n \nnamespace ALDS1_14_D\n{\n\tclass SuffixArray\n\t{\n\t\tinternal int[] sa, rank, tmp;\n\t\tinternal string S;\n\t\tinternal int n, k;\n\t\t\n\t\tpublic SuffixArray(string SS)\n\t\t{\n\t\t\tS = SS;\n\t\t\tn = S.Length;\n\t\t\tsa = new int[n + 1];\n\t\t\trank = new int[n + 1];\n\t\t\ttmp = new int[n + 1];\n\t\t\tConstruct_SA();\n\t\t}\n\t\t\n\t\tpublic int Compare_SA(int i, int j)\n\t\t{\n\t\t\tif(rank[i] > rank[j]) return 1;\n\t\t\tif(rank[i] < rank[j]) return -1;\n\t\t\t\n\t\t\tint ri = i + k  <= n ? rank[i + k] : -1;\n\t\t\tint rj = j + k <= n ? rank[j + k] : -1;\n\t\t\tif(ri > rj) return 1;\n\t\t\tif(ri < rj) return -1;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tpublic void Construct_SA()\n\t\t{\n\t\t\tfor(int i = 0; i <= n; i++)\n\t\t\t{\n\t\t\t\tsa[i] = i;\n\t\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t\t}\n\t\t\t\n\t\t\tfor(k = 1; k <= n; k*= 2)\n\t\t\t{\n\t\t\t\tArray.Sort(sa, Compare_SA);\n\t\t\t\t\n\t\t\t    /*Console.WriteLine();\n                Console.WriteLine(0 +\" \" + sa[0]+ \"   \"+rank[sa[0]]);             \n                for (int i = 1; i <= n; i++)\n                {\n                    Console.WriteLine(i  + \" \" + sa[i] + \" \" + S[sa[i]] + \" \" + rank[sa[i]]);\n                }*/\n                \n                \n                tmp[sa[0]] = 0;\n                for (int i = 1; i <= n; i++)\n                {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + ((Compare_SA(sa[i - 1], sa[i]) < 0) ? 1 : 0);\n                }\n                for (int i = 0; i <= n; i++)\n                {\n                    rank[i] = tmp[i];\n                }\n \n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic bool Contains(string pattern)\n\t\t{\n\t\t\tint l = 1, r = n + 1;\n\t\t\tint pl = pattern.Length;\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.WriteLine(pattern);\n\t\t\twhile(l < r)\n\t\t\t{\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\t\n\t\t\t\tstring subStr = (sa[m] + pl > n) ? S.Substring(sa[m]) : S.Substring(sa[m], pl);\n                    \n                   \n                int comp = subStr.CompareTo(pattern);\n                \n                 //Console.WriteLine(l + \" \" + r + \" \" + m + \" \" + subStr +\" \"+ comp);\n                if (comp == 0) return true;\n                \n                if (comp < 0) l = m + 1;\n                else r = m;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t\n    class Program\n    {\n        static void Main(string[] args)\n        {\n        \tvar T = Console.ReadLine();\n        \t\n            SuffixArray SA = new SuffixArray(T);\n            StringBuilder sb = new StringBuilder();\n \n            var Q = int.Parse(Console.ReadLine());\n \n            for (int i = 0; i < Q; i++)\n            {\n                var P = Console.ReadLine();\n \n                sb.AppendLine(SA.Contains(P) ? \"1\" : \"0\");\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n        var s=sc.S;\n        var sa=new Sa1(s,'0','z');\n        int n=sc.I;\n        StringBuilder sb=new StringBuilder();\n        for(int i = 0;i<n;i++) {sb.Append((sa.Fa1(sc.S)!=-1?1:0)+\"\\n\");}\n        Console.Write(sb);\n\t}\n}\npublic class Sa1{\n\tprivate readonly int n,m,o;\n\tpublic readonly string s;\n\tpublic readonly int[] sa;\n\tpublic Sa1(string s,int a,int z){\n\t\tm=z-a+2;\n\t\to=a-1;\n\t\ts+=(char)o;\n\t\tthis.s=s;\n\t\tn=s.Length;\n\t\tint[] h=new int[n];\n\t\tvar lms=new List<int>();\n\t\tint[] sub=new int[n];\n\t\tint[] hi=new int[m];\n\t\tint[] hc1=new int[m];\n\t\tint[] hc2=new int[m];\n\t\tint[] hc3=new int[m];\n\t\thi[s[n-1]-o]=hc2[s[n-1]-o]=hc3[s[n-1]-o]=1;\n\t\tfor(int i = n-2,k=n-1;i>=0;i--) {\n\t\t\th[i]=s[i]!=s[i+1]?(s[i]>s[i+1]?1:0):h[i+1];\n\t\t\thi[s[i]-o]++;\n\t\t\tif(h[i]==1&&h[i+1]==0){\n\t\t\t\th[i+1]=2;\n\t\t\t\tlms.Add(i+1);\n\t\t\t\tsub[i+1]=k-i;\n\t\t\t\tk=i+1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i<m;i++) {\n\t\t\thi[i]+=hi[i-1];\n\t\t\thc2[i]=hc3[i]=hi[i];\n\t\t\thc1[i]=hi[i-1];\n\t\t}\n\t\tint c=lms.Count;\n\t\tsa=new int[n];\n\t\tfor(int i = 0;i<c;i++) {\n\t\t\thc2[s[lms[i]]-o]--;\n\t\t\tsa[hc2[s[lms[i]]-o]]=lms[i];\n\t\t}\n\t\tfor(int i = 0;i<n;i++) {\n\t\t\tif(sa[i]>0&&h[sa[i]-1]==1){\n\t\t\t\tsa[hc1[s[sa[i]-1]-o]]=sa[i]-1;\n\t\t\t\thc1[s[sa[i]-1]-o]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = n-1;i>=0;i--) {\n\t\t\tif(sa[i]>0&&h[sa[i]-1]!=1){\n\t\t\t\thc3[s[sa[i]-1]-o]--;\n\t\t\t\tsa[hc3[s[sa[i]-1]-o]]=sa[i]-1;\n\t\t\t}\n\t\t}\n\t\tint[] lmsn=new int[c];\n\t\tfor(int i = 0,j=c-1;i<n&&j>=0;i++) {\n\t\t\tif(h[sa[i]]==2){lmsn[j]=sa[i];j--;}\n\t\t}\n\t\tint[] lmsz=new int[n];\n\t\tint[] lmsc=new int[c];\n\t\tbool jf=false;\n\t\tint ki=0;\n\t\tfor(int i = c-2;i>=0;i--) {\n\t\t\tif(sub[lmsn[i]]==sub[lmsn[i+1]]){\n\t\t\t\tbool bo=false;\n\t\t\t\tfor(int j = 0;j<sub[lmsn[i]];j++) {if(s[lmsn[i]+j]!=s[lmsn[i+1]+j]){bo=true;break;}}\n\t\t\t\tif(bo){ki++;}\n\t\t\t\telse{jf=true;}\n\t\t\t}\n\t\t\telse{ki++;}\n\t\t\tlmsz[lmsn[i]]=ki;\n\t\t}\n\t\tfor(int i = c-1;i>=0;i--) {lmsc[c-i-1]=lmsz[lms[i]];}\n\t\thc2[0]=hc3[0]=hi[0];\n\t\thc1[0]=0;\n\t\tfor(int i = 1;i<m;i++) {\n\t\t\thc2[i]=hc3[i]=hi[i];\n\t\t\thc1[i]=hi[i-1];\n\t\t}\n\t\tif(jf){\n\t\t\tlmsn=Fu2(lmsc,ki+1);\n\t\t\tfor(int i = 0;i<c;i++) {lmsn[i]=lms[c-1-lmsn[i]];}\n\t\t}\n\t\tsa=new int[n];\n\t\tfor(int i = 0;i<c;i++) {\n\t\t\thc2[s[lmsn[i]]-o]--;\n\t\t\tsa[hc2[s[lmsn[i]]-o]]=lmsn[i];\n\t\t}\n\t\tfor(int i = 0;i<n;i++) {\n\t\t\tif(sa[i]>0&&h[sa[i]-1]==1){\n\t\t\t\tsa[hc1[s[sa[i]-1]-o]]=sa[i]-1;\n\t\t\t\thc1[s[sa[i]-1]-o]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = n-1;i>=0;i--) {\n\t\t\tif(sa[i]>0&&h[sa[i]-1]!=1){\n\t\t\t\thc3[s[sa[i]-1]-o]--;\n\t\t\t\tsa[hc3[s[sa[i]-1]-o]]=sa[i]-1;\n\t\t\t}\n\t\t}\n\t}\n\tpublic int Fa1(string t){return Bs(t);}\n\tprivate int Bs(string t){\n\t\tint l=t.Length;\n\t\tint lb=-1,mid=0,ub=n-1;\n\t\twhile(ub-lb>1){\n\t\t\tmid=(ub+lb)/2;\n\t\t\tint tm=Min(l,n-sa[mid])-1,ti=0;\n\t\t\twhile(s[sa[mid]+ti]==t[ti]&&ti<tm){ti++;}\n\t\t\tif(s[sa[mid]+ti]>=t[ti]){ub=mid;}\n\t\t\telse{lb=mid;}\n\t\t}\n\t\tbool bo=true;\n\t\tfor(int i = 0;i<l;i++) {\n\t\t\tif(s[sa[ub]+i]!=t[i]){bo=false;break;}\n\t\t}\n\t\treturn bo?ub:-1;\n\t}\n\tprivate int[] Fu2(IReadOnlyList<int> s,int m){\n\t\tint n=s.Count;\n\t\tvar lms=new List<int>();\n\t\tint[] h=new int[n],sub=new int[n],sa=new int[n];\n\t\tint[] hi=new int[m],hc1=new int[m],hc2=new int[m],hc3=new int[m];\n\t\thi[s[n-1]]=hc2[s[n-1]]=hc3[s[n-1]]=1;\n\t\tfor(int i = n-2,k=n-1;i>=0;i--) {\n\t\t\th[i]=s[i]!=s[i+1]?(s[i]>s[i+1]?1:0):h[i+1];\n\t\t\thi[s[i]]++;\n\t\t\tif(h[i]==1&&h[i+1]==0){\n\t\t\t\th[i+1]=2;\n\t\t\t\tlms.Add(i+1);\n\t\t\t\tsub[i+1]=k-i;\n\t\t\t\tk=i+1;\n\t\t\t}\n\t\t}\n\t\tint lm=lms.Count;\n\t\tfor(int i = 1;i<m;i++) {\n\t\t\thi[i]+=hi[i-1];\n\t\t\thc2[i]=hc3[i]=hi[i];\n\t\t\thc1[i]=hi[i-1];\n\t\t}\n\t\tfor(int i = 0;i<lm;i++) {\n\t\t\thc2[s[lms[i]]]--;\n\t\t\tsa[hc2[s[lms[i]]]]=lms[i];\n\t\t}\n\t\tfor(int i = 0;i<n;i++) {\n\t\t\tif(sa[i]>0&&h[sa[i]-1]==1){\n\t\t\t\tsa[hc1[s[sa[i]-1]]]=sa[i]-1;\n\t\t\t\thc1[s[sa[i]-1]]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = n-1;i>=0;i--) {\n\t\t\tif(sa[i]>0&&h[sa[i]-1]!=1){\n\t\t\t\thc3[s[sa[i]-1]]--;\n\t\t\t\tsa[hc3[s[sa[i]-1]]]=sa[i]-1;\n\t\t\t}\n\t\t}\n\t\tint[] sl=new int[lm];\n\t\tfor(int i = 0,j=lm-1;i<n&&j>=0;i++) {\n\t\t\tif(h[sa[i]]==2){sl[j]=sa[i];j--;}\n\t\t}\n\t\tint[] lmsz=new int[n];\n\t\tbool jf=false;\n\t\tint ki=0;\n\t\tfor(int i = lm-2;i>=0;i--) {\n\t\t\tif(sub[sl[i]]==sub[sl[i+1]]){\n\t\t\t\tbool bo=false;\n\t\t\t\tfor(int j = 0;j<sub[sl[i]];j++) {if(s[sl[i]+j]!=s[sl[i+1]+j]){bo=true;break;}}\n\t\t\t\tif(bo){ki++;}\n\t\t\t\telse{jf=true;}\n\t\t\t}\n\t\t\telse{ki++;}\n\t\t\tlmsz[sl[i]]=ki;\n\t\t}\n\t\tint[] lmsc=new int[lm];\n\t\tfor(int i = lm-1;i>=0;i--) {lmsc[lm-i-1]=lmsz[lms[i]];}\n\t\thc2[0]=hc3[0]=hi[0];\n\t\thc1[0]=0;\n\t\tfor(int i = 1;i<m;i++) {\n\t\t\thc2[i]=hc3[i]=hi[i];\n\t\t\thc1[i]=hi[i-1];\n\t\t}\n\t\tif(jf){\n\t\t\tsl=Fu2(lmsc,ki+1);\n\t\t\tfor(int i = 0;i<lm;i++) {sl[i]=lms[lm-1-sl[i]];}\n\t\t}\n\t\tsa=new int[n];\n\t\tfor(int i = 0;i<lm;i++) {\n\t\t\thc2[s[sl[i]]]--;\n\t\t\tsa[n-1-hc2[s[sl[i]]]]=sl[i];\n\t\t}\n\t\tfor(int i = n-1;i>=0;i--) {\n\t\t\tif(sa[i]>0&&h[sa[i]-1]==1){\n\t\t\t\tsa[n-1-hc1[s[sa[i]-1]]]=sa[i]-1;\n\t\t\t\thc1[s[sa[i]-1]]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i<n;i++) {\n\t\t\tif(sa[i]>0&&h[sa[i]-1]!=1){\n\t\t\t\thc3[s[sa[i]-1]]--;\n\t\t\t\tsa[n-1-hc3[s[sa[i]-1]]]=sa[i]-1;\n\t\t\t}\n\t\t}\n\t\treturn sa;\n\t}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\n\n// arihon p335\n// This solution is O(|T|log^2|T| + Q|P|log|T|) order.\nnamespace ALDS1_14_D\n{\n    class SuffixArray\n    {\n        internal int[] sa, rank, tmp;\n        internal string S;\n        internal int n, k;\n \n        public SuffixArray(string SS)\n        {\n            S = SS;\n            n = S.Length;\n            sa = new int[n + 1];\n            rank = new int[2 * n + 1];\n            for (int i = n + 1; i <= n << 1; i++)\n            {\n                rank[i] = -1;\n            }\n            tmp = new int[n + 1];\n            Construct_SA();\n        }\n \n        public int Compare_SA(int i, int j)\n        {\n            return (rank[i] != rank[j]) ? rank[i] - rank[j] : rank[i + k] - rank[j + k];\n        }\n \n        public void Construct_SA()\n        {\n            for (int i = 0; i < n; i++)\n            {\n                sa[i] = i;\n                rank[i] = S[i];\n            }\n            sa[n] = n; rank[n] = -1;\n \n            for (k = 1; k <= n; k <<= 1)\n            {\n                Array.Sort(sa, Compare_SA);\n \n                int d;\n                d = tmp[sa[0]] = 0;\n \n                for (int i = 1; i <= n; i++)\n                {\n                    d = tmp[sa[i]] = d + ((Compare_SA(sa[i - 1], sa[i]) < 0) ? 1 : 0);\n                }\n \n                for (int i = 0; i <= n; i++)\n                {\n                    rank[i] = tmp[i];\n                }\n \n            }\n        }\n \n        public string Contains(string pattern)\n        {\n            int l = 1, r = n + 1;\n            int pl = pattern.Length;\n \n            while (l < r)\n            {\n                int m = (l + r) >> 1;\n \n                string subStr = (sa[m] + pl > n) ? S.Substring(sa[m]) : S.Substring(sa[m], pl);\n \n                int comp = subStr.CompareTo(pattern);\n                if (comp == 0) return \"1\";\n \n                if (comp < 0) l = m + 1;\n                else r = m;\n            }\n            return \"0\";\n        }\n    }\n \n \n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            Console.SetOut(sw);\n            var T = Console.ReadLine();\n            var SA = new SuffixArray(T);\n            var Q = int.Parse(Console.ReadLine());\n            for (int i = 0; i < Q; i++)\n            {\n                var P = Console.ReadLine();\n                Console.WriteLine(SA.Contains(P));\n            }\n            Console.Out.Flush();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\nnamespace ALDS1_14D_1{\n    public class Program{\n        public static void Main(string[] args){\n            var str = Console.ReadLine();\n            var n = int.Parse(Console.ReadLine());\n\n            for(var i = 0; i < n; i++){\n                Console.WriteLine(str.IndexOf(Console.ReadLine(), StringComparison.Ordinal) != -1 ? 1 : 0);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\n \nnamespace ALDS1_14_D\n{\n    class SuffixArray\n    {\n        internal int[] sa, rank, tmp;\n        internal string S;\n        internal int n, k;\n         \n        public SuffixArray(string SS)\n        {\n            S = SS;\n            n = S.Length;\n            sa = new int[n + 1];\n            rank = new int[n + 1];\n            tmp = new int[n + 1];\n            Construct_SA();\n        }\n         \n        public int Compare_SA(int i, int j)\n        {\n            if(rank[i] != rank[j]) return rank[i] - rank[j];\n             \n            int ri = i + k  <= n ? rank[i + k] : -1;\n            int rj = j + k <= n ? rank[j + k] : -1;\n \n            return  ri - rj; \n        }\n         \n        public void Construct_SA()\n        {\n            for(int i = 0; i < n; i++)\n            {\n                sa[i] = i;\n                rank[i] = S[i];\n            }\n            sa[n] = n; rank[n] = -1;\n             \n            for(k = 1; k <= n; k???<<= 1)\n            {\n                Array.Sort(sa, Compare_SA);\n                 \n                int d;\n                d = tmp[sa[0]] = 0;\n                \n                for (int i = 1; i <= n; i++)\n                {\n                    d = tmp[sa[i]] = d + ((Compare_SA(sa[i - 1], sa[i]) < 0) ? 1 : 0);\n                }\n                \n                for (int i = 0; i <= n; i++)\n                {\n                    rank[i] = tmp[i];\n                }\n  \n            }\n        }\n         \n        public string Contains(string pattern)\n        {\n            int l = 1, r = n + 1;\n            int pl = pattern.Length;\n             \n            while(l < r)\n            {\n                int m = (l + r) >> 1;\n                 \n                string subStr = (sa[m] + pl > n) ? S.Substring(sa[m]) : S.Substring(sa[m], pl);\n                     \n                int comp = subStr.CompareTo(pattern);\n                if (comp == 0) return \"1\";\n                 \n                if (comp < 0) l = m + 1;\n                else r = m;\n            }\n            return \"0\";\n        }\n    }\n     \n     \n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            Console.SetOut(sw);\n          \n            var T = Console.ReadLine();\n            var SA = new SuffixArray(T);\n            var Q = int.Parse(Console.ReadLine());\n  \n            for (int i = 0; i < Q; i++)\n            {\n                var P = Console.ReadLine();\n  \n                Console.WriteLine(SA.Contains(P));\n            }\n            Console.Out.Flush();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\n \nnamespace ALDS1_14_D\n{\n    class SuffixArray\n    {\n        internal int[] sa, rank, tmp;\n        internal string S;\n        internal int n, k;\n         \n        public SuffixArray(string SS)\n        {\n            S = SS;\n            n = S.Length;\n            sa = new int[n + 1];\n            rank = new int[n + 1];\n            tmp = new int[n + 1];\n            Construct_SA();\n        }\n         \n        public int Compare_SA(int i, int j)\n        {\n            if(rank[i] != rank[j]) return rank[i] - rank[j];\n             \n            int ri = i + k  <= n ? rank[i + k] : -1;\n            int rj = j + k <= n ? rank[j + k] : -1;\n \n            return  ri - rj; \n        }\n         \n        public void Construct_SA()\n        {\n            for(int i = 0; i < n; i++)\n            {\n                sa[i] = i;\n                rank[i] = S[i];\n            }\n            sa[n] = n; rank[n] = -1;\n             \n            for(k = 1; k <= n; k <<= 1)\n            {\n                Array.Sort(sa, Compare_SA);\n                 \n                int d;\n                d = tmp[sa[0]] = 0;\n                \n                for (int i = 1; i <= n; i++)\n                {\n                    d = tmp[sa[i]] = d + ((Compare_SA(sa[i - 1], sa[i]) < 0) ? 1 : 0);\n                }\n                \n                for (int i = 0; i <= n; i++)\n                {\n                    rank[i] = tmp[i];\n                }\n  \n            }\n        }\n         \n        public string Contains(string pattern)\n        {\n            int l = 1, r = n + 1;\n            int pl = pattern.Length;\n             \n            while(l < r)\n            {\n                int m = (l + r) >> 1;\n                 \n                string subStr = (sa[m] + pl > n) ? S.Substring(sa[m]) : S.Substring(sa[m], pl);\n                     \n                int comp = subStr.CompareTo(pattern);\n                if (comp == 0) return \"1\";\n                 \n                if (comp < 0) l = m + 1;\n                else r = m;\n            }\n            return \"0\";\n        }\n    }\n     \n     \n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            Console.SetOut(sw);\n          \n            var T = Console.ReadLine();\n            var SA = new SuffixArray(T);\n            var Q = int.Parse(Console.ReadLine());\n  \n            for (int i = 0; i < Q; i++)\n            {\n                var P = Console.ReadLine();\n  \n                Console.WriteLine(SA.Contains(P));\n            }\n            Console.Out.Flush();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Pattern\n    {\n        internal string str;\n        internal int id;\n        internal bool find;\n    }\n\n    class SearchString\n    {\n        readonly int MOD = 1000000007;\n        readonly int C = 407;\n\n        public void SearchStrings(string text, Pattern[] patterns)\n        {\n            Array.Sort(patterns, (a, b) => a.str.Length - b.str.Length);\n\n            int curLen = 0;\n            long[] txtTable = new long[text.Length];\n            long[] patTable;\n\n            for (int i = 0; i < patterns.Length; i++)\n            {\n                string pat = patterns[i].str;\n\n                if (pat.Length > text.Length) continue;\n\n                if (curLen != pat.Length)\n                {\n                    txtTable = GenHash(text, text.Length, pat.Length);\n                    curLen = pat.Length;\n                }\n\n                patTable = GenHash(pat, pat.Length, pat.Length);\n\n                for (int j = 0; j <= text.Length - pat.Length; j++)\n                {\n                    if (txtTable[j] == patTable[0])\n                    {\n                        patterns[i].find = true;\n                        break;\n                    }\n                }\n            }\n\n            Array.Sort(patterns, (a, b) => a.id - b.id);\n\n            StringBuilder sb = new StringBuilder();\n\n            foreach (var p in patterns)\n            {\n                sb.AppendLine(p.find ? \"1\" : \"0\");\n            }\n            Console.Write(sb);\n        }\n\n        private long[] GenHash(string v, int n, int m)\n        {\n            long[] ret = new long[n];\n\n            long cn = 1;\n\n            for (int i = 0; i < m; i++) cn = (cn * C) % MOD;\n\n            long hs = 0;\n\n            for (int i = 0; i < m; i++) hs = (hs * C + v[i]) % MOD;\n\n            for (int i = 0; i <= n - m; i++)\n            {\n                ret[i] = hs;\n\n                if (i + m < n) hs = (hs * C - v[i] * cn + v[i + m]) % MOD;\n\n                hs = (hs < 0) ? hs + MOD : hs;\n            }\n            return ret;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string text = Console.ReadLine();\n\n            int Q = int.Parse(Console.ReadLine());\n\n            Pattern[] patterns = new Pattern[Q];\n            Pattern temp;\n\n            for (int i = 0; i < Q; i++)\n            {\n                temp.str = Console.ReadLine();\n                temp.id = i;\n                temp.find = false;\n\n                patterns[i] = temp;\n            }\n\n            SearchString SS = new SearchString();\n            SS.SearchStrings(text, patterns);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\n \n// arihon p335\n// This solution is O(|T|log^2|T| + Q|P|log|T|) order.\nnamespace ALDS1_14_D\n{\n    class SuffixArray\n    {\n        internal int[] sa, rank, tmp;\n        internal string S;\n        internal int n, k;\n  \n        public SuffixArray(string SS)\n        {\n            S = SS;\n            n = S.Length;\n            sa = new int[n + 1];\n            rank = new int[(n << 1) + 1];\n            tmp = new int[n + 1];\n            Construct_SA();\n        }\n  \n        public int Compare_SA(int i, int j)\n        {\n            return (rank[i] != rank[j]) ? rank[i] - rank[j] : rank[i + k] - rank[j + k];\n        }\n  \n        public void Construct_SA()\n        {\n            for (int i = 0; i < n; i++)\n            {\n                sa[i] = i;\n                rank[i] = S[i];\n            }\n            sa[n] = n;\n  \n            for (k = 1; k <= n; k <<= 1)\n            {\n                Array.Sort(sa, Compare_SA);\n  \n                int d;\n                d = tmp[sa[0]] = 1;\n  \n                for (int i = 1; i <= n; i++)\n                {\n                    d = tmp[sa[i]] = d + ((Compare_SA(sa[i - 1], sa[i]) < 0) ? 1 : 0);\n                }\n  \n                for (int i = 0; i <= n; i++)\n                {\n                    rank[i] = tmp[i];\n                }\n            }\n        }\n  \n        public string Contains(string pattern)\n        {\n            int l = 0, r = n;\n            int pl = pattern.Length;\n  \n            while (l < r)\n            {\n                int m = (l + r) >> 1;\n  \n                string subStr = (sa[m] + pl > n) ? S.Substring(sa[m]) : S.Substring(sa[m], pl);\n  \n                int comp = subStr.CompareTo(pattern);\n                if (comp == 0) return \"1\";\n  \n                if (comp < 0) l = m + 1;\n                else r = m;\n            }\n            return \"0\";\n        }\n    }\n  \n  \n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            Console.SetOut(sw);\n            var T = Console.ReadLine();\n            var SA = new SuffixArray(T);\n            var Q = int.Parse(Console.ReadLine());\n            for (int i = 0; i < Q; i++)\n            {\n                var P = Console.ReadLine();\n                Console.WriteLine(SA.Contains(P));\n            }\n            Console.Out.Flush();\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Text;\n\nnamespace ALDS1_14_D\n{\n    class Program\n    {\n        static StringBuilder sb = new StringBuilder();\n        static string S, T;\n        static int[] sa;\n        static int n, k;\n        static int[] rank, tmp;\n        static int Q;\n\n        static void Main(string[] args)\n        {\n            S = Console.ReadLine();\n            n = S.Length;\n            sa = new int[n + 1];\n            rank = new int[n + 1];\n            tmp = new int[n + 1];\n            construct_sa();\n\n       \n            Q = int.Parse(Console.ReadLine());\n            for (int i = 0; i < Q; i++)\n            {\n                T = Console.ReadLine();\n                sb.AppendLine(contain() ? \"1\" : \"0\");\n            }\n            Console.Write(sb);\n        }\n\n        static bool contain()\n        {\n            int a = 0, b = S.Length + 1;\n            string d = \"\";\n            while (a != b)\n            {              \n                int c = (a + b) / 2;\n\n                //S???sa[c]???????????????|T|????????¨T?????????\n                d = \"\";\n                for (int i = 0; i < T.Length; i++)\n                {\n                    if (sa[c] + i >= S.Length) break;\n                    d += S[sa[c] + i];\n                }\n                \n                int dc = d.CompareTo(T);\n                \n                if (dc == 0) return true;\n\n                if (dc < 0) a = c + 1;\n                else b = c; \n            }\n            return false;\n\n        }\n\n        //(rank[i], rank[i + k])??¨(rank[j], rank[j + k])?????????\n        static bool compare_sa(int i, int j)\n        {\n            if (rank[i] != rank[j]) return rank[i] < rank[j];\n            int ri = i + k <= n ? rank[i + k] : -1;\n            int rj = j + k <= n ? rank[j + k] : -1;\n            return ri < rj;\n        }\n        \n        //?????????S?????\\?°??????????????§????\n        static void construct_sa()\n        {\n            //?????????1???????????????????????????????????????????????°??????\n            for (int i = 0; i <= n; i++)\n            {\n                sa[i] = i;\n                rank[i] = i < n ? S[i] : -1;\n            }\n\n\n            //k????????????????????????????????????????????¨???????????????2k????????§???????????????\n            for (k = 1; k <= n; k *= 2)\n            {\n                sa = sa.OrderBy(s => rank[s]).ToArray();\n\n                //?????£??????tmp????¬?????????????????¨??????????????????????rank????§????\n                tmp[sa[0]] = 0;\n                for (int i = 1; i <= n; i++)\n                {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + (compare_sa(sa[i - 1], sa[i]) ? 1 : 0);\n                }\n                for (int i = 0; i <= n; i++)\n                {\n                    rank[i] = tmp[i];\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class SuffixArray\n    {\n        readonly int SIZE = byte.MaxValue * byte.MaxValue;\n        readonly int LIMIT = 16;\n        readonly string Text;\n\n        byte[] Data;\n        int[] index, rank;\n        int size;\n\n        public SuffixArray(string text)\n        {\n            Text = text;\n\n            MakeSuffixArray(text);\n        }\n\n        private int[] MakeSuffixArray(byte[] data)\n        {\n            size = data.Length;\n            Data = new byte[size + 1];\n            Array.Copy(data, Data, size);\n\n            index = new int[size];\n            rank = new int[size];\n\n            SuffixSort();\n\n            return index;\n        }\n\n        private int[] MakeSuffixArray(string source)\n        {\n            byte[] ret = new byte[source.Length];\n\n            for (int i = 0; i < source.Length; i++)\n            {\n                ret[i] = (byte)source[i];\n            }\n            return MakeSuffixArray(ret);\n        }\n\n        private int GetRank(int i) { return i < size ? rank[i] : -1; }\n\n        private void SuffixSort()\n        {\n            int[] count = new int[SIZE];\n            int[] sum = new int[SIZE + 1];\n\n            for (int i = 0; i < size; i++)\n            {\n                count[(Data[i] << 8) + Data[i + 1]]++;\n            }\n\n            for (int i = 1; i < SIZE + 1; i++)\n            {\n                sum[i] = count[i - 1] + sum[i - 1];\n            }\n\n            for (int i = 1; i < SIZE; i++)\n            {\n                count[i] += count[i - 1];\n            }\n\n            int c;\n\n            for (int i = size - 1; i > -1; i--)\n            {\n                c = (Data[i] << 8) + Data[i + 1];\n                count[c]--;\n                index[count[c]] = i;\n                rank[i] = sum[c + 1] - 1;\n            }\n\n            for (int n = 2; n < size; n <<= 1)\n            {\n                int low = 0;\n                bool flag = true;\n\n                while (low < size)\n                {\n                    int temp = low;\n\n                    while (temp < size && index[temp] < 0) temp -= index[temp];\n\n                    if (low < temp)\n                    {\n                        index[low] = -(temp - low);\n                        low = temp;\n                    }\n\n                    if (low < size)\n                    {\n                        int high = rank[index[low]];\n                        MqSort(low, high, n);\n                        low = high + 1;\n                        flag = false;\n                    }\n                }\n\n                if (flag) break;\n            }\n\n            for (int i = 0; i < size; i++) index[rank[i]] = i;\n        }\n\n        private void MqSort(int low, int high, int n)\n        {\n            if (high - low <= LIMIT)\n            {\n                InsertSort(low, high, n);\n                return;\n            }\n\n            int p = SelectPivot(low, high, n);\n\n            int i, j, m1, m2;\n            i = m1 = low;\n            j = m2 = high;\n\n            while (true)\n            {\n                int k = 0;\n\n                while (i <= j)\n                {\n                    k = GetRank(index[i] + n) - p;\n\n                    if (k > 0) break;\n\n                    if (k == 0)\n                    {\n                        Swap(i, m1);\n                        m1++;\n                    }\n                    i++;\n                }\n\n                while (i <= j)\n                {\n                    k = GetRank(index[j] + n) - p;\n\n                    if (k < 0) break;\n\n                    if (k == 0)\n                    {\n                        Swap(j, m2);\n                        m2--;\n                    }\n                    j--;\n                }\n\n                if (i > j) break;\n\n                Swap(i, j);\n                i++; j--;\n            }\n\n            int min = Math.Min(m1 - low, i - m1);\n            for (int k = 0; k < min; k++) Swap(low + k, j - k);\n            m1 = low + (i - m1);\n\n            min = Math.Min(high - m2, m2 - j);\n            for (int k = 0; k < min; k++) Swap(high - k, i + k);\n            m2 = high - (m2 - j) + 1;\n\n            if (low <= m1 - 1) MqSort(low, m1 - 1, n);\n\n            if (m2 > m1)\n            {\n                if (m2 - m1 == 1)\n                {\n                    rank[index[m1]] = m1;\n                    index[m1] = -1;\n                }\n                else\n                {\n                    int r = m2 - 1;\n                    for (int l = m1; l < m2; l++) rank[index[l]] = r;\n                }\n            }\n\n            if (m2 <= high) MqSort(m2, high, n);\n        }\n\n        int SelectPivot(int low, int high, int n)\n        {\n            int m = (high - low) / 4;\n            int a = GetRank(index[low + m] + n),\n                b = GetRank(index[low + m * 2] + n),\n                c = GetRank(index[low + m * 3] + n);\n            if (a > b)\n            {\n                a ^= b;\n                b ^= a;\n                a ^= b;\n            }\n            if (b > c)\n            {\n                b = c;\n                if (a > b) b = a;\n            }\n            return b;\n        }\n\n        private void Swap(int i, int j)\n        {\n            int t = index[i];\n            index[i] = index[j];\n            index[j] = t;\n        }\n\n        int Compare(int x, int y, int n)\n        {\n            int m = size - Math.Max(x, y);\n            int r;\n\n            for (int i = n; i < m; i += n)\n            {\n                r = rank[x + i] - rank[y + i];\n                if (r != 0) return r;\n            }\n            return y - x;\n        }\n\n        private void InsertSort(int low, int high, int n)\n        {\n            high++;\n\n            for (int i = low + 1; i < high; i++)\n            {\n                int t = index[i];\n                int j = i - 1;\n\n                while (j >= low && Compare(t, index[j], n) < 0)\n                {\n                    index[j + 1] = index[j];\n                    j--;\n                }\n                index[j + 1] = t;\n            }\n\n            for (int i = low; i < high; i++)\n            {\n                rank[index[i]] = i;\n                index[i] = -1;\n            }\n        }\n\n        public void PrintSuffixArray()\n        {\n            for (int i = 0; i < index.Length; i++)\n            {\n                string g = GetString(i, size);\n                Console.WriteLine(g);\n            }\n        }\n\n        string GetString(int idx, int n)\n        {\n            int s = index[idx];\n            int e = Math.Min(Data.Length, s + n);\n\n            StringBuilder sb = new StringBuilder();\n\n            if (s == 0)\n            {\n                for (int i = s; i < e; i++) sb.Append((char)Data[i]);\n            }\n            else\n            {\n                for (int i = s; i < e - 1; i++) sb.Append((char)Data[i]);\n            }\n\n            return sb.ToString();\n        }\n\n        public bool Contains(string pattern)\n        {\n            int l = 0, r = size;\n\n            while (l < r)\n            {\n                int m = (l + r) / 2;\n\n                string subStr = (index[m] + pattern.Length > size) ?\n                    Text.Substring(index[m]) :\n                    Text.Substring(index[m], pattern.Length);\n\n                int comp = subStr.CompareTo(pattern);\n                if (comp == 0) return true;\n\n                if (comp < 0) l = m + 1;\n                else r = m;\n            }\n            return false;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string T = Console.ReadLine();\n\n            SuffixArray SA = new SuffixArray(T);\n            StringBuilder sb = new StringBuilder();\n\n            int Q = int.Parse(Console.ReadLine());\n\n            for (int i = 0; i < Q; i++)\n            {\n                string P = Console.ReadLine();\n\n                sb.AppendLine(SA.Contains(P) ? \"1\" : \"0\");\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing static System.Console;\nusing System.Text;\nusing System.IO;\nusing static System.Math;\nnamespace AOJ\n{\n    class Program\n    {\n        static public long[] Sarray() { return ReadLine().Split().Select(long.Parse).ToArray(); }\n        static public List<long> Slist() { return ReadLine().Split().Select(long.Parse).ToList(); }\n        static long Mod = (long)998244353;\n        static void Main(string[] args)\n        {\n            //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n            Solve();\n            //Out.Flush();\n        }\n        static void Solve()\n        {\n            var T = ReadLine();\n            var SA = new SuffixArray(T);\n            var Q = Sarray()[0];\n            for (var i = 0; i < Q; ++i)\n            {\n                var Pi = ReadLine();\n                WriteLine(SA.Contain(Pi) ? 1 : 0);\n            }\n        }\n        class SuffixArray\n        {\n            int _n, _k;\n            int[] _rank;\n            int[] _sa;\n            int[] _lcp;\n            string _S;\n            public SuffixArray(string s)\n            {\n                _n = s.Length;\n                _sa = new int[_n + 1];\n                _rank = new int[_n + 1];\n                _lcp = new int[_n + 1];\n                _S = s;\n                construct_sa();\n                construct_lcp();\n            }\n            int compare(int i, int j)\n            {\n                if (_rank[i] != _rank[j]) return _rank[i] - _rank[j];\n                var ri = (i + _k <= _n) ? _rank[i + _k] : -1;\n                var rj = (j + _k <= _n) ? _rank[j + _k] : -1;\n                return ri - rj;\n            }\n\n            void construct_sa()\n            {\n                for (var i = 0; i <= _n; ++i)\n                {\n                    _sa[i] = i;\n                    _rank[i] = (i < _n) ? _S[i] : -1;\n                }\n                var tmp = new int[_n + 1];\n                for (_k = 1; _k <= _n; _k *= 2)\n                {\n                    Array.Sort(_sa, compare);\n                    tmp[_sa[0]] = 0;\n                    for (var i = 1; i <= _n; ++i)\n                        tmp[_sa[i]] = tmp[_sa[i - 1]] + ((compare(_sa[i - 1], _sa[i]) < 0) ? 1 : 0);\n                    for (var i = 0; i <= _n; ++i)\n                        _rank[i] = tmp[i];\n                }\n            }\n            int[][] _sparse;\n            int[] _height;\n            void construct_lcp()\n            {\n                for (var i = 0; i <= _n; ++i) _rank[_sa[i]] = i;\n                var cur = 0;\n                _lcp[0] = 0;\n                for (var i = 0; i < _n; ++i)\n                {\n                    var j = _sa[_rank[i] - 1];\n                    if (0 < cur) --cur;\n                    for (; j + cur < _n && i + cur < _n; ++cur)\n                        if (_S[j + cur] != _S[i + cur]) break;\n                    _lcp[_rank[i] - 1] = cur;\n                }\n                var n = _lcp.Length;\n                var h = 0;\n                while ((1 << h) < n) ++h;\n                _sparse = Enumerable.Range(0, h).Select(_ => Enumerable.Range(0, 1 << h).ToArray()).ToArray();\n                _height = new int[n + 1];\n                for (var i = 2; i <= n; ++i) _height[i] = _height[i >> 1] + 1;\n                for (var i = 0; i < n; ++i) _sparse[0][i] = _lcp[i];\n                for (var i = 1; i < h; ++i)\n                    for (var j = 0; j < n; ++j)\n                        _sparse[i][j] = Min(_sparse[i - 1][j], _sparse[i - 1][Min(j + (1 << (i - 1)), n - 1)]);\n            }\n            public bool Contain(string T)\n            {\n                var a = 0;\n                var b = _n;\n                while (b - a > 1)\n                {\n                    var c = (a + b) / 2;\n                    if (string.CompareOrdinal(_S, _sa[c], T, 0, T.Length) < 0) a = c;\n                    else b = c;\n                }\n                return string.CompareOrdinal(_S, _sa[b], T, 0, T.Length) == 0;\n            }\n            public int GetLCP(int a, int b) => get(Min(_rank[a], _rank[b]), Max(_rank[a], _rank[b]));\n            int get(int a, int b) => Min(_sparse[_height[b - a]][a], _sparse[_height[b - a]][b - (1 << _height[b - a])]);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Text;\n\nnamespace ALDS1_14_D\n{\n    class Program\n    {\n        static StringBuilder sb = new StringBuilder();\n        static string S, T;\n        static int[] sa;\n        static int n, k;\n        static int[] rank, tmp;\n        static int Q;\n\n        static void Main(string[] args)\n        {\n            S = Console.ReadLine();\n            n = S.Length;\n            sa = new int[n + 1];\n            rank = new int[n + 1];\n            tmp = new int[n + 1];\n            construct_sa();\n\n\n\n            Q = int.Parse(Console.ReadLine());\n            for (int i = 0; i < Q; i++)\n            {\n                T = Console.ReadLine();\n                sb.AppendLine(contain() ? \"1\" : \"0\");\n            }\n            Console.Write(sb);\n        }\n\n        static bool contain()\n        {\n            int a = 0, b = S.Length + 1;\n            string d = \"\";\n            while (a != b)\n            {              \n                int c = (a + b) / 2;\n                //S???sa[c]???????????????|T|????????¨T?????????\n\n\n                d = \"\";\n                for (int i = 0; i < T.Length; i++)\n                {\n                    if (sa[c] + i >= b - 1) break;\n                    d += S[sa[c] + i];\n                }\n                \n                int dc = d.CompareTo(T);\n                //Console.WriteLine(a + \" \" + b + \" \" + c + \" \" + d +\" \"+ dc);\n                if (dc == 0) return true;\n                if (dc < 0) a = c + 1;\n                else b = c; \n            }\n            return false;\n\n        }\n\n        //(rank[i], rank[i + k])??¨(rank[j], rank[j + k])?????????\n        static bool compare_sa(int i, int j)\n        {\n            if (rank[i] != rank[j]) return rank[i] < rank[j];\n            int ri = i + k <= n ? rank[i + k] : -1;\n            int rj = j + k <= n ? rank[j + k] : -1;\n            return ri < rj;\n        }\n        \n        //?????????S?????\\?°??????????????§????\n        static void construct_sa()\n        {\n            //?????????1???????????????????????????????????????????????°??????\n            for (int i = 0; i <= n; i++)\n            {\n                sa[i] = i;\n                rank[i] = i < n ? S[i] : -1;\n            }\n\n            //k????????????????????????????????????????????¨???????????????2k????????§???????????????\n            for (k = 1; k <= n; k *= 2)\n            {\n                //Array.Sort(rank, sa);\n                sa = sa.OrderBy(s => rank[s]).ToArray();\n\n\n                //Console.WriteLine(0 +\" \" + sa[0]+ \"   \"+rank[0]);\n                /*\n                for (int i = 1; i <= n; i++)\n                {\n                    Console.WriteLine(i  + \" \" + sa[i] + \" \" + S[sa[i]] + \" \" + rank[sa[i]]);\n                }*/\n\n\n\n                //?????£??????tmp????¬?????????????????¨??????????????????????rank????§????\n                tmp[sa[0]] = 0;\n                for (int i = 1; i <= n; i++)\n                {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + (compare_sa(sa[i - 1], sa[i]) ? 1 : 0);\n                }\n                for (int i = 0; i <= n; i++)\n                {\n                    rank[i] = tmp[i];\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\n \nnamespace ALDS1_14_D\n{\n\tclass SuffixArray\n\t{\n\t\tinternal int[] sa, rank, tmp;\n\t\tinternal string S;\n\t\tinternal int n, k;\n\t\t\n\t\tpublic SuffixArray(string SS)\n\t\t{\n\t\t\tS = SS;\n\t\t\tn = S.Length;\n\t\t\tsa = new int[n + 1];\n\t\t\trank = new int[n + 1];\n\t\t\ttmp = new int[n + 1];\n\t\t\tConstruct_SA();\n\t\t}\n\t\t\n\t\tpublic int Compare_SA(int i, int j)\n\t\t{\n\t\t\tif(rank[i] != rank[j]) return rank[i] - rank[j];\n\t\t\t\n\t\t\tint ri = i + k  <= n ? rank[i + k] : -1;\n\t\t\tint rj = j + k <= n ? rank[j + k] : -1;\n\n\t\t\treturn  ri - rj; \n\t\t}\n\t\t\n\t\tpublic void Construct_SA()\n\t\t{\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tsa[i] = i;\n\t\t\t\trank[i] = S[i];\n\t\t\t}\n\t\t\tsa[n] = n; rank[n] = -1;\n\t\t\t\n\t\t\tfor(k = 1; k <= n; k*= 2)\n\t\t\t{\n\t\t\t\tArray.Sort(sa, Compare_SA);\n                \n                int d;\n                d = tmp[sa[0]] = 0;\n                for (int i = 1; i <= n; i++)\n                {\n                    d = tmp[sa[i]] = d + ((Compare_SA(sa[i - 1], sa[i]) < 0) ? 1 : 0);\n                }\n                for (int i = 0; i <= n; i++)\n                {\n                    rank[i] = tmp[i];\n                }\n \n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic string Contains(string pattern)\n\t\t{\n\t\t\tint l = 1, r = n + 1;\n\t\t\tint pl = pattern.Length;\n\t\t\t\n\t\t\twhile(l < r)\n\t\t\t{\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\t\n\t\t\t\tstring subStr = (sa[m] + pl > n) ? S.Substring(sa[m]) : S.Substring(sa[m], pl);\n                    \n                int comp = subStr.CompareTo(pattern);\n                if (comp == 0) return \"1\";\n                \n                if (comp < 0) l = m + 1;\n                else r = m;\n\t\t\t}\n\t\t\treturn \"0\";\n\t\t}\n\t}\n\t\n\t\n    class Program\n    {\n        static void Main(string[] args)\n        {\n        \tvar T = Console.ReadLine();\n        \t\n            SuffixArray SA = new SuffixArray(T);\n            StringBuilder sb = new StringBuilder();\n \n            var Q = int.Parse(Console.ReadLine());\n \n            for (int i = 0; i < Q; i++)\n            {\n                var P = Console.ReadLine();\n \n                sb.AppendLine(SA.Contains(P));\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ALDS1_14_D\n{\n    class Program\n    {\n        static StringBuilder sb = new StringBuilder();\n        static string S, T;\n        static int[] sa;\n        static int n, k;\n        static int[] rank, tmp;\n        static int Q;\n\n        static void Main(string[] args)\n        {\n            S = Console.ReadLine();\n            n = S.Length;\n            sa = new int[n + 1];\n            rank = new int[n + 1];\n            tmp = new int[n + 1];\n            construct_sa();\n\n\n\n            Q = int.Parse(Console.ReadLine());\n            for (int i = 0; i < Q; i++)\n            {\n                T = Console.ReadLine();\n                sb.AppendLine(contain() ? \"1\" : \"0\");\n            }\n            Console.Write(sb);\n        }\n\n        static bool contain()\n        {\n            int a = 0, b = S.Length + 1;\n            string d = \"\";\n            while (a != b)\n            {              \n                int c = (a + b) / 2;\n                //S???sa[c]???????????????|T|????????¨T?????????\n\n\n                d = \"\";\n                for (int i = 0; i < T.Length; i++)\n                {\n                    if (sa[c] + i >= b - 1) break;\n                    d += S[sa[c] + i];\n                }\n                \n                int dc = d.CompareTo(T);\n                //Console.WriteLine(a + \" \" + b + \" \" + c + \" \" + d +\" \"+ dc);\n                if (dc == 0) return true;\n                if (dc < 0) a = c + 1;\n                else b = c; \n            }\n            return false;\n\n        }\n\n        //(rank[i], rank[i + k])??¨(rank[j], rank[j + k])?????????\n        static bool compare_sa(int i, int j)\n        {\n            if (rank[i] != rank[j]) return rank[i] < rank[j];\n            int ri = i + k <= n ? rank[i + k] : -1;\n            int rj = j + k <= n ? rank[j + k] : -1;\n            return ri < rj;\n        }\n        \n        //?????????S?????\\?°??????????????§????\n        static void construct_sa()\n        {\n            //?????????1???????????????????????????????????????????????°??????\n            for (int i = 0; i <= n; i++)\n            {\n                sa[i] = i;\n                rank[i] = i < n ? S[i] : -1;\n            }\n\n            //k????????????????????????????????????????????¨???????????????2k????????§???????????????\n            for (k = 1; k <= n; k *= 2)\n            {\n                //Array.Sort(rank, sa);\n                sa = sa.OrderBy(s => rank[s]).ToArray();\n\n\n                //Console.WriteLine(0 +\" \" + sa[0]+ \"   \"+rank[0]);\n                /*\n                for (int i = 1; i <= n; i++)\n                {\n                    Console.WriteLine(i  + \" \" + sa[i] + \" \" + S[sa[i]] + \" \" + rank[sa[i]]);\n                }*/\n\n\n\n                //?????£??????tmp????¬?????????????????¨??????????????????????rank????§????\n                tmp[sa[0]] = 0;\n                for (int i = 1; i <= n; i++)\n                {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + (compare_sa(sa[i - 1], sa[i]) ? 1 : 0);\n                }\n                for (int i = 0; i <= n; i++)\n                {\n                    rank[i] = tmp[i];\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\n\nnamespace ALDS1_14_D\n{\n\tclass SuffixArray\n\t{\n\t\tinternal int[] sa, rank, tmp;\n\t\tinternal string S;\n\t\tinternal int n, k;\n\t\t\n\t\tpublic SuffixArray(string SS)\n\t\t{\n\t\t\tS = SS;\n\t\t\tn = S.Length;\n\t\t\tsa = new int[n + 1];\n\t\t\trank = new int[n + 1];\n\t\t\ttmp = new int[n + 1];\n\t\t\tConstruct_SA();\n\t\t}\n\t\t\n\t\tpublic int Compare_SA(int i, int j)\n\t\t{\n\t\t\tif(rank[i] != rank[j]) return rank[i] - rank[j];\n\t\t\t\n\t\t\tint ri = i + k  <= n ? rank[i + k] : -1;\n\t\t\tint rj = j + k <= n ? rank[j + k] : -1;\n\n\t\t\treturn  ri - rj; \n\t\t}\n\t\t\n\t\tpublic void Construct_SA()\n\t\t{\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tsa[i] = i;\n\t\t\t\trank[i] = S[i];\n\t\t\t}\n\t\t\tsa[n] = n; rank[n] = -1;\n\t\t\t\n\t\t\tfor(k = 1; k <= n; k*= 2)\n\t\t\t{\n\t\t\t\tArray.Sort(sa, Compare_SA);\n                \n                int d;\n                d = tmp[sa[0]] = 0;\n                for (int i = 1; i <= n; i++)\n                {\n                    d = tmp[sa[i]] = d + ((Compare_SA(sa[i - 1], sa[i]) < 0) ? 1 : 0);\n                }\n                for (int i = 0; i <= n; i++)\n                {\n                    rank[i] = tmp[i];\n                }\n \n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic string Contains(string pattern)\n\t\t{\n\t\t\tint l = 1, r = n + 1;\n\t\t\tint pl = pattern.Length;\n\t\t\t\n\t\t\twhile(l < r)\n\t\t\t{\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\t\n\t\t\t\tstring subStr = (sa[m] + pl > n) ? S.Substring(sa[m]) : S.Substring(sa[m], pl);\n                    \n                int comp = subStr.CompareTo(pattern);\n                if (comp == 0) return \"1\";\n                \n                if (comp < 0) l = m + 1;\n                else r = m;\n\t\t\t}\n\t\t\treturn \"0\";\n\t\t}\n\t}\n\t\n\t\n    class Program\n    {\n    \t\n        static void Main(string[] args)\n        {\n        \tvar sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    \t \tConsole.SetOut(sw);\n    \t \n        \tvar T = Console.ReadLine();\n        \t\n            var SA = new SuffixArray(T);\n\n \n            var Q = int.Parse(Console.ReadLine());\n \n            for (int i = 0; i < Q; i++)\n            {\n                var P = Console.ReadLine();\n \n                Console.WriteLine(SA.Contains(P));\n            }\n            Console.Out.Flush();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Text;\n\nnamespace ALDS1_14_D\n{\n    class SuffixArray\n    {\n        internal int[] sa, rank, tmp;\n        internal string S;\n        internal int n, k;\n\n        public SuffixArray(string SS)\n        {\n            S = SS;\n            n = S.Length;\n            sa = new int[n + 1];\n            rank = new int[n + 1];\n            tmp = new int[n + 1];\n            Construct_SA();\n        }\n\n        public int Compare_SA(int i, int j)\n        {\n            if (rank[i] > rank[j]) return 1;\n            if (rank[i] < rank[j]) return -1;\n\n            int ri = i + k <= n ? rank[i + k] : -1;\n            int rj = j + k <= n ? rank[j + k] : -1;\n            if (ri > rj) return 1;\n            if (ri < rj) return -1;\n            return 0;\n        }\n\n        public void Construct_SA()\n        {\n            for (int i = 0; i <= n; i++)\n            {\n                sa[i] = i;\n                rank[i] = i < n ? S[i] : -1;\n            }\n\n            for (k = 1; k <= n; k *= 2)\n            {\n                Array.Sort(sa, Compare_SA);\n\n                /*Console.WriteLine();\n                Console.WriteLine(0 + \" \" + sa[0] + \"   \" + rank[sa[0]]);\n                for (int i = 1; i <= n; i++)\n                {\n                    Console.WriteLine(i + \" \" + sa[i] + \" \" + S[sa[i]] + \" \" + rank[sa[i]]);\n                }*/\n\n\n                tmp[sa[0]] = 0;\n                for (int i = 1; i <= n; i++)\n                {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + ((Compare_SA(sa[i - 1], sa[i]) < 0) ? 1 : 0);\n                }\n                for (int i = 0; i <= n; i++)\n                {\n                    rank[i] = tmp[i];\n                }\n\n            }\n        }\n\n        public bool Contains(string pattern)\n        {\n            int l = 1, r = n + 1;\n            int pl = pattern.Length;\n\n            while (l < r)\n            {\n                int m = (l + r) / 2;\n\n                string subStr = (sa[m] + pl > r) ? S.Substring(sa[m]) : S.Substring(sa[m], pl);\n\n\n                int comp = subStr.CompareTo(pattern);\n\n                //Console.WriteLine(l + \" \" + r + \" \" + m + \" \" + subStr + \" \" + comp);\n                if (comp == 0) return true;\n\n                if (comp < 0) l = m + 1;\n                else r = m;\n            }\n            return false;\n        }\n    }\n\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var T = Console.ReadLine();\n\n            SuffixArray SA = new SuffixArray(T);\n            StringBuilder sb = new StringBuilder();\n\n            var Q = int.Parse(Console.ReadLine());\n\n            for (int i = 0; i < Q; i++)\n            {\n                var P = Console.ReadLine();\n\n                sb.AppendLine(SA.Contains(P) ? \"1\" : \"0\");\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\n \nnamespace ALDS1_14_D\n{\n    class SuffixArray\n    {\n        internal int[] sa, rank, tmp;\n        internal string S;\n        internal int n, k;\n         \n        public SuffixArray(string SS)\n        {\n            S = SS;\n            n = S.Length;\n            sa = new int[n + 1];\n            rank = new int[n + 1];\n            tmp = new int[n + 1];\n            Construct_SA();\n        }\n         \n        public int Compare_SA(int i, int j)\n        {\n            if(rank[i] != rank[j]) return rank[i] - rank[j];\n             \n            int ri = i + k  <= n ? rank[i + k] : -1;\n            int rj = j + k <= n ? rank[j + k] : -1;\n \n            return  ri - rj; \n        }\n         \n        public void Construct_SA()\n        {\n            for(int i = 0; i < n; i++)\n            {\n                sa[i] = i;\n                rank[i] = S[i];\n            }\n            sa[n] = n; rank[n] = -1;\n             \n            for(k = 1; k <= n; k*= 2)\n            {\n                Array.Sort(sa, Compare_SA);\n                 \n                int d;\n                d = tmp[sa[0]] = 0;\n                for (int i = 1; i <= n; i++)\n                {\n                    d = tmp[sa[i]] = d + ((Compare_SA(sa[i - 1], sa[i]) < 0) ? 1 : 0);\n                }\n                for (int i = 0; i <= n; i++)\n                {\n                    rank[i] = tmp[i];\n                }\n  \n            }\n        }\n         \n        public string Contains(string pattern)\n        {\n            int l = 1, r = n + 1;\n            int pl = pattern.Length;\n             \n            while(l < r)\n            {\n                int m = (l + r) / 2;\n                 \n                string subStr = (sa[m] + pl > n) ? S.Substring(sa[m]) : S.Substring(sa[m], pl);\n                     \n                int comp = subStr.CompareTo(pattern);\n                if (comp == 0) return \"1\";\n                 \n                if (comp < 0) l = m + 1;\n                else r = m;\n            }\n            return \"0\";\n        }\n    }\n     \n     \n    class Program\n    {\n         \n        static void Main(string[] args)\n        {\n            var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            //Console.SetOut(sw);\n          \n            var T = Console.ReadLine();\n             \n            var SA = new SuffixArray(T);\n \n  \n            var Q = int.Parse(Console.ReadLine());\n  \n            for (int i = 0; i < Q; i++)\n            {\n                var P = Console.ReadLine();\n  \n                Console.WriteLine(SA.Contains(P));\n            }\n            sw.Flush();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\n \nclass Program\n{\n    static void Main()\n    {\n        string original = Console.ReadLine();\n        int n = int.Parse(Console.ReadLine());\n        for (int i = 0; i < n; i++)\n        {\n            Console.WriteLine(Regex.IsMatch(original, Console.ReadLine()) ? 1 : 0);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing CompProgLib;\n\nnamespace ALDS1_14_D\n{\n    public class Program\n\n    {\n        public static void Main(string[] args)\n        {\n            string line = ReadSt();\n            int n = ReadInt();\n            StringSearch.SuffixArray sa = new StringSearch.SuffixArray(line);\n\n            for (int i = 0 ; i < n ; i++)\n            {\n                Console.WriteLine(sa.Contains(ReadSt()) ? 1 : 0);\n            }\n        }\n\n        static string ReadSt() { return Console.ReadLine(); }\n        static int ReadInt() { return int.Parse(Console.ReadLine()); }\n        static long ReadLong() { return long.Parse(Console.ReadLine()); }\n        static double ReadDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] ReadStAr(char sep = ' ') { return Console.ReadLine().Split(sep); }\n        static int[] ReadIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => int.Parse(e)); }\n        static long[] ReadLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => long.Parse(e)); }\n        static double[] ReadDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => double.Parse(e)); }\n\n    }\n\n}\n\nnamespace CompProgLib\n{\n    public class StringSearch\n    {\n        public class SuffixArray\n        {\n            private string s;\n            private int n;\n            private int k;\n            private int[] rank;\n            private int[] sa;\n\n            public SuffixArray(string target)\n            {\n                s = target;\n                n = s.Length;\n                sa = new int[n + 1];\n                rank = new int[n + 1];\n                Constract_sa();\n            }\n\n            private int Compare_sa(int i, int j)\n            {\n                if (rank[i] != rank[j]) return rank[i] - rank[j];\n                else\n                {\n                    int ri = i + k <= n ? rank[i + k] : -1;\n                    int rj = j + k <= n ? rank[j + k] : -1;\n                    return ri - rj;\n                }\n            }\n\n            private void Constract_sa()\n            {\n                for (int i = 0 ; i <= n ; i++)\n                {\n                    sa[i] = i;\n                    rank[i] = (i < n) ? s[i] : -1;\n                }\n\n                int[] tmp = new int[n + 1];\n                for (k = 1 ; k <= n ; k *= 2)\n                {\n                    Array.Sort(sa, Compare_sa);\n\n                    tmp[sa[0]] = 0;\n                    for (int i = 1 ; i <= n ; i++)\n                    {\n                        tmp[sa[i]] = tmp[sa[i - 1]] + (Compare_sa(sa[i - 1], sa[i]) < 0 ? 1 : 0);\n                    }\n                    for (int i = 0 ; i <= n ; i++)\n                    {\n                        rank[i] = tmp[i];\n                    }\n                }\n            }\n\n            public bool Contains(string pattern)\n            {\n                int a = 0, b = n;\n                while (b - a > 1)\n                {\n                    int c = (a + b) / 2;\n                    if (string.Compare(s, sa[c], pattern, 0, pattern.Length) < 0) a = c;\n                    else b = c;\n\n                }\n                return string.Compare(s, sa[b], pattern, 0, pattern.Length) == 0;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\n \nnamespace ALDS1_14_D\n{\n\tclass SuffixArray\n\t{\n\t\tinternal int[] sa, rank, tmp;\n\t\tinternal string S;\n\t\tinternal int n, k;\n\t\t\n\t\tpublic SuffixArray(string SS)\n\t\t{\n\t\t\tS = SS;\n\t\t\tn = S.Length;\n\t\t\tsa = new int[n + 1];\n\t\t\trank = new int[n + 1];\n\t\t\ttmp = new int[n + 1];\n\t\t\tConstruct_SA();\n\t\t}\n\t\t\n\t\tpublic int Compare_SA(int i, int j)\n\t\t{\n\t\t\tif(rank[i] != rank[j]) return rank[i] - rank[j];\n\t\t\t\n\t\t\tint ri = i + k  <= n ? rank[i + k] : -1;\n\t\t\tint rj = j + k <= n ? rank[j + k] : -1;\n\n\t\t\treturn  ri - rj; \n\t\t}\n\t\t\n\t\tpublic void Construct_SA()\n\t\t{\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tsa[i] = i;\n\t\t\t\trank[i] = S[i];\n\t\t\t}\n\t\t\tsa[n] = n; rank[n] = -1;\n\t\t\t\n\t\t\tfor(k = 1; k <= n; k*= 2)\n\t\t\t{\n\t\t\t\tArray.Sort(sa, Compare_SA);\n                \n                tmp[sa[0]] = 0;\n                for (int i = 1; i <= n; i++)\n                {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + ((Compare_SA(sa[i - 1], sa[i]) < 0) ? 1 : 0);\n                }\n                for (int i = 0; i <= n; i++)\n                {\n                    rank[i] = tmp[i];\n                }\n \n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic string Contains(string pattern)\n\t\t{\n\t\t\tint l = 1, r = n + 1;\n\t\t\tint pl = pattern.Length;\n\t\t\t\n\t\t\twhile(l < r)\n\t\t\t{\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\t\n\t\t\t\tstring subStr = (sa[m] + pl > n) ? S.Substring(sa[m]) : S.Substring(sa[m], pl);\n                    \n                int comp = subStr.CompareTo(pattern);\n                if (comp == 0) return \"1\";\n                \n                if (comp < 0) l = m + 1;\n                else r = m;\n\t\t\t}\n\t\t\treturn \"0\";\n\t\t}\n\t}\n\t\n\t\n    class Program\n    {\n        static void Main(string[] args)\n        {\n        \tvar T = Console.ReadLine();\n        \t\n            SuffixArray SA = new SuffixArray(T);\n            StringBuilder sb = new StringBuilder();\n \n            var Q = int.Parse(Console.ReadLine());\n \n            for (int i = 0; i < Q; i++)\n            {\n                var P = Console.ReadLine();\n \n                sb.AppendLine(SA.Contains(P));\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\n\n// arihon p335\n// This solution is O(|T|log^2|T| + Q|P|log|T|) order.\nnamespace ALDS1_14_D\n{\n    class SuffixArray\n    {\n        internal int[] sa, rank, tmp;\n        internal string S;\n        internal int n, k;\n \n        public SuffixArray(string SS)\n        {\n            S = SS;\n            n = S.Length;\n            sa = new int[n + 1];\n            rank = new int[n << 1 + 1];\n            tmp = new int[n + 1];\n            Construct_SA();\n        }\n \n        public int Compare_SA(int i, int j)\n        {\n            return (rank[i] != rank[j]) ? rank[i] - rank[j] : rank[i + k] - rank[j + k];\n        }\n \n        public void Construct_SA()\n        {\n            for (int i = 0; i < n; i++)\n            {\n                sa[i] = i;\n                rank[i] = S[i];\n            }\n            sa[n] = n;\n \n            for (k = 1; k <= n; k <<= 1)\n            {\n                Array.Sort(sa, Compare_SA);\n \n                int d;\n                d = tmp[sa[0]] = 0;\n \n                for (int i = 1; i <= n; i++)\n                {\n                    d = tmp[sa[i]] = d + ((Compare_SA(sa[i - 1], sa[i]) < 0) ? 1 : 0);\n                }\n \n                for (int i = 0; i <= n; i++)\n                {\n                    rank[i] = tmp[i];\n                }\n            }\n        }\n \n        public string Contains(string pattern)\n        {\n            int l = 1, r = n + 1;\n            int pl = pattern.Length;\n \n            while (l < r)\n            {\n                int m = (l + r) >> 1;\n \n                string subStr = (sa[m] + pl > n) ? S.Substring(sa[m]) : S.Substring(sa[m], pl);\n \n                int comp = subStr.CompareTo(pattern);\n                if (comp == 0) return \"1\";\n \n                if (comp < 0) l = m + 1;\n                else r = m;\n            }\n            return \"0\";\n        }\n    }\n \n \n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            Console.SetOut(sw);\n            var T = Console.ReadLine();\n            var SA = new SuffixArray(T);\n            var Q = int.Parse(Console.ReadLine());\n            for (int i = 0; i < Q; i++)\n            {\n                var P = Console.ReadLine();\n                Console.WriteLine(SA.Contains(P));\n            }\n            Console.Out.Flush();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.IO;\n\nnamespace ALDS1_14_D\n{\n\tclass SuffixArray\n\t{\n\t\tinternal int[] sa, rank, tmp;\n\t\tinternal string S;\n\t\tinternal int n, k;\n\t\t\n\t\tpublic SuffixArray(string SS)\n\t\t{\n\t\t\tS = SS;\n\t\t\tn = S.Length;\n\t\t\tsa = new int[n + 1];\n\t\t\trank = new int[n + 1];\n\t\t\ttmp = new int[n + 1];\n\t\t\tConstruct_SA();\n\t\t}\n\t\t\n\t\tpublic int Compare_SA(int i, int j)\n\t\t{\n\t\t\tif(rank[i] != rank[j]) return rank[i] - rank[j];\n\t\t\t\n\t\t\tint ri = i + k  <= n ? rank[i + k] : -1;\n\t\t\tint rj = j + k <= n ? rank[j + k] : -1;\n\n\t\t\treturn  ri - rj; \n\t\t}\n\t\t\n\t\tpublic void Construct_SA()\n\t\t{\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tsa[i] = i;\n\t\t\t\trank[i] = S[i];\n\t\t\t}\n\t\t\tsa[n] = n; rank[n] = -1;\n\t\t\t\n\t\t\tfor(k = 1; k <= n; k*= 2)\n\t\t\t{\n\t\t\t\tArray.Sort(sa, Compare_SA);\n                \n                int d;\n                d = tmp[sa[0]] = 0;\n                for (int i = 1; i <= n; i++)\n                {\n                    d = tmp[sa[i]] = d + ((Compare_SA(sa[i - 1], sa[i]) < 0) ? 1 : 0);\n                }\n                for (int i = 0; i <= n; i++)\n                {\n                    rank[i] = tmp[i];\n                }\n \n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic string Contains(string pattern)\n\t\t{\n\t\t\tint l = 1, r = n + 1;\n\t\t\tint pl = pattern.Length;\n\t\t\t\n\t\t\twhile(l < r)\n\t\t\t{\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\t\n\t\t\t\tstring subStr = (sa[m] + pl > n) ? S.Substring(sa[m]) : S.Substring(sa[m], pl);\n                    \n                int comp = subStr.CompareTo(pattern);\n                if (comp == 0) return \"1\";\n                \n                if (comp < 0) l = m + 1;\n                else r = m;\n\t\t\t}\n\t\t\treturn \"0\";\n\t\t}\n\t}\n\t\n\t\n    class Program\n    {\n    \t\n        static void Main(string[] args)\n        {\n        \tvar sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    \t \tConsole.SetOut(sw);\n    \t \n        \tvar T = Console.ReadLine();\n        \t\n            SuffixArray SA = new SuffixArray(T);\n            StringBuilder sb = new StringBuilder();\n \n            var Q = int.Parse(Console.ReadLine());\n \n            for (int i = 0; i < Q; i++)\n            {\n                var P = Console.ReadLine();\n \n                Console.WriteLine(SA.Contains(P));\n            }\n            Console.Out.Flush();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\n\n// arihon p335\n// This solution is O(|T|log^2|T| + Q|P|log|T|) order.\nnamespace ALDS1_14_D\n{\n    class SuffixArray\n    {\n        internal int[] sa, rank, tmp;\n        internal string S;\n        internal int n, k;\n \n        public SuffixArray(string SS)\n        {\n            S = SS;\n            n = S.Length;\n            sa = new int[n + 1];\n            rank = new int[(n << 1) + 1];\n            tmp = new int[n + 1];\n            Construct_SA();\n        }\n \n        public int Compare_SA(int i, int j)\n        {\n            return (rank[i] != rank[j]) ? rank[i] - rank[j] : rank[i + k] - rank[j + k];\n        }\n \n        public void Construct_SA()\n        {\n            for (int i = 0; i < n; i++)\n            {\n                sa[i] = i;\n                rank[i] = S[i];\n            }\n            sa[n] = n;\n \n            for (k = 1; k <= n; k <<= 1)\n            {\n                Array.Sort(sa, Compare_SA);\n \n                int d;\n                d = tmp[sa[0]] = 1;\n \n                for (int i = 1; i <= n; i++)\n                {\n                    d = tmp[sa[i]] = d + ((Compare_SA(sa[i - 1], sa[i]) < 0) ? 1 : 0);\n                }\n \n                for (int i = 0; i <= n; i++)\n                {\n                    rank[i] = tmp[i];\n                }\n            }\n        }\n \n        public string Contains(string pattern)\n        {\n            int l = 1, r = n + 1;\n            int pl = pattern.Length;\n \n            while (l < r)\n            {\n                int m = (l + r) >> 1;\n \n                string subStr = (sa[m] + pl > n) ? S.Substring(sa[m]) : S.Substring(sa[m], pl);\n \n                int comp = subStr.CompareTo(pattern);\n                if (comp == 0) return \"1\";\n \n                if (comp < 0) l = m + 1;\n                else r = m;\n            }\n            return \"0\";\n        }\n    }\n \n \n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            Console.SetOut(sw);\n            var T = Console.ReadLine();\n            var SA = new SuffixArray(T);\n            var Q = int.Parse(Console.ReadLine());\n            for (int i = 0; i < Q; i++)\n            {\n                var P = Console.ReadLine();\n                Console.WriteLine(SA.Contains(P));\n            }\n            Console.Out.Flush();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\n\nnamespace ALDS1_14_D\n{\n    class SuffixArray\n    {\n        internal int[] sa, rank, tmp;\n        internal string S;\n        internal int n, k;\n\n        public SuffixArray(string SS)\n        {\n            S = SS;\n            n = S.Length;\n            sa = new int[n + 1];\n            rank = new int[2 * n + 1];\n            for (int i = n + 1; i <  n << 1; i++)\n            {\n                rank[i] = -1;\n            }\n            tmp = new int[n + 1];\n            Construct_SA();\n        }\n\n        public int Compare_SA(int i, int j)\n        {\n            return (rank[i] != rank[j]) ? rank[i] - rank[j] : rank[i + k] - rank[j + k];\n        }\n\n        public void Construct_SA()\n        {\n            for (int i = 0; i < n; i++)\n            {\n                sa[i] = i;\n                rank[i] = S[i];\n            }\n            sa[n] = n; rank[n] = -1;\n\n            for (k = 1; k <= n; k <<= 1)\n            {\n                Array.Sort(sa, Compare_SA);\n\n                int d;\n                d = tmp[sa[0]] = 0;\n\n                for (int i = 1; i <= n; i++)\n                {\n                    d = tmp[sa[i]] = d + ((Compare_SA(sa[i - 1], sa[i]) < 0) ? 1 : 0);\n                }\n\n                for (int i = 0; i <= n; i++)\n                {\n                    rank[i] = tmp[i];\n                }\n\n            }\n        }\n\n        public string Contains(string pattern)\n        {\n            int l = 1, r = n + 1;\n            int pl = pattern.Length;\n\n            while (l < r)\n            {\n                int m = (l + r) >> 1;\n\n                string subStr = (sa[m] + pl > n) ? S.Substring(sa[m]) : S.Substring(sa[m], pl);\n\n                int comp = subStr.CompareTo(pattern);\n                if (comp == 0) return \"1\";\n\n                if (comp < 0) l = m + 1;\n                else r = m;\n            }\n            return \"0\";\n        }\n    }\n\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            Console.SetOut(sw);\n            var T = Console.ReadLine();\n            var SA = new SuffixArray(T);\n            var Q = int.Parse(Console.ReadLine());\n            for (int i = 0; i < Q; i++)\n            {\n                var P = Console.ReadLine();\n                Console.WriteLine(SA.Contains(P));\n            }\n            Console.Out.Flush();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var s = Console.ReadLine().Trim();\n        var q = int.Parse(Console.ReadLine().Trim());\n        for (int i = 0; i < q; i++)\n        {\n            var a = Console.ReadLine().Trim();\n            Console.WriteLine(s.IndexOf(a) == -1 ? 0 : 1);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Text;\n \nnamespace ALDS1_14_D\n{\n\tclass SuffixArray\n\t{\n\t\tinternal int[] sa, rank, tmp;\n\t\tinternal string S;\n\t\tinternal int n, k;\n\t\t\n\t\tpublic SuffixArray(string SS)\n\t\t{\n\t\t\tS = SS;\n\t\t\tn = S.Length;\n\t\t\tsa = new int[n + 1];\n\t\t\trank = new int[n + 1];\n\t\t\ttmp = new int[n + 1];\n\t\t\tConstruct_SA();\n\t\t}\n\t\t\n\t\tpublic int Compare_SA(int i, int j)\n\t\t{\n\t\t\tif(rank[i] > rank[j]) return 1;\n\t\t\tif(rank[i] < rank[j]) return -1;\n\t\t\t\n\t\t\tint ri = i + k  <= n ? rank[i + k] : -1;\n\t\t\tint rj = j + k <= n ? rank[j + k] : -1;\n\t\t\tif(ri > rj) return 1;\n\t\t\tif(ri < rj) return -1;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tpublic void Construct_SA()\n\t\t{\n\t\t\tfor(int i = 0; i <= n; i++)\n\t\t\t{\n\t\t\t\tsa[i] = i;\n\t\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t\t}\n\t\t\t\n\t\t\tfor(k = 1; k <= n; k*= 2)\n\t\t\t{\n\t\t\t\tArray.Sort(sa, Compare_SA);\n\t\t\t\t\n\t\t\t    /*Console.WriteLine();\n                Console.WriteLine(0 +\" \" + sa[0]+ \"   \"+rank[sa[0]]);             \n                for (int i = 1; i <= n; i++)\n                {\n                    Console.WriteLine(i  + \" \" + sa[i] + \" \" + S[sa[i]] + \" \" + rank[sa[i]]);\n                }*/\n                \n                \n                tmp[sa[0]] = 0;\n                for (int i = 1; i <= n; i++)\n                {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + ((Compare_SA(sa[i - 1], sa[i]) < 0) ? 1 : 0);\n                }\n                for (int i = 0; i <= n; i++)\n                {\n                    rank[i] = tmp[i];\n                }\n \n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic bool Contains(string pattern)\n\t\t{\n\t\t\tint l = 1, r = n + 1;\n\t\t\tint pl = pattern.Length;\n\t\t\t\n\t\t\t/*\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.WriteLine(pattern);\n\t\t\t*/\n\t\t\t\n\t\t\twhile(l < r)\n\t\t\t{\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\t\n\t\t\t\tstring subStr = (sa[m] + pl > n) ? S.Substring(sa[m]) : S.Substring(sa[m], pl);\n                    \n                   \n                int comp = subStr.CompareTo(pattern);\n                \n                 //Console.WriteLine(l + \" \" + r + \" \" + m + \" \" + subStr +\" \"+ comp);\n                if (comp == 0) return true;\n                \n                if (comp < 0) l = m + 1;\n                else r = m;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t\n    class Program\n    {\n        static void Main(string[] args)\n        {\n        \tvar T = Console.ReadLine();\n        \t\n            SuffixArray SA = new SuffixArray(T);\n            StringBuilder sb = new StringBuilder();\n \n            var Q = int.Parse(Console.ReadLine());\n \n            for (int i = 0; i < Q; i++)\n            {\n                var P = Console.ReadLine();\n \n                sb.AppendLine(SA.Contains(P) ? \"1\" : \"0\");\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "config = { input: 'tmp', newline: '\\r\\n' }; // win\n//config = { input: '/dev/stdin', newline: '\\n' }; // linux\n\nline = require('fs').readFileSync(config.input, 'ascii')\n  .split(config.newline);\nT = line[0];\nQ = Number(line[1]);\nP = line.slice(2, 2+Q);\nline = null; // dispose\n\nfunction rabinKarpMatcher(T, P, d, q) {\n  var T, n, P, m, h, p, t, i, s;\n  n = T.length;\n  T = \"_\" + T; // start0 -> start1\n  m = P.length;\n  P = \"_\" + P; // start0 -> start1\n  if (m > n) return 0;\n  h = Math.pow(d, m-1) % q;\n  p = 0;\n  t = {};\n  t[0] = 0;\n  for (i = 1; i <= m; i++) { // preprocess\n    p = (d * p + P[i].charCodeAt()) % q;\n    t[0] = (d * t[0] + T[i].charCodeAt()) % q;\n  }\n  for (s = 0; s <= n - m; s++) { // matching\n    if (p == t[s])\n      if (P.slice(1, m+1) === T.slice(s+1, s+m+1))\n        //console.log(\"pattern match at shift \" + s);\n        return 1;\n    if (s < n - m)\n      t[s+1] =\n        (d * (t[s] - T[s+1].charCodeAt() * h) + T[s+m+1].charCodeAt()) % q;\n  }\n  return 0;\n}\n\n\nfor (i in P) console.log(rabinKarpMatcher(T, P[i], 256, Math.pow(2, 31) - 1));"
  },
  {
    "language": "JavaScript",
    "code": "//config = { input: 'tmp', newline: '\\r\\n' }; // win\nconfig = { input: '/dev/stdin', newline: '\\n' }; // linux\n\nline = require('fs').readFileSync(config.input, 'ascii')\n  .split(config.newline);\nT = line[0];\nQ = Number(line[1]);\nP = line.slice(2, 2+Q);\nline = null; // dispose\n\nfunction rabinKarpMatcher(T, P, d, q) {\n  var T, n, P, m, h, p, t, i, s;\n  n = T.length;\n  T = \"_\" + T; // start0 -> start1\n  m = P.length;\n  P = \"_\" + P; // start0 -> start1\n  h = Math.pow(d, m-1) % q;\n  p = 0;\n  t = {};\n  t[0] = 0;\n  for (i = 1; i <= m; i++) { // preprocess\n    p = (d * p + P[i].charCodeAt()) % q;\n    t[0] = (d * t[0] + T[i].charCodeAt()) % q;\n  }\n  for (s = 0; s <= n - m; s++) { // matching\n    if (p == t[s])\n      if (P.slice(1, m+1) === T.slice(s+1, s+m+1))\n        //console.log(\"pattern match at shift \" + s);\n        return 1;\n    if (s < n - m)\n      t[s+1] =\n        (d * (t[s] - T[s+1].charCodeAt() * h) + T[s+m+1].charCodeAt()) % q;\n  }\n  return 0;\n}\n\n\nfor (i in P) console.log(rabinKarpMatcher(T, P[i], 256, Math.pow(2, 31) - 1));"
  },
  {
    "language": "JavaScript",
    "code": "config = { input: 'tmp', newline: '\\r\\n' }; // win\n//config = { input: '/dev/stdin', newline: '\\n' }; // linux\n\nline = require('fs').readFileSync(config.input, 'ascii')\n  .split(config.newline);\nT = line[0];\nQ = Number(line[1]);\nP = line.slice(2, 2+Q);\nline = null; // dispose\n\nfunction rabinKarpMatcher(T, P, d, q) {\n  var T, n, P, m, h, p, t, i, s;\n  n = T.length;\n  T = \"_\" + T; // start0 -> start1\n  m = P.length;\n  P = \"_\" + P; // start0 -> start1\n  h = Math.pow(d, m-1) % q;\n  p = 0;\n  t = {};\n  t[0] = 0;\n  for (i = 1; i <= m; i++) { // preprocess\n    p = (d * p + P[i].charCodeAt()) % q;\n    t[0] = (d * t[0] + T[i].charCodeAt()) % q;\n  }\n  for (s = 0; s <= n - m; s++) { // matching\n    if (p == t[s])\n      if (P.slice(1, m+1) === T.slice(s+1, s+m+1))\n        //console.log(\"pattern match at shift \" + s);\n        return 1;\n    if (s < n - m)\n      t[s+1] =\n        (d * (t[s] - T[s+1].charCodeAt() * h) + T[s+m+1].charCodeAt()) % q;\n  }\n  return 0;\n}\n\n\nfor (i in P) console.log(rabinKarpMatcher(T, P[i], 256, Math.pow(2, 31) - 1));"
  },
  {
    "language": "JavaScript",
    "code": "//config = { input: 'tmp', newline: '\\r\\n' }; // win\nconfig = { input: '/dev/stdin', newline: '\\n' }; // linux\n\nline = require('fs').readFileSync(config.input, 'ascii')\n  .split(config.newline);\nT = line[0];\nQ = Number(line[1]);\nP = line.slice(2, 2+Q);\nline = null; // dispose\n\nfor (i in P) console.log((T.indexOf(P[i]) !== -1) ? 1 : 0);"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr = input.trim().split(\"\\n\");\nvar str=arr[0];\nvar n = (arr[1]-0)+2;\nvar ans=\"\";\nfor(var i=2;i<n;i++){\n   ans += (str.includes(arr[i])?1:0) +\"\\n\";\n}\nconsole.log(ans.trim());\n"
  },
  {
    "language": "JavaScript",
    "code": "//config = { input: 'tmp', newline: '\\r\\n' }; // win\nconfig = { input: '/dev/stdin', newline: '\\n' }; // linux\n\nline = require('fs').readFileSync(config.input, 'ascii')\n  .split(config.newline);\nT = line[0];\nQ = Number(line[1]);\nP = line.slice(2, 2+Q);\nline = null; // dispose\n\nfunction rabinKarpMatcher(T, P, d, q) {\n  var T, n, P, m, h, p, t, i, s;\n  n = T.length;\n  T = \"_\" + T; // start0 -> start1\n  m = P.length;\n  P = \"_\" + P; // start0 -> start1\n  if (m > n) return 0;\n  h = Math.pow(d, m-1) % q;\n  p = 0;\n  t = {};\n  t[0] = 0;\n  for (i = 1; i <= m; i++) { // preprocess\n    p = (d * p + P[i].charCodeAt()) % q;\n    t[0] = (d * t[0] + T[i].charCodeAt()) % q;\n  }\n  for (s = 0; s <= n - m; s++) { // matching\n    if (p == t[s])\n      if (P.slice(1, m+1) === T.slice(s+1, s+m+1))\n        //console.log(\"pattern match at shift \" + s);\n        return 1;\n    if (s < n - m)\n      t[s+1] =\n        (d * (t[s] - T[s+1].charCodeAt() * h) + T[s+m+1].charCodeAt()) % q;\n  }\n  return 0;\n}\n\n\nfor (i in P) console.log(rabinKarpMatcher(T, P[i], 256, Math.pow(2, 31) - 1));"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr = input.trim().split(\"\\n\");\nvar str=arr.shift();\nvar n = arr.shift()-0;\nvar ans = \"\";\nfor(var i=0;i<n;i++){\n   console.log(str.includes(arr[i])?1:0);\n}\n"
  },
  {
    "language": "Ruby",
    "code": "t = gets.chomp;\nn = gets.to_i\n\nn.times do\n    if t.include? gets.chomp\n        puts 1\n    else\n        puts 0\n    end\nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "t = gets.chomp\nq = gets.to_i\nq.times{\n  p = gets.chomp\n  if q.index(q) then\n    puts \"1\"\n  else\n    puts \"0\"\n  end\n}"
  },
  {
    "language": "Ruby",
    "code": "t = gets.chomp\nq = gets.to_i\nq.times{\n  p = gets.chomp\n  if t.index(p) == nil then\n    puts \"0\"\n  else\n    puts \"1\"\n  end\n}"
  },
  {
    "language": "Ruby",
    "code": "T = gets.chop\ngets.to_i.times{\n  puts T.include?(gets.chop) ? 1 : 0 \n}"
  },
  {
    "language": "Ruby",
    "code": "t = gets.chomp\nq = gets.to_i\np = []\nmin = 10 # << optimization variable\nq.times{|i|\n  p[i] = gets.chomp\n}\n\n\nhash = Hash.new{|h,k| h[k] = {}}\n0.upto(t.size-min){|i|\n  hash[t[i,min]][i] = 1\n  hash[t[i]][i] = 1\n}\n(t.size-min+1).upto(t.size){|i|\n  hash[t[i]][i] = 1\n}\n\n\nchecked = {}\np.size.times{|i|\n  unless checked[p[i]]\n    unless hash[p[i][0,min]] || hash[p[i][0]] then\n      checked[p[i]] = 0\n    else\n      ans = 0\n      if p[i].size >= min then\n        hash[p[i][0,min]].each_key{|j|\n          if t[j,p[i].size] == p[i] then\n            ans = 1\n            break\n          end\n        }\n      else\n        hash[p[i][0]].each_key{|j|\n          if t[j,p[i].size] == p[i] then\n            ans = 1\n            break\n          end\n        }\n      end\n      checked[p[i]] = ans\n    end\n  end\n  puts checked[p[i]]\n}"
  },
  {
    "language": "Ruby",
    "code": "t = gets.chomp\nq = gets.to_i\np = []\nmin = 1.0 / 0.0\nmax = 0\nq.times{|i|\n  p[i] = gets.chomp\n  min = p[i].size if p[i].size < min\n  max = p[i].size if p[i].size > max\n}\n\nhash = {}\n0.upto(t.size-min){|i|\n  hash[t[i,min]] = [] unless hash[t[i,min]]\n  hash[t[i,min]] << i\n}\n\nchecked = {}\np.size.times{|i|\n  unless checked[p[i]]\n    unless hash[p[i][0,min]] then\n      checked[p[i]] = 0\n    else\n      ans = 0\n      hash[p[i][0,min]].each{|j|\n        if t[j,p[i].size] == p[i] then\n          ans = 1\n          break\n        end\n      }\n      checked[p[i]] = ans\n    end\n  end\n  puts checked[p[i]]\n}"
  },
  {
    "language": "Ruby",
    "code": "t=gets;gets;$<.map{|s|p(t=~/#{s.chomp}/?1:0)}"
  },
  {
    "language": "Ruby",
    "code": "t = gets.chomp\nq = gets.to_i\nq.times{\n  p = gets.chomp\n  if t.index(p) == nil then\n    puts \"0\"\n  else\n    puts \"1\"\n  end\n}"
  },
  {
    "language": "Ruby",
    "code": "t = gets.chomp\ntext = t.split(\"\")\nhash = {}\ntext.size.times{|i|\n  hash[text[i]] = [] unless hash[text[i]]\n  hash[text[i]] << i\n}\n\nq = gets.to_i\nq.times{\n  p = gets.chomp\n  len = p.size\n  unless hash[p[0]] then\n    puts \"0\"\n    next\n  end\n  ans = 0\n  hash[p[0]].each{|i|\n    if t[i,len] == p then\n      ans = 1\n      break\n    end\n  }\n  puts ans\n}"
  },
  {
    "language": "Ruby",
    "code": "def contain_word(t, p)\n  t_length = t.length\n  p_length = p.length\n  for i in 0..(t_length - p_length)\n    if t[i..i+p_length-1] == p\n      return true\n      break\n    end\n  end\n  return false\nend\n\nt = gets.chomp.to_s\nq = gets.chomp.to_i\np = []\nq.times do\n  input_value = gets.chomp.to_s\n  p.push(input_value)\nend\noutput = []\nfor i in 0..(q-1)\n  if contain_word(t, p[i]) == true\n    output.push(1)\n  else\n    output.push(0)\n  end\nend\nlength = output.length\nfor i in 0..(length-1)\n  puts output[i]\nend"
  },
  {
    "language": "Ruby",
    "code": "def contain_word(t, p)\n  t_length = t.length\n  p_length = p.length\n  for i in 0..(t_length - p_length)\n    if t[i..i+p_length-1] == p\n      return true\n    end\n  end\n  return false\nend\n\nt = gets.chomp.to_s\nq = gets.chomp.to_i\np = []\nq.times do\n  input_value = gets.chomp.to_s\n  p.push(input_value)\nend\noutput = []\nfor i in 0..(q-1)\n  if contain_word(t, p[i]) == true\n    output.push(1)\n  else\n    output.push(0)\n  end\nend\nlength = output.length\nfor i in 0..(length-1)\n  puts output[i]\nend"
  },
  {
    "language": "Ruby",
    "code": "t = gets.chomp.to_s\nq = gets.chomp.to_i\np = []\nq.times do\n  input_value = gets.chomp.to_s\n  p.push(input_value)\nend\noutput = []\n# for i in 0..(q-1)\n#   if contain_word(t, p[i]) == true\n#     output.push(1)\n#   else\n#     output.push(0)\n#   end\n# end\n# length = output.length\n# for i in 0..(length-1)\n#   puts output[i]\n# end\nfor i in 0..(q-1)\n  if t.index(p[i]) == nil\n    output.push(0)\n  else\n    output.push(1)\n  end\nend\nlength = output.length\nfor i in 0..(length-1)\n  puts output[i]\nend"
  },
  {
    "language": "Ruby",
    "code": "t = gets.chomp\nq = gets.to_i\np = []\nmin = 1.0 / 0.0\nmax = 0\nq.times{|i|\n  p[i] = gets.chomp\n  min = p[i].size if p[i].size < min\n  max = p[i].size if p[i].size > max\n}\n\nhash = {}\n0.upto(t.size-min){|i|\n  hash[t[i,min]] = [] unless hash[t[i,min]]\n  hash[t[i,min]] << i\n}\n\np.size.times{|i|\n  unless hash[p[i][0,min]] then\n    puts \"0\"\n    next\n  end\n  ans = 0\n  hash[p[i][0,min]].each{|j|\n    if t[j,p[i].size] == p[i] then\n      ans = 1\n      break\n    end\n  }\n  puts ans\n}"
  },
  {
    "language": "Ruby",
    "code": "t = gets\nq = gets.chomp.to_i\n\nwhile pi = gets&.chomp\n    puts(t[pi] ? 1 : 0)\nend\n"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\ns=gets.chomp+'$'\nn=s.size\nsuff=n.times.sort_by{|i|s[i..-1]}\nbwt=suff.map{|e|s[(e-1)%n]}\nsorted=n.times.map{|i|[bwt[i],i]}.sort\ngets.to_i.times{\n\tq=gets.chomp.reverse\n\tstart=0\n\tstop=n\n\tif q.size.times{|i|\n\t\tstart,stop=[\n\t\t\t(0...n).bsearch{|j|(sorted[j]<=>[q[i],start]) >= 0}||n,\n\t\t\t(0...n).bsearch{|j|(sorted[j]<=>[q[i],stop]) >= 0}||n,\n\t\t]\n\t\tbreak if start==stop\n\t} then\n\t\t#p (start...stop).map{|i|suff[i]}\n\t\tp 1\n\telse\n\t\tp 0\n\tend\n}"
  },
  {
    "language": "Go",
    "code": "\n// Rabin-Karp string search algorithm in Golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"bufio\"\n\t\"os\"\n\t\"strconv\"\n)\n\nconst base = 16777619\n\nfunc Search(txt string, patterns []string) []string {\n\tin := indices(txt, patterns)\n\tmatches := make([]string, len(in))\n\ti := 0\n\tfor j, p := range patterns {\n\t\tif _, ok := in[j]; ok {\n\t\t\tmatches[i] = p\n\t\t\ti++\n\t\t}\n\t}\n\n\treturn matches\n}\n\nfunc indices(txt string, patterns []string) map[int]int {\n\tn, m := len(txt), minLen(patterns)\n\tmatches := make(map[int]int)\n\n\tif n < m || len(patterns) == 0 {\n\t\treturn matches\n\t}\n\n\tvar mult uint32 = 1 // mult = base^(m-1)\n\tfor i := 0; i < m-1; i++ {\n\t\tmult = (mult * base)\n\t}\n\n\thp := hashPatterns(patterns, m)\n\th := hash(txt[:m])\n\tfor i := 0; i < n-m+1 && len(hp) > 0; i++ {\n\t\tif i > 0 {\n\t\t\th = h - mult*uint32(txt[i-1])\n\t\t\th = h*base + uint32(txt[i+m-1])\n\t\t}\n\n\t\tif mps, ok := hp[h]; ok {\n\t\t\tfor _, pi := range mps {\n\t\t\t\tpat := patterns[pi]\n\t\t\t\te := i + len(pat)\n\t\t\t\tif _, ok := matches[pi]; !ok && e <= n && pat == txt[i:e] {\n\t\t\t\t\tmatches[pi] = i\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn matches\n}\n\nfunc hash(s string) uint32 {\n\tvar h uint32\n\tfor i := 0; i < len(s); i++ {\n\t\th = (h*base + uint32(s[i]))\n\t}\n\treturn h\n}\n\nfunc hashPatterns(patterns []string, l int) map[uint32][]int {\n\tm := make(map[uint32][]int)\n\tfor i, t := range patterns {\n\t\th := hash(t[:l])\n\t\tif _, ok := m[h]; ok {\n\t\t\tm[h] = append(m[h], i)\n\t\t} else {\n\t\t\tm[h] = []int{i}\n\t\t}\n\t}\n\n\treturn m\n}\n\nfunc minLen(patterns []string) int {\n\tif len(patterns) == 0 {\n\t\treturn 0\n\t}\n\n\tm := len(patterns[0])\n\tfor i := range patterns {\n\t\tif m > len(patterns[i]) {\n\t\t\tm = len(patterns[i])\n\t\t}\n\t}\n\n\treturn m\n}\n\nvar rdr = bufio.NewReaderSize(os.Stdin, 100000000000)\n\nfunc readLine() string {\n\tbuf := make([]byte, 0, 100000000000)\n\tfor {\n\t\tl, p, e := rdr.ReadLine()\n\t\tif e != nil {\n\t\t\tpanic(e)\n\t\t}\n\t\tbuf = append(buf, l...)\n\t\tif !p {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn string(buf)\n}\n\nfunc main() {\n\ttxt := readLine()\n\tn, _ := strconv.Atoi(readLine())\n\tpatterns := make([]string, 0)\n\tfor i := 0 ; i < n; i++ {\n\t\ttmp := readLine()\n\t\tpatterns = append(patterns, tmp)\n\t}\n\tmatches := Search(txt, patterns)\n\t// fmt.Println(matches)\n\tfor i := range patterns {\n\t\tif inMatches(patterns[i], matches) {\n\t\t\tfmt.Println(1)\n\t\t} else {\n\t\t\tfmt.Println(0)\n\t\t}\n\t}\n}\n\nfunc inMatches(target string, matches []string) bool {\n\tfor i := range matches {\n\t\tif matches[i] == target {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"index/suffixarray\"\n\t\"os\"\n)\n\nfunc main() {\n\tr := bufio.NewReader(os.Stdin)\n\tw := bufio.NewWriter(os.Stdout)\n\tdefer w.Flush()\n\n\tvar s string\n\tvar q int\n\n\tfmt.Fscan(r, &s)\n\tfmt.Fscan(r, &q)\n\n\tindex := suffixarray.New([]byte(s))\n\n\tfor i := 0; i < q; i++ {\n\t\tvar p string\n\t\tfmt.Fscan(r, &p)\n\n\t\tres := index.Lookup([]byte(p), 1)\n\t\tif len(res) > 0 {\n\t\t\tfmt.Fprintln(w, 1)\n\t\t} else {\n\t\t\tfmt.Fprintln(w, 0)\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Go",
    "code": "\n// Rabin-Karp string search algorithm in Golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"bufio\"\n\t\"os\"\n\t\"strconv\"\n)\n\nconst base = 16777619\n\nfunc Search(txt string, patterns []string) []string {\n\tin := indices(txt, patterns)\n\tmatches := make([]string, len(in))\n\ti := 0\n\tfor j, p := range patterns {\n\t\tif _, ok := in[j]; ok {\n\t\t\tmatches[i] = p\n\t\t\ti++\n\t\t}\n\t}\n\n\treturn matches\n}\n\nfunc indices(txt string, patterns []string) map[int]int {\n\tn, m := len(txt), minLen(patterns)\n\tmatches := make(map[int]int)\n\n\tif n < m || len(patterns) == 0 {\n\t\treturn matches\n\t}\n\n\tvar mult uint32 = 1 // mult = base^(m-1)\n\tfor i := 0; i < m-1; i++ {\n\t\tmult = (mult * base)\n\t}\n\n\thp := hashPatterns(patterns, m)\n\th := hash(txt[:m])\n\tfor i := 0; i < n-m+1 && len(hp) > 0; i++ {\n\t\tif i > 0 {\n\t\t\th = h - mult*uint32(txt[i-1])\n\t\t\th = h*base + uint32(txt[i+m-1])\n\t\t}\n\n\t\tif mps, ok := hp[h]; ok {\n\t\t\tfor _, pi := range mps {\n\t\t\t\tpat := patterns[pi]\n\t\t\t\te := i + len(pat)\n\t\t\t\tif _, ok := matches[pi]; !ok && e <= n && pat == txt[i:e] {\n\t\t\t\t\tmatches[pi] = i\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn matches\n}\n\nfunc hash(s string) uint32 {\n\tvar h uint32\n\tfor i := 0; i < len(s); i++ {\n\t\th = (h*base + uint32(s[i]))\n\t}\n\treturn h\n}\n\nfunc hashPatterns(patterns []string, l int) map[uint32][]int {\n\tm := make(map[uint32][]int)\n\tfor i, t := range patterns {\n\t\th := hash(t[:l])\n\t\tif _, ok := m[h]; ok {\n\t\t\tm[h] = append(m[h], i)\n\t\t} else {\n\t\t\tm[h] = []int{i}\n\t\t}\n\t}\n\n\treturn m\n}\n\nfunc minLen(patterns []string) int {\n\tif len(patterns) == 0 {\n\t\treturn 0\n\t}\n\n\tm := len(patterns[0])\n\tfor i := range patterns {\n\t\tif m > len(patterns[i]) {\n\t\t\tm = len(patterns[i])\n\t\t}\n\t}\n\n\treturn m\n}\n\nvar rdr = bufio.NewReaderSize(os.Stdin, 1000000000)\n\nfunc readLine() string {\n\tbuf := make([]byte, 0, 1000000000)\n\tfor {\n\t\tl, p, e := rdr.ReadLine()\n\t\tif e != nil {\n\t\t\tpanic(e)\n\t\t}\n\t\tbuf = append(buf, l...)\n\t\tif !p {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn string(buf)\n}\n\nfunc main() {\n\ttxt := readLine()\n\tn, _ := strconv.Atoi(readLine())\n\tpatterns := make([]string, 0)\n\tfor i := 0 ; i < n; i++ {\n\t\ttmp := readLine()\n\t\tpatterns = append(patterns, tmp)\n\t}\n\tmatches := Search(txt, patterns)\n\t// fmt.Println(matches)\n\tfor i := range patterns {\n\t\tif inMatches(patterns[i], matches) {\n\t\t\tfmt.Println(1)\n\t\t} else {\n\t\t\tfmt.Println(0)\n\t\t}\n\t}\n}\n\nfunc inMatches(target string, matches []string) bool {\n\tfor i := range matches {\n\t\tif matches[i] == target {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
  },
  {
    "language": "Go",
    "code": "\n// Rabin-Karp string search algorithm in Golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"bufio\"\n\t\"os\"\n\t\"strconv\"\n)\n\nconst base = 16777619\n\nfunc Search(txt string, patterns []string) []string {\n\tin := indices(txt, patterns)\n\tmatches := make([]string, len(in))\n\ti := 0\n\tfor j, p := range patterns {\n\t\tif _, ok := in[j]; ok {\n\t\t\tmatches[i] = p\n\t\t\ti++\n\t\t}\n\t}\n\n\treturn matches\n}\n\nfunc indices(txt string, patterns []string) map[int]int {\n\tn, m := len(txt), minLen(patterns)\n\tmatches := make(map[int]int)\n\n\tif n < m || len(patterns) == 0 {\n\t\treturn matches\n\t}\n\n\tvar mult uint32 = 1 // mult = base^(m-1)\n\tfor i := 0; i < m-1; i++ {\n\t\tmult = (mult * base)\n\t}\n\n\thp := hashPatterns(patterns, m)\n\th := hash(txt[:m])\n\tfor i := 0; i < n-m+1 && len(hp) > 0; i++ {\n\t\tif i > 0 {\n\t\t\th = h - mult*uint32(txt[i-1])\n\t\t\th = h*base + uint32(txt[i+m-1])\n\t\t}\n\n\t\tif mps, ok := hp[h]; ok {\n\t\t\tfor _, pi := range mps {\n\t\t\t\tpat := patterns[pi]\n\t\t\t\te := i + len(pat)\n\t\t\t\tif _, ok := matches[pi]; !ok && e <= n && pat == txt[i:e] {\n\t\t\t\t\tmatches[pi] = i\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn matches\n}\n\nfunc hash(s string) uint32 {\n\tvar h uint32\n\tfor i := 0; i < len(s); i++ {\n\t\th = (h*base + uint32(s[i]))\n\t}\n\treturn h\n}\n\nfunc hashPatterns(patterns []string, l int) map[uint32][]int {\n\tm := make(map[uint32][]int)\n\tfor i, t := range patterns {\n\t\th := hash(t[:l])\n\t\tif _, ok := m[h]; ok {\n\t\t\tm[h] = append(m[h], i)\n\t\t} else {\n\t\t\tm[h] = []int{i}\n\t\t}\n\t}\n\n\treturn m\n}\n\nfunc minLen(patterns []string) int {\n\tif len(patterns) == 0 {\n\t\treturn 0\n\t}\n\n\tm := len(patterns[0])\n\tfor i := range patterns {\n\t\tif m > len(patterns[i]) {\n\t\t\tm = len(patterns[i])\n\t\t}\n\t}\n\n\treturn m\n}\n\nvar rdr = bufio.NewReaderSize(os.Stdin, 1000000)\n\nfunc readLine() string {\n\tbuf := make([]byte, 0, 1000000)\n\tfor {\n\t\tl, p, e := rdr.ReadLine()\n\t\tif e != nil {\n\t\t\tpanic(e)\n\t\t}\n\t\tbuf = append(buf, l...)\n\t\tif !p {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn string(buf)\n}\n\nfunc main() {\n\ttxt := readLine()\n\tn, _ := strconv.Atoi(readLine())\n\tpatterns := make([]string, 0)\n\tfor i := 0 ; i < n; i++ {\n\t\ttmp := readLine()\n\t\tpatterns = append(patterns, tmp)\n\t}\n\tmatches := Search(txt, patterns)\n\t// fmt.Println(matches)\n\tfor i := range patterns {\n\t\tif inMatches(patterns[i], matches) {\n\t\t\tfmt.Println(1)\n\t\t} else {\n\t\t\tfmt.Println(0)\n\t\t}\n\t}\n}\n\nfunc inMatches(target string, matches []string) bool {\n\tfor i := range matches {\n\t\tif matches[i] == target {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
  },
  {
    "language": "Go",
    "code": "\n// Rabin-Karp string search algorithm in Golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"bufio\"\n\t\"os\"\n\t\"strconv\"\n)\n\nconst base = 16777619\n\nfunc Search(txt string, patterns []string) []string {\n\tin := indices(txt, patterns)\n\tmatches := make([]string, len(in))\n\ti := 0\n\tfor j, p := range patterns {\n\t\tif _, ok := in[j]; ok {\n\t\t\tmatches[i] = p\n\t\t\ti++\n\t\t}\n\t}\n\n\treturn matches\n}\n\nfunc indices(txt string, patterns []string) map[int]int {\n\tn, m := len(txt), minLen(patterns)\n\tmatches := make(map[int]int)\n\n\tif n < m || len(patterns) == 0 {\n\t\treturn matches\n\t}\n\n\tvar mult uint32 = 1 // mult = base^(m-1)\n\tfor i := 0; i < m-1; i++ {\n\t\tmult = (mult * base)\n\t}\n\n\thp := hashPatterns(patterns, m)\n\th := hash(txt[:m])\n\tfor i := 0; i < n-m+1 && len(hp) > 0; i++ {\n\t\tif i > 0 {\n\t\t\th = h - mult*uint32(txt[i-1])\n\t\t\th = h*base + uint32(txt[i+m-1])\n\t\t}\n\n\t\tif mps, ok := hp[h]; ok {\n\t\t\tfor _, pi := range mps {\n\t\t\t\tpat := patterns[pi]\n\t\t\t\te := i + len(pat)\n\t\t\t\tif _, ok := matches[pi]; !ok && e <= n && pat == txt[i:e] {\n\t\t\t\t\tmatches[pi] = i\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn matches\n}\n\nfunc hash(s string) uint32 {\n\tvar h uint32\n\tfor i := 0; i < len(s); i++ {\n\t\th = (h*base + uint32(s[i]))\n\t}\n\treturn h\n}\n\nfunc hashPatterns(patterns []string, l int) map[uint32][]int {\n\tm := make(map[uint32][]int)\n\tfor i, t := range patterns {\n\t\th := hash(t[:l])\n\t\tif _, ok := m[h]; ok {\n\t\t\tm[h] = append(m[h], i)\n\t\t} else {\n\t\t\tm[h] = []int{i}\n\t\t}\n\t}\n\n\treturn m\n}\n\nfunc minLen(patterns []string) int {\n\tif len(patterns) == 0 {\n\t\treturn 0\n\t}\n\n\tm := len(patterns[0])\n\tfor i := range patterns {\n\t\tif m > len(patterns[i]) {\n\t\t\tm = len(patterns[i])\n\t\t}\n\t}\n\n\treturn m\n}\n\nvar rdr = bufio.NewReaderSize(os.Stdin, 100000000)\n\nfunc readLine() string {\n\tbuf := make([]byte, 0, 100000000)\n\tfor {\n\t\tl, p, e := rdr.ReadLine()\n\t\tif e != nil {\n\t\t\tpanic(e)\n\t\t}\n\t\tbuf = append(buf, l...)\n\t\tif !p {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn string(buf)\n}\n\nfunc main() {\n\ttxt := readLine()\n\tn, _ := strconv.Atoi(readLine())\n\tpatterns := make([]string, 0)\n\tfor i := 0 ; i < n; i++ {\n\t\ttmp := readLine()\n\t\tpatterns = append(patterns, tmp)\n\t}\n\tmatches := Search(txt, patterns)\n\t// fmt.Println(matches)\n\tfor i := range patterns {\n\t\tif inMatches(patterns[i], matches) {\n\t\t\tfmt.Println(1)\n\t\t} else {\n\t\t\tfmt.Println(0)\n\t\t}\n\t}\n}\n\nfunc inMatches(target string, matches []string) bool {\n\tfor i := range matches {\n\t\tif matches[i] == target {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
  },
  {
    "language": "Go",
    "code": "\n// Rabin-Karp string search algorithm in Golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"bufio\"\n\t\"os\"\n\t\"strconv\"\n)\n\nconst base = 16777619\n\nfunc Search(txt string, patterns []string) []string {\n\tin := indices(txt, patterns)\n\tmatches := make([]string, len(in))\n\ti := 0\n\tfor j, p := range patterns {\n\t\tif _, ok := in[j]; ok {\n\t\t\tmatches[i] = p\n\t\t\ti++\n\t\t}\n\t}\n\n\treturn matches\n}\n\nfunc indices(txt string, patterns []string) map[int]int {\n\tn, m := len(txt), minLen(patterns)\n\tmatches := make(map[int]int)\n\n\tif n < m || len(patterns) == 0 {\n\t\treturn matches\n\t}\n\n\tvar mult uint32 = 1 // mult = base^(m-1)\n\tfor i := 0; i < m-1; i++ {\n\t\tmult = (mult * base)\n\t}\n\n\thp := hashPatterns(patterns, m)\n\th := hash(txt[:m])\n\tfor i := 0; i < n-m+1 && len(hp) > 0; i++ {\n\t\tif i > 0 {\n\t\t\th = h - mult*uint32(txt[i-1])\n\t\t\th = h*base + uint32(txt[i+m-1])\n\t\t}\n\n\t\tif mps, ok := hp[h]; ok {\n\t\t\tfor _, pi := range mps {\n\t\t\t\tpat := patterns[pi]\n\t\t\t\te := i + len(pat)\n\t\t\t\tif _, ok := matches[pi]; !ok && e <= n && pat == txt[i:e] {\n\t\t\t\t\tmatches[pi] = i\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn matches\n}\n\nfunc hash(s string) uint32 {\n\tvar h uint32\n\tfor i := 0; i < len(s); i++ {\n\t\th = (h*base + uint32(s[i]))\n\t}\n\treturn h\n}\n\nfunc hashPatterns(patterns []string, l int) map[uint32][]int {\n\tm := make(map[uint32][]int)\n\tfor i, t := range patterns {\n\t\th := hash(t[:l])\n\t\tif _, ok := m[h]; ok {\n\t\t\tm[h] = append(m[h], i)\n\t\t} else {\n\t\t\tm[h] = []int{i}\n\t\t}\n\t}\n\n\treturn m\n}\n\nfunc minLen(patterns []string) int {\n\tif len(patterns) == 0 {\n\t\treturn 0\n\t}\n\n\tm := len(patterns[0])\n\tfor i := range patterns {\n\t\tif m > len(patterns[i]) {\n\t\t\tm = len(patterns[i])\n\t\t}\n\t}\n\n\treturn m\n}\n\nvar rdr = bufio.NewReaderSize(os.Stdin, 10000000)\n\nfunc readLine() string {\n\tbuf := make([]byte, 0, 10000000)\n\tfor {\n\t\tl, p, e := rdr.ReadLine()\n\t\tif e != nil {\n\t\t\tpanic(e)\n\t\t}\n\t\tbuf = append(buf, l...)\n\t\tif !p {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn string(buf)\n}\n\nfunc main() {\n\ttxt := readLine()\n\tn, _ := strconv.Atoi(readLine())\n\tpatterns := make([]string, 0)\n\tfor i := 0 ; i < n; i++ {\n\t\ttmp := readLine()\n\t\tpatterns = append(patterns, tmp)\n\t}\n\tmatches := Search(txt, patterns)\n\t// fmt.Println(matches)\n\tfor i := range patterns {\n\t\tif inMatches(patterns[i], matches) {\n\t\t\tfmt.Println(1)\n\t\t} else {\n\t\t\tfmt.Println(0)\n\t\t}\n\t}\n}\n\nfunc inMatches(target string, matches []string) bool {\n\tfor i := range matches {\n\t\tif matches[i] == target {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport(\n\t\"fmt\"\n\t\"os\"\n\t\"io\"\n\t\"bufio\"\n\t\"bytes\"\n\t\"sort\"\n\t\"math\"\n)\n\n//  長い入力を読む\nfunc ReadLongLines(times int) ([]string, error) {\n\tresult := make([]string, times)\n\treader := bufio.NewReader(os.Stdin)\n\tbuffer := bytes.NewBuffer(make([]byte, 0))\n\treadBytes := int64(2)\n\tfor i := 0; i < times; i++ {\n\t\tfor {\n\t\t\treadBuf, isPrefix, err := reader.ReadLine()\n\t\t\t// fmt.Printf(\"Reader.Read: %d\\n\", len(readBuf))\n\t\t\treadBytes += int64(len(readBuf) + 1)\n\t\t\tif err != nil {\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\tfmt.Println(\"EOF\")\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\treturn result, err\n\t\t\t\t}\n\t\t\t}\n\t\t\t_, err = buffer.Write(readBuf)\n\t\t\tif err != nil {\n\t\t\t\treturn result, err\n\t\t\t}\n\t\t\t// end of line\n\t\t\tif !isPrefix {\n\t\t\t\tresult[i] = buffer.String()\n\t\t\t\tbuffer.Reset()\n\t\t\t\t// reader = bufio.NewReader(os.Stdin)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\t// 先読みしてしまうようなので、戻しておく\n\tos.Stdin.Seek(-int64(reader.Buffered()), os.SEEK_CUR)\n\treturn result, nil\n}\n\n\n\n\ntype SuffixArray struct {\n\tarray []int\n\ttext *string\n}\n\n// とりあえず最初に見つけたものだけ返してみるか\nfunc (this *SuffixArray) Search(pattern *string) int {\n\t// return -1\n\t// Binary Search すればいいんだよね？\n\tbegin := 0\n\tend := len(*this.text) -1\n\tcur := int((end - begin) / 2)\n\t\n\tfor {\n\t\t// fmt.Printf(\"b:%d, c: %d, end: %d\\n\", begin, cur, end)\n\t\tindex := this.array[cur]\n\t\t// fmt.Printf(\"index: %d\\n\", index)\n\t\t// mutch\n\t\tif StartsWith((*this.text)[index:], *pattern) {\n\t\t\treturn index\n\t\t}\n\t\t// if begin == cur || cur == end {\n\t\t// \treturn -1\n\t\t// }\n\t\tif end <= begin {\n\t\t\treturn -1\n\t\t}\n\t\t// to right or left\n\t\tif (*this.text)[index:] < *pattern {\n\t\t\t// fmt.Println(\"--->>>\")\n\t\t\tnewCur := cur + int(math.Ceil(float64(end - cur) / 2.0))\n\t\t\tbegin = cur + 1\n\t\t\tcur = newCur\n\t\t} else {\n\t\t\t// fmt.Println(\"<<<---\")\n\t\t\tnewCur := begin + (cur - begin) / 2\n\t\t\tend = cur - 1\n\t\t\tcur = newCur\n\t\t}\n\t}\n}\n\nfunc StartsWith(text string, pattern string) bool {\n\t// fmt.Printf(\"%s ? %s\\n\", text, pattern)\n\tif len(text) < len(pattern) {\n\t\treturn false\n\t}\n\tfor i := 0; i < len(pattern); i++ {\n\t\tif text[i] != pattern[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc Compare(rank *[]int, sa *[]int, lhs, rhs, k int ) bool {\n\tl := len(*rank)\n\t// if k == 1 {\n\t// \tfmt.Printf(\"sa: %v\\n\", *sa)\n\t// \tfmt.Printf(\"%d, %d\\n\", lhs, rhs)\n\t// }\n\tif (*rank)[(*sa)[lhs]] != (*rank)[(*sa)[rhs]] {\n\t\t// if k == 1 {\n\t\t// \tfmt.Printf(\"not same %d ? %d\\n\", (*rank)[(*sa)[lhs]], (*rank)[(*sa)[rhs]])\n\t\t// }\n\t\treturn (*rank)[(*sa)[lhs]] < (*rank)[(*sa)[rhs]]\n\t} else {\n\t\tli := -1\n\t\tif (*sa)[lhs] + k < l {\n\t\t\tli = (*rank)[(*sa)[lhs] + k]\n\t\t}\n\t\tri := -1\n\t\tif (*sa)[rhs] + k < l {\n\t\t\tri = (*rank)[(*sa)[rhs] + k]\n\t\t}\n\t\t// if k == 1 {\n\t\t// \tfmt.Printf(\"same     %d ? %d\\n\", li, ri)\n\t\t// }\n\t\treturn li < ri\n\t}\n}\n// constructor\nfunc NewSuffixArray(text *string) SuffixArray {\n\tt := (*text) + \"$\"\n\tl := len(t)\n\tsa := make([]int, l)\n\trank := make([]int, l)\n\ttemp := make([]int, l)\n\t\n\t// * はじめに1文字分の rank を作る\n\tfor i := 0; i < l; i++ {\n\t\tsa[i] = i\n\t\trank[i] = int(t[i]) // これで順序は成立する\n\t}\n\n    // * array を i ... i + k の範囲に伸ばして、\n\tfor k := 1; k < l; k *= 2 {\n\t\t// fmt.Printf(\"k:%d\\n\", k)\n\t\tsort.SliceStable(sa, func(lhs, rhs int) bool {\n\t\t\tif rank[sa[lhs]] != rank[sa[rhs]] {\n\t\t\t\treturn rank[sa[lhs]] < rank[sa[rhs]]\n\t\t\t} else {\n\t\t\t\tli := -1\n\t\t\t\tif sa[lhs] + k < l {\n\t\t\t\t\tli = rank[sa[lhs] + k]\n\t\t\t\t}\n\t\t\t\tri := -1\n\t\t\t\tif sa[rhs] + k < l {\n\t\t\t\t\tri = rank[sa[rhs] + k]\n\t\t\t\t}\n\t\t\t\t// fmt.Printf(\"%d < %d\\n\", li, ri)\n\t\t\t\treturn li < ri\n\t\t\t}\n\t\t})\n\n\t\t// * array から rank を作成\n\t\ttemp[sa[0]] = 0\n\t\tfor i := 1; i < l; i++ {\n\t\t\t// fmt.Printf(\"i:%d\\n\", i)\n\t\t\tif Compare(&rank, &sa, i - 1, i, k) {\n\t\t\t\t// fmt.Printf(\"sa[i]: %d\\n\", sa[i])\n\t\t\t\ttemp[sa[i]] = temp[sa[i-1]] + 1\n\t\t\t} else {\n\t\t\t\ttemp[sa[i]] = temp[sa[i-1]] \n\t\t\t}\n\t\t}\n\t\tfor i := 0; i < l; i++ {\n\t\t\trank[i] = temp[i]\n\t\t}\n\t\t// fmt.Printf(\"k:%d %v\\n\", k, rank)\n\t}\n\t// fmt.Println(sa)\n\t// fmt.Println(\"result:\")\n\t// for i := 0; i < l; i++ {\n\t// \tfmt.Printf(\"%s\\n\", t[sa[i]:])\n\t// }\n\t// * 要は自身のrankと i+k のrankでsort ( 最初の倍の長さにできる )\n\treturn SuffixArray{sa, &t}\n}\n\nvar sa SuffixArray\nfunc IsExists(text *string, pattern *string) bool {\n\treturn sa.Search(pattern) != -1\n}\n\nfunc main() {\n\tlines, err := ReadLongLines(1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tt := lines[0]\n\tsa = NewSuffixArray(&t)\n\tvar q int\n\tfmt.Scanf(\"%d\", &q)\n\n\tlines, err = ReadLongLines(q)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfor _, p := range lines {\n\t\tif IsExists(&t, &p) {\n\t\t\tfmt.Println(\"1\")\n\t\t} else {\n\t\t\tfmt.Println(\"0\")\n\t\t}\n\t}\n\t// for i := 0; i < q; i++ {\n\t// \tvar p string\n\t// \tfmt.Scanf(\"%s\", &p)\n\t// \tif IsExists(&t, &p) {\n\t// \t\tfmt.Println(\"1\")\n\t// \t} else {\n\t// \t\tfmt.Println(\"0\")\n\t// \t}\n\t// }\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"bufio\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar rdr = bufio.NewReaderSize(os.Stdin, 1000000)\n\nfunc readLine() string {\n\tbuf := make([]byte, 0, 1000000)\n\tfor {\n\t\tl, p, e := rdr.ReadLine()\n\t\tif e != nil {\n\t\t\tpanic(e)\n\t\t}\n\t\tbuf = append(buf, l...)\n\t\tif !p {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn string(buf)\n}\n\nfunc main() {\n\ttxt := readLine()\n\tn, _ := strconv.Atoi(readLine())\n\tpatterns := make([]string, 0)\n\tfor i := 0 ; i < n; i++ {\n\t\ttmp := readLine()\n\t\tpatterns = append(patterns, tmp)\n\t}\n\t// fmt.Println(matches)\n\tfor i := range patterns {\n\t\tif strings.Contains(txt, patterns[i]) {\n\t\t\tfmt.Println(1)\n\t\t} else {\n\t\t\tfmt.Println(0)\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "Go",
    "code": "\n// Rabin-Karp string search algorithm in Golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"bufio\"\n\t\"os\"\n\t\"strconv\"\n)\n\nconst base = 16777619\n\nfunc Search(txt string, patterns []string) []string {\n\tin := indices(txt, patterns)\n\tmatches := make([]string, len(in))\n\ti := 0\n\tfor j, p := range patterns {\n\t\tif _, ok := in[j]; ok {\n\t\t\tmatches[i] = p\n\t\t\ti++\n\t\t}\n\t}\n\n\treturn matches\n}\n\nfunc indices(txt string, patterns []string) map[int]int {\n\tn, m := len(txt), minLen(patterns)\n\tmatches := make(map[int]int)\n\n\tif n < m || len(patterns) == 0 {\n\t\treturn matches\n\t}\n\n\tvar mult uint32 = 1 // mult = base^(m-1)\n\tfor i := 0; i < m-1; i++ {\n\t\tmult = (mult * base)\n\t}\n\n\thp := hashPatterns(patterns, m)\n\th := hash(txt[:m])\n\tfor i := 0; i < n-m+1 && len(hp) > 0; i++ {\n\t\tif i > 0 {\n\t\t\th = h - mult*uint32(txt[i-1])\n\t\t\th = h*base + uint32(txt[i+m-1])\n\t\t}\n\n\t\tif mps, ok := hp[h]; ok {\n\t\t\tfor _, pi := range mps {\n\t\t\t\tpat := patterns[pi]\n\t\t\t\te := i + len(pat)\n\t\t\t\tif _, ok := matches[pi]; !ok && e <= n && pat == txt[i:e] {\n\t\t\t\t\tmatches[pi] = i\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn matches\n}\n\nfunc hash(s string) uint32 {\n\tvar h uint32\n\tfor i := 0; i < len(s); i++ {\n\t\th = (h*base + uint32(s[i]))\n\t}\n\treturn h\n}\n\nfunc hashPatterns(patterns []string, l int) map[uint32][]int {\n\tm := make(map[uint32][]int)\n\tfor i, t := range patterns {\n\t\th := hash(t[:l])\n\t\tif _, ok := m[h]; ok {\n\t\t\tm[h] = append(m[h], i)\n\t\t} else {\n\t\t\tm[h] = []int{i}\n\t\t}\n\t}\n\n\treturn m\n}\n\nfunc minLen(patterns []string) int {\n\tif len(patterns) == 0 {\n\t\treturn 0\n\t}\n\n\tm := len(patterns[0])\n\tfor i := range patterns {\n\t\tif m > len(patterns[i]) {\n\t\t\tm = len(patterns[i])\n\t\t}\n\t}\n\n\treturn m\n}\n\nvar rdr = bufio.NewReaderSize(os.Stdin, 1000000)\n\nfunc readLine() string {\n\tbuf := make([]byte, 0, 1000000)\n\tfor {\n\t\tl, p, e := rdr.ReadLine()\n\t\tif e != nil {\n\t\t\tpanic(e)\n\t\t}\n\t\tbuf = append(buf, l...)\n\t\tif !p {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn string(buf)\n}\n\nfunc main() {\n\ttxt := readLine()\n\tn, _ := strconv.Atoi(readLine())\n\tpatterns := make([]string, 0)\n\tfor i := 0 ; i < n; i++ {\n\t\ttmp := readLine()\n\t\tpatterns = append(patterns, tmp)\n\t}\n\tmatches := Search(txt, patterns)\n\t// fmt.Println(matches)\n\tfor i := range patterns {\n\t\tif inMatches(patterns[i], matches) {\n\t\t\tfmt.Println(1)\n\t\t} else {\n\t\t\tfmt.Println(0)\n\t\t}\n\t}\n}\n\nfunc inMatches(target string, matches []string) bool {\n\tfor i := range matches {\n\t\tif matches[i] == target {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"math\"\n)\n\n// ---\n// ref. Two Efficient Algorithms for Linear Time Suffix Array Construction\n// ---\n\ntype text []rune\n\n// ---\n// Define suffixArray\n// ---\n\ntype suffixArray []int\n\nfunc newSuffixArray(n int) suffixArray {\n\tsa := make(suffixArray, n)\n\tsa.init()\n\treturn sa\n}\n\nfunc (sa suffixArray) init() {\n\tfor i := 0; i < len(sa); i++ {\n\t\tsa[i] = -1\n\t}\n}\n\n// ---\n// Define buckets\n// ---\n\ntype buckets []int\n\n// ---\n// Define suffix type, S or L\n// ---\n\ntype suffixType bool\ntype suffixTypes []suffixType // true: S, false: L\nconst (\n\tS suffixType = true\n\tL suffixType = false\n)\n\nfunc (st suffixType) String() string {\n\tif (st) {\n\t\treturn \"S\"\n\t}  else {\n\t\treturn \"L\"\n\t}\n}\n\nfunc (sts suffixTypes) isLMS(i int) bool {\n\tif i == 0 {\n\t\treturn false\n\t}\n\treturn sts[i-1] == L && sts[i] == S\n}\n\n// Generate text from string.\n// This function adds sentinel at the end of text.\nfunc newTextFromString(raw string) text {\n\tn := len(raw)\n\ts := make(text, n+1) // +1 for sentinel\n\tfor i := 0; i < n; i++ {\n\t\ts[i] = rune(raw[i])\n\t}\n\ts[n] = 0\n\treturn s\n}\n\n// Generate text from []rune.\n// This function adds sentinel at the end of text.\nfunc newTextFromRunes(runes []rune) text {\n\tn := len(runes)\n\ts := make(text, n+1) // +1 for sentinel\n\tfor i := 0; i < n; i++ {\n\t\ts[i] = runes[i]\n\t}\n\ts[n] = 0\n\treturn s\n}\n\n// Generate text from []int.\n// This function does not add sentinel.\nfunc newTextFromInts(ints []int) text {\n\tn := len(ints)\n\ts := make(text, n)\n\tfor i := 0; i < n; i++ {\n\t\ts[i] = rune(ints[i])\n\t}\n\treturn s\n}\n\nfunc classifyTypes(s text) suffixTypes {\n\tn := len(s)\n\tt := make(suffixTypes, n) // all false(=L)\n\tt[n-1] = S // for sentinel\n\n\tfor i := n-2; i >= 0; i-- {\n\t\tprev := s[i+1]\n\t\tcurrent := s[i]\n\t\tif prev > current || (prev == current && t[i+1]) {\n\t\t\tt[i] = S\n\t\t}\n\t}\n\treturn t\n}\n\nfunc getBuckets(s text, charKinds int, end bool) buckets {\n\tn := len(s)\n\tbkt := make(buckets, charKinds+1)\n\tfor i := 0; i < n; i++ {\n\t\tbkt[s[i]]++\n\t}\n\tsize := bkt[0]\n\tbkt[0] = 0\n\tfor i := 1; i < len(bkt); i++ {\n\t\tif end {\n\t\t\tbkt[i] = bkt[i-1] + bkt[i]\n\t\t} else {\n\t\t\tbkt[i], size = bkt[i-1] + size, bkt[i]\n\t\t}\n\t}\n\treturn bkt\n}\n\nfunc induceSAl(sa suffixArray, s text, t suffixTypes, charKinds int) {\n\tn := len(s)\n\tbkt := getBuckets(s, charKinds, false)\n\tfor i := 0; i < n; i++ {\n\t\tif sa[i] > 0 && t[sa[i]-1] == L {\n\t\t\tsa[bkt[s[sa[i]-1]]] = sa[i]-1\n\t\t\tbkt[s[sa[i]-1]]++\n\t\t}\n\t}\n}\n\nfunc induceSAs(sa suffixArray, s text, t suffixTypes, charKinds int) {\n\tn := len(s)\n\tbkt := getBuckets(s, charKinds, true)\n\tfor i := n-1; i >= 0; i-- {\n\t\tif sa[i] > 0 && t[sa[i]-1] == S {\n\t\t\tsa[bkt[s[sa[i]-1]]] = sa[i]-1\n\t\t\tbkt[s[sa[i]-1]]--\n\t\t}\n\t}\n}\n\n// Construct suffix array by SA-IS algorithm.\n// Note that the last character of s should be sentinel(= 0).\nfunc SAIS(s text, charKinds int) suffixArray {\n\tn := len(s)\n\tt := classifyTypes(s)\n\n\t// ---\n\t// stage 1: reduce the problem size by at least 1/2\n\t// ---\n\n\tbkt := getBuckets(s, charKinds, true)\n\tsa := newSuffixArray(n)\n\tfor i := 1; i < n; i++ {\n\t\tif t.isLMS(i) {\n\t\t\tsa[bkt[s[i]]] = i\n\t\t\tbkt[s[i]]--\n\t\t}\n\t}\n\n\t// induce SAl\n\tinduceSAl(sa, s, t, charKinds)\n\n\t// induce SAs\n\tinduceSAs(sa, s, t, charKinds)\n\n\t// compact all the sorted LMS substrings\n\t// the number of the LMS is not bigger than 2/n\n\tn1 := 0\n\tfor i := 0; i < n; i++ {\n\t\tif t.isLMS(sa[i]) {\n\t\t\tsa[n1] = sa[i]\n\t\t\tn1++\n\t\t}\n\t}\n\n\t// find the lexicographic names of LMS substings\n\t// it is stored in the right end of SA\n\tfor i := n1; i < n; i++ {\n\t\tsa[i] = -1\n\t}\n\tname, prev := 0, -1\n\tfor i := 0; i < n1; i++ {\n\t\tpos := sa[i]\n\t\tdiff := false\n\t\tfor d := 0; d < n; d++ {\n\t\t\tif prev == -1 || s[pos+d] != s[prev+d] || t[pos+d] != t[prev+d] {\n\t\t\t\tdiff = true\n\t\t\t\tbreak\n\t\t\t} else if d > 0 && t.isLMS(pos+d) && t.isLMS(prev+d) {\n\t\t\t\t// TODO: (t.isLMS(pos+d) || t.isLMS(prev+d)) in the literature, but should use '&&'?\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif diff {\n\t\t\tname++\n\t\t\tprev = pos\n\t\t}\n\t\tpos = pos/2\n\t\tsa[n1+pos] = name-1\n\t}\n\tfor i, j := n-1, n-1; i >= n1; i-- {\n\t\tif sa[i] >= 0 {\n\t\t\tsa[j] = sa[i]\n\t\t\tj--\n\t\t}\n\t}\n\n\t// ---\n\t// stage 2: solve the reduced problem\n\t// recurse if names are not yet unique\n\t// ---\n\n\tsa1 := sa[:n1]\n\ts1 := sa[(n-n1):]\n\tif name < n1 {\n\t\tsa1 = SAIS(newTextFromInts(s1), name-1)\n\t} else {\n\t\tfor i := 0; i < n1; i++ {\n\t\t\tsa1[s1[i]] = i\n\t\t}\n\t}\n\n\t// ---\n\t// stage 3: induce the SA\n\t// ---\n\n\tp1 := make([]int, n1)\n\tfor i, j := 0, 0; i < n; i++ {\n\t\tif t.isLMS(i) {\n\t\t\tp1[j] = i\n\t\t\tj++\n\t\t}\n\t}\n\n\tfor i := 0; i < n1; i++ {\n\t\tsa1[i] = p1[sa1[i]]\n\t}\n\n\t// init sa\n\tfor i := n1; i < n; i++ {\n\t\tsa[i] = -1\n\t}\n\tbkt = getBuckets(s, charKinds, true)\n\tfor i := n1-1; i >= 0; i-- {\n\t\tj := sa1[i]\n\t\tsa[i] = -1\n\t\tsa[bkt[s[j]]] = j\n\t\tbkt[s[j]]--\n\t}\n\tinduceSAl(sa, s, t, charKinds)\n\tinduceSAs(sa, s, t, charKinds)\n\n\treturn sa\n}\n\nconst MAX_INPUT = 1000000\n\nfunc parseInput() (text, []string, error) {\n\tsc := bufio.NewScanner(os.Stdin)\n\tbuf := make([]byte, MAX_INPUT+1)\n\tsc.Buffer(buf, MAX_INPUT+1)\n\tsc.Split(bufio.ScanWords)\n\n\ttext := newTextFromString(nextText(sc))\n\n\tn, err := nextInt(sc)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tquery := make([]string, n)\n\tfor i := 0; i < n; i++ {\n\t\tquery[i] = nextText(sc)\n\t}\n\n\treturn text, query, nil\n}\n\nfunc nextText(sc *bufio.Scanner) string {\n\tsc.Scan()\n\treturn sc.Text()\n}\n\nfunc nextInt(sc *bufio.Scanner) (int, error) {\n\treturn strconv.Atoi(nextText(sc))\n}\n\n/*\nReturn 0 if prefix is at the beginning of text.\nIf not, return 1 or -1 comparing strings.\n*/\nfunc comparePrefix(text []rune, prefix []rune) int {\n\tfor i := 0; i < len(prefix); i++ {\n\t\tif text[i] < prefix[i] {\n\t\t\treturn 1\n\t\t} else if text[i] > prefix[i] {\n\t\t\treturn -1\n\t\t}\n\t}\n\treturn 0\n}\n\nfunc binarySearch(key []rune, sa []int, text text) bool {\n\ts := 0\n\te := len(sa) - 1\n\tm := (e + s) / 2\n\tfor s <= e {\n\t\tsuffix := text[sa[m]:]\n\t\tswitch comparePrefix(suffix, key) {\n\t\tcase 0:\n\t\t\treturn true\n\t\tcase 1:\n\t\t\ts = m + 1\n\t\tcase -1:\n\t\t\te = m - 1\n\t\t}\n\t\tm = (e + s) / 2\n\t}\n\treturn false\n}\n\nfunc main() {\n\ttext, query, err := parseInput()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tsa := SAIS(text, math.MaxUint8)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// fmt.Println(query)\n\t// fmt.Println(sa)\n\n\tresult := make([]string, len(query))\n\tfor i, q := range query {\n\t\tif binarySearch([]rune(q), sa, text) {\n\t\t\tresult[i] = \"1\"\n\t\t} else {\n\t\t\tresult[i] = \"0\"\n\t\t}\n\t}\n\tfmt.Println(strings.Join(result, \"\\n\"))\n}\n"
  },
  {
    "language": "PHP",
    "code": "<?php  \n$target = trim(fgets(STDIN));\n$q = trim(fgets(STDIN));\n\nfor ($i=0; $i < $q; $i++){ \n\t$pattern = trim(fgets(STDIN));\n\tif(preg_match(\"/$pattern/\", $target)){\n\t\techo \"1\\n\";\n\t}else{\n\t\techo \"0\\n\";\n\t}\n}\n\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php  \n$target = trim(fgets(STDIN));\n$q = trim(fgets(STDIN));\n\nfor ($i=0; $i < $q; $i++){ \n\t$pattern = trim(fgets(STDIN));\n\t$out = preg_match(\"/$pattern/\", $target) ? 1 : 0;\n\techo \"$out\\n\";\n}\n?>\n"
  },
  {
    "language": "OCaml",
    "code": "let make_suffix_array t n =\n  let ord = Array.make (n + 1) (-1) in\n  String.iteri (fun i e -> ord.(i) <- Char.code e) t;\n  let sa = Array.init (n + 1) (fun i -> i) in\n  let rec doit k =\n    if k > n then sa\n    else begin\n      let cmp a b =\n        if ord.(a) <> ord.(b) then ord.(a) - ord.(b)\n        else (if a + k <= n then ord.(a+k) else 0) - (if b + k <= n then ord.(b+k) else 0) in\n      Array.sort cmp sa;\n      let tmp = Array.make (n + 1) 0 in\n      let rec aux i =\n        if i <= n then begin\n          tmp.(sa.(i)) <- tmp.(sa.(i-1)) + (if cmp sa.(i-1) sa.(i) < 0 then 1 else 0);\n          aux (i + 1)\n        end in\n      aux 1;\n      Array.iteri (fun i e -> ord.(i) <- e) tmp;\n      doit (k * 2)\n    end in\n  doit 1\n\nlet () =\n  let t = read_line () in\n  let n = String.length t in\n  let sa = make_suffix_array t n in\n  let q = read_int () in\n  let rec doit i =\n    if i < q then begin\n      let p = read_line () in\n      let rec aux l r =\n        if l >= r then r\n        else begin\n          let m = (l + r) / 2 in\n          if compare (String.sub t sa.(m) (n - sa.(m))) p < 0 then aux (m + 1) r\n          else aux l m\n        end in\n      let r = aux 0 n in\n      Printf.printf \"%d\\n\" (if compare (String.sub t sa.(r) (n - sa.(r))) p >= 0 then 1 else 0);\n      doit (i + 1)\n    end in\n  doit 0"
  },
  {
    "language": "OCaml",
    "code": "exception Not_equal of int\n\nlet cmp_sa rank a b n k =\n  if rank.(a) <> rank.(b) then compare rank.(a) rank.(b)\n  else\n    compare\n      (if a + k <= n then rank.(a+k) else (-1))\n      (if b + k <= n then rank.(b+k) else (-1))\n\nlet construct_sa t n =\n  let sa = Array.make (n + 1) 0 in\n  let rank = Array.make (n + 1) 0 in\n  let tmp = Array.make (n + 1) 0 in\n  for i = 0 to n - 1 do\n    sa.(i) <- i;\n    rank.(i) <- Char.code t.[i];\n  done;\n  sa.(n) <- n;\n  rank.(n) <- (-1);\n  let k = ref 1 in\n  while !k <= n do\n    Array.sort (fun a b -> cmp_sa rank a b n !k) sa;\n    tmp.(sa.(0)) <- 0;\n    for i = 1 to n do\n      tmp.(sa.(i)) <-\n        tmp.(sa.(i-1)) + (if cmp_sa rank sa.(i-1) sa.(i) n !k = (-1) then 1 else 0);\n    done;\n    for i = 0 to n do rank.(i) <- tmp.(i) done;\n    k := !k * 2;\n  done;\n  sa\n\nlet range_cmp t n offset p k =\n  let m = n - offset in\n  let m = if m < k then m else k in\n  try\n    for i = 0 to m - 1 do\n      if t.[i+offset] <> p.[i] then\n        raise (Not_equal (Char.code t.[i+offset] - Char.code p.[i]));\n    done;\n    if m = k then 0\n    else (- Char.code p.[m])\n  with Not_equal i -> i\n\nlet () =\n  let t = read_line () in\n  let n = String.length t in\n  let sa = construct_sa t n in\n  let q = read_int () in\n  for _ = 0 to q - 1 do\n    let p = read_line () in\n    let k = String.length p in\n    let l = ref 0 in\n    let r = ref (n + 1) in\n    while !l + 1 < !r do\n      let m = (!l + !r) / 2 in\n      let ret = range_cmp t n sa.(m) p k in\n      if ret <= 0 then l := m\n      else r := m;\n    done;\n    Printf.printf \"%d\\n\" (if range_cmp t n sa.(!l) p k = 0 then 1 else 0);\n  done"
  },
  {
    "language": "OCaml",
    "code": "exception Not_equal of int\n\nlet rank = Array.make 1000000 0\nlet tmp = Array.make 1000000 0\n\nlet cmp_sa rank a b n k =\n  if rank.(a) <> rank.(b) then compare rank.(a) rank.(b)\n  else\n    compare\n      (if a + k <= n then rank.(a+k) else (-1))\n      (if b + k <= n then rank.(b+k) else (-1))\n\nlet construct_sa t n =\n  let sa = Array.make (n + 1) 0 in\n  for i = 0 to n - 1 do\n    sa.(i) <- i;\n    rank.(i) <- Char.code t.[i];\n  done;\n  sa.(n) <- n;\n  rank.(n) <- (-1);\n  let k = ref 1 in\n  while !k <= n do\n    Array.sort (fun a b -> cmp_sa rank a b n !k) sa;\n    tmp.(sa.(0)) <- 0;\n    for i = 1 to n do\n      tmp.(sa.(i)) <-\n        tmp.(sa.(i-1)) + (if cmp_sa rank sa.(i-1) sa.(i) n !k = (-1) then 1 else 0);\n    done;\n    for i = 0 to n do rank.(i) <- tmp.(i) done;\n    k := !k * 2;\n  done;\n  sa\n\nlet range_cmp t n offset p k =\n  let m = n - offset in\n  let m = if m < k then m else k in\n  try\n    for i = 0 to m - 1 do\n      if t.[i+offset] <> p.[i] then\n        raise (Not_equal (compare t.[i+offset] p.[i]));\n    done;\n    if m = k then 0\n    else (-1)\n  with Not_equal i -> i\n\nlet () =\n  let t = read_line () in\n  let n = String.length t in\n  let sa = construct_sa t n in\n  let q = read_int () in\n  for _ = 0 to q - 1 do\n    let p = read_line () in\n    let k = String.length p in\n    let l = ref 0 in\n    let r = ref (n + 1) in\n    while !l + 1 < !r do\n      let m = (!l + !r) / 2 in\n      let ret = range_cmp t n sa.(m) p k in\n      if ret <= 0 then l := m\n      else r := m;\n    done;\n    Printf.printf \"%d\\n\" (if range_cmp t n sa.(!l) p k = 0 then 1 else 0);\n  done"
  },
  {
    "language": "OCaml",
    "code": "exception Not_equal of int\n\nlet rank = Array.make 1000005 0\nlet tmp = Array.make 1000005 0\n\nlet cmp_sa rank a b n k =\n  if rank.(a) <> rank.(b) then compare rank.(a) rank.(b)\n  else\n    compare\n      (if a + k <= n then rank.(a+k) else (-1))\n      (if b + k <= n then rank.(b+k) else (-1))\n\nlet construct_sa t n =\n  let sa = Array.make (n + 1) 0 in\n  for i = 0 to n - 1 do\n    sa.(i) <- i;\n    rank.(i) <- Char.code t.[i];\n  done;\n  sa.(n) <- n;\n  rank.(n) <- (-1);\n  let k = ref 1 in\n  while !k <= n do\n    Array.sort (fun a b -> cmp_sa rank a b n !k) sa;\n    tmp.(sa.(0)) <- 0;\n    for i = 1 to n do\n      tmp.(sa.(i)) <-\n        tmp.(sa.(i-1)) + (if cmp_sa rank sa.(i-1) sa.(i) n !k = (-1) then 1 else 0);\n    done;\n    for i = 0 to n do rank.(i) <- tmp.(i) done;\n    k := !k * 2;\n  done;\n  sa\n\nlet range_cmp t n offset p k =\n  let m = n - offset in\n  let m = if m < k then m else k in\n  try\n    for i = 0 to m - 1 do\n      if t.[i+offset] <> p.[i] then\n        raise (Not_equal (compare t.[i+offset] p.[i]));\n    done;\n    if m = k then 0\n    else (-1)\n  with Not_equal i -> i\n\nlet () =\n  let t = read_line () in\n  let n = String.length t in\n  let sa = construct_sa t n in\n  let q = read_int () in\n  for _ = 0 to q - 1 do\n    let p = read_line () in\n    let k = String.length p in\n    let l = ref 0 in\n    let r = ref (n + 1) in\n    while !l + 1 < !r do\n      let m = (!l + !r) / 2 in\n      let ret = range_cmp t n sa.(m) p k in\n      if ret <= 0 then l := m\n      else r := m;\n    done;\n    Printf.printf \"%d\\n\" (if range_cmp t n sa.(!l) p k = 0 then 1 else 0);\n  done"
  },
  {
    "language": "OCaml",
    "code": "exception Not_equal of int\n\nlet cmp_sa rank a b n k =\n  if rank.(a) <> rank.(b) then compare rank.(a) rank.(b)\n  else\n    compare\n      (if a + k <= n then rank.(a+k) else (-1))\n      (if b + k <= n then rank.(b+k) else (-1))\n\nlet construct_sa t n =\n  let sa = Array.make (n + 1) 0 in\n  let rank = Array.make (n + 1) 0 in\n  let tmp = Array.make (n + 1) 0 in\n  for i = 0 to n - 1 do\n    sa.(i) <- i;\n    rank.(i) <- Char.code t.[i];\n  done;\n  sa.(n) <- n;\n  rank.(n) <- (-1);\n  let rec doit k =\n    if k > n then ()\n    else begin\n      Array.fast_sort (fun a b -> cmp_sa rank a b n k) sa;\n      tmp.(sa.(0)) <- 0;\n      for i = 1 to n do\n        tmp.(sa.(i)) <-\n          tmp.(sa.(i-1)) + (if cmp_sa rank sa.(i-1) sa.(i) n k = (-1) then 1 else 0);\n      done;\n      for i = 0 to n do rank.(i) <- tmp.(i) done;\n      doit (2 * k)\n    end in\n  doit 1;\n  sa\n\nlet range_cmp t n offset p k =\n  let m = n - offset in\n  let m = if m < k then m else k in\n  try\n    for i = 0 to m - 1 do\n      if t.[i+offset] <> p.[i] then\n        raise (Not_equal (compare t.[i+offset] p.[i]));\n    done;\n    if m = k then 0\n    else (-1)\n  with Not_equal i -> i\n\nlet () =\n  let t = read_line () in\n  let n = String.length t in\n  let sa = construct_sa t n in\n  let q = read_int () in\n  for _ = 0 to q - 1 do\n    let p = read_line () in\n    let k = String.length p in\n    let rec doit l r =\n      if r - l <= 1 then l\n      else\n        let m = (l + r) / 2 in\n        if range_cmp t n sa.(m) p k <= 0 then doit m r\n        else doit l m in\n    let l = doit 0 (n + 1) in\n    Printf.printf \"%d\\n\" (if range_cmp t n sa.(l) p k = 0 then 1 else 0);\n  done"
  },
  {
    "language": "OCaml",
    "code": "exception Not_equal of int\n\nlet cmp_sa rank a b n k =\n  if rank.(a) <> rank.(b) then compare rank.(a) rank.(b)\n  else\n    compare\n      (if a + k <= n then rank.(a+k) else (-1))\n      (if b + k <= n then rank.(b+k) else (-1))\n\nlet construct_sa t n =\n  let sa = Array.make (n + 1) 0 in\n  let rank = Array.make (n + 1) 0 in\n  let tmp = Array.make (n + 1) 0 in\n  for i = 0 to n - 1 do\n    sa.(i) <- i;\n    rank.(i) <- Char.code t.[i];\n  done;\n  sa.(n) <- n;\n  rank.(n) <- (-1);\n  let k = ref 1 in\n  while !k <= n do\n    Array.sort (fun a b -> cmp_sa rank a b n !k) sa;\n    tmp.(sa.(0)) <- 0;\n    for i = 1 to n do\n      tmp.(sa.(i)) <- tmp.(sa.(i-1)) + cmp_sa rank sa.(i-1) sa.(i) n !k;\n    done;\n    for i = 1 to n do\n      tmp.(sa.(i)) <- -tmp.(sa.(i));\n    done;\n    for i = 0 to n do rank.(i) <- tmp.(i) done;\n    k := !k * 2;\n  done;\n  sa\n\nlet range_cmp t n offset p k =\n  if n - offset < k then (-1)\n  else\n    try\n      for i = 0 to k - 1 do\n        if t.[i+offset] <> p.[i] then\n          raise (Not_equal (compare t.[i+offset] p.[i]));\n      done;\n      0\n    with Not_equal i -> i\n\nlet () =\n  let t = read_line () in\n  let n = String.length t in\n  let sa = construct_sa t n in\n  let q = read_int () in\n  for _ = 0 to q - 1 do\n    let p = read_line () in\n    let k = String.length p in\n    let l = ref 0 in\n    let r = ref (n + 1) in\n    while !l + 1 < !r do\n      let m = (!l + !r) / 2 in\n      let ret = range_cmp t n sa.(m) p k in\n      if ret <= 0 then l := m\n      else r := m;\n    done;\n    Printf.printf \"%d\\n\" (if range_cmp t n sa.(!l) p k = 0 then 1 else 0);\n  done"
  },
  {
    "language": "OCaml",
    "code": "let tails s =\n  let l = String.length s in\n  let a = Array.init (l+1) (fun i -> if i = l then \"\" else String.sub s i (l-i)) in\n  Array.sort compare a; a\n\nlet string_search a p =\n  let al = Array.length a in\n  let pl = String.length p in\n  let rec iter l r =\n    if r - l <= 1 then\n      try if String.sub a.(r) 0 pl = p then 1 else 0 with _ -> 0\n    else\n      let m = (l + r) / 2 in\n      if a.(m) = p then 1\n      else if a.(m) > p then iter l m else iter m r\n  in\n  iter 0 al\n       \nlet () =\n  let t = read_line () in\n  let ta = tails t in\n  let q = read_int () in\n  let rec loop x =\n    if x = 0 then ()\n    else let p = read_line () in\n         string_search ta p |> string_of_int |> print_endline;\n         loop (x-1)\n  in loop q"
  },
  {
    "language": "OCaml",
    "code": "exception Not_equal of int\n\nlet cmp_sa rank a b n k =\n  if rank.(a) <> rank.(b) then compare rank.(a) rank.(b)\n  else\n    compare\n      (if a + k <= n then rank.(a+k) else (-1))\n      (if b + k <= n then rank.(b+k) else (-1))\n\nlet construct_sa t n =\n  let sa = Array.make (n + 1) 0 in\n  let rank = Array.make (n + 1) 0 in\n  let tmp = Array.make (n + 1) 0 in\n  for i = 0 to n - 1 do\n    sa.(i) <- i;\n    rank.(i) <- Char.code t.[i];\n  done;\n  sa.(n) <- n;\n  rank.(n) <- (-1);\n  let k = ref 1 in\n  while !k <= n do\n    Array.sort (fun a b -> cmp_sa rank a b n !k) sa;\n    tmp.(sa.(0)) <- 0;\n    for i = 1 to n do\n      tmp.(sa.(i)) <- tmp.(sa.(i-1)) + cmp_sa rank sa.(i-1) sa.(i) n !k;\n    done;\n    for i = 0 to n do rank.(i) <- tmp.(i) done;\n    k := !k * 2;\n  done;\n  sa\n\nlet range_cmp t n offset p k =\n  try\n    for i = 0 to k - 1 do\n      if t.[i+offset] <> p.[i] then\n        raise (Not_equal (compare t.[i+offset] p.[i]));\n    done;\n    0\n  with Not_equal i -> i\n\nlet () =\n  let t = read_line () in\n  let n = String.length t in\n  let sa = construct_sa t n in\n  let q = read_int () in\n  for _ = 0 to q - 1 do\n    let p = read_line () in\n    let k = String.length p in\n    let l = ref 0 in\n    let r = ref (n + 1) in\n    while !l + 1 < !r do\n      let m = (!l + !r) / 2 in\n      let ret = range_cmp t n sa.(m) p k in\n      if ret <= 0 then l := m\n      else r := m;\n    done;\n    Printf.printf \"%d\\n\" (if range_cmp t n sa.(!l) p k = 0 then 1 else 0);\n  done"
  },
  {
    "language": "OCaml",
    "code": "exception Not_equal of int\n\nlet cmp_sa rank a b n k =\n  if rank.(a) <> rank.(b) then compare rank.(a) rank.(b)\n  else\n    compare\n      (if a + k <= n then rank.(a+k) else (-1))\n      (if b + k <= n then rank.(b+k) else (-1))\n\nlet construct_sa t n =\n  let sa = Array.make (n + 1) 0 in\n  let rank = Array.make (n + 1) 0 in\n  let tmp = Array.make (n + 1) 0 in\n  for i = 0 to n - 1 do\n    sa.(i) <- i;\n    rank.(i) <- Char.code t.[i];\n  done;\n  sa.(n) <- n;\n  rank.(n) <- (-1);\n  let k = ref 1 in\n  while !k <= n do\n    Array.sort (fun a b -> cmp_sa rank a b n !k) sa;\n    tmp.(sa.(0)) <- 0;\n    for i = 1 to n do\n      tmp.(sa.(i)) <-\n        tmp.(sa.(i-1)) + (if cmp_sa rank sa.(i-1) sa.(i) n !k = (-1) then 1 else 0);\n    done;\n    for i = 0 to n do rank.(i) <- tmp.(i) done;\n    k := !k * 2;\n  done;\n  sa\n\nlet range_cmp t n offset p k =\n  let m = n - offset in\n  let m = if m < k then m else k in\n  try\n    for i = 0 to m - 1 do\n      if t.[i+offset] <> p.[i] then\n        raise (Not_equal (compare t.[i+offset] p.[i]));\n    done;\n    if m = k then 0\n    else (-1)\n  with Not_equal i -> i\n\nlet () =\n  let t = read_line () in\n  let n = String.length t in\n  let sa = construct_sa t n in\n  let q = read_int () in\n  for _ = 0 to q - 1 do\n    let p = read_line () in\n    let k = String.length p in\n    let l = ref 0 in\n    let r = ref (n + 1) in\n    while !l + 1 < !r do\n      let m = (!l + !r) / 2 in\n      let ret = range_cmp t n sa.(m) p k in\n      if ret <= 0 then l := m\n      else r := m;\n    done;\n    Printf.printf \"%d\\n\" (if range_cmp t n sa.(!l) p k = 0 then 1 else 0);\n  done"
  },
  {
    "language": "OCaml",
    "code": "let id x = x\n             \nlet string_search s p =\n  let sl = String.length s in\n  let pl = String.length p in\n  let sa = Array.init (sl+1) id in\n  let rank = Array.init (sl+1) (fun i -> if i = sl then (-1) else Char.code s.[i]) in\n  let cmp k i j =\n    if rank.(i) = rank.(j) then\n      let rik = if i + k <= sl then rank.(i+k) else (-1) in\n      let rjk = if j + k <= sl then rank.(j+k) else (-1) in\n      rik - rjk\n    else rank.(i) - rank.(j) in\n  let ra_rank k =\n    let ta = Array.make (sl+1) 0 in\n    let rec iter i =\n      if i > sl then ()\n      else begin\n          ta.(sa.(i)) <- ta.(sa.(i-1)) + (if cmp k sa.(i) sa.(i-1) > 0 then 1 else 0);\n          iter (i+1)\n        end in\n    let rec copy i =\n      if i > sl then ()\n      else begin\n          rank.(i) <- ta.(i);\n          copy (i+1)\n        end in\n    iter 1;\n    copy 0 in\n  let rec sort_sa k =\n    if k > sl then ()\n    else begin\n        Array.sort (cmp k) sa;\n        ra_rank k;\n        sort_sa (2 * k)\n      end in\n  let rec search l r =\n    if r - l <= 1 then\n      try String.sub s sa.(r) pl = p with _ -> false\n    else\n      let m = (l + r) / 2 in\n      match compare (String.sub s sa.(m) (min pl (sl - sa.(m)))) p with\n        0 -> true\n      | x when x < 0 -> search m r\n      | _ -> search l m\n  in\n  sort_sa 1;\n  search 0 (sl+1)\n      \nlet () =\n  let t = read_line () in\n  let q = read_int () in\n  let rec loop x =\n    if x = 0 then ()\n    else let p = read_line () in\n         (if string_search t p then \"1\" else \"0\") |> print_endline;\n         loop (x-1)\n  in loop q"
  },
  {
    "language": "OCaml",
    "code": "let id x = x\n             \nlet make_sa s =\n  let sl = String.length s in\n  let sa = Array.init (sl+1) id in\n  let rank = Array.init (sl+1) (fun i -> if i = sl then (-1) else Char.code s.[i]) in\n  let cmp k i j =\n    if rank.(i) = rank.(j) then\n      let rik = if i + k <= sl then rank.(i+k) else (-1) in\n      let rjk = if j + k <= sl then rank.(j+k) else (-1) in\n      rik - rjk\n    else rank.(i) - rank.(j) in\n  let ra_rank k =\n    let ta = Array.make (sl+1) 0 in\n    let rec iter i =\n      if i > sl then ()\n      else begin\n          ta.(sa.(i)) <- ta.(sa.(i-1)) + (if cmp k sa.(i) sa.(i-1) > 0 then 1 else 0);\n          iter (i+1)\n        end in\n    let rec copy i =\n      if i > sl then ()\n      else begin\n          rank.(i) <- ta.(i);\n          copy (i+1)\n        end in\n    iter 1;\n    copy 0 in\n  let rec sort_sa k =\n    if k > sl then ()\n    else begin\n        Array.sort (cmp k) sa;\n        ra_rank k;\n        sort_sa (2 * k)\n      end in\n  sort_sa 1; sa\n\nlet string_search sa s p =\n  let sl = String.length s in\n  let pl = String.length p in\n  let rec search l r =\n    if r - l <= 1 then\n      try String.sub s sa.(r) pl = p with _ -> false\n    else\n      let m = (l + r) / 2 in\n      match compare (String.sub s sa.(m) (min pl (sl - sa.(m)))) p with\n        0 -> true\n      | x when x < 0 -> search m r\n      | _ -> search l m\n  in\n  search 0 (sl+1)\n\nlet () =\n  let t = read_line () in\n  let q = read_int () in\n  let sa = make_sa t in\n  let rec loop x =\n    if x = 0 then ()\n    else let p = read_line () in\n         (if string_search sa t p then \"1\" else \"0\") |> print_endline;\n         loop (x-1)\n  in loop q"
  },
  {
    "language": "OCaml",
    "code": "exception Not_equal of int\n\nlet rank = Array.make 1000001 0\nlet tmp = Array.make 1000001 0\n\nlet cmp_sa rank a b n k =\n  if rank.(a) <> rank.(b) then compare rank.(a) rank.(b)\n  else\n    compare\n      (if a + k <= n then rank.(a+k) else (-1))\n      (if b + k <= n then rank.(b+k) else (-1))\n\nlet construct_sa t n =\n  let sa = Array.make (n + 1) 0 in\n  for i = 0 to n - 1 do\n    sa.(i) <- i;\n    rank.(i) <- Char.code t.[i];\n  done;\n  sa.(n) <- n;\n  rank.(n) <- (-1);\n  let rec doit k =\n    if k > n then ()\n    else begin\n      Array.sort (fun a b -> cmp_sa rank a b n k) sa;\n      tmp.(sa.(0)) <- 0;\n      for i = 1 to n do\n        tmp.(sa.(i)) <-\n          tmp.(sa.(i-1)) + (if cmp_sa rank sa.(i-1) sa.(i) n k = (-1) then 1 else 0);\n      done;\n      for i = 0 to n do rank.(i) <- tmp.(i) done;\n      doit (2 * k)\n    end in\n  doit 1;\n  sa\n\nlet range_cmp t n offset p k =\n  let m = n - offset in\n  let m = if m < k then m else k in\n  try\n    for i = 0 to m - 1 do\n      if t.[i+offset] <> p.[i] then\n        raise (Not_equal (compare t.[i+offset] p.[i]));\n    done;\n    if m = k then 0\n    else (-1)\n  with Not_equal i -> i\n\nlet () =\n  let t = read_line () in\n  let n = String.length t in\n  let sa = construct_sa t n in\n  let q = read_int () in\n  for _ = 0 to q - 1 do\n    let p = read_line () in\n    let k = String.length p in\n    let rec doit l r =\n      if r - l <= 1 then l\n      else\n        let m = (l + r) / 2 in\n        if range_cmp t n sa.(m) p k <= 0 then doit m r\n        else doit l m in\n    let l = doit 0 (n + 1) in\n    Printf.printf \"%d\\n\" (if range_cmp t n sa.(l) p k = 0 then 1 else 0);\n  done"
  },
  {
    "language": "OCaml",
    "code": "exception Not_equal of int\n\nlet rank = Array.make 1000001 0\nlet tmp = Array.make 1000001 0\n\nlet cmp_sa rank a b n k =\n  if rank.(a) <> rank.(b) then compare rank.(a) rank.(b)\n  else\n    compare\n      (if a + k <= n then rank.(a+k) else (-1))\n      (if b + k <= n then rank.(b+k) else (-1))\n\nlet construct_sa t n =\n  let sa = Array.make (n + 1) 0 in\n  for i = 0 to n - 1 do\n    sa.(i) <- i;\n    rank.(i) <- Char.code t.[i];\n  done;\n  sa.(n) <- n;\n  rank.(n) <- (-1);\n  let rec doit k =\n    if k > n then ()\n    else begin\n      Array.fast_sort (fun a b -> cmp_sa rank a b n k) sa;\n      tmp.(sa.(0)) <- 0;\n      for i = 1 to n do\n        tmp.(sa.(i)) <-\n          tmp.(sa.(i-1)) + (if cmp_sa rank sa.(i-1) sa.(i) n k = (-1) then 1 else 0);\n      done;\n      for i = 0 to n do rank.(i) <- tmp.(i) done;\n      doit (2 * k)\n    end in\n  doit 1;\n  sa\n\nlet range_cmp t n offset p k =\n  let m = n - offset in\n  let m = if m < k then m else k in\n  try\n    for i = 0 to m - 1 do\n      if t.[i+offset] <> p.[i] then\n        raise (Not_equal (compare t.[i+offset] p.[i]));\n    done;\n    if m = k then 0\n    else (-1)\n  with Not_equal i -> i\n\nlet () =\n  let t = read_line () in\n  let n = String.length t in\n  let sa = construct_sa t n in\n  let q = read_int () in\n  for _ = 0 to q - 1 do\n    let p = read_line () in\n    let k = String.length p in\n    let rec doit l r =\n      if r - l <= 1 then l\n      else\n        let m = (l + r) / 2 in\n        if range_cmp t n sa.(m) p k <= 0 then doit m r\n        else doit l m in\n    let l = doit 0 (n + 1) in\n    Printf.printf \"%d\\n\" (if range_cmp t n sa.(l) p k = 0 then 1 else 0);\n  done"
  },
  {
    "language": "OCaml",
    "code": "let make_suffix_array t n =\n  let ord = Array.make (n + 1) (-1) in\n  String.iteri (fun i e -> ord.(i) <- Char.code e) t;\n  let sa = Array.init (n + 1) (fun i -> i) in\n  let rec doit k =\n    if k > n then sa\n    else begin\n      let cmp a b =\n        if ord.(a) <> ord.(b) then ord.(a) - ord.(b)\n        else (if a + k <= n then ord.(a+k) else 0) - (if b + k <= n then ord.(b+k) else 0) in\n      Array.sort cmp sa;\n      let tmp = Array.make (n + 1) 0 in\n      let rec aux i =\n        if i <= n then begin\n          tmp.(sa.(i)) <- tmp.(sa.(i-1)) + (if cmp sa.(i-1) sa.(i) < 0 then 1 else 0);\n          aux (i + 1)\n        end in\n      aux 1;\n      Array.iteri (fun i e -> ord.(i) <- e) tmp;\n      doit (k * 2)\n    end in\n  doit 1\n\nlet () =\n  let t = read_line () in\n  let n = String.length t in\n  let sa = make_suffix_array t n in\n  let q = read_int () in\n  let rec doit i =\n    if i < q then begin\n      let p = read_line () in\n      let rec aux l r =\n        if l >= r then r\n        else begin\n          let m = (l + r) / 2 in\n          if compare (String.sub t sa.(m) (n - sa.(m))) p < 0 then aux (m + 1) r\n          else aux l m\n        end in\n      let r = aux 0 n in\n      begin match\n        try Some (Str.search_forward (Str.regexp p) t sa.(r)) with _ -> None\n      with\n      | None -> Printf.printf \"0\\n\"\n      | _ -> Printf.printf \"1\\n\"\n      end;\n      doit (i + 1)\n    end in\n  doit 0"
  },
  {
    "language": "OCaml",
    "code": "let pn = 1000000007\n\nlet pow x n =\n  let rec doit x n acc =\n    if n = 0 then acc\n    else if n mod 2 = 0 then doit (x * x) (n / 2) acc\n    else doit (x * x) (n / 2) (acc * x) in\n  doit x n 1\n\nlet fold_left f init s n =\n  let rec doit i acc =\n    if i = n then acc\n    else doit (i + 1) (f acc s.[i]) in\n  doit 0 init\n\nlet () =\n  let t = read_line () in\n  let n = String.length t in\n  let h = Array.make (n + 1) 0 in\n  let hash x c = x * pn + Char.code c in\n  String.iteri (fun i c -> h.(i+1) <- hash h.(i) c) t;\n  let include_p p =\n    let m = String.length p in\n    let v = fold_left hash 0 p m in\n    let x = pow pn m in\n    try\n      for i = 0 to n - m do\n        if h.(i+m) - h.(i)*x = v then raise Exit\n      done;\n      false\n    with Exit -> true in\n  let q = read_int () in\n  for _ = 0 to q - 1 do\n    Printf.printf \"%d\\n\" (if read_line () |> include_p then 1 else 0);\n  done"
  },
  {
    "language": "OCaml",
    "code": "let pn = 1000000007\n\nlet make_suffix_array t n =\n  let ord = Array.make (n + 1) (-1) in\n  String.iteri (fun i e -> ord.(i) <- Char.code e) t;\n  let sa = Array.init (n + 1) (fun i -> i) in\n  let rec doit k =\n    if k > n then sa\n    else begin\n      let cmp a b =\n        if ord.(a) <> ord.(b) then ord.(a) - ord.(b)\n        else (if a + k <= n then ord.(a+k) else 0) - (if b + k <= n then ord.(b+k) else 0) in\n      Array.sort cmp sa;\n      let tmp = Array.make (n + 1) 0 in\n      let rec aux i =\n        if i <= n then begin\n          tmp.(sa.(i)) <- tmp.(sa.(i-1)) + (if cmp sa.(i-1) sa.(i) < 0 then 1 else 0);\n          aux (i + 1)\n        end in\n      aux 1;\n      Array.iteri (fun i e -> ord.(i) <- e) tmp;\n      doit (k * 2)\n    end in\n  doit 1\n\nlet pow x n =\n  let rec doit i acc =\n    if i = n then acc\n    else doit (i + 1) (acc*x) in\n  doit 0 1\n\nlet str_fold_left f init s =\n  let n = String.length s in\n  let rec doit i acc =\n    if i = n then acc\n    else doit (i + 1) (f acc s.[i]) in\n  doit 0 init\n\nlet contain_p x y =\n  let n = String.length x in\n  let m = String.length y in\n  let h = Array.make (n + 1) 0 in\n  String.iteri (fun i c -> h.(i+1) <- h.(i)*pn + Char.code c) x;\n  let ht = str_fold_left (fun acc c -> acc*pn + Char.code c) 0 y in\n  let x = pow pn m in\n  let rec doit i =\n    if i > n then false\n    else if h.(i) - h.(i-m)*x = ht then true\n    else doit (i + 1) in\n  doit m\n\nlet () =\n  let t = read_line () in\n  let n = String.length t in\n  let sa = make_suffix_array t n in\n  let q = read_int () in\n  let rec doit i =\n    if i < q then begin\n      let p = read_line () in\n      let rec aux l r =\n        if l >= r then r\n        else begin\n          let m = (l + r) / 2 in\n          if compare (String.sub t sa.(m) (n - sa.(m))) p < 0 then aux (m + 1) r\n          else aux l m\n        end in\n      let r = aux 0 n in\n      Printf.printf \"%d\\n\" (if contain_p (String.sub t sa.(r) (if n - sa.(r) - (String.length p) >= 0 then String.length p else n - sa.(r))) p then 1 else 0);\n      doit (i + 1)\n    end in\n  doit 0"
  },
  {
    "language": "OCaml",
    "code": "exception Not_equal of int\n\nlet cmp_sa rank a b n k =\n  if rank.(a) <> rank.(b) then compare rank.(a) rank.(b)\n  else\n    compare\n      (if a + k <= n then rank.(a+k) else (-1))\n      (if b + k <= n then rank.(b+k) else (-1))\n\nlet construct_sa t n =\n  let sa = Array.make (n + 1) 0 in\n  let rank = Array.make (n + 1) 0\n  let tmp = Array.make (n + 1) 0\n  for i = 0 to n - 1 do\n    sa.(i) <- i;\n    rank.(i) <- Char.code t.[i];\n  done;\n  sa.(n) <- n;\n  rank.(n) <- (-1);\n  let rec doit k =\n    if k > n then ()\n    else begin\n      Array.fast_sort (fun a b -> cmp_sa rank a b n k) sa;\n      tmp.(sa.(0)) <- 0;\n      for i = 1 to n do\n        tmp.(sa.(i)) <-\n          tmp.(sa.(i-1)) + (if cmp_sa rank sa.(i-1) sa.(i) n k = (-1) then 1 else 0);\n      done;\n      for i = 0 to n do rank.(i) <- tmp.(i) done;\n      doit (2 * k)\n    end in\n  doit 1;\n  sa\n\nlet range_cmp t n offset p k =\n  let m = n - offset in\n  let m = if m < k then m else k in\n  try\n    for i = 0 to m - 1 do\n      if t.[i+offset] <> p.[i] then\n        raise (Not_equal (compare t.[i+offset] p.[i]));\n    done;\n    if m = k then 0\n    else (-1)\n  with Not_equal i -> i\n\nlet () =\n  let t = read_line () in\n  let n = String.length t in\n  let sa = construct_sa t n in\n  let q = read_int () in\n  for _ = 0 to q - 1 do\n    let p = read_line () in\n    let k = String.length p in\n    let rec doit l r =\n      if r - l <= 1 then l\n      else\n        let m = (l + r) / 2 in\n        if range_cmp t n sa.(m) p k <= 0 then doit m r\n        else doit l m in\n    let l = doit 0 (n + 1) in\n    Printf.printf \"%d\\n\" (if range_cmp t n sa.(l) p k = 0 then 1 else 0);\n  done"
  },
  {
    "language": "OCaml",
    "code": "let id x = x\n             \nlet make_sa s =\n  let sl = String.length s in\n  let sa = Array.init (sl+1) id in\n  let rank = Array.init (sl+1) (fun i -> if i = sl then (-1) else Char.code s.[i]) in\n  let ta = Array.make (sl+1) 0 in\n  let cmp k i j =\n    if rank.(i) = rank.(j) then\n      let rik = if i + k <= sl then rank.(i+k) else (-1) in\n      let rjk = if j + k <= sl then rank.(j+k) else (-1) in\n      rik - rjk\n    else rank.(i) - rank.(j) in\n  let ra_rank k =\n    let rec iter i =\n      if i > sl then ()\n      else begin\n          ta.(sa.(i)) <- ta.(sa.(i-1)) + (if cmp k sa.(i) sa.(i-1) > 0 then 1 else 0);\n          iter (i+1)\n        end in\n    let rec copy i =\n      if i > sl then ()\n      else begin\n          rank.(i) <- ta.(i);\n          copy (i+1)\n        end in\n    iter 1;\n    copy 0 in\n  let rec sort_sa k =\n    if k > sl then ()\n    else begin\n        Array.fast_sort (cmp k) sa;\n        ra_rank k;\n        sort_sa (2 * k)\n      end in\n  sort_sa 1; sa\n\nlet string_search sa s p =\n  let sl = String.length s in\n  let pl = String.length p in\n  let rec search l r =\n    if r - l <= 1 then\n      try String.sub s sa.(r) pl = p with _ -> false\n    else\n      let m = (l + r) / 2 in\n      match compare (String.sub s sa.(m) (min pl (sl - sa.(m)))) p with\n        0 -> true\n      | x when x < 0 -> search m r\n      | _ -> search l m\n  in\n  search 0 (sl+1)\n\nlet () =\n  let t = read_line () in\n  let q = read_int () in\n  let sa = make_sa t in\n  let rec loop x =\n    if x = 0 then ()\n    else let p = read_line () in\n         (if string_search sa t p then \"1\" else \"0\") |> print_endline;\n         loop (x-1)\n  in loop q"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\n\nclass IndexMatch:\n    shift = 40\n    size = 33554393\n\n    def __init__(self, text):\n        self.text = text\n        self.index = self._create_index()\n\n    def _create_index(self):\n        index = defaultdict(list)\n        index[self.text[0]].append(0)\n\n        for i in range(1, len(self.text)):\n            index[self.text[i-1:i+1]].append(i-1)\n            index[self.text[i]].append(i)\n\n        return index\n\n    def match(self, search_text):\n        def _match(text):\n            ls = len(text)\n            if ls <= 2:\n                indices = [(i, i+ls-1) for i in self.index[text]]\n                return indices\n\n            mid = ls // 2\n            pre = _match(text[:mid])\n            post = _match(text[mid:])\n\n            if len(pre) == 0 or len(post) == 0:\n                return []\n\n            indices = []\n            for (s1, e1) in pre:\n                (s2, e2) = self._find(post, e1+1)\n                if s2 > 0:\n                    indices.append((s1, e2))\n\n            return indices\n\n        return len(_match(search_text)) > 0\n\n    def _find(self, ts, i):\n        if len(ts) == 0:\n            return (-1, -1)\n        mid = len(ts) // 2\n        s, e = ts[mid]\n        if s > i:\n            return self._find(ts[:mid], i)\n        elif s < i:\n            return self._find(ts[mid+1:], i)\n        else:\n            return (s, e)\n\n\ndef run():\n    s1 = input()\n    n = int(input())\n\n    matcher = IndexMatch(s1)\n    for _ in range(n):\n        s2 = input()\n        if matcher.match(s2):\n            print(1)\n        else:\n            print(0)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\noriginal_string = list(map(ord, list(input())))\ncheck_string_count = int(input())\ncheckers = [list(map(ord,list(input()))) for i in range(check_string_count)]\nfor checker in checkers:\n    found = False\n    for index in range(0, len(original_string)-len(checker)):\n        if original_string[index] == checker[0]:\n            found = True\n            for checker_index in range(len(checker)):\n                if checker[checker_index] != original_string[index + checker_index]:\n                    found = False\n                    break\n            if found:\n                print(1)\n                break\n    if not found:\n        print(0)"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nfrom math import floor, ceil, log\nfrom heapq import heapreplace, heappush\nimport time\n\n\nclass TreeIndex:\n    CACHESIZE = 65535\n\n    class Node:\n        __slots__ = ('level', 'keys', 'values', 'keylen')\n\n        def __init__(self, level):\n            self.level = level\n            self.values = []\n            self.keys = {}\n            self.keylen = 2 ** self.level\n\n        def add(self, text, value):\n            if len(text) == 0:\n                self.values.append(value)\n                return self\n            pre = text[:self.keylen]\n            post = text[self.keylen:]\n            if pre not in self.keys:\n                self.keys[pre] = self.__class__(self.level+1)\n            return self.keys[pre].add(post, value)\n\n        def find(self, text):\n            if len(text) == 0:\n                return self\n            pre = text[:self.keylen]\n            post = text[self.keylen:]\n            if pre in self.keys:\n                return self.keys[pre].find(post)\n            else:\n                return None\n\n        def __contains__(self, text):\n            if len(text) > self.keylen:\n                pre = text[:self.keylen]\n                post = text[self.keylen:]\n                return (pre in self.keys and post in self.keys[pre])\n            else:\n                return any(key.startswith(text) for key in self.keys)\n\n        def __str__(self):\n            return ('(' + ','.join([\"{}->{}\".format(k, v)\n                                   for k, v in self.keys.items()]) + ')')\n\n    def __init__(self, text):\n        self.text = text\n        self._init_cache()\n        self._keylen()\n        self._create_index()\n\n    def _keylen(self):\n        chars = Counter(list(self.text))\n        ent = 0.0\n        total = len(self.text)\n        base = len(chars) + 1\n        for c, cnt in chars.items():\n            p = cnt / total\n            ent -= p * log(p, base)\n        self.keylen = max(2 ** ceil(10 * (1 - ent)) - 1, 3)\n\n    def _create_index(self):\n        self.tree = self.Node(0)\n        length = len(self.text)\n        for i in range(length):\n            self.add(self.text[i:i+self.keylen], i)\n\n    def _init_cache(self):\n        self._cache = {}\n        self._cacheq = []\n\n    def _set_cache(self, text, node):\n        if text not in self._cache:\n            if len(self._cacheq) > self.CACHESIZE:\n                _, txt = heapreplace(self._cacheq, (time.clock(), text))\n                del self._cache[txt]\n            else:\n                heappush(self._cacheq, (time.clock(), text))\n            self._cache[text] = node\n\n    def _get_cache(self, text):\n        if text in self._cache:\n            return self._cache[text]\n        else:\n            return None\n\n    def index(self, text):\n        node = self._get_cache(text)\n        if node is None:\n            node = self.tree.find(text)\n\n        if node is None:\n            return []\n        else:\n            self._set_cache(text, node)\n            return node.values\n\n    def add(self, text, value):\n        node = self._get_cache(text)\n        if node is None:\n            node = self.tree.add(text, value)\n            self._set_cache(text, node)\n        else:\n            node.add('', value)\n\n    def match(self, search_text):\n        def _match_partial(lo, hi):\n            split = self.keylen\n            if search_text[lo+split:hi] in self.tree:\n                for i in self.index(search_text[lo:lo+split]):\n                    if (self.text[i+split:i+hi-lo]\n                            == search_text[lo+split:hi]):\n                        yield i\n\n        def _match(lo, hi):\n            length = hi - lo\n\n            if length == self.keylen:\n                return (i for i in self.index(search_text[lo:hi]))\n            elif length < self.keylen*2:\n                return _match_partial(lo, hi)\n\n            mid = lo + length // 2\n            pre = _match(lo, mid)\n            post = _match(mid, hi)\n\n            return _merge(pre, post, mid-lo)\n\n        def _merge(idx1, idx2, shift):\n            i2 = next(idx2)\n            for i1 in idx1:\n                while i1 + shift > i2:\n                    i2 = next(idx2)\n                if i1 + shift == i2:\n                    yield i1\n\n        length = len(search_text)\n        if length < self.keylen:\n            return search_text in self.tree\n\n        # align by key length\n        k = floor(log(length/self.keylen, 2))\n        b = self.keylen * 2**k\n        if length - self.keylen < b < length and k > 0:\n            b = self.keylen * 2**(k-1)\n\n        try:\n            if b + self.keylen < length:\n                match = _merge(_match(0, b), _match(b, length), b)\n            else:\n                match = _match(0, length)\n            next(match)\n            return True\n        except StopIteration:\n            return False\n\n\ndef run():\n    s1 = input()\n    n = int(input())\n\n    index = TreeIndex(s1)\n    for _ in range(n):\n        s2 = input()\n        if index.match(s2):\n            print(1)\n        else:\n            print(0)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "line = input()\nn = int(input())\n\nfor i in range(n):\n    if line.find(input()) == -1:\n        print(0)\n    else:\n        print(1)"
  },
  {
    "language": "Python",
    "code": "base = 127\nmask = (1 << 32) - 1\n\n\ndef calc_hash(f, pl, tl, with_array):\n    dl = tl - pl\n    tmp = []\n\n    t = 1\n    for _ in range(pl):\n        t = (t * base) & mask\n    e = 0\n    for i in range(pl):\n        e = (e * base + f[i]) & mask\n    for i in range(dl):\n        tmp.append(e)\n        e = (e * base - t * f[i] + f[i + pl]) & mask\n    tmp.append(e)\n    if with_array:\n        return set(tmp), tmp\n    else:\n        return set(tmp)\n\n\nt = [ord(c) for c in input().strip()]\ntl = len(t)\nq = int(input())\nh = dict()\nwhile q:\n    p = [ord(c) for c in input().strip()]\n    pl = len(p)\n    if pl > tl:\n        print(0)\n        q -= 1\n        continue\n    if pl >= 10:\n        keys_set, keys_array = calc_hash(p, 10, pl, with_array=True)\n        keys0, keys1 = keys_array[0], keys_array[1:pl - 9]\n        if pl not in h:\n            hash_set, hash_array = h[10] = calc_hash(t, 10, tl, with_array=True)\n        else:\n            hash_set, hash_array = h[10]\n\n        if keys_set.issubset(hash_set):\n            for idx, hash in enumerate(hash_array):\n                if keys0 == hash and hash_array[idx + 1:idx + pl - 9] == keys1:\n                    print(1)\n                    break\n            else:\n                print(0)\n        else:\n            print(0)\n    else:\n        key = calc_hash(p, pl, pl).pop() & mask\n        if pl not in h:\n            h[pl] = calc_hash(t, pl, tl, with_array=False)\n        print(1 if key in h[pl] else 0)\n    q -= 1"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nfrom math import floor, ceil, log\nfrom heapq import heapreplace, heappush\nimport time\n\n\nclass TreeIndex:\n\n    class Node:\n        __slots__ = ('level', 'keys', 'values', 'keylen', '_cache', '_cacheq')\n\n        def __init__(self, level):\n            self.level = level\n            self.values = []\n            self.keys = {}\n            self.keylen = 2 ** self.level\n            self._init_cache()\n\n        def add(self, text, value):\n            def _add(node, t):\n                if len(t) == 0:\n                    node.values.append(value)\n                    return node\n\n                pre = t[:node.keylen]\n                post = t[node.keylen:]\n                if pre not in node.keys:\n                    node.keys[pre] = self.__class__(node.level+1)\n                return _add(node.keys[pre], post)\n\n            node = self._get_cache(text)\n            if node is not None:\n                _add(node, '')\n            else:\n                self._set_cache(text, _add(self, text))\n\n        def index(self, text):\n            def _index(node, t):\n                if len(t) == 0:\n                    return node\n\n                pre = t[:node.keylen]\n                post = t[node.keylen:]\n                if pre in node.keys:\n                    return _index(node.keys[pre], post)\n                else:\n                    return None\n\n            node = self._get_cache(text)\n            if node is not None:\n                return node.values\n            else:\n                node = _index(self, text)\n                if node is not None:\n                    self._set_cache(text, node)\n                    return node.values\n                return []\n\n        def __contains__(self, text):\n            if len(text) > self.keylen:\n                pre = text[:self.keylen]\n                post = text[self.keylen:]\n                return (pre in self.keys and post in self.keys[pre])\n            else:\n                return any(key.startswith(text) for key in self.keys)\n\n        def _init_cache(self):\n            self._cache = {}\n            self._cacheq = []\n\n        def _set_cache(self, text, node):\n            if text not in self._cache:\n                if len(self._cacheq) > 65535:\n                    _, txt = heapreplace(self._cacheq, (time.clock(), text))\n                    del self._cache[txt]\n                else:\n                    heappush(self._cacheq, (time.clock(), text))\n                self._cache[text] = node\n\n        def _get_cache(self, text):\n            if text in self._cache:\n                return self._cache[text]\n            else:\n                return None\n\n        def __str__(self):\n            return ('(' + ','.join([\"{}->{}\".format(k, v)\n                                   for k, v in self.keys.items()]) + ')')\n\n    def __init__(self, text):\n        self._keylen(text)\n        self._create_index(text)\n\n    def _keylen(self, text):\n        chars = Counter(list(text))\n        ent = 0.0\n        total = len(text)\n        base = len(chars) + 1\n        for c, cnt in chars.items():\n            p = cnt / total\n            ent -= p * log(p, base)\n        self.keylen = max(2 ** ceil(10 * (1 - ent)) - 1, 3)\n        # print(ent, self.keylen)\n\n    def _create_index(self, text):\n        tree = self.Node(0)\n        length = len(text)\n        for i in range(length):\n            tree.add(text[i:i+self.keylen], i)\n        self.tree = tree\n        self.text = text\n        # print('key length = {}'.format(self.keylen))\n        # print(self.tree)\n\n    def match(self, search_text):\n        def _match_partial(lo, hi):\n            # print('match partial', lo, hi, search_text[lo:hi])\n            split = self.keylen\n            if search_text[lo+split:hi] in self.tree:\n                for i in self.tree.index(search_text[lo:lo+split]):\n                    if (self.text[i+split:i+hi-lo]\n                            == search_text[lo+split:hi]):\n                        yield i\n\n        def _match(lo, hi):\n            length = hi - lo\n\n            if length == self.keylen:\n                # print('match index', lo, hi)\n                return (i for i in self.tree.index(search_text[lo:hi]))\n\n            if length < self.keylen*2:\n                return _match_partial(lo, hi)\n\n            mid = lo + length // 2\n            pre = _match(lo, mid)\n            post = _match(mid, hi)\n\n            return _merge(pre, post, mid-lo)\n\n        def _merge(idx1, idx2, shift):\n            i2 = next(idx2)\n            for i1 in idx1:\n                while i1 + shift > i2:\n                    i2 = next(idx2)\n                if i1 + shift == i2:\n                    # print('match!', i1, self.text[i1:i1+length], search_text)\n                    yield i1\n\n        length = len(search_text)\n        if length < self.keylen:\n            return search_text in self.tree\n\n        # align by key length\n        k = floor(log(length/self.keylen, 2))\n        b = self.keylen * 2**k\n        if length - self.keylen < b < length and k > 0:\n            b = self.keylen * 2**(k-1)\n\n        try:\n            if b + self.keylen < length:\n                match = _merge(_match(0, b), _match(b, length), b)\n            else:\n                match = _match(0, length)\n            next(match)\n            return True\n        except StopIteration:\n            return False\n\n\ndef run():\n    s1 = input()\n    n = int(input())\n\n    index = TreeIndex(s1)\n    for _ in range(n):\n        s2 = input()\n        if index.match(s2):\n            print(1)\n        else:\n            print(0)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\noriginal_string = list(map(ord, list(input())))\ncheck_string_count = int(input())\ncheckers = [list(map(ord,list(input()))) for i in range(check_string_count)]\nfor checker in checkers:\n    found = False\n    sum_of_checker = sum(checker)\n    if len(checker) > len(original_string):\n        print(0)\n        continue\n    for index in range(0, len(original_string)):\n        if (len(original_string)-len(checker)) < index:\n            break\n        if original_string[index] == checker[0]:\n            found = True\n            sum_of_origin = sum(original_string[index:index+len(checker)])\n            if sum_of_origin != sum_of_checker:\n                found = False\n            if found:\n                print(1)\n                break\n    if not found:\n        print(0)"
  },
  {
    "language": "Python",
    "code": "\ndef isEqual(T,P):\n    for i in range(len(T)-len(P)+1):\n        if T[i:i+len(P)] == P:\n            return 1\n    return 0\n\nT = input()\nn = int(input())\n\nfor i in range(n):\n    P = input()\n    print(isEqual(T,P))"
  },
  {
    "language": "Python",
    "code": "def MAIN():\n    T = input()\n    Q = int(input())\n    P = \"\"\n    for _ in range(Q):\n        P = input()\n        print(1 if P in T else 0)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "#coding:utf-8\n\ndef MSM(T,P):\n    Tlist=list(T)\n    Plist=list(P)\n    ans=0\n    for i in range(len(Tlist)):\n        if Tlist[i]==Plist[0]:\n            ans+=1\n            for j in range(1,len(Plist)):\n                if Plist[j]==Tlist[i+j] and i+j<=len(Tlist):\n                    ans+=1\n        if ans==len(Plist):\n            return 1\n    return 0\n\nif __name__==\"__main__\":\n    T=input()\n    n=int(input())\n    ans=[]\n    for i in range(n):\n        P=input()\n        ans.append(MSM(T,P))\n    for i in range(n):\n        print(ans[i])\n        \n            "
  },
  {
    "language": "Python",
    "code": "x = input()\nn = int(input())\n\n\ndef check(string,word):\n    search_state = 0\n    first_match = 0\n    l = len(string)\n    i = 0\n    while (i < l):\n        # print(string[i])\n        if i+search_state < l and string[i+search_state] == word[search_state]:\n            if first_match == 0:\n                first_match = search_state\n            search_state += 1\n            if search_state == len(word):\n                return 1\n        else:\n            i += max(min(first_match,search_state),1)\n            search_state = 0\n            \n    return 0\n            \n# print(check(x,'baa'))\n    \nfor i in range(n):\n    y = input()\n    print(check(x,y))\n    \n# for i in range(n):\n#     y = input()\n#     print(str(i) + y)\n#     # if y in x:\n    #     print(i + 1)\n    # else:\n    #     print(i + 0)\n        \n        \n        \n"
  },
  {
    "language": "Python",
    "code": "base = 127\nmask = (1 << 32) - 1\n\n\ndef calc_hash(f, pl, tl):\n    dl = tl - pl\n    tmp = []\n\n    t = 1\n    for _ in range(pl):\n        t = (t * base) & mask\n    e = 0\n    for i in range(pl):\n        e = (e * base + f[i]) & mask\n    for i in range(dl):\n        tmp.append(e)\n        e = (e * base - t * f[i] + f[i + pl]) & mask\n    tmp.append(e)\n    return tmp\n\n\nt = [ord(c) for c in input().strip()]\ntl = len(t)\nq = int(input())\nh = dict()\nwhile q:\n    p = [ord(c) for c in input().strip()]\n    pl = len(p)\n    if pl > tl:\n        print(0)\n        q -= 1\n        continue\n    if pl > 10:\n        keys = calc_hash(p, 10, pl)\n        keys0, keys1 = keys[0], keys[1:pl - 9]\n        if pl not in h:\n            hash_array = h[10] = calc_hash(t, 10, tl)\n        else:\n            hash_array = h[10]\n        for idx, hash in enumerate(hash_array):\n            if keys0 == hash and hash_array[idx + 1:idx + pl - 9] == keys1:\n                print(1)\n                break\n        else:\n            print(0)\n    else:\n        key = calc_hash(p, pl, pl).pop() & mask\n        if pl not in h:\n            h[pl] = calc_hash(t, pl, tl)\n        print(1 if key in h[pl] else 0)\n    q -= 1"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nimport time\n\ndef SL(S):\n    t = [\"S\"]*len(S)\n    for i in range(len(S)-2,-1,-1):\n        if S[i] > S[i+1] or (S[i] == S[i+1] and t[i+1] == \"L\"):\n            t[i] = \"L\"\n    return t\n\ndef LMS(t):\n    lms = [False]*len(t)\n    for i in range(1,len(t)):\n        if t[i-1] == \"L\" and t[i] == \"S\":\n            lms[i] = True\n    return lms\n\ndef Bucket(S):\n    bucket = Counter(S)\n    tmp = 0\n    for i in sorted(bucket):\n        bucket[i] = {\"chead\":tmp,\"ctail\":tmp+bucket[i]-1}\n        tmp = bucket[i][\"ctail\"]+1\n    return bucket\n\ndef STEP2(S,t,bucket,SA):\n    for i in range(len(SA)):\n        tmp = SA[i]-1\n        if t[tmp] == \"L\" and tmp > -1:\n            head = bucket[S[tmp]][\"chead\"]\n            SA[head] = tmp\n            bucket[S[tmp]][\"chead\"]+=1\n\ndef STEP3(S,t,SA):\n    bucket = Bucket(S)\n    for i in range(len(SA)-1,-1,-1):\n        tmp = SA[i]-1\n        if t[tmp] == \"S\" and tmp > -1:\n            tail = bucket[S[tmp]][\"ctail\"]\n            SA[tail] = tmp\n            bucket[S[tmp]][\"ctail\"]-=1\n        \ndef InducedSorting(S):\n    l = len(S)\n    t = SL(S)\n    lms = LMS(t)\n    bucket = Bucket(S)\n    SA=[-1]*l\n    P1 = [i for i in range(l) if lms[i]]\n    #STEP1\n    for i,j in enumerate(lms):\n        if j:\n            tail = bucket[S[i]][\"ctail\"]\n            SA[tail] = i\n            bucket[S[i]][\"ctail\"] -= 1\n    #STEP2\n    STEP2(S,t,bucket,SA)\n    #STEP3\n    STEP3(S,t,SA)\n    #Construct S1 from pseudoSA\n    prev = None\n    Name = [None]*l\n    name = 0\n    S1 = []\n    for i in SA:\n        if lms[i]:\n            if prev and not i == len(S)-1:\n                j = 0\n                while(True):\n                    if not S[i+j] == S[prev+j] or not t[i+j] == t[prev+j]:\n                        name+=1\n                        break\n                    if j>0 and lms[i+j]:\n                        break\n                    j+=1\n            Name[i] = name\n            prev = i\n    for i in Name:\n        if not i == None:\n            S1.append(i)\n    #Construct SA1 from S1\n    uniq = True\n    dtmp = {}\n    #for i in Counter(S1):\n    #    if Counter(S1)[i] > 1:\n    #        uniq = False\n    #        break\n    for i in S1:\n        if i in dtmp:\n            uniq = False\n            break\n        else:\n            dtmp[i] = True\n    \n    if uniq:\n        SA1 = [None]*len(S1)\n        for i,j in enumerate(S1):\n            SA1[j] = i\n    else:\n        SA1 = InducedSorting(S1)\n    \n    #Inducing SA from SA1 STEP1\n    bucket = Bucket(S)\n    SA=[-1]*l\n    for i in SA1[::-1]:\n        p = P1[i]\n        tail = bucket[S[p]][\"ctail\"]\n        SA[tail] = p\n        bucket[S[p]][\"ctail\"] -= 1\n    #Inducing SA from SA1 STEP2\n    STEP2(S,t,bucket,SA)\n    #Inducing SA from SA1 STEP3\n    STEP3(S,t,SA)\n    return SA\n\ndef contain(T,sa,P):\n    a = 0\n    b = len(T)\n    while(b-a > 1):\n        c = (a+b)//2\n        if T[sa[c]:sa[c]+len(P)] < P:\n            a = c\n        else:\n            b = c\n    return P == T[sa[b]:sa[b]+len(P)]\n\nT = input()\nQ = int(input())\nP = [input() for _ in range(Q)]\nSA = InducedSorting(T+\"$\")\nfor i in P:\n    if contain(T,SA,i):\n        print(1)\n    else:\n        print(0)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, Counter\nfrom math import floor, log\n\n\nclass NoMatch(Exception):\n    pass\n\n\nclass IndexMatch:\n    MAX_KEYLEN = 20\n\n    def __init__(self, text):\n        self.text = text\n        self.keylen = self._select_keylen()\n        self._create_index()\n\n    def _select_keylen(self):\n        chars = Counter(list(self.text))\n        return min(floor(log(len(self.text), len(chars))), self.MAX_KEYLEN)\n\n    def _create_index(self):\n        index = defaultdict(set)\n        particles = set()\n        for i in range(len(self.text)+1):\n            for j in range(max(i-self.keylen, 0), i):\n                if i - j < self.keylen // 2:\n                    particles.add(self.text[j:i])\n                else:\n                    index[self.text[j:i]].add(j)\n        self.index = index\n        self.particles = particles\n\n    def match(self, search_text):\n        def _match(lo, hi):\n            text = search_text[lo:hi]\n            if hi-lo <= self.keylen:\n                return self.index[text]\n\n            mid = (lo + hi) // 2\n            pre = _match(lo, mid)\n            post = _match(mid, hi)\n\n            if len(pre) == 0 or len(post) == 0:\n                raise NoMatch()\n\n            indices = set(i for i in pre if i+mid-lo in post)\n            return indices\n\n        if len(search_text) < self.keylen // 2:\n            return search_text in self.particles\n\n        try:\n            match = _match(0, len(search_text))\n            return len(match) > 0\n        except NoMatch:\n            return False\n\n\ndef run():\n    s1 = input()\n    n = int(input())\n    ss = []\n\n    for _ in range(n):\n        ss.append(input())\n\n    i = 0\n    maxsize = 100000\n    results = [False] * n\n    while i < n:\n        matcher = IndexMatch(s1[i:i+maxsize])\n        for j, s2 in enumerate(ss):\n            if not results[j]:\n                results[j] = matcher.match(s2)\n\n        i = i + maxsize - 1000\n\n    for result in results:\n        if result:\n            print(1)\n        else:\n            print(0)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "base = 127\nmask = (1 << 32) - 1\n\n\ndef calc_hash(f, pl, tl):\n    dl = tl - pl\n    tmp = set()\n\n    t = 1\n    for _ in range(pl):\n        t = (t * base) & mask\n    e = 0\n    for i in range(pl):\n        e = (e * base + f[i]) & mask\n    for i in range(dl):\n        tmp.add(e)\n        e = (e * base - t * f[i] + f[i + pl]) & mask\n    tmp.add(e)\n    return tmp\n\n\nt = [ord(c) for c in input().strip()]\ntl = len(t)\nq = int(input())\nps = [input().strip() for _ in range(q)]\nh = dict()\nc = dict()\na = []\nfor p in ps:\n    if p in c:\n        a.append(c[p])\n        continue\n    p = [ord(c) for c in p]\n    pl = len(p)\n    if pl > tl:\n        a.append(0)\n        continue\n    bs = min(17, pl)\n    keys = calc_hash(p, bs, pl)\n    if bs not in h:\n        h[bs] = calc_hash(t, bs, tl)\n    a.append(1 if keys.issubset(h[bs]) else 0)\nprint('\\n'.join(map(str, a)))"
  },
  {
    "language": "Python",
    "code": "\ndef isEqual(T,P):\n    for i in range(len(T)-len(P)+1):\n        if T[i:i+len(P)] == P:\n            return 1\n    return 0\n\nif __name__ == '__main__':\n    T = input()\n    n = int(input())\n\n    for i in range(n):\n        P = input()\n        print(isEqual(T,P))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom math import floor, log \n\n\nclass NoMatch(Exception):\n    pass\n\n\nclass IndexMatch:\n\n    def __init__(self, text):\n        self.text = text\n        self.keylen = self._select_keylen()\n        self._create_index()\n\n    def _select_keylen(self):\n        chars = set(list(self.text))\n        return floor(log(len(self.text), len(chars)))\n\n    def _create_index(self):\n        index = defaultdict(set)\n        particles = set()\n        for i in range(len(self.text)+1):\n            for j in range(max(i-self.keylen, 0), i): \n                if i - j < self.keylen // 2:\n                    particles.add(self.text[j:i])\n                else:\n                    index[hash(self.text[j:i])].add(j)\n        self.index = index\n        self.particles = particles\n\n    def match(self, search_text):\n        def _match(lo, hi):\n            text = search_text[lo:hi]\n            if hi-lo <= self.keylen:\n                return self.index[hash(text)]\n\n            mid = (lo + hi) // 2\n            pre = _match(lo, mid)\n            post = _match(mid, hi) \n\n            if len(pre) == 0 or len(post) == 0:\n                raise NoMatch()\n\n            indices = set(i for i in pre if i+mid-lo in post)\n            return indices\n\n        if len(search_text) < self.keylen // 2:\n            return search_text in self.particles\n\n        try:\n            match = _match(0, len(search_text))\n            return len(match) > 0 \n        except NoMatch:\n            return False\n\n\ndef run():\n    s1 = input()\n    n = int(input())\n\n    matcher = IndexMatch(s1)\n    for _ in range(n):\n        s2 = input()\n        if matcher.match(s2):\n            print(1)\n        else:\n            print(0)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "base = 127\nmask = (1 << 32) - 1\n\n\ndef calc_hash(f, pl, tl):\n    dl = tl - pl\n    tmp = set()\n\n    t = 1\n    for _ in range(pl):\n        t = (t * base) & mask\n    e = 0\n    for i in range(pl):\n        e = (e * base + f[i]) & mask\n    for i in range(dl):\n        tmp.add(e)\n        e = (e * base - t * f[i] + f[i + pl]) & mask\n    tmp.add(e)\n    return tmp\n\n\nt = [ord(c) for c in input().strip()]\ntl = len(t)\nq = int(input())\nps = [input().strip() for _ in range(q)]\nh = dict()\nc = dict()\na = []\nfor p in ps:\n    if p in c:\n        a.append(c[p])\n        continue\n    p = [ord(c) for c in p]\n    pl = len(p)\n    if pl > tl:\n        a.append(0)\n        continue\n    bs = min(20, pl)\n    keys = calc_hash(p, bs, pl)\n    if bs not in h:\n        h[bs] = calc_hash(t, bs, tl)\n    a.append(1 if keys.issubset(h[bs]) else 0)\nprint('\\n'.join(map(str, a)))"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\noriginal_string = input()[::-1]\ncheck_string_count = int(input())\ncheckers = [input()[::-1] for i in range(check_string_count)]\nfor checker in checkers:\n    for char in list(checker):\n        if char not in original_string:\n            checker = \"#\"\n            break\n    print(1 if checker in original_string else 0)"
  },
  {
    "language": "Python",
    "code": "x = input()\nn = int(input())\n\n\ndef check(string,word):\n    search_state = 0\n    first_match = 0\n    l = len(string)\n    i = 0\n    while (i < l):\n        if i+len(word) > l:\n            break\n        if word[0] != string[i] or word[-1] != string[i+len(word)-1]:\n            i += 1\n            continue\n        # print(string[i])\n        if string[i+search_state] == word[search_state]:\n            if first_match == 0:\n                first_match = search_state\n            search_state += 1\n            if search_state == len(word):\n                return 1\n        else:\n            i += max(min(first_match,search_state),1)\n            search_state = 0\n            \n    return 0\n            \n# print(check(x,'baa'))\n    \nfor i in range(n):\n    y = input()\n    print(check(x,y))\n    \n# for i in range(n):\n#     y = input()\n#     print(str(i) + y)\n#     # if y in x:\n    #     print(i + 1)\n    # else:\n    #     print(i + 0)\n        \n        \n        \n"
  },
  {
    "language": "Python",
    "code": "#coding:utf-8\n\n# ?§????????????????????????????\ndef make_BM_table(P):\n    CSIZE = 128\n    bm_table = [len(P)]*CSIZE\n\n    for i in range(len(P)-1):\n        bm_table[ord(P[i])] = len(P)-i-1\n\n    print(bm_table)\n\n    return bm_table\n\n# ?????????????´¢\ndef BM_string_search(T,P):\n\n    # ?§????????????????????????????\n    bm_table = make_BM_table(P)\n\n    i = len(P)-1\n\n    while i < len(T):\n        j = len(P)-1\n\n        while T[i] == P[j]:\n            \n            # ??????\n            if j == 0:\n                return True\n\n            i -= 1\n            j -= 1\n\n        i += max(bm_table[ord(T[i])],len(P)-j)\n\n    return False\n\n\nif __name__ == '__main__':\n\n    # ?????????????????\\???\n    T = input()\n    # ????´¢?????????????????°?????\\???\n    n = int(input())\n\n    # ????????????????????????????????????????????\\???\n    for i in range(n):\n        P = input()\n    \n        if BM_string_search(T,P):\n            print(1)\n        else:\n            print(0)\n    "
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom math import floor, log \n\n\nclass NoMatch(Exception):\n    pass\n\n\nclass IndexMatch:\n    MAX_KEYLEN = 13\n\n    def __init__(self, text):\n        self.text = text\n        self.keylen = self._select_keylen()\n        self._create_index()\n\n    def _select_keylen(self):\n        chars = set(list(self.text))\n        return min(floor(log(len(self.text), len(chars))), self.MAX_KEYLEN)\n\n    def _create_index(self):\n        index = defaultdict(set)\n        particles = set()\n        for i in range(len(self.text)+1):\n            for j in range(max(i-self.keylen, 0), i): \n                if i - j < self.keylen // 2:\n                    particles.add(self.text[j:i])\n                else:\n                    index[self.text[j:i]].add(j)\n        self.index = index\n        self.particles = particles\n\n    def match(self, search_text):\n        def _match(lo, hi):\n            text = search_text[lo:hi]\n            if hi-lo <= self.keylen:\n                return self.index[text]\n\n            mid = (lo + hi) // 2\n            pre = _match(lo, mid)\n            post = _match(mid, hi) \n\n            if len(pre) == 0 or len(post) == 0:\n                raise NoMatch()\n\n            indices = set(i for i in pre if i+mid-lo in post)\n            return indices\n\n        if len(search_text) < self.keylen // 2:\n            return search_text in self.particles\n\n        try:\n            match = _match(0, len(search_text))\n            return len(match) > 0 \n        except NoMatch:\n            return False\n\n\ndef run():\n    s1 = input()\n    n = int(input())\n\n    matcher = IndexMatch(s1)\n    for _ in range(n):\n        s2 = input()\n        if matcher.match(s2):\n            print(1)\n        else:\n            print(0)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\n\nclass IndexMatch:\n    shift = 40\n    size = 33554393\n\n    def __init__(self, text):\n        self.text = text\n        self.index = self._create_index()\n\n    def _create_index(self):\n        index = defaultdict(list)\n        index[self.text[0]].append(0)\n\n        for i in range(1, len(self.text)):\n            index[self.text[i-1:i+1]].append(i-1)\n            index[self.text[i]].append(i)\n\n        return index\n\n    def match(self, search_text):\n        def _match(text):\n            ls = len(text)\n            if ls <= 2:\n                return [(i, i+ls-1) for i in self.index[text]]\n\n            mid = ls // 2\n            pre = _match(text[:mid])\n            post = _match(text[mid:])\n\n            if len(pre) == 0 or len(post) == 0:\n                return []\n\n            indices = []\n            for (s1, e1) in pre:\n                (s2, e2) = self._find(post, e1+1)\n                if s2 > 0:\n                    indices.append(s1, e2)\n\n            return indices\n\n        return len(_match(search_text)) > 0\n\n    def _find(self, ts, i):\n        if len(ts) == 0:\n            return (-1, -1)\n        mid = len(ts) // 2\n        s, e = ts[mid]\n        if s > i:\n            return self._find(ts[mid+1:], i)\n        elif s < i:\n            return self._find(ts[:mid], i)\n        else:\n            return (s, e)\n\n\ndef run():\n    s1 = input()\n    n = int(input())\n\n    matcher = IndexMatch(s1)\n    for _ in range(n):\n        s2 = input()\n        if matcher.match(s2):\n            print(1)\n        else:\n            print(0)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "line = input()\nn = int(input())\n\nfor i in range(n):\n    if input() in line:\n        print(1)\n    else:\n        print(0)"
  },
  {
    "language": "Python",
    "code": "#coding:utf-8\n\ndef MSM(T,P):\n    Tlist=list(T)\n    Plist=list(P)\n    if len(Tlist)<len(Plist):\n        return 0\n    for i in range(len(Tlist)):\n        ans=0\n        if Tlist[i]==Plist[0]:\n            ans+=1\n            if len(Plist)>1 and len(Tlist[i:])>=len(Plist):\n                for j in range(1,len(Plist)):\n                    if Plist[j]==Tlist[i+j] and i+j<=len(Tlist):\n                        ans+=1\n        if ans==len(Plist):\n            return 1\n    return 0\n\nif __name__==\"__main__\":\n    T=input()\n    n=int(input())\n    ans=[]\n    for i in range(n):\n        P=input()\n        ans.append(MSM(T,P))\n    for i in range(n):\n        print(ans[i])\n        \n            "
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\noriginal_string = list(map(ord, list(input())))\ncheck_string_count = int(input())\ncheckers = [list(map(ord,list(input()))) for i in range(check_string_count)]\nfor checker in checkers:\n    found = False\n    if len(checker) > len(original_string):\n        print(0)\n        continue\n    for index in range(0, len(original_string)):\n        if (len(original_string)-len(checker)) < index:\n            break\n        if original_string[index] == checker[0]:\n            found = True\n            for checker_index in range(len(checker)):\n                #print(\"{0},{1}\".format(index,checker_index))\n                if checker[checker_index] != original_string[index + checker_index]:\n                    found = False\n                    break\n            if found:\n                print(1)\n                break\n    if not found:\n        print(0)"
  },
  {
    "language": "Python",
    "code": "T = input()\nn = int(input())\nP = input()\n\nfor a in range(n):\n    for i in range(len(T)-len(P)+1):\n        if T[i:i+len(P)] == P:\n            print(1)\n            return\n        else:\n            print(0)\n            return:"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\n\nclass IndexMatch:\n    shift = 40\n    size = 33554393\n\n    def __init__(self, text):\n        self.text = text\n        self.index = self._create_index()\n\n    def _create_index(self):\n        index = defaultdict(list)\n        index[self.text[0]].append(0)\n\n        for i in range(1, len(self.text)):\n            index[self.text[i-1:i+1]].append(i-1)\n            index[self.text[i]].append(i)\n\n        return index\n\n    def match(self, search_text):\n        def _match(text):\n            ls = len(text)\n            if ls <= 2:\n                return [(i, i+ls-1) for i in self.index[text]]\n\n            mid = ls // 2\n            pre = _match(text[:mid])\n            post = _match(text[mid:])\n\n            if len(pre) == 0 or len(post) == 0:\n                return []\n\n            indices = []\n            for (s1, e1) in pre:\n                (s2, e2) = self._find(post, e1+1)\n                if s2 > 0:\n                    indices.append((s1, e2))\n\n            return indices\n\n        return len(_match(search_text)) > 0\n\n    def _find(self, ts, i):\n        if len(ts) == 0:\n            return (-1, -1)\n        mid = len(ts) // 2\n        s, e = ts[mid]\n        if s > i:\n            return self._find(ts[mid+1:], i)\n        elif s < i:\n            return self._find(ts[:mid], i)\n        else:\n            return (s, e)\n\n\ndef run():\n    s1 = input()\n    n = int(input())\n\n    matcher = IndexMatch(s1)\n    for _ in range(n):\n        s2 = input()\n        if matcher.match(s2):\n            print(1)\n        else:\n            print(0)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom math import floor, log\n\n\nclass NoMatch(Exception):\n    pass\n\n\nclass HashIndex:\n    MAX_KEYLEN = 15\n    MAX_SEARCH = 1000\n\n    def __init__(self, text):\n        self.text = text\n        self.keylen = self._select_keylen()\n        self._create_index()\n\n    def _select_keylen(self):\n        chars = len(set(list(self.text)))\n        textlen = len(self.text)\n        if chars > 1:\n            return min(floor(log(textlen, chars)), self.MAX_KEYLEN)\n        else:\n            return self.MAX_SEARCH+1\n\n    def _create_index(self):\n        index = defaultdict(set)\n        particles = set()\n        if self.keylen == self.MAX_SEARCH+1:\n            for i in range(self.keylen+1):\n                particles.add(self.text[0:i+1])\n        else:\n            for i in range(len(self.text)+1):\n                for j in range(max(i-self.keylen, 0), i):\n                    if i - j < self.keylen:\n                        particles.add(self.text[j:i])\n                    else:\n                        index[self.text[j:i]].add(j)\n        self.index = index\n        self.particles = particles\n\n    def match(self, search_text):\n        def _match(lo, hi):\n            length = hi - lo\n            if length == self.keylen:\n                return self.index[search_text[lo:hi]]\n\n            if length < self.keylen*2:\n                results = set()\n                pre = search_text[lo:lo+self.keylen]\n                post = search_text[lo+self.keylen:hi]\n                if post in self.particles:\n                    for i in self.index[pre]:\n                        if post == self.text[i+self.keylen:i+(hi-lo)]:\n                            results.add(i)\n                return results\n\n            mid = lo + length // 2\n            pre = _match(lo, mid)\n            post = _match(mid, hi)\n\n            if len(pre) == 0 or len(post) == 0:\n                raise NoMatch()\n\n            return _merge(pre, post, mid-lo)\n\n        def _merge(idx1, idx2, shift):\n            return set(i for i in idx1 if i + shift in idx2)\n\n        length = len(search_text)\n        if length < self.keylen:\n            # print('check_size', search_text)\n            return search_text in self.particles\n\n        # align by key length\n        k = floor(log(length/self.keylen, 2))\n        b = self.keylen * 2**k\n        if length - self.keylen < b < length and k > 0:\n            b = self.keylen * 2**(k-1)\n\n        try:\n            if b + self.keylen < length:\n                match = _merge(_match(0, b), _match(b, length), b)\n            else:\n                match = _match(0, length)\n            return len(match) > 0\n        except:\n            return False\n\ndef run():\n    s1 = input()\n    n = int(input())\n\n    index = HashIndex(s1)\n    for _ in range(n):\n        s2 = input()\n        if index.match(s2):\n            print(1)\n        else:\n            print(0)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\noriginal_string = input()\ncheck_string_count = int(input())\ncheckers = [input() for i in range(check_string_count)]\nfor checker in checkers:\n    if len(checker) > 10:\n        half_checker = checker[0:int(len(checker)/2)]\n        if half_checker not in original_string:\n            continue\n    print(1 if checker in original_string else 0)"
  },
  {
    "language": "Python",
    "code": "base = 127\nmask = (1 << 32) - 1\n\n\ndef calc_hash(f, pl, tl):\n    dl = tl - pl\n    tmp = set()\n\n    t = 1\n    for _ in range(pl):\n        t = (t * base) & mask\n    e = 0\n    for i in range(pl):\n        e = (e * base + f[i]) & mask\n    for i in range(dl):\n        tmp.add(e)\n        e = (e * base - t * f[i] + f[i + pl]) & mask\n    tmp.add(e)\n    return tmp\n\n\nt = [ord(c) for c in input().strip()]\ntl = len(t)\nq = int(input())\nps = [input().strip() for _ in range(q)]\nh = dict()\na = []\nhash_len = 20\nfor p in ps:\n    p = [ord(c) for c in p]\n    pl = len(p)\n    if pl > tl:\n        a.append(0)\n        continue\n    bs = min(hash_len, pl)\n    keys = calc_hash(p, bs, pl)\n    if bs not in h:\n        h[bs] = calc_hash(t, bs, tl)\n    a.append(1 if keys.issubset(h[bs]) else 0)\nprint('\\n'.join(map(str, a)))"
  },
  {
    "language": "Python",
    "code": "base = 127\nmask = (1 << 32) - 1\n\n\ndef calc_hash(f, pl, tl):\n    dl = tl - pl\n    tmp = set()\n\n    t = 1\n    for _ in range(pl):\n        t = (t * base) & mask\n    e = 0\n    for i in range(pl):\n        e = e * base + f[i]\n    for i in range(dl):\n        tmp.add(e)\n        e = (e * base - t * f[i] + f[i + pl]) & mask\n    tmp.add(e)\n    return tmp\n\n\nt = [ord(c) for c in input().strip()]\ntl = len(t)\nq = int(input())\nh = dict()\nwhile q:\n    p = [ord(c) for c in input().strip()]\n    pl = len(p)\n    key = calc_hash(p, pl, pl).pop() & mask\n    if pl in h:\n        haystack = h[pl]\n    else:\n        haystack = calc_hash(t, pl, tl)\n        h[pl] = haystack\n    print(1 if key in haystack else 0)"
  },
  {
    "language": "Python",
    "code": "T = input()\nn = int(input())\n\n\nfor i in range(n):\n    P = input()\n\n    list = T.split(P)\n\n    if T == list[0]:\n        print(0)\n    else:\n        print(1)\n    "
  },
  {
    "language": "Python",
    "code": "x = input()\nn = int(input())\n\n\ndef check(string,word):\n    search_state = 0\n    first_match = 0\n    l = len(string)\n    i = 0\n    while (i < l):\n        if i+len(word) >= l:\n            break\n        if word[0] != string[i] or word[-1] != string[i+len(word)-1]:\n            i += 1\n            continue\n        # print(string[i])\n        if string[i+search_state] == word[search_state]:\n            if first_match == 0:\n                first_match = search_state\n            search_state += 1\n            if search_state == len(word):\n                return 1\n        else:\n            i += max(min(first_match,search_state),1)\n            search_state = 0\n            \n    return 0\n            \n# print(check(x,'baa'))\n    \nfor i in range(n):\n    y = input()\n    print(i + check(x,y))\n    \n# for i in range(n):\n#     y = input()\n#     print(str(i) + y)\n#     # if y in x:\n    #     print(i + 1)\n    # else:\n    #     print(i + 0)\n        \n        \n  \n"
  },
  {
    "language": "Python",
    "code": "x = input()\nn = int(input())\n\n\ndef check(string,word):\n    search_state = 0\n    first_match = 0\n    l = len(string)\n    i = 0\n    while (i < l):\n        if i+len(word) >= l:\n            break\n        if word[0] != string[i] or word[-1] != string[i+len(word)-1]:\n            i += 1\n            continue\n        # print(string[i])\n        if string[i+search_state] == word[search_state]:\n            if first_match == 0:\n                first_match = search_state\n            search_state += 1\n            if search_state == len(word):\n                return 1\n        else:\n            i += max(min(first_match,search_state),1)\n            search_state = 0\n            \n    return 0\n            \n# print(check(x,'baa'))\n    \nfor i in range(n):\n    y = input()\n    print(i + check(x,y))\n    \n# for i in range(n):\n#     y = input()\n#     print(str(i) + y)\n#     # if y in x:\n    #     print(i + 1)\n    # else:\n    #     print(i + 0)\n        \n        \n        \n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\nimport sys\n\n\ndef lms(t, i):\n    return i > 0 and not t[i-1] and t[i]\n\n\ndef induced_sort(s, k, t, lmss):\n\n    sa = [-1] * len(s)\n    cbin = [0]*k\n\n    for c in s:\n        cbin[c] += 1\n\n    ssum = 0\n    for i in range(k):\n        ssum += cbin[i]\n        cbin[i] = ssum\n\n    count = [0] * k\n    for i in reversed(lmss):\n        c = s[i]\n        sa[cbin[c]-1 - count[c]] = i\n        count[c] += 1\n\n    count = [0] * k\n    for i in sa:\n        if i <= 0 or t[i-1]:\n            continue\n        c = s[i-1]\n        sa[cbin[c-1] + count[c]] = i-1\n        count[c] += 1\n        \n    count = [0] * k\n    for i in reversed(sa):\n        if i <= 0 or not t[i-1]:\n            continue\n        c = s[i-1]\n        sa[cbin[c]-1 - count[c]] = i-1\n        count[c] += 1\n\n    return sa\n\n\ndef sa_is(s, k):\n    slen = len(s)\n    t = [True] * slen # S -> True, T -> False\n    for i in range(slen-2, -1, -1):\n        #if s[i] < s[i+1]:   t[i] = True #'S'\n        if s[i] > s[i+1]:\n            t[i] = False # 'L'\n        elif s[i] == s[i+1]:\n            t[i] = t[i+1]\n\n    lmss = []\n    for i in range(1,slen):\n        if not t[i-1] and t[i]: # lms(t, i):\n            lmss.append(i)\n\n    seed = lmss\n\n    sa = induced_sort(s, k, t, seed)\n\n    new_sa = []\n    for i in sa:\n        if lms(t, i): new_sa.append(i)\n\n    nums = dict() #    nums = [[]] * (max(new_sa)+1)\n    nums[new_sa[0]] = 0\n    num = 0\n    for o in range(len(new_sa)-1):\n        i, j = new_sa[o], new_sa[o+1]\n        diff, d = False, 0\n        for d in range(slen):\n            if s[i+d] != s[j+d] or lms(t, i+d) != lms(t, j+d):\n                diff = True\n                break\n            elif d > 0 and (lms(t, i+d) or lms(t, j+d)):\n                break\n        if diff:\n            num += 1\n        nums[j] = num\n\n#    for i in range(len(nums)-1,-1,-1):\n#        if not nums[i]: nums.pop(i)\n    nums = list(map(lambda x: x[1], sorted(nums.items())))\n\n    if num + 1 < len(nums):\n        sa = sa_is(nums, num+1)\n    else:\n        sa = [[]] * (max(nums)+1)\n        for i, c in enumerate(nums):\n            sa[c] = i\n\n    seed = list(map(lambda x:lmss[x], sa))\n    sa = induced_sort(s, k, t, seed)\n\n    return sa\n\n\ndef strcmp(a, b):\n    for i, bi in enumerate(b):\n        if a[i] == bi: continue\n        return a[i]-bi\n    return 0\n\n\ndef search(s, sa, slen, q):\n    ss = 0\n    ee = slen\n    while ss <= ee:\n        mid = (ss+ee)//2\n        if mid >= slen: break\n        rr = strcmp(s[sa[mid]:], q)\n        if rr==0: return 1\n        if rr >= 0:\n            ee = mid-1\n        else:\n            ss = mid+1\n    return 0\n\n\nif __name__ == '__main__':\n\n    b = sys.stdin.readline().rstrip()\n    b = (b+'$').encode()\n    sa = sa_is(b, 128) #ord('z'))\n    n = int(sys.stdin.readline())\n    for _ in range(n):\n        q = sys.stdin.readline().rstrip().encode()\n        if search(b, sa, len(b), q) > 0:\n            print(1)\n        else:\n            print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "s=input()\nfor _ in range(int(input())):print([0,1][input() in s])"
  },
  {
    "language": "Python",
    "code": "\ndef isEqual(T,P):\n    for i in range(len(T)-len(P)+1):\n        if T[i:i+len(P)] == P:\n            return 1\n    return 0\n\nT = input()\nn = int(input())\n\nfor i in range(n):\n    P = input()\n    print(isEqual(T,P))"
  },
  {
    "language": "Python",
    "code": "\ndef BitapSearch(Text,Pattern):\n    \n    T_MAX = 1000000\n    P_MAX = 1000\n    R = ~1\n\n    pattern_mask = [ ~0 for _ in range(T_MAX)]\n    \n    for i in range(len(Pattern)):\n        pattern_mask[ord(Pattern[i])] &= ~(1 << i)\n    \n    for i in range(len(Text)):\n        R = R|pattern_mask[ord(Text[i])]\n        R = R << 1\n        if R & (1 << len(Pattern)) == 0:\n            return True\n    \n    return False\n\nText = input()\nn = int(input())\n\nfor _ in range(n):\n    Pattern = input()\n\n    if BitapSearch(Text,Pattern):\n        print(1)\n    else:\n        print(0)"
  },
  {
    "language": "Python",
    "code": "s=input()\nn=int(input())\nfor _ in range(n):\n    b=input()\n    print(int(b in s))"
  },
  {
    "language": "Python",
    "code": "def check(T,LT,p):\n    lp=len(p)\n    for i in range(LT-lp+1):\n        if T[i:i+lp]==p:\n            print(\"1\")\n            return\n    print(\"0\")\n\nT = input()\nLT = len(T)\nq = int(input())\nfor i in range(q):\n    p = input()\n    check(T,LT,p)"
  },
  {
    "language": "Python",
    "code": "base = 127\nmask = (1 << 32) - 1\n\n\ndef calc_hash(f, pl, tl):\n    dl = tl - pl\n    tmp = set()\n\n    t = 1\n    for _ in range(pl):\n        t = (t * base) & mask\n    e = 0\n    for i in range(pl):\n        e = e * base + f[i]\n    for i in range(dl):\n        tmp.add(e)\n        e = (e * base - t * f[i] + f[i + pl]) & mask\n    tmp.add(e)\n    return tmp\n\n\nt = [ord(c) for c in input().strip()]\ntl = len(t)\nq = int(input())\nh = dict()\nwhile q:\n    p = [ord(c) for c in input().strip()]\n    pl = len(p)\n    if pl > tl:\n        print(0)\n        q -= 1\n        continue\n    key = calc_hash(p, pl, pl).pop() & mask\n    if pl in h:\n        haystack = h[pl]\n    else:\n        haystack = calc_hash(t, pl, tl)\n        h[pl] = haystack\n    print(1 if key in haystack else 0)\n    q -= 1"
  },
  {
    "language": "Python",
    "code": "import sys\nCSIZE = 256\nbuff = input()\nn = int(input())\n\n\n\ndef make_BM_table(pattern):\n    table = [len(pattern) ] * CSIZE\n    for i in range(len(pattern)):\n        dist = len(pattern) - i - 1\n        table[ord(pattern[i])] = dist\n    return table\n\ndef BM_search(pattern,buff):\n    table = make_BM_table(pattern)\n    i = len(pattern) - 1\n    while i < len(buff) - 1:\n        for k in range(len(pattern)):\n            if pattern[len(pattern)-k-1] != buff[i - k]:\n                i += max(table[ord(buff[i-k])] - (-k-1) ,1)\n                break\n        else: \n            print(\"1\")\n            break\n    else:\n        print(\"0\")\n        \nfor i in range(n):\n    pattern = input()\n    BM_search(pattern, buff)"
  },
  {
    "language": "Python",
    "code": "T=input()\nfor _ in[0]*int(input()):print((input()in T)*1)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nT = input()\nt = len(T)\nn = int(input())\nP = deque(sys.stdin.readlines())\nfor i in range(n):\n    p = P.popleft()\n    m = len(p)-1\n    for k in range(t-m+1):\n        for i in range(m):\n            if p[i] != T[k+i]:\n                break\n        else:\n            print(1)\n            break\n    else:\n        print(0)"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\noriginal_string = input()\ncheck_string_count = int(input())\ncheckers = [input() for i in range(check_string_count)]\nfor checker in checkers:\n    print(1 if checker in original_string else 0)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport sys\nfrom collections import OrderedDict\n\n\ndef main():\n    inputStr = sys.stdin.read()\n    lines = inputStr.split(\"\\n\")\n    text, words = lines[0], lines[2:-1]\n    words_by_length = {}\n    for i, word in enumerate(words):\n        if len(word) in words_by_length:\n            words_by_length[len(word)].append((i, word))\n        else:\n            words_by_length[len(word)] = [(i, word)]\n    words_by_length = OrderedDict(sorted(words_by_length.items(), key=lambda t: t[0]))\n    found_indices = set([])\n    text_length = len(text)\n    for i in range(text_length):\n        for word_length, words_by_index in words_by_length.items():\n            if i + word_length > text_length:\n                break\n            sliced = text[i:(i + word_length)]\n            founds = []\n            for j, (index, word) in enumerate(words_by_index):\n                if sliced == word:\n                    found_indices.add(index)\n                    founds.insert(0, j)\n            for j in founds:\n                words_by_index.pop(j)\n\n    for i in range(len(words)):\n        if i in found_indices:\n            print(1)\n        else:\n            print(0)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "T = input()\nn = int(input())\nP = input()\n\nfor a in range(n):\n    for i in range(len(T)-len(P)+1):\n        if T[i:i+len(P)] == P:\n            print(1)\n            return\n        else:\n            print(0)\n            return\n            "
  },
  {
    "language": "Python",
    "code": "s=input()\nfor _ in range(int(input())):print(int(input() in s))"
  },
  {
    "language": "Python",
    "code": "base = 127\nmask = (1 << 32) - 1\ndef calc_hash(f, pl, tl):\n    dl = tl - pl\n    tmp = set()\n    t = 1\n    for _ in range(pl):\n        t = (t * base) & mask\n    e = 0\n    for i in range(pl):\n        e = (e * base + f[i]) & mask\n    for i in range(dl):\n        tmp.add(e)\n        e = (e * base - t * f[i] + f[i + pl]) & mask\n    tmp.add(e)\n    return tmp\nt = tuple(ord(c) for c in input())\ntl = len(t)\nq = int(input())\nh = dict()\nc = dict()\na = []\nfor _ in range(q):\n    p = input()\n    if p in c:\n        a.append(c[p])\n        continue\n    p = tuple(ord(c) for c in p)\n    pl = len(p)\n    if pl > tl:\n        a.append(\"0\")\n        continue\n    bs = min(19, pl)\n    keys = calc_hash(p, bs, pl)\n    if bs not in h:\n        h[bs] = calc_hash(t, bs, tl)\n    a.append(\"1\" if keys.issubset(h[bs]) else \"0\")\nprint('\\n'.join(a))\n\n"
  },
  {
    "language": "Python",
    "code": "x = input()\nn = int(input())\n\n\ndef check(string,word):\n    search_state = 0\n    l = len(string)\n    i = 0\n    while (i < l):\n        # print(string[i])\n        if i+search_state < l and string[i+search_state] == word[search_state]:\n            search_state += 1\n            if search_state == len(word):\n                return 1\n        else:\n            i += max(search_state,1)\n            search_state = 0\n            \n    return 0\n            \n# print(check(x,'baa'))\n    \nfor i in range(n):\n    y = input()\n    print(check(x,y))\n        \n        \n        \n"
  },
  {
    "language": "Python",
    "code": "x = input()\nn = int(input())\n\n\ndef check(string,word):\n    search_state = 0\n    first_match = 0\n    l = len(string)\n    i = 0\n    while (i < l):\n        if i+len(word) >= l:\n            break\n        if word[0] != string[i] or word[-1] != string[i+len(word)-1]:\n            i += 1\n            continue\n        # print(string[i])\n        if string[i+search_state] == word[search_state]:\n            if first_match == 0:\n                first_match = search_state\n            search_state += 1\n            if search_state == len(word):\n                return 1\n        else:\n            i += max(min(first_match,search_state),1)\n            search_state = 0\n            \n    return 0\n            \n# print(check(x,'baa'))\n    \nfor i in range(n):\n    y = input()\n    print(check(x,y))\n    \n# for i in range(n):\n#     y = input()\n#     print(str(i) + y)\n#     # if y in x:\n    #     print(i + 1)\n    # else:\n    #     print(i + 0)\n        \n        \n        \n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom math import floor, log\n\n\nclass NoMatch(Exception):\n    pass\n\n\nclass IndexMatch:\n\n    def __init__(self, text):\n        self.text = text\n        self.keylen = self._select_keylen()\n        self.index = self._create_index()\n        # print(self.index)\n\n    def _select_keylen(self):\n        chars = set(list(self.text))\n        return floor(log(len(self.text), len(chars)))\n\n    def _create_index(self):\n        index = defaultdict(set)\n        for i in range(len(self.text)+1):\n            for j in range(max(i-self.keylen, 0), i):\n                index[self.text[j:i]].add(j)\n        return index\n\n    def match(self, search_text):\n        def _match(lo, hi):\n            text = search_text[lo:hi]\n            if hi-lo <= self.keylen or text in self.index:\n                # print(text, self.index[text])\n                return self.index[text]\n\n            mid = (lo + hi) // 2\n            pre = _match(lo, mid)\n            post = _match(mid, hi)\n\n            if len(pre) == 0 or len(post) == 0:\n                raise NoMatch()\n\n            indices = set(i for i in pre if i+mid-lo in post)\n            self.index[text] = indices\n            # print(text, hi, lo, mid, len(pre), len(post), len(indices))\n            return indices\n\n        try:\n            match = _match(0, len(search_text))\n            return len(match) > 0\n        except NoMatch:\n            return False\n\n\ndef run():\n    s1 = input()\n    n = int(input())\n\n    matcher = IndexMatch(s1)\n    for _ in range(n):\n        s2 = input()\n        if matcher.match(s2):\n            print(1)\n        else:\n            print(0)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "T = input()\nq = int(input())\nfor i in range(q):\n    p = input()\n    if p in T:\n        print(\"1\")\n    else:\n        print(\"0\")"
  },
  {
    "language": "Python",
    "code": "import sys\nCSIZE = 256\nbuff = input()\nn = int(input())\n\n\n\ndef make_BM_table(pattern):\n    table = [len(pattern) ] * CSIZE\n    for i in range(len(pattern)):\n        dist = len(pattern) - i - 1\n        table[ord(pattern[i])] = dist\n    return table\n\ndef BM_search(pattern,buff):\n    table = make_BM_table(pattern)\n    i = len(pattern) - 1\n    while i < len(buff) :\n        for k in range(len(pattern)):\n            \n            if pattern[len(pattern)-k-1] != buff[i - k]:\n                i += max(table[ord(buff[i-k])] -k-1 ,1)\n                break\n        else: \n            print(\"1\")\n            break\n    else:\n        print(\"0\")\n        \nfor i in range(n):\n    pattern = input()\n    BM_search(pattern, buff)"
  },
  {
    "language": "Python",
    "code": "base = 127\nmask = (1 << 32) - 1\n\ndef calc_hash(lstr, pl, tl):\n    dl = tl - pl\n    tmp = set()\n\n    d = 1\n    for _ in range(pl):\n        d = (d * base) & mask\n    e = 0\n    for i in range(pl):\n        e = (e * base + lstr[i]) & mask\n    for i in range(dl):\n        tmp.add(e)\n        e = (e * base - d * lstr[i] + lstr[i + pl]) & mask\n    tmp.add(e)\n    return tmp\n\n\nt = [ord(c) for c in input().strip()]\ntl = len(t)\nq = int(input())\nps = [input().strip() for _ in range(q)]\nh = dict()\ndic = dict()\na = []\nfor pp in ps:\n    if pp in dic:\n        a.append(dic[pp])\n        continue\n    p = [ord(c) for c in pp]\n    pl = len(p)\n    if pl > tl:\n        a.append(0)\n        continue\n    bs = min(19, pl)\n    keys = calc_hash(p, bs, pl)\n    if bs not in h:\n        h[bs] = calc_hash(t, bs, tl)\n#    print(\"hb\", keys, h[bs])\n    a.append(1 if keys.issubset(h[bs]) else 0) #keysがh[bs]に含まれるか\n    dic[pp] = a[-1]\nprint('\\n'.join(map(str, a)))\n\n\n"
  },
  {
    "language": "Python",
    "code": "\ndef isEqual(T,P):\n    for i in range(len(T)-len(P)+1):\n        if T[i:i+len(P)] == P:\n            return 1\n    return 0\n\nT = input()\nn = int(input())\n\nfor i in range(n):\n    P = input()\n    print(isEqual(T,P))"
  },
  {
    "language": "Python",
    "code": "base = 127\nmask = (1 << 32) - 1\n\n\ndef calc_hash(f, pl, tl):\n    dl = tl - pl\n    tmp = set()\n\n    t = 1\n    for _ in range(pl):\n        t = (t * base) & mask\n    e = 0\n    for i in range(pl):\n        e = (e * base + f[i]) & mask\n    for i in range(dl):\n        tmp.add(e)\n        e = (e * base - t * f[i] + f[i + pl]) & mask\n    tmp.add(e)\n    return tmp\n\n\nt = [ord(c) for c in input().strip()]\ntl = len(t)\nq = int(input())\nps = [input().strip() for _ in range(q)]\nh = dict()\nc = dict()\na = []\nfor p in ps:\n    if p in c:\n        a.append(c[p])\n        continue\n    p = [ord(c) for c in p]\n    pl = len(p)\n    if pl > tl:\n        a.append(0)\n        continue\n    bs = min(19, pl)\n    keys = calc_hash(p, bs, pl)\n    if bs not in h:\n        h[bs] = calc_hash(t, bs, tl)\n    a.append(1 if keys.issubset(h[bs]) else 0)\nprint('\\n'.join(map(str, a)))"
  },
  {
    "language": "Python",
    "code": "base = 127\nmask = (1 << 32) - 1\n\n\ndef calc_hash(f, pl, tl):\n    dl = tl - pl\n    tmp = set()\n\n    t = 1\n    for _ in range(pl):\n        t = (t * base) & mask\n    e = 0\n    for i in range(pl):\n        e = e * base + f[i]\n    for i in range(dl):\n        tmp.add(e)\n        e = (e * base - t * f[i] + f[i + pl]) & mask\n    tmp.add(e)\n    return tmp\n\n\nt = [ord(c) for c in input().strip()]\ntl = len(t)\nq = int(input())\nh = dict()\nwhile q:\n    p = [ord(c) for c in input().strip()]\n    pl = len(p)\n    key = calc_hash(p, pl, pl).pop() & mask\n    if pl in h:\n        haystack = h[pl]\n    else:\n        haystack = calc_hash(t, pl, tl)\n        h[pl] = haystack\n    print(1 if key in haystack else 0)\n    q -= 1"
  },
  {
    "language": "Python",
    "code": "T = input()\nn = int(input())\nfor i in range(n):\n p = input()\n print(1 if p in T else 0)"
  },
  {
    "language": "Python",
    "code": "t = input()\nq = int(input())\n\nfor i in range(q):\n    p = input()\n    if p in t:\n        print(1)\n    else:\n        print(0)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom math import floor, log \n\n\nclass NoMatch(Exception):\n    pass\n\n\nclass IndexMatch:\n    MAX_KEYLEN = 10\n\n    def __init__(self, text):\n        self.text = text\n        self.keylen = self._select_keylen()\n        self._create_index()\n\n    def _select_keylen(self):\n        chars = set(list(self.text))\n        return min(floor(log(len(self.text), len(chars))), self.MAX_KEYLEN)\n\n    def _create_index(self):\n        index = defaultdict(set)\n        particles = set()\n        for i in range(len(self.text)+1):\n            for j in range(max(i-self.keylen, 0), i): \n                if i - j < self.keylen // 2:\n                    particles.add(self.text[j:i])\n                else:\n                    index[self.text[j:i]].add(j)\n        self.index = index\n        self.particles = particles\n\n    def match(self, search_text):\n        def _match(lo, hi):\n            text = search_text[lo:hi]\n            if hi-lo <= self.keylen:\n                return self.index[text]\n\n            mid = (lo + hi) // 2\n            pre = _match(lo, mid)\n            post = _match(mid, hi) \n\n            if len(pre) == 0 or len(post) == 0:\n                raise NoMatch()\n\n            indices = set(i for i in pre if i+mid-lo in post)\n            return indices\n\n        if len(search_text) < self.keylen // 2:\n            return search_text in self.particles\n\n        try:\n            match = _match(0, len(search_text))\n            return len(match) > 0 \n        except NoMatch:\n            return False\n\n\ndef run():\n    s1 = input()\n    n = int(input())\n\n    matcher = IndexMatch(s1)\n    for _ in range(n):\n        s2 = input()\n        if matcher.match(s2):\n            print(1)\n        else:\n            print(0)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "x = input()\nn = int(input())\n\n\ndef check(string,word):\n    search_state = 0\n    l = len(string)\n    i = 0\n    while (i < l):\n        # print(string[i])\n        if string[i+search_state] == word[search_state]:\n            search_state += 1\n            if search_state == len(word):\n                return 1\n        else:\n            i += max(search_state,1)\n            search_state = 0\n            \n    return 0\n            \n# print(check(x,'baa'))\n    \nfor i in range(n):\n    y = input()\n    print(check(x,y))\n        \n        \n        \n"
  },
  {
    "language": "Python",
    "code": "base = 127\nmask = (1 << 32) - 1\n\n\ndef calc_hash(f, pl, tl):\n    dl = tl - pl\n    tmp = set()\n\n    t = 1\n    for _ in range(pl):\n        t = (t * base) & mask\n    e = 0\n    for i in range(pl):\n        e = (e * base + f[i]) & mask\n    for i in range(dl):\n        tmp.add(e)\n        e = (e * base - t * f[i] + f[i + pl]) & mask\n    tmp.add(e)\n    return tmp\n\n\nt = [ord(c) for c in input().strip()]\ntl = len(t)\nq = int(input())\nh = dict()\nwhile q:\n    p = [ord(c) for c in input().strip()]\n    pl = len(p)\n    if pl > tl:\n        print(0)\n        q -= 1\n        continue\n    bs = min(20, pl)\n    keys = calc_hash(p, bs, pl)\n    if bs not in h:\n        h[bs] = calc_hash(t, bs, tl)\n    print(1 if keys.issubset(h[bs]) else 0)\n    q -= 1"
  },
  {
    "language": "Python",
    "code": "#coding:utf-8\n\ndef MSM(T,P):\n    Tlist=list(T)\n    Plist=list(P)\n    if len(Tlist)<len(Plist):\n        return 0\n    for i in range(len(Tlist)):\n        ans=0\n        if Tlist[i]==Plist[0]:\n            ans+=1\n            if len(Plist)>1 and len(Tlist[i:])>len(Plist):\n                for j in range(1,len(Plist)):\n                    if Plist[j]==Tlist[i+j] and i+j<=len(Tlist):\n                        ans+=1\n        if ans==len(Plist):\n            return 1\n    return 0\n\nif __name__==\"__main__\":\n    T=input()\n    n=int(input())\n    ans=[]\n    for i in range(n):\n        P=input()\n        ans.append(MSM(T,P))\n    for i in range(n):\n        print(ans[i])\n        \n            "
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom math import floor, log \n\n\nclass NoMatch(Exception):\n    pass\n\n\nclass IndexMatch:\n    MAX_KEYLEN = 15\n\n    def __init__(self, text):\n        self.text = text\n        self.keylen = self._select_keylen()\n        self._create_index()\n\n    def _select_keylen(self):\n        chars = set(list(self.text))\n        return min(floor(log(len(self.text), len(chars))), self.MAX_KEYLEN)\n\n    def _create_index(self):\n        index = defaultdict(set)\n        particles = set()\n        for i in range(len(self.text)+1):\n            for j in range(max(i-self.keylen, 0), i): \n                if i - j < self.keylen // 2:\n                    particles.add(self.text[j:i])\n                else:\n                    index[self.text[j:i]].add(j)\n        self.index = index\n        self.particles = particles\n\n    def match(self, search_text):\n        def _match(lo, hi):\n            text = search_text[lo:hi]\n            if hi-lo <= self.keylen:\n                return self.index[text]\n\n            mid = (lo + hi) // 2\n            pre = _match(lo, mid)\n            post = _match(mid, hi) \n\n            if len(pre) == 0 or len(post) == 0:\n                raise NoMatch()\n\n            indices = set(i for i in pre if i+mid-lo in post)\n            return indices\n\n        if len(search_text) < self.keylen // 2:\n            return search_text in self.particles\n\n        try:\n            match = _match(0, len(search_text))\n            return len(match) > 0 \n        except NoMatch:\n            return False\n\n\ndef run():\n    s1 = input()\n    n = int(input())\n\n    matcher = IndexMatch(s1)\n    for _ in range(n):\n        s2 = input()\n        if matcher.match(s2):\n            print(1)\n        else:\n            print(0)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "T = input()\nP = int(input())\nfor i in range(P):\n    tmp = input()\n    if tmp in T:\n        print(1)\n    else:\n        print(0)\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\noriginal_string = input()\ncheck_string_count = int(input())\ncheckers = [input() for i in range(check_string_count)]\nfor checker in checkers:\n    skip = False\n    for char in list(checker):\n        if char not in original_string:\n            skip = True\n            break\n    if skip:\n        print(0)\n        continue\n    print(1 if checker in original_string else 0)"
  },
  {
    "language": "Python",
    "code": "from __future__ import print_function\nt = raw_input()\nn = int(raw_input())\n[print(1) if raw_input() in t else print(0) for x in xrange(n)]"
  },
  {
    "language": "Python",
    "code": "T = input()\nQ = int(input())\nfor line in range(Q):\n    P = input()\n    print(1 if P in T else 0)"
  },
  {
    "language": "Python",
    "code": "from typing import Dict, List\n\n\ndef calc_hash(input_v: List[int], target_len: int, input_len: int) -> set:\n    global base, mask\n    diff_len = input_len - target_len\n    hash_set = set()\n\n    bit_mask = 1\n    for _ in range(target_len):\n        bit_mask = (bit_mask * base) & mask\n    hash_v = 0\n    for i in range(target_len):\n        hash_v = (hash_v * base + input_v[i]) & mask\n    for i in range(diff_len):\n        hash_set.add(hash_v)\n        hash_v = (hash_v * base - bit_mask * input_v[i]\n                  + input_v[i + target_len]) & mask\n    hash_set.add(hash_v)\n\n    return hash_set\n\n\nif __name__ == \"__main__\":\n    base = 123  # Ascii code after 'z'\n    mask = (1 << 32) - 1  # Mask.\n\n    input_v = [ord(s) for s in input()]\n    input_len = len(input_v)\n\n    checked_dict: Dict[int, set] = {}\n    num_target = int(input())\n\n    for _ in range(num_target):\n        target_v = [ord(s) for s in input()]\n        target_len = len(target_v)\n        if input_len < target_len:\n            print(0)\n            continue\n        magic_len = min(19, target_len)  # Magic number to reduce calc time.\n        key = calc_hash(target_v, magic_len, target_len)\n        if magic_len not in checked_dict:\n            checked_dict[magic_len] = calc_hash(input_v, magic_len, input_len)\n        if key.issubset(checked_dict[magic_len]):\n            print(1)\n        else:\n            print(0)\n\n"
  },
  {
    "language": "Python",
    "code": "\ndef isEqual(T,P):\n    for i in range(len(T)-len(P)+1):\n        if T[i:i+len(P)] == P:\n            return 1\n    return 0\n\nif __name__ == '__main__':\n    T = input()\n    n = int(input())\n\n    for i in range(n):\n        P = input()\n        print(isEqual(T,P))\n        "
  },
  {
    "language": "Python",
    "code": "#coding:utf-8\n\n# ?§????????????????????????????\ndef make_BM_table(P):\n    CSIZE = 256\n    bm_table = [len(P)]*CSIZE\n    for i in range(len(P)-1):\n        bm_table[ord(P[i])] = len(P)-i\n    \n    return bm_table\n\n# ?????????????´¢\ndef BM_string_search(T,P):\n    \n    # ??????????????´????????????\n    if len(T) == 0 or len(P) == 0 or len(P) > len(T):\n        return False\n\n    bm_table = make_BM_table(P)\n\n    # k???T????????????P?????????\n    k = len(T)-1\n\n    while True:\n        \n        # k???len(T)??\\???????????£??????break\n        if k >= len(T):\n            break\n\n        # i???P?????????????????????????????????\n        i = len(P)-1 \n        # h???T?????????????????????????????????\n        h = k\n        \n        while i >= 0 and h > -1 and P[i] == T[h]:\n            i -= 1\n            h -= 1\n        \n        # i<0?????????P??¨?????´??????\n        if i < 0:\n            return True\n        \n        # ??¢?´¢????????¨????????§????????£????????????????????????\n        else:\n            k += max(bm_table[ord(T[i])],len(P)-h)\n    \n    return False\n\n\nif __name__ == '__main__':\n\n    # ?????????????????\\???\n    T = input()\n    # ????´¢?????????????????°?????\\???\n    n = int(input())\n\n    # ????????????????????????????????????????????\\???\n    for i in range(n):\n        P = input()\n\n        if BM_string_search(T,P):\n            print(1)\n        else:\n            print(0)"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\ndef searchPatterns(origin_string, length):\n    patterns = []\n    for index in range(0, len(origin_string)-(length-1)):\n        patterns.append(original_string[index:index+length])\n    return patterns\n\noriginal_string = input()\noriginal_patterns = [None for i in range(len(original_string))]\ncheck_string_count = int(input())\ncheckers = [input() for i in range(check_string_count)]\nfor checker in checkers:\n    if len(checker) > len(original_string):\n        print(0)\n        continue\n    if original_patterns[len(checker)] == None:\n        original_patterns[len(checker)] = searchPatterns(original_patterns, len(checker))\n    print(1 if checker in original_patterns[len(checker)] else 0)"
  },
  {
    "language": "Python",
    "code": "T = input()\nn = int(input())\nfor i in range(n):\n    P = input()\n    if P in T:\n        print(1)\n    else:\n        print(0)"
  },
  {
    "language": "Python",
    "code": "base = 127\nmask = (1 << 32) - 1\n\n\ndef calc_hash(f, pl, tl, with_array):\n    dl = tl - pl\n    tmp = []\n\n    t = 1\n    for _ in range(pl):\n        t = (t * base) & mask\n    e = 0\n    for i in range(pl):\n        e = (e * base + f[i]) & mask\n    for i in range(dl):\n        tmp.append(e)\n        e = (e * base - t * f[i] + f[i + pl]) & mask\n    tmp.append(e)\n    if with_array:\n        return set(tmp), tmp\n    else:\n        return set(tmp)\n\n\nt = [ord(c) for c in input().strip()]\ntl = len(t)\nq = int(input())\nh = dict()\nwhile q:\n    p = [ord(c) for c in input().strip()]\n    pl = len(p)\n    if pl > tl:\n        print(0)\n        q -= 1\n        continue\n    if pl >= 10:\n        keys_set, keys_array = calc_hash(p, 10, pl, with_array=True)\n        keys0, keys1 = keys_array[0], keys_array[1:pl - 9]\n        if pl not in h:\n            hash_set, hash_array = h[10] = calc_hash(t, 10, tl, with_array=True)\n        else:\n            hash_set, hash_array = h[10]\n\n        if keys_set.issubset(hash_set):\n            for idx, hash in enumerate(hash_array):\n                if keys0 == hash and hash_array[idx + 1:idx + pl - 9] == keys1:\n                    print(1)\n                    break\n            else:\n                print(0)\n        else:\n            print(0)\n    else:\n        key = calc_hash(p, pl, pl, with_array=False).pop() & mask\n        if pl not in h:\n            h[pl] = calc_hash(t, pl, tl, with_array=False)\n        print(1 if key in h[pl] else 0)\n    q -= 1"
  },
  {
    "language": "Python",
    "code": "T = input()\nQ = int(input())\nP = [input() for i in range(Q)]\nfor p in P:\n\tprint(1 if T.find(p) != -1 else 0)"
  },
  {
    "language": "Python",
    "code": "import sys\nT = input()\nt = len(T)\nn = int(input())\nP = sys.stdin.readlines()\nfor i in range(n):\n    p = P[i]\n    m = len(p)-1\n    for k in range(t-m+1):\n        for i in range(m):\n            if p[i] != T[k+i]:\n                break\n        else:\n            print(1)\n            break\n    else:\n        print(0)\n                "
  },
  {
    "language": "Python",
    "code": "if __name__ == '__main__':\n    # ???????????\\???\n    # T = 'aabaaa'\n    seartch_pattern = []\n    # seartch_pattern.append('aa')\n    # seartch_pattern.append('ba')\n    # seartch_pattern.append('bb')\n    # seartch_pattern.append('xyz')\n\n    T = input()\n    num = int(input())\n    for _ in range(num):\n        seartch_pattern.append(input())\n\n    # ????´¢??????\n    results = []\n    for p in seartch_pattern:\n        if p in T:\n            results.append(1)\n        else:\n            results.append(0)\n\n    # ???????????¨???\n    for r in results:\n        print(r)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom math import ceil, log\n\n\nclass IndexMatch:\n    def __init__(self, text):\n        self.text = text\n        self.keylen = self._select_keylen()\n        self.index = self._create_index()\n\n    def _select_keylen(self):\n        chars = set(list(self.text))\n        return ceil(log(len(self.text), len(chars)))\n\n    def _create_index(self):\n        index = defaultdict(list)\n        index[self.text[0]].append(0)\n        st1 = [self.text[0]]\n        st2 = []\n\n        for i in range(1, len(self.text)):\n            c = self.text[i]\n            index[c].append(i)\n            st2 = [c]\n            while len(st1) > 0:\n                s = st1.pop() + c\n                index[s].append(i-len(s)+1)\n                if len(s) <= self.keylen:\n                    st2.append(s)\n            st1, st2 = st2, st1\n\n        return index\n\n    def match(self, search_text):\n        def _match(text):\n            ls = len(text)\n            if ls <= 2 or text in self.index:\n                return self.index[text]\n\n            mid = ls // 2\n            pre = _match(text[:mid])\n            post = _match(text[mid:])\n\n            if len(pre) == 0 or len(post) == 0:\n                return []\n\n            indices = [i for i in pre if (i+mid) in post]\n            self.index[text] = indices\n            return indices\n\n        return len(_match(search_text)) > 0\n\n\ndef run():\n    s1 = input()\n    n = int(input())\n\n    matcher = IndexMatch(s1)\n    for _ in range(n):\n        s2 = input()\n        if matcher.match(s2):\n            print(1)\n        else:\n            print(0)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "base = 127\nmask = (1 << 32) - 1\ndef calc_hash(f, pl, tl):\n    dl = tl - pl\n    tmp = set()\n    t = 1\n    for _ in range(pl):\n        t = (t * base) & mask\n    e = 0\n    for i in range(pl):\n        e = (e * base + f[i]) & mask\n    for i in range(dl):\n        tmp.add(e)\n        e = (e * base - t * f[i] + f[i + pl]) & mask\n    tmp.add(e)\n    return tmp\nt = tuple(ord(c) for c in input())\ntl = len(t)\nq = int(input())\nh = dict()\nc = dict()\na = []\nfor _ in range(q):\n    p = input()\n    if p in c:\n        a.append(c[p])\n        continue\n    p = tuple(ord(c) for c in p)\n    pl = len(p)\n    if pl > tl:\n        a.append(\"0\")\n        continue\n    bs = min(19, pl)\n    keys = calc_hash(p, bs, pl)\n    if bs not in h:\n        h[bs] = calc_hash(t, bs, tl)\n    a.append(\"1\" if keys <= h[bs] else \"0\")\nprint('\\n'.join(a))\n"
  },
  {
    "language": "Python",
    "code": "x = input()\nn = int(input())\n\nfor i in range(n):\n    y = input()\n    if y in x:\n        print(1)\n    else:\n        print(0)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nbase = 127\nmask = (1 << 32) - 1\ndef calc_hash(f, pl, tl):\n    dl = tl - pl\n    tmp = set()\n    t = 1\n    for _ in range(pl):\n        t = (t * base) & mask\n    e = 0\n    for i in range(pl):\n        e = (e * base + f[i]) & mask\n    for i in range(dl):\n        tmp.add(e)\n        e = (e * base - t * f[i] + f[i + pl]) & mask\n    tmp.add(e)\n    return tmp\nt = tuple(ord(c) for c in input())\ntl = len(t)\nq = int(input())\nh = dict()\nc = dict()\na = []\nfor _ in range(q):\n    p = readline().strip()\n    if p in c:\n        a.append(c[p])\n        continue\n    p = tuple(ord(c) for c in p)\n    pl = len(p)\n    if pl > tl:\n        a.append(0)\n        continue\n    bs = min(19, pl)\n    keys = calc_hash(p, bs, pl)\n    if bs not in h:\n        h[bs] = calc_hash(t, bs, tl)\n    a.append(1 if keys.issubset(h[bs]) else 0)\nprint('\\n'.join(map(str, a)))\n\n"
  },
  {
    "language": "Python",
    "code": "\ndef search1(T,P):\n    \n    if P in T:\n        print(1)\n    else:\n        print(0)\n\ndef search2(T,line):\n    \n    if line in T:\n        return True\n    else:\n        return False\n    \n\nT = input()\nn = int(input())\n\n\nfor i in range(n):\n    \n    P = input()\n    \n    if len(P) < 500:\n        \n        search1(T,P)\n\n    else:\n\n        line = P[0:250]\n        if search2(T,line):\n            search1(T,P)\n        else:\n            print(0)"
  },
  {
    "language": "Python",
    "code": "x = input()\nn = int(input())\n\n\ndef check(string,word):\n    search_state = 0\n    first_match = 0\n    l = len(string)\n    i = 0\n    while (i < l):\n        # print(string[i])\n        if i+search_state < l and string[i+search_state] == word[search_state]:\n            if first_match == 0:\n                first_match = search_state\n            search_state += 1\n            if search_state == len(word):\n                return 1\n        else:\n            i += max(min(first_match,search_state),1)\n            search_state = 0\n            \n    return 0\n            \n# print(check(x,'baa'))\n    \nfor i in range(n):\n    y = input()\n    print(i + check(x,y))\n    \n# for i in range(n):\n#     y = input()\n#     print(str(i) + y)\n#     # if y in x:\n    #     print(i + 1)\n    # else:\n    #     print(i + 0)\n        \n        \n        \n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport sys\nfrom collections import OrderedDict\n\n\ndef main():\n    inputStr = sys.stdin.read()\n    lines = inputStr.split(\"\\n\")\n    text, words = lines[0], lines[2:-1]\n    words_by_length = {}\n    for i, word in enumerate(words):\n        if len(word) in words_by_length:\n            words_by_length[len(word)].append((i, word))\n        else:\n            words_by_length[len(word)] = [(i, word)]\n    words_by_length = OrderedDict(sorted(words_by_length.items(), key=lambda t: t[0]))\n    found_indices = set([])\n    text_length = len(text)\n    for i in range(text_length):\n        for word_length, words_by_index in words_by_length.items():\n            if i + word_length >= text_length:\n                break\n            sliced = text[i:(i + word_length)]\n            founds = []\n            for i, (index, word) in enumerate(words_by_index):\n                if sliced == word:\n                    found_indices.add(index)\n                    founds.insert(0, i)\n            for i in founds:\n                words_by_index.pop(i)\n\n    for i in range(len(words)):\n        if i in found_indices:\n            print(1)\n        else:\n            print(0)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "base = 127\nmask = (1 << 32) - 1\ndef calc_hash(f, pl, tl):\n    dl = tl - pl\n    tmp = set()\n    t = 1\n    for _ in range(pl):\n        t = (t * base) & mask\n    e = 0\n    for i in range(pl):\n        e = (e * base + f[i]) & mask\n    for i in range(dl):\n        tmp.add(e)\n        e = (e * base - t * f[i] + f[i + pl]) & mask\n    tmp.add(e)\n    return tmp\nt = tuple(ord(c) for c in input())\ntl = len(t)\nq = int(input())\nh = dict()\nc = dict()\na = []\nfor _ in range(q):\n    p = input()\n    if p in c:\n        a.append(c[p])\n        continue\n    p = tuple(ord(c) for c in p)\n    pl = len(p)\n    if pl > tl:\n        a.append(0)\n        continue\n    bs = min(19, pl)\n    keys = calc_hash(p, bs, pl)\n    if bs not in h:\n        h[bs] = calc_hash(t, bs, tl)\n    a.append(1 if keys.issubset(h[bs]) else 0)\nprint('\\n'.join(map(str, a)))\n\n"
  },
  {
    "language": "Python",
    "code": "base = 127\nmask = (1 << 32) - 1\n\n\ndef calc_hash(f, pl, tl):\n    dl = tl - pl\n    tmp = set()\n\n    t = 1\n    for _ in range(pl):\n        t = (t * base) & mask\n    e = 0\n    for i in range(pl):\n        e = (e * base + f[i]) & mask\n    for i in range(dl):\n        tmp.add(e)\n        e = (e * base - t * f[i] + f[i + pl]) & mask\n    tmp.add(e)\n    return tmp\n\n\nt = [ord(c) for c in input().strip()]\ntl = len(t)\nq = int(input())\nps = [input().strip() for _ in range(q)]\nh = dict()\nc = dict()\na = []\nfor p in ps:\n    if p in c:\n        a.append(c[p])\n        continue\n    p = [ord(c) for c in p]\n    pl = len(p)\n    if pl > tl:\n        a.append(0)\n        continue\n    bs = min(16, pl)\n    keys = calc_hash(p, bs, pl)\n    if bs not in h:\n        h[bs] = calc_hash(t, bs, tl)\n    a.append(1 if keys.issubset(h[bs]) else 0)\nprint('\\n'.join(map(str, a)))"
  },
  {
    "language": "Python",
    "code": "base = 127\nmask = (1 << 32) - 1\n\n\ndef calc_hash(f, pl, tl):\n    dl = tl - pl\n    tmp = set()\n\n    t = 1\n    for _ in range(pl):\n        t = (t * base) & mask\n    e = 0\n    for i in range(pl):\n        e = (e * base + f[i]) & mask\n    for i in range(dl):\n        tmp.add(e)\n        e = (e * base - t * f[i] + f[i + pl]) & mask\n    tmp.add(e)\n    return tmp\n\n\nt = [ord(c) for c in input().strip()]\ntl = len(t)\nq = int(input())\nps = [input().strip() for _ in range(q)]\nh = dict()\na = []\nhash_len = 19\nfor p in ps:\n    p = [ord(c) for c in p]\n    pl = len(p)\n    if pl > tl:\n        a.append(0)\n        continue\n    bs = min(hash_len, pl)\n    keys = calc_hash(p, bs, pl)\n    if bs not in h:\n        h[bs] = calc_hash(t, bs, tl)\n    a.append(1 if keys.issubset(h[bs]) else 0)\nprint('\\n'.join(map(str, a)))"
  },
  {
    "language": "Python",
    "code": "T = input()\nn = int(input())\n\n\nfor i in range(n):\n    P = input()\n    \n    if T in P:\n        print(1)\n    else:\n        print(0)"
  },
  {
    "language": "Python",
    "code": "import re\nT = input()\nP = int(input())\nfor i in range(P):\n    tmp = re.compile(input())\n    obj = re.search(tmp,T)\n    if obj:\n        print(1)\n    else:\n        print(0)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, Counter\nfrom math import floor, ceil, log\nfrom heapq import heapreplace, heappush\nimport time\n\nclass TreeIndex:\n\n    class Node:\n        __slots__ = ('level', 'keys', 'values', 'keylen', '_cache', '_cacheq')\n\n        def __init__(self, level):\n            self.level = level\n            self.values = []\n            self.keys = {}\n            self.keylen = 2 ** self.level\n            self._init_cache()\n\n        def add(self, text, value):\n            def _add(node, t):\n                if len(t) == 0:\n                    node.values.append(value)\n                    return node\n\n                pre = t[:node.keylen]\n                post = t[node.keylen:]\n                if pre not in node.keys:\n                    node.keys[pre] = self.__class__(node.level+1)\n                return _add(node.keys[pre], post)\n\n            node = self._get_cache(text)\n            if node is not None:\n                _add(node, '')\n            else:\n                self._set_cache(text, _add(self, text))\n\n        def index(self, text):\n            def _index(node, t):\n                if len(t) == 0:\n                    return node\n\n                pre = t[:node.keylen]\n                post = t[node.keylen:]\n                if pre in node.keys:\n                    return _index(node.keys[pre], post)\n                else:\n                    return None\n\n            node = self._get_cache(text)\n            if node is not None:\n                return node.values\n            else:\n                node = _index(self, text)\n                if node is not None:\n                    self._set_cache(text, node)\n                    return node.values\n                return []\n\n        def __contains__(self, text):\n            if len(text) > self.keylen:\n                pre = text[:self.keylen]\n                post = text[self.keylen:]\n                return (pre in self.keys and post in self.keys[pre])\n            else:\n                return any(key.startswith(text) for key in self.keys)\n\n        def _init_cache(self):\n            self._cache = {}\n            self._cacheq = []\n\n        def _set_cache(self, text, node):\n            if text not in self._cache:\n                if len(self._cacheq) > 65535:\n                    _, txt = heapreplace(self._cacheq, (time.clock(), text))\n                    del self._cache[txt]\n                else:\n                    heappush(self._cacheq, (time.clock(), text))\n                self._cache[text] = node\n\n        def _get_cache(self, text):\n            if text in self._cache:\n                return self._cache[text]\n            else:\n                return None\n\n        def __str__(self):\n            return ('(' + ','.join([\"{}->{}\".format(k, v)\n                                   for k, v in self.keys.items()]) + ')')\n\n    def __init__(self, text):\n        self._keylen(text)\n        self._create_index(text)\n\n    def _keylen(self, text):\n        chars = Counter(list(text))\n        ent = 0.0\n        total = len(text)\n        base = len(chars) + 1\n        for c, cnt in chars.items():\n            p = cnt / total\n            ent -= p * log(p, base)\n        self.keylen = max(2 ** ceil(10 * (1 - ent)) - 1, 15)\n\n    def _create_index(self, text):\n        tree = self.Node(0)\n        length = len(text)\n        for i in range(length):\n            tree.add(text[i:i+self.keylen], i)\n        self.tree = tree\n        self.text = text\n\n    def match(self, search_text):\n        def _match_partial(lo, hi):\n            split = self.keylen\n            if search_text[lo+split:hi] in self.tree:\n                for i in self.tree.index(search_text[lo:lo+split]):\n                    if (self.text[i+split:i+hi-lo]\n                            == search_text[lo+split:hi]):\n                        yield i\n\n        def _match(lo, hi):\n            length = hi - lo\n\n            if length == self.keylen:\n                return (i for i in self.tree.index(search_text[lo:hi]))\n\n            if length < self.keylen*2:\n                return _match_partial(lo, hi)\n\n            mid = lo + length // 2\n            pre = _match(lo, mid)\n            post = _match(mid, hi)\n\n            return _merge(pre, post, mid-lo)\n\n        def _merge(idx1, idx2, shift):\n            i2 = next(idx2)\n            for i1 in idx1:\n                while i1 + shift > i2:\n                    i2 = next(idx2)\n                if i1 + shift == i2:\n                    yield i1\n\n        length = len(search_text)\n        if length < self.keylen:\n            return search_text in self.tree\n\n        # align by key length\n        k = floor(log(length/self.keylen, 2))\n        b = self.keylen * 2**k\n        if length - self.keylen < b < length and k > 0:\n            b = self.keylen * 2**(k-1)\n\n        try:\n            if b + self.keylen < length:\n                match = _merge(_match(0, b), _match(b, length), b)\n            else:\n                match = _match(0, length)\n            next(match)\n            return True\n        except StopIteration:\n            return False\n\n\ndef run():\n    s1 = input()\n    n = int(input())\n\n    index = TreeIndex(s1)\n    for _ in range(n):\n        s2 = input()\n        if index.match(s2):\n            print(1)\n        else:\n            print(0)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport re\n\noriginal_string = input()\ncheck_string_count = int(input())\nfor count in range(check_string_count):\n    checker = input()\n    print(1 if re.search(checker, original_string) else 0)"
  },
  {
    "language": "Python",
    "code": "line = input()\nn = int(input())\n\nfor i in range(n):\n    if input() in line:\n        print(1)\n    else:\n        print(0)"
  },
  {
    "language": "Python",
    "code": "#coding:utf-8\n\n# ?§????????????????????????????\ndef make_BM_table(P):\n    CSIZE = 128\n    bm_table = [len(P)]*CSIZE\n\n    for i in range(len(P)-1):\n        bm_table[ord(P[i])] = len(P)-i-1\n        \n    return bm_table\n\n# ?????????????´¢\ndef BM_string_search(T,P):\n    \n    if len(P) > len(T):\n        return False\n\n    # ?§????????????????????????????\n    bm_table = make_BM_table(P)\n\n    i = len(P)-1\n\n    while i < len(T):\n        j = len(P)-1\n\n        while T[i] == P[j]:\n            \n            # ??????\n            if j == 0:\n                return True\n\n            i -= 1\n            j -= 1\n\n        i += max(bm_table[ord(T[i])],len(P)-j)\n\n    return False\n\n\nif __name__ == '__main__':\n\n    # ?????????????????\\???\n    T = input()\n    # ????´¢?????????????????°?????\\???\n    n = int(input())\n\n    # ????????????????????????????????????????????\\???\n    for i in range(n):\n        P = input()\n    \n        if BM_string_search(T,P):\n            print(1)\n        else:\n            print(0)\n\n\n    "
  },
  {
    "language": "Python",
    "code": "base = 127\nmask = (1 << 32) - 1\n\n\ndef calc_hash(f, pl, tl):\n    dl = tl - pl\n    tmp = set()\n\n    t = 1\n    for _ in range(pl):\n        t = (t * base) & mask\n    e = 0\n    for i in range(pl):\n        e = (e * base + f[i]) & mask\n    for i in range(dl):\n        tmp.add(e)\n        e = (e * base - t * f[i] + f[i + pl]) & mask\n    tmp.add(e)\n    return tmp\n\n\nt = [ord(c) for c in input().strip()]\ntl = len(t)\nq = int(input())\nps = [input().strip() for _ in range(q)]\nh = dict()\na = []\nhash_len = 18\nfor p in ps:\n    p = [ord(c) for c in p]\n    pl = len(p)\n    if pl > tl:\n        a.append(0)\n        continue\n    bs = min(hash_len, pl)\n    keys = calc_hash(p, bs, pl)\n    if bs not in h:\n        h[bs] = calc_hash(t, bs, tl)\n    a.append(1 if keys.issubset(h[bs]) else 0)\nprint('\\n'.join(map(str, a)))"
  },
  {
    "language": "Python",
    "code": "base = 127\nmask = (1 << 32) - 1\n\n\ndef calc_hash(f, pl, tl):\n    dl = tl - pl\n    tmp = set()\n\n    t = 1\n    for _ in range(pl):\n        t = (t * base) & mask\n    e = 0\n    for i in range(pl):\n        e = (e * base + f[i]) & mask\n    for i in range(dl):\n        tmp.add(e)\n        e = (e * base - t * f[i] + f[i + pl]) & mask\n    tmp.add(e)\n    return tmp\n\n\nt = [ord(c) for c in input().strip()]\ntl = len(t)\nq = int(input())\nh = dict()\nwhile q:\n    p = [ord(c) for c in input().strip()]\n    pl = len(p)\n    if pl > tl:\n        print(0)\n        q -= 1\n        continue\n    bs = min(10, pl)\n    keys = calc_hash(p, bs, pl)\n    if bs not in h:\n        h[bs] = calc_hash(t, bs, tl)\n    print(1 if keys.issubset(h[bs]) else 0)\n    q -= 1"
  },
  {
    "language": "Python",
    "code": "\ndef search1(T,P):\n    \n    if P in T:\n        print(1)\n    else:\n        print(0)\n\ndef search2(T,line):\n    \n    if P in line:\n        return True\n    else:\n        return False\n    \n\nT = input()\nn = int(input())\n\n\nfor i in range(n):\n    \n\n    P = input()\n    \n    if len(P) < 500:\n        \n        search1(T,P)\n\n    else:\n\n        line = P[:500]\n        if search2(T,line):\n            search1(T,P)\n        else:\n            print(0)"
  },
  {
    "language": "Rust",
    "code": "//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n//\n\n//http://wk1080id.hatenablog.com/entry/2018/12/25/005926\nfn gen_suffix_array(a: &Vec<usize>) -> Vec<usize> {\n    let mut s = a.clone();\n    for s in &mut s {\n        *s += 1;\n    }\n    s.push(0);\n    let n = s.len();\n    let m = s.iter().max().unwrap() + 1;\n    // k = 0\n    let mut cnt = vec![0; m];\n    let mut p = vec![0; n];\n    let mut c = vec![0; n];\n    for s in &s {\n        cnt[*s] += 1;\n    }\n    for i in 1..m {\n        cnt[i] += cnt[i - 1];\n    }\n    for i in 0..n {\n        let c = s[i];\n        cnt[c] -= 1;\n        p[cnt[c]] = i;\n    }\n    c[p[0]] = 0;\n    let mut kind = 1;\n    for i in 1..n {\n        if s[p[i]] != s[p[i - 1]] {\n            kind += 1;\n        }\n        c[p[i]] = kind - 1;\n    }\n    let mut k = 1;\n    while k < n {\n        let mut next_p = vec![0; n];\n        for i in 0..n {\n            next_p[i] = (p[i] + n - k) % n;\n        }\n        let mut cnt = vec![0; kind];\n        for &p in &next_p {\n            cnt[c[p]] += 1;\n        }\n        for i in 1..kind {\n            cnt[i] += cnt[i - 1];\n        }\n        for &pn in next_p.iter().rev() {\n            let k = c[pn];\n            cnt[k] -= 1;\n            p[cnt[k]] = pn;\n        }\n        let mut next_c = vec![0; n];\n        next_c[p[0]] = 0;\n        kind = 1;\n        for i in 1..n {\n            let prev = (c[p[i - 1]], c[(p[i - 1] + k) % n]);\n            let cur  = (c[p[i]], c[(p[i] + k) % n]);\n            if prev != cur {\n                kind += 1;\n            }\n            next_c[p[i]] = kind - 1;\n        }\n        c = next_c;\n        k <<= 1;\n    }\n    p\n}\n\nuse std::io::Write;\n\nfn convert(c: char) -> usize {\n    if '0' <= c && c <= '9' {\n        c.to_digit(10).unwrap() as usize\n    } else if 'a' <= c && c <= 'z' {\n        c as usize - 'a' as usize + 10\n    } else {\n        c as usize - 'A' as usize + 36\n    }\n}\n\nfn run() {\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    input! {\n        s: chars,\n        q: usize,\n        a: [chars; q],\n    }\n    let s_map: Vec<usize> = s.into_iter().map(convert).collect();\n    let su = gen_suffix_array(&s_map);\n    let s = s_map;\n    for a in a {\n        let a: Vec<usize> = a.into_iter().map(convert).collect();\n        let mut l = 0;\n        let mut r = su.len() - 1;\n        while r - l > 1 {\n            let m = (l + r) / 2;\n            if *a.as_slice() <= s[su[m]..] {\n                r = m;\n            } else {\n                l = m;\n            }\n        }\n        let ans = if s.len() - su[r] >= a.len() && *a.as_slice() == s[su[r]..(su[r] + a.len())] {\n            1\n        } else {\n            0\n        };\n        writeln!(out, \"{}\", ans).unwrap();\n    }\n}\n\nfn main() {\n    run();\n}\n\n"
  }
]