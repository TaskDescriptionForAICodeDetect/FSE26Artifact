[
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint n,x[24],y[24],r[24],c[24],m[1<<24];\n\nbool insec(int a,int b){\n\treturn (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b])<(r[a]+r[b])*(r[a]+r[b]);\n}\n\nint dfs(int s){\n\tif(m[s]>-1)return m[s];\n\tbool top[24];\n\tfill(top,top+24,1);\n\tint res=0;\n\trep(i,n)rep(j,i)if(s&1<<i&&s&1<<j&&insec(i,j))top[i]=0;\n\trep(i,n)rep(j,i)if(s&1<<i&&s&1<<j&&top[i]&&top[j]&&c[i]==c[j])res=max(res,2+dfs(s-(1<<i)-(1<<j)));\n\treturn m[s]=res;\n}\n\nint main(){\n\twhile(cin>>n&&n){\n\t\trep(i,n)cin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\tfill(m,m+(1<<n),-1);\n\t\tcout<<dfs((1<<n)-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nstruct Data\n{\n    int x;\n    int y;\n    int r;\n    int c;\n};\n\ntypedef struct Data D;\n\nint solve(vector<D> input)\n{\n    int ans = 0;\n    int colornum[4] = {};\n    int n = input.size();\n    // cout << \"ho\" << n << endl;\n    bool notcovered[25];\n    for(int i = 0; i < n; i++){\n        notcovered[i] = true;\n        // cout << i << \" : \" << input[i].x << \" \" << input[i].y << \" \" << input[i].r << \" \" << input[i].c << endl;\n        for(int j = 0; j < i; j++){\n            if(pow(input[i].x - input[j].x, 2) + pow(input[i].y - input[j].y, 2) < pow(input[i].r + input[j].r, 2)){\n                notcovered[i] = false;\n                break;\n            }\n        }\n        if(notcovered[i]) colornum[input[i].c - 1]++;\n    }\n    for(int i = 0; i < 4; i++){\n        if(colornum[i] > 1){\n            vector<D> newinput;\n            for(int j = 0; j < n; j++){\n                if(input[j].c - 1 != i) newinput.push_back(input[j]);\n            }\n            ans = max(ans, solve(newinput) + colornum[i]);\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        vector<D> input;\n        for(int i = 0; i < n; i++){\n            D tmpd;\n            cin >> tmpd.x >> tmpd.y >> tmpd.r >> tmpd.c;\n            input.push_back(tmpd);\n        }\n        cout << solve(input) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\nint n, ans;\nvector<char> dp, up;\nvector<Circle> c;\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = (a.r + b.r) * (a.r + b.r);\n    int d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    return r > d;\n}\n\nchar Rec(char s, int num)\n{\n    if (dp[s] != -1)\n        return dp[s];\n\n    int res = num;\n    // 取り除く2つの円の選択\n    for (int i = 0; i < n; ++i) {\n        // c[i]がないか取り除けない\n        if (!(s >> i & 1) || s & up[i])\n            continue;\n\n        for (int j = i + 1; j < n; ++j) {\n            // c[i]とc[j]の色が異なる\n            if (c[i].c != c[j].c)\n                continue;\n            // c[j]がないか取り除けない\n            if (!(s >> j & 1) || s & up[j])\n                continue;\n\n            int nxt = s & ~(1 << i) & ~(1 << j);\n            res = max(res, (int)Rec(nxt, num + 2));\n        }\n    }\n\n    ans = max(ans, res);\n\n    return dp[s] = res;\n}\n\nint main()\n{\n    while (cin >> n, n) {\n        dp.assign(1 << n, -1);\n        up.assign(n, 0);\n        c.resize(n);\n\n        // 円の入力\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        // 円の重なり，上下関係\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                if (isOverlap(c[i], c[j]))\n                    up[j] |= (1 << i);\n\n        ans = 0;\n        Rec((1 << n) - 1, 0);\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <deque>\n#include <vector>\n#include <numeric>\n#include <iterator>\n#include <array>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\n\n\n#define FF first\n#define SS second\n#define ALL(c) begin((c)), end((c))\n#define REP(i,n) for(ll i=0;i<(ll)n;++i)\ninline int getInt() { int s; scanf(\"%d\", &s); return s; }\n\nstruct circle{\n\tint id,x,y,r;\n};\n\nvector<circle> g_table[4];\n\n\nint main() {\n\n\twhile (true) {\n\t\tll n;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\tarray<bool,4> active;\n\t\tactive.fill(true);\n\n\t\tREP(c, 4) g_table[c].clear();\n\t\tREP(i, n){\n\t\t\tint x,y,r,c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tg_table[c - 1].push_back(circle{i,x,y,r});\n\t\t}\n\n\t\tvector<int> removableColor;\n\t\tdo{\n\t\t\twhile (!removableColor.empty()) {\n\t\t\t\tactive[removableColor.back()] = false;\n\t\t\t\tremovableColor.pop_back();\n\t\t\t}\n\n\t\t\tarray<vector<circle>,4> tops;\n\t\t\tREP(c1, 4) for (auto it1 = g_table[c1].begin(); it1 != g_table[c1].end(); ++it1) {\n\t\t\t\tif(!active[c1]) continue;\n\t\t\t\tbool top = true;\n\t\t\t\tREP(c2, 4) for (auto it2 = g_table[c2].begin(); it2 != g_table[c2].end(); ++it2) {\n\t\t\t\t\tif (!active[c2]) continue;\n\t\t\t\t\tif (c1==c2 && it1 == it2) continue;\n\t\t\t\t\tint xx = (it1->x - it2->x);\n\t\t\t\t\tint yy = (it1->y - it2->y);\n\t\t\t\t\tint rr = (it1->r + it2->r);\n\t\t\t\t\tif (xx*xx + yy*yy < rr*rr && it1->id > it2->id) {\n\t\t\t\t\t\ttop = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (top) tops[c1].push_back(*it1);\n\t\t\t}\n\n\t\t\tREP(c,4) if ((!g_table[c].empty()) && tops[c].size() == g_table[c].size()) removableColor.push_back(c);\n\t\t} while (!removableColor.empty());\n\n\t\tint count = 0;\n\t\tREP(c, 4) if (!active[c]) count += g_table[c].size();\n\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = (a.r + b.r) * (a.r + b.r);\n    int d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    return r > d;\n}\n\nint main()\n{\n    int n;\n\n    while (cin >> n, n) {\n        const int N = 1 << n;\n        vector<char> dp(N, -1), up(n, 0);\n        vector<Circle> c(n);\n\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j) {\n                if (i == j)\n                    continue;\n                if (isOverlap(c[i], c[j])) {\n                    if (i < j) // jの上にiがある\n                        up[j] |= (1 << i);\n                    else // iの上にjがある\n                        up[i] |= (1 << j);\n                }\n            }\n\n        int res = 0;\n        dp[0] = 0; // ビットが立っているならば置かれていない\n        for (int s = 0; s < N; ++s) {\n            if (dp[s] == -1)\n                continue;\n\n            res = max(res, (int)dp[s]);\n            for (int i = 0; i < n; ++i) {\n                // c[i]が置かれていないかc[i]が取り除けない\n                if (s & (1 << i) != 0 || (s & up[i] != up[i]))\n                    continue;\n                // if (s >> i & 1 || (s & up[i]) != up[i])\n                //     continue;\n\n                for (int j = i + 1; j < n; ++j) {\n                    if (c[i].c != c[j].c) // 色が異なる\n                        continue;\n                    // c[j]が置かれていないかc[j]が取り除けない\n                    if ((s & (1 << j)) != 0 || (s & up[j]) != up[j])\n                        continue;\n                    // if (s >> j & 1 || (s & up[j]) != up[j])\n                    //     continue;\n\n                    int nxt = s | (1 << i) | (1 << j);\n                    dp[nxt] = max((int)dp[nxt], dp[s] + 2);\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\nint n;\nchar dp[1 << 24];\n//char up[24];\n//vector<char> dp, up;\n//vector<Circle> c;\nCircle c[24];\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = (a.r + b.r) * (a.r + b.r);\n    int d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    return r > d;\n}\n\nbool isUp(char s, int v)\n{\n    for (int i = 0; i < v; ++i)\n        if ((s >> i & 1) && isOverlap(c[v], c[i]))\n            return true;\n    return false;\n}\n\nchar Rec(int s)\n{\n    if (~dp[s])\n        return dp[s];\n\n    int res = 0;\n    // 取り除く2つの円の選択\n    for (int i = 0; i < n; ++i) {\n        // c[i]がないか取り除けない\n        if (!(s >> i & 1) || isUp(s, i))\n            continue;\n        // if (!(s >> i & 1) || s & up[i])\n        //     continue;\n\n        for (int j = i + 1; j < n; ++j) {\n            // c[i]とc[j]の色が異なる\n            if (c[i].c != c[j].c)\n                continue;\n            // c[j]がないか取り除けない\n            // if (!(s >> j & 1) || s & up[j])\n            //     continue;\n            if (!(s >> j & 1) || isUp(s, j))\n                continue;\n\n//            int nxt = s & ~(1 << i) & ~(1 << j);\n            res = max(res, Rec(s & ~(1 << i) & ~(1 << j)) + 2);\n        }\n    }\n\n    return dp[s] = res;\n}\n\nint main()\n{\n    while (cin >> n, n) {\n        memset(dp, -1, sizeof(dp));\n//        memset(up, 0, sizeof(up));\n//        c.resize(n);\n\n        // 円の入力\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        // // 円の重なり，上下関係\n        // for (int i = 0; i < n; ++i)\n        //     for (int j = i + 1; j < n; ++j)\n        //         if (isOverlap(c[i], c[j]))\n        //             up[j] |= (1 << i);\n\n        cout << (int)Rec((1 << n) - 1) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint n;\nint x[30], y[30], r[30], c[30];\nint on[30];\ndouble dist(int x, int y){\n  return sqrt(x *x + y* y);\n}\nbool ison(int x, int y, int r, int x2, int y2, int r2){\n  double d = dist(x-x2, y- y2);\n  if(d < (double)r + r2) return true;\n  return false;\n}\nmap<int, int> memo;\nint dfs(int S){\n  if(memo.count(S)) return memo[S];\n  int res = __builtin_popcount(S);\n  REP(i, n)REP(j, n){\n    if(i != j && !(S & (1 << i)) && !(S & (1 << j)) && c[i] == c[j]){\n      if(!(on[i] & (~S)) && !(on[j] & (~S))){\n        res = max(res, dfs(S | (1<<i) | (1<<j)));\n      }\n    }\n  }\n  return memo[S] = res;\n}\n\nint main(){\n  while(cin>>n && n){\n    memo.clear();\n    REP(i, n) cin>>x[i]>>y[i]>>r[i]>>c[i];\n    memset(on, 0, sizeof(on));\n    REP(up, n)FOR(low, up + 1, n){\n      if(ison(x[up], y[up], r[up], x[low], y[low], r[low])) on[low] |= (1<<up);\n    }\n    cout<<dfs(0)<<endl;\n  }\n      \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  while(1){\n    int n;\n    cin >> n;\n    if(n==0) return 0;\n    vector<int> x(n),y(n),r(n),c(n);\n    for(int i=0;i<n;i++){\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n    vector<list<int>> ue(n);\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n        if((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])<(r[i]+r[j])*(r[i]+r[j])){\n          ue[j].push_back(i);\n        }\n      }\n    }\n    queue<int> bfs;\n    bfs.push(0);\n    vector<bool> ok(1<<n,false);\n    ok[0]=true;\n    int now;\n    vector<int> can;\n    while(!bfs.empty()){\n      now=bfs.front();\n      bfs.pop();\n      can={};\n      for(int i=0;i<n;i++){\n        if(!(now&(1<<i))){\n          for(auto j:ue[i]){\n            if(!(now&(1<<j))){\n              goto next;\n            }\n          }\n          can.push_back(i);\n          next:\n          continue;\n        }\n      }\n      for(int i=0;i<can.size();i++){\n        for(int j=i+1;j<can.size();j++){\n          if(c[can[i]]==c[can[j]]){\n            if(!ok[now|(1<<can[i])|(1<<can[j])]){\n              ok[now|(1<<can[i])|(1<<can[j])]=true;\n              bfs.push(now|(1<<can[i])|(1<<can[j]));\n            }\n          }\n        }\n      }\n    }\n    int ans=0,k,tmp;\n    for(int i=0;i<(1<<n);i++){\n      if(ok[i]){\n        k=i,tmp=0;\n        while(k){\n          if(k%2) tmp++;\n          k/=2;\n        }\n        ans=max(ans,tmp);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint n,x[30],y[30],r[30],c[30],cover[30];\nchar dp[1<<24];\nvector<int> same_col[5];\n\nint rec(int bit){\n  if(dp[bit])return dp[bit];\n\n  int res = 0;\n  for(int i=0;i<4;i++){\n    if(same_col[i].size()<2)continue;\n    for(int j=0;j<(int)same_col[i].size();j++){\n      for(int k=0;k<j;k++){\n\tconst int a = *(same_col[i].begin()+j), b = *(same_col[i].begin()+k);\n\tif(a<=b)continue;\n\tif( (~bit)&(1<<a) && (~bit)&(1<<b) ){\n\t  if( (~bit)&cover[a] || (~bit)&cover[b])continue;\n\t  same_col[i].erase(same_col[i].begin()+j); same_col[i].erase(same_col[i].begin()+k);\n\t  res = max(res, rec(bit | (1<<a) | (1<<b))+2);\n\t  same_col[i].insert(same_col[i].begin()+k,b); same_col[i].insert(same_col[i].begin()+j,a);\n\t}\n      }\n    }\n  }\n  return dp[bit]=res;\n}\n  \nint main(){\n  while(cin >> n, n){\n    for(int i=0;i<n;i++)cin >> x[i] >> y[i] >> r[i] >> c[i];\n    for(int i=0;i<4;i++)same_col[i].clear();\n\n    for(int i=0;i<n;i++){\n      same_col[c[i]-1].push_back(i);\n      cover[i] = 0;\n      for(int j=0;j<i;j++){\n\tif( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j])*(r[i]+r[j]) ){\n\t  cover[i] |= 1<<j;\n\t}\n      }\n    }\n\n    memset(dp,0,sizeof(dp));\n    cout << rec(0) << endl;\n  }\t  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nstruct Circle {\n\tint x, y, r, c;\n\tbool flag;\n\n\tCircle(int _x, int _y, int _r, int _c) :x(_x), y(_y), r(_r), c(_c), flag(true) {}\n};\n\nbool collision(Circle& c1, Circle& c2)\n{\n\treturn (c2.x - c1.x)*(c2.x - c1.x) + (c2.y - c1.y)*(c2.y - c1.y) < (c2.r + c1.r)*(c2.r + c1.r);\n}\n\nint n;\nint ans;\n\nvoid dfs(vector<Circle>& circles, int del)\n{\n\trep(i, n) {\n\t\tif (circles[i].flag == true) {\n\t\t\tbool flag = true;\n\n\t\t\t//????????£?????????????????????\n\t\t\trep(j, i) {\n\t\t\t\tif (circles[j].flag == true) {\n\t\t\t\t\tif (collision(circles[i], circles[j]) == true) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (flag == false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (circles[i].c != circles[j].c) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbool f = true;\n\n\t\t\t\trep(k, j) {\n\t\t\t\t\tif (circles[k].flag == true) {\n\t\t\t\t\t\tif (collision(circles[j], circles[k]) == true) {\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (f == false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tcircles[i].flag = false;\n\t\t\t\tcircles[j].flag = false;\n\t\t\t\tans = max(ans, del + 2);\n\t\t\t\tdfs(circles, del + 2);\n\t\t\t\tcircles[i].flag = true;\n\t\t\t\tcircles[j].flag = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (true) {\n\t\tcin >> n;\n\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<Circle> circles;\n\t\tans = 0;\n\n\t\trep(i, n) {\n\t\t\tint x, y, r, c;\n\n\t\t\tcin >> x >> y >> r >> c;\n\n\t\t\tcircles.push_back(Circle(x, y, r, c));\n\t\t}\n\n\t\tdfs(circles, 0);\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\nbool circle_overlapping(int y1, int x1, int r1, int y2, int x2, int r2) {\n    int dx = x2 - x1;\n    int dy = y2 - y1;\n    int d = r1 + r2;\n    return dx * dx + dy * dy < d * d;\n}\n\nbool can_remove(int idx1, int idx2, const vector<tuple<int, int, int, int>> &v, vector<int> idx_list) {\n    int x1, y1, r1, c1, x2, y2, r2, c2;\n    tie(x1, y1, r1, c1) = v[idx1];\n    tie(x2, y2, r2, c2) = v[idx2];\n\n    if (c1 != c2) {\n        return false;\n    }\n\n    FOE(i, idx_list) {\n        if (i == idx1) {\n            break;\n        }\n        int x3, y3, r3, c3;\n        tie(x3, y3, r3, c3) = v[i];\n        if (circle_overlapping(y1, x1, r1, y3, x3, r3)) {\n            return false;\n        }\n    }\n    FOE(i, idx_list) {\n        if (i == idx2) {\n            break;\n        }\n        int x3, y3, r3, c3;\n        tie(x3, y3, r3, c3) = v[i];\n        if (circle_overlapping(y2, x2, r2, y3, x3, r3)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n\tios::sync_with_stdio(false);\n\n    while (true) {\n        int N;\n        cin >> N;\n        if (N == 0) {\n            break;\n        }\n        vector<tuple<int, int, int, int>> v;\n        FOR(i, 0, N) {\n            int x, y, r, c;\n            cin >> x >> y >> r >> c;\n            v.emplace_back(make_tuple(x, y, r, c));\n        }\n\n        vector<bool> dp(1LL << (N + 1), false);\n        dp[0] = true;\n\n        FOR(b, 0, 1LL << (N + 1)) {\n            if (not dp[b]) {\n                continue;\n            }\n\n            vector<int> idx;\n            FOR(i, 0, N) {\n                if (not (b & (1 << i))) {\n                    idx.emplace_back(i);\n                }\n            }\n\n            FOR(i, 0, idx.size()) {\n                FOR(j, i + 1, idx.size()) {\n                    if (can_remove(i, j, v, idx)) {\n                        dp[b | (1 << i) | (1 << j)] = true;\n                    }\n                }\n            }\n        }\n\n        int ans = 0;\n        FOR(i, 0, dp.size()) {\n            if (dp[i]) {\n                ans = max(ans, __builtin_popcount(i));\n            }\n        }\n        print(ans);\n    }\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\nstruct E{\n\tvector<int> ov;\n\tint color;\n\tint x, y, r;\n\tE(int _x, int _y, int _r, int _c){\n\t\tcolor = _c;\n\t\tx = _x;\n\t\ty = _y;\n\t\tr = _r;\n\t}\n};\n\nbool dp[(1<<25)] = {0};\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tint x, y, r, c, _ans=0;\n\t\tvector<E> e;\n\t\tqueue<int> que;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tE tmp(x,y,r,c);\n\t\t\tfor(int j=0; j<e.size(); j++){\n\t\t\t\tif( (e[j].x-x)*(e[j].x-x) + (e[j].y-y)*(e[j].y-y) < (e[j].r+r)*(e[j].r+r) ){\n\t\t\t\t\ttmp.ov.push_back( j );\n\t\t\t\t}\n\t\t\t}\n\t\t\te.push_back( tmp );\n\t\t}\n\t\tfill(dp, dp+(1<<25), false);\n\t\tdp[0] = true;\n\t\tque.push(0);\n\t\tint ans=0;\n\t\twhile( !que.empty() ){\n\t\t\tint i = que.front();\n\t\t\tque.pop();\n\t\t\tif(dp[i]){\n\t\t\t\t_ans = 0;\n\t\t\t\tfor(int v=1; v<(1<<n); v<<=1){\n\t\t\t\t\tif( v & i )\n\t\t\t\t\t\t_ans++;\n\t\t\t\t}\n\t\t\t\tans = max(ans, _ans);\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tfor(int l=0; l<k; l++){\n\t\t\t\t\t\tif( k != l && !(i&(1<<k)) && !(i&(1<<l)) && e[k].color == e[l].color){\n\t\t\t\t\t\t\tbool f=true;\n\t\t\t\t\t\t\tfor(int j=0; j<e[k].ov.size(); j++){\n\t\t\t\t\t\t\t\tif( !(i & (1<<e[k].ov[j])) ){\n\t\t\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int j=0; f&&j<e[l].ov.size(); j++){\n\t\t\t\t\t\t\t\tif( !(i & (1<<e[l].ov[j])) ){\n\t\t\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( f ){\n\t\t\t\t\t\t\t\tif( !dp[ i | (1<<k) | (1<<l) ] ){\n\t\t\t\t\t\t\t\t\tdp[ i | (1<<k) | (1<<l) ] = true;\n\t\t\t\t\t\t\t\t\tque.push( i | (1<<k) | (1<<l) );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint sq(int x) { return x * x; }\n\nstruct Circle {\n\tint x, y, r, c;\n\tint tops;\n\tCircle (int _x, int _y, int _r, int _c) : x(_x), y(_y), r(_r), c(_c) {}\n};\n\nbool CC(const Circle& c1, const Circle& c2) {\n\tif (sq(c1.x - c2.x) + sq(c1.y - c2.y) < sq(c1.r + c2.r)) return true;\n\treturn false;\n}\n\nint n;\nvector<Circle> cs;\n\nint memo[1 << 23];\nint mmmax = 1 << 23;\n\nint rec(int cur) {\n\tif (cur < mmmax) {\n\t\tif (memo[cur] >= 0) return memo[cur];\n\t}\n\t\n\tint ret = __builtin_popcount(cur);\t// 返す値を用意する\n\tint rmbit = ~cur;\t// bit反転をとる\n\t\n\t// 今取り除ける円盤を見つける\n\tvector<int> cand;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (cur >> i & 1) continue;\t// すでにとりのぞかれている\n\t\t\n\t\tint topsi = cs[i].tops;\n\t\tif ( (topsi & rmbit) != 0) continue;\n\t\t\n\t\t// i番目の円盤は現在のこっている円盤によらずに取り除ける\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (cur >> j & 1) continue;\n\t\t\t\n\t\t\tint topsj = cs[j].tops;\n\t\t\tif ((topsj & rmbit) != 0) continue;\n\t\t\t\n\t\t\t// j番目の円盤も現在のこっている円盤によらずに取り除ける\n\t\t\t\n\t\t\t// 同じ色なら取り除ける\n\t\t\tif (cs[i].c != cs[j].c) continue;\n\t\t\t\n\t\t\t// i と j を取り除いた場合について再帰\n\t\t\tint nxt = cur | (1 << i);\n\t\t\tnxt |= 1 << j;\n\t\t\tret = max(ret, rec(nxt));\n\t\t}\n\t}\n\t\n\tif (cur < mmmax) memo[cur] = ret;\n\treturn ret;\t// メモしながら返す\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> n; if (n == 0) break;\n\t\t\n\t\tcs.clear();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x, y, r, c; cin >> x >> y >> r >> c;\n\t\t\tcs.push_back(Circle(x, y, r, c));\n\t\t}\n\t\t\n\t\t// 各円盤に対して、どの円盤が取り除かていればその円盤をとりだせるかを入れる\n\t\t// 取り除かなければならない円盤にbitをたてる\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tint tops = 0;\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (CC(cs[i], cs[j])) {\n\t\t\t\t\ttops |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcs[i].tops = tops;\n\t\t}\n\t\t\n\t\t// すべての円盤が残っている状態から開始\t\t\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tcout << rec(0) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint n;\n\nstruct Circle {\n    int x, y, r;\n    int c;\n    Circle() {}\n    Circle(int x, int y, int r, int c) : x(x), y(y), r(r), c(c) {}\n};\n\nbool intersect(Circle& a, Circle& b) {\n    return (a.r+b.r) * (a.r+b.r) > (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y);\n}\n\nvector<Circle> cs;\nbool used[25];\nint remove() {\n    vector<int> tops;\n    for (int i = 0; i < n; i++) {\n        if (used[i]) continue;\n        bool cover = false;\n        for (int j = 0; j < i; j++) {\n            if (used[j]) continue;\n            if (i == j) continue;\n            if (intersect(cs[i], cs[j])) {\n                cover = true;\n                break;\n            }\n        }\n        if (!cover) tops.push_back(i);\n    }\n    int cnt = 0;\n    for (int i = 0; i < tops.size(); i++) {\n        for (int j = 0; j < tops.size(); j++) {\n            if (i == j) continue;\n            if (cs[tops[i]].c == cs[tops[j]].c) {\n                used[tops[i]] = used[tops[j]] = true;\n                cnt = max(cnt, remove()+2);\n                used[tops[i]] = used[tops[j]] = false;\n            }\n        }\n    }\n    return cnt;\n}\n\nint main() {\n    while (cin >> n, n) {\n        cs = vector<Circle>(n);\n        for (int i = 0; i < n; i++) {\n            int x, y, r, c;\n            cin >> x >> y >> r >> c;\n            cs[i] = Circle(x, y, r, c);\n        }\n        memset(used, 0, sizeof(used));\n        cout << remove() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstruct po {int x,y,r,g;};\nvector <po> c[5];\nint ans;\nbool used[1<<24];\nbool check(po a){\n  if(a.x==100000)return false;\n  for(int i=0;i<4;i++)\n    for(int j=0;j<c[i].size();j++){\n      po b = c[i][j];\n      if(a.g>b.g && (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y) < (a.r+b.r)*(a.r+b.r)) return false;\n    }\n  return true;\n}\n\nvoid saiki(int sum,int i,int ima){\n  ans = max(ans,sum);\n  vector <int> J;\n  for(int j=0;j<(int)c[i].size();j++)if(check(c[i][j])==true)J.push_back(j);\n  for(int j=0;j<(int)J.size();j++)\n    for(int k=j+1;k<(int)J.size();k++){\n      int a,b;\n      int nx=(1<<c[i][J[j]].g)|(1<<c[i][J[k]].g)|ima;\n      if(used[nx]==1)continue;\n      used[nx]=1;\n      a=c[i][J[j]].x;\n      b=c[i][J[k]].x;\n      c[i][J[j]].x = c[i][J[k]].x = 100000;\n      for(int l=1;l<=4;l++)saiki(sum+2,(i+l)%4,nx);\n      c[i][J[j]].x=a;\n      c[i][J[k]].x=b;\n    }\n}\n\nint main(){\n  while(1){\n    int n;\n    cin>>n;\n    if(n==0)break;\n    int x,y,r,col;\n    for(int j=0;j<(1<<24);j++)used[j]=0;\n    for(int i=0;i<4;i++) c[i].clear();\n    for(int i=0;i<n;i++)cin >>x>>y>>r>>col, c[--col].push_back((po){x,y,r,i});\n\n    ans=0;\n    for(int i=0;i<4;i++) saiki(0,i,0);\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 30;\nint x[MAXN], y[MAXN], r[MAXN], c[MAXN];\nbool ok[MAXN];\nchar dp[1<<24];\n\nint square(int x) {return x*x;}\n\n// i, j ???????????£?????????????????????\n// ????????£????????? true\nbool check(int i, int j) {\n    int d2 = square(x[i]-x[j]) + square(y[i]-y[j]);\n    return d2 < square(r[i]+r[j]);\n}\n\nchar dfs(int state, int n) {\n    char& ret = dp[state];\n    if (ret >= 0) return ret;\n    ret = 0;\n    // ???????????¨??????????????§??????????????????????????????\n    vector<int> already;\n    memset(ok, true, sizeof(ok));\n    for (int i = 0; i < n; i++) {\n        if ((state>>i)&1) continue;\n        if (ok[i]) {\n            already.push_back(i);\n        }\n        for (int j = i+1; j < n; j++) {\n            if (check(i, j)) ok[j] = false;\n        }\n    }\n    int sz = already.size();\n    for (int i = 0; i < sz; i++) {\n        for (int j = i+1; j < sz; j++) {\n            int ai = already[i], aj = already[j];\n            if (c[ai] == c[aj]) {\n                int nstate = state;\n                nstate |= 1<<ai;\n                nstate |= 1<<aj;\n                ret = max(2+dfs(nstate, n), ret);\n            }\n        }\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while (cin >> n) {\n        if (n==0) break;\n        for (int i = 0; i < n; i++) cin >> x[i] >> y[i] >> r[i] >> c[i];\nmemset(dp, -1, sizeof(dp));\n        cout << (int)dfs(0, n) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nvector<int>x,y,r,c;\nvector<int>memo;\nint n;\nbool intersectCC(int a,int b){\n    int dis = (x[a]-x[b])*(x[a]-x[b]) +(y[a]-y[b])*(y[a]-y[b]);\n    return dis < (r[a]+r[b])*(r[a]+r[b]);\n}\nbool toreru(int bit,int id){\n    rep(i,id){\n        if(intersectCC(i,id) and !(bit >> i & 1)) return false;\n    }\n    return true;\n}\nint dfs(int bit){\n    if(memo[bit] != -INF)return  memo[bit];\n    memo[bit] = 0;\n    for(int i = 0; i < n; i++){\n        for(int j = i+1; j < n;j++){\n            if( bit >> i & 1 or bit >> j &1)continue;\n            if(c[i] != c[j])continue;\n            if(toreru(bit, i) and toreru(bit, j)){\n                cmax(memo[bit], dfs(bit | 1 << i | 1 << j)+2);\n            }\n        }\n    }\n    return memo[bit];\n}\nsigned main(){\n    while(cin >> n,n){\n        x.clear();y.clear();r.clear();c.clear();\n        rep(i,n){\n            int _x,_y,_r,_c;\n            cin >> _x >> _y >> _r >> _c;\n            x.push_back(_x); y.push_back(_y);\n            r.push_back(_r); c.push_back(_c);\n        }\n        memo.assign(1 << n,-INF);\n        cout << dfs(0) << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ndouble EPS = (1e-10);\n\nstruct Point {\n  double x, y;\n};\n\nstruct Circle {\n  Point p;\n  double r;\n  int id;\n};\n\nbool intersect(Circle a, Circle b) {\n  double x1 = a.p.x, y1 = a.p.y;\n  double x2 = b.p.x, y2 = b.p.y;  \n  double d = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n\n  if ( d - (a.r+b.r) < 0.0 ) return true;  \n  else return false;\n}\n\nvector<Circle> C[4];\nvector<Circle> circles;\nint N;\nunordered_map<int, int> dp;\n\nint dfs(int bit) {\n  //cout << bit << endl;\n  if ( bit == (1<<N)-1 ) return 1;\n  if ( dp[bit] ) return dp[bit];\n\n  int ret = 1;\n  int n;\n  for ( int i = 0; i < 4; i++ ) {\n    n = C[i].size();\n    if ( n <= 1 ) continue;\n    for ( int a = 0; a < n; a++ ) {\n      Circle c1 = C[i][a];\n      int i1 = c1.id;\n      //if ( bit == 9 && i1 == 1 ) cout << 'a' << endl;\n      if ( bit & (1<<i1) ) continue;\n      bool flag = true;\t\n      for ( int j = 0; j < i1; j++ ) {\n\tif ( !(bit & (1<<j)) && intersect(circles[j], c1) ) {\n\t  flag = false;\n\t  break;\n\t}\n      }\n      //if ( bit == 9 && i1 == 1 ) cout << 'a' << endl;\n      if ( !flag ) continue;\n      //if ( bit == 9 && i1 == 1 ) cout << 'a' << endl;\n      for ( int b = a+1; b < n; b++ ) {\n\tCircle c2 = C[i][b];\n\tint i2 = c2.id;\n\t//if ( i1 == 1 && i2 == 2 ) cout << 'a' << endl;\n\tif ( bit & (1<<i2) ) continue;       \t\n\tfor ( int j = 0; j < i2; j++ ) {\n\t  if ( !(bit & (1<<j)) && intersect(circles[j], c2) ) {\t    \n\t    flag = false;\n\t    break;\n\t  }\n\t}\n\tif ( flag ) {\n\t  ret = max(ret, dfs(bit|(((1<<i1)+(1<<i2))))+2);\t  \n\t}\n      }\n    }\n  }\n  \n  return dp[bit] = ret;  \n}\n\nsigned main() {\n  while ( cin >> N, N ) {\n    for ( int i = 0; i < 4; i++ ) C[i].clear();\n    circles.clear();\n    dp.clear();    \n    \n    for ( int i = 0; i < N; i++ ) {\n      Circle in;\n      double x, y, r;\n      int c;      \n      cin >> x >> y >> r >> c;\n      c--;\n      in.p = Point{x, y};      \n      in.r = r;\n      in.id = i;      \n      C[c].push_back(in);\n      circles.push_back(in);      \n    }\n    \n    cout << dfs(0)-1 << endl;    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint solve(const vector<int>&cs,const vector<vector<int> >& cover,int bit,vector<int>& memo)\n{\n\tif(memo[bit]!=-1)\n\t\treturn memo[bit];\n\tint n=cs.size();\n\tint res=0;\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i==j || cs[i]!=cs[j])\n\t\t\t\tcontinue;\n\t\t\tif((bit&1<<i) || (bit&1<<j))\n\t\t\t\tcontinue;\n\t\t\tbool ok=true;\n\t\t\tfor(int k=0;k<i;k++)\n\t\t\t\tok&=(bit&1<<k) || cover[i][k]==0;\n\t\t\tfor(int k=0;k<j;k++)\n\t\t\t\tok&=(bit&1<<k) || cover[j][k]==0;\n\t\t\tif(!ok)\n\t\t\t\tcontinue;\n\t\t\tres=max(res,2+solve(cs,cover,bit|1<<i|1<<j,memo));\n\t\t}\n\treturn memo[bit]=res;\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tvector<int> xs(n),ys(n),rs(n),cs(n);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>xs[i]>>ys[i]>>rs[i]>>cs[i];\n\t\tvector<vector<int> > cover(n,vector<int>(n));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tint x=xs[j]-xs[i],y=ys[j]-ys[i],r=rs[i]+rs[j];\n\t\t\t\tif(x*x+y*y<r*r)\n\t\t\t\t\tcover[i][j]=1;\n\t\t\t}\n\t\t}\n\t\tvector<int> memo(1<<n,-1);\n\t\tint res=solve(cs,cover,0,memo);\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<algorithm>\n#define INIT 100\nusing namespace std;\nstruct circle\n{\n    int x, y, r;\n    int c;\n}cc[24];\nchar dp[(1<<24)];\nint n;\nbool intersect(int i, int j)\n{\n    int x1, y1, x2, y2;\n    int r1, r2;\n    x1 = cc[i].x, y1 = cc[i].y, r1 = cc[i].r;\n    x2 = cc[j].x, y2 = cc[j].y, r2 = cc[j].r;\n\n    if( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) >=  (r1+r2)*(r1+r2))\n    {\n        return false;\n\n    }//騾」蠢?キ夐聞>=蜊雁セ大柱?夂┌逶ク莠、\n    else\n        return true;\n\n}\nint check(int a, int b, int state)\n{\n    if( ((1<<a-1)&state) == 0 || ((1<<b-1)&state) == 0 )\n    {\n        return 0;\n    }\n\n    if(cc[a].c != cc[b].c) return 0;\n\n\n    int p[2];\n    p[0]=a, p[1]=b;\n\n    for(int k=0; k<2; k++)\n    {\n        int x =  (1<<p[k]-1)-1;\n        if( (x&state) > 0)\n        {\n            for(int i=1; i<=p[k]-1; i++)\n            {\n                int test = 1 << i-1;\n                if( (test&state) && intersect(p[k], i) )\n                {\n                    return 0;\n                }\n            }\n        }\n    }\n\n    return 1;\n}\nchar DP(int state)\n{\n    if(state==0) return 0;\n    if(dp[state]!=INIT) return dp[state];\n\n    for(int i=1; i<n; i++)\n    {\n        for(int j=i+1; j<=n; j++)\n        {\n            if( check(i,j, state) )\n            {\n                int mask = (1<<i-1) | (1<<j-1);\n\n                dp[state^mask] = DP(state^mask);\n                if(dp[state^mask]+2 > dp[state] || dp[state]==INIT)\n                    dp[state] = dp[state^mask]+2;\n            }\n        }\n    }\n    return dp[state]==INIT? 0:dp[state];\n}\n\nint main()\n{\n\n    while(scanf(\"%d\",&n) && n)\n    {\n        for(int i=1; i<=n; i++)\n            scanf(\"%d%d%d%d\",&cc[i].x, &cc[i].y, &cc[i].r, &cc[i].c);\n\n        int state = (1<<n)-1;\n        for(int i=0; i<=state; i++)\n            dp[i] = INIT;\n\n        dp[state] = DP(state);\n\n        printf(\"%d\\n\",dp[state]);\n\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble tmp=c.r*c.r-norm(pr-c.c);\n\tif(abs(tmp)<EPS)tmp=0;\n\tdouble t=sqrt(tmp);\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nbool dp[1<<24];\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<C>in;\n\t\tvi col(n);\n\t\trep(i,n){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tin.pb(C(P(a,b),c));\n\t\t\tcol[i]=d;\n\t\t}\n\t\trep(i,1<<24)dp[i]=0;\n\t\tdp[0]=1;\n\t\tqueue<int>que;\n\t\tque.push(0);\n\t\tint out=0;\n\t\twhile(!que.empty()){\n\t\t\tint t=que.front();\n\t\t\tque.pop();\n\t\t\tint co=0;\n\t\t\trep(i,n)if(t&1<<i)co++;\n\t\t\tout=max(out,co);\n\t\t\trep(i,n)if((t&1<<i)==0)loop(j,i+1,n)if((t&1<<j)==0&&col[i]==col[j]){\n\t\t\t\tbool h=true;\n\t\t\t\trep(k,i)if((t&1<<k)==0&&abs(in[k].c-in[i].c)<in[k].r+in[i].r)h=false;\n\t\t\t\trep(k,j)if((t&1<<k)==0&&abs(in[k].c-in[j].c)<in[k].r+in[j].r)h=false;\n//\t\t\t\tcout<<i<<\" \"<<j<<\" \"<<h<<endl;\n\t\t\t\tif(h){\n\t\t\t\t\tint nt=(t|1<<i)|1<<j;\n\t\t\t\t\tif(dp[nt]==0){\n\t\t\t\t\t\tque.push(nt);\n\t\t\t\t\t\tdp[nt]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<string>\n#include<cmath>\n#include<cassert>\n#include<unordered_map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll int__;\n#define rep(i,j) for(int__ (i)=0;(i)<(j);(i)++)\n#define repeat(i,j,k) for(int__ i=(j);i<(k);(i)++)\n#define all(v) begin(v),end(v)\n\nconst int INF = 1<<30;\n\nstruct Circle{\n  int x,y,r,c;\n};\n\n\nbool is_intersect(const Circle &c1,const Circle &c2){\n  int dist2=pow(c1.x-c2.x,2)+pow(c1.y-c2.y,2);\n  if(dist2>=pow(c1.r+c2.r,2))return false;\n  return true;\n}\n\nint n;\nvector<Circle> C;\nvector< vector<bool> > is_I;\n\nunordered_map<unsigned int,int> MEMO;\n\n\nint rec(unsigned int bits){\n  if(MEMO.find(bits)!=MEMO.end())return MEMO[bits];\n  \n  int ret=INF;\n  vector<int> tops[4];\n  rep(i,n){\n    if(bits & (1<<i)){\n      rep(j,i){\n        if(bits & (1<<j)){\n          if(is_I[i][j])goto BREAK;\n        }\n      }\n      tops[C[i].c-1].push_back(i);\n   BREAK:;\n    }\n  }\n\n  rep(i,4){\n    rep(j,tops[i].size()){\n      rep(k,j){\n        ret = min(ret,rec(bits & ~((1<<tops[i][j]) | (1<<tops[i][k]))));\n      }\n    }\n  }\n\n  if(ret==INF){\n    ret=__builtin_popcount(bits);\n  }\n  return MEMO[bits]=ret;\n}\n\nint main()\n{\n  while(true){\n    C.clear();\n    is_I.clear();\n    MEMO.clear();\n    \n    cin>>n;\n    if(n==0)break;\n    C.resize(n);\n    is_I.resize(n,vector<bool>(n,false));\n    \n    rep(i,n){\n      int x,y,r,c;\n      cin>>x>>y>>r>>c;\n      C[i]=(Circle){x,y,r,c};\n    }\n    rep(i,n){\n      rep(j,n){\n        is_I[i][j]=is_intersect(C[i], C[j]);\n      }\n    }\n    unsigned int bits=0;\n    rep(i,n)bits|=1<<i;\n    cout<<n-rec(bits)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS=1e-10;\nbool EQ(double a,double b){\n\treturn abs(a-b)<EPS;\n}\n\nint n;\nint xs[101];\nint ys[101];\nint rs[101];\nint cs[101];\nchar dp[1<<24];\nbool isNoCross(int a,int b){\n\tdouble sumR=rs[a]+rs[b];\n\tdouble dist=sqrt(1.0*(xs[a]-xs[b])*(xs[a]-xs[b])+(ys[a]-ys[b])*(ys[a]-ys[b]));\n\tif(EQ(sumR,dist)||sumR<dist)return true;\n\treturn false;\n}\n\nbool isOver(int a,int b){\n\tif(isNoCross(a,b))return true;\n\treturn a<b;\n}\n\nint dfs(int mask){\n\tif(dp[mask]>=0)return dp[mask];\n\tif(mask==(1<<n)-1)return 0;\n\tint res=0;\n\tint lt[30];\n\tint sz=0;\n\tfor(int i=0;i<n;i++){\n\t\tbool ok=true;\n\t\tif((mask>>i)&1)continue;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i==j)continue;\n\t\t\tif((mask>>j)&1)continue;\n\t\t\tif(!isOver(i,j)){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok)\n\t\t\tlt[sz++]=i;\n\t}\n\tfor(int i=0;i<sz;i++){\n\t\tfor(int j=i+1;j<sz;j++){\n\t\t\tint a=lt[i];\n\t\t\tint b=lt[j];\n\t\t\tif(cs[a]==cs[b]){\n\t\t\t\tint nmask=mask;\n\t\t\t\tnmask|=(1<<a);\n\t\t\t\tnmask|=(1<<b);\n\t\t\t\tres=max(res,dfs(nmask)+2);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[mask]=res;\n}\n\nvoid solve(){\n\n\twhile(cin>>n&&n){\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>xs[i]>>ys[i]>>rs[i]>>cs[i];\n\t\tint res=dfs(0);\n\t\tcout<<res<<endl;\n\t}\n}\nint main(){\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint N;\nint parents[25];\nbool visited[1<<24];\nbool used[24];\nint x[25], y[25], r[25], c[25];\n\n\nbool overlap(int a, int b)\n{\n    int dist = (x[a] - x[b]) * (x[a] - x[b]) + (y[a] - y[b]) * (y[a] - y[b]);\n\n    return (dist < (r[a] + r[b]) * (r[a] + r[b]) );\n}\n\nbool isTop(int a)\n{\n    int p = parents[a];\n    for(int i=0; i<N; i++) {\n\tif( p & (1<<i) ) {\n\t    if ( used[i] == false ) return false;\n\t}\n    }\n\n    return true;\n}\n\nvoid make_tree()\n{\n    memset(parents, 0, sizeof(parents));\n    \n    for(int i=0; i<N; i++) {\n\tfor(int j=0; j<i; j++) {\n\t    if(overlap(i,j) == true) parents[i] |= (1<<j);\n\t}\n    }\n}\n\nint hash()\n{\n    int res = 0;\n\n    for(int i=0; i<N; i++)\n\tif(used[i]) res += (1<<i);\n\n    return res;\n}\n\n\nint solve(int cnt)\n{\n    int res = cnt;\n    \n    for(int i=0; i<N; i++)\n\tfor(int j=i+1; j<N; j++) {\n\t    if(used[i] || used[j]) continue;\n\t    if(c[i] != c[j]) continue;\n\t    if(!isTop(i) || !isTop(j)) continue;\n\n\t    used[i] = used[j] = true;\n\n\t    int h = hash();\n\n\t    if ( !visited[h] ) {\n\t\tvisited[h] = true;\n\t\tres = max(res, solve(cnt + 2) );\n\t    }\n\n\t    used[i] = used[j] = false;\n\t}\n\n    return res;\n}\n\nint main()\n{\n    while(cin >> N, N) {\n\tfor(int i=0; i<N; i++) {\n\t    cin >> x[i] >> y[i] >> r[i] >> c[i];\n\t}\n\n\tmemset(used, 0, sizeof(used));\n\tmemset(visited, 0, sizeof(visited));\n\t\n\tmake_tree();\n\tcout <<  solve(0) << endl;\n    }\n}\n\n\t\n\n\t    \n\t\t\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#define HIT(a,b) ((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r))\n\nusing namespace std;\n\nchar Log[90][30];\nint Logcnt;\n\nstruct DISK {\n\tint x,y,r,c,f;\n};\nint n;\n\nvoid setontop(DISK *D){\n\tint i,j;\n\tfor(i=0;i<n;i++){\n\t\tD[i].f=D[i].r;\n\t\tfor(j=i+1;j<n;j++)\n\t\t\tif(D[j].r && HIT(D[i],D[j])) D[i].f=0;\n//\t\tprintf(\"ontop%d %d\\n\", i, D[i].f);\n\t}\n}\n\nint checkLog(DISK *D){\n\tint i,j;\n\tfor(i=0;i<Logcnt;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif((D[j].r && !Log[i][j]) || (!D[j].r && Log[i][j])) break;\n\t\t}\n\t\tif(j==n){\n\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint solve(DISK *D){\n\tint i,j,k,min=30,ret;\n\tif(checkLog(D)) return 30;\n\tfor(i=0;i<n;i++) Log[Logcnt][i]=D[i].r;\n\tLogcnt ++;\n\tsetontop(D);\n\tfor(i=1;i<=4;i++){\n\t\tchar list[6],li=0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(D[j].f&&D[j].c==i) list[li++]=j;\n\t\t}\n//\t\tprintf(\"%d %d\\n\",i,li);\n\t\tif(li<2)continue;\n\t\tDISK tmp[30];\n\t\tfor(j=0;j<li;j++){\n\t\t\tfor(k=j+1;k<li;k++){\n//\t\t\t\tprintf(\"remove(%d,%d)\", list[j],list[k]);\n\t\t\t\tmemcpy(tmp,D,sizeof(tmp));\n\t\t\t\ttmp[list[j]].r=0;\n\t\t\t\ttmp[list[k]].r=0;\n\t\t\t\tret=solve(tmp);\n\t\t\t\tif(ret<min)min=ret;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ret=0,i=0;i<n;i++)if(D[i].r)ret++;\n\tif(ret<min)min=ret;\n//\tprintf(\"return %d\\n\", min);\n\treturn min;\n}\n\nint main(){\n\tint i,j;\n\twhile(cin>>n,n){\n\t\tDISK D[30];\n\t\tLogcnt=0;\n\t\tfor(i=n;i-->0;) cin>>D[i].x>>D[i].y>>D[i].r>>D[i].c;\n\t\tcout<<n-solve(D)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\nbool G[24][24];\nint n,over[24],x[24],y[24],r[24],c[24];\nshort int dp[1<<24];\nint norm(int x,int y) { return x*x+y*y; }\nvector<int> col[4];\nint dfs(int x){\n\tif(dp[x]!=-1) return dp[x];\n\tdp[x]=0;\n\tbool use[24]={};\n\trep(i,n) use[i]=(x>>i)&1;\n\trep(i,4){\n\t\trep(a,col[i].size()){\n\t\t\tif(use[col[i][a]] || over[col[i][a]]>0) continue;\n\t\t\tint p=col[i][a];\n\t\t\trep(b,a){\n\t\t\t\tif(use[col[i][b]] || over[col[i][b]]>0) continue;\n\t\t\t\tint q=col[i][b];\n\t\t\t\tfor(int j=p+1;j<n;j++) if(G[j][p]) over[j]--;\n\t\t\t\tfor(int j=q+1;j<n;j++) if(G[j][q]) over[j]--;\n\t\t\t\tdp[x]=max((int)dp[x],2+dfs(x+(1<<p)+(1<<q)));\n\t\t\t\tfor(int j=p+1;j<n;j++) if(G[j][p]) over[j]++;\n\t\t\t\tfor(int j=q+1;j<n;j++) if(G[j][q]) over[j]++;\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[x];\n}\nint main(){\n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\trep(i,n) rep(j,n) G[i][j]=0;\n\t\trep(i,n) over[i]=0;\n\t\trep(i,n) cin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\trep(i,4) col[i].clear();\n\t\trep(i,n){\n\t\t\tc[i]--;\n\t\t\tcol[c[i]].pb(i);\n\t\t}\n\t\trep(i,n) rep(j,i) if(norm(x[i]-x[j],y[i]-y[j])<norm(r[i]+r[j],0)) G[i][j]=1,over[i]++;\n\t\trep(i,1<<n) dp[i]=-1;\n\t\tcout << dfs(0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 30;\nint x[MAXN], y[MAXN], r[MAXN], c[MAXN];\nint dp[1<<20];\nbool ok[MAXN];\n\nint square(int x) {return x*x;}\n\n// i, j ???????????£?????????????????????\n// ????????£????????? true\nbool check(int i, int j) {\n    int d2 = square(x[i]-x[j]) + square(y[i]-y[j]);\n    return d2 < square(r[i]+r[j]);\n}\n\nint dfs(int state, int n) {\n    if (state < (1<<20)) {\n        if (dp[state] >= 0) return dp[state];\n    }\n    int ret = 0;\n    state ^= (1<<n)-1;\n    // ???????????¨??????????????§??????????????????????????????\n    vector<int> already;\n    memset(ok, true, sizeof(ok));\n    for (int i = 0; i < n; i++) {\n        if ((state>>i)&1) continue;\n        if (ok[i]) {\n            already.push_back(i);\n        }\n        for (int j = i+1; j < n; j++) {\n            if (check(i, j)) ok[j] = false;\n        }\n    }\n    int sz = already.size();\n    for (int i = 0; i < sz; i++) {\n        for (int j = i+1; j < sz; j++) {\n            int ai = already[i], aj = already[j];\n            if (c[ai] == c[aj]) {\n                int nstate = state;\n                nstate |= 1<<ai;\n                nstate |= 1<<aj;\n                ret = max(2+dfs(nstate^((1<<n)-1), n), ret);\n            }\n        }\n    }\n    state ^= (1<<n)-1;\n    if (state < (1<<20)) dp[state] = ret;\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while (cin >> n) {\n        if (n==0) break;\n        for (int i = 0; i < n; i++) cin >> x[i] >> y[i] >> r[i] >> c[i];\n        memset(dp, -1, sizeof(dp));\n        cout << dfs((1<<n)-1, n) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\ndouble x[25],y[25],r[25];\nint c[25],ng[25];\nint n;\nint dp[1<<24];\nint dfs(int i){\n    int ret=0;\n    if(dp[i]!=-1) return dp[i];\n    int cur=0;\n    int ti=i;\n    while(ti){\n        if(ti%2==1){\n            bool flag=true,flag2=true;\n            rep(j,cur)if((i>>j&1)&&(ng[cur]>>j)&1){\n                flag=false;break;\n            }\n            if(flag){\n                FOR(j,cur+1,n)if(!((ng[cur]>>j)&1)&&c[cur]==c[j]&&(i>>j&1)){\n                    bool f=false;\n                    rep(k,j)if((i>>k&1)&&(ng[j]>>k&1)){\n                        f=true;break;\n                    }\n                    if(!f) flag2=false,ret=max(ret,dfs(i^(1<<cur)^(1<<j))+2);\n                }\n            }\n            //if(flag&&!flag2) break;\n        }\n        ++cur;\n        ti>>=1;\n    }\n    return dp[i]=ret;\n}\nint main(){\n    while(cin>>n,n){\n        int cnt=0;\n        memset(ng,0,sizeof(ng));\n        memset(dp,-1,sizeof(dp));\n        rep(i,n) cin>>x[i]>>y[i]>>r[i]>>c[i];\n        FOR(i,1,n)rep(j,i){\n            if(sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]))<r[i]+r[j]){\n                ng[i]|=(1<<j);\n            }\n        }\n        cout<<dfs((1<<n)-1)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nint N;\nint x[30], y[30], r[30], c[30];\nint overlap[30];\nchar dp[(1<<24)+1];\n\nint rec(int S) {\n  if (dp[S] >= 0) return dp[S];\n  int ret = 0;\n  // select lhs\n  for (int i = 0; i < N - 1; ++i) {\n    if (S >> i & 1) continue;\n    if ((overlap[i] | S) != S) continue;\n    // select rhs\n    for (int j = i+1; j < N; ++j) {\n      if ((S >> j & 1) || c[i] != c[j]) continue;\n      if ((overlap[j] | S) != S) continue;\n      // printf(\"%d : %d %d : %d %d : %d %d\\n\", S, i, j, overlap[i], overlap[j]);\n      // remove\n      ret = max(ret, rec(S|(1<<i)|(1<<j)) + 2);\n    }\n  }\n  return dp[S] = ret;\n}\n\nint solve() {\n  // check overlap\n  memset(overlap, 0, sizeof overlap);\n  for (int i = 1; i < N; ++i) {\n    int lapped = 0;\n    for (int j = 0; j < i; ++j) {\n      int dx = x[i] - x[j], dy = y[i] - y[j], dc = r[i] + r[j];\n      if (dx * dx + dy * dy < dc * dc) lapped |= (1 << j);\n    }\n    overlap[i] = lapped;\n  }\n  memset(dp, -1, sizeof dp);\n  return rec(0);\n}\n\nint main() {\n  while (scanf(\"%d\", &N), N) {\n    rep(i,N) scanf(\"%d%d%d%d\", x+i, y+i, r+i, c+i);\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1175\n// And Then. How Many Are There?\n//\n\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<stdio.h>\nusing namespace std;\n\ntypedef struct disc\n{\n  int x, y, r, c;\n}disc;\n\ntypedef struct node\n{\n  disc d;\n  vector<node*> chi;\n}node;\n\nbool c = false;\n\nint overlap(disc a, disc b)\n{\n  double dis_x = (double)(a.x - b.x);\n  double dis_y = (double)(a.y - b.y);\n  double distance = sqrt(dis_x * dis_x + dis_y * dis_y);\n\n  return (distance < (double)(a.r + b.r));\n}\n\n\nvoid free_tree(node* p)\n{\n  for(int i = 0; i < p->chi.size(); i++)\n    {\n      free_tree(p->chi[i]);\n    }\n  delete p;\n  return ;\n}\n\n// void print_tree(node* p, int dep)\n// {\n//   for(int i = 0; i < dep; i++)\n//     {\n//       cout << \" \";\n//     }\n\n//   printf(\"(%d, %d, %d, %d)\\n\", p->d.x, p->d.y, p->d.r, p->d.c);\n\n//   for(int i = 0; i < p->chi.size(); i++)\n//     {\n//       print_tree(p->chi[i], dep + 1);\n//     }\n//   return ;\n// }\n\n\nint dfs(vector<node*> v, int d_n)\n{\n  int ret = d_n;\n  if(v.size() <= 1)\n    return ret;\n  else\n    {\n      for(int i = 0; i < v.size(); i++)\n\t{\n\t  vector<node*> vv = v;\n\t  int a_c = vv[i]->d.c;\n\t  for(int j = i + 1; j < vv.size(); j++)\n\t    {\n\t      if(a_c == vv[j]->d.c)\n\t\t{\n\t\t  vector<node*> a_v = vv[i]->chi;\n\t\t  vector<node*> b_v = vv[j]->chi;\n\t\t  vv.erase(vv.begin() + j);\n\t\t  vv.erase(vv.begin() + i);\n\t\t  vv.insert(vv.end(), a_v.begin(), a_v.end());\n\t\t  vv.insert(vv.end(), b_v.begin(), b_v.end());\n\t\t  int res = dfs(vv, d_n + 2);\n\t\t  vv = v;\n\t\t  ret = ((res > ret)? res: ret);\n\t\t}\n\t    }\n\t}\n    }\n  return ret;\n}\n\n\nvoid inr_insert(disc d, node *p)\n{\n  for(int i = 0; i < p->chi.size(); i++)\n    {\n      if(overlap(d, p->chi[i]->d))\n\t{\n\t  inr_insert(d, p->chi[i]);\n\t  return ;\n\t}\n    }\n  node *n = new node;\n  n->d = d;\n  p->chi.push_back(n);\n  return ;\n}\n\nvoid insert(disc d, node *p)\n{\n  for(int i = 0; i < p->chi.size(); i++)\n    {\n      if(overlap(d, p->chi[i]->d))\n\t{\n\t  inr_insert(d, p->chi[i]);\n\t  c = true;\n\t  return ;\n\t}\n      else\n\t{\n\t  insert(d, p->chi[i]);\n\t}\n    }\n  return ;\n}\n\nint main(void)\n{\n  int n;\n  while(cin >> n, n)\n    {\n      node *root = new node;\n      root->d.x = 0, root->d.y = 0, root->d.c = 0, root->d.r = 0;\n      for(int i = 0; i < n; i++)\n\t{\n\t  disc d;\n\t  cin >> d.x;\n\t  cin >> d.y;\n\t  cin >> d.r;\n\t  cin >> d.c;\n\t  insert(d, root);\n\t  if(!c)\n\t    {\n\t      node *n = new node;\n\t      n->d = d;\n\t      root->chi.push_back(n);\n\t  \n\t    }\n\t  c = false;\n\t  // cout << \"-------------\" << endl;\n\t  // print_tree(root, 0);\n\t}\n      printf(\"%d\\n\", dfs(root->chi, 0));\n      free_tree(root);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <complex>\n#include <queue>\n#include <set>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\ntypedef complex<double> P;\n\nint bitcount(int b) { int c = 0; while(b) { b &= b-1; c++; } return c; }\n\nint n, x[64], y[64], r[64], c[64], g[64][64];\n\nint solve() {\n    rep(i, n) for(int j=i+1; j<n; j++) {\n        const double d = abs(P(x[i], y[i])-P(x[j], y[j]));\n        g[i][j] = d<r[i]+r[j];\n    }\n    int ans = 0;\n    set<int> vis;\n    queue<int> q;\n    q.push(0);\n    vis.insert(0);\n    while(!q.empty()) {\n        int x = q.front();\n        q.pop();\n        ans = max(ans, bitcount(x));\n        int can = ~x;\n        rep(i, n) if((x&(1<<i))==0) {\n            for(int j=i+1; j<n; j++) if(g[i][j]) can &= ~(1<<j);\n        }\n        rep(i, n) if(can&(1<<i)) rep(j, i) if(can&(1<<j) && c[i]==c[j]) {\n            const int nx = x|(1<<i)|(1<<j);\n            if(vis.find(nx)==vis.end()) {\n                q.push(nx);\n                vis.insert(nx);\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    for(;;) {\n        scanf(\"%d\", &n);\n        if(n==0) return 0;\n        rep(i, n) scanf(\"%d%d%d%d\", x+i, y+i, r+i, c+i);\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint N, X[30], Y[30], R[30], C[30];\nint dp[2000000];\n\nbool f(int n, int s) {\n  REP(i, 0, n) {\n    if(s & (1 << i)) continue;\n    if(pow(R[n] + R[i], 2) > pow(X[n] - X[i], 2) + pow(Y[n] - Y[i], 2)) return false;\n  }\n  return true;\n}\n\nint dfs(int s, int n) {\n  if(dp[s] >= 0) return dp[s];\n  if(n == N) return N;\n\n  // cout << s << \" \" << n << endl;\n\n  int ret = n;\n  REP(i, 0, N) {\n    if(s & (1 << i)) continue;\n    REP(j, i + 1, N) {\n      if(s & (1 << j)) continue;\n      if(C[i] != C[j]) continue;\n      if(!f(i, s) || !f(j, s)) continue;\n      ret = max(ret, dfs(s | (1 << i) | (1 << j), n + 2));\n    }\n  }\n\n  return dp[s] = ret;\n}\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> X[i] >> Y[i] >> R[i] >> C[i];\n    REP(i, 0, pow(2, N)) dp[i] = -1;\n\n    cout << dfs(0, 0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint N, X[24], Y[24], R[24], C[24];\nbool r[24][24];\nchar dp[16777216];\n\nbool f(char n, int s) {\n  REP(i, 0, n) {\n    if(s & (1 << i)) continue;\n    if(r[n][i]) return false;\n  }\n  return true;\n}\n\nchar dfs(int s, char n) {\n  if(dp[s] >= 0) return dp[s];\n  if(n == N) return N;\n\n  // cout << s << \" \" << (int) n << endl;\n\n  char ret = n;\n  REP(i, 0, N) {\n    if(s & (1 << i)) continue;\n    REP(j, i + 1, N) {\n      if(s & (1 << j)) continue;\n      if(C[i] != C[j]) continue;\n      if(!f(i, s) || !f(j, s)) continue;\n      ret = max(ret, dfs(s | (1 << i) | (1 << j), n + 2));\n    }\n  }\n\n  return dp[s] = ret;\n}\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> X[i] >> Y[i] >> R[i] >> C[i];\n    REP(i, 0, pow(2, N)) dp[i] = -1;\n    REP(i, 0, N) REP(j, 0, N) {\n      if(pow(R[i] + R[j], 2) > pow(X[i] - X[j], 2) + pow(Y[i] - Y[j], 2)) r[i][j] = r[j][i] = true;\n      else r[i][j] = r[i][j] = false;\n    }\n    cout << (int) dfs(0, 0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nstruct circle {\n    int x, y, r;\n    int c;\n};\n\nbool isis_cc(circle const& c1, circle const& c2) {\n    return (c1.x - c2.x) * (c1.x - c2.x) + (c1.y - c2.y) * (c1.y - c2.y) < (c1.r + c2.r) * (c1.r + c2.r);\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<circle> v(n);\n        vector<short> dp(1 << n, -1);\n        vector<int> on(n);\n        for(int i=0; i<n; ++i) {\n            cin >> v[i].x >> v[i].y >> v[i].r >> v[i].c;\n            for(int j=0; j<i; ++j) {\n                if(isis_cc(v[i], v[j])) {\n                    on[i] |= (1 << j);\n                }\n            }\n        }\n\n        dp[0] = 0;\n        short res = 0;\n        for(int b=0; b<(1<<n); ++b) {\n            if(dp[b] == -1) {\n                continue;\n            }\n            res = max(res, dp[b]);\n\n            for(int j=0; j<n; ++j) {\n                if((b & (1 << j)) != 0 || (b & on[j]) != on[j]) {\n                    continue;\n                }\n                for(int k=j+1; k<n; ++k) {\n                    if(v[j].c != v[k].c || (b & (1 << k)) != 0 || (b & on[k]) != on[k]) {\n                        continue;\n                    }\n                    int next = b | (1 << j) | (1 << k);\n                    dp[next] = max((int)dp[next], dp[b]+2);\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nvp in;\nvi r,cl;\nint out,sum,n;\nvi visit;\nbool hy(int a,int b){\n\tdouble dis=hypot(in[a].first-in[b].first,in[a].second-in[b].second);\n\treturn dis<r[a]+r[b];\n}\nvoid f(){\n\trep(i,n)rep(j,n)if(i!=j&&visit[i]+visit[j]==0&&cl[i]==cl[j]){\n\t\tbool h=true;\n\t\trep(l,n){\n\t\t\tif(l<i&&visit[l]==0&&hy(i,l))h=false;\n\t\t\tif(l<j&&visit[j]==0&&hy(l,j))h=false;\n\t\t}\n\t\tif(!h)continue;\n\t\tvisit[i]=visit[j]=1;\n\t\tsum+=2;\n\t\tout=max(out,sum);\n\t\tf();\n\t\tvisit[i]=visit[j]=0;\n\t\tsum-=2;\n\t}\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tin=vp(n);\n\t\tr=vi(n);\n\t\tcl=vi(n);\n\t\trep(i,n){\n\t\t\tcin>>in[i].first>>in[i].second;\n\t\t\tcin>>r[i]>>cl[i];\n\t\t\tcl[i]--;\n\t\t}\n\t\tvisit=vi(n);\n\t\tout=sum=0;\n\t\tf();\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <memory.h>\n#include <functional>\n#include <algorithm>\nusing namespace std;\n\n//FILE * in = freopen(\"input.txt\", \"r\" , stdin);\n\nconst double EPS = 1e-10;\n\ndouble add(double a, double b){\n\tif(abs(a+b) < EPS * (abs(a) + abs(b))) return 0;\n\treturn a+b;\n}\n\nstruct P {\n\tdouble x, y;\n\tP(){}\n\tP(double x, double y):x(x), y(y){}\n\tP operator - (P p) {\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tdouble dot(P p) {\n\t\treturn add(x * p.x, y * p.y);\n\t}\n\tP operator = (P p) {\n\t\treturn P(p.x, p.y);\n\t}\n};\n\ndouble dist(P p, P q){\n\treturn (p-q).dot(p-q);\n}\n\nstruct disk{P center; int length; int number;};\n\nint n;\ndisk data[50];\nint G[50][50];\nint tag[50];\n\nbool isCovered(int x, int y) {\n\treturn dist(data[x].center, data[y].center) < (data[x].length + data[y].length)*(data[x].length + data[y].length);\n}\n\nint Max = 0;\n\nvoid input(){\n\tint i , j;\n\tint x, y;\n\tMax = 0;\n\tmemset(G, 0, sizeof(G));\n\tfor(i = 0 ; i < n; i++){\n\t\tscanf(\"%d%d%d%d\", &x, &y, &data[i].length, &data[i].number);\n\t\tdata[i].center.x = x;\n\t\tdata[i].center.y = y;\n\t\tfor(j = 0; j < i; j++){\n\t\t\tif(isCovered(j, i)) {\n\t\t\t\tG[j][i] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid getTops(vector<int> tops[4]) {\n\tint i , j;\n\tfor ( i = 0; i < n; i++) {\n\t\tif(tag[i])continue;\n\t\tfor(j = 0; j < n; j++) {\n\t\t\tif(tag[j]) continue;\n\t\t\tif(G[j][i]) break;\n\t\t}\n\t\tif(j == n)\n\t\t\ttops[data[i].number-1].push_back(i);\n\t}\n}\n\nvoid back(int lev) {\n\tvector<int> tops[4];\n\tbool flag = false;\n\tgetTops(tops);\n\tfor(int i = 0; i < 4; i++){\n\t\tint sz = tops[i].size();\n\t\tif(sz == 2) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\ttag[tops[i][0]] = true;\n\t\t\t\ttag[tops[i][1]] = true;\n\t\t\t}\n\t\t\tback(lev+1);\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\ttag[tops[i][0]] = false;\n\t\t\t\ttag[tops[i][1]] = false;\n\t\t\t}\n\t\t}\n\t\telse if (sz > 2) {\n\t\t\tfor(int j = 0; j < sz; j++) {\n\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\ttag[tops[i][j]] = true;\n\t\t\t\t}\n\n\t\t\t\tfor (int k = j + 1; k < sz; k++) {\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\ttag[tops[i][k]] = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tback(lev+1);\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\ttag[tops[i][k]] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\ttag[tops[i][j]] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif ( Max < lev * 2)\n\t\tMax = lev * 2;\n}\n\nvoid process() {\n\tback(0);\n\tprintf(\"%d\\n\", Max);\n}\n\nint main() {\n\twhile(true){\n\t\tscanf(\"%d\", &n);\n\t\tif ( n == 0) break;\n\t\tinput();\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint n;\n\nstruct Circle {\n    int x, y, r;\n    int c;\n    Circle() {}\n    Circle(int x, int y, int r, int c) : x(x), y(y), r(r), c(c) {}\n};\n\nbool intersect(Circle& a, Circle& b) {\n    return (a.r+b.r) * (a.r+b.r) > (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y);\n}\n\nvector<Circle> cs;\nvector< vector<int> > upper;\nvoid init() {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (intersect(cs[i], cs[j])) {\n                upper[i].push_back(j);\n            }\n        }\n    }\n}\n \nchar dp[1<<24];\nint remove(int used=0) {\n    if (dp[used] >= 0) return dp[used];\n    vector<int> tops;\n    for (int i = 0; i < n; i++) {\n        if (used & (1<<i)) continue;\n        bool cover = false;\n        for (int j = 0; j < upper[i].size(); j++) {\n            if (!(used & (1<<upper[i][j]))) {\n                cover = true;\n                break;\n            }\n        }\n        if (!cover) tops.push_back(i);\n    }\n    int cnt = 0;\n    for (int i = 0; i < tops.size(); i++) {\n        for (int j = 0; j < tops.size(); j++) {\n            if (i == j) continue;\n            if (cs[tops[i]].c == cs[tops[j]].c) {\n                used |= (1<<tops[i]);\n                used |= (1<<tops[j]);\n                cnt = max(cnt, remove(used)+2);\n                used ^= (1<<tops[i]);\n                used ^= (1<<tops[j]);\n            }\n        }\n    }\n    return dp[used] = cnt;\n}\n\nint main() {\n    while (cin >> n, n) {\n        cs = vector<Circle>(n);\n        upper = vector< vector<int> >(n);\n        for (int i = 0; i < n; i++) {\n            int x, y, r, c;\n            cin >> x >> y >> r >> c;\n            cs[i] = Circle(x, y, r, c);\n        }\n        init();\n        memset(dp, -1, sizeof(dp));\n        cout << remove() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define double long double\n\ndouble EPS = (1e-8);\n\nstruct Point {\n  double x, y;\n};\n\nstruct Circle {\n  Point p;\n  double r;\n  int id;\n};\n\nbool intersect(Circle a, Circle b) {\n  double x1 = a.p.x, y1 = a.p.y;\n  double x2 = b.p.x, y2 = b.p.y;  \n  double d = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);\n\n  if ( d - (a.r+b.r)*(a.r+b.r) >= -EPS ) return false;  \n  else return true;\n}\n\nvector<Circle> C[4];\nvector<Circle> circles;\nint N;\nunordered_map<int, int> dp;\n\nint dfs(int bit) {\n  //cout << bit << endl;\n  if ( bit == (1<<N)-1 ) return 0;\n  if ( dp[bit] ) return dp[bit];\n\n  int ret = 0;\n  int n;\n  for ( int i = 0; i < 4; i++ ) {\n    n = C[i].size();\n    for ( int a = 0; a < n; a++ ) {\n      Circle c1 = C[i][a];\n      int i1 = c1.id;\n      //if ( bit == 9 && i1 == 1 ) cout << 'a' << endl;\n      if ( bit & (1<<i1) ) continue;\n      bool flag = true;\t\n      for ( int j = 0; j < i1; j++ ) {\n\tif ( !(bit & (1<<j)) && intersect(circles[j], c1) ) {\n\t  flag = false;\n\t  break;\n\t}\n      }\n      //if ( bit == 9 && i1 == 1 ) cout << 'a' << endl;\n      if ( !flag ) continue;\n      //if ( bit == 9 && i1 == 1 ) cout << 'a' << endl;\n      for ( int b = a+1; b < n; b++ ) {\n\tCircle c2 = C[i][b];\n\tint i2 = c2.id;\n\t//if ( i1 == 1 && i2 == 2 ) cout << 'a' << endl;\n\tif ( bit & (1<<i2) ) continue;       \t\n\tfor ( int j = 0; j < i2; j++ ) {\n\t  if ( !(bit & (1<<j)) && intersect(circles[j], c2) ) {\t    \n\t    flag = false;\n\t    break;\n\t  }\n\t}\n\tif ( flag ) {\n\t  ret = max(ret, dfs(bit|(((1<<i1)+(1<<i2))))+2);\t  \n\t} else {\n\t  flag = true;\n\t}\n      }\n    }\n  }\n  \n  return dp[bit] = ret;  \n}\n\nsigned main() {\n  while ( cin >> N, N ) {\n    for ( int i = 0; i < 4; i++ ) C[i].clear();\n    circles.clear();\n    dp.clear();    \n    \n    for ( int i = 0; i < N; i++ ) {\n      Circle in;\n      double x, y, r;\n      int c;      \n      cin >> x >> y >> r >> c;\n      c--;\n      in.p = Point{x, y};      \n      in.r = r;\n      in.id = i;      \n      C[c].push_back(in);\n      circles.push_back(in);      \n    }\n    \n    cout << dfs(0) << endl;    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\nint n;\nvector<char> dp, up;\nvector<Circle> c;\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = (a.r + b.r) * (a.r + b.r);\n    int d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    return r > d;\n}\n\nchar Rec(char s)\n{\n    if (dp[s] != -1)\n        return dp[s];\n\n    int res = 0;\n    // 取り除く2つの円の選択\n    for (int i = 0; i < n; ++i) {\n        // c[i]がないか取り除けない\n        if (!(s >> i & 1) || s & up[i])\n            continue;\n\n        for (int j = i + 1; j < n; ++j) {\n            // c[i]とc[j]の色が異なる\n            if (c[i].c != c[j].c)\n                continue;\n            // c[j]がないか取り除けない\n            if (!(s >> j & 1) || s & up[j])\n                continue;\n\n            int nxt = s & ~(1 << i) & ~(1 << j);\n            res = max(res, (int)Rec(nxt) + 2);\n        }\n    }\n\n    return dp[s] = res;\n}\n\nint main()\n{\n    while (cin >> n, n) {\n        dp.assign(1 << n, -1);\n        up.assign(n, 0);\n        c.resize(n);\n\n        // 円の入力\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        // 円の重なり，上下関係\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                if (isOverlap(c[i], c[j]))\n                    up[j] = up[j] | (1 << i);\n\n        cout << (int)Rec((1 << n) - 1) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint main(){\n  int n;\n  cin >> n;\n  while(n!=0){\n    int sum=0;\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    int f=0;\n    int on[30]={};\n    //int cc[5]={};\n    vector<int> cc[5];\n    while(f==0){\n      f=1;\n      /*\n      for(i=0;i<24;i++) on[i]=0;\n      for(i=0;i<v.size();i++){\n\tfor(j=i+1;j<v.size();j++){\n\t  if(ch(v[i],v[j])==1) on[j]=1;\n\t}\n      }\n      for(i=0;i<5;i++) cc[i]=0;\n      for(i=0;i<v.size();i++){\n\tif(on[i]==0) cc[v[i].c]++;\n      }\n      */\n      int ff=0;\n      while(ff==0){\n\tff=1;\n\tfor(i=0;i<30;i++) on[i]=0;\n\tfor(i=0;i<5;i++) cc[i].clear();\n\tfor(i=0;i<v.size();i++){\n\t  for(j=i+1;j<v.size();j++){\n\t    if(ch(v[i],v[j])==1) on[j]=1;\n\t  }\n\t}\n\tfor(i=0;i<v.size();i++){\n\t  if(on[i]==0) cc[v[i].c].push_back(i);\n\t}\n\tfor(i=1;i<5;i++){\n\t  if(cc[i].size()>0&&cc[i].size()%2==0){\n\t    for(j=cc[i].size()-1;j>=0;j--){\n\t      v.erase(v.begin()+cc[i][j]);\n\t      ff=0;\n\t      f=0;\n\t    }\n\t  }\n\t}\n      }\n      \n      for(i=1;i<5;i++){\n\tk=0;\n\tfor(j=v.size()-1;j>=0;j--){\n\t  if(on[j]==0&&v[j].c==i){\n\t    if((cc[i].size()/2)*2>k) {\n\t      //cout << v[j].id << \" \";\n\t      v.erase(v.begin()+j);\n\t      k++;\n\t      f=0;\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout << n-v.size() << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<vector>\n#include<algorithm>\nstruct S{int c,f,x,y,r;}s[24];\nint A(int x){return x*x;}\nchar m[1<<24];\nint n;\nint F(int f)\n{\n\tif(m[f]>=0)return m[f];\n\tstd::vector<int>v[5];\n\tint i,j,k,r=0,t;\n\tfor(i=0;i<n;++i)\n\t\tif((f&(1<<i))&&!(s[i].f&f))\n\t\t\tv[s[i].c].push_back(i);\n\tfor(k=1;k<5;++k)\n\t\tfor(i=0;i<v[k].size();++i)\n\t\t\tfor(j=i+1;j<v[k].size();++j)\n\t\t\t\tr=std::max(r,2+F(f&~(1<<v[k][i])&~(1<<v[k][j])));\n\treturn m[f]=r;\n}\nint main()\n{\n\tint i,j;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tmemset(m,-1,sizeof(m));\n\t\tmemset(s,0,sizeof(s));\n\t\tfor(i=0;i<n;++i)scanf(\"%d%d%d%d\",&s[i].x,&s[i].y,&s[i].r,&s[i].c);\n\t\tfor(i=0;i<n;++i)\n\t\t\tfor(j=i+1;j<n;++j)\n\t\t\t\tif(A(s[i].x-s[j].x)+A(s[i].y-s[j].y)<A(s[i].r+s[j].r))\n\t\t\t\t\ts[j].f|=1<<i;\n\t\tprintf(\"%d\\n\",F((1<<n)-1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\n#define pb push_back\n\nint anss = 0;\n\nint calculate(int x,int y,int r,int xx,int yy,int rr){\n    int d = (x-xx)*(x-xx)+(y-yy)*(y-yy);\n    if(d >= (r+rr)*(r+rr)) return 0;\n    else return 1;\n}\n\nvoid play(int n,int top[],int col[],vector <int> colors[]){\n    //cout << endl << endl;\n    vector <int> pos[6];\n    int ans=0;\n    for(int i = 0 ; i < n ; i++){\n        //cout << \"t \" << i << \" \" << top[i] << endl;\n        if(top[i] == 0){\n            pos[col[i]].pb(i);\n        }\n        if(top[i] == -1) ans++;\n    }\n\n    anss = max(ans,anss);\n    /*\n    for(int i = 1 ; i < 4 ; i++){\n        //cout << i << \" : \";\n        for(int j = 0 ; j < pos[i].size() ; j++) cout << pos[i][j] << \" \";\n        cout << endl;\n    }\n    */\n    for(int i = 1 ; i <= 4 ; i++){\n        if(pos[i].size() == 6){\n            //cout << \"x\" << endl;\n            int topp[30];\n\n            for(int j = 0 ; j < n ; j++) topp[j] = top[j];\n\n            for(int j = 0 ; j < n ; j++){\n                //cout << \"shift \" << pos[i][0] << \" \" << pos[i][1] << endl;\n                //cout << \"shiff \" << j << \" \" << topp[j] << \" \" << (topp[j] & (1<<pos[i][0])) << endl;\n\n                if( (topp[j] & (1<<pos[i][0])) > 0 && topp[j] > 0 ) topp[j] -= 1<<pos[i][0];\n                if( (topp[j] & (1<<pos[i][1])) > 0 && topp[j] > 0 ) topp[j] -= 1<<pos[i][1];\n                if( (topp[j] & (1<<pos[i][2])) > 0 && topp[j] > 0 ) topp[j] -= 1<<pos[i][2];\n                if( (topp[j] & (1<<pos[i][3])) > 0 && topp[j] > 0 ) topp[j] -= 1<<pos[i][3];\n                if( (topp[j] & (1<<pos[i][4])) > 0 && topp[j] > 0 ) topp[j] -= 1<<pos[i][4];\n                if( (topp[j] & (1<<pos[i][5])) > 0 && topp[j] > 0 ) topp[j] -= 1<<pos[i][5];\n            }\n\n            topp[pos[i][0] ] = -1;\n            topp[pos[i][1] ] = -1;\n            topp[pos[i][2] ] = -1;\n            topp[pos[i][3] ] = -1;\n            topp[pos[i][4] ] = -1;\n            topp[pos[i][5] ] = -1;\n            play(n,topp,col,colors);\n        }\n\n        else if(pos[i].size() == 4 && colors[i].size() == 4){\n            //cout << \"x\" << endl;\n            int topp[30];\n\n            for(int j = 0 ; j < n ; j++) topp[j] = top[j];\n\n            for(int j = 0 ; j < n ; j++){\n                //cout << \"shift \" << pos[i][0] << \" \" << pos[i][1] << endl;\n                //cout << \"shiff \" << j << \" \" << topp[j] << \" \" << (topp[j] & (1<<pos[i][0])) << endl;\n\n                if( (topp[j] & (1<<pos[i][0])) > 0 && topp[j] > 0 ) topp[j] -= 1<<pos[i][0];\n                if( (topp[j] & (1<<pos[i][1])) > 0 && topp[j] > 0 ) topp[j] -= 1<<pos[i][1];\n                if( (topp[j] & (1<<pos[i][2])) > 0 && topp[j] > 0 ) topp[j] -= 1<<pos[i][2];\n                if( (topp[j] & (1<<pos[i][3])) > 0 && topp[j] > 0 ) topp[j] -= 1<<pos[i][3];\n            }\n\n            topp[pos[i][0] ] = -1;\n            topp[pos[i][1] ] = -1;\n            topp[pos[i][2] ] = -1;\n            topp[pos[i][3] ] = -1;\n            play(n,topp,col,colors);\n        }\n        else if(pos[i].size() >= 2){\n            do{\n                int topp[30];\n\n                for(int j = 0 ; j < n ; j++) topp[j] = top[j];\n\n                for(int j = 0 ; j < n ; j++){\n                    //cout << \"shift \" << pos[i][0] << \" \" << pos[i][1] << endl;\n                    //cout << \"shiff \" << j << \" \" << topp[j] << \" \" << (topp[j] & (1<<pos[i][0])) << endl;\n\n                    if( (topp[j] & (1<<pos[i][0])) > 0 && topp[j] > 0 ) topp[j] -= 1<<pos[i][0];\n                    if( (topp[j] & (1<<pos[i][1])) > 0 && topp[j] > 0 ) topp[j] -= 1<<pos[i][1];\n                }\n\n                topp[pos[i][0] ] = -1;\n                topp[pos[i][1] ] = -1;\n                play(n,topp,col,colors);\n            }while(next_permutation( pos[i].begin(),pos[i].end() ) );\n        }\n    }\n\n    //cout << \"end\" << endl;\n}\nmain(){\n    //freopen(\"D.txt\",\"r\",stdin);\n    int n;\n\n    while(cin >> n,n>0){\n        int top[30]={0};\n        int xx[30];\n        int yy[30];\n        int rad[30];\n        int col[30];\n        vector <int> colors[6];\n\n        for(int i = 0 ; i < n ; i++){\n            cin >> xx[n-i-1] >> yy[n-1-i] >> rad[n-1-i] >> col[n-1-i];\n\n            colors[col[n-1-i]].pb(n-1-i);\n        }\n\n        for(int i = 0; i < n ; i++){\n            for(int j = 0 ; j < i ; j++){\n                if(calculate(xx[j],yy[j],rad[j],xx[i],yy[i],rad[i])==1){\n                    top[j]+=1<<i;\n                }\n            }\n        }\n\n        anss = 0;\n        play(n,top,col,colors);\n\n        cout << anss << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1175&lang=ja\n// 解答AC\n// 国内予選2011D\n// And Then. How Many Are There?\n\n/*\nProblem.\n位置と半径、色が指定された円盤が配置されていて、\n同色でそれぞれ上に重なる円盤のないペアを排除していく。\n最大でいくつの円盤を排除可能か？\n\nPoint.\n依存関係を表すテーブル on[N] : i番目のitemより先に削除が必要な要素のbitが立っている。\nbool dp[1<<N]: dp[now] が探索済みかどうかT/F\nbit全探索を行い、dfs(int now)中で\n!(now & on[i]) を満たすi、同様にjを求め、\ndfs(now & ~(1<<i) & ~(1<<j)) が実行可能になる。\n*/\n\n\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<queue>\n\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vector<int> >;\nusing pii = pair<int, int>;\nusing ppi = pair<pii, int>;\n\nstruct saucer{\n  double x, y, r;\n  int c;\n  saucer(double ix, double iy, double ir, int ic): x(ix), y(iy), r(ir), c(ic){}\n};\n\nint n;\nint ans;\nvector<saucer> v;\nvector<int> on;\nvector<bool> dp(1<<4);\nvoid dfs(int now){\n  if(dp[now]) return;\n  dp[now] = true;\n  int unused = 0;\n  for(int i = 0; i < n; i++) if(now >> i & 1) unused++; //未削除itemのカウント\n  ans = max(n-unused, ans);\n  for(int i = 0; i < n; i++){\n    if(!(now>>i & 1) || now & on[i]) continue; //依存itemは全て除去済みである必要がある。\n    for(int j = i+1; j < n; j++){\n      if(!(now>>j & 1) || now & on[j]) continue;\n      if(v[i].c == v[j].c){\n        dfs((now & ~(1 << i)) & ~(1 << j));\n      }\n    }\n  }\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int ti = clock();\n  // start-----------------------------------------------\n  while(cin >> n && n){\n    ans = 0;\n    v = vector<saucer>();\n    on = vi(24, 0);\n    dp = vector<bool>(1<<n, false);\n    double x, y, r; int c;\n    for(int i = 0; i < n; i++){\n      cin >> x >> y >> r >> c;\n      v.push_back({x, y, r, c});\n    }\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < i; j++){\n        if(pow((v[i].x-v[j].x), 2.0) + pow((v[i].y-v[j].y), 2.0) < pow(v[i].r+v[j].r, 2.0)){\n          on[i] |= (1 << j);\n        }\n      }\n    }\n    dfs((1<<n)-1);\n    cout << ans << endl;\n  }\n\n  // end-----------------------------------------------\n  // cerr << 1.0 * (clock() - ti) / CLOCKS_PER_SEC << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 24;\n\nint n, x[N], y[N], r[N], c[N], p[N];\nbool vis[1<<N];\n\nbool lap(int a, int b){\n  int d = (x[a] - x[b]) * (x[a] - x[b]) + (y[a] - y[b]) * (y[a] - y[b]);\n  return d < r[a] * r[a] + 2 * r[a] * r[b] + r[b] * r[b];\n}\n\nint rec(int s){\n  int res = 0;\n  vis[s] = true;\n  for(int i=0;i<n;i++){\n    if((s >> i & 1) == 0) continue;\n    for(int j=i+1;j<n;j++){\n      if((s >> j & 1) == 0) continue;\n      if(c[i] != c[j]) continue;\n      if((p[i] & s) == 0 && (p[j] & s) == 0){\n        s &= ~(1 << i);\n        if((p[j] & s) == 0){\n          s &= ~(1 << j);\n          if(!vis[s]) res = max(res, rec(s));\n          s |= 1 << j;\n        }\n        s |= 1 << i;\n      }\n    }\n  }\n  if(s == (1 << n) - 1) return res;\n  return res + 2;\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++) cin >> x[i] >> y[i] >> r[i] >> c[i];\n    fill(p, p+n, 0);\n    fill(vis, vis+(1<<n), false);\n    for(int i=0;i<n;i++) for(int j=0;j<i;j++) if(lap(i, j)) p[i] |= 1 << j;\n    cout << rec((1<<n)-1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <map>\n#include <bitset>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){\n    rep(i,v.size()) os << v[i] << (i+1==v.size()?\"\":\" \");\n    return os;\n}\n\nint n;\nint x[24], y[24], r[24], c[24];\nbool hit[24][24];\nchar dp[1<<24];\n\nchar dfs(int S, int rem){\n    char & res = dp[S];\n    if(res!=-1) return res;\n    res = 0;\n    rep(i,n){\n        if(S>>i & 1){\n            bool ok = true;\n            rep(k,i) if(hit[i][k] && (S>>k & 1)){\n                ok = false;\n                break;\n            }\n            if(!ok) continue;\n            rep(j,i){\n                if(S>>j & 1){\n                    if(hit[i][j] || c[i]!=c[j]) continue;\n                    bool ok = true;\n                    rep(k,j) if(hit[j][k] && (S>>k & 1)){\n                        ok = false;\n                        break;\n                    }\n                    if(!ok) continue;\n                    S ^= 1<<i | 1<<j;\n                    res = max<char>(dfs(S,rem-2)+2, res);\n                    if(res==rem) return res;\n                    S ^= 1<<i | 1<<j;\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(cin>>n && n){\n        memset(dp,-1,sizeof(dp));\n        rep(i,n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n        rep(i,n)rep(j,i){\n            int dx=x[i]-x[j], dy=y[i]-y[j];\n            int d = dx*dx+dy*dy;\n            hit[i][j] = hit[j][i] = d < (r[i]+r[j])*(r[i]+r[j]);\n        }\n        int S = 0;\n        rep(i,n) S |= 1<<i;\n        cout << (int)dfs(S,n) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint n,x[30],y[30],r[30],c[30],cover[30];\nbool dp[1<<24];\n\nint main(){\n  while(cin >> n, n){\n    for(int i=0;i<n;i++)cin >> x[i] >> y[i] >> r[i] >> c[i];\n    \n    vector<pii> same_col;\n    for(int i=0;i<n;i++){\n      cover[i] = 0;\n      for(int j=0;j<i;j++){\n\tif( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j])*(r[i]+r[j]) ){\n\t  cover[i] |= 1<<j;\n\t}\n\tif(c[i] == c[j])same_col.push_back(pii(i,j));\n      }\n    }\n\n    memset(dp,0,sizeof(dp));\n    dp[0] = true;\n\n    for(int bit=0;bit<(1<<n);bit++){\n      if(!dp[bit])continue;\n      for(int i=0;i<(int)same_col.size();i++){\n\tconst int a = same_col[i].first, b = same_col[i].second;\n\tif( (~bit)&(1<<a) && (~bit)&(1<<b) ){\n\t  if( (~bit)&cover[a] || (~bit)&cover[b])continue;\n\t  dp[bit | (1<<a) | (1<<b)] = true;\n\t}\n      }\n    }\n\n    int ans = 0;\n    for(int bit=0;bit<(1<<n);bit++){\n      if(dp[bit])ans = max(ans, __builtin_popcount(bit));\n    }\n    cout << ans << endl;\n  }\t  \n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nint type[4];\n\nll dist(pii a,pii b){\n  ll dx=a.X-b.X,dy=a.Y-b.Y;\n  return dx*dx+dy*dy;\n}\n\nint ans,next_[24];\n\nint nxt(int a,int b){\n  a^=b;\n  rep(i,24)if(b>>i)\n    a|=next_[i];\n  return a;\n}\n\nint memo[1<<24];\n\nint dfs(int st){\n  if(memo[st])return memo[st];\n  int p,stt,re=0;\n  rep(i,4){\n    p=__builtin_popcount(stt=(st&type[i]));\n    if(p>1){\n      if(p%2){\n\trep(j,24)if(stt>>j){\n\t  re=max(dfs(nxt(st,stt^(1<<j))),re);\n\t}\n\tre+=p-1;\n      }else{\n\tre=p+dfs(nxt(st,stt));\n      }\n      break;\n    }\n  }\n  //  cout<<st<<\":\"<<re<<endl;\n  return memo[st]=re;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int i,j,k;\n  int n;\n  while(cin>>n){\n    if(!n)break;\n    memset(memo,0,sizeof(memo));\n    vector<pii> v(n);\n    vector<int> r(n),c(n),ue(n,1);\n    vv<int> g(n);\n    rep(i,4)type[i]=0;\n    rep(i,n){\n      cin>>v[i].X>>v[i].Y>>r[i]>>c[i];\n      --c[i];\n      type[c[i]]|=(1<<i);\n    }\n    rep(i,n)rep(j,i){\n      if(dist(v[i],v[j])<1ll*(r[i]+r[j])*(r[i]+r[j])){\n\tg[j].pb(i);\n\tue[i]=0;\n      }\n    }\n    int st=0;\n    rep(i,n){\n      st|=(ue[i]<<i);\n      for(int a:g[i])\n\tnext_[a]|=1<<a;\n    }\n    //    cout<<st<<endl;\n    cout<<dfs(st)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint n,x[24],y[24],r[24],c[24];//,m[1<<24];\n\nbool insec(int a,int b){\n\treturn (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b])<(r[a]+r[b])*(r[a]+r[b]);\n}\n\nint dfs(int s){\n\t//if(m[s]>-1)return m[s];\n\tbool top[24];\n\tfill(top,top+24,1);\n\tint res=0;\n\trep(i,n)rep(j,i)if(s&1<<i&&s&1<<j&&insec(i,j))top[i]=0;\n\trep(i,n)rep(j,i)if(s&1<<i&&s&1<<j&&top[i]&&top[j]&&c[i]==c[j])res=max(res,2+dfs(s-(1<<i)-(1<<j)));\n\treturn res;//m[s]=res;\n}\n\nint main(){\n\twhile(cin>>n&&n){\n\t\trep(i,n)cin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\t//fill(m,m+(1<<n),-1);\n\t\tcout<<dfs((1<<n)-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <memory.h>\n#include <functional>\n#include <algorithm>\nusing namespace std;\n\nFILE * in = freopen(\"input.txt\", \"r\" , stdin);\n\nconst double EPS = 1e-10;\n\ndouble add(double a, double b){\n\tif(abs(a+b) < EPS * (abs(a) + abs(b))) return 0;\n\treturn a+b;\n}\n\nstruct P {\n\tdouble x, y;\n\tP(){}\n\tP(double x, double y):x(x), y(y){}\n\tP operator - (P p) {\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tdouble dot(P p) {\n\t\treturn add(x * p.x, y * p.y);\n\t}\n\tP operator = (P p) {\n\t\treturn P(p.x, p.y);\n\t}\n};\n\ndouble dist(P p, P q){\n\treturn (p-q).dot(p-q);\n}\n\nstruct disk{P center; int length; int number;};\n\nint n;\ndisk data[50];\nint G[50][50];\nint tag[50];\n\nbool isCovered(int x, int y) {\n\treturn dist(data[x].center, data[y].center) < (data[x].length + data[y].length)*(data[x].length + data[y].length);\n}\n\nint Max = 0;\n\nvoid input(){\n\tint i , j;\n\tint x, y;\n\tMax = 0;\n\tmemset(G, 0, sizeof(G));\n\tfor(i = 0 ; i < n; i++){\n\t\tscanf(\"%d%d%d%d\", &x, &y, &data[i].length, &data[i].number);\n\t\tdata[i].center.x = x;\n\t\tdata[i].center.y = y;\n\t\tfor(j = 0; j < i; j++){\n\t\t\tif(isCovered(j, i)) {\n\t\t\t\tG[j][i] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid getTops(vector<int> tops[4]) {\n\tint i , j;\n\tfor ( i = 0; i < n; i++) {\n\t\tif(tag[i])continue;\n\t\tfor(j = 0; j < n; j++) {\n\t\t\tif(tag[j]) continue;\n\t\t\tif(G[j][i]) break;\n\t\t}\n\t\tif(j == n)\n\t\t\ttops[data[i].number-1].push_back(i);\n\t}\n}\n\nvoid back(int lev) {\n\tvector<int> tops[4];\n\tbool flag = false;\n\tgetTops(tops);\n\tfor(int i = 0; i < 4; i++){\n\t\tint sz = tops[i].size();\n\t\tif(sz == 2) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\ttag[tops[i][0]] = true;\n\t\t\t\ttag[tops[i][1]] = true;\n\t\t\t}\n\t\t\tback(lev+1);\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\ttag[tops[i][0]] = false;\n\t\t\t\ttag[tops[i][1]] = false;\n\t\t\t}\n\t\t}\n\t\telse if (sz > 2) {\n\t\t\tfor(int j = 0; j < sz; j++) {\n\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\ttag[tops[i][j]] = true;\n\t\t\t\t}\n\n\t\t\t\tfor (int k = j + 1; k < sz; k++) {\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\ttag[tops[i][k]] = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tback(lev+1);\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\ttag[tops[i][k]] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\ttag[tops[i][j]] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif ( Max < lev * 2)\n\t\tMax = lev * 2;\n}\n\nvoid process() {\n\tback(0);\n\tprintf(\"%d\\n\", Max);\n}\n\nint main() {\n\twhile(true){\n\t\tscanf(\"%d\", &n);\n\t\tif ( n == 0) break;\n\t\tinput();\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cstdio>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define fr first\n#define sc second\n#define mp make_pair\n\ntypedef long long int64;\ntypedef pair< int, int > iP;\ntypedef pair< iP, int > iiP;\n\nconst int INF = 2 << 28;\nconst double EPS = 1e-10;\n\nstruct disk {\n    int x, y, r, color;\n};\n\nint n;\nvector< disk > disks;\n\nint rec(int used) {\n\n    vector< int > idx;\n    for(int i = n - 1; i >= 0; i--) {\n        if(!(used >> i & 1)) {\n            bool judge = true;\n            for(int j = i - 1; j >= 0; j--) {\n                if(!(used >> j & 1)) {\n                    if(pow(abs(disks[i].x - disks[j].x), 2) + pow(abs(disks[i].y - disks[j].y), 2) < pow(disks[i].r + disks[j].r, 2))\n                        judge = false;\n                }\n            }\n            if(judge) idx.push_back(i);\n        }\n    }\n\n    int ret = 0;\n    if(idx.size() < 2) return 0;\n    else {\n        for(int i = 0; i < idx.size(); i++) {\n            for(int j = i + 1; j < idx.size(); j++) {\n                if(disks[idx[i]].color == disks[idx[j]].color) {\n                    int mask = (1 << idx[i] | 1 << idx[j]);\n                    ret = max(ret, rec(used | mask) + 2);\n                }\n            }\n        }\n        return ret;\n    }\n}\n\nint main() {\n\n    while(cin >> n, n) {\n        for(int i = 0; i < n; i++) {\n            int x, y, c, r; cin >> x >> y >> r >> c;\n            disks.push_back((disk){x, y, r, c});\n        }\n\n        cout << rec(0) << endl;\n        disks.clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, x[25], y[25], r[25], c[25], v[25]; short dp[16777777];\nint main() {\n\twhile (scanf(\"%d\", &n), n) {\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d%d%d%d\", &x[i], &y[i], &r[i], &c[i]);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tv[i] = 0;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tint dist1 = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n\t\t\t\tint dist2 = (r[i] + r[j]) * (r[i] + r[j]);\n\t\t\t\tif (dist1 < dist2) v[i] += (1 << j);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < 1 << n; i++) {\n\t\t\tdp[i] = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (!(i & (1 << j))) continue;\n\t\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\t\tif (!(i & (1 << k))) continue;\n\t\t\t\t\tif (c[j] != c[k]) continue;\n\t\t\t\t\tint p = i - (1 << j) - (1 << k);\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\tp = (1 << n) - 1 - p;\n\t\t\t\t\tif (p & v[j]) flag = false;\n\t\t\t\t\tif (p & v[k]) flag = false;\n\t\t\t\t\tif (flag) {\n\t\t\t\t\t\tdp[i] = max((int)dp[i], dp[i - (1 << j) - (1 << k)] + 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dp[i] == 0) dp[i] = -11111;\n\t\t}\n\t\tprintf(\"%d\\n\", (int)(*max_element(dp, dp + (1 << n))));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint N;\nint r[24], x[24], y[24], c[24];\nvector<int> ue;\n\nshort dp[1 << 24];\nint xx(int x) { return x * x; }\nshort _dp(int k) {\n\tif (k == 0) return 0;\n\tif (dp[k] >= 0) return dp[k];\n\n\tvector<int> w;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif ( (k & (1 << i)) && (k & ue[i]) == 0 ) w.push_back(i);\n\t}\n\tshort ret = 0;\n\tfor (int i = 0; i < w.size(); ++i) {\n\t\tfor (int j = i+1; j < w.size(); ++j) {\n\t\t\tif (c[w[i]] == c[w[j]]) {\n\t\t\t\tret = max<short>(ret, _dp(k ^ (1 << w[i]) ^ (1 << w[j]))+2);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[k] = ret;\n}\nint main() {\n\twhile (cin >> N, N) {\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\n\t\tbool f[24][24] = {0};\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\tif (xx(x[i]-x[j]) + xx(y[i]-y[j]) < xx(r[i]+r[j])) {\n\t\t\t\t\tf[j][i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tue.clear();\n\t\tue.resize(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint b = 0;\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (f[i][j]) b |= (1 << j);\n\t\t\t}\n\t\t\tue[i] = b;\n\t\t}\n\n\t\tfill(&dp[0], &dp[0]+(1<<24), -1);\n\t\tcout << (int)_dp((1 << N) - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double R;//double long double ??????????????? cmath?????¢??°??????????????????????????????????????????????????§????????????\ntypedef complex<R> Point;\ntypedef pair<Point , Point> Line;\ntypedef pair<Point ,R > Circle;\ntypedef vector<Point> Poly;\n\n#define EPS (1e-10)//??????\n#define EQ(a,b) (abs((a)-(b)) < EPS)//??????????????°???????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )//????????????????????????????????????\n#define mp make_pair\n#define ft first\n#define sd second\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nR dot(Point a,Point b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nR cross(Point a,Point b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\nbool is_orthogonal(Line a,Line b){//2??´????????´?????????\n    return EQ(dot(a.ft - a.sd,b.ft - b.sd),0.0);\n}\nbool is_parallel(Line a,Line b){//2??´??????????????????\n    return EQ(cross(a.ft - a.sd,b.ft - b.sd),0.0);\n}\n\n////////////////////????????????\n\nint ccw(Point a,Point b,Point c){//ok\n    b -= a; c -= a;\n    if(cross(b,c) > EPS) return 1;//a???b??§???????¨???¨???????????????b???c\n    if(cross(b,c) < -EPS) return -1;//a???b??§????¨???¨???????????????b???c\n    if(dot(b,c) < -EPS) return 2;//c--a--b on same line\n    if(norm(c) - norm(b) > EPS) return -2;//a--b--c(abs??????????????????????????????????????????????????????????)\n    return 0;//a--c--b?????????b==c\n}\n\nbool is_intersection_ll(Line l,Line m){//???????????´??????????????????\n    return abs(cross(l.sd - l.ft,m.sd - m.ft)) > EPS || //????????§??????\n        abs(cross(l.sd - l.ft,m.ft - l.ft)) < EPS; //?????????????????????\n}\n\nbool is_intersection_ls(Line l,Line s){//??´???l??¨??????s???????????????\n    return cross(l.sd - l.ft, s.ft-l.ft)*       // s[0] is left of l\n        cross(l.sd - l.ft, s.sd - l.ft) < EPS; // s[1] is right of l\n}\n\nbool is_intersection_lp(Line l,Point p){//??´???l??¨???p???????????????\n    return abs(cross(l.sd - p,l.ft - p));\n}\n\nbool is_intersection_ss(Line a,Line b){//??????????????????????????????ok\n    return ccw(a.ft,a.sd,b.ft)*ccw(a.ft,a.sd,b.sd) <= 0 && ccw(b.ft,b.sd,a.ft)*ccw(b.ft,b.sd,a.sd) <= 0;\n}\n\nbool is_intersection_sp(Line s,Point p){//????????¨?????????????????? ????§??????????????????¨\n    return abs(s.ft - p) + abs(s.sd - p) - abs(s.ft - s.sd) < EPS;\n}\n\n/////////////?????¢\n\nR dis_lp(Line l,Point p){//??´???l??¨???p????????¢\n    return abs(cross(l.sd - l.ft,p - l.ft)) / abs(l.sd - l.ft);\n}\n\nR dis_ll(Line l,Line m){//???????????´???????????¢\n    return is_intersection_ll(l,m) ? 0.0 : dis_lp(l,m.ft);\n}\n\nR dis_ls(Line l,Line s){//??´???l??¨??????s????????¢\n    if(is_intersection_ls(l,s)) return 0.0;\n    return min(dis_lp(l,s.ft),dis_lp(l,s.sd));\n}\n\nR dis_sp(Line s,Point p){//??????s??¨???p????????¢\n    if(dot(s.sd - s.ft,p - s.ft) < EPS) return abs(p - s.ft);\n    if(dot(s.ft - s.sd,p - s.sd) < EPS) return abs(p - s.sd);\n    return dis_lp(s,p);\n}\n\nR dis_ss(Line s,Line t){//???????????????????????¢\n    if(is_intersection_ss(s,t)) return 0.0;\n    return min(min(dis_sp(s,t.ft),dis_sp(s,t.sd)),\n            min(dis_sp(t,s.ft),dis_sp(t,s.sd)));\n}\n\n//////////////?°???±??¨????°?\n\nPoint projection(Line l,Point p){//?°???±????±???????\n    R t = dot(p - l.ft,l.ft - l.sd) / norm(l.ft - l.sd);\n    return l.ft + t * (l.ft - l.sd);\n}\n\nPoint reflection(Line l,Point p){//????°?????±???????\n    return p + 2.0 * (projection(l,p) - p);\n}\n\n//////////////??????(????????????????¨???????????????¨??????????????????????????????????????£??????)\n\nPoint intersection_ll(Line l,Line m){//????????????????????????????????????????????????\n    R A = cross(l.sd - l.ft,m.sd - m.ft);\n    R B = cross(l.sd - l.ft,l.sd - m.ft);\n    if(abs(A) < EPS && abs(B) < EPS) return m.ft;//?????????\n    //if(abs(A) < EPS)assert(false);//????????§????????????\n    return m.ft + B / A * (m.sd - m.ft);\n}\n\nLine intersection_of_two_circles(Circle c1,Circle c2){//ok ????????????????????????Line?????\\????????????(r1 + r2 > sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2))???????????????????????????\n    R a =  abs(c2.ft - c1.ft);\n    R b = c1.sd;\n    R c = c2.sd;\n\n    R rc = (a  * a + b * b - c * c) / (2.0 * a);\n    R rs = sqrt(b * b - rc * rc);//C++ ??§???????????????????????????????????§???????????????sqrt ????????? float ?????????????????? long double ????????????????????????????????????????????¨?????§???????????? C ????????°????????§??????sqrt ????????? double ??????????????£??????????????????\n    Point diff = (c2.ft - c1.ft) / a;\n\n    Line p ;\n    p.ft = c1.ft + diff * rc + diff * Point(0,1) * rs;\n    p.sd = c1.ft + diff * rc + diff * Point(0,-1) * rs;\n\n    return p;\n}\n\n\nLine conver_line(Line a,Point maxi,Point mini){//??????????????´??????????????? maxi???????????????????????? mini?????????\n\n    if(abs(dot(a.sd - a.ft,Point(1.0,0.0))) < EPS){//??????x???????????´??????\n        ;\n    }\n}\n\n/////////////////////////polygon\n\n#define currP(P,i) P[i]//????????????\n#define nextP(P,i) P[(i + 1)%P.size()]//?¬??????????\n\nint is_contains_p_in_Poly(Poly po,Point p){//??????????§???¢????????¨(1)????¢????(-1)????????¨(0)??????????????????????????????\n    bool in = false;\n    REP(i,po.size()){\n        Point a = currP(po,i) - p,b = nextP(po,i) - p;\n        if(a.imag() > b.imag())swap(a,b);\n        if(a.imag() < EPS && -EPS < b.imag())\n            if(cross(a,b) < -EPS) in = !in;\n        if(abs(cross(a,b)) == 0.0 && dot(a,b) < EPS)return  -1;\n    }\n    return in;\n}\n\nR area2(Poly po){//????§???¢?????¢????????????????±???????\n    R A = 0.0;\n    REP(i,po.size())\n        A += cross(currP(po,i),nextP(po, i));\n    return A;\n}\n\n///////////////////////////???\n\nPoly convex_hull(Poly ps){\n    int n = ps.size(),k = 0;\n    Poly ch(2*n);\n    for(int i = 0;i < n;ch[k++] = ps[i++])// lower-hull\n        while(k >= 2 && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0) --k;\n    for(int i = n - 2,t = k + 1;i >= 0;ch[k++] = ps[i--])//upper-hull\n        while(k >= t && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\n#define prevP(P, i) P[(i+P.size()-1) % P.size()]\nbool isconvex(Poly P){\n    for(int i = 0;i < P.size();++i)\n        if(ccw(prevP(P,i),currP(P,i),nextP(P,i)) > 0) return false;\n    return true;\n}\n\nbool kosa(Circle c1, Circle c2) {\n  return abs(c1.ft-c2.ft)<(c1.sd+c2.sd);\n}\n\n#define MAX_N 25\n\nint n;\nCircle cs[MAX_N];\nint cc[MAX_N];\n\nbool input() {\n  cin>>n;\n  int x, y, r;\n  REP(i, n) {\n    cin>>x>>y>>r>>cc[i];\n    cs[i] = mp(Point(x, y), r);\n  }\n  return n!=0;\n}\n\nchar dp[1<<MAX_N];\n\nbool totta[MAX_N],toreru[MAX_N];\n\nint saiki(int S) {\n  if(dp[S] > -1)\n    return dp[S];\n  REP(i,n){totta[i] = S&(1<<i);toreru[i] = true;}\n  REP(i,n){\n    if(totta[i]){\n      toreru[i] = false;\n      continue;\n    }\n    REP(j,i){\n      if(!totta[j] && kosa(cs[i],cs[j])){\n        toreru[i] = false;\n        break;\n      }\n    }\n  }\n  bool f=false;\n  REP(i, n)f=f||toreru[i];\n  if(!f)return 0;\n  int maxi = 0;\n  REP(i,n){\n    if(toreru[i]){\n      FOR(j,i+1,n){\n        if(toreru[j] && cc[i] == cc[j])\n          maxi = max( maxi, saiki(S|(1<<i)|(1<<j))+2 );\n      }\n    }\n  }\n  return maxi;\n}\n\nvoid solve() {\n  REP(i,1<<n)\n    dp[i] = -1;\n  cout<<saiki(0)<<endl;\n}\n\nint main() {\n  \n  while(input()) {\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = a.r * a.r + 2 * a.r * b.r + b.r * b.r;\n    return r > (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\nint main()\n{\n    int n;\n\n    while (cin >> n, n) {\n        const int N = 1 << n;\n        vector<char> dp(N, -1), up(n, 0);\n        vector<Circle> c(n);\n\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j) {\n                if (isOverlap(c[i], c[j])) {\n                    if (i < j) // jの上にiがある\n                        up[j] |= 1 << i;\n                    else // iの上にjがある\n                        up[i] |= 1 << j;\n                }\n            }\n\n        char res = 0;\n        dp[N - 1] = 0;\n        for (int s = N - 1; s >= 0; --s) {\n            if (dp[s] == -1)\n                continue;\n\n            res = max(res, dp[s]);\n            for (int i = 0; i < n; ++i) {\n                if (!(s >> i & 1) || s & up[i]) // c[i]が置かれていないかc[i]が取り除けない\n                    continue;\n\n                for (int j = i + 1; j < n; ++j) {\n                    if (c[i].c != c[j].c) // 色が異なる\n                        continue;\n                    if (!(s >> j & 1) || s & up[j])  // c[j]が置かれていないかc[j]が取り除けない\n                        continue;\n\n                    int nxt = s & ~(1 << i) & ~(1 << j);\n                    dp[nxt] = max((int)dp[nxt], dp[s] + 2);\n                }\n            }\n        }\n\n        cout << (int)res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint n;\nint x[24];\nint y[24];\nint c[24];\nint r[24];\nint memo[1<<24];\nint hit(int i,int j){\n\tint L = r[i]*r[i] + r[j]*r[j] + 2 * r[i] * r[j];\n\tint X = (x[i]-x[j])*(x[i]-x[j]);\n\tint Y = (y[i]-y[j])*(y[i]-y[j]);\n\treturn X + Y < L;\n}\nint nocover(int n,int bit){\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( (bit>>i&1) && hit(i,n) ) return false;\n\t}\n\treturn true;\n}\nint dfs(int bit){\n\tif(~memo[bit]) return memo[bit];\n\tint ans = 0;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tfor(int j = i+1 ; j < n ; j++){\n\t\t\tif( (bit >> j & 1) && (bit >> i & 1) && c[i] == c[j] && nocover(i,bit) && nocover(j,bit) ){\n\t\t\t\tans = max(ans , dfs( bit - (1<<j) - (1<<i) ) + 2);\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[bit] = ans;\n}\nint main(){\n\twhile(cin >> n , n){\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> x[i] >> y[i] >> c[i] >> r[i];\n\t\t}\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tcout << dfs((1<<n)-1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n\n\nstruct cir{\n    int x,y,r,c;\n};\n\nbool same(cir a,cir b){\n    double r2 = (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n    if((a.r+b.r)*(a.r+b.r)>r2)return true;\n    else return false;\n}\n\nbool used(int n,vi vec){\n    rep(i,vec.size()){\n        int to = vec[i];\n        if( (n&(1<<to)) != 0 )return false;\n    }\n    return true;\n}\n\nint main(){\n    int n;\n    while(cin>>n){\n        if(n==0)break;\n        vector<cir> data;\n        \n        rep(i,n){\n            int x,y,r,c;\n            cin>>x>>y>>r>>c;\n            data.pb(cir{x,y,r,c});\n        }\n        \n        \n        vector<int> G[30];\n        \n        for(int i=data.size()-1;i>=0;i--){\n            for(int j=i-1;j>=0;j--){\n                if(same(data[i],data[j])){\n                    G[i].pb(j);\n                }\n            }\n        }\n        \n        bool dp[1<<n];\n        rep(i,1<<n)dp[i]=false;\n        dp[(1<<n)-1]=true;\n        \n        \n        for(int i=(1<<n)-1;i>=0;i--){\n            if(dp[i]==false)continue;\n            rep(j,n){\n                rep(k,n){\n                    if( (i&(1<<j) )==0 || (i&(1<<k) )==0)continue;\n                    if( data[j].c==data[k].c && used(i,G[j]) && used(i,G[k]) ) dp[(i^(1<<j))^(1<<k)] = true;\n                }\n            }\n        }\n        \n        int ans=100;\n        for(int i=(1<<n)-1;i>=0;i--){\n            if(dp[i]==false)continue;\n            ans = min(ans,__builtin_popcount(i));\n        }\n        cout<<n-ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nshort dp[1 << 24];\nvector<int> v[25];\nint xx(int x) { return x * x; }\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tint r[24], x[24], y[24], c[24];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\n\t\tbool f[24][24] = {0}; // f[a][b]: a??????b????????????????????????\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\tif (xx(x[i]-x[j]) + xx(y[i]-y[j]) < xx(r[i]+r[j])) {\n\t\t\t\t\tf[j][i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 25; ++i) v[i].clear();\n\t\tfor (int i = 0; i < (1 << N); ++i) {\n\t\t\tv[__builtin_popcount(i)].push_back(i);\n\t\t}\n\n\t\tvector<int> ue(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint b = 0;\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (f[i][j]) b |= (1 << j);\n\t\t\t}\n\t\t\tue[i] = b;\n\t\t}\n\n\t\tfill(&dp[0], &dp[0]+(1<<24), 0);\n\t\tfor (int t = 0; t <= N; ++t) {\n\t\t\tfor (int l = 0; l < v[t].size(); ++l) {\n\t\t\t\tint k = v[t][l];\n\t\t\t\tvector<int> w;\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tif ( (k & (1 << i)) && (k & ue[i]) == 0 ) w.push_back(i);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < w.size(); ++i) {\n\t\t\t\t\tfor (int j = i+1; j < w.size(); ++j) {\n\t\t\t\t\t\tif (c[w[i]] == c[w[j]]) {\n\t\t\t\t\t\t\tdp[k] = max<short>(dp[k], dp[k ^ (1 << w[i]) ^ (1 << w[j])]+2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1 << N)-1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\n// const int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\nint dp[POW(24)];\nint n;\nint x[25],y[25],r[25],c[25];\n\nbool intersect(int i, int j) {\n  return hypot(x[i]-x[j],y[i]-y[j]) - r[i] - r[j] < -EPS;\n}\n\nbool is_over(int ms, int i) {\n  REP(k,i) if ((ms >> k & 1) && intersect(k,i)) return true;\n  return false;\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  while (cin >> n,n) {\n    REP(i,n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n    MINUS(dp);\n    dp[POW(n)-1] = 0;\n    for (int ms = POW(n) - 1; ms >= 0; ms--) if (dp[ms] >= 0) {\n      REP(i,n) if (ms >> i & 1) {\n        FOR(j,i+1,n) if ((ms >> j & 1) && (c[i] == c[j])) {\n          if (is_over(ms,i) || is_over(ms,j)) continue;\n          CHMAX(dp[ms - (1 << i) - (1 << j)],dp[ms]+2);\n        }\n      }\n    }\n    int ans = 0;\n    REP(ms,POW(n)) CHMAX(ans,dp[ms]);\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n\n\n\n\n\n// #define int long long\n\n\n\n\n\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nmain {\n  while (true) {\n    int n = in();\n    if (n == 0) break;\n    vector<int> x(n), y(n), r(n), c(n);\n    rep(i, n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n    auto intersectCC = [&](int i, int j) {\n      int r2 = (r[i] + r[j]) * (r[i] + r[j]);\n      int d = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n      return d < r2;\n    };\n    auto intersect = [&](int t, int used) {\n      bool f = false;\n      rep(i, t) f |= (~used >> i & 1) && intersectCC(t, i);\n      return f;\n    };\n    vector<int> dp(1 << n, -1);\n    function<int(int)> dfs = [&](int used) {\n      if (dp[used] != -1) return dp[used];\n      cmax(dp[used], 0);\n      rep(i, n) loop(j, i + 1, n) {\n        if ((used >> i & 1) || (used >> j & 1) || c[i] != c[j]) continue;\n        if (intersect(i, used) || intersect(j, used)) continue;\n        cmax(dp[used], dfs(used | (1 << i) | (1 << j)) + 2);\n      }\n      return dp[used];\n    };\n    cout << dfs(0) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\nchar bit_count[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n-bit_count[bit];\n\n    for(int i=0;i<n;i++){\n        if(((bit>>i)&1)==0||ok(i,bit)==false)continue;\n        for(int j=i+1;j<n;j++){\n            if(((bit>>j)&1)==0||ok(j,bit)==false||c[i]!=c[j])continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(memo[to_bit]==false)ret=max(ret,dfs(to_bit));\n\n        }\n    }\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\nvoid init(){\n    for(int i=0;i<(1<<24);i++){\n        for(int j=0;j<24;j++)if((i>>j)&1){\n            bit_count[i]++;\n        }\n    }\n}\n\nint main(){\n    init();\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<vector>\n#include<algorithm>\n#define F first\n#define S second\n#define pb push_back\n#define EPS 1e-10\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint n,ans;\nbool used[1000];\nvector<PP> p;\nvector<int> rank;\n\nvoid ranking(){\n  for(int i=0;i<p.size();i++)rank.pb(1);\n\n  for(int i=0;i<p.size();i++){\n    for(int j=i+1;j<p.size();j++){\n      double r1 = p[i].S.F,r2 = p[i].S.F,d = sqrt(pow(p[i].F.F-p[j].F.F,2)+pow(p[i].F.S-p[j].F.S,2));\n      if(fabs(r1-r2) < d  && d < (r1+r2) ){ //cross each other on two different points\n\trank[j]++;\n      }\n      else if(fabs(d-(r1+r2)) < EPS){ //be circumscribed\n      }\n      else if(fabs(d-fabs(r1-r2)) < EPS){ // be inscribed\n\trank[j]++;\n      }\n      else{\n      }\n    }\n  }\n}\n\n\nvoid rankIncrease(int x,int y){\n \n  for(int i=0;i<rank.size();i++){\n    if(y == i)continue;\n    if(i == x){\n      rank[i]++;\n      continue;\n    }\n double r1 = p[x].S.F,r2 = p[i].S.F,d = sqrt(pow(p[x].F.F-p[i].F.F,2)+pow(p[x].F.S-p[i].F.S,2));\n if(fabs(r1-r2) < d  && d < (r1+r2) ){ //cross each other on two different points\n\trank[i]++;\n      }\n      else if(fabs(d-(r1+r2)) < EPS ){ //be circumscribed\n      }\n      else if(fabs(d-fabs(r1-r2)) < EPS){ // be inscribed\n\trank[i]++;\n      }\n      else{\n      }\n  }\n}\n\n  void rankDecrease(int x,int y){\n  for(int i=0;i<rank.size();i++){\n    if(i == y)continue;\n    if(i == x){\n      rank[i]--;\n      continue;\n    }\n    double r1 = p[x].S.F,r2 = p[i].S.F,d = sqrt(pow(p[x].F.F-p[i].F.F,2)+pow(p[x].F.S-p[i].F.S,2));\n if( fabs(r1-r2) < d  && d < (r1+r2)){ //cross each other on two different pointsq\n\t  rank[i]--;\n      }\n      else if( fabs(d-(r1+r2)) < EPS){ //be circumscribed\n      }\n      else if( fabs(d-fabs(r1-r2)) < EPS){ // be inscribed\n\trank[i]--;\n      }\n      else{\n      }\n  }\n}\n\n\n\n\n\nvoid rec2(int cnt){\n \n   for(int i=0;i<rank.size();i++){\n    //cout << ans << endl;\n    if(rank[i] == 1 ){\n      for(int j=0;j<rank.size();j++){\n\tif(i == j || rank[j] <= 0)continue;\n\tif(p[i].S.S == p[j].S.S && rank[j] == 1 && !used[j]){//usedつかったrtsdkrkm\t\n\t  rankDecrease(i,j); rankDecrease(j,i);\n\t  used[i] = true;\n\t  rec2(cnt+2);\n\t  used[i] = false;\n\t  rankIncrease(i,j); rankIncrease(j,i);\n\t}\n      }\n    }\n  }\n \n  ans = max(ans,cnt);\n}\n\nint main(){\n  \n  while(cin >> n && n){ \n    ans = 0;\n    for(int i=0;i<n;i++)used[i] = false;\n    p.clear(); rank.clear();\n    for(int i=0;i<n;i++){\n      int x,y,r,c;\n      cin >> x >> y >> r >> c;\n      p.pb(PP(P(x,y),P(r,c)));\n    }\n    ranking();\n   \n     rec2(0);   \n \n     cout << ans << endl;\n  }\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n\nvoid rec(int cnt){\n\n  int j=0,flag = 0;\n  bool fl = true;\n  while(fl){ \n\n    if(rank[j] == 0){\n    \n    j++;\n      if(j%n == 0 && j!=0){\n\tj=0;\n\tif(finish()){\n\t  ans = max(ans,cnt);\n\t  fl = false;\n\t  return;\n\t}\n\tflag = 0;\n      }\n      continue;\n    }\n\n    if(rank[j] == 1){\n      for(int i=0;i<rank.size();i++){      \n\tif(i == j || rank[i] <= 0)continue;\n\tif(rank[i] == 1 && p[j].S.S == p[i].S.S){\n\t  flag++;\n\t  rankDecrease(i);\n\t  rankDecrease(j);\n\t  rec(cnt+2);\n\t  rankIncrease(i);\n\t  rankIncrease(j);\n\t  flag--;\n\t}\n      }\n    }\n\n    j++;\n\n    if(j%n == 0 && j!=0){\n      j=0;\n      if(finish()){\n\tans = max(ans,cnt);\n\tfl = false;\n\treturn;\n      }\n      flag= 0;\n    }\n  }\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <complex>\n\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\ntypedef complex<double> Point;\n\n\nstruct Circle {\n    Point c;\n    double r;\n    int color;\n    Circle(Point c=Point(), double r=0.0,int color=0) :\n        c(c),r(r),color(color){}\n};\ndouble getDistance(Point a,Point b) {\n    return abs(a-b);\n}\n\nbool intersect(Circle c1, Circle c2) {\n    double d=getDistance(c1.c,c2.c);\n    return d<c1.r+c2.r;\n}\nint n;\nbool same_color[30][30];\nbool is_intersect[30][30];\nbool ok(int n,int S) {\n    rep(i,n) {\n        if(!(S>>i&1)&&is_intersect[i][n]) return false;\n    }\n\n    return true;\n}\nint dp[1<<24];\nint dfs(int S) {\n    if(dp[S]!=-1) return dp[S];\n    int ret=0;\n    rep(i,n) rep(j,n) if(i!=j) {\n        if(((S>>i)&1)) continue;\n        if(((S>>j)&1)) continue;\n        if(!same_color[i][j]) continue;\n        if(!ok(i,S)) continue;\n        if(!ok(j,S)) continue;\n\n        //printf(\"remove %d %d\\n\",i,j);\n        ret=max(ret,dfs(S|(1<<i)|(1<<j))+2);\n    }\n\n    return dp[S]=ret;\n}\nvoid solve() {\n    memset(dp,-1,sizeof(dp));\n    rep(i,30) rep(j,30) is_intersect[i][j]=false;\n    rep(i,30) rep(j,30) same_color[i][j]=false;\n    vector<Circle> circles;\n    rep(i,n) {\n        double x,y,r;\n        int c;\n        cin>>x>>y>>r>>c;\n        circles.push_back(Circle(Point{x,y},r,c));\n    }\n    rep(i,circles.size()) rep(j,circles.size()) {\n        if(intersect(circles[i],circles[j])) is_intersect[i][j]=true;\n        if(circles[i].color==circles[j].color) same_color[i][j]=true;\n    }\n    cout<<dfs(0)<<endl;\n}\nint main() {\n    while(cin>>n) {\n        if(!n) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\nint n;\nchar dp[1 << 24];\n//char up[24];\n//vector<char> dp, up;\n//vector<Circle> c;\nCircle c[24];\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = (a.r + b.r) * (a.r + b.r);\n    int d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    return r > d;\n}\n\nbool isUp(char s, int v)\n{\n    for (int i = 0; i < v; ++i)\n        if ((s >> i & 1) && isOverlap(c[v], c[i]))\n            return true;\n    return false;\n}\n\nint Rec(int s)\n{\n    if (~dp[s])\n        return dp[s];\n\n    int res = 0;\n    // 取り除く2つの円の選択\n    for (int i = 0; i < n; ++i) {\n        // c[i]がないか取り除けない\n        // if (!(s >> i & 1) || isUp(s, i))\n        //     continue;\n        // if (!(s >> i & 1) || s & up[i])\n        //     continue;\n\n        for (int j = i + 1; j < n; ++j) {\n            // c[i]とc[j]の色が異なる\n            // if (c[i].c != c[j].c)\n            //     continue;\n            // c[j]がないか取り除けない\n            // if (!(s >> j & 1) || s & up[j])\n            //     continue;\n            // if (!(s >> j & 1) || isUp(s, j))\n            //     continue;\n            if ((s >> i & 1) && !isUp(s, i) && c[i].c == c[j].c\n                && (s >> j & 1) && !isUp(s, j))\n//            int nxt = s & ~(1 << i) & ~(1 << j);\n            res = max(res, Rec(s & ~(1 << i) & ~(1 << j)) + 2);\n        }\n    }\n\n    return dp[s] = res;\n}\n\nint main()\n{\n    while (cin >> n, n) {\n        memset(dp, -1, sizeof(dp));\n//        memset(up, 0, sizeof(up));\n//        c.resize(n);\n\n        // 円の入力\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        // // 円の重なり，上下関係\n        // for (int i = 0; i < n; ++i)\n        //     for (int j = i + 1; j < n; ++j)\n        //         if (isOverlap(c[i], c[j]))\n        //             up[j] |= (1 << i);\n\n        cout << (int)Rec((1 << n) - 1) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<complex>\n#include<set>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int M = 24;\nconst int INF = 1000000000;\nconst int C = 5;\n\ntypedef pair<int,int> pii;\n\nint n;\nint x[M];\nint y[M];\nint r[M];\nint c[M];\n\nvector<pii> colpair;\nvector<int> on[M];\n\nbool ok(int state, pii& p){\n\tbool ret = (state&(1<<p.first))==0 && (state&(1<<p.second))==0;\n\trep(i,on[p.first].size()){\n\t\tif((state&(1<<on[p.first][i]))==0)ret = false;\n\t}\n\trep(i,on[p.second].size()){\n\t\tif((state&(1<<on[p.second][i]))==0)ret = false;\n\t}\n\treturn ret;\n}\n\n//int memo[1<<M];\nint saiki(int state){\n\t//if(memo[state]!=-1)return memo[state];\n\t\n\tint ans = 0;\n\trep(i,colpair.size()){\n\t\tif(ok(state, colpair[i])){\n\t\t\tint v = saiki(state | (1<<colpair[i].first) | (1<<colpair[i].second));\n\t\t\tans = max(ans, v+2);\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nvoid init(){\n\t//rep(i,(1<<n))memo[i]=-1;\n\trep(i,n)on[i].clear();\n\tcolpair.clear();\n\t\n\trep(i,n)reps(j,i+1,n){\n\t\tif(c[i]==c[j])colpair.push_back(pii(i,j));\n\t}\n\t\n\trep(i,n){\n\t\trep(j,i){\n\t\t\tint dx = x[i]-x[j];\n\t\t\tint dy = y[i]-y[j];\n\t\t\tint r2 = r[i]+r[j];\n\t\t\t\n\t\t\tif(dx*dx + dy*dy < r2*r2){\n\t\t\t\ton[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\trep(i,colpair.size()){\n\t\tprintf(\"%d %d\\n\",colpair[i].first, colpair[i].second);\n\t}\n\trep(i,n){\n\t\tprintf(\"on \");\n\t\trep(j,on[i].size())printf(\"%d \",on[i][j]);puts(\"\");\n\t}*/\n}\nint solve(){\n\trep(i,n)cin>>x[i]>>y[i]>>r[i]>>c[i];\n\tinit();\n\t\n\treturn saiki(0);\n}\n\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tprintf(\"%d\\n\",solve());\n\t\t//break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\nint n;\nchar dp[1 << 24], up[24];\n//vector<char> dp, up;\nvector<Circle> c;\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = (a.r + b.r) * (a.r + b.r);\n    int d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    return r > d;\n}\n\nchar Rec(char s)\n{\n    if (~dp[s])\n        return dp[s];\n\n    int res = 0;\n    // 取り除く2つの円の選択\n    for (int i = 0; i < n; ++i) {\n        // c[i]がないか取り除けない\n        if (!(s >> i & 1) || s & up[i])\n            continue;\n\n        for (int j = i + 1; j < n; ++j) {\n            // c[i]とc[j]の色が異なる\n            if (c[i].c != c[j].c)\n                continue;\n            // c[j]がないか取り除けない\n            if (!(s >> j & 1) || s & up[j])\n                continue;\n\n            int nxt = s & ~(1 << i) & ~(1 << j);\n            res = max(res, (int)Rec(nxt) + 2);\n        }\n    }\n\n    return dp[s] = res;\n}\n\nint main()\n{\n    while (cin >> n, n) {\n        // dp.assign(1 << n, -1);\n        // up.assign(n, 0);\n        memset(dp, -1, sizeof(dp));\n        memset(up, 0, sizeof(up));\n        c.resize(n);\n\n        // 円の入力\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        // 円の重なり，上下関係\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                if (isOverlap(c[i], c[j]))\n                    up[j] |= (1 << i);\n\n        cout << (int)Rec((1 << n) - 1) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>/*{{{*/\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i, b, e) for (typeof(b) i = (b); assert((i) <= (e)), i != (e); ++i)\n#define SZ(a) ((int)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(),(v).rend())\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((n) >> (m) & 1)\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\nstatic const double PI (3.14159265358979323846);\nstatic const double EPS (1e-10);\n\nusing namespace std;\ntypedef long long int ll;\ntypedef complex<double> P;/*}}}*/\n\nint n;\n\nstruct plate {\n\tint x, y, r;\n\n\tint id;\n\tint color;\n\tbool top;\n\tvector<plate*> downers;\n\tint upper_set; // bitset\n\t/*\n\tinline bool operator < (const plate &p) const {\n\t\tif (top == p.top) {\n\t\t\treturn color < p.color;\n\t\t} else {\n\t\t\treturn top;\n\t\t}\n\t}\n\t*/\n};\nvector<plate> plates;\n\nvoid show_bit(ll set, int width)\n{\n\tfor (int i = width - 1; i >= 0; --i) {\n\t\tprintf(\"%lld\", BITOF(set, i));\n\t}\n\tcout << endl;\n}\n\n/* bug\nvoid show_top() {\n\tFOR(i, 0, plates.size()) {\n\t\tif (plates[i].top) {\n\t\t\tprintf(\"1\");\n\t\t} else {\n\t\t\tprintf(\"0\");\n\t\t}\n\t}\n\tcout << endl;\n}\n*/\n\nvoid remove(int a, int b)/*{{{*/\n{\n\tplate* p[2] = {&(plates[a]), &(plates[b])};\n\tfor (int i = 0; i < 2; ++i) {\n\t\tplate* r = p[i]; // removal\n\t\tfor (int j = 0; j < r->downers.size(); ++j) {\n\t\t\tplate* d = r->downers[j];\n\t\t\td->upper_set &= ~((int)BIT(r->id));\n\t\t\tif (d->upper_set == 0) {\n\t\t\t\td->top = true;\n\t\t\t}\n\t\t}\n\t}\n}/*}}}*/\n\nvoid restore(int a, int b)/*{{{*/\n{\n\tplate* p[2] = {&(plates[a]), &(plates[b])};\n\tfor (int i = 0; i < 2; ++i) {\n\t\tplate* r = p[i]; // removal\n\t\tfor (int j = 0; j < r->downers.size(); ++j) {\n\t\t\tplate* d = r->downers[j];\n\t\t\tif (d->upper_set == 0) {\n\t\t\t\td->top = false;\n\t\t\t}\n\t\t\td->upper_set |= ~((int)BIT(r->id));\n\t\t}\n\t}\n}/*}}}*/\n\nint memo[1 << 24];\nint rec (unsigned int condition)/*{{{*/\n{\n\tif (memo[condition] != -1) {\n\t\treturn memo[condition];\n\t}\n\t//printf(\"condition: \"); show_bit(condition, n);\n\tint res = 0;\n\tFOR(i, 0, plates.size()) {\n\t\tplate p = plates[i];\n\t\tif (!p.top || BITOF(condition, i) == 0) { // not top or already removed\n\t\t\tcontinue;\n\t\t}\n\n\t\tFOR(j, i+1, plates.size()) {\n\t\t\tif (BITOF(condition, j) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tplate r = plates[j]; // removal\n\t\t\tif (!r.top || p.color != r.color) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// remove i and j\n\t\t\tint save = condition;\n\t\t\tcondition &= ~((int)BIT(i));\n\t\t\tcondition &= ~((int)BIT(j));\n\t\t\tremove(i, j);\n\t\t\tres = max(res, rec(condition) + 2);\n\t\t\trestore(i, j);\n\t\t\tcondition = save;\n\t\t}\n\t}\n\tmemo[condition] = res;\n\treturn res;\n}/*}}}*/\n\nint main(int argc, char const* argv[])/*{{{*/\n{\n\twhile (cin >> n, n) {\n\t\tFOR(i, 0, plates.size()) {\n\t\t\tplates[i].downers.clear();\n\t\t}\n\t\tplates.clear();\n\t\t// input\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y, r, c;\n\t\t\tcin >> x >> y >> r >> c;\n\n\t\t\tplate p;\n\t\t\tp.id = i; p.x = x; p.y = y; p.r = r; p.color = c;\n\t\t\tp.top = true; p.upper_set = 0;\n\t\t\tplates.PB(p);\n\t\t}\n\t\t// check overlay\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = i - 1; j >= 0; --j) {\n\t\t\t\tplate *p = &(plates[i]), *q = &(plates[j]);\n\t\t\t\tif ( (double)(p->r + q->r) > sqrt( pow(p->x - q->x, 2) + pow(p->y - q->y, 2) ) ) {\n\t\t\t\t\t// q is upper than p\n\t\t\t\t\tp->upper_set |= BIT(q->id);\n\t\t\t\t\tp->top = false;\n\t\t\t\t\tq->downers.PB(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// init memo\n\t\tFOR(i, 0, 1 << 24) {\n\t\t\tmemo[i] = -1;\n\t\t}\n\t\tint condition = 0xFFFFFF;\n\t\tcout << rec(condition) << endl;\n\t}\n\treturn 0;\n}/*}}}*/"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nstruct recedge\n{\n\tint y, next;\n} edge[5555];\nint l, idx[5555], ind[33], x[33], y[33], r[33], c[33], n, ans;\nvoid build(int x, int y)\n{\n\tedge[++l].y = y;\n\tedge[l].next = idx[x];\n\tidx[x] = l;\n}\nint lg(int x)\n{\n\tint rtn = 0;\n\twhile(x) rtn++, x /= 2;\n\treturn rtn - 1;\n}\nvoid dfs(int msk, int d, int c1, int c2, int c3, int c4)\n{\n\tans = max(ans, d);\n\tif(ans == n or ans == n - 1) return;\n\tint I, J, flag;\n\tif(c1 >= 2)\n\t{\n\t\tint msk1 = 0;\n\t\tfor(int i = 0; i < n; i++) if(c[i + 1] == 1 and ind[i + 1] == 0 and ((1 << i) & msk))\n\t\t{\n\t\t\tflag = true;\n\t\t\tfor(int p = idx[i + 1]; p; p = edge[p].next) if((1 << (edge[p].y - 1)) & msk)\n\t\t\t{flag = false; break;}\n\t\t\tif(flag) msk1 += (1 << i);\n\t\t}\n\t\tfor(int i = msk1; i; i -= i & -i) for(int j = i - (i & -i); j; j -= j & -j)\n\t\t{\n\t\t\tdfs(msk - (i & -i) - (j & -j), d + 2, c1 - 2, c2, c3, c4);\n\t\t}\n\t}\n\tif(c2 >= 2)\n\t{\n\t\tint msk1 = 0;\n\t\tfor(int i = 0; i < n; i++) if(c[i + 1] == 2 and ind[i + 1] == 0 and ((1 << i) & msk))\n\t\t{\n\t\t\tflag = true;\n\t\t\tfor(int p = idx[i + 1]; p; p = edge[p].next) if((1 << (edge[p].y - 1)) & msk)\n\t\t\t{flag = false; break;}\n\t\t\tif(flag) msk1 += (1 << i);\n\t\t}\n\t\tfor(int i = msk1; i; i -= i & -i) for(int j = i - (i & -i); j; j -= j & -j)\n\t\t{\n\t\t\tdfs(msk - (i & -i) - (j & -j), d + 2, c1, c2 - 2, c3, c4);\n\t\t}\n\t}\n\tif(c3 >= 2)\n\t{\n\t\tint msk1 = 0;\n\t\tfor(int i = 0; i < n; i++) if(c[i + 1] == 3 and ind[i + 1] == 0 and ((1 << i) & msk))\n\t\t{\n\t\t\tflag = true;\n\t\t\tfor(int p = idx[i + 1]; p; p = edge[p].next) if((1 << (edge[p].y - 1)) & msk)\n\t\t\t{flag = false; break;}\n\t\t\tif(flag) msk1 += (1 << i);\n\t\t}\n\t\tfor(int i = msk1; i; i -= i & -i) for(int j = i - (i & -i); j; j -= j & -j)\n\t\t{\n\t\t\tdfs(msk - (i & -i) - (j & -j), d + 2, c1, c2, c3 - 2, c4);\n\t\t}\n\t}\n\tif(c4 >= 2)\n\t{\n\t\tint msk1 = 0;\n\t\tfor(int i = 0; i < n; i++) if(c[i + 1] == 4 and ind[i + 1] == 0 and ((1 << i) & msk))\n\t\t{\n\t\t\tflag = true;\n\t\t\tfor(int p = idx[i + 1]; p; p = edge[p].next) if((1 << (edge[p].y - 1)) & msk)\n\t\t\t{flag = false; break;}\n\t\t\tif(flag) msk1 += (1 << i);\n\t\t}\n\t\tfor(int i = msk1; i; i -= i & -i) for(int j = i - (i & -i); j; j -= j & -j)\n\t\t{\n\t\t\tdfs(msk - (i & -i) - (j & -j), d + 2, c1, c2, c3, c4 - 2);\n\t\t}\n\t}\n\t\n}\nint main()\n{\n\tfor(;;)\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tif(!n) break;\n\t\tl = 0;\n\t\tint c1 = 0, c2 = 0, c3 = 0, c4 = 0;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tind[i] = 0; idx[i] = 0;\n\t\t\tscanf(\"%d%d%d%d\", &x[i], &y[i], &r[i], &c[i]);\n\t\t\tif(c[i] == 1) c1++;\n\t\t\tif(c[i] == 2) c2++;\n\t\t\tif(c[i] == 3) c3++;\n\t\t\tif(c[i] == 4) c4++;\n\t\t\t\n\t\t\tfor(int j = i - 1; j >= 1; j--)\n\t\t\t{\n\t\t\t\tif(sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j])) < r[i] + r[j])\n\t\t\t\t{\n\t\t\t\t\tbuild(i, j);\n\t\t\t\t//\tprintf(\"%d -> %d\\n\", j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tdfs((1 << n) - 1, 0, c1, c2, c3, c4);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\tfclose(stdin);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <bitset>\nusing namespace std;\n\ntypedef double D;\nconst double EPS = 1e-8;\n\nstruct P {\n  D x, y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\n\nstruct C {\n  P p;\n  D r;\n  C() { }\n  C(P p_, D r_) : p(p_), r(r_) { }\n  C(D x_, D y_, D r_) : p(x_, y_), r(r_) { }\n};\n\nint sig(double a, double b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\n\nbool iCC(C a, C b) {\n  D dx = a.p.x - b.p.x;\n  D dy = a.p.y - b.p.y;\n  D d2 = dx*dx + dy*dy;\n  return sig(d2, (a.r + b.r)*(a.r + b.r)) < 0;\n}\n\nint N;\nC circle[16];\nint color[16];\nbool overlap[16][16];\n\nint solve(int S) {\n  int top = 0;\n  for(int i = 0; i < N; ++i) {\n    if(((S >> i) & 1) == 0) continue;\n    bool ok = true;\n    for(int j = 0; j < i; ++j) {\n      if(((S >> j) & 1) == 0) continue;\n      if(overlap[i][j]) {\n        ok = false;\n        break;\n      }\n    }\n    if(ok) {\n      top |= 1 << i;\n    }\n  }\n  int res = 0;\n  for(int i = 0; i < N; ++i) {\n    for(int j = i + 1; j < N; ++j) {\n      if((top >> i) & 1 && (top >> j) & 1 && color[i] == color[j]) {\n        int B = S;\n        B &= ~(1 << i);\n        B &= ~(1 << j);\n        res = max(res, 2 + solve(B));\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(true) {\n    cin >> N;\n    if(N == 0) break;\n    for(int i = 0; i < 16; ++i)\n      for(int j = 0; j < 16; ++j)\n        overlap[i][j] = false;\n    for(int i = 0; i < N; ++i) {\n      cin >> circle[i].p.x >> circle[i].p.y >> circle[i].r >> color[i];\n      color[i]--;\n    }\n    for(int i = 0; i < N; ++i) {\n      for(int j = 0; j < i; ++j) {\n        if(iCC(circle[i], circle[j])) {\n          overlap[i][j] = true;\n        }\n      }\n    }\n    cout << solve((1 << N) - 1 ) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n\n\nusing namespace std;\n\nvector<double> x;\nvector<double> y;\nvector<double> r;\nvector<double> c;\nint dp[1<<24];\n\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n\n    if (n == 0) {\n      break;\n    }\n\n    x.resize(n);\n    y.resize(n);\n    r.resize(n);\n    c.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n\n\n    int ans = 0;\n\n    \n    memset(dp, 0, sizeof(dp));\n    for (int i = 0; i < (1 << n); i++) {\n      int popcnt = 0;\n      for (int j = 0; j < n; j++) {\n        if (i & (1 << j)) {\n          popcnt++;\n        }\n      }\n      if (popcnt % 2 == 1) {\n        continue;\n      }\n      vector<bool> tops(n, true);\n      // テ」ツつづ」ツ?? jテ」ツ?ィkテ」ツ?古・ツ渉姪」ツつ古」ツつ凝」ツ?ェテ」ツつ?\n      for (int a = 0; a < n; a++) {\n        if (i & (1 << a)) {\n          tops[a] = false;\n          continue;\n        }\n        for (int b = a + 1; b < n; b++) {\n          if (i & (1 << b)) {\n            tops[b] = false;\n            continue;\n          }\n          // iテ」ツ?ョテ」ツ?サテ」ツ??」ツ?古「ツ??\n          double distance2 = pow(x[a] - x[b], 2) + pow(y[a] - y[b], 2);\n          if (distance2 < pow(r[a] + r[b], 2)) {\n            tops[b] = false;\n          }\n        }\n      }\n      for (int j = 0; j < n; j++) {\n        for (int k = j + 1; k < n; k++) {\n          if (c[j] == c[k]) {\n            if (tops[j] && tops[k]) {\n              // dp[i | (j, k) << c] = max(dp[i | (j, k) << c], dp[i] + 1);\n              int bit = i | (1 << j) | (1 << k);\n              dp[bit] = max(dp[bit], dp[i] + 1);\n              ans = max(ans, dp[bit]);\n            }\n          }\n        }\n      }\n    }\n    \n    cout << ans * 2 << endl;\n\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<complex>\n#include<set>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int M = 24;\nconst int INF = 1000000000;\nconst int C = 5;\n\ntypedef pair<int,int> pii;\n\nint n;\nint x[M];\nint y[M];\nint r[M];\nint c[M];\n\nvector<pii> colpair;\nvector<int> on[M];\nmap<int,int> memo;\n\nbool ok(int state, pii& p){\n\tbool ret = (state&(1<<p.first))==0 && (state&(1<<p.second))==0;\n\trep(i,on[p.first].size()){\n\t\tif((state&(1<<on[p.first][i]))==0)ret = false;\n\t}\n\trep(i,on[p.second].size()){\n\t\tif((state&(1<<on[p.second][i]))==0)ret = false;\n\t}\n\treturn ret;\n}\n\nint saiki(int state){\n\tif(memo.find(state)!=memo.end())return memo[state];\n\t\n\tint ans = 0;\n\trep(i,colpair.size()){\n\t\tif(ok(state, colpair[i])){\n\t\t\tint v = saiki(state | (1<<colpair[i].first) | (1<<colpair[i].second));\n\t\t\tans = max(ans, v+2);\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nvoid init(){\n\tmemo.clear();\n\trep(i,n)on[i].clear();\n\tcolpair.clear();\n\t\n\trep(i,n)reps(j,i+1,n){\n\t\tif(c[i]==c[j])colpair.push_back(pii(i,j));\n\t}\n\t\n\trep(i,n){\n\t\trep(j,i){\n\t\t\tint dx = x[i]-x[j];\n\t\t\tint dy = y[i]-y[j];\n\t\t\tint r2 = r[i]+r[j];\n\t\t\t\n\t\t\tif(dx*dx + dy*dy < r2*r2){\n\t\t\t\ton[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\trep(i,colpair.size()){\n\t\tprintf(\"%d %d\\n\",colpair[i].first, colpair[i].second);\n\t}\n\trep(i,n){\n\t\tprintf(\"on \");\n\t\trep(j,on[i].size())printf(\"%d \",on[i][j]);puts(\"\");\n\t}*/\n}\nint solve(){\n\trep(i,n)cin>>x[i]>>y[i]>>r[i]>>c[i];\n\tinit();\n\t\n\treturn saiki(0);\n}\n\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tprintf(\"%d\\n\",solve());\n\t\t//break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n//template<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nint type[4];\n\nll dist(pii a,pii b){\n  ll dx=a.X-b.X,dy=a.Y-b.Y;\n  return dx*dx+dy*dy;\n}\n\nint ans,next_[24];\n\nint nxt(int a,int b){\n  a^=b;\n  rep(i,24)if(b>>i)\n    a|=next_[i];\n  return a;\n}\n\nint memo[1<<24];\n\nint dfs(int st){\n  if(memo[st])return memo[st];\n  int p,stt,re=0;\n  rep(i,4){\n    p=__builtin_popcount(stt=(st&type[i]));\n    if(p>1){\n      if(p%2){\n\trep(j,24)if(stt>>j){\n\t  re=max(dfs(nxt(st,stt^(1<<j))),re);\n\t}\n\tre+=p-1;\n      }else{\n\tre=p+dfs(nxt(st,stt));\n      }\n      break;\n    }\n  }\n  //  cout<<st<<\":\"<<re<<endl;\n  return memo[st]=re;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int i,j,k;\n  int n;\n  while(cin>>n){\n    if(!n)break;\n    memset(memo,0,sizeof(memo));\n    vector<pii> v(n);\n    vector<int> r(n),c(n),ue(n,1);\n    vector<vector<int>> g(n);\n    rep(i,4)type[i]=0;\n    rep(i,n){\n      cin>>v[i].X>>v[i].Y>>r[i]>>c[i];\n      --c[i];\n      type[c[i]]|=(1<<i);\n    }\n    rep(i,n)rep(j,i){\n      if(dist(v[i],v[j])<1ll*(r[i]+r[j])*(r[i]+r[j])){\n\tg[j].pb(i);\n\tue[i]=0;\n      }\n    }\n    int st=0;\n    rep(i,n){\n      st|=(ue[i]<<i);\n      for(int a:g[i])\n\tnext_[a]|=1<<a;\n    }\n    //    cout<<st<<endl;\n    cout<<dfs(st)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#define x first.first\n#define y first.second\n#define r second.first\n#define color second.second\n\nusing namespace std;\n\ntypedef pair<double,double> P;\ntypedef pair<P,P> C;\n\nconst double EPS = 1e-10;\n\ndouble dist(C a,C b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nbool check(C a,C b){\n  return a.r+b.r>dist(a,b);\n}\n\nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<C>c(n);\n    for(int i=0;i<n;i++)\n      cin >> c[i].x >> c[i].y >> c[i].r >> c[i].color;\n    \n    int dp[(1<<n)];\n    fill(dp,dp+(1<<n),0);\n\n    for(int S=(1<<n)-1;S>=0;S--){\n      for(int i=0;i<n;i++){\n\tfor(int j=i+1;j<n;j++){\n\t  if(!(S>>i&1) || !(S>>j&1))continue;\n\t  if(c[i].color!=c[j].color)continue;\n\n\t  bool fg=false;\n\t  for(int k=0;k<n;k++){\n\t    if(i!=k && check(c[i],c[k]))fg=true;\n\t    if(j!=k && check(c[j],c[k]))fg=true;\n\t  }\n\t  //if(fg)continue;\n\n\t  int nx=S;\n\t  nx&=~(1<<i);\n\t  nx&=~(1<<j);\n\t  dp[nx]=max(dp[nx],dp[S]+2);\n\t}\n      }\n    }\n    int ans=0;\n    for(int i=0;i<(1<<n);i++)ans=max(ans,dp[i]);\n    cout << ans-2 << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\nint N, X[24], Y[24], R[24], C[24];\n\nbool isCoverd(int i, int j)\n{\n  int x = abs(X[i] - X[j]), y = abs(Y[i] - Y[j]), r = R[i] + R[j];\n  return ((x * x) + (y * y)) < (r * r);\n}\n\nbool noCoverd(int j, int s) {\n  for (int i = 0; i < j; i++)\n    if ( (s >> i & 1) && isCoverd(i, j))\n      return false;\n\n  return true;\n}\n\nchar memo[1 << 24];\nint dfs(int s)\n{\n  if (memo[s] != -1)\n    return memo[s];\n  \n  int ans = 0;\n  for (int i = 0; i < N; i++) {\n    for (int j = i + 1; j < N; j++) {\n      if ( (s >> i & 1) && (s >> j & 1)         && // 両方の皿が除去されていない場合\n           noCoverd(i, s) && noCoverd(j, s)     && // 重なっていない\n           C[i] == C[j]\n         ) {\n        ans = max(ans, dfs(s & ~(1 << i) & ~(1 << j)) + 2);\n      }\n    }\n  }\n  \n  return memo[s] = ans;\n}\n\n\nint main()\n{\n  while (cin >> N && N) {\n    for (int i = 0; i < N; i++) \n      cin >> X[i] >> Y[i] >> R[i] >> C[i];\n\n    memset(memo, -1, sizeof(memo));\n\n    cout << dfs((1 << N) - 1) << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nstruct Data\n{\n    int x;\n    int y;\n    int r;\n    int c;\n};\n\ntypedef struct Data D;\n\nchar result[1 << 25];\nvector<D> input;\n\nint solve(int now)\n{\n    // cout << now << endl;\n    // cout << (m.find(now) == m.end()) << endl;\n    if(result[now] != -1) return result[now];\n    // cout << \"hey\" << endl;\n    result[now] = 0;\n    vector<vector<int> >  colornum(5);\n    // cout << \"ho\" << n << endl;\n    for(int i = 0; i < input.size(); i++){\n        if((now & (1 << i)) == 0) continue;\n        bool notcovered = true;\n        // cout << i << \" : \" << input[i].x << \" \" << input[i].y << \" \" << input[i].r << \" \" << input[i].c << endl;\n        for(int j = 0; j < i; j++){\n            if((now & (1 << j)) == 0) continue;\n            // cout << i << \",\" << j << \":\" << pow(input[i].x - input[j].x, 2) + pow(input[i].y - input[j].y, 2) << \" \" << pow(input[i].r + input[j].r, 2) << endl;\n            if(pow(input[i].x - input[j].x, 2) + pow(input[i].y - input[j].y, 2) < pow(input[i].r + input[j].r, 2)){\n                notcovered = false;\n                break;\n            }\n        }\n        if(notcovered) colornum[input[i].c].push_back(i);\n    }\n    for(int i = 1; i < 5; i++){\n        // cout << \"colornumsize \" << colornum[i].size() << endl;\n        if(colornum[i].size() > 1){\n            for(int j = 0; j < colornum[i].size(); j++){\n                for(int k = j + 1; k < colornum[i].size(); k++){\n                    int newinput = now;\n                    for(int l = 0; l < input.size(); l++){\n                        if((now & (1 << l)) == 0 || l == colornum[i][j] || l == colornum[i][k]) newinput &= ~(1 << l);\n                    }\n                    // cout << \"newinput:\" << newinput << endl;\n                    result[now] = max((int)result[now], solve(newinput) + 2);   \n                }\n            }\n        }\n    }\n    return (int)result[now];\n}\n\n\n\nint main()\n{\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        input.clear();\n        for(int i = 0; i < n; i++){\n            D tmpd;\n            cin >> tmpd.x >> tmpd.y >> tmpd.r >> tmpd.c;\n            input.push_back(tmpd);\n        }\n        for(int i = 0; i < (1 << n) + 1; i++){\n            result[i] = -1;\n        }\n        int start = 0;\n        for(int i = 0; i < n; i++){\n            start |= 1 << i;\n        }\n        cout << solve(start) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<iomanip>\n#include<ctime>\n#include<cstring>\n#include<climits>\n#include<string>\n#include<vector>\n#include<map>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<stack>\n#include<deque>\n#include<list>\n#include<vector>\n#define LL long long\n/*\n#ifdef unix\n#define INT64 \"%lld\"\n#else\n#define INT64 \"%I64d\"\n#endif\n*/\nusing namespace std;\nint n,m,cnt,snt,K,times;\nLL oo=1000000007;\nstruct dic\n{\n\tint x,y,r;\n\tint c;\n}p[110];\nint num[110];\nint ans;\nbool vis[110];\nbool f[16777216];\nint dis(int x1,int y1,int x2,int y2)\n{\n\treturn (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n}\nbool cover(int pos,int state)\n{\n\tfor (int i=1;i<pos;i++)\n\tif (((state>>(i-1))&1)&&dis(p[i].x,p[i].y,p[pos].x,p[pos].y)<(p[i].r+p[pos].r)*(p[i].r+p[pos].r)) \n\treturn true;\n\treturn false;\n}\nvoid dp(int state)\n{\n\tint sum=0;\n\tfor (int i=0;i<n;i++) if ((state>>i)&1) sum++;\n\tans=max(ans,n-sum);\n\tif (f[state]) return;\n\tf[state]=true;\n\tfor (int i=1;i<=n;i++)\n\tif (((state>>(i-1))&1)&&!cover(i,state))\n\tfor (int j=i+1;j<=n;j++)\n\tif (((state>>(j-1))&1)&&p[i].c==p[j].c&&!cover(j,state))\n\t{\n\t\tint tstate=state^(1<<(i-1))^(1<<(j-1));\n\t\tdp(tstate);\n\t}\n}\nvoid work()\n{\n\tmemset(p,0,sizeof(p));\n\tfor (int i=1;i<=n;i++)\n\tscanf(\"%d%d%d%d\",&p[i].x,&p[i].y,&p[i].r,&p[i].c);\n\tans=0;\n\tmemset(f,0,sizeof(f));\n\tdp((1<<n)-1);\n\tprintf(\"%d\\n\",ans);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\twhile (n!=0)\n\t{\n\t\twork();\n\t\tscanf(\"%d\",&n);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n\nusing namespace std;\n\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef pair<int, int> PII;\n\ntypedef long double Real;\ntypedef complex<Real> Point;\ntypedef pair<Point, Real> Circle;\n\nnamespace std {\n    bool operator<(const Point &a, const Point &b) {\n        return real(a) == real(b) ? imag(a) < imag(b) : real(a) < real(b);\n    }\n}\n\n//doubleの誤差\n#define EPS (1e-10)\n//double同士の比較\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n//Pointの比較\n#define EQP(a, b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n\n//円\nint circle_relation(Circle a, Circle b) {\n    double d = abs(a.first - b.first);\n\n    if (a.second + b.second + EPS < d) return -1;\n    if (b.second + d + EPS < a.second) return 1;\n    if (a.second + d + EPS < b.second) return 2;\n\n    if (abs(a.second + b.second - d) < EPS) return -3;\n    if (abs(b.second + d - a.second) < EPS) return 3;\n    if (abs(a.second + d - b.second) < EPS) return 4;\n\n    return 0;\n}\n\ntypedef pair<Circle, int> CCircle;\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\nint main() {\n\n    while (true) {\n        int N;\n        cin >> N;\n\n        if (N == 0)break;\n\n        vector<CCircle> circles(N);\n        vector<bool> used(N, false);\n        for (int i = 0; i < N; i++) {\n            double x, y, r;\n            int c;\n            cin >> x >> y >> r >> c;\n            circles[i] = CCircle(Circle(Point(x, y), r), c);\n        }\n        reverse(circles.begin(), circles.end());\n\n        vector<vector<int>> overIds(N);\n        for (int i = 0; i < N; i++) {\n            CCircle baseCircle = circles[i];\n\n            for (int j = i + 1; j < N; j++) {\n                CCircle overCircle = circles[j];\n                int result = circle_relation(baseCircle.first, overCircle.first);\n\n                if (result != -1 && result != -3) {\n                    overIds[i].push_back(j);\n                }\n            }\n        }\n\n        int count = 0;\n        while (true) {\n            bool update = false;\n\n            //色を見ていく\n            for (int i = 1; i <= 4; i++) {\n                int color = i;\n\n                for (int j = N - 1; j >= 0; j--) {\n                    //上側の円がまだ使われてない\n                    //色も同じ\n                    if (!used[j] && circles[j].second == color) {\n\n                        {\n                            //さらに上の円が使われているか\n                            bool good = true;\n                            for (int k = 0; k < overIds[j].size(); k++) {\n                                if (!used[overIds[j][k]]) good = false;\n                            }\n                            if (!good) continue;\n                        }\n\n                        //下側の円を探す\n                        for (int k = j - 1; k >= 0; k--) {\n\n                            //色も同じで使われてない\n                            if (!used[k] && circles[k].second == color) {\n\n                                {\n                                    bool good = true;\n                                    for (int l = 0; l < overIds[k].size(); l++) {\n                                        if (!used[overIds[k][l]]) good = false;\n                                    }\n                                    if (!good) continue;\n                                }\n\n                                used[j] = true;\n                                used[k] = true;\n                                count += 2;\n\n                            }\n\n                        }\n\n                    }\n                }\n            }\n\n            if (!update) {\n                break;\n            }\n        }\n\n        cout << count << endl;\n\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint N;\nint r[24], x[24], y[24], c[24];\nvector<int> ue;\n\nshort dp[1 << 24];\nint xx(int x) { return x * x; }\nshort _dp(int k) {\n\tif (k == 0) return 0;\n\tif (dp[k] >= 0) return dp[k];\n\n\tvector<int> w;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif ( (k & (1 << i)) && (k & ue[i]) == 0 ) w.push_back(i);\n\t}\n\tshort ret = 0;\n\tfor (int i = 0; i < w.size(); ++i) {\n\t\tfor (int j = i+1; j < w.size(); ++j) {\n\t\t\tif (c[w[i]] == c[w[j]]) {\n\t\t\t\tret = max<short>(dp[k], _dp(k ^ (1 << w[i]) ^ (1 << w[j]))+2);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[k] = ret;\n}\nint main() {\n\twhile (cin >> N, N) {\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\n\t\tbool f[24][24] = {0}; // f[a][b]: a??????b????????????????????????\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\tif (xx(x[i]-x[j]) + xx(y[i]-y[j]) < xx(r[i]+r[j])) {\n\t\t\t\t\tf[j][i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tue.clear();\n\t\tue.resize(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint b = 0;\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (f[i][j]) b |= (1 << j);\n\t\t\t}\n\t\t\tue[i] = b;\n\t\t}\n\n\t\tfill(&dp[0], &dp[0]+(1<<24), -1);\n\t\tcout << (int)_dp((1 << N) - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\nint n;\nchar dp[1 << 24];\n//char up[24];\n//vector<char> dp, up;\n//vector<Circle> c;\nCircle c[24];\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = (a.r + b.r) * (a.r + b.r);\n    int d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    return r > d;\n}\n\nbool isUp(char s, int v)\n{\n    for (int i = 0; i < v; ++i)\n        if ((s >> i & 1) && isOverlap(c[v], c[i]))\n            return true;\n    return false;\n}\n\nchar Rec(int s)\n{\n    if (~dp[s])\n        return dp[s];\n\n    int res = 0;\n    // 取り除く2つの円の選択\n    for (int i = 0; i < n; ++i) {\n        // c[i]がないか取り除けない\n        if (!(s >> i & 1) || isUp(s, i))\n            continue;\n        // if (!(s >> i & 1) || s & up[i])\n        //     continue;\n\n        for (int j = i + 1; j < n; ++j) {\n            // c[i]とc[j]の色が異なる\n            if (c[i].c != c[j].c)\n                continue;\n            // c[j]がないか取り除けない\n            // if (!(s >> j & 1) || s & up[j])\n            //     continue;\n            if (!(s >> j & 1) || isUp(s, j))\n                continue;\n\n            int nxt = s & ~(1 << i) & ~(1 << j);\n            res = max(res, (int)Rec(nxt) + 2);\n        }\n    }\n\n    return dp[s] = res;\n}\n\nint main()\n{\n    while (cin >> n, n) {\n        memset(dp, -1, sizeof(dp));\n//        memset(up, 0, sizeof(up));\n//        c.resize(n);\n\n        // 円の入力\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        // // 円の重なり，上下関係\n        // for (int i = 0; i < n; ++i)\n        //     for (int j = i + 1; j < n; ++j)\n        //         if (isOverlap(c[i], c[j]))\n        //             up[j] |= (1 << i);\n\n        cout << (int)Rec((1 << n) - 1) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double R;//double long double ??????????????? cmath?????¢??°??????????????????????????????????????????????????§????????????\ntypedef complex<R> Point;\ntypedef pair<Point , Point> Line;\ntypedef pair<Point ,R > Circle;\ntypedef vector<Point> Poly;\n\n#define EPS (1e-10)//??????\n#define EQ(a,b) (abs((a)-(b)) < EPS)//??????????????°???????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )//????????????????????????????????????\n#define mp make_pair\n#define ft first\n#define sd second\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nR dot(Point a,Point b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nR cross(Point a,Point b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\nbool is_orthogonal(Line a,Line b){//2??´????????´?????????\n    return EQ(dot(a.ft - a.sd,b.ft - b.sd),0.0);\n}\nbool is_parallel(Line a,Line b){//2??´??????????????????\n    return EQ(cross(a.ft - a.sd,b.ft - b.sd),0.0);\n}\n\n////////////////////????????????\n\nint ccw(Point a,Point b,Point c){//ok\n    b -= a; c -= a;\n    if(cross(b,c) > EPS) return 1;//a???b??§???????¨???¨???????????????b???c\n    if(cross(b,c) < -EPS) return -1;//a???b??§????¨???¨???????????????b???c\n    if(dot(b,c) < -EPS) return 2;//c--a--b on same line\n    if(norm(c) - norm(b) > EPS) return -2;//a--b--c(abs??????????????????????????????????????????????????????????)\n    return 0;//a--c--b?????????b==c\n}\n\nbool is_intersection_ll(Line l,Line m){//???????????´??????????????????\n    return abs(cross(l.sd - l.ft,m.sd - m.ft)) > EPS || //????????§??????\n        abs(cross(l.sd - l.ft,m.ft - l.ft)) < EPS; //?????????????????????\n}\n\nbool is_intersection_ls(Line l,Line s){//??´???l??¨??????s???????????????\n    return cross(l.sd - l.ft, s.ft-l.ft)*       // s[0] is left of l\n        cross(l.sd - l.ft, s.sd - l.ft) < EPS; // s[1] is right of l\n}\n\nbool is_intersection_lp(Line l,Point p){//??´???l??¨???p???????????????\n    return abs(cross(l.sd - p,l.ft - p));\n}\n\nbool is_intersection_ss(Line a,Line b){//??????????????????????????????ok\n    return ccw(a.ft,a.sd,b.ft)*ccw(a.ft,a.sd,b.sd) <= 0 && ccw(b.ft,b.sd,a.ft)*ccw(b.ft,b.sd,a.sd) <= 0;\n}\n\nbool is_intersection_sp(Line s,Point p){//????????¨?????????????????? ????§??????????????????¨\n    return abs(s.ft - p) + abs(s.sd - p) - abs(s.ft - s.sd) < EPS;\n}\n\n/////////////?????¢\n\nR dis_lp(Line l,Point p){//??´???l??¨???p????????¢\n    return abs(cross(l.sd - l.ft,p - l.ft)) / abs(l.sd - l.ft);\n}\n\nR dis_ll(Line l,Line m){//???????????´???????????¢\n    return is_intersection_ll(l,m) ? 0.0 : dis_lp(l,m.ft);\n}\n\nR dis_ls(Line l,Line s){//??´???l??¨??????s????????¢\n    if(is_intersection_ls(l,s)) return 0.0;\n    return min(dis_lp(l,s.ft),dis_lp(l,s.sd));\n}\n\nR dis_sp(Line s,Point p){//??????s??¨???p????????¢\n    if(dot(s.sd - s.ft,p - s.ft) < EPS) return abs(p - s.ft);\n    if(dot(s.ft - s.sd,p - s.sd) < EPS) return abs(p - s.sd);\n    return dis_lp(s,p);\n}\n\nR dis_ss(Line s,Line t){//???????????????????????¢\n    if(is_intersection_ss(s,t)) return 0.0;\n    return min(min(dis_sp(s,t.ft),dis_sp(s,t.sd)),\n            min(dis_sp(t,s.ft),dis_sp(t,s.sd)));\n}\n\n//////////////?°???±??¨????°?\n\nPoint projection(Line l,Point p){//?°???±????±???????\n    R t = dot(p - l.ft,l.ft - l.sd) / norm(l.ft - l.sd);\n    return l.ft + t * (l.ft - l.sd);\n}\n\nPoint reflection(Line l,Point p){//????°?????±???????\n    return p + 2.0 * (projection(l,p) - p);\n}\n\n//////////////??????(????????????????¨???????????????¨??????????????????????????????????????£??????)\n\nPoint intersection_ll(Line l,Line m){//????????????????????????????????????????????????\n    R A = cross(l.sd - l.ft,m.sd - m.ft);\n    R B = cross(l.sd - l.ft,l.sd - m.ft);\n    if(abs(A) < EPS && abs(B) < EPS) return m.ft;//?????????\n    //if(abs(A) < EPS)assert(false);//????????§????????????\n    return m.ft + B / A * (m.sd - m.ft);\n}\n\nLine intersection_of_two_circles(Circle c1,Circle c2){//ok ????????????????????????Line?????\\????????????(r1 + r2 > sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2))???????????????????????????\n    R a =  abs(c2.ft - c1.ft);\n    R b = c1.sd;\n    R c = c2.sd;\n\n    R rc = (a  * a + b * b - c * c) / (2.0 * a);\n    R rs = sqrt(b * b - rc * rc);//C++ ??§???????????????????????????????????§???????????????sqrt ????????? float ?????????????????? long double ????????????????????????????????????????????¨?????§???????????? C ????????°????????§??????sqrt ????????? double ??????????????£??????????????????\n    Point diff = (c2.ft - c1.ft) / a;\n\n    Line p ;\n    p.ft = c1.ft + diff * rc + diff * Point(0,1) * rs;\n    p.sd = c1.ft + diff * rc + diff * Point(0,-1) * rs;\n\n    return p;\n}\n\n\nLine conver_line(Line a,Point maxi,Point mini){//??????????????´??????????????? maxi???????????????????????? mini?????????\n\n    if(abs(dot(a.sd - a.ft,Point(1.0,0.0))) < EPS){//??????x???????????´??????\n        ;\n    }\n}\n\n/////////////////////////polygon\n\n#define currP(P,i) P[i]//????????????\n#define nextP(P,i) P[(i + 1)%P.size()]//?¬??????????\n\nint is_contains_p_in_Poly(Poly po,Point p){//??????????§???¢????????¨(1)????¢????(-1)????????¨(0)??????????????????????????????\n    bool in = false;\n    REP(i,po.size()){\n        Point a = currP(po,i) - p,b = nextP(po,i) - p;\n        if(a.imag() > b.imag())swap(a,b);\n        if(a.imag() < EPS && -EPS < b.imag())\n            if(cross(a,b) < -EPS) in = !in;\n        if(abs(cross(a,b)) == 0.0 && dot(a,b) < EPS)return  -1;\n    }\n    return in;\n}\n\nR area2(Poly po){//????§???¢?????¢????????????????±???????\n    R A = 0.0;\n    REP(i,po.size())\n        A += cross(currP(po,i),nextP(po, i));\n    return A;\n}\n\n///////////////////////////???\n\nPoly convex_hull(Poly ps){\n    int n = ps.size(),k = 0;\n    Poly ch(2*n);\n    for(int i = 0;i < n;ch[k++] = ps[i++])// lower-hull\n        while(k >= 2 && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0) --k;\n    for(int i = n - 2,t = k + 1;i >= 0;ch[k++] = ps[i--])//upper-hull\n        while(k >= t && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\n#define prevP(P, i) P[(i+P.size()-1) % P.size()]\nbool isconvex(Poly P){\n    for(int i = 0;i < P.size();++i)\n        if(ccw(prevP(P,i),currP(P,i),nextP(P,i)) > 0) return false;\n    return true;\n}\n\nbool kosa(Circle c1, Circle c2) {\n  if(abs(abs(c1.ft-c2.ft) - (c1.sd+c2.sd)) < EPS)\n    return false;\n  return abs(c1.ft-c2.ft)<(c1.sd+c2.sd);\n}\n\n#define MAX_N 25\n\nint n;\nCircle cs[MAX_N];\nint cc[MAX_N];\n\nbool input() {\n  cin>>n;\n  int x, y, r;\n  REP(i, n) {\n    cin>>x>>y>>r>>cc[i];\n    cs[i] = mp(Point(x, y), r);\n  }\n  return n!=0;\n}\n\nchar dp[1<<MAX_N];\n\nbool totta[MAX_N],toreru[MAX_N];\n\nint saiki(int S) {\n  if(dp[S] > -1)\n    return (int)dp[S];\n  REP(i,n){totta[i] = S&(1<<i);toreru[i] = true;}\n  REP(i,n){\n    if(totta[i]){\n      toreru[i] = false;\n      continue;\n    }\n    REP(j,i){\n      if(!totta[j] && kosa(cs[i],cs[j])){\n        toreru[i] = false;\n        break;\n      }\n    }\n  }\n  bool f=false;\n  REP(i, n)f=f||toreru[i];\n  if(!f)return 0;\n  int maxi = 0;\n  REP(i,n){\n    if(toreru[i]){\n      FOR(j,i+1,n){\n        if(toreru[j] && cc[i] == cc[j])\n          maxi = max( maxi, saiki(S|(1<<i)|(1<<j))+2 );\n      }\n    }\n  }\n  return dp[S] = maxi;\n}\n\nvoid solve() {\n  REP(i,1<<n)\n    dp[i] = -1;\n  cout<<saiki(0)<<endl;\n}\n\nint main() {\n  \n  while(input()) {\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <iostream>\n\nusing namespace std;\n\nint pow2(int m){\n\treturn m * m;\n};\n\nint n, m, c[24], d, p[24];\n\nint func(int s,int t){\n\tint i, a[24] = {0}, b[24] = {0};\n\tfor(i = 23;i >= 0;i--){\n\t\ta[i] = s % 2;\n\t\tb[i] = t % 2;\n\t\ts /= 2;\n\t\tt /= 2;\n\t}\n\tfor(i = 0;i < 24;i++)\n\t\tif(!a[i] && b[i]) return 0;\n\treturn 1;\n}\n\n\nvoid dfs(int cnt){\n\tint i, j;\n\tm = max(m,cnt * 2);\n\tfor(i = 0;i < n - 1;i++){\n\t\tfor(j = i + 1;j < n;j++){\n\t\t\tif(c[i] == c[j] && !(d & (1 << i)) && !(d & (1 << j)) &&func(d,p[i]) && func(d,p[j])){\n\t\t\t\td ^= (1 << i) + (1 << j);\n\t\t\t\tdfs(cnt + 1);\n\t\t\t\td ^= (1 << i) + (1 << j);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(void){\n\tint x[24], y[24], r[24],  i, j;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n\t\tmemset(p,0,sizeof(p));\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < i;j++)\n\t\t\t\tif(sqrt((double)pow2(x[i] - x[j]) + pow2(y[i] - y[j])) < r[i] + r[j]) p[i] += 1 << j;\n\t\t}\n\t\td = 0;\n\t\tm = 0;\n\t\tdfs(0);\n\t\tprintf(\"%d\\n\",m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, x[26], y[26], r[26], col[26], b[26][26]; short dp[16777222];\nint solve(int bit) {\n\tif (dp[bit]) return dp[bit] - 1;\n\tint ret = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (col[i] != col[j]) continue\n\t\t\tif ((bit & b[i][j]) == b[i][j]) {\n\t\t\t\tint res = solve(bit + (1 << i) + (1 << j));\n\t\t\t\tret = max(ret, res + 2);\n\t\t\t}\n\t\t}\n\t}\n\tdp[bit] = ret + 1;\n\treturn ret;\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i] >> r[i] >> col[i];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tb[i][j] = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tint disti = (x[k] - x[i]) * (x[k] - x[i]) + (y[k] - y[i]) * (y[k] - y[i]);\n\t\t\t\t\tint distj = (x[k] - x[j]) * (x[k] - x[j]) + (y[k] - y[j]) * (y[k] - y[j]);\n\t\t\t\t\tif (k < i && disti < (r[i] + r[k]) * (r[i] + r[k])) b[i][j] |= 1 << k;\n\t\t\t\t\tif (k < j && distj < (r[j] + r[k]) * (r[j] + r[k])) b[i][j] |= 1 << k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfill(dp, dp + (1 << n), 0);\n\t\tint ret = solve(0);\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//線分を表す構造体\nstruct Segment{ Point p1, p2; };\n//直線を表す構造体\ntypedef Segment Line;\n//多角形を表す構造体\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// 許容する誤差\n#define EPS (1e-10)\n\n// ベクトルaの絶対値を求める\n//double length = abs(a);\n\n// 2点a,b間の距離を求める\n//double distance = abs(a-b);\n\n/*\n// ベクトルaの単位ベクトルを求める\nPoint b = a / abs(a);\n\n// ベクトルaの法線ベクトルn1,n2を求める\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 点cが直線a,b上にあるかないか\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// 点a,bを通る直線と点cとの距離\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// 線分s1と線分s2の距離\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// 線分sに対する点pの射影\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//線分sを対象軸とした点pの線対称の点\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//点pをangle分だけ時計回りに回転\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//円cと線分lの交点\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//点の内包\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//ベクトルの位置検出\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//凸包\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISEだと内角は180以下（一直線上に並んでいても、頂点として数える）\n        //!= CLOCKWISEだと内角は180未満（一直線上の頂点は数えない）\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //ここも == と != を変更する\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //最も下にある点の中で最も右にある点から反時計回りに並び替え\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//キャリパー法を用いて凸多角形の直径を求める\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//凸多角形の切り取りに使う関数。これがなんなのかはまだ知らない。\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//三角形の面積\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//多角形の面積\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//凸多角形かどうかの判定\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//凹多角形を線分lで切断した際の多角形の数\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\n//i番目を0にする\nint clearBit(int num, int i){\n\tint mask = ~(1 << i);\n\treturn num & mask;\n}\n\n//i番目をvで置き換える\nint updateBit(int num, int i, int v){\n\tint mask = ~(1 << i);\n\treturn (num & mask) | (v << i);\n}\n\nint n, ans;\n\nbool isOver(Circle a, Circle b){\n\treturn abs(a.c - b.c) < a.r + b.r;\n}\n\nvector<short> memo;\nshort dfs(int s, vector<int>& on, vector<int>& c){\n\tif(memo[s] != -1) return memo[s];\n\n\tint canTake[4][6] = {{0}};\n\tint size[4] = {0};\n\trep(i,n){\n\t\tif(getBit(s,i)) continue;\n\t\tif((on[i] bitand s) == on[i]){\n\t\t\tcanTake[c[i]][size[c[i]]++] = i;\n\t\t}\n\t}\n\n\tshort res = 0;\n\trep(i,4){\n\t\trep(j,size[i]){\n\t\t\trange(k,j + 1, size[i]){\n\t\t\t\tint nxt = setBit(setBit(s, canTake[i][j]), canTake[i][k]);\n\t\t\t\tres = max<short>(res, dfs(nxt, on, c) + 2);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn memo[s] = res;\n}\n\nint main(){\n    while(scanf(\"%d\",&n),n){\n        vector<Circle> c(n);\n        vector<int> color(n), on(n,0);\n        rep(i,n){\n            double x,y,r;\n            scanf(\"%lf%lf%lf%d\",&x,&y,&r,&color[i]);\n\t\t\tcolor[i]--;\n            c[i] = {Point(x,y),r};\n\t\t\trep(j,i){\n\t\t\t\tif(isOver(c[i], c[j])) on[i] = setBit(on[i], j);\n\t\t\t}\n        }\n\n\t\tans = 0;\n\t\tmemo = vector<short>(1 << n, -1);\n\t\tcout << dfs(0, on, color) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint sum=0,ds;\nint n;\nvoid rec(vector<circle> vs){\n  //cout << vs.size() << endl;\n  int i,j,k;\n  int f;\n  int on[100]={};\n  vector<int> cc[10];\n  vector<circle> next;\n  \n  f=1;\n  for(i=0;i<100;i++) on[i]=0;\n  for(i=0;i<vs.size();i++){\n    for(j=i+1;j<vs.size();j++){\n      if(ch(vs[i],vs[j])==1) on[j]=1;\n    }\n  }\n  for(i=0;i<vs.size();i++){\n    if(on[i]==0) cc[vs[i].c].push_back(i);\n  }\n  for(i=1;i<5;i++){\n    //cout << cc[i].size() << endl;\n    if(cc[i].size()>=2){\n      f=0;\n      next.clear();\n      for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n      for(j=0;j<cc[i].size();j++){\n\tfor(k=j+1;k<cc[i].size();k++){\n\t  next.erase(next.begin()+cc[i][k]);\n\t  next.erase(next.begin()+cc[i][j]);\n\t  rec(next);\n\t}\n      }\n    }\n  }\n  int o=n-vs.size();\n  if(f==1) sum=max(sum,o);\n}\n\nint main(){\n  cin >> n;\n  while(n!=0){\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    sum=0;\n    rec(v);\n    cout << sum << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint sq(int x) { return x * x; }\n\nstruct Circle {\n\tint x, y, r, c;\n\tint tops;\n\tCircle (int _x, int _y, int _r, int _c) : x(_x), y(_y), r(_r), c(_c) {}\n};\n\nbool CC(const Circle& c1, const Circle& c2) {\n\tif (sq(c1.x - c2.x) + sq(c1.y - c2.y) < sq(c1.r + c2.r)) return true;\n\treturn false;\n}\n\nint n;\nvector<Circle> cs;\n\nint memo[1 << 25];\n\nint rec(int cur) {\n\tif (memo[cur] >= 0) return memo[cur];\n\t\n\t// 今取り除ける円盤を見つける\n\tvector<int> cand;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (cur >> i & 1) continue;\t// すでにとりのぞかれている\n\t\t\n\t\tint tops = cs[i].tops;\n\t\tint rmbit = ~cur;\t// bit反転をとる\n\t\tif ( (tops & rmbit) == 0) {\n\t\t\t// i番目の円盤は現在のこっている円盤によらずに取り除ける\n\t\t\tcand.push_back(i);\n\t\t}\n\t}\n\t\n\tint ret = __builtin_popcount(cur);\t// 返す値を用意する\n\t\n\t// 取り除ける円盤を取り除く\n\tint csize = (int)cand.size();\n\tfor (int i = 0; i < csize; i++) {\n\t\tint ci = cand[i];\n\t\tfor (int j = i + 1; j < csize; j++) {\n\t\t\tint cj = cand[j];\n\t\t\t\n\t\t\t// 同じ色なら取り除ける\n\t\t\tif (cs[ci].c == cs[cj].c) {\n\t\t\t\t// ci と cj を取り除いた場合について再帰\n\t\t\t\tint nxt = cur | (1 << ci);\n\t\t\t\tnxt |= 1 << cj;\n\t\t\t\tret = max(ret, rec(nxt));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn memo[cur] = ret;\t// メモしながら返す\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> n; if (n == 0) break;\n\t\t\n\t\tcs.clear();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x, y, r, c; cin >> x >> y >> r >> c;\n\t\t\tcs.push_back(Circle(x, y, r, c));\n\t\t}\n\t\t\n\t\t// 各円盤に対して、どの円盤が取り除かていればその円盤をとりだせるかを入れる\n\t\t// 取り除かなければならない円盤にbitをたてる\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tint tops = 0;\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (CC(cs[i], cs[j])) {\n\t\t\t\t\ttops |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcs[i].tops = tops;\n\t\t}\n\t\t\n\t\t// すべての円盤が残っている状態から開始\t\t\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tcout << rec(0) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define N 24\n\nint d[1<<N];\nint x[N],y[N],r[N],c[N];\nint n;\nint over[N];\n\nbool pailed(int a,int b){\n  int d2 = (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);\n  int r2 = (r[a]+r[b])*(r[a]+r[b]);\n  return d2 < r2;\n}\n\nint dfs(int i){\n  if(d[i]!=-1) return d[i];\n  d[i] = 0;\n  for(int j=0;j<n-1;j++){\n    //jがないorjの上に円盤がある\n    if(!(i>>j&1)||over[j]&i) continue;\n    for(int k=j+1;k<n;k++){\n      //kがないorkの上に円盤があるor色が違う\n      if(!(i>>k&1)||over[k]&i||c[k]!=c[j]) continue;\n      d[i] = max( d[i],2 + dfs((~(1<<j))&(~(1<<k))&i) );\n    }\n  }\n  return d[i];\n}\n\nint main(){\n  while(cin >> n,n){\n    fill(over,over+n,0);\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n    }\n    for(int i=n-1;i>=0;i--){\n      for(int j=i-1;j>=0;j--){\n        if(pailed(i,j)){\n          over[i] |= 1<<j;\n        }\n      }\n    }\n\n    fill(d,d+(1<<n),-1);\n    cout << (int)dfs((1<<n)-1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint n;\nVI xs, ys, rs, cs;\n\nmap<int, int> memo;\n\nbool is_top(int i, int used) {\n\tfor (int j = i - 1; j >= 0; j--) {\n\t\tif (1 << j & used) continue;\n\n\t\tint x = (xs[i] - xs[j]) * (xs[i] - xs[j]);\n\t\tint y = (ys[i] - ys[j]) * (ys[i] - ys[j]);\n\t\tint dis = x + y;\n\t\tint dis2 = (rs[i] + rs[j]) * (rs[i] + rs[j]);\n\n\t\tif (dis < dis2) {\t// 重なってる\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint dfs(int used) {\n\tint sum = 0;\n\n\tif (memo.count(used)) return memo[used];\n\n\tfor(int i = 0;i < n;i++) {\n\t\tfor(int j = 0;j < n;j++) {\n\t\t\tif(i == j || (1 << i & used) || (1 << j & used)) continue;\n\t\t\tif(!is_top(i, used) || !is_top(j, used)) continue;\n\n\t\t\tint x = (xs[i] - xs[j]) * (xs[i] - xs[j]);\n\t\t\tint y = (ys[i] - ys[j]) * (ys[i] - ys[j]);\n\t\t\tint dis = x + y;\n\t\t\tint dis2 = (rs[i] + rs[j]) * (rs[i] + rs[j]);\n\n\t\t\tif(dis >= dis2 && cs[i] == cs[j]) {\n\t\t\t\tint used_tmp = used;\n\t\t\t\tused_tmp |= 1 << i;\n\t\t\t\tused_tmp |= 1 << j;\n\n\t\t\t\tsum = max(sum, dfs(used_tmp) + 2);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn memo[used] = sum;\n}\n\nint main(void) {\n\twhile(cin >> n, n){\n\t\txs = VI(n);\n\t\tys = VI(n);\n\t\trs = VI(n);\n\t\tcs = VI(n);\n\t\tint used = 0;\n\t\tmemo.clear();\n\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n\t\t}\n\n\t\tcout << dfs(used) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define x first.first\n#define y first.second\n#define r second.first\n#define color second.second\n \nusing namespace std;\n \ntypedef pair<double,double> P;\ntypedef pair<P,P> C;\n \nconst double EPS = 1e-10;\n \ndouble dist(C a,C b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n \nbool check(C a,C b){\n  return a.r+b.r-dist(a,b)>EPS;\n}\n \nint count(int bits){\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits =(((bits >> 4) + bits) & 0x0f0f0f0f);\n  bits += bits >> 8;\n  return (bits + (bits >> 16)) & 0xff;\n}\n \nbool dp[(1<<25)];\n \nint main(void){\n \n\tint n;\n\twhile(cin >> n,n){\n\t\tC c[25];\n\t\tfor(int i=0;i<n;i++){\n\t\t\t//cin >> c[i].x >> c[i].y >> c[i].r >> c[i].color;\n\t\t\tscanf(\"%lf %lf %lf %lf\",&c[i].x,&c[i].y,&c[i].r,&c[i].color);\n\t\t}\n\t\t\n\t\tfill(dp,dp+(1<<n),false);\n\t\tdp[(1<<n)-1]=true;\n     \n\t\tfor(int S=(1<<n)-1;S>=0;S--){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\tif(!(S>>i&1) || !(S>>j&1))continue;\n\t\t\t\t\tif(c[i].color!=c[j].color)continue;\n       \n\t\t\t\t\tbool fg=false;\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(!(S>>k&1))continue;\n\t\t\t\t\t\tfg|= k<i && check(c[i],c[k]);\n\t\t\t\t\t\tfg|= k<j && check(c[j],c[k]);\n\t\t\t\t\t\tif(fg)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(fg)continue;\n\t\t\t\t\t\n\t\t\t\t\tint nx=S;\n\t\t\t\t\tnx&=~(1<<i);\n\t\t\t\t\tnx&=~(1<<j);\n\t\t\t\t\tdp[nx]|=dp[S];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tif(dp[i]){\n\t\t\t\tcout << n-count(i) << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cinttypes>\n\nusing namespace std;\n\nint n;\nvector<int16_t> x, y, r, c;\nint8_t memo[1 << 24];\n\nint rec(int bits) {\n  int ret = 0;\n  if (memo[bits] != 0) {\n    return memo[bits];\n  }\n  vector<bool> tops(n, true);\n  for (int i = 0; i < n; i++) {\n    if (bits & (1 << i)) {\n      continue;\n    }\n    for (int j = i + 1; j < n; j++) {\n      if (bits & (1 << j)) {\n        continue;\n      }\n      int distance2 = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n      if (distance2 < (r[i] + r[j]) * (r[i] + r[j])) {\n        tops[j] = false;\n      }\n    }\n  }\n\n  for (int i = 0; i < n; i++) {\n    if (bits & (1 << i)) {\n      continue;\n    }\n    if (!tops[i]) {\n      continue;\n    }\n    for (int j = i + 1; j < n; j++) {\n      if (bits & (1 << j)) {\n        continue;\n      }\n      if (!tops[j]) {\n        continue;\n      }\n      if (c[i] != c[j]) {\n        continue;\n      }\n      int r = 1 + rec(bits | (1 << i) | (1 << j));\n      if (r > ret) {\n        ret = r;\n      }\n    }\n  }\n\n  return memo[bits] = ret;\n}\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n    x.resize(n);\n    y.resize(n);\n    r.resize(n);\n\n    c.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n\n    cout << 2 * rec(0) << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\n\nint n;\nint x[32], y[32], r[32], c[32];\nint on_mask[32];\nchar dp[1 << 24];\nint recur(int remain)\n{\n\tif (dp[remain] != -1)\n\t\treturn dp[remain];\n\n\tint res = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tif (remain >> i & 1 && (on_mask[i] & remain) == 0)\n\t\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\t\tif (remain >> j & 1 && c[j] == c[i] && (on_mask[j] & remain) == 0)\n\t\t\t\t\tmax_swap(res, recur(remain ^ (1 << i | 1 << j)) + 2);\n\n\treturn dp[remain] = res;\t\t\t\t\t\n}\nbool on(int i, int j)\n{\n\tint dx = x[i] - x[j], dy = y[i] - y[j];\n\tint d = r[i] + r[j];\n\treturn dx * dx + dy * dy < d * d;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> n, n)\n\t{\n\t\trep (i, n)\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\n\t\tCL(on_mask, 0);\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tfor (int i = 0; i < j; ++i)\n\t\t\t\tif (on(i, j))\n\t\t\t\t\ton_mask[j] |= 1 << i;\n\n\t\tCL(dp, -1);\n\t\tcout << recur((1 << n) - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\ntypedef pair < unsigned char , unsigned char > Pt;\nint dp[1 << 24];\nPt pts[24];\nint n, r[24], c[24];\n\nbool intersect( Pt a, Pt b, int r1, int r2){\n  return pow( a.first - b.first, 2) + pow( a.second - b.second, 2) < pow( r1 + r2, 2);\n}\n\nint isnocover( const int& bit, const int& idx ){\n  for(int i = 0 ; i < idx ; i++ ){\n    if( (bit >> i) & 1 && intersect( pts[i], pts[idx], r[i], r[idx])) return false;\n  }\n  return true;\n}\n\nint rec( int bit){\n  if(~dp[bit]) return dp[bit];\n\n  int ret = 0;\n  for(int i = 0 ; i < n ; i++ ){\n    if((bit >> i) & 1){\n      for(int j = i + 1 ; j < n ; j++ ){\n        if( (bit >> j) & 1 && c[i] == c[j] && isnocover( bit, i) && isnocover( bit, j)){\n          ret = max( ret, rec( bit & ~(1 << i) & ~(1 << j)) + 2);\n        }\n      }\n    }\n  }\n  return dp[bit] = ret;\n}\nint main()\n{\n  while(cin >> n, n){\n    fill_n( dp, 1 << 24 , -1);\n    for(int i = 0 ; i < n ; i++ ){\n      int a, b;\n      cin >> a >> b >> r[i] >> c[i];\n      pts[i].first = (char)a, pts[i].second = (char)b;\n    }\n    cout << rec((1 << n) - 1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string.h>\n\nusing namespace std;\n\ntypedef struct a \n{\n\tbool exist[24];\n}state;\n\nvoid init_state(bool exist[24],int n)\n{\n\tfor (int i=0;i<n;++i) exist[i] = true;\n}\n\nint cal_state(bool exist[24],int n)\n{\n\tint res = 0;\n\tfor (int i=0;i<n;++i)\n\t{\n\t\tif (exist[i]) res += 1<<i; \n\t}\n\treturn res;\n}\n\nint cal_number(bool exist[24], int n)\n{\n\tint res = 0;\n\tfor (int i=0;i<n;++i)\n\t{\n\t\tif (exist[i]) ++res;\n\t}\n\treturn res;\n}\n\nbool overlap(int x1,int y1,int r1,int x2,int y2,int r2)\n{\n\tif ((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1) < (r1+r2)*(r1+r2)) return true;\n\telse return false;\n}\n\n\nbool s[1<<24];\n\nint main()\n{\n\tint n = 0;\n\tint x[24];\n\tint y[24];\n\tint r[24];\n\tint c[24];\n\n\tcin >> n;\n\twhile (n)\n\t{\n\t\tfor (int i=0;i<n;++i)\n\t\t{\n\t\t\tcin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\t}\n\n\t\tint res = 0;\n\t\tqueue<state> q;\n\t\tbool ontop[24];\n\n\t\tmemset(s, 0, sizeof(s));\n\t\ts[(1<<n)-1] = true;\n\n\t\tstate tmp;\n\t\tinit_state(tmp.exist,n);\n\t\tq.push(tmp);\n\t\t\n\t\twhile (!q.empty())\n\t\t{\n\t\t\ttmp = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tinit_state(ontop,n);\n\t\t\tres = max(res,n-cal_number(tmp.exist,n));\n\t\t\t\n\t\t\tif (res == n) break;\n\t\t\t\n\t\t\tfor (int i=0;i<n;++i)\n\t\t\t{\n\t\t\t\tif (tmp.exist[i])\n\t\t\t\t{\n\t\t\t\t\tfor (int j = i+1; j<n; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tmp.exist[j]&&ontop[j])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (overlap(x[i],y[i],r[i],x[j],y[j],r[j])) ontop[j] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i=0;i<n;++i)\n\t\t\t{\n\t\t\t\tif (tmp.exist[i]&&ontop[i])\n\t\t\t\t{\n\t\t\t\t\tfor (int j=i+1;j<n;++j) \n\t\t\t\t\t{\n\t\t\t\t\t\tif (tmp.exist[j]&&ontop[j]&&(c[i] == c[j]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstate tt = tmp;\n\n\t\t\t\t\t\t\ttt.exist[i] = false;\n\t\t\t\t\t\t\ttt.exist[j] = false;\n\t\t\t\t\t\t\tif (!s[cal_state(tt.exist,n)])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ts[cal_state(tt.exist,n)] = true;\n\t\t\t\t\t\t\t\tq.push(tt);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\tcout << res << endl;\n\t\tcin >>n;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint n;\n\nstruct Circle {\n    int x, y, r;\n    int c;\n    Circle() {}\n    Circle(int x, int y, int r, int c) : x(x), y(y), r(r), c(c) {}\n};\n\nbool intersect(Circle& a, Circle& b) {\n    return (a.r+b.r) * (a.r+b.r) > (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y);\n}\n\nvector<Circle> cs;\nvector< vector<int> > upper;\nvoid init() {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (intersect(cs[i], cs[j])) {\n                upper[i].push_back(j);\n            }\n        }\n    }\n}\n \nmap<int, short> dp;\nint remove(int used=0) {\n    if (dp[used] > 0) return dp[used];\n    vector<int> tops;\n    for (int i = 0; i < n; i++) {\n        if (used & (1<<i)) continue;\n        bool cover = false;\n        for (int j = 0; j < upper[i].size(); j++) {\n            if (!(used & (1<<upper[i][j]))) {\n                cover = true;\n                break;\n            }\n        }\n        if (!cover) tops.push_back(i);\n    }\n    int cnt = 0;\n    for (int i = 0; i < tops.size(); i++) {\n        for (int j = 0; j < tops.size(); j++) {\n            if (i == j) continue;\n            if (cs[tops[i]].c == cs[tops[j]].c) {\n                used |= (1<<tops[i]);\n                used |= (1<<tops[j]);\n                cnt = max(cnt, remove(used)+2);\n                used ^= (1<<tops[i]);\n                used ^= (1<<tops[j]);\n            }\n        }\n    }\n    return dp[used] = cnt;\n}\n\nint main() {\n    while (cin >> n, n) {\n        cs = vector<Circle>(n);\n        upper = vector< vector<int> >(n);\n        for (int i = 0; i < n; i++) {\n            int x, y, r, c;\n            cin >> x >> y >> r >> c;\n            cs[i] = Circle(x, y, r, c);\n        }\n        init();\n        dp = map<int, short>();\n        cout << remove() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\n\nconst double EPS=1e-6;\ndouble dist(int x0,int y0,int x1,int y1){\n    int x=x0-x1;\n    int y=y0-y1;\n    return sqrt(x*x+y*y)+EPS;\n}\nint dfs(int s,vector<int>& x,vector<int>& y,vector<int>& r,vector<int> &c){\n    vector<vector<int>> rem(4);\n    for(int i=0;i<n;i++){\n        if(s&(1<<i)){\n            bool isok=true;\n            for(int j=0;j<i;j++){\n                isok&=!(s&(1<<j) && dist(x[i],y[i],x[j],y[j])<r[i]+r[j]);\n            }\n            if(isok){\n                rem[c[i]].push_back(i);\n            }\n        }\n    }\n    int res=0;\n    for(int i=0;i<4;i++){\n        for(int j=0;j<rem[i].size();j++){\n            for(int k=0;k<j;k++){\n                int tos=s-(1<<rem[i][j])-(1<<rem[i][k]);\n                res=max(res,dfs(tos,x,y,r,c)+2);\n            }\n        }\n    }    \n    return res;\n}\nint main(){\n    while(cin>>n,n){\n        vector<int> x(n),y(n),r(n),c(n);\n        for(int i=0;i<n;i++){\n            cin>>x[i]>>y[i]>>r[i]>>c[i];\n            c[i]--;\n        }\n        cout<<dfs((1<<n)-1,x,y,r,c)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<vector>\nstruct S{int c,f,x,y,r;}s[24];\nint A(int x){return x*x;}\nchar m[1<<24];\nint n;\nint F(int f)\n{\n\tif(m[f]>=0)return m[f];\n\tstd::vector<int>v[5];\n\tint i,j,k,r=0,t;\n\tfor(i=0;i<n;++i)\n\t\tif((f&(1<<i))&&!(s[i].f&f))\n\t\t\tv[s[i].c].push_back(i);\n\tfor(k=1;k<5;++k)\n\t{\n\t\tfor(i=0,t=v[k].size();i<t;++i)\n\t\t\tfor(j=i+1;j<t;++j)\n\t\t\t\tr+=2+F(f&~(1<<v[k][i])&~(1<<v[k][j]));\n\t}\n\treturn m[f]=r;\n}\nint main()\n{\n\tint i,j;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tmemset(m,-1,sizeof(m));\n\t\tmemset(s,0,sizeof(s));\n\t\tfor(i=0;i<n;++i)scanf(\"%d%d%d%d\",&s[i].x,&s[i].y,&s[i].r,&s[i].c);\n\t\tfor(i=0;i<n;++i)\n\t\t\tfor(j=i+1;j<n;++j)\n\t\t\t\tif(A(s[i].x-s[j].x)+A(s[i].y-s[j].y)<A(s[i].r+s[j].r))\n\t\t\t\t\ts[j].f|=1<<i;\n\t\tprintf(\"%d\\n\",F((1<<n)-1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ndouble EPS = (1e10);\n\nstruct Point {\n  double x, y;\n};\n\nstruct Circle {\n  Point p;\n  double r;\n  int id;\n};\n\nbool intersect(Circle a, Circle b) {\n  double x1 = a.p.x, y1 = a.p.y;\n  double x2 = b.p.x, y2 = b.p.y;  \n  double d = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n\n  if ( d - (a.r+b.r) <= EPS ) return true;  \n  else return false;\n}\n\nvector<Circle> C[4];\nvector<Circle> circles;\nint N;\nunordered_map<int, int> dp;\n\nint dfs(int bit) {\n  //cout << bit << endl;\n  if ( bit == (1<<N)-1 ) return 0;\n  if ( dp[bit] ) return dp[bit];\n\n  int ret = 0;\n  int n;\n  for ( int i = 0; i < 4; i++ ) {\n    n = C[i].size();\n    if ( n <= 1 ) continue;\n    for ( int a = 0; a < n; a++ ) {\n      Circle c1 = C[i][a];\n      int i1 = c1.id;\n      //if ( bit == 9 && i1 == 1 ) cout << 'a' << endl;\n      if ( bit & (1<<i1) ) continue;\n      bool flag = true;\t\n      for ( int j = 0; j < i1; j++ ) {\n\tif ( !(bit & (1<<j)) && intersect(circles[j], c1) ) {\n\t  flag = false;\n\t  break;\n\t}\n      }\n      //if ( bit == 9 && i1 == 1 ) cout << 'a' << endl;\n      if ( !flag ) continue;\n      //if ( bit == 9 && i1 == 1 ) cout << 'a' << endl;\n      for ( int b = a+1; b < n; b++ ) {\n\tCircle c2 = C[i][b];\n\tint i2 = c2.id;\n\t//if ( i1 == 1 && i2 == 2 ) cout << 'a' << endl;\n\tif ( bit & (1<<i2) ) continue;       \t\n\tfor ( int j = 0; j < i2; j++ ) {\n\t  if ( !(bit & (1<<j)) && intersect(circles[j], c2) ) {\t    \n\t    flag = false;\n\t    break;\n\t  }\n\t}\n\tif ( flag ) {\n\t  ret = max(ret, dfs(bit|(((1<<i1)+(1<<i2))))+2);\t  \n\t}\n      }\n    }\n  }\n  \n  return dp[bit] = ret;  \n}\n\nsigned main() {\n  while ( cin >> N, N ) {\n    for ( int i = 0; i < 4; i++ ) C[i].clear();\n    circles.clear();\n    dp.clear();    \n    \n    for ( int i = 0; i < N; i++ ) {\n      Circle in;\n      double x, y, r;\n      int c;      \n      cin >> x >> y >> r >> c;\n      c--;\n      in.p = Point{x, y};      \n      in.r = r;\n      in.id = i;      \n      C[c].push_back(in);\n      circles.push_back(in);      \n    }\n    \n    cout << dfs(0) << endl;    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nbool inter(int x1, int y1, int r1, int x2, int y2, int r2){\n  int dx = x1-x2, dy = y1-y2;\n  return dx*dx+dy*dy < (r1+r2)*(r1+r2);\n}\n\nint N;\nchar dp[1<<24];\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>N, N){\n\tVI xs(N), ys(N), rs(N), cols(N);\n\tREP(i,N) cin >> xs[i] >> ys[i] >> rs[i] >> cols[i];\n\n\tVVI prev(N);\n\tREP(i,N) FOR(j,i+1,N){\n\t  if(inter(xs[i], ys[i], rs[i], xs[j], ys[j], rs[j]))\n\t\tprev[j].PB(i);\n\t}\n\n\tfill(dp, dp+(1<<24), -1);\n\tchar ans = 0;\n\tdp[0] = 0;\n\tfor(int b=0;b<1<<N;++b){\n\t  if(dp[b] < 0) continue;\n\t  for(int j=0;j<N;++j){\n\t\tif(b>>j&1) continue;\n\t\tfor(int k=j+1;k<N;++k){\n\t\t  if(b>>k&1 || cols[j] != cols[k]) continue;\n\t\t  bool ok = true;\n\t\t  for(int x: prev[j])\n\t\t\tif((b>>x&1) == 0) ok = false;\n\t\t  for(int x: prev[k])\n\t\t\tif((b>>x&1) == 0) ok = false;\n\t\t  if(ok){\n\t\t\tint b_ = b|(1<<j)|(1<<k);\n\t\t\tdp[b_] = max(dp[b_], (char)(dp[b]+2));\n\t\t\tans = max(ans, dp[b_]);\n\t\t  }\n\t\t}\n\t  }\n\t}\n\t\n\tcout << (int)ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint res = 0;\nint n;\n// num := 現時点で消した数。\n// state := その時の状態をビットで表したもの\nvoid dfs(int num, int state, vector<vector<int>> &G, vector<int> in, vector<int> &c, vector<bool> &used) {\n    if (used[state]) return;\n    used[state] = true;\n\n    for (int i = 0; i < n; ++i) {\n        if ((state >> i) & 1) continue;\n        for (int j = i + 1; j < n; ++j) {\n            if ((state >> j) & 1) continue;\n\n            if (in[i] == 0 && in[j] == 0 && c[i] == c[j]) {\n                int nstate = state;\n                nstate |= 1 << i;\n                nstate |= 1 << j;\n                for (int to : G[i]) {\n                    --in[to];\n                }\n                for (int to : G[j]) {\n                    --in[to];\n                }\n                dfs(num + 2, nstate, G, in, c, used);\n                for (int to : G[i]) {\n                    ++in[to];\n                }\n                for (int to : G[j]) {\n                    ++in[to];\n                }\n            }\n        }\n    }\n    res = max(res, num);\n}\n\nint main() {\n    while (true) {\n        cin >> n;\n        if (n == 0) break;\n\n        // DAG\n        vector<vector<int>> G(n);\n        // 入次数\n        vector<int> in(n);\n        // 入力\n        vector<int> x(n), y(n), r(n), c(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                // i番目とj番目の円が重なるなら、i->jに向けた辺を張る\n                int dx = x[i] - x[j];\n                int dy = y[i] - y[j];\n                int R = r[i] + r[j];\n                if (dx * dx + dy * dy < R * R) {\n                    G[i].push_back(j);\n                    ++in[j];\n                }\n            }\n        }\n\n        // どの円盤を消したかの情報をビットで表し、その状態ビットに遷移したことがあるかどうか記録\n        vector<bool> used((1 << n), false);\n        res = 0;\n        dfs(0, 0, G, in, c, used);\n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 10000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n//typedef pair<ll, ll> P;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\nstruct Circle {\n  int x, y, r, c;\n  //vector<int> from, to;\n  //int rest;\n  int req;\n  Circle(int x, int y, int r, int c) : x(x), y(y), r(r), c(c), req(0) {}\n  Circle() : req(0) {}\n};\n\n#define N 25\n\nCircle cc[N];\nvector<int> cv[5];\nmap<int, int> memo;\n\nint n;\nint solve(int state) {\n  if(memo.find(state) != memo.end()) {\n    return memo[state];\n  }\n  int rr = 0;\n  repl(c, 1, 4) {\n    vector<int> &v = cv[c];\n    rep(im, v.size()) {\n      int i = v[im];\n      if(state & (1 << i) && (cc[i].req & state) == 0) {\n        rep(jm, im) {\n          int j = v[jm];\n          if(state & (1 << j) && (cc[j].req & state) == 0) {\n            int r = solve(state ^ (1 << i) ^ (1 << j)) + 2;\n            rr = maxd(rr, r);\n          }\n        }\n      }\n    }\n  }\n  memo[state] = rr;\n  return rr;\n}\n\nint main() {\n  while(cin >> n && n) {\n    rep(i, 5) cv[i].clear();\n    memo.clear();\n    rep(i, n) {\n      int x, y, r, c;\n      cin >> x >> y >> r >> c;\n      cc[i] = Circle(x, y, r, c);\n      cv[c].push_back(i);\n      rep(j, i) {\n        if(pow2(cc[i].x - cc[j].x) + pow2(cc[i].y - cc[j].y) < pow2(cc[i].r + cc[j].r)) {\n          cc[i].req |= 1 << j;\n        }\n      }\n    }\n    cout << solve((1<<n)-1) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\n#define pb push_back\n\nint anss = 0;\n\nint calculate(int x,int y,int r,int xx,int yy,int rr){\n    int d = (x-xx)*(x-xx)+(y-yy)*(y-yy);\n    if(d >= (r+rr)*(r+rr)) return 0;\n    else return 1;\n}\n\nvoid play(int n,int top[],int col[],vector <int> colors[]){\n    //cout << endl << endl;\n    vector <int> pos[6];\n    int ans=0;\n    for(int i = 0 ; i < n ; i++){\n        //cout << \"t \" << i << \" \" << top[i] << endl;\n        if(top[i] == 0){\n            pos[col[i]].pb(i);\n        }\n        if(top[i] == -1) ans++;\n    }\n\n    anss = max(ans,anss);\n    /*\n    for(int i = 1 ; i < 4 ; i++){\n        //cout << i << \" : \";\n        for(int j = 0 ; j < pos[i].size() ; j++) cout << pos[i][j] << \" \";\n        cout << endl;\n    }\n    */\n    for(int i = 1 ; i < 4 ; i++){\n        if(pos[i].size() >= 2){\n            do{\n                int topp[30];\n\n                for(int j = 0 ; j < n ; j++) topp[j] = top[j];\n\n                for(int j = 0 ; j < n ; j++){\n                    //cout << \"shift \" << pos[i][0] << \" \" << pos[i][1] << endl;\n                    //cout << \"shiff \" << j << \" \" << topp[j] << \" \" << (topp[j] & (1<<pos[i][0])) << endl;\n\n                    if( (topp[j] & (1<<pos[i][0])) > 0 && topp[j] > 0 ) topp[j] -= 1<<pos[i][0];\n                    if( (topp[j] & (1<<pos[i][1])) > 0 && topp[j] > 0 ) topp[j] -= 1<<pos[i][1];\n                }\n\n                topp[pos[i][0] ] = -1;\n                topp[pos[i][1] ] = -1;\n                play(n,topp,col,colors);\n            }while(next_permutation( pos[i].begin(),pos[i].end() ) );\n        }\n    }\n\n    //cout << \"end\" << endl;\n}\nmain(){\n    //freopen(\"D.txt\",\"r\",stdin);\n    int n;\n\n    while(cin >> n,n>0){\n        int top[30]={0};\n        int xx[30];\n        int yy[30];\n        int rad[30];\n        int col[30];\n        vector <int> colors[6];\n\n        for(int i = 0 ; i < n ; i++){\n            cin >> xx[n-i-1] >> yy[n-1-i] >> rad[n-1-i] >> col[n-1-i];\n\n            colors[col[n-1-i]].pb(n-1-i);\n        }\n\n        for(int i = 0; i < n ; i++){\n            for(int j = 0 ; j < i ; j++){\n                if(calculate(xx[j],yy[j],rad[j],xx[i],yy[i],rad[i])==1){\n                    top[j]+=1<<i;\n                }\n            }\n        }\n\n        anss = 0;\n        play(n,top,col,colors);\n\n        cout << anss << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define show_bits(b, s) if(opt_debug) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#define dumpb(bit, digits) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #bit << \" = \"; for(int __i = digits - 1; __i >= 0; __i--) { cerr << static_cast<bool>(bit & (1 << __i)); if (__i % 4 == 0) { cerr << \" \"; } } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\nbool opt_debug = false;\n\nclass Disk {\n\tprivate:\n\tpublic:\n\t\tint x, y, r, c;\n\t\tset<Disk*> upper_disks;\n\t\tset<Disk*> lower_disks;\n\n\t\tDisk(int _x, int _y, int _r, int _c) : x(_x), y(_y), r(_r), c(_c) {\n\t\t}\n\n\t\tbool overlap(const Disk rhs) {\n\t\t\treturn sqrt(pow(x - rhs.x, 2) + pow(y - rhs.y, 2)) + EPS < r + rhs.r;\n\t\t}\n};\nstd::ostream& operator<<(std::ostream &s, const Disk &d) {\n\ts << \"(\" << d.x << \", \" << d.y << \", \" << d.r << \", \" << d.c << \")\";\n\treturn s;\n}\n\n#define BIT_SUB(a, b) ((a) - ((a) & (b)))\ntypedef vector<unsigned> Vunsigned;\n\nmap<unsigned, char> memo;\nint solve(vector<Disk*> &disks, Vunsigned &upper, unsigned current) {\n\tdumpb(current, 24);\n\tif (EXIST(memo, current)) { return memo[current]; }\n\tint ret = 0;\n\tREP (i, disks.size()) {\n\t\tFOR (j, i+1, disks.size()) {\n\t\t\tif (current & 1 << i || current & 1 << j || (disks[i]->c != disks[j]->c)) { continue; }\n\t\t\tdumpb(upper[i], 24);\n\t\t\tdumpb(upper[j], 24);\n\t\t\tdumpb(BIT_SUB(upper[i], current), 24);\n\t\t\tdumpb(BIT_SUB(upper[j], current), 24);\n\t\t\tif (BIT_SUB(upper[i], current) || BIT_SUB(upper[j], current)) {\n\t\t\t\t// cannot remove\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdump(i);\n\t\t\tdump(j);\n\t\t\tdump(*disks[i]);\n\t\t\tdump(*disks[j]);\n\n\t\t\tunsigned next = current | (1 << i) | (1 << j);\n\t\t\tdumpb(next, 24);\n\t\t\tret = max(ret, 2 + solve(disks, upper, next));\n\t\t}\n\t}\n\treturn memo[current] = ret;\n}\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/0.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tint n;\n\twhile (cin >> n, n) {\n\t\tmemo.clear();\n\t\tVunsigned overlap(n, 0);\n\t\tvector<Disk*> disks;\n\t\tREP (i, n) {\n\t\t\tint x, y, r, c; cin >> x >> y >> r >> c;\n\t\t\tDisk *d = new Disk(x, y, r, c);\n\t\t\tREP (j, disks.size()) {\n\t\t\t\tDisk *rhs = disks[j];\n\t\t\t\tif (d->overlap(*rhs)) {\n\t\t\t\t\toverlap[i] = overlap[i] | (1 << j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdisks.PB(d);\n\t\t}\n\t\tcout << (int)solve(disks, overlap, 0) << endl;\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nvvi data(24, vi(4));\n\nint bitnum(int n) {\n\tint res = 0;\n\tREP(i, 32) {\n\t\tif(n&(1<<i)) {\n\t\t\tres++;\n\t\t}\n\t}\n\treturn res;\n}\n\nbool cover(int i, int j) {\n\tint xd = data[i][0]-data[j][0];\n\tint yd = data[i][1]-data[j][1];\n\tint rd = data[i][2]+data[j][2];\n\t\n\treturn xd*xd+yd*yd < rd*rd;\n}\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tREP(i, n) {\n\t\t\tREP(j, 4) {\n\t\t\t\tcin >> data[i][j];\n\t\t\t}\n\t\t}\n\n\t\tvector<bool> memo(1<<n, false);\n\t\tmemo[(1<<n)-1] = true;\n\t\tstack<int> S;\n\t\tS.push((1<<n)-1);\n\t\tint ans = 0;\n\t\twhile(!S.empty()) {\n\t\t\tint st = S.top();\n\t\t\tS.pop();\n\t\t\tint nst;\n\n\t\t\tif(st == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tREP(i, n) {\n\t\t\t\tif(!(st&(1<<i))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tREP(k, i) {\n\t\t\t\t\tif(cover(k, i)) {\n\t\t\t\t\t\tgoto nexti;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tREP(j, i) {\n\t\t\t\t\tif(!(st&(1<<j)) || data[i][3] != data[j][3]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tREP(k, j) {\n\t\t\t\t\t\tif((st&(1<<k)) && cover(k, j)) {\n\t\t\t\t\t\t\tgoto nextj;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tnst = st^(1<<i)^(1<<j);\n\t\t\t\t\tif(memo[nst]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmemo[nst] = true;\n\t\t\t\t\tans = max(ans, n-bitnum(nst));\n\t\t\t\t\tS.push(nst);\n\n\t\t\t\t\tnextj:;\n\t\t\t\t}\n\t\t\t\tnexti:;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 30;\nint x[MAXN], y[MAXN], r[MAXN], c[MAXN];\nbool ok[MAXN];\nmap<int, int> dp;\n\nint square(int x) {return x*x;}\n\n// i, j ???????????£?????????????????????\n// ????????£????????? true\nbool check(int i, int j) {\n    int d2 = square(x[i]-x[j]) + square(y[i]-y[j]);\n    return d2 < square(r[i]+r[j]);\n}\n\nint dfs(int state, int n) {\n    int ret = 0;\n    if (dp.find(state) != dp.end()) return dp[state];\n    // ???????????¨??????????????§??????????????????????????????\n    vector<int> already;\n    memset(ok, true, sizeof(ok));\n    for (int i = 0; i < n; i++) {\n        if ((state>>i)&1) continue;\n        if (ok[i]) {\n            already.push_back(i);\n        }\n        for (int j = i+1; j < n; j++) {\n            if (check(i, j)) ok[j] = false;\n        }\n    }\n    int sz = already.size();\n    for (int i = 0; i < sz; i++) {\n        for (int j = i+1; j < sz; j++) {\n            int ai = already[i], aj = already[j];\n            if (c[ai] == c[aj]) {\n                int nstate = state;\n                nstate |= 1<<ai;\n                nstate |= 1<<aj;\n                ret = max(2+dfs(nstate, n), ret);\n            }\n        }\n    }\n    return dp[state] = ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while (cin >> n) {\n        if (n==0) break;\n        for (int i = 0; i < n; i++) cin >> x[i] >> y[i] >> r[i] >> c[i];\n        dp.clear();\n        cout << dfs(0, n) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 24\n\nint N,x[MAX],y[MAX],r[MAX],c[MAX];\n\nint dist(int a,int b){\n    return pow(x[a]-x[b],2)+pow(y[a]-y[b],2);\n}\n\nbool check(int a,int b){\n    double d = dist(a,b);\n    return ((r[a]-r[b])*(r[a]-r[b]) < d &&\n            d < (r[a]+r[b])*(r[a]+r[b]));\n}\n\nbool check(int S,int a,int b){\n    bool c[2] = {};\n    for(int i = 0 ; i < N ; i++){\n        if(!c[0]){\n            if(i == a) c[0] = 1;\n            else if(check(a,i)) return 0;\n        }\n        if(!c[1]){\n            if(i == b) c[1] = 1;\n            else if(check(b,i)) return 0;\n        }\n    }\n    return 1;\n}\n\nint main(){\n    while(cin >> N, N){\n        for(int i = 0 ; i < N ; i++){\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n        vector<short> dp(1<<N,0);\n        for(int i = (1<<N)-1 ; i >= 0 ; i--){\n            for(int j = 0 ; j < N ; j++){\n                for(int k = j+1 ; k < N ; k++){\n                    if(c[j] != c[k]) continue;\n                    int S = i | (1<<j) | (1<<k);\n                    if(!check(i,j,k)) continue;\n                    if(dp[i]+1 > dp[S]){\n                        dp[S] = dp[i]+1;\n                    }\n                }\n            }\n        }\n        cout << *max_element(dp.begin(),dp.end())*2 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint sum=0,ds;\nint n;\nvoid rec(vector<circle> vs){\n  //cout << vs.size() << endl;\n  int i,j,k;\n  int f;\n  int on[30]={};\n  vector<int> cc[5];\n  f=1;\n  int ff=0;\n  while(ff==0){\n    ff=1;\n    for(i=0;i<30;i++) on[i]=0;\n    for(i=0;i<5;i++) cc[i].clear();\n    for(i=0;i<vs.size();i++){\n      for(j=i+1;j<vs.size();j++){\n\tif(ch(vs[i],vs[j])==1) on[j]=1;\n      }\n    }\n    for(i=0;i<vs.size();i++){\n      if(on[i]==0) cc[vs[i].c].push_back(i);\n    }\n    for(i=1;i<5;i++){\n      if(cc[i].size()>0&&cc[i].size()%2==0){\n\tfor(j=cc[i].size()-1;j>=0;j--){\n\t  vs.erase(vs.begin()+cc[i][j]);\n\t  ff=0;\n\t  f=0;\n\t}\n\tbreak;\n      }\n    }\n  }\n  for(i=0;i<30;i++) on[i]=0;\n  for(i=0;i<5;i++) cc[i].clear();\n  for(i=0;i<vs.size();i++){\n    for(j=i+1;j<vs.size();j++){\n      if(ch(vs[i],vs[j])==1) on[j]=1;\n    }\n  }\n  for(i=0;i<vs.size();i++){\n    if(on[i]==0) cc[vs[i].c].push_back(i);\n  }\n  for(i=1;i<5;i++){\n    //cout << cc[i].size() << endl;\n    if(cc[i].size()>=2&&cc[i].size()%2==1){\n      f=0;\n      vector<circle> next(vs);\n      //for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n      for(j=0;j<cc[i].size();j++){\n\tfor(k=cc[i].size()-1;k>=0;k--){\n\t  if(k!=j)\n\t    next.erase(next.begin()+cc[i][k]);\n\t}\n\trec(next);\n      }\n      break;\n    }\n  }\n  \n  int o=n-vs.size();\n  if(f==1) sum=max(sum,o);\n  else{\n    rec(vs);\n  }\n}\n\nint main(){\n  cin >> n;\n  while(n!=0){\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      v.push_back(c);\n    }\n    sum=0;\n    rec(v);\n    cout << sum << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\t#include <iostream>\n\t#include <string.h>\n\t#define HIT(a,b) ((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r))\n\n\tusing namespace std;\n\n\tstruct DISK {\n\t\tint x,y,r,c,f;\n\t};\n\tint n;\n\n\tvoid setontop(DISK *D){\n\t\tint i,j;\n\t\tfor(i=0;i<n;i++){\n\t\t\tD[i].f=D[i].r;\n\t\t\tfor(j=i+1;j<n;j++)\n\t\t\t\tif(D[j].r && HIT(D[i],D[j])) D[i].f=0;\n\t//\t\tprintf(\"ontop%d %d\\n\", i, D[i].f);\n\t\t}\n\t}\n\n\tint solve(DISK *D){\n\t\tint i,j,k,min=30,ret;\n\t\tsetontop(D);\n\t\tfor(i=1;i<=4;i++){\n\t\t\tchar list[6],li=0;\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tif(D[j].f&&D[j].c==i) list[li++]=j;\n\t\t\t}\n\t//\t\tprintf(\"%d %d\\n\",i,li);\n\t\t\tif(li<2)continue;\n\t\t\tDISK tmp[30];\n\t\t\tfor(j=0;j<(li+1)/2;j++){\n\t\t\t\tfor(k=j+1;k<li;k++){\n\t//\t\t\t\tprintf(\"remove(%d,%d)\", list[j],list[k]);\n\t\t\t\t\tmemcpy(tmp,D,sizeof(tmp));\n\t\t\t\t\ttmp[list[j]].r=0;\n\t\t\t\t\ttmp[list[k]].r=0;\n\t\t\t\t\tret=solve(tmp);\n\t\t\t\t\tif(ret<min)min=ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(ret=0,i=0;i<n;i++)if(D[i].r)ret++;\n\t\tif(ret<min)min=ret;\n\t//\tprintf(\"return %d\\n\", min);\n\t\treturn min;\n\t}\n\n\tint main(){\n\t\tint i,j;\n\t\twhile(cin>>n,n){\n\t\t\tDISK D[30];\n\t\t\tfor(i=n;i-->0;) cin>>D[i].x>>D[i].y>>D[i].r>>D[i].c;\n\t\t\tcout<<n-solve(D)<<endl;\n\t\t}\n\t\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <complex>\n\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\ntypedef complex<double> Point;\n\n\nstruct Circle {\n    Point c;\n    double r;\n    int color;\n    Circle(Point c=Point(), double r=0.0,int color=0) :\n        c(c),r(r),color(color){}\n};\ndouble getDistance(Point a,Point b) {\n    return abs(a-b);\n}\n\nbool intersect(Circle c1, Circle c2) {\n    double d=getDistance(c1.c,c2.c);\n    return d<c1.r+c2.r;\n}\nint n;\nbool same_color[30][30];\nbool is_intersect[30][30];\nbool ok(int n,int S) {\n    rep(i,n) {\n        if(!(S>>i&1)&&is_intersect[i][n]) return false;\n    }\n\n    return true;\n}\nshort dp[1<<24];\nint dfs(int S) {\n    if(dp[S]!=-1) return dp[S];\n    int ret=0;\n    rep(i,n) rep(j,n) if(i!=j) {\n        if(((S>>i)&1)) continue;\n        if(((S>>j)&1)) continue;\n        if(!same_color[i][j]) continue;\n        //if(!ok(i,S)) continue;\n        //if(!ok(j,S)) continue;\n        bool ok=true;\n        rep(k,n) {\n            if(((S>>k)&1)) continue;\n            if(k<i&&is_intersect[i][k]) ok=false;\n            if(k<j&&is_intersect[j][k]) ok=false;\n        }\n        if(!ok) continue;\n\n        //printf(\"remove %d %d\\n\",i,j);\n        ret=max(ret,dfs(S|(1<<i)|(1<<j))+2);\n    }\n\n    return dp[S]=ret;\n}\nvoid solve() {\n    memset(dp,-1,sizeof(dp));\n    rep(i,30) rep(j,30) is_intersect[i][j]=false;\n    rep(i,30) rep(j,30) same_color[i][j]=false;\n    vector<Circle> circles;\n    rep(i,n) {\n        double x,y,r;\n        int c;\n        cin>>x>>y>>r>>c;\n        circles.push_back(Circle(Point{x,y},r,c));\n    }\n    rep(i,circles.size()) rep(j,circles.size()) {\n        if(intersect(circles[i],circles[j])) is_intersect[i][j]=true;\n        if(circles[i].color==circles[j].color) same_color[i][j]=true;\n    }\n    cout<<dfs(0)<<endl;\n}\nint main() {\n    while(cin>>n) {\n        if(!n) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n\ntypedef struct {\n\tint x, y, r;\n\tint color;\n}circle_t;\n\nint n;\ncircle_t circle[24];\nint bitDP[(1<<24)]; // ??????????????????bit??§??????\nint overlap[24]; // ?????????????????????bit??§??????\n\nint main()\n{\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcin >> circle[i].x;\n\t\t\tcin >> circle[i].y;\n\t\t\tcin >> circle[i].r;\n\t\t\tcin >> circle[i].color;\n\t\t\t\n\t\t\toverlap[i] = 0;\n\t\t\tfor(int j = 0; j < i; j++) {\n\t\t\t\tint distance_x = circle[i].x - circle[j].x;\n\t\t\t\tint distance_y = circle[i].y - circle[j].y;\n\t\t\t\tdouble distance_circle = sqrt(pow(distance_x, 2) + pow(distance_y, 2));\n\t\t\t\tdouble sum_r = circle[i].r + circle[j].r;\n\t\t\t\tif(sum_r > distance_circle) {\n\t\t\t\t\toverlap[i] += (1 << j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(bitDP, 0, sizeof(bitDP));\n\t\t\n\t\tint ans = 0;\n\t\tfor(int bit = 0; bit < (1 << n); bit++) {\n\t\t\tif(bit != 0 && bitDP[bit] == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tif(((1 << i) & bit)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int j = i+1; j < n; j++) {\n\t\t\t\t\tif(((1 << i) | (1 << j)) & bit) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(!(((overlap[i] & bit) == overlap[i]) && ((overlap[j] & bit) == overlap[j]))) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(circle[i].color == circle[j].color) {\n\t\t\t\t\t\tint next = (((1 << i) | (1 << j)) | bit);\n\t\t\t\t\t\tbitDP[next] = max(bitDP[next], bitDP[bit] + 2);\n\t\t\t\t\t\tans = max(ans, bitDP[next]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint sum=0,ds;\nint n;\nvoid rec(vector<circle> vs){\n  //cout << vs.size() << endl;\n  int i,j,k;\n  int f;\n  int on[100]={};\n  vector<int> cc[5];\n  vector<circle> next;\n  \n  f=1;\n  for(i=0;i<100;i++) on[i]=0;\n  for(i=0;i<vs.size();i++){\n    for(j=i+1;j<vs.size();j++){\n      if(ch(vs[i],vs[j])==1) on[j]=1;\n    }\n  }\n  for(i=0;i<vs.size();i++){\n    if(on[i]==0) cc[vs[i].c].push_back(i);\n  }\n  for(i=1;i<5;i++){\n    //cout << cc[i].size() << endl;\n    if(cc[i].size()>=2){\n      next.clear();\n      for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n      for(j=0;j<cc[i].size();j++){\n\tfor(k=j+1;k<cc[i].size();k++){\n\t  next.erase(next.begin()+cc[i][k]);\n\t  next.erase(next.begin()+cc[i][j]);\n\t  rec(next);\n\t  f=1;\n\t}\n      }\n    }\n  }\n  int o=n-vs.size();\n  if(f==1) sum=max(sum,o);\n}\n\nint main(){\n  cin >> n;\n  while(n!=0){\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    sum=0;\n    rec(v);\n    cout << sum << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Circle {\n    short x;\n    short y;\n    short r;\n    short c;\n};\n\nbool overwrap(const Circle& c1, const Circle& c2)\n{\n    const short d = c1.r + c2.r;\n    const short R = (c1.x - c2.x) * (c1.x - c2.x) + (c1.y - c2.y) * (c1.y - c2.y);\n    return d * d > R;\n}\n\nshort n;\nshort dp(vector<short>& table, const vector<vector<bool>>& wrap, const short state, const vector<Circle>& circle)\n{\n    if (table[state] != -1) {\n        return table[state];\n    } else {\n        vector<short> sub(4, 0);\n        vector<vector<short>> top(4, vector<short>(0));\n        for (short j = 0; j < n; j++) {\n            if (state & (1 << j)) {\n                bool ok = true;\n                for (short i = 0; i < j; i++) {\n                    if (state & (1 << i)) {\n                        if (wrap[i][j]) {\n                            ok = false;\n                            break;\n                        }\n                    }\n                }\n                if (ok) {\n                    sub[circle[j].c] += (1 << j);\n                    top[circle[j].c].push_back(j);\n                }\n            }\n        }\n        for (short i = 0; i < 4; i++) {\n            const short size = top[i].size();\n            if (size <= 1) {\n                continue;\n            }\n            if (size % 2 == 0) {\n                const short val = dp(table, wrap, state - sub[i], circle);\n                table[state] = val + size;\n                return val + size;\n            } else {\n                short maxi = 0;\n                for (short j = 0; j < size; j++) {\n                    const short val = dp(table, wrap, state - sub[i] + (1 << top[i][j]), circle);\n                    maxi = max(maxi, val);\n                }\n                table[state] = maxi + (size / 2 * 2);\n                return maxi + (size / 2 * 2);\n            }\n        }\n        table[state] = 0;\n        return 0;\n    }\n}\n\nint main()\n{\n    while (true) {\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        vector<Circle> circle(n);\n        for (short i = 0; i < n; i++) {\n            short x, y, r;\n            short c;\n            cin >> x >> y >> r >> c;\n            c--;\n            circle[i] = Circle{x, y, r, c};\n        }\n\n        vector<vector<bool>> wrap(n, vector<bool>(n, false));  // j?????????i?????????\n        for (short i = 0; i < n; i++) {\n            for (short j = i + 1; j < n; j++) {\n                wrap[i][j] = overwrap(circle[i], circle[j]);\n            }\n        }\n\n        const short maximum = 1 << n;\n        vector<short> table(maximum, -1);\n        table[0] = 0;\n        cout << dp(table, wrap, maximum - 1, circle) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint sum=0,ds;\nint n;\nvoid rec(vector<circle> vs){\n  //cout << vs.size() << endl;\n  int i,j,k;\n  int f;\n  int on[100]={};\n  vector<int> cc[10];\n  vector<circle> next;\n  \n  f=1;\n  int ff=0;\n  while(ff==0){\n    ff=1;\n    for(i=0;i<100;i++) on[i]=0;\n    for(i=0;i<10;i++) cc[i].clear();\n    for(i=0;i<vs.size();i++){\n      for(j=i+1;j<vs.size();j++){\n\tif(ch(vs[i],vs[j])==1) on[j]=1;\n      }\n    }\n    for(i=0;i<vs.size();i++){\n      if(on[i]==0) cc[vs[i].c].push_back(i);\n    }\n    for(i=1;i<5;i++){\n      if(cc[i].size()>0&&cc[i].size()%2==0){\n\tfor(j=cc[i].size()-1;j>=0;j--){\n\t  vs.erase(vs.begin()+cc[i][j]);\n\t  ff=0;\n\t}\n      }\n    }\n  }\n  for(i=1;i<5;i++){\n    //cout << cc[i].size() << endl;\n    if(cc[i].size()>=2&&cc[i].size()%2==1){\n      f=0;\n      next.clear();\n      for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n      for(j=0;j<cc[i].size();j++){\n\tfor(k=cc[i].size()-1;k>=0;k--){\n\t  if(k!=j)\n\t    next.erase(next.begin()+cc[i][k]);\n\t}\n\trec(next);\n      }\n    }\n  }\n  int o=n-vs.size();\n  if(f==1) sum=max(sum,o);\n  else{\n    next.clear();\n    for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n    rec(next);\n  }\n}\n\nint main(){\n  cin >> n;\n  while(n!=0){\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    sum=0;\n    rec(v);\n    cout << sum << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n\nstruct Disc{\n\tint x,y,r,c;\n\tDisc(int p_x,int p_y,int p_r,int p_c){\n\t\tx=p_x;y=p_y;r=p_r;c=p_c;\n\t}\n\tDisc(){};\n};\n\nint n;\nint memo[1<<24];\nbool exist[24];\nDisc D[24];\nint ans;\nint top_memo[24][1<<24];\n\nbool touch(Disc a,Disc b){\n\treturn (a.r+b.r)*(a.r+b.r)>(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n}\n\nbool top(int k,int bit){\n\tif(top_memo[k][bit]>=0) return top_memo[k][bit]==0;\n\tfor(int i=k-1;i>=0;i--){\n\t\tif(exist[i]){\n\t\t\tif(touch(D[k],D[i])){top_memo[k][bit]=1;return false;}\n\t\t}\n\t}\n\ttop_memo[k][bit]=0;\n\treturn true;\n}\n\nint dfs(int bit,int num){\n\tif(memo[bit]>=0) return memo[bit];\n\tint res=num;\n\n\tfor(int i=0;i<n;i++){\n\t\tif(exist[i] && top(i,bit)){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(exist[j] && top(j,bit) && i!=j && D[i].c==D[j].c){\n\t\t\t\t\texist[i]=false;\n\t\t\t\t\texist[j]=false;\n\t\t\t\t\tres=dfs((bit&(~(1<<i)))&(~(1<<j)),num+2);\n\t\t\t\t\texist[i]=true;\n\t\t\t\t\texist[j]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemo[bit]=res;\n\tans=max(ans,res);\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin>>n && n!=0){\n\t\tans=0;\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tmemset(top_memo,-1,sizeof(top_memo));\n\t\tmemset(exist,true,sizeof(exist));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y,r,c;\n\t\t\tcin>>x>>y>>r>>c;\n\t\tD[i]=Disc(x,y,r,c);\n\t\t}\n\t\tans=0;\n\t\tdfs((1<<24)-1,0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\n\nstruct P {\n\tint x, y, r, c;\n\n\tP() : x(0), y(0), r(0), c(0) {}\n\tP(int x, int y, int r, int c) : x(x), y(y), r(r), c(c) {}\n};\n\nint n, ans;\nvector<P> v;\n\n\nvoid dfs(vector<bool> used) {\n\tbool up[50];\n\tmemset(up, 0, sizeof(up));\n\n\tfor(int i = n-1; i >= 0; i--) {\n\t\tif(used[i]) continue;\n\t\tbool flag = true;\n\t\tfor(int j = i-1; j >= 0; j--) {\n\t\t\tif(used[j]) continue;\n\t\t\tint dist = (v[j].x - v[i].x) * (v[j].x - v[i].x) + (v[j].y - v[i].y) * (v[j].y - v[i].y);\n\t\t\tint len = (v[i].r + v[j].r) * (v[i].r + v[j].r);\n\n\t\t\tif(dist < len) {\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\n\t\tif(!flag) up[i] = true;\n\t}\n\n\tfor(int i = n-1; i >= 0; i--) {\n\t\tif(used[i] || up[i]) continue;\n\n\t\tbool flag = true;\n\n\t\tfor(int j = i-1; j >= 0; j--) {\n\t\t\tif(used[j] || up[j]) continue;\n\n\t\t\tint dist = (v[j].x - v[i].x) * (v[j].x - v[i].x) + (v[j].y - v[i].y) * (v[j].y - v[i].y);\n\t\t\tint len = (v[i].r + v[j].r) * (v[i].r + v[j].r);\n\n\t\t\tif(dist >= len && v[i].c == v[j].c) {\n\t\t\t\tused[i] = true;\n\t\t\t\tused[j] = true;\n\t\t\t\tdfs(used);\n\t\t\t\tused[i] = false;\n\t\t\t\tused[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tint cnt = 0;\n\trep(i, n) {\n\t\tif(used[i]) cnt++;\n\t}\n\n\tans = max(ans, cnt);\n}\n\nint main() {\n\twhile(cin >> n && n) {\n\n\t\tv.clear();\n\n\t\trep(i, n) {\n\t\t\tint x, y, r, c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tv.push_back(P(x, y, r, c));\n\t\t}\n\n\t\tvector<bool> used(n);\n\t\trep(i, n) used[i] = false;\n\n\t\tans = 0;\n\t\tdfs(used);\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\nint n;\nchar dp[1 << 24];\n//char up[24];\n//vector<char> dp, up;\n//vector<Circle> c;\nCircle c[24];\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = (a.r + b.r) * (a.r + b.r);\n    int d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    return r > d;\n}\n\nbool isUp(int s, int v)\n{\n    for (int i = 0; i < v; ++i)\n        if ((s >> i & 1) && isOverlap(c[v], c[i]))\n            return false;\n//            return true;\n//    return false;\n    return true;\n}\n\nint Rec(int s)\n{\n    if (~dp[s])\n        return dp[s];\n\n    int res = 0;\n    // 取り除く2つの円の選択\n    for (int i = 0; i < n; ++i) {\n        // c[i]がないか取り除けない\n        // if (!(s >> i & 1) || isUp(s, i))\n        //     continue;\n        // if (!(s >> i & 1) || s & up[i])\n        //     continue;\n\n        for (int j = i + 1; j < n; ++j) {\n            // c[i]とc[j]の色が異なる\n            // if (c[i].c != c[j].c)\n            //     continue;\n            // c[j]がないか取り除けない\n            // if (!(s >> j & 1) || s & up[j])\n            //     continue;\n            // if (!(s >> j & 1) || isUp(s, j))\n            //     continue;\n            if ((s >> i & 1) && isUp(s, i) && c[i].c == c[j].c\n                && (s >> j & 1) && isUp(s, j))\n//            int nxt = s & ~(1 << i) & ~(1 << j);\n            res = max(res, Rec(s & ~(1 << i) & ~(1 << j)) + 2);\n        }\n    }\n\n    return dp[s] = res;\n}\n\nint main()\n{\n    while (cin >> n, n) {\n        memset(dp, -1, sizeof(dp));\n//        memset(up, 0, sizeof(up));\n//        c.resize(n);\n\n        // 円の入力\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        // // 円の重なり，上下関係\n        // for (int i = 0; i < n; ++i)\n        //     for (int j = i + 1; j < n; ++j)\n        //         if (isOverlap(c[i], c[j]))\n        //             up[j] |= (1 << i);\n\n        cout << Rec((1 << n) - 1) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nusing namespace std;\nint N;\n\nstruct Disk {\n  vector<int> child;\n  vector<int> parent;\n};\n\nstruct TmpDisk {\n  int x, y, r, c;\n  TmpDisk(int x, int y, int r, int c) : x(x), y(y), r(r), c(c) {}\n};\n\nvector<Disk> disk_list;\nvector<TmpDisk> tmp_list;\n\nset<int> top;\n\nvoid init() {\n  disk_list.clear();\n  tmp_list.clear();\n  top.clear();\n  disk_list.resize(N);\n}\n\ndouble dist(int x1, int y1, int x2, int y2) {\n  int dx = x1 - x2;\n  int dy = y1 - y2;\n  return dx * dx + dy * dy;\n}\n\nbool touched(int i, int j) {\n  double d = dist(tmp_list[i].x, tmp_list[i].y, tmp_list[j].x, tmp_list[j].y);\n  double r2 = (tmp_list[i].r + tmp_list[j].r);\n  //printf(\"%d, %d, %lf, %lf\\n\", i, j, d, r2);\n  return d < r2 * r2; \n}\n\nvoid fill_parent(int idx, bool visited[30]) {\n  visited[idx] = true;\n  for (int i = 0; i < disk_list[idx].parent.size(); i++) {\n    fill_parent(disk_list[idx].parent[i], visited);\n  }\n}\n\nvoid make_tree() {\n  bool visited[30];\n  for (int i = 0; i < tmp_list.size(); i++) {\n    fill(visited, visited + 30, false);\n    for (int j = i - 1; j >= 0; j--) {\n      if (!visited[j] && touched(i, j)) {\n        fill_parent(j, visited);\n        disk_list[i].parent.push_back(j);\n        disk_list[j].child.push_back(i);\n      }\n    }\n  }\n}\n\nvoid print_top() {\n  printf(\"print top\\n\");\n  for (set<int>::iterator it = top.begin(); it != top.end(); it++) {\n    printf(\"%d \", *it);\n  }\n  printf(\"\\n\");\n}\n\nint _solve() {\n  int mx = 0;\n  //printf(\"called\\n\");\n  //print_top();\n  vector<pair<int, int> > top_list;\n  for (set<int>::iterator it = top.begin(); it != top.end(); it++) {\n    set<int>::iterator jt = it;\n    jt++;\n    for (; jt != top.end(); jt++) {\n      int n1 = *it;\n      int n2 = *jt;\n      if (tmp_list[n1].c == tmp_list[n2].c) {\n        top_list.push_back(make_pair(n1, n2));\n      }\n    }\n  }\n\n  //printf(\"top_list\\n\");\n  /*\n  for (int i = 0; i < top_list.size(); i++) {\n    printf(\"%d %d \", top_list[i].first, top_list[i].second);\n  }\n  */\n  //printf(\"\\n\");\n  \n  for (int i = 0; i < top_list.size(); i++) {\n    int n1 = top_list[i].first;\n    int n2 = top_list[i].second;\n    //printf(\"pair = %d, %d\\n\", n1, n2);\n\n    top.erase(n1);\n    top.erase(n2);\n    vector<int> added;\n    for (int i = 0; i < disk_list[n1].child.size(); i++) {\n      int ch = disk_list[n1].child[i];\n      if (disk_list[ch].parent.size() <= 1) {\n        top.insert(ch);\n        added.push_back(ch);\n      }\n    }\n    for (int i = 0; i < disk_list[n2].child.size(); i++) {\n      int ch = disk_list[n2].child[i];\n      if (disk_list[ch].parent.size() <= 1) {\n        top.insert(ch);\n        added.push_back(ch);\n      }\n    }\n    mx = max(_solve() + 2, mx);\n    for (int i = 0; i < added.size(); i++) {\n      top.erase(added[i]);\n    }\n    top.insert(n1);\n    top.insert(n2);\n  }\n  return mx;\n}\n\nvoid solve() {\n  /*\n  printf(\"child list\\n\");\n  for (int i = 0; i < N; i++) {\n    printf(\"%d:\", i);\n    for (int j = 0; j < disk_list[i].child.size(); j++) {\n      printf(\"%d \", disk_list[i].child[j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"parent list\\n\");\n  for (int i = 0; i < N; i++) {\n    printf(\"%d:\", i);\n    for (int j = 0; j < disk_list[i].parent.size(); j++) {\n      printf(\"%d \", disk_list[i].parent[j]);\n    }\n    printf(\"\\n\");\n  }\n  */\n  for (int i = 0; i < N; i++) {\n    if (disk_list[i].parent.empty()) {\n      top.insert(i);\n      //printf(\"%d \", i);\n    }\n  }\n  //printf(\"\\n\");\n  int mx = _solve();\n  printf(\"%d\\n\", mx);\n}\n\nint main() {\n  while (true) {\n    scanf(\"%d \", &N);\n    if (N == 0) {return 0;}\n    init();\n    for (int i = 0; i < N; i++) {\n      int x, y, r, c;\n      scanf(\"%d %d %d %d \", &x, &y, &r, &c);\n      tmp_list.push_back(TmpDisk(x, y, r, c));\n    }\n    make_tree();\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\nint N, X[24], Y[24], R[24], C[24];\n\nbool isCoverd(int i, int j)\n{\n  int x = abs((int)(X[i] - X[j])), y = abs((int)(Y[i] - Y[j])), r = R[i] + R[j];\n  return ((x * x) + (y * y)) < (r * r);\n}\n\nbool noCoverd(int j, int s) {\n  for (int i = 0; i < j; i++)\n    if ( (s >> i & 1) && isCoverd(i, j))\n      return false;\n\n  return true;\n}\n\nchar memo[1 << 24];\nint dfs(int s)\n{\n  if (memo[s] != -1)\n    return memo[s];\n  \n  int ans = 0;\n  for (int i = 0; i < N; i++) {\n    for (int j = i + 1; j < N; j++) {\n      if ( (s >> i & 1) && (s >> j & 1)         && // 両方の皿が除去されていない場合\n           noCoverd(i, s) && noCoverd(j, s)     && // 重なっていない\n           C[i] == C[j]\n         ) {\n        ans = max(ans, dfs(s & ~(1 << i) & ~(1 << j)) + 2);\n      }\n    }\n  }\n  \n  return memo[s] = ans;\n}\n\n\nint main()\n{\n  while (cin >> N && N) {\n    for (int i = 0; i < N; i++) \n      cin >> X[i] >> Y[i] >> R[i] >> C[i];\n\n    memset(memo, -1, sizeof(memo));\n\n    cout << dfs((1 << N) - 1) << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint n, x[24], y[24], r[24], c[24], memo[1<<24], d[24][24], cd[4][6], cn[4], mx;\n\nint check(int p) {\n  if (memo[p] != -1) return memo[p];\n  int ans = 0, temp[6], tn;\n  for (int i = 0; i < 4; i++) {\n    tn = 0;\n    for (int j = 0; j < cn[i]; j++) {\n      int num = cd[i][j];\n      if (p & (1 << num)) continue;\n      bool flag = true;\n      for (int k = 0; k < num; k++) if (d[num][k] && !(p & (1 << k))) { flag = false; break; }\n      if (flag) temp[tn++] = num;\n    }\n    for (int j = 0; j < tn; j++) for (int k = j+1; k < tn; k++) {\n      ans = max(ans, 2 + check(p | (1 << temp[j]) | (1 << temp[k])));\n      if (ans == mx) return ans;\n    }\n  }\n  return memo[p] = ans;\n}\n\nint main() {\n  while (scanf(\"%d\", &n), n) {\n    mx = (n / 2) * 2;\n    for (int i = 0; i < 4; i++) cn[i] = 0;\n    for (int i = 0; i < n; i++) {\n      scanf(\"%d%d%d%d\", &x[i], &y[i], &r[i], &c[i]);\n      c[i]--;\n      cd[c[i]][cn[c[i]]++] = i;\n    }\n    for (int i = 0; i < 4; i++) sort(cd[i], cd[i] + cn[i]);\n    for (int i = 0; i < (1<<n); i++) memo[i] = -1;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < i; j++) {\n        int xy2 = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n        int r2 = (r[i] + r[j]) * (r[i] + r[j]);\n        if (xy2 < r2) d[i][j] = 1;\n        else d[i][j] = 0;\n      }\n    }\n    printf(\"%d\\n\", check(0));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing ll = long long;\nconst char newl = '\\n';\n#define var auto\n\nvector< ll > xs, ys, rs, cs;\nint dp[1 << 24];\n\nbool is_top(int k, int bit) {\n  auto pow2 = [](ll a) {\n    return a * a;\n  };\n  for (int i = 0; i < k; i += 1) {\n    if (bit & (1 << i)) continue;\n    if (pow2(rs[i] + rs[k]) > pow2(xs[i] - xs[k]) + pow2(ys[i] - ys[k])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nint dfs(int n, int bit) {\n  int &res = dp[bit];\n\n  if (~res) return res;\n  res = 0;\n\n  for (int i = 0; i < n; i += 1) {\n    if (bit & (1 << i)) continue;\n    if (!is_top(i, bit)) continue;\n\n    for (int j = 0; j < i; j += 1) {\n      if (bit & (1 << j)) continue;\n      if (!is_top(j, bit)) continue;\n      if (cs[i] != cs[j]) continue;\n\n      chmax(res, dfs(n, bit | (1 << i) | (1 << j)) + 2);\n    }\n  }\n\n  return res;\n}\n\nvoid solver(int n) {\n  xs = ys = rs = cs = vector< ll >(n);\n\n  for (int i = 0; i < n; i += 1) {\n    cin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n  }\n\n  memset(dp, -1, sizeof(dp));\n  cout << dfs(n, 0) << endl;\n}\n\nsigned main(){\n  int n;\n  \n  while (cin >> n, n) {\n    solver(n);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n;i++){\n        if(((bit>>i)&1)==0||ok(i,bit)==false)continue;\n        for(int j=i+1;j<n;j++){\n            if(c[i]!=c[j]||((bit>>j)&1)==0)continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(ok(j,bit)&&!memo[to_bit]){\n                ret=max(ret,dfs(to_bit));\n            }\n        }\n    }\n\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\n\n\nint main(){\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint n;\nVI xs, ys, rs, cs;\nVI memo;\nVVI grp;\n\nbool is_top(int i, int used) {\n\tfor (int j = i - 1; j >= 0; j--) {\n\t\tif (1 << j & used) continue;\n\n\t\tint x = (xs[i] - xs[j]) * (xs[i] - xs[j]);\n\t\tint y = (ys[i] - ys[j]) * (ys[i] - ys[j]);\n\t\tint dis = x + y;\n\t\tint dis2 = (rs[i] + rs[j]) * (rs[i] + rs[j]);\n\n\t\tif (dis < dis2) {\t// 重なってる\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint dfs(int used) {\n\tint sum = 0;\n\n\tif (memo[used] != -1) return memo[used];\n\n\tfor(int i = 0;i < n;i++) {\n\t\tfor (auto j : grp[cs[i]]) {\n\t\t\tif(i == j || (1 << i & used) || (1 << j & used)) continue;\n\t\t\tif(cs[i] != cs[j]) continue;\n\t\t\tif(!is_top(i, used) || !is_top(j, used)) continue;\n\n\t\t\tint used_tmp = used;\n\t\t\tused_tmp |= 1 << i;\n\t\t\tused_tmp |= 1 << j;\n\n\t\t\tsum = max(sum, dfs(used_tmp) + 2);\n\t\t}\n\t}\n\n\treturn memo[used] = sum;\n}\n\nint main(void) {\n\twhile(cin >> n, n){\n\t\txs = VI(n);\n\t\tys = VI(n);\n\t\trs = VI(n);\n\t\tcs = VI(n);\n\t\tgrp = VVI(4);\n\t\tint used = 0;\n\t\tmemo = VI(1 << n, -1);\n\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n\t\t\tcs[i]--;\n\t\t\tgrp[cs[i]].push_back(i);\n\t\t}\n\n\t\tcout << dfs(used) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nstruct Data\n{\n    int x;\n    int y;\n    int r;\n    int c;\n};\n\ntypedef struct Data D;\n\nint solve(vector<D> input)\n{\n    int ans = 0;\n    int colornum[5] = {};\n    int n = input.size();\n    cout << \"ho\" << n << endl;\n    for(int i = 0; i < n; i++){\n        bool notcovered = true;\n        cout << i << \" : \" << input[i].x << \" \" << input[i].y << \" \" << input[i].r << \" \" << input[i].c << endl;\n        for(int j = 0; j < i; j++){\n            cout << i << \",\" << j << \":\" << pow(input[i].x - input[j].x, 2) + pow(input[i].y - input[j].y, 2) << \" \" << pow(input[i].r + input[j].r, 2) << endl;\n            if(pow(input[i].x - input[j].x, 2) + pow(input[i].y - input[j].y, 2) < pow(input[i].r + input[j].r, 2)){\n                notcovered = false;\n                break;\n            }\n        }\n        if(notcovered) colornum[input[i].c]++;\n    }\n    for(int i = 1; i < 5; i++){\n        if(colornum[i] == 2){\n            vector<D> newinput;\n            for(int j = 0; j < n; j++){\n                if(input[j].c != i) newinput.push_back(input[j]);\n            }\n            ans = max(ans, solve(newinput) + colornum[i]);\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        vector<D> input;\n        for(int i = 0; i < n; i++){\n            D tmpd;\n            cin >> tmpd.x >> tmpd.y >> tmpd.r >> tmpd.c;\n            input.push_back(tmpd);\n        }\n        cout << solve(input) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(long long i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\nDef inf=1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,out;\nvi used;\nvvi in;\nvoid dfs(int a){\n    out=max(out,a);\n    rep(i,n)if(used[i]==0)loop(j,i+1,n)if(used[j]==0&&in[i][3]==in[j][3]){\n        bool h=true;\n        rep(k,i)if(used[k]==0){\n            if((in[i][0]-in[k][0])*(in[i][0]-in[k][0])+\n            (in[i][1]-in[k][1])*(in[i][1]-in[k][1])>=\n            (in[i][2]+in[k][2])*(in[i][2]+in[k][2]));\n            else\n                h=false;\n        }\n        rep(k,j)if(used[k]==0){\n            if((in[j][0]-in[k][0])*(in[j][0]-in[k][0])+\n            (in[j][1]-in[k][1])*(in[j][1]-in[k][1])>=\n            (in[j][2]+in[k][2])*(in[j][2]+in[k][2]));\n            else\n                h=false;\n        }\n        if(!h)continue;\n        used[i]=used[j]=1;\n        dfs(a+2);\n        used[i]=used[j]=0;\n        break;\n    }\n}\nint main(){\n    while(cin>>n,n){\n        used=vi(n);\n        in=vvi(n,vi(4));\n        rep(i,n)rep(j,4)cin>>in[i][j];\n        out=0;\n        dfs(0);\n        cout<<out<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circ{\n  vector<int> chil;\n  int useless;\n  bool done;\n};\nvoid Init();\nvoid Tree();\nint Solve();\ncirc BO[50];\ndouble P[50][3];\nchar dp[(1<<24)];\nvector< vector<int> > color(4);\nint n;\nint main(){\n  while(cin >>n,n){\n    Init();\n    for(int i=0,c; i<n; i++){\n      cin >>P[i][0]>>P[i][1]>>P[i][2]>>c;\n      color[c-1].push_back(i);\n    }\n    Tree();\n    cout <<Solve()<<endl;\n  }\n  return 0;\n}\nvoid Init(){\n  for(int i=0; i<4; i++) color[i].clear();\n  for(int i=0; i<(1<<24); i++) dp[i] = -1;\n  for(int i=0; i<50; i++){\n    BO[i].done = false;\n    BO[i].useless = 0;\n    BO[i].chil.clear();\n    P[i][0] = P[i][1] = P[i][2] = 0;\n  }\n}\nvoid Tree(){\n  for(int i=0; i<n; i++){\n    for(int j=i+1; j<n; j++){\n      double dx = P[i][0]-P[j][0];\n      double dy = P[i][1]-P[j][1];\n      double rr = P[i][2]+P[j][2];\n      if(dx*dx+dy*dy<rr*rr){\n    BO[i].chil.push_back(j);\n    BO[j].useless++;\n      }\n    }\n  }\n}\nint Solve(){\n  int ans = 0,A=0;\n  for(int i=0; i<n; i++) if(BO[i].done) A|=(1<<i);\n  if(dp[A] != -1) return (int)dp[A];\n  for(int i=0; i<4; i++){\n    for(int ii=0; ii<color[i].size(); ii++){\n      for(int jj=ii+1; jj<color[i].size(); jj++){\n    int a = color[i][ii];\n    int b = color[i][jj];\n    if(BO[a].useless || BO[b].useless) continue;\n    if(BO[a].done || BO[b].done) continue;\n    BO[a].done = BO[b].done = true;\n    for(int j=0; j<BO[a].chil.size(); j++) BO[BO[a].chil[j]].useless--;\n    for(int j=0; j<BO[b].chil.size(); j++) BO[BO[b].chil[j]].useless--;\n    int ANS = Solve()+2;\n    if(ans<ANS) ans = ANS;\n    BO[a].done = BO[b].done = false;\n    for(int j=0; j<BO[a].chil.size(); j++) BO[BO[a].chil[j]].useless++;\n    for(int j=0; j<BO[b].chil.size(); j++) BO[BO[b].chil[j]].useless++;\n      }\n    }\n  }\n  dp[A] = (char)ans;\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define N 24\n\nchar d[1<<N];\nint x[N],y[N],r[N],c[N];\nint n;\nint over[N];\n\nbool pailed(int a,int b){\n  int d2 = (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);\n  int r2 = (r[a]+r[b])*(r[a]+r[b]);\n  return d2 < r2;\n}\n\nint dfs(int i){\n  if(d[i]!=-1) return d[i];\n  d[i] = 0;\n  for(int j=0;j<n-1;j++){\n    //jがないorjの上に円盤がある\n    if(!(i>>j&1)||over[j]&i) continue;\n    for(int k=j+1;k<n;k++){\n      //kがないorkの上に円盤があるor色が違う\n      if(!(i>>k&1)||over[k]&i||c[k]!=c[j]) continue;\n      d[i] = max( (int)d[i],2 + dfs((~(1<<j))&(~(1<<k))&i) );\n    }\n  }\n  return d[i];\n}\n\nint main(){\n  while(cin >> n,n){\n    fill(over,over+n,0);\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n    }\n    for(int i=n-1;i>=0;i--){\n      for(int j=i-1;j>=0;j--){\n        if(pailed(i,j)){\n          over[i] |= 1<<j;\n        }\n      }\n    }\n\n    fill(d,d+(1<<n),-1);\n    cout << (int)dfs((1<<n)-1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define pb push_back\nusing namespace std;\n\nint n;\nint x[30], y[30], r[30], c[30];\nbool used[30];\nvector<int> G[30];\nmap<int,int> m;\n\nint dfs(int f){\n\tint ret = 0;\n\tif(m[f]) return m[f];\n\trep(i,n){\n\t\tif(used[i])continue;\n\t\tused[i] = true;\n\t\tbool yes = true;\n\t\trep(j,G[i].size()){\n\t\t\tif(!used[G[i][j]]){\n\t\t\t\tyes = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(yes){\n\t\t\tfor(int j = i+1; j < n; j++){\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tif(c[i] != c[j]) continue;\n\t\t\t\t\n\t\t\t\tused[j] = true;\n\t\t\t\tbool no = false;\n\t\t\t\trep(k,G[j].size()){\n\t\t\t\t\tif(G[j][k] == i){\n\t\t\t\t\t\tno = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(!used[G[j][k]]){\n\t\t\t\t\t\tno = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!no){\n\t\t\t\t\tret = max(ret,dfs(f+(1<<i)+(1<<j))+2);\n\t\t\t\t}\n\t\t\t\tused[j] = false;\n\t\t\t}\n\t\t}\n\t\tused[i] = false;\n\t}\n\tm[f] = ret;\n\treturn ret;\n}\n\nint main(){\n\twhile(scanf(\"%d\",&n),n){\n\t\tmemset(used,0,sizeof(used));\n\t\tm.clear();\n\t\trep(i,30) G[i].clear();\n\t\trep(i,n) scanf(\"%d%d%d%d\",x+i,y+i,r+i,c+i);\n\t\trep(i,n) for(int j = i+1; j < n; j++){\n\t\t\tif((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])<(r[i]+r[j])*(r[i]+r[j])){\n\t\t\t\tG[j].pb(i);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dfs(0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nint N, X[24], Y[24], R[24], C[24];\n\nbool isCoverd(int i, int j)\n{\n  int x = abs(X[i] - X[j]), y = abs(Y[i] - Y[j]), r = R[i] + R[j];\n  return ((x * x) + (y * y)) < (r * r);\n}\n\nbool noCoverd(int j, int s) {\n  for (int i = 0; i < j; i++)\n    if ( (s >> i & 1) && isCoverd(i, j))\n      return false;\n\n  return true;\n}\n\nchar memo[1 << 26];\nint dfs(int s)\n{\n  if (memo[s] != -1) {\n    return memo[s];\n  }\n  \n  int ans = 0;\n  for (int i = 0; i < N; i++) {\n    for (int j = i + 1; j < N; j++) {\n      if ( C[i] == C[j] && (s >> i & 1) && (s >> j & 1) &&\n           noCoverd(i, s) && noCoverd(j, s) ) {\n        ans = max(ans, dfs(s & ~(1 << i) & ~(1 << j)) + 2);\n      }\n    }\n  }\n  \n  return memo[s] = ans;\n}\n\n\nint main()\n{\n  while (cin >> N && N) {\n    for (int i = 0; i < N; i++) \n      cin >> X[i] >> Y[i] >> R[i] >> C[i];\n\n    memset(memo, -1, sizeof(memo));\n\n    cout << dfs((1 << N) - 1) << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvl = vector<vector<ll>>;\n\ndouble eps = 0.00001;\nusing p2 = complex<double>;\n\ndouble det(p2 v1, p2 v2) {\n  return v1.real() * v2.imag() - v1.imag() * v2.real();\n}\n\ndouble dot(p2 v1, p2 v2) {\n  return v1.real() * v2.real() + v1.imag() * v2.imag();\n}\n\nbool same(double x, double y) { return fabs(x - y) < eps; }\n\ndouble dist2(p2 l1, p2 l2) { return dot(l1 - l2, l1 - l2); }\n\nstruct Line {\n  p2 st, ed;\n  Line(p2 st, p2 ed) : st(st), ed(ed) {}\n  double dist() { return sqrt(dist2(st, ed)); }\n  double isPalla(Line l) { return fabs(det(ed - st, l.ed - l.st)) < eps; }\n  double x() { return ed.real() - st.real(); }\n  double y() { return ed.imag() - st.imag(); }\n};\n\nstruct Circle {\n  p2 p;\n  double r;\n  int col;\n  Circle(p2 p, double r, int col) : p(p), r(r), col(col) {}\n  bool include(p2 l) { return dist2(p, l) < r * r + eps; }\n  bool include(Circle c) { return sqrt(dist2(p, c.p)) < r + c.r - eps; }\n};\n\nvector<Circle> cs;\nint ans = 0;\nint n;\nbool vis[1LL << 24] = {0};\n\nvoid dfs(ll bit) {\n  if (vis[bit])\n    return;\n  vis[bit] = true;\n  int c = 0;\n  vector<bool> used(n), ok(n);\n  for (int i = 0; i < n; i++) {\n    used[i] = (bit & (1LL << i)) > 0;\n    ok[i] = !used[i];\n    if (used[i])\n      c++;\n  }\n  ans = max(ans, c);\n  for (int i = 0; i < n; i++) {\n    if (used[i])\n      continue;\n    for (int j = 0; j < i; j++) {\n      if (!used[j] && cs[i].include(cs[j])) {\n        ok[i] = false;\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (!ok[i])\n      continue;\n    for (int j = i + 1; j < n; j++) {\n      if (!ok[j] || cs[i].col != cs[j].col)\n        continue;\n      dfs(bit ^ (1LL << i) ^ (1LL << j));\n    }\n  }\n}\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0)\n      break;\n    cs.clear();\n    ans = 0;\n    for (int i = 0; i < (1LL << n); i++)\n      vis[i] = false;\n    for (int i = 0; i < n; i++) {\n      double x, y, r;\n      int c;\n      cin >> x >> y >> r >> c;\n      cs.emplace_back(p2(x, y), r, c);\n    }\n    dfs(0LL);\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n#define For(i,a,b)  for(int i = a;i < b;i++)\n#define rep(i,n)\tFor(i,0,n)\n#define all(n)\t\tn.begin(),n.end()\n\n//(x + a)^2 + (y + b)^2 <= c\n\nstruct Circle{\n\tint x, y, r;\n\tint c;\n\tCircle(){};\n\tCircle(int x, int y, int r, int c) :x(x), y(y), r(r), c(c){}\n\tint inter(Circle cl){\n\t\tint tx = cl.x, ty = cl.y;\n\t\tint t = (x - tx)*(x - tx) + (y - ty)*(y - ty);\n\t\tint R = (r + cl.r)*(r + cl.r);\n\t\tif (t < R)return 1;\n\t\tif (t >= R)return 0;\n\t}\n};\n\nint n;\n\nint dfs(vector<Circle> v){\n\n\tvector<int> tv[5];\n\trep(i, v.size()){\n\t\tbool tf = true;\n\t\tFor(j,i+1, v.size()){\n\t\t\tif (v[i].inter(v[j]) == 1){\n\t\t\t\ttf = false;\n\t\t\t}\n\t\t}\n\t\tif (tf){\n\t\t\ttv[v[i].c].push_back(i);\n\t\t}\n\t}\n\n\tint ret = 0;\n\tbool f = false;\n\n\trep(i, 5){\n\t\tif (tv[i].size() >= 2){\n\t\t\trep(j, tv[i].size()){\n\t\t\t\tFor(k, j + 1, tv[i].size()){\n\t\t\t\t\tvector<Circle> tmpv;\n\n\t\t\t\t\trep(l, v.size()){\n\t\t\t\t\t\tif (tv[i][j] != l && tv[i][k] != l)\n\t\t\t\t\t\ttmpv.push_back(v[l]);\n\t\t\t\t\t}\n\n\t\t\t\t\tret = max(ret, dfs(tmpv));\n\t\t\t\t}\n\t\t\t}\n\t\t\tf = true;\n\t\t}\n\t}\n\n\tif (!f){\n\t\treturn n - v.size();\n\t}\n\t\n\treturn ret;\n}\n\n\nint main()\n{\n\n\twhile (cin >> n && n){\n\n\t\tvector<Circle> v;\n\t\trep(i, n){\n\t\t\tint x, y, r, c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tv.push_back(Circle(x, y, r, c));\n\t\t}\n\n\t\treverse(all(v));\n\n\t\tcout << dfs(v) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint t[(1<<24)];\nint n,x[25],y[25],r[25],c[25],visited[25];\nvector<int> G[25];\nint dist(int a,int b){return (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);}\n/*\nvoid rec(int pos,int prev){\n  visited[pos]=true;\n  G[prev].push_back(pos);\n  for(int i=1;i<=n;i++){\n    if(visited[i])continue;\n    bool flg=true;\n    for(int j=pos-1;j>=1;j--)\n      if(dist(i,j)<(r[i]+r[j])*(r[i]+r[j]))flg=false;\n    if(flg)rec(i,pos);\n  }\n}\n\nvoid init(){\n  for(int i=0;i<25;i++){\n    G[i].clear();\n    visited[i]=false;\n  }\n}\n*/\nint main(){\n  return 0;\n  /*\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    for(int i=1;i<=n;i++)\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n    for(int i=1;i<=n;i++){\n      if(visited[i])continue;\n      rec(i,0);\n    }\n    \n  }\n  */\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint N, X[24], Y[24], R[24], C[24];\nint r[24], m[24];\nchar dp[16777216];\n\nbool f(char n, int s) { return ((s & m[n]) & r[n]) == 0; }\n\nchar dfs(int s, char n) {\n  if(dp[s] >= 0) return dp[s];\n  if(n == N) return N;\n\n  char ret = n;\n  REP(i, 0, N) {\n    if(s & (1 << i)) continue;\n    REP(j, i + 1, N) {\n      if(s & (1 << j)) continue;\n      if(C[i] != C[j]) continue;\n      if(!f(i, s) || !f(j, s)) continue;\n      ret = max(ret, dfs(s | (1 << i) | (1 << j), n + 2));\n    }\n  }\n\n  return dp[s] = ret;\n}\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> X[i] >> Y[i] >> R[i] >> C[i];\n    REP(i, 0, pow(2, N)) dp[i] = -1;\n    REP(i, 0, N) REP(j, 0, N)\n      if(pow(R[i] + R[j], 2) > pow(X[i] - X[j], 2) + pow(Y[i] - Y[j], 2))\n        r[i] = r[i] | (1 << j);\n    m[0] = 1;\n    REP(i, 1, N) m[i] = m[i - 1] | (1 << i);\n    cout << (int) dfs(0, 0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,b,e) for(int i=(b);i<(e);++i)\n#define rep(i,e) for(int i=0;i<(e);++i)\n\nbool intersect(int x1, int y1, int r1, int x2, int y2, int r2){\n  return pow(r1+r2, 2) > pow(x1-x2, 2)+pow(y1-y2, 2);\n}\n\nint main() {\n  int n;\n  while(cin >> n){\n    if(n==0) return 0;\n\n    vector<int> x(n), y(n), r(n), c(n), on(n, 0);\n\n    rep(i, n){\n      int xt, yt, rt, ct;\n      cin >> xt >> yt >> rt >> ct;\n      x[i]=xt, y[i]=yt, r[i]=rt, c[i]=ct;\n      rep(j, i) if(intersect(xt, yt, rt, x[j], y[j], r[j])) on[i] |= (1<<j);\n    }\n\n    vector<int> dp(1<<n, -1);\n    dp[0] = 0;\n    int ans = 0;\n\n    rep(i, 1<<n){\n      if(dp[i]==-1) continue;\n      ans = max(ans, dp[i]);\n\n      rep(j, n-1){\n        if((i&(1<<j))!=0 || (i&on[j])!=on[j]) continue;\n        REP(k, j+1, n){\n          if((i&(1<<k))!=0 || (i&on[k])!=on[k] || c[j]!=c[k]) continue;\n          int next = (i|(1<<j))|(1<<k);\n          dp[next] = max(dp[next], dp[i]+2);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n \nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n \nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\n\nmap<int,int> m;\n\nint n,d[30][30],abosum[30],ans;\nbool abo[30][30],exist[30];\n\nint check(bool tmp[30]){\n\tint ret = 0,bit = 1;\n\tfor(int i = 1;i <= n;i++){\n\t\tif(tmp[i] == true){\n\t\t\tret += bit;\n\t\t}\n\t\tbit *= 2;\n\t}\n\treturn ret;\n}\n\nvoid solve(int tmpans,bool texist[30],int tabosum[30]){\n\tans = max(ans,tmpans);\n\tint bit = check(texist);\n\tauto itr = m.find(bit);\n\tif(itr != m.end()) return;\n\tm[bit] = 1;\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = i+1;j <= n;j++){\n\t\t\tif(texist[i] == false || texist[j] == false)continue;\n\t\t\tif(tabosum[i] != 0 || tabosum[j] != 0) continue;\n\t\t\tif(d[i][3] != d[j][3]) continue;\n\t\t\ttexist[i] = false; texist[j] = false;\n\t\t\tbit = check(texist);\n\t\t\tauto itr = m.find(bit);\n\t\t\tif(itr != m.end()) continue;\n\t\t\ttexist[i] = true; texist[j] = true;\n\t\t\tbool tmpexist[30];\n\t\t\tfor(int k = 1;k <= n;k++){\n\t\t\t\ttmpexist[k] = texist[k];\n\t\t\t\tif(k == i || k == j) tmpexist[k] = false;\n\t\t\t}\n\t\t\tint tmpabosum[30];\n\t\t\tfor(int k = 1;k <= n;k++){\n\t\t\t\ttmpabosum[k] = tabosum[k];\n\t\t\t\tif( abo[i][k] == true && i < k )tmpabosum[k]--;\n\t\t\t\tif( abo[j][k] == true && j < k )tmpabosum[k]--;\n\t\t\t}\n\t\t\tsolve(tmpans+2,tmpexist,tmpabosum);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0)break;\n\t\tans = 0;\n\t\tm.clear();\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tabo[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\texist[i] = true;\n\t\t\tabosum[i] = 0;\n\t\t\tfor(int j = 0;j < 4;j++){\n\t\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\t\t//cin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = i+1;j <= n;j++){\n\t\t\t\tif(  (d[i][0]-d[j][0])*(d[i][0]-d[j][0]) + (d[i][1]-d[j][1])*(d[i][1]-d[j][1]) < (d[i][2]+d[j][2])*(d[i][2]+d[j][2])    ){\n\t\t\t\t\tabo[i][j] = true; abo[j][i] = true;\n\t\t\t\t\tabosum[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve(0,exist,abosum);\n\t//\tfor(int i = 1;i <= n;i++) cout << \"abo\" << i << \" \" << abosum[i] << endl;\n/*\n\t\tbool flag = true;\n\t\twhile(flag == true){\n\t\t\tflag = false;\n\t\t\tfor(int i = 1;i <= n;i++){\n\t\t\t\tfor(int j = i+1;j <= n;j++){\n\t\t\t\t\tif(exist[i] == false || exist[j] == false)continue;\n\t\t\t\t\tif(abosum[i] != 0 || abosum[j] != 0) continue;\n\t\t\t\t\tif(d[i][3] != d[j][3]) continue;\n\t\t\t\t\tans += 2;\n\t\t\t\t\texist[i] = false; exist[j] = false;\n\t\t\t\t\tflag = true;\n\t\t\t\t\tfor(int k = i+1;k <= n;k++){\n\t\t\t\t\t\tif(abo[i][k] == true){\n\t\t\t\t\t\t\tabosum[k]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = j+1;k <= n;k++){\n\t\t\t\t\t\tif(abo[j][k] == true){\n\t\t\t\t\t\t\tabosum[k]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  while(1){\n    int n;\n    cin >> n;\n    if(n==0) return 0;\n    vector<int> x(n),y(n),r(n),c(n);\n    for(int i=0;i<n;i++){\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n    vector<list<int>> ue(n);\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n        if((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])<(r[i]+r[j])*(r[i]+r[j])){\n          ue[j].push_back(i);\n        }\n      }\n    }\n    queue<int> bfs;\n    bfs.push(0);\n    vector<bool> ok(1<<n,false);\n    ok[0]=true;\n    int now;\n    vector<int> can;\n    while(!bfs.empty()){\n      now=bfs.front();\n      bfs.pop();\n      can={};\n      // cout << now << endl;\n      for(int i=0;i<n;i++){\n        if(!(now&(1<<i))){\n          for(auto j:ue[i]){\n            if(now&(1<<j)){\n              goto next;\n            }\n          }\n          can.push_back(i);\n          next:\n          continue;\n        }\n      }\n      for(int i=0;i<can.size();i++){\n        for(int j=i+1;j<can.size();j++){\n          if(c[i]==c[j]){\n            if(!ok[now|(1<<i)|(1<<j)]){\n              ok[now|(1<<i)|(1<<j)]=true;\n              bfs.push(now|(1<<i)|(1<<j));\n            }\n          }\n        }\n      }\n    }\n    int ans=0,k,tmp;\n    for(int i=0;i<(1<<n);i++){\n      if(ok[i]){\n        k=i,tmp=0;\n        while(k){\n          if(k%2) tmp++;\n          k/=2;\n        }\n        ans=max(ans,tmp);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = a.r * a.r + 2 * a.r * b.r + b.r * b.r;\n    return r > (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\nint main()\n{\n    int n;\n\n    while (cin >> n, n) {\n        const int N = 1 << n;\n        vector<char> dp(N, -1), up(n, 0);\n        vector<Circle> c(n);\n\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j) {\n                if (isOverlap(c[i], c[j])) {\n                    if (i < j) // jの上にiがある\n                        up[j] |= (1 << i);\n                    else // iの上にjがある\n                        up[i] |= (1 << j);\n                }\n            }\n\n        int res = 0;\n        dp[N - 1] = 0;\n        for (int s = N - 1; s >= 0; --s) {\n            if (dp[s] == -1)\n                continue;\n\n            res = max(res, (int)dp[s]);\n            for (int i = 0; i < n; ++i) {\n                if (!(s >> i & 1) || (s & up[i])) // c[i]が置かれていないかc[i]が取り除けない\n                    continue;\n\n                for (int j = i + 1; j < n; ++j) {\n                    if (c[i].c != c[j].c) // 色が異なる\n                        continue;\n                    if (!(s >> j & 1) || (s & up[j]))// c[j]が置かれていないかc[j]が取り除けない\n                        continue;\n\n                    int nxt = s & (~(1 << i)) & (~(1 << j));\n                    dp[nxt] = max((int)dp[nxt], dp[s] + 2);\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#define DEBUG false\n\nusing namespace std;\n#define UI unsigned int\n\nstruct P {\n  //  complex<int> p;\n  complex<double> p;\n  int r,c;\n  bool f; // ±Ì~ÕªêÔãÌê\n};\n\nbool isPile( P p, P q ){ // pÆqªdÈÁÄ¢éêtrue\n  return ( abs(p.p-q.p) < p.r+q.r );\n}\nvoid pr( P p ){\n  cout << p.p << \" \"<<p.r<<\" \"<<p.c<<\" \" ;\n  if( p.f ) cout << \"true\" << endl;\n  else      cout << \"false\"<< endl;\n}\n\nint main(){\n  int n;\n  vector<P> v,w;\n  stack< vector<P> > st;\n  P p,q;\n\n  while( cin>>n && n ){\n    if( DEBUG )\n      cout << \"n=\" << n << \" ************************\" <<endl;\n    v.clear();\n    for( int i=0;i<n;i++ ){\n      cin >> p.p.real() >> p.p.imag() >> p.r >> p.c;\n      p.f = true;\n      v.push_back( p );\n    }\n    for( UI i=0;i<v.size();i++ )\n      for( UI j=i+1;j<v.size();j++ )\n\tif( isPile( v[i],v[j] ) ) v[j].f=false;\n\n    while( !st.empty() ) st.pop();\n    st.push( v );\n    int mn = n; // Å¬Ì~Õ\n    bool f;\n    while( !st.empty() ){\n      v = st.top(); st.pop();\n      f = true;\n      for( UI i=0;i<v.size();i++ ){\n\tif( !v[i].f ) continue;\n\tfor( UI j=i+1;j<v.size();j++ ){\n\t  if( !v[j].f ) continue;\n\t  if( v[i].c!=v[j].c ) continue;\n\n\t  // v[i],v[j] ª~ÕÌgbv( p.f=false )Ìê\n\t  w = v;\n\t  if( DEBUG ){\n\t    cout << \"erase : \"; pr( v[i] );\n\t    cout << \"erase : \"; pr( v[j] );\n\t  }\n\t  w.erase( w.begin()+j );\n\t  w.erase( w.begin()+i );\n\n\t  for( UI k=i;k<w.size();k++ ) w[k].f = true;\n\t  for( UI k=0;k<w.size();k++ )\n\t    for( UI l=k+1;l<w.size();l++ )\n\t      if( isPile( w[k],w[l] ) ) w[l].f = false;\n\t  st.push( w ); f=false;\n\t}\n      }\n      if( f ){\n\tmn = min( mn,(int)v.size() );\n\tif( mn==n ) break;\n\tif( DEBUG ){\n\t  cout << \"mn=\" << mn << endl;\n\t  for( UI i=0;i<v.size();i++ ){\n\t    cout << i <<\"\\t\"; pr( v[i] );\n\t  }\n\t}\n      }\n    }\n    cout << n-mn << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//線分を表す構造体\nstruct Segment{ Point p1, p2; };\n//直線を表す構造体\ntypedef Segment Line;\n//多角形を表す構造体\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// 許容する誤差\n#define EPS (1e-10)\n\n// ベクトルaの絶対値を求める\n//double length = abs(a);\n\n// 2点a,b間の距離を求める\n//double distance = abs(a-b);\n\n/*\n// ベクトルaの単位ベクトルを求める\nPoint b = a / abs(a);\n\n// ベクトルaの法線ベクトルn1,n2を求める\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 点cが直線a,b上にあるかないか\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// 点a,bを通る直線と点cとの距離\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// 線分s1と線分s2の距離\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// 線分sに対する点pの射影\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//線分sを対象軸とした点pの線対称の点\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//点pをangle分だけ時計回りに回転\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//円cと線分lの交点\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//点の内包\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//ベクトルの位置検出\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//凸包\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISEだと内角は180以下（一直線上に並んでいても、頂点として数える）\n        //!= CLOCKWISEだと内角は180未満（一直線上の頂点は数えない）\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //ここも == と != を変更する\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //最も下にある点の中で最も右にある点から反時計回りに並び替え\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//キャリパー法を用いて凸多角形の直径を求める\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//凸多角形の切り取りに使う関数。これがなんなのかはまだ知らない。\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//三角形の面積\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//多角形の面積\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//凸多角形かどうかの判定\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//凹多角形を線分lで切断した際の多角形の数\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\n//i番目を0にする\nint clearBit(int num, int i){\n\tint mask = ~(1 << i);\n\treturn num & mask;\n}\n\n//i番目をvで置き換える\nint updateBit(int num, int i, int v){\n\tint mask = ~(1 << i);\n\treturn (num & mask) | (v << i);\n}\n\nint n, ans;\n\nbool isOver(Circle a, Circle b){\n\tpair<Point,Point> tmp = getCrossPoints(a,b);\n\tdouble na = tmp.first.imag();\n    return isnan(na) == 0;\n}\n\nvoid dfs(vector<vector<int>>& g, int cur, vector<int>& on){\n\tfor(auto to : g[cur]){\n\t\ton[to] = on[to] bitor (1 << cur) bitor on[cur];\n\t\tdfs(g, to, on);\n\t}\n}\n\nvector<bool> memo;\nvoid dfs(int s, vector<int>& on, vector<int> c){\n\tif(memo[s]) return;\n\n\tvector<vector<int>> canTake(4);\n\trep(i,n){\n\t\tif(getBit(s,i)) continue;\n\t\tif((on[i] bitand s) == on[i]){\n\t\t\tcanTake[c[i]].emplace_back(i);\n\t\t}\n\t}\n\n\tvector<int> take(4,0);\n\trep(i,4){\n\t\tfor(auto j : canTake[i]){\n\t\t\ttake[i] = setBit(take[i], j);\n\t\t}\n\t}\n\n\trep(i,4){\n\t\tif(canTake[i].size() >= 2){\n\t\t\tif(canTake[i].size() % 2 == 1){\n\t\t\t\trep(j,canTake[i].size()){\n\t\t\t\t\tdfs(s bitor clearBit(take[i], j), on, c);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdfs(s bitor take[i], on, c);\n\t\t\t}\n\t\t}\n\t}\n\n\tbitset<30> bit(s);\n\tans = max<int>(ans, bit.count());\n\tmemo[s] = true;\n}\n\nint main(){\n    while(scanf(\"%d\",&n),n){\n        vector<Circle> c(n);\n        vector<int> color(n);\n        rep(i,n){\n            double x,y,r;\n            scanf(\"%lf%lf%lf%d\",&x,&y,&r,&color[i]);\n\t\t\tcolor[i]--;\n            c[i] = {Point(x,y),r};\n        }\n\n\t\tvector<vector<int>> g(n);\n\t\tvector<bool> top(n,1);\n\t\trep(i,n){\n\t\t\trange(j,i + 1,n){\n\t\t\t\tif(isOver(c[i], c[j])){\n\t\t\t\t\tg[i].emplace_back(j);\n\t\t\t\t\ttop[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> on(n,0);\n\t\trep(i,n){\n\t\t\tif(not top[i]) continue;\n\t\t\tdfs(g, i, on);\n\t\t}\n\t\t//rep(i,n) show(on[i])\n\n\t\tans = 0;\n\t\tmemo = vector<bool>(1 << n, 0);\n\t\tdfs(0, on, color);\n\t\tcout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\ntypedef struct a \n{\n\tbool exist[24];\n}state;\n\nvoid init_state(bool exist[24],int n)\n{\n\tfor (int i=0;i<n;++i) exist[i] = true;\n}\n\nint cal_state(bool exist[24],int n)\n{\n\tint res = 0;\n\tfor (int i=0;i<n;++i)\n\t{\n\t\tif (exist[i]) res += 1<<i; \n\t}\n\treturn res;\n}\n\nint cal_number(bool exist[24], int n)\n{\n\tint res = 0;\n\tfor (int i=0;i<n;++i)\n\t{\n\t\tif (exist[i]) ++res;\n\t}\n\treturn res;\n}\n\nbool overlap(int x1,int y1,int r1,int x2,int y2,int r2)\n{\n\tif ((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1) < (r1+r2)*(r1+r2)) return true;\n\telse return false;\n}\n\nint main()\n{\n\tint n = 0;\n\tint x[24];\n\tint y[24];\n\tint r[24];\n\tint c[24];\n\n\tcin >> n;\n\twhile (n)\n\t{\n\t\tint res = 0;\n\t\tqueue<state> q;\n\t\tbool ontop[24];\n\t\tbool s[1<<24] = {false};\n\t\t\n\t\tfor (int i=0;i<n;++i)\n\t\t{\n\t\t\tcin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\t}\n\t\t\n\t\tstate tmp;\n\t\tinit_state(tmp.exist,n);\n\t\tq.push(tmp);\n\t\t\n\t\twhile (!q.empty())\n\t\t{\n\t\t\ttmp = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tinit_state(ontop,n);\n\t\t\tres = max(res,n-cal_number(tmp.exist,n));\n\t\t\t\n\t\t\tif (res == n) break;\n\t\t\t\n\t\t\tfor (int i=0;i<n;++i)\n\t\t\t{\n\t\t\t\tif (tmp.exist[i])\n\t\t\t\t{\n\t\t\t\t\tfor (int j = i+1; j<n; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tmp.exist[j]&&ontop[j])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (overlap(x[i],y[i],r[i],x[j],y[j],r[j])) ontop[j] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i=0;i<n;++i)\n\t\t\t{\n\t\t\t\tif (tmp.exist[i]&&ontop[i])\n\t\t\t\t{\n\t\t\t\t\tfor (int j=i+1;j<n;++j) \n\t\t\t\t\t{\n\t\t\t\t\t\tif (tmp.exist[j]&&ontop[j]&&(c[i] == c[j]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmp.exist[i] = false;\n\t\t\t\t\t\t\ttmp.exist[j] = false;\n\t\t\t\t\t\t\tif (!s[cal_state(tmp.exist,n)])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ts[cal_state(tmp.exist,n)] = true;\n\t\t\t\t\t\t\t\tq.push(tmp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\tcout << res << endl;\n\t\tcin >>n;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n#include <complex>\n#include <queue>\n#include <bitset>\nusing namespace std;\nusing ll = long long;\nconst int INF = 1<<30;\nconst int MOD = (int)1e9 + 7;\nconst int MAX_N = 25;\n#define debug(x) cout << #x << \": \" << x << endl\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) { for(int i = 0; i < (int) v.size(); i++) os << v[i] << (i + 1 != v.size() ? \" \" : \"\"); return os; }\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ninline bool equals(double a, double b) { return abs(b - a) < EPS; }\n\nusing Point = complex<double>;\nstruct Circle\n{\n    Point p; double r; int color;\n    Circle() = default;\n    Circle(Point p, double r, int color) : p(p), r(r), color(color) {}\n};\n\nbool check(Circle c1, Circle c2)\n{\n    if(c1.r < c2.r) swap(c1, c2);\n    double d = abs(c1.p - c2.p);\n    if(c1.r + c2.r < d or equals(c1.r + c2.r, d)) return false;\n    return true;\n}\n\nvector<Circle> cir;\nvector<int> pale, dp;\n\nint dfs(int bit)\n{\n    if(dp[bit]) return dp[bit];\n    int res = 0;\n    for(int i = 0; i < cir.size(); i++)\n    {\n        if(bit & (1<<i)) continue;\n        if((bit & pale[i]) != pale[i]) continue;\n        for(int j = i + 1; j < cir.size(); j++)\n        {\n            if(bit & (1<<j)) continue;\n            if(cir[i].color != cir[j].color or check(cir[i], cir[j])) continue;\n            if((bit & pale[j]) != pale[j]) continue;\n            int tmp = bit;\n            tmp |= (1<<i);\n            tmp |= (1<<j);\n            res = max(res, dfs(tmp) + 2);\n        }\n    }\n    //debug(bitset<8>(bit));\n    return dp[bit] = res;\n}\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    while(cin >> N, N)\n    {\n        pale.resize(N, 0);\n        dp.resize(1<<N, 0);\n        for(int i = 0; i < N; i++)\n        {\n            int x, y, r, c; cin >> x >> y >> r >> c;\n            Circle tmp = Circle(Point(x, y), r, c);\n            for(int j = 0; j < cir.size(); j++)\n            {\n                if(check(tmp, cir[j])) pale[i] |= 1<<j;\n            }\n            cir.push_back(tmp);\n        }\n        cout << dfs(0) << endl;\n        cir.clear();\n        pale.clear();\n        dp.clear();\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <bitset>\nusing namespace std;\n\ntypedef complex< int > Point;\n\nint N;\nPoint p[24];\nint R[24], C[24];\nchar f[1 << 24];\n\nvoid read_plate(void);\nvoid solve(void);\nchar dp(int);\nbool is_valid(int, int);\n\nint main() {\n  while (cin >> N, N) {\n    read_plate();\n    solve();\n  }\n\n  return 0;\n}\n\nvoid read_plate(void) {\n  for (int i = 0; i < N; ++i) {\n    int x, y;\n    cin >> x >> y >> R[i] >> C[i];\n    p[i] = Point(x, y);\n  }\n}\n\nvoid solve(void) {\n  fill(&f[0], &f[1 << N], char(-1));\n  cout << int(dp((1 << N) - 1)) << endl;\n}\n\nchar dp(int m) {\n  if (f[m] != -1) return f[m];\n  if (m == 0)     return char(0);\n\n  f[m] = char(0);\n//  cout << \"m = \" << bitset< 7 >(m) << endl;\n  for (int i = 0; i < N; ++i)\n    if ((1 << i & m) && is_valid(i, m))\n      for (int j = 0; j < N; ++j)\n        if ((1 << j & m) && i != j && C[i] == C[j] && is_valid(j, m))\n          f[m] = max(f[m], char(dp(m & ~(1 << i) & ~(1 << j)) + 2));\n\n  return f[m];\n}\n\nbool is_valid(int qi, int qm) {\n  for (int i = qi - 1; i >= 0; --i)\n    if ((1 << i & qm) && norm(p[i] - p[qi]) < (R[i] + R[qi]) * (R[i] + R[qi]))\n      return false;\n  return true;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#define x first.first\n#define y first.second\n#define r second.first\n#define color second.second\n\nusing namespace std;\n\ntypedef pair<double,double> P;\ntypedef pair<P,P> C;\n\nconst double EPS = 1e-10;\n\ndouble dist(C a,C b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nbool check(C a,C b){\n  return a.r+b.r-dist(a,b)>EPS;\n}\n\nint count(int bits){\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits =(((bits >> 4) + bits) & 0x0f0f0f0f);\n  bits += bits >> 8;\n  return (bits + (bits >> 16)) & 0xff;\n}\n\nbool dp[(1<<25)];\n\nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<C>c(n);\n    for(int i=0;i<n;i++)\n      cin >> c[i].x >> c[i].y >> c[i].r >> c[i].color;\n    \n    fill(dp,dp+(1<<n),false);\n    dp[(1<<n)-1]=true;\n    \n    for(int S=(1<<n)-1;S>=0;S--){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  if(i==j || !(S>>i&1) || !(S>>j&1))continue;\n\t  if(c[i].color!=c[j].color)continue;\n\t  \n\t  bool fg=false;\n\t  for(int k=0;k<n;k++){\n\t    if(!(S>>k&1))continue;\n\t    fg|= k<i && check(c[i],c[k]);\n\t    fg|= k<j && check(c[j],c[k]);\n\t  }\n\t  if(fg)continue;\n\t  \n\t  int nx=S;\n\t  nx&=~(1<<i);\n\t  nx&=~(1<<j);\n\t  dp[nx]|=dp[S];\n\t}\n      }\n    }\n    \n    for(int i=0;i<(1<<n);i++){\n      if(dp[i]){\n\tcout << n-count(i) << endl;\n\tbreak;\n      }\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <bitset>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef complex<double> P;\n\nstruct C {\n  P p;\n  int r, c;\n};\nint n;\nvector<C> vc;\nint memo[1<<24];\nint solve(int S) {\n  if (memo[S] != -1) return memo[S];\n//  cout << bitset<24>(S) << endl;\n  vector<int> hoge;\n  REP(i,n) {\n    if (S>>i&1) continue;\n    bool f = 1;\n    REP(j,i) {\n      if (S>>j&1) continue;\n      if (abs(vc[i].p-vc[j].p) < vc[i].r+vc[j].r) {\n        f = 0;\n        break;\n      }\n    }\n    if (f)\n      hoge.push_back(i);\n  }\n  int res = 0;\n  // FOR(it, hoge)\n  //   cout << *it << \" \";\n  // cout << endl;\n  REP(i,hoge.size()) {\n    REP(j,i) {\n      if (vc[hoge[i]].c==vc[hoge[j]].c)\n        res = max(res, solve(S|(1<<hoge[i])|(1<<hoge[j])) + 2);\n    }\n  }\n  return memo[S] = res;\n}\n\nint main() {\n  while(cin>>n,n) {\n    vc.clear();\n    REP(i,n) {\n      int x,y,r,cc;\n      cin >> x>>y>>r>>cc;\n      vc.push_back((C){P(x,y),r,cc});\n    }\n    memset(memo,-1,sizeof(memo));\n    cout << solve(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstruct po {int x,y,r,g;};\nvector <po> c[5];\nint ans;\nint used[1<<24];\nbool check(po a){\n  if(a.x==100000)return false;\n  for(int i=0;i<4;i++)\n    for(int j=0;j<c[i].size();j++){\n      po b = c[i][j];\n      if(a.g>b.g && (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y) < (a.r+b.r)*(a.r+b.r)) return false;\n    }\n  return true;\n}\n\nvoid saiki(int sum,int i,int cnt,int ima){\n  ans = max(ans,sum);\n  vector <int> J;\n  for(int j=0;j<(int)c[i].size();j++)if(check(c[i][j])==true)J.push_back(j);\n  for(int j=0;j<(int)J.size();j++)\n    for(int k=j+1;k<(int)J.size();k++){\n      int a,b;\n      int nx=(1<<c[i][J[j]].g)|(1<<c[i][J[k]].g)|ima;\n      if(used[nx]==1)continue;\n      used[nx]=1;\n      a=c[i][J[j]].x;\n      b=c[i][J[k]].x;\n      c[i][J[j]].x = c[i][J[k]].x = 100000;\n      for(int l=1;l<4;l++)saiki(sum+2,(i+l)%4,0,nx);\n      c[i][J[j]].x=a;\n      c[i][J[k]].x=b;\n    }\n}\n\nint main(){\n  while(1){\n    int n;\n    cin>>n;\n    if(n==0)break;\n    int x,y,r,col;\n    for(int j=0;j<(1<<24);j++)used[j]=0;\n    for(int i=0;i<4;i++) c[i].clear();\n    for(int i=0;i<n;i++)cin >>x>>y>>r>>col, c[--col].push_back((po){x,y,r,i});\n\n    ans=0;\n    for(int i=0;i<4;i++) saiki(0,i,0,0);\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst double EPS = 1e-9;\n\nstruct Circle{\n    point p;\n    double r;\n    int c;\n    Circle(int x,int y,double r,int c) : p(x,y),r(r),c(c) {}\n};\n\nbool is_intersected_circle(Circle a,Circle b){\n    return abs(a.p-b.p)<(a.r + b.r)-EPS;\n}\n\nint popcount(int x){\n    int ret = 0;\n    while(x){\n        x &= x-1;\n        ret++;\n    }\n    return ret;\n}\n\nvoid cerr_bits(int x,int n){\n    for(int i=0;i<n;i++){\n        cerr << ((x&(1 << i)) != 0) << \" \";\n    }\n    cerr << endl;\n}\nint solve(vector<Circle> cs){\n    int n = cs.size();\n\n    vector<vector<char> > override(n,vector<char>(n,false));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(is_intersected_circle(cs[i],cs[j])){\n                override[i][j] = true;\n            }\n        }\n    }\n\n    stack<int> S;\n    int ret = 0;\n    S.push(0);\n    while(not S.empty()){\n        int cur = S.top();\n        //cerr_bits(cur,n);\n        S.pop();\n        ret = max(ret,popcount(cur));\n        vector<char> ov(n,false);\n        for(int i=0;i<n;i++){\n            if(cur & (1 << i)) continue;\n            for(int j=i+1;j<n;j++){\n                if(cur & (1 << j)) continue;\n                if(override[i][j]){\n                    ov[j] = true;\n                }\n            }\n        }\n        for(int i=0;i<n;i++){\n            if((cur & (1 << i)) || ov[i]) continue;\n            if(ov[i]) continue;\n            for(int j=i+1;j<n;j++){\n                if((cur & (1 << j)) || ov[j]) continue;\n                if(cs[i].c == cs[j].c){\n                    int here = cur;\n                    here |= (1 << i);\n                    here |= (1 << j);\n                    S.push(here);\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nint main(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n        vector<Circle> cs;\n        for(int i=0;i<n;i++){\n            int x,y,r,c;\n            cin >> x >> y >> r >> c;\n            cs.push_back(Circle(x,y,r,c));\n        }\n        cout << solve(cs) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    int n; cin >> n;\n    if (!n) break;\n    V<> x(n), y(n), r(n), c(n); for (int i = 0; i < n; ++i) cin >> x[i] >> y[i] >> r[i] >> c[i], --c[i];\n    V<bool> b(n, true);\n    int res = 0;\n    auto dfs = [&](const auto& dfs) -> void {\n      res = max(res, n - accumulate(begin(b), end(b), 0));\n      VV<> idx(4);\n      for (int i = 0; i < n; ++i) if (b[i]) {\n        bool ok = true;\n        for (int j = 0; j < i; ++j) if (b[j]) {\n          if ((x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]) < (r[i] + r[j]) * (r[i] + r[j])) {\n            ok = false;\n            break;\n          }\n        }\n        if (ok) idx[c[i]].push_back(i);\n      }\n      for (auto&& v : idx) if (v.size() >= 2) {\n        for (int i : v) for (int j : v) if (i < j) {\n          b[i] = b[j] = false;\n          dfs(dfs);\n          b[i] = b[j] = true;\n        }\n      }\n    };\n    dfs(dfs);\n    cout << res << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\n\nint n;\nint x[32], y[32], r[32], c[32];\nbool removed[32];\nbool on(int i, int j)\n{\n\tint dx = x[i] - x[j], dy = y[i] - y[j];\n\tint t = r[i] + r[j];\n\treturn dx * dx + dy * dy < t * t;\n}\nint dfs()\n{\n\tvector<int> cand[4];\n\tfor (;;)\n\t{\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t\tcand[i].clear();\n\n\t\tbool top[32];\n\t\tfill(top, top + n, true);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif (removed[i])\n\t\t\t\tcontinue;\n\t\t\tif (top[i])\n\t\t\t\tcand[c[i]].push_back(i);\n\n\t\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\t\tif (on(i, j))\n\t\t\t\t\ttop[j] = false;\n\t\t}\n\n\t\tbool any_rem = false;\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tif (!cand[i].empty() && cand[i].size() % 2 == 0)\n\t\t\t{\n\t\t\t\tforeach (it, cand[i])\n\t\t\t\t\tremoved[*it] = true;\n\t\t\t\tany_rem = true;\n\t\t\t\tcand[i].clear();\n\t\t\t}\n\t\t\telse if (cand[i].size() == 1)\n\t\t\t\tcand[i].clear();\n\t\t}\n\t\tif (!any_rem)\n\t\t\tbreak;\n\t}\n\n\tint res = count(removed, removed + n, true);\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tif (!cand[i].empty())\n\t\t{\n\t\t\tfor (int left = 0; left < cand[i].size(); ++left)\n\t\t\t{\n\t\t\t\tbool c[32];\n\t\t\t\tcopy(removed, removed + n, c);\n\n\t\t\t\tfor (int j = 0; j < cand[i].size(); ++j)\n\t\t\t\t\tif (j != left)\n\t\t\t\t\t\tremoved[j] = true;\n\t\t\t\tmax_swap(res, dfs());\n\n\t\t\t\tcopy(c, c + n, removed);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> n, n)\n\t{\n\t\trep (i, n)\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i], --c[i];\n\t\tfill(removed, removed + n, false);\n\t\tcout << dfs() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nstruct C {\n    P p;\n    R r;\n    C() {}\n    C(P p, R r) : p(p), r(r) {}\n};\nconst int MN = 25;\n\nint n;\nbool g[MN][MN];\nint col[MN];\n\n\nint dp[1<<MN];\n\nint calc(int m) {\n    if (dp[m] != -1) return dp[m];\n    int ma = 0;\n    bool can[MN];\n    for (int i = 0; i < n; i++) {\n        can[i] = true;\n        for (int j = 0; j < i; j++) {\n            if (m & (1<<j)) continue;\n            if (g[i][j]) {\n                can[i] = false;\n                break;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            if (col[i] != col[j]) continue;\n            if (m & (1<<i)) continue;\n            if (m & (1<<j)) continue;\n            if (!can[i]) continue;\n            if (!can[j]) continue;\n            ma = max(ma, 2+calc(m | (1<<i) | (1<<j)));\n        }\n    }\n    return dp[m] = ma;\n}\n\nbool solve() {\n    cin >> n;\n    if (!n) return false;\n    C c[MN];\n\n    for (int i = 0; i < n; i++) {\n        R x, y, r;\n        cin >> x >> y >> r >> col[i];\n        c[i] = C(P(x, y), r);\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            g[i][j] = (abs(c[i].p - c[j].p) < c[i].r+c[j].r);\n        }\n    }\n    memset(dp, -1, sizeof(dp));\n    cout << calc(0) << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nconst int kN = 30;\nint N, x[kN], y[kN], r[kN], c[kN], cross[kN];\nchar dp[(1<<24)+1];\n\nint rec(int S) {\n  if (dp[S] >= 0) return dp[S];\n  int ret = 0;\n  for (int i = 0; i < N; ++i) {\n    if (S >> i & 1) continue;\n    if (S != (S | cross[i])) continue;\n    for (int j = i+1; j < N; ++j) {\n      if (S >> j & 1) continue;\n      if (c[i] != c[j]) continue;\n      if (S != (S | cross[j])) continue;\n      ret = max(ret, rec(S|(1<<i)|(1<<j)) +2);\n    }\n  }\n  return dp[S] = ret;\n}\n\nint solve() {\n  memset(cross, 0, sizeof (cross));\n  for (int i = 0; i < N; ++i) {\n    for (int j = i+1; j < N; ++j) {\n      int dx = x[i] - x[j], dy = y[i] - y[j], ur = r[i] + r[j];\n      if (dx*dx + dy*dy < ur*ur)\n        cross[j] |= (1<<i);\n    }\n  }\n  memset(dp, -1, sizeof dp);\n  // rep(i,N) {\n  //   printf(\"%d : %d\\n\", i, cross[i]);\n  // }\n  return rec(0);\n}\n\nint main() {\n  while (scanf(\"%d\", &N), N) {\n    rep(i,N) scanf(\"%d%d%d%d\", x+i, y+i, r+i, c+i);\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint n;\nint x[25], y[25], r[25], c[25];\nbool board[25][25];\nbool memo[1<<24];\n\nvoid dfs(int S) {\n    if(memo[S]) return;\n    vector<int> candidate;\n    rep(i,0,n) {\n        if(!(S >> i & 1)) continue;\n        bool ok = true;        \n        rep(j,0,i) {\n            if(!(S >> j & 1)) continue;\n            if(board[j][i]) ok = false;\n        }\n        if(ok) candidate.push_back(i);\n    }\n\n    int m = candidate.size();\n    rep(i,0,m) {\n        rep(j,i+1,m) {\n            int x = candidate[i], y = candidate[j];\n            if(c[x] == c[y]) {\n                int nbit = S ^ (1 << x) ^ (1 << y);\n                dfs(nbit);\n                memo[nbit] = true;\n            }\n        }\n    }\n}\n\nll dist(ll x1, ll y1, ll x2, ll y2) {\n    ll d1 = (x1-x2) * (x1-x2);\n    ll d2 = (y1-y2) * (y1-y2);\n    return d1 + d2;\n}\n\nbool in(ll x1, ll y1, ll r1, ll x2, ll y2, ll r2) {\n    double d1 = dist(x1, y1, x2, y2);\n    double d2 = (r1+r2) * (r1+r2);\n    return d1 < d2;\n}\n\nsigned main() {\n    while(cin >> n, n) {\n        memset(board, false, sizeof(board));\n        memset(memo, false, sizeof(memo));\n        rep(i,0,n) {\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n        rep(i,0,n) rep(j,0,i) {\n            if(in(x[i], y[i], r[i], x[j], y[j], r[j])) board[j][i] = true;\n        }\n        dfs((1<<n)-1);\n        int ans = 0;\n        rep(i,0,1<<n) {\n            if(memo[i]) {\n                // printf(\"true: i = %lld\\n\", i);\n                ans = max(ans, n - __builtin_popcount(i));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <bitset>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){\n    rep(i,v.size()) os << v[i] << (i+1==v.size()?\"\":\" \");\n    return os;\n}\n\ndouble eps = 1e-9;\n\nint n;\nint x[24], y[24], r[24], c[24];\nbool hit[24][24];\nbool erase[24];\nint dp[1<<24];\n\nint dfs(int S){\n    int & res = dp[S];\n    if(res!=-1) return res;\n    res = 0;\n    rep(i,n){\n        if(S>>i & 1){\n            rep(j,i){\n                if(S>>j & 1){\n                    if(hit[i][j] || c[i]!=c[j]) continue;\n                    bool ok = true;\n                    rep(k,i) if(hit[i][k] && (S>>k & 1)) ok = false;\n                    rep(k,j) if(hit[j][k] && (S>>k & 1)) ok = false;\n                    if(!ok) continue;\n                    S ^= 1<<i;\n                    S ^= 1<<j;\n                    res = max(dfs(S)+2, res);\n                    S ^= 1<<i;\n                    S ^= 1<<j;\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(cin>>n && n){\n        rep(i,n) rep(j,n) hit[i][j] = false;\n        rep(i,n) erase[i] = false;\n        rep(i,n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n        rep(i,n)rep(j,i){\n            int dx=x[i]-x[j], dy=y[i]-y[j];\n            double d = sqrt(dx*dx+dy*dy);\n            if(d < r[i]+r[j]-eps){\n                hit[i][j] = hit[j][i] = true;\n            }\n        }\n        memset(dp,-1,sizeof(dp));\n        int S = 0;\n        rep(i,n) S |= 1<<i;\n        cout << dfs(S) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nint n, dp[1<<25]={0};\n\nint solve(){\n\tvector<int> pile[24];\n\tint x[24], y[24], r[24], c[24];\n\n\tfor(int i=0; i<n; i++){\n\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\tfor(int j=0; j<i; j++){\n\t\t\tif( sqrt( (x[i]-x[j])*(x[i]*x[j]) + (y[i]-y[j])*(y[i]-y[j]) )\n\t\t\t\t\t< r[i] + r[j] ){\n\t\t\t\tpile[j].push_back( (1<<i) );\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<(1<<n); i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif( !( i&(1<<j) ) ) continue;\n\t\t\tint p=0;\n\t\t\tfor(; p<pile[j].size(); p++ ){\n\t\t\t\tif( pile[j][p] & i )\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( p != pile[j].size() ) continue;\n\t\t\tfor(int k=0; k<j; k++){\n\t\t\t\tif( !( i&(1<<k) ) ) continue;\n\t\t\t\tif( c[j] != c[k] ) continue;\n\t\t\t\tfor(p=0; p<pile[k].size(); p++ ){\n\t\t\t\t\tif( pile[k][p] & i )\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif( p != pile[k].size() ) continue;\n\t\t\t\t\n\t\t\t\t//???????????????\n\t\t\t\tdp[i] = max( dp[i], 2 + dp[ i^( (1<<j) | (1<<k) ) ] );\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[(1<<n)-1] << endl;\n\n\treturn 0;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nclass Solver {\n    private:\n        bool has_used_[30];\n        inline bool is_collisive(int i, int j) {\n            int dx = x[i] - x[j];\n            int dy = y[i] - y[j];\n            int d = r[i] + r[j];\n            return dx * dx + dy * dy < d * d;\n        }\n        inline bool is_top(int i) {\n            for (int j = 0; j < i; ++j) {\n                if (has_used_[j]) {\n                    continue;\n                }\n                if (is_collisive(i, j)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        int simulate() {\n            int count = 0;\n            for (int i = 0; i < n; ++i) {\n                if (has_used_[i] || !is_top(i)) {\n                    continue;\n                }\n                for (int j = i + 1; j < n; ++j) {\n                    if (has_used_[j] || c[i] != c[j] || !is_top(j)) {\n                        continue;\n                    }\n                    has_used_[i] = has_used_[j] = true;\n                    count = max(count, 2 + simulate());\n                    has_used_[i] = has_used_[j] = false;\n                }\n            }\n            return count;\n        }\n    public:\n        int n;\n        int x[30], y[30], r[30], c[30];\n        int solve() {\n            for (int i = 0; i < n; ++i) {\n                has_used_[i] = false;\n            }\n            return simulate();\n        }\n};\n\nint main() {\n    Solver s;\n    while (true) {\n        cin >> s.n;\n        if (s.n == 0) {\n            return 0;\n        }\n        for (int i = 0; i <s.n; ++i) {\n            cin >> s.x[i] >> s.y[i] >> s.r[i] >> s.c[i];\n        }\n        cout << s.solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n        //!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //????????? == ??¨ != ????????´??????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //?????????????????????????????§??????????????????????????????????¨??????????????????????\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//?????£?????????????????¨?????????????§???¢?????´???????±???????\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//???????§???¢??????????????????????????¢??°??????????????????????????????????????\\????????????\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//????§???¢?????¢???\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//????§???¢?????¢???\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//???????§???¢?????????l??§??????????????????????§???¢?????°\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\ntemplate < class BidirectionalIterator >\nbool next_combination ( BidirectionalIterator first1 ,\n        BidirectionalIterator last1 ,\n        BidirectionalIterator first2 ,\n        BidirectionalIterator last2 ){\n    if (( first1 == last1 ) || ( first2 == last2 )) {\n        return false ;\n    }\n    BidirectionalIterator m1 = last1 ;\n    BidirectionalIterator m2 = last2 ; --m2;\n    while (--m1 != first1 && !(* m1 < *m2 )){\n    }\n    bool result = (m1 == first1 ) && !(* first1 < *m2 );\n    if (! result ) {\n        while ( first2 != m2 && !(* m1 < * first2 )) {\n            ++ first2 ;\n        }\n        first1 = m1;\n        std :: iter_swap (first1 , first2 );\n        ++ first1 ;\n        ++ first2 ;\n    }\n    if (( first1 != last1 ) && ( first2 != last2 )) {\n        m1 = last1 ; m2 = first2 ;\n        while (( m1 != first1 ) && (m2 != last2 )) {\n            std :: iter_swap (--m1 , m2 );\n            ++ m2;\n        }\n        std :: reverse (first1 , m1 );\n        std :: reverse (first1 , last1 );\n        std :: reverse (m2 , last2 );\n        std :: reverse (first2 , last2 );\n    }\n    return ! result ;\n}\n\ntemplate < class BidirectionalIterator > bool next_combination ( BidirectionalIterator first , BidirectionalIterator middle , BidirectionalIterator last )\n{\n    return next_combination (first , middle , middle , last );\n}\n\n//????´?v??????r??????????????????????????????\nvoid func(vector<int> v, int r){\n    do{\n    }while(next_combination(v.begin(), v.begin() + r, v.end()));\n}\n\nint n;\n\nbool isOver(Circle a, Circle b){\n    return abs(a.c - b.c) < a.r + b.r;\n}\n\nvoid canUse(Circle c[30], vector<bool> used, int color[30], vector<int> res[4]){\n    //show(\"canUse\")\n    rep(i,n){\n        if(used[i]) continue;\n        bool f = true;\n        range(j,0,i){\n            if(used[j]) continue;\n            if(isOver(c[i], c[j])){\n                f = false;\n                break;\n            }\n        }\n        if(f) res[color[i] - 1].emplace_back(i);\n    }\n}\n\nvoid requireCircleSet(vector<bool> used, vector<int> circles, vector<vector<int>> &cs){\n    //show(\"requireCircleset\")\n    if(circles.size() < 2) return;\n    //rep(i,circles.size()){ cout << circles[i] << endl; }\n    range(i,2,circles.size() + 1){\n        do{\n            vector<int> tmp;\n            rep(j,i){\n                //if(used[j]) continue;\n                //show(circles[j])\n                tmp.emplace_back(circles[j]);\n            }\n            cs.emplace_back(tmp);\n        }while(next_combination(circles.begin(), circles.begin() + i, circles.end()));\n    }\n}\n\nint ans;\n\nvoid dfs(Circle c[30], int color[30], vector<bool> used){\n    //show(\"dfs\");\n    vector<int> use[4];\n    canUse(c,used,color,use);\n    //rep(i,4){\n    //    if(use[i].empty()) continue;\n    //    show(use[i].size())\n    //}\n\n    bool f = true;\n    rep(i,4){\n        if(use[i].empty()) continue;\n        vector<vector<int>> circle_set;\n        requireCircleSet(used, use[i], circle_set);\n        if(circle_set.empty()) continue;\n        f = false;\n        for(auto j:circle_set){\n            vector<bool> tmp = used;\n            for(auto k:j){\n                assert(not tmp[k]);\n                tmp[k] = true;\n            }\n            dfs(c, color, tmp);\n        }\n    }\n\n    if(f){\n        int cnt = 0;\n        rep(i,n){ if(used[i]) cnt++; }\n        ans = max(ans, cnt);\n    }\n}\n\nint main(){\n    while(scanf(\"%d\",&n),n){\n        Circle c[30];\n        int color[30];\n        ans = 0;\n        rep(i,n){\n            double x,y,r;\n            scanf(\"%lf%lf%lf%d\",&x,&y,&r,&color[i]);\n            c[i] = {Point(x,y),r};\n        }\n        vector<bool> used(30,0);\n        dfs(c,color,used);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <utility>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nbool flag[ 1 << 24 ];\n\nint saiki( vector<int> c, vector<long int> on, int n, int cnt, int m, int f ) {\n\tif ( flag[f] == true ) return m;\n\tfor ( int i = 0; i < n-1; i++ ) {\n\t\tfor ( int j = i+1; j < n; j++ ) {\n\t\t\tif ( on[i] == 0 && on[j] == 0 && c[i] == c[j] ) {\n\t\t\t\tvector<long int> on_copy;\n\t\t\t\tfor ( int k = 0; k < n; k++ ) {\n\t\t\t\t\tif ( k == i || k == j ) {\n\t\t\t\t\t\ton_copy.push_back( 1 << k );\n\t\t\t\t\t}else {\n\t\t\t\t\t\tint bit = ~( ( 1 << i ) + ( 1 << j ) );\n\t\t\t\t\t\ton_copy.push_back( on[k] & bit );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint f_copy = f | ( 1 << i ) | ( 1 << j );\n\t\t\t\tm = max( m, n-(cnt-2) );\n\t\t\t\tm = max( m, saiki( c, on_copy, n, cnt-2, m, f_copy ) );\n\t\t\t}\n\t\t}\n\t}\n\tflag[f] = true;\n\treturn m;\n}\n\nint main(){\n\twhile(true) {\n\n\t\tint n;\n\t\tcin >> n;\n\t\tif ( n == 0 ) break;\n\n\t\tvector<int> x;\n\t\tvector<int> y;\n\t\tvector<int> r;\n\t\tvector<int> c;\n\t\tvector<long int> on;\n\t\tlong int input;\n\n\t\tfor ( int i = 0; i < n; i++ ) {\n\t\t\tcin >> input;\n\t\t\tx.push_back(input);\n\t\t\tcin >> input;\n\t\t\ty.push_back(input);\n\t\t\tcin >> input;\n\t\t\tr.push_back(input);\n\t\t\tcin >> input;\n\t\t\tc.push_back(input);\n\t\t\tinput = 0;\n\t\t\tfor ( int j = 0; j < i; j++ ) {\n\t\t\t\tint xlen = x[i] - x[j];\n\t\t\t\tint ylen = y[i] - y[j];\n\t\t\t\tint rlen = r[i] + r[j];\n\t\t\t\tif ( xlen*xlen + ylen*ylen < rlen*rlen ) input += ( 1 << j );\n\t\t\t}\n\t\t\ton.push_back(input);\n\t\t}\n\n\t\tfor ( int i = 0; i < ( 1 << (n-1) ); i++ ) {\n\t\t\tflag[i] = false;\n\t\t}\n\n\t\tcout << saiki( c, on, n, n, 0, 0 ) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 24\n\nint N,x[MAX],y[MAX],r[MAX],c[MAX];\n\nint dist(int a,int b){\n    return (x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]);\n}\n\nbool check(int a,int b){\n    int d = dist(a,b);\n    int add = r[a]+r[b],sub = r[a]-r[b];\n    return ((sub*sub < d && d < add*add) || d <= sub*sub);\n}\n\nint main(){\n    while(cin >> N, N){\n        for(int i = 0 ; i < N ; i++){\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n        int bit[MAX] = {0};\n        for(int i = 0 ; i < N ; i++){\n            for(int j = 0 ; j < i ; j++){\n                if(check(i,j)) bit[i] |= (1<<j);\n            }\n        }\n        vector<bool> dp(1<<N,0);\n        dp[(1<<N)-1] = 1;\n        int res = 0;\n        for(int i = (1<<N)-1 ; i >= 0 ; i--){\n            if(dp[i] == 0) continue;\n            if(N%2 == 0 && __builtin_popcount(i) % 2 == 1) continue;\n            if(N%2 == 1 && __builtin_popcount(i) % 2 == 0) continue;\n            for(int j = 0 ; j < N ; j++){\n                if(__builtin_popcount(i&bit[j]) > 0) continue;\n                for(int k = j+1 ; k < N ; k++){\n                    if(c[j] != c[k]) continue;\n                    if(__builtin_popcount(i&bit[k]) > 0) continue;\n                    int S = i & ~((1<<j) | (1<<k));\n                    dp[S] = 1;\n                    res = max(res,N-__builtin_popcount(i));\n                }\n            }\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<string.h>\n#include<cassert>\n#include<vector>\n#include<algorithm>\n#define F first\n#define S second\n#define pb push_back\n#define EPS 1e-10\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint n,ans;\nbool used[1000];\nvector<PP> p;\nvector<int> rank;\nvector<int> List[1000];\nint cross[1000];\nstatic const int INF = 1<<28;\n\n\nchar dp[1<<24];\nint main(){\n  \n\n  while(cin >> n && n){ \n    ans = 0;\n    for(int i=0;i<n;i++)cross[i] = 0;\n    p.clear(); rank.clear();\n    for(int i=0;i<n;i++){\n List[i].clear();\n      int x,y,r,c;\n      cin >> x >> y >> r >> c;\n      p.pb(PP(P(x,y),P(r,c)));\n      for(int j=0;j<i;j++){\n\tint d1 = pow(p[i].F.F-p[j].F.F,2) + pow(p[i].F.S-p[j].F.S,2);\n\tint d2 = pow(p[i].S.F+p[j].S.F,2);\n\tif(d1 < d2){\n\t  cross[i] |= (1<<j);\n\t}\n      }\n    }\n    // for(int i=0;i<n;i++){\n    //cout << \"cor - \" << cross[i] << endl;\n    //}\n    \n    memset(dp,-1,sizeof(dp));//\n    dp[0] = 0;//\n   \n    for(int i=0;i<(1<<n);i++){//\n      if(dp[i] == -1)continue;//\n      ans = max(ans,(int)dp[i]);//\n      for(int j=0;j<n;j++){//\n\tif((i&cross[j]) != cross[j] || (i&(1<<j)) != 0)continue;//\n   \tfor(int k=j+1;k<n;k++){//\n\t  if(j==k || (i&cross[k])!=cross[k] || (i&(1<<k))!=0 || p[j].S.S != p[k].S.S)continue;\n\t  dp[i|(1<<j)|(1<<k)] = max((int)dp[i|(1<<j)|(1<<k)],(int)dp[i]+2);\n\t}\n      }\n    }\n    \n    // Japan - Iraq : 0 - 0 (03:14)\n    // Japan - Iraq : 1 - 0 (32:02)\n    // Japan - Iraq : 1 - 0 (41:00)\n  \n\n\n\n\n\n\n\n\n\n\n    //rec2(0); close  \n \n     cout << ans << endl;\n  }\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n\nvoid rec(int cnt){\n\n  int j=0,flag = 0;\n  bool fl = true;\n  while(fl){ \n\n    if(rank[j] == 0){\n    \n    j++;\n      if(j%n == 0 && j!=0){\n\tj=0;\n\tif(finish()){\n\t  ans = max(ans,cnt);\n\t  fl = false;\n\t  return;\n\t}\n\tflag = 0;\n      }\n      continue;\n    }\n\n    if(rank[j] == 1){\n      for(int i=0;i<rank.size();i++){      \n\tif(i == j || rank[i] <= 0)continue;\n\tif(rank[i] == 1 && p[j].S.S == p[i].S.S){\n\t  flag++;\n\t  rankDecrease(i);\n\t  rankDecrease(j);\n\t  rec(cnt+2);\n\t  rankIncrease(i);\n\t  rankIncrease(j);\n\t  flag--;\n\t}\n      }\n    }\n\n    j++;\n\n    if(j%n == 0 && j!=0){\n      j=0;\n      if(finish()){\n\tans = max(ans,cnt);\n\tfl = false;\n\treturn;\n      }\n      flag= 0;\n    }\n  }\n}\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n\nvoid rankIncrease(int x,int y){\n \n  for(int i=0;i<List[x].size();i++){\n      rank[List[x][i]]++;\n    }\n    rank[x]++;\n    return;\n\n\n  for(int i=0;i<rank.size();i++){\n    if(y == i)continue;\n    if(i == x){\n      rank[i]++;\n      continue;\n    }\n double r1 = p[x].S.F,r2 = p[i].S.F,d = sqrt(pow(p[x].F.F-p[i].F.F,2)+pow(p[x].F.S-p[i].F.S,2));\n if(fabs(r1-r2) < d  && d < (r1+r2) ){ //cross each other on two different points\n\trank[i]++;\n      }\n      else if(fabs(d-(r1+r2)) < EPS ){ //be circumscribed\n      }\n      else if(fabs(d-fabs(r1-r2)) < EPS){ // be inscribed\n\trank[i]++;\n      }\n      else{\n      }\n  }\n}\n\n  void rankDecrease(int x,int y){\n    for(int i=0;i<List[x].size();i++){\n      rank[List[x][i]]--;\n    }\n    rank[x]--;\n    return;\n\n  for(int i=0;i<rank.size();i++){\n    if(i == y)continue;\n    if(i == x){\n      rank[i]--;\n      continue;\n    }\n    double r1 = p[x].S.F,r2 = p[i].S.F,d = sqrt(pow(p[x].F.F-p[i].F.F,2)+pow(p[x].F.S-p[i].F.S,2));\n if( fabs(r1-r2) < d  && d < (r1+r2)){ //cross each other on two different pointsq\n\t  rank[i]--;\n      }\n      else if( fabs(d-(r1+r2)) < EPS){ //be circumscribed\n      }\n      else if( fabs(d-fabs(r1-r2)) < EPS){ // be inscribed\n\trank[i]--;\n      }\n      else{\n      }\n  }\n}\n\n\n\n\n\nvoid rec2(int cnt){\n  //cout << \"coumter\" << endl;\n   for(int i=0;i<rank.size();i++){\n     if(rank[i] != 1)continue;\n    //cout << ans << endl;\n    if(rank[i] == 1 ){\n      for(int j=0;j<rank.size();j++){\n\tif(i == j || rank[j] <= 0)continue;\n\tif(p[i].S.S == p[j].S.S && rank[j] == 1 ){//usedつかったrtsdkrkm\t\n\t  rankDecrease(i,j); rankDecrease(j,i);\n\t  \n\t  rec2(cnt+2);\n\t  rankIncrease(i,j); rankIncrease(j,i);\n\t}\n      }\n    }\n  }\n \n  ans = max(ans,cnt);\n}\n\n\n*/\n\n\n\n\n\n\n\n\n\n\n/*\nvoid ranking(){\n  //for(int i=0;i<p.size();i++)rank.pb(1);\n\n  for(int i=0;i<p.size();i++){\n    cross[i] = 0;\n    for(int j=0;j<i;j++){\n      double r1 = p[i].S.F,r2 = p[i].S.F,d = pow(p[i].F.F-p[j].F.F,2)+pow(p[i].F.S-p[j].F.S,2);\n      R = pow();\n      if(fabs(r1-r2) < d  && d < (r1+r2) ){ //cross each other on two different points\n\t//rank[j]++;\n\t//List[i].pb(j);\n\tcross[i] |= (1<<j);\n      }\n      else if(fabs(d-(r1+r2)) <= EPS){ //be circumscribed\n      }\n      else if(fabs(d-fabs(r1-r2)) <= EPS){ // be inscribed\n\t//rank[j]++;\n\t//List[i].pb(j);\n\tcross[i] |= (1<<j);\n      }\n      else{\n      }\n    }\n    cout << \"i = \" << i << \",cross = \" << cross[i] << endl;\n  }\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <set>\n#include <sstream>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nbool ISINT(double x){return fabs(x-(int)x)<EPS;}\nbool ISEQ(double x,double y){return fabs(x-y)<EPS;}\nstring itos(ll x){stringstream ss;ss<<x;return ss.str();}\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define EREP(i,a,b) for(int i=a;i<=b;i++)\n#define erep(i,n) EREP(i,0,n)\n#define foreach(itr,c) for(__typeof(c.begin()) itr=c.begin();itr!=c.end();itr++)\n\nint n;\nint x[25],y[25],r[25],c[25];\nint b[25];\n\nbool intersects(int i,int j){\n  int dist1 = pow(x[i]-x[j],2) + pow(y[i]-y[j],2);\n  int dist2 = pow(r[i]+r[j],2);\n\n  return dist2 > dist1;\n}\n\nchar dp[1<<24];\n\nint main(void){\n  while(scanf(\"%d\",&n),n){\n    rep(i,n){\n      scanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n\n      b[i] = 0;\n      rep(j,i) if(intersects(i,j)) b[i] |= (1<<j);\n    }\n\n    int ans = 0;\n    int to = (1<<n);\n    memset(dp,-1,sizeof(dp));\n    dp[0] = 0;\n\n    rep(i,to){\n      if(dp[i] == -1) continue;\n      ans = max(ans,(int)dp[i]);\n      rep(j,n-1){\n        if((i & (1<<j)) != 0 || (i & b[j]) != b[j]) continue;\n        REP(k,j+1,n){\n          if(c[j] != c[k] || (i & (1<<k)) != 0 || (i & b[k]) != b[k]) continue;\n          int next = i | (1<<j) | (1<<k);\n          dp[next] = max((int)dp[next],dp[i]+2);\n        }\n      }\n    }\n\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(long long i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\nDef inf=1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,out;\nvvi used;\nvvi in[4];\nvoid dfs(int a){\n    out=max(out,a);\n    rep(q,4)rep(i,in[q].size())if(used[q][i]==0)\n        loop(j,i+1,in[q].size())if(used[q][j]==0){\n            bool h=true;\n            rep(k,i)if(used[q][k]==0){\n                if(\n                    (in[q][i][0]-in[q][k][0])*(in[q][i][0]-in[q][k][0])+\n                    (in[q][i][1]-in[q][k][1])*(in[q][i][1]-in[q][k][1])>=\n                    (in[q][i][2]+in[q][k][2])*(in[q][i][2]+in[q][k][2]));\n                else\n                    h=false;\n            }\n            rep(k,j)if(used[q][k]==0){\n                if(\n                    (in[q][j][0]-in[q][k][0])*(in[q][j][0]-in[q][k][0])+\n                    (in[q][j][1]-in[q][k][1])*(in[q][j][1]-in[q][k][1])>=\n                    (in[q][j][2]+in[q][k][2])*(in[q][j][2]+in[q][k][2]));\n                else\n                    h=false;\n            }\n            if(!h)continue;\n            used[q][i]=used[q][j]=1;\n            dfs(a+2);\n            used[q][i]=used[q][j]=0;\n        }\n}\nint main(){\n    while(cin>>n,n){\n        used=vvi(4,vi(6));\n        rep(i,4)in[i]=vvi(0);\n        rep(i,n){\n            int a,b,c,d;cin>>a>>b>>c>>d;\n            d--;\n            in[d].pb(vi({a,b,c}));\n        }\n        out=0;\n        dfs(0);\n        cout<<out<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iterator>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint sum=0,ds;\nint n;\nvoid rec(vector<circle> vs){\n  //cout << vs.size() << endl;\n  int i,j,k;\n  int f;\n  int on[30]={};\n  vector<int> cc[5];\n  f=1;\n  int ff=0;\n  while(ff==0){\n    ff=1;\n    for(i=0;i<30;i++) on[i]=0;\n    for(i=0;i<5;i++) cc[i].clear();\n    for(i=0;i<vs.size();i++){\n      for(j=i+1;j<vs.size();j++){\n\tif(ch(vs[i],vs[j])==1) on[j]=1;\n      }\n    }\n    for(i=0;i<vs.size();i++){\n      if(on[i]==0) cc[vs[i].c].push_back(i);\n    }\n    for(i=1;i<5;i++){\n      if(cc[i].size()>0&&cc[i].size()%2==0){\n\tfor(j=cc[i].size()-1;j>=0;j--){\n\t  vs.erase(vs.begin()+cc[i][j]);\n\t  ff=0;\n\t  f=0;\n\t}\n      }\n    }\n  }\n  for(i=1;i<5;i++){\n    //cout << cc[i].size() << endl;\n    if(cc[i].size()>=2&&cc[i].size()%2==1){\n      f=0;\n      vector<circle> next(vs);\n      //for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n      for(j=0;j<cc[i].size();j++){\n\tfor(k=cc[i].size()-1;k>=0;k--){\n\t  if(k!=j)\n\t    next.erase(next.begin()+cc[i][k]);\n\t}\n\trec(next);\n      }\n      break;\n    }\n  }\n  int o=n-vs.size();\n  if(f==1) sum=max(sum,o);\n  else{\n    rec(vs);\n  }\n}\n\nint main(){\n  cin >> n;\n  while(n!=0){\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    sum=0;\n    rec(v);\n    cout << sum << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n \nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n \nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\n\nmap<int,int> m;\n\nint n,d[30][30],abosum[30],ans;\nbool abo[30][30],exist[30];\n\nint check(bool tmp[30]){\n\tint ret = 0,bit = 1;\n\tfor(int i = 1;i <= n;i++){\n\t\tif(tmp[i] == true){\n\t\t\tret += bit;\n\t\t}\n\t\tbit *= 2;\n\t}\n\treturn ret;\n}\n\nvoid solve(int tmpans,bool texist[30],int tabosum[30]){\n\tans = max(ans,tmpans);\n\tint bit = check(texist);\n\tauto itr = m.find(bit);\n\tif(itr != m.end()) return;\n\tm[bit] = 1;\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = i+1;j <= n;j++){\n\t\t\tif(texist[i] == false || texist[j] == false)continue;\n\t\t\tif(tabosum[i] != 0 || tabosum[j] != 0) continue;\n\t\t\tif(d[i][3] != d[j][3]) continue;\n\t\t\ttexist[i] = false; texist[j] = false;\n\t\t\tbit = check(texist);\n\t\t\tauto itr = m.find(bit);\n\t\t\ttexist[i] = true; texist[j] = true;\n\t\t\tif(itr != m.end()) continue;\n\t\t\tbool tmpexist[30];\n\t\t\tfor(int k = 1;k <= n;k++){\n\t\t\t\ttmpexist[k] = texist[k];\n\t\t\t\tif(k == i || k == j) tmpexist[k] = false;\n\t\t\t}\n\t\t\tint tmpabosum[30];\n\t\t\tfor(int k = 1;k <= n;k++){\n\t\t\t\ttmpabosum[k] = tabosum[k];\n\t\t\t\tif( abo[i][k] == true && i < k )tmpabosum[k]--;\n\t\t\t\tif( abo[j][k] == true && j < k )tmpabosum[k]--;\n\t\t\t}\n\t\t\tsolve(tmpans+2,tmpexist,tmpabosum);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0)break;\n\t\tans = 0;\n\t\tm.clear();\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tabo[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\texist[i] = true;\n\t\t\tabosum[i] = 0;\n\t\t\tfor(int j = 0;j < 4;j++){\n\t\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\t\t//cin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = i+1;j <= n;j++){\n\t\t\t\tif(  (d[i][0]-d[j][0])*(d[i][0]-d[j][0]) + (d[i][1]-d[j][1])*(d[i][1]-d[j][1]) < (d[i][2]+d[j][2])*(d[i][2]+d[j][2])    ){\n\t\t\t\t\tabo[i][j] = true; abo[j][i] = true;\n\t\t\t\t\tabosum[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve(0,exist,abosum);\n\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nusing ll = long long;\nusing P = pair<int, int>;\nll GCD(ll a, ll b) { return b?GCD(b, a%b):a; }\nll LCM(ll a, ll b) { return a/GCD(a, b)*b; }\n\nstruct xydata {\n    int x; int y; int r; int c;\n};\n\nbool judge(xydata c1, xydata c2) {\n    ll xy = pow(c1.x-c2.x, 2) + pow(c1.y-c2.y, 2);\n    ll cr = pow(c1.r+c2.r, 2);\n    return xy < cr;\n}\n\nint n;\nint dp[(1<<25)];\n\nint main() {\n    while(1) {\n        cin >> n;\n        if(n == 0) break;\n        vector<xydata> circle(n);\n        for(int bit = 0; bit < (1<<n); ++bit) dp[bit] = -1;\n        vector<int> overlap(n, 0);  // 上に載っているところに1を立てる\n        for(int i = 0; i < n; ++i) {\n            xydata indata;\n            cin >> indata.x >> indata.y >> indata.r >> indata.c;\n            circle.at(i) = indata;\n            for(int j = 0; j < i; ++j) {\n                if(judge(circle.at(i), circle.at(j))) {\n                    overlap.at(i) |= (1<<j);\n                }\n            }\n        }\n\n        dp[0] = 0;\n        int ans = 0;\n        for(int bit = 0; bit < (1<<n); ++bit) {\n            if(dp[bit] == -1) continue;\n            chmax(ans, dp[bit]);\n            for(int i = 0; i < n; ++i) {\n                if((bit&(1<<i)) || (bit&overlap.at(i)) != overlap.at(i)) continue;\n                for(int j = i+1; j < n; ++j) {\n                    if(circle.at(i).c != circle.at(j).c || (bit&(1<<j)) || (bit&overlap.at(j)) != overlap.at(j)) continue;\n                    chmax(dp[bit|(1<<i)|(1<<j)], dp[bit]+2);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 24\nusing namespace std;\n\nint n,x[N],y[N],r[N],c[N],ans,len[N],cn;\nvector<int> v[N];\n\nvoid func(bool erased[N],int cnt,int x){\n  if(cn==10005000) return ;\n  cn++;\n  ans=max(ans,cnt);\n  for(int i=0;i<n;i++){\n    int f=0;\n    if(erased[i]) continue;\n    for(int j=0;j<len[i];j++)\n      if(!erased[v[i][j]]) f=1;\n    if(f) continue;\n    for(int j=i+1;j<n;j++){\n      if(c[i]!=c[j]) continue;\n      if(erased[j]) continue;\n      int f2=0;\n      for(int k=0;k<len[j];k++)\n\tif(!erased[v[j][k]]) f2=1;\n      if(f2) continue;\n      erased[i]=erased[j]=true;\n      func(erased,cnt+2,x+1);\n      erased[i]=erased[j]=false;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    cn=0;\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n      for(int j=i-1;j>=0;j--){\n\tint xl=x[i]-x[j],yl=y[i]-y[j];\n\tint rl=r[i]+r[j];\n\tif(xl*xl+yl*yl<rl*rl)v[i].push_back(j);\n      }\n    }\n    for(int i=0;i<n;i++) len[i]=v[i].size();\n    bool erased[N]={};\n    ans=0;\n    func(erased,0,0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++) v[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* constant */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n#define MAX_C\t(4)\n#define MAX_N\t(24)\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<double> vd;\ntypedef pair<int,int> pii;\ntypedef pair<long,long> pll;\ntypedef long long ll;\n\nstruct disk_t {\n  int x, y, r, c;\n};\n\n/* global variables */\n\nstatic char dists[1 << MAX_N];\n\n/* subroutines */\n\nbool overwrap(disk_t &dsk0, disk_t &dsk1) {\n  int dx = dsk1.x - dsk0.x;\n  int dy = dsk1.y - dsk0.y;\n  int rr = dsk0.r + dsk1.r;\n  return (dx * dx + dy * dy < rr * rr);\n}\n\n/* main */\n\nint main() {\n  int n;\n  \n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n\n    disk_t dsks[MAX_N];\n    vi clrs[MAX_C];\n    int ovs[MAX_N] = {};\n  \n    for (int i = 0; i < n; i++) {\n      cin >> dsks[i].x >> dsks[i].y >> dsks[i].r >> dsks[i].c;\n      dsks[i].c--;\n      clrs[dsks[i].c].push_back(i);\n\n      for (int j = 0; j < i; j++)\n\tif (overwrap(dsks[j], dsks[i]))\n\t  ovs[i] |= (1 << j);\n    }\n\n    queue<int> q;\n\n    char max_cnt = 0;\n    int st = (1 << n) - 1;\n    fill(dists, dists + (1 << n), -1);\n    dists[st] = 0;\n    q.push(st);\n\n    while (! q.empty()) {\n      int ubits = q.front();\n      q.pop();\n      \n      char ud = dists[ubits];\n      if (max_cnt < ud) max_cnt = ud;\n\n      char nvd = ud + 2;\n    \n      for (int c = 0; c < MAX_C; c++) {\n\tvi &ids = clrs[c];\n\tint len = ids.size();\n\n\tfor (int cid0 = 0; cid0 < len; cid0++) {\n\t  int id0 = ids[cid0];\n\t  int bit0 = (1 << id0);\n\t  if ((ubits & bit0) == 0 || (ubits & ovs[id0]) != 0) continue;\n\n\t  for (int cid1 = cid0 + 1; cid1 < len; cid1++) {\n\t    int id1 = ids[cid1];\n\t    int bit1 = (1 << id1);\n\t    if ((ubits & bit1) == 0 || (ubits & ovs[id1]) != 0) continue;\n\n\t    int vbits = ubits & ~(bit0 | bit1);\n\t    if (dists[vbits] < 0) {\n\t      dists[vbits] = nvd;\n\t      q.push(vbits);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    cout << (int)max_cnt << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#include<bitset>\n#include<random>\n#include<time.h>\n#include<fstream>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<(ll)m; i++)\n#define FOR(i,n,m) for(long long i=n; i<(ll)m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nvector<ll> dp;\nvector<vector<ll>> co(4);\nvector<P> pos;\nvector<P> cir;\nvector<ll> mask;\nll dfs(ll bit) {\n\tif(dp[bit]!=-1) return dp[bit];\n\tll ret=0;\n\tbitset<32> bi(bit);\n\tREP(i,4) {\n\t\tREP(j,(ll)co[i].size()) {\n\t\t\tif(bi[co[i][j]]==0||(bit&mask[co[i][j]])!=0) continue;\n\t\t\tREP(k,j) {\n\t\t\t\tif(bi[co[i][k]]==0||(bit&mask[co[i][k]])!=0) continue;\n\t\t\t\tbi[co[i][j]]=0;\n\t\t\t\tbi[co[i][k]]=0;\n\t\t\t\tret=max(ret,2+dfs(bi.to_ullong()));\n\t\t\t\tbi[co[i][j]]=1;\n\t\t\t\tbi[co[i][k]]=1;\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[bit]=ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n==0) return 0;\n\t\tdp.resize((1ll<<n));\n\t\tREP(i,4) co[i].resize(0);\n\t\tpos.resize(n);\n\t\tcir.resize(n);\n\t\tmask.resize(n);\n\t\tREP(i,(1ll<<n)) dp[i]=-1;\n\t\tREP(i,n) {\n\t\t\tll x,y,r,c;\n\t\t\tcin>>x>>y>>r>>c;\n\t\t\tc--;\n\t\t\tpos[i]=P(x,y);\n\t\t\tcir[i]=P(r,c);\n\t\t}\n\t\tREP(i,n) co[cir[i].second].pb(i);\n\t\tREP(i,n) {\n\t\t\tbitset<32> bi(0);\n\t\t\tREP(j,i) {\n\t\t\t\tif((pos[i].first-pos[j].first)*(pos[i].first-pos[j].first)+(pos[i].second-pos[j].\tsecond)*(pos[i].second-pos[j].second)<(cir[i].first+cir[j].first)*(cir[i].first+cir[j].first)) {\n\t\t\t\t\tbi[j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmask[i]=bi.to_ullong();\n\t\t}\n\t\tcout<<dfs((1ll<<n)-1ll)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nbool checked[17000000];\nint FREE[17000000];\nint x[25], y[25], r[25], c[25];\nvector<int> colorinv[5];\n\nint powd(int i, int j) {\n    int dx = x[i] - x[j];\n    int dy = y[i] - y[j];\n    return dx * dx + dy * dy;\n}\n\nint bitcount(int bit) {\n    if(bit == 0) return 0;\n    return (1 & bit) + bitcount(bit >> 1);\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        int n;\n        cin >> n; \n        if(n == 0) break;\n        for(int i = 0; i < n; i++) cin >> x[i] >> y[i] >> r[i] >> c[i];\n        for(int i = 0; i <= 4; i++) colorinv[i].clear();\n        for(int i = 0; i < n; i++) {\n            colorinv[c[i]].push_back(i);\n        }\n        for(int i = 0; i < (1 << n); i++) {\n            checked[i] = false;\n            FREE[i] = 0;\n        }\n        for(int i = 1; i < (1 << n); i++) {\n            int maxi = 0;\n            while(!(1 & (i >> maxi))) maxi++;\n            FREE[i] = FREE[i ^ (1 << maxi)];\n            for(int j = maxi + 1; j < n; j++) {\n                if(powd(j, maxi) < (r[j] + r[maxi]) * (r[j] + r[maxi])) FREE[i] &= ~(1 << j);\n            }\n            FREE[i] |= (1 << maxi);\n            //cerr << i << \" \" << FREE[i] << endl;\n        }\n        checked[(1<<n) - 1] = true;\n        int ans = 0;\n        for(int bit = (1<<n) - 1; bit >= 0; bit--) {\n            //cerr << bit << endl;\n            if(!checked[bit]) continue;\n            //cerr << bit << endl;\n            ans = max(ans, n - bitcount(bit));\n            for(int color = 0; color <= 4; color++) {\n                for(int i = 0; i < colorinv[color].size(); i++) {\n                    for(int j = i + 1; j < colorinv[color].size(); j++) {\n                        if((FREE[bit] >> colorinv[color][i]) & (FREE[bit] >> colorinv[color][j]) & 1) {\n                            int newbit = bit;\n                            newbit &= ~(1 << colorinv[color][i]);\n                            newbit &= ~(1 << colorinv[color][j]);\n                            checked[newbit] = true;\n                        }\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <functional>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n\n#define X first\n#define Y second\n#define mp(x, y) make_pair(x, y)\n#define pb(e) push_back(e)\n#define rep(i, b, n) for (int i = (b); i < (n); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define each(c, i) for (iter(c) i = (c).begin(); i != (c).end(); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\ntypedef pair<double, double> PDD;\ntypedef long long LINT;\ntypedef vector<int> VI;\ntypedef vector<VI> VII;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\n\nconst int MAX_N = 24;\nint N;\nint color[MAX_N];\nint ride[MAX_N];\nint x[MAX_N];\nint y[MAX_N];\nint r[MAX_N];\n\nbool isCollision ( int x1, int y1, int r1, int x2, int y2, int r2 )\n{\n\tint xx = x1 - x2, yy = y1 - y2, rr = r1 + r2;\n\treturn (xx * xx + yy * yy) < (rr * rr);\n}\n\nint dfs ( int state, int depth )\n{\n\tif (depth == N/2) { return 0; }\n\tint res = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif ((state & (1 << i)) && !(state & ride[i])) {\n\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\tif ((state & (1 << j)) && !(state & ride[j]) && color[i] == color[j]) {\n\t\t\t\t\tint next = state & ~((1 << i) | (1 << j));\n\t\t\t\t\tres = max(res, dfs(next, depth+1) + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint d[1 << MAX_N];\n\nint main ( void )\n{\n\twhile (cin >> N, N) {\n\t\tfill(ride, ride+N, 0);\n\t\trep (i, 0, N) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> color[i];\n\t\t\trep (j, 0, i) {\n\t\t\t\tif (isCollision(x[i], y[i], r[i], x[j], y[j], r[j])) {\n\t\t\t\t\tride[i] |= (1 << j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfill(d, d+(1 << N), -1);\n\t\tint state = (1 << N) - 1, ans = 0;\n\t\td[state] = 0;\n\t\tfor (; state > 0; --state) {\n\t\t\tif (d[state] == -1) { continue; }\n\t\t\trep (i, 0, N) {\n\t\t\t\tif (state & (1 << i) && !(state & ride[i])) {\n\t\t\t\t\trep (j, i+1, N) {\n\t\t\t\t\t\tif (state & (1 << j) && !(state & ride[j]) && color[i] == color[j]) {\n\t\t\t\t\t\t\tint next = state & ~((1 << i) | (1 << j));\n\t\t\t\t\t\t\td[next] = max(d[next], d[state] + 2);\n\t\t\t\t\t\t\tans = max(ans, d[next]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\t//cout << dfs((1 << N) - 1, 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#define x first.first\n#define y first.second\n#define r second.first\n#define color second.second\n \nusing namespace std;\n \ntypedef pair<double,double> P;\ntypedef pair<P,P> C;\n \nconst double EPS = 1e-10;\n \ndouble dist(C a,C b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n \nbool check(C a,C b){\n  return a.r+b.r-dist(a,b)>EPS;\n}\n \nint count(int bits){\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits =(((bits >> 4) + bits) & 0x0f0f0f0f);\n  bits += bits >> 8;\n  return (bits + (bits >> 16)) & 0xff;\n}\n \nbool dp[(1<<25)];\n \nint main(void){\n \n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<C>c(n);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin >> c[i].x >> c[i].y >> c[i].r >> c[i].color;\n     \n\t\tfill(dp,dp+(1<<n),false);\n\t\tdp[(1<<n)-1]=true;\n     \n\t\tfor(int S=(1<<n)-1;S>=0;S--){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\t\n\t\t\t\t\tif(c[i].color!=c[j].color)continue;\n       \n\t\t\t\t\tbool fg=false;\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(!(S>>k&1))continue;\n\t\t\t\t\t\tfg|= k<i && check(c[i],c[k]);\n\t\t\t\t\t\tfg|= k<j && check(c[j],c[k]);\n\t\t\t\t\t}\n\t\t\t\t\tif(fg)continue;\n\t\t\t\t\t\n\t\t\t\t\tint nx=S;\n\t\t\t\t\tnx&=~(1<<i);\n\t\t\t\t\tnx&=~(1<<j);\n\t\t\t\t\tdp[nx]|=dp[S];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tif(dp[i]){\n\t\t\t\tcout << n-count(i) << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circ{\n  vector<int> chil;\n  int useless;\n  bool done;\n};\nvoid Init();\nvoid Tree();\nint Solve();\ncirc BO[50];\ndouble P[50][3];\nvector< vector<int> > color(4); \nint n;\nint main(){\n  while(cin >>n,n){\n    Init();\n    for(int i=0,c; i<n; i++){\n      cin >>P[i][0]>>P[i][1]>>P[i][2]>>c;\n      color[c].push_back(i);\n    }\n    Tree();\n    cout <<Solve()<<endl;\n  }\n  return 0;\n}\nvoid Init(){\n  for(int i=0; i<4; i++) color[i].clear();\n  for(int i=0; i<10; i++){\n    BO[i].done = false;\n    BO[i].useless = 0;\n    BO[i].chil.clear();\n    P[i][0] = P[i][1] = P[i][2] = 0;\n  }\n}\nvoid Tree(){\n  for(int i=0; i<n; i++){\n    for(int j=i+1; j<n; j++){\n      double dx = P[i][0]-P[j][0];\n      double dy = P[i][1]-P[j][1];\n      double rr = P[i][2]+P[j][2];\n      if(dx*dx+dy*dy<rr*rr){\n\tBO[i].chil.push_back(j);\n\tBO[j].useless++;\n      }\n    }\n  }\n}\nint Solve(){\n  int ans = 0;\n  for(int i=0; i<4; i++){\n    for(int ii=0; ii<color[i].size(); ii++){\n      for(int jj=ii+1; jj<color[i].size(); jj++){\n\tint a = color[i][ii];\n\tint b = color[i][jj];\n\tif(BO[a].useless || BO[b].useless) continue;\n\tif(BO[a].done || BO[b].done) continue;\n\tBO[a].done = BO[b].done = true;\n\tfor(int k=0; k<BO[a].chil.size(); k++) BO[BO[a].chil[k]].useless--;\n\tfor(int k=0; k<BO[b].chil.size(); k++) BO[BO[b].chil[k]].useless--;\n\tint ANS = Solve()+2;\n\tif(ans<ANS) ans = ANS;\n\tBO[a].done = BO[b].done = false;\n\tfor(int k=0; k<BO[a].chil.size(); k++) BO[BO[a].chil[k]].useless++;\n\tfor(int k=0; k<BO[b].chil.size(); k++) BO[BO[b].chil[k]].useless++;\n      }\n    }\n  }\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <array>\n#include <utility>\ninline int getInt() { int s; scanf(\"%d\", &s); return s; }\n\n#define SIZE 10\ntypedef array<array<int, SIZE>, SIZE> Table;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nint g_c;\n\nvoid fillColor(Table &state, int from, int to) {\n\tif (from==to) return;\n\tvector<pair<int,int>> stack;\n\tstack.emplace_back(1,1);\n\twhile (!stack.empty()) {\n\t\tint x,y; tie(x, y) = stack.back();\n\t\tstack.pop_back();\n\t\tREP(i, 4) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (state[ny][nx] == from) {\n\t\t\t\tstack.emplace_back(nx,ny);\n\t\t\t\tstate[ny][nx] = to;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint countColor(Table & state) {\n\tvector<pair<int, int>> stack;\n\tstack.emplace_back(1, 1);\n\tint cnt = 0;\n\twhile (!stack.empty()) {\n\t\tint x,y; tie(x, y) = stack.back();\n\t\tstack.pop_back();\n\n\t\tREP(i, 4) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (state[ny][nx] == g_c) {\n\t\t\t\tstack.emplace_back(nx, ny);\n\t\t\t\tcnt++;\n\t\t\t\tstate[ny][nx] = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint recursion(int depth, Table state) {\n\tif (depth > 5) return countColor(state);\n\t\n\tint cnt = 1;\n\tREP(i, 6) {\n\t\tif(depth==5 && i != g_c) continue;\n\t\tTable ntable = state;\n\t\tntable[1][1] = i;\n\t\tfillColor(ntable, state[1][1], i);\n\t\tcnt = max(recursion(depth+1, ntable),cnt);\n\t}\n\treturn cnt;\n}\n\nint main() {\n\twhile (true) {\n\t\tll h,w;\n\t\tcin >> h >> w \n\t\tif (h == 0) break;\n\t\t\n\t\tg_c = getInt() - 1;\n\t\tTable table;\n\t\tREP(y, SIZE) REP(x, SIZE) table[y][x] = -1;\n\t\tREP(y, h) REP(x, w) table[y + 1][x + 1] = getInt()-1;\n\t\tcout << recursion(1, table) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nstruct Data\n{\n    int x;\n    int y;\n    int r;\n    int c;\n};\n\ntypedef struct Data D;\n\nint main()\n{\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        vector<D> input;\n        for(int i = 0; i < n; i++){\n            D tmpd;\n            cin >> tmpd.x >> tmpd.y >> tmpd.r >> tmpd.c;\n            input.push_back(tmpd);\n        }\n        int ans = 0;\n        while(1){\n            vector<vector<int> > color(4);\n            n = input.size();\n            for(int i = 0; i < n; i++){\n                bool notcovered = true;\n                for(int j = 0; j < i; j++){\n                    if(sqrt(pow(input[i].x - input[j].x, 2) + pow(input[i].y - input[j].y, 2)) < input[i].r + input[j].r){\n                        notcovered = false;\n                        break;\n                    }\n                }\n                if(notcovered) color[input[i].c - 1].push_back(i);\n            }\n            bool canremove = false;\n            for(int i = 0; i < 4; i++){\n                if(color[i].size() > 1){\n                    canremove = true;\n                    for(int j = 0; j < color[i].size(); j++){\n                        input.erase(input.begin() + color[i][j]);\n                        ans++;\n                    }\n                }\n            }\n            if(!canremove || input.size() < 2) break;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint sum=0,ds;\nint n;\nvoid rec(vector<circle> vs){\n  //cout << vs.size() << endl;\n  int i,j,k;\n  int f;\n  int on[100]={};\n  vector<int> cc[10];\n  vector<circle> next;\n  \n  f=1;\n  for(i=0;i<100;i++) on[i]=0;\n  for(i=0;i<vs.size();i++){\n    for(j=i+1;j<vs.size();j++){\n      if(ch(vs[i],vs[j])==1) on[j]=1;\n    }\n  }\n  for(i=0;i<vs.size();i++){\n    if(on[i]==0) cc[vs[i].c].push_back(i);\n  }\n  for(i=1;i<5;i++){\n    if(cc[i].size()>0&&cc[i].size()%2==0){\n      for(j=cc[i].size()-1;j>=0;j--){\n\tvs.erase(vs.begin()+cc[i][j]);\n\tf=0;\n      }\n    }\n  }\n  for(i=1;i<5;i++){\n    //cout << cc[i].size() << endl;\n    if(cc[i].size()>=2&&cc[i].size()%2==1){\n      f=0;\n      next.clear();\n      for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n      for(j=0;j<cc[i].size();j++){\n\tfor(k=cc[i].size()-1;k>=0;k--){\n\t  if(k!=j)\n\t    next.erase(next.begin()+cc[i][k]);\n\t}\n\trec(next);\n      }\n    }\n  }\n  int o=n-vs.size();\n  if(f==1) sum=max(sum,o);\n  else{\n    next.clear();\n    for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n    rec(next);\n  }\n}\n\nint main(){\n  cin >> n;\n  while(n!=0){\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    sum=0;\n    rec(v);\n    cout << sum << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\n\nclass state{\npublic:\n    P p;\n    double r;\n    int c;\n};\n\nbool onCircle(state a, state b){\n    return (abs(a.p-b.p) < a.r+b.r);\n}\n\nint a[1<<24];\n\nint main(){\n    int n;\n    while(cin >> n && n){\n        state v[24];\n        int ans = 0, over[24];\n        fill(over,over+n,0);\n        fill(a,a+(1<<n),0);\n        for(int i=0;i<n;i++){\n            double x,y;\n            cin >> x >> y >> v[i].r >> v[i].c;\n            v[i].p = P(x,y);\n        }\n\n        for(int i=0;i<n;i++)\n            for(int j=i+1;j<n;j++)\n                if(onCircle(v[i],v[j]))\n                    over[i] |= (1<<j);\n\n        for(int i=0;i<n;i++)\n            for(int j=n-1;j>i;j--)\n                over[i] |= over[j];\n\n        for(int i=0;i<(1<<n);i++){\n            int c = 0;\n            for(int j=0;j<n;j++){\n                if((i & (1<<j)) == 0 && (c & (1<<j)) == 0){\n                    c |= over[j];\n                    for(int k=j+1;k<n;k++){\n                        if((i & (1<<k)) == 0 && (c & (1<<k)) == 0 && v[j].c == v[k].c){\n                            int next = i | (1<<j) | (1<<k);\n                            a[next] = a[i] + 2;\n                            ans = max(ans,a[next]);\n                        }\n                    }\n                }\n            }\n        }\n\n\n\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint n;\nint x[25], y[25], r[25], c[25];\nbool board[25][25];\nbool memo[1<<24];\n\nvoid dfs(int S) {\n    if(!memo[S]) return;\n    vector<int> candidate;\n    rep(i,0,n) {\n        if(!(S >> i & 1)) continue;\n        bool ok = true;        \n        rep(j,0,i) {\n            if(!(S >> j & 1)) continue;\n            if(board[j][i]) ok = false;\n        }\n        if(ok) candidate.push_back(i);\n    }\n\n    int m = candidate.size();\n    rep(i,0,m) {\n        rep(j,i+1,m) {\n            int x = candidate[i], y = candidate[j];\n            if(c[x] == c[y]) {\n                int nbit = S ^ (1 << x) ^ (1 << y);\n                memo[nbit] = true;\n                dfs(nbit);\n            }\n        }\n    }\n}\n\nll dist(ll x1, ll y1, ll x2, ll y2) {\n    ll d1 = (x1-x2) * (x1-x2);\n    ll d2 = (y1-y2) * (y1-y2);\n    return d1 + d2;\n}\n\nbool in(ll x1, ll y1, ll r1, ll x2, ll y2, ll r2) {\n    double d1 = dist(x1, y1, x2, y2);\n    double d2 = (r1+r2) * (r1+r2);\n    return d1 < d2;\n}\n\nsigned main() {\n    while(cin >> n, n) {\n        memset(board, false, sizeof(board));\n        memset(memo, false, sizeof(memo));\n        rep(i,0,n) {\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n        rep(i,0,n) rep(j,0,i) {\n            if(in(x[i], y[i], r[i], x[j], y[j], r[j])) board[j][i] = true;\n        }\n        memo[(1<<n)-1] = true;\n        dfs((1<<n)-1);\n        int ans = 0;\n        rep(i,0,1<<n) {\n            if(memo[i]) {\n                // printf(\"true: i = %lld\\n\", i);\n                ans = max(ans, n - __builtin_popcount(i));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvvi color(4);\n\t\tvi x(n), y(n), r(n), c(n);\n\t\tREP(i, n) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t\tc[i]--;\n\t\t\tcolor[c[i]].push_back(i);\n\t\t}\n\t\tvi b(1 << n, 0);\n\t\tb[(1 << n) - 1] = 1;\n\t\tvvi g(n);\n\t\tvi d(n, 0);\n\t\tREP(i, n)FOR(j, i + 1, n) {\n\t\t\tif ((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) < (r[i] + r[j])*(r[i] + r[j])) {\n\t\t\t\tg[i].push_back(j);\n\t\t\t\td[j]++;\n\t\t\t}\n\t\t}\n\t\tqueue<int> q;\n\t\tq.push((1 << n) - 1);\n\t\twhile (!q.empty()) {\n\t\t\tint bit = q.front(); q.pop();\n\n\t\t\tvi a = d;\n\t\t\tREP(i, n) {\n\t\t\t\tif ((bit&(1 << i)) == 0) {\n\t\t\t\t\tREP(j, g[i].size()) {\n\t\t\t\t\t\ta[g[i][j]]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(i, n)REP(j, i + 1, n) {\n\t\t\t\tif (c[i] == c[j] && (bit&(1 << i)) && (bit&(1 << j)) && a[i] == 0 && a[j] == 0) {\n\t\t\t\t\tif (b[bit ^ i ^ j] == 0)q.push(bit ^ i ^ j);\n\t\t\t\t\tb[bit ^ i ^ j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tREP(i, 1 << n) {\n\t\t\tif (b[i] == 0)continue;\n\t\t\tint cnt = n;\n\t\t\tREP(j, n)if (i&(1 << j))cnt--;\n\t\t\tchmax(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e8\n#define EPS 1e-9\n\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) rep2(i,0,n)\n#define pb push_back\n\nint n,x[24],y[24],r[24],c[24];\nmap<int,int> M;\nmap<int,int>::iterator it;\n\nbool insec(int a,int b){\n\treturn (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b])<(r[a]+r[b])*(r[a]+r[b]);\n}\n\nint f(int s){\n\tit=M.find(s);\n\tif(it!=M.end())return M[s];\n\tint res=0,top[24];\n\tfill(top,top+n,1);\n\trep(i,n)rep(j,i)if(insec(i,j)&&((s>>j)&1))top[i]=0;\n\trep(i,n)rep(j,i){\n\t\tif(top[i]&&top[j]&&((s>>i)&1)&&((s>>j)&1)&&c[i]==c[j])res=max(res,f(s-(1<<i)-(1<<j))+2);\n\t}\n\treturn M[s]=res;\n}\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tM.clear();\n\t\trep(i,n)cin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\tcout<<f((1<<n)-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <map>\n#include <bitset>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){\n    rep(i,v.size()) os << v[i] << (i+1==v.size()?\"\":\" \");\n    return os;\n}\n\nint n;\nint x[24], y[24], r[24], c[24];\nbool hit[24][24];\nchar dp[1<<24];\n\nchar dfs(int S, int rem){\n    char & res = dp[S];\n    if(res!=-1) return res;\n    res = 0;\n    rep(i,n){\n        if(S>>i & 1){\n            rep(j,i){\n                if(S>>j & 1){\n                    if(hit[i][j] || c[i]!=c[j]) continue;\n                    bool ok = true;\n                    rep(k,i) if(hit[i][k] && (S>>k & 1)) ok = false;\n                    rep(k,j) if(hit[j][k] && (S>>k & 1)) ok = false;\n                    if(!ok) continue;\n                    S ^= 1<<i;\n                    S ^= 1<<j;\n                    res = max<char>(dfs(S,rem-2)+2, res);\n                    if(res==rem) return res;\n                    S ^= 1<<i;\n                    S ^= 1<<j;\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(cin>>n && n){\n        memset(dp,-1,sizeof(dp));\n        rep(i,n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n        rep(i,n)rep(j,i){\n            int dx=x[i]-x[j], dy=y[i]-y[j];\n            int d = dx*dx+dy*dy;\n            hit[i][j] = hit[j][i] = d < (r[i]+r[j])*(r[i]+r[j]);\n        }\n        int S = 0;\n        rep(i,n) S |= 1<<i;\n        cout << (int)dfs(S,n) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define EPS 1e-9\n\nclass circle {\npublic:\n  int c;\n  double x, y, r;\n  circle(double tx, double ty, double tr, int tc) {\n    x = tx;\n    y = ty;\n    r = tr;\n    c = tc;\n  }\n};\n\nvector <circle> tempCirc;\n\nbool collision(circle c1, circle c2) {\n  return c1.r+c2.r-hypot(c1.x-c2.x, c1.y-c2.y) >= EPS;\n}\n\nint memo[(2<<24)+1];\nint rec(int x) {\n  int n = tempCirc.size();\n  vector <int> field[n];\n\n  if (memo[x] != -1) return memo[x];\n  int ret = 0;\n  for (int i = n-1; i >= 0; i--) {\n    if (! ((x>>i)&1) ) continue;\n    for (int j = i-1; j >= 0; j--) {\n      if (! ((x>>j)&1) ) continue;\n      if (collision(tempCirc[i], tempCirc[j])) {\n\tfield[i].push_back(j);\n      }\n    }\n  }\n\n  vector <int> list;\n  for (int i = 0; i < n; i++) {\n    if (field[i].size() == 0) list.push_back(i);\n  }\n\n  for (int i = 0; i < list.size(); i++) {\n    for (int j = i+1; j < list.size(); j++) {\n      if (! (x&(1<<list[i])) ) continue;\n      if (! (x&(1<<list[j])) ) continue;\n      if (tempCirc[list[i]].c != tempCirc[list[j]].c) continue;\n      ret = max(ret, rec(x^(1<<list[i])^(1<<list[j]))+2 );\n      if (ret == 6) {\n\tstd::cout << static_cast<std::bitset<25> >(x) << std::endl;\n      }\n    }\n  }\n\n\n  return memo[x] = ret;\n}\n\nint main() {\n  int n;\n  while(true) {\n    cin >> n;\n    if (n == 0) break;\n    vector <circle> circ;\n    for (int i = 0; i < n; i++) {\n      int c;\n      double x, y, r;\n      cin >> x >> y >> r >> c;\n      circ.push_back(circle(x, y, r, c));\n    }\n    tempCirc = circ;\n\n    memset(memo, -1, sizeof(memo));\n    std::cout << rec((1<<n)-1) << std::endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\n\n#define all(c) ((c).begin()), ((c).end())\n#define debug(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\n\nconst double EPS = 1e-10;\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\n\nstruct C{\n\tP p;\n\tint r;\n\tint c;\n};\n\nmap<int, int> dp;\nint n;\nvector<C> cs;\n\nint next_combination(int p){\n    int lsb = p&-p;\n    int rem = p+lsb;\n    int rit = rem&~p;\n    return rem|(((rit/lsb)>>1)-1);\n}\n\nint go(int mask) {\n\tif(mask == 0) return 0;\n\tif(present(dp, mask)) return dp[mask];\n\tint res = 0;\n\tint bn = __builtin_popcount(mask);\n\tbn -= 2;\n\tif (bn < 0) return 0;\n\tfor(int next = (1 << bn) - 1; next < (1 << n); next = next_combination(next)) {\n\t\tif((mask | next) != mask) continue;\n\t\tint use = mask ^ next;\n\t\tint i = __builtin_ctz(use);\n\t\tint j = __builtin_ctz(use >> (i + 1)) + i + 1;\n\t\tif(cs[i].c != cs[j].c) continue;\n\t\tbool ok = true;\n\t\trep(k, i) if(mask & (1 << k)) if (cs[i].r + cs[k].r > abs(cs[i].p - cs[k].p)) ok = false;\n\t\trep(k, j) if(mask & (1 << k)) if (cs[j].r + cs[k].r > abs(cs[j].p - cs[k].p)) ok = false;\n\t\tif(!ok) {\n\t\t\tif(next) continue;\n\t\t\telse break;\n\t\t}\n\t\tres = max(res, go(next) + 2);\n\t}\n\treturn dp[mask] = res;\n}\n\nint main() {\n\tfor (; cin >> n, n != 0; ) {\n\t\tcs.clear();\n\t\trep (i, n) {\n\t\t\tC c; int x, y; cin >> x >> y >> c.r >> c.c;\n\t\t\tc.p = P(x, y);\n\t\t\tcs.pb(c);\n\t\t}\n\t\tdp.clear();\n\t\tcout << go((1 << n) -1) << endl;;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n;i++){\n        if(((bit>>i)&1)==0||ok(i,bit)==false)continue;\n        for(int j=i+1;j<n;j++){\n            if(((bit>>j)&1)==0)continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(c[i]==c[j]&&ok(j,bit)&&!memo[to_bit]){\n                ret=max(ret,dfs(to_bit));\n            }\n        }\n    }\n\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\n\n\nint main(){\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\n\nclass state{\npublic:\n    P p;\n    double r;\n    int c;\n};\n\nbool onCircle(state a, state b){\n    return (abs(a.p-b.p) < a.r+b.r);\n}\n\nshort int a[1<<24];\n\nint main(){\n    int n;\n    while(cin >> n && n){\n        state v[24];\n        int ans = 0, over[24];\n        fill(over,over+n,0);\n        fill(a,a+(1<<n),0);\n        for(int i=0;i<n;i++){\n            double x,y;\n            cin >> x >> y >> v[i].r >> v[i].c;\n            v[i].p = P(x,y);\n        }\n\n        for(int i=0;i<n;i++)\n            for(int j=i+1;j<n;j++)\n                if(onCircle(v[i],v[j]))\n                    over[i] |= (1<<j);\n\n        for(int i=0;i<n;i++)\n            for(int j=n-1;j>i;j--)\n                over[i] |= over[j];\n\n        for(int i=0;i<(1<<n);i++){\n            int c = 0;\n            for(int j=0;j<n;j++){\n                if((i & (1<<j)) == 0 && (c & (1<<j)) == 0){\n                    c |= over[j];\n                    for(int k=j+1;k<n;k++){\n                        if((i & (1<<k)) == 0 && (c & (1<<k)) == 0 && v[j].c == v[k].c){\n                            int next = i | (1<<j) | (1<<k);\n                            a[next] = a[i] + 2;\n                            ans = max((short int)ans,a[next]);\n                        }\n                    }\n                }\n            }\n        }\n\n\n\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n;\nstruct po {int x,y,r,g;};\nvector <po> c[5];\n\nint cal(int x1,int y1,int x2,int y2){\n  return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n}\n\nbool check(po n){\n  for(int i=1;i<=4;i++)\n    for(int j=0;j<c[i].size();j++)\n      if(c[i][j].g<n.g&&cal(c[i][j].x,c[i][j].y,n.x,n.y) < (c[i][j].r+n.r)*(c[i][j].r+n.r)) return false;\n  return true;\n}\n\nint main(){\n  while(1){\n    cin >> n;\n    if(n==0)break;\n\n    int x,y,r,col;\n    for(int i=0;i<=4;i++) c[i].clear();\n    for(int i=0;i<n;i++)cin >>x>>y>>r>>col, c[col].push_back((po){x,y,r,i});\n\n    int ans = 0;\n    while(1){\n      int sum = 0;\n      for(int i=1;i<=4;i++){\n\tvector <int> top;\n\tfor(int j=0;j<(int)c[i].size();j++)if(check(c[i][j])==true) top.push_back(j);\n\tif(top.size()==2)c[i].erase(c[i].begin()+top[1]),c[i].erase(c[i].begin()+top[0]),sum+=2;\n      }\n      ans+=sum;\n      if(sum==0)break;\n    }\n    cout << ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct Disk{ int x,y,r,c; };\n\nint n;\nDisk D[24];\n\nint overlap[24],dp[1<<24];\n\nint dfs(int used){\n\tif(~dp[used]) return dp[used];\n\n\tint nc[4]={},top[4][6];\n\trep(i,n) if((used&(1<<i))==0 && (overlap[i]&used)==overlap[i]) {\n\t\ttop[D[i].c][nc[D[i].c]++]=i;\n\t}\n\n\tint ans=0;\n\trep(c,4) rep(j,nc[c]) rep(i,j) {\n\t\tans=max(ans,dfs(used|(1<<top[c][i])|(1<<top[c][j]))+2);\n\t}\n\treturn dp[used]=ans;\n}\n\n#define sq(x) ((x)*(x))\n#define sqsum(x,y) (sq(x)+sq(y))\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\trep(S,1<<n) dp[S]=-1;\n\t\trep(i,n) scanf(\"%d%d%d%d\",&D[i].x,&D[i].y,&D[i].r,&D[i].c), D[i].c--;\n\n\t\trep(i,n){\n\t\t\toverlap[i]=0;\n\t\t\trep(j,i) if(sqsum(D[i].x-D[j].x,D[i].y-D[j].y)<sq(D[i].r+D[j].r)) {\n\t\t\t\toverlap[i]|=1<<j;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",dfs(0));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#define HIT(a,b) ((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r))\n\nusing namespace std;\n\nstruct DISK {\n\tint x,y,r,c,f;\n};\nint n;\n\nvoid setontop(DISK *D){\n\tint i,j;\n\tfor(i=0;i<n;i++){\n\t\tD[i].f=D[i].r;\n\t\tfor(j=i+1;j<n;j++)\n\t\t\tif(D[j].r && HIT(D[i],D[j])) D[i].f=0;\n\t}\n}\n\nint solve(DISK *D){\n\tint i,j,k,min=30,ret;\n\tsetontop(D);\n\tfor(i=1;i<=4;i++){\n\t\tchar list[6],li=0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(D[j].f&&D[j].c==i) list[li++]=j;\n\t\t}\n\t\tif(li<2)continue;\n\t\tDISK tmp[30];\n\t\tfor(j=0;j<li;j++){\n\t\t\tfor(k=j+1;k<li;k++){\n\t\t\t\tmemcpy(tmp,D,sizeof(tmp));\n\t\t\t\ttmp[list[j]].r=0;\n\t\t\t\ttmp[list[k]].r=0;\n\t\t\t\tret=solve(tmp);\n\t\t\t\tif(ret<min)min=ret;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ret=0,i=0;i<n;i++)if(D[i].r)ret++;\n\tif(ret<min)min=ret;\n\treturn min;\n}\n\nint main(){\n\tint i,j;\n\twhile(cin>>n,n){\n\t\tDISK D[30];\n\t\tfor(i=n;i-->0;) cin>>D[i].x>>D[i].y>>D[i].r>>D[i].c;\n\t\tcout<<n-solve(D)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nstruct Solver\n{\n\tconst int N;\n\tVI xs, ys, rs, cs;\n\tset< vector<bool> > visited;\n\n\tint res;\n\n\tSolver( int n ) : N( n ), xs( N ), ys( N ), rs( N ), cs( N ), res( 0 )\n\t{\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tcin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n\t\t}\n\t\treturn;\n\t}\n\n\toperator int()\n\t{\n\t\tdfs( vector<bool>( N, true ) );\n\t\treturn res;\n\t}\n\n\tvoid dfs( vector<bool> exists )\n\t{\n\t\tif ( EXIST( visited, exists ) )\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tvisited.insert( exists );\n\t\tres = max<int>( res, count( ALL( exists ), false ) );\n\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tREP( j, 0, i )\n\t\t\t{\n\t\t\t\tif ( !exists[i] || !exists[j] || cs[i] != cs[j] )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( !overlapped( exists, i ) && !overlapped( exists, j ) )\n\t\t\t\t{\n\t\t\t\t\texists[i] = exists[j] = false;\n\t\t\t\t\tdfs( exists );\n\t\t\t\t\texists[i] = exists[j] = true;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\tbool overlapped( const vector<bool> &exists, const int p )\n\t{\n\t\tREP( i, 0, p )\n\t\t{\n\t\t\tif ( !exists[i] )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( ( xs[p] - xs[i] ) * ( xs[p] - xs[i] ) + ( ys[p] - ys[i] ) * ( ys[p] - ys[i] ) < ( rs[i] + rs[p] ) * ( rs[i] + rs[p] ) )\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int n; cin >> n, n; )\n\t{\n\t\tcout << Solver( n ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\nbool circle_overlapping(int y1, int x1, int r1, int y2, int x2, int r2) {\n    int dx = x2 - x1;\n    int dy = y2 - y1;\n    int d = r1 + r2;\n    return dx * dx + dy * dy < d * d;\n}\n\nbool can_remove(int idx1, int idx2, const vector<tuple<int, int, int, int>> &v, vector<int> idx_list) {\n    int x1, y1, r1, c1, x2, y2, r2, c2;\n    tie(x1, y1, r1, c1) = v[idx1];\n    tie(x2, y2, r2, c2) = v[idx2];\n\n    if (c1 != c2) {\n        return false;\n    }\n\n    FOE(i, idx_list) {\n        if (i == idx1) {\n            break;\n        }\n        int x3, y3, r3, c3;\n        tie(x3, y3, r3, c3) = v[i];\n        if (circle_overlapping(y1, x1, r1, y3, x3, r3)) {\n            return false;\n        }\n    }\n    FOE(i, idx_list) {\n        if (i == idx2) {\n            break;\n        }\n        int x3, y3, r3, c3;\n        tie(x3, y3, r3, c3) = v[i];\n        if (circle_overlapping(y2, x2, r2, y3, x3, r3)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n\tios::sync_with_stdio(false);\n\n    while (true) {\n        int N;\n        cin >> N;\n        if (N == 0) {\n            break;\n        }\n        vector<tuple<int, int, int, int>> v;\n        FOR(i, 0, N) {\n            int x, y, r, c;\n            cin >> x >> y >> r >> c;\n            v.emplace_back(make_tuple(x, y, r, c));\n        }\n\n        int ans = 0;\n        vector<bool> dp(1LL << (N + 1), false);\n        dp[0] = true;\n        FOR(b, 0, 1LL << (N + 1)) {\n            if (not dp[b]) {\n                continue;\n            }\n\n            vector<int> idx_list;\n            FOR(i, 0, N) {\n                if (not (b & (1 << i))) {\n                    idx_list.emplace_back(i);\n                }\n            }\n\n            vector<int> vv;\n            FOR(i, 0, idx_list.size()) {\n                int x1, y1, r1, c1;\n                tie(x1, y1, r1, c1) = v[idx_list[i]];\n                bool ok = true;\n                for(int j = i - 1; j >= 0; --j) {\n                    int x2, y2, r2, c2;\n                    tie(x2, y2, r2, c2) = v[idx_list[j]];\n                    if (circle_overlapping(y1, x1, r1, y2, x2, r2)) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) {\n                    vv.emplace_back(idx_list[i]);\n                }\n            }\n\n            FOR(i, 0, vv.size()) {\n                FOR(j, i + 1, vv.size()) {\n                    int x1, y1, r1, c1, x2, y2, r2, c2;\n                    tie(x1, y1, r1, c1) = v[vv[i]];\n                    tie(x2, y2, r2, c2) = v[vv[j]];\n                    if (c1 == c2) {\n                        int key = (b | (1 << vv[i]) | (1 << vv[j]));\n                        dp[key] = true;\n                        ans = max(ans, __builtin_popcount(key));\n                    }\n                }\n            }\n        }\n\n        print(ans);\n    }\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\nvector<vector<int> >vec;\nvoid dfs(vector<int>tmp){\n    if(tmp.size() == 6){\n        vec.push_back(tmp);\n        return;\n    }\n    for(int i = 0; i < 6; i++){\n        int check = 0;\n        for(int j = 0; j < tmp.size(); j++)if(tmp[j] == i)check = 1;\n        if(check)continue;\n        vector<int>cp = tmp;\n        cp.push_back(i);\n        dfs(cp);\n        if(tmp.size() % 2 == 0)break;\n    }\n}\n\n\nint main(){\n    dfs(vector<int>(0));\n    for(int n; cin >> n, n; ){\n        vector<int>X(n), Y(n), R(n), C(n);\n        vector<int>en[4];\n        // ue[a][b]//aの上にbがある\n        int ue[32][32] = {};\n        for(int i = 0; i < n; i++){\n            cin >> X[i] >> Y[i] >> R[i] >> C[i];\n            en[C[i] - 1].push_back(i);\n        }\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                int RR = (R[i] + R[j]) * (R[i] + R[j]);\n                int rr = (X[i] - X[j]) * (X[i] - X[j]) + (Y[i] - Y[j]) * (Y[i] - Y[j]);\n                if(rr < RR)ue[j][i] = 1;\n            }\n        }\n        int ans = 0;\n        for(int i = 0; i < 4; i++){\n            while(en[i].size() < 6)en[i].push_back(-1);\n        }\n        for(int a = 0; a < 15; a++){\n            for(int b = 0; b < 15; b++){\n                for(int c = 0; c < 15; c++){\n                    for(int d = 0; d < 15; d++){\n                        int tmp = 0;\n                        int are[4] = {a, b, c, d};\n                        int rm[32] = {};\n                        for(int flg = 1; flg;){\n                            flg = 0;\n                            for(int i = 0; i < 4; i++){\n                                for(int j = 0; j < 6; j+=2){\n                                    int A = en[i][vec[are[i]][j]];\n                                    int B = en[i][vec[are[i]][j + 1]];\n                                    if(A == -1)continue;\n                                    if(B == -1)continue;\n                                    if(rm[A])continue;\n                                    if(rm[B])continue;\n                                    int aok = 1, bok = 1;\n                                    for(int k = 0; k < n; k++){\n                                        if(ue[A][k] && rm[k] == 0)aok = 0;\n                                        if(ue[B][k] && rm[k] == 0)bok = 0;\n                                    }\n                                    if(aok && bok){\n                                        rm[A] = 1;\n                                        rm[B] = 1;\n                                        tmp += 2;\n                                        flg = 1;\n                                    }\n                                }\n                            }\n                        }\n                        ans = max(ans, tmp);\n                    }\n                }\n            }\n        }\n        \n\n        cout << ans << endl;\n    }\n    \n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n\tint n;\nint dp[1<<24];\nconst int NONE=-1;\nint dfs(vi &c,vvi &g,vi &cnt,int mask){\n\tint ret=0;\n\tif(dp[mask]!=NONE){\n\t\treturn dp[mask];\n\t}\n\tREP(i,n){\n\t\tFOR(j,i+1,n){\n\t\t\tif(cnt[i]==0&&cnt[j]==0&&c[i]==c[j]&&!(mask&(1<<i))&&!(mask&(1<<j))){\n\t\t\t\tvvi ng(g);\n\t\t\t\tvi ncnt(cnt);\n\t\t\t\tREP(k,n){\n\t\t\t\t\tif(g[i][k]){\n\t\t\t\t\t\tng[i][k]=0;\n\t\t\t\t\t\tncnt[k]--;\n\t\t\t\t\t}\n\t\t\t\t\tif(g[j][k]){\n\t\t\t\t\t\tng[j][k]=0;\n\t\t\t\t\t\tncnt[k]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint nmask=mask;\n\t\t\t\tnmask|=(1<<i);\n\t\t\t\tnmask|=(1<<j);\n\t\t\t\tret=max(ret,dfs(c,ng,ncnt,nmask)+2);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[mask]=ret;\n}\n\nint main(){\n\twhile(cin>>n,n){\n\t\tREP(i,(1<<24)){\n\t\t\tdp[i]=NONE;\n\t\t}\n\t\tvi x(n),y(n),r(n),c(n);\n\t\tvvi g(n,vi(n));\n\t\tvi cnt(n);\n\t\tREP(i,n){\n\t\t\tcin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\t}\n\t\tREP(i,n){\n\t\t\tFOR(j,i+1,n){\n\t\t\t\tint dx=abs(x[i]-x[j]);\n\t\t\t\tint dy=abs(y[i]-y[j]);\n\t\t\t\tint rr=r[i]+r[j];\n\t\t\t\tif(dx*dx+dy*dy<rr*rr){\n\t\t\t\t\tg[i][j]=1;\n\t\t\t\t\tcnt[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dfs(c,g,cnt,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nstruct en{\n    int x, y, r, c;\n    vector<int> over;\n};\n\nint n, ans;\n\nvoid solve(vector<en> e) {\n    vector<vector<int> > a(5, vector<int>());\n    for (int i = 0; i < n; i++) {\n        if (!e[i].c) continue;\n        bool f = true;\n        for (int j = 0; j < e[i].over.size(); j++) {\n            int t = e[i].over[j];\n            if (e[t].c != 0) f = false;\n        }\n        if (f) a[e[i].c].push_back(i);\n    }\n    \n    if (a[1].size() < 2 && a[2].size() < 2 && a[3].size() < 2 && a[4].size() < 2) {\n        int cnt = 0;\n        for (int i = 0; i < n; i++) if (e[i].c == 0) cnt++;\n        ans = max(ans, cnt);\n        return;\n    }\n    \n    for (int i = 1; i < 5; i++) {\n        for (int j = 0; j < a[i].size(); j++) {\n            e[a[i][j]].c = 0;\n        }\n    }\n    \n    int w1=0, w2=0, w3=0, w4=0; \n    while (1) {\n        vector<en> e2 = e;\n        \n        bool f1 = false;\n        if (a[1].size() && a[1].size()%2 && w1 < a[1].size()) e2[a[1][w1]].c = 1, f1 = true;\n        while (1) {\n            bool f2 = false;\n            if (a[2].size() && a[2].size()%2 && w2 < a[2].size()) e2[a[2][w2]].c = 2, f2 = true;\n            while (1) {\n                bool f3 = false;\n                if (a[3].size() && a[3].size()%2 && w3 < a[3].size()) e2[a[3][w3]].c = 3, f3 = true;\n                while (1) {\n                    bool f4 = false;\n                    if (a[4].size() && a[4].size()%2 && w4 < a[4].size()) e2[a[4][w4]].c = 4, f4 = true;\n                    \n                    solve(e2);\n                    \n                    if (f4) e2[a[4][w4]].c = 0, w4++;\n                    if (a[4].size() == w4 || a[4].size()%2 == 0) {\n                        w4 = 0;\n                        break;\n                    }\n                }\n                if (f3) e2[a[3][w3]].c = 0, w3++;\n                if (a[3].size() == w3 || a[3].size()%2 == 0) {\n                    w3 = 0;\n                    break;\n                }\n            }\n            if (f2) e2[a[2][w2]].c = 0, w2++;\n            if (a[2].size() == w2 || a[2].size()%2 == 0) {\n                w2 = 0;\n                break;\n            }\n        }\n        if (f1) e2[a[1][w1]].c = 0, w1++;\n        if (a[1].size() == w1 || a[1].size()%2 == 0) {\n            w1 = 0;\n            break;\n        }\n    }\n\n}\n\nint main(void){\n    while (cin>>n && n) {\n        vector<en> e(n);\n        ans = 0;\n        for (int i = 0; i < n; i++) {\n            cin >> e[i].x >> e[i].y >> e[i].r >> e[i].c;\n            for (int j = 0; j < i; j++) {\n                int tx = e[i].x - e[j].x;\n                int ty = e[i].y - e[j].y;\n                double a = sqrt(tx*tx + ty*ty);\n                if (a >= e[i].r + e[j].r) continue;\n                e[i].over.push_back(j);\n            }\n        }\n        solve(e);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define x first.first\n#define y first.second\n#define r second.first\n#define color second.second\n\nusing namespace std;\n\ntypedef pair<double,double> P;\ntypedef pair<P,P> C;\n\nbool check(C a,C b){\n  return a.r+b.r>sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n \nint count(int bits){\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits =(((bits >> 4) + bits) & 0x0f0f0f0f);\n  bits += bits >> 8;\n  return (bits + (bits >> 16)) & 0xff;\n}\n \nbool dp[(1<<25)];\n \nint main(void){\n \n\tint n;\n\twhile(cin >> n,n){\n\t\tC c[25];\n\t\tfor(int i=0;i<n;i++){\n\t\t\t//cin >> c[i].x >> c[i].y >> c[i].r >> c[i].color;\n\t\t\tscanf(\"%lf %lf %lf %lf\",&c[i].x,&c[i].y,&c[i].r,&c[i].color);\n\t\t}\n\t\t\n\t\tfill(dp,dp+(1<<n),false);\n\t\tdp[(1<<n)-1]=true;\n\t\tint ans=0;\n\t\t\n\t\tfor(int S=(1<<n)-1;S>=0;S--){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\t\n\t\t\t\t\tint nx=S;\n\t\t\t\t\tnx&=~(1<<i);\n\t\t\t\t\tnx&=~(1<<j);\n\t\t\t\t\tif(dp[nx])continue;\n\t\t\t\t\t\n\t\t\t\t\tif(!(S>>i&1) || !(S>>j&1))continue;\n\t\t\t\t\tif(c[i].color!=c[j].color)continue;\n\t\t\t\t\t\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(!(S>>k&1))continue;\n\t\t\t\t\t\tif((k<i && check(c[i],c[k]))||(k<j && check(c[j],c[k])))goto end;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdp[nx]|=dp[S];\n\t\t\t\t\tend:;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp[S])ans=max(ans,n-count(S));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#include<memory>\n\n\nusing namespace std;\n//#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double,int> pdi;\ntypedef pair<long double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst long double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\n//const ll mod = 998244353;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst long double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG\n\n#define DUMPOUT cerr\n\n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\nint dp[1LL<<24];\n\nint dfs(int n, int State, vector<vector<int>>& g, vector<int>& c, vector<int>& deg) {\n  if (dp[State] != 0) return dp[State];\n  if (State == (1LL<<n) - 1LL) return 0;\n  vector<int> kouho;\n  rep(i, n) {\n    if (!(State>>i & 1) && deg[i] == 0) kouho.push_back(i);\n  }\n  int m = kouho.size();\n  rep(i, m) {\n    rep2(j, i+1, m) {\n      int a = kouho[i];\n      int b = kouho[j];\n      if (c[a] != c[b]) continue;\n      int NextState = (State | (1LL<<a));\n      NextState |= (1LL<<b);\n      vector<int> Nextdeg = deg;\n      for (auto u : g[a]) {\n        Nextdeg[u]--;\n      }\n      for (auto v : g[b]) {\n        Nextdeg[v]--;\n      }\n      dp[State] = max(dp[State], dfs(n, NextState, g, c, Nextdeg) + 2);\n    }\n  }\n  return dp[State];\n}\n\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n;\n  while (cin >> n) {\n    if (n == 0) break;\n    vector<vector<int>> g(n);\n    vector<int> x(n), y(n), r(n), c(n);\n    vector<int> deg(n);\n    rep(i, n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n    rep(i, n-1) {\n      rep2(j, i+1, n) {\n        int d = (x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]);\n        int rd = (r[j] + r[i]) * (r[j] + r[i]);\n        if (d < rd) {\n          g[i].push_back(j);\n          g[j].push_back(i);\n          deg[j]++;\n        }\n      }\n    }\n    //dump(deg);\n    rep(i, (1LL<<n)) dp[i] = 0;\n    cout << dfs(n, 0, g, c, deg) << endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n\tint n;\nchar dp[1<<24];\nconst char NONE=255;\nint dfs(vi &c,vvi &g,vi &cnt,int mask){\n\tint ret=0;\n\tif(dp[mask]!=NONE){\n\t\treturn dp[mask];\n\t}\n\tREP(i,n){\n\t\tFOR(j,i+1,n){\n\t\t\tif(cnt[i]==0&&cnt[j]==0&&c[i]==c[j]&&!(mask&(1<<i))&&!(mask&(1<<j))){\n\t\t\t\tvi ncnt(cnt);\n\t\t\t\tREP(k,n){\n\t\t\t\t\tif(g[i][k]){\n\t\t\t\t\t\tncnt[k]--;\n\t\t\t\t\t}\n\t\t\t\t\tif(g[j][k]){\n\t\t\t\t\t\tncnt[k]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint nmask=mask;\n\t\t\t\tnmask|=(1<<i);\n\t\t\t\tnmask|=(1<<j);\n\t\t\t\tret=max(ret,dfs(c,g,ncnt,nmask)+2);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[mask]=ret;\n}\n\nint main(){\n\twhile(cin>>n,n){\n\t\tREP(i,(1<<24)){\n\t\t\tdp[i]=NONE;\n\t\t}\n\t\tvi x(n),y(n),r(n),c(n);\n\t\tvvi g(n,vi(n));\n\t\tvi cnt(n);\n\t\tREP(i,n){\n\t\t\tcin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\t}\n\t\tREP(i,n){\n\t\t\tFOR(j,i+1,n){\n\t\t\t\tint dx=abs(x[i]-x[j]);\n\t\t\t\tint dy=abs(y[i]-y[j]);\n\t\t\t\tint rr=r[i]+r[j];\n\t\t\t\tif(dx*dx+dy*dy<rr*rr){\n\t\t\t\t\tg[i][j]=1;\n\t\t\t\t\tcnt[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dfs(c,g,cnt,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    vector<int> X(n), Y(n), R(n), C(n);\n    map<int, vector<int> > M;\n    for(int i = 0; i < n; ++i){\n      cin >> X[i] >> Y[i] >> R[i] >> C[i];\n      M[C[i]].push_back(i);\n    }\n    vector<int> DP(1<<n, -1);\n    DP[0] = 0;\n    for(int i = 0; i < 1<<n; ++i){\n      if(DP[i] < 0) continue;\n      for(int j = 0; j < n; ++j){\n        bool f = true;\n        if((i>>j) & 1) continue;\n        for(int l = 0; l < j; ++l){\n          if((!((i>>l)&1)) && (X[l] - X[j])*(X[l] - X[j]) + (Y[l] - Y[j])*(Y[l] - Y[j]) < (R[l] + R[j])*(R[l] + R[j])){\n            f = false;\n            break;\n          }\n        }\n        if(!f) continue;\n        int c = C[j];\n        for(int k = 0; k < M[c].size(); ++k){\n          int a = M[c][k];\n          if(a == j || ((i>>a) & 1)) continue;\n          f = true;\n          for(int l = 0; l < a; ++l){\n            if((!((i>>l)&1)) && (X[l] - X[a])*(X[l] - X[a]) + (Y[l] - Y[a])*(Y[l] - Y[a]) < (R[l] + R[a])*(R[l] + R[a])){\n              f = false;\n              break;\n            }\n          }\n          if(f){\n            //cout << j << \" \" << a << endl;\n            DP[i|(1<<j)|(1<<a)] = max(DP[i|(1<<j)|(1<<a)], DP[i] + 2);\n          }\n        }\n      }\n    }\n    int ans = 0;\n    for(int i = 0; i < 1<<n; ++i){\n      //cout << i << \" \" << DP[i] << endl;\n      ans = max(ans, DP[i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint x[50],y[50],r[50],c[50];\nint n;\n\nchar dp[1 << 24];\n\nint main(){\n  while(cin >> n,n){\n    vector<bool> used(50);\n    int ond[50] = {};\n    for(int i = 0; i < n; i++){\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n      ond[i] = 0;\n      for(int j = 0; j < i; j++){\n        int dx = abs(x[i] - x[j]);\n        int dy = abs(y[i] - y[j]);\n        int dr = r[i] + r[j];\n        if(dx * dx + dy * dy < dr * dr){\n            ond[i] |= (1 << j);\n        }\n      }\n    }\n    int ans = 0;\n    memset(dp, -1, sizeof(dp));\n    dp[0] = 0;\n    for(int bit = 0; bit < 1 << n; bit++){\n        if(dp[bit] == -1) continue;\n        ans = max(ans, (int)dp[bit]);\n        for(int i = 0; i < n - 1; i++){\n            if((bit & (1 << i)) != 0 || (ond[i] & bit) != ond[i]) continue;\n            for(int j = i + 1; j < n; j++){\n                if(c[i] != c[j] || (bit & (1 << j)) != 0 || (ond[j] & bit) != ond[j]) continue;\n                int nx = bit | (1 << i) | (1 << j);\n                dp[nx] = max((int)dp[nx], dp[bit] + 2);\n            }\n        }\n      }\n      cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <bitset>\nusing namespace std;\n\ntypedef complex< int > Point;\n\nint N;\nPoint p[24];\nint R[24], C[24];\nint f[1 << 24];\n\nvoid read_plate(void);\nvoid solve(void);\nint dp(int);\nbool is_valid(int, int);\n\nint main() {\n  while (cin >> N, N) {\n    read_plate();\n    solve();\n  }\n\n  return 0;\n}\n\nvoid read_plate(void) {\n  for (int i = 0; i < N; ++i) {\n    int x, y;\n    cin >> x >> y >> R[i] >> C[i];\n    p[i] = Point(x, y);\n  }\n}\n\nvoid solve(void) {\n  fill(&f[0], &f[1 << N], -1);\n  cout << dp((1 << N) - 1) << endl;\n}\n\nint dp(int m) {\n  if (f[m] != -1) return f[m];\n  if (m == 0)     return 0;\n\n  f[m] = 0;\n//  cout << \"m = \" << bitset< 7 >(m) << endl;\n  for (int i = 0; i < N; ++i)\n    if ((1 << i & m) && is_valid(i, m))\n      for (int j = 0; j < N; ++j)\n        if ((1 << j & m) && i != j && C[i] == C[j] && is_valid(j, m))\n          f[m] = max(f[m], dp(m & ~(1 << i) & ~(1 << j)) + 2);\n\n  return f[m];\n}\n\nbool is_valid(int qi, int qm) {\n  for (int i = qi - 1; i >= 0; --i)\n    if ((1 << i & qm) && norm(p[i] - p[qi]) < (R[i] + R[qi]) * (R[i] + R[qi]))\n      return false;\n  return true;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circ{\n  vector<int> chil;\n  int useless;\n  bool done;\n};\nvoid Init();\nvoid Tree();\nint Solve();\ncirc BO[50];\ndouble P[50][3];\nchar dp[(1<<24)];\nvector< vector<int> > color(4);\nint n;\nint main(){\n  while(cin >>n,n){\n    Init();\n    for(int i=0,c; i<n; i++){\n      cin >>P[i][0]>>P[i][1]>>P[i][2]>>c;\n      color[c-1].push_back(i);\n    }\n    Tree();\n    cout <<Solve()<<endl;\n  }\n  return 0;\n}\nvoid Init(){\n  for(int i=0; i<4; i++) color[i].clear();\n  for(int i=0; i<(1<<24); i++) dp[i] = -1;\n  for(int i=0; i<50; i++){\n    BO[i].done = false;\n    BO[i].useless = 0;\n    BO[i].chil.clear();\n    P[i][0] = P[i][1] = P[i][2] = 0;\n  }\n}\nvoid Tree(){\n  for(int i=0; i<n; i++){\n    for(int j=i+1; j<n; j++){\n      double dx = P[i][0]-P[j][0];\n      double dy = P[i][1]-P[j][1];\n      double rr = P[i][2]+P[j][2];\n      if(dx*dx+dy*dy<rr*rr){\n    BO[i].chil.push_back(j);\n    BO[j].useless++;\n      }\n    }\n  }\n}\nint Solve(){\n  int ans = 0,A;\n  for(int i=0; i<n; i++) A|=(1<<i);\n  if(dp[A] != -1) return (int)dp[A];\n  for(int i=0; i<4; i++){\n    for(int ii=0; ii<color[i].size(); ii++){\n      for(int jj=ii+1; jj<color[i].size(); jj++){\n    int a = color[i][ii];\n    int b = color[i][jj];\n    if(BO[a].useless || BO[b].useless) continue;\n    if(BO[a].done || BO[b].done) continue;\n    BO[a].done = BO[b].done = true;\n    for(int j=0; j<BO[a].chil.size(); j++) BO[BO[a].chil[j]].useless--;\n    for(int j=0; j<BO[b].chil.size(); j++) BO[BO[b].chil[j]].useless--;\n    int ANS = Solve()+2;\n    if(ans<ANS) ans = ANS;\n    BO[a].done = BO[b].done = false;\n    for(int j=0; j<BO[a].chil.size(); j++) BO[BO[a].chil[j]].useless++;\n    for(int j=0; j<BO[b].chil.size(); j++) BO[BO[b].chil[j]].useless++;\n      }\n    }\n  }\n  dp[A] = (char)ans;\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <algorithm>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define FOR(i,a,n) for(int i=a;i<n;++i)\n#define REP(i,n) FOR(i,0,n)\n\nstruct disk{\n\tint x,y,r,c,n;\n};\nbool on(disk l,disk r){\n\treturn(pow(l.r+r.r,2.0)>pow(l.x-r.x,2.0)+pow(l.y-r.y,2.0));\n}\nstruct tree{\n\tdisk d;\n\tvector<tree> children;\n\tint depth;\n\ttree(disk d,int depth):d(d),depth(depth){\n\t}\n\ttree(){d.n=-1;depth=0;}\n\tvoid add(disk &other){\n\t\tif(!add_r(other)){\n\t\t\tchildren.push_back(tree(other,depth+1));\n\t\t}\n\t}\n\tbool add_r(disk &other){\n\t\tif(children.empty()){\n\t\t\tif(on(d,other)){\n\t\t\t\tchildren.push_back(tree(other,depth+1));\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].add_r(other)){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\tif(on(d,other)){\n\t\t\t\t\tchildren.push_back(tree(other,depth+1));\n\t\t\t\t\treturn true;\n\t\t\t\t}else{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tvoid leaves(vector<tree*> &trees){\n\t\tif(children.empty()){\n\t\t\ttrees.push_back(this);\n\t\t}else{\n\t\t\tREP(i,children.size()){\n\t\t\t\tchildren[i].leaves(trees);\n\t\t\t}\n\t\t}\n\t}\n\tbool dlt(disk &dd){\n\t\tif(children.empty()){\n\t\t\treturn false;\n\t\t}\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].d.n==dd.n){\n\t\t\t\tchildren.erase(children.begin()+i);\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\tif(children[i].dlt(dd))return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n/*\nint dfs(tree &t){\n\tvector<disk> leaves;\n\tt.leaves(leaves);\n\tint best=0;\n\tREP(i,leaves.size()){\n\t\tFOR(j,i+1,leaves.size()){\n\t\t\tif(leaves[i].c==leaves[j].c){\n\t\t\t\ttree nt(t);\n\t\t\t\tnt.dlt(leaves[i]);\n\t\t\t\tnt.dlt(leaves[j]);\n\t\t\t\tbest=max(best,dfs(nt)+2);\n\t\t\t}\n\t\t}\n\t}\n\treturn best;\n}\n*/\n\nbool pred(tree *l,tree *r){\n\treturn l->depth>r->depth;\n}\nint greedy(tree &t){\n\tvector<tree*> leaves;\n\tt.leaves(leaves);\n\tsort(leaves.begin(),leaves.end(),pred);\n\tREP(i,leaves.size()){\n\t\tFOR(j,i+1,leaves.size()){\n\t\t\tif(leaves[i]->d.c==leaves[j]->d.c){\n\t\t\t\ttree nt(t);\n\t\t\t\tnt.dlt(leaves[i]->d);\n\t\t\t\tnt.dlt(leaves[j]->d);\n\t\t\t\treturn greedy(nt)+2;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\ttree t;\n\t\tvector<disk> disks;\n\t\tREP(i,n){\n\t\t\tdisk d;\n\t\t\tcin>>d.x>>d.y>>d.r>>d.c;\n\t\t\td.n=i;\n\t\t\tdisks.push_back(d);\n\t\t}\n\t\tREP(i,n){\n\t\t\tt.add(disks[n-i-1]);\n\t\t}\n\t\tcout<<greedy(t)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lp(i,n) for(int i=0;i<n;i++)\n\nint color[24],ans;\nvector<long long> dp,dpmemo;\n\nvoid calc(vector<int> canremove[],int nowremove,int n){\n  lp(i,n){\n    int checkmemo=0;\n    lp(j,n){\n      if(canremove[i][24]==-1) break;\n      if(canremove[i][24]==-2){\n\tcheckmemo=1;\n\tbreak;\n      }\n      if(canremove[i][j]!=0){\n\tcheckmemo=1;\n\tbreak;\n      }\n    }\n    if(checkmemo==0) canremove[i][24]=-1;\n  }\n  int dpyou=0,ic;\n  for(int i=0;i<n;i++){\n    ic=(int)pow(4,ic);\n    dpyou+=ic*canremove[i][24]*-1;\n  }\n  lp(i,dp.size()){\n    if(dp[i]==dpyou&&dpmemo[i]<nowremove) return;\n  }\n  dp.push_back(dpyou);\n  dpmemo.push_back(nowremove);\n  ans=max(ans,nowremove);\n  for(int i=0;i<n-1;i++){\n    for(int j=i+1;j<n;j++){\n      if(color[i]==color[j]){\n\tif(canremove[i][24]==-1&&canremove[j][24]==-1){\n\t  vector<int> memo[24];\n\t  lp(k,24){\n\t    memo[k]=canremove[k];\n\t  }\n\t  lp(k,24){\n\t    memo[k][i]=0;\n\t    memo[k][j]=0;\n\t  }\n\t  memo[i][24]=-2;\n\t  memo[j][24]=-2;\n\t  calc(memo,nowremove+2,n);\n\t}\n      }\n    }\n  }\n  return;\n}\n\n\nint main(){\n  while(1){\n    int n;\n    cin>>n;\n    if(n==0) break;\n    int x[24],y[24],l[24];\n    vector<int> canremove[25];\n    lp(i,24){\n      color[i]=-1;\n      canremove[i].clear();\n      lp(j,25){\n\tcanremove[i].push_back(0);\n      }\n    }\n    lp(i,n){\n      cin>>x[i]>>y[i]>>l[i]>>color[i];\n      int count=0;\n      for(int j=0;j<i;j++){\n\tif(fabs(x[i]-x[j])*fabs(x[i]-x[j])+fabs(y[i]-y[j])*fabs(y[i]-y[j]) < (l[i]+l[j])*(l[i]+l[j])){\n\t  \n\t  count++;\n\t  canremove[i][j]=1;\n\t}\n      }\n      if(count==0) canremove[i][24]=-1;\n    }\n    ans=0;\n    dp.clear();\n    dpmemo.clear();\n    calc(canremove,0,n);\n    cout<<ans<<endl;\n  }\n  \n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nstruct E{\n\tvector<int> ov;\n\tint color;\n\tint x, y, r;\n\tE(int _x, int _y, int _r, int _c){\n\t\tcolor = _c;\n\t\tx = _x;\n\t\ty = _y;\n\t\tr = _r;\n\t}\n};\nstruct status{\n\tbool l[100];\n\tstatus(){\n\t\tfill(l, l+100, true);\n\t}\n};\n\nbool dp[(1<<30)] = {0};\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tint x, y, r, c, _ans=0;\n\t\tvector<E> e;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tE tmp(x,y,r,c);\n\t\t\tfor(int j=0; j<e.size(); j++){\n\t\t\t\tif( (e[j].x-x)*(e[j].x-x) + (e[j].y-y)*(e[j].y-y) < (e[j].r+r)*(e[j].r+r) ){\n\t\t\t\t\ttmp.ov.push_back( j );\n\t\t\t\t}\n\t\t\t}\n\t\t\te.push_back( tmp );\n\t\t}\n\t\tdp[0] = true;\n\t\tfor(int i=0; i<(1<<n); i++){\n\t\t\tif(dp[i]){\n\t\t\t\t_ans = i;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tfor(int l=0; l<n; l++){\n\t\t\t\t\t\tif( k != l && e[k].color == e[l].color){\n\t\t\t\t\t\t\tbool f=true;\n\t\t\t\t\t\t\tfor(int j=0; j<e[k].ov.size(); j++)\n\t\t\t\t\t\t\t\tif( !(i & (1<<e[k].ov[j])) )\n\t\t\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t\tfor(int j=0; j<e[l].ov.size(); j++)\n\t\t\t\t\t\t\t\tif( !(i & (1<<e[l].ov[j])) )\n\t\t\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t\tif( f ){\n\t\t\t\t\t\t\t\tdp[ i | (1<<k) | (1<<l) ] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=1; i<(1<<n); i<<=1){\n\t\t\tif( i & _ans )\n\t\t\t\tans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint n, ans = 0;\nint x[25], y[25], r[25], c[25];\nbool memo[1<<24];\n\nbool overlap(int i, int j){\n    return (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j]) * (r[i]+r[j]);\n}\n\nvoid dfs(VI f){\n    int x = 0;\n    REP(i,n) x += f[i] * (1<<i);\n    if (memo[x]) return;\n    memo[x] = 1;\n\n    int res = 0;\n    REP(i,n) res += f[i];\n    ans = max(ans, res);\n\n    VI top(n);\n    REP(i,n){\n        if (f[i]) continue;\n        bool g = 1;\n        REP(j,i){\n            if (f[j]) continue;\n            if (overlap(i,j)) g = 0;\n        }\n        top[i] = (!f[i] & g);\n    }\n\n    // REP(i,n) printf(\"%d \", f[i]);\n    // cout << endl;\n\n    REP(i,n) REP(j,i){\n        if (!top[i] || !top[j] || c[i] != c[j]) continue;\n        f[i] = f[j] = 1;\n        dfs(f);\n        f[i] = f[j] = 0;\n    }\n}\n\nint main() {\n    ifstream ifs(\"in.txt\");\n    while (ifs >> n && n){\n        VI f(n);\n        ans = 0;\n        REP(i,1<<n) memo[i] = 0;\n        REP(i,n) ifs >> x[i] >> y[i] >> r[i] >> c[i];\n\n        dfs(f);\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <complex>\n#include <queue>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\ntypedef complex<double> P;\n\nint bitcount(int b) { int c = 0; while(b) { b &= b-1; c++; } return c; }\n\nint n, x[64], y[64], r[64], c[64], g[64][64];\nbool vis[1<<24];\n\nint solve() {\n    memset(vis, 0, sizeof(vis));\n    rep(i, n) for(int j=i+1; j<n; j++) {\n        const double d = abs(P(x[i], y[i])-P(x[j], y[j]));\n        g[i][j] = d<r[i]+r[j];\n    }\n    int ans = 0;\n    queue<int> q;\n    q.push(0);\n    vis[0] = true;\n    while(!q.empty()) {\n        int x = q.front();\n        q.pop();\n        ans = max(ans, bitcount(x));\n        int can = ~x;\n        rep(i, n) if((x&(1<<i))==0) {\n            for(int j=i+1; j<n; j++) if(g[i][j]) can &= ~(1<<j);\n        }\n        rep(i, n) if(can&(1<<i)) rep(j, i) if(can&(1<<j) && c[i]==c[j]) {\n            const int nx = x|(1<<i)|(1<<j);\n            if(!vis[nx]) q.push(nx), vis[nx] = true;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    for(;;) {\n        scanf(\"%d\", &n);\n        if(n==0) return 0;\n        rep(i, n) scanf(\"%d%d%d%d\", x+i, y+i, r+i, c+i);\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <string.h>\n\nusing namespace std;\n\nconst int MAX_N = 24;\n\nclass Circle {\npublic:\n\tshort x, y, r, c; // 中心のxy座標、半径、色番号\n};\n\n/* 入力 */\nint n; // 円盤の枚数\nCircle cir[MAX_N]; // 円の情報\n\n/*\nS:すでに取り除いた円の集合(bitで表す、右から円番号0,1,2,...,MAX_N)\ndp[S]:ここから取り除ける最大枚数\n漸化式\ndp[全部取り除いた] = n\ndp[S] = max(dp[S U 取り除いた2つの円]+2)\n*/\nshort dp[1 << MAX_N];\n\n/* 2点間の距離 */\ndouble dis(char x1, char y1, char x2, char y2) {\n\treturn sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));\n}\n\n/* 円kが上に1枚でも重なっているかどうか、重なっていたらtrue */\nbool ispiled(int k, int S) {\n\tfor (int i = k - 1; i >= 0; i--) {\n\t\tif (dis(cir[i].x, cir[i].y, cir[k].x, cir[k].y) < cir[i].r + cir[k].r && !(S >> i & 1)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n/*\nbool ispiled(Circle c1, Circle c2) {\n\tif (dis(c1.x, c1.y, c2.x, c2.y) < c1.r + c2.r) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n*/\n\n/* S:すでに取り除いた円盤の集合 */\nshort remove(int S) {\n\t//cout << \"S = \" << S << \" dp[\" << S << \"]: \" << dp[S] << endl;\n\tif (dp[S] >= 0) {\n\t\treturn dp[S];\n\t}\n\t\n        /* 全部取り除いた */\n\tif (S == ((1 << n) - 1)) {\n\t\treturn dp[S] = n;\n\t}\n\n\tint res = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (S >> i & 1 || ispiled(i, S)) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t/* どちらかがすでに取り除かれているか、2つの色が違うか、2枚のうち1枚以上が下にあれば取り除けないので次の組へ */\n\t\t\tif (S >> j & 1 || cir[i].c != cir[j].c || ispiled(j, S)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (true) {\n\t\t\t\tint tmp = S | 1 << i;\n\t\t\t\ttmp = tmp | 1 << j;\n\t\t\t\tres = max(res, remove(tmp) + 2);\n\t\t\t\tif (res == n + 2) {\n\t\t\t\t\tres = n;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (res == n) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[S] = res;\n}\n\nint main() {\n\t// 方針: bitDP\n\t//const int MAX_N = 24;\n\twhile (true) {\n\t\t//cout << \"n=\" << endl;\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> cir[i].x >> cir[i].y >> cir[i].r >> cir[i].c;\n\t\t}\n\t\tmemset(dp, -1, sizeof(dp));\n\t\t//cout << \"test\" << endl;\n\t\tcout << remove(0) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint x[100], y[100], r[100], c[100], n;\nqueue<int>Q;\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++)cin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\tQ.push((1 << n) - 1); int maxn = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tint bit[24]; int a = Q.front(); Q.pop();\n\t\t\tfor (int i = 0; i < 24; i++)bit[i] = (a / (1 << i)) % 2;\n\t\t\tint cnt = 0; for (int i = 0; i < 24; i++)cnt += bit[i];\n\t\t\tmaxn = max(maxn, n - cnt); int d[24];\n\t\t\tfor (int i = 0; i < 24; i++)d[i] = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (bit[i] == 0)continue;\n\t\t\t\td[i] = 1;\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (bit[j] == 0)continue;\n\t\t\t\t\tint dist = (x[i] - x[j])*(x[i] - x[j]);\n\t\t\t\t\tdist += (y[i] - y[j])*(y[i] - y[j]);\n\t\t\t\t\tif (dist < (r[i] + r[j])*(r[i] + r[j]))d[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (d[i] == 0 || d[j] == 0)continue;\n\t\t\t\t\tif (c[i] == c[j]) {\n\t\t\t\t\t\tQ.push(a - (1 << i) - (1 << j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nstruct cir {\n\tint x;\n\tint y;\n\tint r;\n\tunsigned char c;\n\tvector<unsigned char> top;\n};\nint bit_sum(int a) {\n\tint res = 0;\n\tREP(i, 32)\n\t\tif ((a >> i) & 1)\n\t\t\tres++;\n\treturn res;\n}\nint main() {\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<cir> en(n);\n\t\tREP(i, n) {\n\t\t\tcin >> en[i].x >> en[i].y >> en[i].r >> en[i].c;\n\t\t\tfor (int j = 0;j < i;j++)\n\t\t\t\tif ((en[j].x - en[i].x)*(en[j].x - en[i].x) + (en[j].y - en[i].y)*(en[j].y - en[i].y) < (en[i].r + en[j].r)*(en[i].r + en[j].r))\n\t\t\t\t\ten[i].top.push_back(j);\n\t\t}\n\t\tint ans = 0;\n\t\tset<int> dp;\n\t\tqueue<int> Q;\n\t\tint start = 0;\n\t\tREP(i, n) {\n\t\t\tstart *= 2;\n\t\t\tstart++;\n\t\t}\n\t\tdp.insert(start);\n\t\tQ.push(start);\n\t\twhile (!Q.empty()) {\n\t\t\tint q = Q.front();Q.pop();\n\t\t\tans = max(ans, n - bit_sum(q));\n\t\t\tREP(i, n) {\n\t\t\t\tif (((q >> i) & 1)) {\n\t\t\t\t\tbool clear = true;\n\t\t\t\t\tREP(j, en[i].top.size()) {\n\t\t\t\t\t\tif ((q >> en[i].top[j]) & 1)\n\t\t\t\t\t\t\tclear = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (!clear)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tFOR(j, i + 1, n) {\n\t\t\t\t\t\tif (((q >> j) & 1)&&en[i].c==en[j].c) {\n\t\t\t\t\t\t\tbool clear = true;\n\t\t\t\t\t\t\tREP(k, en[j].top.size()) {\n\t\t\t\t\t\t\t\tif ((q >> en[j].top[k]) & 1)\n\t\t\t\t\t\t\t\t\tclear = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!clear)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tif (dp.find((q ^ (1 << i)) ^ (1 << j)) == dp.end()) {\n\t\t\t\t\t\t\t\tQ.push((q ^ (1 << i)) ^ (1 << j));\n\t\t\t\t\t\t\t\tdp.insert((q ^ (1 << i)) ^ (1 << j));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nvvi data(24, vi(4));\n\nint bitnum(int n) {\n\tint res = 0;\n\tREP(i, 32) {\n\t\tif(n&(1<<i)) {\n\t\t\tres++;\n\t\t}\n\t}\n\treturn res;\n}\n\nbool cover(int i, int j) {\n\tint xd = data[i][0]-data[j][0];\n\tint yd = data[i][1]-data[j][1];\n\tint rd = data[i][2]+data[j][2];\n\t\n\treturn xd*xd+yd*yd < rd*rd;\n}\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tREP(i, n) {\n\t\t\tREP(j, 4) {\n\t\t\t\tcin >> data[i][j];\n\t\t\t}\n\t\t}\n\n\t\tvector<bool> memo(1<<n, false);\n\t\tmemo[(1<<n)-1] = true;\n\t\tstack<int> S;\n\t\tS.push((1<<n)-1);\n\t\tint ans = 0;\n\t\twhile(!S.empty()) {\n\t\t\tint st = S.top();\n\t\t\tS.pop();\n\n\t\t\tif(st == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tREP(i, n) {\n\t\t\t\tif(!(st&(1<<i))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tREP(k, i) {\n\t\t\t\t\tif(cover(k, i)) {\n\t\t\t\t\t\tgoto nexti;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tREP(j, i) {\n\t\t\t\t\tif(!(st&(1<<j)) || data[i][3] != data[j][3]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tREP(k, j) {\n\t\t\t\t\t\tif((st&(1<<k)) && cover(k, j)) {\n\t\t\t\t\t\t\tgoto nextj;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint nst = st^(1<<i)^(1<<j);\n\t\t\t\t\tif(memo[nst]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmemo[nst] = true;\n\t\t\t\t\tans = max(ans, n-bitnum(nst));\n\t\t\t\t\tS.push(nst);\n\n\t\t\t\t\tnextj:;\n\t\t\t\t}\n\t\t\t\tnexti:;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nbool visit[1<<24];\nint c[24];\nint key[24];\nint n;\n\nvoid dfs(int x) {\n\tvisit[x] = true;\n\tfor(int i=0; i<n; i++) {\n\t\tif(x & (1<<i)) continue;\n\t\tbool ok = true;\n\t\tfor(int ii=0; ii<n; ii++) {\n\t\t\tif( !(x&(1<<ii)) && (key[i]&(1<<ii)) ) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok) continue;\n\n\t\tfor(int j=i+1; j<n; j++) {\n\t\t\tif(x & (1<<j)) continue;\n\t\t\tif(c[i] != c[j]) continue;\n\t\t\tif( visit[x | (1<<i) | (1<<j)] ) continue;\n\t\t\tok = true;\n\t\t\tfor(int jj=0; jj<n; jj++) {\n\t\t\t\tif( !(x&(1<<jj)) && (key[j]&(1<<jj)) ) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok) {\n\t\t\t\tdfs(x | (1<<i) | (1<<j));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(cin >> n, n) {\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tvi x(n), y(n), r(n);\n\t\trep(i, n) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tmemset(key, 0, sizeof(key));\n\t\trep(i, n) {\n\t\t\tfor(int j=i-1; j>=0; j--) {\n\t\t\t\tint d = (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]);\n\t\t\t\tif(d < (r[i]+r[j])*(r[i]+r[j])) {\n\t\t\t\t\tkey[i] |= (1<<j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdfs(0);\n\n\t\tint maxi = 0;\n\t\trep(i, (1<<n)) {\n\t\t\tif(visit[i]) {\n\t\t\t\tint num = 0;\n\t\t\t\trep(j, n) {\n\t\t\t\t\tif( i & (1<<j) ) num++;\n\t\t\t\t}\n\t\t\t\tmaxi = max(maxi, num);\n\t\t\t}\n\t\t}\n\t\tcout << maxi << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct C {\n  int x, y, r, c;\n};\n\nint n;\nC c[24];\nint on[24];\nchar T[1<<24];\nvector<int> to[5];\n\nint isIntersect(C &a, C &b) {\n  int d1 = a.x - b.x;\n  int d2 = a.y - b.y;\n  int d3 = a.r + b.r;\n  if(d1*d1 + d2*d2 < d3*d3) return 2;\n  //if(d1*d1 + d2*d2 == d3*d3) return 1;\n  return 0;\n}\n\nint make() {\n  for(int i = 1; i <= 4; ++i) to[i].clear();\n  fill(on, on+n, 0);\n  for(int i = 0; i < n; ++i) {\n    to[c[i].c].push_back(i);\n    for(int j = i+1; j < n; ++j) {\n      if(isIntersect(c[i], c[j])) {\n\ton[j] |= (1<<i);\n      }\n    }\n  }\n}\n\nchar rec(int S) {\n  if(T[S] != -1) return T[S];\n  char res = 0;\n  for(int t = 1; t <= 4; ++t) {\n    for(int u = 0; u < to[t].size(); ++u) {\n      int i = to[t][u];\n      if(S & (1<<i)) continue;\n      if(on[i] & S != on[i]) continue;\n      for(int v = u+1; v < to[t].size(); ++v) {\n\tint j = to[t][v];\n\tif(j == i) continue;\n\tif(S & (1<<j)) continue;\n\tif(on[j] & S != on[j]) continue;\n\tint nS = S;\n\tnS |= (1<<i);\n\tnS |= (1<<j);\n\tres = max(res, (char)(rec(nS) + 2));\n      }\n    }\n  }\n  return T[S] = res;\n}\n\nint solve() {\n  make();\n  fill(T, T+(1<<n), -1);\n  return rec(0);\n  for(int S = (1<<n)-1; S >= 0; --S) {\n    T[S] = 0;\n\n    for(int t = 1; t <= 4; ++t) {\n      for(int u = 0; u < to[t].size(); ++u) {\n\tint i = to[t][u];\n\tif(S & (1<<i)) continue;\n\tif(on[i] & S != on[i]) continue;\n\tfor(int v = u+1; v < to[t].size(); ++v) {\n\t  int j = to[t][v];\n\t  if(j == i) continue;\n\t  if(S & (1<<j)) continue;\n\t  if(on[j] & S != on[j]) continue;\n\t  int nS = S;\n\t  nS |= (1<<i);\n\t  nS |= (1<<j);\n\t  T[S] = max(T[S], (char)(T[nS] + 2));\n\t}\n      }\n    }\n  }\n  return T[0];\n}\n\nint main() {\n  while((cin >> n) && n) {\n    for(int i = 0; i < n; ++i) {\n      cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n    }\n\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing Int = int;\nusing Bool = bool;\ntemplate <class T>\nusing Vector = std::vector<T>;\n\nstruct Circle {\n    Int x, y, r;\n    Circle(Int x = 0, Int y = 0, Int r = 0) : x(x), y(y), r(r) {}\n};\n\nBool intersect(Circle a, Circle b) {\n    Int dx = a.x - b.x, dy = a.y - b.y, sr = a.r + b.r;\n    return dx * dx + dy * dy < sr * sr;\n}\n\nconstexpr Int N = 24;\nVector<Int> dp(1 << N);\nVector<Int> c;\nVector<Vector<Int>> on;\n\nInt dfs(Int b) {\n    if (dp[b] >= 0) return dp[b];\n\n    dp[b] = __builtin_popcountll(b);\n    Vector<Bool> isleaf(N, false);\n\n    for (Int v = N - 1; v >= 0; --v) {\n        if ((b >> v) & 1) {\n            isleaf[v] = true;\n            for (Int u : on[v]) {\n                isleaf[u] = false;\n            }\n        }\n    }\n\n    for (Int v = 0; v < N; ++v) {\n        for (Int u = 0; u < v; ++u) {\n            if (isleaf[u] && isleaf[v] && c[u] == c[v]) {\n                dp[b] = std::min(dp[b], dfs(b - (1 << u) - (1 << v)));\n            }\n        }\n    }\n    return dp[b];\n}\n\nBool solve() {\n    Int n;\n    std::cin >> n;\n    if (n == 0) return false;\n\n    Vector<Circle> d(n);\n    c.resize(n);\n    for (Int i = 0; i < n; ++i) {\n        std::cin >> d[i].x >> d[i].y >> d[i].r >> c[i];\n    }\n\n    on.clear();\n    on.resize(n);\n    for (Int v = 0; v < n; ++v) {\n        for (Int u = 0; u < v; ++u) {\n            if (intersect(d[u], d[v])) {\n                on[u].push_back(v);\n            }\n        }\n    }\n\n    std::fill(dp.begin(), dp.end(), -1);\n    std::cout << n - dfs((1 << n) - 1) << std::endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\nint n;\nint x[24];\nint y[24];\nint r[24];\nint c[24];\nint ans;\nbool memo[1 << 24];\n\ninline int dbl(int x){ return x * x; }\n\nint main(){\n  while(scanf(\"%d\", &n), n){\n    REP(i,n) scanf(\"%d%d%d%d\", x+i, y+i, r+i, c+i);\n    memset(memo, 0, sizeof(memo)); ans = 0;\n\n    stack<int> q;\n    q.push((1 << n) - 1);\n    memo[(1<<n) - 1] = true;\n\n    while(q.size()){\n      int flag = q.top(); q.pop();\n      bool top[24]; REP(i,24) top[i] = true;\n\n      ans = max(ans, n - __builtin_popcount(flag));\n      if(ans == n) break;\n\n      for(int i = 0; i < n; i++){\n        if(flag & (1 << i)){\n          for(int j = i + 1; j < n; j++){\n            if(top[j] && (flag & (1 << j))){\n              if(dbl(x[i] - x[j]) + dbl(y[i] - y[j]) < dbl(r[i] + r[j])){\n                top[j] = false;\n              }\n            }\n          }\n        }\n      }\n\n      for(int i = 0; i < n; i++){\n        if((flag & (1 << i)) && top[i]){\n          for(int j = i + 1; j < n; j++){\n            if(top[j] && (flag & (1 << j)) && c[i] == c[j]){\n              int next = flag ^ (1 << i) ^ (1 << j);\n              if(!memo[next]){\n                q.push(next);\n                memo[next] = true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    print(ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n;i++){\n        if(((bit>>i)&1)==0||ok(i,bit)==false)continue;\n        for(int j=i+1;j<n;j++){\n\n            if(((bit>>j)&1)==0)continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(c[i]==c[j]&&ok(j,bit)&&!memo[to_bit]){\n                ret=max(ret,dfs(to_bit));\n            }\n        }\n    }\n\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\n\n\nint main(){\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  while (1){\n    int n;\n    cin >> n;\n    if (n == 0){\n      break;\n    }\n    vector<int> x(n), y(n), r(n), c(n);\n    for (int i = 0; i < n; i++){\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n      c[i]--;\n    }\n    vector<vector<int>> id(4);\n    for (int i = 0; i < n; i++){\n      id[c[i]].push_back(i);\n    }\n    vector<vector<bool>> intersect(n, vector<bool>(n, false));\n    for (int i = 0; i < n; i++){\n      for (int j = 0; j < n; j++){\n        if (i < j){\n          if ((x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]) < (r[i] + r[j]) * (r[i] + r[j])){\n            intersect[i][j] = true;\n          }\n        }\n      }\n    }\n    int ans = 0;\n    queue<int> Q;\n    Q.push((1 << n) - 1);\n    set<int> used;\n    used.insert((1 << n) - 1);\n    while (!Q.empty()){\n      int S = Q.front();\n      Q.pop();\n      ans = n - __builtin_popcount(S);\n      for (int i = 0; i < 4; i++){\n        int sz = id[i].size();\n        for (int j = 0; j < sz; j++){\n          for (int k = j + 1; k < sz; k++){\n            if ((S >> id[i][j] & 1) && (S >> id[i][k] & 1)){\n              bool ok = true;\n              for (int l = 0; l < id[i][j]; l++){\n                if ((S >> l & 1) && intersect[l][id[i][j]]){\n                  ok = false;\n                }\n              }\n              for (int l = 0; l < id[i][k]; l++){\n                if ((S >> l & 1) && intersect[l][id[i][k]]){\n                  ok = false;\n                }\n              }\n              if (ok){\n                int next = S - (1 << id[i][j]) - (1 << id[i][k]);\n                if (!used.count(next)){\n                  used.insert(next);\n                  Q.push(next);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n\nstruct Disc{\n\tint x,y,r,c;\n\tDisc(int p_x,int p_y,int p_r,int p_c){\n\t\tx=p_x;y=p_y;r=p_r;c=p_c;\n\t}\n\tDisc(){};\n};\n\nint n;\nchar memo[1<<24];\nbool exist[24];\nDisc D[24];\nint ans;\n\nbool touch(Disc a,Disc b){\n\treturn (a.r+b.r)*(a.r+b.r)>(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n}\n\nbool top(int k){\n\tfor(int i=k-1;i>=0;i--){\n\t\tif(exist[i]){\n\t\t\tif(touch(D[k],D[i])){return false;}\n\t\t}\n\t}\n\treturn true;\n}\n\nint dfs(int bit,int num){\n\tif(memo[bit]>=0) return memo[bit];\n\tint res=num;\n\n\tfor(int i=0;i<n;i++){\n\t\tif(exist[i] && top(i)){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(exist[j] && top(j) && i!=j && D[i].c==D[j].c){\n\t\t\t\t\texist[i]=false;\n\t\t\t\t\texist[j]=false;\n\t\t\t\t\tres=dfs((bit&(~(1<<i)))&(~(1<<j)),num+2);\n\t\t\t\t\texist[i]=true;\n\t\t\t\t\texist[j]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemo[bit]=res;\n\tans=max(ans,res);\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin>>n && n!=0){\n\t\tans=0;\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tmemset(exist,true,sizeof(exist));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y,r,c;\n\t\t\tcin>>x>>y>>r>>c;\n\t\tD[i]=Disc(x,y,r,c);\n\t\t}\n\t\tans=0;\n\t\tdfs((1<<24)-1,0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-10\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1 << 28;\n\nint n;\nvector<double> x, y, r;\nvector<int> c;\nvector<int> dp;\n\nvector<vector<int> > create (set<int> era) {\n    vector<vector<int> > par(n);\n    for (int i = 0; i < n; i++) {\n        if (era.find(i) != era.end()) {\n            par[i].push_back(INF);\n            continue;\n        }\n        for (int j = 0; j < i; j++) {\n            double dis = pow(x[j] - x[i], 2.0) +  pow(y[j] - y[i], 2.0);\n            if (sqrt(dis) < r[i] + r[j] && era.find(j) == era.end()) {\n                par[i].push_back(j);\n            }\n        }\n    }\n\n    return par;\n}\n\nint dfs (vector<vector<int> > par, set<int> era) {\n    int check = 0;\n    for (auto i : era) {\n        check |= 1 << i;\n    }\n    if (dp[check] != INF) return dp[check];\n\n    vector<vector<int> > count(5);\n    for (int i = 0; i < n; i++) {\n        bool flag = true;\n        for (int j = 0; j < par[i].size(); j++) {\n            if (era.find(par[i][j]) == era.end()) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            count[c[i]].push_back(i);\n        }\n    }\n\n    int ret = 0;\n    for (int i = 1; i < count.size(); i++) {\n        if (count[i].size() >= 2) {\n            for (int sx = 0; sx < count[i].size(); sx++) {\n                for (int sy = sx + 1; sy < count[i].size(); sy++) {\n                    if (sx == sy) continue;\n                    set<int> t_era(era);\n                    t_era.insert(count[i][sx]);\n                    t_era.insert(count[i][sy]);\n                    vector<vector<int> > t_par(create(t_era));\n                    ret = max(ret, (dfs(t_par, t_era) + 2));\n                }\n            }\n        }\n    }\n    return ret; //dp[check] = ret;\n}\n\nint main () {\n    while (cin >> n, n) {\n        dp.resize(1 << n, INF);\n\n        x.resize(n), y.resize(n), r.resize(n), c.resize(n);\n        for (int i = 0; i < n; i++) {\n            cin  >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n        vector<vector<int> > par(create(set<int>()));\n\n        cout << dfs(par, set<int>()) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 9;\nusing Graph = vector<vector<int>>;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ninline int sgn(double a, double b = 0) { return a < b - EPS ? -1 : a > b + EPS ? 1 : 0; }\n\nstruct C {\n    P p;\n    double r;\n    C(){}\n    C(P _p, double _r) : p(_p), r(_r) {}\n    C(double _x, double _y, double _r) : p(_x, _y), r(_r) {}\n    void print() {\n        cerr << p.real() << \" \" << p.imag() << \" \" << r << endl;\n    }\n};\n\nC readC() {\n    double x, y, r;\n    cin >> x >> y >> r;\n    return C(x, y, r);\n}\n\nint relationCC(C c1, C c2) {\n    double d = abs(c1.p - c2.p);\n    if (sgn(d, c1.r + c2.r) == 1)       return 4; // distant\n    if (sgn(d, c1.r + c2.r) == 0)       return 3; // touch outside\n    if (sgn(d, abs(c1.r - c2.r)) == -1) return 0; // c1 in c2\n    if (sgn(d, abs(c1.r - c2.r)) == 0)  return 1; // c1 touches in c2\n    return 2; // two crosspoints\n}\n\nint n;\nvvi id_by_color;\nbool on[24][24];\nbool visited[1 << 24];\nint ans;\n\nbool valid(int i, int state) {\n    rep(k, i) {\n        if ((state >> k & 1) && on[k][i]) return false;\n    }\n    return true;\n}\n\nvoid dfs(int state, int num) {\n    // cerr << \"state = \" << bitset<8>(state) << \", num = \" << num << endl;\n    if (visited[state]) return;\n    visited[state] = true;\n    chmax(ans, n - num);\n    if (num <= 1) return;\n\n    for (auto v_id : id_by_color) {\n        int m = v_id.size();\n        rep(i, m) {\n            if (!(state >> v_id[i] & 1)) continue;\n            rep2(j, i + 1, m) {\n                if (!(state >> v_id[j] & 1)) continue;\n                if (valid(v_id[i], state) && valid(v_id[j], state)) {\n                    dfs((state & ~(1 << v_id[i])) & ~(1 << v_id[j]), num - 2);\n                }\n            }\n        }\n    }\n}\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    while (cin >> n, n) {\n        vector<C> circles(n);\n        id_by_color.clear(); id_by_color.resize(4);\n        rep(i, n) {\n            circles[i] = readC();\n            int c;\n            cin >> c;\n            c--;\n            id_by_color[c].emplace_back(i);\n        }\n\n        // printVV(id_by_color);\n\n        rep(i, n) {\n            rep2(j, i + 1, n) {\n                if (relationCC(circles[i], circles[j]) <= 2) {\n                    on[i][j] = true;\n                }\n                else {\n                    on[i][j] = false;\n                }\n            }\n        }\n\n        // rep(i, n) {\n        //     rep(j, n) {\n        //         cout << on[i][j] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n\n        rep(i, 1 << n) visited[i] = false;\n        ans = 0;\n        dfs((1 << n) - 1, n);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define REP(i, n) FOR(i, 0, n)\n\nint sq(int a)\n{\n\treturn a * a;\n}\n\nint n;\nint x[24], y[24], r[24], c[24];\n\nint dist(int i, int j)\n{\n\treturn sq(x[i] - x[j]) + sq(y[i] - y[j]);\n}\n\nbool isec(int i, int j)\n{\n\treturn dist(i, j) < sq(r[i] + r[j]);\n}\n\nvector<pair<int, int>> v;\nint ng[24];\nint dp[1 << 24];\n\nint calc(int bit)\n{\n\tif (~dp[bit]) return dp[bit];\n\t\n\tint res = 0;\n\t\n\tfor (auto p : v){\n\t\tint c = (1 << p.first) | (1 << p.second);\n\t\tif (bit & c) continue;\n\t\tif (~bit & ng[p.first]) continue;\n\t\tif (~bit & ng[p.second]) continue;\n\t\tres = max(res, 2 + calc(bit | c));\n\t}\n\t\n\treturn dp[bit] = res;\n}\n\nint solve()\n{\n\tv.clear();\n\tREP(i, n) FOR(j, i + 1, n){\n\t\tif (isec(i, j)) continue;\n\t\tif (c[i] != c[j]) continue;\n\t\tv.emplace_back(i, j);\n\t}\n\t\n\tmemset(ng, 0, sizeof ng);\n\tREP(i, n) FOR(j, 0, i){\n\t\tif (isec(i, j)) ng[i] |= 1 << j;\n\t}\n\t\n\tmemset(dp, -1, sizeof dp);\n\treturn calc(0);\n}\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\tREP(i, n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<math.h>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\nstruct status{\n    bool o[24];\n};\n\nint n;\ndouble x[24], y[24], r[24];\nint c[24];\ndouble d[24][24];\n\ndouble dist(double x1, double y1, double x2, double y2){\n    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\n\nint main(){\n    while(1){\n        cin >> n;\n        if(n==0) break;\n\n        REP(i, n){\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n\n        int colnum = 0;\n        REP(i, n){\n            colnum = max(colnum, c[i]);\n        }\n\n        REP(i, n){\n            REP(j, n){\n                d[i][j] = dist(x[i], y[i], x[j], y[j])-(r[i]+r[j]);\n            }\n        }\n\n        int maxnum = 0;\n        queue<status> que;\n        status s;\n        REP(i, n) s.o[i] = true;\n        que.push(s);\n        while(!que.empty()){\n            status s = que.front();\n            que.pop();\n\n            int count = 0;\n            REP(i, n){\n                if(!s.o[i]) count += 1;\n            }\n            maxnum = max(maxnum, count);\n\n            vector<int> top[4];\n            REP(i, n){\n                if(s.o[i]){\n                    bool flag = true;\n                    REP(j, i){\n                        if(s.o[j] && d[i][j]<0) flag = false;\n                    }\n                    if(flag){\n                        top[c[i]-1].push_back(i);\n                    }\n                }\n            }\n\n            REP(i, colnum){\n                if(top[i].size()>=2){\n                    REP(j, top[i].size()-1){\n                        for(int k=j+1; k<top[i].size(); k++){\n                            status ns;\n                            REP(l, n) ns.o[l] = s.o[l];\n                            ns.o[top[i][j]] = false;\n                            ns.o[top[i][k]] = false;\n                            que.push(ns);\n                        }\n                    }\n                }\n            }\n        }\n        cout << maxnum << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint n;\nint x[25],y[25],r[25],c[25];\nint cover[25];\ndouble d[25][25];\nbool check[1<<25];\nint cnt,comb,a,b;\nint m,ans;\nint u;\n\ndouble dis(int i,int j){\n  return sqrt( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j]) * (y[i]-y[j]) );\n}\n\nvoid cov(int a){\n  cover[a] = -1;\n  for(int j=a-1;j>=0;j--){\n    if(d[j][a]<r[a]+r[j] && u>>j & 1){\n      cover[a] = j;\n      break;\n    }\n  }\n} \n\n  \nvoid rec(void){\n  int cnt;\n\n  if(check[u])return;\n  check[u] = true;\n\n  for(int i=1;i<=4;i++){\n    cnt = 0;\n    for(int j=0;j<n;j++){\n      if( (u>>j & 1) && cover[j]<0 && c[j] == i)cnt++;\n    }\n    if(cnt==6){\n      for(int j=0;j<n;j++){\n\tif(c[j] == i)u -= 1<<j;\n      }\n      for(int j=0;j<n;j++)cov(j);\n\n      ans += 6;\n      m = max(m,ans);\n      rec();\n      if(!u)return;\n      ans -= 6;\n\n      for(int j=0;j<n;j++){\n\tif(c[j] == i)u += 1<<j;\n      }\n      for(int j=0;j<n;j++)cov(j);\n    }else{\n      for(int j=0;j<n;j++){\n\tif( (u>>j & 1) && cover[j]<0 && c[j] == i){\n\t  for(int k=j+1;k<n;k++){\n\t    if( (u>>k & 1) && cover[k]<0 && c[k] == i){\n\t      u -= 1<<j;\n\t      u -= 1<<k;\n\t      for(int l=0;l<n;l++)cov(l);\n\n\t      ans += 2;\n\t      m = max(m,ans);\n\t      rec();\n\t      if(!u)return;\n\t      ans -= 2;\n\n\t      u += 1<<j;\n\t      u += 1<<k;\n\t      for(int l=0;l<n;l++)cov(l);\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n}\n\n\n\nint main(){\n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    for(int i=0;i<n;i++)cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++)d[i][j] = dis(i,j);\n    }\n\n    u = (1<<n) - 1;\n    for(int i=0;i<(1<<n);i++)check[i] = false;\n    for(int i=0;i<n;i++)cov(i);\n\n    \n    m = 0;\n    ans = 0;\n    rec();\n\n    cout << m << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <stack>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nclass Circle;\nconst int MAX_N=24;\n\nstruct Circle{\n     int x;\n     int y;\n     int r;\n     set<int> ons;\n};\n\nbool iscover(Circle a,Circle b){\n     int dist=(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n     return (a.r+b.r)*(a.r+b.r)>dist;\n}\nvector<Circle> clist;\nint map[MAX_N];//ãÉæÁÄé~Ì\nint color[MAX_N];\nint maxdel=0,del=0;\nint N;\nbool used[MAX_N];\nint map_c[4];\n\nvoid delc(int n){\n     for(int i=0;i<N;i++){\n\t  if(clist[i].ons.find(n)!=clist[i].ons.end()){\n\t       --map[i];\n\t  }\n     }\n     used[n]=true;\n     ++del;maxdel=max(maxdel,del);\n}\nvoid revc(int n){\n     for(int i=0;i<N;i++){\n\t  if(clist[i].ons.find(n)!=clist[i].ons.end()){\n\t       ++map[i];\n\t  }\n     }\n     used[n]=false;\n     --del;\n}\n\nvoid firstdel(){\n     vector<int> dellist[4];\n     for(int i=0;i<N;i++){\n\t  if(map_c[color[i]]==0){\n\t       //cout<<\"c\"<<color[i]<<endl;\n\t       dellist[color[i]].push_back(i);\n\t  }\n     }\n     for(int k=0;k<4;k++){\n\t  if(dellist[k].size()<2)continue;\n\t  for(int i=0;i<(dellist[k].size()-1);i+=2){\n\t       delc(dellist[k][i]);delc(dellist[k][i+1]);\n\t       //cout<<\"i\"<<i<<endl;\n\t       \n\t  }\n     }\n     //cout<<\"#\"<<endl;\n}\n\nvoid dfs(int n1,int n2){\n     delc(n1);delc(n2);\n     //stack<P> sta;\n     vector<int> freecir[4];\n     for(int i=0;i<N;i++){\n\t  if(map[i]==0&&(!used[i]))freecir[color[i]].push_back(i);\n     }\n     for(int k=0;k<4;k++){\n\t  for(int i=0;i<freecir[k].size();i++){\n\t       for(int j=i+1;j<freecir[k].size();j++){\n\t\t    dfs(freecir[k][i],freecir[k][j]);\n\t\t    //cout<<freecir[k][i]<<freecir[k][j]<<endl;\n\t       }\n\t  }\n     }\n     revc(n1);revc(n2);\n     return;\n}\n\nvoid solve(){\n     firstdel();\n     vector<int> freecir[4];\n     for(int i=0;i<N;i++){\n\t  if(map[i]==0&&!used[i]){\n\t       freecir[color[i]].push_back(i);\n\t       //cout<<color[i]<<\":\"<<i<<endl;\n\t  }\n     }\n     //cout<<\"#\"<<endl;\n     for(int k=0;k<4;k++){\n\t  for(int i=0;i<freecir[k].size();i++){\n\t       for(int j=i+1;j<freecir[k].size();j++){\n\t\t    dfs(freecir[k][i],freecir[k][j]);\n\t\t    //cout<<freecir[k][i]<<freecir[k][j]<<endl;\n\t       }\n\t  }\n     }\n     //cout<<\"#\"<<endl;\n     return;\n}\n\t  \n\nint main(){\n     while(cin>>N,N){\n\t  clist.clear();\n\t  for(int i=0;i<N;i++){\n\t       map[i]=0;\n\t       color[i]=0;\n\t       used[i]=false;\n\t  }\n\t  maxdel=0;\n\t  del=0;\n\t  map_c[0]=map_c[1]=map_c[2]=map_c[3]=0;\n\t  \n\t  for(int i=0;i<N;i++){\n\t       Circle c;\n\t       int col;\n\t       cin>>c.x>>c.y>>c.r>>col;\n\t       col--;//1~4->0~3\n\t       color[i]=col;\n\t       for(int j=0;j<clist.size();j++){\n\t\t    if(iscover(c,clist[j])){\n\t\t\t c.ons.insert(j);\n\t\t\t map[i]++;\n\t\t\t map_c[color[i]]++;\n\t\t\t map_c[color[j]]++;\n\t\t\t //cout<<i<<\":\"<<j<<endl;\n\t\t    }\n\t       }\n\t       clist.push_back(c);\n\t  }\n\t  solve();\n\t  cout<<maxdel<<endl;\n     }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct C {\n  int x, y, r, c;\n};\n\nint n;\nC c[24];\nint on[24];\nchar T[1<<24];\n\nint isIntersect(C &a, C &b) {\n  int d1 = a.x - b.x;\n  int d2 = a.y - b.y;\n  int d3 = a.r + b.r;\n  if(d1*d1 + d2*d2 < d3*d3) return 2;\n  //if(d1*d1 + d2*d2 == d3*d3) return 1;\n  return 0;\n}\n\nint make() {\n  fill(on, on+n, 0);\n  for(int i = 0; i < n; ++i) {\n    for(int j = i+1; j < n; ++j) {\n      if(isIntersect(c[i], c[j])) {\n\ton[j] |= (1<<i);\n      }\n    }\n  }\n}\n\nint rec(int S) {\n  if(T[S] != -1) return T[S];\n  int res = 0;\n  for(int i = 0; i < n; ++i) {\n    if(S & (1<<i)) continue;\n    if(on[i] & S != on[i]) continue;\n    for(int j = i+1; j < n; ++j) {\n      if(S & (1<<j)) continue;\n      if(on[j] & S != on[j]) continue;\n      if(c[i].c != c[j].c) continue;\n      int nS = S;\n      nS |= (1<<i);\n      nS |= (1<<j);\n      res = max(res, rec(nS) + 2);\n    }\n  }\n  return T[S] = res;\n}\n\nconst int INF = (1<<24);\n\nint solve() {\n  make();\n  for(int S = (1<<n)-1; S >= 0; --S) {\n    T[S] = 0;\n    for(int i = 0; i < n; ++i) {\n      if(S & (1<<i)) continue;\n      if(on[i] & S != on[i]) continue;\n      for(int j = i+1; j < n; ++j) {\n\tif(S & (1<<j)) continue;\n\tif(on[j] & S != on[j]) continue;\n\tif(c[i].c != c[j].c) continue;\n\tint nS = S;\n\tnS |= (1<<i);\n\tnS |= (1<<j);\n\tT[S] = max(T[S], (char)(T[nS] + 2));\n      }\n    }\n  }\n  return T[0];\n}\n\n\n\nint main() {\n  while((cin >> n) && n) {\n    for(int i = 0; i < n; ++i) {\n      cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n    }\n\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint n;\nint x[24],y[24],r[24],c[24];\n\ninline bool intersect(int p, int q)\n{\n    double dist=sqrt((x[p]-x[q])*(x[p]-x[q])+(y[p]-y[q])*(y[p]-y[q]));\n    return dist<(r[p]+r[q]);\n}\n\ninline bool available(int p, int state)\n{\n    rep(i,p)\n    {\n        if(state>>i&1 && intersect(p,i)) return false;\n    }\n    return true;\n}\n\nchar dp[1<<24];\nchar dfs(int state)\n{\n    if(dp[state]>=0) return dp[state];\n    if(__builtin_popcount(state)<2) return 0;\n\n    char ret=(char)0;\n    rep(i,n)\n    {\n        if(state>>i&1)\n        {\n            if(!available(i,state)) continue;\n\n            rep(j,n)\n            {\n                if(i==j) continue;\n                if(c[i]!=c[j]) continue;\n\n                if(state>>j&1)\n                {\n                    if(!available(j,state)) continue;\n                    ret = max(ret,(char)(dfs(state-(1<<i)-(1<<j))+2));\n                }\n            }\n        }\n    }\n\n    return dp[state]=ret;\n}\n\nint main()\n{\n    while(cin >>n,n)\n    {\n        rep(i,n) scanf(\" %d %d %d %d\", &x[i], &y[i], &r[i], &c[i]);\n        memset(dp,(char)-1,sizeof(dp));\n        cout << (int)dfs((1<<n)-1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 24;\n\nint n, x[N], y[N], r[N], c[N], p[N];\nbool vis[1<<N];\n\nbool lap(int a, int b){\n  int d = (x[a] - x[b]) * (x[a] - x[b]) + (y[a] - y[b]) * (y[a] - y[b]);\n  return d < r[a] * r[a] + 2 * r[a] * r[b] + r[b] * r[b];\n}\n\nint rec(int s){\n  //cout << \"#\" << s << endl;\n  int res = 0;\n  vis[s] = true;\n  for(int i=0;i<n;i++){\n    if((s >> i & 1) == 0) continue;\n    for(int j=i+1;j<n;j++){\n      if((s >> j & 1) == 0) continue;\n      if(c[i] != c[j]) continue;\n      if((p[i] & s) == 0 && (p[j] & s) == 0){\n        s &= ~(1 << i);\n        if((p[j] & s) == 0){\n          s &= ~(1 << j);\n          if(!vis[s]) res = max(res, rec(s));\n          s |= 1 << j;\n        }\n        s |= 1 << i;\n      }\n    }\n  }\n  if(s == (1 << n) - 1) return res;\n  return res + 2;\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++) cin >> x[i] >> y[i] >> r[i] >> c[i];\n    fill(p, p+n, 0);\n    fill(vis, vis+(1<<n), false);\n    for(int i=0;i<n;i++) for(int j=0;j<i;j++) if(lap(i, j)) p[i] |= 1 << j;\n    //for(int i=0;i<n;i++) cout << p[i] << ' '; cout << endl;\n    cout << rec((1<<n)-1) << endl;\n    //break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nstruct Circle {\n    int x, y, r, c;\n};\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector<Circle> circles;\n        REP(i, n) {\n            int x, y, r, c;\n            cin >> x >> y >> r >> c;\n            circles.push_back({x, y, r, c});\n        }\n\n        vi overlap(n);\n        REP(i, n-1) {\n            FOR(j, i+1, n) {\n                Circle c1 = circles[i];\n                Circle c2 = circles[j];\n                if (\n                    pow(c1.x - c2.x, 2) + pow(c1.y - c2.y, 2) < pow(c1.r + c2.r, 2)\n                ) {\n                    overlap[j] |= 1 << i;\n                }\n            }\n        }\n\n        vi dp(1 << n, -1);\n        dp[(1 << n) - 1] = 0;\n        int res = 0;\n        for (int m = (1 << n) - 1; m >= 0; m--) {\n            if (dp[m] == -1) continue;\n            REP(i, n-1) {\n                FOR(j, i+1, n) {\n                    if (m & (1 << i) && m & (1 << j) &&\n                        circles[i].c == circles[j].c &&\n                        (overlap[i] & m) == 0 && (overlap[j] & m) == 0) {\n                        int mm = m & ~(1 << i) & ~(1 << j);\n                        dp[mm] = dp[m] + 2;\n                        res = max(res, dp[mm]);\n                    }\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct circle{\n  double x, y, r;\n  int c;\n  unordered_set<int> up, down;\n};\n \nvoid calcOverlap(int n, circle *disk){\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      double x = disk[i].x - disk[j].x,\n        y = disk[i].y - disk[j].y;\n      if(sqrt(x*x + y*y) + 1e-8< disk[i].r + disk[j].r){\n        disk[j].up.insert(i);\n        disk[i].down.insert(j);\n      }\n    }\n  }\n}\n \nbool canRemove(circle d, circle dd){\n  if(d.c != dd.c)return false;\n  return d.up.empty() and dd.up.empty();\n}\n \nint dfs(int n, circle *disk, bool *removed, int dep = 0){\n  int res = 0;\n  bool f = false;\n  for (int i = 0; i < n; i++) {\n    if(removed[i] == true)continue;\n    for (int j = i + 1; j < n; j++) {\n      if(removed[j] == true)continue;\n      if(not canRemove(disk[i], disk[j]))continue;\n      f = true;\n      removed[i] = true;\n      removed[j] = true;\n      vector<int> erase_i, erase_j;\n      for (int k = 0; k < n; k++) {\n        if(disk[k].up.find(i) != disk[k].up.end()){\n          disk[k].up.erase(i);\n          erase_i.push_back(k);\n        }\n        if(disk[k].up.find(j) != disk[k].up.end()){\n          disk[k].up.erase(j);\n          erase_j.push_back(j);\n        }\n      }\n      res = max(res, dfs(n, disk, removed, dep + 1));\n      for (int k = 0; k < erase_j.size(); k++) {\n        disk[erase_j[k]].up.insert(j);\n      }\n      for (int k = 0; k < erase_i.size(); k++) {\n        disk[erase_i[k]].up.insert(i);\n      }\n      removed[i] = false;\n      removed[j] = false;\n    }\n  }\n  return f?res:dep;\n}\n \nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n, n){\n    circle disk[n];\n    for (int i = 0; i < n; i++) {\n      cin >> disk[i].x >> disk[i].y >> disk[i].r >> disk[i].c;\n    }\n    bool removed[n];\n    memset(removed, false, sizeof(removed));\n    calcOverlap(n, disk);\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        if(not canRemove(disk[i], disk[j]))continue;\n        if(not disk[i].down.empty() or\n           not disk[j].down.empty())continue;\n        removed[i] = true;\n        removed[j] = true;\n        ans++;\n      }\n    }\n    std::cout << 2*(ans + dfs(n, disk, removed)) << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint sqr(int x){\n  return x*x;\n}\n\nshort mem[1<<24];\nint ud[24];\n\nint dfs(int b){\n  if(mem[b]>=0)return mem[b];\n  mem[b]=0;\n  for(int i=0;i<4;i++){\n    for(int j=0;j<6;j++){\n      for(int k=0;k<j;k++){\n\tint jx=i*6+j;\n\tint kx=i*6+k;\n\tif((b>>jx&1)&&(b>>kx&1)&&!(ud[jx]&b)&&!(ud[kx]&b)){\n\t  mem[b]=max<int>(mem[b],dfs(b&~(1<<jx)&~(1<<kx))+2);\n\t}\n      }\n    }\n  }\n  return mem[b];\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    int x[24],y[24],r[24],c[24];\n    vector<int> u[24];\n    vector<int> cs[4];\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n      cs[c[i]-1].push_back(i);\n      for(int j=0;j<i;j++){\n\tif(sqr(x[i]-x[j])+sqr(y[i]-y[j])<sqr(r[i]+r[j])){\n\t  u[i].push_back(j);\n\t}\n      }\n    }\n    int m[24];\n    int b=0;\n    for(int i=0;i<4;i++){\n      for(int j=0;j<6;j++){\n\tif(j<cs[i].size()){\n\t  b|=1<<i*6+j;\n\t  m[cs[i][j]]=i*6+j;\n\t}\n      }\n    }\n    fill(begin(ud),end(ud),0);\n    for(int i=0;i<4;i++){\n      for(int j=0;j<6;j++){\n\tif(j<cs[i].size()){\n\t  for(auto e:u[cs[i][j]]){\n\t    ud[i*6+j]|=1<<m[e];\n\t  }\n\t}\n      }\n    }\n    fill(begin(mem),end(mem),-1);\n    cout<<dfs(b)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint sum=0,ds;\nint n;\nvoid rec(vector<circle> vs){\n  //cout << vs.size() << endl;\n  int i,j,k;\n  int f;\n  int on[100]={};\n  vector<int> cc[10];\n  vector<circle> next;\n  \n  f=1;\n  for(i=0;i<100;i++) on[i]=0;\n  for(i=0;i<vs.size();i++){\n    for(j=i+1;j<vs.size();j++){\n      if(ch(vs[i],vs[j])==1) on[j]=1;\n    }\n  }\n  for(i=0;i<vs.size();i++){\n    if(on[i]==0) cc[vs[i].c].push_back(i);\n  }\n  for(i=1;i<5;i++){\n    //cout << cc[i].size() << endl;\n    if(cc[i].size()>=2){\n      next.clear();\n      for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n      for(j=0;j<cc[i].size();j++){\n\tfor(k=j+1;k<cc[i].size();k++){\n\t  next.erase(next.begin()+cc[i][k]);\n\t  next.erase(next.begin()+cc[i][j]);\n\t  rec(next);\n\t  f=0;\n\t}\n      }\n    }\n  }\n  int o=n-vs.size();\n  if(f==1) sum=max(sum,o);\n}\n\nint main(){\n  cin >> n;\n  while(n!=0){\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    sum=0;\n    rec(v);\n    cout << sum << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    int n; cin >> n;\n    if (!n) break;\n    V<> x(n), y(n), r(n), c(n); for (int i = 0; i < n; ++i) cin >> x[i] >> y[i] >> r[i] >> c[i], --c[i];\n    V<bool> b(n, true);\n    int res = 0;\n    auto dfs = [&](const auto& dfs) -> void {\n      res = max(res, n - accumulate(begin(b), end(b), 0));\n      if (res == n) return;\n      VV<> idx(4);\n      for (int i = 0; i < n; ++i) if (b[i]) {\n        bool ok = true;\n        for (int j = 0; j < i; ++j) if (b[j]) {\n          if ((x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]) < (r[i] + r[j]) * (r[i] + r[j])) {\n            ok = false;\n            break;\n          }\n        }\n        if (ok) idx[c[i]].push_back(i);\n      }\n      for (auto&& v : idx) if (v.size() >= 2) {\n        for (int i : v) for (int j : v) if (i < j) {\n          b[i] = b[j] = false;\n          dfs(dfs);\n          b[i] = b[j] = true;\n        }\n      }\n    };\n    dfs(dfs);\n    cout << res << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\n\nclass Main{\n\tpublic:\n\n\n\tint dfs(){\n\t\tint rM=0;\n\t\t//color\n\t\tREP(c,4){\n\t\t\t//canrmvから2つ選ぶ\n\t\t\tREP(i,N)if(cs[i]==c && canrmv[i] && !rmv[i])REP(j,N)if(i<j)if(cs[j]==c &&canrmv[j] && !rmv[j]){\n\t\t\t\trmv[i]=rmv[j]=true;\n\t\t\t\t//ref\n\t\t\t\trefresh();\n\t\t\t\trM=max(rM,dfs()+2);\n\t\t\t\trmv[i]=rmv[j]=false;\n\t\t\t\trefresh();\n\t\t\t}\n\t\t}\n\t\treturn rM;\n\t}\n\n\tint N;\n\tvector<int> xs,ys,rs,cs;\n\tvector<bool> canrmv;\n\tvector<bool> rmv;\n\n\tvoid refresh(){\n\t\tREP(i,N)canrmv[i]=true;\n\t\tREP(i,N)if(!rmv[i])REP(j,N)if(!rmv[j])if(i<j){\n\t\t\tif(hypot(xs[i]-xs[j],ys[i]-ys[j])<rs[i]+rs[j])canrmv[j]=false;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\t// ifstream cin(\"D2\");\n//\t\tofstream cout( \"D2.out\" );\n\t\t\n\t\twhile(true){\n\t\t\tcin >> N;if(N==0)break;\n\t\t\txs=vector<int>(N);ys=vector<int>(N);\n\t\t\trs=vector<int>(N);cs=vector<int>(N);\n\t\t\tREP(i,N) {\n\t\t\t\tcin >> xs[i] >> ys[i]>>rs[i]>>cs[i];cs[i]--;\n\t\t\t }\n\t\t\t canrmv=vector<bool>(N);\n\t\t\t rmv=vector<bool>(N);\n\t\t\trefresh();\n\t\t\tcout << dfs() <<endl;\n\t\t}\n\t}\n\n\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define N 24\n\nclass Disk {\npublic:\n    int x, y, r, c;\n\n    Disk(int xx, int yy, int rr, int cc) :x(xx), y(yy), r(rr), c(cc) {}\n\n    bool on(const Disk& d) {\n        return (x - d.x) * (x - d.x) + (y - d.y) * (y - d.y) < (r + d.r) * (r + d.r);\n    }\n    bool sameColor(const Disk &d) {\n        return c == d.c;\n    }\n};\n\nvector<Disk> disk;\nvector<int> memo(1<<(N+1));\n\nint dfs(int used) {\n    if(memo[used] != -1) return memo[used];\n    vector<int> candidate;\n    for(int i = 0; i < disk.size(); i++) {\n        if(used & (1<<i)) continue;\n        bool ok = true;\n        for(int j = 0; j < i; j++) {\n            if(used & (1<<j)) continue;\n            if(!disk[j].on(disk[i])) continue;\n            ok = false;\n            break;\n        }\n        if(ok) candidate.push_back(i);\n    }\n\n    int result = 0;\n    for(int ci = 0; ci < candidate.size(); ci++) {\n        for(int cj = 0; cj < ci; cj++) {\n            int i = candidate[ci];\n            int j = candidate[cj];\n            if(!disk[i].sameColor(disk[j])) continue;\n            result = max(result, 2 + dfs(used | (1<<i) | (1<<j)));\n        }\n    }\n    return memo[used] = result;\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        disk.clear();\n        fill(memo.begin(), memo.end(), -1);\n        for(int i = 0; i < n; i++) {\n            int x, y, r, c;\n            cin >> x >> y >> r >>c;\n            disk.push_back(Disk(x, y, r, c));\n        }\n        cout << dfs(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nstruct Solver\n{\n\tconst int N;\n\tVI xs, ys, rs, cs;\n\n\tSolver( int n ) : N( n ), xs( N ), ys( N ), rs( N ), cs( N )\n\t{\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tcin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n\t\t}\n\t\treturn;\n\t}\n\n\toperator int()\n\t{\n\t\tint res = 0;\n\n\t\tqueue< vector<bool> > que;\n\t\tque.push( vector<bool>( N, true ) );\n\n\t\tset< vector<bool> > visited;\n\t\tvisited.insert( vector<bool>( N, false ) );\n\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tauto exists = que.front();\n\t\t\tque.pop();\n\n\t\t\tres = max<int>( res, count( ALL( exists ), false ) );\n\n\t\t\tREP( i, 0, N )\n\t\t\t{\n\t\t\t\tif ( overlapped( exists, i ) )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tREP( j, 0, i )\n\t\t\t\t{\n\t\t\t\t\tif ( !exists[i] || !exists[j] || cs[i] != cs[j] || overlapped( exists, j ))\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\texists[i] = exists[j] = false;\n\t\t\t\t\tif ( !EXIST( visited, exists ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tque.push( exists );\n\t\t\t\t\t}\n\t\t\t\t\tvisited.insert( exists );\n\t\t\t\t\texists[i] = exists[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tbool overlapped( const vector<bool> &exists, const int p )\n\t{\n\t\tREP( i, 0, p )\n\t\t{\n\t\t\tif ( !exists[i] )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( ( xs[p] - xs[i] ) * ( xs[p] - xs[i] ) + ( ys[p] - ys[i] ) * ( ys[p] - ys[i] ) < ( rs[i] + rs[p] ) * ( rs[i] + rs[p] ) )\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int n; cin >> n, n; )\n\t{\n\t\tcout << Solver( n ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\nint n;\nint x[24];\nint y[24];\nint r[24];\nint c[24];\nint ans;\nbool memo[1 << 24];\n\ninline int dbl(int x){ return x * x; }\n\nint main(){\n  while(scanf(\"%d\", &n), n){\n    REP(i,n) scanf(\"%d%d%d%d\", x+i, y+i, r+i, c+i);\n    memset(memo, 0, sizeof(memo)); ans = 0;\n\n    queue<int> q; q.push((1 << n) - 1);\n    memo[(1<<n) - 1] = true;\n\n    while(q.size()){\n      int flag = q.front(); q.pop();\n      ans = max(ans, n - __builtin_popcount(flag));\n\n      bool top[24]; REP(i,n) top[i] = true;\n\n      for(int i = 0; i < n; i++){\n        if(flag & (1 << i)){\n          for(int j = i + 1; j < n; j++){\n            if(flag & (1 << j)){\n              if(dbl(x[i] - x[j]) + dbl(y[i] - y[j]) < dbl(r[i] + r[j]))\n                top[j] = false;\n            }\n          }\n        }\n      }\n\n      for(int i = 0; i < n; i++){\n        if(top[i]){\n          for(int j = 0; j < n; j++){\n            if(top[j] && c[i] == c[j]){\n              int next = flag ^ (1 << i) ^ (1 << j);\n              if(!memo[next]){\n                q.push(next);\n                memo[next] = true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    print(ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n\nlong long  mod = 1000000007;\n\n\nbool lap[30][30];\n\n\nbool overlap(int i,int j,vector<int> &x,vector<int>&y,vector<int> &r){\n\tint k = 0;\n\tk = (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]);\n\tif(k>= (r[i]+r[j])*(r[i]+r[j]))return 0;\n\treturn 1;\n}\n\n\nint main(){\n\tint n;\n\twhile(cin >> n && n!=0){\n\t\tset<int>st,st2;\n\t\tvector<int>x(n),y(n),r(n),c(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tfor(int i=0;i<30;i++){\n\t\t\tfor(int j=0;j<30;j++){\n\t\t\t\tlap[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(overlap(i,j,x,y,r)==1){\n\t\t\t\t\tlap[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tbool flag = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\tif(lap[i][j]==0){\n\t\t\t\t\t\tfor(int k=i+1;k<j;k++){\n\t\t\t\t\t\t\tif(lap[i][k]&&lap[k][j]){\n\t\t\t\t\t\t\t\tlap[i][j]=1;\n\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)break;\n\t\t}\n\t\t/*for(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tcout << i <<  \" \" << j << \" \" << lap[i][j] << endl;\n\t\t\t}\n\t\t}*/\n\n\t\tst.insert((1<<n)-1);\n\t\tst2.insert((1<<n)-1);\n\t\twhile(1){\n\t\t\tbool flag = 1;\n\t\t\tset<int> st3;\n\t\t\tfor(auto s:st2){\n\t\t\t\t//cout << static_cast<bitset<24>>(s) << endl;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\t\tif(c[i]==c[j]){\n\t\t\t\t\t\t\tif((s&(1<<i))&&(s&(1<<j))){\n\t\t\t\t\t\t\t\tbool fl =1;\n\t\t\t\t\t\t\t\tfor(int p=0;p<i;p++){\n\t\t\t\t\t\t\t\t\tif(lap[p][i]==1&&(s&(1<<p)))fl = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int p=0;p<j;p++){\n\t\t\t\t\t\t\t\t\tif(lap[p][j]==1&&(s&(1<<p)))fl = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(fl){\n\t\t\t\t\t\t\t\t\tst.insert(s-(1<<i)-(1<<j));\n\t\t\t\t\t\t\t\t\tst3.insert(s-(1<<i)-(1<<j));\n\t\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tst2 = st3;\n\t\t\tif(flag)break;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(auto s:st){\n\t\t\tint c = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(s&(1<<i)){\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans,n-c);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n//// start up ////\nvoid solve();\ninline void readfrom(string filename) { freopen(filename.c_str(), \"r\", stdin); }\ninline void writeto(string filename) { freopen(filename.c_str(), \"w\", stdout); }\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n\tdouble arg() const { return atan2(y, x); }\n\tstatic P2 polar(double length, double theta) { return P2(std::polar(length, theta)); }\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n/// 円\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < -EPS; }\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < -EPS; } \n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n////////////////////\n/// template end ///\n////////////////////\n\nchar find(const vector<pair<int, int>> &chips, int remain, vector<char> &memo)\n{\n\tif (!remain) { return 0; }\n\tif (memo[remain] > 0) { return memo[remain]; }\n\n\tint r = 0;\n\tREP(i, chips.size()) if (remain & 1 << i) if ((remain & chips[i].second) == 0)\n\tFOR(j, i+1, chips.size()) if (remain & 1 << j) if ((remain & chips[j].second) == 0)\n\tif (chips[i].first == chips[j].first)\n\t{\n\t\tr = max(r, 2 + find(chips, remain & ~(1 << i) & ~(1 << j), memo));\n\t}\n\n\treturn memo[remain] = r;\n}\n\nvoid solve()\n{\n\tint testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, n);\n\t\tif (!(n )) { break; }\n\t\t\n\t\tvector<Circle> cs;\n\t\tvector<pair<int, int>> chips;\n\t\tREP(i, n)\n\t\t{\n\t\t\tREAD(Circle, circle);\n\t\t\tREAD(int, c);\n\t\t\tint block = 0;\n\t\t\tREP(j, cs.size())\n\t\t\t{\n\t\t\t\tif (circle.IntersectWith(cs[j])) block |= 1 << j;\n\t\t\t}\n\t\t\tcs.push_back(circle);\n\t\t\tchips.emplace_back(c, block);\n\t\t}\n\n\t\tvector<char> memo(1 << 24, -1);\n\t\tint result = find(chips, (1 << n) - 1, memo);\n\t\tWRITE(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint n;\nint x[25],y[25],r[25],c[25];\nint cover[25];\ndouble d[25][25];\nbool check[1<<25];\nint cnt,comb,a,b;\nint m,ans;\nint u;\n\ndouble dis(int i,int j){\n  return sqrt( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j]) * (y[i]-y[j]) );\n}\n\nvoid cov(int a){\n  cover[a] = -1;\n  for(int j=a-1;j>=0;j--){\n    if(d[j][a]<r[a]+r[j] && u>>j & 1){\n      cover[a] = j;\n      break;\n    }\n  }\n} \n\n  \nvoid rec(void){\n  int cnt;\n  for(int i=1;i<=4;i++){\n    cnt = 0;\n    for(int j=0;j<n;j++){\n      if( (u>>j & 1) && cover[j]<0 && c[j] == i)cnt++;\n    }\n    if(cnt==6){\n      for(int j=0;j<n;j++){\n\tif(c[j] == i)u -= 1<<j;\n      }\n      for(int j=0;j<n;j++)cov(j);\n\n      ans += 6;\n      m = max(m,ans);\n      if(!check[u]){\n\trec();\n\tcheck[u] = true;\n      }\n      ans -= 6;\n\n      for(int j=0;j<n;j++){\n\tif(c[j] == i)u += 1<<j;\n      }\n      for(int j=0;j<n;j++)cov(j);\n    }else{\n      for(int j=0;j<n;j++){\n\tif( (u>>j & 1) && cover[j]<0 && c[j] == i){\n\t  for(int k=j+1;k<n;k++){\n\t    if( (u>>k & 1) && cover[k]<0 && c[k] == i){\n\t      u -= 1<<j;\n\t      u -= 1<<k;\n\t      for(int l=0;l<n;l++)cov(l);\n\n\t      ans += 2;\n\t      m = max(m,ans);\n\t      if(!check[u]){\n\t\trec();\n\t\tcheck[u] = true;\n\t      }\n\t      ans -= 2;\n\n\t      u += 1<<j;\n\t      u += 1<<k;\n\t      for(int l=0;l<n;l++)cov(l);\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n}\n\n\n\nint main(){\n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    for(int i=0;i<n;i++)cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++)d[i][j] = dis(i,j);\n    }\n\n    u = (1<<n) - 1;\n    for(int i=0;i<(1<<n);i++)check[i] = false;\n    for(int i=0;i<n;i++)cov(i);\n\n    \n    m = 0;\n    ans = 0;\n    rec();\n\n    cout << m << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n\ntypedef struct {\n\tint x, y, r;\n\tint color;\n}circle_t;\n\nint n;\ncircle_t circle[30];\nint bitDP[(1<<24)]; // ??????????????????bit??§??????\nint overlap[30]; // ?????????????????????bit??§??????\n\nint main()\n{\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcin >> circle[i].x;\n\t\t\tcin >> circle[i].y;\n\t\t\tcin >> circle[i].r;\n\t\t\tcin >> circle[i].color;\n\t\t\t\n\t\t\toverlap[i] = 0;\n\t\t\tfor(int j = 0; j < i; j++) {\n\t\t\t\tint distance_x = circle[i].x - circle[j].x;\n\t\t\t\tint distance_y = circle[i].y - circle[j].y;\n\t\t\t\tdouble distance_circle = sqrt(pow(distance_x, 2) + pow(distance_y, 2));\n\t\t\t\tdouble sum_r = circle[i].r + circle[j].r;\n\t\t\t\tif(sum_r > distance_circle) {\n\t\t\t\t\toverlap[i] += (1 << j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int bit = 0; bit < (1 << n); bit++) {\n\t\t\tbitDP[bit] = 0;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int bit = 0; bit < (1 << n); bit++) {\n\t\t\tif(bit != 0 && bitDP[bit] == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tif(((1 << i) & bit)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int j = i+1; j < n; j++) {\n\t\t\t\t\tif(((1 << i) + (1 << j)) & bit) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(!(((overlap[i] & bit) == overlap[i]) && ((overlap[j] & bit) == overlap[j]))) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(circle[i].color == circle[j].color) {\n\t\t\t\t\t\tint next = (((1 << i) + (1 << j)) | bit);\n\t\t\t\t\t\tbitDP[next] = max(bitDP[next], bitDP[bit] + 2);\n\t\t\t\t\t\tans = max(ans, bitDP[next]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N;\nint ps[30][4];\nbool dp[100000000];\nbool hyou[25][25];\n\n\nbool hantei(int p, int i) {\n\tif ((1 << p) & i) return false;\n\tfor(int j = 0; j < p; j++) {\n\t\tif(hyou[p][j] and ((1 << j) & i) == 0) return false;\n\t}\n\treturn true;\n}\nint bitcount(int i) {\n\tint res = 0;\n\tfor(int b = 0; b < N; b++) {\n\t\tif ((i >> b) & 1) res++;\n\t}\n\treturn res;\n}\n\nint main() {\n\t\n\twhile(cin >> N, N) {\n\t\t//int x, y, r, c;\n\t\tfor(int i = 0; i < (1 << 24) ; i++) dp[i] = false;\n\t\tfor(int n = 0; n < N; n++) {\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tcin >> ps[n][i] ;\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint dx = ps[n][0] - ps[i][0];\n\t\t\t\tint dy = ps[n][1] - ps[i][1];\n\t\t\t\tint r1 = ps[n][2] + ps[i][2];\n\t\t\t\t\n\t\t\t\tif (dx * dx + dy * dy < r1 * r1) {\n\t\t\t\t\thyou[n][i] = true;\n\t\t\t\t} else {\n\t\t\t\t\thyou[n][i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[0] = true;\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < (1 << N); i++) {\n\t\t\tif (dp[i] == false) continue;\n\t\t\tfor(int k1 = 0; k1 < N; k1 ++) {\n\t\t\t\tif(!hantei(k1, i)) continue;\n\t\t\t\tfor(int k2 = k1 + 1; k2 < N; k2 ++) {\n\t\t\t\t\tif(!hantei(k2, i)) continue;\n\t\t\t\t\tif (ps[k1][3] == ps[k2][3]) dp[i | (1 << k1) | (1 << k2)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, bitcount(i));\n\t\t\t\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\t\t\n\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[100], y[100], r[100], c[100];\n\nint dist(int x, int y) {\n\treturn x * x + y * y;\n}\n\nint dfs(int S) {\n\tvector<int> ng(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif ((S & (1 << i)) || (S & (1 << j))) continue;\n\t\t\tif (dist(x[i] - x[j], y[i] - y[j]) < (r[i] + r[j]) * (r[i] + r[j])) {\n\t\t\t\tng[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif ((S & (1 << i)) == 0 && (S & (1 << j)) == 0 && !ng[i] && !ng[j] && c[i] == c[j]) {\n\t\t\t\tres = max(res, 2 + dfs(S | (1 << i) | (1 << j)));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tcout << dfs(0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<iomanip>\n#include<ctime>\n#include<cstring>\n#include<climits>\n#include<string>\n#include<vector>\n#include<map>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<stack>\n#include<deque>\n#include<list>\n#include<vector>\n#define LL long long\n/*\n#ifdef unix\n#define INT64 \"%lld\"\n#else\n#define INT64 \"%I64d\"\n#endif\n*/\nusing namespace std;\nint n,m,cnt,snt,K,times;\nLL oo=1000000007;\nstruct dic\n{\n\tint x,y,r;\n\tint c;\n}p[110],q[110];\nint num[110];\nint ans;\nbool vis[110];\ndouble dis(double x1,double y1,double x2,double y2)\n{\n\treturn (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n}\nbool cover(int pos)\n{\n\tfor (int i=1;i<pos;i++)\n\tif (!vis[i]&&dis(p[i].x,p[i].y,p[pos].x,p[pos].y)<(p[i].r+p[pos].r)*(p[i].r+p[pos].r)) \n\treturn true;\n\treturn false;\n}\nbool covero(int pos)\n{\n\tfor (int i=pos+1;i<=n;i++)\n\tif (!vis[i]&&dis(p[i].x,p[i].y,p[pos].x,p[pos].y)<(p[i].r+p[pos].r)*(p[i].r+p[pos].r)) \n\treturn true;\n\treturn false;\n}\nvoid dfs(int x,int y)\n{\n\tans=max(ans,y);\n\tint cc=0,minn=100;\n\tfor (int k=1;k<=4;k++)\n\t{\n\t\tint snt=0;\n\t\tfor (int i=1;i<=n;i++)\n\t\tif ((!vis[i])&&p[i].c==k&&(!cover(i))) snt++;\n\t\tif (snt>=2&&snt<minn) \n\t\t{\n\t\t\tminn=snt;\n\t\t\tcc=k;\n\t\t}\n\t}\n\tif (!cc) \n\t{\n\t\treturn;\n\t}\n\tdic q[10];\n\tint num[10];\n\tint m=0;\n\tfor (int i=1;i<=n;i++)\n\tif ((!vis[i])&&p[i].c==cc&&(!cover(i))) \n\t{\n\t\tq[++m]=p[i];\n\t\tnum[m]=i;\n\t}\n\tif  (m%2==0)\n\t{\n\t\tfor (int i=1;i<=m;i++) vis[num[i]]=true;\n\t\tdfs(x+1,y+m);\n\t\tfor (int i=1;i<=m;i++) vis[num[i]]=false;\n\t}\n\telse \n\t{\n\t\tint pp=m/2;\n\t\tfor (int i=1;i<=m;i++)\n\t\t{\n\t\t\tfor (int j=1;j<=m;j++) if (j!=i) vis[num[j]]=true;\n\t\t\tdfs(x+1,y+pp*2);\n\t\t\tfor (int j=1;j<=m;j++) if (j!=i) vis[num[j]]=false;\n\t\t}\n\t}\n}\nvoid work()\n{\n\tfor (int i=1;i<=n;i++)\n\tscanf(\"%d%d%d%d\",&p[i].x,&p[i].y,&p[i].r,&p[i].c);\n\tmemset(vis,0,sizeof(vis));\n\tans=0;\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\twhile (n!=0)\n\t{\n\t\twork();\n\t\tscanf(\"%d\",&n);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 24\n\nint N,x[MAX],y[MAX],r[MAX],c[MAX];\n\nint dist(int a,int b){\n    return (x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]);\n}\n\nbool check(int a,int b){\n    int d = dist(a,b);\n    int add = r[a]+r[b],sub = r[a]-r[b];\n    return ((sub*sub < d && d < add*add) || d <= sub*sub);\n}\n\nint main(){\n    while(cin >> N, N){\n        for(int i = 0 ; i < N ; i++){\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n        int bit[MAX] = {0};\n        for(int i = 0 ; i < N ; i++){\n            for(int j = 0 ; j < i ; j++){\n                if(check(i,j)) bit[i] |= (1<<j);\n            }\n        }\n        vector<bool> dp(1<<N,0);\n        dp[(1<<N)-1] = 1;\n        int res = 0;\n        for(int i = (1<<N)-1 ; i >= 0 ; i--){\n            if(dp[i] == 0) continue;\n            int n = __builtin_popcount(i);\n            for(int j = 0 ; j < N ; j++){\n                if((i&bit[j]) > 0) continue;\n                for(int k = j+1 ; k < N ; k++){\n                    if(c[j] != c[k]) continue;\n                    if((i&bit[k]) > 0) continue;\n                    int S = i & ~((1<<j) | (1<<k));\n                    dp[S] = 1;\n                    res = max(res,N-n);\n                }\n            }\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, int>\n\nclass C{\n    public:\n        int x, y, r, c;\n};\n\nvector<C> discs;\n\nint calDis(int x1, int y1, int x2, int y2){\n    int a = x1 - x2, b = y1 - y2;\n    return sqrt( a * a + b * b );\n}\n\nP searchPair(vector< set<int> > &v, vector<bool> &used){\n    REP(i, v.size()){\n        REP(j, v.size()){\n            if(i == j) continue;\n            if(!used[i] && !used[j] && discs[i].c == discs[j].c && v[i].empty() && v[j].empty()){\n                return P(i, j);\n            }\n        }\n    }\n    return P(-1, -1);\n}\n\nint dfs(vector< set<int> > &v, vector<bool> used, int cnt){\n    P p = searchPair(v, used);\n    if(p.first == -1) return cnt;\n    //else cout << p.first <<\", \" <<p.second <<endl;\n\n    int ret = cnt;\n    used[p.first] = true;\n    used[p.second] = true;\n    vector< set<int> > tmp = v;\n    REP(i, tmp.size()){\n        set<int>::iterator it = tmp[i].find(p.first);\n        if(it != tmp[i].end()) tmp[i].erase(it);\n        it = tmp[i].find(p.first);\n        if(it != tmp[i].end()) tmp[i].erase(it);\n    }\n    ret = max(ret, dfs(tmp, used, cnt + 2));\n    used[p.first] = false;\n    used[p.second] = false;\n\n    return ret;\n}\n\nint main(){\n    int n;\n    while(cin >>n && n){\n        discs = vector<C>(n);\n        vector< set<int> > v(n, set<int>());\n        REP(i, n) cin >>discs[i].x >>discs[i].y >>discs[i].r >>discs[i].c;\n\n        for(int now = 0; now < n; now++){\n            for(int i = now + 1; i < n; i++){\n                if(discs[now].r + discs[i].r > calDis(discs[now].x, discs[now].y, discs[i].x, discs[i].y)){\n                    v[i].insert(now);\n                    //TODO: 下の行がうまく動かないよー\n                    for(set<int>::iterator it = v[now].begin(); it != v[now].end(); it++) v[i].insert((*it));\n                }\n            }\n        }\n        //debug\n        //REP(i, n){\n        //    cout <<i <<\": \";\n        //    for(set<int>::iterator it = v[i].begin(); it != v[i].end(); it++) cout <<(*it) <<\", \";\n        //    cout <<endl;\n        //}\n        //cout <<endl;\n        cout <<dfs(v, vector<bool>(n, false), 0) <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-9\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nint N;\n\nmap<int,int> m;\n\nint to_i (vec &used) {\n    int res = 0;\n    for (int i = 0; i < N; i++) {\n        if (used[i])\n            res |= 1 << i;\n    }\n}\n\nint dfs(mat &rank, vec &used, vec &C) {\n    int toI = to_i(used);\n    if (m.find(toI) != m.end()) return m[toI];\n    int res = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j) continue;\n            if (!used[i] && !used[j] && C[i] == C[j] && !(rank[i][j] || rank[j][i])) {\n                bool flag = true;\n                for (int k = 0; k < N; k++) {\n                    if (k == i || k == j) continue;\n                    if (rank[i][k] && !used[k]) flag = false;\n                    if (rank[j][k] && !used[k]) flag = false;\n                }\n\n                if (flag) {\n                    used[i] = used[j] = 1;\n                    res = max(dfs(rank, used, C) + 1, res);\n                    used[i] = used[j] = 0;\n                }\n            }\n        }\n    }\n\n    return m[toI] = res;\n}\n\nint main() {\n    while (cin >> N, N) {\n        m.clear();\n        vector<double> X(N), Y(N), R(N);\n        vector<int> C(N);\n        for (int i = 0; i < N; i++) {\n            cin >> X[i] >> Y[i] >> R[i] >> C[i];\n        }\n\n        mat rank(N, vec(N));\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                double dis = sqrt(pow(X[i] - X[j], 2.) + pow(Y[i] - Y[j], 2.));\n                if (dis < R[i] + R[j]) {\n                    rank[j][i] = 1;\n                }\n            }\n        }\n\n        vec used(N);\n        cout << 2 * dfs(rank, used, C) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n#include<set>\nusing namespace std;\n\nstruct object{\n// 各円を示す構造体\n\tint id;\n\tint posx;\n\tint posy;\n\tint rad;\n\tint color;\n\tlist<int> parent;\n};\n\nbool operator == (object a,object b){\n\treturn a.id==b.id;\n}\nbool operator < (object a, object b){\n\treturn a.id<b.id;\n}\nbool operator < (list<object> a, list<object> b){\n\tif(a.size()!=b.size()) return a.size()<b.size();\n\tlist<object>::iterator ita=a.begin(),itb=b.begin();\n\twhile(1){\n\t\tif(ita==a.end())return false;\n\t\tif(ita==itb){\n\t\t\t++ita;\n\t\t\t++itb;\n\t\t}else{\n\t\t\treturn *ita<*itb;\n\t\t}\n\t}\n}\n\nvoid checkcontact(object& upper,object& lower){\n//　2つの円の重なりを調べ、下の円に自分の上にある円のidを記録\n\tif((upper.posx-lower.posx)*(upper.posx-lower.posx)+(upper.posy-lower.posy)*(upper.posy-lower.posy)<(upper.rad+lower.rad)*(upper.rad+lower.rad)){\n\t\tlower.parent.push_back(upper.id);\n\t}\n}\n\nlist<object>::iterator nexttop(list<object>::iterator itcur,list<object>::iterator& itl){\n// 現在iteratorと末端iteratorから、次の回収可能円を示すiterator又は末端iteratorを返却\n\tdo{\n\t\t++itcur;\n\t\tif(itcur==itl)return itcur;\n\t}while(!(*itcur).parent.empty());\n\treturn itcur;\n}\n\nunsigned int cal(list<object>& base,set< list<object> >& cald){\n\tif(cald.find(base)!=cald.end())return -1;\n\tlist<object> cop;\n\tlist<object>::iterator ita,itb,itc,itl;\n\tunsigned int submax=-1,subret;\n\titl=base.end();\n\tfor(ita=base.begin();ita!=itl;ita=nexttop(ita,itl)){\n\t\tfor(itb=nexttop(ita,itl);itb!=itl;itb=nexttop(itb,itl)){\n\t\t\tif((*itb).color==(*ita).color){\n\t\t\t\tcop=base;\n\t\t\t\tcop.remove(*ita);\n\t\t\t\tcop.remove(*itb);\n\t\t\t\tfor(itc=cop.begin();itc!=cop.end();++itc){\n\t\t\t\t\t(*itc).parent.remove((*ita).id);\n\t\t\t\t\t(*itc).parent.remove((*itb).id);\n\t\t\t\t}\n\t\t\t\tsubret=cal(cop,cald);\n\t\t\t\tif(subret<submax)submax=subret;\n\t\t\t}\n\t\t}\n\t}\n\tsubret=base.size();\n\tif(subret<submax)submax=subret;\n\tcald.insert(base);\n\treturn submax;\n}\nint main(){\n\tint n;\n\tobject tmp; \n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tlist<object> objects;\n\t\tlist<object>::iterator ita,itl;\n\t\tset< list<object> > cald;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp.id=i;\n\t\t\tcin>>tmp.posx>>tmp.posy>>tmp.rad>>tmp.color;\n\t\t\ttmp.parent.clear();\n\t\t\titl=objects.end();\n\t\t\tfor(ita=objects.begin();ita!=itl;++ita)checkcontact(*ita,tmp);\n\t\t\tobjects.push_back(tmp);\n\t\t}\n\t\tcout<<n-cal(objects,cald)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define sqr(a) ((a) * (a))\n\nusing namespace std;\n\nint mem[1 << 24];\nint n, x[24], y[24], r[24], c[24];\n\nbool judge(int b,int i){\n\tfor(int j = 0;j < i;j++){\n\t\tif(((b >> j) & 1) == 0 && sqr(x[j] - x[i]) + sqr(y[j] - y[i]) < sqr(r[j] + r[i])){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n\nint rec(int b){ // iは参照番地\n\tbool end = true;\n\tint res = 0;\n\tif(mem[b] != -1){\n\t\treturn mem[b];\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tif(((b >> i) & 1) == 0){ // iはとられていないものとられていないもの\n\t\t\tfor(int j = 0;j < i;j++){\n\t\t\t\tif(((b >> j) & 1) == 0){ // jがとられていないもの\n\t\t\t\t\tif(judge(b,i) && judge(b,j) && c[i] == c[j]){\n\t\t\t\t\t\tres = max(rec(b | (1 << i) | (1 << j)) + 2,res);\n\t\t\t\t\t\tend = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(end){\n\t\treturn 0;\n\t}\n\treturn mem[b] = res;\n}\n\nint main(void){\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfill(mem,mem + (1 << 24),-1);\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tcout << rec(0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define N 24\n\nint d[1<<N];\nint x[N],y[N],r[N],c[N];\n\nbool pailed(int a,int b){\n  int d2 = (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);\n  int r2 = (r[a]+r[b])*(r[a]+r[b]);\n  return d2 < r2;\n}\n\n\nint main(){\n  int n;\n  while(cin >> n,n){\n    vector<int> over(n);\n    fill(over.begin(),over.end(),0);\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n    }\n    for(int i=n-1;i>=0;i--){\n      for(int j=i-1;j>=0;j--){\n        if(pailed(i,j)){\n          over[i] |= 1<<j;\n        }\n      }\n    }\n\n    fill(d,d+(1<<n),0);\n    for(int i=0;i<1<<n;i++){\n      for(int j=0;j<n-1;j++){\n        if(!(i>>j&1)||over[j]&i) continue;\n        for(int k=j+1;k<n;k++){\n          if(!(i>>k&1)||over[k]&i||c[k]!=c[j]) continue;\n            d[i] = 2 + d[(~(1<<j))&(~(1<<k))&i];\n        }\n      }\n    }\n\n    cout << d[(1<<n)-1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<numeric>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\n//0?¬?\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double a) { return Point(a * x, a * y); }\n\tPoint operator/(double a) { return Point(x / a, y / a); }\n\tbool operator<(const Point &p)const { return x != p.x ? x < p.x : y < p.y; }\n\tbool operator==(const Point &p)const { return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS; }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n\n\t//Vector????????¢\n\tPoint rotate(double rad) { return Point(x*cos(rad) - y*sin(rad), x*sin(rad) + y*cos(rad)); }\n};\ninline ostream &operator << (ostream &os, const Point &p) { os << p.x << \" \" << p.y; return os; }\ninline istream &operator >> (istream &is, Point &p) { double x, y; is >> x >> y; p = Point(x, y); return is; }\n\n//1?¬?\ntypedef Point Vector;\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point(1, 1)) :p1(p1), p2(p2) {}\n\tVector vec() { return p2 - p1; }\n};\ntypedef Segment Line;\n\n//2?¬?\nclass Circle {\npublic:\n\tPoint c; //center\n\tdouble r; //radius\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\ntypedef vector<Point> Polygon;\n\n//?????? dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\n//?????? cross product\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\n//????????¢??? radian ??? ??? degree\ndouble rad(double deg) { return M_PI*deg / 180; }\n//????§? argument\ndouble arg(Vector p) { return atan2(p.y, p.x); }\n//?\\???¢??? polar form\nVector polar(double r, double a) { return Point(cos(a)*r, sin(a)*r); }\n\n//??´?????????\nbool isOrthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) { return isOrthogonal(a1 - a2, b1 - b2); }\nbool isOrthogonal(Segment s1, Segment s2) { return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//????????????\nbool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool isParallel(Point a1, Point a2, Point b1, Point b2) { return isParallel(a1 - a2, b1 - b2); }\nbool isParallel(Segment s1, Segment s2) { return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//?°???±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n//????°?\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p)*2.0; }\n\n//??????(p0,p1)????????????p2???????????¢???\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\n\n//??´?????¨??´??????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2); }\n//(?????????????¶????)\n\n//2??????????????¢\ndouble getDistance(Point a, Point b) { return (a - b).abs(); }\n//??´?????¨???????????¢\ndouble getDistanceLP(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()); }\n//????????¨???????????¢\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn getDistanceLP(s, p);\n}\n//????????¨??????????????¢\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn\tmin(\n\t\tmin(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))\n\t);\n}\n\n//?????¨??´??????????????????\nbool intersect(Circle c, Line l) { return getDistanceLP(l, c.c) <= c.r; }\n//?????¨?????????????????? ??±?????\\???(common tangent)?????°\nint intersect(Circle c1, Circle c2) {\n\tdouble d = getDistance(c1.c, c2.c);\n\tif (d > c1.r + c2.r)return 4;\n\tif (d == c1.r + c2.r)return 3;\n\tif (d + c1.r == c2.r || d + c2.r == c1.r)return 1; //?????¨?????´ return ???;\n\tif (d + c1.r < c2.r || d + c2.r < c1.r)return 0;\n\treturn 2;\n}\n\n//????????¨???????????????\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tassert(intersect(s1, s2));\n\tVector base = s2.p2 - s2.p1;\n\tdouble a1 = abs(cross(base, s1.p1 - s2.p1)); //area1\n\tdouble a2 = abs(cross(base, s1.p2 - s2.p1)); //area2\n\tdouble t = a1 / (a1 + a2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n//??´?????¨??´????????????\n//Point getCrossPointLL(Line l1, Line l2) {}\n\n//?????¨??´????????????\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n//?????¨????????????\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\tint m = intersect(c1, c2);\n\tassert(m != 4 && m != 0);\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//????????????\nenum { OUT = 0, ON, IN };\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS)return ON;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS&&EPS<b.y&&cross(a, b)>EPS)x = !x;\n\t}\n\treturn (x ? IN : OUT);\n}\n\n//????§???¢?????¢???\ndouble area(Polygon g) {\n\tdouble a = 0;\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\ta += cross(g[i], g[(i + 1) % g.size()]);\n\treturn a / 2.0;\n}\n\n//?????§????????????????¨??????????\nbool isConvex(Polygon g) {\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\tif (ccw(g[i], g[(i + 1) % g.size()], g[(i + 2) % g.size()]) == CLOCKWISE)\n\t\t\treturn false;\n\treturn true;\n}\n\nint above[25];\nsigned char dp[1 << 24];//??¶??? 0?????????????????¨ 1???????????????????????????\n\nint main() {\n\tfor (int n; cin >> n&&n;) {\n\t\tCircle C[25];\n\t\tint c[25];\n\t\tmemset(above, 0, sizeof(above));\n\t\tmemset(dp, -1, sizeof(dp));\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> C[i].c >> C[i].r >> c[i];\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tint ct = intersect(C[i], C[j]);\n\t\t\t\tif (ct <= 2)above[i] |= (1 << j); //??????????????£????????????????¨????\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tint fend = (1 << n);\n\t\tdp[0] = 0;\n\t\tfor (int bit = 0; bit < fend; bit++) {\n\t\t\tif (dp[bit] == -1)continue;\n\t\t\tans = max(ans, (int)dp[bit]);\n\t\t\tfor (int j = 0; j < n - 1; j++) {//n-1???????????§?????? (n-1,n)\n\t\t\t\tif (\n\t\t\t\t\t(bit&(1 << j)) == 0 //??????????????£?????????\n\t\t\t\t\t&& (bit&above[j]) == above[j] //??????k????????????????????????\n\t\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\t//?????¢????????£????¶??????????????????¢???\n\t\t\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tc[j] == c[k] //????????????\n\t\t\t\t\t\t\t&& (bit&(1 << k)) == 0 //??????????????£?????????\n\t\t\t\t\t\t\t&& (bit&above[k]) == above[k] //??????k????????????????????????\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint h = bit | (1 << j) | (1 << k); //??????j,k????????????????????¶???\n\t\t\t\t\t\t\tdp[h] = dp[bit] + 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24],S[24];\nbool take[24];\nint dp[1<<24];\n\ninline int sqr(int x){ return x*x; }\n\nint solve(int nowS){\n    int i,j,k;\n    int res = 0;\n    static const bool underFirst[] = {true, true, false};\n    static const bool underSecond[] = {true, false, true};\n\n\n    if( dp[nowS] != -1 ) return dp[nowS];\n\n    // 1. (円盤iの下に他の円盤がある,円盤jの下に他の円盤がある) の組み合わせ\n    // 2.1 円盤iの下に他の円盤がある,円盤jの下にはなにもない\n    // 2.2 円盤iの下にはなにもない,円盤jの下に他の円盤がある\n    \n    bool get = false;\n    for(k=0; k<3; k++){\n        for(i=0; i<n; i++){\n            if( (S[i] == (nowS & S[i])) && !(nowS & (1<<i)) && (take[i] == underFirst[k]) ) {\n                for(j=i+1; j<n; j++){\n                    if( (S[j] == (nowS & S[j])) && c[i] == c[j] && !(nowS & (1<<j)) && (take[j] == underSecond[k]) ){\n                        res = max(res, solve(nowS | (1<<i) | (1<<j)) + 2);\n                        get = true;\n                    }\n                }\n            }\n        }\n    }\n\n    // 3. 円盤iの下にはなにもない,円盤jの下にもなにもない(取れるだけ取る)\n    int sum = 0;\n    if( !get ){\n        bool used[24];\n        memset(used, false, sizeof(used));\n        for(i=0; i<n; i++){\n            if( !used[i] && (S[i] == (nowS & S[i])) && !(nowS & (1<<i)) && (take[i] == false) ) {\n                for(j=i+1; j<n; j++){\n                    if( !used[j] && (S[j] == (nowS & S[j])) && c[i] == c[j] && !(nowS & (1<<j)) && (take[j] == false) ){\n                        sum += 2;\n                        used[i] = used[j] = true;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    return dp[nowS] = res + sum;\n}\n\n\nint main(){\n    int i,j;\n\n    while( cin >> n, n ){\n        // init\n        memset(S, 0, sizeof(S));\n        memset(take, false, sizeof(take));\n        memset(dp, -1, sizeof(dp));\n\n        // input\n        for(i=0; i<n; i++) cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n        // フィルターを作る\n        for(i=0; i<n; i++){\n            for(j=0; j<i; j++){\n                if( sqr(x[i] - x[j]) + sqr(y[i] - y[j]) < sqr(r[i] + r[j]) ){\n                    S[i] |= 1<<j;\n\n                    // 円盤jの下にある円盤があるかどうか\n                    take[j] = true;\n                }\n            }\n        }\n        cout << solve(0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nmain {\n  while (true) {\n    int n = in();\n    if (n == 0) break;\n    vector<int> x(n), y(n), r(n), c(n);\n    rep(i, n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n    auto intersectCC = [&](int i, int j) {\n      int r2 = (r[i] + r[j]) * (r[i] + r[j]);\n      int d = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n      return d < r2;\n    };\n    auto intersect = [&](int t, int used) {\n      bool f = false;\n      rep(i, t) f |= (~used >> i & 1) && intersectCC(t, i);\n      return f;\n    };\n    vector<int> dp(1 << n, -1);\n    function<int(int)> dfs = [&](int used) {\n      if (dp[used] != -1) return dp[used];\n      cmax(dp[used], 0);\n      rep(i, n) loop(j, i + 1, n) {\n        if ((used >> i & 1) || (used >> j & 1) || c[i] != c[j]) continue;\n        if (intersect(i, used) || intersect(j, used)) continue;\n        cmax(dp[used], dfs(used | (1 << i) | (1 << j)) + 2);\n      }\n      return dp[used];\n    };\n    cout << dfs(0) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define len(v) (int)(v).size()\n\nusing namespace std;\n\nvector<int> G[25];\nint mp[(1 << 24)];\nint ch[(1 << 24)];\nvector<int> x,y,r,c;\nint p[25];\nint n;\n\nint dfs(int par)\n{\n    if(mp[par] >= 0){\n        return mp[par];\n    }\n    vector<vector<int> > cl(4);\n    rep(i,n){\n        if((par >> i)&1){\n            cl[c[i]].pb(i);\n        }\n    }\n    int mx = 0;\n    rep(i,4){\n        if(len(cl[i])>=2){\n            rep(j,len(cl[i])-1){\n                int npar = par - (1 << cl[i][j]);\n                for(auto& v : G[cl[i][j]]){\n                    p[v] -= (1 << cl[i][j]);\n                    if(p[v]==0) npar += (1 << v);\n                }\n                for(int k=j+1;k<len(cl[i]);k++){\n                    npar -= (1 << cl[i][k]);\n                    for(auto& v : G[cl[i][k]]){\n                        p[v] -= (1 << cl[i][k]);\n                        if(p[v]==0) npar += (1 << v);\n                    }\n                    mx = max(mx,dfs(npar)+2);\n                    for(auto& v : G[cl[i][k]]){\n                        if(p[v]==0) npar -= (1 << v);\n                        p[v] += (1 << cl[i][k]);\n                    }\n                    npar += (1 << cl[i][k]);\n                }\n                for(auto& v : G[cl[i][j]]){\n                    p[v] += (1 << cl[i][j]);\n                }\n            }\n        }\n    }\n    mp[par] = mx;\n    return mx;\n}\n\ninline bool intersect(int i, int j)\n{\n    return (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j])*(r[i]+r[j]);\n}\n\nint main()\n{\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            G[i].clear();\n        }\n        memset(mp,-1,sizeof(mp));\n        memset(ch,0,sizeof(ch));\n        x.resize(n),y.resize(n),r.resize(n),c.resize(n);\n        rep(i,n){\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n            p[i] = 0;\n            c[i]--;\n            rep(j,i){\n                if(intersect(i,j)){\n                    G[j].pb(i);\n                    p[i] += (1 << j);\n                }\n            }\n        }\n        int par = 0;\n        rep(i,n){\n            if(p[i] == 0){\n                par += (1 << i);\n            }\n        }\n        cout << dfs(par) << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\nint n;\nchar dp[1 << 24];\n//char up[24];\n//vector<char> dp, up;\n//vector<Circle> c;\nCircle c[24];\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = (a.r + b.r) * (a.r + b.r);\n    int d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    return r > d;\n}\n\nbool isUp(char s, int v)\n{\n    for (int i = 0; i < v; ++i)\n        if ((s >> i & 1) && isOverlap(c[v], c[i]))\n            return true;\n    return false;\n}\n\nchar Rec(int s)\n{\n    if (~dp[s])\n        return dp[s];\n\n    int res = 0;\n    // 取り除く2つの円の選択\n    for (int i = 0; i < n; ++i) {\n        // c[i]がないか取り除けない\n        // if (!(s >> i & 1) || isUp(s, i))\n        //     continue;\n        // if (!(s >> i & 1) || s & up[i])\n        //     continue;\n\n        for (int j = i + 1; j < n; ++j) {\n            // c[i]とc[j]の色が異なる\n            // if (c[i].c != c[j].c)\n            //     continue;\n            // c[j]がないか取り除けない\n            // if (!(s >> j & 1) || s & up[j])\n            //     continue;\n            // if (!(s >> j & 1) || isUp(s, j))\n            //     continue;\n            if ((s >> i & 1) && !isUp(s, i) && c[i].c == c[j].c\n                && (s >> j & 1) && !isUp(s, j))\n//            int nxt = s & ~(1 << i) & ~(1 << j);\n            res = max(res, Rec(s & ~(1 << i) & ~(1 << j)) + 2);\n        }\n    }\n\n    return dp[s] = res;\n}\n\nint main()\n{\n    while (cin >> n, n) {\n        memset(dp, -1, sizeof(dp));\n//        memset(up, 0, sizeof(up));\n//        c.resize(n);\n\n        // 円の入力\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        // // 円の重なり，上下関係\n        // for (int i = 0; i < n; ++i)\n        //     for (int j = i + 1; j < n; ++j)\n        //         if (isOverlap(c[i], c[j]))\n        //             up[j] |= (1 << i);\n\n        cout << (int)Rec((1 << n) - 1) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct D{\n  int x,y,r,c;\n  D(int x=0,int y=0,int r=0,int c=-1):x(x),y(y),r(r),c(c){};\n};\n\nD d[25];\nint n;\nchar s[1<<24]; // stateの状態の時、取り除ける最大の枚数\nint ans;\n\nint dis(int i,int j){\n  int x=d[i].x-d[j].x, y=d[i].y-d[j].y;\n  return x*x+y*y;\n}\n\nbool isTop(int state,int i){ // d[i] の上に円盤がないならtrue\n  //    cout << \" isTop (\" << state <<\",\"<<i << \")\" << endl;\n  for( int j=0;j<i;j++ ){\n    //    cout << \" j=\" << j;\n    if( !(state & 1<<j) ) continue;\n    int dist = dis(i,j);\n    int r = d[i].r + d[j].r;\n    r=r*r;\n\n    //    cout << \" dist=\"<<dist << \" r=\"<<r  << endl;\n    if( dist < r ) return false;\n  }\n\n  return true;\n}\n\nint dfs( int state ){\n  /*\n  cout << \"state(\" << state << \")\";\n  for( int i=n-1;i>=0;i-- ){\n    if( state & 1<<i ) cout << \"1\";\n    else cout << \"0\";\n  }\n  cout << \" \" << (int)s[state] << endl;;\n  */\n\n  int a,b,rtn=0,c;\n  if( s[state]>=0 ) return s[state];\n\n\n  for( int i=0;i<n;i++ ){\n    if( ! (a=state & 1<<i) ) continue;\n    if( !isTop(state,i) ) continue;\n    //    cout << \"i = top\"<<endl;\n\n    for( int j=i+1;j<n;j++ ){\n      if( ! (b=state & 1<<j) ) continue;\n      if( d[i].c!=d[j].c ) continue;\n      if( !isTop(state,j) ) continue;\n      //      cout << \"j=top\" <<endl;\n\n      c=dfs( state-a-b )+2;\n      if( c>rtn ) rtn=c;\n    }\n  }\n  return s[state]=rtn;\n}\n\nint main(){\n\n  while( cin>>n && n){\n    for( int i=0;i<n;i++ )\n      cin >> d[i].x >> d[i].y >> d[i].r >> d[i].c;\n\n    for(int i=0,len=1<<n;i<len;s[i++]=-1 );\n    s[0]=0;\n\n    int state=0;\n    for( int i=0;i<n;i++ )    state = state | 1<<i;\n    cout << dfs( state ) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define MAX_COLORS 6\n#define MAX_CIRCLES 4\n#define MAX_N (MAX_COLORS*MAX_CIRCLES)\n#define MAX_STATES (1<<MAX_N)\n\nint biggest, n;\n\nstruct circle{\n    int x, y, r, c;\n};\n\ncircle C[MAX_N];\nchar dp[MAX_STATES];\n\nbool isOver( circle c1, circle c2 ){\n    int dx, dy;\n    dx = (c1.x - c2.x) * (c1.x - c2.x);\n    dy = (c1.y - c2.y) * (c1.y - c2.y);\n    return dx + dy < (c1.r + c2.r)*(c1.r + c2.r) ? true : false;\n}\n\nbool isDeleted( int state, int num ){\n    return (state & (1<<num)) == 0 ? false : true;\n}\n/*\nvoid pbit(int num){\n    //cout << \"bit: \";\n    do{\n        printf(\"%d\", num&1);\n        num = num>>1;\n    }while(num);\n    //printf(\"\\n\");\n}*/\n\nbool isTop( int state, int num ){\n    //pbit(state);\n    for( int i = num-1; i >= 0; i-- ){\n        if( isDeleted(state, i) ) continue;\n        if( isOver(C[num], C[i]) ) return false;\n    }\n    //cout << num << \" is top\" << endl;\n    return true;\n}\n\nvoid search(int s){\n    //for( int s = 0; s < 1<<n; s++ ){\n        /*cout << \"s: \";\n        pbit(s);\n        cout << endl;\n        */\n        for( int i = 0; i < n; i++ ){\n            if( isDeleted(s, i) ) continue;\n            //cout << \"i: \" << i << endl;\n            for( int j = i+1; j < n; j++ ){\n                if( isDeleted(s, j) ) continue;\n                //cout << \"i: \" << i << endl;\n                //cout << \"j: \" << j << endl;\n                if( isTop(s, i) && isTop(s, j) && C[i].c == C[j].c ){\n                    int next = s | 1<<i | 1<<j;\n                    //pbit(s);\n                    //cout << \",\" << i << \",\" << j << endl;\n                    if( dp[next] < dp[s]+2 ) dp[next] = dp[s]+2;\n                    if( biggest < dp[next] ) biggest = dp[next];\n                    if( (next | 1) != (1<<n)-1 ) search(next);\n                }\n            }\n        }\n    //}\n}\n\nvoid init(){\n    for( int s = 0; s < 1<<n; s++ ){\n        dp[s] = 0;\n    }\n}\n\nint main(){\n    while( cin >> n, n ){\n        for( int i = 0; i < n; i++ ){\n            circle a;\n            //scanf(\"%d%d%d%d\", a.x, a.y, a.r, a.c);\n            cin >> a.x >> a.y >> a.r >> a.c;\n            C[i] = a;\n        }\n        biggest = 0;\n        init();\n        //dp[0] = 0;\n        search(0);\n        printf(\"%d\\n\", biggest);\n        //cout << \"ans: \" << biggest << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\nint N, X[24], Y[24], R[24], C[24];\n\nbool isCoverd(int i, int j)\n{\n  int x = abs(X[i] - X[j]), y = abs(Y[i] - Y[j]), r = R[i] + R[j];\n  return ((x * x) + (y * y)) < (r * r);\n}\n\nbool noCoverd(int j, int s) {\n  for (int i = 0; i < j; i++)\n    if ( (s >> i & 1) && isCoverd(i, j))\n      return false;\n\n  return true;\n}\n\nchar memo[1 << 24];\nint dfs(int s)\n{\n  if (memo[s] != -1)\n    return memo[s];\n  \n  int ans = 0;\n  for (int i = 0; i < N; i++) {\n    for (int j = i + 1; j < N; j++) {\n      if ( (s >> i & 1) && (s >> j & 1)         && // 両方の皿が除去されていない場合\n           noCoverd(i, s) && noCoverd(j, s)     && // 重なっていない\n           C[i] == C[j]\n         ) {\n        ans = max(ans, dfs(s & ~(1 << i) & ~(1 << j)) + 2);\n      }\n    }\n  }\n  \n  return memo[s] = ans;\n}\n\n\nint main()\n{\n  while (cin >> N && N) {\n    for (int i = 0; i < N; i++) \n      cin >> X[i] >> Y[i] >> R[i] >> C[i];\n\n    memset(memo, -1, sizeof(memo));\n\n    cout << dfs((1 << N) - 1) << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define pb push_back\nusing namespace std;\n\nint n;\nint ans;\nint x[30], y[30], r[30], c[30];\nbool used[30];\nbool did[30][30];\nvector<int> G[30];\n\nvoid dfs(int cnt){\n\tans = max(ans,cnt);\n\trep(i,n){\n\t\tif(used[i])continue;\n\t\tused[i] = true;\n\t\tbool yes = true;\n\t\trep(j,G[i].size()){\n\t\t\tif(!used[G[i][j]]){\n\t\t\t\tyes = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(yes){\n\t\t\tfor(int j = i+1; j < n; j++){\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tif(c[i] != c[j]) continue;\n\t\t\t\tif(did[i][j]) continue;\n\t\t\t\t\n\t\t\t\tused[j] = true;\n\t\t\t\tbool no = false;\n\t\t\t\trep(k,G[j].size()){\n\t\t\t\t\tif(G[j][k] == i){\n\t\t\t\t\t\tno = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(!used[G[j][k]]){\n\t\t\t\t\t\tno = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!no){\n\t\t\t\t\tdid[i][j] = true;\n\t\t\t\t\tdfs(cnt+2);\n\t\t\t\t}\n\t\t\t\tused[j] = false;\n\t\t\t}\n\t\t}\n\t\tused[i] = false;\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%d\",&n),n){\n\t\tmemset(used,0,sizeof(used));\n\t\tmemset(did,0,sizeof(did));\n\t\tans = 0;\n\t\trep(i,30) G[i].clear();\n\t\trep(i,n) scanf(\"%d%d%d%d\",x+i,y+i,r+i,c+i);\n\t\trep(i,n) for(int j = i+1; j < n; j++){\n\t\t\tif((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])<(r[i]+r[j])*(r[i]+r[j])){\n\t\t\t\tG[j].pb(i);\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint main(){\n  int n;\n  cin >> n;\n  while(n!=0){\n    int sum=0;\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    int f=0;\n    int on[24]={};\n    int cc[5]={};\n    while(f==0){\n      f=1;\n      \n      for(i=0;i<24;i++) on[i]=0;\n      for(i=0;i<v.size();i++){\n\tfor(j=i+1;j<v.size();j++){\n\t  if(ch(v[i],v[j])==1) on[j]=1;\n\t}\n      }\n      for(i=0;i<5;i++) cc[i]=0;\n      for(i=0;i<v.size();i++){\n\tif(on[i]==0) cc[v[i].c]++;\n      }\n      for(i=1;i<5;i++){\n\tk=0;\n\tfor(j=v.size()-1;j>=0;j--){\n\t  if(on[j]==0&&v[j].c==i){\n\t    if((cc[i]/2)*2>k) {\n\t      v.erase(v.begin()+j);\n\t      k++;\n\t      sum++;\n\t      f=0;\n\t    }\n\t  }\n\t}\n\tif(f==0) break;\n      }\n    }\n    cout << sum << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n\n#define REP(i,a,n) for(i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n\nbool used[30];\nint x[30], y[30], r[30], c[30], over[30];\nint n;\nmap<int,int> dp;\n\nint sqr(int x){ return x*x; }\n\nbool istop(int node){\n  int i;\n  rep(i,node) if( !used[i] ) {\n    if( sqr(x[i] - x[node]) + sqr(y[i] - y[node]) < sqr(r[i]) + 2*r[i]*r[node] + sqr(r[node]) ) return false;\n  }\n  return true;\n}\n\nint solve(int S){\n  int i,j, res = 0;\n\n  if( dp.count(S) ) return dp[S];\n  \n  rep(i,n) if( !used[i] && ((S&over[i]) == over[i]) ){\n    REP(j,i+1,n) if( !used[j] && c[i] == c[j] && ((S&over[j]) == over[j]) ){\n      used[i] = used[j] = true;\n      //printf(\"(%d,%d), S=%d\\n\",i,j,S|(1<<i)|(1<<j));\n      res = max(res, solve(S|(1<<i)|(1<<j)) + 2);\n      used[i] = used[j] = false;\n    }\n  }\n  return dp[S] = res;\n}\n\nint main(){\n  int i,j;\n  \n  while( scanf(\"%d\",&n), n ){\n    memset(used, false, sizeof(used));\n    dp.clear();\n    rep(i,n) scanf(\"%d %d %d %d\",x+i,y+i,r+i,c+i);\n\n    rep(i,n){\n      int S = 0;\n      rep(j,i){\n        if( sqr(x[i] - x[j]) + sqr(y[i] - y[j]) < sqr(r[i]) + 2*r[i]*r[j] + sqr(r[j]) ){\n          S |= 1<<j;\n        }\n      }\n      over[i] = S;\n    }\n\n    /*\n    rep(i,n){\n      printf(\"over[%d] = %d\\n\",i,over[i]);\n    }\n      */\n\n    /*\n    cout << \"n=\" << n << endl;\n    rep(i,n){\n      printf(\"x[%2d] = %3d, y[%2d] = %3d, r[%2d] = %3d, c[%2d] = %3d\\n\",i,x[i],i,y[i],i,r[i],i,c[i]);\n    }\n    rep(i,n){\n        printf(\"istop(%d) = %d\\n\",i,istop(i));\n    }\n      */\n\n    cout << solve(0) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\ndouble sqr(double x) { return x*x; }\n\nstruct circle\n{\n  int x, y, r, c;\n  bool covers(const circle& a) const\n  {\n    return sqrt(sqr(x - a.x) + sqr(y - a.y)) < r + a.r;\n  }\n};\n\nint N;\ncircle cs[24];\n\nint memo[1<<24];\nint dfs(int used)\n{\n  int& ans = memo[used];\n  if (ans != -1) {\n    return ans;\n  }\n\n  ans = 0;\n  bool top[24];\n  fill_n(top, 24, true);\n  for (int i = 0; i < N; i++) {\n    if (used & (1<<i)) {\n      continue;\n    }\n    for (int j = i+1; j < N; j++) {\n      if (used & (1<<j)) {\n        continue;\n      }\n      if (cs[i].covers(cs[j])) {\n        top[j] = false;\n      }\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    if (used & (1<<i)) {\n      continue;\n    }\n    if (!top[i]) {\n      continue;\n    }\n    for (int j = i+1; j < N; j++) {\n      if (used & (1<<j)) {\n        continue;\n      }\n      if (!top[j]) {\n        continue;\n      }\n      if (cs[i].c == cs[j].c) {\n        ans = max(ans, 2 + dfs(used | (1<<i) | (1<<j)));\n      }\n    }\n  }\n  return ans;\n}\n\nint main()\n{\n  while (cin >> N && N != 0) {\n    for (int i = 0; i < N; i++) {\n      cin >> cs[i].x >> cs[i].y >> cs[i].r >> cs[i].c;\n    }\n    fill_n(memo, 1<<N, -1);\n    cout << dfs(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\n\nclass state{\npublic:\n    P p;\n    double r;\n    int c;\n};\n\nbool onCircle(state a, state b){\n    return (abs(a.p-b.p) < a.r+b.r);\n}\n\nshort int a[1<<24];\nint n;\nstate v[24];\nint ans, over[24];\n\nvoid check(int pos){\n    int c = 0;\n    for(int i=0;i<n;i++){\n        if((pos & (1<<i)) == 0){\n            c |= over[i];\n            int c2 = c;\n            for(int j=i+1;j<n;j++){\n                if((pos & (1<<j)) == 0 && (c2 & (1<<j)) == 0 && v[i].c == v[j].c){\n                    int next = pos | (1<<i) | (1<<j);\n                    if(a[next] < a[pos] + 2){\n                        a[next] = a[pos] + 2;\n                        ans = max((short int)ans,a[next]);\n                        check(next);\n                    }\n                }\n                if((pos & (1<<j)) == 0) c2 |= over[j];\n            }\n        }\n    }\n}\n\nint main(){\n    while(cin >> n && n){\n        fill(over,over+n,0);\n        fill(a,a+(1<<n),0);\n        ans = 0;\n        for(int i=0;i<n;i++){\n            double x,y;\n            cin >> x >> y >> v[i].r >> v[i].c;\n            v[i].p = P(x,y);\n        }\n\n        for(int i=0;i<n;i++)\n            for(int j=0;j<n;j++)\n                if(onCircle(v[i],v[j]))\n                    over[i] |= (1<<j);\n\n        check(0);\n\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\n\nclass Main{\n\tpublic:\n\n\tmap<int,int> dp;\n\n\tint dfs(int rmv){\n\t\tif(dp.count(rmv))return dp[rmv];\n\t\tint rM=0;\n\t\t//canrmvから2つ選ぶ\n\t\tREP(i,N)if(canrmv(i,rmv))REP(j,N)if(i<j)if(cs[i]==cs[j] && canrmv(j,rmv)){\n\t\t\trmv|=1<<i;rmv|=1<<j;\n\t\t\trM=max(rM,dfs(rmv)+2);\n\t\t\trmv&=~(1<<i);rmv&=~(1<<j);\n\t\t}\n\t\treturn dp[rmv]=rM;\n\t}\n\n\tbool canrmv(int i,int rmv){\n\t\tif((rmv>>i)&1)return false;\n\t\tREP(j,i) if(!((rmv>>j)&1) && ((is[i]>>j)&1))return false;\n\t\treturn true;\n\t}\n\n\tint N;\n\tvector<int> xs,ys,rs,cs;\n\tvector<int> is;\n\n\tbool intersect(int i,int j){\n\t\treturn hypot(xs[i]-xs[j],ys[i]-ys[j])<rs[i]+rs[j];\n\t}\n\n\tvoid run(){\n\t\t// ifstream cin(\"D2\");\n//\t\tofstream cout( \"D2.out\" );\n\t\t\n\t\twhile(true){\n\t\t\tcin >> N;if(N==0)break;\n\t\t\txs=vector<int>(N);ys=vector<int>(N);\n\t\t\trs=vector<int>(N);cs=vector<int>(N);\n\t\t\tREP(i,N) {\n\t\t\t\tcin >> xs[i] >> ys[i]>>rs[i]>>cs[i];cs[i]--;\n\t\t\t }\n\t\t\t is=vector<int>(N);\n\t\t\t REP(i,N)REP(j,N)if(intersect(i,j))is[i]|=1<<j;\n\t\t\tdp=map<int,int>();\n\t\t\tcout << dfs(0) <<endl;\n\t\t}\n\t}\n\n\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n;\nint x[24],y[24],r[24],c[24];\nint dist(int a,int b){return (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);}\n \nint rec(int S){\n  int res=0;\n  bool f[n];\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    f[i]=true;\n    for(int j=i-1;j>=0;j--){\n      if((S>>j)&1)continue;\n      if(dist(i,j)>=(r[i]+r[j])*(r[i]+r[j]))continue;\n      f[i]=false;\n    }\n  }\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    if(!f[i])continue;\n    for(int j=i+1;j<n;j++){\n      if((S>>j)&1)continue;\n      if(!f[j])continue;\n      if(c[i]!=c[j])continue;\n      return 2+rec(S+(1<<i)+(1<<j));\n    }\n  }\n  return 0;\n}\n \nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++)\n      scanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n    cout<<rec(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse if (dis < eps) {\n\t\tconst ld ar = min(l.r, r.r);\n\t\treturn ar*ar*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\nvector<Circle>cs;\nvector<int>colors;\nchar memo[1 << 24];\nint getans(const vector<vector<int>>&edges, vector<int>&nums,bitset<24>&used) {\n\tif (memo[used.to_ulong()] != -1)return memo[used.to_ulong()];\n\tvector<vector<int>>colorids(4);\n\tfor (int i = 0; i < nums.size(); ++i) {\n\t\tif (!used[i]) {\n\t\t\tif (!nums[i]) {\n\t\t\t\tcolorids[colors[i]].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tfor (int a = 0; a < colorids[i].size(); ++a) {\n\t\t\tint aid = colorids[i][a];\n\t\t\tfor (int b = a + 1; b < colorids[i].size(); ++b) {\n\t\t\t\tconst int bid = colorids[i][b];\n\t\t\t\tused[aid] = true;\n\t\t\t\tused[bid] = true;\n\t\t\t\tfor (auto e : edges[aid]) {\n\t\t\t\t\tnums[e]--;\n\t\t\t\t}\n\t\t\t\tfor (auto e : edges[bid]) {\n\t\t\t\t\tnums[e]--;\n\t\t\t\t}\n\t\t\t\tans = max(ans,2 + getans(edges, nums, used));\n\t\t\t\tused[aid] = false;\n\t\t\t\tused[bid] = false;\n\t\t\t\tfor (auto e : edges[aid]) {\n\t\t\t\t\tnums[e]++;\n\t\t\t\t}\n\t\t\t\tfor (auto e : edges[bid]) {\n\t\t\t\t\tnums[e]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[used.to_ulong()]=ans;\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 1 << 24; ++i) {\n\t\t\tmemo[i] = -1;\n\t\t}\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tcs.clear();\n\t\tcolors.clear();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y, r, c; cin >> x >> y >> r >> c;\n\t\t\tc--;\n\t\t\tcs.emplace_back(Point(x, y), r);\n\t\t\tcolors.push_back(c);\n\t\t}\n\t\tvector<vector<int>>edges(N);\n\t\tvector<int>nums(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tif (two_circle_area(cs[i],cs[j])>eps) {\n\t\t\t\t\tedges[i].push_back(j);\n\t\t\t\t\tnums[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbitset<24>bs;\n\t\tint ans = getans(edges, nums,bs);\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint n;\nint x[24];\nint y[24];\nint c[24];\nint r[24];\nchar memo[1<<24];\nint hit(int i,int j){\n\tint L = r[i]*r[i] + r[j]*r[j] + 2 * r[i] * r[j];\n\tint X = (x[i]-x[j])*(x[i]-x[j]);\n\tint Y = (y[i]-y[j])*(y[i]-y[j]);\n\treturn X + Y < L;\n}\nint nocover(int n,int bit){\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( (bit>>i&1) && hit(i,n) ) return false;\n\t}\n\treturn true;\n}\nint dfs(int bit){\n\tif(~memo[bit]) return memo[bit];\n\tint ans = 0;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tfor(int j = i+1 ; j < n ; j++){\n\t\t\tif( (bit >> j & 1) && (bit >> i & 1) && c[i] == c[j] && nocover(i,bit) && nocover(j,bit) ){\n\t\t\t\tans = max(ans , dfs( bit - (1<<j) - (1<<i) ) + 2);\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[bit] = ans;\n}\nint main(){\n\twhile(cin >> n , n){\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tcout << dfs((1<<n)-1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 4*6;\n\nint n;\nint x[N], y[N], r[N], c[N], over[N];\nchar memo[1<<N];\n\nbool intersects(int x1, int y1, int r1, int x2, int y2, int r2) {\n  int x = x2 - x1, y = y2 - y1, r = r1 + r2;\n  return x*x + y*y < r*r;\n}\n\nint calc(int used) {\n  if (memo[used] != -1) { return memo[used]; }\n  int ret = 0;\n  for (int i = 0; i < n; ++i) {\n    if (used & (1 << i)) { continue; }\n    if (over[i] & ~used) { continue; }\n    for (int j = i+1; j < n; ++j) {\n      if (used & (1 << j)) { continue; }\n      if (over[j] & ~used) { continue; }\n      if (c[i] != c[j]) { continue; }\n      ret = max(ret, calc(used | (1 << i) | (1 << j)) + 2);\n    }\n  }\n  return memo[used] = ret;\n}\n\nint main() {\n  while (scanf(\"%d\", &n), n) {\n    memset(memo, -1, sizeof(memo));\n    for (int i = 0; i < n; ++i) {\n      scanf(\"%d%d%d%d\", x+i, y+i, r+i, c+i);\n    }\n    for (int i = 0; i < n; ++i) {\n      over[i] = 0;\n      for (int j = 0; j < i; ++j) {\n        if (intersects(x[i], y[i], r[i], x[j], y[j], r[j])) {\n          over[i] |= 1 << j;\n        }\n      }\n    }\n    printf(\"%d\\n\", calc(0));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\nstruct E{\n\tvector<int> ov;\n\tint color;\n\tint x, y, r;\n\tE(int _x, int _y, int _r, int _c){\n\t\tcolor = _c;\n\t\tx = _x;\n\t\ty = _y;\n\t\tr = _r;\n\t}\n};\n\nbool dp[(1<<25)] = {0};\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tint x, y, r, c, _ans=0;\n\t\tvector<E> e;\n\t\tqueue<int> que;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tE tmp(x,y,r,c);\n\t\t\tfor(int j=0; j<e.size(); j++){\n\t\t\t\tif( (e[j].x-x)*(e[j].x-x) + (e[j].y-y)*(e[j].y-y) < (e[j].r+r)*(e[j].r+r) ){\n\t\t\t\t\ttmp.ov.push_back( j );\n\t\t\t\t}\n\t\t\t}\n\t\t\te.push_back( tmp );\n\t\t}\n\t\tfill(dp, dp+(1<<25), false);\n\t\tdp[0] = true;\n\t\tque.push(0);\n\t\twhile( !que.empty() ){\n\t\t\tint i = que.front();\n\t\t\tque.pop();\n\t\t\tif(dp[i]){\n\t\t\t\t_ans = max(_ans,i);\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tfor(int l=0; l<n; l++){\n\t\t\t\t\t\tif( k != l && !(i&(1<<k)) && !(i&(1<<l)) && e[k].color == e[l].color){\n\t\t\t\t\t\t\tbool f=true;\n\t\t\t\t\t\t\tfor(int j=0; j<e[k].ov.size(); j++){\n\t\t\t\t\t\t\t\tif( !(i & (1<<e[k].ov[j])) ){\n\t\t\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int j=0; f&&j<e[l].ov.size(); j++){\n\t\t\t\t\t\t\t\tif( !(i & (1<<e[l].ov[j])) ){\n\t\t\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( f ){\n\t\t\t\t\t\t\t\tdp[ i | (1<<k) | (1<<l) ] = true;\n\t\t\t\t\t\t\t\tque.push( i | (1<<k) | (1<<l) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=1; i<(1<<n); i<<=1){\n\t\t\tif( i & _ans )\n\t\t\t\tans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint n;\nint x[25],y[25],r[25],c[25];\nint cover[25];\nbool use[25];\nint cnt,comb,a,b;\nint m,ans;\n\ndouble dis(int i,int j){\n  return sqrt( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j]) * (y[i]-y[j]) );\n}\n\nvoid cov(int a){\n  cover[a] = -1;\n  for(int j=a-1;j>=0;j--){\n    if(dis(a,j)<r[a]+r[j] && !use[j]){\n      cover[a] = j;\n      break;\n    }\n  }\n} \n\n  \nvoid rec(void){\n  int cnt;\n  for(int i=1;i<=4;i++){\n    cnt = 0;\n    for(int j=0;j<n;j++){\n      if(!use[j] && (cover[j]<0 || use[cover[j]]) && c[j] == i)cnt++;\n    }\n    if(cnt==6){\n      for(int j=0;j<n;j++){\n\tif(c[j] == i)use[j] = true;\n      }\n      for(int j=0;j<n;j++)cov(j);\n\n      ans += 6;\n      m = max(m,ans);\n      rec();\n      ans -= 6;\n\n      for(int j=0;j<n;j++){\n\tif(c[j] == i)use[j] = false;\n      }\n      for(int j=0;j<n;j++)cov(j);\n    }else{\n      for(int j=0;j<n;j++){\n\tif(!use[j] && cover[j]<0 && c[j] == i){\n\t  for(int k=j+1;k<n;k++){\n\t    if(!use[k] && cover[k]<0 && c[k] == i){\n\t      use[j] = true;\n\t      use[k] = true;\n\t      for(int l=0;l<n;l++)cov(l);\n\t      \n\t      ans += 2;\n\t      m = max(m,ans);\n\t      rec();\n\t      ans -= 2;\n\t      \n\t      use[j] = false;\n\t      use[k] = false;\n\t      for(int l=0;l<n;l++)cov(l);\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n}\n\n\n\nint main(){\n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    for(int i=0;i<n;i++)cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n    for(int i=0;i<n;i++)cov(i);\n    \n    for(int i=0;i<n;i++)use[i] = false;\n\n    m = 0;\n    ans = 0;\n    rec();\n\n    cout << m << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nbool inter(int x1, int y1, int r1, int x2, int y2, int r2){\n  int dx = x1-x2, dy = y1-y2;\n  return dx*dx+dy*dy < (r1+r2)*(r1+r2);\n}\n\nint N;\nint dfs(VVI& prev, VI& cols, vector<bool>& used){\n  int res = 0;\n  for(int c=1;c<=4;++c){\n\tVI cand;\n\tREP(i,N)\n\t  if(cols[i] == c && !used[i]){\n\t\tint j=0;\n\t\tfor(;j<SZ(prev[i]);++j) if(!used[prev[i][j]]) break;\n\t\tif(j == SZ(prev[i]))\n\t\t  cand.PB(i);\n\t  }\n\n\tif(SZ(cand) < 2) continue;\n\tREP(i,SZ(cand)) FOR(j,i+1,SZ(cand)){\n\t  used[cand[i]] = used[cand[j]] = true;\n\t  res = max(res, 2+dfs(prev, cols, used));\n\t  used[cand[i]] = used[cand[j]] = false;\n\t}\n  }\n\n\treturn res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>N, N){\n\tVI xs(N), ys(N), rs(N), cols(N);\n\tREP(i,N) cin >> xs[i] >> ys[i] >> rs[i] >> cols[i];\n\n\tVVI prev(N);\n\tREP(i,N) FOR(j,i+1,N){\n\t  if(inter(xs[i], ys[i], rs[i], xs[j], ys[j], rs[j]))\n\t\tprev[j].PB(i);\n\t}\n\tvector<bool> used(N, false);\n\tcout << dfs(prev, cols, used) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//????????????2???????????§??????????????????????????????????????????????¬??????¨NG. ???????????¨??¢?´¢????????????\n//??????????????????????????????????????????????????£?????????????????????????????????O(2^n)????????????????????°??§?????????\n//?????????????????????????????????????????£?????????)???????????°????????¶?????????????????????????????§???????????????????§???????????¢??????????????????§?????¨?????????????????????????????????????????§????????????\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint n;\nint x[24], y[24], r[24], c[24];\n\n//rem???i??????????????????i????????£???????????°1, ??????????????????????????°0\n//????????????????????????????????????????????°????????§???\nint dfs(int rem) {\n\tbool isOut[24];\t//isOut[i] = ???i??????????????????????????°true\n\tint i, j;\n\t\n\tif (rem == 0) return 0;\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif ((rem >> j) % 2 == 0) continue;\t//??¢????????????????????????\n\t\t\tint dd = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n\t\t\tint rr = (r[i] + r[j]) * (r[i] + r[j]);\n\t\t\tif (dd < rr) break;\n\t\t}\n\t\tisOut[i] = (j == i);\n\t}\n\t\n\tint ret = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tif ((rem >> i) % 2 == 0 || !isOut[i]) continue;\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tif ((rem >> j) % 2 == 0 || !isOut[j]) continue;\n\t\t\tif (c[i] != c[j]) continue;\n\t\t\t//???i, j????????????????????????\n\t\t\tret = max(ret, dfs(rem - (1 << i) - (1 << j)) + 2);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\twhile (cin >> n) {\n\t\tif (!n) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tcout << dfs((1 << n) - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint main(){\n  int n;\n  cin >> n;\n  while(n!=0){\n    int sum=0;\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    int f=0;\n    int on[30]={};\n    //int cc[5]={};\n    vector<int> cc[5];\n    while(f==0){\n      f=1;\n      for(i=0;i<30;i++) on[i]=0;\n      for(i=0;i<v.size();i++){\n\tfor(j=i+1;j<v.size();j++){\n\t  if(ch(v[i],v[j])==1) on[j]=1;\n\t}\n      }\n      \n      for(i=0;i<5;i++) cc[i].clear();\n      for(i=0;i<v.size();i++){\n\tif(on[i]==0) cc[v[i].c].push_back(i);\n      }\n      \n      for(i=1;i<5;i++){\n\tif(cc[i].size()>0&&cc[i].size()%2==0){\n\t  for(j=cc[i].size()-1;j>=0;j--){\n\t    v.erase(v.begin()+cc[i][j]);\n\t    f=0;\n\t  }\n\t}\n      }\n    }\n    cout << n-v.size() << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint n;\nint x[100],y[100],r[100],c[100];\nbool vis[1<<24];\n\nvoid solve(){\n  rep(i,n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n  CLR(vis);\n  int ans=0;\n  queue<int> q;\n  q.push((1<<n)-1);\n  int up[24]={};\n  rep(i,n)rep(j,i){\n    int dx=x[i]-x[j];\n    int dy=y[i]-y[j];\n    if(dx*dx+dy*dy<(r[i]+r[j])*(r[i]+r[j])) up[i] |= 1<<j;\n  }\n  \n  while(!q.empty()){\n    int cv=q.front();\n    q.pop();\n    if(vis[cv]) continue;\n    vis[cv] = true;\n    ans = max(ans ,n-__builtin_popcount(cv));\n\n    rep(i,n){\n      if((~cv>>i)&1) continue;\n      if(up[i]&cv) continue;\n      rep(j,i){\n\tif(c[i]!=c[j]) continue;\n\tif(up[j]&cv) continue;\t\n\tif((~cv>>j)&1) continue;\n\tq.push(cv&~(1<<i)&~(1<<j));\n      }\n    }\n      \n  }\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> n && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <deque>\n#include <vector>\n#include <numeric>\n#include <iterator>\n#include <array>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\n\n\n#define FF first\n#define SS second\n#define ALL(c) begin((c)), end((c))\n#define REP(i,n) for(ll i=0;i<(ll)n;++i)\ninline int getInt() { int s; scanf(\"%d\", &s); return s; }\n/*\n#define SIZE 500000\nvector<ll> table(SIZE);\n\n\n\nvoid sieve_of_eratosthenes() {\n\tiota(ALL(table), 0);\n\tfor (int i = 2; i < SIZE; ++i)\n\t\ttable[i] = i;\n\tfor (int i = 2; i*i < SIZE; ++i)\n\tif (table[i])\n\tfor (int j = i*i; j < SIZE; j += i)\n\t\ttable[j] = 0;\n}*/\n\n/*\ntypedef array<array<int, 10>, 10> Table;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nvoid dd(Table &state, int from, int to) {\n\tif (from==to) return;\n\tvector<pair<int,int>> stack;\n\tstack.emplace_back(1,1);\n\twhile (!stack.empty()) {\n\t\tauto p = stack.back();\n\t\tstack.pop_back();\n\t\tint x = p.FF;\n\t\tint y = p.SS;\n\n\t\tREP(i, 4) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (state[ny][nx] == from) {\n\t\t\t\tstack.emplace_back(nx,ny);\n\t\t\t\tstate[ny][nx] = to;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint g_c;\n\nint cc(Table & state) {\n\tvector<pair<int, int>> stack;\n\tstack.emplace_back(1, 1);\n\tint cnt = 0;\n\twhile (!stack.empty()) {\n\t\tauto p = stack.back();\n\t\tstack.pop_back();\n\t\tint x = p.FF;\n\t\tint y = p.SS;\n\n\t\tREP(i, 4) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (state[ny][nx] == g_c) {\n\t\t\t\tstack.emplace_back(nx, ny);\n\t\t\t\tcnt++;\n\t\t\t\tstate[ny][nx] = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint walk(int depth, Table state) {\n\tif (depth == 5) {\n\t\tTable ntable = state;\n\t\tntable[1][1] = g_c;\n\t\tdd(ntable, state[1][1], g_c);\n\t\treturn cc(ntable);\n\t}\n\tint cnt = 1;\n\tREP(i, 6) {\n\t\tTable ntable = state;\n\t\tntable[1][1] = i;\n\t\tdd(ntable, state[1][1], i); //色変\n\t\tcnt = max(walk(depth+1, ntable),cnt);\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tfreopen(\"Text.txt\", \"r\", stdin);\n\n\n\twhile (true) {\n\t\tll h,w;\n\t\tcin >> h >> w >> g_c;\n\t\tif (h == 0) break;\n\t\tg_c--;\n\t\tTable table;\n\t\tREP(y, 10) REP(x, 10) table[y][x] = -1;\n\t\tREP(y, h) REP(x, w) {\n\t\t\tcin >> table[y + 1][x + 1];\n\t\t\ttable[y + 1][x + 1]--;\n\t\t}\n\n\t\tcout << walk(1, table) << endl;\n\t}\n}\n*/\nstruct circle{\n\tint id,x,y,r;\n};\n\nvector<circle> g_table[4];\n\n\nint main() {\n\n\twhile (true) {\n\t\tll n;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\tarray<bool,4> active;\n\t\tactive.fill(true);\n\n\t\tREP(c, 4) g_table[c].clear();\n\t\tREP(i, n){\n\t\t\tint x,y,r,c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tg_table[c - 1].push_back(circle{i,x,y,r});\n\t\t}\n\n\t\tvector<int> removableColor;\n\t\tdo{\n\t\t\twhile (!removableColor.empty()) {\n\t\t\t\tactive[removableColor.back()] = false;\n\t\t\t\tremovableColor.pop_back();\n\t\t\t}\n\n\t\t\tarray<vector<circle>,4> tops;\n\t\t\tREP(c1, 4) for (auto it1 = g_table[c1].begin(); it1 != g_table[c1].end(); ++it1) {\n\t\t\t\tif(!active[c1]) continue;\n\t\t\t\tbool top = true;\n\t\t\t\tREP(c2, 4) for (auto it2 = g_table[c2].begin(); it2 != g_table[c2].end(); ++it2) {\n\t\t\t\t\tif (!active[c2]) continue;\n\t\t\t\t\tif (c1==c2 && it1 == it2) continue;\n\t\t\t\t\tint xx = (it1->x - it2->x);\n\t\t\t\t\tint yy = (it1->y - it2->y);\n\t\t\t\t\tint rr = (it1->r + it2->r);\n\t\t\t\t\tif (xx*xx + yy*yy < rr*rr && it1->id > it2->id) {\n\t\t\t\t\t\ttop = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (top) tops[c1].push_back(*it1);\n\t\t\t}\n\n\t\t\tREP(c,4) if ((!g_table[c].empty()) && tops[c].size() == g_table[c].size()) removableColor.push_back(c);\n\t\t} while (!removableColor.empty());\n\n\t\tint count = 0;\n\t\tREP(c, 4) if (!active[c]) count += g_table[c].size();\n\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvvi color(4);\n\t\tvi x(n), y(n), r(n), c(n);\n\t\tREP(i, n) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t\tc[i]--;\n\t\t\tcolor[c[i]].push_back(i);\n\t\t}\n\t\tvi b(1 << n, 0);\n\t\tb[(1 << n) - 1] = 1;\n\t\tvvi g(n);\n\t\tvi d(n, 0);\n\t\tREP(i, n)FOR(j, i + 1, n) {\n\t\t\tif ((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) < (r[i] + r[j])*(r[i] + r[j])) {\n\t\t\t\tg[i].push_back(j);\n\t\t\t\td[j]++;\n\t\t\t}\n\t\t}\n\t\tqueue<int> q;\n\t\tq.push((1 << n) - 1);\n\t\twhile (!q.empty()) {\n\t\t\tint bit = q.front(); q.pop();\n\n\t\t\tvi a = d;\n\t\t\tREP(i, n) {\n\t\t\t\tif ((bit&(1 << i)) == 0) {\n\t\t\t\t\tREP(j, g[i].size()) {\n\t\t\t\t\t\ta[g[i][j]]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(i, n)FOR(j, i + 1, n) {\n\t\t\t\tif (c[i] == c[j] && (bit&(1 << i)) && (bit&(1 << j)) && a[i] == 0 && a[j] == 0) {\n\t\t\t\t\tif (b[bit ^ i ^ j] == 0)q.push(bit ^ i ^ j);\n\t\t\t\t\tb[bit ^ i ^ j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tREP(i, 1 << n) {\n\t\t\tif (b[i] == 0)continue;\n\t\t\tint cnt = n;\n\t\t\tREP(j, n)if (i&(1 << j))cnt--;\n\t\t\tchmax(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double R;//double long double ??????????????? cmath?????¢??°??????????????????????????????????????????????????§????????????\ntypedef complex<R> Point;\ntypedef pair<Point , Point> Line;\ntypedef pair<Point ,R > Circle;\ntypedef vector<Point> Poly;\n\n#define EPS (1e-10)//??????\n#define EQ(a,b) (abs((a)-(b)) < EPS)//??????????????°???????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )//????????????????????????????????????\n#define mp make_pair\n#define ft first\n#define sd second\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nR dot(Point a,Point b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nR cross(Point a,Point b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\nbool is_orthogonal(Line a,Line b){//2??´????????´?????????\n    return EQ(dot(a.ft - a.sd,b.ft - b.sd),0.0);\n}\nbool is_parallel(Line a,Line b){//2??´??????????????????\n    return EQ(cross(a.ft - a.sd,b.ft - b.sd),0.0);\n}\n\n////////////////////????????????\n\nint ccw(Point a,Point b,Point c){//ok\n    b -= a; c -= a;\n    if(cross(b,c) > EPS) return 1;//a???b??§???????¨???¨???????????????b???c\n    if(cross(b,c) < -EPS) return -1;//a???b??§????¨???¨???????????????b???c\n    if(dot(b,c) < -EPS) return 2;//c--a--b on same line\n    if(norm(c) - norm(b) > EPS) return -2;//a--b--c(abs??????????????????????????????????????????????????????????)\n    return 0;//a--c--b?????????b==c\n}\n\nbool is_intersection_ll(Line l,Line m){//???????????´??????????????????\n    return abs(cross(l.sd - l.ft,m.sd - m.ft)) > EPS || //????????§??????\n        abs(cross(l.sd - l.ft,m.ft - l.ft)) < EPS; //?????????????????????\n}\n\nbool is_intersection_ls(Line l,Line s){//??´???l??¨??????s???????????????\n    return cross(l.sd - l.ft, s.ft-l.ft)*       // s[0] is left of l\n        cross(l.sd - l.ft, s.sd - l.ft) < EPS; // s[1] is right of l\n}\n\nbool is_intersection_lp(Line l,Point p){//??´???l??¨???p???????????????\n    return abs(cross(l.sd - p,l.ft - p));\n}\n\nbool is_intersection_ss(Line a,Line b){\n    return ccw(a.ft,a.sd,b.ft)*ccw(a.ft,a.sd,b.sd) <= 0 && ccw(b.ft,b.sd,a.ft)*ccw(b.ft,b.sd,a.sd) <= 0;\n}\n\nbool is_intersection_sp(Line s,Point p){\n    return abs(s.ft - p) + abs(s.sd - p) - abs(s.ft - s.sd) < EPS;\n}\n\n/////////////?????¢\n\nR dis_lp(Line l,Point p){//??´???l??¨???p????????¢\n    return abs(cross(l.sd - l.ft,p - l.ft)) / abs(l.sd - l.ft);\n}\n\nR dis_ll(Line l,Line m){//???????????´???????????¢\n    return is_intersection_ll(l,m) ? 0.0 : dis_lp(l,m.ft);\n}\n\nR dis_ls(Line l,Line s){//??´???l??¨??????s????????¢\n    if(is_intersection_ls(l,s)) return 0.0;\n    return min(dis_lp(l,s.ft),dis_lp(l,s.sd));\n}\n\nR dis_sp(Line s,Point p){//??????s??¨???p????????¢\n    if(dot(s.sd - s.ft,p - s.ft) < EPS) return abs(p - s.ft);\n    if(dot(s.ft - s.sd,p - s.sd) < EPS) return abs(p - s.sd);\n    return dis_lp(s,p);\n}\n\nR dis_ss(Line s,Line t){//???????????????????????¢\n    if(is_intersection_ss(s,t)) return 0.0;\n    return min(min(dis_sp(s,t.ft),dis_sp(s,t.sd)),\n            min(dis_sp(t,s.ft),dis_sp(t,s.sd)));\n}\n\n//////////////?°???±??¨????°?\n\nPoint projection(Line l,Point p){//?°???±????±???????\n    R t = dot(p - l.ft,l.ft - l.sd) / norm(l.ft - l.sd);\n    return l.ft + t * (l.ft - l.sd);\n}\n\nPoint reflection(Line l,Point p){//????°?????±???????\n    return p + 2.0 * (projection(l,p) - p);\n}\n\n//////////////??????(????????????????¨???????????????¨??????????????????????????????????????£??????)\n\nPoint intersection_ll(Line l,Line m){//????????????????????????????????????????????????\n    R A = cross(l.sd - l.ft,m.sd - m.ft);\n    R B = cross(l.sd - l.ft,l.sd - m.ft);\n    if(abs(A) < EPS && abs(B) < EPS) return m.ft;//?????????\n    //if(abs(A) < EPS)assert(false);//????????§????????????\n    return m.ft + B / A * (m.sd - m.ft);\n}\n\nLine intersection_of_two_circles(Circle c1,Circle c2){//ok ????????????????????????Line?????\\????????????(r1 + r2 > sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2))???????????????????????????\n    R a =  abs(c2.ft - c1.ft);\n    R b = c1.sd;\n    R c = c2.sd;\n\n    R rc = (a  * a + b * b - c * c) / (2.0 * a);\n    R rs = sqrt(b * b - rc * rc);//C++ ??§???????????????????????????????????§???????????????sqrt ????????? float ?????????????????? long double ????????????????????????????????????????????¨?????§???????????? C ????????°????????§??????sqrt ????????? double ??????????????£??????????????????\n    Point diff = (c2.ft - c1.ft) / a;\n\n    Line p ;\n    p.ft = c1.ft + diff * rc + diff * Point(0,1) * rs;\n    p.sd = c1.ft + diff * rc + diff * Point(0,-1) * rs;\n\n    return p;\n}\n\n\nLine conver_line(Line a,Point maxi,Point mini){//??????????????´??????????????? maxi???????????????????????? mini?????????\n\n    if(abs(dot(a.sd - a.ft,Point(1.0,0.0))) < EPS){//??????x???????????´??????\n        ;\n    }\n}\n\n/////////////////////////polygon\n\n#define currP(P,i) P[i]//????????????\n#define nextP(P,i) P[(i + 1)%P.size()]//?¬??????????\n\nint is_contains_p_in_Poly(Poly po,Point p){//??????????§???¢????????¨(1)????¢????(-1)????????¨(0)??????????????????????????????\n    bool in = false;\n    REP(i,po.size()){\n        Point a = currP(po,i) - p,b = nextP(po,i) - p;\n        if(a.imag() > b.imag())swap(a,b);\n        if(a.imag() < EPS && -EPS < b.imag())\n            if(cross(a,b) < -EPS) in = !in;\n        if(abs(cross(a,b)) == 0.0 && dot(a,b) < EPS)return  -1;\n    }\n    return in;\n}\n\nR area2(Poly po){//????§???¢?????¢????????????????±???????\n    R A = 0.0;\n    REP(i,po.size())\n        A += cross(currP(po,i),nextP(po, i));\n    return A;\n}\n\n///////////////////////////???\n\nPoly convex_hull(Poly ps){\n    int n = ps.size(),k = 0;\n    Poly ch(2*n);\n    for(int i = 0;i < n;ch[k++] = ps[i++])// lower-hull\n        while(k >= 2 && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0) --k;\n    for(int i = n - 2,t = k + 1;i >= 0;ch[k++] = ps[i--])//upper-hull\n        while(k >= t && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\n#define prevP(P, i) P[(i+P.size()-1) % P.size()]\nbool isconvex(Poly P){\n    for(int i = 0;i < P.size();++i)\n        if(ccw(prevP(P,i),currP(P,i),nextP(P,i)) > 0) return false;\n    return true;\n}\n\nbool kosa(Circle c1, Circle c2) {\n  if(abs(abs(c1.ft-c2.ft) - (c1.sd+c2.sd)) < EPS)\n    return false;\n  return abs(c1.ft-c2.ft)<(c1.sd+c2.sd);\n}\n\n#define MAX_N 25\n\nint n;\nCircle cs[MAX_N];\nint cc[MAX_N];\n\nbool input() {\n  cin>>n;\n  int x, y, r;\n  REP(i, n) {\n    cin>>x>>y>>r>>cc[i];\n    cs[i] = mp(Point(x, y), r);\n  }\n  return n!=0;\n}\n\nchar dp[1<<MAX_N];\n\nbool totta[MAX_N],toreru[MAX_N];\n\nint saiki(int S) {\n  if(dp[S] > -1)\n    return (int)dp[S];\n  REP(i,n){totta[i] = S&(1<<i);toreru[i] = true;}\n  REP(i,n){\n    if(totta[i]){\n      toreru[i] = false;\n      continue;\n    }\n    REP(j,i){\n      if(!totta[j] && kosa(cs[i],cs[j])){\n        toreru[i] = false;\n        break;\n      }\n    }\n  }\n  bool f=false;\n  REP(i, n)f=(f||toreru[i]);\n  if(!f)return 0;\n  int maxi = 0;\n  REP(i,n){\n    if(toreru[i]){\n      FOR(j,i+1,n){\n        if(toreru[j] && cc[i] == cc[j])\n          maxi = max( maxi, saiki(S|(1<<i)|(1<<j))+2 );\n      }\n    }\n  }\n  return dp[S] = maxi;\n}\n\nvoid solve() {\n  REP(i,1<<MAX_N)\n    dp[i] = -1;\n  cout<<saiki(0)<<endl;\n}\n\nint main() {\n  \n  while(input()) {\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//線分を表す構造体\nstruct Segment{ Point p1, p2; };\n//直線を表す構造体\ntypedef Segment Line;\n//多角形を表す構造体\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// 許容する誤差\n#define EPS (1e-10)\n\n// ベクトルaの絶対値を求める\n//double length = abs(a);\n\n// 2点a,b間の距離を求める\n//double distance = abs(a-b);\n\n/*\n// ベクトルaの単位ベクトルを求める\nPoint b = a / abs(a);\n\n// ベクトルaの法線ベクトルn1,n2を求める\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 点cが直線a,b上にあるかないか\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// 点a,bを通る直線と点cとの距離\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// 線分s1と線分s2の距離\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// 線分sに対する点pの射影\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//線分sを対象軸とした点pの線対称の点\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//点pをangle分だけ時計回りに回転\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//円cと線分lの交点\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//点の内包\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//ベクトルの位置検出\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//凸包\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISEだと内角は180以下（一直線上に並んでいても、頂点として数える）\n        //!= CLOCKWISEだと内角は180未満（一直線上の頂点は数えない）\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //ここも == と != を変更する\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //最も下にある点の中で最も右にある点から反時計回りに並び替え\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//キャリパー法を用いて凸多角形の直径を求める\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//凸多角形の切り取りに使う関数。これがなんなのかはまだ知らない。\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//三角形の面積\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//多角形の面積\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//凸多角形かどうかの判定\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//凹多角形を線分lで切断した際の多角形の数\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\n//i番目を0にする\nint clearBit(int num, int i){\n\tint mask = ~(1 << i);\n\treturn num & mask;\n}\n\n//i番目をvで置き換える\nint updateBit(int num, int i, int v){\n\tint mask = ~(1 << i);\n\treturn (num & mask) | (v << i);\n}\n\nint n, ans;\n\nbool isOver(Circle a, Circle b){\n\tpair<Point,Point> tmp = getCrossPoints(a,b);\n\tdouble na = tmp.first.imag();\n    return isnan(na);\n}\n\nvoid dfs(vector<vector<int>>& g, int cur, vector<int>& on){\n\tfor(auto to : g[cur]){\n\t\ton[to] = on[to] bitor (1 << cur) bitor on[cur];\n\t\tdfs(g, to, on);\n\t}\n}\n\nvector<bool> memo;\nvoid dfs(int s, vector<int>& on, vector<int> c){\n\tif(memo[s]) return;\n\n\tvector<vector<int>> canTake(4);\n\trep(i,n){\n\t\tif(getBit(s,i)) continue;\n\t\tif((on[i] bitand s) == on[i]){\n\t\t\tcanTake[c[i]].emplace_back(i);\n\t\t}\n\t}\n\n\tvector<int> take(4,0);\n\trep(i,4){\n\t\tfor(auto j : canTake[i]){\n\t\t\ttake[i] = setBit(take[i], j);\n\t\t}\n\t}\n\n\trep(i,4){\n\t\tif(canTake[i].size() >= 2){\n\t\t\tif(canTake[i].size() % 2 == 1){\n\t\t\t\trep(j,canTake[i].size()){\n\t\t\t\t\tdfs(s bitor clearBit(take[i], j), on, c);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdfs(s bitor take[i], on, c);\n\t\t\t}\n\t\t}\n\t}\n\n\tbitset<30> bit(s);\n\tans = max<int>(ans, bit.count());\n\tmemo[s] = true;\n}\n\nint main(){\n    while(scanf(\"%d\",&n),n){\n        vector<Circle> c(n);\n        vector<int> color(n);\n        rep(i,n){\n            double x,y,r;\n            scanf(\"%lf%lf%lf%d\",&x,&y,&r,&color[i]);\n\t\t\tcolor[i]--;\n            c[i] = {Point(x,y),r};\n        }\n\n\t\tvector<vector<int>> g(n);\n\t\tvector<bool> top(n,1);\n\t\trep(i,n){\n\t\t\trange(j,i + 1,n){\n\t\t\t\tif(isOver(c[i], c[j])){\n\t\t\t\t\tg[i].emplace_back(j);\n\t\t\t\t\ttop[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> on(n,0);\n\t\trep(i,n){\n\t\t\tif(not top[i]) continue;\n\t\t\tdfs(g, i, on);\n\t\t}\n\t\t//rep(i,n) show(on[i])\n\n\t\tans = 0;\n\t\tmemo = vector<bool>(1 << n, 0);\n\t\tdfs(0, on, color);\n\t\tcout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nint n;\nint x[24],y[24],r[24],c[24];\nint dist(int a,int b){return (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);}\n \nint rec(int S){\n  int res=0;\n  bool f[n];\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    f[i]=true;\n    for(int j=i-1;j>=0;j--){\n      if((S>>j)&1)continue;\n      if(dist(i,j)>=(r[i]+r[j])*(r[i]+r[j]))continue;\n      f[i]=false;\n    }\n  }\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    if(!f[i])continue;\n    for(int j=i+1;j<n;j++){\n      if((S>>j)&1)continue;\n      if(!f[j])continue;\n      if(c[i]!=c[j])continue;\n      res=max(res,2+rec(S+(1<<i)+(1<<j)));\n    }\n  }\n  return res;\n}\n \nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++)\n      scanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n    cout<<rec(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n//template<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nint type[4];\n\nll dist(pii a,pii b){\n  ll dx=a.X-b.X,dy=a.Y-b.Y;\n  return dx*dx+dy*dy;\n}\n\nint ans,next_[24];\n\nint nxt(int a,int b){\n  a^=b;\n  rep(i,24)if(b>>i)\n    a|=next_[i];\n  return a;\n}\n\nchar memo[1<<24];\n\nint dfs(int st){\n  if(memo[st])return memo[st];\n  int p,stt,re=0;\n  rep(i,4){\n    p=__builtin_popcount(stt=(st&type[i]));\n    if(p>1){\n      if(p%2){\n\trep(j,24)if(stt>>j){\n\t  re=max(dfs(nxt(st,stt^(1<<j))),re);\n\t}\n\tre+=p-1;\n      }else{\n\tre=p+dfs(nxt(st,stt));\n      }\n      break;\n    }\n  }\n  //  cout<<st<<\":\"<<re<<endl;\n  return memo[st]=re;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int i,j,k;\n  int n;\n  while(cin>>n){\n    if(!n)break;\n    memset(memo,0,sizeof(memo));\n    vector<pii> v(n);\n    vector<int> r(n),c(n),ue(n,1);\n    vector<vector<int>> g(n);\n    rep(i,4)type[i]=0;\n    rep(i,n){\n      cin>>v[i].X>>v[i].Y>>r[i]>>c[i];\n      --c[i];\n      type[c[i]]|=(1<<i);\n    }\n    rep(i,n)rep(j,i){\n      if(dist(v[i],v[j])<1ll*(r[i]+r[j])*(r[i]+r[j])){\n\tg[j].pb(i);\n\tue[i]=0;\n      }\n    }\n    int st=0;\n    rep(i,n){\n      st|=(ue[i]<<i);\n      for(int a:g[i])\n\tnext_[a]|=1<<a;\n    }\n    //    cout<<st<<endl;\n    cout<<dfs(st)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int N = 24;\n\nint n;\nint ol[N];\nint x[N], y[N], r[N], c[N];\nbool vis[1<<N];\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n    for(int i=0;i<n;i++){\n      ol[i] = 0;\n      for(int j=0;j<i;j++){\n        if((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) < (r[i] + r[j]) * (r[i] + r[j])){\n          ol[i] |= (1<<j);\n        }\n      }\n    }\n    fill(vis, vis+(1<<n), false);\n    queue<int> q;\n    int u = (1<<n) - 1;\n    q.push(u);\n    vis[u] = true;\n    while(!q.empty()){\n      u = q.front();q.pop();\n      //cout << u << endl;\n      for(int i=0;i<n;i++){\n        if(u>>i & 1 == 0) continue;\n        for(int j=i+1;j<n;j++){\n          if(u>>j & 1 == 0) continue;\n          if(c[i] != c[j]) continue;\n          int f1 = ((ol[i]&u)>>i)<<i;\n          int f2 = ((ol[j]&u)>>j)<<j;\n          //cout << i << ' ' << ol[i] << ' ' << f1 << endl;\n          //cout << j << ' ' << ol[j] << ' ' << f2 << endl;\n          if(f1 < (ol[i]&u) || f2 < (ol[j]&u)) continue;\n          int v = u;\n          v &= ~(1<<i);\n          v &= ~(1<<j);\n          if(vis[v]) continue;\n          vis[v] = true;\n          //cout << \"-> \" << v << endl;\n          q.push(v);\n        }\n      }\n    }\n    int ans = 0;\n    for(int i=0;i<(1<<n);i++){\n      if(vis[i]){\n        int cnt = 0;\n        for(int j=0;j<n;j++){\n          if(i>>j & 1) cnt++;\n        }\n        cnt = n - cnt;\n        ans = max(ans, cnt);\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int N = 25;\n\nint n;\nint ol[N];\nint x[N], y[N], r[N], c[N];\nbool vis[1<<N];\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n    for(int i=0;i<n;i++){\n      ol[i] = 0;\n      for(int j=0;j<i;j++){\n        if((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) < (r[i] + r[j]) * (r[i] + r[j])){\n          ol[i] |= (1<<j);\n        }\n      }\n    }\n    fill(vis, vis+(1<<n), false);\n    queue<int> q;\n    int u = (1<<n) - 1;\n    q.push(u);\n    vis[u] = true;\n    while(!q.empty()){\n      u = q.front();q.pop();\n      //cout << u << endl;\n      for(int i=0;i<n;i++){\n        if(u>>i & 1 == 0) continue;\n        for(int j=i+1;j<n;j++){\n          if(u>>j & 1 == 0) continue;\n          if(c[i] != c[j]) continue;\n          int f1 = ((ol[i]&u)>>i)<<i;\n          int f2 = ((ol[j]&u)>>j)<<j;\n          //cout << i << ' ' << ol[i] << ' ' << f1 << endl;\n          //cout << j << ' ' << ol[j] << ' ' << f2 << endl;\n          if(f1 < (ol[i]&u) || f2 < (ol[j]&u)) continue;\n          int v = u;\n          v &= ~(1<<i);\n          v &= ~(1<<j);\n          if(vis[v]) continue;\n          vis[v] = true;\n          //cout << \"-> \" << v << endl;\n          q.push(v);\n        }\n      }\n    }\n    int ans = 0;\n    for(int i=0;i<(1<<n);i++){\n      if(vis[i]){\n        int cnt = 0;\n        for(int j=0;j<n;j++){\n          if(i>>j & 1) cnt++;\n        }\n        cnt = n - cnt;\n        ans = max(ans, cnt);\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\n\nstruct disc {\n    int x;\n    int y;\n    int r;\n    int c;\n    vector<int> overlap;\n    disc(int x, int y, int r, int c) : x(x), y(y), r(r), c(c){}\n};\n\nbool is_overlap(disc& a, disc& b)\n{\n    int d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    return d < (a.r + b.r) * (a.r + b.r);\n}\n\nbool remove(vector<disc>& v)\n{\n    vector<int> top;\n\n    for (int i = 0; i < v.size(); ++i){\n        if (v[i].overlap.empty()){\n            top.push_back(i);\n        }\n    }\n    for (int i = 0; i < top.size(); ++i){\n        for (int j = i + 1; j < top.size(); ++j){\n            if (v[top[i]].c == v[top[j]].c){\n                for (auto& k : v){\n                    auto& ol = k.overlap;\n                    if (ol.size() && ol[0] == top[i]) ol.erase(ol.begin());\n                    if (ol.size() && ol[0] == top[j]) ol.erase(ol.begin());\n                }\n                v[top[i]].overlap.push_back(top[i]);\n                v[top[j]].overlap.push_back(top[j]);\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n){\n        vector<disc> v;\n\n        for (int i = 0; i < n; ++i){\n            int x, y, r, c;\n            cin >> x >> y >> r >> c;\n\n            disc d(x, y, r, c);\n            for (int j = 0; j < v.size(); ++j){\n                if (is_overlap(d, v[j])){\n                    d.overlap.push_back(j);\n                }\n            }\n            /*\n            if (d.overlap.empty()) cout << \" -\";\n            else for (int j = 0; j < d.overlap.size(); ++j) cout << \" \" << d.overlap[j];\n            cout << endl;\n            */\n            v.push_back(d);\n        }\n\n        int cnt = 0;\n        while (remove(v)){\n            cnt += 2;\n        }\n        cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[1<<25];\nint main(){\n  int n;;\n  while(cin>>n,n){\n    int col[n],ans=0;\n    double r[n],x[n],y[n];\n    for(int i=0;i<n;i++)\n      cin>>x[i]>>y[i]>>r[i]>>col[i];\n    memset(dp,0,sizeof(dp));\n    dp[((1<<n)-1)]=1;\n  \n    for(int i=1<<n;i>=0;i--)if(dp[i])\n\tfor(int j=n-1;j>=0;j--)if((1<<j)&i)\n\t    for(int k=j-1;k>=0;k--)\n\t      if(((1<<k)&i)&&col[j]==col[k]){\n\t\tfor(int l=j-1;l>=0;l--)if((i&(1<<l))&&abs(sqrt((x[l]-x[j])*(x[l]-x[j])+(y[l]-y[j])*(y[l]-y[j])))<r[j]+r[l])goto L;\n\t        for(int l=k-1;l>=0;l--)if((i&(1<<l))&&abs(sqrt((x[l]-x[k])*(x[l]-x[k])+(y[l]-y[k])*(y[l]-y[k])))<r[k]+r[l])goto L;\n\t\tdp[i-(1<<j)-(1<<k)] =dp[i]+2;\n\t\tans=max(ans,dp[i-(1<<j)-(1<<k)]);\n\t      L:;\n\t      }\n    cout<<ans-1<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n#define HIT(a,b) ((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r))\n\nstruct DISK{\n\tint x,y,r,c,o;\n\tDISK():o(0){}\n};\nint n;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n, n){\n\t\tvector<DISK> D(n);\n\t\tREP(i, n) cin>>D[i].x>>D[i].y>>D[i].r>>D[i].c;\n\t\tREP(j, n)REP(i, j)if(HIT(D[i],D[j])) D[j].o |= 1<<i;\n\t\tint ans = 0;\n\t\tqueue<int> dp;\n\t\tdp.push(0);\n\t\twhile(!dp.empty()){\n\t\t\tconst int b = dp.front(); dp.pop();\n\t\t\tREP(j, n)REP(i, j)if(!((b >> i) & 1)){\n\t\t\t\tif((b >> i) & 1 || (b>>j) & 1 || D[i].c != D[j].c || ~b & D[i].o || ~b & D[j].o) continue;\n\t\t\t\tdp.push(b|1<<i|1<<j);\n\t\t\t}\n\t\t\tans = max(ans, __builtin_popcount(b));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstruct Disc {\n  int x, y, r, c;\n};\n\nconst int MAX_N = 24;\nint N;\nDisc D[MAX_N];\nint on[MAX_N];\nchar T[1<<MAX_N];\n\nint isIntersect(const Disc &a, const Disc &b) {\n  int dx = a.x - b.x;\n  int dy = a.y - b.y;\n  int sr = a.r + b.r;\n  if(dx*dx+dy*dy == sr*sr) return 1;\n  if(dx*dx+dy*dy < sr*sr) return 2;\n  return 0;\n}\n\nint make() {\n  for(int i = 0; i < N; ++i) {\n    on[i] = 0;\n    for(int j = i-1; j >= 0; --j) {\n      if(isIntersect(D[i], D[j]) == 2) on[i] |= 1<<j;\n    }\n  }\n}\n\nint solve() {\n  for(int S = (1<<N)-1; S >= 0; --S) {\n    T[S] = 0;\n    for(int i = 0; i < N; ++i) {\n      if(S & (1<<i)) continue;\n      if((S & on[i]) != on[i]) continue;\n      for(int j = i+1; j < N; ++j) {\n\tif(S & (1<<j)) continue;\n\tif((S & on[j]) != on[j]) continue;\n\n\tif(D[i].c != D[j].c) continue;\n\tT[S] = max(T[S], (char)(T[S | (1<<i) | (1<<j)]+2));\n      }\n    }\n  }\n  return T[0];\n}\n\nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i) {\n      cin >> D[i].x >> D[i].y >> D[i].r >> D[i].c;\n    }\n    make();\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nstruct Data\n{\n    int x;\n    int y;\n    int r;\n    int c;\n};\n\ntypedef struct Data D;\n\nint solve(vector<D> input)\n{\n    int ans = 0;\n    vector<vector<int> >  colornum(5);\n    int n = input.size();\n    // cout << \"ho\" << n << endl;\n    for(int i = 0; i < n; i++){\n        bool notcovered = true;\n        // cout << i << \" : \" << input[i].x << \" \" << input[i].y << \" \" << input[i].r << \" \" << input[i].c << endl;\n        for(int j = 0; j < i; j++){\n            // cout << i << \",\" << j << \":\" << pow(input[i].x - input[j].x, 2) + pow(input[i].y - input[j].y, 2) << \" \" << pow(input[i].r + input[j].r, 2) << endl;\n            if(pow(input[i].x - input[j].x, 2) + pow(input[i].y - input[j].y, 2) < pow(input[i].r + input[j].r, 2)){\n                notcovered = false;\n                break;\n            }\n        }\n        if(notcovered) colornum[input[i].c].push_back(i);\n    }\n    for(int i = 1; i < 5; i++){\n        if(colornum[i].size() > 1){\n            for(int j = 0; j < colornum[i].size(); j++){\n                for(int k = j + 1; k < colornum[i].size(); k++){\n                    vector<D> newinput;\n                    for(int l = 0; l < n; l++){\n                        if(l != colornum[i][j] && l != colornum[i][k]){\n                            newinput.push_back(input[l]);\n                        }\n                    }\n                    ans = max(ans, solve(newinput) + 2);   \n                }\n            }\n            \n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        vector<D> input;\n        for(int i = 0; i < n; i++){\n            D tmpd;\n            cin >> tmpd.x >> tmpd.y >> tmpd.r >> tmpd.c;\n            input.push_back(tmpd);\n        }\n        cout << solve(input) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <map>\n#include <stack>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n \nusing namespace std;\n \n#define ll long long\n#define pi pair<int,int>\n#define pll pair<ll,ll>\n#define pii pair<int,pi>\n#define X first\n#define Y second\n#define pb push_back\n#define ab(x) ((x)<0?(-(x)):(x))\n#define xx(x) ((x)*(x))\n#define mp make_pair\n#define vi vector<int>\n#define vll vector<ll>\n#define vs vector<string>\n#define vpi vector<pi>\n#define vpll vector<pll>\n#define ALL(x) (x).begin(),(x).end()\n#define Max (1<<30)\n#define LLMax (1ll<<60)\ntemplate<class T>string ToString(T t){stringstream s;s<<t;return s.str();}\ntemplate<class T>void ToOther(T&t,string a){stringstream s(a);s>>t;}\n \n\n\nchar ck[1<<24];\nchar TT=0;\nint n;\nint x[55];\nint y[55];\nint cor[55];\nint R[55];\n\nint up[55];\nbool can(int p,int q){\n\tif( xx(x[p]-x[q]) + xx(y[p]-y[q]) < xx(R[p]+R[q]))return 1;\n\treturn 0;\n}\nbool no_up(int x,int st){\n\treturn !(up[x]&st);\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tfor(int i=0;i<n;i++)cin>>x[i]>>y[i]>>R[i]>>cor[i];\n\n\t\tmemset(up,0,sizeof(up));\n\n\t\tfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++)if(can(i,j))up[j] |= (1<<i);\n\t\tqueue<int> q;\n\t\tqueue<int> num;\n\t\tq.push((1<<n)-1);\n\t\tnum.push(0);\n\t\tTT++;\n\t\tck[(1<<n)-1]=TT;\n\n\t\tint r=0;\n\t\twhile(q.size()){\n\t\t\tint k=q.front();\n\t\t\tint t=num.front();\n\t\t\tq.pop();num.pop();\n\n\t\t\tr=max(r,t);\n\n\t\t\tfor(int i=n-1;i>=0;i--)if(k>>i&1)for(int j=i-1;j>=0;j--)if(k>>j&1){\n\t\t\t\tif(cor[i]==cor[j] && no_up(i,k) && no_up(j,k)){\n\t\t\t\t\tint nxt= k^(1<<i)^(1<<j);\n\t\t\t\t\tint nxt2=t+2;\n\n\t\t\t\t\tif(ck[nxt]==TT)continue;\n\t\t\t\t\tck[nxt]=TT;\n\n\t\t\t\t\tq.push(nxt);\n\t\t\t\t\tnum.push(nxt2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<r<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint n;\nint x[30], y[30], r[30], c[30];\nint on[30];\ndouble dist(int x, int y){\n  return sqrt(x *x + y* y);\n}\nbool ison(int x, int y, int r, int x2, int y2, int r2){\n  double d = dist(x-x2, y- y2);\n  if(d < (double)r + r2) return true;\n  return false;\n}\nchar memo[1<<24];\nint dfs(int S){\n  if(memo[S] != -1) return memo[S];\n  int res = __builtin_popcount(S);\n  REP(i, n)REP(j, n){\n    if(i != j && !(S & (1 << i)) && !(S & (1 << j)) && c[i] == c[j]){\n      if(!(on[i] & (~S)) && !(on[j] & (~S))){\n        res = max(res, dfs(S | (1<<i) | (1<<j)));\n      }\n    }\n  }\n  return memo[S] = res;\n}\n\nint main(){\n  while(cin>>n && n){\n    REP(i, n) cin>>x[i]>>y[i]>>r[i]>>c[i];\n    memset(on, 0, sizeof(on));\n    REP(up, n)FOR(low, up + 1, n){\n      if(ison(x[up], y[up], r[up], x[low], y[low], r[low])) on[low] |= (1<<up);\n    }\n    memset(memo, -1, sizeof(memo));\n    cout<<dfs(0)<<endl;\n  }\n      \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <math.h>\n#include <set>\n \n#define REP(i,n)for (int i=0;i<(n);i++)\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nint x[30],y[30],r[30],c[30];\nint dp[1<<24];\n\nbool over(int i,int j){\n\treturn (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])<(r[i]+r[j])*(r[i]+r[j]);\n}\n\nint dfs(int bit){\n\t//cout<<bit<<endl;\n\tif(dp[bit]!=-1)return dp[bit];\n\tint res=0;\n\tREP(i,n){\n\t\tif(bit>>i&1)continue;\n\t\tbool f=false;\n\t\tREP(k,i)if(!(bit>>k&1)&&over(i,k))f=true;\n\t\tif(f)continue;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(bit>>j&1)continue;\n\t\t\tf=false;\n\t\t\tREP(k,j)if(!(bit>>k&1)&&over(k,j))f=true;\n\t\t\tif(f)continue;\n\t\t\t//cout<<i<<\" \"<<j<<endl;\n\t\t\tif(c[i]!=c[j])continue;\n\t\t\t//cout<<i<<\" \"<<j<<endl;\n\t\t\tint a=(bit|1<<i)|1<<j;\n\t\t\tres=max(res,dfs(a)+2);\n\t\t}\n\t}\n\treturn dp[bit]=res;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tREP(i,n)cin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tcout<<dfs(0)<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=(n);i<(int)(N);i++)\n#define ck(n,a,b) (a)<=(n)&&(n)<=(b)\n#define p(s) cout<<(s)<<endl\n#define F first\n#define S second\ntypedef long long ll;\nusing namespace std;\n\nstruct ST{\n\tint x, y, r, c;\n\tvector<int> up;\n};\nST enban[25];\nint n;\n\nint dfs(bool remove[]){\n\tvector<int> c[4];//enbango\n\n\tREP(i,0,n){\n\t\tbool ok=true;\n\t\tif(remove[i]) continue;\n\t\tfor(auto u: enban[i].up){\n\t\t\tif(!remove[u]){\n\t\t\t\tok=false;\n\t\t\t}\n\t\t}\n\t\tif(ok)c[enban[i].c].push_back(i);\n\t}\n\tbool flag=false;\n\tint ret=0;\n\tREP(j,0,4){\n\t\tif(c[j].size()%2) continue;\n\t\tfor(auto v:c[j]) {\n\t\t\tremove[v] = true;\n\t\t\tret=max(ret,dfs(remove));\n\t\t}\n\t}\n\n\tif(flag)\n\tREP(i,0,4){\n\t\tif(c[i].size()==3||c[i].size()==5){\n\t\t\tbool tmp_remove[25];\n\t\t\tREP(j,0,n) tmp_remove[j] = remove[j];\n\t\t\tREP(j,0,c[i].size()){\n\t\t\t\tREP(k,0,c[i].size()){\n\t\t\t\t\ttmp_remove[c[i][k]]=true;\n\t\t\t\t}\n\t\t\t\ttmp_remove[c[i][j]]=false;\n\t\t\t\tret=max(ret,dfs(tmp_remove));\n\t\t\t}\n\t\t}\n\t}\n\treturn max<int>(ret,count(remove,remove+n,true));\n}\n\nint main() {\n\twhile(cin>>n, n){\n\n\t\tbool remove[25];\n\t\tREP(i, 0, 25) remove[i]=false;\n\t\tREP(i, 0, n){\n\t\t\tcin>>enban[i].x>>enban[i].y>>enban[i].r>>enban[i].c;\n\t\t\tenban[i].c--;\n\t\t\tenban[i].up.clear();\n\t\t}\n\n\t\t// ????????????????????????\n\t\tREP(i, 1, n){\n\t\t\tREP(j, 0, i){\n\t\t\t\tint r=(enban[i].x-enban[j].x)*(enban[i].x-enban[j].x)\n\t\t\t\t\t\t\t\t\t\t\t\t+ (enban[i].y-enban[j].y)*(enban[i].y-enban[j].y);\n\t\t\t\tint R=(enban[i].r+enban[j].r) * (enban[i].r+enban[j].r);\n\n\t\t\t\tif(r<R) enban[i].up.push_back(j);\n\t\t\t}\n\t\t}\n\t\tp(dfs(remove));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint n;\nint x[24],y[24],r[24],c[24];\n\ninline bool intersect(int p, int q)\n{\n    double dist=sqrt((x[p]-x[q])*(x[p]-x[q])+(y[p]-y[q])*(y[p]-y[q]));\n    return dist<(r[p]+r[q]);\n}\n\nunordered_map<int,int> dp;\n// int dp[1<<24];\nint dfs(int state)\n{\n    if(dp.find(state) != dp.end()) return dp[state];\n    // if(dp[state]>=0) return dp[state];\n    if(__builtin_popcount(state)<2) return 0;\n\n    int ret=0;\n    rep(i,n)\n    {\n        if(state>>i&1)\n        {\n            bool av=true;\n            rep(j,i)\n            {\n                if(state>>j&1 && intersect(i,j))\n                {\n                    av=false;\n                    break;\n                }\n            }\n\n            if(!av) continue;\n\n            rep(j,n)\n            {\n                if(i==j) continue;\n                if(c[i]!=c[j]) continue;\n\n                if(state>>j&1)\n                {\n                    bool av2=true;\n                    rep(k,j)\n                    {\n                        if(state>>k&1 && intersect(j,k))\n                        {\n                            av2=false;\n                            break;\n                        }\n                    }\n\n                    if(!av2) continue;\n\n                    ret = max(ret,dfs(state-(1<<i)-(1<<j))+2);\n                }\n            }\n        }\n    }\n\n    return dp[state]=ret;\n}\n\nint main()\n{\n    while(cin >>n,n)\n    {\n        rep(i,n) scanf(\" %d %d %d %d\", &x[i], &y[i], &r[i], &c[i]);\n        dp.clear();\n        cout << dfs((1<<n)-1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<vector>\n#include<complex>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cctype>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n  \n#define REP(i,x,n) for(int i = x ; i < (int)(n) ; i++)\n#define rep(i,n) REP(i, 0, n)\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n  \ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef complex<double> Point;\n  \nstatic const int INF = (1<<29);\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n  \nstruct Circle{\n  Point p;\n  int r,color;\n  Circle(){}\n  Circle(Point p, int r, int c):p(p),r(r),color(c){}\n};\n  \nint n;\nint ans;\nbool del[24];\nCircle circle[24];\nbool visit[(1 << 24)];\n \nbool check(int i, int j){\n  return abs(circle[i].p - circle[j].p) < (double)(circle[i].r + circle[j].r);\n}\n  \nvoid dfs(int count, int select){\n  if(visit[select]) return;\n  visit[select] = true;\n  ans = max(ans,count);\n  bool overlap;\n    \n  for(int i = 0 ; i < n ; i++){\n    if(del[i]) continue;\n    for(int j = i + 1 ; j < n ; j++){\n      if(del[j]) continue;\n        \n      if(circle[i].color != circle[j].color) continue;\n  \n      overlap = false;\n      for(int k = i - 1 ; k >= 0 ; k--){\n        if(del[k]) continue;\n        if(check(i,k)){\n          overlap = true;\n          break;\n        }\n      }\n      if(overlap) continue;\n  \n      overlap = false;\n      for(int k = j - 1 ; k >= 0 ; k--){\n        if(del[k]) continue;\n        if(check(j,k)){\n          overlap = true;\n          break;\n        }\n      }\n      if(overlap) continue;\n        \n      del[i] = del[j] = true;\n      int tmp = select;\n      tmp |= (1 << i);\n      tmp |= (1 << j);\n      dfs(count + 2, tmp);\n      del[i] = del[j] = false;\n    }\n  }\n}\n  \nint main(){\n  while(cin >> n && n){\n    rep(i,n){\n      int x,y,r,c;\n      cin >> x >> y >> r >> c;\n      circle[i] = Circle(Point(x,y),r,c);\n    }\n    ans = 0;\n    memset(visit,false,sizeof(visit));\n    memset(del,false,sizeof(del));\n    dfs(0,0);\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst double eps = 1e-8;\n\ntemplate<typename T> inline T sqr(T x){return x * x;}\ntemplate<typename T> inline void chmax(T& t, T f){if(t < f)t = f;}\n\nstruct Circle : Point {\n    double r;\n    int c;\n    Circle(const Point &a, double r, int c):Point(a), r(r), c(c){}\n};\n\nint overlap(Circle &c1, Circle &c2){\n    if(sqr(c1.r + c2.r) < norm(c1 - c2))return 0;\n    if(abs(c1 - c2) + c1.r < c2.r + eps)return -1;\n    if(c2.r < c1.r && abs(c1 - c2) + c2.r < c1.r + eps)return 1;\n    if(abs(abs(c1 - c2) - c1.r - c2.r) < eps)return -2;\n    return 2;\n}\n\nint n;\nvector<Circle> disc;\n\nint dfs(map<int, set<int> > cur){\n    int res = n - (int)cur.size();\n    for(auto i=cur.begin(); i!=cur.end(); ++i){\n        if(!i->second.empty())continue;\n        auto j = i;\n        for(j++; j!=cur.end(); ++j){\n            if(!j->second.empty() || disc[i->first].c != disc[j->first].c)continue;\n            map<int, set<int> > nxt(cur);\n            for(auto& x: nxt){\n                if(x.second.count(i->first))x.second.erase(i->first);\n                if(x.second.count(j->first))x.second.erase(j->first);\n            }\n            nxt.erase(i->first);\n            nxt.erase(j->first);\n            chmax(res, dfs(nxt));\n        }\n    }\n    return res;\n}\n\nint solve(){\n    map<int, set<int> > indeg;\n    rep(i, n){\n        indeg.emplace(i, set<int>());\n        rep(j, i){\n            int chk = overlap(disc[i], disc[j]);\n            if(chk == 0 || chk == -2)continue;\n            rep(k, j)if(indeg[i].count(k) && indeg[j].count(k))indeg[i].erase(k);\n            indeg[i].insert(j);\n        }\n    }\n    return dfs(indeg);\n}\n\nint main(){\n    while(cin >> n, n){\n        disc.clear();\n        rep(i, n){\n            int x, y, r, c;\n            cin >> x >> y >> r >> c;\n            disc.emplace_back(Point(x, y), r, c);\n        }\n        cout << solve() << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\nint bit_count[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n-bit_count[bit];\n\n    for(int i=0;i<n;i++){\n        if(((bit>>i)&1)==0||ok(i,bit)==false)continue;\n        for(int j=i+1;j<n;j++){\n            if(((bit>>j)&1)==0||ok(j,bit)==false||c[i]!=c[j])continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(memo[to_bit]==false)ret=max(ret,dfs(to_bit));\n\n        }\n    }\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\nvoid init(){\n    for(int i=0;i<(1<<24);i++){\n        for(int j=0;j<24;j++)if((i>>j)&1){\n            bit_count[i]++;\n        }\n    }\n}\n\nint main(){\n    init();\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>/*{{{*/\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i, b, e) for (typeof(b) i = (b); assert((i) <= (e)), i != (e); ++i)\n#define SZ(a) ((int)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(),(v).rend())\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((n) >> (m) & 1)\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\nstatic const double PI (3.14159265358979323846);\nstatic const double EPS (1e-10);\n\nusing namespace std;\ntypedef long long int ll;\ntypedef complex<double> P;/*}}}*/\n\nint n;\n\nstruct plate {\n\tint x, y, r;\n\n\tint id;\n\tint color;\n\tbool top;\n\tvector<plate*> downers;\n\tint upper_set; // bitset\n\t/*\n\tinline bool operator < (const plate &p) const {\n\t\tif (top == p.top) {\n\t\t\treturn color < p.color;\n\t\t} else {\n\t\t\treturn top;\n\t\t}\n\t}\n\t*/\n};\nvector<plate> plates;\n\nvoid show_bit(ll set, int width)\n{\n\tfor (int i = width - 1; i >= 0; --i) {\n\t\tprintf(\"%lld\", BITOF(set, i));\n\t}\n\tcout << endl;\n}\n\n/* bug\nvoid show_top() {\n\tFOR(i, 0, plates.size()) {\n\t\tif (plates[i].top) {\n\t\t\tprintf(\"1\");\n\t\t} else {\n\t\t\tprintf(\"0\");\n\t\t}\n\t}\n\tcout << endl;\n}\n*/\n\nvoid remove(int a, int b)/*{{{*/\n{\n\tplate* p[2] = {&(plates[a]), &(plates[b])};\n\tfor (int i = 0; i < 2; ++i) {\n\t\tplate* r = p[i]; // removal\n\t\tfor (int j = 0; j < r->downers.size(); ++j) {\n\t\t\tplate* d = r->downers[j];\n\t\t\td->upper_set &= ~((int)BIT(r->id));\n\t\t\tif (d->upper_set == 0) {\n\t\t\t\td->top = true;\n\t\t\t}\n\t\t}\n\t}\n}/*}}}*/\n\nvoid restore(int a, int b)/*{{{*/\n{\n\tplate* p[2] = {&(plates[a]), &(plates[b])};\n\tfor (int i = 0; i < 2; ++i) {\n\t\tplate* r = p[i]; // removal\n\t\tfor (int j = 0; j < r->downers.size(); ++j) {\n\t\t\tplate* d = r->downers[j];\n\t\t\tif (d->upper_set == 0) {\n\t\t\t\td->top = false;\n\t\t\t}\n\t\t\td->upper_set |= ~((int)BIT(r->id));\n\t\t}\n\t}\n}/*}}}*/\n\nmap<int, int> memo;\nint rec (unsigned int condition)/*{{{*/\n{\n\tif (memo[condition] != 0) {\n\t\treturn memo[condition];\n\t}\n\t//printf(\"condition: \"); show_bit(condition, n);\n\tint res = 0;\n\tFOR(i, 0, plates.size()) {\n\t\tplate p = plates[i];\n\t\tif (!p.top || BITOF(condition, i) == 0) { // not top or already removed\n\t\t\tcontinue;\n\t\t}\n\n\t\tFOR(j, i+1, plates.size()) {\n\t\t\tif (BITOF(condition, j) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tplate r = plates[j]; // removal\n\t\t\tif (!r.top || p.color != r.color) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// remove i and j\n\t\t\tint save = condition;\n\t\t\tcondition &= ~((int)BIT(i));\n\t\t\tcondition &= ~((int)BIT(j));\n\t\t\tremove(i, j);\n\t\t\tres = max(res, rec(condition) + 2);\n\t\t\trestore(i, j);\n\t\t\tcondition = save;\n\t\t}\n\t}\n\tmemo.insert(map<int, int>::value_type(condition, res));\n\treturn res;\n}/*}}}*/\n\nint main(int argc, char const* argv[])/*{{{*/\n{\n\twhile (cin >> n, n) {\n\t\tFOR(i, 0, plates.size()) {\n\t\t\tplates[i].downers.clear();\n\t\t}\n\t\tplates.clear();\n\t\t// input\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y, r, c;\n\t\t\tcin >> x >> y >> r >> c;\n\n\t\t\tplate p;\n\t\t\tp.id = i; p.x = x; p.y = y; p.r = r; p.color = c;\n\t\t\tp.top = true; p.upper_set = 0;\n\t\t\tplates.PB(p);\n\t\t}\n\t\t// check overlay\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = i - 1; j >= 0; --j) {\n\t\t\t\tplate *p = &(plates[i]), *q = &(plates[j]);\n\t\t\t\tif ( (double)(p->r + q->r) > sqrt( pow(p->x - q->x, 2) + pow(p->y - q->y, 2) ) ) {\n\t\t\t\t\t// q is upper than p\n\t\t\t\t\tp->upper_set |= BIT(q->id);\n\t\t\t\t\tp->top = false;\n\t\t\t\t\tq->downers.PB(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// init memo\n\t\tmemo.clear();\n\t\tint condition = 0xFFFFFF;\n\t\tcout << rec(condition) << endl;\n\t}\n\treturn 0;\n}/*}}}*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n\nusing namespace std;\n\ninline bool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define For(i,a,b)\tfor(ll (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst int dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\nconst int mod = 1000000007;\nconst int INF = 1e9;\n\nbool inter(int x1,int y1,int r1,int x2,int y2,int r2){\n\tint dist = (x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2);\n\tif (dist < (r1 + r2) * (r1 + r2)){\n\t\treturn true;\n\t}else return false;\n}\n\nshort dp[(1 << 24) + 1];\n\nint main()\n{\n\tint n;\n\tint x[100], y[100], r[100], c[100];\n\tvector<int> f[100];\n\n\twhile (cin >> n && n){\n\t\tmemset(f, 0, sizeof f);\n\t\trep(i, n){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\trep(i, n){\n\t\t\tFor(j, i + 1, n){\n\t\t\t\tif (inter(x[i], y[i], r[i], x[j], y[j], r[j]))\n\t\t\t\t\tf[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tmemset(dp, -1, sizeof dp);\n\t\tint ans = 0;\n\t\tdp[0] = 0;\n\t\trep(k, 1 << 24){\n\t\t\tif (dp[k] == -1)continue;\n\t\t\trep(i, n){\n\t\t\t\tif (1 & k >> i)continue;\n\n\t\t\t\tbool If = false;\n\t\t\t\trep(l, f[i].size()){\n\t\t\t\t\tif (!(1 & k >> f[i][l])){\n\t\t\t\t\t\tIf = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (If)continue;\n\n\t\t\t\tFor(j,i+1, n){\n\n\t\t\t\t\tif (1 & k >> j)continue;\n\t\t\t\t\tif (c[i] != c[j])continue;\n\n\t\t\t\t\tbool Jf = false;\n\t\t\t\t\trep(l, f[j].size()){\n\t\t\t\t\t\tif (!(1 & k >> f[j][l])){\n\t\t\t\t\t\t\tJf = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Jf)continue;\n\n\t\t\t\t\tint nx = k | (1 << j) | (1 << i);\n\t\t\t\t\tdp[nx] = max(int(dp[nx]),dp[k] + 2);\n\t\t\t\t\tans = max(int(dp[nx]), ans);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <functional>\nusing namespace std;\n\n//ifstream ifs(\"test.txt\");\n//#define cin ifs\n\nstruct Point{\n\tint x, y;\n};\n\nstruct Circle{\n\tPoint p;\n\tint radius;\n\tint color;\n\tint parentCount = 0;\n\tvector<Circle*> children;\n};\n\nbool IsCross(Circle& a, Circle& b){\n\tauto c = sqrt(pow((a.p.x - b.p.x), 2) + pow((a.p.y - b.p.y), 2));\n\treturn c < a.radius + b.radius;\n}\n\nvoid Func(int n){\n\n\tvector<Circle> circles(n);\n\n\tfor (auto&& a : circles){\n\t\tcin >> a.p.x >> a.p.y >> a.radius >> a.color;\n\t}\n\n\tvector<Circle*> root;\n\troot.emplace_back(&circles.at(0));\n\n\tfor (int i = 1; i < n; i++){ // current\n\t\tfor (int j = 0; j < i; j++){ // parent\n\t\t\tif (IsCross(circles.at(i), circles.at(j))){ // kousa\n\t\t\t\tcircles.at(j).children.emplace_back(&circles.at(i));\n\t\t\t\tcircles.at(i).parentCount++;\n\t\t\t}\n\t\t}\n\t\tif (circles.at(i).parentCount == 0){\n\t\t\troot.emplace_back(&circles.at(i));\n\t\t}\n\t}\n\n\tint count = 0;\n\twhile (true){\n\n\t\tfor (int i = 1; i < (int)root.size();i++){\n\t\t\tfor (int j = 0; j < i; j++){\n\n\t\t\t\tif (root.at(i)->color == root.at(j)->color){\n\t\t\t\t\tfor (int k = 0; k < root.at(i)->children.size();k++){\n\t\t\t\t\t\tif (root.at(i)->children.at(k)->parentCount == 1){\n\t\t\t\t\t\t\troot.emplace_back(root.at(i)->children.at(k));\n\t\t\t\t\t\t\troot.at(i)->children.at(k)->parentCount = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\troot.at(i)->children.at(k)->parentCount--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k < root.at(j)->children.size(); k++){\n\t\t\t\t\t\tif (root.at(j)->children.at(k)->parentCount == 1){\n\t\t\t\t\t\t\troot.emplace_back(root.at(j)->children.at(k));\n\t\t\t\t\t\t\troot.at(j)->children.at(k)->parentCount = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\troot.at(j)->children.at(k)->parentCount--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\troot.erase(root.begin() + i);\n\t\t\t\t\troot.erase(root.begin() + j);\n\t\t\t\t\tcount += 2;\n\t\t\t\t\tgoto EXIT;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tEXIT:;\n\n\t}\n\n\tcout << count << endl;\n}\n\nint main()\n{\n\n\twhile (true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tFunc(n);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define mod 1000000007\n#define all(c) begin(c),end(c)\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nusing ll = long long;\nusing vi = vector<int>; using vs = vector<string>;\nint dd[] = { 0, 1, 0, -1, 0 }; //→↓←↑\n\n\n\nvoid solve()\n{\n\tint N;\n\twhile (cin >> N, N)\n\t{\n\t\tvector<int> x(N);\n\t\tvector<int> y(N);\n\t\tvector<int> r(N);\n\t\tvector<int> c(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\t\n\t\tvector<int> G[N];\n\t\t//vector<int> P(N);\n\t/*\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tP[i] = -1;\n\t\t}*/\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t{\n\t\t\t\tint xx = x[i] - x[j];\n\t\t\t\tint yy = y[i] - y[j];\n\t\t\t\tint rr = r[i] + r[j];\n\t\t\t\tif (xx * xx + yy * yy < rr * rr)\n\t\t\t\t{\n\t\t\t\t\tG[j].emplace_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> dp(1 << N, 0);\n\t\tint ans = 0;\n\t\tvector<bool> ok(N, false);\n\t\tfor (int S = 0; S < 1 << N; S++)\n\t\t{\n\t\t\tif (S != 0 && dp[S] == 0)continue;\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t{\n\t\t\t\tif (S >> i & 1)continue;\n\t\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t\t{\n\t\t\t\t\tif (S >> j & 1)continue;\n\t\t\t\t\tif (c[i] != c[j])continue;\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\tfor (int v : G[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((S >> v & 1) == 0) {\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!flag)continue;\n\t\t\t\t\tfor (int v : G[j]) {\n\t\t\t\t\t\tif ((S >> v & 1) == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!flag)continue;\n\n\n\t\t\t\t\tdp[S | (1 << i) | (1 << j)] = dp[S] + 2;\n\t\t\t\t\tans = max(ans, dp[S + 2]);\n\t\t\t\t\t//ok[i] = true;\n\t\t\t\t\t//ok[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << dp[S] << endl;\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\nusing namespace std;\nint n,x[24],y[24],r[24],c[24];\nint dist(int a,int b){return (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);}\n\nint rec(int S){\n  int res=0;\n  bool f[n];\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    f[i]=true;\n    for(int j=i-1;j>=0;j--){\n      if((S>>j)&1)continue;\n      if(dist(i,j)>=(r[i]+r[j])*(r[i]+r[j]))continue;\n      f[i]=false;\n    }\n  }\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    if(!f[i])continue;\n    for(int j=i+1;j<n;j++){\n      if((S>>j)&1)continue;\n      if(!f[j])continue;\n      if(c[i]!=c[j])continue;\n      res=max(res,2+rec(S+(1<<i)+(1<<j)));\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++)\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n    cout<<rec(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <map>\n#include <bitset>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){\n    rep(i,v.size()) os << v[i] << (i+1==v.size()?\"\":\" \");\n    return os;\n}\n\ndouble eps = 1e-9;\n\nint n;\nint x[24], y[24], r[24], c[24];\nbool hit[24][24];\nmap<int,int> dp;\n\nint dfs(int S){\n    if(dp.count(S)) return dp[S];\n    int & res = dp[S];\n    res = 0;\n    rep(i,n){\n        if(S>>i & 1){\n            rep(j,i){\n                if(S>>j & 1){\n                    if(hit[i][j] || c[i]!=c[j]) continue;\n                    bool ok = true;\n                    rep(k,i) if(hit[i][k] && (S>>k & 1)) ok = false;\n                    rep(k,j) if(hit[j][k] && (S>>k & 1)) ok = false;\n                    if(!ok) continue;\n                    S ^= 1<<i;\n                    S ^= 1<<j;\n                    res = max(dfs(S)+2, res);\n                    S ^= 1<<i;\n                    S ^= 1<<j;\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(cin>>n && n){\n        dp.clear();\n        rep(i,n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n        rep(i,n)rep(j,i){\n            int dx=x[i]-x[j], dy=y[i]-y[j];\n            int d = dx*dx+dy*dy;\n            hit[i][j] = hit[j][i] = d < (r[i]+r[j])*(r[i]+r[j]);\n        }\n        int S = 0;\n        rep(i,n) S |= 1<<i;\n        cout << dfs(S) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n\nconst double pi = 3.141592653589793238462643383279;\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s)\n{\n  int v;\n  istringstream sin(s);\n  sin >> v;\n  return v;\n}\ntemplate <class T>\ninline string toString(T x)\n{\n  ostringstream sout;\n  sout << x;\n  return sout.str();\n}\ninline int readInt()\n{\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a) * (a))\n#define EACH(i, c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i, s, n) for (int i = s; i < (int)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for (int i = a; i < (b); ++i)\n#define trav(a, x) for (auto &a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n\nclass UnionFind\n{\npublic:\n  vector<int> par;\n  vector<int> siz;\n\n  UnionFind(int sz_) : par(sz_), siz(sz_, 1)\n  {\n    for (ll i = 0; i < sz_; ++i)\n      par[i] = i;\n  }\n  void init(int sz_)\n  {\n    par.resize(sz_);\n    siz.assign(sz_, 1LL);\n    for (ll i = 0; i < sz_; ++i)\n      par[i] = i;\n  }\n\n  int root(int x)\n  {\n    while (par[x] != x)\n    {\n      x = par[x] = par[par[x]];\n    }\n    return x;\n  }\n\n  bool merge(int x, int y)\n  {\n    x = root(x);\n    y = root(y);\n    if (x == y)\n      return false;\n    if (siz[x] < siz[y])\n      swap(x, y);\n    siz[x] += siz[y];\n    par[y] = x;\n    return true;\n  }\n\n  bool issame(int x, int y)\n  {\n    return root(x) == root(y);\n  }\n\n  int size(int x)\n  {\n    return siz[root(x)];\n  }\n};\n\nll modPow(ll x, ll n, ll mod = MOD)\n{\n  ll res = 1;\n  while (n)\n  {\n    if (n & 1)\n      res = (res * x) % mod;\n\n    res %= mod;\n    x = x * x % mod;\n    n >>= 1;\n  }\n  return res;\n}\n\n#define SIEVE_SIZE 5000000 + 10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve()\n{\n  for (int i = 0; i < SIEVE_SIZE; ++i)\n    sieve[i] = true;\n  sieve[0] = sieve[1] = false;\n  for (int i = 2; i * i < SIEVE_SIZE; ++i)\n    if (sieve[i])\n      for (int j = 2; i * j < SIEVE_SIZE; ++j)\n        sieve[i * j] = false;\n}\n\nbool isprime(ll n)\n{\n  if (n == 0 || n == 1)\n    return false;\n  for (ll i = 2; i * i <= n; ++i)\n    if (n % i == 0)\n      return false;\n  return true;\n}\n\nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit()\n{\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (int i = 2; i < MAX; i++)\n  {\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\n\n// 二項係数計算\nlong long COM(int n, int k)\n{\n  if (n < k)\n    return 0;\n  if (n < 0 || k < 0)\n    return 0;\n  return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nlong long extGCD(long long a, long long b, long long &x, long long &y)\n{\n  if (b == 0)\n  {\n    x = 1;\n    y = 0;\n    return a;\n  }\n  long long d = extGCD(b, a % b, y, x);\n  y -= a / b * x;\n  return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK)\ninline long long mod(long long a, long long m)\n{\n  return (a % m + m) % m;\n}\n\n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m)\n{\n  long long x, y;\n  extGCD(a, m, x, y);\n  return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b)\n{\n\n  if (b == 0)\n    return a;\n  return GCD(b, a % b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B)\n{\n  mat C(A.size(), vec((int)B[0].size()));\n  for (int i = 0; i < A.size(); ++i)\n  {\n    for (int k = 0; k < B.size(); ++k)\n    {\n      for (int j = 0; j < B[0].size(); ++j)\n      {\n        C[i][j] = (C[i][j] + A[i][k] % MOD * B[k][j] % MOD) % MOD;\n      }\n    }\n  }\n  return C;\n}\nmat matPow(mat A, ll n)\n{\n  mat B(A.size(), vec((int)A.size()));\n\n  for (int i = 0; i < A.size(); ++i)\n  {\n    B[i][i] = 1;\n  }\n\n  while (n > 0)\n  {\n    if (n & 1)\n      B = mul(B, A);\n    A = mul(A, A);\n    n >>= 1;\n  }\n  return B;\n}\nconst int UP = 0;\nconst int FRONT = 1;\nconst int RIGHT = 2;\nconst int LEFT = 3;\nconst int BACK = 4;\nconst int DOWN = 5;\nstruct Dice\n{\n\n  vector<int> d;\n\n  Dice(vector<int> v, int N = 6)\n  {\n    d.resize(N);\n    for (int i = 0; i < N; i++)\n    {\n      d[i] = v[i];\n    }\n  }\n\n  Dice(int t, int f, int N = 6)\n  {\n    d.resize(N);\n    d[UP] = t;\n    d[DOWN] = 7 - d[UP];\n    d[FRONT] = f;\n    d[BACK] = 7 - d[FRONT];\n\n    if (t == 1)\n    {\n      if (f == 2)\n      {\n        d[RIGHT] = 3;\n      }\n      else if (f == 3)\n      {\n        d[RIGHT] = 5;\n      }\n      else if (f == 4)\n      {\n        d[RIGHT] = 2;\n      }\n      else if (f == 5)\n      {\n        d[RIGHT] = 4;\n      }\n    }\n    else if (t == 2)\n    {\n      if (f == 1)\n      {\n        d[RIGHT] = 4;\n      }\n      else if (f == 3)\n      {\n        d[RIGHT] = 1;\n      }\n      else if (f == 6)\n      {\n        d[RIGHT] = 3;\n      }\n      else if (f == 4)\n      {\n        d[RIGHT] = 6;\n      }\n    }\n    else if (t == 3)\n    {\n      if (f == 1)\n      {\n        d[RIGHT] = 2;\n      }\n      else if (f == 2)\n      {\n        d[RIGHT] = 6;\n      }\n      else if (f == 5)\n      {\n        d[RIGHT] = 1;\n      }\n      else if (f == 6)\n      {\n        d[RIGHT] = 5;\n      }\n    }\n    else if (t == 4)\n    {\n      if (f == 1)\n      {\n        d[RIGHT] = 5;\n      }\n      else if (f == 2)\n      {\n        d[RIGHT] = 1;\n      }\n      else if (f == 5)\n      {\n        d[RIGHT] = 6;\n      }\n      else if (f == 6)\n      {\n        d[RIGHT] = 2;\n      }\n    }\n    else if (t == 5)\n    {\n      if (f == 1)\n      {\n        d[RIGHT] = 3;\n      }\n      else if (f == 3)\n      {\n        d[RIGHT] = 6;\n      }\n      else if (f == 4)\n      {\n        d[RIGHT] = 1;\n      }\n      else if (f == 6)\n      {\n        d[RIGHT] = 4;\n      }\n    }\n    else if (t == 6)\n    {\n      if (f == 2)\n      {\n        d[RIGHT] = 4;\n      }\n      else if (f == 3)\n      {\n        d[RIGHT] = 2;\n      }\n      else if (f == 4)\n      {\n        d[RIGHT] = 5;\n      }\n      else if (f == 5)\n      {\n        d[RIGHT] = 3;\n      }\n    }\n    d[LEFT] = 7 - d[RIGHT];\n  }\n\n  void rotate(char s)\n  {\n    vector<int> tmp = d;\n    if (s == 'S')\n    {\n      d[0] = tmp[4];\n      d[1] = tmp[0];\n      d[5] = tmp[1];\n      d[4] = tmp[5];\n    }\n\n    if (s == 'E')\n    {\n      d[0] = tmp[3];\n      d[2] = tmp[0];\n      d[5] = tmp[2];\n      d[3] = tmp[5];\n    }\n\n    if (s == 'W')\n    {\n      d[0] = tmp[2];\n      d[3] = tmp[0];\n      d[5] = tmp[3];\n      d[2] = tmp[5];\n    }\n\n    if (s == 'N')\n    {\n      d[0] = tmp[1];\n      d[1] = tmp[5];\n      d[5] = tmp[4];\n      d[4] = tmp[0];\n    }\n  }\n\n  void spin()\n  {\n    vector<int> tmp = d;\n    d[1] = tmp[2];\n    d[2] = tmp[4];\n    d[4] = tmp[3];\n    d[3] = tmp[1];\n  }\n\n  int operator[](const int &k)\n  {\n    return d[k];\n  }\n\n  bool issame(Dice &d2)\n  {\n    bool res = true;\n\n    for (int i = 0; i < 6; i++)\n    {\n      if (d[i] != d2[i])\n        res = false;\n    }\n\n    return res;\n  }\n};\n\n//i, jの高さkの値\nint arr[210][210];\nint h[210][210];\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n\n  int n;\n  vector<int> res;\n  while (cin >> n, n)\n  {\n    vector<double> x(n), y(n), r(n), c(n);\n\n    vector<int> mask;\n    REP(i, n)\n    {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n      c[i]--;\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n      int t = 0;\n      for (int j = 0; j < i; j++)\n      {\n        double d = sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]));\n\n        if (r[i] + r[j] > d)\n        {\n          t |= (1 << j);\n        }\n      }\n      mask.push_back(t);\n    }\n\n    vector<int> dp(1 << n, -1);\n    dp[0] = 0;\n    int ans = 0;\n    for (int bit = 0; bit < (1 << n); bit++)\n    {\n      if (dp[bit] == -1)\n        continue;\n      map<int, vector<int>> mp;\n      for (int i = 0; i < n; i++)\n      {\n        if ((bit & (1 << i)) == 0 && (mask[i] & bit) == mask[i])\n        {\n          mp[c[i]].push_back(i);\n        }\n      }\n\n      for (auto e : mp)\n      {\n        if (e.second.size() <= 1)\n          continue;\n\n        for (int i = 0; i < e.second.size(); i++)\n        {\n          int x = e.second[i];\n          for (int j = i + 1; j < e.second.size(); j++)\n          {\n            int y = e.second[j];\n            int t = 0;\n            t |= (1 << x);\n            t |= (1 << y);\n            dp[bit | t] = max(dp[bit | t], dp[bit] + 2);\n            ans = max(ans, dp[bit | t]);\n          }\n        }\n      }\n    }\n    //res.push_back(ans);\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n\nlong long  mod = 1000000007;\n\n\nbool lap[30][30];\n\n\nbool overlap(int i,int j,vector<int> &x,vector<int>&y,vector<int> &r){\n\tint k = 0;\n\tk = (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]);\n\tif(k>= (r[i]+r[j])*(r[i]+r[j]))return 0;\n\treturn 1;\n}\n\n\nint main(){\n\tint n;\n\twhile(cin >> n && n!=0){\n\t\tset<int>st,st2;\n\t\tvector<int>x(n),y(n),r(n),c(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tfor(int i=0;i<30;i++){\n\t\t\tfor(int j=0;j<30;j++){\n\t\t\t\tlap[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(overlap(i,j,x,y,r)==1){\n\t\t\t\t\tlap[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tbool flag = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\tif(lap[i][j]==0){\n\t\t\t\t\t\tfor(int k=i+1;k<j;k++){\n\t\t\t\t\t\t\tif(lap[i][k]&&lap[k][j]){\n\t\t\t\t\t\t\t\tlap[i][j]=1;\n\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)break;\n\t\t}\n\t\t/*for(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tcout << i <<  \" \" << j << \" \" << lap[i][j] << endl;\n\t\t\t}\n\t\t}*/\n\n\t\tst.insert((1<<n)-1);\n\t\tst2.insert((1<<n)-1);\n\t\twhile(1){\n\t\t\tbool flag = 1;\n\t\t\tset<int> st3;\n\t\t\tfor(auto s:st2){\n\t\t\t\t//cout << static_cast<bitset<24>>(s) << endl;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\t\tif(c[i]==c[j]){\n\t\t\t\t\t\t\tif((s&(1<<i))&&(s&(1<<j))){\n\t\t\t\t\t\t\t\tbool fl =1;\n\t\t\t\t\t\t\t\tfor(int p=0;p<i;p++){\n\t\t\t\t\t\t\t\t\tif(lap[p][i]==1&&(s&(1<<p)))fl = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int p=0;p<j;p++){\n\t\t\t\t\t\t\t\t\tif(lap[p][j]==1&&(s&(1<<p)))fl = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(fl){\n\t\t\t\t\t\t\t\t\tst.insert(s-(1<<i)-(1<<j));\n\t\t\t\t\t\t\t\t\tst3.insert(s-(1<<i)-(1<<j));\n\t\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tst2 = st3;\n\t\t\tif(flag)break;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(auto s:st){\n\t\t\tint c = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(s&(1<<i)){\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans,n-c);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//9:55\n//10:15\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#define SQR(X) ((X)*(X))\n\nusing namespace std;\n\nint dp[1<<24];\nint x[24],y[24],r[24],c[24];\n\nint rem(int n,int s){\n  bool under[24]={};\n  for(int i=0;i<n;i++){\n    if((s&(1<<i))==0){\n      for(int j=i+1;j<n;j++){\n\tif(SQR(x[i]-x[j])+SQR(y[i]-y[j])<SQR(r[i]+r[j])){\n\t  under[j]=true;\n\t}\n      }\n    }\n  }\n  int mr=0;\n  for(int i=0;i<n;i++){\n    if(((s&(1<<i))==0)&&!under[i]){\n      for(int j=i+1;j<n;j++){\n\tif(((s&(1<<j))==0)&&!under[j]&&c[i]==c[j]){\n\t  mr=max(mr,rem(n,s|(1<<i)|(1<<j))+2);\n\t}\n      }\n    }\n  }\n  return mr;\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n    }\n    cout<<rem(n,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\n// <<<\n\nvoid solve(int n) {\n    vector<int> x(n),y(n),r(n),c(n);\n    rep (i,n) cin >> x[i] >> y[i] >> r[i] >> c[i], --c[i];\n\n    vector<vector<int>> g(n);\n    rep (i,n) rep (j,n) if (i < j) {\n        int dx = x[i]-x[j], dy = y[i]-y[j], rsum = r[i]+r[j];\n        if (dx*dx + dy*dy < rsum*rsum) {\n            g[i].eb(j);\n        }\n    }\n    dump(as_mat(g));\n\n    vector<bool> dp(1LL<<n);\n    dp[0] = true;\n    rep (s,1LL<<n) if (dp[s]) {\n        static vector<int> deg;\n        deg.resize(n);\n        fill(all(deg),0);\n        rep (i,n) if (~s>>i&1) for (int j : g[i]) deg[j]++;\n        static vector<int> v[4];\n        for (auto &w : v) w.clear();\n        rep (i,n) if ((~s>>i&1) && deg[i] == 0) v[c[i]].eb(i);\n        for (auto &w : v) {\n            rep (j,w.size()) rep (k,w.size()) if (j < k) {\n                dp[s^(1LL<<w[j])^(1LL<<w[k])] = true;\n            }\n        }\n    }\n    debug {\n        rep (s,1LL<<n) if (dp[s]) {\n            dump(as_bit(s),popcnt(s));\n        }\n    }\n\n    int ma = 0;\n    rep (s,1LL<<n) if (dp[s]) chmax(ma, popcnt(s));\n    cout << ma << \"\\n\";\n\n}\n\n\nint32_t main() {\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        solve(n);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <string.h>\n\nusing namespace std;\n\nconst int MAX_N = 24;\n\nclass Circle {\npublic:\n\tshort x, y, r, c; // 中心のxy座標、半径、色番号\n};\n\n/* 入力 */\nint n; // 円盤の枚数\nCircle cir[MAX_N]; // 円の情報\n\n/*\nS:すでに取り除いた円の集合(bitで表す、右から円番号0,1,2,...,MAX_N)\ndp[S]:ここから取り除ける最大枚数\n漸化式\ndp[全部取り除いた] = 0\ndp[S] = max(dp[S U 取り除いた2つの円]+2)\n*/\nshort dp[1 << MAX_N];\n\n/* 2点間の距離 */\ndouble dis(char x1, char y1, char x2, char y2) {\n\treturn sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));\n}\n\n/* 円kが上に1枚でも重なっているかどうか、重なっていたらtrue */\nbool ispiled(int k, int S) {\n\tfor (int i = k - 1; i >= 0; i--) {\n\t\tif (dis(cir[i].x, cir[i].y, cir[k].x, cir[k].y) < cir[i].r + cir[k].r && !(S >> i & 1)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n/*\nbool ispiled(Circle c1, Circle c2) {\n\tif (dis(c1.x, c1.y, c2.x, c2.y) < c1.r + c2.r) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n*/\n\n/* S:すでに取り除いた円盤の集合 */\nshort remove(int S) {\n\t//cout << \"S = \" << S << \" dp[\" << S << \"]: \" << dp[S] << endl;\n\tif (dp[S] >= 0) {\n\t\treturn dp[S];\n\t}\n\t\n        /* 全部取り除いた */\n\tif (S == ((1 << n) - 1)) {\n\t\treturn dp[S] = 0;\n\t}\n\n\tint res = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (S >> i & 1 || ispiled(i, S)) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t/* どちらかがすでに取り除かれているか、2つの色が違うか、2枚のうち1枚以上が下にあれば取り除けないので次の組へ */\n\t\t\tif (S >> j & 1 || cir[i].c != cir[j].c || ispiled(j, S)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (true) {\n\t\t\t\tint tmp = S | 1 << i;\n\t\t\t\ttmp = tmp | 1 << j;\n\t\t\t\tres = max(res, remove(tmp) + 2);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[S] = res;\n}\n\nint main() {\n\t// 方針: bitDP\n\t//const int MAX_N = 24;\n\twhile (true) {\n\t\t//cout << \"n=\" << endl;\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> cir[i].x >> cir[i].y >> cir[i].r >> cir[i].c;\n\t\t}\n\t\tmemset(dp, -1, sizeof(dp));\n\t\t//cout << \"test\" << endl;\n\t\tcout << remove(0) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 24\nusing namespace std;\n\nint n,x[N],y[N],r[N],c[N],ans,len[N];\nvector<int> v[N];\n\nvoid func(bool erased[N],int cnt,int x){\n  ans=max(ans,cnt);\n  for(int i=0;i<n;i++){\n    int f=0;\n    if(erased[i]) continue;\n    for(int j=0;j<len[i];j++)\n      if(!erased[v[i][j]]) f=1;\n    if(f) continue;\n    for(int j=i+1;j<n;j++){\n      if(c[i]!=c[j]) continue;\n      if(erased[j]) continue;\n      int f2=0;\n      for(int k=0;k<len[j];k++)\n\tif(!erased[v[j][k]]) f2=1;\n      if(f2) continue;\n      erased[i]=erased[j]=true;\n      func(erased,cnt+2,x+1);\n      erased[i]=erased[j]=false;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n      for(int j=i-1;j>=0;j--){\n\tint xl=x[i]-x[j],yl=y[i]-y[j];\n\tint rl=r[i]+r[j];\n\tif(xl*xl+yl*yl<rl*rl)v[i].push_back(j);\n      }\n    }\n    for(int i=0;i<n;i++) len[i]=v[i].size();\n    bool erased[N]={};\n    ans=0;\n    func(erased,0,0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++) v[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\n/* 円 */\nstruct C {\n    P p; double r;\n    C() : p(0), r(0) {}\n    C(const P &p, double r) : p(p), r(r) { }\n};\n\nbool intersectCC(const C &c, const C &d){\n    return (norm(c.p - d.p) - (c.r + d.r)*(c.r + d.r) < -EPS);\n}\n\nint ans, n;\nset<int> done;\nvi E[32];\nvector<C> cir;\nvi col;\n\nvoid input(){\n    rep(i,n){\n\tint x, y, r, c;\n\tcin >> x >> y >> r >> c;\n\tcir.pb(C(P(x,y),r));\n\tcol.pb(c);\n    }\n}\n\nvoid init(){\n    ans = 0;\n    done.clear();\n    cir.clear();\n    col.clear();\n    rep(i,32) E[i].clear();\n    return;\n}\n\nvoid make_edge(){\n    rep(i,n)repi(j,i+1,n)\n\tif(intersectCC(cir[i],cir[j])){\n//\t    cerr << i << ' ' << j << endl;\n\t    E[j].pb(i);\n\t}\n    return;\n}\n\nvoid saiki(int S){\n    if(done.find(S) != done.end()) return;\n    done.insert(S);\n    bool naiyo = true;\n    rep(i,n)repi(j,i+1,n)if(((S>>i)&1) && ((S>>j&1)) && (col[i] == col[j])){\n\tbool ok = true;\n\trep(a,E[i].size())if((S>>E[i][a])&1){\n\t    ok=false;\n\t    break;\n\t}\n\tif(!ok) continue;\n\tok = true;\n\trep(a,E[j].size())if((S>>E[j][a])&1){\n\t    ok=false;\n\t    break;\n\t}\n\tif(!ok) continue;\n/*\n\tcerr << \"hoge\\n\";\n\tcerr << i << \" \" << j << endl;\n*/\n\tsaiki(S^(1<<i)^(1<<j));\n\tnaiyo = false;\n    }\n    if(naiyo){\n\tint cnt = 0;\n\trep(i,n)if((S>>i)&1)cnt++;\n\tans = max(ans, n-cnt);\n    }\n    return;\n}\n\nint main() {\n    while(cin >> n, n){\n\tinit();\n\tinput();\n\tmake_edge();\n\tsaiki((1<<n)-1);\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstruct po {int x,y,r,g;};\nvector <po> c[5];\nint ans;\nbool check(po a){\n  if(a.g==10000)return false;\n  for(int i=0;i<4;i++)\n    for(int j=0;j<c[i].size();j++){\n      po b = c[i][j];\n      if(a.g>b.g && (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y) < (a.r+b.r)*(a.r+b.r)) return false;\n    }\n  return true;\n}\n\nint com=0;\nvoid saiki(int sum,int i,int cnt){\n  ans = max(ans,sum);\n  com++;\n  vector <int> J;\n  for(int j=0;j<(int)c[i].size();j++)if(check(c[i][j])==true)J.push_back(j);\n  for(int j=0;j<(int)J.size();j++)\n    for(int k=j+1;k<(int)J.size();k++){\n      int a,b;\n      a=c[i][J[j]].g;\n      b=c[i][J[k]].g;\n      c[i][J[j]].g = c[i][J[k]].g = 10000;\n      for(int l=1;l<4;l++)saiki(sum+2,(i+l)%4,0);\n      c[i][J[j]].g=a;\n      c[i][J[k]].g=b;\n    }\n}\n\nint main(){\n  while(1){\n    int n;\n    cin>>n;\n    if(n==0)break;\n    int x,y,r,col;\n    for(int i=0;i<4;i++) c[i].clear();\n    for(int i=0;i<n;i++)cin >>x>>y>>r>>col, c[--col].push_back((po){x,y,r,i});\n\n    ans =com=0;\n    for(int i=0;i<4;i++) saiki(0,i,0);\n    cout <<ans<<endl;\n    //    cout <<\"com=\"<<com<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//線分を表す構造体\nstruct Segment{ Point p1, p2; };\n//直線を表す構造体\ntypedef Segment Line;\n//多角形を表す構造体\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// 許容する誤差\n#define EPS (1e-10)\n\n// ベクトルaの絶対値を求める\n//double length = abs(a);\n\n// 2点a,b間の距離を求める\n//double distance = abs(a-b);\n\n/*\n// ベクトルaの単位ベクトルを求める\nPoint b = a / abs(a);\n\n// ベクトルaの法線ベクトルn1,n2を求める\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 点cが直線a,b上にあるかないか\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// 点a,bを通る直線と点cとの距離\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// 線分s1と線分s2の距離\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// 線分sに対する点pの射影\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//線分sを対象軸とした点pの線対称の点\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//点pをangle分だけ時計回りに回転\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//円cと線分lの交点\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//点の内包\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//ベクトルの位置検出\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//凸包\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISEだと内角は180以下（一直線上に並んでいても、頂点として数える）\n        //!= CLOCKWISEだと内角は180未満（一直線上の頂点は数えない）\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //ここも == と != を変更する\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //最も下にある点の中で最も右にある点から反時計回りに並び替え\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//キャリパー法を用いて凸多角形の直径を求める\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//凸多角形の切り取りに使う関数。これがなんなのかはまだ知らない。\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//三角形の面積\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//多角形の面積\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//凸多角形かどうかの判定\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//凹多角形を線分lで切断した際の多角形の数\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\n//i番目を0にする\nint clearBit(int num, int i){\n\tint mask = ~(1 << i);\n\treturn num & mask;\n}\n\n//i番目をvで置き換える\nint updateBit(int num, int i, int v){\n\tint mask = ~(1 << i);\n\treturn (num & mask) | (v << i);\n}\n\nint n, ans;\n\nbool isOver(Circle a, Circle b){\n\tpair<Point,Point> tmp = getCrossPoints(a,b);\n    return isnan(tmp.first.imag());\n}\n\nvoid dfs(vector<vector<int>>& g, int cur, vector<int>& on){\n\tfor(auto to : g[cur]){\n\t\ton[to] = on[to] bitor (1 << cur) bitor on[cur];\n\t\tdfs(g, to, on);\n\t}\n}\n\nvector<bool> memo;\nvoid dfs(int s, vector<int>& on, vector<int> c){\n\tif(memo[s]) return;\n\n\tvector<vector<int>> canTake(4);\n\trep(i,n){\n\t\tif(getBit(s,i)) continue;\n\t\tif((on[i] bitand s) == on[i]){\n\t\t\tcanTake[c[i]].emplace_back(i);\n\t\t}\n\t}\n\n\tvector<int> take(4,0);\n\trep(i,4){\n\t\tfor(auto j : canTake[i]){\n\t\t\ttake[i] = setBit(take[i], j);\n\t\t}\n\t}\n\n\trep(i,4){\n\t\tif(canTake[i].size() >= 2){\n\t\t\tif(canTake[i].size() % 2 == 1){\n\t\t\t\trep(j,canTake[i].size()){\n\t\t\t\t\tdfs(s bitor clearBit(take[i], j), on, c);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdfs(s bitor take[i], on, c);\n\t\t\t}\n\t\t}\n\t}\n\n\tbitset<30> bit(s);\n\tans = max<int>(ans, bit.count());\n\tmemo[s] = true;\n}\n\nint main(){\n    while(scanf(\"%d\",&n),n){\n        vector<Circle> c(n);\n        vector<int> color(n);\n        rep(i,n){\n            double x,y,r;\n            scanf(\"%lf%lf%lf%d\",&x,&y,&r,&color[i]);\n\t\t\tcolor[i]--;\n            c[i] = {Point(x,y),r};\n        }\n\n\t\tvector<vector<int>> g(n);\n\t\tvector<bool> top(n,1);\n\t\trep(i,n){\n\t\t\trange(j,i + 1,n){\n\t\t\t\tif(isOver(c[i], c[j])){\n\t\t\t\t\tg[i].emplace_back(j);\n\t\t\t\t\ttop[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> on(n,0);\n\t\trep(i,n){\n\t\t\tif(not top[i]) continue;\n\t\t\tdfs(g, i, on);\n\t\t}\n\t\t//rep(i,n) show(on[i])\n\n\t\tans = 0;\n\t\tmemo = vector<bool>(1 << n, 0);\n\t\tdfs(0, on, color);\n\t\tcout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[(1<<24)+2];\nint main(){\n  int n;;\n  while(cin>>n,n){\n    int col[n],ans=0;\n    double r[n],x[n],y[n];\n    for(int i=0;i<n;i++)\n      cin>>x[i]>>y[i]>>r[i]>>col[i];\n    memset(dp,0,sizeof(dp));\n    dp[((1<<n)-1)]=1;\n  \n    for(int i=1<<n;i>=0;i--)if(dp[i])\n\tfor(int j=n-1;j>=0;j--)if((1<<j)&i)\n\t    for(int k=j-1;k>=0;k--)\n\t      if(((1<<k)&i)&&col[j]==col[k]){\n\t\tfor(int l=j-1;l>=0;l--)if((i&(1<<l))&&abs(sqrt((x[l]-x[j])*(x[l]-x[j])+(y[l]-y[j])*(y[l]-y[j])))<r[j]+r[l])goto L;\n\t        for(int l=k-1;l>=0;l--)if((i&(1<<l))&&abs(sqrt((x[l]-x[k])*(x[l]-x[k])+(y[l]-y[k])*(y[l]-y[k])))<r[k]+r[l])goto L;\n\t\tdp[i-(1<<j)-(1<<k)] =dp[i]+2;\n\t\tans=max(ans,dp[i-(1<<j)-(1<<k)]);\n\t      L:;\n\t      }\n    cout<<ans-1<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nclass Round\n{\n\tpublic:\n\tdouble x,y,r;\n\tint c;\n\tRound(){}\n\tRound(double a,double b,double rr,int d)\n\t{\n\t\tx=a;y=b;r=rr;c=d;\n\t}\n};\n\nclass Edge\n{\n\tpublic:\n\tint to,cost;\n\tEdge(int t,int c)\n\t{\n\t\tto=t;cost=c;\n\t}\n};\n\ndouble dist(Round &r1,Round &r2)\n{\n\treturn sqrt((r1.x-r2.x)*(r1.x-r2.x)+(r1.y-r2.y)*(r1.y-r2.y));\n}\n\nbool contain(Round &r1,Round &r2)\n{\n\tif(r1.r+r2.r>dist(r1,r2))\n\t\treturn true;\n\treturn false;\n}\nRound ban[30];\nvector<Edge> g[30];\nvector<Edge> rg[30];//逆辺グラフ\nint dp[1<<24];//1のところだけ円盤が取り除かれているとき、さらに取り除くことのできる数\n\nint access(int index,int n)\n{\n\t//cerr<<index<<endl;\n\tif(dp[index]!=-1)\n\t\treturn dp[index];\n\tdp[index]=0;\n\tbool f;\n\tvector<int> v;//上にある円盤\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(index&(1<<i))\n\t\t\tcontinue;\n\t\tf=true;\n\t\tfor(int j=0;j<rg[i].size();j++)\n\t\t{\n\t\t\tif(!(index&(1<<rg[i][j].to)))\n\t\t\t{\n\t\t\t\tf=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(f)\n\t\t\tv.push_back(i);\n\t}\n\tfor(int i=0;i<v.size();i++)\n\t{\n\t\tfor(int j=i+1;j<v.size();j++)\n\t\t{\n\t\t\tif(ban[v[i]].c==ban[v[j]].c)\n\t\t\t\tdp[index]=max(dp[index],2+access(index^((1<<v[i])|(1<<v[j])),n));\n\t\t}\n\t}\n\treturn dp[index];\n}\nint main()\n{\n\tint n;\n\tint k;\n\twhile(1)\n\t{\n\t\tcin>>n;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tk=0;\n\t\tfor(int i=0;i<30;i++)\n\t\t{\n\t\t\tg[i].clear();\n\t\t\trg[i].clear();\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tdouble x,y,r;\n\t\t\tint c;\n\t\t\tcin>>x>>y>>r>>c;\n\t\t\tc--;\n\t\t\tban[i]=Round(x,y,r,c);\n\t\t\t//自分より上について調べる\n\t\t\tfor(int j=i-1;j>-1;j--)\n\t\t\t{\n\t\t\t\tif(contain(ban[i],ban[j]))\n\t\t\t\t{\n\t\t\t\t\tbool f=true;\n\t\t\t\t\tfor(int k=0;k<g[j].size();k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int l=0;l<rg[i].size();l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(g[j][k].to==rg[i][l].to)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(f)\n\t\t\t\t\t{\n\t\t\t\t\t\trg[i].push_back(Edge(j,1));\n\t\t\t\t\t\tg[j].push_back(Edge(i,1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//input end\n\t\tfill(dp,dp+(1<<24),-1);\n\t\t\n\t\tcout<<access(0,n)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <deque>\n#include <vector>\n#include <numeric>\n#include <iterator>\n#include <array>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\n\n\n#define FF first\n#define SS second\n#define ALL(c) begin((c)), end((c))\n#define REP(i,n) for(ll i=0;i<(ll)n;++i)\ninline int getInt() { int s; scanf(\"%d\", &s); return s; }\n/*\n#define SIZE 500000\nvector<ll> table(SIZE);\n\n\n\nvoid sieve_of_eratosthenes() {\n\tiota(ALL(table), 0);\n\tfor (int i = 2; i < SIZE; ++i)\n\t\ttable[i] = i;\n\tfor (int i = 2; i*i < SIZE; ++i)\n\tif (table[i])\n\tfor (int j = i*i; j < SIZE; j += i)\n\t\ttable[j] = 0;\n}*/\n\n/*\ntypedef array<array<int, 10>, 10> Table;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nvoid dd(Table &state, int from, int to) {\n\tif (from==to) return;\n\tvector<pair<int,int>> stack;\n\tstack.emplace_back(1,1);\n\twhile (!stack.empty()) {\n\t\tauto p = stack.back();\n\t\tstack.pop_back();\n\t\tint x = p.FF;\n\t\tint y = p.SS;\n\n\t\tREP(i, 4) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (state[ny][nx] == from) {\n\t\t\t\tstack.emplace_back(nx,ny);\n\t\t\t\tstate[ny][nx] = to;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint g_c;\n\nint cc(Table & state) {\n\tvector<pair<int, int>> stack;\n\tstack.emplace_back(1, 1);\n\tint cnt = 0;\n\twhile (!stack.empty()) {\n\t\tauto p = stack.back();\n\t\tstack.pop_back();\n\t\tint x = p.FF;\n\t\tint y = p.SS;\n\n\t\tREP(i, 4) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (state[ny][nx] == g_c) {\n\t\t\t\tstack.emplace_back(nx, ny);\n\t\t\t\tcnt++;\n\t\t\t\tstate[ny][nx] = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint walk(int depth, Table state) {\n\tif (depth == 5) {\n\t\tTable ntable = state;\n\t\tntable[1][1] = g_c;\n\t\tdd(ntable, state[1][1], g_c);\n\t\treturn cc(ntable);\n\t}\n\tint cnt = 1;\n\tREP(i, 6) {\n\t\tTable ntable = state;\n\t\tntable[1][1] = i;\n\t\tdd(ntable, state[1][1], i); //色変\n\t\tcnt = max(walk(depth+1, ntable),cnt);\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tfreopen(\"Text.txt\", \"r\", stdin);\n\n\n\twhile (true) {\n\t\tll h,w;\n\t\tcin >> h >> w >> g_c;\n\t\tif (h == 0) break;\n\t\tg_c--;\n\t\tTable table;\n\t\tREP(y, 10) REP(x, 10) table[y][x] = -1;\n\t\tREP(y, h) REP(x, w) {\n\t\t\tcin >> table[y + 1][x + 1];\n\t\t\ttable[y + 1][x + 1]--;\n\t\t}\n\n\t\tcout << walk(1, table) << endl;\n\t}\n}\n*/\nstruct circle{\n\tll id,x,y,r;\n};\n\nvector<circle> g_table[4];\n\n\nint main() {\n\twhile (true) {\n\t\tll n;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\tarray<bool,4> active;\n\t\tactive.fill(true);\n\n\t\tREP(c, 4) g_table[c].clear();\n\t\tREP(i, n){\n\t\t\tint x,y,r,c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tg_table[c - 1].push_back(circle{i,x,y,r});\n\t\t}\n\n\t\tvector<int> removableColor;\n\t\tdo{\n\t\t\twhile (!removableColor.empty()) {\n\t\t\t\tactive[removableColor.back()] = false;\n\t\t\t\tremovableColor.pop_back();\n\t\t\t}\n\n\t\t\tarray<vector<circle>,4> tops;\n\t\t\tREP(c1, 4) for (auto it1 = g_table[c1].begin(); it1 != g_table[c1].end(); ++it1) {\n\t\t\t\tif(!active[c1]) continue;\n\t\t\t\tbool top = true;\n\t\t\t\tREP(c2, 4) for (auto it2 = g_table[c2].begin(); it2 != g_table[c2].end(); ++it2) {\n\t\t\t\t\tif (!active[c2]) continue;\n\t\t\t\t\tif (c1==c2 && it1 == it2) continue;\n\t\t\t\t\tint xx = (it1->x - it2->x);\n\t\t\t\t\tint yy = (it1->y - it2->y);\n\t\t\t\t\tint rr = (it1->r + it2->r);\n\t\t\t\t\tif (xx*xx + yy*yy < rr*rr && it1->id > it2->id) {\n\t\t\t\t\t\ttop = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (top) tops[c1].push_back(*it1);\n\t\t\t}\n\n\t\t\tREP(c,4) if ((!g_table[c].empty()) && tops[c].size() == g_table[c].size()) removableColor.push_back(c);\n\t\t} while (!removableColor.empty());\n\n\t\tint count = 0;\n\t\tREP(c, 4) if (!active[c]) count += g_table[c].size();\n\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circ{\n  vector<int> chil;\n  int useless;\n  bool done;\n};\nvoid Init();\nvoid Tree();\nint Solve();\ncirc BO[50];\ndouble P[50][3];\nvector< vector<int> > color(4); \nint n;\nint main(){\n  while(cin >>n,n){\n    Init();\n    for(int i=0,c; i<n; i++){\n      cin >>P[i][0]>>P[i][1]>>P[i][2]>>c;\n      color[c-1].push_back(i);\n    }\n    Tree();\n    cout <<Solve()<<endl;\n  }\n  return 0;\n}\nvoid Init(){\n  for(int i=0; i<4; i++) color[i].clear();\n  for(int i=0; i<50; i++){\n    BO[i].done = false;\n    BO[i].useless = 0;\n    BO[i].chil.clear();\n    P[i][0] = P[i][1] = P[i][2] = 0;\n  }\n}\nvoid Tree(){\n  for(int i=0; i<n; i++){\n    for(int j=i+1; j<n; j++){\n      double dx = P[i][0]-P[j][0];\n      double dy = P[i][1]-P[j][1];\n      double rr = P[i][2]+P[j][2];\n      if(dx*dx+dy*dy<rr*rr){\n\tBO[i].chil.push_back(j);\n\tBO[j].useless++;\n      }\n    }\n  }\n}\nint Solve(){\n  int ans = 0;\n  for(int i=0; i<4; i++){\n    for(int ii=0; ii<color[i].size(); ii++){\n      for(int jj=ii+1; jj<color[i].size(); jj++){\n\tint a = color[i][ii];\n\tint b = color[i][jj];\n\tif(BO[a].useless || BO[b].useless) continue;\n\tif(BO[a].done || BO[b].done) continue;\n\tBO[a].done = BO[b].done = true;\n\tfor(int j=0; j<BO[a].chil.size(); j++) BO[BO[a].chil[j]].useless--;\n\tfor(int j=0; j<BO[b].chil.size(); j++) BO[BO[b].chil[j]].useless--;\n\tint ANS = Solve()+2;\n\tif(ans<ANS) ans = ANS;\n\tBO[a].done = BO[b].done = false;\n\tfor(int j=0; j<BO[a].chil.size(); j++) BO[BO[a].chil[j]].useless++;\n\tfor(int j=0; j<BO[b].chil.size(); j++) BO[BO[b].chil[j]].useless++;\n      }\n    }\n  }\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint x[100], y[100], r[100], c[100], n;\nqueue<int>Q; bool p[1 << 24];\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < (1 << 24); i++)p[i] = false;\n\t\tcin >> n; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++)cin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\tQ.push((1 << n) - 1); int maxn = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tint bit[24]; int a = Q.front(); Q.pop();\n\t\t\tfor (int i = 0; i < 24; i++)bit[i] = (a / (1 << i)) % 2;\n\t\t\tint cnt = 0; for (int i = 0; i < 24; i++)cnt += bit[i];\n\t\t\tmaxn = max(maxn, n - cnt); int d[24];\n\t\t\tfor (int i = 0; i < 24; i++)d[i] = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (bit[i] == 0)continue;\n\t\t\t\td[i] = 1;\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (bit[j] == 0)continue;\n\t\t\t\t\tint dist = (x[i] - x[j])*(x[i] - x[j]);\n\t\t\t\t\tdist += (y[i] - y[j])*(y[i] - y[j]);\n\t\t\t\t\tif (dist < (r[i] + r[j])*(r[i] + r[j]))d[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (d[i] == 0 || d[j] == 0)continue;\n\t\t\t\t\tif (c[i] == c[j]) {\n\t\t\t\t\t\tint v = a - (1 << i) - (1 << j);\n\t\t\t\t\t\tif (p[v] == true)continue;\n\t\t\t\t\t\tQ.push(v); p[v] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//9:55\n//10:15\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#define SQR(X) ((X)*(X))\n\nusing namespace std;\n\nmap<int,int> dp;\nint x[24],y[24],r[24],c[24];\n\nint rem(int n,int s){\n  if(dp.find(s)!=dp.end())return dp[s];\n  bool under[24]={};\n  for(int i=0;i<n;i++){\n    if((s&(1<<i))==0){\n      for(int j=i+1;j<n;j++){\n\tif(SQR(x[i]-x[j])+SQR(y[i]-y[j])<SQR(r[i]+r[j])){\n\t  under[j]=true;\n\t}\n      }\n    }\n  }\n  int mr=0;\n  for(int i=0;i<n;i++){\n    if(((s&(1<<i))==0)&&!under[i]){\n      for(int j=i+1;j<n;j++){\n\tif(((s&(1<<j))==0)&&!under[j]&&c[i]==c[j]){\n\t  mr=max(mr,rem(n,s|(1<<i)|(1<<j))+2);\n\t}\n      }\n    }\n  }\n  dp[s]=mr;\n  return mr;\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    dp.clear();\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n    }\n    cout<<rem(n,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint n,x[30],y[30],r[30],c[30],cover[30];\nchar dp[1<<24];\nvector<pii> same_col;\n\nint rec(int bit){\n  if(dp[bit])return dp[bit];\n\n  int res = 0;\n  for(int i=0;i<(int)same_col.size();i++){\n    const int a = same_col[i].first, b = same_col[i].second;\n    if( (~bit)&(1<<a) && (~bit)&(1<<b) ){\n      if( (~bit)&cover[a] || (~bit)&cover[b])continue;\n      res = max(res, rec(bit | (1<<a) | (1<<b))+2);\n    }\n  }\n  return dp[bit]=res;\n}\n  \nint main(){\n  while(cin >> n, n){\n    for(int i=0;i<n;i++)cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n    same_col.clear();\n    for(int i=0;i<n;i++){\n      cover[i] = 0;\n      for(int j=0;j<i;j++){\n\tif( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j])*(r[i]+r[j]) ){\n\t  cover[i] |= 1<<j;\n\t}\n\tif(c[i] == c[j])same_col.push_back(pii(i,j));\n      }\n    }\n\n    memset(dp,0,sizeof(dp));\n    cout << rec(0) << endl;\n  }\t  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint n, ans = 0;\nint x[25], y[25], r[25], c[25];\n\nbool overlap(int i, int j){\n    return (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j]) * (r[i]+r[j]);\n}\n\nvoid dfs(VI f){\n    int res = 0;\n    REP(i,n) res += f[i];\n    ans = max(ans, res);\n\n    VI top(n);\n    REP(i,n){\n        if (f[i]) continue;\n        bool g = 1;\n        REP(j,i){\n            if (f[j]) continue;\n            if (overlap(i,j)) g = 0;\n        }\n        top[i] = g;\n    }\n\n    REP(i,n) REP(j,i){\n        if (!top[i] || !top[j] || c[i] != c[j]) continue;\n        f[i] = f[j] = 1;\n        dfs(f);\n        f[i] = f[j] = 0;\n    }\n}\n\nint main() {\n    while (cin >> n && n){\n        VI f(n);\n        REP(i,n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n        dfs(f);\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circ{\n  vector<int> chil;\n  int useless;\n  bool done;\n  int color;\n};\nvoid Init();\nvoid Tree();\nint Solve();\ncirc BO[50];\ndouble P[50][3];\nint n;\nint main(){\n  while(cin >>n,n){\n    Init();\n    for(int i=0; i<n; i++) cin >>P[i][0]>>P[i][1]>>P[i][2]>>BO[i].color;\n    Tree();\n    cout <<Solve()<<endl;\n  }\n  return 0;\n}\nvoid Init(){\n  for(int i=0; i<50; i++){\n    BO[i].done = false;\n    BO[i].useless = 0;\n    BO[i].chil.clear();\n    P[i][0] = P[i][1] = P[i][2] = 0;\n  }\n}\nvoid Tree(){\n  for(int i=0; i<n; i++){\n    for(int j=i+1; j<n; j++){\n      double dx = P[i][0]-P[j][0];\n      double dy = P[i][1]-P[j][1];\n      double rr = P[i][2]+P[j][2];\n      if(dx*dx+dy*dy<rr*rr){\n\tBO[i].chil.push_back(j);\n\tBO[j].useless++;\n      }\n    }\n  }\n}\nint Solve(){\n  int ans = 0;\n  for(int i=0; i<n; i++){\n    for(int j=i+1; j<n; j++){\n      if(BO[i].useless || BO[j].useless) continue;\n      if(BO[i].color != BO[j].color) continue;\n      if(BO[i].done || BO[j].done) continue;\n      BO[i].done = BO[j].done = true;\n      for(int k=0; k<BO[i].chil.size(); k++) BO[BO[i].chil[k]].useless--;\n      for(int k=0; k<BO[j].chil.size(); k++) BO[BO[j].chil[k]].useless--;\n      int ANS = Solve()+2;\n      if(ans<ANS) ans = ANS;\n      BO[i].done = BO[j].done = false;\n      for(int k=0; k<BO[i].chil.size(); k++) BO[BO[i].chil[k]].useless++;\n      for(int k=0; k<BO[j].chil.size(); k++) BO[BO[j].chil[k]].useless++;\n    }\n  }\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define REP(i,a) rep((i),0,(a))\nusing namespace std;\n//global\n\nstruct Data{\n\tint x, y,r;\n\tint c;\n};\nData data[24];\nbool dp[1024 * 1024 * 16];\nint min_num;\nint N;\nbool double_check(int i, int j){\n\tint dx, dy, dr;\n\tdx = data[j].x - data[i].x;\n\tdy = data[j].y - data[i].y;\n\tdr = data[j].r + data[i].r;\n\t//printf(\"[%d,%d]%d,%d,%d\\n\", i, j, dx, dy, dr);\n\tif ((dx*dx + dy*dy)<(dr*dr))return(true);\n\telse return(false);\n}\n\nvoid printbit(int x){\n\tREP(i, N){\n\t\tif ((x >> (N - i-1)) & 1)cout << 1;\n\t\telse cout<<0;\n\t}\n\tcout << endl;\n\n\n}\nvoid solve(int num, int rest){\n\t/*cout << \"rest\"<<endl;\n\tprintbit(rest);*/\n\tif (min_num > num)min_num = num;\n\tif (num <= 1)return;\n\tif (dp[rest])return;\n\tdp[rest] = true;\n\tint color[4] = { 0 }, index[4] = { 0 };\n\tREP(i, N){\n\t\tint bit = (1 << i);\n\t\tif ((rest&bit) > 0){\n\t\t\tbool f = true;\n\t\t\trep(j,0,i)if((rest&(1<<j))>0)\n\t\t\tif (double_check(i, j)){\n\t\t\t\tf = false; continue;\n\t\t\t}\n\t\t\tif (f){\n\t\t\t\tcolor[data[i].c] += bit;\n\t\t\t\tindex[data[i].c]++;\n\t\t\t}\n\t\t}\n\t}\n\t//rep(i, 0, 4){printf(\"%d,\",index[i]);printbit(color[i]);}\n\t/*rep(i, 0, 4)\n\tif (index[i]>=2)\n\tif (!(index[i] & 1)){\n\t\tsolve(num - index[i], rest - color[i]);\n\t}\n\telse{\n\t\tint p = 1;\n\t\trep(j, 0, index[j]){\n\t\t\twhile (!(p & 1))p <<= 1;\n\t\t\tsolve(num - index[i] + 1, rest - color[i] + p);\n\n\t\t}\n*/\n\trep(i, 0, 4)\n\tif (index[i] >= 2){\n\t\tint p = 1;\n\t\trep(j, 0, index[i] - 1){\n\t\t\twhile ((p&color[i]) ==0)p<<=1;\n\t\t\tint pt = p<<1;\n\t\t\trep(k, j + 1, index[i])\n\t\t\t{\n\t\t\t\twhile ((pt&color[i])==0)pt <<= 1;\n\t\t\t\tint sub = p + pt;\n\t\t\t\t/*cout << \"sub\" << endl;\n\t\t\t\tprintbit(sub);*/\n\t\t\t\tsolve(num - 2, rest - sub);\n\t\t\t\tpt <<= 1;\n\t\t\t}\n\t\t\tp <<=1;\n\t\t}\n\t}\n\n\t//cout << \"return\" << endl;\n}\n\n\n\nint main(void){\n\twhile (true){\n\t\tcin >> N;\n\t\tif (N == 0)return(0);\n\t\tmin_num = N;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tREP(i, N){\n\t\t\tcin >> data[i].x >> data[i].y >> data[i].r>>data[i].c;\n\t\t\tdata[i].c--;\n\t\t}\n\t\tsolve(N, (1 << N) - 1);\n\t\tcout << N - min_num << endl;\n\t}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\ntypedef double D;\nconst D EPS = 1e-8;\n\nstruct P {\n    D x, y;\n    P(D x_, D y_) : x(x_), y(y_) { }\n    P() {}\n};\n\ninline P operator -(const P& a, const P& b) { return P(a.x - b.x, a.y - b.y); }\ninline D inp(const P& a, const P' b) { return a.x*b.x + a.y*b.y; }\ninline D norm(const P& p) { return inp(p, p); }\ninline D abs(const P& p) { return sqrt(norm(p)); }\n\nstruct C {\n    P p; D r;\n    C(P p_, D r_) : p(p_), r(r_) { }\n    C() { }\n};\n\ninline bool iCC(const C& a, const C& b) {\n    D d = abs(a.p - b.p);\n    return (a.r + b.r)  - EPS > d;\n}\n\nint bit_count(unsigned int b) {\n    return __builtin_popcount(b);\n}\n\nint bit_right(unsigned int b) {\n    return __builtin_ctz(b);\n}\n\nint bit_left(unsigned int b) {\n    return 31 - __builtin_clz(b);\n}\n\nint N;\nvector<int> color;\nvector<C> circle;\nvector<char> ok;\nint num;\nint ans;\n\n\nvoid solve() {\n    vector<vector<int> > v(4, vector<int>());\n    for(int i = 0; i < N; i++) {\n        if(ok[i]) {\n            bool fr = true;\n            for(int j = i + 1; j < N; j++) {\n                if(ok[j]) {\n                    if(iCC(circle[i], circle[j])) {\n                        fr = false;\n                        break;\n                    }\n                }\n            }\n            if(fr) {\n                v[color[i]].push_back(i);\n            }\n        }\n    }\n#if 0\n    for(int i = 0; i < 4; i++) {\n        cerr << \"color \" << i << \": \";\n        for(int j = 0; j < (int)v[i].size(); j++) {\n            cerr << v[i][j] << \" \";\n        }\n        cerr << endl;\n    }\n#endif\n    for(int i = 0; i < 4; i++) {\n        if(v[i].size() >= 2) {\n            for(int b = 0; b < (1 << v[i].size()); b++) {\n                if(bit_count(b) == 2) {\n                    int n = v[i][bit_right(b)];\n                    int m = v[i][bit_left(b)];\n                    ok[n] = 0;\n                    ok[m] = 0;\n                    num -= 2;\n                    ans = max(ans, N - num);\n                    solve();\n                    ok[n] = 1;\n                    ok[m] = 1;\n                    num += 2;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    for(; cin >> N, N; ) {\n        color = vector<int>(N);\n        circle = vector<C>(N);\n        ok = vector<char>(N, 1);\n        num = N;\n        ans = 0;\n        for(int i = 0; i < N; i++) {\n            cin >> circle[i].p.x >> circle[i].p.y >> circle[i].r >> color[i];\n            color[i]--;\n        }\n        reverse(circle.begin(), circle.end());\n        reverse(color.begin(), color.end());\n        solve();\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\n\nconst int MAX = 24;\nint n;\nint x[MAX], y[MAX], r[MAX], c[MAX];\nbool under[MAX];\nshort memo[1 << MAX];\n\nshort dfs(int rest) {\n\tif(memo[rest] >= 0)\n\t\treturn memo[rest];\n\n\tint can = rest;\n\tfor(int i = 0; i < n; ++i)\n\t\tcan &= ~under[i];\n\n\tint res = 0;\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(can & (1 << i)) {\n\t\t\tconst int tmp = rest & (~(1 << i));\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tif(c[i] == c[j] && (can & (1 << j))) {\n\t\t\t\t\tconst int next = tmp & (~(1 << j));\n\t\t\t\t\tchmax(res, dfs(next) + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn memo[rest] = res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\n\t\tmemset(under, 0, sizeof(under));\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tfor(int j = i + 1; j < n; ++j)\n\t\t\t\tif(hypot(x[i] - x[j], y[i] - y[j]) <= r[i] + r[j])\n\t\t\t\t\tunder[i] |= (1 << j);\n\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tcout << dfs((1 << n) - 1) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\n#define For(i,a,b)  for(int i = a;i < b;i++)\n#define rep(i,n)\tFor(i,0,n)\n#define all(n)\t\tn.begin(),n.end()\n\n//(x + a)^2 + (y + b)^2 <= c\n\nstruct Circle{\n\tint x, y, r;\n\tint c;\n\tCircle(){};\n\tCircle(int x, int y, int r, int c) :x(x), y(y), r(r), c(c){}\n\tint inter(Circle cl){\n\t\tint tx = cl.x, ty = cl.y;\n\t\tint t = (x - tx)*(x - tx) + (y - ty)*(y - ty);\n\t\tint R = (r + cl.r)*(r + cl.r);\n\t\tif (t < R)return 1;\n\t\tif (t >= R)return 0;\n\t}\n};\n\nint n;\nvector<Circle> v;\n\nint dfs(vector<bool> cf){\n\n\tvector<int> tv[5];\n\trep(i, n)if(!cf[i]){\n\t\tbool tf = true;\n\t\tFor(j,i+1, n)if(!cf[j]){\n\t\t\tif (v[i].inter(v[j]) == 1){\n\t\t\t\ttf = false;\n\t\t\t}\n\t\t}\n\t\tif (tf){\n\t\t\ttv[v[i].c].push_back(i);\n\t\t}\n\t}\n\n\tint ret = 0;\n\tbool f = false;\n\n\trep(i, 5){\n\t\tif (tv[i].size() >= 2){\n\t\t\trep(j, tv[i].size()){\n\t\t\t\tFor(k, j + 1, tv[i].size()){\n\t\t\t\t\t auto tf = cf;\n\n\t\t\t\t\trep(l, v.size()){\n\t\t\t\t\t\tif (tv[i][j] == l || tv[i][k] == l)\n\t\t\t\t\t\t\ttf[l] = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tret = max(ret, dfs(tf));\n\t\t\t\t}\n\t\t\t}\n\t\t\tf = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!f){\n\t\tint cnt = 0;\n\t\trep(i, n){\n\t\t\tif (cf[i]){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\t\n\treturn ret;\n}\n\n\nint main()\n{\n\n\twhile (cin >> n && n){\n\t\trep(i, n){\n\t\t\tint x, y, r, c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tv.push_back(Circle(x, y, r, c));\n\t\t}\n\n\t\treverse(all(v));\n\n\t\tvector<bool> cf(n+1,0);\n\t\tcout << dfs(cf) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef unsigned int uint;\ntypedef vector<int> VI;\ntypedef vector<double> VD;\ntypedef vector<vector<int> > VV;\n \nconst int INF = 1 << 28;\nconst double EPS = 1e-9;\n \nint n;\nVV par;\nVD x, y, r;\nVI c;\nmap<int,int> m;\n \nstring toString (int era) {\n    string str;\n    for (int i = 0; i < n; i++) {\n        str = (era % 2 ? \"1\" : \"0\") + str;\n    }\n \n    return str;\n}\n \nint dfs (int era) {\n    if (era == ((1 << n) - 1)) return 0;\n    int cera = ((1 << n) - 1) ^ era;\n    if (m.find(era) != m.end()) {\n        return m[era];\n    }\n     \n    VV count(5);\n    rep (i,n) {\n        bool flag = true;\n        if (era & (1 << i)) continue; \n        rep(j,par[i].size()) {\n            if (cera & (1 << par[i][j])) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            count[c[i]].push_back(i);\n        }\n    }\n \n    int ret = 0;\n    REP(i,1,5) {\n        if (count[i].size() >= 2) {\n            rep(j,count[i].size()-1) REP(k,j+1,count[i].size()) {\n                int tera = era;\n                tera |= (1 << count[i][j]);\n                tera |= (1 << count[i][k]);\n                ret = max(ret, dfs(tera) + 2);\n            }\n        }\n    }\n \n    return m[era] = ret;\n}\n \nint main()\n{\n    while (cin >> n, n) {\n        x.resize(n), y.resize(n), r.resize(n), c.resize(n);\n        m.clear();\n         \n        rep(i, n) {\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n         \n        par.clear();\n        par.resize(n);\n        rep(i,n) rep(j,i) {\n            double dis = pow(x[i] - x[j], 2.) + pow(y[i] - y[j], 2.);\n            if (sqrt(dis) < r[i] + r[j]) {\n                par[i].push_back(j);\n            }\n        }\n \n        cout << dfs(0) << endl;\n    }\n                 \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nstruct Solver\n{\n\tconst int N;\n\tVI xs, ys, rs, cs;\n\n\tint res;\n\n\tSolver( int n ) : N( n ), xs( N ), ys( N ), rs( N ), cs( N ), res( 0 )\n\t{\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tcin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n\t\t}\n\t\treturn;\n\t}\n\n\toperator int()\n\t{\n\t\tdfs( vector<bool>( N, true ) );\n\t\treturn res;\n\t}\n\n\tvoid dfs( vector<bool> exists )\n\t{\n\t\tres = max<int>( res, count( ALL( exists ), false ) );\n\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tREP( j, 0, i )\n\t\t\t{\n\t\t\t\tif ( !exists[i] || !exists[j] || cs[i] != cs[j] )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( !overlapped( exists, i ) && !overlapped( exists, j ) )\n\t\t\t\t{\n\t\t\t\t\texists[i] = exists[j] = false;\n\t\t\t\t\tdfs( exists );\n\t\t\t\t\texists[i] = exists[j] = true;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\tbool overlapped( const vector<bool> &exists, const int p )\n\t{\n\t\tREP( i, 0, p )\n\t\t{\n\t\t\tif ( !exists[i] )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( ( xs[p] - xs[i] ) * ( xs[p] - xs[i] ) + ( ys[p] - ys[i] ) * ( ys[p] - ys[i] ) < ( rs[i] + rs[p] ) * ( rs[i] + rs[p] ) )\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int n; cin >> n, n; )\n\t{\n\t\tcout << Solver( n ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24], y[24], r[24], c[24];\n\nint dist(int x, int y) {\n\treturn x * x + y * y;\n}\n\nchar dp[1 << 24];\n\nint dfs(int S) {\n\tif (dp[S] != -1) return dp[S];\n\tvector<int> ng(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif ((S & (1 << i)) || (S & (1 << j))) continue;\n\t\t\tif (dist(x[i] - x[j], y[i] - y[j]) < (r[i] + r[j]) * (r[i] + r[j])) {\n\t\t\t\tng[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif ((S & (1 << i)) == 0 && (S & (1 << j)) == 0 && !ng[i] && !ng[j] && c[i] == c[j]) {\n\t\t\t\tres = max(res, 2 + dfs(S | (1 << i) | (1 << j)));\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[S] = res;\n}\n\nint main()\n{\n\twhile (cin >> n, n) {\n\t\tfill(dp, dp + (1 << 24), -1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tcout << dfs(0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nstruct Node{\n\tint x;\n\tint y;\n\tint r;\n\tint c;\n\tint rm;\n};\nstruct Node nodes[100];\nchar memo[20000000];\n\n\nint recur(int bit){\n\tint id[N];\n\tint len = 0;\n\tif(memo[bit] != -1){\n\t\treturn memo[bit];\n\t}\n\n\tfor(int i = 0; i< N; i++){\n\t\tif(bit & (1 << i)){\n\t\t\tint x = nodes[i].x;\n\t\t\tint y = nodes[i].y;\n\t\t\tint r = nodes[i].r;\n\t\t\tint flg = 1;\n\t\t\tfor(int j = 0; j < i; j++){\n\t\t\t\tif(bit & (1 << j)){\n\t\t\t\t\tint xx = x - nodes[j].x;\n\t\t\t\t\tint yy = y - nodes[j].y;\n\t\t\t\t\tint rr = r + nodes[j].r;\n\t\t\t\t\tif(xx * xx + yy * yy < rr * rr){\n\t\t\t\t\t\tflg = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg) id[len++] = i;\n\t\t}\n\t}\n\n\tint ret = 0;\n\tfor(int i = 0; i < len; i++){\n\t\tfor(int j = i + 1; j < len; j++){\n\t\t\tint id1 = id[i];\n\t\t\tint id2 = id[j];\n\t\t\tif(nodes[id1].c == nodes[id2].c){\n\t\t\t\tint nb = bit;\n\t\t\t\t\n\t\t\t\tnb = nb & ~(1 << id1);\n\t\t\t\tnb = nb & ~(1 << id2);\n\t\t\t\tret = max(ret, recur(nb) + 2);\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[bit] = ret;\n}\n\nint main(){\n\twhile(cin >> N, N){\n\t\tfor(int i = 0; i < 20000000; i++){\n\t\t\tmemo[i] = -1;\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint x, y, r, c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tnodes[i].x = x;\n\t\t\tnodes[i].y = y;\n\t\t\tnodes[i].r = r;\n\t\t\tnodes[i].c = c;\n\t\t\tnodes[i].rm = 1;\n\t\t}\n\t\tint bit = 0;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tbit = (bit << 1) | 1;\n\t\t}\n\t\tcout << recur(bit) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nstruct C {\n    P p;\n    R r;\n    C() {}\n    C(P p, R r) : p(p), r(r) {}\n};\nconst int MN = 24;\n\nint n;\nbool g[MN][MN];\nint col[MN];\n\n\nint dp[1<<MN];\n\nint calc(int m) {\n    if (dp[m] != -1) return dp[m];\n    int ma = 0;\n    bool can[MN];\n    for (int i = 0; i < n; i++) {\n        can[i] = true;\n        for (int j = 0; j < i; j++) {\n            if (m & (1<<j)) continue;\n            if (g[i][j]) {\n                can[i] = false;\n                break;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            if (col[i] != col[j]) continue;\n            if (m & (1<<i)) continue;\n            if (m & (1<<j)) continue;\n            if (!can[i]) continue;\n            if (!can[j]) continue;\n            ma = max(ma, 2+calc(m | (1<<i) | (1<<j)));\n        }\n    }\n    return dp[m] = ma;\n}\n\nbool solve() {\n    cin >> n;\n    if (!n) return false;\n    C c[MN];\n\n    for (int i = 0; i < n; i++) {\n        R x, y, r;\n        cin >> x >> y >> r >> col[i];\n        c[i] = C(P(x, y), r);\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            g[i][j] = (abs(c[i].p - c[j].p) < c[i].r+c[j].r);\n        }\n    }\n    memset(dp, -1, sizeof(dp));\n    cout << calc(0) << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define x first.first\n#define y first.second\n#define r second.first\n#define color second.second\n\nusing namespace std;\n\ntypedef pair<double,double> P;\ntypedef pair<P,P> C;\n\nbool check(C a,C b){\n  return a.r+b.r>sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n \nint count(int bits){\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits =(((bits >> 4) + bits) & 0x0f0f0f0f);\n  bits += bits >> 8;\n  return (bits + (bits >> 16)) & 0xff;\n}\n \nbool dp[(1<<25)];\n \nint main(void){\n \n\tint n;\n\twhile(cin >> n,n){\n\t\tC c[25];\n\t\tfor(int i=0;i<n;i++){\n\t\t\t//cin >> c[i].x >> c[i].y >> c[i].r >> c[i].color;\n\t\t\tscanf(\"%lf %lf %lf %lf\",&c[i].x,&c[i].y,&c[i].r,&c[i].color);\n\t\t}\n\t\t\n\t\tfill(dp,dp+(1<<n),false);\n\t\tdp[(1<<n)-1]=true;\n\t\tint ans=0;\n\t\t\n\t\tfor(int S=(1<<n)-1;S>=0;S--){\n\t\t\tif(!dp[S])continue;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\t\n\t\t\t\t\tint nx=S;\n\t\t\t\t\tnx&=~(1<<i);\n\t\t\t\t\tnx&=~(1<<j);\n\t\t\t\t\tif(dp[nx])continue;\n\t\t\t\t\t\n\t\t\t\t\tif(!(S>>i&1) || !(S>>j&1))continue;\n\t\t\t\t\tif(c[i].color!=c[j].color)continue;\n\t\t\t\t\t\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(!(S>>k&1))continue;\n\t\t\t\t\t\tif((k<i && check(c[i],c[k]))||(k<j && check(c[j],c[k])))goto end;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdp[nx]|=dp[S];\n\t\t\t\t\tend:;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp[S])ans=max(ans,n-count(S));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\nint x[24], y[24], r[24], c[24];\n\nint dp[(1 << 24) + 1];\n\nbool intersect(int i, int j)\n{\n    return (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) < (r[i] + r[j]) * (r[i] + r[j]);\n}\n\nbool is_select(int i, int s)\n{\n    for (int j = 0; j < i; ++j)\n        if (!(s & (1 << j)))\n            if (intersect(i, j))\n                return false;\n    return true;\n}\n\nint rec(int s)\n{\n    if (s == (1 << n) - 1)\n        return 0;\n\n    if (dp[s] != -1)\n        return dp[s];\n\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        if (s & (1 << i))\n            continue;\n        if (!is_select(i, s))\n            continue;\n\n        for (int j = i + 1; j < n; ++j) {\n            if (s & (1 << j))\n                continue;\n            if (!is_select(j, s))\n                continue;\n\n            if (c[i] != c[j])\n                continue;\n\n            ans = max(ans, rec(s | (1 << i) | (1 << j)) + 2);\n        }\n    }\n    return dp[s] = ans;\n}\n\nint main()\n{\n    for (;;) {\n        scanf(\"%d\", &n);\n        if (n == 0)\n            break;\n\n        for (int i = 0; i < n; ++i)\n            scanf(\"%d %d %d %d\", &x[i], &y[i], &r[i], &c[i]);\n\n        fill(dp, dp + (1 << 24) + 1, -1);\n        int ans = rec(0);\n        printf(\"%d\\n\", ans);\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define REP(i,a) rep((i),0,(a))\nusing namespace std;\n//global\n\nstruct Data{\n\tint x, y,r;\n\tint c;\n};\nData data[24];\nbool dp[1024 * 1024 * 16];\nint min_num;\nint N;\nbool double_check(int i, int j){\n\tint dx, dy, dr;\n\tdx = data[j].x - data[i].x;\n\tdy = data[j].y - data[i].y;\n\tdr = data[j].r + data[i].r;\n\t//printf(\"[%d,%d]%d,%d,%d\\n\", i, j, dx, dy, dr);\n\tif ((dx*dx + dy*dy)<(dr*dr))return(true);\n\telse return(false);\n}\n\nvoid printbit(int x){\n\tREP(i, N){\n\t\tif ((x >> (N - i-1)) & 1)cout << 1;\n\t\telse cout<<0;\n\t}\n\tcout << endl;\n\n\n}\nvoid solve(int num, int rest){\n\t//cout << rest<<endl;\n\t//printbit(rest);\n\tif (min_num > num)min_num = num;\n\tif (num <= 1)return;\n\tif (dp[rest])return;\n\tdp[rest] = true;\n\tint color[4] = { 0 }, index[4] = { 0 };\n\tREP(i, N){\n\t\tint bit = (1 << i);\n\t\tif ((rest&bit) > 0){\n\t\t\tbool f = true;\n\t\t\trep(j,0,i)if((rest&(1<<j))>0)\n\t\t\tif (double_check(i, j)){\n\t\t\t\tf = false; continue;\n\t\t\t}\n\t\t\tif (f){\n\t\t\t\tcolor[data[i].c] += bit;\n\t\t\t\tindex[data[i].c]++;\n\t\t\t}\n\t\t}\n\t}\n\t//rep(i, 0, 4){printf(\"%d,\",index[i]);printbit(color[i]);}\n\trep(i, 0, 4)\n\tif (index[i]>=2)\n\tif (!(index[i] & 1)){\n\t\tsolve(num - index[i], rest - color[i]);\n\t}\n\telse{\n\t\tint p = 1;\n\t\trep(j, 0, index[j]){\n\t\t\twhile (!(p & 1))p <<= 1;\n\t\t\tsolve(num - index[i] + 1, rest - color[i] + p);\n\n\t\t}\n\n\n\n\t}\n\n\n}\n\n\n\nint main(void){\n\twhile (true){\n\t\tcin >> N;\n\t\tif (N == 0)return(0);\n\t\tmin_num = N;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tREP(i, N){\n\t\t\tcin >> data[i].x >> data[i].y >> data[i].r>>data[i].c;\n\t\t\tdata[i].c--;\n\t\t}\n\t\tsolve(N, (1 << N) - 1);\n\t\tcout << N - min_num << endl;\n\t}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n\nlong long  mod = 1000000007;\n\n\nbool lap[30][30];\n\n\nbool overlap(int i,int j,vector<int> &x,vector<int>&y,vector<int> &r){\n\tint k = 0;\n\tk = (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]);\n\tif(k>= (r[i]+r[j])*(r[i]+r[j]))return 0;\n\treturn 1;\n}\n\n\nint main(){\n\tint n;\n\twhile(cin >> n && n!=0){\n\t\tset<int>st,st2;\n\t\tvector<int>x(n),y(n),r(n),c(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tfor(int i=0;i<30;i++){\n\t\t\tfor(int j=0;j<30;j++){\n\t\t\t\tlap[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(overlap(i,j,x,y,r)==1){\n\t\t\t\t\tlap[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tbool flag = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\tif(lap[i][j]==0){\n\t\t\t\t\t\tfor(int k=i+1;k<j;k++){\n\t\t\t\t\t\t\tif(lap[i][k]&&lap[k][j]){\n\t\t\t\t\t\t\t\tlap[i][j]=1;\n\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)break;\n\t\t}\n\t\t/*for(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tcout << i <<  \" \" << j << \" \" << lap[i][j] << endl;\n\t\t\t}\n\t\t}*/\n\n\t\tst.insert((1<<n)-1);\n\t\tst2.insert((1<<n)-1);\n\t\twhile(1){\n\t\t\tbool flag = 1;\n\t\t\tset<int> st3;\n\t\t\tfor(auto s:st2){\n\t\t\t\t/*int k = 0;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(s&(1<<i)){\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << k << \" \" << static_cast<bitset<24>>(s) << endl;*/\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\t\tif(c[i]==c[j]){\n\t\t\t\t\t\t\tif((s&(1<<i))&&(s&(1<<j))){\n\t\t\t\t\t\t\t\tbool fl =1;\n\t\t\t\t\t\t\t\tfor(int p=0;p<i;p++){\n\t\t\t\t\t\t\t\t\tif(lap[p][i]==1&&(s&(1<<p)))fl = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int p=0;p<j;p++){\n\t\t\t\t\t\t\t\t\tif(lap[p][j]==1&&(s&(1<<p)))fl = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(fl){\n\t\t\t\t\t\t\t\t\tif(st.count(s-(1<<i)-(1<<j))==0){\n\t\t\t\t\t\t\t\t\t\tst.insert(s-(1<<i)-(1<<j));\n\t\t\t\t\t\t\t\t\t\tst3.insert(s-(1<<i)-(1<<j));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tst2 = st3;\n\t\t\tif(flag)break;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(auto s:st){\n\t\t\tint k = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(s&(1<<i)){\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans,n-k);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint sum=0,ds;\nint n;\nvoid rec(vector<circle> vs){\n  //cout << vs.size() << endl;\n  int i,j,k;\n  int f;\n  int on[30]={};\n  vector<int> cc[5];\n  f=1;\n  int ff=0;\n  while(ff==0){\n    ff=1;\n    for(i=0;i<30;i++) on[i]=0;\n    for(i=0;i<5;i++) cc[i].clear();\n    for(i=0;i<vs.size();i++){\n      for(j=i+1;j<vs.size();j++){\n\tif(ch(vs[i],vs[j])==1) on[j]=1;\n      }\n    }\n    for(i=0;i<vs.size();i++){\n      if(on[i]==0) cc[vs[i].c].push_back(i);\n    }\n    for(i=1;i<5;i++){\n      if(cc[i].size()>0&&cc[i].size()%2==0){\n\tfor(j=cc[i].size()-1;j>=0;j--){\n\t  vs.erase(vs.begin()+cc[i][j]);\n\t  ff=0;\n\t  f=0;\n\t}\n      }\n    }\n  }\n  for(i=1;i<5;i++){\n    //cout << cc[i].size() << endl;\n    if(cc[i].size()>=2&&cc[i].size()%2==1){\n      f=0;\n      vector<circle> next;\n      for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n      for(j=0;j<cc[i].size();j++){\n\tfor(k=cc[i].size()-1;k>=0;k--){\n\t  if(k!=j)\n\t    next.erase(next.begin()+cc[i][k]);\n\t}\n\trec(next);\n      }\n      break;\n    }\n  }\n  int o=n-vs.size();\n  if(f==1) sum=max(sum,o);\n  else{\n    vector<circle> next;\n    for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n    rec(next);\n  }\n}\n\nint main(){\n  cin >> n;\n  while(n!=0){\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    sum=0;\n    rec(v);\n    cout << sum << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circ{\n  vector<int> chil;\n  vector<int> par;\n  bool done;\n  bool useless;\n  int color;\n};\nvoid Init();\nvoid Tree();\nint Solve();\ncirc BO[50];\ndouble P[50][3];\nint n;\nint main(){\n  while(cin >>n,n){\n    Init();\n    for(int i=0; i<n; i++) cin >>P[i][0]>>P[i][1]>>P[i][2]>>BO[i].color;\n    Tree();\n    cout <<Solve()<<endl;\n  }\n  return 0;\n}\nvoid Init(){\n  for(int i=0; i<50; i++){\n    BO[i].done = false;\n    BO[i].useless = false;\n    BO[i].chil.clear();\n    BO[i].par.clear();\n    P[i][0] = P[i][1] = P[i][2] = 0;\n  }\n}\nvoid Tree(){\n  for(int i=0; i<n; i++){\n    for(int j=i+1; j<n; j++){\n      double dx = P[i][0]-P[j][0];\n      double dy = P[i][1]-P[j][1];\n      double rr = P[i][2]+P[j][2];\n      if(dx*dx+dy*dy<rr*rr){\n\tBO[i].chil.push_back(j);\n\tBO[j].par.push_back(i);\n\tBO[j].useless = true;\n      }\n    }\n  }\n}\nint Solve(){\n  int ans = 0;\n  for(int i=0; i<n; i++){\n    for(int j=i+1; j<n; j++){\n      if(BO[i].useless || BO[j].useless) continue;\n      if(BO[i].color != BO[j].color) continue;\n      if(BO[i].done || BO[j].done) continue;\n      BO[i].done = BO[j].done = true;\n      for(int k=0; k<BO[i].chil.size(); k++){\n\tfor(int l=0; l<BO[BO[i].chil[k]].par.size(); l++){\n\t  if(!BO[BO[BO[i].chil[k]].par[l]].done) break;\n\t  if(l == BO[BO[i].chil[k]].par.size()-1) BO[BO[i].chil[k]].useless = false;\n\t}\n      }\n      for(int k=0; k<BO[j].chil.size(); k++){\n\tfor(int l=0; l<BO[BO[j].chil[k]].par.size(); l++){\n\t  if(!BO[BO[BO[j].chil[k]].par[l]].done) break;\n\t  if(l == BO[BO[j].chil[k]].par.size()-1) BO[BO[j].chil[k]].useless = false;\n\t}\n      }\n      int ANS = Solve()+2;\n      if(ans<ANS) ans = ANS;\n      BO[i].done = BO[j].done = false;\n      for(int k=0; k<BO[i].chil.size(); k++) BO[BO[i].chil[k]].useless = true;\n      for(int k=0; k<BO[j].chil.size(); k++) BO[BO[j].chil[k]].useless = true;\n    }\n  }\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nint n, S[24];\nint x[24],y[24],r[24],c[24];\nchar dp[1<<24];\nbool take[24];\n\n\ninline int sqr(int x){ return x*x; }\n\nint solve(int nowS){\n    int i,j,k;\n    int res = 0;\n    static const bool underFirst[] = {true, true, false};\n    static const bool underSecond[] = {true, false, true};\n\n\n    if( dp[nowS] != -1 ) return dp[nowS];\n\n    // 1. (円盤iの下に他の円盤がある,円盤jの下に他の円盤がある) の組み合わせ\n    // 2.1 円盤iの下に他の円盤がある,円盤jの下にはなにもない\n    // 2.2 円盤iの下にはなにもない,円盤jの下に他の円盤がある\n    \n    bool get = false;\n    for(k=0; k<3; k++){\n        for(i=0; i<n; i++){\n            if( (S[i] == (nowS & S[i])) && !(nowS & (1<<i)) && (take[i] == underFirst[k]) ) {\n                for(j=i+1; j<n; j++){\n                    if( (S[j] == (nowS & S[j])) && c[i] == c[j] && !(nowS & (1<<j)) && (take[j] == underSecond[k]) ){\n                        res = max(res, solve(nowS | (1<<i) | (1<<j)) + 2);\n                        get = true;\n                    }\n                }\n            }\n        }\n    }\n\n    // 3. 円盤iの下にはなにもない,円盤jの下にもなにもない(取れるだけ取る)\n    int sum = 0;\n    if( !get ){\n        bool used[24];\n        memset(used, false, sizeof(used));\n        for(i=0; i<n; i++){\n            if( !used[i] && (S[i] == (nowS & S[i])) && !(nowS & (1<<i)) && (take[i] == false) ) {\n                for(j=i+1; j<n; j++){\n                    if( !used[j] && (S[j] == (nowS & S[j])) && c[i] == c[j] && !(nowS & (1<<j)) && (take[j] == false) ){\n                        sum += 2;\n                        used[i] = used[j] = true;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    return dp[nowS] = res + sum;\n}\n\n\nint main(){\n    int i,j;\n\n    while( cin >> n, n ){\n        // init\n        memset(S, 0, sizeof(S));\n        memset(take, false, sizeof(take));\n        memset(dp, -1, sizeof(dp));\n\n        // input\n        for(i=0; i<n; i++) cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n        // フィルターを作る\n        for(i=0; i<n; i++){\n            for(j=0; j<i; j++){\n                if( sqr(x[i] - x[j]) + sqr(y[i] - y[j]) < sqr(r[i] + r[j]) ){\n                    S[i] |= 1<<j;\n\n                    // 円盤jの下にある円盤があるかどうか\n                    take[j] = true;\n                }\n            }\n        }\n        cout << solve(0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint n;\nVI xs, ys, rs, cs;\nVVI grp;\n\nbool is_top(int i, int used) {\n\tfor (int j = i - 1; j >= 0; j--) {\n\t\tif (1 << j & used) continue;\n\n\t\tint x = (xs[i] - xs[j]) * (xs[i] - xs[j]);\n\t\tint y = (ys[i] - ys[j]) * (ys[i] - ys[j]);\n\t\tint dis = x + y;\n\t\tint dis2 = (rs[i] + rs[j]) * (rs[i] + rs[j]);\n\n\t\tif (dis < dis2) {\t// 重なってる\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main(void) {\n\twhile(cin >> n, n){\n\t\txs = VI(n);\n\t\tys = VI(n);\n\t\trs = VI(n);\n\t\tcs = VI(n);\n\t\tgrp = VVI(n);\n\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n\t\t\tcs[i]--;\n\t\t\tgrp[cs[i]].push_back(i);\n\t\t}\n\n\t\t//\n\n\t\tvector<queue<PII>> ps(2);\n\t\tps[0].push(make_pair(0, 0));\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint cur = i % 2;\n\t\t\tint next = (i + 1) % 2;\n\n\t\t\tps[next] = queue<PII>();\n\n\t\t\twhile (ps[cur].size()) {\n\t\t\t\tPII p = ps[cur].front();\n\t\t\t\tint used = p.fst;\n\t\t\t\tint sum = p.snd;\n\n\t\t\t\tps[cur].pop();\n\n\t\t\t\t// 同じ色の円盤はいくつか\n\t\t\t\tVI can_pop;\n\t\t\t\tfor (auto j : grp[cs[i]]) {\n\t\t\t\t\tif (!(1 << j & used) && is_top(j, used)) {\n\t\t\t\t\t\tcan_pop.push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint cnt = can_pop.size();\n\n\t\t\t\tif (cnt >= 2 && !(cnt % 2)) { // 偶数なら全部とれる\n\t\t\t\t\tint next_used = used;\n\t\t\t\t\tfor (auto j : can_pop) {\n\t\t\t\t\t\tnext_used |= 1 << j;\n\t\t\t\t\t}\n\t\t\t\t\tps[next].push(make_pair(next_used, sum + cnt));\n\t\t\t\t} else if (cnt > 2) { // 奇数ならどれか取れる\n\t\t\t\t\t for (auto j : can_pop) {\n\t\t\t\t\t\t if (i != j) {\n\t\t\t\t\t\t\t int next_used = used | (1 << j);\n\t\t\t\t\t\t\t ps[next].push(make_pair(next_used, sum + 2));\n\t\t\t\t\t\t }\n\t\t\t\t\t }\n\t\t\t\t} else {\n\t\t\t\t\tps[next].push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\n\t\twhile (ps[n % 2].size()) {\n\t\t\tPII p = ps[n % 2].front();\n\t\t\tans = max(ans, p.snd);\n\t\t\tps[n % 2].pop();\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n\nint DP[1<<24];//LSB???i=0?????????\n\nint main(){\n    int n;\n    int X[24];\n    int Y[24];\n    int R[24];\n    int C[24];\n    int cover[24];//???????????????????????????\n    while(cin>>n,n){\n        for(int i=0;i<n;i++){\n            cin>>X[i]>>Y[i]>>R[i]>>C[i];            \n        }\n        fill(cover,cover+24,0);\n        for(int i=0;i<n;i++){//i???j???????????????????????????\n            for(int j=i+1;j<n;j++){\n                if(hypot(X[i]-X[j],Y[i]-Y[j])<R[i]+R[j]){\n                    cover[j]|=1<<i;\n                }\n            }\n        }\n        fill(DP,DP+(1<<24),0);\n        for(int E=0;E<(1<<n);E++){\n            for(int i=0;i<n;i++){\n                if((E&(1<<i))==0) continue;\n                for(int j=i+1;j<n;j++){\n                    if((E&(1<<j))==0) continue;\n                    if(cover[j]&E) continue;\n                    if(C[i]==C[j]) DP[E]=max(DP[E^(1<<i)^(1<<j)]+2,DP[E]);\n                }\n            }\n        }\n        cout<<DP[(1<<n)-1]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = a.r * a.r + 2 * a.r * b.r + b.r * b.r;\n    return r > (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\nint main()\n{\n    int n;\n\n    while (cin >> n, n) {\n        const int N = 1 << n;\n        vector<char> dp(N, -1), up(n, 0);\n        vector<Circle> c(n);\n\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j) {\n                if (isOverlap(c[i], c[j])) {\n                    if (i < j) // jの上にiがある\n                        up[j] |= (1 << i);\n                    else // iの上にjがある\n                        up[i] |= (1 << j);\n                }\n            }\n\n        int res = 0;\n        dp[N - 1] = 0;\n        for (int s = N - 1; s >= 0; --s) {\n            if (dp[s] == -1)\n                continue;\n\n            res = max(res, (int)dp[s]);\n            for (int i = 0; i < n; ++i) {\n                if (!(s >> i & 1) || (s & up[i])) // c[i]が置かれていないかc[i]が取り除けない\n                    continue;\n\n                for (int j = i + 1; j < n; ++j) {\n                    if (c[i].c != c[j].c) // 色が異なる\n                        continue;\n                    if (!(s >> j & 1) || (s & up[j]))// c[j]が置かれていないかc[j]が取り除けない\n                        continue;\n\n                    int nxt = (s & ~(1 << i)) & ~(1 << j);\n                    dp[nxt] = max((int)dp[nxt], dp[s] + 2);\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct circle{\n  double x, y, r;\n  int c;\n  unordered_set<int> up, down;\n};\n\nvoid calcOverlap(int n, circle *disk){\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      int x = disk[i].x - disk[j].x, y = disk[i].y - disk[j].y;\n      if(sqrt(x*x + y*y) + 1e-8< disk[i].r + disk[j].r){\n        disk[j].up.insert(i);\n        disk[i].down.insert(j);\n      }\n    }\n  }\n}\n\nbool canRemove(circle d, circle dd){\n  if(d.c != dd.c)return false;\n  if(not d.up.empty() or\n     not dd.up.empty())return false;\n  return true;\n}\n\nint dfs(int n, circle *disk, bool *removed, int dep = 0){\n  int res = 0;\n  bool f = false;\n  for (int i = 0; i < n; i++) {\n    if(removed[i] == true)continue;\n    for (int j = i + 1; j < n; j++) {\n      if(removed[j] == true)continue;\n      if(not canRemove(disk[i], disk[j]))continue;\n      f = true;\n      removed[i] = true;\n      removed[j] = true;\n      vector<int> erase_i, erase_j;\n      for (int k = 0; k < n; k++) {\n        if(disk[k].up.find(i) != disk[k].up.end()){\n          disk[k].up.erase(i);\n          erase_i.push_back(k);\n        }\n        if(disk[k].up.find(j) != disk[k].up.end()){\n          disk[k].up.erase(j);\n          erase_j.push_back(j);\n        }\n      }\n      res = max(res, dfs(n, disk, removed, dep + 1));\n      for (int k = 0; k < erase_j.size(); k++) {\n        disk[erase_j[k]].up.insert(j);\n      }\n      for (int k = 0; k < erase_i.size(); k++) {\n        disk[erase_i[k]].up.insert(i);\n      }\n      removed[i] = false;\n      removed[j] = false;\n    }\n  }\n  return f?res:dep;\n}\n\nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n, n){\n    circle disk[n];\n    for (int i = 0; i < n; i++) {\n      cin >> disk[i].x >> disk[i].y >> disk[i].r >> disk[i].c;\n    }\n    bool removed[n];\n    memset(removed, false, sizeof(removed));\n    calcOverlap(n, disk);\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        if(not canRemove(disk[i], disk[j]))continue;\n        if(not disk[i].down.empty() or\n           not disk[j].down.empty())continue;\n        removed[i] = true;\n        removed[j] = true;\n        ans++;\n      }\n    }\n    std::cout << 2*(ans + dfs(n, disk, removed)) << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstruct Disc {\n  int x, y, r, c;\n};\n\nconst int MAX_N = 24;\nint N;\nDisc D[MAX_N];\nint on[MAX_N];\nint T[1<<MAX_N];\n\nint isIntersect(const Disc &a, const Disc &b) {\n  int dx = a.x - b.x;\n  int dy = a.y - b.y;\n  int sr = a.r + b.r;\n  if(dx*dx+dy*dy == sr*sr) return 1;\n  if(dx*dx+dy*dy < sr*sr) return 2;\n  return 0;\n}\n\nint make() {\n  for(int i = 0; i < N; ++i) {\n    on[i] = 0;\n    for(int j = i-1; j >= 0; --j) {\n      if(isIntersect(D[i], D[j]) == 2) on[i] |= 1<<j;\n    }\n  }\n}\n\nint rec(int S) {\n  int &res = T[S];\n  if(res == -1) {\n    res = 0;\n    for(int i = 0; i < N; ++i) {\n      if(S & (1<<i)) continue;\n      if((S & on[i]) != on[i]) continue;\n      for(int j = i+1; j < N; ++j) {\n\tif(S & (1<<j)) continue;\n\tif((S & on[j]) != on[j]) continue;\n\n\tif(D[i].c != D[j].c) continue;\n\tres = max(res, rec(S | (1<<i) | (1<<j))+2);\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i) {\n      cin >> D[i].x >> D[i].y >> D[i].r >> D[i].c;\n    }\n    make();\n    fill(T, T+(1<<N), -1);\n    cout << rec(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 24\nusing namespace std;\n\nint n,x[N],y[N],r[N],c[N],ans;\nbool dp[(1<<N)];\nvector<int> v[N];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n      for(int j=i-1;j>=0;j--){\n\tint X=x[i]-x[j];\n\tint Y=y[i]-y[j];\n\tint R=r[i]+r[j];\n\tif(X*X+Y*Y<R*R)v[i].push_back(j);\n      }\n    }\n    for(int i=0;i<(1<<n);i++)dp[i]=false;\n    dp[0]=true;\n    ans=0;\n    for(int i=0;i<(1<<n);i++){\n      if(!dp[i])continue;\n      ans=max(ans,__builtin_popcount(i));\n      for(int j=0;j<n;j++){\n\tif((i&(1<<j)))continue;\n\tint f=0;\n\tfor(int k=0;k<v[j].size();k++)\n\t  if(!(i&(1<<v[j][k])))f=1;\n\tif(f)continue;\n\tfor(int k=j+1;k<n;k++){\n\t  if(c[j]!=c[k])continue;\n\t  if((i&(1<<k)))continue;\n\t  f=0;\n\t  for(int l=0;l<v[k].size();l++)\n\t    if(!(i&(1<<v[k][l])))f=1;\n\t  if(f)continue;\n\t  dp[((i|(1<<j))|(1<<k))]=true;\n\t}\n      }\n    }\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++)v[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "nt n; //枚数\nint x[25],y[25],r[25],c[25]; //円盤\nint b[25]; //各円盤の上に重なっている円盤（ビット管理）\n\n//円盤iと円盤jが重なっているかの判定\nbool intersects(int i,int j){\n  int dist1 = pow(x[i]-x[j],2) + pow(y[i]-y[j],2);\n  int dist2 = pow(r[i]+r[j],2);\n\n  return dist2 > dist1;\n}\n\n//DP用\nchar dp[1<<24];\n\nint main(void){\n  while(scanf(\"%d\",&n),n){\n    rep(i,n){\n      scanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n\n      //円盤iの上に重なっている円盤を全て探す\n      b[i] = 0;\n      rep(j,i) if(intersects(i,j)) b[i] |= (1<<j);\n    }\n\n    int ans = 0;\n    int to = (1<<n);\n    memset(dp,-1,sizeof(dp));\n    dp[0] = 0;\n\n    rep(i,to){\n      if(dp[i] == -1) continue;\n\n      ans = max(ans,(int)dp[i]);\n\n      //消せる円盤のペア(j,k)を探す\n      rep(j,n-1){\n        //すでに円盤jは消えている or 円盤jの上の円盤が邪魔して消せない\n        if((i & (1<<j)) != 0 || (i & b[j]) != b[j]) continue;\n\n        REP(k,j+1,n){\n          //jとkの色が違う or すでに円盤kは消えている or 円盤kの上の円盤が邪魔\n          if(c[j] != c[k] || (i & (1<<k)) != 0 || (i & b[k]) != b[k]) continue;\n\n          int next = i | (1<<j) | (1<<k); //next = 円盤jとkを消した状態(ビット管理)\n          dp[next] = max((int)dp[next],dp[i]+2);\n        }\n      }\n    }\n\n    printf(\"%d\\n\",ans);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n\n\n#define FOR(i,x) for (__typeof (x.begin ()) i = x.begin (); i != x.end (); ++i)\n\n#define all(x) x.begin (), x.end ()\n#define vol(x) (int)x.size ()\n\n#define PB push_back\n#define MP make_pair\n\n#define X first\n#define Y second\n\n#define sqr(x) ((x) * (x))\n#define abs(x) (((x) > 0) ? (x) : (-(x))) \n#define lowbit(x) ((x) & (-(x)))\n\n\nusing namespace std;\n\n\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef double dbl;\n\n\nint const N_MAX = 50;\n\n\nint N, ans;\nint A [N_MAX], B [N_MAX], R [N_MAX], C [N_MAX];\nbool V [N_MAX];\n\nvector<int> O, Vy;\n\ninline bool check (int i, int j) {\n\tint x = A [i] - A [j], y = B [i] - B [j], r = R [i] + R [j];\n\t\n\treturn x * x + y * y >= r * r;\n}\n\ninline bool checkp (int x) {\n\tfor (int i = 1; i < x; ++i)\n\t\tif (!V [i] && !check (i, x))\n\t\t\treturn false;\n\treturn true;\n}\n\nint main () {\n\twhile (scanf (\"%d\", &N) != EOF && N > 0) {\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t\tscanf (\"%d%d%d%d\", &A [i], &B [i], &R [i], &C [i]);\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tfor (int t1 = 1; t1 <= 100; ++t1) {\n\t\t\tO.clear ();\n\t\t\tfor (int i = 1; i <= N; ++i)\n\t\t\t\tV [i] = false, O.PB (i);\n\t\t\t\n\t\t\tfor (int t2 = 1; t2 <= 10000; ++t2) {\n\t\t\t\trandom_shuffle (all (O));\n\t\t\t\t\n\t\t\t\tint x = O.front ();\n\t\t\t\t\n\t\t\t\tVy.clear ();\n\t\t\t\t\n\t\t\t\tfor (int i = 1; i < vol (O); ++i)\n\t\t\t\t\tif (C [x] == C [O [i]])\n\t\t\t\t\t\tVy.PB (O [i]);\n\t\t\t\t\n\t\t\t\tif (vol (Vy) == 0) continue;\n\t\t\t\t\n\t\t\t\trandom_shuffle (all (Vy));\n\t\t\t\t\n\t\t\t\tint y = Vy.front ();\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (checkp (x) && checkp (y)) {\n\t\t\t\t\tV [x] = V [y] = true;\n\t\t\t\t\t\n\t\t\t\t\tO.clear ();\n\t\t\t\t\tfor (int i = 1; i <= N; ++i)\n\t\t\t\t\t\tif (!V [i])\n\t\t\t\t\t\t\tO.PB (i);\n\t\t\t\t} else\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tans = max (ans, N - vol (O));\n\t\t}\n\t\t\n\t\tprintf (\"%d\\n\", ans);\n\t}\n\t\n\tfclose (stdin);\n\tfclose (stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst double eps = 1e-8;\n\ntemplate<typename T> inline T sqr(T x){return x * x;}\ntemplate<typename T> inline void chmax(T& t, T f){if(t < f)t = f;}\n\nstruct Circle : Point {\n    double r;\n    int c;\n    Circle(const Point &a, double r, int c):Point(a), r(r), c(c){}\n};\n\nint overlap(Circle &c1, Circle &c2){\n    if(sqr(c1.r + c2.r) < norm(c1 - c2))return 0;\n    if(abs(c1 - c2) + c1.r < c2.r + eps)return -1;\n    if(c2.r < c1.r && abs(c1 - c2) + c2.r < c1.r + eps)return 1;\n    if(abs(abs(c1 - c2) - c1.r - c2.r) < eps)return -2;\n    return 2;\n}\n\nint n;\nvector<Circle> disc;\nvector<int> mem;\n\nint dfs(vector<int>& indeg, int table){\n    if(mem[table] != -1)return mem[table];\n    int res = n - __builtin_popcount(table);\n    rep(i, n){\n        if(!(table >> i & 1) || indeg[i])continue;\n        for(int j=i+1; j<n; ++j){\n            if(!(table >> j & 1) || indeg[j] || disc[i].c != disc[j].c)continue;\n            vector<int> nxt(indeg);\n            rep(k, n)nxt[k] &= ~(1 << i | 1 << j);\n            chmax(res, dfs(nxt, table ^ 1 << i ^ 1 << j));\n        }\n    }\n    return mem[table] = res;\n}\n\nint solve(){\n    vector<int> indeg(n, 0);\n    rep(i, n)rep(j, i){\n        int chk = overlap(disc[i], disc[j]);\n        if(chk == 0 || chk == -2)continue;\n        rep(k, j)if(indeg[i] >> k & 1 && indeg[j] >> k & 1)indeg[i] ^= 1 << k;\n        indeg[i] |= 1 << j;\n    }\n    mem.assign(1<<n, -1);\n    return dfs(indeg, (1 << n) - 1);\n}\n\nint main(){\n    while(cin >> n, n){\n        disc.clear();\n        rep(i, n){\n            int x, y, r, c;\n            cin >> x >> y >> r >> c;\n            disc.emplace_back(Point(x, y), r, c);\n        }\n        cout << solve() << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 24;\nint n;\nint x[MAXN], y[MAXN], r[MAXN], c[MAXN], top[MAXN], dp[1<<MAXN];\n\nint main() {\n  while(cin >> n && n) {\n    for(int i = 0; i < n; ++i) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n    for(int i = 0; i < n; ++i) {\n      top[i] = 0;\n      for(int j = 0; j < i; ++j) {\n        if((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j])\n           < (r[i]+r[j])*(r[i]+r[j])) {\n          top[i] |= 1 << j;\n        }\n      }\n    }\n    memset(dp, 0, sizeof(dp));\n    dp[(1<<n)-1] = 1;\n    for(int b = (1<<n)-1; b >= 0; --b) {\n      if(!dp[b]) continue;\n      for(int i = 0; i < n; ++i) {\n        if(!(b>>i&1) || (b & top[i])) continue;\n        for(int j = i+1; j < n; ++j) {\n          if(!(b>>j&1) || (b & top[j]) || c[i] != c[j]) continue;\n          dp[b - (1<<i) - (1<<j)] = 1;\n        }\n      }\n    }\n    int res = n;\n    for(int b = 0; b < (1<<n); ++b) {\n      if(dp[b]) res = min(res, __builtin_popcount(b));\n    }\n    cout << n - res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint x[25],y[25],r[25],c[25];\n\nbool in(int i, int j){\n    double d = hypot(abs(x[i] - x[j]), abs(y[i] - y[j]));\n    //cout << i << \" \" << j << \" \" << d << endl;\n    if(d >= (r[i] + r[j]))return false;\n    return true;\n}\n\nint main(void) {\n    int i,j,k;\n    int n;\n    while(cin>>n, n){\n        rep(i,n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n        int ans = 0;\n\n        while(1){\n            rep(i,n)if(c[i] > 0){\n                bool ch = false;\n                //cout << i << endl;\n\n                loop(j,i+1,n)if(c[j] == c[i] && !in(i,j)){\n                    bool p = true;\n                    //cout << \"?  \" << i << \" \" << j << endl;\n                    rep(k,j)if(i != k && c[k] > 0){\n                        if(in(j,k)) p = false;\n                    }\n                    if(p){\n                        //cout << \"! \" << i << \" \" << j << endl;\n                        ch = true;\n                        c[j] = -1;\n                    }\n                }\n                if(ch){\n                    ans++;\n                    c[i] = -1;\n                    break;\n                }\n            }\n            if(i == n)break;\n        }\n\n        cout << ans * 2 << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n\nunordered_map<int,int> memo;\nint rec(int used, vector<vector<bool> > const & e, vector<int> const & c) {\n    if (memo.count(used)) return memo[used];\n    int n = e.size();\n    vector<int> top;\n    repeat (i,n) if (not (used & (1 << i))) {\n        bool ok = true;\n        repeat (j,i) if (not (used & (1 << j))) {\n            if (e[j][i]) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) top.push_back(i);\n    }\n    int result = 0;\n    repeat (ti,top.size()) {\n        int i = top[ti];\n        repeat (tj,ti) {\n            int j = top[tj];\n            if (c[i] == c[j]) {\n                result = max(result, rec(used ^ (1<<i) ^ (1<<j), e, c) + 2);\n            }\n        }\n    }\n    return memo[used] = result;\n}\nint solve(vector<vector<bool> > const & e, vector<int> const & c) {\n    memo.clear();\n    return rec(0, e, c);\n}\n\ntemplate <typename T>\nT sq(T x) { return x*x; }\nstruct circle_t { int x, y, r; };\nbool is_intersect(circle_t a, circle_t b) {\n    return sq(a.x - b.x) + sq(a.y - b.y) < sq(a.r + b.r);\n}\nint main() {\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        vector<circle_t> p(n);\n        vector<int> c(n);\n        repeat (i,n) {\n            cin >> p[i].x >> p[i].y >> p[i].r >> c[i];\n        }\n        vector<vector<bool> > e(n, vector<bool>(n));\n        repeat (i,n) {\n            repeat (j,i) {\n                if (is_intersect(p[i], p[j])) {\n                    e[i][j] = e[j][i] = true;\n                }\n            }\n        }\n        cout << solve(e, c) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\n\nclass state{\npublic:\n    P p;\n    double r;\n    int c;\n};\n\nbool onCircle(state a, state b){\n    return (abs(a.p-b.p) < a.r+b.r);\n}\n\nshort int a[1<<24];\nint n;\nstate v[24];\nint ans, over[24];\n\nvoid check(int pos){\n    int c = 0;\n    for(int i=0;i<n;i++){\n        if((pos & (1<<i)) == 0){\n            c |= over[i];\n            for(int j=i+1;j<n;j++){\n                if((pos & (1<<j)) == 0 && (c & (1<<j)) == 0 && v[i].c == v[j].c){\n                    int next = pos | (1<<i) | (1<<j);\n                    if(a[next] < a[pos] + 2){\n                        a[next] = a[pos] + 2;\n                        ans = max((short int)ans,a[next]);\n                        check(next);\n                    }\n                }\n                if((pos & (1<<j)) == 0) c |= over[j];\n            }\n        }\n    }\n}\n\nint main(){\n    while(cin >> n && n){\n        fill(over,over+n,0);\n        fill(a,a+(1<<n),0);\n        ans = 0;\n        for(int i=0;i<n;i++){\n            double x,y;\n            cin >> x >> y >> v[i].r >> v[i].c;\n            v[i].p = P(x,y);\n        }\n\n        for(int i=0;i<n;i++)\n            for(int j=0;j<n;j++)\n                if(onCircle(v[i],v[j]))\n                    over[i] |= (1<<j);\n\n        check(0);\n\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<map>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 24;\nconst double eps = 1e-10;\ntypedef complex<double> P;\nclass st{\npublic:\n  P a;\n  double r;\n  int color;\n  int id;\n  bool operator<(const st & a)const{\n    if (color != a.color)return color < a.color;\n    return id < a.id;\n  }\n};\n\nint over[N];\n\nint is_intersected_circle(P a,P b,double r1,double r2){\n  double d=abs(a-b);\n  if (d < eps && abs(r1-r2) < eps)return 3;\n  if (d+r2 < r1)return 0;\n  if (d+r1 < r2)return 1;\n  if (d > r1+r2) return 4;\n  if (abs((r1+r2)-d) < eps)return 4;\n  return 2;\n}\n\nvector<int> edge[N];\nint dp[(1<<N)];\nint colorstart[5];\n\nint search(int state,st *in,int n){\n  if (state == (1<<n))return 0;\n  int &ret = dp[state];\n  if (ret == -1){\n    ret=0;\n    //color1\n    rep(k,4){\n      REP(i,colorstart[k],colorstart[k+1]){\n        int now=in[i].id;\n        if (((1<<now)&state) != 0)continue;\n        if ((over[now]&state) == over[now]);\n        else continue;\n        REP(j,i+1,colorstart[k+1]){\n          int next=in[j].id;\n          if (((1<<next)&state) != 0)continue;\n          if ((over[next]&state) == over[next]);\n          else continue;\n          //cout <<\"remove \" << now <<\" \" << next << endl;\n          ret=max(ret,2+search(state|(1<<now)|(1<<next),in,n));\n        }\n      }\n    }\n  }\n  return ret;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    rep(i,(1<<n))dp[i]=-1;\n    rep(i,n)edge[i].clear();\n    st in[n];\n    rep(i,n){\n      cin>>in[i].a.real()>>in[i].a.imag()>>in[i].r>>in[i].color;\n      in[i].id=i;\n    }\n    sort(in,in+n);\n    rep(i,n){\n      rep(j,n){\n        if (in[i].id <= in[j].id)continue;\n        int tmp=is_intersected_circle(in[i].a,in[j].a,in[i].r,in[j].r);\n        if (tmp == 0 || tmp == 1 || tmp == 2 || tmp == 3){\n          edge[in[i].id].push_back(in[j].id);\n        }\n      }\n    }\n\n    rep(i,n){\n      int now=in[i].id;\n      over[now]=0;\n      rep(j,edge[now].size()){\n        int next=edge[now][j];\n        over[now]|=(1<<next);\n        //cout <<next << \" is over \" << now << endl;\n      }\n      //cout << now <<\" hoge \" << over[now] << endl;\n    }\n    rep(i,5)colorstart[i]=n;\n    rep(i,n){\n      colorstart[in[i].color-1]=min(colorstart[in[i].color-1],i);\n    }\n\n    //rep(i,5)cout << colorstart[i] << \" \";cout << endl;\n    cout << search(0,in,n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 24\n\nint N,x[MAX],y[MAX],r[MAX],c[MAX];\n\nint dist(int a,int b){\n    return pow(x[a]-x[b],2)+pow(y[a]-y[b],2);\n}\n\nbool check(int a,int b){\n    double d = dist(a,b);\n    return ((r[a]-r[b])*(r[a]-r[b]) < d &&\n            d < (r[a]+r[b])*(r[a]+r[b]));\n}\n\nbool check(int S,int a,int b){\n    bool c[2] = {};\n    for(int i = 0 ; i < N ; i++){\n        if(!c[0]){\n            if(i == a) c[0] = 1;\n            else if(check(a,i)) return 0;\n        }\n        if(!c[1]){\n            if(i == b) c[1] = 1;\n            else if(check(b,i)) return 0;\n        }\n    }\n    return 1;\n}\n\nint main(){\n    while(cin >> N, N){\n        for(int i = 0 ; i < N ; i++){\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n        vector<int> dp(1<<N,0);\n        for(int i = (1<<N)-1 ; i >= 0 ; i--){\n            for(int j = 0 ; j < N ; j++){\n                for(int k = j+1 ; k < N ; k++){\n                    if(c[j] != c[k]) continue;\n                    int S = i | (1<<j) | (1<<k);\n                    if(!check(i,j,k)) continue;\n                    dp[S] = max(dp[S],dp[i]+2);\n                }\n            }\n        }\n        cout << *max_element(dp.begin(),dp.end()) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\nconst double EPS = 1e-9;\n\nint main(void){\n    int n;\n    while(cin>>n, n){\n        VP p(n);\n        vector<double> r(n);\n        vector<int> c(n);\n        rep(i,n){\n            double x,y;\n            cin>>x>>y>>r[i]>>c[i];\n            p[i] = Point(x,y);\n        }\n\n        int cnt = 0;\n        vector<bool> is_front(n), selected(n);\n        while(1){\n            bool remove = false;\n            rep(i,n){\n                if(selected[i]) continue;\n                bool ok = true;\n                rep(j,i)if(!selected[j]){\n                    if(r[i]+r[j]> abs(p[i]-p[j])){\n                        ok = false;\n                    }\n                }\n                if(ok) is_front[i] = true;\n            }\n            rep(i,n)rep(j,i)if(!selected[i] && !selected[j]){\n                if(is_front[i] && is_front[j] && c[i]==c[j]){\n                    selected[i] = selected[j] = true;\n                    cnt += 2;\n                    remove = true;\n                }\n            }\n\n            if(!remove) break;\n        }\n        cout<<cnt<<endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nint N, X[24], Y[24], R[24], C[24];\nint no_coverd[24][1 << 26];\n\nbool isCoverd(int i, int j)\n{\n  int x = abs(X[i] - X[j]), y = abs(Y[i] - Y[j]), r = R[i] + R[j];\n  return ((x * x) + (y * y)) < (r * r);\n}\n\nbool noCoverd(int j, int s) {\n  for (int i = 0; i < j; i++)\n    if ( (s >> i & 1) && isCoverd(i, j))\n      return false;\n\n  return true;\n}\n\nchar memo[1 << 26];\nint dfs(int s)\n{\n  if (memo[s] != -1) {\n    return memo[s];\n  }\n  \n  int ans = 0;\n  for (int i = 0; i < N; i++) {\n    for (int j = i + 1; j < N; j++) {\n      if ( C[i] == C[j] && (s >> i & 1) && (s >> j & 1) &&\n           noCoverd(i, s) && noCoverd(j, s) ) {\n        ans = max(ans, dfs(s & ~(1 << i) & ~(1 << j)) + 2);\n      }\n    }\n  }\n  \n  return memo[s] = ans;\n}\n\n\nint main()\n{\n  while (cin >> N && N) {\n    for (int i = 0; i < N; i++) \n      cin >> X[i] >> Y[i] >> R[i] >> C[i];\n\n    memset(memo, -1, sizeof(memo));\n\n    cout << dfs((1 << N) - 1) << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n\n#define REP(i,a,n) for(i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n\nbool used[30];\nint x[30], y[30], r[30], c[30], over[30];\nint n;\nchar dp[1<<24];\n\nint sqr(int x){ return x*x; }\n\nint solve(int S){\n  int i,j, res = 0;\n\n  if( dp[S] != -1 ) return (int)dp[S];\n  \n  rep(i,n) if( !used[i] && ((S&over[i]) == over[i]) ){\n    REP(j,i+1,n) if( !used[j] && c[i] == c[j] && ((S&over[j]) == over[j]) ){\n      used[i] = used[j] = true;\n      //printf(\"(%d,%d), S=%d\\n\",i,j,S|(1<<i)|(1<<j));\n      res = max(res, solve(S|(1<<i)|(1<<j)) + 2);\n      used[i] = used[j] = false;\n    }\n  }\n  return dp[S] = res;\n}\n\nint main(){\n  int i,j;\n  \n  while( scanf(\"%d\",&n), n ){\n    memset(used, false, sizeof(used));\n    rep(i,1<<n) dp[i] = -1;\n    rep(i,n) scanf(\"%d %d %d %d\",x+i,y+i,r+i,c+i);\n\n    rep(i,n){\n      int S = 0;\n      rep(j,i){\n        if( sqr(x[i] - x[j]) + sqr(y[i] - y[j]) < sqr(r[i]) + 2*r[i]*r[j] + sqr(r[j]) ){\n          S |= 1<<j;\n        }\n      }\n      over[i] = S;\n    }\n\n    printf(\"%d\\n\",solve(0));\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\ntypedef pair < int , int > Pt;\nbool dp[1 << 24];\nPt pts[24];\nint n, r[24], c[24];\nconst int INF = 1 << 28;\nbool intersect( Pt a, Pt b, int r1, int r2){\n  return pow( a.first - b.first, 2) + pow( a.second - b.second, 2) < pow( r1 + r2, 2);\n}\n\nint isnocover( const int& bit, const int& idx ){\n  for(int i = 0 ; i < idx ; i++ ){\n    if( (bit >> i) & 1 && intersect( pts[i], pts[idx], r[i], r[idx])) return false;\n  }\n  return true;\n}\n\nint rec( int bit){\n  if(dp[bit]++) return -INF;\n  int ret = 0;\n  for(int i = 0 ; i < n ; i++ ){\n    if((bit >> i) & 1){\n      for(int j = i + 1 ; j < n ; j++ ){\n        if( (bit >> j) & 1 && c[i] == c[j] && isnocover( bit, i) && isnocover( bit, j)){\n          ret = max( ret, rec( bit & ~(1 << i) & ~(1 << j)) + 2);\n        }\n      }\n    }\n  }\n  return ret;\n}\nint main()\n{\n  while(cin >> n, n){\n    fill_n( dp, 1 << 24 , false);\n    for(int i = 0 ; i < n ; i++ ){\n      cin >> pts[i].first >> pts[i].second >> r[i] >> c[i];\n    }\n    cout << rec((1 << n) - 1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nstruct A {\n    double x;\n    double y;\n    double r;\n    int c;\n}a[30];\nchar dp[1<<25];\nint n;\ninline bool cover(int qq,int x) {\n    int i;\n    double tmp;\n    for(i=qq-1;i>=0;i--) {\n        if(((x>>i)&1)==0) continue;\n        tmp=(a[qq].x-a[i].x)*(a[qq].x-a[i].x)+(a[qq].y-a[i].y)*(a[qq].y-a[i].y);\n        if((a[qq].r+a[i].r)*(a[qq].r+a[i].r)>tmp) break;\n    }\n    return i!=-1;\n}\nchar maxnum(char x) {\n    if(dp[x]!=-1) return dp[x];\n    int i,j,k,tmp;\n    char ans=0,y;\n    for(i=0;i<n;i++) {\n        if(((x>>i)&1)==0) continue;\n        if(cover(i,x)) continue;\n        for(j=i+1;j<n;j++) {\n            if(((x>>j)&1)==0) continue;\n            if(a[i].c!=a[j].c) continue;\n            if(cover(j,x)) continue;\n            y=x-(1<<i)-(1<<j);\n            tmp=maxnum(y)+2;\n            if(ans<tmp) ans=tmp;\n        }\n    }\n    dp[x]=ans;\n    return ans;\n}\nint main() {\n    int i;\n    while(scanf(\"%d\",&n),n) {\n        for(i=0;i<n;i++) {\n            scanf(\"%d %d %d %d\",&a[i].x,&a[i].y,&a[i].r,&a[i].c);\n            dp[1<<i]=0;\n        }\n        for(i=0;i<(1<<n);i++)\n            dp[i]=-1;\n        dp[0]=0;\n        printf(\"%d\\n\",maxnum((1<<n)-1));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n \nusing namespace std;\n \nint n;\nint x[25], y[25], r[25], c[25], b[25];\nint dp[1<<24];\n \nbool chackOverLap(int i, int j){\n    int dist1 = pow(x[i]-x[j], 2) + pow(y[i]-y[j], 2);\n    int dist2 = pow(r[i]+r[j], 2);\n    return dist2 > dist1;\n}\n \nint main(void){\n    while(1){\n        cin >> n;\n        if(!n) break;\n        for(int i=0; i<n; i++){\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n            b[i] = 0;\n            for(int j=0; j<i; j++){\n                if(chackOverLap(i, j)) b[i] |= (1<<j);\n            }\n        }\n \n        int S = (1<<n);\n        fill(dp, dp+S, -1);\n        dp[0] = 0;\n \n        int ans = 0;\n        for(int i=0; i<S; i++){\n            if(dp[i] == -1) continue;\n            ans = max(ans, dp[i]);\n            for(int j=0; j<n-1;j ++){\n                if((i & (1<<j)) != 0 || (i & b[j]) != b[j]) continue;\n                for(int k=j+1; k<n; k++){\n                    if(c[j] != c[k] || (i & (1<<k)) != 0 || (i & b[k]) != b[k]) continue;\n                    int next = i | (1<<j) | (1<<k); \n                    dp[next] = max(dp[next], dp[i]+2);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nstruct Circle\n{\n\tint x,y,r,c,m;\n};\n\nint N;\nchar mem[1<<24];\nCircle s[24];\n\nint solve(int state)\n{\n\tif(mem[state]>=0)\n\t{\n\t\treturn mem[state];\n\t}\n\n\tvector<int> del[4];\n\tfor(int i=0; i<N; i++)\n\t{\n\t\tif(state & (1<<i))\n\t\t{\n\t\t\tif(state & s[i].m) continue;\n\t\t\tdel[s[i].c-1].push_back(i);\n\t\t}\n\t}\n\n\tint res=0;\n\n\tfor(int k=0;   k<4; k++)\n\tfor(int i=0;   i<del[k].size(); i++)\n\tfor(int j=i+1; j<del[k].size(); j++)\n\t{\n\t\tint newstate = state;\n\t\tnewstate &= ~(1<<del[k][i]);\n\t\tnewstate &= ~(1<<del[k][j]);\n\t\tres = max(res, solve(newstate)+2);\n\t}\n\n\tmem[state] = res;\n\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin>>N, N)\n\t{\n\t\tmemset(mem, -1, sizeof(mem));\n\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tcin>>s[i].x>>s[i].y>>s[i].r>>s[i].c;\n\t\t}\n\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\ts[i].m=0;\n\t\t\tfor(int j=0; j<i; j++)\n\t\t\t{\n\t\t\t\tint dx = s[i].x-s[j].x;\n\t\t\t\tint dy = s[i].y-s[j].y;\n\t\t\t\tint dr = s[i].r+s[j].r;\n\t\t\t\tif(dx*dx+dy*dy < dr*dr)\n\t\t\t\t{\n\t\t\t\t\ts[i].m |= 1<<j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << solve((1<<N)-1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define REP(i,a) rep((i),0,(a))\nusing namespace std;\n//global\n\nstruct Data{\n\tint x, y,r;\n\tint c;\n};\nData data[24];\nbool dp[1024 * 1024 * 16];\nint min_num;\nint N;\nbool double_check(int i, int j){\n\tint dx, dy, dr;\n\tdx = data[j].x - data[i].x;\n\tdy = data[j].y - data[i].y;\n\tdr = data[j].r + data[i].r;\n\t//printf(\"[%d,%d]%d,%d,%d\\n\", i, j, dx, dy, dr);\n\tif ((dx*dx + dy*dy)<(dr*dr))return(true);\n\telse return(false);\n}\n\nvoid printbit(int x){\n\tREP(i, N){\n\t\tif ((x >> (N - i-1)) & 1)cout << 1;\n\t\telse cout<<0;\n\t}\n\tcout << endl;\n\n\n}\nvoid solve(int num, int rest){\n\t//cout << \"rest\"<<endl;\n\t//printbit(rest);\n\tif (min_num > num)min_num = num;\n\tif (num <= 1)return;\n\tif (dp[rest])return;\n\tdp[rest] = true;\n\tint color[4] = { 0 }, index[4] = { 0 };\n\tREP(i, N){\n\t\tint bit = (1 << i);\n\t\tif ((rest&bit) > 0){\n\t\t\tbool f = true;\n\t\t\trep(j,0,i)if((rest&(1<<j))>0)\n\t\t\tif (double_check(i, j)){\n\t\t\t\tf = false; continue;\n\t\t\t}\n\t\t\tif (f){\n\t\t\t\tcolor[data[i].c] += bit;\n\t\t\t\tindex[data[i].c]++;\n\t\t\t}\n\t\t}\n\t}\n\t//rep(i, 0, 4){printf(\"%d,\",index[i]);printbit(color[i]);}\n\t/*rep(i, 0, 4)\n\tif (index[i]>=2)\n\tif (!(index[i] & 1)){\n\t\tsolve(num - index[i], rest - color[i]);\n\t}\n\telse{\n\t\tint p = 1;\n\t\trep(j, 0, index[j]){\n\t\t\twhile (!(p & 1))p <<= 1;\n\t\t\tsolve(num - index[i] + 1, rest - color[i] + p);\n\n\t\t}\n*/\n\trep(i, 0, 4)\n\tif (index[i] >= 2){\n\t\tint p = 1;\n\t\trep(j, 0, index[i] - 1){\n\t\t\twhile ((p&color[i]) ==0)p<<=1;\n\t\t\tint pt = p<<1;\n\t\t\trep(k, j + 1, index[i])\n\t\t\t{\n\t\t\t\twhile ((pt&color[i])==0)pt <<= 1;\n\t\t\t\tint sub = p + pt;\n\t\t\t\t//cout << \"sub\" << endl;\n\t\t//\t\tprintbit(sub);\n\t\t\t\tsolve(num - 2, rest - sub);\n\t\t\t}\n\t\t\tp <<=1;\n\t\t}\n\t}\n\n\t//cout << \"return\" << endl;\n}\n\n\n\nint main(void){\n\twhile (true){\n\t\tcin >> N;\n\t\tif (N == 0)return(0);\n\t\tmin_num = N;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tREP(i, N){\n\t\t\tcin >> data[i].x >> data[i].y >> data[i].r>>data[i].c;\n\t\t\tdata[i].c--;\n\t\t}\n\t\tsolve(N, (1 << N) - 1);\n\t\tcout << N - min_num << endl;\n\t}}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, x[26], y[26], r[26], col[26], b[26][26]; short dp[16777222];\nint solve(int bit) {\n\tif (dp[bit]) return dp[bit] - 1;\n\tint ret = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (col[i] != col[j]) continue;\n\t\t\tif (bit & (1 << i)) continue;\n\t\t\tif (bit & (1 << j)) continue;\n\t\t\tif ((bit & b[i][j]) == b[i][j]) {\n\t\t\t\tint res = solve(bit + (1 << i) + (1 << j));\n\t\t\t\tret = max(ret, res + 2);\n\t\t\t}\n\t\t}\n\t}\n\tdp[bit] = ret + 1;\n\treturn ret;\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i] >> r[i] >> col[i];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tb[i][j] = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tint disti = (x[k] - x[i]) * (x[k] - x[i]) + (y[k] - y[i]) * (y[k] - y[i]);\n\t\t\t\t\tint distj = (x[k] - x[j]) * (x[k] - x[j]) + (y[k] - y[j]) * (y[k] - y[j]);\n\t\t\t\t\tif (k < i && disti < (r[i] + r[k]) * (r[i] + r[k])) b[i][j] |= 1 << k;\n\t\t\t\t\tif (k < j && distj < (r[j] + r[k]) * (r[j] + r[k])) b[i][j] |= 1 << k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfill(dp, dp + (1 << n), 0);\n\t\tint ret = solve(0);\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[25], y[25], r[25], c[25];\nvector<int> onaji[4];\n\nbool ishogan(int i, int j){ // iがjの上か\n  return i < j && (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j])*(r[i]+r[j]);\n}\n\nunordered_map<bitset<24>, int > po;\n\nbool cantake(bitset<24> jotai, int num){\n  bool tmp = true;\n  for(int i=0;i<n;i++)if(jotai[i] && ishogan(i, num))tmp=false;\n  return tmp && jotai[num];\n}\n\nint dfs(bitset<24> jotai){\n  int ans = 0;\n  for(int iro=0;iro<4;iro++){\n    for(int i=0;i<onaji[iro].size();i++)for(int j=i+1;j<onaji[iro].size();j++){\n      if(cantake(jotai, onaji[iro][i]) && cantake(jotai, onaji[iro][j])){\n        jotai.reset(onaji[iro][i]);\n        jotai.reset(onaji[iro][j]);\n        if(po.find(jotai) != po.end()){\n          ans = max(ans, 2+po[jotai]);\n        }\n        else ans = max(ans, 2+dfs(jotai));\n        jotai.set(onaji[iro][i]);\n        jotai.set(onaji[iro][j]);\n      }\n    }\n  }\n  po[jotai] = ans;\n  return ans;\n}\n\nint main(){\n  while(1){\n    scanf(\"%d\", &n);\n    if(n==0)break;\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d%d%d\", &x[i], &y[i], &r[i], &c[i]);\n      c[i]--;\n    }\n    for(int i=0;i<4;i++)onaji[i] = vector<int>();\n    po = unordered_map<bitset<24>, int > ();\n\n    for(int i=0;i<n;i++){\n      onaji[c[i]].push_back(i);\n    }\nbitset<24> tmp;\nfor(int i=0;i<24;i++)tmp.set(i);\nprintf(\"%d\\n\", dfs(tmp));\n\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <fstream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct node {\n    int x,y,r,c;\n}c[30];\nint d[30][30];\nint r[30][30];\nbool cover[30];\nbool use[30];\nint ans,n;\nbool get[18000000*2];\nint mi[25];\n\nint getting()\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n\tsum += mi[i] * (!use[i]);\n    return sum;\n    \n}\n\nvoid cover_check()\n{\n    memset(cover,false,sizeof(cover));\n    for (int i = 1; i <= n; ++i) \n\tif (!use[i]) {\n\t    for (int j = 1; j < i; ++j) \n\t\tif (!use[j]) {\n\t\t    if (r[i][j] > d[i][j]) {\n\t\t\tcover[i] = true;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t}\n}\n\nvoid search(int now)\n{\n    int w = getting();\n    if (get[w]) return;\n    else get[w] = true;\n    \n    bool tmp[100];\n    for (int i = 1; i <= n; ++i)\n\ttmp[i] = cover[i];\n\n    for (int i = 1; i <= n; ++i)\n\tif (!use[i] && !cover[i]) {\n\t    for (int j = i + 1; j <= n; ++j) \n\t\tif (!use[j] && !cover[j] && c[i].c == c[j].c) {\n\t\t    use[i] = true;\n\t\t    use[j] = true;\n\t\t    ans = max(ans,now);\n\t\t    cover_check();\n\t\t    search(now+1);\n\t\t    use[i] = false;\n\t\t    use[j] = false;\n\t\t    if (ans * 2 == n) return;\n\t\t}\n\t}\n    for (int i = 1; i <= n; ++i)\n\tcover[i] = tmp[i];\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    \n    cin >> n;\n    mi[1] = 1;\n    for (int i = 2; i <= 24; ++i)\n\tmi[i] = mi[i-1] * 2;\n    while (n) {\n\tmemset(get,false,sizeof(get));\n\tans = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t    cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t    for (int j = 1; j <= n; ++j) {\n\t\td[i][j] = (c[i].x - c[j].x) * (c[i].x - c[j].x) + (c[i].y - c[j].y) * (c[i].y - c[j].y);\n\t\tr[i][j] = (c[i].r + c[j].r) * (c[i].r + c[j].r);\n\t    }\n\tmemset(use,false,sizeof(use));\n\tmemset(cover,false,sizeof(cover));\n\tcover_check();\n\n\tsearch(1);\n\t\n\tcout << ans * 2 << endl;\n\t\n\tcin >> n;\n    }\n    \n    return 0;\n}\n\n\n\n\n\n    /*\n    for (int col = 1; col <= 4; ++col) {\n\tfor (int i = 1; i <= n; ++i) \n\t    if (!use[i] && c[i].c == col && !cover[i]) {\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t    if (!use[j] && c[j].c == col && !cover[j]) {\n\t\t\t//cout << i << \" \" << j << \" \" << now << endl;\n\t\t\tuse[i] = true;\n\t\t\tuse[j] = true;\n\t\t\tans = max(ans,now);\n\t\t\tcover_check();\n\n\t\t\tsearch(now+1);\n\t\t\tuse[i] = false;\n\t\t\tuse[j] = false;\n\t\t    }\n\t    }\n    }\n    */"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\ntypedef pair < int , int > Pt;\nbool dp[1 << 24];\nPt pts[24];\nint n, r[24], c[24];\nint hoge[24];\nconst int INF = 1 << 28;\nbool intersect( Pt a, Pt b, int r1, int r2){\n  return pow( a.first - b.first, 2) + pow( a.second - b.second, 2) < pow( r1 + r2, 2);\n}\n\nint rec( int bit){\n  if(dp[bit]++) return -INF;\n  int ret = 0;\n  for(int i = 0 ; i < n ; i++ ){\n    if((bit >> i) & 1){\n      for(int j = i + 1 ; j < n ; j++ ){\n        if( (bit >> j) & 1 && c[i] == c[j] && !(bit & hoge[i] | hoge[j])){\n          ret = max( ret, rec( bit & ~(1 << i) & ~(1 << j)) + 2);\n        }\n      }\n    }\n  }\n  return ret;\n}\nint main()\n{\n  while(cin >> n, n){\n    fill_n( dp, 1 << 24 , false);\n    fill_n( hoge, 24 , 0);\n\n    for(int i = 0 ; i < n ; i++ ){\n      cin >> pts[i].first >> pts[i].second >> r[i] >> c[i];\n      for(int j = 0 ; j < i ; j++ ){\n        if(intersect(pts[i],pts[j],r[i],r[j])) hoge[i] |= 1 << j;\n      }\n    }\n    cout << rec((1 << n) - 1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint main(){\n  int n;\n  cin >> n;\n  while(n!=0){\n    int sum=0;\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    int f=0;\n    int on[30]={};\n    //int cc[5]={};\n    vector<int> cc[5];\n    while(f==0){\n      f=1;\n      /*\n      for(i=0;i<24;i++) on[i]=0;\n      for(i=0;i<v.size();i++){\n\tfor(j=i+1;j<v.size();j++){\n\t  if(ch(v[i],v[j])==1) on[j]=1;\n\t}\n      }\n      for(i=0;i<5;i++) cc[i]=0;\n      for(i=0;i<v.size();i++){\n\tif(on[i]==0) cc[v[i].c]++;\n      }\n      */\n      int ff=0;\n      //while(ff==0){\n\tff=1;\n\tfor(i=0;i<30;i++) on[i]=0;\n\tfor(i=0;i<v.size();i++){\n\t  for(j=i+1;j<v.size();j++){\n\t    if(ch(v[i],v[j])==1) on[j]=1;\n\t  }\n\t}\n\t\n\tfor(i=0;i<5;i++) cc[i].clear();\n\tfor(i=0;i<v.size();i++){\n\t  if(on[i]==0) cc[v[i].c].push_back(i);\n\t}\n\t\n\tfor(i=1;i<5;i++){\n\t  if(cc[i].size()>0&&cc[i].size()%2==0){\n\t    for(j=cc[i].size()-1;j>=0;j--){\n\t      v.erase(v.begin()+cc[i][j]);\n\t      ff=0;\n\t      f=0;\n\t    }\n\t  }\n\t}\n\t\n\t//}\n      \n      for(i=1;i<5;i++){\n\tk=0;\n\tfor(j=v.size()-1;j>=0;j--){\n\t  if(on[j]==0&&v[j].c==i){\n\t    if(cc[i].size()%2==1&&cc[i].size()<k) {\n\t      //cout << v[j].id << \" \";\n\t      v.erase(v.begin()+j);\n\t      k++;\n\t      f=0;\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout << n-v.size() << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,x[25],y[25],r[25],c[25],ans=0;\nbool memo[(1<<24)]={};\n\nbool check(int a,int b){\n  int dis=(x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);\n  if(((r[a]+r[b])*(r[a]+r[b]))<=dis)return false;\n  return true;\n} \n\nbool top(int now,int bits){\n  for(int i=0;i<now;i++){\n    if((bits>>i)%2 && check(i,now))return false;\n  }\n  return true;\n}\n\nvoid dfs(int bits,int sum){\n  ans=max(sum,ans);\n  //cout<<ans<<\" \"<<bits<<endl;\n  for(int i=0;i<n;i++){\n    if((bits>>i)%2 && top(i,bits)){\n      for(int j=i+1;j<n;j++){\n\tif(c[i]==c[j] && (bits>>j)%2 && top(j,bits)){\n\t  int nbits=bits-((1<<i)+(1<<j));\n\t  if(!memo[nbits]){\n\t    memo[nbits]=true;\n\t    dfs(nbits,sum+2);\n\t  }\n\t}\n      }\n    }\n  }\n  return;\n}\n\nint main()\n{\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    ans=0;\n    for(int i=0;i<(1<<24);i++)memo[i]=false;\n    memo[(1<<n)-1]=true;\n    dfs((1<<n)-1,0);\n    cout<<ans<<endl; \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<iomanip>\n#include<ctime>\n#include<cstring>\n#include<climits>\n#include<string>\n#include<vector>\n#include<map>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<stack>\n#include<deque>\n#include<list>\n#include<vector>\n#define LL long long\n/*\n#ifdef unix\n#define INT64 \"%lld\"\n#else\n#define INT64 \"%I64d\"\n#endif\n*/\nusing namespace std;\nint n,m,cnt,snt,K,times;\nLL oo=1000000007;\nstruct dic\n{\n\tint x,y,r;\n\tint c;\n}p[110];\nint num[110];\nint ans;\nbool vis[110];\nint dis(int x1,int y1,int x2,int y2)\n{\n\treturn (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n}\nbool cover(int pos)\n{\n\tfor (int i=1;i<pos;i++)\n\tif (!vis[i]&&dis(p[i].x,p[i].y,p[pos].x,p[pos].y)<(p[i].r+p[pos].r)*(p[i].r+p[pos].r)) \n\treturn true;\n\treturn false;\n}\nvoid dfs(int x,int y)\n{\n\tans=max(ans,y);\n\tint cc=0;\n\tfor (int k=1;k<=6;k++)\n\t{\n\t\tint snt=0;\n\t\tfor (int i=1;i<=n;i++)\n\t\tif ((!vis[i])&&p[i].c==k&&(!cover(i))) snt++;\n\t\tif (snt>=2) \n\t\t{\n\t\t\tcc=k;break;\n\t\t}\n\t}\n\tif (cc==0) \n\t{\n\t\treturn;\n\t}\n\t//dic q[10];\n\tint num[20];\n\tint m=0;\n\tfor (int i=1;i<=n;i++)\n\tif ((!vis[i])&&p[i].c==cc&&(!cover(i))) \n\t{\n\t\tm++;\n//\t\tq[m]=p[i];\n\t\tnum[m]=i;\n\t}\n\tif  (m%2==0)\n\t{\n\t\tfor (int i=1;i<=m;i++) vis[num[i]]=true;\n\t\tdfs(x+1,y+m);\n\t\tfor (int i=1;i<=m;i++) vis[num[i]]=false;\n\t}\n\telse \n\t{\n\t\tint pp=m/2;\n\t\tfor (int i=1;i<=m;i++)\n\t\t{\n\t\t\tfor (int j=1;j<=m;j++) if (j!=i) vis[num[j]]=true;\n\t\t\tdfs(x+1,y+pp*2);\n\t\t\tfor (int j=1;j<=m;j++) if (j!=i) vis[num[j]]=false;\n\t\t}\n\t}\n}\nvoid work()\n{\n\tmemset(p,0,sizeof(p));\n\tfor (int i=1;i<=n;i++)\n\tscanf(\"%d%d%d%d\",&p[i].x,&p[i].y,&p[i].r,&p[i].c);\n\tmemset(vis,0,sizeof(vis));\n\tans=0;\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\twhile (n!=0)\n\t{\n\t\twork();\n\t\tscanf(\"%d\",&n);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n\n\nstruct cir{\n    int x,y,r,c;\n};\n\nbool same(cir a,cir b){\n    double r2 = (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n    if((a.r+b.r)*(a.r+b.r)>r2)return true;\n    else return false;\n}\n\nbool used(int n,vi vec){\n    rep(i,vec.size()){\n        int to = vec[i];\n        if( (n&(1<<to)) != 0 )return false;\n    }\n    return true;\n}\n\nint main(){\n    int n;\n    while(cin>>n){\n        if(n==0)break;\n        vector<cir> data;\n        \n        rep(i,n){\n            int x,y,r,c;\n            cin>>x>>y>>r>>c;\n            data.pb(cir{x,y,r,c});\n        }\n        \n        \n        vector<int> G[30];\n        \n        for(int i=data.size()-1;i>=0;i--){\n            for(int j=i-1;j>=0;j--){\n                if(same(data[i],data[j])){\n                    G[i].pb(j);\n                }\n            }\n        }\n        \n        static bool dp[1<<24];\n        rep(i,1<<n)dp[i]=false;\n        dp[(1<<n)-1]=true;\n        \n        \n        for(int i=(1<<n)-1;i>=0;i--){\n            if(dp[i]==false)continue;\n            rep(j,n){\n                for(int k=j+1;k<n;k++){\n                    if( (i&(1<<j) )==0 || (i&(1<<k) )==0)continue;\n                    if( data[j].c==data[k].c && used(i,G[j]) && used(i,G[k]) ) dp[(i^(1<<j))^(1<<k)] = true;\n                }\n            }\n        }\n        \n        int ans=100;\n        for(int i=(1<<n)-1;i>=0;i--){\n            if(dp[i]==false)continue;\n            ans = min(ans,__builtin_popcount(i));\n        }\n        cout<<n-ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//And Then. How Many Are There?\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct C{\n  int c; //???\n  int x, y; //????????§?¨?\n  int r; //??????\n};\n\nint n;\nC data[24];\nint bit[24]; //??????????????¨???????????????\nint dp[1<<24];\n\nC make_C(int x, int y, int r, int c){\n  C ret;\n  ret.x=x; ret.y=y; ret.r=r; ret.c=c;\n  return ret;\n}\n\n//a??¨b???????????????true\nbool dis(C a, C b){\n  return (((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y)) < (a.r+b.r)*(a.r+b.r));\n}\n\n//b:??????????????????????????¨???????????????\nint solve(int b){\n  if(dp[b]!=-1)return dp[b];\n\n  int mx=0;\n  for(int i=0; i<n-1; i++){//1???????????????\n    if(bit[i]&b != bit[i])continue;//??????????????????\n    if((b&(1<<i))!=0)continue;//??¢??????????????????\n   \n    for(int j=i+1; j<n; j++){//2???????????????\n      if(bit[j]&b != bit[j])continue;//??????????????????\n      if((b&(1<<j))!=0)continue;//??¢??????????????????\n      if(data[i].c != data[j].c)continue;//????????????\n\n      int tmp_b = (b|(1<<i))|(1<<j);\n      int tmp_mx = solve(tmp_b)+2;\n      if(mx<tmp_mx)mx=tmp_mx;\n    }\n  }\n  return dp[b]=mx;\n}\n\nint main(){\n  while(cin >> n, !(n==0)){\n    memset(bit, 0, sizeof(bit));\n    memset(dp, -1, sizeof(dp));\n    for(int i=0; i<n; i++){\n      int x, y, r, c;\n      cin >> x >> y >> r >> c;\n      data[i]=make_C(x, y, r, c);\n      for(int j=0; j<i; j++){\n\tif(dis(data[i], data[j]))bit[i] = bit[i]|(1<<j);\n      }\n    }\n    cout<<solve(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint n;\nint x[25], y[25], r[25], c[25];\nbool board[25][25];\nbool memo[1<<24];\n\nvoid dfs(int S) {\n    if(!memo[S]) return;\n    vector<int> candidate;\n    rep(i,0,n) {\n        if(!(S >> i & 1)) continue;\n        bool ok = true;        \n        rep(j,0,i) {\n            if(!(S >> j & 1)) continue;\n            if(board[j][i]) ok = false;\n        }\n        if(ok) candidate.push_back(i);\n    }\n\n    int m = candidate.size();\n    rep(i,0,m) {\n        rep(j,i+1,m) {\n            int x = candidate[i], y = candidate[j];\n            if(c[x] == c[y]) {\n                int nbit = S ^ (1 << x) ^ (1 << y);\n                memo[nbit] = true;\n                dfs(nbit);\n            }\n        }\n    }\n}\n\nll dist(ll x1, ll y1, ll x2, ll y2) {\n    ll d1 = (x1-x2) * (x1-x2);\n    ll d2 = (y1-y2) * (y1-y2);\n    return d1 + d2;\n}\n\nbool in(ll x1, ll y1, ll r1, ll x2, ll y2, ll r2) {\n    double d1 = dist(x1, y1, x2, y2);\n    double d2 = (r1+r2) * (r1+r2);\n    return d1 < d2;\n}\n\nsigned main() {\n    while(cin >> n, n) {\n        memset(board, false, sizeof(board));\n        memset(memo, false, sizeof(memo));\n        rep(i,0,n) {\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n        rep(i,0,n) rep(j,0,i) {\n            if(in(x[i], y[i], r[i], x[j], y[j], r[j])) board[j][i] = true;\n        }\n        memo[(1<<n)-1] = true;\n        dfs((1<<n)-1);\n        int ans = 0;\n        rep(i,0,1<<n) {\n            if(memo[i]) {\n                // printf(\"true: i = %lld\\n\", i);\n                ans = max(ans, n - __builtin_popcount(i));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define x first.first\n#define y first.second\n#define r second.first\n#define color second.second\n\nusing namespace std;\n\ntypedef pair<double,double> P;\ntypedef pair<P,P> C;\n\nbool check(C a,C b){\n  return a.r+b.r>sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n \nint count(int bits){\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits =(((bits >> 4) + bits) & 0x0f0f0f0f);\n  bits += bits >> 8;\n  return (bits + (bits >> 16)) & 0xff;\n}\n \nbool dp[(1<<25)];\n \nint main(void){\n \n\tint n;\n\twhile(cin >> n,n){\n\t\tC c[25];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tscanf(\"%lf %lf %lf %lf\",&c[i].x,&c[i].y,&c[i].r,&c[i].color);\n\t\t\n\t\tfill(dp,dp+(1<<n),false);\n\t\tdp[(1<<n)-1]=true;\n\t\tint ans=0;\n\t\t\n\t\tfor(int S=(1<<n)-1;S>=0;S--){\n\t\t\tif(!dp[S])continue;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\t\n\t\t\t\t\tint nx=S;\n\t\t\t\t\tnx&=~(1<<i);\n\t\t\t\t\tnx&=~(1<<j);\n\t\t\t\t\tif(dp[nx])continue;\n\t\t\t\t\t\n\t\t\t\t\tif(!(S>>i&1) || !(S>>j&1))continue;\n\t\t\t\t\tif(c[i].color!=c[j].color)continue;\n\t\t\t\t\t\n\t\t\t\t\tbool fg=false;\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(!(S>>k&1))continue;\n\t\t\t\t\t\tfg|= k<i && check(c[i],c[k]);\n\t\t\t\t\t\tfg|= k<j && check(c[j],c[k]);\n\t\t\t\t\t\tif(fg)break;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(!fg)dp[nx]|=dp[S];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp[S])ans=max(ans,n-count(S));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint sqr(int x){\n  return x*x;\n}\n\nint mem[1<<24];\nint ud[24];\n\nint dfs(int b){\n  if(mem[b]>=0)return mem[b];\n  mem[b]=0;\n  for(int i=0;i<4;i++){\n    for(int j=0;j<6;j++){\n      for(int k=0;k<j;k++){\n\tint jx=i*6+j;\n\tint kx=i*6+k;\n\tif((b>>jx&1)&&(b>>kx&1)&&!(ud[jx]&b)&&!(ud[kx]&b)){\n\t  mem[b]=max(mem[b],dfs(b&~(1<<jx)&~(1<<kx))+2);\n\t}\n      }\n    }\n  }\n  return mem[b];\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    int x[24],y[24],r[24],c[24];\n    vector<int> u[24];\n    vector<int> cs[4];\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n      cs[c[i]-1].push_back(i);\n      for(int j=0;j<i;j++){\n\tif(sqr(x[i]-x[j])+sqr(y[i]-y[j])<sqr(r[i]+r[j])){\n\t  u[i].push_back(j);\n\t}\n      }\n    }\n    int m[24];\n    int b=0;\n    for(int i=0;i<4;i++){\n      for(int j=0;j<6;j++){\n\tif(j<cs[i].size()){\n\t  b|=1<<i*6+j;\n\t  m[cs[i][j]]=i*6+j;\n\t}\n      }\n    }\n    fill(begin(ud),end(ud),0);\n    for(int i=0;i<4;i++){\n      for(int j=0;j<6;j++){\n\tif(j<cs[i].size()){\n\t  for(auto e:u[cs[i][j]]){\n\t    ud[i*6+j]|=1<<m[e];\n\t  }\n\t}\n      }\n    }\n    fill(begin(mem),end(mem),-1);\n    cout<<dfs(b)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <utility>\n#include <tuple>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <list>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <bitset>\n#include <numeric>\n#include <functional>\n\nusing namespace std;\n\nint square(int x) {\n\treturn x * x;\n}\n\nstruct Circle {\n\tint x, y, r, c;\n\t\n\tCircle() {};\n\tCircle(int x, int y, int r, int c) :x(x), y(y), r(r), c(c) {};\n};\n\nbool ok(Circle& a, Circle& b) {\n\treturn square(a.x - b.x) + square(a.y - b.y) < square(a.r + b.r);\n}\n\nint dp[1 << 24], intersect[30];\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tfill(dp, dp + (1 << 24), -1);\n\t\tfill(intersect, intersect + 30, 0);\n\t\tvector<Circle> cs(n);\n\t\tfor (int i = 0; i < n; ++i) cin >> cs[i].x >> cs[i].y >> cs[i].r >> cs[i].c;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\t\tif (ok(cs[i], cs[j])) intersect[j] |= (1 << i);\n\t\tdp[0] = 0;\n\t\tfor (int i = 0; i < (1 << n); ++i) {\n\t\t\tif (dp[i] == -1) continue;\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif ((i & (1 << j)) || (i & intersect[j]) != intersect[j]) continue;\n\t\t\t\tfor (int k = j + 1; k < n; ++k) {\n\t\t\t\t\tif ((i & (1 << k)) || (i & intersect[k]) != intersect[k]) continue;\n\t\t\t\t\tif (cs[j].c != cs[k].c) continue;\n\t\t\t\t\tint to = i | (1 << j) | (1 << k);\n\t\t\t\t\tdp[to] = max(dp[to], dp[i] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < (1 << 24); ++i) ans = max(ans, dp[i]);\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\nusing namespace std;\n\n#define x real()\n#define y imag()\n#define pb push_back \ntypedef double D;\ntypedef complex<D> P;\ntypedef struct circle{\n\tP p;\n\tD r;\n} C;\n\nint rel[24];\nC c[24];\nvector<int> color[4];\nbool use[1<<24];\nint cmax;\n\nbool IC(C a,C b){\n\tD d=norm(a.p-b.p);\n\tD r=(a.r+b.r)*(a.r+b.r);\n\treturn d<r;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n, n){\n\t\tcmax=0;\n\t\tfor(int i=0;i<4;i++){\n\t\t\twhile(!color[i].empty())\n\t\t\t\tcolor[i].pop_back();\n\t\t}\n\t\tfor(int i=0;i<24;i++)\n\t\t\trel[i]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tmp;\n\t\t\tcin >> c[i].p.x >> c[i].p.y >> c[i].r;\n\t\t\tcin >> tmp;\n\t\t\tcolor[tmp-1].pb(i);\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tif(IC(c[i],c[j]))\n\t\t\t\t\trel[i]|=1<<j;\n\t\t\t}\n\t\t}\t\t\n\n\t\tuse[0]=true;\n\t\tfor(int u=0;u< (1<<n);u++){\n\t\t\tif(!use[u])\n\t\t\t\tcontinue;\n\t\t\tint res=0;\n\t\t\tint tmp=u;\n\t\t\twhile(tmp){\n\t\t\t\tif(tmp&1)\n\t\t\t\t\tres++;\n\t\t\t\ttmp >>=1;\n\t\t\t}\n\t\t\tcmax=max(cmax,res);\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tfor(int j=0;j<color[i].size();j++){\n\t\t\t\t\tif(u >>color[i][j]&0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(rel[color[i][j]]&~u)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor(int k=j+1;k<color[i].size();k++){\n\t\t\t\t\t\tif(u >>color[i][k]&0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif(rel[color[i][k]]&~u)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tuse[u|(1<<color[i][j])|(1<<color[i][k])]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cmax << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<complex>\n#include<set>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int M = 24;\nconst int INF = 1000000000;\nconst int C = 5;\n\ntypedef pair<int,int> pii;\n\nint n;\nint x[M];\nint y[M];\nint r[M];\nint c[M];\n\nvector<pii> colpair;\nvector<int> on[M];\nmap<int,int> memo;\n\nbool ok(int state, pii& p){\n\tbool ret = (state&(1<<p.first))==0 && (state&(1<<p.second))==0;\n\tif(ret==false)return ret;\n\t\n\trep(i,on[p.first].size()){\n\t\tif((state&(1<<on[p.first][i]))==0)ret = false;\n\t}\n\trep(i,on[p.second].size()){\n\t\tif((state&(1<<on[p.second][i]))==0)ret = false;\n\t}\n\treturn ret;\n}\n\nint saiki(int state){\n\tif(memo.find(state)!=memo.end())return memo[state];\n\t\n\tint ans = 0;\n\trep(i,colpair.size()){\n\t\tif(ok(state, colpair[i])){\n\t\t\tint v = saiki(state | (1<<colpair[i].first) | (1<<colpair[i].second));\n\t\t\tans = max(ans, v+2);\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nvoid init(){\n\tmemo.clear();\n\trep(i,n)on[i].clear();\n\tcolpair.clear();\n\t\n\trep(i,n)reps(j,i+1,n){\n\t\tif(c[i]==c[j])colpair.push_back(pii(i,j));\n\t}\n\t\n\trep(i,n){\n\t\trep(j,i){\n\t\t\tint dx = x[i]-x[j];\n\t\t\tint dy = y[i]-y[j];\n\t\t\tint r2 = r[i]+r[j];\n\t\t\t\n\t\t\tif(dx*dx + dy*dy < r2*r2){\n\t\t\t\ton[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\trep(i,colpair.size()){\n\t\tprintf(\"%d %d\\n\",colpair[i].first, colpair[i].second);\n\t}\n\trep(i,n){\n\t\tprintf(\"on \");\n\t\trep(j,on[i].size())printf(\"%d \",on[i][j]);puts(\"\");\n\t}*/\n}\nint solve(){\n\trep(i,n)cin>>x[i]>>y[i]>>r[i]>>c[i];\n\tinit();\n\t\n\treturn saiki(0);\n}\n\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tprintf(\"%d\\n\",solve());\n\t\t//break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint n;\nint x[24];\nint y[24];\nint c[24];\nint r[24];\nchar memo[1<<24];\nint hit(int i,int j){\n\tint L = r[i]*r[i] + r[j]*r[j] + 2 * r[i] * r[j];\n\tint X = (x[i]-x[j])*(x[i]-x[j]);\n\tint Y = (y[i]-y[j])*(y[i]-y[j]);\n\treturn X + Y < L;\n}\nint nocover(int n,int bit){\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( (bit>>i&1) && hit(i,n) ) return false;\n\t}\n\treturn true;\n}\nint dfs(int bit){\n\tif(~memo[bit]) return memo[bit];\n\tint ans = 0;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tfor(int j = i+1 ; j < n ; j++){\n\t\t\tif( (bit >> j & 1) && (bit >> i & 1) && c[i] == c[j] && nocover(i,bit) && nocover(j,bit) ){\n\t\t\t\tans = max(ans , dfs( bit - (1<<j) - (1<<i) ) + 2);\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[bit] = ans;\n}\nint main(){\n\twhile(cin >> n , n){\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> x[i] >> y[i] >> c[i] >> r[i];\n\t\t}\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tcout << dfs((1<<n)-1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define len(v) (int)(v).size()\n\nusing namespace std;\n\nvector<int> G[25];\nint mp[(1 << 24)];\nvector<int> x,y,r,c;\nint p[25];\nint n;\n\nint dfs(int par)\n{\n    if(mp[par] >= 0){\n        return mp[par];\n    }\n    vector<vector<int> > cl(4);\n    rep(i,n){\n        if((par >> i)&1){\n            cl[c[i]].pb(i);\n        }\n    }\n    int mx = 0;\n    rep(i,4){\n        if(len(cl[i])>=2){\n            rep(j,len(cl[i])-1){\n                int npar = par - (1 << cl[i][j]);\n                for(auto& v : G[cl[i][j]]){\n                    p[v] -= (1 << cl[i][j]);\n                    if(p[v]==0) npar += (1 << v);\n                }\n                for(int k=j+1;k<len(cl[i]);k++){\n                    npar -= (1 << cl[i][k]);\n                    for(auto& v : G[cl[i][k]]){\n                        p[v] -= (1 << cl[i][k]);\n                        if(p[v]==0) npar += (1 << v);\n                    }\n                    mx = max(mx,dfs(npar)+2);\n                    for(auto& v : G[cl[i][k]]){\n                        if(p[v]==0) npar -= (1 << v);\n                        p[v] += (1 << cl[i][k]);\n                    }\n                    npar += (1 << cl[i][k]);\n                }\n                for(auto& v : G[cl[i][j]]){\n                    p[v] += (1 << cl[i][j]);\n                }\n            }\n        }\n    }\n    mp[par] = mx;\n    return mx;\n}\n\ninline bool intersect(int i, int j)\n{\n    return (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j])*(r[i]+r[j]);\n}\n\nint main()\n{\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            G[i].clear();\n        }\n        memset(mp,-1,sizeof(mp));\n        x.resize(n),y.resize(n),r.resize(n),c.resize(n);\n        rep(i,n){\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n            p[i] = 0;\n            c[i]--;\n            rep(j,i){\n                if(intersect(i,j)){\n                    G[j].pb(i);\n                    p[i] += (1 << j);\n                }\n            }\n        }\n        int par = 0;\n        rep(i,n){\n            if(p[i] == 0){\n                par += (1 << i);\n            }\n        }\n        cout << dfs(par) << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for (int i=0;i<n;i++)\n#define ll long long\n\n#define ALL(x) x.begin(),x.end()\n\nusing namespace std;\nstruct Node{\n    int x,y,r,c,id;\n    vector<int> top;\n    vector<int> bottom;\n\n};\nmap<vector<deque<pair<int,int>>>,bool> mp;\nbool finish;\n\nmap<vector<int>,bool> used;\n\n\n\nvoid show(vector<int> &v){\n    rep(i,v.size()) cerr<<v[i]<<\" \";\n    cerr<<endl;\n}\n\nvoid vecdel(vector<int> &v,int n){\n    auto itr = v.begin();\n   for(; itr != v.end(); ++itr) {\n        if (*itr==n) break;;\n    }\n    v.erase(itr);\n}\n\nbool ismount(Node n1,Node n2){\n    double dist=sqrt((n1.x-n2.x)*(n1.x-n2.x)+(n1.y-n2.y)*(n1.y-n2.y));\n    return dist<(double)(n1.r+n2.r);\n}\n\nbool has(vector<int> &v,int n){\n    return find(ALL(v),n)!=v.end();\n}\n\n\nint dfs(vector<Node> &forest,vector<int> &leaf,int start){\n    int ret=0;\n    int rem=0;\n    rep(i,forest.size())\n    {\n       if (!has(forest[i].top,-1)){\n            rem++;\n        }\n    }\n    if (rem<2){\n       finish=true;\n     //  cerr<<\"fini\"<<endl;\n       return  2*(forest.size()/2);   \n    }\n    \n    if (used[leaf]==true){\n    //    cerr<<\"skip\"<<endl;\n       return -1;\n    }\n      used[leaf]=true;\n//    show(leaf);\n    for (int i=0;i<leaf.size();i++){\n        for (int j=i+1;j<leaf.size();j++){\n            int a=leaf[i];\n            int b=leaf[j];\n            if (forest[a].c==forest[b].c){\n                vector<int> nleaf;\n                auto nforest=forest;\n                //copy(leaf.begin(), leaf.end(), back_inserter(nleaf));\n                //vecdel(nleaf,a);\n                //vecdel(nleaf,b);\n                for (auto k:forest[a].bottom)\n                    vecdel(nforest[k].top,a);\n                for (auto k:forest[b].bottom)\n                    vecdel(nforest[k].top,b);\n                nforest[a].top.push_back(-1);\n                nforest[b].top.push_back(-1);\n                rep(i,nforest.size()){\n                    if (nforest[i].top.size()==0)\n                        nleaf.push_back(i);\n                }\n\n                sort(ALL(nleaf));\n                ret=max(ret,dfs(nforest,nleaf,i)+2);  \n                if (finish){\n                    //cerr<<\"fin\"<<endl;\n                    return 2*(forest.size()/2);\n                }\n            }\n        }\n    }\n    return ret;\n}\n\n\n\nint main(){\n    \n    while (true){\n        finish=false;\n        mp.clear();\n        used.clear();\n        int n;\n        cin>>n;\n        if (n==0)\n            break;\n        vector<Node> forest(n);\n        int x,y,r,c;\n        rep(i,n){\n            cin>>x>>y>>r>>c;\n            forest[i]={x,y,r,c,i,{},{}};\n        }\n        bool f=true;\n        while(f){\n            f=false;\n            rep(i,n){\n                for (int j=0;j<i;j++){\n                    if (ismount(forest[i],forest[j]) && !has(forest[i].top,j)){\n                        forest[i].top.push_back(j);\n                        forest[j].bottom.push_back(i);\n                        f=true;\n                    }\n                }\n            }  \n        }\n        f=true;\n        while(f){\n            f=false;\n            rep(i,n){\n                for (int j=0;j<i;j++){\n                    for (int k=0;k<j;k++){\n                        if (has(forest[i].top,j) && has(forest[j].top,k) && has (forest[i].top,k)){\n                            vecdel(forest[i].top,k);\n                            vecdel(forest[k].bottom,i);\n                            f=true;\n                        }\n                    }\n                }\n            }  \n        }\n        vector<int> leaf;\n        rep(i,forest.size()){\n            if (forest[i].top.size()==0){\n                leaf.push_back(forest[i].id);\n            }\n        }\n        //show(leaf);        \n        cout<<dfs(forest,leaf,0)<<endl;\n    }\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nshort int mem[16777216];\n\nint solve(int a[24][24],int *c,int depth){\n\tint max=0;\n\tint tmp=0;\n\tint est=0;\n\tint xsum,ysum;\n\tint (*copy)[24] = new int[24][24];\n\tint *cpy = new int[24];\n\t/*for(int i=0;i<24;i++){\n\t\tcout << c[i] << \" \";\n\t}\n\tcout << endl;*/\n\tint d,e;\n\tmax = depth;\n\tfor(int x=0;x<24-1;x++){\n\t\tfor(int y=x+1;y<24;y++){\n\t\t\t//a[x],a[y]が全部０か？\n\t\t\txsum=0;ysum=0;\n\t\t\tfor(int z=0;z<24;z++){ xsum+=a[x][z]; ysum+=a[y][z];}\n\t\t\td=0;\n\t\t\tfor(int z=0;z<24;z++){ if(c[z]>0)d++;}\n\t\t\tif(d<2) return depth;\n\t\t\t//a[x],a[y]が全部0でかつ，xとyの色は一緒なのか？\n\t\t\tif(c[x]==c[y] && xsum==0 && ysum==0 && c[x]!=0){\n\t\t\t\t//配列をコピーする\n\t\t\t\tfor(int i=0;i<24;i++){\n\t\t\t\t\tfor(int j=0;j<24;j++) copy[i][j]=a[i][j];\n\t\t\t\t}\n\t\t\t\t//コピーした配列で選ばれたxとyを取り除く\n\t\t\t\tfor(int i=0;i<24;i++){\n\t\t\t\t\tcopy[i][x]=0;\n\t\t\t\t\tcopy[i][y]=0;\n\t\t\t\t\tcpy[i]=c[i];\n\t\t\t\t}\n\t\t\t\tcpy[x]=0;\n\t\t\t\tcpy[y]=0;\n\t\t\t\td=0;\n\t\t\t\tfor(int i=0;i<24;i++){\n\t\t\t\t\tif(cpy[i]!=0){\n\t\t\t\t\te=1;\n\t\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\t\te*=2;\n\t\t\t\t\t}\n\t\t\t\t\td+=e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(mem[d]==-1){\n\t\t\t\t\ttmp=solve(copy,cpy,depth+1);\n\t\t\t\t\tmem[d]=tmp;\n\t\t\t\t}else{\n\t\t\t\t\ttmp=mem[d];\n\t\t\t\t}\n\t\t\t\tif(tmp>=12) return 12;\n\t\t\t\tif(max<tmp){\n\t\t\t\t\tmax=tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdelete []copy;\n\tdelete cpy;\n\treturn max;\n}\n\nbool on(int x1,int y1,int r1,int x2,int y2,int r2){\n\tbool result;\n\tint dx,dy;\n\tint dis;\n\tint mindis;\n\tresult=false;\n\t\n\tdx=(x1-x2);\n\tdy=(y1-y2);\n\tmindis=r1+r2;\n\n\tdis=sqrt(dx*dx+dy*dy);\n\n\tif(dis<mindis) result=true;\n\t\n\treturn result;\n}\n\nint main(void){\n\tint n;\n\tint xs[24];\n\tint ys[24];\n\tint rs[24];\n\tint cs[24];\n\tint onTable[24][24];\n\n\n\n\twhile(true){\n\t\t//データを初期化\n\t\tfor(int i=0;i<24;i++){\n\t\t\txs[i]=-1;\n\t\t\tys[i]=-1;\n\t\t\trs[i]=0;\n\t\t\tcs[i]=0;\n\t\t\tfor(int j=0;j<24;j++) onTable[i][j]=0;\n\t\t}\n\n\t\t//枚数を入力\n\t\tcin >> n;\n\t\tif(n==0) break;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> xs[i];\n\t\t\tcin >> ys[i];\n\t\t\tcin >> rs[i];\n\t\t\tcin >> cs[i];\n\t\t}\n\t\t\n\t\t//行列を作成\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\tif(on(xs[i],ys[i],rs[i],xs[j],ys[j],rs[j])){\n\t\t\t\t\tonTable[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//行列を表示\n\t/*\tfor(int i=0;i<n;i++){\n\t\t\tprintf(\"%2d:\",i);\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcout << onTable[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n*/\n\t\tfor(int i=0;i<16777216;i++){\n\t\t\tmem[i]=-1;\n\t\t}\n\t\tcout << solve(onTable,cs,0)*2 << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define show_bits(b, s) if(opt_debug) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#define dumpb(bit, digits) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #bit << \" = \"; for(int __i = digits - 1; __i >= 0; __i--) { cerr << static_cast<bool>(bit & (1 << __i)); if (__i % 4 == 0) { cerr << \" \"; } } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\nbool opt_debug = false;\n\nclass Disk {\n\tprivate:\n\tpublic:\n\t\tint x, y, r, c;\n\t\tset<Disk*> upper_disks;\n\t\tset<Disk*> lower_disks;\n\n\t\tDisk(int _x, int _y, int _r, int _c) : x(_x), y(_y), r(_r), c(_c) {\n\t\t}\n\n\t\tbool overlap(const Disk rhs) {\n\t\t\treturn sqrt(pow(x - rhs.x, 2) + pow(y - rhs.y, 2)) + EPS < r + rhs.r;\n\t\t}\n};\nstd::ostream& operator<<(std::ostream &s, const Disk &d) {\n\ts << \"(\" << d.x << \", \" << d.y << \", \" << d.r << \", \" << d.c << \")\";\n\treturn s;\n}\n\n#define BIT_SUB(a, b) ((a) - ((a) & (b)))\n\nmap<ULL, char> memo;\nint solve(vector<Disk*> &disks, VULL &upper, ULL current) {\n\tdumpb(current, 24);\n\tif (EXIST(memo, current)) { return memo[current]; }\n\tint ret = 0;\n\tREP (i, disks.size()) {\n\t\tFOR (j, i+1, disks.size()) {\n\t\t\tif (current & 1 << i || current & 1 << j || (disks[i]->c != disks[j]->c)) { continue; }\n\t\t\tdumpb(upper[i], 24);\n\t\t\tdumpb(upper[j], 24);\n\t\t\tdumpb(BIT_SUB(upper[i], current), 24);\n\t\t\tdumpb(BIT_SUB(upper[j], current), 24);\n\t\t\tif (BIT_SUB(upper[i], current) || BIT_SUB(upper[j], current)) {\n\t\t\t\t// cannot remove\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdump(i);\n\t\t\tdump(j);\n\t\t\tdump(*disks[i]);\n\t\t\tdump(*disks[j]);\n\n\t\t\tULL next = current | (1 << i) | (1 << j);\n\t\t\tdumpb(next, 24);\n\t\t\tret = max(ret, 2 + solve(disks, upper, next));\n\t\t}\n\t}\n\treturn memo[current] = ret;\n}\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/0.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tint n;\n\twhile (cin >> n, n) {\n\t\tmemo.clear();\n\t\tVULL overlap(n, 0);\n\t\tvector<Disk*> disks;\n\t\tREP (i, n) {\n\t\t\tint x, y, r, c; cin >> x >> y >> r >> c;\n\t\t\tDisk *d = new Disk(x, y, r, c);\n\t\t\tREP (j, disks.size()) {\n\t\t\t\tDisk *rhs = disks[j];\n\t\t\t\tif (d->overlap(*rhs)) {\n\t\t\t\t\toverlap[i] = overlap[i] | (1 << j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdisks.PB(d);\n\t\t}\n\t\tcout << (int)solve(disks, overlap, 0) << endl;\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define x first.first\n#define y first.second\n#define r second.first\n#define color second.second\n\nusing namespace std;\n\ntypedef pair<double,double> P;\ntypedef pair<P,P> C;\n\nbool check(C a,C b){\n  return a.r+b.r>sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n \nint count(int bits){\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits =(((bits >> 4) + bits) & 0x0f0f0f0f);\n  bits += bits >> 8;\n  return (bits + (bits >> 16)) & 0xff;\n}\n \nbool dp[(1<<25)];\n \nint main(void){\n \n\tint n;\n\twhile(cin >> n,n){\n\t\tC c[25];\n\t\tfor(int i=0;i<n;i++){\n\t\t\t//cin >> c[i].x >> c[i].y >> c[i].r >> c[i].color;\n\t\t\tscanf(\"%lf %lf %lf %lf\",&c[i].x,&c[i].y,&c[i].r,&c[i].color);\n\t\t}\n\t\t\n\t\tfill(dp,dp+(1<<n),false);\n\t\tdp[(1<<n)-1]=true;\n\t\tint ans=0;\n\t\t\n\t\tfor(int S=(1<<n)-1;S>=0;S--){\n\t\t\tif(!dp[S])continue;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\t\n\t\t\t\t\tint nx=S;\n\t\t\t\t\t\n\t\t\t\t\tif(!(S>>i&1) || !(S>>j&1))continue;\n\t\t\t\t\tif(c[i].color!=c[j].color)continue;\n\t\t\t\t\t\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(!(S>>k&1))continue;\n\t\t\t\t\t\tif((k<i && check(c[i],c[k]))||(k<j && check(c[j],c[k])))goto end;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tnx&=~(1<<i);\n\t\t\t\t\tnx&=~(1<<j);\n\t\t\t\t\tdp[nx]|=dp[S];\n\t\t\t\t\tend:;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp[S])ans=max(ans,n-count(S));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n\nlong long  mod = 1000000007;\n\n\nbool lap[30][30];\n\n\nbool overlap(int i,int j,vector<int> &x,vector<int>&y,vector<int> &r){\n\tint k = 0;\n\tk = (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]);\n\tif(k>= (r[i]+r[j])*(r[i]+r[j]))return 0;\n\treturn 1;\n}\nint n;\nint dp[1<<24];\nint dfs(int s,vector<int>&c){\n\tif(dp[s] != -1) return dp[s];\n\tint k = 0;\n\tfor(int i=0;i<n;i++){\n\t\tif(s&(1<<i)){\n\t\t\tk++;\n\t\t}\n\t}\n\tdp[s] = n-k;\n\tint res= n-k;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(c[i]==c[j]){\n\t\t\t\tif((s&(1<<i))&&(s&(1<<j))){\n\t\t\t\t\tbool fl =1;\n\t\t\t\t\tfor(int p=0;p<i;p++){\n\t\t\t\t\t\tif(lap[p][i]==1&&(s&(1<<p)))fl = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int p=0;p<j;p++){\n\t\t\t\t\t\tif(lap[p][j]==1&&(s&(1<<p)))fl = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(fl){\n\t\t\t\t\t\tres = max(res,dfs(s-(1<<i)-(1<<j),c));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[s] = res;\n}\n\nint main(){\n\twhile(cin >> n && n!=0){\n\t\tvector<int>x(n),y(n),r(n),c(n);\n\t\tfor(int i=0;i<(1<<24);i++){\n\t\t\tdp[i] = -1;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tfor(int i=0;i<30;i++){\n\t\t\tfor(int j=0;j<30;j++){\n\t\t\t\tlap[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(overlap(i,j,x,y,r)==1){\n\t\t\t\t\tlap[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tbool flag = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\tif(lap[i][j]==0){\n\t\t\t\t\t\tfor(int k=i+1;k<j;k++){\n\t\t\t\t\t\t\tif(lap[i][k]&&lap[k][j]){\n\t\t\t\t\t\t\t\tlap[i][j]=1;\n\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)break;\n\t\t}\n\t\t/*for(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tcout << i <<  \" \" << j << \" \" << lap[i][j] << endl;\n\t\t\t}\n\t\t}*/\n\n\t\tcout << dfs((1<<n)-1,c) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint n,x[30],y[30],r[30],c[30],cover[30];\nchar dp[1<<24];\nvector<int> same_col[5];\n\nint rec(int bit){\n  if(dp[bit])return dp[bit];\n\n  int res = 0;\n  for(int i=0;i<4;i++){\n    if(same_col[i].size()<2)continue;\n    for(int a : same_col[i])for(int b : same_col[i]){\n\tif(a<=b)continue;\n\tif( (~bit)&(1<<a) && (~bit)&(1<<b) ){\n\t  if( (~bit)&cover[a] || (~bit)&cover[b])continue;\n\t  res = max(res, rec(bit | (1<<a) | (1<<b))+2);\n\t}\n      }\n  }\n  return dp[bit]=res;\n}\n  \nint main(){\n  while(cin >> n, n){\n    for(int i=0;i<n;i++)cin >> x[i] >> y[i] >> r[i] >> c[i];\n    for(int i=0;i<4;i++)same_col[i].clear();\n\n    for(int i=0;i<n;i++){\n      same_col[c[i]-1].push_back(i);\n      cover[i] = 0;\n      for(int j=0;j<i;j++){\n\tif( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j])*(r[i]+r[j]) ){\n\t  cover[i] |= 1<<j;\n\t}\n      }\n    }\n\n    memset(dp,0,sizeof(dp));\n    cout << rec(0) << endl;\n  }\t  \n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nmain {\n  while (true) {\n    int n = in();\n    if (n == 0) break;\n    vector<int> x(n), y(n), r(n), c(n);\n    rep(i, n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n    auto intersectCC = [&](int i, int j) {\n      int r2 = (r[i] + r[j]) * (r[i] + r[j]);\n      int d = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n      return d < r2;\n    };\n    auto intersect = [&](int t, int used) {\n      bool f = false;\n      rep(i, t) f |= (~used >> i & 1) && intersectCC(t, i);\n      return f;\n    };\n    vector<int16_t> dp(1 << n, -1);\n    function<int(int)> dfs = [&](int used) {\n      if (dp[used] != -1) return dp[used];\n      cmax(dp[used], 0);\n      rep(i, n) loop(j, i + 1, n) {\n        if ((used >> i & 1) || (used >> j & 1) || c[i] != c[j]) continue;\n        if (intersect(i, used) || intersect(j, used)) continue;\n        cmax(dp[used], dfs(used | (1 << i) | (1 << j)) + 2);\n      }\n      return dp[used];\n    };\n    cout << dfs(0) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#define HIT(a,b) ((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r))\n\nusing namespace std;\n\nstatic char Log[90][30]={0};\nstatic int Logcnt=0;\n\nstruct DISK {\n\tint x,y,r,c,f;\n};\nint n;\n\nvoid setontop(DISK *D){\n\tint i,j;\n\tfor(i=0;i<n;i++){\n\t\tD[i].f=D[i].r;\n\t\tfor(j=i+1;j<n;j++)\n\t\t\tif(D[j].r && HIT(D[i],D[j])) D[i].f=0;\n//\t\tprintf(\"ontop%d %d\\n\", i, D[i].f);\n\t}\n}\n\nint checkLog(DISK *D){\n\tint i,j;\n\tfor(i=0;i<Logcnt;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif((D[j].r && !Log[i][j]) || (!D[j].r && Log[i][j])) break;\n\t\t}\n\t\tif(j==n){\n\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint solve(DISK *D){\n\tint i,j,k,min=30,ret;\n\tif(checkLog(D)) return 30;\n\tfor(i=0;i<n;i++) Log[Logcnt][i]=D[i].r;\n\tLogcnt ++;\n\tif(Logcnt>=90) return 30;\n\tsetontop(D);\n\tfor(i=1;i<=4;i++){\n\t\tchar list[6],li=0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(D[j].f&&D[j].c==i) list[li++]=j;\n\t\t}\n//\t\tprintf(\"%d %d\\n\",i,li);\n\t\tif(li<2)continue;\n\t\tDISK tmp[30];\n\t\tfor(j=0;j<li;j++){\n\t\t\tfor(k=j+1;k<li;k++){\n//\t\t\t\tprintf(\"remove(%d,%d)\", list[j],list[k]);\n\t\t\t\tmemcpy(tmp,D,sizeof(tmp));\n\t\t\t\ttmp[list[j]].r=0;\n\t\t\t\ttmp[list[k]].r=0;\n\t\t\t\tret=solve(tmp);\n\t\t\t\tif(ret<min)min=ret;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ret=0,i=0;i<n;i++)if(D[i].r)ret++;\n\tif(ret<min)min=ret;\n//\tprintf(\"return %d\\n\", min);\n\treturn min;\n}\n\nint main(){\n\tint i,j;\n\twhile(cin>>n,n){\n\t\tDISK D[30];\n\t\tLogcnt=0;\n\t\tfor(i=n;i-->0;) cin>>D[i].x>>D[i].y>>D[i].r>>D[i].c;\n\t\tcout<<n-solve(D)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct circle{\n  double x, y, r;\n  int c;\n  unordered_set<int> overlap;\n};\n\nvoid calcOverlap(int n, circle *disk){\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      int x = disk[i].x - disk[j].x, y = disk[i].y - disk[j].y;\n      if(sqrt(x*x + y*y) + 1e-8< disk[i].r + disk[j].r){\n        disk[j].overlap.insert(i);\n      }\n    }\n  }\n}\n\nint dfs(int n, circle *disk, bool *removed, int dep = 0){\n  int res = 0;\n  bool f = false;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      if(removed[i] == true or removed[j] == true)continue;\n      if(disk[i].c != disk[j].c)continue;\n      if(disk[i].overlap.empty() and disk[j].overlap.empty()){\n        f = true;\n        removed[i] = true;\n        removed[j] = true;\n        for (int k = 0; k < n; k++) {\n          disk[k].overlap.erase(i);\n          disk[k].overlap.erase(j);\n        }\n        res = max(res, dfs(n, disk, removed, dep + 1));\n      }\n    }\n  }\n  return f?res:dep;\n}\n\nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n, n){\n    circle disk[n];\n    for (int i = 0; i < n; i++) {\n      cin >> disk[i].x >> disk[i].y >> disk[i].r >> disk[i].c;\n    }\n    calcOverlap(n, disk);\n    // for (int i = 0; i < n; i++) {\n    //   std::cout << \"i:\" << i << std::endl;\n    //   for (int j :disk[i].overlap) {\n    //     std::cout << j << \" \";\n    //   }\n    //   std::cout << std::endl;\n    // }\n    bool removed[n];\n    memset(removed, false, sizeof(removed));\n    std::cout << 2*dfs(n, disk, removed) << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<string>\n#include<cmath>\n#include<cassert>\n#include<unordered_map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll int__;\n#define rep(i,j) for(int__ (i)=0;(i)<(j);(i)++)\n#define repeat(i,j,k) for(int__ i=(j);i<(k);(i)++)\n#define all(v) begin(v),end(v)\n\nconst int INF = 1<<30;\n\nstruct Circle{\n  int x,y,r,c;\n};\n\n\nbool is_intersect(const Circle &c1,const Circle &c2){\n  int dist2=pow(c1.x-c2.x,2)+pow(c1.y-c2.y,2);\n  if(dist2>=pow(c1.r+c2.r,2))return false;\n  return true;\n}\n\nint n;\nvector<Circle> C;\nvector< vector<bool> > is_I;\n\nunordered_map<unsigned int,int> MEMO;\n\n\nint rec(unsigned int bits){\n  if(MEMO.find(bits)!=MEMO.end())return MEMO[bits];\n  \n  int ret=INF;\n  vector<int> tops[4];\n  rep(i,n){\n    if(bits & (1<<i)){\n      rep(j,i){\n        if(bits & (1<<j)){\n          if(is_I[i][j])goto BREAK;\n        }\n      }\n      tops[C[i].c-1].push_back(i);\n   BREAK:;\n    }\n  }\n\n  rep(i,4){\n    rep(j,tops[i].size()){\n      rep(k,j){\n        ret = min(ret,rec(bits & ~((1<<tops[i][j]) | (1<<tops[i][k]))));\n      }\n    }\n  }\n\n  if(ret==INF){\n    ret=__builtin_popcount(bits);\n  }\n  return MEMO[bits]=ret;\n}\n\nint main()\n{\n  while(true){\n    C.clear();\n    is_I.clear();\n    MEMO.clear();\n    \n    cin>>n;\n    if(n==0)break;\n    C.resize(n);\n    is_I.resize(n,vector<bool>(n,false));\n    \n    rep(i,n){\n      int x,y,r,c;\n      cin>>x>>y>>r>>c;\n      C[i]=(Circle){x,y,r,c};\n    }\n    rep(i,n){\n      rep(j,n){\n        is_I[i][j]=is_intersect(C[i], C[j]);\n      }\n    }\n    unsigned int bits=0;\n    rep(i,n)bits|=1<<i;\n    cout<<n-rec(bits)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint N, X[30], Y[30], R[30], C[30];\nint dp[20000000];\n\nbool f(int n, int s) {\n  REP(i, 0, n) {\n    if(s & (1 << i)) continue;\n    if(pow(R[n] + R[i], 2) > pow(X[n] - X[i], 2) + pow(Y[n] - Y[i], 2)) return false;\n  }\n  return true;\n}\n\nint dfs(int s, int n) {\n  if(dp[s] >= 0) return dp[s];\n  if(n == N) return N;\n\n  // cout << s << \" \" << n << endl;\n\n  int ret = n;\n  REP(i, 0, N) {\n    if(s & (1 << i)) continue;\n    REP(j, i + 1, N) {\n      if(s & (1 << j)) continue;\n      if(C[i] != C[j]) continue;\n      if(!f(i, s) || !f(j, s)) continue;\n      ret = max(ret, dfs(s | (1 << i) | (1 << j), n + 2));\n    }\n  }\n\n  return dp[s] = ret;\n}\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> X[i] >> Y[i] >> R[i] >> C[i];\n    REP(i, 0, pow(2, N)) dp[i] = -1;\n\n    cout << dfs(0, 0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool dp[1 << 24];\nint can[1 << 24];\nint cover[30];\nint x[30], y[30], r[30], c[30];\n\nint main() {\n    int N;\n    while(1) {\n        scanf(\"%d\", &N);\n        if(!N) break;\n        memset(dp, false, sizeof(dp));\n        memset(can, 0, sizeof(can));\n        memset(cover, 0, sizeof(cover));\n\n        vector< vector<int> > colors(4);\n        for(int i=0; i<N; i++) {\n            scanf(\"%d%d%d%d\", &x[i], &y[i], &r[i], &c[i]);\n            c[i]--;\n            colors[ c[i] ].push_back(i);\n        }\n\n        // i が j によって覆われる\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<i; j++) {\n                int diff_x = x[i] - x[j];\n                int diff_y = y[i] - y[j];\n                int A = diff_x * diff_x + diff_y * diff_y;\n                int B = (r[i] + r[j]) * (r[i] + r[j]);\n                if(A < B) {\n                    cover[i] |= (1 << j);\n                }\n            }\n        }\n\n        dp[(1<<N)-1] = true;\n        for(int bit=(1<<N)-1; bit>=0; bit--) {\n            if(!dp[bit]) continue;\n            for(int k=0; k<4; k++) {\n                int S = colors[k].size();\n                if(S < 2) continue;\n\n                for(int i=0; i<S; i++) {\n                    for(int j=i+1; j<S; j++) {\n                        int u = colors[k][i], v = colors[k][j];\n                        if(bit & cover[u]) continue;\n                        if(bit & cover[v]) continue;\n                        if((bit >> u & 1) == 0) continue;\n                        if((bit >> v & 1) == 0) continue;\n\n                        int nbit = bit ^ (1 << u) ^ (1 << v);\n                        dp[nbit] = true;\n                    }\n                }\n            }\n        }\n\n        int ans = 0;\n        for(int bit=0; bit<(1<<N); bit++) {\n            if(dp[bit]) ans = max(ans, N - __builtin_popcount(bit));\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstruct Disk{\n\tdouble x, y, r;\n\tint c, id;\n}disk[30];\nvector<Disk> colors[6];\nchar dp[1<<24];\ndouble dis[25][25];\nbool iscover(int a, int b){\n\tdouble r = (disk[a].r+disk[b].r)*(disk[a].r+disk[b].r);\n\tif(dis[a][b] < r){\n\t\treturn true;\n\t}\n\treturn false;\n}\nbool ontop(int a, int state){\n\tfor(int i = 0; i < a; i++)\n\t\tif(!((state >> i) & 1) && iscover(i, a)){\n\t\t\treturn false;\n\t\t}\n\treturn true;\n}\nbool pairable(int a, int b, int state){\n\tif(!iscover(a, b) && ontop(a, state) && ontop(b, state))\n\t\treturn true;\n\treturn false;\n}\nint main(){\n\tint n;\n\twhile(scanf(\"%d\", &n), n){\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor(int i = 1; i <= 4; i++)\n\t\t\tcolors[i].clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%lf%lf%lf%d\", &disk[i].x, &disk[i].y, &disk[i].r, &disk[i].c);\n\t\t\tdisk[i].id = i;\n\t\t\tcolors[disk[i].c].push_back(disk[i]);\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\tdis[i][j] = (disk[i].x-disk[j].x)*(disk[i].x-disk[j].x)+(disk[i].y-disk[j].y)*(disk[i].y-disk[j].y);\n\t\tint M = 1 << n;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tif(i > 0 && !dp[i])\n\t\t\t\tcontinue;\n\t\t\tfor(int c = 1; c <= 4; c++){\n\t\t\t\tfor(int j = 0; j < colors[c].size(); j++){\n\t\t\t\t\tif((1<<colors[c][j].id)& i)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor(int k = j+1; k < colors[c].size(); k++){\n\t\t\t\t\t\t\tif((1<<colors[c][k].id) & i)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tif(pairable(colors[c][j].id, colors[c][k].id, i)){\n\t\t\t\t\t\t\t\tint nstate = i | (1<<colors[c][j].id) | (1<<colors[c][k].id);\n\t\t\t\t\t\t\t\tdp[nstate] = max(dp[nstate], dp[i]+2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < M; i++)\n\t\t\tans = max(ans, dp[i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pb push_back\n#define sz size()\n#define vi vector<int>\n\nint n,x[25],y[25],r[25],c[25],ans;\nbool v[1<<24];\n\nint sq(int x){return x*x;}\n\nvoid f(int mask){\n\tif(v[mask])return;\n\tv[mask]=1;\n\tvi d;\n\trep(i,n)if(mask>>i&1)d.pb(i);\n\tans=max(ans,n-(int)d.sz);\n\tbool top[25];\n\trep(i,d.sz)top[i]=1;\n\trep(i,d.sz)rep2(j,i+1,d.sz){\n\t\tif(sq(x[d[i]]-x[d[j]])+sq(y[d[i]]-y[d[j]])<sq(r[d[i]]+r[d[j]])){\n\t\t\ttop[j]=0;\n\t\t}\n\t}\n\trep(i,d.sz)rep2(j,i+1,d.sz){\n\t\tif(top[i] && top[j] && c[d[i]]==c[d[j]]){\n\t\t\tf(mask-(1<<d[i])-(1<<d[j]));\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>n && n){\n\t\trep(i,n)cin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\tans=0;\n\t\tmemset(v,0,sizeof(v));\n\t\tf((1<<n)-1);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n\nlong long  mod = 1000000007;\n\n\nbool lap[30][30];\n\n\nbool overlap(int i,int j,vector<int> &x,vector<int>&y,vector<int> &r){\n\tint k = 0;\n\tk = (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]);\n\tif(k>= (r[i]+r[j])*(r[i]+r[j]))return 0;\n\treturn 1;\n}\n\n\nint main(){\n\tint n;\n\twhile(cin >> n && n!=0){\n\t\tset<int>st,st2;\n\t\tvector<int>x(n),y(n),r(n),c(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tfor(int i=0;i<30;i++){\n\t\t\tfor(int j=0;j<30;j++){\n\t\t\t\tlap[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(overlap(i,j,x,y,r)==1){\n\t\t\t\t\tlap[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tbool flag = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\tif(lap[i][j]==0){\n\t\t\t\t\t\tfor(int k=i+1;k<j;k++){\n\t\t\t\t\t\t\tif(lap[i][k]&&lap[k][j]){\n\t\t\t\t\t\t\t\tlap[i][j]=1;\n\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)break;\n\t\t}\n\t\t/*for(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tcout << i <<  \" \" << j << \" \" << lap[i][j] << endl;\n\t\t\t}\n\t\t}*/\n\n\t\tst.insert((1<<n)-1);\n\t\tst2.insert((1<<n)-1);\n\t\twhile(1){\n\t\t\tbool flag = 1;\n\t\t\tset<int> st3;\n\t\t\tfor(auto s:st2){\n\t\t\t\t//cout << static_cast<bitset<24>>(s) << endl;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\t\tif(c[i]==c[j]){\n\t\t\t\t\t\t\tif((s&(1<<i))&&(s&(1<<j))){\n\t\t\t\t\t\t\t\tbool fl =1;\n\t\t\t\t\t\t\t\tfor(int p=0;p<i;p++){\n\t\t\t\t\t\t\t\t\tif(lap[p][i]==1&&(s&(1<<p)))fl = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int p=0;p<j;p++){\n\t\t\t\t\t\t\t\t\tif(lap[p][j]==1&&(s&(1<<p)))fl = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(fl){\n\t\t\t\t\t\t\t\t\tst.insert(s-(1<<i)-(1<<j));\n\t\t\t\t\t\t\t\t\tst3.insert(s-(1<<i)-(1<<j));\n\t\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tst2 = st3;\n\t\t\tif(flag)break;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(auto s:st){\n\t\t\tint c = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(s&(1<<i)){\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans,n-c);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 24\n\nint N,x[MAX],y[MAX],r[MAX],c[MAX];\n\nint dist(int a,int b){\n    return (x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]);\n}\n\nbool check(int a,int b){\n    int d = dist(a,b);\n    int add = r[a]+r[b],sub = r[a]-r[b];\n    return ((sub*sub < d && d < add*add) || d <= sub*sub);\n}\n\nint main(){\n    while(cin >> N, N){\n        for(int i = 0 ; i < N ; i++){\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n        int bit[MAX] = {0};\n        for(int i = 0 ; i < N ; i++){\n            for(int j = 0 ; j < i ; j++){\n                if(check(i,j)) bit[i] |= (1<<j);\n            }\n        }\n        vector<bool> dp(1<<N,0);\n        dp[(1<<N)-1] = 1;\n        int res = 0;\n        for(int i = (1<<N)-1 ; i >= 0 ; i--){\n            if(dp[i] == 0) continue;\n            if(N%2 == 0 && __builtin_popcount(i) % 2 == 1) continue;\n            if(N%2 == 1 && __builtin_popcount(i) % 2 == 0) continue;\n            int n = __builtin_popcount(i);\n            for(int j = 0 ; j < N ; j++){\n                if((i&bit[j]) > 0) continue;\n                for(int k = j+1 ; k < N ; k++){\n                    if(c[j] != c[k]) continue;\n                    if((i&bit[k]) > 0) continue;\n                    int S = i & ~((1<<j) | (1<<k));\n                    dp[S] = 1;\n                    res = max(res,N-n);\n                }\n            }\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint sqr(int x){\n  return x*x;\n}\n\nshort mem[1<<24];\nint ud[24];\n\nint dfs(int b){\n  if(mem[b]>=0)return mem[b];\n  mem[b]=0;\n  for(int i=0;i<4;i++){\n    for(int j=0;j<6;j++){\n      for(int k=0;k<j;k++){\n\tint jx=i*6+j;\n\tint kx=i*6+k;\n\tif((b>>jx&1)&&(b>>kx&1)&&!(ud[jx]&b)&&!(ud[kx]&b)){\n\t  mem[b]=max(mem[b],dfs(b&~(1<<jx)&~(1<<kx))+2);\n\t}\n      }\n    }\n  }\n  return mem[b];\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    int x[24],y[24],r[24],c[24];\n    vector<int> u[24];\n    vector<int> cs[4];\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n      cs[c[i]-1].push_back(i);\n      for(int j=0;j<i;j++){\n\tif(sqr(x[i]-x[j])+sqr(y[i]-y[j])<sqr(r[i]+r[j])){\n\t  u[i].push_back(j);\n\t}\n      }\n    }\n    int m[24];\n    int b=0;\n    for(int i=0;i<4;i++){\n      for(int j=0;j<6;j++){\n\tif(j<cs[i].size()){\n\t  b|=1<<i*6+j;\n\t  m[cs[i][j]]=i*6+j;\n\t}\n      }\n    }\n    fill(begin(ud),end(ud),0);\n    for(int i=0;i<4;i++){\n      for(int j=0;j<6;j++){\n\tif(j<cs[i].size()){\n\t  for(auto e:u[cs[i][j]]){\n\t    ud[i*6+j]|=1<<m[e];\n\t  }\n\t}\n      }\n    }\n    fill(begin(mem),end(mem),-1);\n    cout<<dfs(b)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long Long;\n#define whole(xs) xs.begin(), xs.end()\n\nstruct Circle {\n    int x, y, r, c;\n};\nistream& operator>>(istream& is, Circle& c) {\n    is >> c.x >> c.y >> c.r >> c.c;\n    return is;\n}\n\nstruct Point {\n    int x, y;\n    Point(int x = 0, int y = 0) : x(x), y(y) {}\n};\n#define Pow2(x) ((x) * (x))\nint Dist2(const Point& a, const Point& b) {\n    return Pow2(a.x - b.x) + Pow2(a.y - b.y);\n}\n\nint N;\nvector<Circle> Cs;\nbool input() {\n    cin >> N;\n    if (N == 0) return false;\n    Cs.resize(N);\n    for (int i = 0; i < N; i++) {\n        cin >> Cs[i];\n    }\n    return true;\n}\n\nbool Overlap(const Circle& a, const Circle& b) {\n    return Pow2(a.r + b.r) > Dist2(Point(a.x, a.y), Point(b.x, b.y));\n}\n\nbool IsTop(int used, int index) {\n    for (int i = 0; i < index; i++) {\n        if (used & (1 << i)) continue;\n        if (Overlap(Cs[i], Cs[index])) return false;\n    }\n    return true;\n}\n\nint Cache[1 << 24];\nint dfs(int used) {\n    int Ret = 0;\n    if (Cache[used] >= 0) return Cache[used];\n    for (int i = 0; i < N; i++) {\n        if (used & (1 << i)) continue;\n        if (!IsTop(used, i)) continue;\n        for (int j = i + 1; j < N; j++) {\n            if (used & (1 << j)) continue;\n            if (!IsTop(used, j)) continue;\n            if (Cs[i].c == Cs[j].c) {\n                Ret = max(Ret, dfs(used | (1 << i) | (1 << j)) + 2);\n            }\n        }\n    }\n    return Cache[used] = Ret;\n}\n\nvoid solve() {\n    memset(Cache, -1, sizeof(Cache));\n    cout << dfs(0) << endl;\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n\nusing namespace std;\n\nint x[30],y[30],r[30],c[30],n;\nbool table[30][30];\n\nint dist2(int i,int j){\n\tint dx=x[i]-x[j],dy=y[i]-y[j];\n\treturn dx*dx+dy*dy;\n}\n\nint slv(vector<int> sum,vector<int> used){\n\tint i,j,k,re=0,tmp;\n\tbool flag=0;\n/*\tfor(i=0;i<n;i++){\n\tcout<<sum[i]<<\" \";\n\t}cout<<endl;\n*/\t\n\tfor(i=0;i<n;i++){\n\t\tif(sum[i]>0 || used[i])continue;\n\t\tfor(j=i+1;j<n;j++){\n\t\t\tif(sum[j]>0 || used[j])continue;\n\t\t\tif(c[i]==c[j]){\n//\t\t\tcout<<\"(\"<<i<<\",\"<<j<<\")\"<<endl;\n\t\t\t\tused[i]=used[j]=1;\n\t\t\t\tfor(k=i+1;k<n;k++)\n\t\t\t\t\tsum[k]-=table[i][k];\n\t\t\t\tfor(k=j+1;k<n;k++)\n\t\t\t\t\tsum[k]-=table[j][k];\n\t\t\t\tflag=1;\n\t\t\t\tif((tmp=slv(sum,used)+2) > re){\n\t\t\t\t\tre=tmp;\n\t\t\t\t}\n\t\t\t\tused[i]=used[j]=0;\n\t\t\t\tfor(k=i+1;k<n;k++)\n\t\t\t\t\tsum[k]+=table[i][k];\n\t\t\t\tfor(k=j+1;k<n;k++)\n\t\t\t\t\tsum[k]+=table[j][k];\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\treturn re;\n}\n\t\t\t\t\n\t\t\n\nint main(){\n\tint i,j;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tvector<int> sum;\n\t\tvector<int> used;\n\t//\tre=0;\n\t\tmemset(table,0,sizeof(table));\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",x+i,y+i,r+i,c+i);\n\t\t\tused.push_back(0);\n\t\t\tsum.push_back(0);\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\ttable[i][j]=(r[i]+r[j])*(r[i]+r[j])>dist2(i,j);\n\t\t\t\tif(i>j)sum[i]+=table[i][j];\n\t\t\t}\n\t\t}\t//harahe\n\t\t\n/*\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++)cout<<table[i][j]<<\" \";\n\t\t\tcout<<\":\"<<sum[i]<<endl;\n\t\t}*/\n\t\tprintf(\"%d\\n\",slv(sum,used));\n\t\t\n\t}\n\t\n\treturn 0;\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for (int i=0; i<(int)n; ++i)\n\ntypedef complex<double> P;\ndouble const EPS = 1e-8;\n\nstruct C {\n  P p;\n  double r;\n  int c;\n};\n\nvector<C> circle;\nint n;\nint memo[1<<25];\n\nint dfs(int S) {\n  if(memo[S] != -1) return memo[S];\n  //  cout<<S<<endl;\n  int ret = 0;\n  vector<int> hoge[4];\n  if((S&1) == 0) hoge[circle[0].c].push_back(0);\n\n  for (int i=1; i<n; ++i) {\n    if (S>>i&1) continue;\n    bool f = true;\n    rep(j,i) {\n      if (S>>j&1) continue;\n      if (abs(circle[i].p - circle[j].p) < circle[i].r + circle[j].r)\n        f = false;\n    }\n    if (f) {\n      hoge[circle[i].c].push_back(i);\n    }\n  }\n\n  // cout<<\"S = \"<<S<<endl;\n  // for(int i=0; i<4; ++i) {\n  //   cout<<i<<\" size = \"<<hoge[i].size()<<endl;\n  //   for(int j=0; j<hoge[i].size(); ++j)\n  //     cout<<hoge[i][j]<<\" \";\n  //   cout<<endl;\n  // }\n  rep(i,4) {\n\n    if(hoge[i].size() <= 1) continue;\n    for(int j=0; j<hoge[i].size(); ++j)\n      for(int k=j+1; k<hoge[i].size(); ++k) {\n        ret = max(ret, 2+dfs(S|(1<<(hoge[i][j]))|(1<<(hoge[i][k]))));\n      }\n  }\n  return memo[S] = ret;\n}\n\nint main() {\n  while(cin >> n,n) {\n    memset(memo, -1, sizeof(memo));\n    circle.clear();\n    circle.resize(n);\n    rep(i,n) {\n      int x,y,r,c;\n      cin >> x>>y>>r>>c;\n      c--;\n      circle[i] = (C){P(x,y),r,c};\n    }\n    cout << dfs(0)<< endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct Disc {\n  int x, y, r, c, on, id;\n};\n\nconst int MAX_N = 24;\nint N;\nvector<Disc> vd[4];\nchar T[1<<MAX_N];\n\nint isIntersect(const Disc &a, const Disc &b) {\n  int dx = a.x - b.x;\n  int dy = a.y - b.y;\n  int sr = a.r + b.r;\n  if(dx*dx+dy*dy == sr*sr) return 1;\n  if(dx*dx+dy*dy < sr*sr) return 2;\n  return 0;\n}\n\nint solve() {\n  for(int S = (1<<N)-1; S >= 0; --S) {\n    T[S] = 0;\n    for(int i = 0; i < 4; ++i) {\n      for(int j = 0; j < vd[i].size(); ++j) {\n\tif(S & (1<<vd[i][j].id)) continue;\n\tif((S & vd[i][j].on) != vd[i][j].on) continue;\n\tfor(int k = j+1; k < vd[i].size(); ++k) {\n\t  if(S & (1<<vd[i][k].id)) continue;\n\t  if((S & vd[i][k].on) != vd[i][k].on) continue;\n\t  T[S] = max(T[S], (char)(T[S | (1<<i) | (1<<j)]+2));\n\t}\n      }\n    }\n  }\n  return T[0];\n}\n\nint main() {\n  while(cin >> N && N) {\n    int id = 0;\n    for(int i = 0; i < 4; ++i) vd[i].clear();\n    for(int i = 0; i < N; ++i) {\n      Disc d;\n      cin >> d.x >> d.y >> d.r >> d.c;\n      --d.c;\n      d.id = id++;\n      d.on = 0;\n      for(int i = 0; i < 4; ++i) {\n\tfor(int j = 0; j < vd[i].size(); ++j) {\n\t  if(isIntersect(d, vd[i][j]) == 2) d.on |= 1<<vd[i][j].id;\n\t}\n      }\n      vd[d.c].push_back(d);\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n\n\nstruct Disc{\n\tint x,y,r,c;\n\tDisc(int p_x,int p_y,int p_r,int p_c){\n\t\tx=p_x;y=p_y;r=p_r;c=p_c;\n\t}\n\tDisc(){};\n};\n\nint n;\nint memo[1<<24];\nbool exist[24];\nDisc D[24];\nint ans;\n\nbool touch(Disc a,Disc b){\n\treturn (a.r+b.r)*(a.r+b.r)>(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n}\n\nbool top(int k){\n\tfor(int i=k-1;i>=0;i--){\n\t\tif(exist[i]){\n\t\t\tif(touch(D[k],D[i])) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\n\nint dfs(int bit,int num){\n\tif(memo[bit]>=0) return memo[bit];\n\tint res=num;\n\n\tfor(int i=0;i<n;i++){\n\t\tif(exist[i] && top(i)){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(exist[j] && top(j) && i!=j && D[i].c==D[j].c){\n\t\t\t\t\texist[i]=false;\n\t\t\t\t\texist[j]=false;\n\t\t\t\t\tres=max(res,dfs((bit&(~1<<i))&(~1<<j),num+2));\n\t\t\t\t\texist[i]=true;\n\t\t\t\t\texist[j]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemo[bit]=res;\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin>>n && n!=0){\n\t\tans=0;\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tmemset(exist,true,sizeof(exist));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y,r,c;\n\t\t\tcin>>x>>y>>r>>c;\n\t\t\tD[i]=Disc(x,y,r,c);\n\t\t}\n\t\tcout<<dfs((1<<24)-1,0)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define MAX_COLORS 6\n#define MAX_CIRCLES 4\n#define MAX_N (MAX_COLORS*MAX_CIRCLES)\n#define MAX_STATES (1<<MAX_N)\n\nint biggest, n;\n\nstruct circle{\n    int x, y, r, c;\n};\n/*\nint X[MAX_N];\nint Y[MAX_N];\nint R[MAX_N];\nint C[MAX_N];*/\n\ncircle C[MAX_N];\nchar dp[MAX_STATES];\n\nbool isOver( circle c1, circle c2 ){\n    int dx, dy;\n    dx = (c1.x - c2.x) * (c1.x - c2.x);\n    dy = (c1.y - c2.y) * (c1.y - c2.y);\n    return dx + dy < (c1.r + c2.r)*(c1.r + c2.r) ? true : false;\n}\n\nbool isDeleted( int state, int num ){\n    return (state & (1<<num)) == 0 ? false : true;\n}\n/*\nvoid pbit(int num){\n    //cout << \"bit: \";\n    do{\n        printf(\"%d\", num&1);\n        num = num>>1;\n    }while(num);\n    //printf(\"\\n\");\n}*/\n\nbool isTop( int state, int num ){\n    //pbit(state);\n    for( int i = num-1; i >= 0; i-- ){\n        if( isDeleted(state, i) ) continue;\n        if( isOver(C[num], C[i]) ) return false;\n    }\n    //cout << num << \" is top\" << endl;\n    return true;\n}\n\nvoid search(int s){\n    //for( int s = 0; s < 1<<n; s++ ){\n        /*cout << \"s: \";\n        pbit(s);\n        cout << endl;\n        */\n        for( int i = 0; i < n; i++ ){\n            if( isDeleted(s, i) ) continue;\n            //cout << \"i: \" << i << endl;\n            for( int j = i+1; j < n; j++ ){\n                if( isDeleted(s, j) ) continue;\n                //cout << \"i: \" << i << endl;\n                //cout << \"j: \" << j << endl;\n                if( isTop(s, i) && isTop(s, j) && C[i].c == C[j].c ){\n                    int next = s | 1<<i | 1<<j;\n                    bool visited;\n                    visited = dp[next] == -1 ? false : true;\n                    //next(s);\n                    //cout << \",\" << i << \",\" << j << endl;\n                    if( dp[next] < dp[s]+2 ) dp[next] = dp[s]+2;\n                    if( biggest < dp[next] ) biggest = dp[next];\n                    if( (next|1) != (1<<n)-1 && !visited ) search(next);\n                }\n            }\n        }\n    //}\n}\n\nvoid init(){\n    for( int s = 0; s < 1<<n; s++ ){\n        dp[s] = -1;\n    }\n}\n\nint main(){\n    while( cin >> n, n ){\n        for( int i = 0; i < n; i++ ){\n            circle a;\n            //scanf(\"%d%d%d%d\", a.x, a.y, a.r, a.c);\n            cin >> a.x >> a.y >> a.r >> a.c;\n            C[i] = a;\n        }\n        biggest = 0;\n        init();\n        dp[0] = 0;\n        search(0);\n        printf(\"%d\\n\", biggest);\n        //cout << \"ans: \" << biggest << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n#define rep(i, a, b) for (int i = (a); i < ((int)b); ++i)\n#define rrep(i, a, b) for (int i = (int)(b) - 1; i >= ((int)a); --i)\n#define sz(c) ((int)c.size())\n\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing pii = pair<int, int>;\n\nvoid dump_impl(string s) {}\ntemplate <class H, class... T>\nvoid dump_impl(string s, H head, T... tail) {\n    int p = 0;\n    rep(i, 0, s.size()) {\n        char x = s[i];\n        if (p == 0 && x == ',') {\n            cerr << \" = \" << head << \", \";\n            dump_impl(s.substr(i + 1), tail...);\n            return;\n        } else {\n            cerr << x;\n            if (x == '(') p++;\n            if (x == ')') p--;\n        }\n    }\n}\n#ifdef LOCAL\n#define dump(...) do { cerr << \"\\x1b[33;1m\"; dump_impl(#__VA_ARGS__ \",\", __VA_ARGS__); cerr << \"\\x1b[0m\" << endl; } while (0)\n#else\n#define dump(...)\n#endif\n\nconst int INF = 1e9;\n\nstruct Circle {\n    pii c;\n    int r;\n};\n\nint sq(int x) { return x * x; }\nint sq_dist(int x1, int y1, int x2, int y2) {\n    return sq(x1 - x2) + sq(y1 - y2);\n}\n\nvoid solve(int N) {\n    vector<vector<int>> color(4);\n    vector<Circle> C;\n    rep(i, 0, N) {\n        int x, y, r, c;\n        cin >> x >> y >> r >> c;\n        c--;\n        C.emplace_back(Circle {{x, y}, r});\n        color[c].emplace_back(C.size() - 1);\n    }\n\n    auto over = [&](int i, int j) {\n        return sq_dist(C[i].c.first, C[i].c.second, C[j].c.first, C[j].c.second) < sq(C[i].r + C[j].r);\n    };\n\n    vvi G(N);\n    rep(i, 0, sz(C)) {\n        rep(j, i + 1, sz(C)) {\n            if (i == j) continue;\n            if (over(i, j)) {\n                G[i].push_back(j);\n            }\n        }\n    }\n    vector<int> mask(N);\n    rep(v, 0, N) {\n        for (int w : G[v]) {\n            mask[w] |= 1 << v;\n        }\n    }\n\n    // rep(v, 0, N) {\n    //     for (int w : G[v]) {\n    //         dump(v, w);\n    //     }\n    //     dump(v, bitset<10>(mask[v]));\n    // }\n\n    vector<int> memo(1 << N, INF);\n    auto rec = [&](auto fun, int S) -> int {\n        auto &MEMO = memo[S];\n        if (MEMO != INF) return MEMO;\n\n        int ret = 0;\n        rep(c, 0, 4) {\n            rep(i, 0, sz(color[c])) {\n                if (S & mask[color[c][i]]) continue;\n                rep(j, i + 1, sz(color[c])) {\n                    if (S & mask[color[c][j]]) continue;\n                    if ((S >> color[c][i] & 1) && (S >> color[c][j] & 1)) {\n                        int nS = S ^ (1 << color[c][i]) ^ (1 << color[c][j]);\n                        ret = max(ret, fun(fun, nS) + 2);\n                    }\n                }\n            }\n        }\n        return MEMO = ret;\n    };\n    cout << rec(rec, (1 << N) - 1) << endl;\n}\n\nsigned main() {\n    while (1) {\n        int N;\n        cin >> N;\n        if (N == 0) break;\n        solve(N);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n\n\nusing namespace std;\n\nvector<double> x;\nvector<double> y;\nvector<double> r;\nvector<double> c;\nvector<bool> tops;\n\nint dp[1<<24];\n\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n\n    if (n == 0) {\n      break;\n    }\n\n    x.resize(n);\n    y.resize(n);\n    r.resize(n);\n    c.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n\n\n    int ans = 0;\n\n    \n    memset(dp, 0, sizeof(dp));\n    for (int i = 0; i < (1 << n); i++) {\n      tops.resize(n, false);\n      int popcnt = 0;\n      for (int j = 0; j < n; j++) {\n        if (i & (1 << j)) {\n          popcnt++;\n        }\n      }\n      if (popcnt % 2 == 1) {\n        continue;\n      }\n      // テ」ツつづ」ツ?? jテ」ツ?ィkテ」ツ?古・ツ渉姪」ツつ古」ツつ凝」ツ?ェテ」ツつ?\n      for (int a = 0; a < n; a++) {\n        if (i & (1 << a)) {\n          tops[a] = false;\n          continue;\n        }\n        for (int b = a + 1; b < n; b++) {\n          if (i & (1 << b)) {\n            tops[b] = false;\n            continue;\n          }\n          // iテ」ツ?ョテ」ツ?サテ」ツ??」ツ?古「ツ??\n          double distance2 = pow(x[a] - x[b], 2) + pow(y[a] - y[b], 2);\n          if (distance2 < pow(r[a] + r[b], 2)) {\n            tops[b] = false;\n          }\n        }\n      }\n      for (int j = 0; j < n; j++) {\n        for (int k = j + 1; k < n; k++) {\n          if (c[j] == c[k]) {\n            if (tops[j] && tops[k]) {\n              // dp[i | (j, k) << c] = max(dp[i | (j, k) << c], dp[i] + 1);\n              int bit = i | (1 << j) | (1 << k);\n              dp[bit] = max(dp[bit], dp[i] + 1);\n              ans = max(ans, dp[bit]);\n            }\n          }\n        }\n      }\n    }\n    \n    cout << ans * 2 << endl;\n\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint n, ans = 0;\nint x[25], y[25], r[25], c[25];\n\nbool overlap(int i, int j){\n    return (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j]) * (r[i]+r[j]);\n}\n\nvoid dfs(VI f){\n    int res = 0;\n    REP(i,n) res += f[i];\n    ans = max(ans, res);\n\n    VI top(n);\n    REP(i,n){\n        if (f[i]) continue;\n        bool g = 1;\n        REP(j,i){\n            if (f[j]) continue;\n            if (overlap(i,j)) g = 0;\n        }\n        top[i] = (!f[i] & g);\n    }\n\n    REP(i,n) REP(j,i){\n        if (!top[i] || !top[j] || c[i] != c[j]) continue;\n        f[i] = f[j] = 1;\n        dfs(f);\n        f[i] = f[j] = 0;\n    }\n}\n\nint main() {\n    while (cin >> n && n){\n        VI f(n);\n        REP(i,n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n        dfs(f);\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct disk{\n    int x,y,r,c;\n    disk(int x, int y, int r, int c):x(x),y(y),r(r),c(c){}\n    disk(){}\n};\n    \nbool dfs(int n, int bit, vector<vector<int> > &adj){\n    for(int i=0; i<(int)adj[n].size(); i++){\n        if((1<<adj[n][i] & bit)==0) return false;\n    }\n    return true;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        vector<disk> d(n);\n        vector<vector<int> > adj(n);\n        for(int i=0; i<n; i++){\n            int x,y,r,c;\n            cin >> x >> y >> r >> c;\n            d[i] = disk(x,y,r,c);\n            for(int j=0; j<i; j++){\n                if((x-d[j].x)*(x-d[j].x)+(y-d[j].y)*(y-d[j].y) < (r+d[j].r)*(r+d[j].r)){\n                    adj[i].push_back(j);\n                }\n            }\n        }\n\n        vector<vector<int> > dp(n/2+1, vector<int>(1<<n, 0));\n        int ans=0;\n        for(int i=0; i<n/2; i++){\n            for(int j=0; j<(1<<n); j++){\n                int countbit=0;\n                for(int k=0; k<n; k++){\n                    if((1<<k & j) != 0) countbit++;\n                }\n                if(countbit != i*2) continue;\n                for(int s=0; s<n; s++){\n                    if((1<<s & j) != 0 || !dfs(s, j, adj)) continue;\n                    for(int t=0; t<n; t++){\n                        if(s==t || (1<<t & j) != 0 || !dfs(t, j, adj)) continue;\n                        dp[i+1][j|s|t] = max(dp[i+1][j|s|t], dp[i][j]+2);\n                        ans = max(ans, dp[i+1][j|s|t]);\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef unsigned int uint;\ntypedef vector<int> VI;\ntypedef vector<double> VD;\ntypedef vector<vector<int> > VV;\n\nconst int INF = 1 << 28;\nconst double EPS = 1e-9;\n\nint n;\nVV par;\nVD x, y, r;\nVI c;\nmap<int,int> m;\n\nstring toString (int era) {\n    string str;\n    for (int i = 0; i < n; i++) {\n        str = (era % 2 ? \"1\" : \"0\") + str;\n    }\n\n    return str;\n}\n\nint dfs (int era) {\n    if (era == ((1 << n) - 1)) return 0;\n    int cera = ((1 << n) - 1) ^ era;\n    if (m.find(cera) != m.end()) {\n        return m[cera];\n    }\n    \n    VV count(5);\n    rep (i,n) {\n        bool flag = true;\n        if (era & (1 << i)) continue; \n        rep(j,par[i].size()) {\n            if (cera & (1 << par[i][j])) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            count[c[i]].push_back(i);\n        }\n    }\n\n    int ret = 0;\n    REP(i,1,5) {\n        if (count[i].size() >= 2) {\n            rep(j,count[i].size()-1) REP(k,j+1,count[i].size()) {\n                int tera = era;\n                tera |= (1 << count[i][j]);\n                tera |= (1 << count[i][k]);\n                ret = max(ret, dfs(tera) + 2);\n            }\n        }\n    }\n\n    return m[cera] = ret;\n}\n\nint main()\n{\n    while (cin >> n, n) {\n        x.resize(n), y.resize(n), r.resize(n), c.resize(n);\n        m.clear();\n        \n        rep(i, n) {\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n        \n        par.clear();\n        par.resize(n);\n        rep(i,n) rep(j,i) {\n            double dis = pow(x[i] - x[j], 2.) + pow(y[i] - y[j], 2.);\n            if (sqrt(dis) < r[i] + r[j]) {\n                par[i].push_back(j);\n            }\n        }\n\n        cout << dfs(0) << endl;\n    }\n                \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\n\nclass state{\npublic:\n    P p;\n    double r;\n    int c;\n};\n\nbool onCircle(state a, state b){\n    return (abs(a.p-b.p) < a.r+b.r);\n}\n\nshort int a[1<<24];\nint n;\nstate v[24];\nint ans, over[24];\n\nvoid check(int pos){\n    int c = 0;\n    for(int i=0;i<n-1;i++){\n        if((pos & (1<<i)) == 0 && (c & (1<<i)) == 0){\n            c |= over[i];\n            for(int j=i+1;j<n;j++){\n                if((pos & (1<<j)) == 0 && (c & (1<<j)) == 0 && v[i].c == v[j].c){\n                    int next = pos | (1<<i) | (1<<j);\n                    a[next] = a[pos] + 2;\n                    ans = max((short int)ans,a[next]);\n                    check(next);\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    while(cin >> n && n){\n        fill(over,over+n,0);\n        fill(a,a+(1<<n),0);\n        ans = 0;\n        for(int i=0;i<n;i++){\n            double x,y;\n            cin >> x >> y >> v[i].r >> v[i].c;\n            v[i].p = P(x,y);\n        }\n\n        for(int i=0;i<n;i++)\n            for(int j=i+1;j<n;j++)\n                if(onCircle(v[i],v[j]))\n                    over[i] |= (1<<j);\n\n        for(int i=0;i<n;i++)\n            for(int j=n-1;j>i;j--)\n                over[i] |= over[j];\n\n        check(0);\n\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//And Then. How Many Are There?\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct C{\n  int c; //???\n  int x, y; //????????§?¨?\n  int r; //??????\n  C(){}\n  C(int x, int y, int r, int c){\n    this->x = x;\n    this->y = y;\n    this->r = r;\n    this->c = c;\n  }\n};\n\nint n;\nC data[24];\nint bit[24]; //??????????????¨???????????????\nint dp[1<<24];\n\n//a??¨b???????????????true\nbool dis(C a, C b){\n  return (((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y)) < (a.r+b.r)*(a.r+b.r));\n}\n\n//b:??????????????????????????¨???????????????\nint solve(int b){\n  if(b == (1<<n)-1)return 0;\n  if(dp[b]!=-1)return dp[b];\n\n  int mx=0;\n  for(int i=0; i<n-1; i++){//1???????????????\n    if(bit[i]&b != bit[i])continue;//??????????????????\n    if((b&(1<<i))!=0)continue;//??¢??????????????????\n   \n    for(int j=i+1; j<n; j++){//2???????????????\n      if(bit[j]&b != bit[j])continue;//??????????????????\n      if((b&(1<<j))!=0)continue;//??¢??????????????????\n      if(data[i].c != data[j].c)continue;//????????????\n\n      int tmp_b = (b|(1<<i))|(1<<j);\n      int tmp_mx = solve(tmp_b)+2;\n      if(mx<tmp_mx)mx=tmp_mx;\n    }\n  }\n  return dp[b]=mx;\n}\n\nint main(){\n  while(cin >> n, !(n==0)){\n    memset(bit, 0, sizeof(bit));\n    memset(dp, -1, sizeof(dp));\n    for(int i=0; i<n; i++){\n      int x, y, r, c;\n      cin >> x >> y >> r >> c;\n      C tmp(x, y, r, c);\n      data[i]=tmp;\n      for(int j=0; j<i; j++){\n\tif(dis(data[i], data[j]))bit[i] = bit[i]|(1<<j);\n      }\n    }\n    cout<<solve(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n\nint n;\nint circle[24][4];\nint bitDP[(1<<24)]; // ??????????????????bit??§??????\nint overlap[24]; // ?????????????????????bit??§??????\n\nint main()\n{\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcin >> circle[i][0];\n\t\t\tcin >> circle[i][1];\n\t\t\tcin >> circle[i][2];\n\t\t\tcin >> circle[i][3];\n\t\t\t\n\t\t\toverlap[i] = 0;\n\t\t\tfor(int j = 0; j < i; j++) {\n\t\t\t\tint distance_x = circle[i][0] - circle[j][0];\n\t\t\t\tint distance_y = circle[i][1] - circle[j][1];\n\t\t\t\tdouble distance_circle = sqrt(pow(distance_x, 2) + pow(distance_y, 2));\n\t\t\t\tif(circle[i][2] + circle[j][2] > distance_circle) {\n\t\t\t\t\toverlap[i] += (1 << j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(bitDP, 0, sizeof(bitDP));\n\t\t\n\t\tint ans = 0;\n\t\tfor(int bit = 0; bit < (1 << n); bit++) {\n\t\t\tif(bit != 0 && bitDP[bit] == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tif(((1 << i) & bit)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int j = i+1; j < n; j++) {\n\t\t\t\t\tif(((1 << i) | (1 << j)) & bit) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(!(((overlap[i] & bit) == overlap[i]) && ((overlap[j] & bit) == overlap[j]))) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(circle[i][3] == circle[j][3]) {\n\t\t\t\t\t\tint next = (((1 << i) | (1 << j)) | bit);\n\t\t\t\t\t\tbitDP[next] = max(bitDP[next], bitDP[bit] + 2);\n\t\t\t\t\t\tans = max(ans, bitDP[next]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvvi color(4);\n\t\tvi x(n), y(n), r(n), c(n);\n\t\tREP(i, n) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t\tc[i]--;\n\t\t\tcolor[c[i]].push_back(i);\n\t\t}\n\t\tvi b(1 << n, 0);\n\t\tb[(1 << n) - 1] = 1;\n\t\tvvi g(n);\n\t\tvi d(n, 0);\n\t\tREP(i, n)FOR(j, i + 1, n) {\n\t\t\tif ((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) < (r[i] + r[j])*(r[i] + r[j])) {\n\t\t\t\tg[i].push_back(j);\n\t\t\t\td[j]++;\n\t\t\t}\n\t\t}\n\t\tqueue<int> q;\n\t\tq.push((1 << n) - 1);\n\t\twhile (!q.empty()) {\n\t\t\tint bit = q.front(); q.pop();\n\n\t\t\tvi a = d;\n\t\t\tREP(i, n) {\n\t\t\t\tif ((bit&(1 << i)) == 0) {\n\t\t\t\t\tREP(j, g[i].size()) {\n\t\t\t\t\t\ta[g[i][j]]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(i, n)FOR(j, i + 1, n) {\n\t\t\t\tif (c[i] == c[j] && (bit&(1 << i)) && (bit&(1 << j)) && a[i] == 0 && a[j] == 0) {\n\t\t\t\t\tif (b[bit ^ i ^ j] == 0)q.push(bit ^ i ^ j);\n\t\t\t\t\tb[bit ^ i ^ j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tREP(i, 1 << n) {\n\t\t\tif (b[i] == 0)continue;\n\t\t\tint cnt = n;\n\t\t\tREP(j, n)if (i&(1 << j))cnt--;\n\t\t\tchmax(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <string.h>\n\nusing namespace std;\n\nconst int MAX_N = 24;\n\nclass Circle {\npublic:\n\tint x, y, r, c; // 中心のxy座標、半径、色番号\n};\n\n/* 入力 */\nint n; // 円盤の枚数\nCircle cir[MAX_N]; // 円の情報\n\n/*\nS:すでに取り除いた円の集合(bitで表す、右から円番号0,1,2,...,MAX_N)\ndp[S]:ここから取り除ける最大枚数\n漸化式\ndp[全部取り除いた] = n\ndp[S] = max(dp[S U 取り除いた2つの円]+2)\n*/\nint dp[1 << MAX_N];\n\n/* 2点間の距離 */\ndouble dis(int x1, int y1, int x2, int y2) {\n\treturn sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));\n}\n\n/* 円kが上に1枚でも重なっているかどうか、重なっていたらtrue */\nbool ispiled(int k, int S) {\n\tfor (int i = k - 1; i >= 0; i--) {\n\t\tif (dis(cir[i].x, cir[i].y, cir[k].x, cir[k].y) < cir[i].r + cir[k].r && !(S >> i & 1)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n/*\nbool ispiled(Circle c1, Circle c2) {\n\tif (dis(c1.x, c1.y, c2.x, c2.y) < c1.r + c2.r) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n*/\n\n/* S:すでに取り除いた円盤の集合 */\nint remove(int S) {\n\t//cout << \"S = \" << S << \" dp[\" << S << \"]: \" << dp[S] << endl;\n\tif (dp[S] >= 0) {\n\t\treturn dp[S];\n\t}\n\t\n        /* 全部取り除いた */\n\tif (S == ((1 << n) - 1)) {\n\t\treturn dp[S] = n;\n\t}\n\n\tint res = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t/* どちらかがすでに取り除かれているか、2つの色が違うか、2枚のうち1枚以上が下にあれば取り除けないので次の組へ */\n\t\t\tif (S >> i & 1 || S >> j & 1 || cir[i].c != cir[j].c || ispiled(i, S) || ispiled(j, S)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (true) {\n\t\t\t\tint tmp = S | 1 << i;\n\t\t\t\ttmp = tmp | 1 << j;\n\t\t\t\tres = max(res, remove(tmp) + 2);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[S] = res;\n}\n\nint main() {\n\t// 方針: bitDP\n\t//const int MAX_N = 24;\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> cir[i].x >>cir[i].y >> cir[i].r >> cir[i].c;\n\t\t}\n\t\tmemset(dp, -1, sizeof(dp));\n\t\t//cout << \"test\" << endl;\n\t\tcout << remove(0) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\nconstexpr int MAX_N = 1 << 24;\nint b[25];\n\nbool intersects(vector<int> &x, vector<int> &y, vector<int> &r, int i, int j) {\n    int dx = (x[i] - x[j]) * (x[i] - x[j]);\n    int dy = (y[i] - y[j]) * (y[i] - y[j]);\n    int dist1 = dx + dy;\n    int dist2 = (r[i] + r[j]) * (r[i] + r[j]);\n    return dist1 < dist2;\n}\n\nint main() {\n\n    while (true) {\n\n        int N;\n        cin >> N;\n\n        if (N == 0) break;\n\n        vector<int> x(N), y(N), r(N), c(N);\n        for (int i = 0; i < N; i++) cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n        //上からi枚目\n        for (int i = 0; i < N; i++) {\n            b[i] = 0;\n            //i枚目よりあとに降ってきたものを見る\n            for (int j = 0; j < i; j++) {\n                if (intersects(x, y, r, i, j)) b[i] |= (1 << j);\n            }\n        }\n\n        vector<int> dp(1 << N, -1);\n        int ans = 0;\n        int to = (1 << N);\n        dp[0] = 0;\n\n        //すべての円の使い方の状態を見る\n        for (int i = 0; i < to; i++) {\n            //このような円の状態はありえない\n            if (dp[i] == -1) continue;\n\n            //消せる円盤のペア(j, k)を探す\n            for (int j = 0; j < N - 1; j++) {\n                if ((i & (1 << j)) != 0 || (i & b[j]) != b[j]) continue;\n\n                //jより下にあるkをさがす\n                for (int k = j + 1; k < N; k++) {\n                    if (c[j] != c[k] || (i & (1 << k)) != 0 || (i & b[k]) != b[k]) continue;\n\n                    int next = i | (1 << j) | (1 << k);\n                    dp[next] = max(dp[next], dp[i] + 2);\n\n                }\n            }\n        }\n\n        for (int i = 0; i < (1 << N); i++) ans = max(ans, (int) dp[i]);\n        cout << ans  << endl;\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=(n);i<(int)(N);i++)\n#define ck(n,a,b) (a)<=(n)&&(n)<=(b)\n#define p(s) cout<<(s)<<endl\n#define F first\n#define S second\ntypedef long long ll;\nusing namespace std;\n\nstruct ST{\n\tint x, y, r, c;\n\tvector<int> up;\n};\nST enban[25];\nint n;\n\n\nint dfs(bool remove[]){\n\tvector<int> c[4];//enbango\n\n\tREP(i,0,n){\n\t\tbool ok=true;\n\t\tif(remove[i]) continue;\n\t\tfor(auto u: enban[i].up){\n\t\t\tif(!remove[u]){\n\t\t\t\tok=false;\n\t\t\t}\n\t\t}\n\t\tif(ok)c[enban[i].c].push_back(i);\n\t}\n\tbool flag=false;\n\tREP(j,0,4){\n\t\tif(c[j].size()%2) continue;\n\t\tfor(auto v:c[j]) {\n\t\t\tremove[v] = true;\n\t\t\tflag=true;\n\t\t}\n\t}\n\tint ret=0;\n\tif(flag) ret=dfs(remove);\n\tREP(i,0,4){\n\t\tif(c[i].size()==3||c[i].size()==5){\n\t\t\tbool tmp_remove[25];\n\t\t\tREP(j,0,n) tmp_remove[j] = remove[j];\n\t\t\tREP(j,0,c[i].size()){\n\t\t\t\tREP(j,0,c[i].size()){\n\t\t\t\t\ttmp_remove[c[i][j]]=true;\n\t\t\t\t}\n\t\t\t\ttmp_remove[c[i][j]]=false;\n\t\t\t\tret=max(ret,dfs(tmp_remove));\n\t\t\t}\n\t\t}\n\t}\n\treturn max<int>(ret,count(remove,remove+n,true));\n}\n\nint main() {\n\twhile(cin>>n, n){\n\n\t\tbool remove[25];\n\t\tREP(i, 0, 25) remove[i]=false;\n\t\tREP(i, 0, n){\n\t\t\tcin>>enban[i].x>>enban[i].y>>enban[i].r>>enban[i].c;\n\t\t\tenban[i].c--;\n\t\t\tenban[i].up.clear();\n\t\t}\n\n\t\t// ????????????????????????\n\t\tREP(i, 1, n){\n\t\t\tREP(j, 0, i){\n\t\t\t\tint r=(enban[i].x-enban[j].x)*(enban[i].x-enban[j].x)\n\t\t\t\t\t\t\t\t\t\t\t\t+ (enban[i].y-enban[j].y)*(enban[i].y-enban[j].y);\n\t\t\t\tint R=(enban[i].r+enban[j].r) * (enban[i].r+enban[j].r);\n\n\t\t\t\tif(r<R) enban[i].up.push_back(j);\n\t\t\t}\n\t\t}\n\t\t//REP(i,0,n){\n\t\t//cout<<enban[i].up.size()<<endl;\n\t\t//}\n\t\t// dfs\n\t\tp(dfs(remove));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "import java.util.*;\n\nimport javax.swing.Box.Filler;\n\npublic class Main {\n\tCoin[] coins;\n\tScanner sc = new Scanner(System.in);\n\tboolean[] lapped;\n\tint n;\n\tint[] state;\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\tcoins = new Coin[n];\n\t\t\tlapped = new boolean[n];\n\t\t\tfor(int i=0;i<n;i++) coins[i] = new Coin();\n\t\t\tint S=(1<<n)-1;\n\t\t\tstate = new int[1<<n];\n\t\t\tfor(int i=0;i<(1<<n);i++) state[i] = -1;\n\t\t\tSystem.out.println(solve(S));\n\t\t}\n\t}\n\t\n\tint solve( int S ) {\n//\t\tSystem.out.println(S);\n\t\tif( S == 0 ) return 0;\n\t\tif (state[S] >= 0) return state[S];\n\t\tanalyseLapped(S);\n//\t\tfor(int i=0;i<n;i++) System.out.print(lapped[i] + \" \");\n//\t\tSystem.out.println();\n//\t\tsc.next();\n\t\tint cnt = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif( ((S>>i) & 1) != 1 || lapped[i] ) continue;\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif ( ((S>>j) & 1) == 1 && !lapped[j] && coins[i].c == coins[j].c ) {\n\t\t\t\t\tcnt = Math.max(cnt, solve(S-((1<<i) + (1<<j)))+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn state[S] = cnt;\n\t}\n\t\n\tvoid analyseLapped(int S) {\n\t\tfor(int i=0;i<n;i++) lapped[i] = false;\n\t\tfor(int i=0;i<n;i++) {\n//\t\t\tSystem.out.println( (S>>i) & 1 );\n\t\t\tif( ((S>>i) & 1) != 1 ) continue;\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif( ((S>>j) & 1) != 1 ) continue;\n//\t\t\t\tSystem.out.println(coins[i].isLapped(coins[j]));\n\t\t\t\tif( coins[i].isLapped(coins[j]) ) lapped[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\tprotected class Coin {\n\t\tint x, y, r, c;\n\t\t\n\t\tpublic Coin() {\n\t\t\tscan();\n\t\t}\n\t\t\n\t\tvoid scan() {\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\t\t\tr = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t}\n\t\t\n\t\tboolean isLapped( Coin c ) {\n\t\t\treturn (c.x-x)*(c.x-x)+(c.y-y)*(c.y-y) < (r+c.r)*(r+c.r);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//線分を表す構造体\nstruct Segment{ Point p1, p2; };\n//直線を表す構造体\ntypedef Segment Line;\n//多角形を表す構造体\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// 許容する誤差\n#define EPS (1e-10)\n\n// ベクトルaの絶対値を求める\n//double length = abs(a);\n\n// 2点a,b間の距離を求める\n//double distance = abs(a-b);\n\n/*\n// ベクトルaの単位ベクトルを求める\nPoint b = a / abs(a);\n\n// ベクトルaの法線ベクトルn1,n2を求める\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 点cが直線a,b上にあるかないか\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// 点a,bを通る直線と点cとの距離\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// 線分s1と線分s2の距離\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// 線分sに対する点pの射影\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//線分sを対象軸とした点pの線対称の点\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//点pをangle分だけ時計回りに回転\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//円cと線分lの交点\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//点の内包\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//ベクトルの位置検出\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//凸包\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISEだと内角は180以下（一直線上に並んでいても、頂点として数える）\n        //!= CLOCKWISEだと内角は180未満（一直線上の頂点は数えない）\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //ここも == と != を変更する\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //最も下にある点の中で最も右にある点から反時計回りに並び替え\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//キャリパー法を用いて凸多角形の直径を求める\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//凸多角形の切り取りに使う関数。これがなんなのかはまだ知らない。\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//三角形の面積\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//多角形の面積\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//凸多角形かどうかの判定\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//凹多角形を線分lで切断した際の多角形の数\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\n//i番目を0にする\nint clearBit(int num, int i){\n\tint mask = ~(1 << i);\n\treturn num & mask;\n}\n\n//i番目をvで置き換える\nint updateBit(int num, int i, int v){\n\tint mask = ~(1 << i);\n\treturn (num & mask) | (v << i);\n}\n\nint n, ans;\n\nbool isOver(Circle a, Circle b){\n\tpair<Point,Point> tmp = getCrossPoints(a,b);\n\tdouble na = tmp.first.imag();\n    return std::isnan(na) == 0;\n}\n\nvoid dfs(vector<vector<int>>& g, int cur, vector<int>& on){\n\tfor(auto to : g[cur]){\n\t\ton[to] = on[to] bitor (1 << cur) bitor on[cur];\n\t\tdfs(g, to, on);\n\t}\n}\n\nvector<bool> memo;\nvoid dfs(int s, vector<int>& on, vector<int> c){\n\tif(memo[s]) return;\n\n\tvector<vector<int>> canTake(4);\n\trep(i,n){\n\t\tif(getBit(s,i)) continue;\n\t\tif((on[i] bitand s) == on[i]){\n\t\t\tcanTake[c[i]].emplace_back(i);\n\t\t}\n\t}\n\n\tvector<int> take(4,0);\n\trep(i,4){\n\t\tfor(auto j : canTake[i]){\n\t\t\ttake[i] = setBit(take[i], j);\n\t\t}\n\t}\n\n\trep(i,4){\n\t\tif(canTake[i].size() >= 2){\n\t\t\tif(canTake[i].size() % 2 == 1){\n\t\t\t\trep(j,canTake[i].size()){\n\t\t\t\t\tdfs(s bitor clearBit(take[i], canTake[i][j]), on, c);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdfs(s bitor take[i], on, c);\n\t\t\t}\n\t\t}\n\t}\n\n\tbitset<30> bit(s);\n\tans = max<int>(ans, bit.count());\n\tmemo[s] = true;\n}\n\nint main(){\n    while(scanf(\"%d\",&n),n){\n        vector<Circle> c(n);\n        vector<int> color(n);\n        rep(i,n){\n            double x,y,r;\n            scanf(\"%lf%lf%lf%d\",&x,&y,&r,&color[i]);\n\t\t\tcolor[i]--;\n            c[i] = {Point(x,y),r};\n        }\n\n\t\tvector<vector<int>> g(n);\n\t\tvector<bool> top(n,1);\n\t\trep(i,n){\n\t\t\trange(j,i + 1,n){\n\t\t\t\tif(isOver(c[i], c[j])){\n\t\t\t\t\tg[i].emplace_back(j);\n\t\t\t\t\ttop[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> on(n,0);\n\t\trep(i,n){\n\t\t\tif(not top[i]) continue;\n\t\t\tdfs(g, i, on);\n\t\t}\n\t\t//rep(i,n) show(on[i])\n\n\t\tans = 0;\n\t\tmemo = vector<bool>(1 << n, 0);\n\t\tdfs(0, on, color);\n\t\tcout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nchar dp[1<<24];\nint n, x[25], y[25], r[25], c[25], up[25];\n\nint main(){\n\tint i, j,k, ans;\n\twhile(1){\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tans = 0;\n\t\tfor(i=0;i<(1<<n);i++) dp[i]=0;\n\t\tfor(i=0;i<24;i++) up[i] = 0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tcin >> x[j] >> y[j] >> r[j] >> c[j];\n\t\t}\n\t\tfor(i=0;i<n-1;i++){\n\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\tif(pow(x[i]-x[j],2)+pow(y[i]-y[j],2) < pow(r[i]+r[j],2)){\n\t\t\t\t\tup[j] += 1<<i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<(1<<n);i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tfor(k=j+1;k<n;k++){\n\t\t\t\t\tif((i&(1<<j))&&(i&(1<<k))&&((up[j]&i)==0)&&((up[k]&i)==0)&&(c[j]==c[k])){\n\t\t\t\t\t\tint yy = i - (1<<j) - (1<<k);\n\t\t\t\t\t\tdp[i] = max((int)dp[yy]+2,(int)dp[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",dp[(1<<n)-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n\n#define REP(i,a,n) for(i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n\nbool used[30];\nint x[30], y[30], r[30], c[30];\nint n;\nmap<int,int> dp;\n\nint sqr(int x){ return x*x; }\n\nbool istop(int node){\n  int i;\n  rep(i,node) if( !used[i] ) {\n    if( sqr(x[i] - x[node]) + sqr(y[i] - y[node]) < sqr(r[i]) + 2*r[i]*r[node] + sqr(r[node]) ) return false;\n  }\n  return true;\n}\n\nint solve(int S){\n  int i,j, res = 0;\n\n  if( dp.count(S) ) return dp[S];\n  \n  rep(i,n) if( !used[i] && istop(i) ){\n    REP(j,i+1,n) if( !used[j] && c[i] == c[j] && istop(j) ){\n      used[i] = used[j] = true;\n      //printf(\"(%d,%d), S=%d\\n\",i,j,S|(1<<i)|(1<<j));\n      res = max(res, solve(S|(1<<i)|(1<<j)) + 2);\n      used[i] = used[j] = false;\n    }\n  }\n  return dp[S] = res;\n}\n\nint main(){\n  int i,j;\n  \n  while( cin >> n, n ){\n    memset(used, false, sizeof(used));\n    dp.clear();\n    \n    rep(i,n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n    /*\n    cout << \"n=\" << n << endl;\n    rep(i,n){\n      printf(\"x[%2d] = %3d, y[%2d] = %3d, r[%2d] = %3d, c[%2d] = %3d\\n\",i,x[i],i,y[i],i,r[i],i,c[i]);\n    }\n    rep(i,n){\n        printf(\"istop(%d) = %d\\n\",i,istop(i));\n    }\n      */\n\n    cout << solve(0) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint N, X[24], Y[24], R[24], C[24];\nint r[24], m[24];\nchar dp[16777216];\n\nbool f(char n, int s) { return ((s & r[n]) & m[n]) == 0; }\n\nchar dfs(int s, char n) {\n  if(n == N) return N;\n\n  char ret = n;\n  REP(i, 0, N) {\n    int mi = (1 << i);\n    if((~s & mi) || !f(i, s)) continue;\n    REP(j, i + 1, N) {\n      int mj = (1 << j);\n      if(C[i] != C[j] || (~s & mj) || !f(j, s)) continue;\n      int ns = ~(~s | mi | mj);\n      if(dp[ns] >= 0) continue;\n      ret = max(ret, dfs(ns, n + 2));\n    }\n  }\n\n  return dp[s] = ret;\n}\n\nint main(void) {\n  m[0] = 0;\n  REP(i, 0, 23) m[i + 1] = m[i] | (1 << i);\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> X[i] >> Y[i] >> R[i] >> C[i];\n    REP(i, 0, pow(2, N)) dp[i] = -1;\n    REP(i, 0, N) r[i] = 0;\n    REP(i, 0, N) REP(j, 0, N) {\n      if(pow(R[i] + R[j], 2) > pow(X[i] - X[j], 2) + pow(Y[i] - Y[j], 2)) {\n        r[i] = r[i] | (1 << j);\n        r[j] = r[j] | (1 << i);\n      }\n    }\n    cout << (int) dfs((1 << N) - 1, 0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-9\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nint N;\n\nmap<int,int> m;\n\nint to_i (vec &used) {\n    int res = 0;\n    for (int i = 0; i < N; i++) {\n        if (used[i])\n            res |= 1 << i;\n    }\n}\n\nint dfs(mat &rank, vec &used, vec &C) {\n    int toI = to_i(used);\n    if (m.find(toI) != m.end()) return m[toI];\n    int res = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j) continue;\n            if (!used[i] && !used[j] && C[i] == C[j] && !(rank[i][j] || rank[j][i])) {\n                bool flag = true;\n                for (int k = 0; k < N; k++) {\n                    if (k == i || k == j) continue;\n                    if (rank[i][k] && !used[k]) flag = false;\n                    if (rank[j][k] && !used[k]) flag = false;\n                }\n\n                if (flag) {\n                    used[i] = used[j] = 1;\n                    res = max(dfs(rank, used, C) + 1, res);\n                    used[i] = used[j] = 0;\n                }\n            }\n        }\n    }\n\n    return m[toI] = res;\n}\n\nint main() {\n    while (cin >> N, N) {\n        m.clear();\n        vector<double> X(N), Y(N), R(N);\n        vector<int> C(N);\n        for (int i = 0; i < N; i++) {\n            cin >> X[i] >> Y[i] >> R[i] >> C[i];\n        }\n\n        mat rank(N, vec(N));\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                double dis = sqrt(pow(X[i] - X[j], 2.) + pow(Y[i] - Y[j], 2.));\n                if (dis < R[i] + R[j]) {\n                    rank[j][i] = 1;\n                }\n            }\n        }\n\n\n        vec used(N);\n        cout << 2 * dfs(rank, used, C) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <map>\n\nint n;\nint x[32];\nint y[32];\nint r[32];\nint c[32];\n\nvoid Load() {\n  scanf(\"%d\", &n);\n  for(int i = 0; i < (int)n; ++i) {\n    scanf(\"%d\", &x[i]);\n    scanf(\"%d\", &y[i]);\n    scanf(\"%d\", &r[i]);\n    scanf(\"%d\", &c[i]);\n  }\n}\n\nclass Solve_ {\npublic:\n  int operator () () {\n    int res = 0;\n    int valid[32] = {}; // not removed\n    for(int i = 0; i < n; ++i) valid[i] = true;\n    for(;;) {\n      bool remove_flag = false;\n      bool top[32]   = {}; // not overlaped\n      for(int i = 0; i < n; ++i) top[i] = true;\n      for(int i = 0; i < n; ++i) {\n        if( not valid[i] ) continue;\n        for(int j = 0; j < i; ++j) {\n          if( not valid[j] ) continue;\n          if( (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) < (r[i] + r[j]) * (r[i] + r[j]) ) {\n            printf(\" overlap : %d %d\\n\", i, j);\n            top[i] = false;\n          }\n        }\n      }\n      for(int i = 0; i < n; ++i) {\n        if( not valid[i] ) continue;\n        if( not top[i] ) continue;\n        printf(\" top : %d\\n\", i);\n      }\n      for(int i = 0; i < n; ++i) {\n        if( not valid[i] ) continue;\n        if( not top[i] ) continue;\n        for(int j = i + 1; j < n; ++j) {\n          if( not valid[j] ) continue;\n          if( not top[j] ) continue;\n          if( c[i] != c[j] ) continue;\n          valid[i] = false;\n          valid[j] = false;\n          remove_flag = true;\n          res += 2;\n          printf(\" removed : %d %d\\n\", i, j);\n        }\n      }\n      if( not remove_flag ) break;\n    }\n    return res;\n  }\nprivate:\n};\nSolve_ Solve;\n\nint main() {\n  for(;;) {\n    Load();\n    if( n == 0 ) break;\n    int res = Solve();\n    printf(\"%d\\n\", res);\n  }  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(long long i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\nDef inf=1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,out;\nvi used;\nvvi in;\nvoid dfs(int a){\n    out=max(out,a);\n    rep(i,n)if(used[i]==0){loop(j,i+1,n)if(used[j]==0&&in[i][3]==in[j][3]){\n        bool h=true;\n        rep(k,i)if(used[k]==0){\n            if((in[i][0]-in[k][0])*(in[i][0]-in[k][0])+\n            (in[i][1]-in[k][1])*(in[i][1]-in[k][1])>=\n            (in[i][2]+in[k][2])*(in[i][2]+in[k][2]));\n            else\n                h=false;\n        }\n        rep(k,j)if(used[k]==0){\n            if((in[j][0]-in[k][0])*(in[j][0]-in[k][0])+\n            (in[j][1]-in[k][1])*(in[j][1]-in[k][1])>=\n            (in[j][2]+in[k][2])*(in[j][2]+in[k][2]));\n            else\n                h=false;\n        }\n        if(!h)continue;\n        used[i]=used[j]=1;\n        dfs(a+2);\n        used[i]=used[j]=0;\n    }break;}\n}\nint main(){\n    while(cin>>n,n){\n        used=vi(n);\n        in=vvi(n,vi(4));\n        rep(i,n)rep(j,4)cin>>in[i][j];\n        out=0;\n        dfs(0);\n        cout<<out<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool overlap[24][24];\nbool memo[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++)if((bit>>i)&1){\n        if(overlap[a][i])return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n-1;i++){\n        if(((bit>>i)&1)==0||ok(i,bit)==false)continue;\n        for(int j=i+1;j<n;j++){\n            if(c[i]!=c[j]||((bit>>j)&1)==0)continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(ok(j,bit)&&!memo[to_bit]){\n                ret=max(ret,dfs(to_bit));\n            }\n        }\n    }\n\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            int dist=(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);\n            int sum=(r[i]+r[j])*(r[i]+r[j]);\n            overlap[i][j]=dist<sum;\n        }\n    }\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\n\n\nint main(){\n    while(input())solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define x first.first\n#define y first.second\n#define r second.first\n#define color second.second\n\nusing namespace std;\n\ntypedef pair<double,double> P;\ntypedef pair<P,P> C;\n\nbool check(C a,C b){\n  return a.r+b.r>sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n \nint count(int bits){\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits =(((bits >> 4) + bits) & 0x0f0f0f0f);\n  bits += bits >> 8;\n  return (bits + (bits >> 16)) & 0xff;\n}\n \nbool dp[(1<<25)];\n \nint main(void){\n \n\tint n;\n\twhile(cin >> n,n){\n\t\tC c[25];\n\t\tfor(int i=0;i<n;i++){\n\t\t\t//cin >> c[i].x >> c[i].y >> c[i].r >> c[i].color;\n\t\t\tscanf(\"%lf %lf %lf %lf\",&c[i].x,&c[i].y,&c[i].r,&c[i].color);\n\t\t}\n\t\t\n\t\tfill(dp,dp+(1<<n),false);\n\t\tdp[(1<<n)-1]=true;\n\t\tint ans=0;\n\t\t\n\t\tfor(int S=(1<<n)-1;S>=0;S--){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\tif(!(S>>i&1) || !(S>>j&1))continue;\n\t\t\t\t\tif(c[i].color!=c[j].color)continue;\n\t\t\t\t\t\n\t\t\t\t\tint nx=S;\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(!(S>>k&1))continue;\n\t\t\t\t\t\tif((k<i && check(c[i],c[k]))||(k<j && check(c[j],c[k])))goto end;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tnx&=~(1<<i);\n\t\t\t\t\tnx&=~(1<<j);\n\t\t\t\t\tdp[nx]|=dp[S];\n\t\t\t\t\tend:;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp[S])ans=max(ans,n-count(S));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[30],y[30],r[30],c[30];\nint cover[30];\nbool dp[1<<24];\n\ninline bool cross(int a, int b){\n  return (x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b])\n    < (r[a]+r[b])*(r[a]+r[b]);\n}\n\nint main(){\n  while(cin >> n, n){\n    for(int i=0;i<n;i++)cin >> x[i] >> y[i] >> r[i] >> c[i];\n    \n    for(int i=0;i<n;i++){\n      cover[i] = 0;\n      for(int j=0;j<i;j++){\n\tif(cross(i,j))cover[i] |= 1<<j;\n      }\n    }\n\n    memset(dp,0,sizeof(dp));\n    dp[0] = true;\n\n    for(int bit=0;bit<(1<<n);bit++){\n      if(!dp[bit])continue;\n      for(int a=0;a<n;a++){\n\tif( (bit>>a) & 1)continue;\n\tif( (~bit)&cover[a] )continue;\n\n\tfor(int b=a+1;b<n;b++){\n\t  if( (bit>>b) & 1)continue;\n\t  if( (~bit)&cover[b] )continue;\n\t  if(c[a] != c[b])continue;\n\n\t  dp[bit | (1<<a) | (1<<b)] = true;\n\t}\n      }\n    }\n\n    int ans = 0;\n    for(int bit=0;bit<(1<<n);bit++){\n      if(dp[bit])ans = max(ans, __builtin_popcount(bit));\n    }\n    cout << ans << endl;\n  }\t  \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 30;\nint x[MAXN], y[MAXN], r[MAXN], c[MAXN];\nbool ok[MAXN];\n\nint square(int x) {return x*x;}\n\n// i, j ???????????£?????????????????????\n// ????????£????????? true\nbool check(int i, int j) {\n    int d2 = square(x[i]-x[j]) + square(y[i]-y[j]);\n    return d2 < square(r[i]+r[j]);\n}\n\nint ans;\n\nvoid dfs(int state, int n) {\n    ans = max<int>(ans, __builtin_popcount(state));\n    // ???????????¨??????????????§??????????????????????????????\n    vector<int> already;\n    memset(ok, true, sizeof(ok));\n    for (int i = 0; i < n; i++) {\n        if ((state>>i)&1) continue;\n        if (ok[i]) {\n            already.push_back(i);\n        }\n        for (int j = i+1; j < n; j++) {\n            if (check(i, j)) ok[j] = false;\n        }\n    }\n    int sz = already.size();\n    for (int i = 0; i < sz; i++) {\n        for (int j = i+1; j < sz; j++) {\n            int ai = already[i], aj = already[j];\n            if (c[ai] == c[aj]) {\n                int nstate = state;\n                nstate |= 1<<ai;\n                nstate |= 1<<aj;\n                dfs(nstate, n);\n            }\n        }\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while (cin >> n) {\n        if (n==0) break;\n        for (int i = 0; i < n; i++) cin >> x[i] >> y[i] >> r[i] >> c[i];\n        ans = 0;\n        dfs(0, n);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <queue>\n#include <stack>\n#include <map>\nusing namespace std;\n\n#define REP(i, s, e) for (int i = (s); i < (e); i++)\n#define REPI(i, s, e) for (int i = (s); i <= (e); i++)\n#define rep(i, n) REP(i, 0, n)\n#define repi(i, n) REPI(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\n\n#define dump(x) (cout << #x << \" = \" << x << endl)\n#define dump2(x, y) (cout << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl)\n#define dump3(x, y, z) (cout << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \"<< z << \")\" << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define MAX 24\nint n;\nint xs[MAX], ys[MAX], rs[MAX], cs[MAX];\n\nchar memo[1<<MAX];\n\n#define DBL(x) ((x)*(x))\n\nbool connect(int i, int j)\n{\n\tdouble d = (DBL(xs[i]-xs[j]) + DBL(ys[i]-ys[j]));\n\treturn d < DBL(rs[i]+rs[j]);\n}\n\nbool top(int bit, int i)\n{\n\tfor (int j = i-1; j >= 0; j--)\n\t\tif (!((bit>>j)&1))\n\t\t\tif (connect(i, j))\n\t\t\t\treturn false;\n\treturn true;\n}\n\nint solve(int bit)\n{\n\tif (bit == (1<<n)-1) return 0;\n\tif (memo[bit] != -1) return memo[bit];\n\n\tmemo[bit] = 0;\n\trep(i, n) {\n\t\tif ((bit>>i)&1) continue;\n\t\tif (!top(bit, i)) continue;\n\t\tREP(j, i+1, n) {\n\t\t\tif (cs[i] != cs[j]) continue;\n\t\t\tif ((bit>>j)&1) continue;\n\t\t\tif (!top(bit, j)) continue;\n\t\t\tmemo[bit] = max(memo[bit], (char)(solve(bit|(1<<i)|(1<<j))+2));\n\t\t}\n\t}\n\treturn memo[bit];\n}\n\nint main(void)\n{\n\twhile (cin >> n, n) {\n\t\tmemset(memo, -1, sizeof(memo));\n\t\trep(i, n) cin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n\n\t\tcout << solve(0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n\twhile(true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif(!n) {\n\t\t\tbreak;\n\t\t}\n\t\tvector< int > x(n), y(n), r(n), c(n);\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\n\n\t\tvector< int > dp(1 << n, 0);\n\n\t\tvector< int > on(n, 0);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\t\tif((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) < (r[i] + r[j]) * (r[i] + r[j])) {\n\t\t\t\t\ton[j] |= (1 << i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdp[0] = 1;\n\t\tfor(int i = 0; i < (1 << n); i++) {\n\t\t\tif(!dp[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\t\tif(j == k) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(c[j] == c[k] && (i & on[j]) == on[j] && (i & on[k]) == on[k]) {\n\t\t\t\t\t\tdp[i | (1 << j) | (1 << k)] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < (1 << n); i++) {\n\t\t\tint tmp = 0;\n\t\t\tif(dp[i]) {\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tif(i >> j & 1) {\n\t\t\t\t\t\ttmp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = max(ans, tmp);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nshort dp[1<<24];\n\nint main()\n{\n  int n;\n  int x[25], y[25], r[25], c[25], b[25];\n  while(cin >> n, n) {\n    for(int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i]; b[i] = 0;\n      for(int j = 0; j < i; j++) {\n\tif((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j])*(r[i]+r[j])) b[i] |= (1<<j);\n      }\n    }\n    memset(dp, -1, sizeof(dp));\n    dp[0] = 0;\n    for(int i = 0; i < (1<<n); i++) {\n      if(!~dp[i]) continue;\n      for(int j = 0; j < n-1; j++) {\n\tif(((i >> j) & 1) == 0 && (i & b[j]) == b[j]) {\n\t  for(int k = j+1; k < n; k++) {\n\t    if(c[j] == c[k] && ((i >> k) & 1) == 0 && (i & b[k]) == b[k]) {\n\t      dp[i|(1<<j)|(1<<k)] = max(dp[i|(1<<j)|(1<<k)], (short)(dp[i]+2));\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout << *max_element(dp, dp + (1<<n)) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\nstruct E{\n\tvector<int> ov;\n\tint color;\n\tint x, y, r;\n\tE(int _x, int _y, int _r, int _c){\n\t\tcolor = _c;\n\t\tx = _x;\n\t\ty = _y;\n\t\tr = _r;\n\t}\n};\n\nbool dp[(1<<30)] = {0};\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tint x, y, r, c, _ans=0;\n\t\tvector<E> e;\n\t\tqueue<int> que;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tE tmp(x,y,r,c);\n\t\t\tfor(int j=0; j<e.size(); j++){\n\t\t\t\tif( (e[j].x-x)*(e[j].x-x) + (e[j].y-y)*(e[j].y-y) < (e[j].r+r)*(e[j].r+r) ){\n\t\t\t\t\ttmp.ov.push_back( j );\n\t\t\t\t}\n\t\t\t}\n\t\t\te.push_back( tmp );\n\t\t}\n\t\tdp[0] = true;\n\t\tque.push(0);\n\t\twhile( !que.empty() ){\n\t\t\tint i = que.front();\n\t\t\tque.pop();\n\t\t\tif(dp[i]){\n\t\t\t\t_ans = max(_ans,i);\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tfor(int l=0; l<n; l++){\n\t\t\t\t\t\tif( k != l && !(i&(1<<k)) && !(i&(1<<l)) && e[k].color == e[l].color){\n\t\t\t\t\t\t\tbool f=true;\n\t\t\t\t\t\t\tfor(int j=0; j<e[k].ov.size(); j++){\n\t\t\t\t\t\t\t\tif( !(i & (1<<e[k].ov[j])) ){\n\t\t\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int j=0; f&&j<e[l].ov.size(); j++){\n\t\t\t\t\t\t\t\tif( !(i & (1<<e[l].ov[j])) ){\n\t\t\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( f ){\n\t\t\t\t\t\t\t\tdp[ i | (1<<k) | (1<<l) ] = true;\n\t\t\t\t\t\t\t\tque.push( i | (1<<k) | (1<<l) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=1; i<(1<<n); i<<=1){\n\t\t\tif( i & _ans )\n\t\t\t\tans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define MAX_COLORS 6\n#define MAX_CIRCLES 4\n#define MAX_N (MAX_COLORS*MAX_CIRCLES)\n#define MAX_STATES (1<<MAX_N)\n\nint biggest, n;\n\nstruct circle{\n    int x, y, r, c;\n};\n\ncircle C[MAX_N];\nchar dp[MAX_STATES];\n\nbool isOver( circle c1, circle c2 ){\n    int dx, dy;\n    dx = (c1.x - c2.x) * (c1.x - c2.x);\n    dy = (c1.y - c2.y) * (c1.y - c2.y);\n    return dx + dy < (c1.r + c2.r)*(c1.r + c2.r) ? true : false;\n}\n\nbool isDeleted( int state, int num ){\n    return (state & (1<<num)) == 0 ? false : true;\n}\n/*\nvoid pbit(int num){\n    //cout << \"bit: \";\n    do{\n        printf(\"%d\", num&1);\n        num = num>>1;\n    }while(num);\n    //printf(\"\\n\");\n}*/\n\nbool isTop( int state, int num ){\n    //pbit(state);\n    for( int i = num-1; i >= 0; i-- ){\n        if( isDeleted(state, i) ) continue;\n        if( isOver(C[num], C[i]) ) return false;\n    }\n    //cout << num << \" is top\" << endl;\n    return true;\n}\n\nvoid search(int s){\n    //for( int s = 0; s < 1<<n; s++ ){\n        /*cout << \"s: \";\n        pbit(s);\n        cout << endl;\n        */\n        for( int i = 0; i < n; i++ ){\n            if( isDeleted(s, i) ) continue;\n            //cout << \"i: \" << i << endl;\n            for( int j = i+1; j < n; j++ ){\n                if( isDeleted(s, j) ) continue;\n                //cout << \"i: \" << i << endl;\n                //cout << \"j: \" << j << endl;\n                if( isTop(s, i) && isTop(s, j) && C[i].c == C[j].c ){\n                    int next = s | 1<<i | 1<<j;\n                    //pbit(s);\n                    //cout << \",\" << i << \",\" << j << endl;\n                    if( dp[next] < dp[s]+2 ) dp[next] = dp[s]+2;\n                    if( biggest < dp[next] ) biggest = dp[next];\n                    search(next);\n                }\n            }\n        }\n    //}\n}\n\nvoid init(){\n    for( int s = 0; s < 1<<n; s++ ){\n        dp[s] = 0;\n    }\n}\n\nint main(){\n    while( cin >> n, n ){\n        for( int i = 0; i < n; i++ ){\n            circle a;\n            //scanf(\"%d%d%d%d\", a.x, a.y, a.r, a.c);\n            cin >> a.x >> a.y >> a.r >> a.c;\n            C[i] = a;\n        }\n        biggest = 0;\n        init();\n        //dp[0] = 0;\n        search(0);\n        printf(\"%d\\n\", biggest);\n        //cout << \"ans: \" << biggest << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nclass Data{\npublic:\n\tint x;\n\tint y;\n\tint r;\n\tint c;\n\tData(int _x,int _y,int _r,int _c){\n\t\tx = _x;\n\t\ty = _y;\n\t\tr = _r;\n\t\tc = _c;\n\t}\n};\n\nbool check(const vector<Data>& d,int a,int b){\n\tif(d[a].c != d[b].c) return false;\n\tfor(int i=0;i<a;i++){\n\t\tif((d[a].x-d[i].x)*(d[a].x-d[i].x)+(d[a].y-d[i].y)*(d[a].y-d[i].y) < (d[a].r + d[i].r)*(d[a].r + d[i].r)) return false;\n\t}\n\tfor(int i=0;i<b;i++){\n\t\tif((d[b].x-d[i].x)*(d[b].x-d[i].x)+(d[b].y-d[i].y)*(d[b].y-d[i].y) < (d[b].r + d[i].r)*(d[b].r + d[i].r)) return false;\n\t}\n\n\treturn true;\n}\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tint x,y,r,c;\n\t\tvector<Data> nodes; \n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&x,&y,&r,&c);\n\t\t\tnodes.push_back(Data(x,y,r,c));\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int i=n;i>=2;i-=2){\n\t\t\tvector<int> flag(i);\n\t\t\tflag[0] = 1;\n\t\t\tflag[1] = 1;\n\t\t\tsort(flag.begin(),flag.end());\n\n\t\t\tdo{\n\t\t\t\tvector<int> idx;\n\t\t\t\tfor(int j=0;j<flag.size();j++){\n\t\t\t\t\tif(flag[j]){\n\t\t\t\t\t\tidx.push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(check(nodes,idx[0],idx[1])){\n\t\t\t\t\tnodes.erase(nodes.begin()+idx[0]);\n\t\t\t\t\tnodes.erase(nodes.begin()+idx[1]-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}while(next_permutation(flag.begin(),flag.end()));\n\t\t}\n\n\t\tprintf(\"%d\\n\",max(res,n-(int)nodes.size()));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 24\n\nint N,x[MAX],y[MAX],r[MAX],c[MAX];\n\nint dist(int a,int b){\n    return (x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]);\n}\n\nbool check(int a,int b){\n    int d = dist(a,b);\n    int add = r[a]+r[b],sub = r[a]-r[b];\n    return ((sub*sub < d && d < add*add) || d <= sub*sub);\n}\n\nint main(){\n    while(cin >> N, N){\n        for(int i = 0 ; i < N ; i++){\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n        int bit[MAX] = {0};\n        for(int i = 0 ; i < N ; i++){\n            for(int j = 0 ; j < i ; j++){\n                if(check(i,j)) bit[i] |= (1<<j);\n            }\n        }\n        vector<bool> dp(1<<N,0);\n        dp[(1<<N)-1] = 1;\n        int res = 0;\n        for(int i = (1<<N)-1 ; i >= 0 ; i--){\n            if(dp[i] == 0) continue;\n            if(N%2 == 0 && __builtin_popcount(i) % 2 == 1) continue;\n            if(N%2 == 1 && __builtin_popcount(i) % 2 == 0) continue;\n            for(int j = 0 ; j < N ; j++){\n                if((i&bit[j]) > 0) continue;\n                for(int k = j+1 ; k < N ; k++){\n                    if(c[j] != c[k]) continue;\n                    if((i&bit[k]) > 0) continue;\n                    int S = i & ~((1<<j) | (1<<k));\n                    dp[S] = 1;\n                    res = max(res,N-__builtin_popcount(i));\n                }\n            }\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\n//char bit_count[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            if(((bit>>i)&1)==0)continue;\n            if(((bit>>j)&1)==0)continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(c[i]==c[j]&&ok(i,bit)&&ok(j,bit)&&!memo[to_bit]){\n                ret=max(ret,dfs(to_bit));\n            }\n        }\n    }\n\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\nvoid init(){\n    for(int i=0;i<(1<<24);i++){\n        for(int j=0;j<24;j++)if((i>>j)&1){\n            bit_count[i]++;\n        }\n    }\n}\n\nint main(){\n    init();\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<25];\n\n//dist(i,j)<r[i]+r[j]->ok\nbool ok(int a,int bit){#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<25];\n\n//dist(i,j)<r[i]+r[j]->ok\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            if(((bit>>i)&1)==0)continue;\n            if(((bit>>j)&1)==0)continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(c[i]==c[j]&&ok(i,bit)&&ok(j,bit)&&!memo[to_bit]){\n                ret=max(ret,dfs(to_bit));\n            }\n        }\n    }\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\nint main(){\n\n    int a=(1<<5)-1;\n    while(input())solve();\n    return 0;\n}\n\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    if(memo[bit]==true)return 0;\n    memo[bit]=true;\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            if(((bit>>i)&1)==0)continue;\n            if(((bit>>j)&1)==0)continue;\n            if(c[i]==c[j]&&ok(i,bit)&&ok(j,bit)){\n                ret=max(ret,dfs((bit^(1<<i))^(1<<j)));\n            }\n        }\n    }\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\nint main(){\n\n    int a=(1<<5)-1;\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define fi first\n#define se second\n\nconst double EPS = 1e-9;\n\ntypedef pair<double,double> pdd;\n\nstruct circle {\n\tdouble x, y;\n\tdouble r, c;\n\tcircle(double x_, double y_, double r_, double c_) {\n\t\tx = x_; y = y_; r = r_; c = c_;\n\t}\n};\n\nvector<vector<int> > edge;\n\ntemplate<typename T>\nT sqr(T a) { return a * a; }\n\nbool on(circle c1, circle c2) {\n\tdouble d = sqrt(sqr(c1.x - c2.x) + sqr(c1.y - c2.y));\n\n\tif(d + EPS > c1.r + c2.r) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool used[1 << 24];\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tvector<circle> v;\n\t\tedge.clear();\n\t\tedge.resize(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdouble x, y;\n\t\t\tdouble r, c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tcircle in(x,y,r,c);\n\t\t\tfor(int j = 0; j < v.size(); j++) {\n\t\t\t\tif(on(in, v[j])) {\n\t\t\t\t\tedge[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tv.push_back(in);\n\t\t}\n\n\t\tqueue<int> q;\n\t\tq.push((1 << n) - 1);\n\t\tint res = 0;\n\t\tfor(int i = 0; i < (1 << 24); i++)\n\t\t\tused[i] = false;\n\t\twhile(!q.empty()) {\n\t\t\tint a = q.front();\n\t\t\tint flg = (1 << n) - 1;\n\t\t\tq.pop();\n\n\t\t\tint tmp = 0;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tif(a & (1 << i)) continue;\n\t\t\t\ttmp++;\n\t\t\t}\n\t\t\tres = max(res, tmp);\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tif(a & (1 << i)) {\n\t\t\t\t\tfor(int j = 0; j < edge[i].size(); j++) {\n\t\t\t\t\t\tif(a & (1 << edge[i][j]))\n\t\t\t\t\t\t\tflg &= ~(1 << i);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tflg &= ~(1 << i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tif(flg & (1 << i)) {\n\t\t\t\t\tfor(int j = i+1; j < n; j++) {\n\t\t\t\t\t\tif(flg & (1 << j)) {\n\t\t\t\t\t\t\tif(v[i].c == v[j].c) {\n\t\t\t\t\t\t\t\tint pb = a;\n\t\t\t\t\t\t\t\tpb &= ~(1 << i);\n\t\t\t\t\t\t\t\tpb &= ~(1 << j);\n\t\t\t\t\t\t\t\tif(!used[pb]) {\n\t\t\t\t\t\t\t\t\tq.push(pb);\n\t\t\t\t\t\t\t\t\tused[pb] = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <string.h>\n\nusing namespace std;\n\nconst int MAX_N = 24;\n\nclass Circle {\npublic:\n\tchar x, y, r, c; // 中心のxy座標、半径、色番号\n};\n\n/* 入力 */\nint n; // 円盤の枚数\nCircle cir[MAX_N]; // 円の情報\n\n/*\nS:すでに取り除いた円の集合(bitで表す、右から円番号0,1,2,...,MAX_N)\ndp[S]:ここから取り除ける最大枚数\n漸化式\ndp[全部取り除いた] = n\ndp[S] = max(dp[S U 取り除いた2つの円]+2)\n*/\nchar dp[1 << MAX_N];\n\n/* 2点間の距離 */\ndouble dis(char x1, char y1, char x2, char y2) {\n\treturn sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));\n}\n\n/* 円kが上に1枚でも重なっているかどうか、重なっていたらtrue */\nbool ispiled(int k, int S) {\n\tfor (int i = k - 1; i >= 0; i--) {\n\t\tif (dis(cir[i].x, cir[i].y, cir[k].x, cir[k].y) < cir[i].r + cir[k].r && !(S >> i & 1)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n/*\nbool ispiled(Circle c1, Circle c2) {\n\tif (dis(c1.x, c1.y, c2.x, c2.y) < c1.r + c2.r) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n*/\n\n/* S:すでに取り除いた円盤の集合 */\nchar remove(int S) {\n\t//cout << \"S = \" << S << \" dp[\" << S << \"]: \" << dp[S] << endl;\n\tif (dp[S] >= 0) {\n\t\treturn dp[S];\n\t}\n\t\n        /* 全部取り除いた */\n\tif (S == ((1 << n) - 1)) {\n\t\treturn dp[S] = n;\n\t}\n\n\tint res = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t/* どちらかがすでに取り除かれているか、2つの色が違うか、2枚のうち1枚以上が下にあれば取り除けないので次の組へ */\n\t\t\tif (S >> i & 1 || S >> j & 1 || cir[i].c != cir[j].c || ispiled(i, S) || ispiled(j, S)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (true) {\n\t\t\t\tint tmp = S | 1 << i;\n\t\t\t\ttmp = tmp | 1 << j;\n\t\t\t\tres = max(res, remove(tmp) + 2);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[S] = res;\n}\n\nint main() {\n\t// 方針: bitDP\n\t//const int MAX_N = 24;\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> cir[i].x >>cir[i].y >> cir[i].r >> cir[i].c;\n\t\t}\n\t\tmemset(dp, -1, sizeof(dp));\n\t\t//cout << \"test\" << endl;\n\t\tcout << remove(0) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double R;//double long double ??????????????? cmath?????¢??°??????????????????????????????????????????????????§????????????\ntypedef complex<R> Point;\ntypedef pair<Point , Point> Line;\ntypedef pair<Point ,R > Circle;\ntypedef vector<Point> Poly;\n\n#define EPS (1e-10)//??????\n#define EQ(a,b) (abs((a)-(b)) < EPS)//??????????????°???????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )//????????????????????????????????????\n#define mp make_pair\n#define ft first\n#define sd second\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nR dot(Point a,Point b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nR cross(Point a,Point b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\nbool is_orthogonal(Line a,Line b){//2??´????????´?????????\n    return EQ(dot(a.ft - a.sd,b.ft - b.sd),0.0);\n}\nbool is_parallel(Line a,Line b){//2??´??????????????????\n    return EQ(cross(a.ft - a.sd,b.ft - b.sd),0.0);\n}\n\n////////////////////????????????\n\nint ccw(Point a,Point b,Point c){//ok\n    b -= a; c -= a;\n    if(cross(b,c) > EPS) return 1;//a???b??§???????¨???¨???????????????b???c\n    if(cross(b,c) < -EPS) return -1;//a???b??§????¨???¨???????????????b???c\n    if(dot(b,c) < -EPS) return 2;//c--a--b on same line\n    if(norm(c) - norm(b) > EPS) return -2;//a--b--c(abs??????????????????????????????????????????????????????????)\n    return 0;//a--c--b?????????b==c\n}\n\nbool is_intersection_ll(Line l,Line m){//???????????´??????????????????\n    return abs(cross(l.sd - l.ft,m.sd - m.ft)) > EPS || //????????§??????\n        abs(cross(l.sd - l.ft,m.ft - l.ft)) < EPS; //?????????????????????\n}\n\nbool is_intersection_ls(Line l,Line s){//??´???l??¨??????s???????????????\n    return cross(l.sd - l.ft, s.ft-l.ft)*       // s[0] is left of l\n        cross(l.sd - l.ft, s.sd - l.ft) < EPS; // s[1] is right of l\n}\n\nbool is_intersection_lp(Line l,Point p){//??´???l??¨???p???????????????\n    return abs(cross(l.sd - p,l.ft - p));\n}\n\nbool is_intersection_ss(Line a,Line b){//??????????????????????????????ok\n    return ccw(a.ft,a.sd,b.ft)*ccw(a.ft,a.sd,b.sd) <= 0 && ccw(b.ft,b.sd,a.ft)*ccw(b.ft,b.sd,a.sd) <= 0;\n}\n\nbool is_intersection_sp(Line s,Point p){//????????¨?????????????????? ????§??????????????????¨\n    return abs(s.ft - p) + abs(s.sd - p) - abs(s.ft - s.sd) < EPS;\n}\n\n/////////////?????¢\n\nR dis_lp(Line l,Point p){//??´???l??¨???p????????¢\n    return abs(cross(l.sd - l.ft,p - l.ft)) / abs(l.sd - l.ft);\n}\n\nR dis_ll(Line l,Line m){//???????????´???????????¢\n    return is_intersection_ll(l,m) ? 0.0 : dis_lp(l,m.ft);\n}\n\nR dis_ls(Line l,Line s){//??´???l??¨??????s????????¢\n    if(is_intersection_ls(l,s)) return 0.0;\n    return min(dis_lp(l,s.ft),dis_lp(l,s.sd));\n}\n\nR dis_sp(Line s,Point p){//??????s??¨???p????????¢\n    if(dot(s.sd - s.ft,p - s.ft) < EPS) return abs(p - s.ft);\n    if(dot(s.ft - s.sd,p - s.sd) < EPS) return abs(p - s.sd);\n    return dis_lp(s,p);\n}\n\nR dis_ss(Line s,Line t){//???????????????????????¢\n    if(is_intersection_ss(s,t)) return 0.0;\n    return min(min(dis_sp(s,t.ft),dis_sp(s,t.sd)),\n            min(dis_sp(t,s.ft),dis_sp(t,s.sd)));\n}\n\n//////////////?°???±??¨????°?\n\nPoint projection(Line l,Point p){//?°???±????±???????\n    R t = dot(p - l.ft,l.ft - l.sd) / norm(l.ft - l.sd);\n    return l.ft + t * (l.ft - l.sd);\n}\n\nPoint reflection(Line l,Point p){//????°?????±???????\n    return p + 2.0 * (projection(l,p) - p);\n}\n\n//////////////??????(????????????????¨???????????????¨??????????????????????????????????????£??????)\n\nPoint intersection_ll(Line l,Line m){//????????????????????????????????????????????????\n    R A = cross(l.sd - l.ft,m.sd - m.ft);\n    R B = cross(l.sd - l.ft,l.sd - m.ft);\n    if(abs(A) < EPS && abs(B) < EPS) return m.ft;//?????????\n    //if(abs(A) < EPS)assert(false);//????????§????????????\n    return m.ft + B / A * (m.sd - m.ft);\n}\n\nLine intersection_of_two_circles(Circle c1,Circle c2){//ok ????????????????????????Line?????\\????????????(r1 + r2 > sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2))???????????????????????????\n    R a =  abs(c2.ft - c1.ft);\n    R b = c1.sd;\n    R c = c2.sd;\n\n    R rc = (a  * a + b * b - c * c) / (2.0 * a);\n    R rs = sqrt(b * b - rc * rc);//C++ ??§???????????????????????????????????§???????????????sqrt ????????? float ?????????????????? long double ????????????????????????????????????????????¨?????§???????????? C ????????°????????§??????sqrt ????????? double ??????????????£??????????????????\n    Point diff = (c2.ft - c1.ft) / a;\n\n    Line p ;\n    p.ft = c1.ft + diff * rc + diff * Point(0,1) * rs;\n    p.sd = c1.ft + diff * rc + diff * Point(0,-1) * rs;\n\n    return p;\n}\n\n\nLine conver_line(Line a,Point maxi,Point mini){//??????????????´??????????????? maxi???????????????????????? mini?????????\n\n    if(abs(dot(a.sd - a.ft,Point(1.0,0.0))) < EPS){//??????x???????????´??????\n        ;\n    }\n}\n\n/////////////////////////polygon\n\n#define currP(P,i) P[i]//????????????\n#define nextP(P,i) P[(i + 1)%P.size()]//?¬??????????\n\nint is_contains_p_in_Poly(Poly po,Point p){//??????????§???¢????????¨(1)????¢????(-1)????????¨(0)??????????????????????????????\n    bool in = false;\n    REP(i,po.size()){\n        Point a = currP(po,i) - p,b = nextP(po,i) - p;\n        if(a.imag() > b.imag())swap(a,b);\n        if(a.imag() < EPS && -EPS < b.imag())\n            if(cross(a,b) < -EPS) in = !in;\n        if(abs(cross(a,b)) == 0.0 && dot(a,b) < EPS)return  -1;\n    }\n    return in;\n}\n\nR area2(Poly po){//????§???¢?????¢????????????????±???????\n    R A = 0.0;\n    REP(i,po.size())\n        A += cross(currP(po,i),nextP(po, i));\n    return A;\n}\n\n///////////////////////////???\n\nPoly convex_hull(Poly ps){\n    int n = ps.size(),k = 0;\n    Poly ch(2*n);\n    for(int i = 0;i < n;ch[k++] = ps[i++])// lower-hull\n        while(k >= 2 && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0) --k;\n    for(int i = n - 2,t = k + 1;i >= 0;ch[k++] = ps[i--])//upper-hull\n        while(k >= t && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\n#define prevP(P, i) P[(i+P.size()-1) % P.size()]\nbool isconvex(Poly P){\n    for(int i = 0;i < P.size();++i)\n        if(ccw(prevP(P,i),currP(P,i),nextP(P,i)) > 0) return false;\n    return true;\n}\n\nbool kosa(Circle c1, Circle c2) {\n  return abs(c1.ft-c2.ft)<(c1.sd+c2.sd);\n}\n\n#define MAX_N 25\n\nint n;\nCircle cs[MAX_N];\nint cc[MAX_N];\n\nbool input() {\n  cin>>n;\n  int x, y, r;\n  REP(i, n) {\n    cin>>x>>y>>r>>cc[i];\n    cs[i] = mp(Point(x, y), r);\n  }\n  return n!=0;\n}\n\nchar dp[1<<MAX_N];\n\nbool totta[MAX_N],toreru[MAX_N];\n\nint saiki(int S) {\n  if(dp[S] > -1)\n    return dp[S];\n  REP(i,n){totta[i] = S&(1<<i);toreru[i] = true;}\n  REP(i,n){\n    if(totta[i]){\n      toreru[i] = false;\n      continue;\n    }\n    REP(j,i){\n      if(!totta[j] && kosa(cs[i],cs[j])){\n        toreru[i] = false;\n        break;\n      }\n    }\n  }\n  bool f=false;\n  REP(i, n)f=f||toreru[i];\n  if(!f)return 0;\n  int maxi = 0;\n  REP(i,n){\n    if(toreru[i]){\n      FOR(j,i+1,n){\n        if(toreru[j] && cc[i] == cc[j])\n          maxi = max( maxi, saiki(S|(1<<i)|(1<<j))+2 );\n      }\n    }\n  }\n  return maxi;\n}\n\nvoid solve() {\n  REP(i,1<<n)\n    dp[i] = -1;\n  //cout<<saiki(0)<<endl;\n  printf(\"%d\\n\",saiki(0));\n}\n\nint main() {\n  \n  while(input()) {\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct C {\n  int x, y, r, c;\n};\n\nint n;\nC c[24];\nint on[24];\nchar T[1<<24];\nvector<int> to[5];\n\nint isIntersect(C &a, C &b) {\n  int d1 = a.x - b.x;\n  int d2 = a.y - b.y;\n  int d3 = a.r + b.r;\n  if(d1*d1 + d2*d2 < d3*d3) return 2;\n  //if(d1*d1 + d2*d2 == d3*d3) return 1;\n  return 0;\n}\n\nint make() {\n  for(int i = 1; i <= 4; ++i) to[i].clear();\n  fill(on, on+n, 0);\n  for(int i = 0; i < n; ++i) {\n    to[c[i].c].push_back(i);\n    for(int j = i+1; j < n; ++j) {\n      if(isIntersect(c[i], c[j])) {\n\ton[j] |= (1<<i);\n      }\n    }\n  }\n}\n\nint rec(int S) {\n  if(T[S] != -1) return T[S];\n  int res = 0;\n  for(int i = 0; i < n; ++i) {\n    if(S & (1<<i)) continue;\n    if(on[i] & S != on[i]) continue;\n    for(int j = i+1; j < n; ++j) {\n      if(S & (1<<j)) continue;\n      if(on[j] & S != on[j]) continue;\n      if(c[i].c != c[j].c) continue;\n      int nS = S;\n      nS |= (1<<i);\n      nS |= (1<<j);\n      res = max(res, rec(nS) + 2);\n    }\n  }\n  return T[S] = res;\n}\n\nint solve() {\n  make();\n  for(int S = (1<<n)-1; S >= 0; --S) {\n    T[S] = 0;\n    for(int i = 0; i < n; ++i) {\n      if(S & (1<<i)) continue;\n      if(on[i] & S != on[i]) continue;\n      for(int k = 0; k < to[c[i].c].size(); ++k) {\n\tint j = to[c[i].c][k];\n\tif(j == i) continue;\n\tif(S & (1<<j)) continue;\n\tif(on[j] & S != on[j]) continue;\n\tint nS = S;\n\tnS |= (1<<i);\n\tnS |= (1<<j);\n\tT[S] = max(T[S], (char)(T[nS] + 2));\n      }\n    }\n  }\n  return T[0];\n}\n\n\n\nint main() {\n  while((cin >> n) && n) {\n    for(int i = 0; i < n; ++i) {\n      cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n    }\n\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n\n\nstruct cir{\n    int x,y,r,c;\n};\n\nbool same(cir a,cir b){\n    double r2 = (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n    if((a.r+b.r)*(a.r+b.r)>r2)return true;\n    else return false;\n}\n\nbool used(int n,vi vec){\n    rep(i,vec.size()){\n        int to = vec[i];\n        if( (n&(1<<to)) != 0 )return false;\n    }\n    return true;\n}\n\nint main(){\n    int n;\n    while(cin>>n){\n        if(n==0)break;\n        vector<cir> data;\n        \n        rep(i,n){\n            int x,y,r,c;\n            cin>>x>>y>>r>>c;\n            data.pb(cir{x,y,r,c});\n        }\n        \n        \n        vector<int> G[30];\n        \n        for(int i=data.size()-1;i>=0;i--){\n            for(int j=i-1;j>=0;j--){\n                if(same(data[i],data[j])){\n                    G[i].pb(j);\n                }\n            }\n        }\n        \n        static bool dp[1<<n];\n        rep(i,1<<n)dp[i]=false;\n        dp[(1<<n)-1]=true;\n        \n        \n        for(int i=(1<<n)-1;i>=0;i--){\n            if(dp[i]==false)continue;\n            rep(j,n){\n                for(int k=j+1;k<n;k++){\n                    if( (i&(1<<j) )==0 || (i&(1<<k) )==0)continue;\n                    if( data[j].c==data[k].c && used(i,G[j]) && used(i,G[k]) ) dp[(i^(1<<j))^(1<<k)] = true;\n                }\n            }\n        }\n        \n        int ans=100;\n        for(int i=(1<<n)-1;i>=0;i--){\n            if(dp[i]==false)continue;\n            ans = min(ans,__builtin_popcount(i));\n        }\n        cout<<n-ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <set>\n#include <sstream>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nbool ISINT(double x){return fabs(x-(int)x)<EPS;}\nbool ISEQ(double x,double y){return fabs(x-y)<EPS;}\nstring itos(ll x){stringstream ss;ss<<x;return ss.str();}\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define EREP(i,a,b) for(int i=a;i<=b;i++)\n#define erep(i,n) EREP(i,0,n)\n#define foreach(itr,c) for(__typeof(c.begin()) itr=c.begin();itr!=c.end();itr++)\n\nint n;\nint x[25],y[25],r[25],c[25];\nint b[25];\n\nbool intersects(int i,int j){\n  int dist1 = pow(x[i]-x[j],2) + pow(y[i]-y[j],2);\n  int dist2 = pow(r[i]+r[j],2);\n\n  return dist2 > dist1;\n}\n\nint dp[1<<24];\n\nint main(void){\n  while(scanf(\"%d\",&n),n){\n    rep(i,n){\n      scanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n\n      b[i] = 0;\n      rep(j,i) if(intersects(i,j)) b[i] |= (1<<j);\n    }\n\n    int ans = 0;\n    int to = (1<<n);\n    memset(dp,-1,sizeof(dp));\n    dp[0] = 0;\n\n    rep(i,to){\n      if(dp[i] == -1) continue;\n      ans = max(ans,dp[i]);\n      rep(j,n-1){\n        if((i & (1<<j)) != 0 || (i & b[j]) != b[j]) continue;\n        REP(k,j+1,n){\n          if(c[j] != c[k] || (i & (1<<k)) != 0 || (i & b[k]) != b[k]) continue;\n          int next = i | (1<<j) | (1<<k);\n          dp[next] = max(dp[next],dp[i]+2);\n        }\n      }\n    }\n\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nstruct A {\n    int x;\n    int y;\n    int r;\n    int c;\n}a[30];\nchar dp[1<<25];\nint n;\ninline bool cover(int qq,int x) {\n    int i;\n    int tmp;\n    for(i=qq-1;i>=0;i--) {\n        if(((x>>i)&1)==0) continue;\n        tmp=(a[qq].x-a[i].x)*(a[qq].x-a[i].x)+(a[qq].y-a[i].y)*(a[qq].y-a[i].y);\n        if((a[qq].r+a[i].r)*(a[qq].r+a[i].r)>tmp) return 1;\n    }\n    return 0;\n}\nchar maxnum(char x) {\n    if(dp[x]!=-1) return dp[x];\n    int i,j,k;\n    char ans=0,y,tmp;\n    for(i=0;i<n;i++) {\n        if(((x>>i)&1)==0) continue;\n        if(cover(i,x)) continue;\n        for(j=i+1;j<n;j++) {\n            if(((x>>j)&1)==0) continue;\n            if(a[i].c!=a[j].c) continue;\n            if(cover(j,x)) continue;\n            y=x^(1<<i)^(1<<j);\n            tmp=maxnum(y)+2;\n            if(ans<tmp) ans=tmp;\n        }\n    }\n    dp[x]=ans;\n    return ans;\n}\nint main() {\n    int i;\n    while(scanf(\"%d\",&n),n) {\n    \tfor(i=0;i<(1<<n);i++)\n            dp[i]=-1;\n        for(i=0;i<n;i++) {\n            scanf(\"%d %d %d %d\",&a[i].x,&a[i].y,&a[i].r,&a[i].c);\n            dp[1<<i]=0;\n        }\n        dp[0]=0;\n        printf(\"%d\\n\",maxnum((1<<n)-1));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nmain {\n  while (true) {\n    int n = in();\n    if (n == 0) break;\n    vector<int> x(n), y(n), r(n), c(n);\n    rep(i, n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n    auto intersectCC = [&](int i, int j) {\n      int r2 = (r[i] + r[j]) * (r[i] + r[j]);\n      int d = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n      return d < r2;\n    };\n    auto intersect = [&](int t, int used) {\n      bool f = false;\n      rep(i, t) f |= (~used >> i & 1) && intersectCC(t, i);\n      return f;\n    };\n    vector<int> dp(1 << n, -1);\n    function<int(int)> dfs = [&](int used) {\n      if (dp[used] != -1) return dp[used];\n      cmax(dp[used], 0);\n      rep(i, n) loop(j, i + 1, n) {\n        if ((used >> i & 1) || (used >> j & 1) || c[i] != c[j]) continue;\n        if (intersect(i, used) || intersect(j, used)) continue;\n        cmax(dp[used], dfs(used | (1 << i) | (1 << j)) + 2);\n      }\n      return dp[used];\n    };\n    cout << dfs(0) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint n;\nVI xs, ys, rs, cs;\nVVI grp;\n\nbool is_top(int i, int used) {\n\tfor (int j = i - 1; j >= 0; j--) {\n\t\tif (1 << j & used) continue;\n\n\t\tint x = (xs[i] - xs[j]) * (xs[i] - xs[j]);\n\t\tint y = (ys[i] - ys[j]) * (ys[i] - ys[j]);\n\t\tint dis = x + y;\n\t\tint dis2 = (rs[i] + rs[j]) * (rs[i] + rs[j]);\n\n\t\tif (dis < dis2) {\t// 重なってる\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main(void) {\n\twhile(cin >> n, n){\n\t\txs = VI(n);\n\t\tys = VI(n);\n\t\trs = VI(n);\n\t\tcs = VI(n);\n\t\tgrp = VVI(n);\n\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n\t\t\tcs[i]--;\n\t\t\tgrp[cs[i]].push_back(i);\n\t\t}\n\n\t\t//\n\n\t\tvector<queue<PII>> ps(2);\n\t\tps[0].push(make_pair(0, 0));\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint cur = i % 2;\n\t\t\tint next = (i + 1) % 2;\n\n\t\t\tps[next] = queue<PII>();\n\n\t\t\twhile (ps[cur].size()) {\n\t\t\t\tPII p = ps[cur].front();\n\t\t\t\tint used = p.fst;\n\t\t\t\tint sum = p.snd;\n\n\t\t\t\tps[cur].pop();\n\n\t\t\t\t// 同じ色の円盤はいくつか\n\t\t\t\tVI can_pop;\n\t\t\t\tfor (auto j : grp[cs[i]]) {\n\t\t\t\t\tif (!(1 << j & used) && is_top(j, used)) {\n\t\t\t\t\t\tcan_pop.push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint cnt = can_pop.size();\n\n\t\t\t\tif (cnt >= 2 && !(cnt % 2)) { // 偶数なら全部とれる\n\t\t\t\t\tint next_used = used;\n\t\t\t\t\tfor (auto j : can_pop) {\n\t\t\t\t\t\tnext_used |= 1 << j;\n\t\t\t\t\t}\n\t\t\t\t\tps[next].push(make_pair(next_used, sum + cnt));\n\t\t\t\t} else if (cnt > 2) { // 奇数ならどれか取れる\n\t\t\t\t\t for (auto j : can_pop) {\n\t\t\t\t\t\t if (i != j) {\n\t\t\t\t\t\t\t int next_used = used | (1 << j);\n\t\t\t\t\t\t\t ps[next].push(make_pair(next_used, sum + 2));\n\t\t\t\t\t\t }\n\t\t\t\t\t }\n\t\t\t\t} else {\n\t\t\t\t\tps[next].push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\n\t\twhile (ps[n % 2].size()) {\n\t\t\tPII p = ps[n % 2].front();\n\t\t\tans = max(ans, p.snd);\n\t\t\tps[n % 2].pop();\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n\nconst int MAXN = 30;\nint x[MAXN], y[MAXN], r[MAXN], c[MAXN];\nbool ok[MAXN];\nmap<int, int> dp;\n\nint square(int x) {return x*x;}\n\nbool check(int i, int j) {\n    int d2 = square(x[i]-x[j]) + square(y[i]-y[j]);\n    return d2 < square(r[i]+r[j]);\n}\n\nint dfs(int state, int n) {\n    int ret = 0;\n    if (dp.find(state) != dp.end()) return dp[state];\n    vector<int> already;\n    memset(ok, true, sizeof(ok));\n    for (int i = 0; i < n; i++) {\n        if ((state>>i)&1) continue;\n        if (ok[i]) {\n            already.push_back(i);\n        }\n        for (int j = i+1; j < n; j++) {\n            if (check(i, j)) ok[j] = false;\n        }\n    }\n    int sz = already.size();\n    for (int i = 0; i < sz; i++) {\n        for (int j = i+1; j < sz; j++) {\n            int ai = already[i], aj = already[j];\n            if (c[ai] == c[aj]) {\n                int nstate = state;\n                nstate |= 1<<ai;\n                nstate |= 1<<aj;\n                ret = max(2+dfs(nstate, n), ret);\n            }\n        }\n    }\n    return dp[state] = ret;\n}\n\nint main() {\n    // cin.tie(0);\n    // ios::sync_with_stdio(false);\n    int n;\n    while(scanf(\"%d\", &n) && n){\n      for (int i = 0; i < n; i++) scanf(\"%d %d %d %d\", &x[i],&y[i],&r[i],&c[i]);\n      dp.clear();\n      cout << dfs(0, n) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct circle{\n  double x, y, r;\n  int c;\n  unordered_set<int> up, down;\n};\n\nvoid calcOverlap(int n, circle *disk){\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      int x = disk[i].x - disk[j].x, y = disk[i].y - disk[j].y;\n      if(sqrt(x*x + y*y) + 1e-8< disk[i].r + disk[j].r){\n        disk[j].up.insert(i);\n        disk[i].down.insert(j);\n      }\n    }\n  }\n}\n\nbool canRemove(circle d, circle dd){\n  if(d.c != dd.c)return false;\n  return d.up.empty() and dd.up.empty();\n}\n\nint dfs(int n, circle *disk, bool *removed, int dep = 0){\n  int res = 0;\n  bool f = false;\n  for (int i = 0; i < n; i++) {\n    if(removed[i] == true)continue;\n    for (int j = i + 1; j < n; j++) {\n      if(removed[j] == true)continue;\n      if(not canRemove(disk[i], disk[j]))continue;\n      f = true;\n      removed[i] = true;\n      removed[j] = true;\n      int erase_i = -1, erase_j = -1;\n      for (int k = 0; k < n; k++) {\n        if(disk[k].up.find(i) != disk[k].up.end()){\n          disk[k].up.erase(i);\n          erase_i = k;\n        }\n        if(disk[k].up.find(j) != disk[k].up.end()){\n          disk[k].up.erase(j);\n          erase_j = k;\n        }\n      }\n      res = max(res, dfs(n, disk, removed, dep + 1));\n      if(erase_j != -1)disk[erase_j].up.insert(j);\n      if(erase_i != -1)disk[erase_i].up.insert(i);\n      removed[i] = false;\n      removed[j] = false;\n    }\n  }\n  return f?res:dep;\n}\n\nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n, n){\n    circle disk[n];\n    for (int i = 0; i < n; i++) {\n      cin >> disk[i].x >> disk[i].y >> disk[i].r >> disk[i].c;\n    }\n    bool removed[n];\n    memset(removed, false, sizeof(removed));\n    calcOverlap(n, disk);\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        if(not canRemove(disk[i], disk[j]))continue;\n        if(not disk[i].down.empty() or\n           not disk[j].down.empty())continue;\n        removed[i] = true;\n        removed[j] = true;\n        ans++;\n      }\n    }\n    std::cout << 2*(ans + dfs(n, disk, removed)) << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nconst int limit=10;\nint n,ans;\nint num[limit],x[limit],y[limit],r[limit],v[limit];\nbool visit[limit];\nbool road[limit][limit];\nusing namespace std;\n\nvoid dfs(int step)\n{\n\tif(step-1>ans) ans=step-1;\n\tfor(int i=1;i<=n;i++) \n\tif ((!visit[i])&&(num[i]==0))\n\t\tfor(int j=1;j<=n;j++) if ((v[i]==v[j])&&(i!=j)&&(!visit[j])&&(num[j]==0)) \n\t\t{\n\t\t\tvisit[i]=true; visit[j]=true;\n\t\t\tfor(int k=1;k<=n;k++) \n\t\t\t{\n\t\t\t\tif(road[i][k]) num[k]--;\n\t\t\t\tif(road[j][k]) num[k]--;\n\t\t\t}\n\t\t\tdfs(step+1);\n\t\t\tvisit[i]=false; visit[j]=false;\n\t\t\tfor(int k=1;k<=n;k++) \n\t\t\t{\n\t\t\t\tif(road[i][k]) num[k]++;\n\t\t\t\tif(road[j][k]) num[k]++;\n\t\t\t}\n\t\t}\n}\nint main()\n{\n\t//freopen(\"input.txt\",\"r\",stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n\tcin>>n;\n\twhile(n!=0)\n\t{\n\t\tans=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tnum[i]=0;\n\t\t\tfor(int j=1;j<=n;j++) link[i][j]=false;\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tvisit[i]=false;\n\t\t \tcin>>x[i]>>y[i]>>r[i]>>v[i];\n\t\t \tfor(int j=1;j<i;j++) if((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])<(r[i]+r[j])*(r[i]+r[j]))\n\t\t \t{\n\t\t \t\troad[j][i]=true;\n\t\t \t\tnum[i]++;\n\t\t \t}\n\t    }\n\t    dfs(1);\n\t    cout<<ans*2<<endl;\n\t    cin>>n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int N = 25;\n\nint n;\nint ol[N];\nint x[N], y[N], r[N], c[N];\nbool vis[1<<N];\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n    for(int i=0;i<n;i++){\n      ol[i] = 0;\n      for(int j=0;j<i;j++){\n        if((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) < (r[i] + r[j]) * (r[i] + r[j])){\n          ol[i] |= (1<<j);\n        }\n      }\n    }\n    fill(vis, vis+(1<<n), false);\n    queue<int> q;\n    int u = (1<<n) - 1;\n    q.push(u);\n    vis[u] = true;\n    while(!q.empty()){\n      u = q.front();q.pop();\n      //cout << u << endl;\n      for(int i=0;i<n;i++){\n        if(u>>i & 1 == 0) continue;\n        for(int j=i+1;j<n;j++){\n          if((u>>j & 1) == 0) continue;\n          if(c[i] != c[j]) continue;\n          int f1 = ((ol[i]&u)>>i)<<i;\n          int f2 = ((ol[j]&u)>>j)<<j;\n          //cout << i << ' ' << ol[i] << ' ' << f1 << endl;\n          //cout << j << ' ' << ol[j] << ' ' << f2 << endl;\n          if(f1 < (ol[i]&u) || f2 < (ol[j]&u)) continue;\n          int v = u;\n          v &= ~(1<<i);\n          v &= ~(1<<j);\n          if(vis[v]) continue;\n          vis[v] = true;\n          //cout << \"-> \" << v << endl;\n          q.push(v);\n        }\n      }\n    }\n    int ans = 0;\n    for(int i=0;i<(1<<n);i++){\n      if(vis[i]){\n        int cnt = 0;\n        for(int j=0;j<n;j++){\n          if((i>>j & 1) == 0) cnt++;\n        }\n        ans = max(ans, cnt);\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n\nunordered_map<int,int> memo;\nint rec(int used, vector<vector<bool> > const & e, vector<int> const & c) {\n    if (memo.count(used)) return used;\n    int n = e.size();\n    vector<int> top;\n    repeat (i,n) if (not (used & (1 << i))) {\n        bool ok = true;\n        repeat (j,i) if (not (used & (1 << j))) {\n            if (e[j][i]) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) top.push_back(i);\n    }\n    int result = 0;\n    repeat (ti,top.size()) {\n        int i = top[ti];\n        repeat (tj,ti) {\n            int j = top[tj];\n            if (c[i] == c[j]) {\n                result = max(result, rec(used ^ (1<<i) ^ (1<<j), e, c) + 2);\n            }\n        }\n    }\n    return memo[used] = result;\n}\nint solve(vector<vector<bool> > const & e, vector<int> const & c) {\n    memo.clear();\n    return rec(0, e, c);\n}\n\ntemplate <typename T>\nT sq(T x) { return x*x; }\nstruct circle_t { int x, y, r; };\nbool is_intersect(circle_t a, circle_t b) {\n    return sq(a.x - b.x) + sq(a.y - b.y) < sq(a.r + b.r);\n}\nint main() {\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        vector<circle_t> p(n);\n        vector<int> c(n);\n        repeat (i,n) {\n            cin >> p[i].x >> p[i].y >> p[i].r >> c[i];\n        }\n        vector<vector<bool> > e(n, vector<bool>(n));\n        repeat (i,n) {\n            repeat (j,i) {\n                if (is_intersect(p[i], p[j])) {\n                    e[i][j] = e[j][i] = true;\n                }\n            }\n        }\n        cout << solve(e, c) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 30;\nint x[MAXN], y[MAXN], r[MAXN], c[MAXN];\nint dp[1<<24];\nbool ok[MAXN];\n\nint square(int x) {return x*x;}\n\n// i, j ???????????£?????????????????????\n// ????????£????????? true\nbool check(int i, int j) {\n    int d2 = square(x[i]-x[j]) + square(y[i]-y[j]);\n    return d2 < square(r[i]+r[j]);\n}\n\nint dfs(int state, int n) {\n    int& ret = dp[state];\n    if (ret >= 0) return ret;\n    ret = 0;\n    // ???????????¨??????????????§??????????????????????????????\n    vector<int> already;\n    memset(ok, true, sizeof(ok));\n    for (int i = 0; i < n; i++) {\n        if ((state>>i)&1) continue;\n        if (ok[i]) {\n            already.push_back(i);\n        }\n        for (int j = i+1; j < n; j++) {\n            if (check(i, j)) ok[j] = false;\n        }\n    }\n    int sz = already.size();\n    for (int i = 0; i < sz; i++) {\n        for (int j = i+1; j < sz; j++) {\n            int ai = already[i], aj = already[j];\n            if (c[ai] == c[aj]) {\n                int nstate = state;\n                nstate |= 1<<ai;\n                nstate |= 1<<aj;\n                ret = max(2+dfs(nstate, n), ret);\n            }\n        }\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while (cin >> n) {\n        if (n==0) break;\n        for (int i = 0; i < n; i++) cin >> x[i] >> y[i] >> r[i] >> c[i];\n        memset(dp, -1, sizeof(dp));\n        cout << dfs(0, n) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-9\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nint N;\n\nint dfs(mat &rank, vec &used, vec &C) {\n    int res = 0;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j) continue;\n            if (!used[i] && !used[j] && C[i] == C[j] && !(rank[i][j] || rank[j][i])) {\n                bool flag = true;\n                for (int k = 0; k < N; k++) {\n                    if (k == i || k == j) continue;\n                    if (rank[i][k] && !used[k]) flag = false;\n                    if (rank[j][k] && !used[k]) flag = false;\n                }\n\n                if (flag) {\n                    used[i] = used[j] = 1;\n                    res = max(dfs(rank, used, C) + 1, res);\n                    used[i] = used[j] = 0;\n                }\n            }\n        }\n    }\n\n    return res;\n}\n\nint main() {\n    while (cin >> N, N) {\n        vector<double> X(N), Y(N), R(N);\n        vector<int> C(N);\n        for (int i = 0; i < N; i++) {\n            cin >> X[i] >> Y[i] >> R[i] >> C[i];\n        }\n\n        mat rank(N, vec(N));\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                double dis = sqrt(pow(X[i] - X[j], 2.) + pow(Y[i] - Y[j], 2.));\n                if (dis < R[i] + R[j]) {\n                    rank[j][i] = 1;\n                }\n            }\n        }\n\n\n        vec used(N);\n        cout << 2 * dfs(rank, used, C) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint n;\nint x[25],y[25],r[25],c[25];\nint cover[25];\ndouble d[25][25];\nbool check[1<<25];\nint cnt,comb,a,b;\nint m,ans;\nint u;\n\ndouble dis(int i,int j){\n  return sqrt( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j]) * (y[i]-y[j]) );\n}\n\nvoid cov(int a){\n  cover[a] = -1;\n  for(int j=a-1;j>=0;j--){\n    if(d[j][a]<r[a]+r[j] && u>>j & 1){\n      cover[a] = j;\n      break;\n    }\n  }\n} \n\n  \nvoid rec(void){\n  int cnt;\n\n  if(check[u])return;\n  check[u] = true;\n\n  for(int i=1;i<=4;i++){\n    cnt = 0;\n    for(int j=0;j<n;j++){\n      if( (u>>j & 1) && cover[j]<0 && c[j] == i)cnt++;\n    }\n    if(cnt==6){\n      for(int j=0;j<n;j++){\n\tif(c[j] == i)u -= 1<<j;\n      }\n      for(int j=0;j<n;j++)cov(j);\n\n      ans += 6;\n      m = max(m,ans);\n      if(!check[u]){\n        check[u] = true;\n\trec();\n\tif(!u)return;\n      }\n      ans -= 6;\n\n      for(int j=0;j<n;j++){\n\tif(c[j] == i)u += 1<<j;\n      }\n      for(int j=0;j<n;j++)cov(j);\n    }else{\n      for(int j=0;j<n;j++){\n\tif( (u>>j & 1) && cover[j]<0 && c[j] == i){\n\t  for(int k=j+1;k<n;k++){\n\t    if( (u>>k & 1) && cover[k]<0 && c[k] == i){\n\t      u -= 1<<j;\n\t      u -= 1<<k;\n\t      for(int l=0;l<n;l++)cov(l);\n\n\t      ans += 2;\n\t      m = max(m,ans);\n\t      rec();\n\t      if(!u)return;\n\t      ans -= 2;\n\n\t      u += 1<<j;\n\t      u += 1<<k;\n\t      for(int l=0;l<n;l++)cov(l);\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n}\n\n\n\nint main(){\n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    for(int i=0;i<n;i++)cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++)d[i][j] = dis(i,j);\n    }\n\n    u = (1<<n) - 1;\n    for(int i=0;i<(1<<n);i++)check[i] = false;\n    for(int i=0;i<n;i++)cov(i);\n\n    \n    m = 0;\n    ans = 0;\n    rec();\n\n    cout << m << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = a.r * a.r + 2 * a.r * b.r + b.r * b.r;\n    return r > (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\nint main()\n{\n    int n;\n\n    while (cin >> n, n) {\n        const int N = 1 << n;\n        vector<char> dp(N, -1), up(n, 0);\n        vector<Circle> c(n);\n\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j) {\n                if (isOverlap(c[i], c[j])) {\n                    if (i < j) // jの上にiがある\n                        up[j] |= (1 << i);\n                    else // iの上にjがある\n                        up[i] |= (1 << j);\n                }\n            }\n\n        int res = 0;\n        dp[N - 1] = 0;\n        for (int s = N - 1; s >= 0; --s) {\n            if (dp[s] == -1)\n                continue;\n\n            res = max(res, (int)dp[s]);\n            for (int i = 0; i < n; ++i) {\n                if (!(s >> i & 1) || s & up[i]) // c[i]が置かれていないかc[i]が取り除けない\n                    continue;\n\n                for (int j = i + 1; j < n; ++j) {\n                    if (c[i].c != c[j].c) // 色が異なる\n                        continue;\n                    if (!(s >> j & 1) || s & up[j])  // c[j]が置かれていないかc[j]が取り除けない\n                        continue;\n\n                    int nxt = s & ~(1 << i) & ~(1 << j);\n                    dp[nxt] = max((int)dp[nxt], dp[s] + 2);\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\nchar bit_count[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n-bit_count[bit];\n\n    for(int i=0;i<n;i++){\n        if(((bit>>i)&1)==0||ok(i,bit)==false)continue;\n        for(int j=i+1;j<n;j++){\n            if(((bit>>j)&1)==0||ok(j,bit)==false||c[i]!=c[j])continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(!memo[to_bit])ret=max(ret,dfs(to_bit));\n\n        }\n    }\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\nvoid init(){\n    for(int i=0;i<(1<<24);i++){\n        for(int j=0;j<24;j++)if((i>>j)&1){\n            bit_count[i]++;\n        }\n    }\n}\n\nint main(){\n    init();\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define x first.first\n#define y first.second\n#define r second.first\n#define color second.second\n\nusing namespace std;\n\ntypedef pair<double,double> P;\ntypedef pair<P,P> C;\n\nbool check(C a,C b){\n  return a.r+b.r>sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n \nint count(int bits){\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits =(((bits >> 4) + bits) & 0x0f0f0f0f);\n  bits += bits >> 8;\n  return (bits + (bits >> 16)) & 0xff;\n}\n \nbool dp[(1<<25)];\n \nint main(void){\n \n\tint n;\n\twhile(cin >> n,n){\n\t\tC c[25];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tscanf(\"%lf %lf %lf %lf\",&c[i].x,&c[i].y,&c[i].r,&c[i].color);\n\t\t\n\t\tfill(dp,dp+(1<<n),false);\n\t\tdp[(1<<n)-1]=true;\n\t\tint ans=0;\n\t\t\n\t\tfor(int S=(1<<n)-1;S>=0;S--){\n\t\t\tif(!dp[S])continue;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\t\n\t\t\t\t\tint nx=S;\n\t\t\t\t\tnx&=~(1<<i) & ~(1<<j);\n\t\t\t\t\tif(dp[nx])continue;\n\t\t\t\t\t\n\t\t\t\t\tif(!(S>>i&1) || !(S>>j&1))continue;\n\t\t\t\t\tif(c[i].color!=c[j].color)continue;\n\t\t\t\t\t\n\t\t\t\t\tbool fg=false;\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(!(S>>k&1))continue;\n\t\t\t\t\t\tfg|= k<i && check(c[i],c[k]);\n\t\t\t\t\t\tfg|= k<j && check(c[j],c[k]);\n\t\t\t\t\t\tif(fg)break;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(!fg)dp[nx]|=dp[S];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp[S])ans=max(ans,n-count(S));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <functional>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n\n#define X first\n#define Y second\n#define mp(x, y) make_pair(x, y)\n#define pb(e) push_back(e)\n#define rep(i, b, n) for (int i = (b); i < (n); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define each(c, i) for (iter(c) i = (c).begin(); i != (c).end(); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\ntypedef pair<double, double> PDD;\ntypedef long long LINT;\ntypedef vector<int> VI;\ntypedef vector<VI> VII;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\n\nconst int MAX_N = 24;\nint N;\nint color[MAX_N];\nint ride[MAX_N];\nint x[MAX_N];\nint y[MAX_N];\nint r[MAX_N];\n\nbool isCollision ( int x1, int y1, int r1, int x2, int y2, int r2 )\n{\n\tint xx = x1 - x2, yy = y1 - y2, rr = r1 + r2;\n\treturn (xx * xx + yy * yy) < (rr * rr);\n}\n\nint dfs ( int state, int depth )\n{\n\tif (depth == N/2) { return 0; }\n\tint res = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif ((state & (1 << i)) && !(state & ride[i])) {\n\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\tif ((state & (1 << j)) && !(state & ride[j]) && color[i] == color[j]) {\n\t\t\t\t\tint next = state & ~((1 << i) | (1 << j));\n\t\t\t\t\tres = max(res, dfs(next, depth+1) + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nchar d[1 << MAX_N];\n\nint main ( void )\n{\n\twhile (cin >> N, N) {\n\t\tfill(ride, ride+N, 0);\n\t\trep (i, 0, N) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> color[i];\n\t\t\trep (j, 0, i) {\n\t\t\t\tif (isCollision(x[i], y[i], r[i], x[j], y[j], r[j])) {\n\t\t\t\t\tride[i] |= (1 << j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfill(d, d+(1 << N), -1);\n\t\tint state = (1 << N) - 1;\n\t\tchar ans = 0;\n\t\td[state] = 0;\n\t\tfor (; state > 0; --state) {\n\t\t\tif (d[state] == -1) { continue; }\n\t\t\trep (i, 0, N) {\n\t\t\t\tif (state & (1 << i) && !(state & ride[i])) {\n\t\t\t\t\trep (j, i+1, N) {\n\t\t\t\t\t\tif (state & (1 << j) && !(state & ride[j]) && color[i] == color[j]) {\n\t\t\t\t\t\t\tint next = state & ~((1 << i) | (1 << j));\n\t\t\t\t\t\t\td[next] = max<char>(d[next], d[state] + 2);\n\t\t\t\t\t\t\tans = max<char>(ans, d[next]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (int)ans << endl;\n\t\t//cout << dfs((1 << N) - 1, 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n\nint dp[1<<24];\nint n;\nint x[24],y[24],r[24],c[24];\n\nint square(int a){\n\treturn a*a;\n}\nbool overlap(int i,int j){\n\treturn square(x[i]-x[j])+square(y[i]-y[j]) < square(r[i]+r[j]);\n}\nbool top(int s,int k){\n\tfor(int i=0;i<k;i++){\n\t\tif(s&1<<i){\n\t\t\tif(overlap(k,i))return false;\n\t\t}\n\t}\n\treturn true;\n}\nint dfs(int s){\n\tif(dp[s]!=-1)return dp[s];\n\tint res=0;\n\tfor(int i=0;i<n;i++){\n\t\tif((s&1<<i)==0 || !top(s,i))continue;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif((s&1<<j)==0 || !top(s,j))continue;\n\t\t\tif(c[i]==c[j])res = max(res,dfs(s&~(1<<i)&~(1<<j))+2);\n\t\t}\n\t}\n\treturn dp[s]=res;\n}\nint main(){\n\twhile(cin>>n&&n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\t}\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tcout<<dfs((1<<n)-1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<math.h>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\nstruct status{\n    bool o[24];\n};\n\nint n;\ndouble x[24], y[24], r[24];\nint c[24];\ndouble d[24][24];\n\ndouble dist(double x1, double y1, double x2, double y2){\n    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\n\nbool gone[1<<24];\n\nint o2idx(bool (&o)[24]){\n    int output = 0;\n    REP(i, n){\n        if(o[i]){\n            output = output | 1<<i;\n        }\n    }\n    return output;\n}\n\nint main(){\n    while(1){\n        cin >> n;\n        if(n==0) break;\n\n        REP(i, n){\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n\n        int colnum = 0;\n        REP(i, n){\n            colnum = max(colnum, c[i]);\n        }\n\n        REP(i, n){\n            REP(j, n){\n                d[i][j] = dist(x[i], y[i], x[j], y[j])-(r[i]+r[j]);\n            }\n        }\n\n        REP(i, 1<<n) gone[i]=false;\n\n        int maxnum = 0;\n        queue<status> que;\n        status s;\n        REP(i, n) s.o[i] = true;\n        que.push(s);\n        gone[o2idx(s.o)] = true;\n        while(!que.empty()){\n            status s = que.front();\n            que.pop();\n\n            int count = 0;\n            REP(i, n){\n                if(!s.o[i]) count += 1;\n                // cout << s.o[i] << \" \";\n            }\n            // cout << endl;\n            maxnum = max(maxnum, count);\n\n            vector<int> top[4];\n            REP(i, n){\n                if(s.o[i]){\n                    bool flag = true;\n                    REP(j, i){\n                        if(s.o[j] && d[i][j]<0) flag = false;\n                    }\n                    if(flag){\n                        top[c[i]-1].push_back(i);\n                    }\n                }\n            }\n\n            REP(i, colnum){\n                if(top[i].size()>=2){\n                    REP(j, top[i].size()-1){\n                        for(int k=j+1; k<top[i].size(); k++){\n                            status ns;\n                            REP(l, n) ns.o[l] = s.o[l];\n                            ns.o[top[i][j]] = false;\n                            ns.o[top[i][k]] = false;\n                            if(!gone[o2idx(ns.o)]){\n                                gone[o2idx(ns.o)] = true;\n                                que.push(ns);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        cout << maxnum << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nstruct Solver\n{\n\tconst int N;\n\tVI xs, ys, rs, cs;\n\tset< vector<bool> > visited;\n\n\tint res;\n\n\tSolver( int n ) : N( n ), xs( N ), ys( N ), rs( N ), cs( N ), res( 0 )\n\t{\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tcin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n\t\t}\n\t\treturn;\n\t}\n\n\toperator int()\n\t{\n\t\tvector<bool> tmp( N, true );\n\t\tdfs( tmp );\n\t\treturn res;\n\t}\n\n\tvoid dfs( vector<bool> &exists )\n\t{\n\t\tif ( EXIST( visited, exists ) )\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tvisited.insert( exists );\n\t\tres = max<int>( res, count( ALL( exists ), false ) );\n\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tif ( overlapped( exists, i ) )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tREP( j, 0, i )\n\t\t\t{\n\t\t\t\tif ( !exists[i] || !exists[j] || cs[i] != cs[j] || overlapped( exists, j ))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\texists[i] = exists[j] = false;\n\t\t\t\tdfs( exists );\n\t\t\t\texists[i] = exists[j] = true;\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\tbool overlapped( const vector<bool> &exists, const int p )\n\t{\n\t\tREP( i, 0, p )\n\t\t{\n\t\t\tif ( !exists[i] )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( ( xs[p] - xs[i] ) * ( xs[p] - xs[i] ) + ( ys[p] - ys[i] ) * ( ys[p] - ys[i] ) < ( rs[i] + rs[p] ) * ( rs[i] + rs[p] ) )\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int n; cin >> n, n; )\n\t{\n\t\tcout << Solver( n ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nbool used[25];\ndouble x[25],y[25],r[25];\nint c[25];\nint main(){\n    int n;\n    while(cin>>n,n){\n        int cnt=0;\n        memset(used,0,sizeof(used));\n        rep(i,n) cin>>x[i]>>y[i]>>r[i]>>c[i];\n        rep(i,n-1)if(!used[i]){\n            double tx=x[i],ty=y[i],tr=r[i];\n            int tc=c[i];\n            bool flag=false;\n            rep(j,i){\n                if(!used[j]&&sqrt((tx-x[j])*(tx-x[j])+(ty-y[j])*(ty-y[j]))<tr+r[i]){\n                    flag=true;break;\n                }\n            }\n            if(flag) continue;\n            FOR(j,i+1,n){\n                if(tc==c[j]){\n                    rep(k,j){\n                        if(!used[j]&&sqrt((tx-x[j])*(tx-x[j])+(ty-y[j])*(ty-y[j]))<tr+r[i]){\n                            flag=true;break;\n                        }\n                    }\n                    if(flag) continue;\n                    else{\n                        cnt+=2;\n                        used[i]=used[j]=true;\n                        break;\n                    }\n                }\n            }\n        }\n        cout<<cnt<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int N = 24;\n\nint n;\nint ol[N];\nint x[N], y[N], r[N], c[N];\nbool vis[1<<N];\nint vec[(1<<N)+1];\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n    for(int i=0;i<n;i++){\n      ol[i] = 0;\n      for(int j=0;j<i;j++){\n        if((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) < (r[i] + r[j]) * (r[i] + r[j])){\n          ol[i] |= (1<<j);\n        }\n      }\n    }\n    fill(vis, vis+(1<<n), false);\n\n    int l = 0, r = 0;\n    //queue<int> q;\n    int u = (1<<n) - 1;\n    vec[r++] = u;\n    //q.push(u);\n    vis[u] = true;\n    int ans = -2;\n    while(l < r){\n    //while(!q.empty()){\n      ans += 2;\n      for(int k=0;k<r-l;k++){\n      //for(int k=0;k<q.size();k++){\n        u = vec[l++];\n        //u = q.front();q.pop();\n        for(int i=0;i<n;i++){\n          if(u>>i & 1 == 0) continue;\n          int f1 = ((ol[i]&u)>>i)<<i;\n          if(f1 < (ol[i]&u)) continue;\n          for(int j=i+1;j<n;j++){\n            if((u>>j & 1) == 0) continue;\n            if(c[i] != c[j]) continue;\n            int f2 = ((ol[j]&u)>>j)<<j;\n            if(f2 < (ol[j]&u)) continue;\n            int v = u;\n            v &= ~(1<<i);\n            v &= ~(1<<j);\n            if(vis[v]) continue;\n            vis[v] = true;\n            vec[r++] = v;\n            //q.push(v);\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint x[30], y[30], r[30], c[30], n, ans;\nbool memo[1<<24];\n// d[i][j] i?????????j????????£?????????1\nbool d[30][30];\nvoid dfs(ll m) {\n  if(memo[m]) return;\n  //cout << bitset<24>(m) << endl;\n  //???????????£?????????????????°???????????¨?????°??????\n  VI cnt[6];\n  REP(i, n) {\n    //i????????¨??????????????£??????continue\n    if(m>>i&1) continue;\n    bool flag = true;\n    REP(j, n) {\n      //j????????¨??????????????£??????continue\n      if(m>>j&1) continue;\n      if(d[i][j]) flag = false;\n    }\n    if(flag) cnt[c[i]].PB(i);\n  }\n\n  bool g = false;\n  FOR(i, 1, 5) if(cnt[i].size()>=2) g = true;\n  //????????£????????????\n  if(!g) {\n    int sum=0;\n    REP(i, n) {\n      if(m>>i&1) sum++;\n    }\n    ans = max(ans, sum);\n    memo[m] = true;\n    return;\n  }\n\n  FOR(i, 1, 5) {\n    //cout << \"i:\" << cnt[i].size() << endl;\n    if(cnt[i].size()<=1) continue;\n    REP(j, cnt[i].size()) REP(k, j) {\n      //cout << j << \":\" << k << endl;\n      ll tmp = m;\n      tmp |= 1<<cnt[i][j];\n      tmp |= 1<<cnt[i][k];\n      dfs(tmp);\n    }\n  }\n  memo[m] = true;\n  return;\n}\n\nsigned main(void)\n{\n  while(true) {\n    cin >> n;\n    if(!n) break;\n    REP(i, 30) REP(j, 30) d[i][j] = 0;\n    bool h = true;\n    REP(i, n) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n      for(int j=i-1; j>=0; --j) {\n        // ??????i??¨??????j???????????£??????????????????i???????????????j????????¨????????????\n        double dist = sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j])), rr = r[i] + r[j];\n        //cout << dist << \" \" << rr << endl;\n        if(dist < rr) d[i][j] = true, h = false;\n      }\n    }\n    /*REP(i, n) {\n      REP(j, n) {\n        cout << d[i][j] << \" \";\n      }\n      cout << endl;\n    }*/\n    if(h) {cout << n << endl; continue;}\n    ans = 0;\n    memset(memo,false,sizeof(memo));\n    dfs(0);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-10\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int INF = 1 << 28;\n\nint n;\nvector<double> x, y, r;\nvector<int> c;\nmap<long long, int> m;\n\nvector<vector<int> > create (int era) {\n    vector<vector<int> > par(n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            double dis = pow(x[j] - x[i], 2.0) +  pow(y[j] - y[i], 2.0);\n            if (sqrt(dis) < r[i] + r[j] && !(era & (1 << j))) {\n                par[i].push_back(j);\n            }\n        }\n    }\n\n    return par;\n}\n\nint dfs (vector<vector<int> > par, int era) {\n    if (m.find(era) != m.end()) {\n        return m[era];\n    }\n    vector<vector<int> > count(5);\n    for (int i = 0; i < n; i++) {\n        bool flag = true;\n        for (int j = 0; j < par[i].size(); j++) {\n            if (!(era & (1 << par[i][j]))) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag && (era & (1 << i)) == 0) {\n            count[c[i]].push_back(i);\n        }\n    }\n\n    int ret = 0;\n    for (int i = 1; i < count.size(); i++) {\n        if (count[i].size() >= 2) {\n            for (int sx = 0; sx < count[i].size(); sx++) {\n                for (int sy = sx + 1; sy < count[i].size(); sy++) {\n                    if (sx == sy) continue;\n                    int era_t = era;\n                    era_t |= (1 << count[i][sx]);\n                    era_t |= (1 << count[i][sy]);\n                    vector<vector<int> > t_par(create(era_t));\n                    ret = max(ret, (dfs(t_par, era_t) + 2));\n                }\n            }\n        }\n    }\n\n    return m[era] = ret;\n}\n\nint main () {\n    while (cin >> n, n) {\n        m.clear();\n        x.resize(n), y.resize(n), r.resize(n), c.resize(n);\n        for (int i = 0; i < n; i++) {\n            cin  >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n\n        vector<vector<int> > par(create(0));\n\n\n        cout << dfs(par, 0) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\nusing namespace std;\n\nstruct object{\n// 各円を示す構造体\n\tint id;\n\tint posx;\n\tint posy;\n\tint rad;\n\tint color;\n\tlist<int> parent;\n};\n\nvoid checkcontact(object& upper,object& lower){\n//　2つの円の重なりを調べ、下の円に自分の上にある円のidを記録\n\tif((upper.posx-lower.posx)*(upper.posx-lower.posx)+(upper.posy-lower.posy)*(upper.posy-lower.posy)<(upper.rad+lower.rad)*(upper.rad+lower.rad)){\n\t\tlower.parent.push_back(upper.id);\n\t}\n}\n\n\nlist<object>::iterator nexttop(list<object>::iterator itcur,list<object>::iterator& itl){\n// 現在iteratorと末端iteratorから、次の回収可能円を示すiterator又は末端iteratorを返却\n\tdo{\n\t\t++itcur;\n\t\tif(itcur==itl)return itcur;\n\t}while(!(*itcur).parent.empty());\n\treturn itcur;\n}\n\n\nunsigned int cal(list<object>& base){\n\tlist<object> cop;\n\tlist<object>::iterator ita,itb,itc,itl;\n\tunsigned int submax=-1,subret;\n\titl=base.end();\n\tcop.resize(base.size()-2);\n\tfor(ita=base.begin();ita!=itl;ita=nexttop(ita,itl)){\n\t\tif(base.size()<2)break;\n\t\tfor(itb=nexttop(ita,itl);itb!=itl;itb=nexttop(itb,itl)){\n\t\t\tif((*itb).color==(*ita).color){\n\t\t\t\tcop.clear();\n\t\t\t\tfor(itc=base.begin();itc!=itl;++itc){\n\t\t\t\t\tif(itc!=ita&&itc!=itb){\n\t\t\t\t\t\tcop.push_back(*itc);\n\t\t\t\t\t\tcop.back().parent.remove((*ita).id);\n\t\t\t\t\t\tcop.back().parent.remove((*itb).id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubret=cal(cop);\n\t\t\t\tif(subret<submax)submax=subret;\n\t\t\t}\n\t\t}\n\t}\n\tsubret=base.size();\n\tif(subret<submax)submax=subret;\n\treturn submax;\n}\nint main(){\n\tint n;\n\tobject tmp; \n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tlist<object> objects;\n\t\tlist<object>::iterator ita,itl;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp.id=i;\n\t\t\tcin>>tmp.posx>>tmp.posy>>tmp.rad>>tmp.color;\n\t\t\ttmp.parent.clear();\n\t\t\titl=objects.end();\n\t\t\tfor(ita=objects.begin();ita!=itl;++ita)checkcontact(*ita,tmp);\n\t\t\tobjects.push_back(tmp);\n\t\t}\n\t\tcout<<n-cal(objects)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\ntypedef double D;\nconst D EPS = 1e-8;\n\nstruct P {\n    D x, y;\n    P(D x_, D y_) : x(x_), y(y_) { }\n    P() {}\n};\n\ninline P operator -(const P& a, const P& b) { return P(a.x - b.x, a.y - b.y); }\ninline D inp(const P& a, const P& b) { return a.x*b.x + a.y*b.y; }\ninline D norm(const P& p) { return inp(p, p); }\ninline D abs(const P& p) { return sqrt(norm(p)); }\n\nstruct C {\n    P p; D r;\n    C(P p_, D r_) : p(p_), r(r_) { }\n    C() { }\n};\n\ninline bool iCC(const C& a, const C& b) {\n    D d = abs(a.p - b.p);\n    return (a.r + b.r)  - EPS > d;\n}\n\nint bit_count(unsigned int b) {\n    return __builtin_popcount(b);\n}\n\nint bit_right(unsigned int b) {\n    return __builtin_ctz(b);\n}\n\nint bit_left(unsigned int b) {\n    return 31 - __builtin_clz(b);\n}\n\nint N;\nvector<int> color;\nvector<C> circle;\nvector<char> ok;\nint num;\nint ans;\n\n\nvoid solve() {\n    vector<vector<int> > v(4, vector<int>());\n    for(int i = 0; i < N; i++) {\n        if(ok[i]) {\n            bool fr = true;\n            for(int j = i + 1; j < N; j++) {\n                if(ok[j]) {\n                    if(iCC(circle[i], circle[j])) {\n                        fr = false;\n                        break;\n                    }\n                }\n            }\n            if(fr) {\n                v[color[i]].push_back(i);\n            }\n        }\n    }\n#if 0\n    for(int i = 0; i < 4; i++) {\n        cerr << \"color \" << i << \": \";\n        for(int j = 0; j < (int)v[i].size(); j++) {\n            cerr << v[i][j] << \" \";\n        }\n        cerr << endl;\n    }\n#endif\n    for(int i = 0; i < 4; i++) {\n        if(v[i].size() >= 2) {\n            for(int b = 0; b < (1 << v[i].size()); b++) {\n                if(bit_count(b) == 2) {\n                    int n = v[i][bit_right(b)];\n                    int m = v[i][bit_left(b)];\n                    ok[n] = 0;\n                    ok[m] = 0;\n                    num -= 2;\n                    ans = max(ans, N - num);\n                    solve();\n                    ok[n] = 1;\n                    ok[m] = 1;\n                    num += 2;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    for(; cin >> N, N; ) {\n        color = vector<int>(N);\n        circle = vector<C>(N);\n        ok = vector<char>(N, 1);\n        num = N;\n        ans = 0;\n        for(int i = 0; i < N; i++) {\n            cin >> circle[i].p.x >> circle[i].p.y >> circle[i].r >> color[i];\n            color[i]--;\n        }\n        reverse(circle.begin(), circle.end());\n        reverse(color.begin(), color.end());\n        solve();\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\n\nconstexpr int MAX_N = 24;\nconstexpr int MAX_C = 4;\n\nint n;\nint x[MAX_N], y[MAX_N], r[MAX_N], c[MAX_N];\n\nint ans;\nint over[MAX_N];\nbool visited[1 << MAX_N];\n\ninline int square(int value) {\n\treturn value * value;\n}\n\ninline bool intersect(int x1, int y1, int r1, int x2, int y2, int r2) {\n\treturn square(x1 - x2) + square(y1 - y2) < square(r1 + r2);\n}\n\nvoid dfs(int rest, int cnt = 0) {\n\tchmax(ans, cnt);\n\tvisited[rest] = true;\n\n\tint candidates[MAX_C] = {};\n\tfor(int i = 0; i < n; ++i) {\n\t\tif((rest & (1 << i)) && (rest & over[i]) == 0) {\n\t\t\tcandidates[c[i]] |= 1 << i;\n\t\t}\n\t}\n\n\tfor(const auto &bit : candidates) {\n\t\tfor(int p = bit; p;) {\n\t\t\tconst int i = p & -p;\n\t\t\tp &= p - 1;\n\n\t\t\tfor(int q = p; q; q &= q - 1) {\n\t\t\t\tconst int j = q & -q;\n\t\t\t\tconst int next_rest = rest ^ (i | j);\n\t\t\t\tif(!visited[next_rest]) dfs(next_rest, cnt + 2);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n && n) {\n\t\tfill_n(over, n, 0);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t\t--c[i];\n\n\t\t\tfor(int j = 0; j < i; ++j) {\n\t\t\t\tif(intersect(x[i], y[i], r[i], x[j], y[j], r[j])) {\n\t\t\t\t\tover[i] |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfill_n(visited, 1 << n, false);\n\t\tans = 0;\n\t\tdfs((1 << n) - 1);\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse if (dis < eps) {\n\t\tconst ld ar = min(l.r, r.r);\n\t\treturn ar*ar*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\nvector<Circle>cs;\nvector<int>colors;\nint memo[1 << 24];\nint getans(const vector<vector<int>>&edges, vector<int>&nums,bitset<24>&used) {\n\tif (memo[used.to_ulong()] != -1)return memo[used.to_ulong()];\n\tvector<vector<int>>colorids(4);\n\tfor (int i = 0; i < used.size(); ++i) {\n\t\tif (!used[i]) {\n\t\t\tif (!nums[i]) {\n\t\t\t\tcolorids[colors[i]].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tfor (int a = 0; a < colorids[i].size(); ++a) {\n\t\t\tint aid = colorids[i][a];\n\t\t\tfor (int b = a + 1; b < colorids[i].size(); ++b) {\n\t\t\t\tconst int bid = colorids[i][b];\n\t\t\t\tused[aid] = true;\n\t\t\t\tused[bid] = true;\n\t\t\t\tfor (auto e : edges[aid]) {\n\t\t\t\t\tnums[e]--;\n\t\t\t\t}\n\t\t\t\tfor (auto e : edges[bid]) {\n\t\t\t\t\tnums[e]--;\n\t\t\t\t}\n\t\t\t\tans = max(ans,2 + getans(edges, nums, used));\n\t\t\t\tused[aid] = false;\n\t\t\t\tused[bid] = false;\n\t\t\t\tfor (auto e : edges[aid]) {\n\t\t\t\t\tnums[e]++;\n\t\t\t\t}\n\t\t\t\tfor (auto e : edges[bid]) {\n\t\t\t\t\tnums[e]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[used.to_ulong()]=ans;\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 1 << 24; ++i) {\n\t\t\tmemo[i] = -1;\n\t\t}\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tcs.clear();\n\t\tcolors.clear();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y, r, c; cin >> x >> y >> r >> c;\n\t\t\tc--;\n\t\t\tcs.emplace_back(Point(x, y), r);\n\t\t\tcolors.push_back(c);\n\t\t}\n\t\tvector<vector<int>>edges(N);\n\t\tvector<int>nums(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tif (two_circle_area(cs[i],cs[j])>eps) {\n\t\t\t\t\tedges[i].push_back(j);\n\t\t\t\t\tnums[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbitset<24>bs;\n\t\tint ans = getans(edges, nums,bs);\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 24;\nint n;\nint x[MAXN], y[MAXN], r[MAXN], c[MAXN], top[MAXN];\nbool dp[1<<MAXN];\n\nint main() {\n  while(cin >> n && n) {\n    for(int i = 0; i < n; ++i) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n    for(int i = 0; i < n; ++i) {\n      top[i] = 0;\n      for(int j = 0; j < i; ++j) {\n        if((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j])\n           < (r[i]+r[j])*(r[i]+r[j])) {\n          top[i] |= 1 << j;\n        }\n      }\n    }\n    memset(dp, 0, sizeof(dp));\n    dp[(1<<n)-1] = 1;\n    for(int b = (1<<n)-1; b >= 0; --b) {\n      if(!dp[b]) continue;\n      for(int i = 0; i < n; ++i) {\n        if(!(b>>i&1) || (b & top[i])) continue;\n        for(int j = i+1; j < n; ++j) {\n          if(!(b>>j&1) || (b & top[j]) || c[i] != c[j]) continue;\n          dp[b - (1<<i) - (1<<j)] = 1;\n        }\n      }\n    }\n    int res = n;\n    for(int b = 0; b < (1<<n); ++b) {\n      if(dp[b]) res = min(res, __builtin_popcount(b));\n    }\n    cout << n - res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\nint n;\nvector<char> dp;\nvector<int> up;\nvector<Circle> c(24);\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    return (a.r + b.r) * (a.r + b.r) > (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\nint Rec(int s)\n{\n    if (~dp[s])\n        return dp[s];\n\n    int res = 0;\n    // 取り除く2つの円の選択\n    for (int i = 0; i < n; ++i) {\n        // c[i]がないか取り除けない\n        if (!(s >> i & 1) || s & up[i])\n            continue;\n\n        for (int j = i + 1; j < n; ++j) {\n            // c[i]とc[j]の色が異なる  c[j]がないか取り除けない\n            if (c[i].c != c[j].c || !(s >> j & 1) || s & up[j])\n                continue;\n\n            res = max(res, Rec(s & ~(1 << i) & ~(1 << j)) + 2);\n        }\n    }\n\n    return dp[s] = res;\n}\n\nint main()\n{\n    while (cin >> n, n) {\n        dp.assign(1 << n, -1);\n        up.assign(n, 0);\n\n        // 円の入力\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        // 円の重なり，上下関係\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                if (isOverlap(c[i], c[j]))\n                    up[j] |= (1 << i);\n\n        cout << Rec((1 << n) - 1) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n\nclass Disc{//~ÕÌîñð\\·NX\npublic:\n\tint x,y,r,c;\n\tDisc(int x,int y,int r,int c): x(x),y(y),r(r),c(c){}\n\tDisc(){};\n};\n\nint n;//~ÕÌ\nchar memo[1<<24];//Dp\nbool exist[24];//~ÕªcÁÄé©Ç¤©\nDisc D[24];//~Õðüêézñ\n\nbool touch(Disc a,Disc b){//2Ì~ÕªdÈÁÄ¢é©@ñæÉ·êÎë·ðCÉµÈ­Äàæ¢\n\treturn (a.r+b.r)*(a.r+b.r)>(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n}\n\nbool top(int k){//kÔÚÌ~ÕÌãÉ¼Ì~ÕªæÁÄ¢È¢©\n\tfor(int i=k-1;i>=0;i--){\n\t\tif(exist[i]){\n\t\t\tif(touch(D[k],D[i])){return false;}\n\t\t}\n\t}\n\treturn true;\n}\n\nint dfs(int bit,int num){//»µÄ[³Dæ\n\tif(memo[bit]>=0) return memo[bit];\n\tint res=num;\n\n\tfor(int i=0;i<n;i++){\n\t\tif(exist[i] && top(i)){\n\t\t\tfor(int j=i+1;j<n;j++){//j=0 Éµ½çTLEµ½\n\t\t\t\t//jÔÚÌ~Õª¶ÝµÄCãÉ¼Ì~ÕªæÁÄÈ­ÄCiÔÚÌ~ÕÆFªê\n\t\t\t\tif(exist[j] && top(j) && i!=j && D[i].c==D[j].c){\n\t\t\t\t\texist[i]=false;//æè­\n\t\t\t\t\texist[j]=false;\n\t\t\t\t\tres=dfs((bit&(~(1<<i)))&(~(1<<j)),num+2);\n\t\t\t\t\texist[i]=true;//ß·\n\t\t\t\t\texist[j]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemo[bit]=res;//é\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin>>n && n!=0){\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tmemset(exist,true,sizeof(exist));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y,r,c;\n\t\t\tcin>>x>>y>>r>>c;\n\t\tD[i]=Disc(x,y,r,c);\n\t\t}\n\t\tcout<<dfs((1<<24)-1,0)<<endl;;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nconst int N = 6*4;\nint dp[1 << N];\nint cover[N];\nint x[N], y[N], r[N], c[N];\nint n;\n\nint rec(int bits){\n\tif (bits == 0) return 0;\n\n\tint &res = dp[bits];\n\tif (res >= 0) return res;\n\tres = 0;\n\tfor (int i = 0; i < n; ++i){\n\t\tif (~bits&(1 << i)) continue;\n\t\tif (bits&cover[i]) continue;\n\t\tfor (int j = i+1; j < n; ++j){\n\t\t\tif (~bits&(1 << j)) continue;\n\t\t\tif (bits&cover[j]) continue;\n\t\t\tif (c[i] != c[j]) continue;\n\t\t\tres = max(res, 2 + rec(bits&~(1 << i)&~(1 << j)));\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tauto sq = [](int x){return x*x; };\n\twhile (cin >> n, n){\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t\tcover[i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tfor (int j = 0; j < i; ++j){\n\t\t\t\tif (sq(x[i] - x[j]) + sq(y[i] - y[j]) >= sq(r[i] + r[j])) continue;\n\t\t\t\tcover[i] |= 1<<j;\n\t\t\t}\n\t\t}\n\n\t\tcout << rec((1 << n) - 1) << '\\n';\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\nint x[24], y[24], r[24], c[24];\n\nchar dp[(1 << 24) + 1];\n\nbool intersect(int i, int j)\n{\n    return (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) < (r[i] + r[j]) * (r[i] + r[j]);\n}\n\nbool is_select(int i, int s)\n{\n    for (int j = 0; j < i; ++j)\n        if (!(s & (1 << j)))\n            if (intersect(i, j))\n                return false;\n    return true;\n}\n\nint rec(int s)\n{\n    if (s == (1 << n) - 1)\n        return 0;\n\n    if (dp[s] != -1)\n        return dp[s];\n\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        if (s & (1 << i))\n            continue;\n        if (!is_select(i, s))\n            continue;\n\n        for (int j = i + 1; j < n; ++j) {\n            if (s & (1 << j))\n                continue;\n            if (!is_select(j, s))\n                continue;\n\n            if (c[i] != c[j])\n                continue;\n\n            ans = max(ans, rec(s | (1 << i) | (1 << j)) + 2);\n        }\n    }\n    return dp[s] = ans;\n}\n\nint main()\n{\n    for (;;) {\n        scanf(\"%d\", &n);\n        if (n == 0)\n            break;\n\n        for (int i = 0; i < n; ++i)\n            scanf(\"%d %d %d %d\", &x[i], &y[i], &r[i], &c[i]);\n\n        fill(dp, dp + (1 << 24) + 1, -1);\n        int ans = rec(0);\n        printf(\"%d\\n\", ans);\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct cir {\n\tint num;\n\tint x;\n\tint y;\n\tint r;\n\tint c;\n\tbool top;\n\tset<int> maue;\n\t/*bool operator==(const cir& right) {\n\t\treturn x == right.x && y == right.y && r == right.r && c == right.c && top == right.top && maue == right.maue;\n\t}\n\tbool operator<(const cir& right) {\n\t\treturn x != right.x ? x < right.x : y != right.y ? y < right.y : r != right.r ? r < right.r:true;\n\t}*/\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<cir> circle(n);\n\t\tREP(i, n) {\n\t\t\tcin >> circle[i].x >> circle[i].y >> circle[i].r >> circle[i].c;\n\t\t\tcircle[i].top = true;\n\t\t\tcircle[i].num = i;\n\t\t}\n\t\tREP(i, n / 2)\n\t\t\tswap(circle[i], circle[n - 1 - i]);\n\t\tREP(i, n) {\n\t\t\tREP(j, i) {\n\t\t\t\tif ((circle[i].x - circle[j].x)*(circle[i].x - circle[j].x) +\n\t\t\t\t\t(circle[i].y - circle[j].y)*(circle[i].y - circle[j].y) <\n\t\t\t\t\t(circle[i].r + circle[j].r)*(circle[i].r + circle[j].r)) {\n\t\t\t\t\tcircle[j].top = false;\n\t\t\t\t\tcircle[j].maue.insert(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tqueue<vector<cir>> qvc;\n\t\tset<int> G;\n\t\tint num = 0;\n\t\tREP(i, circle.size())\n\t\t\tif (circle[i].num == i)\n\t\t\t\tnum += (1 << i);\n\t\tG.insert(num);\n\t\tqvc.push(circle);\n\t\twhile (!qvc.empty())\n\t\t{\n\t\t\tvector<cir> Q = qvc.front();qvc.pop();\n\t\t\tans = max(ans, n - (int)Q.size());\n\t\t\tFOR(i, 1, 5) {\n\t\t\t\tREP(j, Q.size()) {\n\t\t\t\t\tif (Q[j].top&&Q[j].c == i)\n\t\t\t\t\t\tFOR(k, j + 1, Q.size()) {\n\t\t\t\t\t\tif (Q[k].top&&Q[k].c == i) {\n\t\t\t\t\t\t\tvector<cir> Q2 = Q;\n\t\t\t\t\t\t\tREP(l, Q2.size())\n\t\t\t\t\t\t\t\tif (!Q2[l].maue.empty())\n\t\t\t\t\t\t\t\t\tif (EXIST(Q2[l].maue, j)) {\n\t\t\t\t\t\t\t\t\t\tQ2[l].maue.erase(j);\n\t\t\t\t\t\t\t\t\t\tif (Q2[l].maue.empty())\n\t\t\t\t\t\t\t\t\t\t\tQ2[l].top = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tREP(l, Q2.size())\n\t\t\t\t\t\t\t\tif (!Q2[l].maue.empty())\n\t\t\t\t\t\t\t\t\tif (EXIST(Q2[l].maue, k)) {\n\t\t\t\t\t\t\t\t\t\tQ2[l].maue.erase(k);\n\t\t\t\t\t\t\t\t\t\tif (Q2[l].maue.empty())\n\t\t\t\t\t\t\t\t\t\t\tQ2[l].top = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tQ2.erase(Q2.begin() + k);\n\t\t\t\t\t\t\tQ2.erase(Q2.begin() + j);\n\t\t\t\t\t\t\tint num2 = 0;\n\t\t\t\t\t\t\tREP(i, Q2.size())\n\t\t\t\t\t\t\t\tif (Q2[i].num == i)\n\t\t\t\t\t\t\t\t\tnum2 += (1 << i);\n\t\t\t\t\t\t\tif (EXIST(G, num2)) {\n\t\t\t\t\t\t\t\tqvc.push(Q2);\n\t\t\t\t\t\t\t\tG.insert(num2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n        //!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //????????? == ??¨ != ????????´??????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //?????????????????????????????§??????????????????????????????????¨??????????????????????\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//?????£?????????????????¨?????????????§???¢?????´???????±???????\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//???????§???¢??????????????????????????¢??°??????????????????????????????????????\\????????????\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//????§???¢?????¢???\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//????§???¢?????¢???\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//???????§???¢?????????l??§??????????????????????§???¢?????°\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\ntemplate < class BidirectionalIterator >\nbool next_combination ( BidirectionalIterator first1 ,\n        BidirectionalIterator last1 ,\n        BidirectionalIterator first2 ,\n        BidirectionalIterator last2 ){\n    if (( first1 == last1 ) || ( first2 == last2 )) {\n        return false ;\n    }\n    BidirectionalIterator m1 = last1 ;\n    BidirectionalIterator m2 = last2 ; --m2;\n    while (--m1 != first1 && !(* m1 < *m2 )){\n    }\n    bool result = (m1 == first1 ) && !(* first1 < *m2 );\n    if (! result ) {\n        while ( first2 != m2 && !(* m1 < * first2 )) {\n            ++ first2 ;\n        }\n        first1 = m1;\n        std :: iter_swap (first1 , first2 );\n        ++ first1 ;\n        ++ first2 ;\n    }\n    if (( first1 != last1 ) && ( first2 != last2 )) {\n        m1 = last1 ; m2 = first2 ;\n        while (( m1 != first1 ) && (m2 != last2 )) {\n            std :: iter_swap (--m1 , m2 );\n            ++ m2;\n        }\n        std :: reverse (first1 , m1 );\n        std :: reverse (first1 , last1 );\n        std :: reverse (m2 , last2 );\n        std :: reverse (first2 , last2 );\n    }\n    return ! result ;\n}\n\ntemplate < class BidirectionalIterator > bool next_combination ( BidirectionalIterator first , BidirectionalIterator middle , BidirectionalIterator last )\n{\n    return next_combination (first , middle , middle , last );\n}\n\n//????´?v??????r??????????????????????????????\nvoid func(vector<int> v, int r){\n    do{\n    }while(next_combination(v.begin(), v.begin() + r, v.end()));\n}\n\nint n;\n\nbool isOver(Circle a, Circle b){\n    return abs(a.c - b.c) < a.r + b.r;\n}\n\nvoid canUse(Circle c[30], vector<bool> used, int color[30], vector<int> res[4]){\n    //show(\"canUse\")\n    rep(i,n){\n        if(used[i]) continue;\n        bool f = true;\n        range(j,0,i){\n            if(used[j]) continue;\n            if(isOver(c[i], c[j])){\n                f = false;\n                break;\n            }\n        }\n        if(f) res[color[i] - 1].emplace_back(i);\n    }\n}\n\nvoid requireCircleSet(vector<bool> used, vector<int> circles, vector<vector<int>> &cs){\n    //show(\"requireCircleset\")\n    if(circles.size() < 2) return;\n    //rep(i,circles.size()){ cout << circles[i] << endl; }\n    range(i,2,circles.size() + 1){\n        do{\n            vector<int> tmp;\n            rep(j,i){\n                //if(used[j]) continue;\n                //show(circles[j])\n                tmp.emplace_back(circles[j]);\n            }\n            cs.emplace_back(tmp);\n        }while(next_combination(circles.begin(), circles.begin() + i, circles.end()));\n    }\n}\n\nmap<vector<bool>,int> m;\n\nvoid dfs(Circle c[30], int color[30], vector<bool> used){\n    if(m.count(used) != 0) return;\n    int cnt = 0;\n    rep(i,n){ if(used[i]) cnt++; }\n    m[ used ] = max(m[used],cnt);\n\n\n    //show(\"dfs\");\n    vector<int> use[4];\n    canUse(c,used,color,use);\n    //rep(i,4){\n    //    if(use[i].empty()) continue;\n    //    show(use[i].size())\n    //}\n\n    rep(i,4){\n        if(use[i].empty()) continue;\n        vector<vector<int>> circle_set;\n        requireCircleSet(used, use[i], circle_set);\n        if(circle_set.empty()) continue;\n        for(int j = circle_set.size() - 1; j >= 0; j--){\n            vector<bool> tmp = used;\n            for(auto k:circle_set[j]){\n                assert(not tmp[k]);\n                tmp[k] = true;\n            }\n            dfs(c, color, tmp);\n        }\n    }\n}\n\nint main(){\n    while(scanf(\"%d\",&n),n){\n        Circle c[30];\n        int color[30];\n        m.clear();\n        rep(i,n){\n            double x,y,r;\n            scanf(\"%lf%lf%lf%d\",&x,&y,&r,&color[i]);\n            c[i] = {Point(x,y),r};\n        }\n        vector<bool> used(30,0);\n        dfs(c,color,used);\n\n        int maxi = 0;\n        for(auto it:m){\n            maxi = max(maxi, it.second);\n        }\n        cout << maxi << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n \nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n \nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\n\nmap<int,int> m;\n\nint n,d[30][30],abosum[30],ans;\nbool abo[30][30],exist[30];\n\nint check(bool tmp[30]){\n\tint ret = 0,bit = 1;\n\tfor(int i = 1;i <= n;i++){\n\t\tif(tmp[i] == true){\n\t\t\tret += bit;\n\t\t}\n\t\tbit *= 2;\n\t}\n\treturn ret;\n}\n\nvoid solve(int tmpans,bool texist[30],int tabosum[30]){\n\tans = max(ans,tmpans);\n\tint bit = check(texist);\n\tauto itr = m.find(bit);\n\tif(itr != m.end()) return;\n\tm[bit] = 1;\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = i+1;j <= n;j++){\n\t\t\tif(texist[i] == false || texist[j] == false)continue;\n\t\t\tif(tabosum[i] != 0 || tabosum[j] != 0) continue;\n\t\t\tif(d[i][3] != d[j][3]) continue;\n\t\t\ttexist[i] = false; texist[j] = false;\n\t\t\tbit = check(texist);\n\t\t\tauto itr = m.find(bit);\n\t\t\tif(itr != m.end()) continue;\n\t\t\ttexist[i] = true; texist[j] = true;\n\t\t\tbool tmpexist[30];\n\t\t\tfor(int k = 1;k <= n;k++){\n\t\t\t\ttmpexist[k] = texist[k];\n\t\t\t\tif(k == i || k == j) tmpexist[k] = false;\n\t\t\t}\n\t\t\tint tmpabosum[30];\n\t\t\tfor(int k = 1;k <= n;k++){\n\t\t\t\ttmpabosum[k] = tabosum[k];\n\t\t\t\tif( abo[i][k] == true && i < k )tmpabosum[k]--;\n\t\t\t\tif( abo[j][k] == true && j < k )tmpabosum[k]--;\n\t\t\t}\n\t\t\tsolve(tmpans+2,tmpexist,tmpabosum);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0)break;\n\t\tans = 0;\n\t\tm.clear();\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tabo[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\texist[i] = true;\n\t\t\tabosum[i] = 0;\n\t\t\tfor(int j = 0;j < 4;j++){\n\t\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\t\t//cin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = i+1;j <= n;j++){\n\t\t\t\tif(  (d[i][0]-d[j][0])*(d[i][0]-d[j][0]) + (d[i][1]-d[j][1])*(d[i][1]-d[j][1]) < (d[i][2]+d[j][2])*(d[i][2]+d[j][2])    ){\n\t\t\t\t\tabo[i][j] = true; abo[j][i] = true;\n\t\t\t\t\tabosum[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve(0,exist,abosum);\n\t//\tfor(int i = 1;i <= n;i++) cout << \"abo\" << i << \" \" << abosum[i] << endl;\n/*\n\t\tbool flag = true;\n\t\twhile(flag == true){\n\t\t\tflag = false;\n\t\t\tfor(int i = 1;i <= n;i++){\n\t\t\t\tfor(int j = i+1;j <= n;j++){\n\t\t\t\t\tif(exist[i] == false || exist[j] == false)continue;\n\t\t\t\t\tif(abosum[i] != 0 || abosum[j] != 0) continue;\n\t\t\t\t\tif(d[i][3] != d[j][3]) continue;\n\t\t\t\t\tans += 2;\n\t\t\t\t\texist[i] = false; exist[j] = false;\n\t\t\t\t\tflag = true;\n\t\t\t\t\tfor(int k = i+1;k <= n;k++){\n\t\t\t\t\t\tif(abo[i][k] == true){\n\t\t\t\t\t\t\tabosum[k]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = j+1;k <= n;k++){\n\t\t\t\t\t\tif(abo[j][k] == true){\n\t\t\t\t\t\t\tabosum[k]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n;\nint x[111],y[111],r[111],c[111];\nbool used[111];\n\nbool judge(int i,int j){\n\tbool ok=true;\n\trep(k,i){\n\t\tif(used[k])continue;\n\t\tif(pow(x[i]-x[k],2)+pow(y[i]-y[k],2)<pow(r[i]+r[k],2))ok=false;\n\t}\n\trep(k,j){\n\t\tif(used[k])continue;\n\t\tif(pow(x[k]-x[j],2)+pow(y[k]-y[j],2)<pow(r[k]+r[j],2))ok=false;\n\t}\n\treturn ok;\n}\n\nint dfs(){\n\tint res=0;\n\trep(i,n)repl(j,i+1,n){\n\t\tif(!used[i]&&!used[j]&&c[i]==c[j]&&judge(i,j)){\n\t\t\tused[i]=used[j]=true;\n\t\t\tmaxch(res,dfs()+2);\n\t\t\tused[i]=used[j]=false;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\t//cin.sync_with_stdio(false);\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\trep(i,n)scanf(\"%d%d%d%d\",x+i,y+i,r+i,c+i);\n\t\tmemset(used,0,sizeof(used));\n\t\tcout<<dfs()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n;\nint xs[100];\nint ys[100];\nint rs[100];\nint cs[100];\n\nint square(int x) { return x * x; }\nbool In(int i, int j) {\n  double d2 = square(xs[i] - xs[j]) + square(ys[i] - ys[j]);\n  double r2 = square(rs[i] + rs[j]);\n  if (d2 < r2) { return true; }\n  return false;\n}\n\nchar memo[1 << 24];\nint calc(int used) {\n  if (memo[used] != -1) { return memo[used]; }\n  int ret = __builtin_popcount(used);\n  REP(i, n) {\n    if ((used >> i) & 1) { continue; }\n    REP(k, i) {\n      if ((used >> k) & 1) { continue; }\n      if (In(k, i)) { goto next; }\n    }\n    REP(j, i) {\n      if ((used >> j) & 1) { continue; }\n      if (cs[i] != cs[j]) { continue; }\n      REP(k, j) {\n        if ((used >> k) & 1) { continue; }\n        if (In(k, j)) { goto next; }\n      }\n      ret = max(ret, calc(used | (1 << i) | (1 << j)));\n    }\nnext:;\n  }\n  return memo[used] = ret;\n}\n\nint main() {\n  while (scanf(\"%d\", &n), n) {\n    MEMSET(memo, -1);\n    REP(i, n) {\n      scanf(\"%d %d %d %d\", &xs[i], &ys[i], &rs[i], &cs[i]);\n    }\n    cout << calc(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<stdio.h>\n#include<string.h>\n\nusing namespace std;\n\nint n;\nint x[25], y[25], r[25], c[25];\nint over[25];\t\t\t// i?????????????????????????????£??????????????????bit??§??¨???\nchar dp[1<<24];\t\t\t// i(bit???????????¨???)??¨????????¶????????§????????????????????????????????§???\n// ?¶???????????????????bit????????????\n\nbool overlap(int i, int j)\n{\n  return pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2) < pow(r[i] + r[j], 2);\n}\n\n\nint main(void)\n{\n  while(cin >> n, n)\n    {\n      memset(over, 0, sizeof(over));\n      for(int i = 0; i < n; i++)\n\t{\n\t  cin >> x[i] >> y[i] >> r[i] >> c[i];\n\t  for(int j = 0; j < i; j++)\n\t    {\n\t      if(overlap(i, j))\n\t\tover[i] |= (1 << j);\n\t    }\n\t}\n      memset(dp, -1, sizeof(dp));\n      dp[0] = 0;\t\t// ????????????????????????????????¶?????§???0\n      int ans = 0;\n      for(int i = 0; i < (1<<n); i++) // 0~(1<<n)??§??¨??¶??????????????????(n == 4??????16??¶??????4??????????????????????????????????????????or??????????????????????????????2?????????????????¶???????????¨??????)\n\t{\n\t  if(dp[i] == -1)\t// ??¶???i?????°????????????\n\t    continue;\n\t  ans = max(ans, (int)dp[i]);\n\t  for(int j = 0; j < n; j++)\n\t    {\t\t\t// ?????§?????????j????¶????????????? or ??????j???????????????????????¨????????????\n\t      if((i & (1<<j)) != 0 || ((~i) & over[j]) != 0)\n\t\tcontinue;\n\t      for(int k = j + 1; k < n; k++)\n\t\t{\t\t// ??????j??¨??????k??????????????? or ?????§?????????k????¶????????????? or ??????k???????????????????????¨????????????\n\t\t  if(c[j] != c[k] || (i & (1<<k)) != 0 || ((~i) & over[k]) != 0)\n\t\t    continue;\n\t\t  int next = i | (1<<j) | (1<<k); // next = ??????j??¨k????????????????????¶???\n\t\t  dp[next] = max((int)dp[next], dp[i] + 2);\n\t\t}\n\t    }\n\t}\n      printf(\"%d\\n\", ans);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\nconst int MAX_N = 24;\n\nclass Circle {\npublic:\n\tint x, y, r, c; // 中心のxy座標、半径、色番号\n};\n\n/* 入力 */\nint n; // 円盤の枚数\nCircle cir[MAX_N]; // 円の情報\n\n/*\nS:すでに取り除いた円の集合(bitで表す、右から円番号0,1,2,...,MAX_N)\ndp[S]:ここから取り除ける最大枚数\n漸化式\ndp[全部取り除いた] = n\ndp[S] = max(dp[S U 取り除いた2つの円]+2)\n*/\nint dp[1 << MAX_N];\n\n/* 2点間の距離 */\ndouble dis(int x1, int y1, int x2, int y2) {\n\treturn sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));\n}\n\n/* 円kが上に1枚でも重なっているかどうか、重なっていたらtrue */\nbool ispiled(int k, int S) {\n\tfor (int i = k - 1; i >= 0; i--) {\n\t\tif (dis(cir[i].x, cir[i].y, cir[k].x, cir[k].y) < cir[i].r + cir[k].r && !(S >> i & 1)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n/*\nbool ispiled(Circle c1, Circle c2) {\n\tif (dis(c1.x, c1.y, c2.x, c2.y) < c1.r + c2.r) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n*/\n\n/* S:すでに取り除いた円盤の集合 */\nint remove(int S) {\n\t//cout << \"S = \" << S << \" dp[\" << S << \"]: \" << dp[S] << endl;\n\tif (dp[S] >= 0) {\n\t\treturn dp[S];\n\t}\n\t\n        /* 全部取り除いた */\n\tif (S == ((1 << n) - 1)) {\n\t\treturn dp[S] = n;\n\t}\n\n\tint res = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t/* どちらかがすでに取り除かれているか、2つの色が違うか、2枚のうち1枚以上が下にあれば取り除けないので次の組へ */\n\t\t\tif (S >> i & 1 || S >> j & 1 || cir[i].c != cir[j].c || ispiled(i, S) || ispiled(j, S)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (true) {\n\t\t\t\tint tmp = S | 1 << i;\n\t\t\t\ttmp = tmp | 1 << j;\n\t\t\t\tres = max(res, remove(tmp) + 2);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[S] = res;\n}\n\nint main() {\n\t// 方針: bitDP\n\t//const int MAX_N = 24;\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> cir[i].x >>cir[i].y >> cir[i].r >> cir[i].c;\n\t\t}\n\t\tmemset(dp, -1, sizeof(dp));\n\t\t//cout << \"test\" << endl;\n\t\tcout << remove(0) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint sq(int x) { return x * x; }\n\nstruct Circle {\n\tint x, y, r, c;\n\tint tops;\n\tCircle (int _x, int _y, int _r, int _c) : x(_x), y(_y), r(_r), c(_c) {}\n};\n\nbool CC(const Circle& c1, const Circle& c2) {\n\tif (sq(c1.x - c2.x) + sq(c1.y - c2.y) < sq(c1.r + c2.r)) return true;\n\treturn false;\n}\n\nint n;\nvector<Circle> cs;\n\nint memo[1 << 24];\n\nint rec(int cur) {\n\tif (memo[cur] >= 0) return memo[cur];\n\t\n\t// 今取り除ける円盤を見つける\n\tvector<int> cand;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (cur >> i & 1) continue;\t// すでにとりのぞかれている\n\t\t\n\t\tint tops = cs[i].tops;\n\t\tint rmbit = ~cur;\t// bit反転をとる\n\t\tif ( (tops & rmbit) == 0) {\n\t\t\t// i番目の円盤は現在のこっている円盤によらずに取り除ける\n\t\t\tcand.push_back(i);\n\t\t}\n\t}\n\t\n\tint ret = __builtin_popcount(cur);\t// 返す値を用意する\n\t\n\t// 取り除ける円盤を取り除く\n\tint csize = (int)cand.size();\n\tfor (int i = 0; i < csize; i++) {\n\t\tint ci = cand[i];\n\t\tfor (int j = i + 1; j < csize; j++) {\n\t\t\tint cj = cand[j];\n\t\t\t\n\t\t\t// 同じ色なら取り除ける\n\t\t\tif (cs[ci].c == cs[cj].c) {\n\t\t\t\t// ci と cj を取り除いた場合について再帰\n\t\t\t\tint nxt = cur | (1 << ci);\n\t\t\t\tnxt |= 1 << cj;\n\t\t\t\tret = max(ret, rec(nxt));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn memo[cur] = ret;\t// メモしながら返す\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> n; if (n == 0) break;\n\t\t\n\t\tcs.clear();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x, y, r, c; cin >> x >> y >> r >> c;\n\t\t\tcs.push_back(Circle(x, y, r, c));\n\t\t}\n\t\t\n\t\t// 各円盤に対して、どの円盤が取り除かていればその円盤をとりだせるかを入れる\n\t\t// 取り除かなければならない円盤にbitをたてる\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tint tops = 0;\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (CC(cs[i], cs[j])) {\n\t\t\t\t\ttops |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcs[i].tops = tops;\n\t\t}\n\t\t\n\t\t// すべての円盤が残っている状態から開始\t\t\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tcout << rec(0) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, int>\n\nclass C{\n    public:\n        int x, y, r, c;\n};\n\nvector<C> discs;\n\nint calDis(int x1, int y1, int x2, int y2){\n    int a = x1 - x2, b = y1 - y2;\n    return sqrt( a * a + b * b );\n}\n\nint dfs(vector< set<int> > &v, vector<bool> used, int cnt){\n    int ret = cnt;\n    REP(i, v.size()){\n        FOR(j, i + 1, v.size()){\n            if(i == j) continue;\n            if(!used[i] && !used[j] && discs[i].c == discs[j].c && v[i].empty() && v[j].empty()){\n                used[i] = true;\n                used[j] = true;\n                vector< set<int> > tmp = v;\n                REP(k, tmp.size()){\n                    set<int>::iterator it = tmp[k].find(i);\n                    if(it != tmp[k].end()) tmp[k].erase(it);\n                    it = tmp[k].find(j);\n                    if(it != tmp[k].end()) tmp[k].erase(it);\n                }\n                ret = max(ret, dfs(tmp, used, cnt + 2));\n                used[i] = false;\n                used[j] = false;\n            }\n        }\n    }\n    return ret;\n}\n\nint main(){\n    int n;\n    while(cin >>n && n){\n        discs = vector<C>(n);\n        vector< set<int> > v(n, set<int>());\n        REP(i, n) cin >>discs[i].x >>discs[i].y >>discs[i].r >>discs[i].c;\n\n        for(int now = 0; now < n; now++){\n            for(int i = now + 1; i < n; i++){\n                if(discs[now].r + discs[i].r > calDis(discs[now].x, discs[now].y, discs[i].x, discs[i].y)){\n                    v[i].insert(now);\n                    //TODO: 下の行がうまく動かないよー\n                    for(set<int>::iterator it = v[now].begin(); it != v[now].end(); it++) v[i].insert((*it));\n                }\n            }\n        }\n        //debug\n        //REP(i, n){\n        //    cout <<i <<\": \";\n        //    for(set<int>::iterator it = v[i].begin(); it != v[i].end(); it++) cout <<(*it) <<\", \";\n        //    cout <<endl;\n        //}\n        //cout <<endl;\n        cout <<dfs(v, vector<bool>(n, false), 0) <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> x, y, r, c;\n\nbool overlap(int a, int b) {\n  int hypot2 = (x[a] - x[b]) * (x[a] - x[b]) + (y[a] - y[b]) * (y[a] - y[b]);\n  int d2 = (r[a] + r[b]) * (r[a] + r[b]);\n  return (hypot2 < d2);\n}\n\nint main() {\n  int n;\n  while (cin >> n, n) {\n    x = vector<int>(n);\n    y = vector<int>(n);\n    r = vector<int>(n);\n    c = vector<int>(n);\n    for (int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n    int ans = 0;\n    vector<int> dp(1 << n, 0);\n    queue<int> q;\n    q.push(0);\n    while (!q.empty()) {\n      int b = q.front(); q.pop();\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n          if (i >= j || b >> i & 1 || b >> j & 1) continue;\n          if (c[i] != c[j]) continue;\n          bool ok = true;\n          for (int k = 0; k < i; k++) {\n            if (b >> k & 1) continue;\n            if (overlap(k, i)) ok = false;\n          }\n          for (int k = 0; k < j; k++) {\n            if (b >> k & 1) continue;\n            if (overlap(k, j)) ok = false;\n          }\n          int nb = b | (1 << i) | (1 << j);\n          if (ok && dp[nb] < dp[b] + 2) {\n            dp[nb] = dp[b] + 2;\n            ans = max(ans, dp[nb]);\n            q.push(nb);\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\nconstexpr int MAX_N = 1 << 24;\nint b[25];\n\nbool intersects(vector<int> &x, vector<int> &y, vector<int> &r, int i, int j) {\n    int dx = (x[i] - x[j]) * (x[i] - x[j]);\n    int dy = (y[i] - y[j]) * (y[i] - y[j]);\n    int dist1 = dx + dy;\n    int dist2 = (r[i] + r[j]) * (r[i] + r[j]);\n    return dist1 < dist2;\n}\n\nint main() {\n\n    while (true) {\n\n        int N;\n        cin >> N;\n\n        if (N == 0) break;\n\n        vector<int> x(N), y(N), r(N), c(N);\n        for (int i = 0; i < N; i++) cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n        //上からi枚目\n        for (int i = 0; i < N; i++) {\n            b[i] = 0;\n            //i枚目よりあとに降ってきたものを見る\n            for (int j = 0; j < i; j++) {\n                if (intersects(x, y, r, i, j)) b[i] |= (1 << j);\n            }\n        }\n\n        vector<int> dp(1 << N, -1);\n        int ans = 0;\n        int to = (1 << N);\n        dp[0] = 0;\n\n        //すべての円の使い方の状態を見る\n        for (int i = 0; i < to; i++) {\n            //このような円の状態はありえない\n            if (dp[i] == -1) continue;\n\n            //消せる円盤のペア(j, k)を探す\n            for (int j = 0; j < N - 1; j++) {\n                if ((i & (1 << j)) != 0 || (i & b[j]) != b[j]) continue;\n\n                //jより下にあるkをさがす\n                for (int k = j + 1; k < N; k++) {\n                    if (c[j] != c[k] || (i & (1 << k)) != 0 || (i & b[k]) != b[k]) continue;\n\n                    int next = i | (1 << j) | (1 << k);\n                    dp[next] = max(dp[next], dp[i] + 2);\n\n                }\n            }\n        }\n\n        for (int i = 0; i < (1 << N); i++) ans = max(ans, (int) dp[i]);\n        cout << ans * 2 << endl;\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define mp make_pair\n#define pb push_back\n#define EB emplace_back\n#define fi first\n#define se second\n#define all(v) ALL(v)\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\nconstexpr double eps = 1e-14; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint N;\nbool dp[1<<24];\n\nvoid solve(){\n    vector<int> x(N),y(N),r(N),c(N);\n    rep(i,N){\n        cin>>x[i]>>y[i]>>r[i]>>c[i];\n        c[i]--;\n    }\n\n    bool on[24][24]={};\n    rep(i,N){\n        for(int j=0;j<i;j++){\n            // i?????????j?????????????\n            double d = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n            if(d >= r[i]+r[j]) on[i][j]=false;\n            else on[i][j]=true;\n        }\n    }\n\n\n\n    rep(i,1<<24) dp[i]=false;\n    dp[0]=true;\n    rep(mask,(1<<N)){\n        if(!dp[mask]) continue;\n        //cout << \"mask : \" << static_cast<bitset<4>>(mask) << endl;\n\n        for(int i=0;i<N;i++) for(int j=i+1;j<N;j++){\n            if(c[i]!=c[j]) continue;\n            if(((mask>>i)&1) or ((mask>>j)&1)) continue;\n            bool oki = [=](){\n                for(int k=0;k<i;k++){\n                    if(on[i][k] && ((mask>>k)&1)==0) return false;\n                }\n                return true;\n            }();\n\n            bool okj = [=](){\n                for(int k=0;k<j;k++){\n                    if(on[j][k] && ((mask>>k)&1)==0) return false;\n                }\n                return true;\n            }();\n            if(!oki or !okj) continue;\n            int nxt = mask | (1<<i) | (1<<j);\n            dp[nxt] = true;\n            //cout << \"\\tnext : \" << static_cast<bitset<4>>(nxt) << endl;\n        }\n    }\n\n    //rep(i,(1<<N)){\n    //    cout << static_cast<bitset<8>>(i) << \" : \" << dp[i] << endl;\n    //}\n\n    int ans = 0;\n    rep(i,(1<<N)){\n        if(dp[i])\n            ans = max(ans,__builtin_popcount(i));\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    while(cin>>N){\n        if(N==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-10\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1 << 28;\n\nint n;\nvector<double> x, y, r;\nvector<int> c;\nvector<int> dp;\n\nvector<vector<int> > create (set<int> era) {\n    vector<vector<int> > par(n);\n    for (int i = 0; i < n; i++) {\n        if (era.find(i) != era.end()) {\n            par[i].push_back(INF);\n            continue;\n        }\n        for (int j = 0; j < i; j++) {\n            double dis = pow(x[j] - x[i], 2.0) +  pow(y[j] - y[i], 2.0);\n            if (sqrt(dis) < r[i] + r[j] && era.find(j) == era.end()) {\n                par[i].push_back(j);\n            }\n        }\n    }\n\n    return par;\n}\n\nint dfs (vector<vector<int> > par, set<int> era) {\n    int check = 0;\n    for (auto i : era) {\n        check |= 1 << i;\n    }\n    if (dp[check] != INF) return dp[check];\n\n    vector<vector<int> > count(5);\n    for (int i = 0; i < n; i++) {\n        bool flag = true;\n        for (int j = 0; j < par[i].size(); j++) {\n            if (era.find(par[i][j]) == era.end()) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            count[c[i]].push_back(i);\n        }\n    }\n\n    int ret = 0;\n    for (int i = 1; i < count.size(); i++) {\n        if (count[i].size() >= 2) {\n            for (int sx = 0; sx < count[i].size(); sx++) {\n                for (int sy = sx + 1; sy < count[i].size(); sy++) {\n                    if (sx == sy) continue;\n                    set<int> t_era(era);\n                    t_era.insert(count[i][sx]);\n                    t_era.insert(count[i][sy]);\n                    vector<vector<int> > t_par(create(t_era));\n                    ret = max(ret, (dfs(t_par, t_era) + 2));\n                }\n            }\n        }\n    }\n\n    return dp[check] = ret;\n}\n\nint main () {\n    while (cin >> n, n) {\n        dp.resize(0);\n        dp.resize(1 << n, INF);\n\n        x.resize(n), y.resize(n), r.resize(n), c.resize(n);\n        for (int i = 0; i < n; i++) {\n            cin  >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n        vector<vector<int> > par(create(set<int>()));\n\n        cout << dfs(par, set<int>()) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint n;\nint x[30], y[30], r[30], c[30];\nint on[30];\ndouble dist(int x, int y){\n  return sqrt(x *x + y* y);\n}\nbool ison(int x, int y, int r, int x2, int y2, int r2){\n  double d = dist(x-x2, y- y2);\n  if(d < (double)r + r2) return true;\n  return false;\n}\nint memo[1<<24];\nint dfs(int S){\n  if(memo[S] != -1) return memo[S];\n  int res = __builtin_popcount(S);\n  REP(i, n)REP(j, n){\n    if(i != j && !(S & (1 << i)) && !(S & (1 << j)) && c[i] == c[j]){\n      if(!(on[i] & (~S)) && !(on[j] & (~S))){\n        res = max(res, dfs(S | (1<<i) | (1<<j)));\n      }\n    }\n  }\n  return memo[S] = res;\n}\n\nint main(){\n  while(cin>>n && n){\n    REP(i, n) cin>>x[i]>>y[i]>>r[i]>>c[i];\n    memset(on, 0, sizeof(on));\n    REP(up, n)FOR(low, up + 1, n){\n      if(ison(x[up], y[up], r[up], x[low], y[low], r[low])) on[low] |= (1<<up);\n    }\n    memset(memo, -1, sizeof(memo));\n    cout<<dfs(0)<<endl;\n  }\n      \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define EPS 1e-9\n\nclass circle {\npublic:\n  int c;\n  double x, y, r;\n  circle(double tx, double ty, double tr, int tc) {\n    x = tx;\n    y = ty;\n    r = tr;\n    c = tc;\n  }\n};\n\nvector <circle> tempCirc;\n\nbool collision(circle c1, circle c2) {\n  return c1.r+c2.r-hypot(c1.x-c2.x, c1.y-c2.y) >= EPS;\n}\n\nint memo[(2<<24)+1];\nint rec(int x) {\n  int n = tempCirc.size();\n  vector <int> field[n];\n\n  if (memo[x] != -1) return memo[x];\n  int ret = 0;\n  for (int i = n-1; i >= 0; i--) {\n    if (! ((x>>i)&1) ) continue;\n    for (int j = i-1; j >= 0; j--) {\n      if (! ((x>>j)&1) ) continue;\n      if (collision(tempCirc[i], tempCirc[j])) {\n\tfield[i].push_back(j);\n      }\n    }\n  }\n\n  vector <int> list;\n  for (int i = 0; i < n; i++) {\n    if (field[i].size() == 0) list.push_back(i);\n  }\n\n  for (int i = 0; i < list.size(); i++) {\n    for (int j = i+1; j < list.size(); j++) {\n      if (! (x&(1<<list[i])) ) continue;\n      if (! (x&(1<<list[j])) ) continue;\n      if (tempCirc[list[i]].c != tempCirc[list[j]].c) continue;\n      ret = max(ret, rec(x^(1<<list[i])^(1<<list[j]))+2 );\n    }\n  }\n\n\n  return memo[x] = ret;\n}\n\nint main() {\n  int n;\n  while(true) {\n    cin >> n;\n    if (n == 0) break;\n    vector <circle> circ;\n    for (int i = 0; i < n; i++) {\n      int c;\n      double x, y, r;\n      cin >> x >> y >> r >> c;\n      circ.push_back(circle(x, y, r, c));\n    }\n    tempCirc = circ;\n\n    memset(memo, -1, sizeof(memo));\n    std::cout << rec((1<<n)-1) << std::endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\n\n#define all(c) ((c).begin()), ((c).end())\n#define debug(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\n\nconst double EPS = 1e-10;\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\n\nstruct C{\n\tP p;\n\tint r;\n\tint c;\n};\n\n\nint main() {\n\tfor (int n; cin >> n, n != 0; ) {\n\t\tvector<C> cs;\n\t\trep (i, n) {\n\t\t\tC c; int x, y; cin >> x >> y >> c.r >> c.c;\n\t\t\tc.p = P(x, y);\n\t\t\tcs.pb(c);\n\t\t}\n\t\t\n\t\tmap<int, int> dp;\n\t\tfor (int mask = 0; mask < (1 << n); mask++) {\n\t\t\tint res = 0;\n\t\t\trep (i, n) if (mask & (1 << i)) REP (j, i + 1, n - 1) if (mask & (1 << j)) {\n\t\t\t\tif(cs[i].c != cs[j].c) continue;\n\t\t\t\tbool ok = true;\n\t\t\t\trep(k, i) if(mask & (1 << k)) if (cs[i].r + cs[k].r > abs(cs[i].p - cs[k].p)) ok = false;\n\t\t\t\trep(k, j) if(mask & (1 << k)) if (cs[j].r + cs[k].r > abs(cs[j].p - cs[k].p)) ok = false;\n\t\t\t\tif(!ok) continue;\n\t\t\t\tres = max(res, dp[mask ^ (1 << i) ^ (1 << j)] + 2);\n\t\t\t}\n\t\t\tdp[mask] = res;\n\t\t}\n\t\tcout << dp[(1 << n) - 1] << endl;;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\n\nconstexpr int MAX_N = 24;\nconstexpr int MAX_C = 4;\n\nint n;\nint x[MAX_N], y[MAX_N], r[MAX_N], c[MAX_N];\n\nint ans;\nint over[MAX_N];\nbool visited[1 << MAX_N];\narray<vector<int>, MAX_C> circles;\nint shift[MAX_N + 1];\n\ninline void init() {\n\tfor(int i = 0; i <= MAX_N; ++i) {\n\t\tshift[i] = 1 << i;\n\t}\n}\n\ninline int square(int value) {\n\treturn value * value;\n}\n\ninline bool intersect(int x1, int y1, int r1, int x2, int y2, int r2) {\n\treturn square(x1 - x2) + square(y1 - y2) < square(r1 + r2);\n}\n\nvoid dfs(int rest, int cnt = 0) {\n\tchmax(ans, cnt);\n\tvisited[rest] = true;\n\n\tfor(const auto &S : circles) {\n\t\tfor(int i = 1; i < S.size(); ++i) {\n\t\t\tif((rest & shift[S[i]]) == 0 || (over[S[i]] & rest)) continue;\n\n\t\t\tfor(int j = 0; j < i; ++j) {\n\t\t\t\tif((rest & shift[S[j]]) == 0 || (over[S[j]] & rest)) continue;\n\t\t\t\tconst int next_rest = rest ^ (shift[S[i]] | shift[S[j]]);\n\t\t\t\tif(!visited[next_rest]) dfs(next_rest, cnt + 2);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tinit();\n\n\twhile(cin >> n && n) {\n\t\tfill_n(over, n, 0);\n\t\tfor(auto &S : circles) {\n\t\t\tS.clear();\n\t\t}\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t\t--c[i];\n\n\t\t\tcircles[c[i]].emplace_back(i);\n\n\t\t\tfor(int j = 0; j < i; ++j) {\n\t\t\t\tif(intersect(x[i], y[i], r[i], x[j], y[j], r[j])) {\n\t\t\t\t\tover[i] |= shift[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfill_n(visited, 1 << n, false);\n\t\tans = 0;\n\t\tdfs(shift[n] - 1);\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n\nconst int MAXN = 30;\nint x[MAXN], y[MAXN], r[MAXN], c[MAXN];\nbool ok[MAXN];\nmap<int, int> dp;\n\nint square(int x) {return x*x;}\n\nbool check(int i, int j) {\n    int d2 = square(x[i]-x[j]) + square(y[i]-y[j]);\n    return d2 < square(r[i]+r[j]);\n}\n\nint dfs(int state, int n) {\n    int ret = 0;\n    if (dp.find(state) != dp.end()) return dp[state];\n    vector<int> already;\n    memset(ok, true, sizeof(ok));\n    for (int i = 0; i < n; i++) {\n        if ((state>>i)&1) continue;\n        if (ok[i]) {\n            already.push_back(i);\n        }\n        for (int j = i+1; j < n; j++) {\n            if (check(i, j)) ok[j] = false;\n        }\n    }\n    int sz = already.size();\n    for (int i = 0; i < sz; i++) {\n        for (int j = i+1; j < sz; j++) {\n            int ai = already[i], aj = already[j];\n            if (c[ai] == c[aj]) {\n                int nstate = state;\n                nstate |= 1<<ai;\n                nstate |= 1<<aj;\n                ret = max(2+dfs(nstate, n), ret);\n            }\n        }\n    }\n    return dp[state] = ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while(scanf(\"%d\", &n) && n){\n      for (int i = 0; i < n; i++) scanf(\"%d %d %d %d\", &x[i],&y[i],&r[i],&c[i]);\n      dp.clear();\n      cout << dfs(0, n) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define MAX_COLORS 6\n#define MAX_CIRCLES 4\n#define MAX_N (MAX_COLORS*MAX_CIRCLES)\n#define MAX_STATES (1<<MAX_N)\n\nint biggest, n;\n\nstruct circle{\n    int x, y, r, c;\n};\n\ncircle C[MAX_N];\nchar dp[MAX_STATES];\n\nbool isOver( circle c1, circle c2 ){\n    int dx, dy;\n    dx = (c1.x - c2.x) * (c1.x - c2.x);\n    dy = (c1.y - c2.y) * (c1.y - c2.y);\n    return dx + dy < (c1.r + c2.r)*(c1.r + c2.r) ? true : false;\n}\n\nbool isDeleted( int state, int num ){\n    return (state & (1<<num)) == 0 ? false : true;\n}\n/*\nvoid pbit(int num){\n    //cout << \"bit: \";\n    do{\n        printf(\"%d\", num&1);\n        num = num>>1;\n    }while(num);\n    //printf(\"\\n\");\n}*/\n\nbool isTop( int state, int num ){\n    //pbit(state);\n    for( int i = num-1; i >= 0; i-- ){\n        if( isDeleted(state, i) ) continue;\n        if( isOver(C[num], C[i]) ) return false;\n    }\n    //cout << num << \" is top\" << endl;\n    return true;\n}\n\nvoid search(int s){\n    //for( int s = 0; s < 1<<n; s++ ){\n        /*cout << \"s: \";\n        pbit(s);\n        cout << endl;\n        */\n        for( int i = 0; i < n; i++ ){\n            if( isDeleted(s, i) ) continue;\n            //cout << \"i: \" << i << endl;\n            for( int j = i+1; j < n; j++ ){\n                if( isDeleted(s, j) ) continue;\n                //cout << \"i: \" << i << endl;\n                //cout << \"j: \" << j << endl;\n                if( isTop(s, i) && isTop(s, j) && C[i].c == C[j].c ){\n                    int next = s | 1<<i | 1<<j;\n                    //pbit(s);\n                    //cout << \",\" << i << \",\" << j << endl;\n                    if( dp[next] < dp[s]+2 ) dp[next] = dp[s]+2;\n                    if( biggest < dp[next] ) biggest = dp[next];\n                    if( next < n-1 ) search(next);\n                }\n            }\n        }\n    //}\n}\n\nvoid init(){\n    for( int s = 0; s < 1<<n; s++ ){\n        dp[s] = 0;\n    }\n}\n\nint main(){\n    while( cin >> n, n ){\n        for( int i = 0; i < n; i++ ){\n            circle a;\n            //scanf(\"%d%d%d%d\", a.x, a.y, a.r, a.c);\n            cin >> a.x >> a.y >> a.r >> a.c;\n            C[i] = a;\n        }\n        biggest = 0;\n        init();\n        //dp[0] = 0;\n        search(0);\n        printf(\"%d\\n\", biggest);\n        //cout << \"ans: \" << biggest << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 10000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n//typedef pair<ll, ll> P;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\nstruct Circle {\n  int x, y, r, c;\n  vector<int> from, to;\n  int rest;\n  Circle(int x, int y, int r, int c) : x(x), y(y), r(r), c(c), rest(0) {}\n  Circle() : rest(0) {}\n};\n\n#define N 30\n\nCircle cc[N];\n\nint n;\nint solve(int state, int res) {\n  if(!state) return res;\n  int rr = res;\n  rep(i, n) {\n    if(state & (1 << i) && cc[i].rest == 0) {\n      rep(j, i) {\n        if(state & (1 << j) && cc[j].rest == 0 && cc[j].c == cc[i].c) {\n          rep(k, cc[i].to.size()) cc[cc[i].to[k]].rest -= 1;\n          rep(k, cc[j].to.size()) cc[cc[j].to[k]].rest -= 1;\n          int r = solve(state ^ (1 << i) ^ (1 << j), res+2);\n          rr = maxd(rr, r);\n          rep(k, cc[i].to.size()) cc[cc[i].to[k]].rest += 1;\n          rep(k, cc[j].to.size()) cc[cc[j].to[k]].rest += 1;\n        }\n      }\n    }\n  }\n  return rr;\n}\n\nint main() {\n  while(cin >> n && n) {\n    rep(i, n) {\n      int x, y, r, c;\n      cin >> x >> y >> r >> c;\n      cc[i] = Circle(x, y, r, c);\n      rep(j, i) {\n        if(pow2(cc[i].x - cc[j].x) + pow2(cc[i].y - cc[j].y) < pow2(cc[i].r + cc[j].r)) {\n          cc[i].from.push_back(j);\n          cc[i].rest += 1;\n          cc[j].to.push_back(i);\n        }\n      }\n    }\n    cout << solve((1<<n)-1, 0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <bitset>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef complex<double> P;\n\nstruct C {\n  P p;\n  int r, c;\n};\nint n;\nvector<C> vc;\nsigned char memo[1<<24];\nint solve(int S) {\n  if (memo[S] != -1) return memo[S];\n//cout << bitset<24>(S) << endl;\n  int T = 0;\n  REP(i,n) {\n    if (S>>i&1) continue;\n    bool f = 1;\n    REP(j,i) {\n      if (S>>j&1) continue;\n      if (abs(vc[i].p-vc[j].p) < vc[i].r+vc[j].r) {\n        f = 0;\n        break;\n      }\n    }\n    if (f) T |= 1<<i;\n  }\n  int res = 0;\n  // FOR(it, hoge)\n  //   cout << *it << \" \";\n  // cout << endl;\n  REP(i,n) {\n    if (!(T>>i&1)) continue;\n    REP(j,i) {\n      if (!(T>>j&1)) continue;\n      if (vc[i].c==vc[j].c)\n        res = max(res, solve(S|(1<<i)|(1<<j)) + 2);\n    }\n  }\n  return memo[S] = res;\n}\n\nint main() {\n  while(cin>>n,n) {\n    vc.clear();\n    REP(i,n) {\n      int x,y,r,cc;\n      cin >> x>>y>>r>>cc;\n      vc.push_back((C){P(x,y),r,cc});\n    }\n    memset(memo,-1,sizeof(memo));\n    cout << solve(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstruct po {int x,y,r,g;};\nstruct popo{vector <po> c[5];};\nint ans =0;\n\nbool check(po a,popo c){\n  if(a.g==10000)return false;\n  for(int i=0;i<4;i++)\n    for(int j=0;j<c.c[i].size();j++){\n      po b = c.c[i][j];\n      if(a.g>b.g && (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y) < (a.r+b.r)*(a.r+b.r)) return false;\n    }\n  return true;\n}\n\nint cnt;\nvoid saiki(popo c,int sum,int i){\n  cnt++;\n  if(cnt>1000000/2)return;\n  vector <int> J;\n  for(int j=0;j<(int)c.c[i].size();j++)if(check(c.c[i][j],c)==true)J.push_back(j);\n  for(int j=0;j<J.size();j++)\n    for(int k=j+1;k<J.size();k++){\n      int a,b;\n      a=c.c[i][J[j]].g;\n      b=c.c[i][J[k]].g;\n      c.c[i][J[j]].g = c.c[i][J[k]].g = 10000;\n      for(int l=0;l<4;l++)saiki(c,sum+2,l);\n      c.c[i][J[j]].g=a;\n      c.c[i][J[k]].g=b;\n    }\n  ans = max(ans,sum);\n}\n\nint main(){\n  while(1){\n    int n;\n    cin>>n;\n    if(n==0)break;\n    popo c;\n    int x,y,r,col;\n    for(int i=0;i<n;i++)cin >>x>>y>>r>>col, c.c[--col].push_back((po){x,y,r,i});\n    ans = 0;\n    cnt=0;\n    for(int i=0;i<4;i++)cnt=0,saiki(c,0,i);\n    cout << ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n\nint dp[1<<24];\nint n;\nint x[24],y[24],r[24],c[24];\n\nint square(int a){\n\treturn a*a;\n}\nbool overlap(int i,int j){\n\treturn square(x[i]-x[j])+square(y[i]-y[j]) < square(r[i]+r[j]);\n}\nbool top(int s,int k){\n\tfor(int i=0;i<k;i++){\n\t\tif(s&1<<i){\n\t\t\tif(overlap(k,i))return false;\n\t\t}\n\t}\n\treturn true;\n}\nint dfs(int s){\n\tif(dp[s]!=-1)return dp[s];\n\tint res=0;\n\tfor(int i=0;i<n;i++){\n\t\tif((s&1<<i)==0 || !top(s,i))continue;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif((s&1<<j)==0 || !top(s,j))continue;\n\t\t\tif(c[i]==c[j])res = max(res,dfs(s&~(1<<i)&~(1<<j))+2);\n\t\t}\n\t}\n\treturn dp[s]=res;\n}\nint main(){\n\twhile(cin>>n&&n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\t}\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tcout<<dfs((1<<n)-1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int N = 25;\n\nint n;\nint ol[N];\nint x[N], y[N], r[N], c[N];\nbool vis[1<<N];\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n    for(int i=0;i<n;i++){\n      ol[i] = 0;\n      for(int j=0;j<i;j++){\n        if((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) < (r[i] + r[j]) * (r[i] + r[j])){\n          ol[i] |= (1<<j);\n        }\n      }\n    }\n    fill(vis, vis+(1<<n), false);\n    queue<int> q;\n    int u = (1<<n) - 1;\n    q.push(u);\n    vis[u] = true;\n    int ans = -2;\n    while(!q.empty()){\n      ans += 2;\n      for(int k=0;k<q.size();k++){\n        u = q.front();q.pop();\n        for(int i=0;i<n;i++){\n          if(u>>i & 1 == 0) continue;\n          for(int j=i+1;j<n;j++){\n            if((u>>j & 1) == 0) continue;\n            if(c[i] != c[j]) continue;\n            int f1 = ((ol[i]&u)>>i)<<i;\n            int f2 = ((ol[j]&u)>>j)<<j;\n            if(f1 < (ol[i]&u) || f2 < (ol[j]&u)) continue;\n            int v = u;\n            v &= ~(1<<i);\n            v &= ~(1<<j);\n            if(vis[v]) continue;\n            vis[v] = true;\n            q.push(v);\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint sum=0,ds;\nint n;\nvoid rec(vector<circle> vs){\n  //cout << vs.size() << endl;\n  int i,j,k;\n  int f;\n  int on[30]={};\n  vector<int> cc[5];\n  vector<circle> next;\n  f=1;\n  int ff=0;\n  while(ff==0){\n    ff=1;\n    for(i=0;i<30;i++) on[i]=0;\n    for(i=0;i<5;i++) cc[i].clear();\n    for(i=0;i<vs.size();i++){\n      for(j=i+1;j<vs.size();j++){\n\tif(ch(vs[i],vs[j])==1) on[j]=1;\n      }\n    }\n    for(i=0;i<vs.size();i++){\n      if(on[i]==0) cc[vs[i].c].push_back(i);\n    }\n    for(i=1;i<5;i++){\n      if(cc[i].size()>0&&cc[i].size()%2==0){\n\tfor(j=cc[i].size()-1;j>=0;j--){\n\t  vs.erase(vs.begin()+cc[i][j]);\n\t  ff=0;\n\t  f=0;\n\t}\n      }\n    }\n  }\n  for(i=1;i<5;i++){\n    //cout << cc[i].size() << endl;\n    if(cc[i].size()>=2&&cc[i].size()%2==1){\n      f=0;\n      next.clear();\n      for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n      for(j=0;j<cc[i].size();j++){\n\tfor(k=cc[i].size()-1;k>=0;k--){\n\t  if(k!=j)\n\t    next.erase(next.begin()+cc[i][k]);\n\t}\n\trec(next);\n      }\n      break;\n    }\n  }\n  int o=n-vs.size();\n  if(f==1) sum=max(sum,o);\n  else{\n    next.clear();\n    for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n    rec(next);\n  }\n}\n\nint main(){\n  cin >> n;\n  while(n!=0){\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    sum=0;\n    rec(v);\n    cout << sum << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\nint n;\nchar dp[1 << 24];\n//char up[24];\n//vector<char> dp, up;\n//vector<Circle> c;\nCircle c[24];\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = (a.r + b.r) * (a.r + b.r);\n    int d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    return r > d;\n}\n\nbool isUp(char s, int v)\n{\n    for (int i = 0; i < v; ++i)\n        if ((s >> i & 1) && isOverlap(c[v], c[i]))\n            return false;\n//            return true;\n//    return false;\n    return true;\n}\n\nint Rec(int s)\n{\n    if (~dp[s])\n        return dp[s];\n\n    int res = 0;\n    // 取り除く2つの円の選択\n    for (int i = 0; i < n; ++i) {\n        // c[i]がないか取り除けない\n        // if (!(s >> i & 1) || isUp(s, i))\n        //     continue;\n        // if (!(s >> i & 1) || s & up[i])\n        //     continue;\n\n        for (int j = i + 1; j < n; ++j) {\n            // c[i]とc[j]の色が異なる\n            // if (c[i].c != c[j].c)\n            //     continue;\n            // c[j]がないか取り除けない\n            // if (!(s >> j & 1) || s & up[j])\n            //     continue;\n            // if (!(s >> j & 1) || isUp(s, j))\n            //     continue;\n            if ((s >> i & 1) && isUp(s, i) && c[i].c == c[j].c\n                && (s >> j & 1) && isUp(s, j))\n//            int nxt = s & ~(1 << i) & ~(1 << j);\n            res = max(res, Rec(s & ~(1 << i) & ~(1 << j)) + 2);\n        }\n    }\n\n    return dp[s] = res;\n}\n\nint main()\n{\n    while (cin >> n, n) {\n        memset(dp, -1, sizeof(dp));\n//        memset(up, 0, sizeof(up));\n//        c.resize(n);\n\n        // 円の入力\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        // // 円の重なり，上下関係\n        // for (int i = 0; i < n; ++i)\n        //     for (int j = i + 1; j < n; ++j)\n        //         if (isOverlap(c[i], c[j]))\n        //             up[j] |= (1 << i);\n\n        cout << Rec((1 << n) - 1) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nbool visited[1<<24];\n\nclass Data{\npublic:\n\tint x;\n\tint y;\n\tint r;\n\tint c;\n\tData(int _x,int _y,int _r,int _c){\n\t\tx = _x;\n\t\ty = _y;\n\t\tr = _r;\n\t\tc = _c;\n\t}\n};\n\n\n\nbool check(const vector<Data>& d,int a,int b,int visited){\n\t//true then erase\n\tif(d[a].c != d[b].c) return false;\n\tfor(int i=0;i<a;i++){\n\t\tif(visited & (1<<i)) continue;\n\t\tif((d[a].x-d[i].x)*(d[a].x-d[i].x)+(d[a].y-d[i].y)*(d[a].y-d[i].y) < (d[a].r + d[i].r)*(d[a].r + d[i].r)) return false;\n\t}\n\tfor(int i=0;i<b;i++){\n\t\tif(visited & (1<<i)) continue;\n\t\tif((d[b].x-d[i].x)*(d[b].x-d[i].x)+(d[b].y-d[i].y)*(d[b].y-d[i].y) < (d[b].r + d[i].r)*(d[b].r + d[i].r)) return false;\n\t}\n\n\treturn true;\n}\n\nvoid dfs(const vector<Data>& nodes,int got){\n\tvisited[got] = true;\n\n\tfor(int i=0;i<nodes.size();i++){\n\t\tfor(int j=i+1;j<nodes.size();j++){\n\t\t\tif(got & (1<<i) || got & (1<<j)) continue;\n\t\t\tif(check(nodes,i,j,got)){\n\t\t\t\tint tmp = got;\n\t\t\t\ttmp |= (1<<i);\n\t\t\t\ttmp |= (1<<j);\n\n\t\t\t\tif(visited[tmp]) continue;\n\t\t\t\tdfs(nodes,tmp);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tint x,y,r,c;\n\t\tvector<Data> nodes; \n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&x,&y,&r,&c);\n\t\t\tnodes.push_back(Data(x,y,r,c));\n\t\t}\n\n\t\tdfs(nodes,0);\n\n\t\tint res = 0;\n\t\tfor(int S=(1<<n)-1;S>=0;S--){\n\t\t\tif(visited[S]){\n\t\t\t\tint tmp=0;\n\t\t\t\tfor(int i=0;i<n;i++) tmp += (bool)((1<<i) & S);\n\t\t\t\tres = max(tmp,res);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <math.h>\n \n#define REP(i,n)for (int i=0;i<(n);i++)\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nint x[30],y[30],r[30],c[30];\nbool used[30];\n\nbool over(int i,int j){\n\tif(used[i]||used[j])return false;\n\treturn (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])<(r[i]+r[j])*(r[i]+r[j]);\n}\n\nint dfs(){\n\tint res=0;\n\tREP(i,n){\n\t\tif(used[i])continue;\n\t\tbool f=false;\n\t\tREP(k,i)if(over(i,k))f=true;\n\t\tif(f)continue;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tf=false;\n\t\t\tREP(k,j)if(over(k,j))f=true;\n\t\t\tif(f)continue;\n\t\t\tif(used[j])continue;\n\t\t\tif(c[i]!=c[j])continue;\n\t\t\tused[i]=used[j]=true;\n\t\t\tres=max(res,dfs()+2);\n\t\t\tused[i]=used[j]=false;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tREP(i,n)cin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\tREP(i,n)used[i]=false;\n\t\tcout<<dfs()<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n;;\n  while(cin>>n,n){\nint dp[(1<<n)+2];\n    int col[n],ans=0;\n    double r[n],x[n],y[n];\n    for(int i=0;i<n;i++)\n      cin>>x[i]>>y[i]>>r[i]>>col[i];\n    memset(dp,0,sizeof(dp));\n    dp[((1<<n)-1)]=1;\n  \n    for(int i=1<<n;i>=0;i--)if(dp[i])\n\tfor(int j=n-1;j>=0;j--)if((1<<j)&i)\n\t    for(int k=j-1;k>=0;k--)\n\t      if(((1<<k)&i)&&col[j]==col[k]){\n\t\tfor(int l=j-1;l>=0;l--)if((i&(1<<l))&&abs(sqrt((x[l]-x[j])*(x[l]-x[j])+(y[l]-y[j])*(y[l]-y[j])))<r[j]+r[l])goto L;\n\t        for(int l=k-1;l>=0;l--)if((i&(1<<l))&&abs(sqrt((x[l]-x[k])*(x[l]-x[k])+(y[l]-y[k])*(y[l]-y[k])))<r[k]+r[l])goto L;\n\t\tdp[i-(1<<j)-(1<<k)] =dp[i]+2;\n\t\tans=max(ans,dp[i-(1<<j)-(1<<k)]);\n\t      L:;\n\t      }\n    cout<<ans-1<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct P {\n  int x,y,r,k;\n}p[30];\nbool u[30],b[1<<24];\nint n,ans,c[30];\nvector<int> g[30];\n \nbool ck(int a, int b) {\n  double d=sqrt((p[a].x-p[b].x)*(p[a].x-p[b].x)+(p[a].y-p[b].y)*(p[a].y-p[b].y));\n  double c=p[a].r+p[b].r;\n  return d<c;\n}\n\nvoid dfs() {\n  int cnt=0,t=0;\n  for(int i=0; i<n; i++) {\n    cnt+=u[i];\n    t|=u[i]<<i;\n  }\n  if(ans<cnt) ans=cnt;\n  if(b[t]) return;\n  b[t]=1;\n  vector<int> v;\n  for(int i=0; i<n; i++) {\n    if(!u[i]&&!c[i]) v.push_back(i);\n  }\n  for(int i=0; i<v.size(); i++) {\n    for(int j=i+1; j<v.size(); j++) {\n      if(p[v[i]].k==p[v[j]].k) {\n        for(int l=0; l<g[v[i]].size(); l++) c[g[v[i]][l]]--;\n        for(int l=0; l<g[v[j]].size(); l++) c[g[v[j]][l]]--;\n        u[v[i]]=u[v[j]]=1;\n        dfs();\n        u[v[i]]=u[v[j]]=0;\n        for(int l=0; l<g[v[i]].size(); l++) c[g[v[i]][l]]++;\n        for(int l=0; l<g[v[j]].size(); l++) c[g[v[j]][l]]++;\n      }\n    }\n  }\n}\n   \n \nint main() {\n  while(cin >> n && n) {\n    for(int i=0; i<n; i++) {\n      int a1,a2,a3,a4;\n      cin >> a1 >> a2 >> a3 >> a4;\n      p[i]=(P){a1,a2,a3,a4};\n      g[i].clear();\n    }\n    fill(b,b+(1<<n),0);\n    memset(u,0,sizeof(u));\n    memset(c,0,sizeof(c));\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<i; j++) {\n        if(ck(i,j)) {\n          c[i]++;\n          g[j].push_back(i);\n        }\n      }\n    }\n    ans=0;\n    dfs();\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nbool visit[1<<24];\nint c[24];\nint key[24];\nint n;\n\nvoid dfs(int x) {\n\tvisit[x] = true;\n\tfor(int i=0; i<n; i++) {\n\t\tif(x & (1<<i)) continue;\n\t\tbool ok = true;\n\t\tfor(int ii=0; ii<n; ii++) {\n\t\t\tif( !(x&(1<<ii)) && (key[i]&(1<<ii)) ) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok) continue;\n\n\t\tfor(int j=i+1; j<n; j++) {\n\t\t\tif(x & (1<<j)) continue;\n\t\t\tif(c[i] != c[j]) continue;\n\t\t\tif( visit[x | (1<<i) | (1<<j)] ) continue;\n\t\t\tfor(int jj=0; jj<n; jj++) {\n\t\t\t\tif( !(x&(1<<jj)) && (key[j]&(1<<jj)) ) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok) {\n\t\t\t\tdfs(x | (1<<i) | (1<<j));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(cin >> n, n) {\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tvi x(n), y(n), r(n);\n\t\trep(i, n) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tmemset(key, 0, sizeof(key));\n\t\trep(i, n) {\n\t\t\tfor(int j=i-1; j>=0; j--) {\n\t\t\t\tint d = (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]);\n\t\t\t\tif(d < (r[i]+r[j])*(r[i]+r[j])) {\n\t\t\t\t\tkey[i] |= (1<<j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdfs(0);\n\n\t\tint maxi = 0;\n\t\trep(i, (1<<n)) {\n\t\t\tif(visit[i]) {\n\t\t\t\tint num = 0;\n\t\t\t\trep(j, n) {\n\t\t\t\t\tif( i & (1<<j) ) num++;\n\t\t\t\t}\n\t\t\t\tmaxi = max(maxi, num);\n\t\t\t}\n\t\t}\n\t\tcout << maxi << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n\n\nusing namespace std;\n\ndouble x[24];\ndouble y[24];\ndouble r[24];\ndouble c[24];\nbool tops[24];\n\nint dp[1<<24];\n\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n\n    if (n == 0) {\n      break;\n    }\n\n    for (int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n\n\n    int ans = 0;\n\n    \n    memset(dp, 0, sizeof(dp));\n    for (int i = 0; i < (1 << n); i++) {\n      fill_n(tops,n,false);\n      int popcnt = 0;\n      for (int j = 0; j < n; j++) {\n        if (i & (1 << j)) {\n          popcnt++;\n        }\n      }\n      if (popcnt % 2 == 1) {\n        continue;\n      }\n      // テ」ツつづ」ツ?? jテ」ツ?ィkテ」ツ?古・ツ渉姪」ツつ古」ツつ凝」ツ?ェテ」ツつ?\n      for (int a = 0; a < n; a++) {\n        if (i & (1 << a)) {\n          tops[a] = false;\n          continue;\n        }\n        for (int b = a + 1; b < n; b++) {\n          if (i & (1 << b)) {\n            tops[b] = false;\n            continue;\n          }\n          // iテ」ツ?ョテ」ツ?サテ」ツ??」ツ?古「ツ??\n          double distance2 = pow(x[a] - x[b], 2) + pow(y[a] - y[b], 2);\n          if (distance2 < pow(r[a] + r[b], 2)) {\n            tops[b] = false;\n          }\n        }\n      }\n      for (int j = 0; j < n; j++) {\n        for (int k = j + 1; k < n; k++) {\n          if (c[j] == c[k]) {\n            if (tops[j] && tops[k]) {\n              // dp[i | (j, k) << c] = max(dp[i | (j, k) << c], dp[i] + 1);\n              int bit = i | (1 << j) | (1 << k);\n              dp[bit] = max(dp[bit], dp[i] + 1);\n              ans = max(ans, dp[bit]);\n            }\n          }\n        }\n      }\n    }\n    \n    cout << ans * 2 << endl;\n\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 24\nusing namespace std;\n\nint n,x[N],y[N],r[N],c[N],ans,len[N],cn;\nvector<int> v[N];\n\nvoid func(bool erased[N],int cnt,int x){\n  if(cn==15000000) return ;\n  cn++;\n  ans=max(ans,cnt);\n  for(int i=0;i<n;i++){\n    int f=0;\n    if(erased[i]) continue;\n    for(int j=0;j<len[i];j++)\n      if(!erased[v[i][j]]) f=1;\n    if(f) continue;\n    for(int j=i+1;j<n;j++){\n      if(c[i]!=c[j]) continue;\n      if(erased[j]) continue;\n      int f2=0;\n      for(int k=0;k<len[j];k++)\n\tif(!erased[v[j][k]]) f2=1;\n      if(f2) continue;\n      erased[i]=erased[j]=true;\n      func(erased,cnt+2,x+1);\n      erased[i]=erased[j]=false;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    cn=0;\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n      for(int j=i-1;j>=0;j--){\n\tint xl=x[i]-x[j],yl=y[i]-y[j];\n\tint rl=r[i]+r[j];\n\tif(xl*xl+yl*yl<rl*rl)v[i].push_back(j);\n      }\n    }\n    for(int i=0;i<n;i++) len[i]=v[i].size();\n    bool erased[N]={};\n    ans=0;\n    func(erased,0,0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++) v[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <map>\n\nint n;\nint x[32];\nint y[32];\nint r[32];\nint c[32];\n\nvoid Load() {\n  scanf(\"%d\", &n);\n  for(int i = 0; i < (int)n; ++i) {\n    scanf(\"%d\", &x[i]);\n    scanf(\"%d\", &y[i]);\n    scanf(\"%d\", &r[i]);\n    scanf(\"%d\", &c[i]);\n  }\n}\n\nclass Solve_ {\npublic:\n  int operator () () {\n    /*\n    int res = 0;\n    int valid[32] = {}; // not removed\n    for(int i = 0; i < n; ++i) valid[i] = true;\n    for(;;) {\n      bool remove_flag = false;\n      bool top[32]   = {}; // not overlaped\n      for(int i = 0; i < n; ++i) top[i] = true;\n      for(int i = 0; i < n; ++i) {\n        if( not valid[i] ) continue;\n        for(int j = 0; j < i; ++j) {\n          if( not valid[j] ) continue;\n          if( (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) < (r[i] + r[j]) * (r[i] + r[j]) ) {\n            top[i] = false;\n          }\n        }\n      }\n      for(int i = 0; i < n; ++i) {\n        if( not valid[i] ) continue;\n        if( not top[i] ) continue;\n      }\n      for(int i = 0; i < n; ++i) {\n        if( not valid[i] ) continue;\n        if( not top[i] ) continue;\n        for(int j = i + 1; j < n; ++j) {\n          if( not valid[j] ) continue;\n          if( not top[j] ) continue;\n          if( c[i] != c[j] ) continue;\n          valid[i] = false;\n          valid[j] = false;\n          remove_flag = true;\n          res += 2;\n        }\n      }\n      if( not remove_flag ) break;\n    }\n    */\n    for(int i = 0; i < (1 << 24); ++i) {\n      memo[i] = 0;\n    }\n    bool valid[32] = {};\n    for(int i = 0; i < n; ++i) valid[i] = true;\n    int res = dfs(valid);\n    return res;\n  }\n  int dfs(bool valid[32]) {\n    int memoid = CalcMemoId(valid);\n    if( memo[memoid] != 0 ) {\n      return memo[memoid];\n    }\n    int res = 0;\n    bool top[32];\n    calc_top(valid, top);\n    for(int i = 0; i < n; ++i) {\n      if( not valid[i] ) continue;\n      if( not top[i] ) continue;\n      for(int j = 0; j < i; ++j) {\n        if( not valid[j] ) continue;\n        if( not top[j] ) continue;\n        if( c[i] != c[j] ) continue;\n\n        valid[i] = valid[j] = false;\n        res = std::max(res, dfs(valid) + 2);\n        valid[i] = valid[j] = true;\n        if( res == 24 ) return res;\n      }\n    }\n    memo[memoid] = res;\n    return res;\n  }\n  void calc_top(bool valid[32], bool top[32]) {\n    for(int i = 0; i < n; ++i) {\n      top[i] = (valid[i] ? true : false);\n    }\n    for(int i = 0; i < n; ++i) {\n      if( not valid[i] ) continue;\n      for(int j = 0; j < i; ++j) {\n        if( not valid[j] ) continue;\n        if( (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) < (r[i] + r[j]) * (r[i] + r[j]) ) {\n          top[i] = false;\n        }\n      }\n    }        \n  }\n  int CalcMemoId(bool valid[32]) {\n    int res = 0;\n    for(int i = 0; i < n; ++i) {\n      if( valid[i] ) {\n        res |= (1 << i);\n      }\n    }\n    return res;\n  }\nprivate:\n  int8_t memo[1<<24];\n};\nSolve_ Solve;\n\nint main() {\n  for(;;) {\n    Load();\n    if( n == 0 ) break;\n    int res = Solve();\n    printf(\"%d\\n\", res);\n  }  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint N, X[24], Y[24], R[24], C[24];\nint r[24], m[24];\nchar dp[16777216];\n\nint f(char n, int s) { return ((s & r[n]) & m[n]) == 0; }\n\nint main(void) {\n  m[0] = 0;\n  REP(i, 0, 23) m[i + 1] = m[i] | (1 << i);\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> X[i] >> Y[i] >> R[i] >> C[i];\n    REP(i, 0, pow(2, N)) dp[i] = -1;\n    REP(i, 0, N) r[i] = 0;\n    REP(i, 0, N) REP(j, 0, N) {\n      if(pow(R[i] + R[j], 2) > pow(X[i] - X[j], 2) + pow(Y[i] - Y[j], 2)) {\n        r[i] = r[i] | (1 << j);\n        r[j] = r[j] | (1 << i);\n      }\n    }\n    char ans = dp[(1 << N) - 1] = 0;\n    for(int s = (1 << N) - 1; s >= 0; s--) {\n      if(dp[s] == -1) continue;\n\n      char n = N;\n      REP(i, 0, N) if(s & (1 << i)) n--;\n      if(n % 2) continue;\n      ans = max(ans, n);\n\n      // cout << s << \" \" << (int) n << endl;\n\n      REP(i, 0, N) {\n        int mi = (1 << i);\n        if((~s & mi) || !f(i, s)) continue;\n        REP(j, i + 1, N) {\n          int mj = (1 << j);\n          if(C[i] != C[j] || (~s & mj) || !f(j, s)) continue;\n          int ns = ~(~s | mi | mj);\n          dp[ns] = n + 2;\n        }\n      }\n    }\n    cout << (int) ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint N,ans;\nbool* state;\n\nstruct Info{\n\tInfo(){\n\t\tx = y = r = 0.0;\n\t\tcolor = 0;\n\t}\n\tdouble x,y,r;\n\tint color;\n};\n\n\nbool isOverlap(Info left,Info right){\n\tdouble dist = sqrt((left.x-right.x)*(left.x-right.x)+(left.y-right.y)*(left.y-right.y));\n\treturn dist <  left.r + right.r;\n}\n\n\nint makeCode(bool removed[]){\n\n\tint ret = 0;\n\n\tint S = 1;\n\tfor(int i = 0; i <= N-1; i++){\n\t\tif(removed[i]){\n\t\t\tret += S;\n\t\t}\n\t\tS *= 2;\n\t}\n\treturn ret;\n}\n\n\nvoid recursive(Info info[],bool removed[],int count){\n\n\tif(count == N || ans == N)return;\n\n\tans = max(ans,count);\n\n\tbool check[N],over_rapFLG;\n\n\tfor(int i = 0; i < N; i++)check[i] = false;\n\n\tfor(int i = N-1; i >= 0; i--){\n\n\t\tif(removed[i] == true)continue;\n\n\t\tover_rapFLG = false;\n\n\t\tfor(int j = i-1; j >=0; j--){\n\n\t\t\tif(removed[j] == true)continue;\n\n\t\t\tif(isOverlap(info[i],info[j])){\n\t\t\t\tover_rapFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!over_rapFLG){\n\t\t\tcheck[i] = true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N-1; i++){\n\t\tfor(int k = i+1; k < N; k++){\n\t\t\tif(check[i] == true && check[k] == true && info[i].color == info[k].color){\n\t\t\t\tif(count == N-2){\n\t\t\t\t\tans = N;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tbool next_removed[N];\n\t\t\t\tfor(int i = 0; i < N; i++)next_removed[i] = removed[i];\n\t\t\t\tnext_removed[i] = true;\n\t\t\t\tnext_removed[k] = true;\n\n\t\t\t\tint code = makeCode(next_removed);\n\n\t\t\t\tif(state[code] == false){\n\t\t\t\t\tstate[code] = true;\n\t\t\t\t\trecursive(info,next_removed,count+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid func(){\n\tInfo info[N];\n\n\tint limit = pow(2,N);\n\n\tfor(int i = 0; i < limit; i++)state[i] = false;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf %d\",&info[i].x,&info[i].y,&info[i].r,&info[i].color);\n\t}\n\n\tans = 0;\n\n\tbool removed[N];\n\tfor(int i = 0; i < N; i++)removed[i] = false;\n\n\trecursive(info,removed,0);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tstate = new bool[16777216];\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n\n    if (n == 0) {\n      break;\n    }\n\n    vector<double> x(n);\n    vector<double> y(n);\n    vector<double> r(n);\n    vector<double> c(n);\n    \n\n    for (int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n\n    vector<int> dp(1 << n, 0);\n\n    int ans = 0;\n\n    \n\n    \n    for (int i = 0; i < (1 << n); i++) {\n      int popcnt = 0;\n      for (int j = 0; j < n; j++) {\n        if (i & (1 << j)) {\n          popcnt++;\n        }\n      }\n      if (popcnt % 2 == 1) {\n        continue;\n      }\n      vector<bool> tops(n, true);\n      // テ」ツつづ」ツ?? jテ」ツ?ィkテ」ツ?古・ツ渉姪」ツつ古」ツつ凝」ツ?ェテ」ツつ?\n      for (int a = 0; a < n; a++) {\n        if (i & (1 << a)) {\n          tops[a] = false;\n          continue;\n        }\n        for (int b = a + 1; b < n; b++) {\n          if (i & (1 << b)) {\n            tops[b] = false;\n            continue;\n          }\n          // iテ」ツ?ョテ」ツ?サテ」ツ??」ツ?古「ツ??\n          double distance2 = pow(x[a] - x[b], 2) + pow(y[a] - y[b], 2);\n          if (distance2 < pow(r[a] + r[b], 2)) {\n            tops[b] = false;\n          }\n        }\n      }\n      for (int j = 0; j < n; j++) {\n        for (int k = j + 1; k < n; k++) {\n          if (c[j] == c[k]) {\n            if (tops[j] && tops[k]) {\n              // dp[i | (j, k) << c] = max(dp[i | (j, k) << c], dp[i] + 1);\n              int bit = i | (1 << j) | (1 << k);\n              dp[bit] = max(dp[bit], dp[i] + 1);\n              ans = max(ans, dp[bit]);\n            }\n          }\n        }\n      }\n    }\n    \n    cout << ans * 2 << endl;\n\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define N 24\n\nchar d[1<<N];\nint x[N],y[N],r[N],c[N];\n\nbool pailed(int a,int b){\n  int d2 = (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);\n  int r2 = (r[a]+r[b])*(r[a]+r[b]);\n  return d2 < r2;\n}\n\nint main(){\n  int n;\n  while(cin >> n,n){\n    vector<int> over(n);\n    fill(over.begin(),over.end(),0);\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n    }\n    for(int i=n-1;i>=0;i--){\n      for(int j=i-1;j>=0;j--){\n        if(pailed(i,j)){\n          over[i] |= 1<<j;\n        }\n      }\n    }\n\n    fill(d,d+(1<<n),0);\n    for(int i=0;i<1<<n;i++){\n      for(int j=0;j<n-1;j++){\n        if(!(i>>j&1)||over[j]&i) continue;\n        for(int k=j+1;k<n;k++){\n          if(!(i>>k&1)||over[k]&i||c[k]!=c[j]) continue;\n          d[i] = max((int)d[i],2 + d[(~(1<<j))&(~(1<<k))&i]);\n        }\n      }\n    }\n    cout << (int)d[(1<<n)-1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n#define HIT(a,b) ((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r))\n\nstruct DISK{\n\tint x,y,r,c,o;\n\tDISK():o(0){}\n};\nint n;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n, n){\n\t\tvector<DISK> D(n);\n\t\tREP(i, n) cin>>D[i].x>>D[i].y>>D[i].r>>D[i].c;\n\t\tREP(j, n)REP(i, j)if(HIT(D[i],D[j])) D[j].o |= 1<<i;\n\t\tint ans = 0;\n\t\tvector<char> dp(1<<n);\n\t\tdp[0] = 1;\n\t\tREP(b, 1<<n)if(dp[b]){\n\t\t\tREP(j, n)REP(i, j)if(!((b >> i) & 1)){\n\t\t\t\tif((b >> i) & 1 || (b>>j) & 1 || D[i].c != D[j].c || ~b & D[i].o || ~b & D[j].o) continue;\n\t\t\t\tdp[b|1<<i|1<<j] = 1;\n\t\t\t}\n\t\t\tans = max(ans, __builtin_popcount(b));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst double eps = 1e-8;\n\ntemplate<typename T> inline T sqr(T x){return x * x;}\ntemplate<typename T> inline void chmax(T& t, T f){if(t < f)t = f;}\n\nstruct Circle : Point {\n    double r;\n    int c;\n    Circle(const Point &a, double r, int c):Point(a), r(r), c(c){}\n};\n\nint overlap(Circle &c1, Circle &c2){\n    if(sqr(c1.r + c2.r) < norm(c1 - c2))return 0;\n    if(abs(c1 - c2) + c1.r < c2.r + eps)return -1;\n    if(c2.r < c1.r && abs(c1 - c2) + c2.r < c1.r + eps)return 1;\n    if(abs(abs(c1 - c2) - c1.r - c2.r) < eps)return -2;\n    return 2;\n}\n\nint n;\nvector<Circle> disc;\nvector<bool> vis;\n\nvoid dfs(vector<int>& indeg, int table, int& maxi){\n    if(vis[table])return; else vis[table] = true;\n    chmax(maxi, n - __builtin_popcount(table));\n    rep(i, n){\n        if(!(table >> i & 1) || indeg[i])continue;\n        for(int j=i+1; j<n; ++j){\n            if(!(table >> j & 1) || indeg[j] || disc[i].c != disc[j].c)continue;\n            vector<int> nxt(indeg);\n            rep(k, n)nxt[k] &= ~(1 << i | 1 << j);\n            dfs(nxt, table ^ 1 << i ^ 1 << j, maxi);\n        }\n    }\n}\n\nint solve(){\n    vector<int> indeg(n, 0);\n    rep(i, n)rep(j, i){\n        int chk = overlap(disc[i], disc[j]);\n        if(chk == 0 || chk == -2)continue;\n        rep(k, j)if(indeg[i] >> k & 1 && indeg[j] >> k & 1)indeg[i] ^= 1 << k;\n        indeg[i] |= 1 << j;\n    }\n    vis.assign(1<<n, false);\n    int res = 0;\n    dfs(indeg, (1 << n) - 1, res);\n    return res;\n}\n\nint main(){\n    while(cin >> n, n){\n        disc.clear();\n        rep(i, n){\n            int x, y, r, c;\n            cin >> x >> y >> r >> c;\n            disc.emplace_back(Point(x, y), r, c);\n        }\n        cout << solve() << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint main(){\n  int n;\n  cin >> n;\n  while(n!=0){\n    int sum=0;\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    int f=0;\n    int on[30]={};\n    //int cc[5]={};\n    vector<int> cc[5];\n    while(f==0){\n      f=1;\n      /*\n      for(i=0;i<24;i++) on[i]=0;\n      for(i=0;i<v.size();i++){\n\tfor(j=i+1;j<v.size();j++){\n\t  if(ch(v[i],v[j])==1) on[j]=1;\n\t}\n      }\n      for(i=0;i<5;i++) cc[i]=0;\n      for(i=0;i<v.size();i++){\n\tif(on[i]==0) cc[v[i].c]++;\n      }\n      */\n      int ff=0;\n      //while(ff==0){\n\tff=1;\n\tfor(i=0;i<30;i++) on[i]=0;\n\tfor(i=0;i<v.size();i++){\n\t  for(j=i+1;j<v.size();j++){\n\t    if(ch(v[i],v[j])==1) on[j]=1;\n\t  }\n\t}\n\t\n\tfor(i=0;i<5;i++) cc[i].clear();\n\tfor(i=0;i<v.size();i++){\n\t  if(on[i]==0) cc[v[i].c].push_back(i);\n\t}\n\t\n\tfor(i=1;i<5;i++){\n\t  if(cc[i].size()>0&&cc[i].size()%2==0){\n\t    for(j=cc[i].size()-1;j>=0;j--){\n\t      v.erase(v.begin()+cc[i][j]);\n\t      ff=0;\n\t      f=0;\n\t    }\n\t  }\n\t}\n\t\n\t//}\n\t/*\n      for(i=1;i<5;i++){\n\tk=0;\n\tfor(j=v.size()-1;j>=0;j--){\n\t  if(on[j]==0&&v[j].c==i){\n\t    if(cc[i].size()%2==1&&cc[i].size()<k) {\n\t      //cout << v[j].id << \" \";\n\t      v.erase(v.begin()+j);\n\t      k++;\n\t      f=0;\n\t    }\n\t  }\n\t}\n      }\n      */\n    }\n    cout << n-v.size() << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nmain {\n  while (true) {\n    int n = in();\n    if (n == 0) break;\n    vector<int> x(n), y(n), r(n), c(n);\n    rep(i, n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n    auto intersectCC = [&](int i, int j) {\n      int r2 = (r[i] + r[j]) * (r[i] + r[j]);\n      int d = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n      return d < r2;\n    };\n    auto intersect = [&](int t, int used) {\n      bool f = false;\n      rep(i, t) f |= (~used >> i & 1) && intersectCC(t, i);\n      return f;\n    };\n    vector<int8_t> dp(1 << n, -1);\n    function<int(int)> dfs = [&](int used) {\n      if (dp[used] != -1) return dp[used];\n      cmax(dp[used], 0);\n      rep(i, n) loop(j, i + 1, n) {\n        if ((used >> i & 1) || (used >> j & 1) || c[i] != c[j]) continue;\n        if (intersect(i, used) || intersect(j, used)) continue;\n        cmax(dp[used], dfs(used | (1 << i) | (1 << j)) + 2);\n      }\n      return dp[used];\n    };\n    cout << dfs(0) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long Long;\n#define whole(xs) xs.begin(), xs.end()\n\nstruct Circle {\n    int x, y, r, c;\n};\nistream& operator>>(istream& is, Circle& c) {\n    is >> c.x >> c.y >> c.r >> c.c;\n    return is;\n}\n\nstruct Point {\n    int x, y;\n    Point(int x = 0, int y = 0) : x(x), y(y) {}\n};\n#define Pow2(x) ((x) * (x))\nint Dist2(const Point& a, const Point& b) {\n    return Pow2(a.x - b.x) + Pow2(a.y - b.y);\n}\n\nint N;\nvector<Circle> Cs;\nbool input() {\n    cin >> N;\n    if (N == 0) return false;\n    Cs.resize(N);\n    for (int i = 0; i < N; i++) {\n        cin >> Cs[i];\n    }\n    return true;\n}\n\nbool Overlap(const Circle& a, const Circle& b) {\n    return Pow2(a.r + b.r) > Dist2(Point(a.x, a.y), Point(b.x, b.y));\n}\n\nbool IsTop(int used, int index) {\n    for (int i = 0; i < index; i++) {\n        if (used & (1 << i)) continue;\n        if (Overlap(Cs[i], Cs[index])) return false;\n    }\n    return true;\n}\n\nchar Cache[1 << 24];\nint dfs(int used) {\n    int Ret = 0;\n    if (Cache[used] >= 0) return Cache[used];\n    for (int i = 0; i < N; i++) {\n        if (used & (1 << i)) continue;\n        if (!IsTop(used, i)) continue;\n        for (int j = i + 1; j < N; j++) {\n            if (used & (1 << j)) continue;\n            if (!IsTop(used, j)) continue;\n            if (Cs[i].c == Cs[j].c) {\n                Ret = max(Ret, dfs(used | (1 << i) | (1 << j)) + 2);\n            }\n        }\n    }\n    return Cache[used] = Ret;\n}\n\nvoid solve() {\n    memset(Cache, -1, sizeof(Cache));\n    cout << dfs(0) << endl;\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nstruct Solver\n{\n\tconst int N;\n\tVI xs, ys, rs, cs;\n\n\tint res;\n\n\tSolver( int n ) : N( n ), xs( N ), ys( N ), rs( N ), cs( N ), res( 0 )\n\t{\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tcin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n\t\t}\n\t\treturn;\n\t}\n\n\toperator int()\n\t{\n\t\tdfs( vector<bool>( N, true ) );\n\t\treturn res;\n\t}\n\n\tvoid dfs( vector<bool> exists )\n\t{\n\t\tres = max( res, count( ALL( exists ), false ) );\n\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tREP( j, 0, i )\n\t\t\t{\n\t\t\t\tif ( !exists[i] || !exists[j] || cs[i] != cs[j] )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( !overlapped( exists, i ) && !overlapped( exists, j ) )\n\t\t\t\t{\n\t\t\t\t\texists[i] = exists[j] = false;\n\t\t\t\t\tdfs( exists );\n\t\t\t\t\texists[i] = exists[j] = true;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\tbool overlapped( const vector<bool> &exists, const int p )\n\t{\n\t\tREP( i, 0, p )\n\t\t{\n\t\t\tif ( !exists[i] )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( ( xs[p] - xs[i] ) * ( xs[p] - xs[i] ) + ( ys[p] - ys[i] ) * ( ys[p] - ys[i] ) < ( rs[i] + rs[p] ) * ( rs[i] + rs[p] ) )\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int n; cin >> n, n; )\n\t{\n\t\tcout << Solver( n ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint n;\nint x[25], y[25], r[25], c[25];\nbool board[25][25];\nbool memo[1<<24];\n\nvoid dfs(int S) {\n    if(memo[S]) return;\n    vector<int> candidate;\n    rep(i,0,n) {\n        if(!(S >> i & 1)) continue;\n        bool ok = true;        \n        rep(j,0,i) {\n            if(!(S >> j & 1)) continue;\n            if(board[j][i]) ok = false;\n        }\n        if(ok) candidate.push_back(i);\n    }\n\n    int m = candidate.size();\n    rep(i,0,m) {\n        rep(j,i+1,m) {\n            int x = candidate[i], y = candidate[j];\n            if(c[x] == c[y]) {\n                int nbit = S ^ (1 << x) ^ (1 << y);\n                dfs(nbit);\n                memo[nbit] = true;\n            }\n        }\n    }\n}\n\nll dist(ll x1, ll y1, ll x2, ll y2) {\n    ll d1 = (x1-x2) * (x1-x2);\n    ll d2 = (y1-y2) * (y1-y2);\n    return d1 + d2;\n}\n\nbool in(ll x1, ll y1, ll r1, ll x2, ll y2, ll r2) {\n    double d1 = dist(x1, y1, x2, y2);\n    double d2 = (r1+r2) * (r1+r2);\n    return d1 < d2;\n}\n\nsigned main() {\n    while(cin >> n, n) {\n        memset(board, false, sizeof(board));\n        memset(memo, false, sizeof(memo));\n        rep(i,0,n) {\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n        rep(i,0,n) rep(j,0,i) {\n            if(in(x[i], y[i], r[i], x[j], y[j], r[j])) board[j][i] = true;\n        }\n        dfs((1<<n)-1);\n        int ans = 0;\n        rep(i,0,1<<n) {\n            if(memo[i]) {\n                // printf(\"true: i = %lld\\n\", i);\n                ans = max(ans, n - __builtin_popcount(i));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <bitset>\n#include <unordered_map>\nusing namespace std;\n\ntypedef double D;\nconst double EPS = 1e-8;\n\nstruct P {\n  D x, y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\n\nstruct C {\n  P p;\n  D r;\n  C() { }\n  C(P p_, D r_) : p(p_), r(r_) { }\n  C(D x_, D y_, D r_) : p(x_, y_), r(r_) { }\n};\n\nint sig(double a, double b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\n\nbool iCC(C a, C b) {\n  D dx = a.p.x - b.p.x;\n  D dy = a.p.y - b.p.y;\n  D d2 = dx*dx + dy*dy;\n  return sig(d2, (a.r + b.r)*(a.r + b.r)) < 0;\n}\n\nint N;\nC circle[24];\nint color[24];\nbool overlap[24][24];\n\nunordered_map<int, int> memo;\nint solve(int S) {\n  if(memo.count(S)) return memo[S];\n  int top = 0;\n  for(int i = 0; i < N; ++i) {\n    if(((S >> i) & 1) == 0) continue;\n    bool ok = true;\n    for(int j = 0; j < i; ++j) {\n      if(((S >> j) & 1) == 0) continue;\n      if(overlap[i][j]) {\n        ok = false;\n        break;\n      }\n    }\n    if(ok) {\n      top |= (1 << i);\n    }\n  }\n  int res = 0;\n  for(int i = 0; i < N; ++i) {\n    for(int j = i + 1; j < N; ++j) {\n      if(((top >> i) & 1) && ((top >> j) & 1) && color[i] == color[j]) {\n        int B = S;\n        B &= ~(1 << i);\n        B &= ~(1 << j);\n        res = max(res, 2 + solve(B));\n      }\n    }\n  }\n  return memo[S] = res;\n}\n\nint main() {\n  while(true) {\n    memo.clear();\n    cin >> N;\n    if(N == 0) break;\n    for(int i = 0; i < 24; ++i)\n      for(int j = 0; j < 24; ++j)\n        overlap[i][j] = false;\n    for(int i = 0; i < N; ++i) {\n      cin >> circle[i].p.x >> circle[i].p.y >> circle[i].r >> color[i];\n      color[i]--;\n    }\n    for(int i = 0; i < N; ++i) {\n      for(int j = 0; j < i; ++j) {\n        if(iCC(circle[i], circle[j])) {\n          overlap[i][j] = true;\n        }\n      }\n    }\n    cout << solve((1 << N) - 1 ) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nclass solver{\n    public:\n    int n,ans=0;\n    vector<int> memo,x,y,r,c;\n\n    int toInt(vector<bool>& v){\n        int res = 0;\n        for(int i = 0;i < v.size();i++){\n            res <<= 1;\n            res += v[i];\n        }\n        return res;\n    }\n\n    int count(vector<bool>& v){\n        int res = 0;\n        for(int i = 0;i < v.size();i++){\n            res += v[i];\n        }\n        return res;\n    }\n    \n    void dfs(vector<bool>& v){\n        int toi = toInt(v);\n        if(memo[toi])return;\n        memo[toi] = 1;\n        ans = max(ans,n-count(v));\n        bool top[n];\n        for(int i = 0;i < n;i++)top[i] = v[i];\n        for(int i = 0;i < n;i++){\n            for(int j = i+1;j < n;j++){\n                if(!v[j])continue;\n                if((r[i]+r[j])*(r[i]+r[j]) > (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])){\n                    top[i] = false;\n                }\n            }\n        }\n        for(int i = 0;i < n;i++){\n            for(int j = i+1;j < n;j++){\n                if(c[i] == c[j] && top[i] && top[j]){\n                    v[i] = false;\n                    v[j] = false;\n                    dfs(v);\n                    v[i] = true;\n                    v[j] = true;\n                }\n            }\n        }\n    }\n\n    int solve(int arg){\n        n = arg;\n        memo.resize(1<<n);\n        fill(memo.begin(),memo.end(),0);\n        x.resize(n);\n        y.resize(n);\n        r.resize(n);\n        c.resize(n);\n        for(int i = 0;i < n;i++){\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n        reverse(x.begin(),x.end());\n        reverse(y.begin(),y.end());\n        reverse(r.begin(),r.end());\n        reverse(c.begin(),c.end());\n        vector<bool> v(n,true);\n        dfs(v);\n        return ans;\n    }\n    \n};\n\nint main(){\n    int n;\n    while(true){\n        cin >> n;\n        if(!n)return 0;\n        solver s;\n        cout << s.solve(n) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//????????????2???????????§??????????????????????????????????????????????¬??????¨NG. ???????????¨??¢?´¢????????????\n//??????????????????????????????????????????????????£?????????????????????????????????O(2^n)????????????????????°??§?????????\n//?????????????????????????????????????????£?????????)???????????°????????¶?????????????????????????????§???????????????????§???????????¢??????????????????§?????¨?????????????????????????????????????????§????????????\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint n;\nint x[24], y[24], r[24], c[24];\nshort int dp[1 << 24];\n\n//rem???i??????????????????i????????£???????????°1, ??????????????????????????°0\n//????????????????????????????????????????????°????????§???\nint dfs(int rem) {\n\tbool isOut[24];\t//isOut[i] = ???i??????????????????????????°true\n\tint i, j;\n\t\n\t//if (rem == 0) return 0;\n\tif (dp[rem] >= 0) return dp[rem];\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif ((rem >> j) % 2 == 0) continue;\t//??¢????????????????????????\n\t\t\tint dd = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n\t\t\tint rr = (r[i] + r[j]) * (r[i] + r[j]);\n\t\t\tif (dd < rr) break;\n\t\t}\n\t\tisOut[i] = (j == i);\n\t}\n\t\n\tint ret = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tif ((rem >> i) % 2 == 0 || !isOut[i]) continue;\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tif ((rem >> j) % 2 == 0 || !isOut[j]) continue;\n\t\t\tif (c[i] != c[j]) continue;\n\t\t\t//???i, j????????????????????????\n\t\t\tret = max(ret, dfs(rem - (1 << i) - (1 << j)) + 2);\n\t\t}\n\t}\n\treturn (dp[rem] = ret);\n}\n\nint main() {\n\twhile (cin >> n) {\n\t\tif (!n) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tfor (int i = 0; i < (1<<n); i++) {\n\t\t\tdp[i] = -1;\n\t\t}\n\t\tcout << dfs((1 << n) - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nstruct Circle {\n\tint x, y, r, c;\n\n\tCircle(int _x, int _y, int _r, int _c) :x(_x), y(_y), r(_r), c(_c) {}\n};\n\nbool collision(Circle& c1, Circle& c2)\n{\n\treturn (c2.x - c1.x)*(c2.x - c1.x) + (c2.y - c1.y)*(c2.y - c1.y) < (c2.r + c1.r)*(c2.r + c1.r);\n}\n\nconst int MAX = 24;\n\nint n;\nbool memo[1 << MAX];\n\nvoid dfs(vector<Circle>& circles, int bit)\n{\n\tmemo[bit] = true;\n\n\trep(i, n) {\n\t\tif ((bit >> i) % 2 == 0) {\n\t\t\tbool flag = true;\n\n\t\t\t//????????£?????????????????????\n\t\t\trep(j, i) {\n\t\t\t\tif ((bit >> j) % 2 == 0) {\n\t\t\t\t\tif (collision(circles[i], circles[j]) == true) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (flag == false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif ((bit >> j) % 2 == 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (circles[i].c != circles[j].c) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbool f = true;\n\n\t\t\t\trep(k, j) {\n\t\t\t\t\tif ((bit >> k) % 2 == 0) {\n\t\t\t\t\t\tif (collision(circles[j], circles[k]) == true) {\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (f == false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint b = bit;\n\t\t\t\tb = b | (1 << i);\n\t\t\t\tb = b | (1 << j);\n\t\t\t\tif (memo[b] == false) {\n\t\t\t\t\tdfs(circles, b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (true) {\n\t\tcin >> n;\n\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<Circle> circles;\n\n\t\trep(i, 1 << MAX) {\n\t\t\tmemo[i] = false;\n\t\t}\n\n\t\trep(i, n) {\n\t\t\tint x, y, r, c;\n\n\t\t\tcin >> x >> y >> r >> c;\n\n\t\t\tcircles.push_back(Circle(x, y, r, c));\n\t\t}\n\n\t\tdfs(circles, 0);\n\n\t\tint ans = 0;\n\n\t\trep(i, 1 << n) {\n\t\t\tint temp = 0;\n\n\t\t\tif (memo[i] == true) {\n\t\t\t\trep(j, n) {\n\t\t\t\t\tif ((i >> j) % 2 == 1) {\n\t\t\t\t\t\ttemp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tans = max(ans, temp);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nstruct Solver\n{\n\tconst int N;\n\tVI xs, ys, rs, cs;\n\tset< vector<bool> > visited;\n\n\tint res;\n\n\tSolver( int n ) : N( n ), xs( N ), ys( N ), rs( N ), cs( N ), res( 0 )\n\t{\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tcin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n\t\t}\n\t\treturn;\n\t}\n\n\toperator int()\n\t{\n\t\tvector<bool> tmp( N, true );\n\t\tdfs( tmp );\n\t\treturn res;\n\t}\n\n\tvoid dfs( vector<bool> &exists )\n\t{\n\t\tif ( EXIST( visited, exists ) )\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tvisited.insert( exists );\n\t\tres = max<int>( res, count( ALL( exists ), false ) );\n\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tREP( j, 0, i )\n\t\t\t{\n\t\t\t\tif ( !exists[i] || !exists[j] || cs[i] != cs[j] )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( !overlapped( exists, i ) && !overlapped( exists, j ) )\n\t\t\t\t{\n\t\t\t\t\texists[i] = exists[j] = false;\n\t\t\t\t\tdfs( exists );\n\t\t\t\t\texists[i] = exists[j] = true;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\tbool overlapped( const vector<bool> &exists, const int p )\n\t{\n\t\tREP( i, 0, p )\n\t\t{\n\t\t\tif ( !exists[i] )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( ( xs[p] - xs[i] ) * ( xs[p] - xs[i] ) + ( ys[p] - ys[i] ) * ( ys[p] - ys[i] ) < ( rs[i] + rs[p] ) * ( rs[i] + rs[p] ) )\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int n; cin >> n, n; )\n\t{\n\t\tcout << Solver( n ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define pb push_back\nusing namespace std;\n\nint n;\nint ans;\nint x[30], y[30], r[30], c[30];\nbool used[30];\nbool did[30][30];\nvector<int> G[30];\n\nvoid dfs(int cnt){\n\tans = max(ans,cnt);\n\trep(i,n){\n\t\tif(used[i])continue;\n\t\tused[i] = true;\n\t\tbool yes = true;\n\t\trep(j,G[i].size()){\n\t\t\tif(!used[G[i][j]]){\n\t\t\t\tyes = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(yes){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tif(c[i] != c[j]) continue;\n\t\t\t\tif(did[i][j]) continue;\n\t\t\t\t\n\t\t\t\tused[j] = true;\n\t\t\t\tbool no = false;\n\t\t\t\trep(k,G[j].size()){\n\t\t\t\t\tif(G[j][k] == i){\n\t\t\t\t\t\tno = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(!used[G[j][k]]){\n\t\t\t\t\t\tno = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!no){\n\t\t\t\t\tdid[i][j] = true;\n\t\t\t\t\tdfs(cnt+2);\n\t\t\t\t}\n\t\t\t\tused[j] = false;\n\t\t\t}\n\t\t}\n\t\tused[i] = false;\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%d\",&n),n){\n\t\tmemset(used,0,sizeof(used));\n\t\tmemset(did,0,sizeof(did));\n\t\tans = 0;\n\t\trep(i,30) G[i].clear();\n\t\trep(i,n) scanf(\"%d%d%d%d\",x+i,y+i,r+i,c+i);\n\t\trep(i,n) for(int j = i+1; j < n; j++){\n\t\t\tif((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])<(r[i]+r[j])*(r[i]+r[j])){\n\t\t\t\tG[j].pb(i);\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define MAX 30\nusing namespace std;\nint  dp[1<<24];\nint n;\nint x[MAX],y[MAX],r[MAX],c[MAX];\nbool samecol(int a,int b){\n\treturn c[a]==c[b];\n}\nbool check(int a,int b){//kasanaru\n\tif((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b])<(r[a]+r[b])*(r[a]+r[b])){\n\t\treturn 1;\n\t}else\n\t\treturn 0;\n}\nint f(int now,int sum){\n\tif(dp[now]!=-1)\n\t\treturn dp[now];\n\tint ans=0;\n\tbool flag=true;\n\tfor(int i=0;i<n;i++)\n\tfor(int j=i+1;j<n;j++){\n\t\tif((now&(1<<i))&&(now&(1<<j))&&samecol(i,j)&&!check(i,j)){\n\t\t\t\n\t\t\tbool fl=false;\n\t\t\tfor(int k=0;k<j;k++){\n\t\t\t\tif((now&(1<<k))&&check(k,j)){\n\t\t\t\t\tfl=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\tif((now&(1<<k))&&check(i,k)){\n\t\t\t\t\tfl=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!fl){\n\t\t\tint nnow=now;\n\t\t\tnnow=nnow^(1<<i);\n\t\t\tnnow=nnow^(1<<j);\n\t\t\tflag=false;\n\t\t\tans=max(ans,f(nnow,sum+2));\n\t\t\t}\n\t\t}\n\t}\n\tif(flag){\n\t\treturn sum;\n\t}\n\treturn dp[now]=ans;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\t}\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tf((1<<n)-1,0);\n\t\tcout<<dp[(1<<n)-1]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n\nlong long  mod = 1000000007;\n\n\nbool lap[30][30];\n\n\nbool overlap(int i,int j,vector<int> &x,vector<int>&y,vector<int> &r){\n\tint k = 0;\n\tk = (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]);\n\tif(k>= (r[i]+r[j])*(r[i]+r[j]))return 0;\n\treturn 1;\n}\nint n;\nchar dp[1<<24];\nchar dfs(int s,vector<int>&c){\n\tif(dp[s] != -1) return dp[s];\n\tint k = 0;\n\tfor(int i=0;i<n;i++){\n\t\tif(s&(1<<i)){\n\t\t\tk++;\n\t\t}\n\t}\n\tdp[s] = n-k;\n\tchar res= n-k;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(c[i]==c[j]){\n\t\t\t\tif((s&(1<<i))&&(s&(1<<j))){\n\t\t\t\t\tbool fl =1;\n\t\t\t\t\tfor(int p=0;p<i;p++){\n\t\t\t\t\t\tif(lap[p][i]==1&&(s&(1<<p)))fl = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int p=0;p<j;p++){\n\t\t\t\t\t\tif(lap[p][j]==1&&(s&(1<<p)))fl = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(fl){\n\t\t\t\t\t\tres = max(res,dfs(s-(1<<i)-(1<<j),c));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[s] = res;\n}\n\nint main(){\n\twhile(cin >> n && n!=0){\n\t\tvector<int>x(n),y(n),r(n),c(n);\n\t\tfor(int i=0;i<(1<<24);i++){\n\t\t\tdp[i] = -1;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tfor(int i=0;i<30;i++){\n\t\t\tfor(int j=0;j<30;j++){\n\t\t\t\tlap[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(overlap(i,j,x,y,r)==1){\n\t\t\t\t\tlap[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tbool flag = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\tif(lap[i][j]==0){\n\t\t\t\t\t\tfor(int k=i+1;k<j;k++){\n\t\t\t\t\t\t\tif(lap[i][k]&&lap[k][j]){\n\t\t\t\t\t\t\t\tlap[i][j]=1;\n\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)break;\n\t\t}\n\t\t/*for(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tcout << i <<  \" \" << j << \" \" << lap[i][j] << endl;\n\t\t\t}\n\t\t}*/\n\n\t\tcout << (int)dfs((1<<n)-1,c) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 24\nusing namespace std;\n\nint n,x[N],y[N],r[N],c[N],ans,len[N],cn;\nvector<int> v[N];\n\nvoid func(bool erased[N],int cnt,int x){\n  if(cn==100000000) return ;\n  cn++;\n  ans=max(ans,cnt);\n  for(int i=0;i<n;i++){\n    int f=0;\n    if(erased[i]) continue;\n    for(int j=0;j<len[i];j++)\n      if(!erased[v[i][j]]) f=1;\n    if(f) continue;\n    for(int j=i+1;j<n;j++){\n      if(c[i]!=c[j]) continue;\n      if(erased[j]) continue;\n      int f2=0;\n      for(int k=0;k<len[j];k++)\n\tif(!erased[v[j][k]]) f2=1;\n      if(f2) continue;\n      erased[i]=erased[j]=true;\n      func(erased,cnt+2,x+1);\n      erased[i]=erased[j]=false;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    cn=0;\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n      for(int j=i-1;j>=0;j--){\n\tint xl=x[i]-x[j],yl=y[i]-y[j];\n\tint rl=r[i]+r[j];\n\tif(xl*xl+yl*yl<rl*rl)v[i].push_back(j);\n      }\n    }\n    for(int i=0;i<n;i++) len[i]=v[i].size();\n    bool erased[N]={};\n    ans=0;\n    func(erased,0,0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++) v[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define pb push_back\nusing namespace std;\n\nint n;\nint ans;\nint x[30], y[30], r[30], c[30];\nbool used[30];\nvector<int> G[30];\n\nvoid dfs(int cnt){\n\tans = max(ans,cnt);\n\trep(i,n){\n\t\tif(used[i])continue;\n\t\tused[i] = true;\n\t\tbool yes = true;\n\t\trep(j,G[i].size()){\n\t\t\tif(!used[G[i][j]]){\n\t\t\t\tyes = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(yes){\n\t\t\tfor(int j = i+1; j < n; j++){\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tif(c[i] != c[j]) continue;\n\t\t\t\t\n\t\t\t\tused[j] = true;\n\t\t\t\tbool no = false;\n\t\t\t\trep(k,G[j].size()){\n\t\t\t\t\tif(G[j][k] == i){\n\t\t\t\t\t\tno = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(!used[G[j][k]]){\n\t\t\t\t\t\tno = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!no){\n\t\t\t\t\tdfs(cnt+2);\n\t\t\t\t}\n\t\t\t\tused[j] = false;\n\t\t\t}\n\t\t}\n\t\tused[i] = false;\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%d\",&n),n){\n\t\tmemset(used,0,sizeof(used));\n\t\tans = 0;\n\t\trep(i,30) G[i].clear();\n\t\trep(i,n) scanf(\"%d%d%d%d\",x+i,y+i,r+i,c+i);\n\t\trep(i,n) for(int j = i+1; j < n; j++){\n\t\t\tif((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])<(r[i]+r[j])*(r[i]+r[j])){\n\t\t\t\tG[j].pb(i);\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nint n;\nbool G[25][25], visited[1<<24];\nchar dp[1<<24];\nvector<int> col[5];\n\nbool check(int i, int S){\n    rep(j, i)if(!(S>>j & 1) && G[j][i]) return false;\n    return true;\n}\n\nchar dfs(int S){\n    if(n - __builtin_popcount(S) <= 1) return 0;\n    if(visited[S]) return dp[S];\n    visited[S] = true;\n    dp[S] = 0;\n    rep(c, 4)if(col[c].size() >= 2){\n        rep(i, col[c].size()-1)if(!(S>>col[c][i] & 1) && check(col[c][i], S)){\n            For(j, i+1, col[c].size())if(!(S>>col[c][j] & 1) && check(col[c][j], S)){\n                chmax(dp[S], (char)(2 + dfs(S | (1<<col[c][i]) | (1<<col[c][j]))));\n            }\n        }\n    }\n    return dp[S];\n}\n\nvoid solve(){\n    int x[n], y[n], r[n], c[n];\n    rep(i, 4) col[i].clear();\n    rep(i, n){\n        scanf(\"%d%d%d%d\", &x[i], &y[i], &r[i], &c[i]);\n        --c[i];\n        col[c[i]].push_back(i);\n    }\n    rep(i, n)rep(j, n) G[i][j] = false;\n    rep(i, n)For(j, i+1, n){\n        if((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j])*(r[i]+r[j])){\n            G[i][j] = true;\n        }\n    }\n    \n    rep(i, 1<<n) visited[i] = false;\n    printf(\"%d\\n\", dfs(0));\n}\n\nint main(){\n    while(scanf(\"%d\", &n) && n){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint N, X[24], Y[24], R[24], C[24];\nint r[24], m[24];\nchar dp[16777216];\n\nint f(char n, int s) { return ((s & r[n]) & m[n]) == 0; }\n\nint main(void) {\n  m[0] = 0;\n  REP(i, 0, 23) m[i + 1] = m[i] | (1 << i);\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> X[i] >> Y[i] >> R[i] >> C[i];\n    REP(i, 0, 1 << N) dp[i] = -1;\n    REP(i, 0, N) r[i] = 0;\n    REP(i, 0, N) REP(j, 0, N) {\n      if(pow(R[i] + R[j], 2) > pow(X[i] - X[j], 2) + pow(Y[i] - Y[j], 2)) {\n        r[i] = r[i] | (1 << j);\n        r[j] = r[j] | (1 << i);\n      }\n    }\n    char ans = dp[(1 << N) - 1] = 0;\n    for(int s = (1 << N) - 1; s >= 0; s--) if(dp[s] != -1) {\n      ans = max(ans, dp[s]);\n      REP(i, 0, N) {\n        int mi = (1 << i);\n        if((~s & mi) || !f(i, s)) continue;\n        REP(j, i + 1, N) {\n          int mj = (1 << j);\n          if(C[i] != C[j] || (~s & mj) || !f(j, s)) continue;\n          int ns = ~(~s | mi | mj);\n          dp[ns] = dp[s] + 2;\n        }\n      }\n    }\n    cout << (int) ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    int n; cin >> n;\n    if (!n) break;\n    V<> x(n), y(n), r(n), c(n); for (int i = 0; i < n; ++i) cin >> x[i] >> y[i] >> r[i] >> c[i], --c[i];\n    V<bool> b(n, true);\n    int res = 0;\n    auto dfs = [&](const auto& dfs) -> void {\n      res = max(res, n - accumulate(begin(b), end(b), 0));\n      VV<> idx(4);\n      for (int i = n - 1; i >= 0; --i) if (b[i]) {\n        bool ok = true;\n        for (int j = 0; j < i; ++j) if (b[j]) {\n          if ((x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]) < (r[i] + r[j]) * (r[i] + r[j])) {\n            ok = false;\n            break;\n          }\n        }\n        if (ok) idx[c[i]].push_back(i);\n      }\n      for (auto&& v : idx) if (v.size() >= 2) {\n        if (v.size() & 1) {\n          for (int i : v) {\n            for (int j : v) if (j != i) b[j] = false;\n            dfs(dfs);\n            for (int j : v) if (j != i) b[j] = true;\n          }\n        } else {\n          for (int i : v) b[i] = false;\n          dfs(dfs);\n          for (int i : v) b[i] = true;\n        }\n      }\n    };\n    dfs(dfs);\n    cout << res << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nint N;\nint x[30], y[30], r[30], c[30];\nint overlap[30];\nchar dp[(1<<24)+1];\n\nint rec(int S) {\n  if (dp[S] >= 0) return dp[S];\n  int ret = 0;\n  // select lhs\n  for (int i = 0; i < N - 1; ++i) {\n    if (S >> i & 1) continue;\n    if (overlap[i] > S) continue;\n    // select rhs\n    for (int j = i+1; j < N; ++j) {\n      if ((S >> j & 1) || c[i] != c[j]) continue;\n      if (overlap[j] > S) continue;\n      // remove\n      ret = max(ret, rec(S|(1<<i)|(1<<j)) + 2);\n    }\n  }\n  return dp[S] = ret;\n}\n\nint solve() {\n  // check overlap\n  memset(overlap, 0, sizeof overlap);\n  for (int i = 1; i < N; ++i) {\n    int lapped = 0;\n    for (int j = 0; j < i; ++j) {\n      int dx = x[i] - x[j], dy = y[i] - y[j], dc = r[i] + r[j];\n      if (dx * dx + dy * dy < dc * dc) lapped |= (1 << j);\n    }\n    overlap[i] = lapped;\n  }\n  memset(dp, -1, sizeof dp);\n  return rec(0);\n}\n\nint main() {\n  while (scanf(\"%d\", &N), N) {\n    rep(i,N) scanf(\"%d%d%d%d\", x+i, y+i, r+i, c+i);\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint x[30], y[30], r[30], c[30], n, ans;\nbool memo[1<<24];\n// d[i][j] i?????????j????????£?????????1\nbool d[30][30];\nvoid dfs(ll m) {\n  if(memo[m]) return;\n  //cout << bitset<24>(m) << endl;\n  //???????????£?????????????????°???????????¨?????°??????\n  VI cnt[6];\n  REP(i, n) {\n    //i????????¨??????????????£??????continue\n    if(m>>i&1) continue;\n    bool flag = true;\n    REP(j, n) {\n      //j????????¨??????????????£??????continue\n      if(m>>j&1) continue;\n      if(d[i][j]) flag = false;\n    }\n    if(flag) cnt[c[i]].PB(i);\n  }\n\n  bool g = false;\n  FOR(i, 1, 5) if(cnt[i].size()>=2) g = true;\n  //????????£????????????\n  if(!g) {\n    int sum=0;\n    REP(i, n) {\n      if(m>>i&1) sum++;\n    }\n    ans = max(ans, sum);\n    memo[m] = true;\n    return;\n  }\n\n  FOR(i, 1, 5) {\n    //cout << \"i:\" << cnt[i].size() << endl;\n    if(cnt[i].size()<=1) continue;\n    REP(j, cnt[i].size()) REP(k, j) {\n      //cout << j << \":\" << k << endl;\n      ll tmp = m;\n      tmp |= 1<<cnt[i][j];\n      tmp |= 1<<cnt[i][k];\n      dfs(tmp);\n    }\n  }\n  memo[m] = true;\n  return;\n}\n\nsigned main(void)\n{\n  while(true) {\n    cin >> n;\n    if(!n) break;\n    REP(i, 30) REP(j, 30) d[i][j] = 0;\n    bool h = true;\n    REP(i, n) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n      for(int j=i-1; j>=0; --j) {\n        // ??????i??¨??????j???????????£??????????????????i???????????????j????????¨????????????\n        double dist = sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j])), rr = r[i] + r[j];\n        //cout << dist << \" \" << rr << endl;\n        if(dist < rr) d[i][j] = true, h = false;\n      }\n    }\n    /*REP(i, n) {\n      REP(j, n) {\n        cout << d[i][j] << \" \";\n      }\n      cout << endl;\n    }*/\n    ans = 0;\n    memset(memo,false,sizeof(memo));\n    dfs(0);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n,cnt_max;\nbool flag[1<<24];\n\nint hantei( long long int put, long long int remove ) {\n  if ( ( put ^ ( put & remove ) ) == 0 ) return 1;\n  return 0;\n}\n\nint saiki( vector<int> c, vector<long long int> put, long long int remove, int cnt ) {\n  if ( flag[remove] ) return 0;\n  flag[remove] = true;\n  for ( int i = 0; i < n-1; i++ ) {\n    if ( hantei( put[i], remove ) ) {\n      for ( int j = i+1; j < n; j++ ) {\n\tif ( hantei( put[j], remove ) && c[i] == c[j] ) {\n\t  put[i] += 1<<n;\n\t  put[j] += 1<<n;\n\t  saiki( c, put, remove + (1<<i) + (1<<j), cnt+2 );\n\t  put[i] -= 1<<n;\n\t  put[j] -= 1<<n;\n\t}\n      }\n    }\n  }\n  cnt_max = max( cnt_max, cnt );\n  return 0;\n}\n\nint main() {\n\n  while(true) {\n\n    cin >> n;\n    if ( n == 0 ) break;\n\n    vector<int> x,y,r,c;\n    vector<long long int> put;\n    int input1,input2,input3,input4;\n    for ( int i = 0; i < n; i++ ) {\n      cin >> input1 >> input2 >> input3 >> input4;\n      x.push_back(input1);\n      y.push_back(input2);\n      r.push_back(input3);\n      c.push_back(input4);\n      put.push_back(0);\n      for ( int j = 0; j < i; j++ ) {\n\tinput1 = x[i] - x[j];\n\tinput2 = y[i] - y[j];\n\tinput3 = r[i] + r[j];\n\tif ( input1*input1 + input2*input2 < input3*input3 ) put[i] += ( 1 << j );\n      }\n    }\n\n    for ( int i = 0; i < (1<<24); i++ ) {\n      flag[i] = false;\n    }\n    cnt_max = 0;\n    saiki( c, put, 0, 0 );\n    cout << cnt_max << endl;\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nusing namespace std;\nchar dp[(1<<24)];\nint n,x[24],y[24],r[24],c[24],s[24];\nint dist(int a,int b){return (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);}\n\nint check(int a,int b){\n  int ra=r[a]+r[b];\n  if(dist(a,b) < ra*ra)return 1;\n  else return 0;\n}\n\n\nint main(){\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    int i,j,k,ans=0;\n    for(i=0;i<n;i++)\n      scanf(\"%d %d %d %d\",&x[i],&y[i],&r[i],&c[i]);\n    for(i=0;i<n;i++){\n      s[i]=0;\n      for(j=i-1;j>=0;j--)s[i]+=(check(i,j)<<j);\n    }\n    memset(dp,-1,sizeof(dp));\n    dp[0]=0;\n    for(k=0;k<(1<<n);k++){\n      if(dp[k]==-1)continue;\n      if(ans<dp[k])ans=dp[k];\n      for(i=0;i<n;i++){\n\tif((k>>i&1)||(k&s[i])!=s[i])continue;\n\tfor(j=i+1;j<n;j++){\n\t  if(c[i]!=c[j]||(k>>j&1)||(k&s[j])!=s[j])continue;\n\t  int nk=k+(1<<i)+(1<<j);\n\t  if(dp[nk]<dp[k]+2)dp[nk]=dp[k]+2;\n\t}\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\n#define x real()\n#define y imag()\n#define pb push_back \ntypedef double D;\ntypedef complex<D> P;\ntypedef struct circle{\n\tP p;\n\tD r;\n} C;\n\nint rel[24];\nC c[24];\nvector<int> color[4];\nchar use[1<<24];\nint cmax;\n\nbool IC(C a,C b){\n\tD d=norm(a.p-b.p);\n\tD r=(a.r+b.r)*(a.r+b.r);\n\treturn d<r;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n, n){\n\t\tcmax=0;\n\t\tfor(int i=0;i<4;i++){\n\t\t\twhile(!color[i].empty())\n\t\t\t\tcolor[i].pop_back();\n\t\t}\n\t\tfor(int i=0;i<24;i++)\n\t\t\trel[i]=0;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tmp;\n\t\t\tcin >> c[i].p.x >> c[i].p.y >> c[i].r;\n\t\t\tcin >> tmp;\n\t\t\tcolor[tmp-1].pb(i);\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tif(IC(c[i],c[j]))\n\t\t\t\t\trel[i]|=1<<j;\n\t\t\t}\n\t\t}\t\t\n\t\tmemset(use,-1,sizeof(use));\n\t\tuse[0]=0;\n\t\tfor(int u=0;u<(1<<n);u++){\n\t\t\tif(use[u]==-1)\n\t\t\t\tcontinue;\n\t\t\tcmax=max(cmax,(int)use[u]);\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tfor(int j=0;j<color[i].size();j++){\n\t\t\t\t\tif(u >>color[i][j]&1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(rel[color[i][j]]&~u)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor(int k=j+1;k<color[i].size();k++){\n\t\t\t\t\t\tif(u >>color[i][k]&1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif(rel[color[i][k]]&~u)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tuse[u|(1<<color[i][j])|(1<<color[i][k])]=use[u]+2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cmax << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nshort dp[(1<<24)+1];\nint main(){\n  int n;;\n  while(cin>>n,n){\n    int col[n],ans=0;\n    double r[n],x[n],y[n];\n    for(int i=0;i<n;i++)\n      cin>>x[i]>>y[i]>>r[i]>>col[i];\n    memset(dp,0,sizeof(dp));\n    dp[((1<<n)-1)]=1;\n  \n    for(int i=1<<n;i>=0;i--)if(dp[i])\n\tfor(int j=n-1;j>=0;j--)if((1<<j)&i)\n\t    for(int k=j-1;k>=0;k--)\n\t      if(((1<<k)&i)&&col[j]==col[k]){\n\t\tfor(int l=j-1;l>=0;l--)if((i&(1<<l))&&abs(sqrt((x[l]-x[j])*(x[l]-x[j])+(y[l]-y[j])*(y[l]-y[j])))<r[j]+r[l])goto L;\n\t        for(int l=k-1;l>=0;l--)if((i&(1<<l))&&abs(sqrt((x[l]-x[k])*(x[l]-x[k])+(y[l]-y[k])*(y[l]-y[k])))<r[k]+r[l])goto L;\n\t\tdp[i-(1<<j)-(1<<k)] =dp[i]+2;\n\t\tans=max(ans,(int)dp[i-(1<<j)-(1<<k)]);\n\t      L:;\n\t      }\n    if(ans)cout<<ans-1<<endl;\n    else cout<<0<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cstdio>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define fr first\n#define sc second\n#define mp make_pair\n\ntypedef long long int64;\ntypedef pair< int, int > iP;\ntypedef pair< iP, int > iiP;\n\nconst int INF = 2 << 28;\nconst double EPS = 1e-10;\n\nstruct disk {\n    int x, y, r, color;\n};\n\nint n, dp[2 << 24];\nvector< disk > disks;\n\nint rec(int used) {\n    if(~dp[used]) return dp[used];\n    vector< int > idx;\n    for(int i = n - 1; i >= 0; i--) {\n        if(!(used >> i & 1)) {\n            bool judge = true;\n            for(int j = i - 1; j >= 0; j--) {\n                if(!(used >> j & 1)) {\n                    if(pow(abs(disks[i].x - disks[j].x), 2) + pow(abs(disks[i].y - disks[j].y), 2) < pow(disks[i].r + disks[j].r, 2))\n                        judge = false;\n                }\n            }\n            if(judge) idx.push_back(i);\n        }\n    }\n\n    int ret = 0;\n    if(idx.size() < 2) return dp[used] = 0;\n    else {\n        for(int i = 0; i < idx.size(); i++) {\n            for(int j = i + 1; j < idx.size(); j++) {\n                if(disks[idx[i]].color == disks[idx[j]].color) {\n                    ret = max(ret, rec(used | (1 << idx[i] | 1 << idx[j])) + 2);\n                }\n            }\n        }\n        return dp[used] = ret;\n    }\n}\n\nint main() {\n\n    while(cin >> n, n) {\n        for(int i = 0; i < n; i++) {\n            int x, y, c, r; cin >> x >> y >> r >> c;\n            disks.push_back((disk){x, y, r, c});\n        }\n\n        memset(dp, -1, sizeof(dp));\n        cout << rec(0) << endl;\n        disks.clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint main(){\n  int n;\n  cin >> n;\n  while(n!=0){\n    int sum=0;\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    int f=0;\n    int on[30]={};\n    //int cc[5]={};\n    vector<int> cc[5];\n    while(f==0){\n      f=1;\n      /*\n      for(i=0;i<24;i++) on[i]=0;\n      for(i=0;i<v.size();i++){\n\tfor(j=i+1;j<v.size();j++){\n\t  if(ch(v[i],v[j])==1) on[j]=1;\n\t}\n      }\n      for(i=0;i<5;i++) cc[i]=0;\n      for(i=0;i<v.size();i++){\n\tif(on[i]==0) cc[v[i].c]++;\n      }\n      */\n      int ff=0;\n      //while(ff==0){\n\tff=1;\n\tfor(i=0;i<30;i++) on[i]=0;\n\tfor(i=0;i<5;i++) cc[i].clear();\n\tfor(i=0;i<v.size();i++){\n\t  for(j=i+1;j<v.size();j++){\n\t    if(ch(v[i],v[j])==1) on[j]=1;\n\t  }\n\t}\n\tfor(i=0;i<v.size();i++){\n\t  if(on[i]==0) cc[v[i].c].push_back(i);\n\t}\n\tfor(i=1;i<5;i++){\n\t  if(cc[i].size()>0&&cc[i].size()%2==0){\n\t    for(j=cc[i].size()-1;j>=0;j--){\n\t      v.erase(v.begin()+cc[i][j]);\n\t      ff=0;\n\t      f=0;\n\t    }\n\t  }\n\t}\n\t//}\n      \n      for(i=1;i<5;i++){\n\tk=0;\n\tfor(j=v.size()-1;j>=0;j--){\n\t  if(on[j]==0&&v[j].c==i){\n\t    if((cc[i].size()/2)*2>k) {\n\t      //cout << v[j].id << \" \";\n\t      v.erase(v.begin()+j);\n\t      k++;\n\t      f=0;\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout << n-v.size() << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct circle\n{\n    int x, y, r, c;\n    circle(int _x, int _y, int _r, int _c) : x(_x), y(_y), r(_r), c(_c) {}\n};\n\nint N;\nint res = 0;\nvoid dfs(int sum, vector<int> in, int state, vector<bool> &used, vector<circle> &cs, vector<vector<int>> &G)\n{\n    int flag = 1;\n    if (used[state])\n    {\n        return;\n    }\n    for (int i = 0; i < N; i++)\n    {\n        if (state & (1 << i))\n            continue;\n        for (int j = i + 1; j < N; j++)\n        {\n            if (state & (1 << j))\n                continue;\n\n            if (in[i] == 0 && in[j] == 0 && cs[i].c == cs[j].c)\n            {\n                auto in2 = in;\n                auto s = state;\n                flag = 0;\n                for (int nv : G[i])\n                {\n                    in2[nv]--;\n                }\n                for (int nv : G[j])\n                {\n                    in2[nv]--;\n                }\n                s |= (1 << i);\n                s |= (1 << j);\n                dfs(sum + 2, in2, s, used, cs, G);\n            }\n        }\n    }\n    if (flag)\n        res = max(res, sum);\n\n    used[state] = 1;\n}\n\nint main()\n{\n    while (cin >> N, N)\n    {\n        res = 0;\n        vector<circle> circles(N, circle(0, 0, 0, 0));\n        for (int i = 0; i < N; i++)\n        {\n            int x, y, r, c;\n            cin >> x >> y >> r >> c;\n            circles[i] = circle(x, y, r, c);\n        }\n        vector<vector<int>> G(N, vector<int>());\n        vector<int> in(N);\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = i + 1; j < N; j++)\n            {\n                auto c1 = circles[i];\n                auto c2 = circles[j];\n                if ((c1.r + c2.r) * (c1.r + c2.r) > ((c1.x - c2.x) * (c1.x - c2.x) + (c1.y - c2.y) * (c1.y - c2.y)))\n                {\n                    G[i].push_back(j);\n                    in[j]++;\n                }\n            }\n        }\n        vector<bool> used(1 << N);\n        dfs(0, in, 0, used, circles, G);\n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvvi color(4);\n\t\tvi x(n), y(n), r(n), c(n);\n\t\tREP(i, n) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t\tc[i]--;\n\t\t\tcolor[c[i]].push_back(i);\n\t\t}\n\t\tvi b(1 << n, 0);\n\t\tb[(1 << n) - 1] = 1;\n\t\tvvi g(n);\n\t\tvi d(n, 0);\n\t\tREP(i, n)FOR(j, i + 1, n) {\n\t\t\tif ((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) < (r[i] + r[j])*(r[i] + r[j])) {\n\t\t\t\tg[i].push_back(j);\n\t\t\t\td[j]++;\n\t\t\t}\n\t\t}\n\t\tqueue<int> q;\n\t\tq.push((1 << n) - 1);\n\t\twhile (!q.empty()) {\n\t\t\tint bit = q.front(); q.pop();\n\t\t\n\t\t\tvi c = d;\n\t\t\tREP(i, n) {\n\t\t\t\tif ((bit&(1 << i)) == 0) {\n\t\t\t\t\tREP(j, g[i].size()) {\n\t\t\t\t\t\tc[g[i][j]]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(k, 4)REP(i, color[k].size())FOR(j, i + 1, color[k].size()) {\n\t\t\t\tif ((bit&(1 << color[k][i])) && (bit&(1 << color[k][j]))&&c[color[k][i]]==0&&c[color[k][j]]==0) {\n\t\t\t\t\tif (b[bit ^ (1 << color[k][i]) ^ (1 << color[k][j])] == 0)q.push(bit ^ (1 << color[k][i]) ^ (1 << color[k][j]));\n\t\t\t\t\tb[bit ^ (1 << color[k][i]) ^ (1 << color[k][j])] = 1;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tREP(i, 1 << n) {\n\t\t\tif (b[i] == 0)continue;\n\t\t\tint cnt = n;\n\t\t\tREP(j, n)if (i&(1 << j))cnt--;\n\t\t\tchmax(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <numeric>\n#include <iostream>\n\nusing namespace std;\n\nint n;\n\nvector<int> x, y, r, c;\n\nint distsqr(int x1, int y1, int x2, int y2)\n{\n\treturn (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n}\n\nbool finds(vector<int> x, int s)\n{\n\tfor (int i = 0; i < x.size(); i++)\n\t{\n\t\tif (x[i] == s)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &n);\n\n\t\tif (n == 0) { break; }\n\n\t\tx = vector<int>(n);\n\t\ty = vector<int>(n);\n\t\tr = vector<int>(n);\n\t\tc = vector<int>(n);\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &x[i]);\n\t\t\tscanf(\"%d\", &y[i]);\n\t\t\tscanf(\"%d\", &r[i]);\n\t\t\tscanf(\"%d\", &c[i]);\n\t\t}\n\n\t\tvector<int> startcpp(n); iota(startcpp.begin(), startcpp.end(), 0);\n\n\t\tqueue<vector<int> > que; que.push(startcpp);\n\n\t\tmap<vector<int>, int> d; d[startcpp] = 1;\n\n\t\tint ret = 0;\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tvector<int> v1 = que.front(); que.pop();\n\n\t\t\tret = d[v1] - 1;\n\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tif (c[i] == c[j] && finds(v1, i) && finds(v1, j))\n\t\t\t\t\t{\n\t\t\t\t\t\tbool ok = true;\n\n\t\t\t\t\t\tfor (int k = i + 1; k < n; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (finds(v1, k))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint dist = distsqr(x[i], y[i], x[k], y[k]);\n\n\t\t\t\t\t\t\t\tif (dist < (r[i] + r[k]) * (r[i] + r[k]))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (int k = j + 1; k < n; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (finds(v1, k))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint dist = distsqr(x[j], y[j], x[k], y[k]);\n\n\t\t\t\t\t\t\t\tif (dist < (r[j] + r[k]) * (r[j] + r[k]))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ok)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvector<int> v2;\n\n\t\t\t\t\t\t\tfor (int k = 0; k < v1.size(); k++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (v1[k] != i && v1[k] != j)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tv2.push_back(k);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\td[v2] = d[v1] + 1;\n\n\t\t\t\t\t\t\tque.push(v2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<map>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 24;\nconst double eps = 1e-10;\ntypedef complex<double> P;\nclass st{\npublic:\n  P a;\n  double r;\n  int color;\n  int id;\n  bool operator<(const st & a)const{\n    if (color != a.color)return color < a.color;\n    return id < a.id;\n  }\n};\n\nint over[N];\n\nint is_intersected_circle(P a,P b,double r1,double r2){\n  double d=abs(a-b);\n  if (d < eps && abs(r1-r2) < eps)return 3;\n  if (d+r2 < r1)return 0;\n  if (d+r1 < r2)return 1;\n  if (d > r1+r2) return 4;\n  if (abs((r1+r2)-d) < eps)return 4;\n  return 2;\n}\n\nvector<int> edge[N];\nshort dp[(1<<N)];\nint colorstart[5];\n\nshort search(int state,st *in,int n){\n  if (state == (1<<n))return 0;\n  short &ret = dp[state];\n  if (ret == -1){\n    ret=0;\n    //color1\n    rep(k,4){\n      REP(i,colorstart[k],colorstart[k+1]){\n        int now=in[i].id;\n        if (((1<<now)&state) != 0)continue;\n        if ((over[now]&state) == over[now]);\n        else continue;\n        REP(j,i+1,colorstart[k+1]){\n          int next=in[j].id;\n          if (((1<<next)&state) != 0)continue;\n          if ((over[next]&state) == over[next]);\n          else continue;\n          //cout <<\"remove \" << now <<\" \" << next << endl;\n          ret=max(ret,(short)(2+search(state|(1<<now)|(1<<next),in,n)));\n        }\n      }\n    }\n  }\n  return ret;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    rep(i,(1<<n))dp[i]=-1;\n    rep(i,n)edge[i].clear();\n    st in[n];\n    rep(i,n){\n      cin>>in[i].a.real()>>in[i].a.imag()>>in[i].r>>in[i].color;\n      in[i].id=i;\n    }\n    sort(in,in+n);\n    rep(i,n){\n      rep(j,n){\n        if (in[i].id <= in[j].id)continue;\n        int tmp=is_intersected_circle(in[i].a,in[j].a,in[i].r,in[j].r);\n        if (tmp == 0 || tmp == 1 || tmp == 2 || tmp == 3){\n          edge[in[i].id].push_back(in[j].id);\n        }\n      }\n    }\n\n    rep(i,n){\n      int now=in[i].id;\n      over[now]=0;\n      rep(j,edge[now].size()){\n        int next=edge[now][j];\n        over[now]|=(1<<next);\n        //cout <<next << \" is over \" << now << endl;\n      }\n      //cout << now <<\" hoge \" << over[now] << endl;\n    }\n    rep(i,5)colorstart[i]=n;\n    rep(i,n){\n      colorstart[in[i].color-1]=min(colorstart[in[i].color-1],i);\n    }\n\n    //rep(i,5)cout << colorstart[i] << \" \";cout << endl;\n    cout << search(0,in,n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,n1,n2) for(int i=n1;i<n2;i++)\n#define bFOR(i,n1,n2) for(int i=n1;i>=n2;i--)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\ntypedef long long int ll;\ntypedef pair<ll,ll> Pi;\nconst int INF=(ll)(1LL<<30)-1;\nconst double INFd=100000000000.0;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\nint dx[4]={0,1,0,-1},dy[4]={-1,0,1,0};\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nint n;\nint x[25],y[25],r[25],c[25];\nint max_del;\nint isVisit[1<<24];\nbool can_delete(int t,int sid){\n\tbool ret=1;\n\tfor(int i=0;i<t;i++){\n\t\tif(!(sid>>i&1)){\n\t\t\tint dis=(x[i]-x[t])*(x[i]-x[t])+(y[i]-y[t])*(y[i]-y[t]);\n\t\t\tif(dis<(r[i]+r[t])*(r[i]+r[t]))ret=0;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint num_deleted(int sid){\n\tint ret=0;\n\twhile(sid){\n\t\tif(sid&1)ret++;\n\t\tsid=sid>>1;\n\t}\n\treturn ret;\n}\n\nvoid dfs(int sid){\n\tmax_del=max(max_del,num_deleted(sid));\n\tfor(int i=0;i<n-1;i++){\n\t\tif(((!(sid>>i&1))&&can_delete(i,sid))){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\n\t\t\t\t//cout<<sid<<endl;\n\t\t\t\tif((!(sid>>j&1))&&can_delete(j,sid)){\n\t\t\t\t\tif(c[i]==c[j]){\n\t\t\t\t\t\tint newsid=(sid|1<<i|1<<j);\n\t\t\t\t\t\tif(isVisit[newsid]==0){\n\t\t\t\t\t\t\tisVisit[newsid]=1;\n\t\t\t\t\t\t\tdfs(newsid);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tmax_del=0;\n\t\tREP(i,n)\n\t\t\tcin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\t/*for(int i=0;i<n;i++){\n\t\t\t\tcout<<can_delete(i)<<endl;\n\t\t}*/\n\t\tREP(i,1<<24){\n\t\t\tisVisit[i]=0;\n\t\t}\n\t\tisVisit[0]=1;\n\t\tdfs(0);\n\t\tcout<<max_del<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nbool visited[1<<24];\n\nclass Data{\npublic:\n\tint x;\n\tint y;\n\tint r;\n\tint c;\n\tData(int _x,int _y,int _r,int _c){\n\t\tx = _x;\n\t\ty = _y;\n\t\tr = _r;\n\t\tc = _c;\n\t}\n};\n\n\n\nbool check(const vector<Data>& d,int a,int b,int visited){\n\t//true then erase\n\tif(d[a].c != d[b].c) return false;\n\tfor(int i=0;i<a;i++){\n\t\tif(visited & (1<<i)) continue;\n\t\tif((d[a].x-d[i].x)*(d[a].x-d[i].x)+(d[a].y-d[i].y)*(d[a].y-d[i].y) < (d[a].r + d[i].r)*(d[a].r + d[i].r)) return false;\n\t}\n\tfor(int i=0;i<b;i++){\n\t\tif(visited & (1<<i)) continue;\n\t\tif((d[b].x-d[i].x)*(d[b].x-d[i].x)+(d[b].y-d[i].y)*(d[b].y-d[i].y) < (d[b].r + d[i].r)*(d[b].r + d[i].r)) return false;\n\t}\n\n\treturn true;\n}\n\nvoid dfs(const vector<Data>& nodes,int got){\n\tvisited[got] = true;\n\n\tfor(int i=0;i<nodes.size();i++){\n\t\tfor(int j=i+1;j<nodes.size();j++){\n\t\t\tif(got & (1<<i) || got & (1<<j)) continue;\n\t\t\tif(check(nodes,i,j,got)){\n\t\t\t\tint tmp = got;\n\t\t\t\ttmp |= (1<<i);\n\t\t\t\ttmp |= (1<<j);\n\n\t\t\t\tif(visited[tmp]) continue;\n\t\t\t\tdfs(nodes,tmp);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tmemset(visited,0,sizeof(visited));\n\n\t\tint x,y,r,c;\n\t\tvector<Data> nodes; \n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&x,&y,&r,&c);\n\t\t\tnodes.push_back(Data(x,y,r,c));\n\t\t}\n\n\t\tdfs(nodes,0);\n\n\t\tint res = 0;\n\t\tfor(int S=(1<<n)-1;S>=0;S--){\n\t\t\tif(visited[S]){\n\t\t\t\tint tmp=0;\n\t\t\t\tfor(int i=0;i<n;i++) tmp += (bool)((1<<i) & S);\n\t\t\t\tres = max(tmp,res);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "int n; //枚数\nint x[25],y[25],r[25],c[25]; //円盤\nint b[25]; //各円盤の上に重なっている円盤（ビット管理）\n\n//円盤iと円盤jが重なっているかの判定\nbool intersects(int i,int j){\n  int dist1 = pow(x[i]-x[j],2) + pow(y[i]-y[j],2);\n  int dist2 = pow(r[i]+r[j],2);\n\n  return dist2 > dist1;\n}\n\n//DP用\nchar dp[1<<24];\n\nint main(void){\n  while(scanf(\"%d\",&n),n){\n    rep(i,n){\n      scanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n\n      //円盤iの上に重なっている円盤を全て探す\n      b[i] = 0;\n      rep(j,i) if(intersects(i,j)) b[i] |= (1<<j);\n    }\n\n    int ans = 0;\n    int to = (1<<n);\n    memset(dp,-1,sizeof(dp));\n    dp[0] = 0;\n\n    rep(i,to){\n      if(dp[i] == -1) continue;\n\n      ans = max(ans,(int)dp[i]);\n\n      //消せる円盤のペア(j,k)を探す\n      rep(j,n-1){\n        //すでに円盤jは消えている or 円盤jの上の円盤が邪魔して消せない\n        if((i & (1<<j)) != 0 || (i & b[j]) != b[j]) continue;\n\n        REP(k,j+1,n){\n          //jとkの色が違う or すでに円盤kは消えている or 円盤kの上の円盤が邪魔\n          if(c[j] != c[k] || (i & (1<<k)) != 0 || (i & b[k]) != b[k]) continue;\n\n          int next = i | (1<<j) | (1<<k); //next = 円盤jとkを消した状態(ビット管理)\n          dp[next] = max((int)dp[next],dp[i]+2);\n        }\n      }\n    }\n\n    printf(\"%d\\n\",ans);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n#include <ctime>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, string> Ps;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF = 1 << 27;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\nconst int CLK = CLOCKS_PER_SEC;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nint n;\nint x[24];\nint y[24];\nint r[24];\nint c[24];\nint memo[1 << 24];\n\nbool intersect(int i, int j){\n  int dx = x[i] - x[j];\n  int dy = y[i] - y[j];\n  if(dx * dx + dy * dy < (r[i] + r[j]) * (r[i] + r[j])) return true;\n  else return false;\n}\n\nint dfs(int state){\n\tif(memo[state] >= 0){\n\t\treturn memo[state];\n\t}else{\n\t\tmemo[state] = 0;\n\t\tbool top[24];\n\t\tfill(top, top + 24, true);\n\t\trep(i,n){\n\t\t\trep(j,i){\n\t\t\t\tif((state&(1<<i)) && (state&(1<<j)) &&intersect(i,j)) top[i]=false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < i; j++){\n\t\t\t\tif( (state&(1<<i)) && (state&(1<<j)) && top[i] && top[j] && c[i]==c[j]){\n\t\t\t\t\tmemo[state] = max(memo[state], 2 + dfs(state ^ (1 << i) ^ (1 << j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn memo[state];\n\t}\n}\n  \n\nint main(){\n  while(cin >> n && n){\n    memset(memo, -1, sizeof(memo));\n    rep(i,n)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    cout<<dfs((1<<n)-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstruct po {int x,y,r,g;};\nstruct popo{vector <po> c[5];};\nint ans =0;\n\nbool check(po a,popo c){\n  if(a.g==10000)return false;\n  for(int i=0;i<4;i++)\n    for(int j=0;j<c.c[i].size();j++){\n      po b = c.c[i][j];\n      if(a.g>b.g && (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y) < (a.r+b.r)*(a.r+b.r)) return false;\n    }\n  return true;\n}\n\nint cnt;\nvoid saiki(popo c,int sum,int i){\n  cnt++;\n  if(cnt>1000000/2)return;\n  vector <int> J;\n  for(int j=0;j<(int)c.c[i].size();j++)if(check(c.c[i][j],c)==true)J.push_back(j);\n  for(int j=0;j<J.size();j++)\n    for(int k=j+1;k<J.size();k++){\n      int a,b;\n      a=c.c[i][J[j]].g;\n      b=c.c[i][J[k]].g;\n      c.c[i][J[j]].g = c.c[i][J[k]].g = 10000;\n      for(int l=0;l<4;l++)saiki(c,sum+2,l);\n      c.c[i][J[j]].g=a;\n      c.c[i][J[k]].g=b;\n    }\n  ans = max(ans,sum);\n}\n\nint main(){\n  while(1){\n    int n;\n    cin>>n;\n    if(n==0)break;\n    popo c;\n    int x,y,r,col;\n    for(int i=0;i<n;i++)cin >>x>>y>>r>>col, c.c[--col].push_back((po){x,y,r,i});\n    ans = 0;\n    cnt=0;\n    for(int i=0;i<4;i++)saiki(c,0,i);\n    cout << ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,x[25],y[25],r[25],c[25],ans=0;\nbool memo[(1<<24)]={};\n\nbool check(int a,int b){\n  int dis=(x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);\n  if(((r[a]+r[b])*(r[a]+r[b]))<=dis)return false;\n  return true;\n} \n\nbool top(int now,int bits){\n  for(int i=0;i<now;i++){\n    if((bits>>i)%2 && check(i,now))return false;\n  }\n  return true;\n}\n\nvoid dfs(int bits,int sum){\n  ans=max(sum,ans);\n  //cout<<ans<<\" \"<<bits<<endl;\n  for(int i=0;i<n;i++){\n    if((bits>>i)%2 && top(i,bits)){\n      for(int j=i+1;j<n;j++){\n\tif(c[i]==c[j] && (bits>>j)%2 && top(j,bits)){\n\t  int nbits=bits-((1<<i)+(1<<j));\n\t  if(!memo[nbits]){\n\t    memo[nbits]=true;\n\t    dfs(nbits,sum+2);\n\t    memo[nbits]=false;\n\t  }\n\t}\n      }\n    }\n  }\n  return;\n}\n\nint main()\n{\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    ans=0;\n    for(int i=0;i<(1<<24);i++)memo[i]=false;\n    memo[(1<<n)-1]=true;\n    dfs((1<<n)-1,0);\n    cout<<ans<<endl; \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//And Then. How Many Are There?\n#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24], y[24], r[24], c[24];\nint bit[24]; //??????????????¨???????????????\nshort int dp[1<<24];\n\n//a??¨b???????????????true\nbool dis(int i, int j){\n  return (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j])*(r[i]+r[j]);\n}\n\n//b:??????????????????????????¨???????????????\nint solve(int b){\n  if(dp[b]!=-1)return dp[b];\n\n  int mx=0;\n  for(int i=0; i<n-1; i++){//1???????????????\n    if((bit[i]&b)!=bit[i])continue;//??????????????????\n    if((b&(1<<i))!=0)continue;//??¢??????????????????\n   \n    for(int j=i+1; j<n; j++){//2???????????????\n      if((bit[j]&b)!=bit[j])continue;//??????????????????\n      if((b&(1<<j))!=0)continue;//??¢??????????????????\n      if(c[i] != c[j])continue;//????????????\n\n      mx = max(mx, solve(b|(1<<i)|(1<<j))+2);\n    }\n  }\n  return dp[b]=mx;\n}\n\nint main(){\n  while(cin >> n, !(n==0)){\n    memset(bit, 0, sizeof(bit));\n    memset(dp, -1, sizeof(dp));\n    for(int i=0; i<n; i++){\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n      for(int j=0; j<i; j++)if(dis(i, j))bit[i] = bit[i]|(1<<j);\n    }\n    cout<<solve(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\nconst double EPS = 1e-7;\n\n//2点間の距離\ndouble dist(double x1,double y1,double x2,double y2){\n    return sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n}\nlong long dist2(long long x1, long long y1, long long x2, long long y2){\n   return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n}\n\nint bitnum(int n){\n    int ret = 0;\n    while(n > 0){\n        ret += (n & 1); n >>= 1;\n    }\n    return ret;\n}\n\nbool used[1LL << 24];\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    while(cin >> n, n){\n        vector<double> x(n), y(n), r(n);\n        vector<int> c(n);\n        vector<int> d[4]; \n        rep(i, 0, n){\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n            c[i]--;\n            d[c[i]].push_back(i);\n        }\n        bool f[25][25] = {};\n        rep(i, 0, n){\n            rep(j, i + 1, n){\n                double tmp = dist(x[i], y[i], x[j], y[j]);\n                // cout << tmp << endl;\n                if(tmp < r[i] + r[j] - EPS){\n                    f[i][j] = true;\n                }\n            }\n        }\n        int ans = 0;\n        memset(used, false, sizeof(used));\n        queue<int> q;\n        q.push(0);\n        used[0] = true;\n        while(!q.empty()){\n            int mask = q.front(); q.pop();\n            ans = max(ans, bitnum(mask));\n            rep(k, 0, 4){\n                rep(i, 0, d[k].size()){\n                    int x = d[k][i];\n                    if(mask & (1LL << x)) continue; \n                    bool flag = false;                   \n                    rep(j, 0, x){\n                        int z = j;\n                        if(!(mask & (1LL << z)) && f[z][x]){\n                            flag = true; break;\n                        } \n                    }\n                    if(flag) continue;\n                    rep(j, i + 1, d[k].size()){\n                        int y = d[k][j];\n                        if(mask & (1LL << y)) continue;\n                        bool flag1 = false;\n                        rep(l, 0, y){\n                            int u = l;\n                            if(!(mask & (1LL << u)) && f[u][y]){\n                                flag1 = true; break;\n                            }\n                        }\n                        if(flag1) continue;\n                        int nxt = mask | (1LL << x) | (1LL << y);\n                        if(used[nxt]) continue;\n                        used[nxt] = true;\n                        q.push(nxt);\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<vector>\nstruct S{int c,f,x,y,r;}s[24];\nint A(int x){return x*x;}\nchar m[1<<24];\nint n;\nint F(int f)\n{\n\tif(m[f]>=0)return m[f];\n\tstd::vector<int>v[5];\n\tint i,j,k,r=0,t;\n\tfor(i=0;i<n;++i)if((f&(1<<i))&&!(s[i].f&f))v[s[i].c].push_back(i);\n\tfor(k=1;k<5;++k)\n\t\tfor(i=0,t=v[k].size();i<t;++i)\n\t\t\tfor(j=i+1;j<t;++j)\n\t\t\t\tr+=2+F(f&~(1<<v[k][i])&~(1<<v[k][j]));\n\treturn m[f]=r;\n}\nint main()\n{\n\tint i,j;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tmemset(m,-1,sizeof(m));\n\t\tmemset(s,0,sizeof(s));\n\t\tfor(i=0;i<n;++i)scanf(\"%d%d%d%d\",&s[i].x,&s[i].y,&s[i].r,&s[i].c);\n\t\tfor(i=0;i<n;++i)for(j=i+1;j<n;++j)if(A(s[i].x-s[j].x)+A(s[i].y-s[j].y)<A(s[i].r+s[j].r))s[j].f|=1<<i;\n\t\tprintf(\"%d\\n\",F((1<<n)-1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nint sq(int a) { return a*a; }\n\nint bitcount(int a) {\n    int c = 0;\n    while (a) c++, a&=a-1;\n    return c;\n}\n\nint n, x[30], y[30], r[30], c[30];\n\nbool conf(int i, int j) {\n    return sq(r[i]+r[j]) > sq(x[i]-x[j])+sq(y[i]-y[j]);\n}\n\nmap<int, int> memo;\n\nint rec(int b) {\n    if (memo.count(b)) return memo[b];\n    bool f[30];\n    rep (i, n) if ((b&(1<<i)) == 0) {\n        f[i] = true;\n        rep (j, i) if ((b&(1<<j)) == 0 && conf(i, j)) f[i] = false;\n    }\n    int ans = bitcount(b);\n    rep (i, n) if ((b&(1<<i)) == 0 && f[i]) {\n        rep (j, i) if ((b&(1<<j)) == 0 && f[j] && c[i] == c[j]) {\n            ans = max(ans, rec(b|(1<<i)|(1<<j)));\n        }\n    }\n    return memo[b] = ans;\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d\", &n);\n        if (n == 0) return 0;\n        rep (i, n) scanf(\"%d%d%d%d\", x+i, y+i, r+i, c+i);\n        memo.clear();\n        printf(\"%d\\n\", rec(0));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nbool cross(int x1,int y1,int r1,int x2,int y2,int r2){\n\tif((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)<(r1+r2)*(r1+r2))return true;\n\treturn false;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t\n\twhile(cin>>N,N){\n\t\tvector<int>x(N);\n\t\tvector<int>y(N);\n\t\tvector<int>r(N);\n\t\tvector<int>c(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\t}\n\t\tbitset<1024*1024*4*4>bs;\n\t\tbs.flip(0);\n\t\tfor(int i=0;i<1<<N;i++){\n\t\t\tif(!bs.test(i))continue;\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tif((i>>j)&1)continue;\n\t\t\t\tbool fed=false;\n\t\t\t\tfor(int k=0;k<j;k++){\n\t\t\t\t\tif((i>>k)&1)continue;\n\t\t\t\t\tfed|=cross(x[j],y[j],r[j],x[k],y[k],r[k]);\n\t\t\t\t}\n\t\t\t\tif(fed)continue;\n\t\t\t\tfor(int k=j+1;k<N;k++){\n\t\t\t\t\tif((i>>k)&1)continue;\n\t\t\t\t\tif(c[k]!=c[j])continue;\n\t\t\t\t\tbool sed=false;\n\t\t\t\t\tfor(int l=0;l<k;l++){\n\t\t\t\t\t\tif((i>>l)&1)continue;\n\t\t\t\t\t\tsed|=cross(x[k],y[k],r[k],x[l],y[l],r[l]);\n\t\t\t\t\t}\n\t\t\t\t\tif(sed)continue;\n\t\t\t\t\tbs.set(i|(1<<j)|(1<<k));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<1<<N;i++){\n\t\t\tif(!bs.test(i))continue;\n\t\t\tint box=0;\n\t\t\tfor(int j=0;j<N;j++)box+=(i>>j)&1;\n\t\t\tans=max(ans,box);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\n\nclass state{\npublic:\n    P p;\n    double r;\n    int c;\n};\n\nbool onCircle(state a, state b){\n    return (abs(a.p-b.p) < a.r+b.r);\n}\n\nshort int a[1<<24];\nint n;\nstate v[24];\nint ans, over[24];\n\nvoid check(int pos){\n    int c = 0;\n    for(int i=0;i<n;i++){\n        if((pos & (1<<i)) == 0 && (c & (1<<i)) == 0){\n            c |= over[i];\n            int c2 = c;\n            for(int j=i+1;j<n;j++){\n                if((pos & (1<<j)) == 0 && (c2 & (1<<j)) == 0 && v[i].c == v[j].c){\n                    int next = pos | (1<<i) | (1<<j);\n                    if(a[next] < a[pos] + 2){\n                        a[next] = a[pos] + 2;\n                        ans = max((short int)ans,a[next]);\n                        check(next);\n                    }\n                }\n                if((pos & (1<<j)) == 0) c2 |= over[j];\n            }\n        }\n    }\n}\n\nint main(){\n    while(cin >> n && n){\n        fill(over,over+n,0);\n        fill(a,a+(1<<n),0);\n        ans = 0;\n        for(int i=0;i<n;i++){\n            double x,y;\n            cin >> x >> y >> v[i].r >> v[i].c;\n            v[i].p = P(x,y);\n        }\n\n        for(int i=0;i<n;i++)\n            for(int j=0;j<n;j++)\n                if(onCircle(v[i],v[j]))\n                    over[i] |= (1<<j);\n\n        check(0);\n\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define sq(a) ((a) * (a))\n\nint n;\nint x[24], y[24], r[24], c[24];\nint s[24];\nchar dp[1 << 24];\n\nint calc(int bit)\n{\n\tif (~dp[bit]) return dp[bit];\n\tint res = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tif (bit & (1 << i)) continue;\n\t\tif (s[i] & ~bit) continue;\n\t\tfor (int j = 0; j < i; j++){\n\t\t\tif (bit & (1 << j)) continue;\n\t\t\tif (c[i] != c[j]) continue;\n\t\t\tif (s[j] & ~bit) continue;\n\t\t\tres = max(res, 2 + calc(bit | (1 << i) | (1 << j)));\n\t\t}\n\t}\n\treturn dp[bit] = res;\n}\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\tmemset(s, 0, sizeof(s));\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < i; j++){\n\t\t\t\tif (sq(x[i] - x[j]) + sq(y[i] - y[j]) < sq(r[i] + r[j])){\n\t\t\t\t\ts[i] |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << calc(0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct circle{\n  double x, y, r;\n  int c;\n  unordered_set<int> overlap;\n};\n\nvoid calcOverlap(int n, circle *disk){\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      int x = disk[i].x - disk[j].x, y = disk[i].y - disk[j].y;\n      if(sqrt(x*x + y*y) + 1e-8< disk[i].r + disk[j].r){\n        disk[j].overlap.insert(i);\n      }\n    }\n  }\n}\n\nint dfs(int n, circle *disk, bool *removed, int dep = 0){\n  int res = 0;\n  bool f = false;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      if(removed[i] == true or removed[j] == true)continue;\n      if(disk[i].c != disk[j].c)continue;\n      if(not disk[i].overlap.empty() or\n         not disk[j].overlap.empty())continue;\n      f = true;\n      removed[i] = true;\n      removed[j] = true;\n      for (int k = 0; k < n; k++) {\n        disk[k].overlap.erase(i);\n        disk[k].overlap.erase(j);\n      }\n      res = max(res, dfs(n, disk, removed, dep + 1));\n      removed[i] = false;\n      removed[j] = false;\n    }\n  }\n  return f?res:dep;\n}\n\nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n, n){\n    circle disk[n];\n    for (int i = 0; i < n; i++) {\n      cin >> disk[i].x >> disk[i].y >> disk[i].r >> disk[i].c;\n    }\n    calcOverlap(n, disk);\n    // for (int i = 0; i < n; i++) {\n    //   std::cout << \"i:\" << i << std::endl;\n    //   for (int j :disk[i].overlap) {\n    //     std::cout << j << \" \";\n    //   }\n    //   std::cout << std::endl;\n    // }\n    bool removed[n];\n    memset(removed, false, sizeof(removed));\n    std::cout << 2*dfs(n, disk, removed) << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nstruct Solver\n{\n\tconst int N;\n\tVI xs, ys, rs, cs;\n\tset< vector<bool> > visited;\n\n\tint res;\n\n\tSolver( int n ) : N( n ), xs( N ), ys( N ), rs( N ), cs( N ), res( 0 )\n\t{\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tcin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n\t\t}\n\t\treturn;\n\t}\n\n\toperator int()\n\t{\n\t\tvector<bool> tmp( N, true );\n\t\tdfs( tmp );\n\t\treturn res;\n\t}\n\n\tvoid dfs( vector<bool> &exists )\n\t{\n\t\tres = max<int>( res, count( ALL( exists ), false ) );\n\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tif ( overlapped( exists, i ) )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tREP( j, 0, i )\n\t\t\t{\n\t\t\t\tif ( !exists[i] || !exists[j] || cs[i] != cs[j] || overlapped( exists, j ))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\texists[i] = exists[j] = false;\n\t\t\t\tif ( !EXIST( visited, exists ) )\n\t\t\t\t{\n\t\t\t\t\tdfs( exists );\n\t\t\t\t}\n\t\t\t\tvisited.insert( exists );\n\t\t\t\texists[i] = exists[j] = true;\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\tbool overlapped( const vector<bool> &exists, const int p )\n\t{\n\t\tREP( i, 0, p )\n\t\t{\n\t\t\tif ( !exists[i] )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( ( xs[p] - xs[i] ) * ( xs[p] - xs[i] ) + ( ys[p] - ys[i] ) * ( ys[p] - ys[i] ) < ( rs[i] + rs[p] ) * ( rs[i] + rs[p] ) )\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int n; cin >> n, n; )\n\t{\n\t\tcout << Solver( n ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint n;\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define FOR(i,a,n) for(int i = a; i < n; i++)\ntypedef vector<int> VI;\nconst int INF = 1e9;\nbool check(int i, int j, VI& x, VI& y, VI& r){\n  int dist = (x[i]-x[j]) * (x[i]-x[j]) + (y[i]-y[j]) * (y[i]-y[j]);\n  int rdist = (r[i] + r[j]) * (r[i] + r[j]);\n  return dist < rdist;\n}\n\nbool dp[1<<24];\n\nint func(int bit,VI& ng, VI& c){\n  if(dp[bit]++) return -INF;\n  int res = 0;\n\n  rep(i,n){\n    if((bit>>i) & 1){\n      FOR(j,i+1,n){\n        if((bit>>j) & 1 && c[i] == c[j] && !(bit&ng[i]) && !(bit & ng[j])) {\n          res = max(res, func(bit & ~(1<<i) & ~(1<<j),ng,c) + 2);\n        }\n      }\n    }\n  }\n  return res;\n}\n\n\nint main(){\n  while(true){\n    cin >> n;\n    if(n == 0) break;\n    memset(dp,false,sizeof(dp));\n\n    VI x(n), y(n), r(n), c(n);\n    VI ng(n,0);\n    rep(i,n){\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n      rep(j,i) if(check(i,j,x,y,r)) ng[i] |= 1<<j;\n    }\n    cout << func((1<<n) - 1,ng,c) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nconst int kN = 30;\nint N, x[kN], y[kN], r[kN], c[kN], cross[kN];\nint dp[(1<<24)+1];\n\nint rec(int S) {\n  if (dp[S] >= 0) return dp[S];\n  int ret = 0;\n  for (int i = 0; i < N; ++i) {\n    if (S >> i & 1) continue;\n    if (S != (S | cross[i])) continue;\n    for (int j = i+1; j < N; ++j) {\n      if (S >> j & 1) continue;\n      if (c[i] != c[j]) continue;\n      if (S != (S | cross[j])) continue;\n      ret = max(ret, rec(S|(1<<i)|(1<<j)) +2);\n    }\n  }\n  return dp[S] = ret;\n}\n\nint solve() {\n  memset(cross, 0, sizeof (cross));\n  for (int i = 0; i < N; ++i) {\n    for (int j = i+1; j < N; ++j) {\n      int dx = x[i] - x[j], dy = y[i] - y[j], ur = r[i] + r[j];\n      if (dx*dx + dy*dy < ur*ur)\n        cross[j] |= (1<<i);\n    }\n  }\n  memset(dp, -1, sizeof dp);\n  // rep(i,N) {\n  //   printf(\"%d : %d\\n\", i, cross[i]);\n  // }\n  return rec(0);\n}\n\nint main() {\n  while (scanf(\"%d\", &N), N) {\n    rep(i,N) scanf(\"%d%d%d%d\", x+i, y+i, r+i, c+i);\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define pb push_back\nusing namespace std;\n\nint n;\nint x[30], y[30], r[30], c[30];\nbool used[30];\nvector<int> G[30];\nint did[(1<<25)];\n\n\nint dfs(int f){\n\tint ret = 0;\n\tif(did[f]) return did[f];\n\trep(i,n){\n\t\tif(used[i])continue;\n\t\tused[i] = true;\n\t\tbool yes = true;\n\t\trep(j,G[i].size()){\n\t\t\tif(!used[G[i][j]]){\n\t\t\t\tyes = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(yes){\n\t\t\tfor(int j = i+1; j < n; j++){\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tif(c[i] != c[j]) continue;\n\t\t\t\t\n\t\t\t\tused[j] = true;\n\t\t\t\tbool no = false;\n\t\t\t\trep(k,G[j].size()){\n\t\t\t\t\tif(G[j][k] == i){\n\t\t\t\t\t\tno = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(!used[G[j][k]]){\n\t\t\t\t\t\tno = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!no){\n\t\t\t\t\tret = max(ret,dfs(f+(1<<i)+(1<<j))+2);\n\t\t\t\t}\n\t\t\t\tused[j] = false;\n\t\t\t}\n\t\t}\n\t\tused[i] = false;\n\t}\n\tdid[f] = ret;\n\treturn ret;\n}\n\nint main(){\n\twhile(scanf(\"%d\",&n),n){\n\t\tmemset(used,0,sizeof(used));\n\t\tmemset(did,0,sizeof(did));\n\t\trep(i,30) G[i].clear();\n\t\trep(i,n) scanf(\"%d%d%d%d\",x+i,y+i,r+i,c+i);\n\t\trep(i,n) for(int j = i+1; j < n; j++){\n\t\t\tif((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])<(r[i]+r[j])*(r[i]+r[j])){\n\t\t\t\tG[j].pb(i);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dfs(0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pb push_back\n#define sz size()\n#define vi vector<int>\n\nint n,x[25],y[25],r[25],c[25],ans;\nbool v[1<<24];\n\nint sq(int x){return x*x;}\n\nvoid f(int mask){\n\tif(v[mask])return;\n\tv[mask]=1;\n\tvi d;\n\trep(i,n)if(mask>>i&1)d.pb(i);\n\tans=max(ans,n-(int)d.sz);\n\tbool top[25];\n\trep(i,d.sz)top[i]=1;\n\trep(i,d.sz)rep2(j,i+1,d.sz){\n\t\tif(sq(x[d[i]]-x[d[j]])+sq(y[d[i]]-y[d[j]])<sq(r[d[i]]+r[d[j]])){\n\t\t\ttop[j]=0;\n\t\t}\n\t}\n\trep(i,d.sz)rep2(j,i+1,d.sz){\n\t\tif(top[i] && top[j] && c[d[i]]==c[d[j]]){\n\t\t\tf(mask-(1<<d[i])-(1<<d[j]));\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>n && n){\n\t\trep(i,n)cin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\tans=0;\n\t\tmemset(v,0,sizeof(v));\n\t\tf((1<<n)-1);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 24\nusing namespace std;\n\nint n,x[N],y[N],r[N],c[N],ans,len[N];\nvector<int> v[N];\n\nvoid func(bool erased[N],int cnt,int x){\n  ans=max(ans,cnt);\n  for(int i=x;i<n;i++){\n    int f=0;\n    if(erased[i]) continue;\n    for(int j=0;j<len[i];j++)\n      if(!erased[v[i][j]]) f=1;\n    if(f) continue;\n    for(int j=i+1;j<n;j++){\n      if(c[i]!=c[j]) continue;\n      if(erased[j]) continue;\n      int f2=0;\n      for(int k=0;k<len[j];k++)\n\tif(!erased[v[j][k]]) f2=1;\n      if(f2) continue;\n      erased[i]=erased[j]=true;\n      func(erased,cnt+2,i+1);\n      erased[i]=erased[j]=false;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n      for(int j=i-1;j>=0;j--){\n\tint xl=x[i]-x[j],yl=y[i]-y[j];\n\tint rl=r[i]+r[j];\n\tif(sqrt(xl*xl+yl*yl)<rl)v[i].push_back(n-j-1);\n      }\n    }\n    reverse(x,x+n);\n    reverse(y,y+n);\n    reverse(r,r+n);\n    reverse(c,c+n);\n    reverse(v,v+n);\n    for(int i=0;i<n;i++) len[i]=v[i].size();\n    bool erased[N]={};\n    ans=0;\n    func(erased,0,0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++) v[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\nstruct disk{\n    int x,y,r,c;\n    disk(int x, int y, int r, int c):x(x),y(y),r(r),c(c){}\n    disk(){}\n};\nbool bittrue(int n, int i){\n    return (n&(1<<i)) != 0;\n}\nint countbit(int num){\n    num = (num & 0x55555555) + (num>>1 & 0x55555555);\n    num = (num & 0x33333333) + (num>>2 & 0x33333333);\n    num = (num & 0x0f0f0f0f) + (num>>4 & 0x0f0f0f0f);\n    num = (num & 0x00ff00ff) + (num>>8 & 0x00ff00ff);\n    return (num & 0x0000ffff) + (num>>16 & 0x0000ffff);\n}\n\nint dfs(int curr, int score, vector<vector<int> > &adj, vector<bool> &used){\n    if(used[curr]) return 0;\n    used[curr] = true;\n    int ret = score;\n    for(int i=0; i<(int)adj[curr].size(); i++){\n        ret = max(ret, dfs(adj[curr][i], score+2, adj, used));\n    }\n    return ret;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        vector<disk> d(n);\n        vector<vector<int> > ovl(n);\n        for(int i=0; i<n; i++){\n            int x,y,r,c;\n            cin >> x >> y >> r >> c;\n            d[i] = disk(x,y,r,c);\n            for(int j=0; j<i; j++){\n                if((x-d[j].x)*(x-d[j].x)+(y-d[j].y)*(y-d[j].y) < (r+d[j].r)*(r+d[j].r)){\n                    ovl[i].push_back(j);\n                }\n            }\n        }\n        vector<\n            vector<int> > adj(1<<n);\n        for(int b=0; b<(1<<n); b++){\n            if((n-countbit(b))%2 != 0) continue;\n            for(int i=0; i<n; i++){\n                if(!bittrue(b,i)) continue;\n                bool flag=true;\n                for(int k=0; k<(int)ovl[i].size(); k++){\n                    if(bittrue(b,ovl[i][k])){\n                        flag = false;\n                        break;\n                    }\n                }\n                if(!flag) continue;\n                \n                for(int j=i+1; j<n; j++){\n                    if(!bittrue(b,j) || d[i].c != d[j].c) continue;\n                    bool flag = true;\n                    for(int k=0; k<(int)ovl[j].size(); k++){\n                        if(bittrue(b, ovl[j][k])){\n                            flag=false;\n                            break;\n                        }\n                    }\n                    if(flag){\n                        adj[b].push_back(b&~(1<<i)&~(1<<j));\n                    }\n                }\n            }\n        }\n\n        vector<bool> used(1<<n, false);\n        cout << dfs((1<<n)-1, 0, adj, used) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\n\nint main(){\n\n    while(1){\n        int n; cin >> n;\n        if(!n) break;\n        vector<int> x(n);\n        vector<int> y(n);\n        vector<int> r(n);\n        vector<int> c(n);        \n\n        for(int i = 0; i < n; i++) cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n        vector<vector<bool> > canTake(n, vector<bool> (n, false));\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                int d = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n                if(d < (r[i] + r[j]) * (r[i] + r[j])) canTake[j][i] = true;\n            }\n        }\n\n        /*for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                cout << canTake[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        cout << endl;*/\n\n        //ワーシャルフロイド\n        for(int k = 0; k < n; k++){\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    canTake[i][j] = canTake[i][j] || canTake[i][k] && canTake[k][j];\n                }\n            }\n        }\n\n        /*for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                cout << canTake[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        cout << endl;\n        */\n        //幅優先探索\n        vector<bool> visited((1<<n), false);\n        queue<pair<int, int> > q;\n        q.push({0, (1<<n) - 1});\n        visited[(1<<n) - 1] = true;\n\n        int ans = 0;\n\n        while(!q.empty()){\n\n            int now_bit = q.front().second;\n            int now_cost = q.front().first;\n            ans = max(ans, now_cost);\n            q.pop();\n\n            for(int i = 0; i < n; i++){\n                for(int j = i + 1; j < n; j++){\n\n                    //i番目 と j番目が取り出せるか\n                    if(!((1<<i) & now_bit)) continue;\n                    if(!((1<<j) & now_bit)) continue;                    \n                    //色が違うならダメ\n                    if(c[i] != c[j]) continue;\n                \n                    //iの上に何かあればダメ\n                    bool flagi = true;\n                    for(int k = 0; k < n; k++){\n                        if(canTake[i][k] && (now_bit & (1<<k))){\n                            flagi = false;\n                            break;\n                        }\n                    }\n\n\n                    if(!flagi) continue;\n                \n                    bool flagj = true;\n                    for(int k = 0; k < n; k++){\n                        if(canTake[j][k] && (now_bit & (1<<k))){\n                            flagj = false;\n                            break;\n                        }\n                    }\n\n                    if(!flagj) continue;\n\n                    int next_bit = now_bit & (~((1<<i) | (1<<j)));\n                    if(!visited[next_bit]){\n                        visited[next_bit] = true;\n                        q.push({now_cost + 1, next_bit});\n                    }\n                }\n            }\n        }\n\n        cout << 2 * ans << endl;\n    }\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint n;\n\nstruct Circle {\n    int x, y, r;\n    int c;\n    Circle() {}\n    Circle(int x, int y, int r, int c) : x(x), y(y), r(r), c(c) {}\n};\n\nbool intersect(Circle& a, Circle& b) {\n    return (a.r+b.r) * (a.r+b.r) > (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y);\n}\n\nvector<Circle> cs;\nvector< vector<int> > upper;\nvoid init() {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (intersect(cs[i], cs[j])) {\n                upper[i].push_back(j);\n            }\n        }\n    }\n}\n \nshort dp[1<<24];\nint remove(int used=0) {\n    if (dp[used] >= 0) return dp[used];\n    vector<int> tops;\n    for (int i = 0; i < n; i++) {\n        if (used & (1<<i)) continue;\n        bool cover = false;\n        for (int j = 0; j < upper[i].size(); j++) {\n            if (!(used & (1<<upper[i][j]))) {\n                cover = true;\n                break;\n            }\n        }\n        if (!cover) tops.push_back(i);\n    }\n    int cnt = 0;\n    for (int i = 0; i < tops.size(); i++) {\n        for (int j = 0; j < tops.size(); j++) {\n            if (i == j) continue;\n            if (cs[tops[i]].c == cs[tops[j]].c) {\n                used |= (1<<tops[i]);\n                used |= (1<<tops[j]);\n                cnt = max(cnt, remove(used)+2);\n                used ^= (1<<tops[i]);\n                used ^= (1<<tops[j]);\n            }\n        }\n    }\n    return dp[used] = cnt;\n}\n\nint main() {\n    while (cin >> n, n) {\n        cs = vector<Circle>(n);\n        upper = vector< vector<int> >(n);\n        for (int i = 0; i < n; i++) {\n            int x, y, r, c;\n            cin >> x >> y >> r >> c;\n            cs[i] = Circle(x, y, r, c);\n        }\n        init();\n        memset(dp, -1, sizeof(dp));\n        cout << remove() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nmain {\n  while (true) {\n    int n = in();\n    if (n == 0) break;\n    vector<int> x(n), y(n), r(n), c(n);\n    rep(i, n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n    auto intersectCC = [&](int i, int j) {\n      int r2 = (r[i] + r[j]) * (r[i] + r[j]);\n      int d = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n      return d < r2;\n    };\n    auto intersect = [&](int t, int used) {\n      bool f = false;\n      rep(i, t) f |= (~used >> i & 1) && intersectCC(t, i);\n      return f;\n    };\n    vector<char> dp(1 << n, -1);\n    function<int(int)> dfs = [&](int used) {\n      if (dp[used] != -1) return dp[used];\n      cmax(dp[used], 0);\n      rep(i, n) loop(j, i + 1, n) {\n        if ((used >> i & 1) || (used >> j & 1) || c[i] != c[j]) continue;\n        if (intersect(i, used) || intersect(j, used)) continue;\n        cmax(dp[used], dfs(used | (1 << i) | (1 << j)) + 2);\n      }\n      return dp[used];\n    };\n    cout << dfs(0) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nint N, X[24], Y[24], R[24], C[24];\n\nbool isCoverd(int i, int j)\n{\n  int x = abs(X[i] - X[j]), y = abs(Y[i] - Y[j]), r = R[i] + R[j];\n  return ((x * x) + (y * y)) < (r * r);\n}\n\nbool noCoverd(int j, int s) {\n  for (int i = 0; i < j; i++)\n    if ( (s >> i & 1) && isCoverd(i, j))\n      return false;\n\n  return true;\n}\n\nchar memo[1 << 25];\nint dfs(int s)\n{\n  if (memo[s] != -1) {\n    return memo[s];\n  }\n  \n  int ans = 0;\n  for (int i = 0; i < N; i++) {\n    for (int j = i + 1; j < N; j++) {\n      if ( C[i] == C[j] && (s >> i & 1) && (s >> j & 1) &&\n           noCoverd(i, s) && noCoverd(j, s) ) {\n        ans = max(ans, dfs(s & ~(1 << i) & ~(1 << j)) + 2);\n      }\n    }\n  }\n  \n  return memo[s] = ans;\n}\n\n\nint main()\n{\n  while (cin >> N && N) {\n    for (int i = 0; i < N; i++) \n      cin >> X[i] >> Y[i] >> R[i] >> C[i];\n\n    memset(memo, -1, sizeof(memo));\n\n    cout << dfs((1 << N) - 1) << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct circle{\n  double x, y, r;\n  int c;\n  unordered_set<int> up, down;\n};\nint n;\nbool dp[(1<<24)];\nbool canRemove(int &state, circle &disk){\n  for (auto up:disk.up){\n    if((state & (1<<up)))return false;\n  }\n  return true;\n}\n\nvoid calcDP(int &state, circle *disk){\n  for (int i = 0; i < n; i++) {\n    if((state & (1<<i)) == 0)continue;\n    if(not canRemove(state, disk[i]))continue;\n    for (int j = i + 1; j < n; j++) {\n      if((state & (1<<j)) == 0)continue;\n      if(disk[i].c != disk[j].c)continue;\n      if(not canRemove(state, disk[j]))continue;\n      int next_state = state ^ (1<<i);\n      next_state ^= (1<<j);\n      //std::cout << \"next_state:\" << next_state << std::endl;\n      dp[next_state] = true;\n    }\n  }\n}\nvoid overlap(int n, circle *disk){\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      double dx = disk[i].x - disk[j].x,\n        dy = disk[i].y - disk[j].y;\n      if(sqrt(dx*dx + dy*dy) + 1e-8 < disk[i].r + disk[j].r)\n        disk[j].up.insert(i);\n    }\n  }\n}\n             \nint main(int argc, char *argv[]){\n  while(cin >> n, n){\n    circle disk[n];\n    for (int i = 0; i < n; i++) {\n      cin >> disk[i].x >> disk[i].y >> disk[i].r >> disk[i].c;\n    }\n    overlap(n, disk);\n    int ans = 0;\n    int roop = (1<<n);\n    memset(dp, false, sizeof(dp));\n    dp[roop - 1] = true;\n    for (int i = roop - 1; i > 0; i--) {\n      if(dp[i] == false)continue;\n      calcDP(i, disk);\n    }\n    for (int i = 0; i < roop; i++) {\n      if(dp[i] == false)continue;\n      ans = max(ans, n - __builtin_popcount(i));\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nint N, X[24], Y[24], R[24], C[24];\n\nbool isCoverd(int i, int j)\n{\n  int x = abs(X[i] - X[j]), y = abs(Y[i] - Y[j]), r = R[i] + R[j];\n  return ((x * x) + (y * y)) < (r * r);\n}\n\nbool noCoverd(int j, int s) {\n  for (int i = 0; i < j; i++)\n    if ( (s >> i & 1) && isCoverd(i, j))\n      return false;\n\n  return true;\n}\n\nchar memo[1 << 24];\nint dfs(int s)\n{\n  if (memo[s] != -1)\n    return memo[s];\n  \n  int ans = 0;\n  for (int i = 0; i < N; i++) {\n    for (int j = i + 1; j < N; j++) {\n      if ( (s >> i & 1) && (s >> j & 1)         && // 両方の皿が除去されていない場合\n           noCoverd(i, s) && noCoverd(j, s)     && // 重なっていない\n           C[i] == C[j]\n         ) {\n        ans = max(ans, dfs(s & ~(1 << i) & ~(1 << j)) + 2);\n      }\n    }\n  }\n  \n  return memo[s] = ans;\n}\n\n\nint main()\n{\n  while (cin >> N && N) {\n    for (int i = 0; i < N; i++) \n      cin >> X[i] >> Y[i] >> R[i] >> C[i];\n\n    memset(memo, -1, sizeof(memo));\n\n    cout << dfs((1 << N) - 1) << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nstruct circle { int x, y, r, col; };\nbool con(circle a, circle b) {\n\tif ((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y) < (a.r + b.r)*(a.r + b.r))return true;\n\treturn false;\n}\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tcircle a[24]; int c[24];\n\t\trep(i, n) {\n\t\t\tint x, y, r, col;\n\t\t\tcin >> x >> y >> r >> col;\n\t\t\ta[i] = { x,y,r,col };\n\t\t\tc[i] = col;\n\t\t}\n\t\tvector<int> cov[24];\n\t\trep(i, n) {\n\t\t\tRep(j, i + 1, n) {\n\t\t\t\tif (con(a[i], a[j])) {\n\t\t\t\t\tcov[j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sta = (1 << n) - 1;\n\t\tmap<int, int> used; used[sta] = 1;\n\t\tqueue<int> q;\n\t\tint ma = 0;\n\t\tq.push(sta);\n\t\twhile (!q.empty()) {\n\t\t\tint now = q.front(); q.pop();\n\t\t\tint del[24] = {}; vector<int>noncov;\n\t\t\tint cnt = 0;\n\t\t\trep(k, n) {\n\t\t\t\tif (!(now&(1 << k)))del[k] = 1;\n\t\t\t\telse {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tma = max(ma, n - cnt);\n\t\t\trep(k, n) {\n\t\t\t\tif (del[k])continue;\n\t\t\t\tint len = cov[k].size();\n\t\t\t\tbool f = true;\n\t\t\t\trep(i, len) {\n\t\t\t\t\tif (!del[cov[k][i]])f = false;\n\t\t\t\t}\n\t\t\t\tif (f)noncov.push_back(k);\n\t\t\t}\n\t\t\tint len2 = noncov.size();\n\t\t\trep(i, len2) {\n\t\t\t\tRep(j, i + 1, len2) {\n\t\t\t\t\tif (c[noncov[i]] == c[noncov[j]]) {\n\t\t\t\t\t\tint res = now;\n\t\t\t\t\t\tres ^= (1 << noncov[i]); res ^= (1 << noncov[j]);\n\t\t\t\t\t\tif (used[res] != 1) {\n\t\t\t\t\t\t\tused[res] = 1; q.push(res);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ma << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <set>\n#include <map>\n#include <string>\nusing namespace std;\n\n#define For(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define Rep(i,n) For(i,0,n)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\n\n#define INF 1000000000\n\n#define MAX_N 24\n\nstruct disk{\n\tint x, y, r, c;\n\tdisk(int a, int b, int c, int d):x(a),y(b),r(c),c(d){}\n};\n\nint N;\nint mem[1<<MAX_N];\nvector<disk> D;\n\nbool is_top(int k, int b){\n\tRep(i,k) if((b&(1<<i)) == 0 && ((D[i].x-D[k].x)*(D[i].x-D[k].x)+(D[i].y-D[k].y)*(D[i].y-D[k].y) < (D[i].r+D[k].r)*(D[i].r+D[k].r))) return false;\n\treturn true;\n}\n\nint dfs(int b){\n\tif(mem[b] != -1) return mem[b];\n\tint res = -1;\n\tRep(i,N)For(j,i+1,N){\n\t\tif((b&(1<<i)) == 0 && (b&(1<<j)) == 0){\n\t\t\tif(D[i].c == D[j].c && is_top(i, b) && is_top(j, b)) res = max(dfs(b|(1<<i)|(1<<j)), res);\n\t\t}\n\t}\n\tif(res != -1) return mem[b] = res+2;\n\telse return mem[b] = 0;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\tD.clear();\n\t\tRep(i,N){\n\t\t\tint x, y, r, c;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &r, &c);\n\t\t\tD.pb(disk(x, y, r, c));\n\t\t}\n\t\tRep(i,1<<N) mem[i] = -1;\n\t\tprintf(\"%d\\n\", dfs(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<vector>\n#include<complex>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cctype>\n#include<cstring>\n#include<cassert>\nint n; //枚数\nint x[25],y[25],r[25],c[25]; //円盤\nint b[25]; //各円盤の上に重なっている円盤（ビット管理）\n\n//円盤iと円盤jが重なっているかの判定\nbool intersects(int i,int j){\n  int dist1 = pow(x[i]-x[j],2) + pow(y[i]-y[j],2);\n  int dist2 = pow(r[i]+r[j],2);\n\n  return dist2 > dist1;\n}\n\n//DP用\nchar dp[1<<24];\n\nint main(void){\n  while(scanf(\"%d\",&n),n){\n    rep(i,n){\n      scanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n\n      //円盤iの上に重なっている円盤を全て探す\n      b[i] = 0;\n      rep(j,i) if(intersects(i,j)) b[i] |= (1<<j);\n    }\n\n    int ans = 0;\n    int to = (1<<n);\n    memset(dp,-1,sizeof(dp));\n    dp[0] = 0;\n\n    rep(i,to){\n      if(dp[i] == -1) continue;\n\n      ans = max(ans,(int)dp[i]);\n\n      //消せる円盤のペア(j,k)を探す\n      rep(j,n-1){\n        //すでに円盤jは消えている or 円盤jの上の円盤が邪魔して消せない\n        if((i & (1<<j)) != 0 || (i & b[j]) != b[j]) continue;\n\n        REP(k,j+1,n){\n          //jとkの色が違う or すでに円盤kは消えている or 円盤kの上の円盤が邪魔\n          if(c[j] != c[k] || (i & (1<<k)) != 0 || (i & b[k]) != b[k]) continue;\n\n          int next = i | (1<<j) | (1<<k); //next = 円盤jとkを消した状態(ビット管理)\n          dp[next] = max((int)dp[next],dp[i]+2);\n        }\n      }\n    }\n\n    printf(\"%d\\n\",ans);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n, ans;\nint x[24], y[24], r[24], c[24];\nbool exist[24];\n// memo[bits] := ツ円ツづ個湘ウツ妥?bits ツづ個づ?つォツづ個づ?づィツ渉慊つッツづゥツ鳴?青板づーツ陛板つキ. \nchar memo[1<<24];\n\nvoid init(){\n\tfor(int i=0 ; i < n ; i++ ) exist[i] = true;\n\tfor(int i=0 ; i < (1<<n) ; i++ ) memo[i] = -1;\n}\n\nint dist(int x1, int y1, int x2, int y2){\n\treturn (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n}\n\n// ツ円ツ氾?i ツつェ1ツ氾板湘」 <=> j < i ツづ?づ按づィ, ツ円ツ氾?i ツづ?重ツづ按づゥツ円ツ氾?j ツつェツ堕カツ催敖つオツづ按つ「.\nbool is_top(int i){\n\tfor(int j=0 ; j < i ; j++ ){\n\t\tif( !exist[j] ) continue;\n\t\t\n\t\tint r1 = r[i];\n\t\tint r2 = r[j];\n\t\tint d = dist( x[i] , y[i] , x[j] , y[j] );\n\t\tif( d < (r1 + r2) * (r1 + r2) ){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint solve(int bits, int cnt){\n\tif( memo[bits] >= 0 ) return memo[bits];\n\tint result = cnt;\n\t\n\tans = max( ans , cnt );\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tif( !exist[i] || !is_top(i) ) continue;\n\t\t\n\t\tfor(int j=i+1 ; j < n ; j++ ){\n\t\t\tif( c[i] != c[j] || !exist[j] || !is_top(j) ) continue;\n\t\t\t\n\t\t\texist[i] = exist[j] = false;\n\t\t\tint next_bits = (bits & (~(1<<i))) & (~(1<<j));\n\t\t\tresult = solve( next_bits , cnt+2 );\n\t\t\texist[i] = exist[j] = true;\n\t\t}\n\t}\n\tmemo[bits] = result;\n\tans = max( ans , result );\n\treturn result;\n}\n\nint main(){\n\twhile( cin >> n , n ){\n\t\tinit();\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tans = 0;\n\t\tsolve( ((1<<n)-1) , 0 );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\nint n;\nint circle[24][4];\nint bitDP[(1<<24)]; // ??????????????????bit??§??????\nint overlap[24]; // ?????????????????????bit??§??????\n\nint main()\n{\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcin >> circle[i][0];\n\t\t\tcin >> circle[i][1];\n\t\t\tcin >> circle[i][2];\n\t\t\tcin >> circle[i][3];\n\t\t\t\n\t\t\toverlap[i] = 0;\n\t\t\tfor(int j = 0; j < i; j++) {\n\t\t\t\tint distance_x = circle[i][0] - circle[j][0];\n\t\t\t\tint distance_y = circle[i][1] - circle[j][1];\n\t\t\t\tdouble distance_circle = sqrt(pow(distance_x, 2) + pow(distance_y, 2));\n\t\t\t\tif(circle[i][2] + circle[j][2] > distance_circle) {\n\t\t\t\t\toverlap[i] += (1 << j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int bit = 0; bit < (1 << n); bit++) {\n\t\t\tbitDP[bit] = 0;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int bit = 0; bit < (1 << n); bit++) {\n\t\t\tif(bit != 0 && bitDP[bit] == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tif(((1 << i) & bit)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int j = i+1; j < n; j++) {\n\t\t\t\t\tif(((1 << i) | (1 << j)) & bit) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(((overlap[i] & bit) != overlap[i]) || ((overlap[j] & bit) != overlap[j])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(circle[i][3] == circle[j][3]) {\n\t\t\t\t\t\tint next = (((1 << i) | (1 << j)) | bit);\n\t\t\t\t\t\tif(bitDP[next] < bitDP[bit] + 2) {\n\t\t\t\t\t\t\tbitDP[next] = bitDP[bit] + 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ans < bitDP[next]) {\n\t\t\t\t\t\t\tans = bitDP[next];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lp(i,n) for(int i=0;i<n;i++)\n\nint color[24],ans;\n\nvoid calc(vector<int> canremove[],int nowremove,int n){\n  lp(i,n){\n    int checkmemo=0;\n    lp(j,n){\n      if(canremove[i][24]==-1) break;\n      if(canremove[i][24]==-2){\n\tcheckmemo=1;\n\tbreak;\n      }\n      if(canremove[i][j]!=0){\n\tcheckmemo=1;\n\tbreak;\n      }\n    }\n    if(checkmemo==0) canremove[i][24]=-1;\n  }\n  ans=max(ans,nowremove);\n  for(int i=0;i<n-1;i++){\n    for(int j=i+1;j<n;j++){\n      if(color[i]==color[j]){\n\tif(canremove[i][24]==-1&&canremove[j][24]==-1){\n\t  vector<int> memo[24];\n\t  lp(k,24){\n\t    memo[k]=canremove[k];\n\t  }\n\t  lp(k,24){\n\t    memo[k][i]=0;\n\t    memo[k][j]=0;\n\t  }\n\t  memo[i][24]=-2;\n\t  memo[j][24]=-2;\n\t  calc(memo,nowremove+2,n);\n\t}\n      }\n    }\n  }\n  return;\n}\n\n\nint main(){\n  while(1){\n    int n;\n    cin>>n;\n    if(n==0) break;\n    int x[24],y[24],l[24];\n    vector<int> canremove[25];\n    lp(i,24){\n      color[i]=-1;\n      canremove[i].clear();\n      lp(j,25){\n\tcanremove[i].push_back(0);\n      }\n    }\n    lp(i,n){\n      cin>>x[i]>>y[i]>>l[i]>>color[i];\n      int count=0;\n      for(int j=0;j<i;j++){\n\tif(fabs(x[i]-x[j])*fabs(x[i]-x[j])+fabs(y[i]-y[j])*fabs(y[i]-y[j]) < (l[i]+l[j])*(l[i]+l[j])){\n\t  \n\t  count++;\n\t  canremove[i][j]=1;\n\t}\n      }\n      if(count==0) canremove[i][24]=-1;\n    }\n    ans=0;\n    calc(canremove,0,n);\n    cout<<ans<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\nint n;\ndouble x[24], y[24], r[24];\nint c[24], p[24];\n\nint dp[1 << 24];\n\nint f(int s) {\n\tif(dp[s] != -1) return -1;\n\tif(s == 0) return 0;\n\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++) if((s & (1 << i)) && ((s & p[i]) == 0)) {\n\t\tfor(int j = i + 1; j < n; j++) if((s & (1 << j)) && ((s & p[j]) == 0)) {\n\t\t\tif(c[i] != c[j]) continue;\n\t\t\tint ns = s ^ (1 << i) ^ (1 << j);\n\t\t\tret = max(ret, 2 + f(ns));\n\t\t}\n\t}\n\treturn dp[s] = ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\n\t\tmemset(p, 0, sizeof p);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < i; j++) {\n\t\t\t\tdouble d = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n\t\t\t\tif(d < (r[i] + r[j]) * (r[i] + r[j])) {\n\t\t\t\t\tp[i] |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(dp, -1, sizeof dp);\n\t\tcout << f((1 << n) - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define mod 1000000007\n#define all(c) begin(c),end(c)\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nusing ll = long long;\nusing vi = vector<int>; using vs = vector<string>;\nint dd[] = { 0, 1, 0, -1, 0 }; //→↓←↑\n\n\n\nvoid solve()\n{\n\tint N;\n\twhile (cin >> N, N)\n\t{\n\t\tvector<int> x(N);\n\t\tvector<int> y(N);\n\t\tvector<int> r(N);\n\t\tvector<int> c(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\t\n\t\tvector<int> G[30];\n\t\t//vector<int> P(N);\n\t/*\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tP[i] = -1;\n\t\t}*/\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t{\n\t\t\t\tint xx = x[i] - x[j];\n\t\t\t\tint yy = y[i] - y[j];\n\t\t\t\tint rr = r[i] + r[j];\n\t\t\t\tif (xx * xx + yy * yy < rr * rr)\n\t\t\t\t{\n\t\t\t\t\tG[j].emplace_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> dp(1 << 24, 0);\n\t\tint ans = 0;\n\t\tvector<bool> ok(N, false);\n\t\tfor (int S = 0; S < 1 << N; S++)\n\t\t{\n\t\t\t//if (S != 0 && dp[S] == 0)continue;\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t{\n\t\t\t\tif (S >> i & 1)continue;\n\t\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t\t{\n\t\t\t\t\tif (S >> j & 1)continue;\n\t\t\t\t\tif (c[i] != c[j])continue;\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\tfor (int v : G[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!ok[v]) {\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!flag)continue;\n\t\t\t\t\tfor (int v : G[j]) {\n\t\t\t\t\t\tif (!ok[v])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!flag)continue;\n\n\n\t\t\t\t\tchmax(dp[S | (1 << i) | (1 << j)], dp[S] + 2);\n\t\t\t\t\tchmax(ans, dp[S | (1 << i) | (1 << j)]);\n\t\t\t\t\tok[i] = true;\n\t\t\t\t\tok[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << dp[S] << endl;\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint n;\nint x[24],y[24],c[24],r[24];\nchar memo[1<<24];\nint hit(int i,int j){\n\tint L = r[i]*r[i] + r[j]*r[j] + 2 * r[i] * r[j];\n\tint X = (x[i]-x[j])*(x[i]-x[j]);\n\tint Y = (y[i]-y[j])*(y[i]-y[j]);\n\treturn X + Y < L;\n}\nint nocover(int n,int bit){\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( (bit>>i&1) && hit(i,n) ) return false;\n\t}\n\treturn true;\n}\nint dfs(int bit){\n\tif(~memo[bit]) return memo[bit];\n\tint ans = 0;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tfor(int j = i+1 ; j < n ; j++){\n\t\t\tif( (bit >> j & 1) && (bit >> i & 1) && c[i] == c[j] && nocover(i,bit) && nocover(j,bit) ){\n\t\t\t\tans = max(ans , dfs( bit & ~(1<<j) & ~(1<<i) ) + 2);\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[bit] = ans;\n}\nint main(){\n\twhile(cin >> n , n){\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tcout << dfs((1<<n)-1) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nint N;\nint x[30], y[30], r[30], c[30];\nint overlap[30], dp[(1<<23)+1];\n\nint rec(int S) {\n  if (dp[S] >= 0) return dp[S];\n  int ret = 0;\n  // select lhs\n  for (int i = 0; i < N - 1; ++i) {\n    if (S >> i & 1) continue;\n    if (overlap[i] > S) continue;\n    // select rhs\n    for (int j = i+1; j < N; ++j) {\n      if ((S >> j & 1) || c[i] != c[j]) continue;\n      if (overlap[j] > S) continue;\n      // remove\n      ret = max(ret, rec(S|(1<<i)|(1<<j)) + 2);\n    }\n  }\n  return dp[S] = ret;\n}\n\nint solve() {\n  // check overlap\n  memset(overlap, 0, sizeof overlap);\n  for (int i = 1; i < N; ++i) {\n    int lapped = 0;\n    for (int j = 0; j < i; ++j) {\n      int dx = x[i] - x[j], dy = y[i] - y[j], dc = r[i] + r[j];\n      if (dx * dx + dy * dy < dc * dc) lapped |= (1 << j);\n    }\n    overlap[i] = lapped;\n  }\n  memset(dp, -1, sizeof dp);\n  return rec(0);\n}\n\nint main() {\n  while (scanf(\"%d\", &N), N) {\n    rep(i,N) scanf(\"%d%d%d%d\", x+i, y+i, r+i, c+i);\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define REP(i,a) rep((i),0,(a))\nusing namespace std;\n//global\n\nstruct Data{\n\tint x, y,r;\n\tint c;\n};\nData data[24];\nbool dp[1024 * 1024 * 16];\nint min_num;\nint N;\nbool double_check(int i, int j){\n\tint dx, dy, dr;\n\tdx = data[j].x - data[i].x;\n\tdy = data[j].y - data[i].y;\n\tdr = data[j].r + data[i].r;\n\t//printf(\"[%d,%d]%d,%d,%d\\n\", i, j, dx, dy, dr);\n\tif ((dx*dx + dy*dy)<(dr*dr))return(true);\n\telse return(false);\n}\n\nvoid printbit(int x){\n\tREP(i, N){\n\t\tif ((x >> (N - i-1)) & 1)cout << 1;\n\t\telse cout<<0;\n\t}\n\tcout << endl;\n\n\n}\nvoid solve(int num, int rest){\n\t//cout << rest<<endl;\n\t//printbit(rest);\n\tif (min_num > num)min_num = num;\n\tif (num <= 1)return;\n\tif (dp[rest])return;\n\n\tint color[4] = { 0 }, index[4] = { 0 };\n\tREP(i, N){\n\t\tint bit = (1 << i);\n\t\tif ((rest&bit) > 0){\n\t\t\tbool f = true;\n\t\t\trep(j,0,i)if((rest&(1<<j))>0)\n\t\t\tif (double_check(i, j)){\n\t\t\t\tf = false; continue;\n\t\t\t}\n\t\t\tif (f){\n\t\t\t\tcolor[data[i].c] += bit;\n\t\t\t\tindex[data[i].c]++;\n\t\t\t}\n\t\t}\n\t}\n\t//rep(i, 0, 4){printf(\"%d,\",index[i]);printbit(color[i]);}\n\trep(i, 0, 4)\n\tif (index[i]>=2)\n\tif (!(index[i] & 1)){\n\t\tsolve(num - index[i], rest - color[i]);\n\t}\n\telse{\n\t\tint p = 1;\n\t\trep(j, 0, index[j]){\n\t\t\twhile (!(p & 1))p <<= 1;\n\t\t\tsolve(num - index[i] + 1, rest - color[i] + p);\n\n\t\t}\n\n\n\n\t}\n\n\n}\n\n\n\nint main(void){\n\twhile (true){\n\t\tcin >> N;\n\t\tif (N == 0)return(0);\n\t\tmin_num = N;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tREP(i, N){\n\t\t\tcin >> data[i].x >> data[i].y >> data[i].r>>data[i].c;\n\t\t\tdata[i].c--;\n\t\t}\n\t\tsolve(N, (1 << N) - 1);\n\t\tcout << N - min_num << endl;\n\t}}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nint N;\nint x[30], y[30], r[30], c[30];\nint overlap[30], dp[1<<25];\n\nint rec(int S) {\n  if (dp[S] >= 0) return dp[S];\n  int ret = 0;\n  // select lhs\n  for (int i = 0; i < N - 1; ++i) {\n    if (S >> i & 1) continue;\n    if (overlap[i] > S) continue;\n    // select rhs\n    for (int j = i+1; j < N; ++j) {\n      if ((S >> j & 1) || c[i] != c[j]) continue;\n      if (overlap[j] > S) continue;\n      // remove\n      ret = max(ret, rec(S|(1<<i)|(1<<j)) + 2);\n    }\n  }\n  return dp[S] = ret;\n}\n\nint solve() {\n  // check overlap\n  memset(overlap, 0, sizeof overlap);\n  for (int i = 1; i < N; ++i) {\n    int lapped = 0;\n    for (int j = 0; j < i; ++j) {\n      int dx = x[i] - x[j], dy = y[i] - y[j], dc = r[i] + r[j];\n      if (dx * dx + dy * dy < dc * dc) lapped |= (1 << j);\n    }\n    overlap[i] = lapped;\n  }\n  memset(dp, -1, sizeof dp);\n  return rec(0);\n}\n\nint main() {\n  while (scanf(\"%d\", &N), N) {\n    rep(i,N) scanf(\"%d%d%d%d\", x+i, y+i, r+i, c+i);\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\nchar bit_count[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n-bit_count[bit];\n\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            if(((bit>>i)&1)==0)continue;\n            if(((bit>>j)&1)==0)continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(c[i]==c[j]&&ok(i,bit)&&ok(j,bit)&&!memo[to_bit]){\n                ret=max(ret,dfs(to_bit));\n            }\n        }\n    }\n\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\nvoid init(){\n    for(int i=0;i<(1<<24);i++){\n        for(int j=0;j<24;j++)if((i>>j)&1){\n            bit_count[i]++;\n        }\n    }\n}\n\nint main(){\n    init();\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nstruct Disc {\n\tint x, y, r, c;\n\tint depend;\n};\n\nmap<int, int> memo;\n\nint recur(vector<Disc> &discs, int picked){\n\tif(memo.find(picked) != memo.end()){ return memo[picked]; }\n\tvector<int> pickable[4];\n\tfor(int i = 0; i < discs.size(); ++i){\n\t\tif(picked & (1 << i)){ continue; }\n\t\tif(discs[i].depend & ~picked){ continue; }\n\t\tpickable[discs[i].c - 1].push_back(i);\n\t}\n\tint result = __builtin_popcount(picked);\n\tfor(int i = 0; i < 4; ++i){\n\t\tfor(int j = 0; j < pickable[i].size(); ++j){\n\t\t\tfor(int k = 0; k < j; ++k){\n\t\t\t\tint pick = (1 << pickable[i][j]) | (1 << pickable[i][k]);\n\t\t\t\tresult = max(result, recur(discs, picked | pick));\n\t\t\t}\n\t\t}\n\t}\n\tmemo[picked] = result;\n\treturn result;\n}\n\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tvector<Disc> discs(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> discs[i].x >> discs[i].y >> discs[i].r >> discs[i].c;\n\t\t}\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < i; ++j){\n\t\t\t\tint x = discs[i].x - discs[j].x;\n\t\t\t\tint y = discs[i].y - discs[j].y;\n\t\t\t\tint r = discs[i].r + discs[j].r;\n\t\t\t\tif(x * x + y * y < r * r){\n\t\t\t\t\tdiscs[i].depend |= (1 << j) | discs[j].depend;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemo.clear();\n\t\tcout << recur(discs, 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nint sq(int a) { return a*a; }\n\nint bitcount(int a) {\n    int c = 0;\n    while (a) c++, a&=a-1;\n    return c;\n}\n\nint n, x[30], y[30], r[30], c[30];\nint memo[1<<24];\n\nbool conf(int i, int j) {\n    return sq(r[i]+r[j]) > sq(x[i]-x[j])+sq(y[i]-y[j]);\n}\n\nint rec(int b) {\n    if (memo[b] != 0) return memo[b];\n    bool f[30];\n    rep (i, n) if ((b&(1<<i)) == 0) {\n        f[i] = true;\n        rep (j, i) if ((b&(1<<j)) == 0 && conf(i, j)) f[i] = false;\n    }\n    int ans = bitcount(b);\n    rep (i, n) if ((b&(1<<i)) == 0 && f[i]) {\n        rep (j, i) if ((b&(1<<j)) == 0 && f[j] && c[i] == c[j]) {\n            ans = max(ans, rec(b|(1<<i)|(1<<j)));\n        }\n    }\n    return memo[b] = ans;\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d\", &n);\n        if (n == 0) return 0;\n        memset(memo, 0, sizeof(memo));\n        rep (i, n) scanf(\"%d%d%d%d\", x+i, y+i, r+i, c+i);\n        printf(\"%d\\n\", rec(0));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n\nclass Disc{//~ÕÌîñð\\·NX\npublic:\n\tint x,y,r,c;\n\tDisc(int x,int y,int r,int c): x(x),y(y),r(r),c(c){}\n\tDisc(){};\n};\n\nint n;//~ÕÌ\nchar memo[1<<24];//Dp\nbool exist[24];//~ÕªcÁÄé©Ç¤©\nDisc D[24];//~Õðüêézñ\nint ans;//¦ðüêé\n\nbool touch(Disc a,Disc b){//2Ì~ÕªdÈÁÄ¢é©@ñæÉ·êÎë·ðCÉµÈ­Äàæ¢\n\treturn (a.r+b.r)*(a.r+b.r)>(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n}\n\nbool top(int k){//kÔÚÌ~ÕÌãÉ¼Ì~ÕªæÁÄ¢È¢©\n\tfor(int i=k-1;i>=0;i--){\n\t\tif(exist[i]){\n\t\t\tif(touch(D[k],D[i])){return false;}\n\t\t}\n\t}\n\treturn true;\n}\n\nint dfs(int bit,int num){//»µÄ[³Dæ\n\tif(memo[bit]>=0) return memo[bit];\n\tint res=num;\n\n\tfor(int i=0;i<n;i++){\n\t\tif(exist[i] && top(i)){\n\t\t\tfor(int j=i+1;j<n;j++){//j=0 Éµ½çTLEµ½\n\t\t\t\t//jÔÚÌ~Õª¶ÝµÄCãÉ¼Ì~ÕªæÁÄÈ­ÄCiÔÚÌ~ÕÆFªê\n\t\t\t\tif(exist[j] && top(j) && i!=j && D[i].c==D[j].c){\n\t\t\t\t\texist[i]=false;//æè­\n\t\t\t\t\texist[j]=false;\n\t\t\t\t\tres=dfs((bit&(~(1<<i)))&(~(1<<j)),num+2);\n\t\t\t\t\texist[i]=true;//ß·\n\t\t\t\t\texist[j]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemo[bit]=res;//é\n\tans=max(ans,res);\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin>>n && n!=0){\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tmemset(exist,true,sizeof(exist));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y,r,c;\n\t\t\tcin>>x>>y>>r>>c;\n\t\tD[i]=Disc(x,y,r,c);\n\t\t}\n\t\tans=0;\n\t\tdfs((1<<24)-1,0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n#include<set>\nusing namespace std;\n\nstruct object{\n// 各円を示す構造体\n\tint id;\n\tint posx;\n\tint posy;\n\tint rad;\n\tint color;\n\tlist<int> parent;\n};\n\nbool operator == (object a,object b){\n\treturn a.id==b.id;\n}\nbool operator < (object a, object b){\n\treturn a.id<b.id;\n}\nbool operator == (list<object> a,list<object>b){\n\tif(a.size()!=b.size())return false;\n\tlist<object>::iterator ita=a.begin(),itb=b.begin();\n\twhile(ita!=a.end()){\n\t\tif(!(*ita==*itb))return false;\n\t}\n\treturn true;\n}\nbool operator < (list<object> a, list<object> b){\n\tif(a.size()!=b.size()) return a.size()<b.size();\n\tlist<object>::iterator ita=a.begin(),itb=b.begin();\n\twhile(1){\n\t\tif(*ita==*itb){\n\t\t\t++ita;\n\t\t\t++itb;\n\t\t\tif(ita==a.end())return false;\n\t\t}else{\n\t\t\treturn *ita<*itb;\n\t\t}\n\t}\n}\n\nvoid checkcontact(object& upper,object& lower){\n//　2つの円の重なりを調べ、下の円に自分の上にある円のidを記録\n\tif((upper.posx-lower.posx)*(upper.posx-lower.posx)+(upper.posy-lower.posy)*(upper.posy-lower.posy)<(upper.rad+lower.rad)*(upper.rad+lower.rad)){\n\t\tlower.parent.push_back(upper.id);\n\t}\n}\n\nlist<object>::iterator nexttop(list<object>::iterator itcur,list<object>::iterator itl){\n// 現在iteratorと末端iteratorから、次の回収可能円を示すiterator又は末端iteratorを返却\n\tdo{\n\t\t++itcur;\n\t\tif(itcur==itl)return itcur;\n\t}while(!(*itcur).parent.empty());\n\treturn itcur;\n}\n\nunsigned int cal(list<object>& base,set< list<object> >& cald){\n\tif(cald.find(base)!=cald.end())return -1;\n\tlist<object> cop;\n\tlist<object>::iterator ita,itb,itc;\n\tunsigned int submax=-1,subret;\n\tfor(ita=base.begin();ita!=base.end();ita=nexttop(ita,base.end())){\n\t\tfor(itb=nexttop(ita,base.end());itb!=base.end();itb=nexttop(itb,base.end())){\n\t\t\tif((*itb).color==(*ita).color){\n\t\t\t\tcop=base;\n\t\t\t\tcop.remove(*ita);\n\t\t\t\tcop.remove(*itb);\n\t\t\t\tfor(itc=cop.begin();itc!=cop.end();++itc){\n\t\t\t\t\t(*itc).parent.remove((*ita).id);\n\t\t\t\t\t(*itc).parent.remove((*itb).id);\n\t\t\t\t}\n\t\t\t\tsubret=cal(cop,cald);\n\t\t\t\tif(subret<submax)submax=subret;\n\t\t\t}\n\t\t}\n\t}\n\tsubret=base.size();\n\tif(subret<submax)submax=subret;\n\tcald.insert(base);\n\treturn submax;\n}\nint main(){\n\tint n;\n\tobject tmp; \n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tlist<object> objects;\n\t\tlist<object>::iterator ita;\n\t\tset< list<object> > cald;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp.id=i;\n\t\t\tcin>>tmp.posx>>tmp.posy>>tmp.rad>>tmp.color;\n\t\t\ttmp.parent.clear();\n\t\t\tfor(ita=objects.begin();ita!=objects.end();++ita)checkcontact(*ita,tmp);\n\t\t\tobjects.push_back(tmp);\n\t\t}\n\t\tcald.clear();\n\t\tcout<<n-cal(objects,cald)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nstruct Solver\n{\n\tconst int N;\n\tVI xs, ys, rs, cs;\n\tset< vector<bool> > visited;\n\n\tint res;\n\n\tSolver( int n ) : N( n ), xs( N ), ys( N ), rs( N ), cs( N ), res( 0 )\n\t{\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tcin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n\t\t}\n\t\treturn;\n\t}\n\n\toperator int()\n\t{\n\t\tvector<bool> tmp( N, true );\n\t\tdfs( tmp );\n\t\treturn res;\n\t}\n\n\tvoid dfs( vector<bool> &exists )\n\t{\n\t\tif ( EXIST( visited, exists ) )\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tvisited.insert( exists );\n\t\tres = max<int>( res, count( ALL( exists ), false ) );\n\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tif ( overlapped( exists, i ) )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tREP( j, 0, i )\n\t\t\t{\n\t\t\t\tif ( !exists[i] || !exists[j] || cs[i] != cs[j] || overlapped( exists, j ))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\texists[i] = exists[j] = false;\n\t\t\t\tif ( !EXIST( visited, exists ) )\n\t\t\t\t{\n\t\t\t\t\tdfs( exists );\n\t\t\t\t}\n\t\t\t\texists[i] = exists[j] = true;\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\tbool overlapped( const vector<bool> &exists, const int p )\n\t{\n\t\tREP( i, 0, p )\n\t\t{\n\t\t\tif ( !exists[i] )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( ( xs[p] - xs[i] ) * ( xs[p] - xs[i] ) + ( ys[p] - ys[i] ) * ( ys[p] - ys[i] ) < ( rs[i] + rs[p] ) * ( rs[i] + rs[p] ) )\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int n; cin >> n, n; )\n\t{\n\t\tcout << Solver( n ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, x[26], y[26], r[26], col[26], b[26][26], dp[16777222];\nint solve(int bit) {\n\tif (dp[bit]) return dp[bit] - 1;\n\tint ret = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (col[i] != col[j]) continue;\n\t\t\tif (bit & (1 << i)) continue;\n\t\t\tif (bit & (1 << j)) continue;\n\t\t\tif ((bit & b[i][j]) == b[i][j]) {\n\t\t\t\tint res = solve(bit + (1 << i) + (1 << j));\n\t\t\t\tret = max(ret, res + 2);\n\t\t\t}\n\t\t}\n\t}\n\tdp[bit] = ret + 1;\n\treturn ret;\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i] >> r[i] >> col[i];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tb[i][j] = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tint disti = (x[k] - x[i]) * (x[k] - x[i]) + (y[k] - y[i]) * (y[k] - y[i]);\n\t\t\t\t\tint distj = (x[k] - x[j]) * (x[k] - x[j]) + (y[k] - y[j]) * (y[k] - y[j]);\n\t\t\t\t\tif (k < i && disti < (r[i] + r[k]) * (r[i] + r[k])) b[i][j] |= 1 << k;\n\t\t\t\t\tif (k < j && distj < (r[j] + r[k]) * (r[j] + r[k])) b[i][j] |= 1 << k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfill(dp, dp + (1 << n), 0);\n\t\tint ret = solve(0);\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n\nint8_t DP[1<<24];//LSB???i=0?????????\nint X[24];\nint Y[24];\nint R[24];\nint C[24];\nint cover[24];//???????????????????????????\nint n;\n\nint rec(int E){\n    if(~DP[E]) return DP[E];\n    int maximum=0;\n    for(int i=0;i<n;i++){\n        if((E&(1<<i))==0) continue;\n        if(cover[i]&E) continue;\n        for(int j=i+1;j<n;j++){\n            if((E&(1<<j))==0) continue;\n            if(cover[j]&E) continue;\n            if(C[i]==C[j]){\n                maximum=max(maximum,rec(E^(1<<i)^(1<<j))+2);\n            }\n        }\n    }\n    DP[E]=maximum;\n    return maximum;\n}\n\nint main(){\n    while(cin>>n,n){\n        for(int i=0;i<n;i++){\n            cin>>X[i]>>Y[i]>>R[i]>>C[i];            \n        }\n        fill(cover,cover+24,0);\n        for(int i=0;i<n;i++){//i???j???????????????????????????\n            for(int j=i+1;j<n;j++){\n                if(hypot(X[i]-X[j],Y[i]-Y[j])<R[i]+R[j]){\n                    cover[j]|=1<<i;\n                }\n            }\n        }\n        fill(DP,DP+(1<<24),-1);\n        DP[0]=0;\n        cout<<rec((1<<n)-1)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS=1e-10;\nbool EQ(double a,double b){\n\treturn abs(a-b)<EPS;\n}\n\nint n;\nint xs[101];\nint ys[101];\nint rs[101];\nint cs[101];\nint dp[1<<24];\nbool isNoCross(int a,int b){\n\tdouble sumR=rs[a]+rs[b];\n\tdouble dist=sqrt(1.0*(xs[a]-xs[b])*(xs[a]-xs[b])+(ys[a]-ys[b])*(ys[a]-ys[b]));\n\tif(EQ(sumR,dist)||sumR<dist)return true;\n\treturn false;\n}\n\nbool isOver(int a,int b){\n\tif(isNoCross(a,b))return true;\n\treturn a<b;\n}\n\nint dfs(int mask){\n\tif(dp[mask]>=0)return dp[mask];\n\tif(mask==(1<<n)-1)return 0;\n\tint res=0;\n\tint lt[30];\n\tint sz=0;\n\tfor(int i=0;i<n;i++){\n\t\tbool ok=true;\n\t\tif((mask>>i)&1)continue;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i==j)continue;\n\t\t\tif((mask>>j)&1)continue;\n\t\t\tif(!isOver(i,j)){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok)\n\t\t\tlt[sz++]=i;\n\t}\n\tfor(int i=0;i<sz;i++){\n\t\tfor(int j=i+1;j<sz;j++){\n\t\t\tint a=lt[i];\n\t\t\tint b=lt[j];\n\t\t\tif(cs[a]==cs[b]){\n\t\t\t\tint nmask=mask;\n\t\t\t\tnmask|=(1<<a);\n\t\t\t\tnmask|=(1<<b);\n\t\t\t\tres=max(res,dfs(nmask)+2);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[mask]=res;\n}\n\nvoid solve(){\n\n\twhile(cin>>n&&n){\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>xs[i]>>ys[i]>>rs[i]>>cs[i];\n\t\tint res=dfs(0);\n\t\tcout<<res<<endl;\n\t}\n}\nint main(){\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i,n) for((i)=0;(i)<(int)n;(i)++)\n#define foreach(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n\nint n, x[30], y[30], r[30], c[30], res;\nint memo[30];\n\nbool isOverlap(int a, int b) {\n  double sub_x = (double)(abs(x[a]-x[b]));\n  double sub_y = (double)(abs(y[a]-y[b]));\n  double dist = sqrt(sub_x*sub_x + sub_y*sub_y);\n  return (dist < r[a] + r[b]) ? 1 : 0 ;\n}\n\nvoid dfs(int S, int sum) {\n  //printf(\"%d %d\\n\", S, sum);\n  res = max(res, sum);\n  int i, j;\n  rep(i,n) if (!((1<<i)&S) && (S & memo[i]) == memo[i]) {\n    rep(j,n) if (!((1<<j)&S) && (S & memo[j]) == memo[j]) {\n      if (i == j || c[i] != c[j]) continue;\n      dfs(S|(1<<i)|(1<<j), sum + 2);\n    }\n  }\n}\n\nchar dp[1<<24+1];\n\nint main() {\n  int i, j;\n  while (cin>>n, n) {\n    res = 0;\n    memset(dp, -1, sizeof dp);\n    rep(i,n) cin>>x[i]>>y[i]>>r[i]>>c[i];\n    rep(i,n) {\n      memo[i] = 0;\n      rep(j,i) if (isOverlap(i,j)) memo[i] |= (1<<j);\n    }\n    //dfs(0, 0);\n    dp[0] = 0;\n    for(int S=0;S<(1<<n);S++) {\n      if(dp[S] == -1) continue;\n      res = max(res, (int)dp[S]);\n      rep(i,n) if (!((1<<i)&S) && (S & memo[i]) == memo[i]) {\n        rep(j,n) if (!((1<<j)&S) && (S & memo[j]) == memo[j]) {\n          if (i == j || c[i] != c[j]) continue;\n          int nS = S|(1<<i)|(1<<j);\n          dp[nS] = max((int)dp[nS], dp[S]+2);\n        }\n      }\n    }\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint main(){\n  int n;\n  cin >> n;\n  while(n!=0){\n    int sum=0;\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    int f=0;\n    int on[100]={};\n    //int cc[5]={};\n    vector<int> cc[5];\n    while(f==0){\n      f=1;\n      /*\n      for(i=0;i<24;i++) on[i]=0;\n      for(i=0;i<v.size();i++){\n\tfor(j=i+1;j<v.size();j++){\n\t  if(ch(v[i],v[j])==1) on[j]=1;\n\t}\n      }\n      for(i=0;i<5;i++) cc[i]=0;\n      for(i=0;i<v.size();i++){\n\tif(on[i]==0) cc[v[i].c]++;\n      }\n      */\n      int ff=0;\n      while(ff==0){\n\tff=1;\n\tfor(i=0;i<100;i++) on[i]=0;\n\tfor(i=0;i<5;i++) cc[i].clear();\n\tfor(i=0;i<v.size();i++){\n\t  for(j=i+1;j<v.size();j++){\n\t    if(ch(v[i],v[j])==1) on[j]=1;\n\t  }\n\t}\n\tfor(i=0;i<v.size();i++){\n\t  if(on[i]==0) cc[v[i].c].push_back(i);\n\t}\n\tfor(i=1;i<5;i++){\n\t  if(cc[i].size()>0&&cc[i].size()%2==0){\n\t    for(j=cc[i].size()-1;j>=0;j--){\n\t      v.erase(v.begin()+cc[i][j]);\n\t      ff=0;\n\t      f=0;\n\t    }\n\t  }\n\t}\n      }\n      \n      for(i=1;i<5;i++){\n\tk=0;\n\tfor(j=v.size()-1;j>=0;j--){\n\t  if(on[j]==0&&v[j].c==i){\n\t    if((cc[i].size()/2)*2>k) {\n\t      //cout << v[j].id << \" \";\n\t      v.erase(v.begin()+j);\n\t      k++;\n\t      f=0;\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout << n-v.size() << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\nusing namespace std;\n#define repeat(i,n) for (int i = 0; i < (n); ++i)\n#define repeat_from(i,m,n) for (int i = m; i < (n); ++i)\ntypedef set<int> seti;\n\n#ifdef DEBUG\n#include <cassert>\n#define debug(a) a\n#else\n#define debug(a)\n#endif\n\n// pos\nstruct pos { int x, y; };\npos operator+(const pos & p, const pos & q) { return (pos){p.x + q.x, p.y + q.y}; }\npos operator-(const pos & p) { return (pos){- p.x, - p.y}; }\npos operator-(const pos & p, const pos & q) { return p + (- q); }\nint dot(const pos & p, const pos & q) { return p.x * q.x + p.y * q.y; }\nint length_squared(const pos & p) { return dot(p,p); }\nistream & operator>>(istream & input, pos & p) { return input >> p.x >> p.y; }\n\n// circle\nstruct circle { pos p; int r; };\nint sq(int a) { return a * a; }\nbool is_intersected(const circle & a, const circle & b) { return length_squared(a.p - b.p) < sq(a.r + b.r); }\nistream & operator>>(istream & input, circle & a) { return input >> a.p >> a.r; }\n\n#define MAX_N 24\n#define MAX_COLOR 4\nint n;\ncircle c[MAX_N];\nint clr[MAX_N]; // in { 1, 2, 3, 4 }\nbool over[MAX_N][MAX_N]; // over[i][j] requires i < j\nbool used[MAX_N];\nint nest[MAX_N];\n\nint solve() {\n    int result = 0;\n    repeat (i,n) if (nest[i] == 0 and not used[i]) {\n        repeat_from (j,i+1,n) if (clr[j] == clr[i]) if (nest[j] == 0 and not used[j]) {\n            used[i] = used[j] = true;\n            repeat_from (k,i+1,n) if (over[i][k]) -- nest[k];\n            repeat_from (k,j+1,n) if (over[j][k]) -- nest[k];\n            result = max(result, solve()) + 2;\n            used[i] = used[j] = false;\n            repeat_from (k,i+1,n) if (over[i][k]) ++ nest[k];\n            repeat_from (k,j+1,n) if (over[j][k]) ++ nest[k];\n        }\n    }\n    return result;\n}\n\nint main() {\n    while (true) {\n        cin >> n;\n        if (n == 0) break;\n        repeat (i,n) {\n            cin >> c[i] >> clr[i];\n            used[i] = false; nest[i] = 0;\n            repeat (j,i) if (over[j][i] = is_intersected(c[i],c[j])) ++ nest[i];\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define len(v) (int)(v).size()\n\nusing namespace std;\n\nvector<int> G[25];\nmap<vector<int>,int> mp;\nvector<int> x,y,r,c;\nint p[25];\nint n;\n\nint dfs(vector<int> par)\n{\n    if(mp.find(par) != mp.end()){\n        return mp[par];\n    }\n    vector<vector<int> > cl(4);\n    rep(i,len(par)){\n        cl[c[par[i]]].pb(par[i]);\n    }\n    int mx = 0;\n    rep(i,4){\n        if(len(cl[i])>=2){\n            rep(j,len(cl[i])-1){\n                int pp[25] = {};\n                rep(k,n) pp[k] = p[k];\n                set<int> st1;\n                for(auto& v : G[cl[i][j]]){\n                    if((pp[v] >> cl[i][j])&1){\n                        pp[v] -= (1 << cl[i][j]);\n                        if(pp[v] == 0) st1.insert(v);\n                    }\n                }\n                for(int k=j;k<len(cl[i]);k++){\n                    set<int> st2;\n                    for(auto& v : G[cl[i][k]]){\n                        if((pp[v] >> cl[i][k])&1){\n                            pp[v] -= (1 << cl[i][k]);\n                            if(pp[v] == 0) st2.insert(v);\n                        }\n                    }\n                    vector<int> nvec;\n                    rep(l,len(par)){\n                        if(par[l] != cl[i][j] && par[l] != cl[i][k]){\n                            nvec.pb(par[l]);\n                        }\n                    }\n                    for(auto& val : st1){\n                        nvec.pb(val);\n                    }\n                    for(auto& val : st2){\n                        nvec.pb(val);\n                    }\n                    mx = max(mx,dfs(nvec)+2);\n                    for(auto& val : st2){\n                        pp[val] += (1 << cl[i][k]);\n                    }\n                }\n            }\n        }\n    }\n    return mx;\n}\n\ninline bool intersect(int i, int j)\n{\n    return (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j])*(r[i]+r[j]);\n}\n\nint main()\n{\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            G[i].clear();\n        }\n        mp.clear();\n        x.resize(n),y.resize(n),r.resize(n),c.resize(n);\n        rep(i,n){\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n            p[i] = 0;\n            c[i]--;\n            rep(j,i){\n                if(intersect(i,j)){\n                    G[j].pb(i);\n                    p[i] += (1 << j);\n                }\n            }\n        }\n        vector<int> par;\n        rep(i,n){\n            if(p[i] == 0){\n                par.pb(i);\n            }\n        }\n        cout << dfs(par) << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint x[30], y[30], r[30], c[30], n, ans;\nVI cnt[6];\n// d[i][j] i?????????j????????£?????????1\nbool d[30][30];\nvoid dfs(ll m) {\n  //cout << bitset<4>(m) << endl;\n  //???????????£?????????????????°???????????¨?????°??????\n  REP(i, 5) cnt[i] = {};\n  REP(i, n) {\n    //i????????¨??????????????£??????continue\n    if(m>>i&1) continue;\n    bool flag = true;\n    REP(j, n) {\n      //j????????¨??????????????£??????continue\n      if(m>>j&1) continue;\n      if(d[i][j]) flag = false;\n    }\n    if(flag) cnt[c[i]].PB(i);\n  }\n\n  bool g = false;\n  FOR(i, 1, 5) if(cnt[i].size()>=2) g = true;\n  //????????£????????????\n  if(!g) {\n    int sum=0;\n    REP(i, n) {\n      if(m>>i&1) sum++;\n    }\n    ans = max(ans, sum);\n    return;\n  }\n\n  FOR(i, 1, 5) {\n    //out << \"i:\" << cnt[i].size() << endl;\n    if(cnt[i].size()<=1) continue;\n    //???i??§?¶????????????°?????¶??°?????????????????¨??¨?¶????\n    if(cnt[i].size()%2 == 0) {\n      ll tmp = m;\n      for(int j: cnt[i]) {\n        tmp |= 1<<j;\n      }\n      dfs(tmp);\n    }\n    //?\\???°??????1???????????????????????¨??¨??????\n    else {\n      ll tmp = m;\n      for(int j: cnt[i]) {\n        tmp |= 1<<j;\n      }\n      REP(j, cnt[i].size()) {\n        dfs(tmp&~(1<<cnt[i][j]));\n      }\n    }\n  }\n\n  return;\n}\n\nsigned main(void)\n{\n  while(true) {\n    cin >> n;\n    if(!n) break;\n    REP(i, 30) REP(j, 30) d[i][j] = 0;\n    REP(i, n) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n      for(int j=i-1; j>=0; --j) {\n        // ??????i??¨??????j???????????£??????????????????i???????????????j????????¨????????????\n        double dist = sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j])), rr = r[i] + r[j];\n        //cout << dist << \" \" << rr << endl;\n        if(dist < rr) d[i][j] = true;\n      }\n    }\n    /*REP(i, n) {\n      REP(j, n) {\n        cout << d[i][j] << \" \";\n      }\n      cout << endl;\n    }*/\n    ans = 0;\n    dfs(0);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct cir {\n\tint x;\n\tint y;\n\tint r;\n\tint c;\n\tbool top;\n\tset<int> maue;\n};\n\nint main() {\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<cir> circle(n);\n\t\tREP(i, n) {\n\t\t\tcin >> circle[i].x >> circle[i].y >> circle[i].r >> circle[i].c;\n\t\t\tcircle[i].top = true;\n\t\t}\n\t\tREP(i, n/2)\n\t\tswap(circle[i], circle[n-1-i]);\n\t\tREP(i, n) {\n\t\t\tREP(j, i) {\n\t\t\t\t\tif ((circle[i].x - circle[j].x)*(circle[i].x - circle[j].x) +\n\t\t\t\t\t\t(circle[i].y - circle[j].y)*(circle[i].y - circle[j].y) <\n\t\t\t\t\t\t(circle[i].r + circle[j].r)*(circle[i].r + circle[j].r)) {\n\t\t\t\t\t\tcircle[j].top = false;\n\t\t\t\t\t\tcircle[j].maue.insert(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tqueue<vector<cir>> qvc;\n\t\tqvc.push(circle);\n\t\twhile (!qvc.empty())\n\t\t{\n\t\t\tvector<cir> Q = qvc.front();qvc.pop();\n\t\t\tans = max(ans,n - (int)Q.size());\n\t\t\tFOR(i,1,5) {\n\t\t\t\tREP(j, Q.size()) {\n\t\t\t\t\tif(Q[j].top&&Q[j].c==i)\n\t\t\t\t\tFOR(k, j + 1, Q.size()) {\n\t\t\t\t\t\tif (Q[k].top&&Q[k].c == i) {\n\t\t\t\t\t\t\tvector<cir> Q2 = Q;\n\t\t\t\t\t\t\tREP(l,Q2.size())\n\t\t\t\t\t\t\t\tif (EXIST(Q2[l].maue, j)) {\n\t\t\t\t\t\t\t\t\tQ2[l].maue.erase(j);\n\t\t\t\t\t\t\t\t\tif (Q2[l].maue.empty())\n\t\t\t\t\t\t\t\t\t\tQ2[l].top = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tREP(l, Q2.size())\n\t\t\t\t\t\t\t\tif (EXIST(Q2[l].maue, k)) {\n\t\t\t\t\t\t\t\t\tQ2[l].maue.erase(k);\n\t\t\t\t\t\t\t\t\tif (Q2[l].maue.empty())\n\t\t\t\t\t\t\t\t\t\tQ2[l].top = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tQ2.erase(Q2.begin() + k);\n\t\t\t\t\t\t\tQ2.erase(Q2.begin() + j);\n\t\t\t\t\t\t\tqvc.push(Q2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<bitset>\n#include<algorithm>\nusing namespace std;\n\n#define N 24\n\nclass Disk {\npublic:\n    int x, y, r, c;\n\n    Disk(int xx, int yy, int rr, int cc) :x(xx), y(yy), r(rr), c(cc) {}\n\n    bool on(const Disk& d) {\n        return (x - d.x) * (x - d.x) + (y - d.y) * (y - d.y) < (r + d.r) * (r + d.r);\n    }\n    bool sameColor(const Disk &d) {\n        return c == d.c;\n    }\n};\n\nint dfs(vector<Disk> disk, bitset<N> used) {\n    vector<int> candidate;\n    for(int i = 0; i < disk.size(); i++) {\n        if(used[i]) continue;\n        bool ok = true;\n        for(int j = 0; j < i; j++) {\n            if(used[j]) continue;\n            if(!disk[j].on(disk[i])) continue;\n            ok = false;\n            break;\n        }\n        if(ok) candidate.push_back(i);\n    }\n\n    int result = 0;\n    for(int ci = 0; ci < candidate.size(); ci++) {\n        for(int cj = 0; cj < ci; cj++) {\n            int i = candidate[ci];\n            int j = candidate[cj];\n            if(!disk[i].sameColor(disk[j])) continue;\n            bitset<N> u = used;\n            u.set(i);\n            u.set(j);\n            result = max(result, 2 + dfs(disk, u));\n        }\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<Disk> disk;\n        for(int i = 0; i < n; i++) {\n            int x, y, r, c;\n            cin >> x >> y >> r >>c;\n            disk.push_back(Disk(x, y, r, c));\n        }\n        cout << dfs(disk, bitset<N>(0)) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <bitset>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef complex<double> P;\n\nstruct C {\n  P p;\n  int r, c;\n};\nint n;\nvector<C> vc;\n\nint solve(int S) {\n//  cout << bitset<8>(S) << endl;\n  vector<int> hoge;\n  REP(i,n) {\n    if (S>>i&1) continue;\n    bool f = 0;\n    REP(j,i) {\n      if (S>>j&1) continue;\n      if (abs(vc[i].p-vc[j].p) < vc[i].r+vc[j].r)\n        f = 1;\n    }\n    if (!f)\n      hoge.push_back(i);\n  }\n  int res = 0;\n  // FOR(it, hoge)\n  //   cout << *it << \" \";\n  // cout << endl;\n  REP(i,hoge.size()) {\n    REP(j,i) {\n      if (vc[hoge[i]].c==vc[hoge[j]].c)\n        res = max(res, solve(S|(1<<hoge[i])|(1<<hoge[j])) + 2);\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(cin>>n,n) {\n    vc.clear();\n    REP(i,n) {\n      int x,y,r,cc;\n      cin >> x>>y>>r>>cc;\n      vc.push_back((C){P(x,y),r,cc});\n    }\n    cout << solve(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <assert.h>\n#include <queue>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\ntypedef pair<int,int> P;\ntypedef pair<int,P> Q;\ntypedef pair<int,Q> R;\n\nbool dist[(1<<24)];\nint n;\nint x[30],y[30],r[30],c[30];\nvector<int>col[4];\nint up[30];\nint main(){\n\t\n\twhile(1){\n\t\tcin>>n;if(n==0)return 0;\n\t\trep(i,4) col[i].clear();\n\t\trep(i,n){\n\t\t\tcin>>x[i]>>y[i]>>r[i]>>c[i]; c[i]--;\n\t\t\tcol[c[i]].pb(i);\n\t\t}\n\t\trep(i,n){\n\t\t\tup[i] = 0;\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tlong long dist = 1LL*(x[i]-x[j])*(x[i]-x[j])+1LL*(y[i]-y[j])*(y[i]-y[j]);\n\t\t\t\tlong long d2 = 1LL*(r[i]+r[j])*(r[i]+r[j]);\n\t\t\t\tif(dist < d2) up[i] |= (1<<j);\n\t\t\t}\n\t\t}\n\t\trep(i,(1<<n)) dist[i] = 0;\n\t\tdist[0] = 1;\n\t\trep(i,(1<<n)){\n\t\t\tif(dist[i] == false) continue;\n\t\t\trep(j,4){\n\t\t\t\trep(k,col[j].size()) for(int q=k+1;q<col[j].size();q++){\n\t\t\t\t\tint a = col[j][k], b = col[j][q];\n\t\t\t\t\tif(((i>>a)&1)) continue;\n\t\t\t\t\tif(((i>>b)&1)) continue;\n\t\t\t\t\tif(a > b) swap(a,b);\n\t\t\t\t\tif(((up[b]>>a)&1)) continue;\n\t\t\t\t\tif( (up[a]&i) == up[a] && (up[b]&i) == up[b] ){\n\t\t\t\t\t\tdist[i|(1<<a)|(1<<b)] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep(i,(1<<n)) if(dist[i]) ans = max(ans,__builtin_popcount(i));\n\t\tcout << ans << endl;\n\t}\n}\n\t\t\n\t\t\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nstruct Circle{\n\tint x, y, r, c;\n\t// コンストラクタで初期化\n\tCircle(int x_, int y_, int r_, int c_){\n\t\tx = x_; y = y_; r = r_; c = c_;\n\t};\n\t// this と円 cir が重なるかどうか \n\tbool is_intersect(const Circle& cir){\n\t\tint d = (x - cir.x) * (x - cir.x) + (y - cir.y) * (y - cir.y);\n\t\treturn ( d < (r + cir.r) * (r + cir.r) );\n\t}\n};\n\n// 円の個数\nint n;\n// 円 : v.size() <= 24\nvector<Circle> v;\n// exist[i] := 円 i が存在するかどうか.\nbool exist[24];\n// メモ\n// memo[bits] := 円の状態 bits のときのとり除ける枚数を返す. \nchar memo[1<<24];\n// 答え\nint ans;\n\n// 初期化\nvoid init(){\n\tv.clear();\n\tfor(int i=0 ; i < n ; i++ ) exist[i] = true;\n\tfor(int i=0 ; i < (1<<n) ; i++ ) memo[i] = -1;\n}\n\n// 円 k が一番上にあるかどうか\n// k > i となる すべての i の円と衝突していなければよい.\nbool is_top(int k){\n\tfor(int i = k-1 ; i >= 0 ; i-- ){\n\t\tif( exist[i] == false ) continue;\n\t\t\n\t\tif( v[k].is_intersect(v[i]) ){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n// メモ化再帰\nint dfs(int bits, int cnt){\n\tif( memo[bits] >= 0 ) return memo[bits];\n\tint result = cnt;\n\t\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tif( exist[i] == false || !is_top(i) ) continue;\n\t\t\n\t\tfor(int j=i+1 ; j < n ; j++ ){\n\t\t\tif( exist[j] == false || !is_top(j) || i == j ) continue;\n\t\t\t\n\t\t\t// 円 i と 円 j が取り除けたら取り除いて再帰\n\t\t\tif( v[i].c == v[j].c ){\n\t\t\t\texist[i] = false;\n\t\t\t\texist[j] = false;\n\t\t\t\tint next_bits = (bits & (~(1<<i))) & (~(1<<j));\n\t\t\t\tresult = dfs( next_bits , cnt+2 );\n\t\t\t\texist[i] = true;\n\t\t\t\texist[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t// メモ\n\tmemo[bits] = result;\n\t// 答えの更新\n\tans = max( ans , result );\n\treturn result;\n}\n\nint main(){\n\twhile( cin >> n , n ){\n\t\tinit();\n\t\t\n\t\t// 入力\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint x, y, r, c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tv.push_back( Circle( x , y , r , c ) );\n\t\t}\n\t\t\n\t\t// 探索\n\t\tans = 0;\n\t\tdfs( ((1<<n)-1) , 0 );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\nchar bit_count[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n-bit_count[bit];\n\n    for(int i=0;i<n;i++){\n        if(((bit>>i)&1)==0||ok(i,bit)==false)continue;\n        for(int j=i+1;j<n;j++){\n            if(ok(j,bit)==false||((bit>>j)&1)==0||c[i]!=c[j])continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(!memo[to_bit])ret=max(ret,dfs(to_bit));\n\n        }\n    }\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\nvoid init(){\n    for(int i=0;i<(1<<24);i++){\n        for(int j=0;j<24;j++)if((i>>j)&1){\n            bit_count[i]++;\n        }\n    }\n}\n\nint main(){\n    init();\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint x[25],y[25],r[25],c[25];\n\nbool in(int i, int j){\n    int dist = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n    int d = (r[i] + r[j]) * (r[i] + r[j]);\n    return dist < d;\n}\n\nint b[25]; // 上に重なっている円盤の番号(bit)\nchar dp[1 << 24];//i-bitが立っている = 円盤iは消えている\n\n\nint main(void) {\n    int i,j,k;\n    int n;\n    while(cin>>n, n){\n        rep(i,n){\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n            b[i] = 0;\n            rep(j,i)if(in(i,j)) b[i] |= (1<<j);\n        }\n\n        int ans = 0;\n        int m = (1 << n);\n        rep(i,m)dp[i] = -1;\n        dp[0] = 0;\n\n        rep(i,m){\n            if(dp[i] < 0) continue;\n            ans = max(ans, (int)dp[i]);\n\n            //残っている円盤の状態がiのときに消せる円盤のペア(j,k)を探す\n            rep(j,n){\n                if(i & (1 << j))continue; //すでに円盤jが消えている\n                if((i & b[j]) != b[j]) continue; //円盤j上の円盤(b[j])のどれかがまだ残っている\n\n                loop(k,j+1,n)if(c[j] == c[k]){\n                    if(i & (1 << k))continue; //すでに円盤kが消えている\n                    if((i & b[k]) != b[k]) continue; //円盤k上の円盤(b[k])のどれかがまだ残っている\n\n                    int next = i | (1 << j) | (1 << k); //円盤jと円盤kを消した状態\n                    dp[next] = max((int)dp[next], dp[i] + 2);\n                }\n\n            }\n\n        }\n\n        cout << ans << endl;\n\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<25];\n\n//dist(i,j)<r[i]+r[j]->ok\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            if(((bit>>i)&1)==0)continue;\n            if(((bit>>j)&1)==0)continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(c[i]==c[j]&&ok(i,bit)&&ok(j,bit)&&!memo[to_bit]){\n                ret=max(ret,dfs(to_bit));\n            }\n        }\n    }\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\nint main(){\n\n    int a=(1<<5)-1;\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint n;\nint x[24],y[24],r[24],c[24];\n\ninline bool intersect(int p, int q)\n{\n    double dist=sqrt((x[p]-x[q])*(x[p]-x[q])+(y[p]-y[q])*(y[p]-y[q]));\n    return dist<(r[p]+r[q]);\n}\n\ninline bool available(int p, int state)\n{\n    rep(i,p)\n    {\n        if(state>>i&1 && intersect(p,i)) return false;\n    }\n    return true;\n}\n\nunordered_map<int,int> dp;\n// int dp[1<<24];\nint dfs(int state)\n{\n    if(dp.find(state) != dp.end()) return dp[state];\n    // if(dp[state]>=0) return dp[state];\n    if(__builtin_popcount(state)<2) return 0;\n\n    int ret=0;\n    rep(i,n)\n    {\n        if(state>>i&1)\n        {\n            if(!available(i,state)) continue;\n\n            rep(j,n)\n            {\n                if(i==j) continue;\n                if(c[i]!=c[j]) continue;\n\n                if(state>>j&1)\n                {\n                    if(!available(j,state)) continue;\n                    ret = max(ret,dfs(state-(1<<i)-(1<<j))+2);\n                }\n            }\n        }\n    }\n\n    return dp[state]=ret;\n}\n\nint main()\n{\n    while(cin >>n,n)\n    {\n        rep(i,n) scanf(\" %d %d %d %d\", &x[i], &y[i], &r[i], &c[i]);\n        dp.clear();\n        cout << dfs((1<<n)-1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double R;//double long double ??????????????? cmath?????¢??°??????????????????????????????????????????????????§????????????\ntypedef complex<R> Point;\ntypedef pair<Point , Point> Line;\ntypedef pair<Point ,R > Circle;\ntypedef vector<Point> Poly;\n\n#define EPS (1e-10)//??????\n#define EQ(a,b) (abs((a)-(b)) < EPS)//??????????????°???????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )//????????????????????????????????????\n#define mp make_pair\n#define ft first\n#define sd second\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nR dot(Point a,Point b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nR cross(Point a,Point b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\nbool is_orthogonal(Line a,Line b){//2??´????????´?????????\n    return EQ(dot(a.ft - a.sd,b.ft - b.sd),0.0);\n}\nbool is_parallel(Line a,Line b){//2??´??????????????????\n    return EQ(cross(a.ft - a.sd,b.ft - b.sd),0.0);\n}\n\n////////////////////????????????\n\nint ccw(Point a,Point b,Point c){//ok\n    b -= a; c -= a;\n    if(cross(b,c) > EPS) return 1;//a???b??§???????¨???¨???????????????b???c\n    if(cross(b,c) < -EPS) return -1;//a???b??§????¨???¨???????????????b???c\n    if(dot(b,c) < -EPS) return 2;//c--a--b on same line\n    if(norm(c) - norm(b) > EPS) return -2;//a--b--c(abs??????????????????????????????????????????????????????????)\n    return 0;//a--c--b?????????b==c\n}\n\nbool is_intersection_ll(Line l,Line m){//???????????´??????????????????\n    return abs(cross(l.sd - l.ft,m.sd - m.ft)) > EPS || //????????§??????\n        abs(cross(l.sd - l.ft,m.ft - l.ft)) < EPS; //?????????????????????\n}\n\nbool is_intersection_ls(Line l,Line s){//??´???l??¨??????s???????????????\n    return cross(l.sd - l.ft, s.ft-l.ft)*       // s[0] is left of l\n        cross(l.sd - l.ft, s.sd - l.ft) < EPS; // s[1] is right of l\n}\n\nbool is_intersection_lp(Line l,Point p){//??´???l??¨???p???????????????\n    return abs(cross(l.sd - p,l.ft - p));\n}\n\nbool is_intersection_ss(Line a,Line b){//??????????????????????????????ok\n    return ccw(a.ft,a.sd,b.ft)*ccw(a.ft,a.sd,b.sd) <= 0 && ccw(b.ft,b.sd,a.ft)*ccw(b.ft,b.sd,a.sd) <= 0;\n}\n\nbool is_intersection_sp(Line s,Point p){//????????¨?????????????????? ????§??????????????????¨\n    return abs(s.ft - p) + abs(s.sd - p) - abs(s.ft - s.sd) < EPS;\n}\n\n/////////////?????¢\n\nR dis_lp(Line l,Point p){//??´???l??¨???p????????¢\n    return abs(cross(l.sd - l.ft,p - l.ft)) / abs(l.sd - l.ft);\n}\n\nR dis_ll(Line l,Line m){//???????????´???????????¢\n    return is_intersection_ll(l,m) ? 0.0 : dis_lp(l,m.ft);\n}\n\nR dis_ls(Line l,Line s){//??´???l??¨??????s????????¢\n    if(is_intersection_ls(l,s)) return 0.0;\n    return min(dis_lp(l,s.ft),dis_lp(l,s.sd));\n}\n\nR dis_sp(Line s,Point p){//??????s??¨???p????????¢\n    if(dot(s.sd - s.ft,p - s.ft) < EPS) return abs(p - s.ft);\n    if(dot(s.ft - s.sd,p - s.sd) < EPS) return abs(p - s.sd);\n    return dis_lp(s,p);\n}\n\nR dis_ss(Line s,Line t){//???????????????????????¢\n    if(is_intersection_ss(s,t)) return 0.0;\n    return min(min(dis_sp(s,t.ft),dis_sp(s,t.sd)),\n            min(dis_sp(t,s.ft),dis_sp(t,s.sd)));\n}\n\n//////////////?°???±??¨????°?\n\nPoint projection(Line l,Point p){//?°???±????±???????\n    R t = dot(p - l.ft,l.ft - l.sd) / norm(l.ft - l.sd);\n    return l.ft + t * (l.ft - l.sd);\n}\n\nPoint reflection(Line l,Point p){//????°?????±???????\n    return p + 2.0 * (projection(l,p) - p);\n}\n\n//////////////??????(????????????????¨???????????????¨??????????????????????????????????????£??????)\n\nPoint intersection_ll(Line l,Line m){//????????????????????????????????????????????????\n    R A = cross(l.sd - l.ft,m.sd - m.ft);\n    R B = cross(l.sd - l.ft,l.sd - m.ft);\n    if(abs(A) < EPS && abs(B) < EPS) return m.ft;//?????????\n    //if(abs(A) < EPS)assert(false);//????????§????????????\n    return m.ft + B / A * (m.sd - m.ft);\n}\n\nLine intersection_of_two_circles(Circle c1,Circle c2){//ok ????????????????????????Line?????\\????????????(r1 + r2 > sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2))???????????????????????????\n    R a =  abs(c2.ft - c1.ft);\n    R b = c1.sd;\n    R c = c2.sd;\n\n    R rc = (a  * a + b * b - c * c) / (2.0 * a);\n    R rs = sqrt(b * b - rc * rc);//C++ ??§???????????????????????????????????§???????????????sqrt ????????? float ?????????????????? long double ????????????????????????????????????????????¨?????§???????????? C ????????°????????§??????sqrt ????????? double ??????????????£??????????????????\n    Point diff = (c2.ft - c1.ft) / a;\n\n    Line p ;\n    p.ft = c1.ft + diff * rc + diff * Point(0,1) * rs;\n    p.sd = c1.ft + diff * rc + diff * Point(0,-1) * rs;\n\n    return p;\n}\n\n\nLine conver_line(Line a,Point maxi,Point mini){//??????????????´??????????????? maxi???????????????????????? mini?????????\n\n    if(abs(dot(a.sd - a.ft,Point(1.0,0.0))) < EPS){//??????x???????????´??????\n        ;\n    }\n}\n\n/////////////////////////polygon\n\n#define currP(P,i) P[i]//????????????\n#define nextP(P,i) P[(i + 1)%P.size()]//?¬??????????\n\nint is_contains_p_in_Poly(Poly po,Point p){//??????????§???¢????????¨(1)????¢????(-1)????????¨(0)??????????????????????????????\n    bool in = false;\n    REP(i,po.size()){\n        Point a = currP(po,i) - p,b = nextP(po,i) - p;\n        if(a.imag() > b.imag())swap(a,b);\n        if(a.imag() < EPS && -EPS < b.imag())\n            if(cross(a,b) < -EPS) in = !in;\n        if(abs(cross(a,b)) == 0.0 && dot(a,b) < EPS)return  -1;\n    }\n    return in;\n}\n\nR area2(Poly po){//????§???¢?????¢????????????????±???????\n    R A = 0.0;\n    REP(i,po.size())\n        A += cross(currP(po,i),nextP(po, i));\n    return A;\n}\n\n///////////////////////////???\n\nPoly convex_hull(Poly ps){\n    int n = ps.size(),k = 0;\n    Poly ch(2*n);\n    for(int i = 0;i < n;ch[k++] = ps[i++])// lower-hull\n        while(k >= 2 && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0) --k;\n    for(int i = n - 2,t = k + 1;i >= 0;ch[k++] = ps[i--])//upper-hull\n        while(k >= t && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\n#define prevP(P, i) P[(i+P.size()-1) % P.size()]\nbool isconvex(Poly P){\n    for(int i = 0;i < P.size();++i)\n        if(ccw(prevP(P,i),currP(P,i),nextP(P,i)) > 0) return false;\n    return true;\n}\n\nbool kosa(Circle c1, Circle c2) {\n  return abs(c1.ft-c2.ft)<(c1.sd+c2.sd);\n}\n\n#define MAX_N 25\n\nint n;\nCircle cs[MAX_N];\nint cc[MAX_N];\n\nbool input() {\n  cin>>n;\n  int x, y, r;\n  REP(i, n) {\n    cin>>x>>y>>r>>cc[i];\n    cs[i] = mp(Point(x, y), r);\n  }\n  return n!=0;\n}\n\nint dp[1<<MAX_N];\n\nint saiki(int S) {\n  if(dp[S] > -1)\n    return dp[S];\n  bool totta[MAX_N],toreru[MAX_N];\n  REP(i,n){totta[i] = S&(1<<i);toreru[i] = true;}\n  REP(i,n){\n    if(totta[i]){\n      toreru[i] = false;\n      continue;\n    }\n    REP(j,i){\n      if(!totta[j] && kosa(cs[i],cs[j])){\n        toreru[i] = false;\n        break;\n      }\n    }\n  }\n  bool f=false;\n  REP(i, n)f=f||toreru[i];\n  if(!f)return 0;\n  int maxi = 0;\n  REP(i,n){\n    if(toreru[i]){\n      FOR(j,i+1,n){\n        if(toreru[j] && cc[i] == cc[j])\n          maxi = max( maxi, saiki(S|(1<<i)|(1<<j))+2 );\n      }\n    }\n  }\n  return maxi;\n}\n\nvoid solve() {\n  REP(i,1<<n)\n    dp[i] = -1;\n  cout<<saiki(0)<<endl;\n}\n\nint main() {\n  \n  while(input()) {\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define len(v) (int)(v).size()\n\nusing namespace std;\n\nvector<int> G[25];\nint mp[(1 << 24)];\nvector<int> x,y,r,c;\nint p[25];\nint n;\n\nint dfs(int par)\n{\n    if(mp[par] >= 0){\n        return mp[par];\n    }\n    vector<vector<int> > cl(4);\n    rep(i,n){\n        if((par >> i)&1){\n            cl[c[i]].pb(i);\n        }\n    }\n    int mx = 0;\n    rep(i,4){\n        if(len(cl[i])>=2){\n            rep(j,len(cl[i])-1){\n                for(int k=j+1;k<len(cl[i]);k++){\n                    int u = cl[i][j], v = cl[i][k];\n                    int ch = (1 << u) + (1 << v);\n                    int npar = par - (1 << u) - (1 << v);\n                    rep(l,n){\n                        if(p[l] && !(p[l]&(~ch))){\n                            npar += (1 << l);\n                        }\n                    }\n                    mx = max(mx,dfs(npar)+2);\n                }\n            }\n        }\n    }\n    return mx;\n}\n\ninline bool intersect(int i, int j)\n{\n    return (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j])*(r[i]+r[j]);\n}\n\nint main()\n{\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            G[i].clear();\n        }\n        memset(mp,-1,sizeof(mp));\n        x.resize(n),y.resize(n),r.resize(n),c.resize(n);\n        rep(i,n){\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n            p[i] = 0;\n            c[i]--;\n            rep(j,i){\n                if(intersect(i,j)){\n                    G[j].pb(i);\n                    p[i] += (1 << j);\n                }\n            }\n        }\n        int par = 0;\n        rep(i,n){\n            if(p[i] == 0){\n                par += (1 << i);\n            }\n        }\n        cout << dfs(par) << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nstruct en {\n    int x,y,r,c;\n    vector<int> over;\n};\n\nint n, ans;\nvector<en> e;\nchar dp[1<<24];\n\nvoid solve(int bit) {\n    vector<vector<int> > a(5, vector<int>());\n    for (int i = 0; i < n; i++) {\n        if (bit & (1<<i)) continue;\n        bool f = true;\n        for (int j = 0; j < e[i].over.size(); j++) {\n            int t = e[i].over[j];\n            if (!(bit & (1<<t))) f = false;\n        }\n        if (f) a[e[i].c].push_back(i);\n    }\n    \n    \n    if (a[1].size() < 2 && a[2].size() < 2 && a[3].size() < 2 && a[4].size() < 2) {\n        ans = max(ans, dp[bit]-'a');\n        return;\n    }\n    \n    for (int i = 1; i < 5; i++) {\n        if (a[i].size() >= 2) for (int j = 0; j < a[i].size()-1; j++) {\n            for (int k = j+1; k < a[i].size(); k++) {\n                int nbit = bit;\n                nbit |= (1<<a[i][j]);\n                nbit |= (1<<a[i][k]);\n                dp[nbit] = dp[bit]+2;\n                solve(nbit);\n            }\n        }\n    }\n}\n\nint main(void){\n    while (cin>>n && n) {\n        ans = 0;\n        vector<en> e2(n);\n        e = e2;\n        memset(dp, 'a', sizeof(dp));\n        for (int i = 0; i < n; i++) {\n            cin >> e[i].x >> e[i].y >> e[i].r >> e[i].c;\n            for (int j = 0; j < i; j++) {\n                int tx = e[j].x - e[i].x;\n                int ty = e[j].y - e[i].y;\n                double t = sqrt(tx*tx + ty*ty);\n                if (t < e[i].r + e[j].r) e[i].over.push_back(j);\n            }\n        }\n        \n        solve(0);\n        cout << ans << endl;;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstruct Disc {\n  int x, y, r, c;\n};\n\nconst int MAX_N = 24;\nint N;\nDisc D[MAX_N];\nint on[MAX_N];\nint T[1<<MAX_N];\n\nint isIntersect(const Disc &a, const Disc &b) {\n  int dx = a.x - b.x;\n  int dy = a.y - b.y;\n  int sr = a.r + b.r;\n  if(dx*dx+dy*dy == sr*sr) return 1;\n  if(dx*dx+dy*dy < sr*sr) return 2;\n  return 0;\n}\n\nint make() {\n  for(int i = 0; i < N; ++i) {\n    on[i] = 0;\n    for(int j = i-1; j >= 0; --j) {\n      if(isIntersect(D[i], D[j]) == 2) on[i] |= 1<<j;\n    }\n  }\n}\n\nint solve() {\n  for(int S = (1<<N)-1; S >= 0; --S) {\n    T[S] = 0;\n    for(int i = 0; i < N; ++i) {\n      if(S & (1<<i)) continue;\n      if((S & on[i]) != on[i]) continue;\n      for(int j = i+1; j < N; ++j) {\n\tif(S & (1<<j)) continue;\n\tif((S & on[j]) != on[j]) continue;\n\n\tif(D[i].c != D[j].c) continue;\n\tT[S] = max(T[S], T[S | (1<<i) | (1<<j)]+2);\n      }\n    }\n  }\n  return T[0];\n}\n\nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i) {\n      cin >> D[i].x >> D[i].y >> D[i].r >> D[i].c;\n    }\n    make();\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cxxabi.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    ((ll)1ll<60)\n#define INF     ((int)1<<30)\n#define EPS     (1e-9)\n#define MOD     (1000000007)\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool b=1;for(auto s:t)os<<(exchange(b,0)||strlen(abi::__cxa_demangle(typeid(S).name(),0,0,0))>20?\"\":\" \")<<s;return os<<endl;}\n\n#define msk(a) ((int)1<<(a))\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\tint n;\n\twhile(cin>>n,n){\n\t    vi above(n,0);\n\t    vi dp(1<<n,0); //dp[取った円盤の集合]=何枚取り除いたか\n\t    vvi circ(n,vi(4));\n\t    rep(i,n){\n\t        cin>>circ[i][0]>>circ[i][1]>>circ[i][2]>>circ[i][3];\n\t        rep(j,i){\n\t            if(hypot(circ[i][0]-circ[j][0],circ[i][1]-circ[j][1])+EPS<circ[i][2]+circ[j][2]){\n\t                above[i]|=(1<<j);\n\t            }\n\t        }\n\t    }\n\t    int ans=0;\n\t    rep(s,1<<n){\n\t        if(s!=0 and dp[s]==0) continue;\n\t        rep(i,n) if((~s)&msk(i)) range(j,i+1,n) if((~s)&msk(j)){\n\t            if(circ[i][3]==circ[j][3]){\n    \t            if(!(above[i] & ~s) and !(above[j] & ~s)){\n            \t        //cout<<pii(i,j)<<endl;\n    \t                int ns=s|msk(i)|msk(j);\n\t                    dp[ns]=dp[s]+2;\n    \t                ans=max(ans,dp[ns]);\n    \t            }\n\t            }\n\t        }\n\t    }\n\t    cout<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint dp[1<<24];\n\nint main()\n{\n  int n;\n  int x[25], y[25], r[25], c[25], b[25];\n  while(cin >> n, n) {\n    for(int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i]; b[i] = 0;\n      for(int j = 0; j < i; j++) {\n\tif((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j])*(r[i]+r[j])) b[i] |= (1<<j);\n      }\n    }\n    memset(dp, -1, sizeof(dp));\n    dp[0] = 0;\n    for(int i = 0; i < (1<<n); i++) {\n      if(!~dp[i]) continue;\n      for(int j = 0; j < n-1; j++) {\n\tif(((i >> j) & 1) == 0 && (i & b[j]) == b[j]) {\n\t  for(int k = j+1; k < n; k++) {\n\t    if(c[j] == c[k] && ((i >> k) & 1) == 0 && (i & b[k]) == b[k]) {\n\t      dp[i|(1<<j)|(1<<k)] = max(dp[i|(1<<j)|(1<<k)], dp[i] + 2);\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout << *max_element(dp, dp + (1<<n)) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nstruct Circle\n{\n\tint x,y,r,c,m;\n};\n\nint N;\nchar mem[1<<24];\nCircle s[24];\n\nint solve(int state)\n{\n\tif(mem[state]>=0)\n\t{\n\t\treturn mem[state];\n\t}\n\n\tvector<int> del[4];\n\tfor(int i=0; i<N; i++)\n\t{\n\t\tif(state & (1<<i))\n\t\t{\n\t\t\tif(state & s[i].m) continue;\n\t\t\tdel[s[i].c].push_back(i);\n\t\t}\n\t}\n\n\tint res=0;\n\n\tfor(int k=0;   k<4; k++)\n\tfor(int i=0;   i<del[k].size(); i++)\n\tfor(int j=i+1; j<del[k].size(); j++)\n\t{\n\t\tint newstate = state;\n\t\tnewstate &= ~(1<<del[k][i]);\n\t\tnewstate &= ~(1<<del[k][j]);\n\t\tres = max(res, solve(newstate)+2);\n\t}\n\n\tmem[state] = res;\n\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin>>N, N)\n\t{\n\t\tmemset(mem, -1, sizeof(mem));\n\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tcin>>s[i].x>>s[i].y>>s[i].r>>s[i].c;\n\t\t}\n\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\ts[i].m=0;\n\t\t\tfor(int j=0; j<i; j++)\n\t\t\t{\n\t\t\t\tint dx = s[i].x-s[j].x;\n\t\t\t\tint dy = s[i].y-s[j].y;\n\t\t\t\tint dr = s[i].r+s[j].r;\n\t\t\t\tif(dx*dx+dy*dy < dr*dr)\n\t\t\t\t{\n\t\t\t\t\ts[i].m |= 1<<j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << solve((1<<N)-1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nvp in;\nvi r,cl;\nint out,sum,n;\nvi visit;\nvvi cost;\nbool hy(int a,int b){\n\tdouble dis=hypot(in[a].first-in[b].first,in[a].second-in[b].second);\n\treturn dis<r[a]+r[b];\n}\nvoid f(){\n\trep(i,n)loop(j,i+1,n)if(visit[i]+visit[j]==0&&cl[i]==cl[j]){\n\t\tbool h=true;\n\t\trep(l,n){\n\t\t\tif(l<i&&visit[l]==0&&cost[i][l])h=false;\n\t\t\tif(l<j&&visit[l]==0&&cost[j][l])h=false;\n\t\t}\n\t\tif(!h)continue;\n\t\tvisit[i]=visit[j]=1;\n\t\tsum+=2;\n\t\tout=max(out,sum);\n\t\tf();\n\t\tvisit[i]=visit[j]=0;\n\t\tsum-=2;\n\t}\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tin=vp(n);\n\t\tr=vi(n);\n\t\tcl=vi(n);\n\t\trep(i,n){\n\t\t\tcin>>in[i].first>>in[i].second;\n\t\t\tcin>>r[i]>>cl[i];\n\t\t\tcl[i]--;\n\t\t}\n\t\tvisit=vi(n);\n\t\tcost=vvi(n,vi(n));\n\t\trep(i,n)rep(j,n)cost[i][j]=hy(i,j);\n\t\tout=sum=0;\n\t\tf();\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 24\n\nint N,x[MAX],y[MAX],r[MAX],c[MAX];\n\nint dist(int a,int b){\n    return pow(x[a]-x[b],2)+pow(y[a]-y[b],2);\n}\n\nbool check(int a,int b){\n    double d = dist(a,b);\n    return ((r[a]-r[b])*(r[a]-r[b]) < d &&\n            d < (r[a]+r[b])*(r[a]+r[b]));\n}\n\nbool check(int S,int a,int b){\n    bool c[2] = {};\n    for(int i = 0 ; i < N ; i++){\n        if(!c[0]){\n            if(i == a) c[0] = 1;\n            else if(check(a,i)) return 0;\n        }\n        if(!c[1]){\n            if(i == b) c[1] = 1;\n            else if(check(b,i)) return 0;\n        }\n    }\n    return 1;\n}\n\nint main(){\n    while(cin >> N, N){\n        for(int i = 0 ; i < N ; i++){\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n        vector<short> dp(1<<N,-1);\n\tdp[(1<<N)-1] = 0;\n        for(int i = (1<<N)-1 ; i >= 0 ; i--){\n            for(int j = 0 ; j < N ; j++){\n                for(int k = j+1 ; k < N ; k++){\n                    if(c[j] != c[k]) continue;\n                    int S = i | (1<<j) | (1<<k);\n\t\t    if(dp[S] == -1) continue;\n                    if(!check(i,j,k)) continue;\n                    if(dp[i]+1 > dp[S]){\n                        dp[S] = dp[i]+1;\n                    }\n                }\n            }\n        }\n        cout << *max_element(dp.begin(),dp.end())*2 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> disc;\n\nint check(int a, int crtState) {\n    int ret = 1;\n    int xA = disc[a][0];\n    int yA = disc[a][1];\n    int rA = disc[a][2];\n    for (int i = 0; i < a; i++) {\n        if (crtState & (1 << i)) continue;\n        int x = disc[i][0];\n        int y = disc[i][1];\n        int r = disc[i][2];\n        int dist = (xA - x)*(xA - x) + (yA - y)*(yA - y);\n        int distR = (rA+r)*(rA+r);\n        if (dist < distR) ret = 0;\n    }\n    \n    return ret;\n}\n\n\nint solve(int N) {\n    disc.clear();\n    for (int i = 0; i < N; i++) {\n        int x, y, r, c; cin >> x >> y >> r >> c;\n        disc.push_back({x, y, r, c});\n    }\n    \n    vector<int> v((1 << N), -1);\n    v[0] = 0;\n    queue<int> que;\n    que.push(0);\n    while (!que.empty()) {\n        int crtState = que.front();\n        que.pop();\n        for (int i = 0; i < N; i++) {\n            for (int j = i+1; j < N; j++) {\n                int bitI = (1 << i);\n                int bitJ = (1 << j);\n                if ((bitI & crtState) || (bitJ & crtState)) continue;\n                int nextState = crtState + bitI + bitJ;\n                if (v[nextState] >= 0) continue;\n                if (disc[i][3] == disc[j][3] && check(i, crtState) && check(j, crtState)) {\n                    v[nextState] = v[crtState] + 1;\n                    que.push(nextState);\n                }\n            }\n        }\n    }\n    \n    int ret = 0;\n    for (int i = 0; i < (1 << N); i++) {\n        ret = max(ret, v[i]);\n    }\n    return ret*2;\n}\n\nint main(void){\n    int N;\n    vector<int> ans;\n    while (1) {\n        cin >> N;\n        if (!N) break;\n        ans.push_back(solve(N));\n    }\n    for (auto &i : ans) {\n        cout << i << endl;\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define N 24\n\nchar d[1<<N];\nint x[N],y[N],r[N],c[N];\n\nbool pailed(int a,int b){\n  int d2 = (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);\n  int r2 = (r[a]+r[b])*(r[a]+r[b]);\n  return d2 < r2;\n}\n\nint main(){\n  int n;\n  while(cin >> n,n){\n    vector<int> over(n);\n    fill(over.begin(),over.end(),0);\n\n    for(int i=0;i<n;i++){\n      scanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n    }\n    for(int i=n-1;i>=0;i--){\n      for(int j=i-1;j>=0;j--){\n        if(pailed(i,j)){\n          over[i] |= 1<<j;\n        }\n      }\n    }\n\n    fill(d,d+(1<<n),0);\n    for(int i=0;i<1<<n;i++){\n      for(int j=0;j<n-1;j++){\n        if(!(i>>j&1)||over[j]&i) continue;\n        for(int k=j+1;k<n;k++){\n          if(!(i>>k&1)||over[k]&i||c[k]!=c[j]) continue;\n            d[i] = 2 + d[(~(1<<j))&(~(1<<k))&i];\n        }\n      }\n    }\n    cout << (int)d[(1<<n)-1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint ret=0;\nint x[30];\nint y[30];\nint r[30];\nint c[30];\nint used[30];\nint n;\nint now;\nvoid solve(){\n\tret=max(ret,now);\n\tint can[30];\n\tfor(int i=0;i<n;i++)can[i]=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(used[i])continue;\n\t\tcan[i]=1;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(!used[j]&&(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])<(r[i]+r[j])*(r[i]+r[j]))can[i]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++){\n\t\tif(can[i]&&can[j]&&c[i]==c[j]){\n\t\t\tnow+=2;\n\t\t\tused[i]=used[j]=1;\n\t\t\tsolve();\n\t\t\tused[i]=used[j]=0;\n\t\t\tnow-=2;\n\t\t}\n\t}\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=a-1;i>=0;i--)scanf(\"%d%d%d%d\",x+i,y+i,r+i,c+i);\n\t\tret=0;n=a;\n\t\tfor(int i=0;i<a;i++)used[i]=0;\n\t\tnow=0;\n\t\tsolve();\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct circle{\n  double x, y, r;\n  int c;\n  unordered_set<int> up, down;\n};\n\nvoid calcOverlap(int n, circle *disk){\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      int x = disk[i].x - disk[j].x, y = disk[i].y - disk[j].y;\n      if(sqrt(x*x + y*y) + 1e-8< disk[i].r + disk[j].r){\n        disk[j].up.insert(i);\n        disk[i].down.insert(j);\n      }\n    }\n  }\n}\n\nbool canRemove(circle d, circle dd){\n  if(d.c != dd.c)return false;\n  if(not d.up.empty() or\n     not dd.up.empty())return false;\n  return true;\n}\n\nint dfs(int n, circle *disk, bool *removed, int dep = 0){\n  int res = 0;\n  bool f = false;\n  for (int i = 0; i < n; i++) {\n    if(removed[i] == true)continue;\n    for (int j = i + 1; j < n; j++) {\n      if(removed[j] == true)continue;\n      if(not canRemove(disk[i], disk[j]))continue;\n      f = true;\n      removed[i] = true;\n      removed[j] = true;\n      vector<int> erase_i, erase_j;\n      for (int k = 0; k < n; k++) {\n        if(disk[k].up.find(i) != disk[k].up.end()){\n          disk[k].up.erase(i);\n          erase_i.push_back(k);\n        }\n        if(disk[k].up.find(j) != disk[k].up.end()){\n          disk[k].up.erase(j);\n          erase_j.push_back(j);\n        }\n      }\n      res = max(res, dfs(n, disk, removed, dep + 1));\n      for (int k = 0; k < erase_j.size(); k++) {\n        disk[erase_j[k]].up.insert(j);\n      }\n      for (int k = 0; k < erase_i.size(); k++) {\n        disk[erase_i[k]].up.insert(i);\n      }\n      removed[i] = false;\n      removed[j] = false;\n    }\n  }\n  return f?res:dep;\n}\n\nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n, n){\n    circle disk[n];\n    for (int i = 0; i < n; i++) {\n      cin >> disk[i].x >> disk[i].y >> disk[i].r >> disk[i].c;\n    }\n    bool removed[n];\n    memset(removed, false, sizeof(removed));\n    calcOverlap(n, disk);\n    int ans = 0;\n    // for (int i = 0; i < n; i++) {\n    //   for (int j = i + 1; j < n; j++) {\n    //     if(not canRemove(disk[i], disk[j]))continue;\n    //     if(not disk[i].down.empty() or\n    //        not disk[j].down.empty())continue;\n    //     removed[i] = true;\n    //     removed[j] = true;\n    //     ans++;\n    //   }\n    // }\n    std::cout << 2*(ans + dfs(n, disk, removed)) << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n \nstruct Disc{\n    int x,y,r,c;\n    Disc(int p_x,int p_y,int p_r,int p_c){\n        x=p_x;y=p_y;r=p_r;c=p_c;\n    }\n    Disc(){};\n};\n \nint n;\nchar memo[1<<24];\nbool exist[24];\nDisc D[24];\nint ans;\n \nbool touch(Disc a,Disc b){\n    return (a.r+b.r)*(a.r+b.r)>(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n}\n \nbool top(int k){\n    for(int i=k-1;i>=0;i--){\n        if(exist[i]){\n            if(touch(D[k],D[i])){return false;}\n        }\n    }\n    return true;\n}\n \nint dfs(int bit,int num){\n    if(memo[bit]>=0) return memo[bit];\n    int res=num;\n \n    for(int i=0;i<n;i++){\n        if(exist[i] && top(i)){\n            for(int j=i+1;j<n;j++){\n                if(exist[j] && top(j) && i!=j && D[i].c==D[j].c){\n                    exist[i]=false;\n                    exist[j]=false;\n                    res=dfs((bit&(~(1<<i)))&(~(1<<j)),num+2);\n                    exist[i]=true;\n                    exist[j]=true;\n                }\n            }\n        }\n    }\n    memo[bit]=res;\n    ans=max(ans,res);\n    return res;\n}\n \nint main()\n{\n    while(cin>>n && n!=0){\n        ans=0;\n        memset(memo,-1,sizeof(memo));\n        memset(exist,true,sizeof(exist));\n        for(int i=0;i<n;i++){\n            int x,y,r,c;\n            cin>>x>>y>>r>>c;\n        D[i]=Disc(x,y,r,c);\n        }\n        ans=0;\n        dfs((1<<24)-1,0);\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <functional>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n\nusing namespace std;\n\ntypedef long long int lli;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) {\n    return vector<T>(a, b);\n}\n\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\nstruct Data {\n    int x, y, r, c;\n    Data(int _x, int _y, int _r, int _c)\n        : x(_x), y(_y), r(_r), c(_c) {}\n    Data() {}\n};\n\nint pw2(int n) {\n    return n * n;\n}\n\nbool inside(Data &d1, Data &d2) {\n    return (pw2(d1.x - d2.x) + pw2(d1.y - d2.y)) < pw2(d1.r + d2.r);\n}\n\nint bitcount(int a) {\n    int res = 0;\n    while (a) {\n        res += a % 2;\n        a >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector<Data> circles(n);\n        REP(i, 0, n) {\n            int x, y, r, c;\n            cin >> x >> y >> r >> c;\n            circles[i] = Data(x, y, r, c);\n        }\n        vector<bool> memo(1 << n, false);\n        function<bool(int, int, int)> check = [&](int state, int a, int b) -> bool {\n            bool ok = true;\n            REP(i, 0, a) {\n                if (state & (1 << i)) {\n                    ok &= (!inside(circles[i], circles[a]));\n                }\n            }\n            REP(i, 0, b) {\n                if (state & (1 << i)) {\n                    ok &= (!inside(circles[i], circles[b]));\n                }\n            }\n            return ok;\n        };\n        function<void(int)> rec = [&](int state) {\n            if (memo[state]) return;\n            memo[state] = true;\n            REP(i, 0, n) {\n                REP(j, i + 1, n) {\n                    if (circles[i].c == circles[j].c) {\n                        int a = 1 << i, b = 1 << j;\n                        if (((state & a) != a) || ((state & b) != b)) continue;\n                        if (check(state, i, j)) {\n                            rec(state ^ a ^ b);\n                        }\n                    }\n                }\n            }\n        };\n        rec((1 << n) - 1);\n        int ans = 0;\n        REP(i, 0, 1 << n) {\n            if (memo[i]) {\n                ans = max(ans, n - bitcount(i));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n)-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(b)-1;i>=(a);--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n    if (a > b) { a = b; return true; }\n    return false;\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp);\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v);\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"{\";\n    int a = 0;\n    for (auto &tp : mp) {\n        if (a) os << \", \"; a = 1;\n        os << tp;\n    }\n    return os << \"}\";\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        int n; cin >> n;\n        if (n == 0) break;\n\n        vi x(n), y(n), r(n), c(n);\n        REP(i, n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n        vi dp(1<<n);\n        dp[0] = 1;\n        REP(s, 1<<n) {\n            if (dp[s] == 0) continue;\n\n            map<int, vi> remove;\n            REP(i, n) {\n                if (s >> i & 1) continue;\n                bool valid = true;\n                REP(j, i) {\n                    if (s >> j & 1) continue;\n                    int dx = x[i] - x[j], dy = y[i] - y[j];\n                    double d = sqrt(dx * dx + dy * dy);\n                    if (r[i] + r[j] > d + eps) valid = false;\n                }\n                if (valid) remove[c[i]].push_back(i);\n            }\n            for (auto &tp : remove) {\n                REP(i, tp.second.size()) {\n                    FOR(j, i+1, tp.second.size()) {\n                        int t = s;\n                        t |= 1<<tp.second[i];\n                        t |= 1<<tp.second[j];\n                        dp[t] = 1;\n                    }\n                }\n            }\n        }\n\n        int ans = 0;\n        REP(s, 1<<n) if (dp[s]) chmax(ans, __builtin_popcount(s));\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    int n; cin >> n;\n    if (!n) break;\n    V<> x(n), y(n), r(n), c(n); for (int i = 0; i < n; ++i) cin >> x[i] >> y[i] >> r[i] >> c[i], --c[i];\n    V<bool> b(n, true);\n    int res = 0;\n    for (int _ = 0; _ < 100; ++_) {\n      VV<> idx(4);\n      for (int i = 0; i < n; ++i) if (b[i]) {\n        bool ok = true;\n        for (int j = 0; j < i; ++j) if (b[j]) {\n          if ((x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]) < (r[i] + r[j]) * (r[i] + r[j])) {\n            ok = false;\n            break;\n          }\n        }\n        if (ok) idx[c[i]].push_back(i);\n      }\n      for (int i = 0; i < 4; ++i) {\n        while (idx[i].size() >= 2) {\n          for (int _ = 0; _ < 2; ++_) {\n            b[idx[i].back()] = false;\n            idx[i].pop_back();\n          }\n          res += 2;\n        }\n      }\n    }\n    cout << res << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint n,x[30],y[30],r[30],c[30],cover[30];\nchar dp[1<<24];\nvector<int> same_col[5];\n\nint rec(int bit){\n  if(dp[bit])return dp[bit];\n\n  int res = 0;\n  for(int i=0;i<4;i++){\n    if(same_col[i].size()<2)continue;\n    for(int a : same_col[i])for(int b : same_col[i]){\n\tif(a<=b)continue;\n\tif( (~bit)&(1<<a) && (~bit)&(1<<b) ){\n\t  if( (~bit)&cover[a] || (~bit)&cover[b])continue;\n\t  res = max(res, rec(bit | (1<<a) | (1<<b))+2);\n\t}\n      }\n  }\n  return dp[bit]=res;\n}\n  \nint main(){\n  while(cin >> n, n){\n    for(int i=0;i<n;i++)cin >> x[i] >> y[i] >> r[i] >> c[i];\n    for(int i=0;i<4;i++)same_col[i].clear();\n\n    for(int i=0;i<n;i++){\n      same_col[c[i]-1].push_back(i);\n      cover[i] = 0;\n      for(int j=0;j<i;j++){\n\tif( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j])*(r[i]+r[j]) ){\n\t  cover[i] |= 1<<j;\n\t}\n      }\n    }\n\n    memset(dp,0,sizeof(dp));\n    cout << rec(0) << endl;\n  }\t  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#define x first.first\n#define y first.second\n#define r second.first\n#define color second.second\n\nusing namespace std;\n\ntypedef pair<double,double> P;\ntypedef pair<P,P> C;\n\nconst double EPS = 1e-10;\n\ndouble dist(C a,C b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nbool check(C a,C b){\n  return a.r+b.r>dist(a,b);\n}\n\nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<C>c(n);\n    for(int i=0;i<n;i++)\n      cin >> c[i].x >> c[i].y >> c[i].r >> c[i].color;\n    \n    static int dp[(1<<n)];\n    fill(dp,dp+(1<<n),0);\n\n    for(int S=(1<<n)-1;S>=0;S--){\n      for(int i=0;i<n;i++){\n\tfor(int j=i+1;j<n;j++){\n\t  if(!(S>>i&1) || !(S>>j&1))continue;\n\t  if(c[i].color!=c[j].color)continue;\n\n\t  bool fg=false;\n\t  for(int k=0;k<n;k++){\n\t    if(i!=k && check(c[i],c[k]))fg=true;\n\t    if(j!=k && check(c[j],c[k]))fg=true;\n\t  }\n\t  //if(fg)continue;\n\n\t  int nx=S;\n\t  nx&=~(1<<i);\n\t  nx&=~(1<<j);\n\t  dp[nx]=max(dp[nx],dp[S]+2);\n\t}\n      }\n    }\n    int ans=0;\n    for(int i=0;i<(1<<n);i++)ans=max(ans,dp[i]);\n    cout << ans-2 << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct disk{\n    int x,y,r,c;\n    disk(int x, int y, int r, int c):x(x),y(y),r(r),c(c){}\n    disk(){}\n};\nbool bittrue(int n, int i){\n    return (n&(1<<i)) != 0;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        vector<disk> d(n);\n        vector<vector<int> > ovl(n);\n        for(int i=0; i<n; i++){\n            int x,y,r,c;\n            cin >> x >> y >> r >> c;\n            d[i] = disk(x,y,r,c);\n            for(int j=0; j<i; j++){\n                if((x-d[j].x)*(x-d[j].x)+(y-d[j].y)*(y-d[j].y) < (r+d[j].r)*(r+d[j].r)){\n                    ovl[i].push_back(j);\n                }\n            }\n        }\n\n        char ans = 0;\n        vector<char> dp(1<<n, -1);\n        dp[0] = 0;\n        for(int b=0; b<(1<<n); b++){\n            if(dp[b]==-1) continue;\n            for(int i=0; i<n; i++){\n                if(bittrue(b,i)) continue;\n                bool flag=true;\n                for(int k=0; k<(int)ovl[i].size(); k++){\n                    if(!bittrue(b,ovl[i][k])){\n                        flag = false;\n                        break;\n                    }\n                }\n                if(!flag) continue;\n                \n                for(int j=i+1; j<n; j++){\n                    if(bittrue(b,j) || d[i].c != d[j].c) continue;\n                    bool flag = true;\n                    for(int k=0; k<(int)ovl[j].size(); k++){\n                        if(!bittrue(b, ovl[j][k])){\n                            flag=false;\n                            break;\n                        }\n                    }\n                    if(flag){\n                        int next = b|(1<<i)|(1<<j);\n                        dp[next] = max((int)dp[next], dp[b]+2);\n                        ans = max(ans, dp[next]);\n                    }\n                }\n            }\n        }\n\n        cout << (int)ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n\nint pow2(int m){\n\treturn m * m;\n};\n\nint max(int a,int b){\n\tif(a > b)\n\t\treturn a;\n\telse\n\t\treturn b;\n};\n\nint x[24], y[24], r[24], c[24], n, p = 0, mx;\n\nvoid dfs(void){\n\tint i, j, k, l, t, m, tmp1, tmp2;\n\tmx = max(p,mx);\n\tfor(i = 1;i <= 4;i++){\n\t\tfor(j = 0;j < n - 1;j++){\n\t\t\tif(c[j] == i && x[j] != -1){\n\t\t\t\tfor(k = j + 1;k < n;k++){\n\t\t\t\t\tif(c[k] == i && x[k] != -1){\n\t\t\t\t\t\tfor(l = 0;l < j;l++){\n\t\t\t\t\t\t\tif(x[l] == -1) continue;\n\t\t\t\t\t\t\tif(sqrt((double)(pow2(x[l] - x[j]) + pow2(y[l] - y[j]))) < r[l] + r[j])\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(m = 0;m < k;m++){\n\t\t\t\t\t\t\tif(x[m] == -1) continue;\n\t\t\t\t\t\t\tif(sqrt((double)(pow2(x[m] - x[k]) + pow2(y[m] - y[k]))) < r[m] + r[k])\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(l == j && m == k){\n\t\t\t\t\t\t\ttmp1 = x[j];\n\t\t\t\t\t\t\ttmp2 = x[k];\n\t\t\t\t\t\t\tx[j] = -1;\n\t\t\t\t\t\t\tx[k] = -1;\n\t\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\t\tdfs();\n\t\t\t\t\t\t\tp -= 2;\n\t\t\t\t\t\t\tx[j] = tmp1;\n\t\t\t\t\t\t\tx[k] = tmp2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tint i, ans;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)\n\t\t\tbreak;\n\t\tmx = 0;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n\t\tdfs();\n\t\tprintf(\"%d\\n\",mx);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nstruct Disc {\n\tint x, y, r, c;\n\tint depend;\n};\n\nint memo[1 << 24];\n\nint recur(vector<Disc> &discs, int picked){\n\tif(memo[picked] >= 0){ return memo[picked]; }\n\tvector<int> pickable[4];\n\tfor(int i = 0; i < discs.size(); ++i){\n\t\tif(picked & (1 << i)){ continue; }\n\t\tif(discs[i].depend & ~picked){ continue; }\n\t\tpickable[discs[i].c - 1].push_back(i);\n\t}\n\tint result = __builtin_popcount(picked);\n\tfor(int i = 0; i < 4; ++i){\n\t\tfor(int j = 0; j < pickable[i].size(); ++j){\n\t\t\tfor(int k = 0; k < j; ++k){\n\t\t\t\tint pick = (1 << pickable[i][j]) | (1 << pickable[i][k]);\n\t\t\t\tresult = max(result, recur(discs, picked | pick));\n\t\t\t}\n\t\t}\n\t}\n\tmemo[picked] = result;\n\treturn result;\n}\n\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tvector<Disc> discs(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> discs[i].x >> discs[i].y >> discs[i].r >> discs[i].c;\n\t\t}\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < i; ++j){\n\t\t\t\tint x = discs[i].x - discs[j].x;\n\t\t\t\tint y = discs[i].y - discs[j].y;\n\t\t\t\tint r = discs[i].r + discs[j].r;\n\t\t\t\tif(x * x + y * y < r * r){\n\t\t\t\t\tdiscs[i].depend |= (1 << j) | discs[j].depend;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tcout << recur(discs, 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nstruct Data\n{\n    int x;\n    int y;\n    int r;\n    int c;\n};\n\ntypedef struct Data D;\n\nmap<string, char> m;\nvector<D> input;\n\nint solve(string now)\n{\n    // cout << now << endl;\n    // cout << (m.find(now) == m.end()) << endl;\n    if(m.find(now) != m.end()) return m[now];\n    // cout << \"hey\" << endl;\n    m[now] = 0;\n    vector<vector<int> >  colornum(5);\n    // cout << \"ho\" << n << endl;\n    for(int i = 0; i < input.size(); i++){\n        if(now[i] == '0') continue;\n        bool notcovered = true;\n        // cout << i << \" : \" << input[i].x << \" \" << input[i].y << \" \" << input[i].r << \" \" << input[i].c << endl;\n        for(int j = 0; j < i; j++){\n            if(now[j] == '0') continue;\n            // cout << i << \",\" << j << \":\" << pow(input[i].x - input[j].x, 2) + pow(input[i].y - input[j].y, 2) << \" \" << pow(input[i].r + input[j].r, 2) << endl;\n            if(pow(input[i].x - input[j].x, 2) + pow(input[i].y - input[j].y, 2) < pow(input[i].r + input[j].r, 2)){\n                notcovered = false;\n                break;\n            }\n        }\n        if(notcovered) colornum[input[i].c].push_back(i);\n    }\n    for(int i = 1; i < 5; i++){\n        // cout << \"colornumsize \" << colornum[i].size() << endl;\n        if(colornum[i].size() > 1){\n            for(int j = 0; j < colornum[i].size(); j++){\n                for(int k = j + 1; k < colornum[i].size(); k++){\n                    string newinput = \"\";\n                    for(int l = 0; l < input.size(); l++){\n                        if(now[l] == '0' || l == colornum[i][j] || l == colornum[i][k]) newinput += \"0\";\n                        else newinput += \"1\";\n                    }\n                    // cout << newinput << endl;\n                    m[now] = max(m[now], solve(newinput) + 2);   \n                }\n            }\n        }\n    }\n    return m[now];\n}\n\n\n\nint main()\n{\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        input.clear();\n        m.clear();\n        for(int i = 0; i < n; i++){\n            D tmpd;\n            cin >> tmpd.x >> tmpd.y >> tmpd.r >> tmpd.c;\n            input.push_back(tmpd);\n        }\n        string start = \"\";\n        for(int i = 0; i < n; i++){\n            start += \"1\";\n        }\n        cout << solve(start) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = (a.r + b.r) * (a.r + b.r);\n    int d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    return r > d;\n}\n\nint main()\n{\n    int n;\n\n    while (cin >> n, n) {\n        const int N = 1 << n;\n        vector<char> dp(N, -1), up(n, 0);\n        vector<Circle> c(n);\n\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j) {\n                if (i == j)\n                    continue;\n                if (isOverlap(c[i], c[j])) {\n                    if (i < j) // jの上にiがある\n                        up[j] |= (1 << i);\n                    else // iの上にjがある\n                        up[i] |= (1 << j);\n                }\n            }\n\n        int res = 0;\n        dp[0] = 0; // ビットが立っているならば置かれていない\n        for (int s = 0; s < N; ++s) {\n            if (dp[s] == -1)\n                continue;\n\n            res = max(res, (int)dp[s]);\n            for (int i = 0; i < n; ++i) {\n                if (s >> i & 1 || (s & up[i]) != up[i]) // c[i]が置かれていないかc[i]が取り除けない\n                    continue;\n\n                for (int j = i + 1; j < n; ++j) {\n                    if (c[i].c != c[j].c) // 色が異なる\n                        continue;\n                    if (s >> j & 1 || (s & up[j]) != up[j])// c[j]が置かれていないかc[j]が取り除けない\n                        continue;\n\n                    int nxt = s | 1 << i | 1 << j;\n                    dp[nxt] = max((int)dp[nxt], dp[s] + 2);\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint main(){\n  int n;\n  cin >> n;\n  while(n!=0){\n    int sum=0;\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    int f=0;\n    int on[24]={};\n    int cc[5]={};\n    while(f==0){\n      f=1;\n      \n      for(i=0;i<24;i++) on[i]=0;\n      for(i=0;i<v.size();i++){\n\tfor(j=i+1;j<v.size();j++){\n\t  if(ch(v[i],v[j])==1) on[j]=1;\n\t}\n      }\n      for(i=0;i<5;i++) cc[i]=0;\n      for(i=0;i<v.size();i++){\n\t//cout << v[i].id<<\":\"<<on[i] <<endl;\n\tif(on[i]==0) cc[v[i].c]++;\n      }\n      for(i=1;i<5;i++){\n\tk=0;\n\tfor(j=v.size()-1;j>=0;j--){\n\t  if(on[j]==0&&v[j].c==i){\n\t    if((cc[i]/2)*2>k) {\n\t      //cout << v[j].id << \" \";\n\t      v.erase(v.begin()+j);\n\t      k++;\n\t      sum++;\n\t      f=0;\n\t    }\n\t  }\n\t}\n      }\n      //cout << f << endl;\n    }\n    //cout << endl;\n    cout << sum << endl;\n    //cout << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\n\n#define all(c) ((c).begin()), ((c).end())\n#define debug(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\n\nconst double EPS = 1e-10;\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\n\nstruct C{\n\tP p;\n\tint r;\n\tint c;\n};\n\nmap<int, int> dp;\nint n;\nvector<C> cs;\n\nint next_combination(int p){\n    int lsb = p&-p;\n    int rem = p+lsb;\n    int rit = rem&~p;\n    return rem|(((rit/lsb)>>1)-1);\n}\n\nint go(int mask) {\n\tif(mask < 2) return 0;\n\tif(present(dp, mask)) return dp[mask];\n\tint res = 0;\n\tint bn = __builtin_popcount(mask);\n\tbn -= 2;\n\tfor(int next = (1 << bn) - 1; next < (1 << n); next = next_combination(next)) {\n\t\tif((mask | next) != mask) continue;\n\t\tint use = mask ^ next;\n\t\tint i = __builtin_ctz(use);\n\t\tint j = __builtin_ctz(use >> (i + 1)) + i + 1;\n\t\tif(cs[i].c != cs[j].c) continue;\n\t\tbool ok = true;\n\t\trep(k, i) if(mask & (1 << k)) if (cs[i].r + cs[k].r > abs(cs[i].p - cs[k].p)) ok = false;\n\t\trep(k, j) if(mask & (1 << k)) if (cs[j].r + cs[k].r > abs(cs[j].p - cs[k].p)) ok = false;\n\t\tif(!ok) {\n\t\t\tif(next) continue;\n\t\t\telse break;\n\t\t}\n\t\tres = max(res, go(next) + 2);\n\t}\n\treturn dp[mask] = res;\n}\n\nint main() {\n\tfor (; cin >> n, n != 0; ) {\n\t\tcs.clear();\n\t\trep (i, n) {\n\t\t\tC c; int x, y; cin >> x >> y >> c.r >> c.c;\n\t\t\tc.p = P(x, y);\n\t\t\tcs.pb(c);\n\t\t}\n\t\tdp.clear();\n\t\tcout << go((1 << n) -1) << endl;;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#define x first.first\n#define y first.second\n#define r second.first\n#define color second.second\n\nusing namespace std;\n\ntypedef pair<double,double> P;\ntypedef pair<P,P> C;\n\nconst double EPS = 1e-10;\n\ndouble dist(C a,C b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nbool check(C a,C b){\n  return a.r+b.r>dist(a,b);\n}\n\nshort dp[(1<<24)];\n\nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<C>c(n);\n    for(int i=0;i<n;i++)\n      cin >> c[i].x >> c[i].y >> c[i].r >> c[i].color;\n    \n    fill(dp,dp+(1<<n),0);\n\n    for(int S=(1<<n)-1;S>=0;S--){\n      for(int i=0;i<n;i++){\n\tfor(int j=i+1;j<n;j++){\n\t  if(!(S>>i&1) || !(S>>j&1))continue;\n\t  if(c[i].color!=c[j].color)continue;\n\n\t  bool fg=false;\n\t  for(int k=0;k<n;k++){\n\t    if(i!=k && check(c[i],c[k]))fg=true;\n\t    if(j!=k && check(c[j],c[k]))fg=true;\n\t  }\n\t  //if(fg)continue;\n\n\t  int nx=S;\n\t  nx&=~(1<<i);\n\t  nx&=~(1<<j);\n\t  dp[nx]=max(dp[nx],(short)(dp[S]+2));\n\t}\n      }\n    }\n    short ans=0;\n    for(int i=0;i<(1<<n);i++)ans=max(ans,dp[i]);\n    cout << ans-2 << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\n\nclass state{\npublic:\n    P p;\n    double r;\n    int c;\n};\n\nbool onCircle(state a, state b){\n    return (abs(a.p-b.p) < a.r+b.r);\n}\n\nshort int a[1<<24];\nint n;\nstate v[24];\nint ans, over[24];\n\nvoid check(int pos){\n    int c = 0;\n    for(int i=0;i<n-1;i++){\n        if((pos & (1<<i)) == 0){\n            c |= over[i];\n            for(int j=i+1;j<n;j++){\n                if((pos & (1<<j)) == 0 && (c & (1<<j)) == 0 && v[i].c == v[j].c){\n                    int next = pos | (1<<i) | (1<<j);\n                    if(a[next] < a[pos] + 2){\n                        a[next] = a[pos] + 2;\n                        ans = max((short int)ans,a[next]);\n                        check(next);\n                    }\n                } else if((pos & (1<<j)) == 0) c |= over[j];\n            }\n        }\n    }\n}\n\nint main(){\n    while(cin >> n && n){\n        fill(over,over+n,0);\n        fill(a,a+(1<<n),0);\n        ans = 0;\n        for(int i=0;i<n;i++){\n            double x,y;\n            cin >> x >> y >> v[i].r >> v[i].c;\n            v[i].p = P(x,y);\n        }\n\n        for(int i=0;i<n;i++)\n            for(int j=0;j<n;j++)\n                if(onCircle(v[i],v[j]))\n                    over[i] |= (1<<j);\n\n        /*\n        for(int i=0;i<n;i++)\n            for(int j=n-1;j>i;j--)\n                over[i] |= over[j];\n        */\n\n        check(0);\n\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <array>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) begin((c)), end((c))\n#define REP(i,n) for(ll i=0;i<(ll)n;++i)\n\ninline int getInt() { int s; scanf(\"%d\", &s); return s; }\n\n#define SIZE 10\ntypedef array<array<int, SIZE>, SIZE> Table;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nint g_c;\n\nvoid fillColor(Table &state, int from, int to) {\n\tif (from==to) return;\n\tvector<pair<int,int>> stack;\n\tstack.emplace_back(1,1);\n\twhile (!stack.empty()) {\n\t\tint x,y; tie(x, y) = stack.back();\n\t\tstack.pop_back();\n\t\tREP(i, 4) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (state[ny][nx] == from) {\n\t\t\t\tstack.emplace_back(nx,ny);\n\t\t\t\tstate[ny][nx] = to;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint countColor(Table & state) {\n\tvector<pair<int, int>> stack;\n\tstack.emplace_back(1, 1);\n\tint cnt = 0;\n\twhile (!stack.empty()) {\n\t\tint x,y; tie(x, y) = stack.back();\n\t\tstack.pop_back();\n\n\t\tREP(i, 4) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (state[ny][nx] == g_c) {\n\t\t\t\tstack.emplace_back(nx, ny);\n\t\t\t\tcnt++;\n\t\t\t\tstate[ny][nx] = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint recursion(int depth, Table state) {\n\tif (depth > 5) return countColor(state);\n\t\n\tint cnt = 1;\n\tREP(i, 6) {\n\t\tif(depth==5 && i != g_c) continue;\n\t\tTable ntable = state;\n\t\tntable[1][1] = i;\n\t\tfillColor(ntable, state[1][1], i);\n\t\tcnt = max(recursion(depth+1, ntable),cnt);\n\t}\n\treturn cnt;\n}\n\nint main() {\n\twhile (true) {\n\t\tll h,w;\n\t\tcin >> h >> w \n\t\tif (h == 0) break;\n\t\t\n\t\tg_c = getInt() - 1;\n\t\tTable table;\n\t\tREP(y, SIZE) REP(x, SIZE) table[y][x] = -1;\n\t\tREP(y, h) REP(x, w) table[y + 1][x + 1] = getInt()-1;\n\t\tcout << recursion(1, table) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nstruct recedge\n{\n\tint y, next;\n} edge[5555];\nint l, idx[5555], ind[33], x[33], y[33], r[33], c[33], n, ans, times, LIM;\nvoid build(int x, int y)\n{\n\tedge[++l].y = y;\n\tedge[l].next = idx[x];\n\tidx[x] = l;\n}\nint lg(int x)\n{\n\tint rtn = 0;\n\twhile(x) rtn++, x /= 2;\n\treturn rtn - 1;\n}\nvoid dfs(int msk, int d, int c1, int c2, int c3, int c4)\n{\n\tans = max(ans, d);\n\tif(ans == n or ans == n - 1) return;\n\ttimes ++;\n\tif(times > LIM) return;\n\tint I, J, f[n + 1], l, q[n + 1];\n\tfor(int i = 0; i < n; i++) f[i] = true;\n\tfor(int i = 0; i < n; i++) if((1 << i) & msk)\n\t\tfor(int p = idx[i + 1]; p; p = edge[p].next) f[edge[p].y - 1] = false;\n\tif(c1 >= 2)\n\t{\n\t\tl = 0;\n\t\tfor(int i = 0; i < n; i++) if(c[i + 1] == 1 and ind[i + 1] == 0 and ((1 << i) & msk) and f[i])\n\t\t\tq[++l] = 1 << i;\n\t\tfor(int i = 1; i < l; i ++) for(int j = i + 1; j <= l; j ++)\n\t\t{\n\t\t\tdfs(msk - q[i] - q[j], d + 2, c1 - 2, c2, c3, c4);\n\t\t}\n\t}\n\tif(c2 >= 2)\n\t{\n\t\tl = 0;\n\t\tfor(int i = 0; i < n; i++) if(c[i + 1] == 2 and ind[i + 1] == 0 and ((1 << i) & msk) and f[i])\n\t\t\tq[++l] = 1 << i;\n\t\tfor(int i = 1; i < l; i ++) for(int j = i + 1; j <= l; j ++)\n\t\t{\n\t\t\tdfs(msk - q[i] - q[j], d + 2, c1, c2 - 2, c3, c4);\n\t\t}\n\t}\n\tif(c3 >= 2)\n\t{\n\t\tl = 0;\n\t\tfor(int i = 0; i < n; i++) if(c[i + 1] == 3 and ind[i + 1] == 0 and ((1 << i) & msk) and f[i])\n\t\t\tq[++l] = 1 << i;\n\t\tfor(int i = 1; i < l; i ++) for(int j = i + 1; j <= l; j ++)\n\t\t{\n\t\t\tdfs(msk - q[i] - q[j], d + 2, c1, c2, c3 - 2, c4);\n\t\t}\n\t}\n\tif(c4 >= 2)\n\t{\n\t\tl = 0;\n\t\tfor(int i = 0; i < n; i++) if(c[i + 1] == 4 and ind[i + 1] == 0 and ((1 << i) & msk) and f[i])\n\t\t\tq[++l] = 1 << i;\n\t\tfor(int i = 1; i < l; i ++) for(int j = i + 1; j <= l; j ++)\n\t\t{\n\t\t\tdfs(msk - q[i] - q[j], d + 2, c1, c2, c3, c4 - 2);\n\t\t}\n\t}\n\t\n}\nint main()\n{\n\tLIM = 10000;\n\tfor(;;)\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tif(!n) break;\n\t\ttimes = 0;\n\t\tl = 0;\n\t\tint c1 = 0, c2 = 0, c3 = 0, c4 = 0;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tind[i] = 0; idx[i] = 0;\n\t\t\tscanf(\"%d%d%d%d\", &x[i], &y[i], &r[i], &c[i]);\n\t\t\tif(c[i] == 1) c1++;\n\t\t\tif(c[i] == 2) c2++;\n\t\t\tif(c[i] == 3) c3++;\n\t\t\tif(c[i] == 4) c4++;\n\t\t\t\n\t\t\tfor(int j = i - 1; j >= 1; j--)\n\t\t\t{\n\t\t\t\tif(sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j])) < r[i] + r[j])\n\t\t\t\t{\n\t\t\t\t\tbuild(j, i);\n\t\t\t\t//\tprintf(\"%d -> %d\\n\", j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tdfs((1 << n) - 1, 0, c1, c2, c3, c4);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\tfclose(stdin);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<bool> used(1 << 24, false);\n\nstruct rounds{\n            int x, y, r, c;\n        };\n\nbool color(int x, int y, vector<rounds> &data){\n    return data[x].c == data[y].c;\n}\n\nvoid dfs(vector<vector<int>> &check, vector<rounds> &data, int now, int &ans){\n    if (!used[now]){\n        used[now] = true;\n        vector<bool> ok(n, false);\n        for (int i = 0; i < n; i++){\n            if ((now >> i) & 1) continue;\n            bool flag = true;\n            for (int j = 0; j < check[i].size(); j++){\n                if (((now >> check[i][j]) & 1) == 0) flag = false;\n            }\n            if (flag) ok[i] = true;\n        }\n        bool flag = false;\n        for (int i = 0; i < n; i++){\n            if (!ok[i]) continue;\n            for (int j = i + 1; j < n; j++){\n                if (!ok[j]) continue;\n                if (color(i, j, data)){\n                    flag = true;\n                    int next = now;\n                    next |= (int)pow(2, i);\n                    next |= (int)pow(2, j);\n                    dfs(check, data, next, ans);\n                }\n            }\n        }\n        if (!flag){\n            int tmp = 0;\n            for (int i = 0; i < n; i++){\n                if ((now >> i) & 1) tmp++;\n            }\n            ans = max(ans, tmp);\n        }\n    }\n}\n\nint main(){\n    while (1){\n        for (int i = 0; i < (1 << 24); i++) used[i] = false;\n        cin >> n;\n        if (!n) break;\n        \n        int ans = 0;\n        vector<rounds> data(n);\n        for (int i = 0; i < n; i++) cin >> data[i].x >> data[i].y >> data[i].r >> data[i].c;\n\n        vector<vector<int>> check(n);\n        for (int i = 0; i < n; i++){\n            for (int j = i + 1; j < n; j++){\n                int X = data[i].x - data[j].x;\n                int Y = data[i].y - data[j].y;\n                int R = data[i].r + data[j].r;\n                if (X * X + Y * Y < R * R) check[j].push_back(i);\n            }\n        }\n\n        int now = 0;\n        dfs(check, data, now, ans);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <deque>\n#include <vector>\n#include <numeric>\n#include <iterator>\n#include <array>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\n\n\n#define FF first\n#define SS second\n#define ALL(c) begin((c)), end((c))\n#define REP(i,n) for(ll i=0;i<(ll)n;++i)\ninline int getInt() { int s; scanf(\"%d\", &s); return s; }\n\nstruct circle{\n\tll id,x,y,r,c;\n\tbool operator==(const circle & o) {\n\t\treturn id==o.id;\n\t}\n};\n\n\n\nint main() {\\\n\twhile (true) {\n\t\tll n;\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tvector<circle> g_table;\n\t\tREP(i, n){\n\t\t\tint x,y,r,c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tg_table.push_back(circle{i,x,y,r,c-1});\n\t\t}\n\t\twhile (true) {\n\t\t\tvector<circle> tops[4];\n\n\t\t\tREP(i, g_table.size()) {\n\t\t\t\tbool top = true;\n\t\t\t\tREP(j, g_table.size()) {\n\t\t\t\t\tll xx = g_table[i].x - g_table[j].x;\n\t\t\t\t\tll yy = g_table[i].y - g_table[j].y;\n\t\t\t\t\tll rr = g_table[i].r + g_table[j].r;\n\t\t\t\t\tif (xx*xx + yy*yy < rr*rr && i>j) {\n\t\t\t\t\t\ttop = false; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (top) tops[g_table[i].c].push_back(g_table[i]);\n\t\t\t}\n\n\t\t\tbool done = false;\n\t\t\tREP(c, 4) while (tops[c].size() >= 2) {\n\t\t\t\tdone = true;\n\t\t\t\tg_table.erase(remove(ALL(g_table), tops[c].back()), g_table.end());\n\t\t\t\ttops[c].pop_back();\n\t\t\t\tg_table.erase(remove(ALL(g_table), tops[c].back()), g_table.end());\n\t\t\t\ttops[c].pop_back();\n\t\t\t}\n\n\t\t\tif (!done) break;\n\t\t}\n\n\t\tcout << n - g_table.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint chk(int x1, int y1, int r1, int x2, int y2, int r2){\n\tif((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)<(r1+r2)*(r1+r2))return 1;\n\treturn 0;\n}\n\nstring view(int t,int n){\n\tstring s=\"\";\n\tfor(int i=0,b=1;i<n;i++,b<<=1){\n\t\tif(t&b)s+=\"1\";\n\t\telse s+=\"0\";\n\t}\n\treturn s;\n}\n\nint main(){\n\t\n\tfor(int n;cin>>n,n;){\n\t\tint X[24], Y[24], R[24], C[24];\n\t\tint edge[24]={};\n\t\tint ans=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>X[i]>>Y[i]>>R[i]>>C[i];\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0,b=1;j<n;j++,b<<=1){\n\t\t\t\tif(chk(X[i],Y[i],R[i],X[j],Y[j],R[j])&&i>j){\n\t\t\t\t\tedge[i]|=b;\n\t\t\t\t\t//cout<<i<<\"-\"<<j<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tmap<int,int>M;\n\t\tstack<int>S;\n\t\tM[0]=1;\n\t\tS.push(0);\n\t\twhile(!S.empty()){\n\t\t\tint t=S.top();S.pop();\n\t\t\tint tmp=0;\n\t\t\tfor(int i=0,b=1;i<n;i++,b<<=1)if(t&b)tmp++;\n\t\t\tans=max(ans,tmp);\n\t\t\tint flg[24]={0};\n\t\t\tfor(int i=0,b=1;i<n;i++,b<<=1){\n\t\t\t\tif(t&b)continue;\n\t\t\t\tif((t&edge[i])!=edge[i])continue;\n\t\t\t\tflg[i]=1;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0,b=1;i<n;i++,b<<=1){\n\t\t\t\tif(flg[i]==0)continue;\n\t\t\t\tfor(int j=0,b2=1;j<n;j++,b2<<=1){\n\t\t\t\t\tif(i>=j)continue;\n\t\t\t\t\tif(flg[j]==0)continue;\n\t\t\t\t\tif(C[i]!=C[j])continue;\n\t\t\t\t\tint t2=t+b+b2;\n\t\t\t\t\tif(M[t2])continue;\n\t\t\t\t\tM[t2]=1;\n\t\t\t\t\tS.push(t2);\n\t\t\t\t\t//cout<<view(t2,n)<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint n;\nVI xs, ys, rs, cs;\n//VI memo;\nmap<int, int> memo;\nVI memo2;\nVVI grp;\n\nVVB nears;\n\nbool is_top(int i, int used) {\n\tfor (int j = i - 1; j >= 0; j--) {\n\t\tif (1 << j & used) continue;\n\n\t\tif (nears[i][j]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint dfs(int used) {\n\tint sum = 0;\n\n\tint flg = (1 << (n - 1) & used) ? 0 : 1;\n\n\tif (flg  && memo2[used] != -1) return memo2[used];\n\tif (!flg && memo.count(used)) return memo[used];\n\n\tfor(int i = 0;i < n;i++) {\n\t\tfor (auto j : grp[cs[i]]) {\n\t\t\tif(i == j || (1 << i & used) || (1 << j & used)) continue;\n\t\t\tif(cs[i] != cs[j]) continue;\n\t\t\tif(!is_top(i, used) || !is_top(j, used)) continue;\n\n\t\t\tint used_tmp = used;\n\t\t\tused_tmp |= 1 << i;\n\t\t\tused_tmp |= 1 << j;\n\n\t\t\tsum = max(sum, dfs(used_tmp) + 2);\n\t\t}\n\t}\n\n\treturn (flg ? memo2[used] : memo[used]) = sum;\n//\treturn sum;\n}\n\nint main(void) {\n\twhile(cin >> n, n){\n\t\txs = VI(n);\n\t\tys = VI(n);\n\t\trs = VI(n);\n\t\tcs = VI(n);\n\n\t\tgrp = VVI(4);\n\t\tmemo.clear();\n\t\tmemo2 = VI(1 << (n - 1), -1);\n\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n\t\t\tcs[i]--;\n\t\t\tgrp[cs[i]].push_back(i);\n\t\t}\n\n\t\tnears = VVB(n, VB(n));\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint x = (xs[i] - xs[j]) * (xs[i] - xs[j]);\n\t\t\t\tint y = (ys[i] - ys[j]) * (ys[i] - ys[j]);\n\t\t\t\tint dis = x + y;\n\t\t\t\tint dis2 = (rs[i] + rs[j]) * (rs[i] + rs[j]);\n\n\t\t\t\tnears[i][j] = dis < dis2;\n\t\t\t}\n\t\t}\n\n\t\tint used = 0;\n\t\tcout << dfs(used) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double R;//double long double ??????????????? cmath?????¢??°??????????????????????????????????????????????????§????????????\ntypedef complex<R> Point;\ntypedef pair<Point , Point> Line;\ntypedef pair<Point ,R > Circle;\ntypedef vector<Point> Poly;\n\n#define EPS (1e-10)//??????\n#define EQ(a,b) (abs((a)-(b)) < EPS)//??????????????°???????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )//????????????????????????????????????\n#define ft first\n#define sd second\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define MAX_N 24\nint n;\nCircle c[MAX_N];\nchar color[MAX_N];\nchar memo[1<<MAX_N];\nbool done[1<<MAX_N];\n\nbool input(){\n    cin >> n;\n    int x,y,r;\n    REP(i,n){\n        cin >> x >> y >> r >> color[i];\n        c[i] = Circle(Point(x,y),r);\n    }\n\n    return n!=0;\n}\n\nbool intersection_cc(Circle c1,Circle c2){\n    return abs(c1.ft - c2.ft) - (c1.sd + c2.sd) < -EPS;\n}\n\nint saiki(int S){\n    if(done[S])\n        return memo[S];\n    bool toreru[MAX_N];\n    REP(i,n){\n        toreru[i] = true;\n        if(S&(1<<i)){\n            toreru[i] = false;\n            continue;\n        }\n        REP(j,i){\n            if(!(S&(1<<j)) && intersection_cc(c[i],c[j])){\n                toreru[i] = false;\n                break;\n            }\n        }\n    }\n    int maxi = 0;\n    REP(i,n){\n        if(!toreru[i])\n            continue;\n        FOR(j,i+1,n){\n            if(toreru[j] && color[i] == color[j]){\n                maxi = max(maxi,saiki(S|(1<<i)|(1<<j)) + 2);\n            }\n        }\n    }\n    done[S] = true;\n    return memo[S] = maxi;\n}\n\nvoid solve(){\n    REP(i,(1<<n))\n        done[i] = false; \n    printf(\"%d\\n\",saiki(0));\n}\nint main(){\n    while(input())\n        solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\nchar bit_count[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            if(((bit>>i)&1)==0)continue;\n            if(((bit>>j)&1)==0)continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(c[i]==c[j]&&ok(i,bit)&&ok(j,bit)&&!memo[to_bit]){\n                ret=max(ret,dfs(to_bit));\n            }\n        }\n    }\n\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n/*\nvoid init(){\n    for(int i=0;i<(1<<24);i++){\n        for(int j=0;j<24;j++)if((i>>j)&1){\n            bit_count[i]++;\n        }\n    }\n}*/\n\nint main(){\n    //init();\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint sq(int x) { return x * x; }\n\nstruct Circle {\n\tint x, y, r, c;\n\tint tops;\n\tCircle (int _x, int _y, int _r, int _c) : x(_x), y(_y), r(_r), c(_c) {}\n};\n\nbool CC(const Circle& c1, const Circle& c2) {\n\tif (sq(c1.x - c2.x) + sq(c1.y - c2.y) < sq(c1.r + c2.r)) return true;\n\treturn false;\n}\n\nint n;\nvector<Circle> cs;\n\nint ans;\nbool memo[1 << 25];\n\nvoid rec(int cur) {\n\tif (memo[cur]) return;\n\t\n\tint ret = __builtin_popcount(cur);\t// テァツ渉セテ・ツ慊ィテ・ツ渉姪」ツつ甘ゥツ卍、テ」ツ??」ツ?淌・ツ?凝ヲツ閉ー\n\tans = max(ans, ret);\n\t\n\tint rmbit = ~cur;\t// bitテ・ツ渉催ィツサツ「テ」ツつ津」ツ?ィテ」ツつ?\n\t\n\t// テ、ツサツ甘・ツ渉姪」ツつ甘ゥツ卍、テ」ツ?妥」ツつ凝・ツ??ァツ崢、テ」ツつ津ィツヲツ凝」ツ?、テ」ツ?妥」ツつ?\n\tfor (int i = 0; i < n; i++) {\n\t\tif (cur >> i & 1) continue;\t// テ」ツ?凖」ツ?ァテ」ツ?ォテ」ツ?ィテ」ツつ甘」ツ?ョテ」ツ?榲」ツ?凝」ツつ古」ツ?ヲテ」ツ??」ツつ?\n\t\t\n\t\tint topsi = cs[i].tops;\n\t\tif ( (topsi & rmbit) != 0) continue;\n\t\t\n\t\t// iテァツ閉ェテァツ崢ョテ」ツ?ョテ・ツ??ァツ崢、テ」ツ?ッテァツ渉セテ・ツ慊ィテ」ツ?ョテ」ツ?禿」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝・ツ??ァツ崢、テ」ツ?ォテ」ツつ暗」ツつ嘉」ツ?堙」ツ?ォテ・ツ渉姪」ツつ甘ゥツ卍、テ」ツ?妥」ツつ?\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (cur >> j & 1) continue;\t// テ」ツ?凖」ツ?ァテ」ツ?ォテ」ツ?ィテ」ツつ甘」ツ?ョテ」ツ?榲」ツ?凝」ツつ古」ツ?ヲテ」ツ??」ツつ?\n\t\t\t\n\t\t\tint topsj = cs[j].tops;\n\t\t\tif ((topsj & rmbit) != 0) continue;\n\t\t\t\n\t\t\t// jテァツ閉ェテァツ崢ョテ」ツ?ョテ・ツ??ァツ崢、テ」ツつづァツ渉セテ・ツ慊ィテ」ツ?ョテ」ツ?禿」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝・ツ??ァツ崢、テ」ツ?ォテ」ツつ暗」ツつ嘉」ツ?堙」ツ?ォテ・ツ渉姪」ツつ甘ゥツ卍、テ」ツ?妥」ツつ?\n\t\t\t\n\t\t\t// テ・ツ青古」ツ?佚ィツ可イテ」ツ?ェテ」ツつ嘉・ツ渉姪」ツつ甘ゥツ卍、テ」ツ?妥」ツつ?\n\t\t\tif (cs[i].c != cs[j].c) continue;\n\t\t\t\n\t\t\t// i テ」ツ?ィ j テ」ツつ津・ツ渉姪」ツつ甘ゥツ卍、テ」ツ??」ツ?淌・ツ?エテ・ツ青暗」ツ?ォテ」ツ?、テ」ツ??」ツ?ヲテ・ツ?催・ツクツー\n\t\t\tint nxt = cur | (1 << i);\n\t\t\tnxt |= 1 << j;\n\t\t\trec(nxt);\n\t\t}\n\t}\n\t\n\tmemo[cur] = true;\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> n; if (n == 0) break;\n\t\t\n\t\tcs.clear();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x, y, r, c; cin >> x >> y >> r >> c;\n\t\t\tcs.push_back(Circle(x, y, r, c));\n\t\t}\n\t\t\n\t\t// テ・ツ青?・ツ??ァツ崢、テ」ツ?ォテ・ツッツセテ」ツ?療」ツ?ヲテ」ツ??」ツ?ゥテ」ツ?ョテ・ツ??ァツ崢、テ」ツ?古・ツ渉姪」ツつ甘ゥツ卍、テ」ツ?凝」ツ?ヲテ」ツ??」ツつ古」ツ?ーテ」ツ?敕」ツ?ョテ・ツ??ァツ崢、テ」ツつ津」ツ?ィテ」ツつ甘」ツ??」ツ?崚」ツつ凝」ツ?凝」ツつ津・ツ?・テ」ツつ古」ツつ?\n\t\t// テ・ツ渉姪」ツつ甘ゥツ卍、テ」ツ?凝」ツ?ェテ」ツ?妥」ツつ古」ツ?ーテ」ツ?ェテ」ツつ嘉」ツ?ェテ」ツ??・ツ??ァツ崢、テ」ツ?ォbitテ」ツつ津」ツ?淌」ツ?ヲテ」ツつ?\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tint tops = 0;\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (CC(cs[i], cs[j])) {\n\t\t\t\t\ttops |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcs[i].tops = tops;\n\t\t}\n\t\t\n\t\t// テ」ツ?凖」ツ?ケテ」ツ?ヲテ」ツ?ョテ・ツ??ァツ崢、テ」ツ?古ヲツョツ凝」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝ァツ環カテヲツ?凝」ツ?凝」ツつ嘉ゥツ鳴凝・ツァツ?\t\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tans = 0;\n\t\trec(0);\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nmain {\n  while (true) {\n    int n = in();\n    if (n == 0) break;\n    vector<int> x(n), y(n), r(n), c(n);\n    rep(i, n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n    auto intersectCC = [&](int i, int j) {\n      int r2 = (r[i] + r[j]) * (r[i] + r[j]);\n      int d = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n      return d < r2;\n    };\n    auto intersect = [&](int t, int used) {\n      bool f = false;\n      rep(i, t) f |= (~used >> i & 1) && intersectCC(t, i);\n      return f;\n    };\n    vector<int64_t> dp(1 << n, -1);\n    function<int(int)> dfs = [&](int used) {\n      if (dp[used] != -1) return dp[used];\n      cmax(dp[used], 0);\n      rep(i, n) loop(j, i + 1, n) {\n        if ((used >> i & 1) || (used >> j & 1) || c[i] != c[j]) continue;\n        if (intersect(i, used) || intersect(j, used)) continue;\n        cmax(dp[used], dfs(used | (1 << i) | (1 << j)) + 2);\n      }\n      return dp[used];\n    };\n    cout << dfs(0) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n;\nint x[111],y[111],r[111],c[111];\nbool used[111];\nint mem[1<<24];\n\nbool judge(int i,int j){\n\tbool ok=true;\n\trep(k,i){\n\t\tif(used[k])continue;\n\t\tif(pow(x[i]-x[k],2)+pow(y[i]-y[k],2)<pow(r[i]+r[k],2))ok=false;\n\t}\n\trep(k,j){\n\t\tif(used[k])continue;\n\t\tif(pow(x[k]-x[j],2)+pow(y[k]-y[j],2)<pow(r[k]+r[j],2))ok=false;\n\t}\n\treturn ok;\n}\n\nint dfs(int v){\n\tif(mem[v]!=-1)return mem[v];\n\tint res=0;\n\trep(i,n)repl(j,i+1,n){\n\t\tif(!used[i]&&!used[j]&&c[i]==c[j]&&judge(i,j)){\n\t\t\tused[i]=used[j]=true;\n\t\t\tmaxch(res,dfs(v|(1<<i)|(1<<j))+2);\n\t\t\tused[i]=used[j]=false;\n\t\t}\n\t}\n\treturn mem[v]=res;\n}\n\nint main(){\n\t//cin.sync_with_stdio(false);\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\trep(i,n)scanf(\"%d%d%d%d\",x+i,y+i,r+i,c+i);\n\t\tmemset(used,0,sizeof(used));\n\t\tmemset(mem,-1,sizeof(mem));\n\t\tcout<<dfs(0)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e18\n//#define int long long\n#define Rep(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) Rep(i, 0, n)\n#define all(a) (a).begin(), (a).end()\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int mod = 1000000007;\n\n#define MAX_N 24\n\nint n, x[MAX_N], y[MAX_N], r[MAX_N], c[MAX_N];\nint dp[1 << MAX_N];\nbool vis[1 << MAX_N];\n\nint solve(int a)\n{\n    if (vis[a])\n        return dp[a];\n    vis[a] = true;\n    vector<bool> ok(n, true);\n    rep(i, n) if (a & (1 << i)) ok[i] = false;\n    rep(i, n)\n    {\n        if (a & (1 << i))\n            continue;\n        Rep(j, i + 1, n)\n        {\n            if (a & (1 << j))\n                continue;\n            int d = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n            if (d < (r[i] + r[j]) * (r[i] + r[j]))\n                ok[j] = false;\n        }\n    }\n    int res = 0;\n    rep(i, n)\n    {\n        if (!ok[i])\n            continue;\n        Rep(j, i + 1, n)\n        {\n            if (ok[j] && c[i] == c[j])\n            {\n                int nxt = a + (1 << i) + (1 << j);\n                res = max(res, solve(nxt) + 2);\n            }\n        }\n    }\n    return dp[a] = res;\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    while (cin >> n, n)\n    {\n        rep(i, n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n        rep(i, 1 << n) vis[i] = false;\n        cout << solve(0) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\nconst double EPS = 1e-8;\n\nint main(void){\n    int n;\n    while(cin>>n, n){\n        VP p(n);\n        vector<double> r(n);\n        vector<int> c(n);\n        rep(i,n){\n            double x,y;\n            cin>>x>>y>>r[i]>>c[i];\n            p[i] = Point(x,y);\n        }\n\n        int cnt = 0;\n        vector<bool> is_front(n), selected(n);\n        while(1){\n            bool remove = false;\n            rep(i,n){\n                if(selected[i]) continue;\n                bool ok = true;\n                rep(j,i)if(!selected[j]){\n                    if(r[i]+r[j] > EPS + abs(p[i]-p[j])){\n                        ok = false;\n                    }\n                }\n                if(ok) is_front[i] = true;\n            }\n            rep(i,n)rep(j,i)if(!selected[i] && !selected[j]){\n                if(is_front[i] && is_front[j] && c[i]==c[j]){\n                    selected[i] = selected[j] = true;\n                    cnt += 2;\n                    remove = true;\n                }\n            }\n\n            if(!remove) break;\n        }\n        cout<<cnt<<endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int N = 24;\n\nint n;\nint ol[N];\nint x[N], y[N], r[N], c[N];\nbool vis[1<<N];\nint vec[(1<<N)+1];\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n    for(int i=0;i<n;i++){\n      ol[i] = 0;\n      for(int j=0;j<i;j++){\n        if((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) < (r[i] + r[j]) * (r[i] + r[j])){\n          ol[i] |= (1<<j);\n        }\n      }\n    }\n    fill(vis, vis+(1<<n), false);\n\n    int l = 0, r = 0;\n    //queue<int> q;\n    int u = (1<<n) - 1;\n    vec[r++] = u;\n    //q.push(u);\n    vis[u] = true;\n    int ans = -2;\n    while(l < r){\n    //while(!q.empty()){\n      ans += 2;\n      for(int k=0;k<r-l;k++){\n      //for(int k=0;k<q.size();k++){\n        u = vec[l++];\n        //u = q.front();q.pop();\n        for(int i=0;i<n;i++){\n          if(u>>i & 1 == 0) continue;\n          for(int j=i+1;j<n;j++){\n            if((u>>j & 1) == 0) continue;\n            if(c[i] != c[j]) continue;\n            int f1 = ((ol[i]&u)>>i)<<i;\n            int f2 = ((ol[j]&u)>>j)<<j;\n            if(f1 < (ol[i]&u) || f2 < (ol[j]&u)) continue;\n            int v = u;\n            v &= ~(1<<i);\n            v &= ~(1<<j);\n            if(vis[v]) continue;\n            vis[v] = true;\n            vec[r++] = v;\n            //q.push(v);\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ndouble EPS = (1e-10);\n\nstruct Point {\n  double x, y;\n};\n\nstruct Circle {\n  Point p;\n  double r;\n  int id;\n};\n\nbool intersect(Circle a, Circle b) {\n  double x1 = a.p.x, y1 = a.p.y;\n  double x2 = b.p.x, y2 = b.p.y;  \n  double d = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n\n  if ( d - (a.r+b.r) < 0.0 ) return true;  \n  else return false;\n}\n\nvector<Circle> C[4];\nvector<Circle> circles;\nint N;\nunordered_map<int, int> dp;\n\nint dfs(int bit) {\n  //cout << bit << endl;\n  if ( bit == (1<<N)-1 ) return 0;\n  if ( dp[bit] ) return dp[bit];\n\n  int ret = 0;\n  int n;\n  for ( int i = 0; i < 4; i++ ) {\n    n = C[i].size();\n    if ( n <= 1 ) continue;\n    for ( int a = 0; a < n; a++ ) {\n      Circle c1 = C[i][a];\n      int i1 = c1.id;\n      //if ( bit == 9 && i1 == 1 ) cout << 'a' << endl;\n      if ( bit & (1<<i1) ) continue;\n      bool flag = true;\t\n      for ( int j = 0; j < i1; j++ ) {\n\tif ( !(bit & (1<<j)) && intersect(circles[j], c1) ) {\n\t  flag = false;\n\t  break;\n\t}\n      }\n      //if ( bit == 9 && i1 == 1 ) cout << 'a' << endl;\n      if ( !flag ) continue;\n      //if ( bit == 9 && i1 == 1 ) cout << 'a' << endl;\n      for ( int b = a+1; b < n; b++ ) {\n\tCircle c2 = C[i][b];\n\tint i2 = c2.id;\n\t//if ( i1 == 1 && i2 == 2 ) cout << 'a' << endl;\n\tif ( bit & (1<<i2) ) continue;       \t\n\tfor ( int j = 0; j < i2; j++ ) {\n\t  if ( !(bit & (1<<j)) && intersect(circles[j], c2) ) {\t    \n\t    flag = false;\n\t    break;\n\t  }\n\t}\n\tif ( flag ) {\n\t  ret = max(ret, dfs(bit|(((1<<i1)+(1<<i2))))+2);\t  \n\t}\n      }\n    }\n  }\n  \n  return dp[bit] = ret;  \n}\n\nsigned main() {\n  while ( cin >> N, N ) {\n    for ( int i = 0; i < 4; i++ ) C[i].clear();\n    circles.clear();\n    dp.clear();    \n    \n    for ( int i = 0; i < N; i++ ) {\n      Circle in;\n      double x, y, r;\n      int c;      \n      cin >> x >> y >> r >> c;\n      c--;\n      in.p = Point{x, y};      \n      in.r = r;\n      in.id = i;      \n      C[c].push_back(in);\n      circles.push_back(in);      \n    }\n    \n    cout << dfs(0) << endl;    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24], y[24], r[24], c[24];\n\nint dist(int x, int y) {\n\treturn x * x + y * y;\n}\n\nint dp[1 << 24];\n\nint dfs(int S) {\n\tif (dp[S] != -1) return dp[S];\n\tvector<int> ng(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif ((S & (1 << i)) || (S & (1 << j))) continue;\n\t\t\tif (dist(x[i] - x[j], y[i] - y[j]) < (r[i] + r[j]) * (r[i] + r[j])) {\n\t\t\t\tng[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif ((S & (1 << i)) == 0 && (S & (1 << j)) == 0 && !ng[i] && !ng[j] && c[i] == c[j]) {\n\t\t\t\tres = max(res, 2 + dfs(S | (1 << i) | (1 << j)));\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[S] = res;\n}\n\nint main()\n{\n\twhile (cin >> n, n) {\n\t\tfill(dp, dp + (1 << 24), -1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tcout << dfs(0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n\n\nstruct cir{\n    int x,y,r,c;\n};\n\nbool same(cir a,cir b){\n    double r2 = (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n    if((a.r+b.r)*(a.r+b.r)>r2)return true;\n    else return false;\n}\n\nbool used(int n,vi vec){\n    rep(i,vec.size()){\n        int to = vec[i];\n        if( (n&(1<<to)) != 0 )return false;\n    }\n    return true;\n}\n\nbool dp[1<<n];\n\nint main(){\n    int n;\n    while(cin>>n){\n        if(n==0)break;\n        vector<cir> data;\n        \n        rep(i,n){\n            int x,y,r,c;\n            cin>>x>>y>>r>>c;\n            data.pb(cir{x,y,r,c});\n        }\n        \n        \n        vector<int> G[30];\n        \n        for(int i=data.size()-1;i>=0;i--){\n            for(int j=i-1;j>=0;j--){\n                if(same(data[i],data[j])){\n                    G[i].pb(j);\n                }\n            }\n        }\n        \n        \n        rep(i,1<<n)dp[i]=false;\n        dp[(1<<n)-1]=true;\n        \n        \n        for(int i=(1<<n)-1;i>=0;i--){\n            if(dp[i]==false)continue;\n            rep(j,n){\n                for(int k=j+1;k<n;k++){\n                    if( (i&(1<<j) )==0 || (i&(1<<k) )==0)continue;\n                    if( data[j].c==data[k].c && used(i,G[j]) && used(i,G[k]) ) dp[(i^(1<<j))^(1<<k)] = true;\n                }\n            }\n        }\n        \n        int ans=100;\n        for(int i=(1<<n)-1;i>=0;i--){\n            if(dp[i]==false)continue;\n            ans = min(ans,__builtin_popcount(i));\n        }\n        cout<<n-ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n,cnt_max;\n\nint hantei( long long int put, long long int remove ) {\n  if ( ( put ^ ( put & remove ) ) == 0 ) return 1;\n  return 0;\n}\n\nint saiki( vector<int> c, vector<long long int> put, long long int remove, int cnt ) {\n  for ( int i = 0; i < n-1; i++ ) {\n    if ( hantei( put[i], remove ) ) {\n      for ( int j = i+1; j < n; j++ ) {\n\tif ( hantei( put[j], remove ) && c[i] == c[j] ) {\n\t  put[i] += 1<<n;\n\t  put[j] += 1<<n;\n\t  saiki( c, put, remove + (1<<i) + (1<<j), cnt+2 );\n\t  put[i] -= 1<<n;\n\t  put[j] -= 1<<n;\n\t}\n      }\n    }\n  }\n  cnt_max = max( cnt_max, cnt );\n  return 0;\n}\n\nint main() {\n\n  while(true) {\n\n    cin >> n;\n    if ( n == 0 ) break;\n\n    vector<int> x,y,r,c;\n    vector<long long int> put;\n    int input1,input2,input3,input4;\n    for ( int i = 0; i < n; i++ ) {\n      cin >> input1 >> input2 >> input3 >> input4;\n      x.push_back(input1);\n      y.push_back(input2);\n      r.push_back(input3);\n      c.push_back(input4);\n      put.push_back(0);\n      for ( int j = 0; j < i; j++ ) {\n\tinput1 = x[i] - x[j];\n\tinput2 = y[i] - y[j];\n\tinput3 = r[i] + r[j];\n\tif ( input1*input1 + input2*input2 < input3*input3 ) put[i] += ( 1 << j );\n      }\n    }\n\n    cnt_max = 0;\n    saiki( c, put, 0, 0 );\n    cout << cnt_max << endl;\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n\n#define ll long long int\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\nclass Circle{\npublic:\n    int x, y, r, c;\n    Circle(int x_, int y_, int r_, int c_) : x(x_), y(y_), r(r_), c(c_){};\n};\n\nbool over(Circle &c1, Circle &c2){\n    return (c1.x-c2.x)*(c1.x-c2.x) + (c1.y-c2.y)*(c1.y-c2.y) < (c1.r+c2.r)*(c1.r+c2.r);\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int N;\n    while(cin>>N, N){\n        vector<vector<int>> is_over(N, vector<int>(N, false));\n        vector<Circle> circles;\n        for(int i=0; i<N; i++){\n            int x, y, r, c;\n            cin >> x >> y >> r >> c;\n            circles.push_back(Circle(x, y, r, c));\n        }\n        \n        for(int i=0; i<N; i++){\n            for(int j=0; j<N; j++){\n                if(i < j && over(circles[i], circles[j]))\n                    is_over[i][j] = true;\n            }\n        }\n        vector<vector<int>> colors(4);\n        for(int i=0; i<N; i++)\n            colors[circles[i].c-1].push_back(i);\n        \n        vector<bool> dp(1<<N, false);\n        dp[(1<<N)-1] = true;\n        \n        for(int i=(1<<N)-1; 0<=i; i--){\n            if(!dp[i])\n                continue;\n            \n            for(int c=0; c<4; c++){\n                for(int j=0; j<colors[c].size(); j++){\n                    for(int k=j+1; k<colors[c].size(); k++){\n                        int uppper = colors[c][j];\n                        int lower = colors[c][k];\n                        if(!is_over[uppper][lower] && i>>uppper&1 && i>>lower&1){\n                            bool is_ng = false;\n                            for(int l=0; l<uppper; l++){\n                                if(i>>l&1)\n                                    is_ng |= is_over[l][uppper];\n                            }\n                            for(int l=0; l<lower; l++){\n                                if(i>>l&1)\n                                    is_ng |= is_over[l][lower];\n                            }\n                            if(!is_ng)\n                                dp[i-(1<<uppper)-(1<<lower)] = true;\n                        }\n                    }\n                }\n            }\n        }\n        \n        int ans = 0;\n        for(int i=0; i<1<<N; i++){\n            if(!dp[i])\n                continue;\n            int count = 0;\n            for(int j=0; j<N; j++){\n                count += (i>>j)&1;\n            }\n            ans = max(ans, N-count);\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c, id;\n};\nbool overlap[24][24];\nchar mem[1 << 24];\n\ninline int sq(int x) {\n    return x * x;\n}\n\nvoid calc_overlap(vector<Circle> &cir) {\n    int n = cir.size();\n    for (int i=0; i<n; ++i) {\n        for (int j=i+1; j<n; ++j) {\n            overlap[cir[i].id][cir[j].id] = sq(cir[i].x - cir[j].x) + sq(cir[i].y - cir[j].y) < sq(cir[i].r + cir[j].r);\n            overlap[cir[j].id][cir[i].id] = overlap[cir[i].id][cir[j].id];\n        }\n    }\n}\n\nint dfs(vector<Circle> &cir, int key) {\n    if (mem[key] != -1) return mem[key];\n\n    int n = cir.size();\n    bool ok[24] = {}; // ok[i] := cir[i]の上に何も重なってなければtrue\n\n    for (Circle &c: cir) {\n        ok[c.id] = true;\n    }\n    for (int i=0; i<n; ++i) {\n        for (int j=i+1; j<n; ++j) {\n            if ( ! overlap[cir[i].id][cir[j].id]) continue;\n            if (cir[i].id < cir[j].id) {\n                ok[cir[j].id] = false;\n            } else {\n                ok[cir[i].id] = false;\n            }\n        }\n    }\n\n    int ret = 0;\n    for (int i=0; i<n; ++i) {\n        for (int j=i+1; j<n; ++j) {\n            Circle a = cir[i];\n            Circle b = cir[j];\n            if ( ! ok[a.id] || ! ok[b.id] || a.c != b.c) continue;\n\n            swap(cir[j], cir.back()); cir.pop_back();\n            swap(cir[i], cir.back()); cir.pop_back();\n            key = key - (1 << a.id) - (1 << b.id);\n\n            ret = max(ret, 2 + dfs(cir, key));\n\n            cir.push_back(a); swap(cir[i], cir.back());\n            cir.push_back(b); swap(cir[j], cir.back());\n            key = key + (1 << a.id) + (1 << b.id);\n        }\n    }\n    return mem[key] = ret;\n}\n\nint main() {\n    int n;\n    while (cin >> n && n) {\n        int x, y, r, c;\n        vector<Circle> cir;\n        for (int i=0; i<n; ++i) {\n            cin >> x >> y >> r >> c;\n            cir.push_back((Circle){x, y, r, c, i});\n        }\n\n        calc_overlap(cir);\n        fill_n(mem, 1 << 24, -1);\n\n        cout << dfs(cir, (1 << n) - 1) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\n\n#define all(c) ((c).begin()), ((c).end())\n#define debug(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\n\nconst double EPS = 1e-10;\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\n\nstruct C{\n\tP p;\n\tint r;\n\tint c;\n};\n\nmap<int, int> dp;\nint n;\nvector<C> cs;\nint cover[30];\n\nint next_combination(int p){\n    int lsb = p&-p;\n    int rem = p+lsb;\n    int rit = rem&~p;\n    return rem|(((rit/lsb)>>1)-1);\n}\n\nint go(int mask) {\n\tif(mask == 0) return 0;\n\tif(present(dp, mask)) return dp[mask];\n\tint res = 0;\n\trep (i, n) if (mask & (1 << i)) REP (j, i + 1, n - 1) if (mask & (1 << j)) {\n\t\tif(cs[i].c != cs[j].c) continue;\n\t\tif((mask & cover[i]) || (mask & cover[j])) continue;\n\t\tres = max(res, go(mask ^ (1 << i) ^ (1 << j)) + 2);\n\t}\n\treturn dp[mask] = res;\n}\n\nint main() {\n\tfor (; cin >> n, n != 0; ) {\n\t\tcs.clear();\n\t\trep (i, n) {\n\t\t\tC c; int x, y; cin >> x >> y >> c.r >> c.c;\n\t\t\tc.p = P(x, y);\n\t\t\tcs.pb(c);\n\t\t}\n\t\trep(i, n) {\n\t\t\tint mask = 0;\n\t\t\trep(j, i) if(cs[i].r + cs[j].r > abs(cs[i].p - cs[j].p)) mask |= 1 << j;\n\t\t\tcover[i] = mask;\n\t\t}\n\t\t\n\t\tdp.clear();\n\t\tcout << go((1 << n) -1) << endl;;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, x[25], y[25], r[25], c[25]; short dp[16777777];\nint main() {\n\twhile (scanf(\"%d\", &n), n) {\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d%d%d%d\", &x[i], &y[i], &r[i], &c[i]);\n\t\tfor (int i = 1; i < 1 << n; i++) {\n\t\t\tdp[i] = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (!(i & (1 << j))) continue;\n\t\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\t\tif (!(i & (1 << k))) continue;\n\t\t\t\t\tif (c[j] != c[k]) continue;\n\t\t\t\t\tint p = i - (1 << j) - (1 << k);\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\tfor (int l = 0; l < j; l++) {\n\t\t\t\t\t\tif (!(p & (1 << l))) {\n\t\t\t\t\t\t\tint dist = (x[j] - x[l]) * (x[j] - x[l]) + (y[j] - y[l]) * (y[j] - y[l]);\n\t\t\t\t\t\t\tif (dist < (r[j] + r[l]) * (r[j] + r[l])) flag = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int l = 0; l < k; l++) {\n\t\t\t\t\t\tif (!(p & (1 << l))) {\n\t\t\t\t\t\t\tint dist = (x[k] - x[l]) * (x[k] - x[l]) + (y[k] - y[l]) * (y[k] - y[l]);\n\t\t\t\t\t\t\tif (dist < (r[k] + r[l]) * (r[k] + r[l])) flag = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (flag) {\n\t\t\t\t\t\tdp[i] = max((int)dp[i], dp[i - (1 << j) - (1 << k)] + 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dp[i] == 0) dp[i] = -11111;\n\t\t}\n\t\tprintf(\"%d\\n\", (int)(*max_element(dp, dp + (1 << n))));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n, m, bak, cl, qx[99909], qy[99909], dis[33][33], pas[77][77], x, y, dx[4], dy[4], mn[33][33], ans[77][77][2];\nint main()\n{\n\tdx[0] = -1; dy[0] = 0;\n\tdx[1] = 0; dy[1] = -1;\n\tdx[2] = +1; dy[2] = 0;\n\tdx[3] = 0; dy[3] = +1;\n\t\tfor(;;)\n\t{\n\tfor(int i = 0; i < 77; i++) for(int j = 0; j < 77; j++) pas[i][j] = 1;\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(!n or !m)\n\t\t\tbreak;\n\t\t//printf(\"%d %d\\n\", n, m);\n\t\tfor(int i = 1; i <= 2 * n - 1; i++)\n\t\t{\n\t\t\tif(i & 1)\n\t\t\t{\n\t\t\t\tfor(int j = 1; j < m; j++)\n\t\t\t\t{\n\t\t\t\t\tscanf(\"%d\", &pas[i + 1][j * 2 + 1]);\n\t\t\t\t}\n\t\t\t}else\n\t\t\t{\n\t\t\t\tfor(int j = 1; j <= m; j++)\n\t\t\t\t{\n\t\t\t\t\tscanf(\"%d\", &pas[i + 1][j * 2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag = true;\n\t\tfor(int i = 2; i <= 2 * n; i++) for(int j = 2; j <= 2 * m; j++) if(i % 2 == 1 xor j % 2 == 1)\n\t\t{\n\t\t\t//\tprintf(\"%d %d\\n\", i,j);\n\t\t\tbak = pas[i][j];\n\t\t\tpas[i][j] = 1;\n\n\t\t\tqx[cl = 1] = n;\n\t\t\tqy[1] = m;\n\t\t\tfor(int i1 = 1; i1 <= n; i1++) for(int j1 = 1; j1 <= m; j1++) dis[i1][j1] = -1;\n\t\t\tdis[n][m] = 0;\n\t\t\tfor(int op = 1; op <= cl; op++)\n\t\t\t{\n\t\t\t//\tprintf(\"%d\\n\", op);\n\t\t\t\tx = qx[op]; y = qy[op];\n\t\t\t\tfor(int d = 0; d < 4; d++)\n\t\t\t\t{\n\t\t\t\t//\tprintf(\"%d %d\\n\", x + dx[d], y + dy[d]);\n\t\t\t\t\tif(!pas[2 * x + dx[d]][2 * y + dy[d]] and dis[x + dx[d]][y + dy[d]] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdis[x + dx[d]][y + dy[d]] = dis[x][y] + 1;\n\t\t\t\t\t\tqx[++cl] = x + dx[d];\n\t\t\t\t\t\tqy[cl] = y + dy[d];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dis[1][1] == -1) {flag = false; break;}\n\t\t\tans[i][j][0] = dis[i / 2][j / 2];\n\t\t\tans[i][j][1] = dis[(i + 1) / 2][(j + 1) / 2];\n\t\t//\tprintf(\"ans[%d][%d][%d] = %d, ans[%d][%d][%d] = %d, \\n\", i, j,0, ans[i][j][0], i, j, 1, ans[i][j][1]);\n\t\t\tpas[i][j] = bak;\n\t\t}\n\t\tif(!flag) {printf(\"-1\\n\"); continue;}\n\t\tfor(int i = 1; i <= n; i++) for(int j = 1; j <= m; j++) mn[i][j] = 0x3fffffff;\n\t\tmn[n][m] = 0;\n\t\tqx[cl = 1] = n;\n\t\tqy[1] = m;\n\t\tfor(int op = 1; op <= cl; op++)\n\t\t{\n\t\t\tx = qx[op]; y = qy[op];\n\t\t\tfor(int d = 0; d < 4; d++)if(!pas[x * 2 + dx[d]][y * 2 + dy[d]])\n\t\t\t{\n\t\t\t\tint tmp = max(1 + mn[x][y], ans[x * 2 + dx[d]][y * 2 + dy[d]][(dx[d] + dy[d]) == 1?1:0]);\n\t\t\t\t//printf(\"%d %d %d\\n\", x, y, tmp);\n\t\t\t\tif(mn[x + dx[d]][y + dy[d]] > tmp)\n\t\t\t\t{\n\t\t\t\t\tmn[x + dx[d]][y + dy[d]] = tmp;\n\t\t\t\t\tqx[++cl] = x + dx[d];\n\t\t\t\t\tqy[cl] = y + dy[d];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", mn[1][1]);\n\t}\n\tfclose(stdin);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\nstruct E{\n\tvector<int> ov;\n\tint color;\n\tint x, y, r;\n\tE(int _x, int _y, int _r, int _c){\n\t\tcolor = _c;\n\t\tx = _x;\n\t\ty = _y;\n\t\tr = _r;\n\t}\n};\n\nbool dp[(1<<25)] = {0};\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tint x, y, r, c, _ans=0;\n\t\tvector<E> e;\n\t\tqueue<int> que;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tE tmp(x,y,r,c);\n\t\t\tfor(int j=0; j<e.size(); j++){\n\t\t\t\tif( (e[j].x-x)*(e[j].x-x) + (e[j].y-y)*(e[j].y-y) < (e[j].r+r)*(e[j].r+r) ){\n\t\t\t\t\ttmp.ov.push_back( j );\n\t\t\t\t}\n\t\t\t}\n\t\t\te.push_back( tmp );\n\t\t}\n\t\tfill(dp, dp+(1<<25), false);\n\t//\tdp[0] = true;\n\t\tque.push(0);\n\t\twhile( !que.empty() ){\n\t\t\tint i = que.front();\n\t\t\tque.pop();\n\t\t\tif(!dp[i]){\n\t\t\t\tdp[i] = true;\n\t\t\t\t_ans = max(_ans,i);\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tfor(int l=0; l<n; l++){\n\t\t\t\t\t\tif( k != l && !(i&(1<<k)) && !(i&(1<<l)) && e[k].color == e[l].color){\n\t\t\t\t\t\t\tbool f=true;\n\t\t\t\t\t\t\tfor(int j=0; j<e[k].ov.size(); j++){\n\t\t\t\t\t\t\t\tif( !(i & (1<<e[k].ov[j])) ){\n\t\t\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int j=0; f&&j<e[l].ov.size(); j++){\n\t\t\t\t\t\t\t\tif( !(i & (1<<e[l].ov[j])) ){\n\t\t\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( f ){\n\t\t\t\t\t\t\t//\tdp[ i | (1<<k) | (1<<l) ] = true;\n\t\t\t\t\t\t\t\tque.push( i | (1<<k) | (1<<l) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=1; i<(1<<n); i<<=1){\n\t\t\tif( i & _ans )\n\t\t\t\tans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint n,x[30],y[30],r[30],c[30],cover[30];\nint dp[1<<24];\nvector<pii> same_col;\n\nint rec(int bit){\n  if(dp[bit])return dp[bit];\n\n  int res = 0;\n  for(int i=0;i<(int)same_col.size();i++){\n    const int a = same_col[i].first, b = same_col[i].second;\n    if( (~bit)&(1<<a) && (~bit)&(1<<b) ){\n      if( (~bit)&cover[a] || (~bit)&cover[b])continue;\n      res = max(res, rec(bit | (1<<a) | (1<<b))+2);\n    }\n  }\n  return dp[bit]=res;\n}\n  \nint main(){\n  while(cin >> n, n){\n    for(int i=0;i<n;i++)cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n    same_col.clear();\n    for(int i=0;i<n;i++){\n      cover[i] = 0;\n      for(int j=0;j<i;j++){\n\tif( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j])*(r[i]+r[j]) ){\n\t  cover[i] |= 1<<j;\n\t}\n\tif(c[i] == c[j])same_col.push_back(pii(i,j));\n      }\n    }\n\n    memset(dp,0,sizeof(dp));\n    cout << rec(0) << endl;\n  }\t  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint main(){\n  int n;\n  cin >> n;\n  while(n!=0){\n    int sum=0;\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    int f=0;\n    int on[30]={};\n    //int cc[5]={};\n    vector<int> cc[5];\n    while(f==0){\n      f=1;\n      /*\n      for(i=0;i<24;i++) on[i]=0;\n      for(i=0;i<v.size();i++){\n\tfor(j=i+1;j<v.size();j++){\n\t  if(ch(v[i],v[j])==1) on[j]=1;\n\t}\n      }\n      for(i=0;i<5;i++) cc[i]=0;\n      for(i=0;i<v.size();i++){\n\tif(on[i]==0) cc[v[i].c]++;\n      }\n      */\n      int ff=0;\n      //while(ff==0){\n\tff=1;\n\tfor(i=0;i<30;i++) on[i]=0;\n\tfor(i=0;i<v.size();i++){\n\t  for(j=i+1;j<v.size();j++){\n\t    if(ch(v[i],v[j])==1) on[j]=1;\n\t  }\n\t}\n\t\n\tfor(i=0;i<5;i++) cc[i].clear();\n\tfor(i=0;i<v.size();i++){\n\t  if(on[i]==0) cc[v[i].c].push_back(i);\n\t}\n\t/*\n\tfor(i=1;i<5;i++){\n\t  if(cc[i].size()>0&&cc[i].size()%2==0){\n\t    for(j=cc[i].size()-1;j>=0;j--){\n\t      v.erase(v.begin()+cc[i][j]);\n\t      ff=0;\n\t      f=0;\n\t    }\n\t  }\n\t}\n\t*/\n\t//}\n      \n      for(i=1;i<5;i++){\n\tk=0;\n\tfor(j=v.size()-1;j>=0;j--){\n\t  if(on[j]==0&&v[j].c==i){\n\t    if((cc[i].size()/2)*2>k) {\n\t      //cout << v[j].id << \" \";\n\t      v.erase(v.begin()+j);\n\t      k++;\n\t      f=0;\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout << n-v.size() << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = (a.r + b.r) * (a.r + b.r);\n    int d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    return r > d;\n}\n\nint main()\n{\n    int n;\n\n    while (cin >> n, n) {\n        const int N = 1 << n;\n        vector<char> dp(N, -1), up(n, 0);\n        vector<Circle> c(n);\n\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j) {\n                if (i == j)\n                    continue;\n                if (isOverlap(c[i], c[j])) {\n                    if (i < j) // jの上にiがある\n                        up[j] |= (1 << i);\n                    else // iの上にjがある\n                        up[i] |= (1 << j);\n                }\n            }\n\n        int res = 0;\n        dp[N - 1] = 0;\n        for (int s = N - 1; s >= 0; --s) {\n            if (dp[s] == -1)\n                continue;\n\n            res = max(res, (int)dp[s]);\n            for (int i = 0; i < n; ++i) {\n                if (!(s >> i & 1) || (s & up[i])) // c[i]が置かれていないかc[i]が取り除けない\n                    continue;\n\n                for (int j = i + 1; j < n; ++j) {\n                    if (c[i].c != c[j].c) // 色が異なる\n                        continue;\n                    if (!(s >> j & 1) || (s & up[j]))// c[j]が置かれていないかc[j]が取り除けない\n                        continue;\n\n                    int nxt = s & ~(1 << i) & ~(1 << j);\n                    dp[nxt] = max((int)dp[nxt], dp[s] + 2);\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define show_bits(b, s) if(opt_debug) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#define dumpb(bit, digits) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #bit << \" = \"; for(int __i = digits - 1; __i >= 0; __i--) { cerr << static_cast<bool>(bit & (1 << __i)); if (__i % 4 == 0) { cerr << \" \"; } } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\nbool opt_debug = false;\n\nclass Disk {\n\tprivate:\n\tpublic:\n\t\tint x, y, r, c;\n\t\tset<Disk*> upper_disks;\n\t\tset<Disk*> lower_disks;\n\n\t\tDisk(int _x, int _y, int _r, int _c) : x(_x), y(_y), r(_r), c(_c) {\n\t\t}\n\n\t\tbool overlap(const Disk rhs) {\n\t\t\treturn sqrt(pow(x - rhs.x, 2) + pow(y - rhs.y, 2)) + EPS < r + rhs.r;\n\t\t}\n};\nstd::ostream& operator<<(std::ostream &s, const Disk &d) {\n\ts << \"(\" << d.x << \", \" << d.y << \", \" << d.r << \", \" << d.c << \")\";\n\treturn s;\n}\n\n#define BIT_SUB(a, b) ((a) - ((a) & (b)))\n\nmap<ULL, int> memo;\nint solve(vector<Disk*> &disks, VULL &upper, ULL current) {\n\tdumpb(current, 24);\n\tif (EXIST(memo, current)) { return memo[current]; }\n\tint ret = 0;\n\tREP (i, disks.size()) {\n\t\tFOR (j, i+1, disks.size()) {\n\t\t\tif (current & 1 << i || current & 1 << j || (disks[i]->c != disks[j]->c)) { continue; }\n\t\t\tdumpb(upper[i], 24);\n\t\t\tdumpb(upper[j], 24);\n\t\t\tdumpb(BIT_SUB(upper[i], current), 24);\n\t\t\tdumpb(BIT_SUB(upper[j], current), 24);\n\t\t\tif (BIT_SUB(upper[i], current) || BIT_SUB(upper[j], current)) {\n\t\t\t\t// cannot remove\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdump(i);\n\t\t\tdump(j);\n\t\t\tdump(*disks[i]);\n\t\t\tdump(*disks[j]);\n\n\t\t\tULL next = current | (1 << i) | (1 << j);\n\t\t\tdumpb(next, 24);\n\t\t\tret = max(ret, 2 + solve(disks, upper, next));\n\t\t}\n\t}\n\treturn memo[current] = ret;\n}\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/0.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tint n;\n\twhile (cin >> n, n) {\n\t\tmemo.clear();\n\t\tVULL overlap(n, 0);\n\t\tvector<Disk*> disks;\n\t\tREP (i, n) {\n\t\t\tint x, y, r, c; cin >> x >> y >> r >> c;\n\t\t\tDisk *d = new Disk(x, y, r, c);\n\t\t\tREP (j, disks.size()) {\n\t\t\t\tDisk *rhs = disks[j];\n\t\t\t\tif (d->overlap(*rhs)) {\n\t\t\t\t\toverlap[i] = overlap[i] | (1 << j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdisks.PB(d);\n\t\t}\n\t\tcout << solve(disks, overlap, 0) << endl;\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cstdio>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define fr first\n#define sc second\n#define mp make_pair\n\ntypedef long long int64;\ntypedef pair< int, int > iP;\ntypedef pair< iP, int > iiP;\n\nconst int INF = 2 << 28;\nconst double EPS = 1e-10;\n\nstruct disk {\n    int x, y, r, color;\n};\n\nint n;\nmap< int, int > dp;\nvector< disk > disks;\n\nint rec(int used) {\n    if(dp[used]) return dp[used];\n    vector< int > idx;\n    for(int i = n - 1; i >= 0; i--) {\n        if(!(used >> i & 1)) {\n            bool judge = true;\n            for(int j = i - 1; j >= 0; j--) {\n                if(!(used >> j & 1)) {\n                    if(pow(abs(disks[i].x - disks[j].x), 2) + pow(abs(disks[i].y - disks[j].y), 2) < pow(disks[i].r + disks[j].r, 2))\n                        judge = false;\n                }\n            }\n            if(judge) idx.push_back(i);\n        }\n    }\n\n    int ret = 0;\n    if(idx.size() < 2) return 0;\n    else {\n        for(int i = 0; i < idx.size(); i++) {\n            for(int j = i + 1; j < idx.size(); j++) {\n                if(disks[idx[i]].color == disks[idx[j]].color) {\n                    ret = max(ret, rec(used | (1 << idx[i] | 1 << idx[j])) + 2);\n                }\n            }\n        }\n        return dp[used] = ret;\n    }\n}\n\nint main() {\n\n    while(cin >> n, n) {\n        for(int i = 0; i < n; i++) {\n            int x, y, c, r; cin >> x >> y >> r >> c;\n            disks.push_back((disk){x, y, r, c});\n        }\n\n        cout << rec(0) << endl;\n        disks.clear();\n        dp.clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define mp make_pair\n#define pb push_back\n#define EB emplace_back\n#define fi first\n#define se second\n#define all(v) ALL(v)\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\nconstexpr double eps = 1e-14; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint N;\nvector<int> x,y,r,c;\n\nint dfs(vector<bool> u){\n    //cout << u << endl;\n    int ret = 0;\n    for(int i=0;i<N;i++) for(int j=i+1;j<N;j++) if(c[i]==c[j]){\n        if(!u[i] or !u[j]) continue;\n        //bool ch=false;\n        //if(i==1 and j==3) ch = true;\n        bool oki=true;\n        for(int k=i-1;k>-1;k--){\n            if(!u[k]) continue;\n            double d=sqrt((x[i]-x[k])*(x[i]-x[k])+(y[i]-y[k])*(y[i]-y[k]));\n            //if(ch){\n            //    cout << \"ri + rk : \" << r[i]+r[k] << endl;\n            //    cout << \"d : \" << d << endl;\n            //}\n            if(!(r[i]+r[k]<=d)){\n                oki=false;\n                break;\n            }\n        }\n        if(oki==false) continue;\n        bool okj=true;\n        for(int k=j-1;k>-1;k--){\n            if(!u[k]) continue;\n            double d=sqrt((x[j]-x[k])*(x[j]-x[k])+(y[j]-y[k])*(y[j]-y[k]));\n            //if(ch){\n            //    cout << \"k : \" << k << endl;\n            //    cout << \"rj + rk : \" << r[j]+r[k] << endl;\n            //    cout << \"d : \" << d << endl;\n            //}\n            if(!(r[j]+r[k]<=d)){\n                okj=false;\n                break;\n            }\n        }\n        if(okj==false) continue;\n\n        auto t = u;\n        t[i] = false;\n        t[j] = false;\n        int x = dfs(t);\n        ret = max(ret,x+2);\n    }\n\n    return ret;\n}\n\n\nvoid solve(){\n    x.assign(N,0);\n    y.assign(N,0);\n    r.assign(N,0);\n    c.assign(N,0);\n    rep(i,N){\n        cin >> x[i] >> y[i] >> r[i] >> c[i];\n        c[i]--;\n    }\n\n    vector<bool> u(N,true);\n    cout << dfs(u) << endl;\n}\n\nint main(){\n    while(cin>>N){\n        if(N==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\nint n;\nvector<char> dp;\nvector<int> up;\nvector<Circle> c(24);\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = (a.r + b.r) * (a.r + b.r);\n    int d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    return r > d;\n}\n\nint Rec(int s)\n{\n    if (~dp[s])\n        return dp[s];\n\n    int res = 0;\n    // 取り除く2つの円の選択\n    for (int i = 0; i < n; ++i) {\n        // c[i]がないか取り除けない\n        if (!(s >> i & 1) || s & up[i])\n            continue;\n\n        for (int j = i + 1; j < n; ++j) {\n            // c[i]とc[j]の色が異なる\n            if (c[i].c != c[j].c)\n                continue;\n            // c[j]がないか取り除けない\n            if (!(s >> j & 1) || s & up[j])\n                continue;\n            res = max(res, Rec(s & ~(1 << i) & ~(1 << j)) + 2);\n        }\n    }\n\n    return dp[s] = res;\n}\n\nint main()\n{\n    while (cin >> n, n) {\n        dp.assign(1 << n, -1);\n        up.assign(n, 0);\n\n        // 円の入力\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        // 円の重なり，上下関係\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                if (isOverlap(c[i], c[j]))\n                    up[j] |= (1 << i);\n\n        cout << Rec((1 << n) - 1) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint n, ans = 0;\nint x[25], y[25], r[25], c[25];\nbool memo[1<<24];\n\nbool overlap(int i, int j){\n    return (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j]) * (r[i]+r[j]);\n}\n\nvoid dfs(VI f){\n    int x = 0;\n    REP(i,n) x += f[i] * (1<<i);\n    if (memo[x]) return;\n    memo[x] = 1;\n\n    int res = 0;\n    REP(i,n) res += f[i];\n    ans = max(ans, res);\n\n    VI top(n);\n    REP(i,n){\n        if (f[i]) continue;\n        bool g = 1;\n        REP(j,i){\n            if (f[j]) continue;\n            if (overlap(i,j)) g = 0;\n        }\n        top[i] = (!f[i] & g);\n    }\n\n    // REP(i,n) printf(\"%d \", f[i]);\n    // cout << endl;\n\n    REP(i,n) REP(j,i){\n        if (!top[i] || !top[j] || c[i] != c[j]) continue;\n        f[i] = f[j] = 1;\n        dfs(f);\n        f[i] = f[j] = 0;\n    }\n}\n\nint main() {\n    ifstream ifs(\"in.txt\");\n    while (cin >> n && n){\n        VI f(n);\n        ans = 0;\n        REP(i,1<<n) memo[i] = 0;\n        REP(i,n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n        dfs(f);\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint sq(int x) { return x * x; }\n\nstruct Circle {\n\tint x, y, r, c;\n\tint tops;\n\tCircle (int _x, int _y, int _r, int _c) : x(_x), y(_y), r(_r), c(_c) {}\n};\n\nbool CC(const Circle& c1, const Circle& c2) {\n\tif (sq(c1.x - c2.x) + sq(c1.y - c2.y) < sq(c1.r + c2.r)) return true;\n\treturn false;\n}\n\nint n;\nvector<Circle> cs;\n\nint ans;\nbool memo[1 << 25];\n\nvoid rec(int cur) {\n\tif (memo[cur]) return;\n\t\n\tint ret = __builtin_popcount(cur);\t// 現在取り除いた個数\n\tans = max(ans, ret);\n\t\n\tint rmbit = ~cur;\t// bit反転をとる\n\t\n\t// 今取り除ける円盤を見つける\n\tfor (int i = 0; i < n; i++) {\n\t\tif (cur >> i & 1) continue;\t// すでにとりのぞかれている\n\t\t\n\t\tint topsi = cs[i].tops;\n\t\tif ( (topsi & rmbit) != 0) continue;\n\t\t\n\t\t// i番目の円盤は現在のこっている円盤によらずに取り除ける\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (cur >> j & 1) continue;\t// すでにとりのぞかれている\n\t\t\t\n\t\t\tint topsj = cs[j].tops;\n\t\t\tif ((topsj & rmbit) != 0) continue;\n\t\t\t\n\t\t\t// j番目の円盤も現在のこっている円盤によらずに取り除ける\n\t\t\t\n\t\t\t// 同じ色なら取り除ける\n\t\t\tif (cs[i].c != cs[j].c) continue;\n\t\t\t\n\t\t\t// i と j を取り除いた場合について再帰\n\t\t\tint nxt = cur | (1 << i);\n\t\t\tnxt |= 1 << j;\n\t\t\trec(nxt);\n\t\t}\n\t}\n\t\n\tmemo[cur] = true;\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> n; if (n == 0) break;\n\t\t\n\t\tcs.clear();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x, y, r, c; cin >> x >> y >> r >> c;\n\t\t\tcs.push_back(Circle(x, y, r, c));\n\t\t}\n\t\t\n\t\t// 各円盤に対して、どの円盤が取り除かていればその円盤をとりだせるかを入れる\n\t\t// 取り除かなければならない円盤にbitをたてる\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tint tops = 0;\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (CC(cs[i], cs[j])) {\n\t\t\t\t\ttops |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcs[i].tops = tops;\n\t\t}\n\t\t\n\t\t// すべての円盤が残っている状態から開始\t\t\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tans = 0;\n\t\trec(0);\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//線分を表す構造体\nstruct Segment{ Point p1, p2; };\n//直線を表す構造体\ntypedef Segment Line;\n//多角形を表す構造体\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// 許容する誤差\n#define EPS (1e-10)\n\n// ベクトルaの絶対値を求める\n//double length = abs(a);\n\n// 2点a,b間の距離を求める\n//double distance = abs(a-b);\n\n/*\n// ベクトルaの単位ベクトルを求める\nPoint b = a / abs(a);\n\n// ベクトルaの法線ベクトルn1,n2を求める\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 点cが直線a,b上にあるかないか\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// 点a,bを通る直線と点cとの距離\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// 線分s1と線分s2の距離\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// 線分sに対する点pの射影\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//線分sを対象軸とした点pの線対称の点\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//点pをangle分だけ時計回りに回転\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//円cと線分lの交点\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//点の内包\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//ベクトルの位置検出\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//凸包\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISEだと内角は180以下（一直線上に並んでいても、頂点として数える）\n        //!= CLOCKWISEだと内角は180未満（一直線上の頂点は数えない）\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //ここも == と != を変更する\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //最も下にある点の中で最も右にある点から反時計回りに並び替え\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//キャリパー法を用いて凸多角形の直径を求める\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//凸多角形の切り取りに使う関数。これがなんなのかはまだ知らない。\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//三角形の面積\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//多角形の面積\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//凸多角形かどうかの判定\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//凹多角形を線分lで切断した際の多角形の数\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\n//i番目を0にする\nint clearBit(int num, int i){\n\tint mask = ~(1 << i);\n\treturn num & mask;\n}\n\n//i番目をvで置き換える\nint updateBit(int num, int i, int v){\n\tint mask = ~(1 << i);\n\treturn (num & mask) | (v << i);\n}\n\nint n, ans;\n\nbool isOver(Circle a, Circle b){\n    return abs(a.c - b.c) < a.r + b.r;\n}\n\nvoid dfs(vector<vector<int>>& g, int cur, vector<int>& on){\n\tfor(auto to : g[cur]){\n\t\ton[to] = on[to] bitor (1 << cur) bitor on[cur];\n\t\tdfs(g, to, on);\n\t}\n}\n\nvector<bool> memo;\nvoid dfs(int s, vector<int>& on, vector<int> c){\n\tif(memo[s]) return;\n\n\tvector<vector<int>> canTake(4);\n\trep(i,n){\n\t\tif(getBit(s,i)) continue;\n\t\tif((on[i] bitand s) == on[i]){\n\t\t\tcanTake[c[i]].emplace_back(i);\n\t\t}\n\t}\n\n\tvector<int> take(4,0);\n\trep(i,4){\n\t\tfor(auto j : canTake[i]){\n\t\t\ttake[i] = setBit(take[i], j);\n\t\t}\n\t}\n\n\trep(i,4){\n\t\tif(canTake[i].size() >= 2){\n\t\t\tif(canTake[i].size() % 2 == 1){\n\t\t\t\trep(j,canTake[i].size()){\n\t\t\t\t\tdfs(s bitor clearBit(take[i], j), on, c);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdfs(s bitor take[i], on, c);\n\t\t\t}\n\t\t}\n\t}\n\n\tbitset<30> bit(s);\n\tans = max<int>(ans, bit.count());\n\tmemo[s] = true;\n}\n\nint main(){\n    while(scanf(\"%d\",&n),n){\n        vector<Circle> c(n);\n        vector<int> color(n);\n        rep(i,n){\n            double x,y,r;\n            scanf(\"%lf%lf%lf%d\",&x,&y,&r,&color[i]);\n\t\t\tcolor[i]--;\n            c[i] = {Point(x,y),r};\n        }\n\n\t\tvector<vector<int>> g(n);\n\t\tvector<bool> top(n,1);\n\t\trep(i,n){\n\t\t\trange(j,i + 1,n){\n\t\t\t\tif(isOver(c[i], c[j])){\n\t\t\t\t\tg[i].emplace_back(j);\n\t\t\t\t\ttop[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> on(n,0);\n\t\trep(i,n){\n\t\t\tif(not top[i]) continue;\n\t\t\tdfs(g, i, on);\n\t\t}\n\t\t//rep(i,n) show(on[i])\n\n\t\tans = 0;\n\t\tmemo = vector<bool>(1 << n, 0);\n\t\tdfs(0, on, color);\n\t\tcout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define MAX_COLORS 6\n#define MAX_CIRCLES 4\n#define MAX_N (MAX_COLORS*MAX_CIRCLES)\n#define MAX_STATES (1<<MAX_N)\n\nint biggest, n;\n\n/*\nstruct circle{\n    int x, y, r, c;\n};*/\n\nint X[MAX_N];\nint Y[MAX_N];\nint R[MAX_N];\nint C[MAX_N];\n\n//circle C[MAX_N];\nchar dp[MAX_STATES];\n\nbool isOver( int c1, int c2 ){\n    int dx, dy;\n    dx = (X[c1] - X[c2]) * (X[c1] - X[c2]);\n    dy = (Y[c1] - Y[c2]) * (Y[c1] - Y[c2]);\n    return dx + dy < (R[c1] + R[c2])*(R[c1] + R[c2]) ? true : false;\n}\n\nbool isDeleted( int state, int num ){\n    return (state & (1<<num)) == 0 ? false : true;\n}\n/*\nvoid pbit(int num){\n    //cout << \"bit: \";\n    do{\n        printf(\"%d\", num&1);\n        num = num>>1;\n    }while(num);\n    //printf(\"\\n\");\n}*/\n\nbool isTop( int state, int num ){\n    //pbit(state);\n    for( int i = num-1; i >= 0; i-- ){\n        if( isDeleted(state, i) ) continue;\n        if( isOver(num, i) ) return false;\n    }\n    //cout << num << \" is top\" << endl;\n    return true;\n}\n\nvoid search(int s){\n    //for( int s = 0; s < 1<<n; s++ ){\n        /*cout << \"s: \";\n        pbit(s);\n        cout << endl;\n        */\n        for( int i = 0; i < n; i++ ){\n            if( isDeleted(s, i) ) continue;\n            //cout << \"i: \" << i << endl;\n            for( int j = i+1; j < n; j++ ){\n                if( isDeleted(s, j) ) continue;\n                //cout << \"i: \" << i << endl;\n                //cout << \"j: \" << j << endl;\n                if( isTop(s, i) && isTop(s, j) && C[i] == C[j] ){\n                    int next = s | 1<<i | 1<<j;\n                    //pbit(s);\n                    //cout << \",\" << i << \",\" << j << endl;\n                    if( dp[next] < dp[s]+2 ) dp[next] = dp[s]+2;\n                    if( biggest < dp[next] ) biggest = dp[next];\n                    if( (next | 1) != (1<<n)-1 ) search(next);\n                }\n            }\n        }\n    //}\n}\n\nvoid init(){\n    for( int s = 0; s < 1<<n; s++ ){\n        dp[s] = 0;\n    }\n}\n\nint main(){\n    while( cin >> n, n ){\n        for( int i = 0; i < n; i++ ){\n            //circle a;\n            //scanf(\"%d%d%d%d\", a.x, a.y, a.r, a.c);\n            cin >> X[i] >> Y[i] >> R[i] >> C[i];\n            // C[i] = a;\n        }\n        biggest = 0;\n        init();\n        //dp[0] = 0;\n        search(0);\n        printf(\"%d\\n\", biggest);\n        //cout << \"ans: \" << biggest << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<vector>\n#include<algorithm>\n#define F first\n#define S second\n#define pb push_back\n#define EPS 1e-10\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint n,ans;\nbool used[1000];\nvector<PP> p;\nvector<int> rank;\nvector<int> List[1000];\n\nvoid ranking(){\n  for(int i=0;i<p.size();i++)rank.pb(1);\n\n  for(int i=0;i<p.size();i++){\n    for(int j=i+1;j<p.size();j++){\n      double r1 = p[i].S.F,r2 = p[i].S.F,d = sqrt(pow(p[i].F.F-p[j].F.F,2)+pow(p[i].F.S-p[j].F.S,2));\n      if(fabs(r1-r2) < d  && d < (r1+r2) ){ //cross each other on two different points\n\trank[j]++;\n\tList[i].pb(j);\n      }\n      else if(fabs(d-(r1+r2)) < EPS){ //be circumscribed\n      }\n      else if(fabs(d-fabs(r1-r2)) < EPS){ // be inscribed\n\trank[j]++;\n\tList[i].pb(j);\n      }\n      else{\n      }\n    }\n  }\n}\n\n\nvoid rankIncrease(int x,int y){\n \n  for(int i=0;i<List[x].size();i++){\n      rank[List[x][i]]++;\n    }\n    rank[x]++;\n    return;\n\n\n  for(int i=0;i<rank.size();i++){\n    if(y == i)continue;\n    if(i == x){\n      rank[i]++;\n      continue;\n    }\n double r1 = p[x].S.F,r2 = p[i].S.F,d = sqrt(pow(p[x].F.F-p[i].F.F,2)+pow(p[x].F.S-p[i].F.S,2));\n if(fabs(r1-r2) < d  && d < (r1+r2) ){ //cross each other on two different points\n\trank[i]++;\n      }\n      else if(fabs(d-(r1+r2)) < EPS ){ //be circumscribed\n      }\n      else if(fabs(d-fabs(r1-r2)) < EPS){ // be inscribed\n\trank[i]++;\n      }\n      else{\n      }\n  }\n}\n\n  void rankDecrease(int x,int y){\n    for(int i=0;i<List[x].size();i++){\n      rank[List[x][i]]--;\n    }\n    rank[x]--;\n    return;\n\n  for(int i=0;i<rank.size();i++){\n    if(i == y)continue;\n    if(i == x){\n      rank[i]--;\n      continue;\n    }\n    double r1 = p[x].S.F,r2 = p[i].S.F,d = sqrt(pow(p[x].F.F-p[i].F.F,2)+pow(p[x].F.S-p[i].F.S,2));\n if( fabs(r1-r2) < d  && d < (r1+r2)){ //cross each other on two different pointsq\n\t  rank[i]--;\n      }\n      else if( fabs(d-(r1+r2)) < EPS){ //be circumscribed\n      }\n      else if( fabs(d-fabs(r1-r2)) < EPS){ // be inscribed\n\trank[i]--;\n      }\n      else{\n      }\n  }\n}\n\n\n\n\n\nvoid rec2(int cnt){\n  //cout << \"coumter\" << endl;\n   for(int i=0;i<rank.size();i++){\n     if(rank[i] != 1)continue;\n    //cout << ans << endl;\n    if(rank[i] == 1 ){\n      for(int j=0;j<rank.size();j++){\n\tif(i == j || rank[j] <= 0)continue;\n\tif(p[i].S.S == p[j].S.S && rank[j] == 1 ){//usedつかったrtsdkrkm\t\n\t  rankDecrease(i,j); rankDecrease(j,i);\n\t  \n\t  rec2(cnt+2);\n\t  rankIncrease(i,j); rankIncrease(j,i);\n\t}\n      }\n    }\n  }\n \n  ans = max(ans,cnt);\n}\n\nint main(){\n  \n  while(cin >> n && n){ \n    ans = 0;\n    for(int i=0;i<n;i++)used[i] = false;\n    p.clear(); rank.clear();\n    for(int i=0;i<n;i++){\n List[i].clear();\n      int x,y,r,c;\n      cin >> x >> y >> r >> c;\n      p.pb(PP(P(x,y),P(r,c)));\n    }\n    ranking();\n  \n    rec2(0);   \n \n     cout << ans << endl;\n  }\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n\nvoid rec(int cnt){\n\n  int j=0,flag = 0;\n  bool fl = true;\n  while(fl){ \n\n    if(rank[j] == 0){\n    \n    j++;\n      if(j%n == 0 && j!=0){\n\tj=0;\n\tif(finish()){\n\t  ans = max(ans,cnt);\n\t  fl = false;\n\t  return;\n\t}\n\tflag = 0;\n      }\n      continue;\n    }\n\n    if(rank[j] == 1){\n      for(int i=0;i<rank.size();i++){      \n\tif(i == j || rank[i] <= 0)continue;\n\tif(rank[i] == 1 && p[j].S.S == p[i].S.S){\n\t  flag++;\n\t  rankDecrease(i);\n\t  rankDecrease(j);\n\t  rec(cnt+2);\n\t  rankIncrease(i);\n\t  rankIncrease(j);\n\t  flag--;\n\t}\n      }\n    }\n\n    j++;\n\n    if(j%n == 0 && j!=0){\n      j=0;\n      if(finish()){\n\tans = max(ans,cnt);\n\tfl = false;\n\treturn;\n      }\n      flag= 0;\n    }\n  }\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<vector>\nstruct S{int c,f,x,y,r;}s[24];\nint A(int x){return x*x;}\nchar m[1<<24];\nint n,c[5];\nint F(int f)\n{\n\tif(m[f]>=0)return m[f];\n\tstd::vector<int>v[5];\n\tint i,j,k,r=0,t,u;\n\tfor(i=0;i<n;++i)\n\t\tif((f&(1<<i))&&!(s[i].f&f))\n\t\t\tv[s[i].c].push_back(i);\n\tfor(k=1;k<5;++k)\n\t{\n\t\tif(c[k]>0&&c[k]%2==0&&c[k]==v[k].size())\n\t\t{\n\t\t\tu=c[k];\n\t\t\tc[k]=0;\n\t\t\tr+=u;\n\t\t\tt=f;\n\t\t\tfor(i=0;i<v[k].size();++i)t^=(1<<v[k][i]);\n\t\t\tr+=F(t);\n\t\t\tc[k]=u;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(i=0;i<v[k].size();++i)\n\t\t\t\tfor(j=i+1;j<v[k].size();++j)\n\t\t\t\t{\n\t\t\t\t\tc[k]-=2;\n\t\t\t\t\tr+=2+F(f&~(1<<v[k][i])&~(1<<v[k][j]));\n\t\t\t\t\tc[k]+=2;\n\t\t\t\t}\n\t\t}\n\t}\n\treturn m[f]=r;\n}\nint main()\n{\n\tint i,j;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tmemset(m,-1,sizeof(m));\n\t\tmemset(s,0,sizeof(s));\n\t\tmemset(c,0,sizeof(c));\n\t\tfor(i=0;i<n;++i)scanf(\"%d%d%d%d\",&s[i].x,&s[i].y,&s[i].r,&s[i].c),++c[s[i].c];\n\t\tfor(i=0;i<n;++i)\n\t\t\tfor(j=i+1;j<n;++j)\n\t\t\t\tif(A(s[i].x-s[j].x)+A(s[i].y-s[j].y)<A(s[i].r+s[j].r))\n\t\t\t\t\ts[j].f|=1<<i;\n\t\tprintf(\"%d\\n\",F((1<<n)-1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle {\n    double x, y, r;\n    int c;\n    Circle() {}\n    Circle(double x, double y, double r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    return (a.r + b.r) > sqrt((a.x - b.x) * (a.x - b.x) +\n                              (a.y - b.y) * (a.y - b.y));\n}\n\nint main()\n{\n    int n;\n\n    while (cin >> n, n) {\n        vector<int> dp(1 << n, 0), up(n, 0);\n        vector<Circle> c(n);\n\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                if (isOverlap(c[i], c[j])) {\n                    if (i < j) // jの上にiがある\n                        up[j] |= 1 << i;\n                    else // iの上にjがある\n                        up[i] |= 1 << j;\n                }\n\n        for (int s = 0; s < 1 << n; ++s) {\n            for (int i = 0; i < n; ++i) {\n                if (s >> i & 1 || s & up[i])  // c[i]が既に置かれているかc[i]が置けない\n                    continue;\n                for (int j = i + 1; j < n; ++j) {\n                    if (c[i].c != c[j].c) // 色が異なる\n                        continue;\n                    if (s >> j & 1 || s & up[j])  // c[j]が既に置かれているかc[j]が置けない\n                        continue;\n                    if (up[i] >> j & 1 || up[j] >> i & 1) // c[i]とc[j]を同時に置けない\n                        continue;\n                    int nxt = s | 1 << i;\n                    nxt = nxt | 1 << j;\n                    dp[nxt] += dp[s] + 2;\n                }\n            }\n        }\n\n        cout << dp[(1 << n) - 1] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint foo(int S, vector<int>& c, vector<int>& a, vector<int>& memo) {\n\tif (memo[S] != -1) return memo[S];\n\tint n = c.size(), cnt = 0;\n\tvector< vector<int> > v(4);\n\tfor (int i = 0; i < n; i++)\n\t\tif (S & (1 << i)) {\n\t\t\tcnt++;\n\t\t\tif (!(S & a[i])) v[c[i] - 1].push_back(i);\n\t\t}\t\n\tint mini = cnt;\n\tfor (int j = 0; j < 4; j++) {\n\t\tint m = v[j].size();\n\t\tfor (int k = 0; k < m; k++)\n\t\t\tfor (int _k = k + 1; _k < m; _k++) {\n\t\t\t\tint _S = S - (1 << v[j][k]) - (1 << v[j][_k]);\n\t\t\t\tmini = min(mini, foo(_S, c, a, memo));\n\t\t\t}\n\t}\n\treturn memo[S] = mini;\n}\n\nint main() {\n\tfor (;;) {\n\t\tint n; cin >> n;\n\t\tif (n == 0) break;\n\t\tvector<int> x(n), y(n), r(n), c(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tint dx = x[i] - x[j], dy = y[i] - y[j], d = r[i] + r[j];\n\t\t\t\tif (dx * dx + dy * dy < d * d) a[i] |= (1 << j);\n\t\t\t}\n\t\tvector<int> memo(1 << n, -1);\n\t\tcout << n - foo((1 << n) - 1, c, a, memo) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint sum=0,ds;\nint n;\nvoid rec(vector<circle> vs){\n  //cout << vs.size() << endl;\n  int i,j,k;\n  int f;\n  int on[30]={};\n  vector<int> cc[5];\n  vector<circle> next;\n  f=1;\n  int ff=0;\n  while(ff==0){\n    ff=1;\n    for(i=0;i<30;i++) on[i]=0;\n    for(i=0;i<5;i++) cc[i].clear();\n    for(i=0;i<vs.size();i++){\n      for(j=i+1;j<vs.size();j++){\n\tif(ch(vs[i],vs[j])==1) on[j]=1;\n      }\n    }\n    for(i=0;i<vs.size();i++){\n      if(on[i]==0) cc[vs[i].c].push_back(i);\n    }\n    for(i=1;i<5;i++){\n      if(cc[i].size()>0&&cc[i].size()%2==0){\n\tfor(j=cc[i].size()-1;j>=0;j--){\n\t  vs.erase(vs.begin()+cc[i][j]);\n\t  ff=0;\n\t}\n      }\n    }\n  }\n  for(i=1;i<5;i++){\n    //cout << cc[i].size() << endl;\n    if(cc[i].size()>=2&&cc[i].size()%2==1){\n      f=0;\n      next.clear();\n      for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n      for(j=0;j<cc[i].size();j++){\n\tfor(k=cc[i].size()-1;k>=0;k--){\n\t  if(k!=j)\n\t    next.erase(next.begin()+cc[i][k]);\n\t}\n\trec(next);\n      }\n      break;\n    }\n  }\n  int o=n-vs.size();\n  if(f==1) sum=max(sum,o);\n  else{\n    next.clear();\n    for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n    rec(next);\n  }\n}\n\nint main(){\n  cin >> n;\n  while(n!=0){\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    sum=0;\n    rec(v);\n    cout << sum << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct circle{\n  double x, y, r;\n  int c;\n  unordered_set<int> up, down;\n};\n  \nvoid calcOverlap(int n, circle *disk){\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      double x = disk[i].x - disk[j].x,\n        y = disk[i].y - disk[j].y;\n      if(sqrt(x*x + y*y) + 1e-8 < disk[i].r + disk[j].r){\n        disk[j].up.insert(i);\n        disk[i].down.insert(j);\n      }\n    }\n  }\n}\n  \nbool canRemove(circle d, circle dd){\n  if(d.c != dd.c)return false;\n  if(d.down.size() == 0 and dd.down.size() == 0)return false;\n  return d.up.empty() and dd.up.empty();\n}\n  \nint dfs(int n, circle *disk, bool *removed, int dep = 0){\n  int res = dep;\n  for (int i = 0; i < n; i++) {\n    if(removed[i] == true)continue;\n    for (int j = i + 1; j < n; j++) {\n      if(removed[j] == true)continue;\n      if(not canRemove(disk[i], disk[j]))continue;\n      removed[i] = true;\n      removed[j] = true;\n      vector<int> erase_i, erase_j;\n      for (int k = 0; k < n; k++) {\n        if(disk[k].up.find(i) != disk[k].up.end()){\n          disk[k].up.erase(i);\n          erase_i.push_back(k);\n        }\n        if(disk[k].up.find(j) != disk[k].up.end()){\n          disk[k].up.erase(j);\n          erase_j.push_back(k);\n        }\n      }\n      res = max(res, dfs(n, disk, removed, dep + 1));\n      for (int k = 0; k < erase_j.size(); k++) {\n        disk[erase_j[k]].up.insert(j);\n      }\n      for (int k = 0; k < erase_i.size(); k++) {\n        disk[erase_i[k]].up.insert(i);\n      }\n      removed[i] = false;\n      removed[j] = false;\n    }\n  }\n  if(res == dep){\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        if(removed[i] or removed[j])continue;\n        if(disk[i].c == disk[j].c)res++;\n      }\n    }\n  }\n  return res;\n}\n  \nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n, n){\n    circle disk[n];\n    for (int i = 0; i < n; i++) {\n      cin >> disk[i].x >> disk[i].y >> disk[i].r >> disk[i].c;\n    }\n    bool removed[n];\n    memset(removed, false, sizeof(removed));\n    calcOverlap(n, disk);\n    int ans = 0;\n    std::cout << 2*(ans + dfs(n, disk, removed)) << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nstruct Circle{\n\tint cx,cy,r,color;\n};\n\n// ð·»è\nbool cross(Circle c1,Circle c2){\n\treturn (c1.cx-c2.cx)*(c1.cx-c2.cx)+(c1.cy-c2.cy)*(c1.cy-c2.cy) < (c1.r+c2.r)*(c1.r+c2.r);\n}\n\nint dp[1<<24];\nCircle circles[30];\nint n;\n\nint dfs(int s){\n\tif(dp[s]!=-1)\n\t\treturn dp[s];\n\tif(s==0)\n\t\treturn 0;\n\n\t// ¡êÔãÉ é~ðßé\n\tbool up[30];\n\tfill(up,up+30,false);\n\tfor(int i = 0; i < n; i++){\n\t\tbool f = false;\n\t\tif((((s>>i)&1)==0))\n\t\t\tcontinue;\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif(i==j||(((s>>j)&1)==0))\n\t\t\t\tcontinue;\n\t\t\t// SÌ~Æä×ÄêÔãÉ é©Ç¤©ðÝé\n\t\t\tif(cross(circles[i],circles[j])){\n\t\t\t\tif(i>j){\n\t\t\t\t\tf=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!f){\n\t\t\tup[i]=true;\n\t\t}\n\t}\n\n\t// æè­û@ð·×Ä·\n\tint maxNum=0;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = i+1; j < n; j++){\n\t\t\tif(up[i]&&up[j]&&circles[i].color==circles[j].color){\n\t\t\t\tint ns=s;\n\t\t\t\tns &= ~(1<<i);\n\t\t\t\tns &= ~(1<<j);\n\t\t\t\tmaxNum=max(maxNum,dfs(ns)+2);\n\t\t\t}\n\t\t}\n\t}\n\tdp[s]=maxNum;\n\treturn maxNum;\n}\n\nint main(){\n\n\twhile(cin>>n&&n!=0){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tCircle cc;\n\t\t\tcin>>cc.cx>>cc.cy>>cc.r>>cc.color;\n\t\t\tcircles[i]=cc;\n\t\t}\n\t\tfill(dp,dp+(1<<24),-1);\n\t\tcout<<dfs((1<<(n))-1)<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <bitset>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef complex<double> P;\n\nstruct C {\n  P p;\n  int r, c;\n};\nint n;\nvector<C> vc;\nint memo[1<<24];\nint solve(int S) {\n  if (memo[S] != -1) return memo[S];\n//cout << bitset<24>(S) << endl;\n  int T = 0;\n  REP(i,n) {\n    if (S>>i&1) continue;\n    bool f = 1;\n    REP(j,i) {\n      if (S>>j&1) continue;\n      if (abs(vc[i].p-vc[j].p) < vc[i].r+vc[j].r) {\n        f = 0;\n        break;\n      }\n    }\n    if (f) T |= 1<<i;\n  }\n  int res = 0;\n  // FOR(it, hoge)\n  //   cout << *it << \" \";\n  // cout << endl;\n  REP(i,n) {\n    if (!(T>>i&1)) continue;\n    REP(j,i) {\n      if (!(T>>j&1)) continue;\n      if (vc[i].c==vc[j].c)\n        res = max(res, solve(S|(1<<i)|(1<<j)) + 2);\n    }\n  }\n  return memo[S] = res;\n}\n\nint main() {\n  while(cin>>n,n) {\n    vc.clear();\n    REP(i,n) {\n      int x,y,r,cc;\n      cin >> x>>y>>r>>cc;\n      vc.push_back((C){P(x,y),r,cc});\n    }\n    memset(memo,-1,sizeof(memo));\n    cout << solve(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\n\nclass state{\npublic:\n    P p;\n    double r;\n    int c;\n};\n\nbool onCircle(state a, state b){\n    return (abs(a.p-b.p) < a.r+b.r);\n}\n\nshort int a[1<<24];\nint n;\nstate v[24];\nint ans, over[24];\n\nvoid check(int pos){\n    int c = 0;\n    for(int i=0;i<n-1;i++){\n        if((pos & (1<<i)) == 0 && (c & (1<<i)) == 0){\n            c |= over[i];\n            for(int j=i+1;j<n;j++){\n                if((pos & (1<<j)) == 0 && (c & (1<<j)) == 0 && v[i].c == v[j].c){\n                    int next = pos | (1<<i) | (1<<j);\n                    if(a[next] < a[pos] + 2){\n                        a[next] = a[pos] + 2;\n                        ans = max((short int)ans,a[next]);\n                        check(next);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    while(cin >> n && n){\n        fill(over,over+n,0);\n        fill(a,a+(1<<n),0);\n        ans = 0;\n        for(int i=0;i<n;i++){\n            double x,y;\n            cin >> x >> y >> v[i].r >> v[i].c;\n            v[i].p = P(x,y);\n        }\n\n        for(int i=0;i<n;i++)\n            for(int j=i+1;j<n;j++)\n                if(onCircle(v[i],v[j]))\n                    over[i] |= (1<<j);\n\n        for(int i=0;i<n;i++)\n            for(int j=n-1;j>i;j--)\n                over[i] |= over[j];\n\n        check(0);\n\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <utility>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nbool flag[ 1 << 23 ];\n\nint saiki( vector<int> c, vector<long int> on, int n, int cnt, int m, int f ) {\n\tif ( flag[f] == true ) return m;\n\tfor ( int i = 0; i < n-1; i++ ) {\n\t\tfor ( int j = i+1; j < n; j++ ) {\n\t\t\tif ( on[i] == 0 && on[j] == 0 && c[i] == c[j] ) {\n\t\t\t\tvector<long int> on_copy;\n\t\t\t\tfor ( int k = 0; k < n; k++ ) {\n\t\t\t\t\tif ( k == i || k == j ) {\n\t\t\t\t\t\ton_copy.push_back( 1 << k );\n\t\t\t\t\t}else {\n\t\t\t\t\t\tint bit = ~( ( 1 << i ) + ( 1 << j ) );\n\t\t\t\t\t\ton_copy.push_back( on[k] & bit );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint f_copy = f | ( 1 << i ) | ( 1 << j );\n\t\t\t\tm = max( m, n-(cnt-2) );\n\t\t\t\tm = max( m, saiki( c, on_copy, n, cnt-2, m, f_copy ) );\n\t\t\t}\n\t\t}\n\t}\n\tflag[f] = true;\n\treturn m;\n}\n\nint main(){\n\twhile(true) {\n\n\t\tint n;\n\t\tcin >> n;\n\t\tif ( n == 0 ) break;\n\n\t\tvector<int> x;\n\t\tvector<int> y;\n\t\tvector<int> r;\n\t\tvector<int> c;\n\t\tvector<long int> on;\n\t\tlong int input;\n\n\t\tfor ( int i = 0; i < n; i++ ) {\n\t\t\tcin >> input;\n\t\t\tx.push_back(input);\n\t\t\tcin >> input;\n\t\t\ty.push_back(input);\n\t\t\tcin >> input;\n\t\t\tr.push_back(input);\n\t\t\tcin >> input;\n\t\t\tc.push_back(input);\n\t\t\tinput = 0;\n\t\t\tfor ( int j = 0; j < i; j++ ) {\n\t\t\t\tint xlen = x[i] - x[j];\n\t\t\t\tint ylen = y[i] - y[j];\n\t\t\t\tint rlen = r[i] + r[j];\n\t\t\t\tif ( xlen*xlen + ylen*ylen < rlen*rlen ) input += ( 1 << j );\n\t\t\t}\n\t\t\ton.push_back(input);\n\t\t}\n\n\t\tfor ( int i = 0; i < ( 1 << (n-1) ); i++ ) {\n\t\t\tflag[i] = false;\n\t\t}\n\n\t\tcout << saiki( c, on, n, n, 0, 0 ) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define double long double\n\ndouble EPS = (1e-8);\n\nstruct Point {\n  double x, y;\n};\n\nstruct Circle {\n  Point p;\n  double r;\n  int id;\n};\n\nbool intersect(Circle a, Circle b) {\n  double x1 = a.p.x, y1 = a.p.y;\n  double x2 = b.p.x, y2 = b.p.y;  \n  double d = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);\n\n  if ( d - (a.r+b.r)*(a.r+b.r) >= -EPS ) return false;  \n  else return true;\n}\n\nvector<Circle> C[4];\nvector<Circle> circles;\nint N;\nunordered_map<int, int> dp;\n\nint dfs(int bit) {\n  //cout << bit << endl;\n  if ( bit == (1<<N)-1 ) return 0;\n  if ( dp[bit] ) return dp[bit];\n\n  int ret = 0;\n  int n;\n  for ( int i = 0; i < 4; i++ ) {\n    n = C[i].size();\n    for ( int a = 0; a < n; a++ ) {\n      Circle c1 = C[i][a];\n      int i1 = c1.id;\n      //if ( bit == 9 && i1 == 1 ) cout << 'a' << endl;\n      if ( bit & (1<<i1) ) continue;\n      bool flag = true;\t\n      for ( int j = 0; j < i1; j++ ) {\n\tif ( !(bit & (1<<j)) && intersect(circles[j], c1) ) {\n\t  flag = false;\n\t  break;\n\t}\n      }\n      //if ( bit == 9 && i1 == 1 ) cout << 'a' << endl;\n      if ( !flag ) continue;\n      //if ( bit == 9 && i1 == 1 ) cout << 'a' << endl;\n      for ( int b = a+1; b < n; b++ ) {\n\tCircle c2 = C[i][b];\n\tint i2 = c2.id;\n\t//if ( i1 == 1 && i2 == 2 ) cout << 'a' << endl;\n\tif ( bit & (1<<i2) ) continue;       \t\n\tfor ( int j = 0; j < i2; j++ ) {\n\t  if ( !(bit & (1<<j)) && intersect(circles[j], c2) ) {\t    \n\t    flag = false;\n\t    break;\n\t  }\n\t}\n\tif ( flag ) {\n\t  ret = max(ret, dfs(bit|(((1<<i1)+(1<<i2))))+2);\t  \n\t} else {\n\t  flag = true;\n\t}\n      }\n    }\n  }\n  \n  return dp[bit] = ret;  \n}\n\nsigned main() {\n  while ( cin >> N, N ) {\n    for ( int i = 0; i < 4; i++ ) C[i].clear();\n    circles.clear();\n    dp.clear();    \n    \n    for ( int i = 0; i < N; i++ ) {\n      Circle in;\n      double x, y, r;\n      int c;      \n      cin >> x >> y >> r >> c;\n      c--;\n      in.p = Point{x, y};      \n      in.r = r;\n      in.id = i;      \n      C[c].push_back(in);\n      circles.push_back(in);      \n    }\n    \n    cout << dfs(0) << endl;    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct circle{\n  double x, y, r;\n  int c;\n  unordered_set<int> up, down;\n};\n\nvoid calcOverlap(int n, circle *disk){\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      int x = disk[i].x - disk[j].x, y = disk[i].y - disk[j].y;\n      if(sqrt(x*x + y*y) + 1e-8< disk[i].r + disk[j].r){\n        disk[j].up.insert(i);\n        disk[i].down.insert(j);\n      }\n    }\n  }\n}\n\nbool canRemove(circle d, circle dd){\n  if(d.c != dd.c)return false;\n  if(not d.up.empty() or\n     not dd.up.empty())return false;\n  return true;\n}\n\nint dfs(int n, circle *disk, bool *removed, int dep = 0){\n  int res = 0;\n  bool f = false;\n  for (int i = 0; i < n; i++) {\n    if(removed[i] == true)continue;\n    for (int j = i + 1; j < n; j++) {\n      if(removed[j] == true)continue;\n      if(not canRemove(disk[i], disk[j]))continue;\n      f = true;\n      removed[i] = true;\n      removed[j] = true;\n      vector<int> erase_i, erase_j;\n      for (int k = 0; k < n; k++) {\n        if(disk[k].up.find(i) != disk[k].up.end()){\n          disk[k].up.erase(i);\n          erase_i.push_back(k);\n        }\n        if(disk[k].up.find(j) != disk[k].up.end()){\n          disk[k].up.erase(j);\n          erase_j.push_back(j);\n        }\n      }\n      res = max(res, dfs(n, disk, removed, dep + 1));\n      for (int k = 0; k < erase_j.size(); k++) {\n        disk[erase_j[k]].up.insert(j);\n      }\n      for (int k = 0; k < erase_i.size(); k++) {\n        disk[erase_i[k]].up.insert(i);\n      }\n      removed[i] = false;\n      removed[j] = false;\n    }\n  }\n  return f?res:dep;\n}\n\nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n, n){\n    circle disk[n];\n    for (int i = 0; i < n; i++) {\n      cin >> disk[i].x >> disk[i].y >> disk[i].r >> disk[i].c;\n    }\n    bool removed[n];\n    memset(removed, false, sizeof(removed));\n    calcOverlap(n, disk);\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        if(not canRemove(disk[i], disk[j]))continue;\n        if(not disk[i].down.empty() or\n           not disk[j].down.empty())continue;\n        removed[i] = true;\n        removed[j] = true;\n        ans++;\n      }\n    }\n    std::cout << 2*(ans + dfs(n, disk, removed)) << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\nusing namespace std;\n\n#define x real()\n#define y imag()\n#define pb push_back \ntypedef double D;\ntypedef complex<D> P;\ntypedef struct circle{\n\tP p;\n\tD r;\n} C;\n\nbool rel[24][24];\nC c[24];\nvector<int> color[4];\nbool used[1<<24];\nint cmax;\n\nbool IC(C a,C b){\n\tD d=norm(a.p-b.p);\n\tD r=(a.r+b.r)*(a.r+b.r);\n\treturn d<r;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n, n){\n\t\tcmax=0;\n\t\tfor(int i=0;i<4;i++){\n\t\t\twhile(!color[i].empty())\n\t\t\t\tcolor[i].pop_back();\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tmp;\n\t\t\tcin >> c[i].p.x >> c[i].p.y >> c[i].r;\n\t\t\tcin >> tmp;\n\t\t\tcolor[tmp-1].pb(i);\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(i==j)\n\t\t\t\t\tcontinue;\n\t\t\t\trel[i][j]=IC(c[i],c[j]);\n\t\t\t}\n\t\t}\n\t\tused[0]=true;\n\t\tfor(int u=0;u<(1<<n);u++){\n\t\t\tif(!used[u])\n\t\t\t\tcontinue;\n\t\t\tint res=0;\n\t\t\tint tmp=u;\n\t\t\twhile(tmp){\n\t\t\t\tif(tmp&1)\n\t\t\t\t\tres++;\n\t\t\t\ttmp >>=1;\n\t\t\t}\n\t\t\tcmax=max(cmax,res);\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tfor(int j=0;j<color[i].size();j++){\n\t\t\t\t\tbool jok=true;\n\t\t\t\t\tif(u >>color[i][j]&1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor(int jc=color[i][j]-1;jc>=0;jc--)\n\t\t\t\t\t\tif(rel[ color[i][j] ][jc]&!(u >>jc&1))\n\t\t\t\t\t\t\tjok=false;\n\t\t\t\t\tif(!jok)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tfor(int k=j+1;k<color[i].size();k++){\n\t\t\t\t\t\tbool kok=true;\n\t\t\t\t\t\tif(u >>color[i][k]&1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor(int kc=color[i][k]-1;kc>=0;kc--)\n\t\t\t\t\t\t\tif(rel[color[i][k]][kc]&!(u >>kc&1))\n\t\t\t\t\t\t\t\tkok=false;\n\t\t\t\t\t\tif(!kok)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tused[u|(1<<color[i][j])|(1<<color[i][k])]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cmax << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint sq(int x) { return x * x; }\n\nstruct Circle {\n\tint x, y, r, c;\n\tint tops;\n\tCircle (int _x, int _y, int _r, int _c) : x(_x), y(_y), r(_r), c(_c) {}\n};\n\nbool CC(const Circle& c1, const Circle& c2) {\n\tif (sq(c1.x - c2.x) + sq(c1.y - c2.y) < sq(c1.r + c2.r)) return true;\n\treturn false;\n}\n\nint n;\nvector<Circle> cs;\n\nint memo[1 << 24];\n\nint rec(int cur) {\n\tif (memo[cur] >= 0) return memo[cur];\n\t\n\tint ret = __builtin_popcount(cur);\t// 返す値を用意する\n\tint rmbit = ~cur;\t// bit反転をとる\n\t\n\t// 今取り除ける円盤を見つける\n\tvector<int> cand;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (cur >> i & 1) continue;\t// すでにとりのぞかれている\n\t\t\n\t\tint topsi = cs[i].tops;\n\t\tif ( (topsi & rmbit) != 0) continue;\n\t\t\n\t\t// i番目の円盤は現在のこっている円盤によらずに取り除ける\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (cur >> j & 1) continue;\n\t\t\t\n\t\t\tint topsj = cs[j].tops;\n\t\t\tif ((topsj & rmbit) != 0) continue;\n\t\t\t\n\t\t\t// j番目の円盤も現在のこっている円盤によらずに取り除ける\n\t\t\t\n\t\t\t// 同じ色なら取り除ける\n\t\t\tif (cs[i].c != cs[j].c) continue;\n\t\t\t\n\t\t\t// i と j を取り除いた場合について再帰\n\t\t\tint nxt = cur | (1 << i);\n\t\t\tnxt |= 1 << j;\n\t\t\tret = max(ret, rec(nxt));\n\t\t}\n\t}\n\t\n\treturn memo[cur] = ret;\t// メモしながら返す\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> n; if (n == 0) break;\n\t\t\n\t\tcs.clear();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x, y, r, c; cin >> x >> y >> r >> c;\n\t\t\tcs.push_back(Circle(x, y, r, c));\n\t\t}\n\t\t\n\t\t// 各円盤に対して、どの円盤が取り除かていればその円盤をとりだせるかを入れる\n\t\t// 取り除かなければならない円盤にbitをたてる\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tint tops = 0;\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (CC(cs[i], cs[j])) {\n\t\t\t\t\ttops |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcs[i].tops = tops;\n\t\t}\n\t\t\n\t\t// すべての円盤が残っている状態から開始\t\t\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tcout << rec(0) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint sum=0,ds;\nint n;\nvoid rec(vector<circle> vs){\n  //cout << vs.size() << endl;\n  int i,j,k;\n  int f;\n  int on[100]={};\n  vector<int> cc[10];\n  vector<circle> next;\n  \n  f=1;\n  for(i=0;i<100;i++) on[i]=0;\n  for(i=0;i<vs.size();i++){\n    for(j=i+1;j<vs.size();j++){\n      if(ch(vs[i],vs[j])==1) on[j]=1;\n    }\n  }\n  for(i=0;i<vs.size();i++){\n    if(on[i]==0) cc[vs[i].c].push_back(i);\n  }\n  for(i=1;i<5;i++){\n    if(cc[i].size()>0&&cc[i].size()%2==0){\n      for(j=cc[i].size()-1;j>=0;j--){\n\tvs.erase(vs.begin()+cc[i][j]);\n\tf=0;\n      }\n    }\n  }\n  for(i=1;i<5;i++){\n    //cout << cc[i].size() << endl;\n    if(cc[i].size()>=2&&cc[i].size()%2==1){\n      f=0;\n      next.clear();\n      for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n      for(j=0;j<cc[i].size();j++){\n\tfor(k=j+1;k<cc[i].size();k++){\n\t  next.erase(next.begin()+cc[i][k]);\n\t  next.erase(next.begin()+cc[i][j]);\n\t  rec(next);\n\t}\n      }\n    }\n  }\n  int o=n-vs.size();\n  if(f==1) sum=max(sum,o);\n  else{\n    next.clear();\n    for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n    rec(next);\n  }\n}\n\nint main(){\n  cin >> n;\n  while(n!=0){\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    sum=0;\n    rec(v);\n    cout << sum << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <iostream>\n\nusing namespace std;\n\nint pow2(int m){\n\treturn m * m;\n};\n\nint n, m, c[24], d, p[24];\n\nint bitnum(int n){\n\tint cnt;\n\tcnt = 0;\n\twhile(n){\n\t\tif(n % 2 == 1) cnt++;\n\t\tn /= 2;\n\t}\n\treturn cnt;\n}\n\nint main(void){\n\tint x[24], y[24], r[24], i, j, k, dp[1 << 7];\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n\t\tmemset(p,0,sizeof(p));\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < i;j++)\n\t\t\t\tif(sqrt((double)pow2(x[i] - x[j]) + pow2(y[i] - y[j])) < r[i] + r[j]) p[i] += 1 << j;\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0] = 1;\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i]){\n\t\t\t\tfor(j = 0;j < n - 1;j++){\n\t\t\t\t\tfor(k = j + 1;k < n;k++)\n\t\t\t\t\t\tif(c[j] == c[k] && ~i & (1 << j) && ~i & (1 << k) && (i & p[j]) == p[j] && (i & p[k]) == p[k]) dp[i + (1 << j) + (1 << k)] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tm = 0;\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i])\n\t\t\t\tm = max(m,bitnum(i))\n\t\t}\n\t\tprintf(\"%d\\n\",m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <functional>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n\n#define X first\n#define Y second\n#define mp(x, y) make_pair(x, y)\n#define pb(e) push_back(e)\n#define rep(i, b, n) for (int i = b; i < n; ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define each(c, i) for (iter(c) i = (c).begin(); i != (c).end(); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\ntypedef pair<double, double> PDD;\ntypedef long long LINT;\ntypedef vector<int> VI;\ntypedef vector<VI> VII;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\n\nconst int MAX_N = 24;\nint N;\nint color[MAX_N];\nint ride[MAX_N];\nint x[MAX_N];\nint y[MAX_N];\nint r[MAX_N];\n\nbool isCollision ( int x1, int y1, int r1, int x2, int y2, int r2 )\n{\n\tint xx = x1 - x2, yy = y1 - y2, rr = r1 + r2;\n\treturn (xx * xx + yy * yy) < (rr * rr);\n}\n\nint dfs ( int state, int depth )\n{\n\tif (depth == N/2) { return 0; }\n\tint res = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif ((state & (1 << i)) && !(state & ride[i])) {\n\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\tif ((state & (1 << j)) && !(state & ride[j]) && color[i] == color[j]) {\n\t\t\t\t\tint next = state & ~((1 << i) | (1 << j));\n\t\t\t\t\tres = max(res, dfs(next, depth+1) + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main ( void )\n{\n\twhile (cin >> N, N) {\n\t\tfill(ride, ride+N, 0);\n\t\trep (i, 0, N) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> color[i];\n\t\t\trep (j, 0, i) {\n\t\t\t\tif (isCollision(x[i], y[i], r[i], x[j], y[j], r[j])) {\n\t\t\t\t\tride[i] |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dfs((1 << N) - 1, 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circ{\n  vector<int> chil;\n  int useless;\n  bool done;\n};\nvoid Init();\nvoid Tree();\nint Solve();\ncirc BO[50];\ndouble P[50][3];\nvector< vector<int> > color(4); \nint n;\nint main(){\n  while(cin >>n,n){\n    Init();\n    for(int i=0,c; i<n; i++){\n      cin >>P[i][0]>>P[i][1]>>P[i][2]>>c;\n      color[c-1].push_back(i);\n    }\n    Tree();\n    cout <<Solve()<<endl;\n  }\n  return 0;\n}\nvoid Init(){\n  for(int i=0; i<4; i++) color[i].clear();\n  for(int i=0; i<10; i++){\n    BO[i].done = false;\n    BO[i].useless = 0;\n    BO[i].chil.clear();\n    P[i][0] = P[i][1] = P[i][2] = 0;\n  }\n}\nvoid Tree(){\n  for(int i=0; i<n; i++){\n    for(int j=i+1; j<n; j++){\n      double dx = P[i][0]-P[j][0];\n      double dy = P[i][1]-P[j][1];\n      double rr = P[i][2]+P[j][2];\n      if(dx*dx+dy*dy<rr*rr){\n\tBO[i].chil.push_back(j);\n\tBO[j].useless++;\n      }\n    }\n  }\n}\nint Solve(){\n  int ans = 0;\n  for(int i=0; i<4; i++){\n    for(int ii=0; ii<color[i].size(); ii++){\n      for(int jj=ii+1; jj<color[i].size(); jj++){\n\tint a = color[i][ii];\n\tint b = color[i][jj];\n\tif(BO[a].useless || BO[b].useless) continue;\n\tif(BO[a].done || BO[b].done) continue;\n\tBO[a].done = BO[b].done = true;\n\tfor(int j=0; j<BO[a].chil.size(); j++) BO[BO[a].chil[j]].useless--;\n\tfor(int j=0; j<BO[b].chil.size(); j++) BO[BO[b].chil[j]].useless--;\n\tint ANS = Solve()+2;\n\tif(ans<ANS) ans = ANS;\n\tBO[a].done = BO[b].done = false;\n\tfor(int j=0; j<BO[a].chil.size(); j++) BO[BO[a].chil[j]].useless++;\n\tfor(int j=0; j<BO[b].chil.size(); j++) BO[BO[b].chil[j]].useless++;\n      }\n    }\n  }\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define FOR(i,a,n) for(int i=a;i<n;++i)\n#define REP(i,n) FOR(i,0,n)\n\nstruct disk{\n\tint x,y,r,c,n;\n};\nbool on(disk l,disk r){\n\treturn(pow(l.r+r.r,2.0)>pow(l.x-r.x,2.0)+pow(l.y-r.y,2.0));\n}\nstruct tree{\n\tdisk d;\n\tvector<tree> children;\n\tint depth;\n\ttree(disk d,int depth):d(d),depth(depth){\n\t}\n\ttree(){d.n=-1;depth=0;}\n\tvoid add(disk &other){\n\t\tif(!add_r(other)){\n\t\t\tchildren.push_back(tree(other,depth+1));\n\t\t}\n\t}\n\tbool add_r(disk &other){\n\t\tif(children.empty()){\n\t\t\tif(on(d,other)){\n\t\t\t\tchildren.push_back(tree(other,depth+1));\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].add_r(other)){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\tif(on(d,other)){\n\t\t\t\t\tchildren.push_back(tree(other,depth+1));\n\t\t\t\t\treturn true;\n\t\t\t\t}else{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tvoid leaves(vector<tree*> &trees){\n\t\tif(children.empty()){\n\t\t\ttrees.push_back(this);\n\t\t}else{\n\t\t\tREP(i,children.size()){\n\t\t\t\tchildren[i].leaves(trees);\n\t\t\t}\n\t\t}\n\t}\n\tbool dlt(disk &dd){\n\t\tif(children.empty()){\n\t\t\treturn false;\n\t\t}\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].d.n==dd.n){\n\t\t\t\tchildren.erase(children.begin()+i);\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\tif(children[i].dlt(dd))return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint dfs(tree &t){\n\tvector<tree*> leaves;\n\tt.leaves(leaves);\n\tint best=0;\n\tREP(i,leaves.size()){\n\t\tFOR(j,i+1,leaves.size()){\n\t\t\tif(leaves[i]->d.c==leaves[j]->d.c){\n\t\t\t\ttree nt(t);\n\t\t\t\tnt.dlt(leaves[i]->d);\n\t\t\t\tnt.dlt(leaves[j]->d);\n\t\t\t\tbest=max(best,dfs(nt)+2);\n\t\t\t}\n\t\t}\n\t}\n\treturn best;\n}\n\nbool pred(tree *l,tree *r){\n\treturn l->depth>r->depth;\n}\nint greedy(tree &t){\n\tvector<tree*> leaves;\n\tt.leaves(leaves);\n\tsort(leaves.begin(),leaves.end(),pred);\n\tREP(i,leaves.size()){\n\t\tFOR(j,i+1,leaves.size()){\n\t\t\tif(leaves[i]->d.c==leaves[j]->d.c){\n\t\t\t\ttree nt(t);\n\t\t\t\tnt.dlt(leaves[i]->d);\n\t\t\t\tnt.dlt(leaves[j]->d);\n\t\t\t\treturn greedy(nt)+2;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\ttree t;\n\t\tvector<disk> disks;\n\t\tREP(i,n){\n\t\t\tdisk d;\n\t\t\tcin>>d.x>>d.y>>d.r>>d.c;\n\t\t\td.n=i;\n\t\t\tdisks.push_back(d);\n\t\t}\n\t\tREP(i,n){\n\t\t\tt.add(disks[n-i-1]);\n\t\t}\n\t\tcout<<dfs(t)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <complex>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\n\nconst ld EPS = 1e-8;\n\nstruct C{\n  P c;\n  ld r;\n  C(P c_,ld r_):c(c_),r(r_){}\n  C(ld l1,ld l2, ld l3):c(l1,l2),r(l3){}\n};\n\nvoid search(vector<char>& opt, int bits, const vector<C>& cs, const vector<int>& clr, const vector<vector<bool>>& t,int n) {\n  vector<vector<int>> ebl(4);\n  REP(i,n) {\n    if(((bits>>i)&1)==0)continue;\n    bool fr = true;\n    REP(j,i){\n      if(((bits>>j)&1)==0)continue;\n      if(t[i][j]) {\n        fr=false;\n        break;\n      }\n    }\n    if(fr){\n      ebl[clr[i]].push_back(i);\n    }\n  }\n  char mx_ebl = 0;\n  REP(i,4){\n    if(ebl[i].size() < 2) continue;\n    int m=ebl[i].size();\n    REP(j,m)REP(k,j){\n      int ij = ebl[i][j];\n      int ik = ebl[i][k];\n      int nb = (bits & ~(1 << ij)) & ~(1 << ik);\n      if(opt[nb] < 0) {\n        search(opt, nb, cs,clr,t,n);\n      }\n      mx_ebl = max(mx_ebl, char(opt[nb] + 2));\n    }\n  }\n  opt[bits] = mx_ebl;\n}\n\nint main() {\n  while(1){\n    int n;\n    cin >> n;\n    if(!n) break;\n    vector<C> cs;\n    vector<int> clr;\n    REP(i,n) {\n      ld x,y,r;\n      int c;\n      cin>>x>>y>>r>>c;\n      --c;\n      cs.emplace_back(x,y,r);\n      clr.push_back(c);\n    }\n    vector<vector<bool>> t(n,vector<bool>(n,false));\n    REP(i,n)REP(j,i){\n      if(norm(cs[i].c-cs[j].c) + EPS < (cs[i].r+cs[j].r)*(cs[i].r+cs[j].r)) {\n        t[i][j] = true;\n      }\n    }\n    vector<char> opt(1<<n, -1);\n    search(opt,(1<<n)-1,cs,clr,t,n);\n    int o = opt[(1<<n)-1];\n    cout << o << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\nint n;\ndouble x[24], y[24], r[24];\nint c[24], p[24];\n\nchar dp[1 << 24];\n\nint f(int s) {\n\tif(dp[s] != -1) return -1;\n\tif(s == 0) return 0;\n\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++) if((s & (1 << i)) && ((s & p[i]) == 0)) {\n\t\tfor(int j = i + 1; j < n; j++) if((s & (1 << j)) && ((s & p[j]) == 0)) {\n\t\t\tif(c[i] != c[j]) continue;\n\t\t\tint ns = s ^ (1 << i) ^ (1 << j);\n\t\t\tret = max(ret, 2 + f(ns));\n\t\t}\n\t}\n\treturn dp[s] = ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\n\t\tmemset(p, 0, sizeof p);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < i; j++) {\n\t\t\t\tdouble d = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n\t\t\t\tif(d < (r[i] + r[j]) * (r[i] + r[j])) {\n\t\t\t\t\tp[i] |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(dp, -1, sizeof dp);\n\t\tcout << f((1 << n) - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define mod 1000000007\n#define all(c) begin(c),end(c)\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nusing ll = long long;\nusing vi = vector<int>; using vs = vector<string>;\nint dd[] = { 0, 1, 0, -1, 0 }; //→↓←↑\n\n\n\nvoid solve()\n{\n\tint N;\n\twhile (cin >> N, N)\n\t{\n\t\tvector<int> x(N);\n\t\tvector<int> y(N);\n\t\tvector<int> r(N);\n\t\tvector<int> c(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\t\n\t\tvector<int> G[30];\n\t\t//vector<int> P(N);\n\t/*\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tP[i] = -1;\n\t\t}*/\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t{\n\t\t\t\tint xx = x[i] - x[j];\n\t\t\t\tint yy = y[i] - y[j];\n\t\t\t\tint rr = r[i] + r[j];\n\t\t\t\tif (xx * xx + yy * yy < rr * rr)\n\t\t\t\t{\n\t\t\t\t\tG[j].emplace_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> dp(1 << N, 0);\n\t\tint ans = 0;\n\t\tvector<bool> ok(N, false);\n\t\tfor (int S = 0; S < 1 << N; S++)\n\t\t{\n\t\t\tif (S != 0 && dp[S] == 0)continue;\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t{\n\t\t\t\tif (S >> i & 1)continue;\n\t\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t\t{\n\t\t\t\t\tif (S >> j & 1)continue;\n\t\t\t\t\tif (c[i] != c[j])continue;\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\tfor (int v : G[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!ok[v]) {\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!flag)continue;\n\t\t\t\t\tfor (int v : G[j]) {\n\t\t\t\t\t\tif (!ok[v])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!flag)continue;\n\n\n\t\t\t\t\tchmax(dp[S | (1 << i) | (1 << j)], dp[S] + 2);\n\t\t\t\t\tchmax(ans, dp[S | (1 << i) | (1 << j)]);\n\t\t\t\t\tok[i] = true;\n\t\t\t\t\tok[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << dp[S] << endl;\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\nint x[30],y[30],r[30],c[30],n;\nbool table[30][30];\nmap<pair<vector<int>,vector<int> >,int> memo;\n\nint dist2(int i,int j){\n\tint dx=x[i]-x[j],dy=y[i]-y[j];\n\treturn dx*dx+dy*dy;\n}\n\nint slv(vector<int> sum,vector<int> used){\n\tint i,j,k,re=0,tmp;\n\tbool flag=0;\n/*\tfor(i=0;i<n;i++){\n\tcout<<sum[i]<<\" \";\n\t}cout<<endl;\n*/\t\n\tfor(i=0;i<n;i++){\n\t\tif(sum[i]>0 || used[i])continue;\n\t\tfor(j=i+1;j<n;j++){\n\t\t\tif(sum[j]>0 || used[j])continue;\n\t\t\tif(c[i]==c[j]){\n//\t\t\tcout<<\"(\"<<i<<\",\"<<j<<\")\"<<endl;\n\t\t\t\tused[i]=used[j]=1;\n\t\t\t\tfor(k=i+1;k<n;k++)\n\t\t\t\t\tsum[k]-=table[i][k];\n\t\t\t\tfor(k=j+1;k<n;k++)\n\t\t\t\t\tsum[k]-=table[j][k];\n\t\t\t\tflag=1;\n\t\t\t\tif(memo.count(make_pair(sum,used))){\n\t\t\t\t\ttmp=memo[make_pair(sum,used)];\n\t\t\t\t}else{\n\t\t\t\t\ttmp=slv(sum,used)+2;\n\t\t\t\t\tmemo.insert(make_pair(make_pair(sum,used),tmp));\n\t\t\t\t}\n\t\t\t\tif((tmp) > re){\n\t\t\t\t\tre=tmp;\n\t\t\t\t}\n\t\t\t\tused[i]=used[j]=0;\n\t\t\t\tfor(k=i+1;k<n;k++)\n\t\t\t\t\tsum[k]+=table[i][k];\n\t\t\t\tfor(k=j+1;k<n;k++)\n\t\t\t\t\tsum[k]+=table[j][k];\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\treturn re;\n}\n\t\t\t\t\n\t\t\n\nint main(){\n\tint i,j;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tvector<int> sum;\n\t\tvector<int> used;\n\t//\tre=0;\n\t\tmemset(table,0,sizeof(table));\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",x+i,y+i,r+i,c+i);\n\t\t\tused.push_back(0);\n\t\t\tsum.push_back(0);\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\ttable[i][j]=(r[i]+r[j])*(r[i]+r[j])>dist2(i,j);\n\t\t\t\tif(i>j)sum[i]+=table[i][j];\n\t\t\t}\n\t\t}\t//harahe\n\t\t\n/*\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++)cout<<table[i][j]<<\" \";\n\t\t\tcout<<\":\"<<sum[i]<<endl;\n\t\t}*/\n\t\tprintf(\"%d\\n\",slv(sum,used));\n\t\t\n\t}\n\t\n\treturn 0;\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double R;//double long double ??????????????? cmath?????¢??°??????????????????????????????????????????????????§????????????\ntypedef complex<R> Point;\ntypedef pair<Point , Point> Line;\ntypedef pair<Point ,R > Circle;\ntypedef vector<Point> Poly;\n\n#define EPS (1e-10)//??????\n#define EQ(a,b) (abs((a)-(b)) < EPS)//??????????????°???????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )//????????????????????????????????????\n#define mp make_pair\n#define ft first\n#define sd second\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nR dot(Point a,Point b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nR cross(Point a,Point b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\nbool is_orthogonal(Line a,Line b){//2??´????????´?????????\n    return EQ(dot(a.ft - a.sd,b.ft - b.sd),0.0);\n}\nbool is_parallel(Line a,Line b){//2??´??????????????????\n    return EQ(cross(a.ft - a.sd,b.ft - b.sd),0.0);\n}\n\n////////////////////????????????\n\nint ccw(Point a,Point b,Point c){//ok\n    b -= a; c -= a;\n    if(cross(b,c) > EPS) return 1;//a???b??§???????¨???¨???????????????b???c\n    if(cross(b,c) < -EPS) return -1;//a???b??§????¨???¨???????????????b???c\n    if(dot(b,c) < -EPS) return 2;//c--a--b on same line\n    if(norm(c) - norm(b) > EPS) return -2;//a--b--c(abs??????????????????????????????????????????????????????????)\n    return 0;//a--c--b?????????b==c\n}\n\nbool is_intersection_ll(Line l,Line m){//???????????´??????????????????\n    return abs(cross(l.sd - l.ft,m.sd - m.ft)) > EPS || //????????§??????\n        abs(cross(l.sd - l.ft,m.ft - l.ft)) < EPS; //?????????????????????\n}\n\nbool is_intersection_ls(Line l,Line s){//??´???l??¨??????s???????????????\n    return cross(l.sd - l.ft, s.ft-l.ft)*       // s[0] is left of l\n        cross(l.sd - l.ft, s.sd - l.ft) < EPS; // s[1] is right of l\n}\n\nbool is_intersection_lp(Line l,Point p){//??´???l??¨???p???????????????\n    return abs(cross(l.sd - p,l.ft - p));\n}\n\nbool is_intersection_ss(Line a,Line b){//??????????????????????????????ok\n    return ccw(a.ft,a.sd,b.ft)*ccw(a.ft,a.sd,b.sd) <= 0 && ccw(b.ft,b.sd,a.ft)*ccw(b.ft,b.sd,a.sd) <= 0;\n}\n\nbool is_intersection_sp(Line s,Point p){//????????¨?????????????????? ????§??????????????????¨\n    return abs(s.ft - p) + abs(s.sd - p) - abs(s.ft - s.sd) < EPS;\n}\n\n/////////////?????¢\n\nR dis_lp(Line l,Point p){//??´???l??¨???p????????¢\n    return abs(cross(l.sd - l.ft,p - l.ft)) / abs(l.sd - l.ft);\n}\n\nR dis_ll(Line l,Line m){//???????????´???????????¢\n    return is_intersection_ll(l,m) ? 0.0 : dis_lp(l,m.ft);\n}\n\nR dis_ls(Line l,Line s){//??´???l??¨??????s????????¢\n    if(is_intersection_ls(l,s)) return 0.0;\n    return min(dis_lp(l,s.ft),dis_lp(l,s.sd));\n}\n\nR dis_sp(Line s,Point p){//??????s??¨???p????????¢\n    if(dot(s.sd - s.ft,p - s.ft) < EPS) return abs(p - s.ft);\n    if(dot(s.ft - s.sd,p - s.sd) < EPS) return abs(p - s.sd);\n    return dis_lp(s,p);\n}\n\nR dis_ss(Line s,Line t){//???????????????????????¢\n    if(is_intersection_ss(s,t)) return 0.0;\n    return min(min(dis_sp(s,t.ft),dis_sp(s,t.sd)),\n            min(dis_sp(t,s.ft),dis_sp(t,s.sd)));\n}\n\n//////////////?°???±??¨????°?\n\nPoint projection(Line l,Point p){//?°???±????±???????\n    R t = dot(p - l.ft,l.ft - l.sd) / norm(l.ft - l.sd);\n    return l.ft + t * (l.ft - l.sd);\n}\n\nPoint reflection(Line l,Point p){//????°?????±???????\n    return p + 2.0 * (projection(l,p) - p);\n}\n\n//////////////??????(????????????????¨???????????????¨??????????????????????????????????????£??????)\n\nPoint intersection_ll(Line l,Line m){//????????????????????????????????????????????????\n    R A = cross(l.sd - l.ft,m.sd - m.ft);\n    R B = cross(l.sd - l.ft,l.sd - m.ft);\n    if(abs(A) < EPS && abs(B) < EPS) return m.ft;//?????????\n    //if(abs(A) < EPS)assert(false);//????????§????????????\n    return m.ft + B / A * (m.sd - m.ft);\n}\n\nLine intersection_of_two_circles(Circle c1,Circle c2){//ok ????????????????????????Line?????\\????????????(r1 + r2 > sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2))???????????????????????????\n    R a =  abs(c2.ft - c1.ft);\n    R b = c1.sd;\n    R c = c2.sd;\n\n    R rc = (a  * a + b * b - c * c) / (2.0 * a);\n    R rs = sqrt(b * b - rc * rc);//C++ ??§???????????????????????????????????§???????????????sqrt ????????? float ?????????????????? long double ????????????????????????????????????????????¨?????§???????????? C ????????°????????§??????sqrt ????????? double ??????????????£??????????????????\n    Point diff = (c2.ft - c1.ft) / a;\n\n    Line p ;\n    p.ft = c1.ft + diff * rc + diff * Point(0,1) * rs;\n    p.sd = c1.ft + diff * rc + diff * Point(0,-1) * rs;\n\n    return p;\n}\n\n\nLine conver_line(Line a,Point maxi,Point mini){//??????????????´??????????????? maxi???????????????????????? mini?????????\n\n    if(abs(dot(a.sd - a.ft,Point(1.0,0.0))) < EPS){//??????x???????????´??????\n        ;\n    }\n}\n\n/////////////////////////polygon\n\n#define currP(P,i) P[i]//????????????\n#define nextP(P,i) P[(i + 1)%P.size()]//?¬??????????\n\nint is_contains_p_in_Poly(Poly po,Point p){//??????????§???¢????????¨(1)????¢????(-1)????????¨(0)??????????????????????????????\n    bool in = false;\n    REP(i,po.size()){\n        Point a = currP(po,i) - p,b = nextP(po,i) - p;\n        if(a.imag() > b.imag())swap(a,b);\n        if(a.imag() < EPS && -EPS < b.imag())\n            if(cross(a,b) < -EPS) in = !in;\n        if(abs(cross(a,b)) == 0.0 && dot(a,b) < EPS)return  -1;\n    }\n    return in;\n}\n\nR area2(Poly po){//????§???¢?????¢????????????????±???????\n    R A = 0.0;\n    REP(i,po.size())\n        A += cross(currP(po,i),nextP(po, i));\n    return A;\n}\n\n///////////////////////////???\n\nPoly convex_hull(Poly ps){\n    int n = ps.size(),k = 0;\n    Poly ch(2*n);\n    for(int i = 0;i < n;ch[k++] = ps[i++])// lower-hull\n        while(k >= 2 && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0) --k;\n    for(int i = n - 2,t = k + 1;i >= 0;ch[k++] = ps[i--])//upper-hull\n        while(k >= t && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\n#define prevP(P, i) P[(i+P.size()-1) % P.size()]\nbool isconvex(Poly P){\n    for(int i = 0;i < P.size();++i)\n        if(ccw(prevP(P,i),currP(P,i),nextP(P,i)) > 0) return false;\n    return true;\n}\n\nbool kosa(Circle c1, Circle c2) {\n  return abs(c1.ft-c2.ft)<(c1.sd+c2.sd);\n}\n\n#define MAX_N 24\n\nint n;\nCircle cs[MAX_N];\nint cc[MAX_N];\n\nbool input() {\n  cin>>n;\n  int x, y, r;\n  REP(i, n) {\n    cin>>x>>y>>r>>cc[i];\n    cs[i] = mp(Point(x, y), r);\n  }\n  return n!=0;\n}\n\nchar dp[1<<MAX_N];\n\nbool totta[MAX_N],toreru[MAX_N];\n\nint saiki(int S) {\n  if(dp[S] > -1)\n    return dp[S];\n  REP(i,n){totta[i] = S&(1<<i);toreru[i] = true;}\n  REP(i,n){\n    if(totta[i]){\n      toreru[i] = false;\n      continue;\n    }\n    REP(j,i){\n      if(!totta[j] && kosa(cs[i],cs[j])){\n        toreru[i] = false;\n        break;\n      }\n    }\n  }\n  bool f=false;\n  REP(i, n)f=f||toreru[i];\n  if(!f)return 0;\n  int maxi = 0;\n  REP(i,n){\n    if(toreru[i]){\n      FOR(j,i+1,n){\n        if(toreru[j] && cc[i] == cc[j])\n          maxi = max( maxi, saiki(S|(1<<i)|(1<<j))+2 );\n      }\n    }\n  }\n  return maxi;\n}\n\nvoid solve() {\n  REP(i,1<<n)\n    dp[i] = -1;\n  cout<<saiki(0)<<endl;\n}\n\nint main() {\n  \n  while(input()) {\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n\nint n;\nvector<int> x(30),y(30),r(30),c(30);\n\nbool intersect(int idx,int jdx){\n    return (x[idx]-x[jdx])*(x[idx]-x[jdx])+(y[idx]-y[jdx])*(y[idx]-y[jdx])<(r[idx]+r[jdx])*(r[idx]+r[jdx]);\n}\n\nvoid dfs(int st, map<int,int> &visited,vector<bool> &dp){\n    dp[st]=true;\n    visited[st]++;\n    vector<int> cand;\n    for(int i=0;i<n;i++){\n        if((st>>i)&1) cand.push_back(i);\n    }\n    vector<bool> rm(n,true);\n    for(int i=0;i<(int)cand.size();i++){\n        for(int j=0;j<i;j++){\n            if(intersect(cand[i],cand[j])) rm[cand[i]]=false;\n        }\n    }\n    for(int i=0;i<(int)cand.size();i++){\n        for(int j=i+1;j<(int)cand.size();j++){\n            int idx=cand[i],jdx=cand[j];\n            if(!rm[idx] || !rm[jdx]) continue;\n            if(c[idx] != c[jdx]) continue;\n            int next=st;\n            next &= ~(1<<idx);\n            next &= ~(1<<jdx);\n            if(visited[next]) continue;\n            //cout<<\"next = \"<<next<<endl;\n            dfs(next,visited,dp);\n        }\n    }\n    return ;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin>>n,n){\n        for(int i=0;i<n;i++){\n            cin>>x[i]>>y[i]>>r[i]>>c[i];\n        }\n        vector<bool> dp(1<<n,false);\n        map<int,int> visited;\n        dfs((1<<n)-1,visited,dp);\n        int res=0;\n        for(int i=0;i<(1<<n);i++){\n            if(!dp[i]) continue;\n            res=max(res, __builtin_popcount(i ^ ((1<<n)-1)));\n            //cout<<i<<endl;\n        }\n        cout<<res<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<set>\nusing namespace std;\nint ret=0;\nint x[30];\nint y[30];\nint r[30];\nint c[30];\nint used;\nset<int>dp;\nint n;\nint now;\nvoid solve(){\n\tif(dp.count(used))return;\n\tdp.insert(used);\n\tret=max(ret,now);\n\tint can[30];\n\tfor(int i=0;i<n;i++)can[i]=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(used&(1<<i))continue;\n\t\tcan[i]=1;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(!(used&(1<<j))&&(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])<(r[i]+r[j])*(r[i]+r[j]))can[i]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++){\n\t\tif(can[i]&&can[j]&&c[i]==c[j]){\n\t\t\tnow+=2;\n\t\t\tused+=(1<<i)+(1<<j);\n\t//\t\tused[i]=used[j]=1;\n\t\t\tsolve();\n\t\t\tused-=(1<<i)+(1<<j);\n\t//\t\tused[i]=used[j]=0;\n\t\t\tnow-=2;\n\t\t}\n\t}\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=a-1;i>=0;i--)scanf(\"%d%d%d%d\",x+i,y+i,r+i,c+i);\n\t\tret=0;n=a;\n\t//\tused=vector<int>(a);\n\t\tused=0;\n\t\tdp.clear();\n\t\tnow=0;\n\t\tsolve();\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n\nint8_t DP[1<<24];//LSB???i=0?????????\nint X[24];\nint Y[24];\nint R[24];\nint C[24];\nint cover[24];//???????????????????????????\nint n;\n\nint rec(int E){\n    if(~DP[E]) return DP[E];\n    int maximum=0;\n    for(int i=0;i<n;i++){\n        if((E&(1<<i))==0) continue;\n        for(int j=i+1;j<n;j++){\n            if((E&(1<<j))==0) continue;\n            if(cover[j]&E) continue;\n            if(C[i]==C[j]){\n                maximum=max(maximum,rec(E^(1<<i)^(1<<j))+2);\n            }\n        }\n    }\n    DP[E]=maximum;\n    return maximum;\n}\n\nint main(){\n    while(cin>>n,n){\n        for(int i=0;i<n;i++){\n            cin>>X[i]>>Y[i]>>R[i]>>C[i];            \n        }\n        fill(cover,cover+24,0);\n        for(int i=0;i<n;i++){//i???j???????????????????????????\n            for(int j=i+1;j<n;j++){\n                if(hypot(X[i]-X[j],Y[i]-Y[j])<R[i]+R[j]){\n                    cover[j]|=1<<i;\n                }\n            }\n        }\n        fill(DP,DP+(1<<24),-1);\n        DP[0]=0;\n        cout<<rec((1<<n)-1)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define repn(i, m, n) for (int i = m; i < int(n); ++i)\n\nchar mem[1<<6][1<<6][1<<6][1<<6];\nint a[4], x[4][6], y[4][6], r[4][6];\nint over[4][6];\n\nint f(int bit) {\n  //cout << bit << endl;\n  int res = 0;\n  rep (i, 4) {\n    rep (j, a[i]) {\n      int bit1 = 1 << (i * 6 + j);\n      //cout << i << \" \" << j << \" \" << over[i][j] << endl;\n      if (bit & over[i][j] || !(bit & bit1)) continue;\n      repn (k, j + 1, a[i]) {\n\tint bit2 = 1 << (i * 6 + k);\n\t//cout << bit << \" \" << bit1 << \" \" << bit2 << endl;\n\tif (bit & over[i][k] || !(bit & bit2)) continue;\n\tres = max(res, f(bit ^ bit1 ^ bit2) + 2);\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  int n;\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n    memset(a, 0, sizeof(a));\n    memset(mem, 0, sizeof(mem));\n    memset(over, 0, sizeof(over));\n    rep (i, n) {\n      int xx, yy, rr, cc;\n      cin >> xx >> yy >> rr >> cc;\n      --cc;\n      x[cc][a[cc]] = xx;\n      y[cc][a[cc]] = yy;\n      r[cc][a[cc]] = rr;\n      rep (i, 4) rep (j, a[i]) {\n\tif ((x[i][j] - xx) * (x[i][j] - xx) + (y[i][j] - yy) * (y[i][j] - yy) >= (r[i][j] + rr) * (r[i][j] + rr)) continue;\n\tover[cc][a[cc]] |= 1 << (i * 6 + j);\n      }\n      //cout << cc << \" \" << a[cc] << \" \" << over[cc][a[cc]] << endl;\n      ++a[cc];\n    }\n    int bit = (1 << a[0]) - 1;\n    bit |= (1 << 6 << a[1]) - (1 << 6);\n    bit |= (1 << 12 << a[2]) - (1 << 12);\n    bit |= (1 << 18 << a[3]) - (1 << 18);\n    cout << f(bit) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\nchar bit_count[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\nchar bit_count[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            if(((bit>>i)&1)==0)continue;\n            if(((bit>>j)&1)==0)continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(c[i]==c[j]&&ok(i,bit)&&ok(j,bit)&&!memo[to_bit]){\n                ret=max(ret,dfs(to_bit));\n            }\n        }\n    }\n\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\nvoid init(){\n    for(int i=0;i<(1<<24);i++){\n        for(int j=0;j<24;j++)if((i>>j)&1){\n            bit_count[i]++;\n        }\n    }\n}\n\nint main(){\n    init();\n    while(input())solve();\n    return 0;\n}\ni]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            if(((bit>>i)&1)==0)continue;\n            if(((bit>>j)&1)==0)continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(c[i]==c[j]&&ok(i,bit)&&ok(j,bit)&&!memo[to_bit]){\n                ret=max(ret,dfs(to_bit));\n            }\n        }\n    }\n\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\nvoid init(){\n    for(int i=0;i<(1<<24);i++){\n        for(int j=0;j<24;j++)if((i>>j)&1){\n            bit_count[i]++;\n        }\n    }\n}\n\nint main(){\n    //init();\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = a.r * a.r + 2 * a.r * b.r + b.r * b.r;\n    return r > (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\nint main()\n{\n    int n;\n\n    while (cin >> n, n) {\n        const int N = 1 << n;\n        vector<char> dp(N, -1), up(n, 0);\n        vector<Circle> c(n);\n\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j) {\n                if (isOverlap(c[i], c[j])) {\n                    if (i < j) // jの上にiがある\n                        up[j] |= (1 << i);\n                    else // iの上にjがある\n                        up[i] |= (1 << j);\n                }\n            }\n\n        int res = 0;\n        dp[N - 1] = 0;\n        for (int s = N - 1; s >= 0; --s) {\n            if (dp[s] == -1)\n                continue;\n\n            res = max(res, (int)dp[s]);\n            for (int i = 0; i < n; ++i) {\n                if (!(s >> i & 1) || (s & up[i])) // c[i]が置かれていないかc[i]が取り除けない\n                    continue;\n\n                for (int j = i + 1; j < n; ++j) {\n                    if (c[i].c != c[j].c) // 色が異なる\n                        continue;\n                    if (!(s >> j & 1) || (s & up[j]))// c[j]が置かれていないかc[j]が取り除けない\n                        continue;\n\n                    int nxt = s & ~(1 << i) & ~(1 << j);\n                    dp[nxt] = max((int)dp[nxt], dp[s] + 2);\n                }\n            }\n        }\n\n        for (int s = N - 1; s >= 0; --s)\n            res = max(res, (int)dp[s]);\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\nint n;\nint x[24];\nint y[24];\nint r[24];\nint c[24];\nint ans;\nbool memo[1 << 24];\n\ninline int dbl(int x){ return x * x; }\n\nint kasa[24];\n\nint main(){\n  while(scanf(\"%d\", &n), n){\n    REP(i,n) scanf(\"%d%d%d%d\", x+i, y+i, r+i, c+i);\n    memset(memo, 0, sizeof(memo)); ans = 0;\n\n    stack<int> q; q.push((1 << n) - 1);\n    memo[(1<<n) - 1] = true;\n\n    for(int i = 0; i < n; i++){\n      kasa[i] = 0;\n      for(int j = i + 1; j < n; j++){\n        if(dbl(x[i] - x[j]) + dbl(y[i] - y[j]) < dbl(r[i] + r[j]))\n          kasa[i] += (1 << j);\n      }\n    }\n\n    while(q.size()){\n      int flag = q.top(); q.pop();\n      bool top[24]; REP(i,n) top[i] = true;\n\n      ans = max(ans, n - __builtin_popcount(flag));\n      if(ans == n) break;\n\n      int candidate = flag;\n      for(int i = 0; i < n; i++){\n        if(flag & (1 << i)){\n          candidate &= (~kasa[i]);\n        }\n      }\n\n      for(int i = 0; i < n; i++){\n        if(candidate & (1 << i)){\n          for(int j = i + 1; j < n; j++){\n            if(candidate & (1 << j)){\n              int next = flag ^ (1 << i) ^ (1 << j);\n              if(!memo[next]){\n                q.push(next);\n                memo[next] = true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    print(ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint sum;\nint n;\nvector<circle>  v;\nint on[30]={};\nbool dp[1<<24];\nvoid rec(int bit){\n  if(dp[bit]) return;\n  dp[bit]=true;\n  int i,j,k;\n  int o=0;\n  for(i=0;i<n;i++) if(bit>>i&1) o++;\n  sum=max(n-o,sum);\n  int f=0;\n  for(i=0;i<n;i++){\n    if(!(bit>>i&1)||bit&on[i]) continue;\n    for(j=i+1;j<n;j++){\n      if(!(bit>>j&1)||bit&on[j]) continue;\n      if(v[i].c==v[j].c){\n\trec((bit&~(1<<i))&~(1<<j));\n      }\n    }\n  }\n}\n\nint main(){\n  cin >> n;\n  while(n!=0){\n    circle c;\n    int i,j,k;\n    v.clear();\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      v.push_back(c);\n    }\n    sum=0;\n    fill(on,on+30,0);\n    for(i=0;i<n;i++){\n      for(j=0;j<i;j++){\n\tif(ch(v[i],v[j])) on[i]|=(1<<j);\n      }\n    }\n    fill(dp,dp+(1<<n),false);\n    rec((1<<n)-1);\n    cout << sum << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n#define N 24\n\nclass Disk {\npublic:\n    int x, y, r, c;\n\n    Disk(int xx, int yy, int rr, int cc) :x(xx), y(yy), r(rr), c(cc) {}\n\n    bool on(const Disk& d) {\n        return (x - d.x) * (x - d.x) + (y - d.y) * (y - d.y) < (r + d.r) * (r + d.r);\n    }\n    bool sameColor(const Disk &d) {\n        return c == d.c;\n    }\n};\n\nvector<Disk> disk;\nmap<int, int> memo;\n\nint dfs(int used) {\n    if(memo[used]) return memo[used];\n    vector<int> candidate;\n    for(int i = 0; i < disk.size(); i++) {\n        if(used & (1<<i)) continue;\n        bool ok = true;\n        for(int j = 0; j < i; j++) {\n            if(used & (1<<j)) continue;\n            if(!disk[j].on(disk[i])) continue;\n            ok = false;\n            break;\n        }\n        if(ok) candidate.push_back(i);\n    }\n\n    int result = 0;\n    for(int ci = 0; ci < candidate.size(); ci++) {\n        for(int cj = 0; cj < ci; cj++) {\n            int i = candidate[ci];\n            int j = candidate[cj];\n            if(!disk[i].sameColor(disk[j])) continue;\n            result = max(result, 2 + dfs(used | (1<<i) | (1<<j)));\n        }\n    }\n    return memo[used] = result;\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        disk.clear();\n        memo.clear();\n        for(int i = 0; i < n; i++) {\n            int x, y, r, c;\n            cin >> x >> y >> r >>c;\n            disk.push_back(Disk(x, y, r, c));\n        }\n        cout << dfs(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n#include <ctime>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, string> Ps;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF = 1 << 27;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\nconst int CLK = CLOCKS_PER_SEC;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nint x[24];\nint y[24];\nint r[24];\nint c[24];\nint dp[1 << 24];\n\nbool intersect(int i, int j){\n\tint dx = x[i] - x[j];\n\tint dy = y[i] - y[j];\n\tif((dx*dx)+(dy*dy) < (r[i] + r[j])*(r[i] + r[j])) return true;\n\telse return false;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tmemset(dp, 0, sizeof(dp));\n\t\trep(i, n){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\n\t\trep(state, 1 << n){\n\t\t\tint can_use = state;\n\t\t\trep(j, n){\n\t\t\t\trep(i, j){\n\t\t\t\t\tif((state & (1 << i)) && (state & (1 << j)) && (intersect(i, j))){\n\t\t\t\t\t\tcan_use &= ~(1 << j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, n){\n\t\t\t\trep(j, i){\n\t\t\t\t\tif((can_use & (1 << i)) && (can_use & (1 << j)) && c[i] == c[j]){\n\t\t\t\t\t\tdp[state] = max(dp[state], dp[state - (1 << j) - (1 << i)] + 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1 << n) - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,dp[(1<<25)];\nint x[24],y[24],r[24],c[24];\nint dist(int a,int b){return (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);}\n\nint rec(int S){\n  if(dp[S]!=-1)return dp[S];\n  int res=0;\n  bool f[n];\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    f[i]=true;\n    for(int j=i-1;j>=0;j--){\n      if((S>>j)&1)continue;\n      if(dist(i,j)>=(r[i]+r[j])*(r[i]+r[j]))continue;\n      f[i]=false;\n    }\n  }\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    if(!f[i])continue;\n    for(int j=i+1;j<n;j++){\n      if((S>>j)&1)continue;\n      if(!f[j])continue;\n      if(c[i]!=c[j])continue;\n      res=max(res,2+rec(S+(1<<i)+(1<<j)));\n    }\n  }\n  return dp[S]=res;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<(1<<n)*2;i++)dp[i]=-1;\n    for(int i=0;i<n;i++)\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n    cout<<rec(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n        //!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //????????? == ??¨ != ????????´??????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //?????????????????????????????§??????????????????????????????????¨??????????????????????\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//?????£?????????????????¨?????????????§???¢?????´???????±???????\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//???????§???¢??????????????????????????¢??°??????????????????????????????????????\\????????????\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//????§???¢?????¢???\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//????§???¢?????¢???\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//???????§???¢?????????l??§??????????????????????§???¢?????°\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\ntemplate < class BidirectionalIterator >\nbool next_combination ( BidirectionalIterator first1 ,\n        BidirectionalIterator last1 ,\n        BidirectionalIterator first2 ,\n        BidirectionalIterator last2 ){\n    if (( first1 == last1 ) || ( first2 == last2 )) {\n        return false ;\n    }\n    BidirectionalIterator m1 = last1 ;\n    BidirectionalIterator m2 = last2 ; --m2;\n    while (--m1 != first1 && !(* m1 < *m2 )){\n    }\n    bool result = (m1 == first1 ) && !(* first1 < *m2 );\n    if (! result ) {\n        while ( first2 != m2 && !(* m1 < * first2 )) {\n            ++ first2 ;\n        }\n        first1 = m1;\n        std :: iter_swap (first1 , first2 );\n        ++ first1 ;\n        ++ first2 ;\n    }\n    if (( first1 != last1 ) && ( first2 != last2 )) {\n        m1 = last1 ; m2 = first2 ;\n        while (( m1 != first1 ) && (m2 != last2 )) {\n            std :: iter_swap (--m1 , m2 );\n            ++ m2;\n        }\n        std :: reverse (first1 , m1 );\n        std :: reverse (first1 , last1 );\n        std :: reverse (m2 , last2 );\n        std :: reverse (first2 , last2 );\n    }\n    return ! result ;\n}\n\ntemplate < class BidirectionalIterator > bool next_combination ( BidirectionalIterator first , BidirectionalIterator middle , BidirectionalIterator last )\n{\n    return next_combination (first , middle , middle , last );\n}\n\n//????´?v??????r??????????????????????????????\nvoid func(vector<int> v, int r){\n    do{\n    }while(next_combination(v.begin(), v.begin() + r, v.end()));\n}\n\nint n;\n\nbool isOver(Circle a, Circle b){\n    return abs(a.c - b.c) < a.r + b.r;\n}\n\nvoid canUse(Circle c[30], vector<bool> used, int color[30], vector<int> res[4]){\n    //show(\"canUse\")\n    rep(i,n){\n        if(used[i]) continue;\n        bool f = true;\n        range(j,0,i){\n            if(used[j]) continue;\n            if(isOver(c[i], c[j])){\n                f = false;\n                break;\n            }\n        }\n        if(f) res[color[i] - 1].emplace_back(i);\n    }\n}\n\nvoid requireCircleSet(vector<int> circles, vector<vector<int>> &cs){\n    //show(\"requireCircleset\")\n    if(circles.size() < 2) return;\n    range(i,2,circles.size() + 1){\n        vector<int> tmp;\n        do{\n            for(auto i:circles) tmp.emplace_back(i);\n        }while(next_combination(circles.begin(), circles.begin() + i, circles.end()));\n        cs.emplace_back(tmp);\n    }\n}\n\nint ans;\n\nvoid dfs(Circle c[30], int color[30], vector<bool> used){\n    //show(\"dfs\");\n    vector<int> use[4];\n    canUse(c,used,color,use);\n    //rep(i,4){\n    //    if(use[i].empty()) continue;\n    //    show(use[i].size())\n    //}\n\n    bool f = true;\n    rep(i,4){\n        if(use[i].empty()) continue;\n        vector<vector<int>> circle_set;\n        requireCircleSet(use[i], circle_set);\n        if(circle_set.empty()) continue;\n        f = false;\n        for(auto j:circle_set){\n            vector<bool> tmp = used;\n            for(auto k:j){\n                assert(not tmp[k]);\n                tmp[k] = true;\n            }\n            dfs(c, color, tmp);\n        }\n    }\n\n    if(f){\n        int cnt = 0;\n        rep(i,n){ if(used[i]) cnt++; }\n        ans = max(ans, cnt);\n    }\n}\n\nint main(){\n    while(scanf(\"%d\",&n),n){\n        Circle c[30];\n        int color[30];\n        ans = 0;\n        rep(i,n){\n            double x,y,r;\n            scanf(\"%lf%lf%lf%d\",&x,&y,&r,&color[i]);\n            c[i] = {Point(x,y),r};\n        }\n        vector<bool> used(30,0);\n        dfs(c,color,used);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <iostream>\n\nusing namespace std;\n\nint pow2(int m){\n\treturn m * m;\n};\n\nint n, m, c[24], d, p[24];\n\nint bitnum(int n){\n\tint cnt;\n\tcnt = 0;\n\twhile(n){\n\t\tif(n % 2 == 1) cnt++;\n\t\tn /= 2;\n\t}\n\treturn cnt;\n}\n\nint main(void){\n\tint x[24], y[24], r[24], i, j, k, dp[1 << 24];\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n\t\tmemset(p,0,sizeof(p));\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < i;j++)\n\t\t\t\tif(sqrt((double)pow2(x[i] - x[j]) + pow2(y[i] - y[j])) < r[i] + r[j]) p[i] += 1 << j;\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0] = 1;\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i]){\n\t\t\t\tfor(j = 0;j < n - 1;j++){\n\t\t\t\t\tfor(k = j + 1;k < n;k++)\n\t\t\t\t\t\tif(c[j] == c[k] && ~i & (1 << j) && ~i & (1 << k) && (i & p[j]) == p[j] && (i & p[k]) == p[k]) dp[i + (1 << j) + (1 << k)] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tm = 0;\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i])\n\t\t\t\tm = max(m,bitnum(i))\n\t\t}\n\t\tprintf(\"%d\\n\",m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n \nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n \nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\n\n\nint n,d[30][30],abosum[30],ans;\nbool abo[30][30],exist[30];\n\nvoid solve(int tmpans,bool texist[30],int tabosum[30]){\n\tans = max(ans,tmpans);\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = i+1;j <= n;j++){\n\t\t\tif(texist[i] == false || texist[j] == false)continue;\n\t\t\tif(tabosum[i] != 0 || tabosum[j] != 0) continue;\n\t\t\tif(d[i][3] != d[j][3]) continue;\n\t\t\tbool tmpexist[30];\n\t\t\tfor(int k = 1;k <= n;k++){\n\t\t\t\ttmpexist[k] = texist[k];\n\t\t\t\tif(k == i || k == j) tmpexist[k] = false;\n\t\t\t}\n\t\t\tint tmpabosum[30];\n\t\t\tfor(int k = 1;k <= n;k++){\n\t\t\t\ttmpabosum[k] = tabosum[k];\n\t\t\t\tif( abo[i][k] == true && i < k )tmpabosum[k]--;\n\t\t\t\tif( abo[j][k] == true && j < k )tmpabosum[k]--;\n\t\t\t}\n\t\t\tsolve(tmpans+2,tmpexist,tmpabosum);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0)break;\n\t\tans = 0;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tabo[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\texist[i] = true;\n\t\t\tabosum[i] = 0;\n\t\t\tfor(int j = 0;j < 4;j++){\n\t\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\t\t//cin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = i+1;j <= n;j++){\n\t\t\t\tif(  (d[i][0]-d[j][0])*(d[i][0]-d[j][0]) + (d[i][1]-d[j][1])*(d[i][1]-d[j][1]) < (d[i][2]+d[j][2])*(d[i][2]+d[j][2])    ){\n\t\t\t\t\tabo[i][j] = true; abo[j][i] = true;\n\t\t\t\t\tabosum[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve(0,exist,abosum);\n\t//\tfor(int i = 1;i <= n;i++) cout << \"abo\" << i << \" \" << abosum[i] << endl;\n/*\n\t\tbool flag = true;\n\t\twhile(flag == true){\n\t\t\tflag = false;\n\t\t\tfor(int i = 1;i <= n;i++){\n\t\t\t\tfor(int j = i+1;j <= n;j++){\n\t\t\t\t\tif(exist[i] == false || exist[j] == false)continue;\n\t\t\t\t\tif(abosum[i] != 0 || abosum[j] != 0) continue;\n\t\t\t\t\tif(d[i][3] != d[j][3]) continue;\n\t\t\t\t\tans += 2;\n\t\t\t\t\texist[i] = false; exist[j] = false;\n\t\t\t\t\tflag = true;\n\t\t\t\t\tfor(int k = i+1;k <= n;k++){\n\t\t\t\t\t\tif(abo[i][k] == true){\n\t\t\t\t\t\t\tabosum[k]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = j+1;k <= n;k++){\n\t\t\t\t\t\tif(abo[j][k] == true){\n\t\t\t\t\t\t\tabosum[k]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint sum=0,ds;\nint n;\nvoid rec(vector<circle> vs){\n  //cout << vs.size() << endl;\n  int i,j,k;\n  int f;\n  int on[100]={};\n  vector<int> cc[10];\n  vector<circle> next;\n  \n  f=1;\n  int ff=0;\n  while(ff==0){\n    ff=1;\n    for(i=0;i<100;i++) on[i]=0;\n    for(i=0;i<10;i++) cc[i].clear();\n    for(i=0;i<vs.size();i++){\n      for(j=i+1;j<vs.size();j++){\n\tif(ch(vs[i],vs[j])==1) on[j]=1;\n      }\n    }\n    for(i=0;i<vs.size();i++){\n      if(on[i]==0) cc[vs[i].c].push_back(i);\n    }\n    for(i=1;i<5;i++){\n      if(cc[i].size()>0&&cc[i].size()%2==0){\n\tfor(j=cc[i].size()-1;j>=0;j--){\n\t  vs.erase(vs.begin()+cc[i][j]);\n\t  ff=0;\n\t}\n      }\n    }\n  }\n  for(i=1;i<5;i++){\n    //cout << cc[i].size() << endl;\n    if(cc[i].size()>=2&&cc[i].size()%2==1){\n      f=0;\n      next.clear();\n      for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n      for(j=0;j<cc[i].size();j++){\n\tfor(k=cc[i].size()-1;k>=0;k--){\n\t  if(k!=j)\n\t    next.erase(next.begin()+cc[i][k]);\n\t}\n\trec(next);\n      }\n      break;\n    }\n  }\n  int o=n-vs.size();\n  if(f==1) sum=max(sum,o);\n  else{\n    next.clear();\n    for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n    rec(next);\n  }\n}\n\nint main(){\n  cin >> n;\n  while(n!=0){\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    sum=0;\n    rec(v);\n    cout << sum << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <set>\n#include <sstream>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nbool ISINT(double x){return fabs(x-(int)x)<EPS;}\nbool ISEQ(double x,double y){return fabs(x-y)<EPS;}\nstring itos(ll x){stringstream ss;ss<<x;return ss.str();}\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define EREP(i,a,b) for(int i=a;i<=b;i++)\n#define erep(i,n) EREP(i,0,n)\n#define foreach(itr,c) for(__typeof(c.begin()) itr=c.begin();itr!=c.end();itr++)\n\nint n;\nint x[25],y[25],r[25],c[25];\nint b[25];\n\nbool intersects(int i,int j){\n  int dist1 = pow(x[i]-x[j],2) + pow(y[i]-y[j],2);\n  int dist2 = pow(r[i]+r[j],2);\n\n  return dist2 > dist1;\n}\n\nint dp[1<<25];\n\nint main(void){\n  while(scanf(\"%d\",&n),n){\n    rep(i,n){\n      scanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n\n      b[i] = 0;\n      rep(j,i) if(intersects(i,j)) b[i] |= (1<<j);\n    }\n\n    int ans = 0;\n    int to = (1<<n);\n    memset(dp,-1,sizeof(dp));\n    dp[0] = 0;\n\n    rep(i,to){\n      if(dp[i] == -1) continue;\n      ans = max(ans,dp[i]);\n      rep(j,n-1){\n        if((i & (1<<j)) != 0 || (i & b[j]) != b[j]) continue;\n        REP(k,j+1,n){\n          if(c[j] != c[k] || (i & (1<<k)) != 0 || (i & b[k]) != b[k]) continue;\n          int next = i | (1<<j) | (1<<k);\n          dp[next] = max(dp[next],dp[i]+2);\n        }\n      }\n    }\n\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Circle {\n    int x;\n    int y;\n    int r;\n    int c;\n};\n\nbool overwrap(const Circle& c1, const Circle& c2)\n{\n    const int d = c1.r + c2.r;\n    const int R = (c1.x - c2.x) * (c1.x - c2.x) + (c1.y - c2.y) * (c1.y - c2.y);\n    return d * d > R;\n}\n\nint n;\n//int dp(vector<int>& table, const vector<vector<bool>>& wrap, const int state, const vector<Circle>& circle)\nint dp(map<int, int>& table, const vector<vector<bool>>& wrap, const int state, const vector<Circle>& circle)\n{\n    if (table.find(state) != table.end()) {\n        return table[state];\n    } else {\n        vector<int> sub(4, 0);\n        vector<vector<int>> top(4, vector<int>(0));\n        for (int j = 0; j < n; j++) {\n            if (state & (1 << j)) {\n                bool ok = true;\n                for (int i = 0; i < j; i++) {\n                    if (state & (1 << i)) {\n                        if (wrap[i][j]) {\n                            ok = false;\n                            break;\n                        }\n                    }\n                }\n                if (ok) {\n                    sub[circle[j].c] += (1 << j);\n                    top[circle[j].c].push_back(j);\n                }\n            }\n        }\n        for (int i = 0; i < 4; i++) {\n            const int size = top[i].size();\n            if (size <= 1) {\n                continue;\n            }\n            if (size % 2 == 0) {\n                const int val = dp(table, wrap, state - sub[i], circle);\n                table[state] = val + size;\n                return val + size;\n            } else {\n                int maxi = 0;\n                for (int j = 0; j < size; j++) {\n                    const int val = dp(table, wrap, state - sub[i] + (1 << top[i][j]), circle);\n                    maxi = max(maxi, val);\n                }\n                table[state] = maxi + (size / 2 * 2);\n                return maxi + (size / 2 * 2);\n            }\n        }\n        table[state] = 0;\n        return 0;\n    }\n}\n\nint main()\n{\n    while (true) {\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        vector<Circle> circle(n);\n        for (int i = 0; i < n; i++) {\n            int x, y, r;\n            int c;\n            cin >> x >> y >> r >> c;\n            c--;\n            circle[i] = Circle{x, y, r, c};\n        }\n\n        vector<vector<bool>> wrap(n, vector<bool>(n, false));  // j?????????i?????????\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                wrap[i][j] = overwrap(circle[i], circle[j]);\n            }\n        }\n\n        const int maximum = 1 << n;\n        map<int, int> table;\n        // vector<int> table(maximum, -1);\n        table[0] = 0;\n        cout << dp(table, wrap, maximum - 1, circle) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 24\n\nint N,x[MAX],y[MAX],r[MAX],c[MAX];\n\nint dist(int a,int b){\n    return (x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]);\n}\n\nbool check(int a,int b){\n    int d = dist(a,b);\n    int add = r[a]+r[b],sub = r[a]-r[b];\n    return ((sub*sub < d && d < add*add) || d <= sub*sub);\n}\n\nint main(){\n    while(cin >> N, N){\n        for(int i = 0 ; i < N ; i++){\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n        int bit[MAX] = {0};\n        for(int i = 0 ; i < N ; i++){\n            for(int j = 0 ; j < i ; j++){\n                if(check(i,j)) bit[i] |= (1<<j);\n            }\n        }\n        vector<bool> dp(1<<N,0);\n        dp[(1<<N)-1] = 1;\n        int res = 0;\n        for(int i = (1<<N)-1 ; i >= 0 ; i--){\n            if(dp[i] == 0) continue;\n            if(N%2 == 0 && __builtin_popcount(i) % 2 == 1) continue;\n            if(N%2 == 1 && __builtin_popcount(i) % 2 == 0) continue;\n\t    int n = __builtin_popcount(i);\n            for(int j = 0 ; j < N ; j++){\n                if((i&bit[j]) > 0) continue;\n                for(int k = j+1 ; k < N ; k++){\n                    if(c[j] != c[k]) continue;\n                    if((i&bit[k]) > 0) continue;\n                    int S = i & ~((1<<j) | (1<<k));\n                    dp[S] = 1;\n                    res = max(res,N-n);\n                }\n            }\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\nint n, ans;\nvector<char> dp, up;\nvector<Circle> c;\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = (a.r + b.r) * (a.r + b.r);\n    int d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    return r > d;\n}\n\nchar Rec(char s)\n{\n    if (dp[s] != -1)\n        return dp[s];\n\n    int res = 0;\n    // 取り除く2つの円の選択\n    for (int i = 0; i < n; ++i) {\n        // c[i]がないか取り除けない\n        if (!(s >> i & 1) || s & up[i])\n            continue;\n\n        for (int j = i + 1; j < n; ++j) {\n            // c[i]とc[j]の色が異なる\n            if (c[i].c != c[j].c)\n                continue;\n            // c[j]がないか取り除けない\n            if (!(s >> j & 1) || s & up[j])\n                continue;\n\n            int nxt = s & ~(1 << i) & ~(1 << j);\n            res = max(res, (int)Rec(nxt) + 2);\n        }\n    }\n\n    ans = max(ans, res);\n\n    return dp[s] = res;\n}\n\nint main()\n{\n    while (cin >> n, n) {\n        dp.assign(1 << n, -1);\n        up.assign(n, 0);\n        c.resize(n);\n\n        // 円の入力\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        // 円の重なり，上下関係\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                if (isOverlap(c[i], c[j]))\n                    up[j] |= (1 << i);\n\n        ans = 0;\n        Rec((1 << n) - 1);\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint n;\nVI xs, ys, rs, cs;\n//VI memo;\nmap<int, int> memo;\nVI memo2;\nVVI grp;\n\nVVB nears;\n\nbool is_top(int i, int used) {\n\tfor (int j = i - 1; j >= 0; j--) {\n\t\tif (1 << j & used) continue;\n\n\t\tif (nears[i][j]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint dfs(int used) {\n\tint sum = 0;\n\n\tint flg = (n > 2 && (used < (1 << (n - 2)))) ? 1 : 0;\n\n\tif (flg  && memo2[used] != -1) return memo2[used];\n\tif (!flg && memo.count(used)) return memo[used];\n\n\tfor(int i = 0;i < n;i++) {\n\t\tfor (auto j : grp[cs[i]]) {\n\t\t\tif(i == j || (1 << i & used) || (1 << j & used)) continue;\n\t\t\tif(cs[i] != cs[j]) continue;\n\t\t\tif(!is_top(i, used) || !is_top(j, used)) continue;\n\n\t\t\tint used_tmp = used;\n\t\t\tused_tmp |= 1 << i;\n\t\t\tused_tmp |= 1 << j;\n\n\t\t\tsum = max(sum, dfs(used_tmp) + 2);\n\t\t}\n\t}\n\n\treturn (flg ? memo2[used] : memo[used]) = sum;\n//\treturn sum;\n}\n\nint main(void) {\n\twhile(cin >> n, n){\n\t\txs = VI(n);\n\t\tys = VI(n);\n\t\trs = VI(n);\n\t\tcs = VI(n);\n\n\t\tgrp = VVI(4);\n\t\tmemo.clear();\n\n\t\tif (n > 2) {\n\t\t\tmemo2 = VI(1 << (n - 2), -1);\n\t\t}\n\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n\t\t\tcs[i]--;\n\t\t\tgrp[cs[i]].push_back(i);\n\t\t}\n\n\t\tnears = VVB(n, VB(n));\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint x = (xs[i] - xs[j]) * (xs[i] - xs[j]);\n\t\t\t\tint y = (ys[i] - ys[j]) * (ys[i] - ys[j]);\n\t\t\t\tint dis = x + y;\n\t\t\t\tint dis2 = (rs[i] + rs[j]) * (rs[i] + rs[j]);\n\n\t\t\t\tnears[i][j] = dis < dis2;\n\t\t\t}\n\t\t}\n\n\t\tint used = 0;\n\t\tcout << dfs(used) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<map>\n#include<cmath>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 24;\nconst double eps = 1e-10;\ntypedef complex<double> P;\nclass st{\npublic:\n  P a;\n  double r;\n  int color;\n  int id;\n  bool operator<(const st & a)const{\n    if (color != a.color)return color < a.color;\n    return id < a.id;\n  }\n};\n\nint over[N];\n\nint is_intersected_circle(P a,P b,double r1,double r2){\n  double d=abs(a-b);\n  if (d < eps && abs(r1-r2) < eps)return 3;\n  if (d+r2 < r1)return 0;\n  if (d+r1 < r2)return 1;\n  if (d > r1+r2) return 4;\n  if (abs((r1+r2)-d) < eps)return 4;\n  return 2;\n}\n\nvector<int> edge[N];\nint dp[(1<<N)];\nint colorstart[5];\n\nint search(int state,st *in,int n){\n  if (state == (1<<n))return 0;\n  int &ret = dp[state];\n  if (ret == -1){\n    ret=0;\n    //color1\n    rep(k,4){\n      REP(i,colorstart[k],colorstart[k+1]){\n        int now=in[i].id;\n        if (((1<<now)&state) != 0)continue;\n        if ((over[now]&state) == over[now]);\n        else continue;\n        REP(j,i+1,colorstart[k+1]){\n          int next=in[j].id;\n          if (((1<<next)&state) != 0)continue;\n          if ((over[next]&state) == over[next]);\n          else continue;\n          //cout <<\"remove \" << now <<\" \" << next << endl;\n          ret=max(ret,2+search(state|(1<<now)|(1<<next),in,n));\n        }\n      }\n    }\n  }\n  return ret;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    rep(i,(1<<n))dp[i]=-1;\n    rep(i,n)edge[i].clear();\n    st in[n];\n    rep(i,n){\n      cin>>in[i].a.real()>>in[i].a.imag()>>in[i].r>>in[i].color;\n      in[i].id=i;\n    }\n    sort(in,in+n);\n    rep(i,n){\n      rep(j,n){\n        if (in[i].id <= in[j].id)continue;\n        int tmp=is_intersected_circle(in[i].a,in[j].a,in[i].r,in[j].r);\n        if (tmp == 0 || tmp == 1 || tmp == 2 || tmp == 3){\n          edge[in[i].id].push_back(in[j].id);\n        }\n      }\n    }\n\n    rep(i,n){\n      int now=in[i].id;\n      over[now]=0;\n      rep(j,edge[now].size()){\n        int next=edge[now][j];\n        over[now]|=(1<<next);\n        //cout <<next << \" is over \" << now << endl;\n      }\n      //cout << now <<\" hoge \" << over[now] << endl;\n    }\n    rep(i,5)colorstart[i]=n;\n    rep(i,n){\n      colorstart[in[i].color-1]=min(colorstart[in[i].color-1],i);\n    }\n\n    //rep(i,5)cout << colorstart[i] << \" \";cout << endl;\n    cout << search(0,in,n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#define DEBUG false\n\nusing namespace std;\n#define UI unsigned int\n\nstruct P {\n  //  complex<int> p;\n  complex<double> p;\n  int r,c;\n  bool f; // ±Ì~ÕªêÔãÌê\n};\n\nbool isPile( P p, P q ){ // pÆqªdÈÁÄ¢éêtrue\n  return ( abs(p.p-q.p) < p.r+q.r );\n}\nvoid pr( P p ){\n  cout << p.p << \" \"<<p.r<<\" \"<<p.c<<\" \" ;\n  if( p.f ) cout << \"true\" << endl;\n  else      cout << \"false\"<< endl;\n}\n\nint main(){\n  int n;\n  vector<P> v,w;\n  stack< vector<P> > st;\n  P p,q;\n\n  while( cin>>n && n ){\n    if( DEBUG )\n      cout << \"n=\" << n << \" ************************\" <<endl;\n    v.clear();\n    for( int i=0;i<n;i++ ){\n      cin >> p.p.real() >> p.p.imag() >> p.r >> p.c;\n      p.f = true;\n      v.push_back( p );\n    }\n    for( UI i=0;i<v.size();i++ )\n      for( UI j=i+1;j<v.size();j++ )\n\tif( isPile( v[i],v[j] ) ) v[j].f=false;\n\n    while( !st.empty() ) st.pop();\n    st.push( v );\n    int mn = n; // Å¬Ì~Õ\n    bool f;\n    while( !st.empty() ){\n      v = st.top(); st.pop();\n      f = true;\n      for( UI i=0;i<v.size();i++ ){\n\tif( !v[i].f ) continue;\n\tfor( UI j=i+1;j<v.size();j++ ){\n\t  if( !v[j].f ) continue;\n\t  if( v[i].c!=v[j].c ) continue;\n\n\t  // v[i],v[j] ª~ÕÌgbv( p.f=false )Ìê\n\t  w = v;\n\t  if( DEBUG ){\n\t    cout << \"erase : \"; pr( v[i] );\n\t    cout << \"erase : \"; pr( v[j] );\n\t  }\n\t  w.erase( w.begin()+j );\n\t  w.erase( w.begin()+i );\n\n\t  for( UI k=i;k<w.size();k++ ) w[k].f = true;\n\t  for( UI k=0;k<w.size();k++ )\n\t    for( UI l=k+1;l<w.size();l++ )\n\t      if( isPile( w[k],w[l] ) ) w[l].f = false;\n\t  st.push( w ); f=false;\n\t}\n      }\n      if( f ){\n\tmn = min( mn,(int)v.size() );\n\tif( DEBUG ){\n\t  cout << \"mn=\" << mn << endl;\n\t  for( UI i=0;i<v.size();i++ ){\n\t    cout << i <<\"\\t\"; pr( v[i] );\n\t  }\n\t}\n      }\n    }\n    cout << n-mn << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#define x first.first\n#define y first.second\n#define r second.first\n#define color second.second\n \nusing namespace std;\n \ntypedef pair<double,double> P;\ntypedef pair<P,P> C;\n \nconst double EPS = 1e-10;\n \ndouble dist(C a,C b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n \nbool check(C a,C b){\n  return a.r+b.r-dist(a,b)>EPS;\n}\n \nint count(int bits){\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits =(((bits >> 4) + bits) & 0x0f0f0f0f);\n  bits += bits >> 8;\n  return (bits + (bits >> 16)) & 0xff;\n}\n \nbool dp[(1<<25)];\n \nint main(void){\n \n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<C>c(n);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin >> c[i].x >> c[i].y >> c[i].r >> c[i].color;\n     \n\t\tfill(dp,dp+(1<<n),false);\n\t\tdp[(1<<n)-1]=true;\n     \n\t\tfor(int S=(1<<n)-1;S>=0;S--){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\t\n\t\t\t\t\tif(c[i].color!=c[j].color)continue;\n       \n\t\t\t\t\tbool fg=false;\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(!(S>>k&1))continue;\n\t\t\t\t\t\tfg|= k<i && check(c[i],c[k]);\n\t\t\t\t\t\tfg|= k<j && check(c[j],c[k]);\n\t\t\t\t\t\tif(fg)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(fg)continue;\n\t\t\t\t\t\n\t\t\t\t\tint nx=S;\n\t\t\t\t\tnx&=~(1<<i);\n\t\t\t\t\tnx&=~(1<<j);\n\t\t\t\t\tdp[nx]|=dp[S];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tif(dp[i]){\n\t\t\t\tcout << n-count(i) << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse if (dis < eps) {\n\t\tconst ld ar = min(l.r, r.r);\n\t\treturn ar*ar*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\nvector<Circle>cs;\nvector<int>colors;\n\nint getans(const vector<vector<int>>&edges, vector<int>&nums,vector<int>&used) {\n\tvector<vector<int>>colorids(4);\n\tfor (int i = 0; i < used.size(); ++i) {\n\t\tif (!used[i]) {\n\t\t\tif (!nums[i]) {\n\t\t\t\tcolorids[colors[i]].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tfor (int a = 0; a < colorids[i].size(); ++a) {\n\t\t\tint aid = colorids[i][a];\n\t\t\tfor (int b = a + 1; b < colorids[i].size(); ++b) {\n\t\t\t\tconst int bid = colorids[i][b];\n\t\t\t\tused[aid] = true;\n\t\t\t\tused[bid] = true;\n\t\t\t\tfor (auto e : edges[aid]) {\n\t\t\t\t\tnums[e]--;\n\t\t\t\t}\n\t\t\t\tfor (auto e : edges[bid]) {\n\t\t\t\t\tnums[e]--;\n\t\t\t\t}\n\t\t\t\tans = max(ans,2 + getans(edges, nums, used));\n\t\t\t\tused[aid] = false;\n\t\t\t\tused[bid] = false;\n\t\t\t\tfor (auto e : edges[aid]) {\n\t\t\t\t\tnums[e]++;\n\t\t\t\t}\n\t\t\t\tfor (auto e : edges[bid]) {\n\t\t\t\t\tnums[e]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tcs.clear();\n\t\tcolors.clear();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y, r, c; cin >> x >> y >> r >> c;\n\t\t\tc--;\n\t\t\tcs.emplace_back(Point(x, y), r);\n\t\t\tcolors.push_back(c);\n\t\t}\n\t\tvector<vector<int>>edges(N);\n\t\tvector<int>nums(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tif (two_circle_area(cs[i],cs[j])>eps) {\n\t\t\t\t\tedges[i].push_back(j);\n\t\t\t\t\tnums[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>used(N, false);\n\t\tint ans = getans(edges, nums, used);\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i =0;i<n;++i)\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n#define FOR(it,a ) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntypedef pair<int,int> PI;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\n\nint n;\n\nint x[30];\nint y[30];\nint r[30];\nint c[30];\n\nbool ok[1<<24];\n\nint st[24];\n\nint overlap(int a,int b){\n  int dx=x[a]-x[b];\n  int dy=y[a]-y[b];\n  \n  if(dx*dx+dy*dy < (r[a]+r[b])*(r[a]+r[b]))\n    return 1;\n  return 0;\n}\n\nint ans;\n\nvoid dfs(int cst){\n  if(ok[cst]) return;\n  ok[cst] =  1;\n  ans = max(ans, __builtin_popcount(cst));\n  \n  rep(i,n)if(~cst&(1<<i)) if((cst&st[i]) == st[i])rep(j,i){\n    if(c[i] != c[j]) continue;\n    if(cst&(1<<j)) continue;\n    if(overlap(i,j)) continue;\n    if((cst&st[j]) != st[j]) continue;\n    dfs(cst | (1<<i)|(1<<j));\n  }\n}\n\nvoid solve(){\n  rep(i,n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n  memset(ok,0,sizeof(ok));\n  ans = 0;\n  memset(st,0,sizeof(st));\n  rep(i,n)rep(j,i){\n    //cout << i << \" \" << j << \" \" << overlap(i,j) << endl;\n    st[i] |= overlap(i,j) << j;\n  }\n  \n  rep(i,n)rep(j,i)\n    if(c[i]==c[j] && !overlap(i,j) && st[i]==0 && st[j]==0)\n      dfs((1<<i)|(1<<j));\n    \n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> n,n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n;i++){\n        if(((bit>>i)&1)==0||ok(i,bit)==false)continue;\n        for(int j=i+1;j<n;j++){\n            if(((bit>>j)&1)==0||c[i]!=c[j])continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(ok(j,bit)&&!memo[to_bit]){\n                ret=max(ret,dfs(to_bit));\n            }\n        }\n    }\n\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\n\n\nint main(){\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nchar dp[1<<24];\nint n, x[25], y[25], r[25], c[25], up[25];\n\nint main(){\n\tint i, j,k, ans;\n\twhile(1){\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tans = 0;\n\t\tfor(i=0;i<(1<<n);i++) dp[i]=0;\n\t\tfor(i=0;i<24;i++) up[i] = 0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tcin >> x[j] >> y[j] >> r[j] >> c[j];\n\t\t}\n\t\tfor(i=0;i<n-1;i++){\n\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\tif(pow(x[i]-x[j],2)+pow(y[i]-y[j],2) < pow(r[i]+r[j],2)){\n\t\t\t\t\tup[j] += 1<<i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<(1<<n);i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tif((i&(1<<j))==0||(up[j]&i)) continue;\n\t\t\t\tfor(k=j+1;k<n;k++){\n\t\t\t\t\tif((i&(1<<k))&&((up[k]&i)==0)&&(c[j]==c[k])){\n\t\t\t\t\t\tint yy = i - (1<<j) - (1<<k);\n\t\t\t\t\t\tdp[i] = max((int)dp[yy]+2,(int)dp[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",dp[(1<<n)-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct state{\n    int x,y,r,c;\n};\n\nbool check(int x1,int y1,int r1,int x2,int y2,int r2){\n    if((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2) >= (r1+r2)*(r1+r2)){\n        return 0;\n    }\n    else return 1;\n}\n\nint memo[1<<24];\n\nint dp(vector<state>&v,int now){\n    if(memo[now]!=-1)return memo[now];\n    vector<int>ue(v.size(),0);\n    for(int i=0;i<v.size();++i){\n        if(!((now>>i)&1))continue;\n        for(int j=0;j<i;++j){\n            if(!((now>>j)&1))continue;\n            if(check(v[i].x,v[i].y,v[i].r,v[j].x,v[j].y,v[j].r)){\n                ue[i]++;\n            }\n        }\n    }\n    int ret=0;\n    for(int i=0;i<v.size();++i){\n        for(int j=i+1;j<v.size();++j){\n            if((now>>i)&1 && (now>>j)&1){\n                if(ue[i]==0 && ue[j]==0){\n                    if(v[i].c != v[j].c)continue;\n                    ret=max(ret,dp(v,now-((1<<i)+(1<<j)))+2);\n                }\n            }\n        }\n    }\n    return memo[now]=ret;\n}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        for(int i=0;i<(1<<24);++i){\n            memo[i]=-1;\n        }\n        vector<state>v(n);\n        for(int i=0;i<n;++i){\n            int x,y,r,c;\n            cin>>x>>y>>r>>c;\n            v[i]={x,y,r,c};\n        }\n        cout<<dp(v,(1 << n)-1)<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstruct po {int x,y,r,g;};\nstruct popo{vector <po> c[5];};\nint ans =0;\n\nbool check(po a,popo c){\n  if(a.g==10000)return false;\n  for(int i=0;i<4;i++)\n    for(int j=0;j<c.c[i].size();j++){\n      po b = c.c[i][j];\n      if(a.g>b.g && (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y) < (a.r+b.r)*(a.r+b.r)) return false;\n    }\n  return true;\n}\n\nint cnt;\nvoid saiki(popo c,int sum,int i){\n  cnt++;\n  if(cnt>6000000/2)return;\n  vector <int> J;\n  for(int j=0;j<(int)c.c[i].size();j++)if(check(c.c[i][j],c)==true)J.push_back(j);\n  for(int j=0;j<J.size();j++)\n    for(int k=j+1;k<J.size();k++){\n      int a,b;\n      a=c.c[i][J[j]].g;\n      b=c.c[i][J[k]].g;\n      c.c[i][J[j]].g = c.c[i][J[k]].g = 10000;\n      for(int l=0;l<4;l++)saiki(c,sum+2,l);\n      c.c[i][J[j]].g=a;\n      c.c[i][J[k]].g=b;\n    }\n  ans = max(ans,sum);\n}\n\nint main(){\n  while(1){\n    int n;\n    cin>>n;\n    if(n==0)break;\n    popo c;\n    int x,y,r,col;\n    for(int i=0;i<n;i++)cin >>x>>y>>r>>col, c.c[--col].push_back((po){x,y,r,i});\n    ans = 0;\n    cnt=0;\n    for(int i=0;i<4;i++)saiki(c,0,i);\n    cout << ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\n\nint n;\nint x[256], y[256], r[256], c[256];\nbool removed[256];\nbool on(int i, int j)\n{\n\tint dx = x[i] - x[j], dy = y[i] - y[j];\n\tint t = r[i] + r[j];\n\treturn dx * dx + dy * dy < t * t;\n}\nint dfs()\n{\n\tvector<int> cand[4];\n\tfor (;;)\n\t{\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t\tcand[i].clear();\n\n\t\tbool top[256];\n\t\tfill(top, top + n, true);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif (removed[i])\n\t\t\t\tcontinue;\n\t\t\tif (top[i])\n\t\t\t\tcand[c[i]].push_back(i);\n\n\t\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\t\tif (on(i, j))\n\t\t\t\t\ttop[j] = false;\n\t\t}\n\n\t\tbool any_rem = false;\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tif (!cand[i].empty() && cand[i].size() % 2 == 0)\n\t\t\t{\n\t\t\t\tforeach (it, cand[i])\n\t\t\t\t\tremoved[*it] = true;\n\t\t\t\tany_rem = true;\n\t\t\t\tcand[i].clear();\n\t\t\t}\n\t\t\telse if (cand[i].size() == 1)\n\t\t\t\tcand[i].clear();\n\t\t}\n\t\tif (!any_rem)\n\t\t\tbreak;\n\t}\n\n\tint res = count(removed, removed + n, true);\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tif (!cand[i].empty())\n\t\t{\n\t\t\tfor (int left = 0; left < cand[i].size(); ++left)\n\t\t\t{\n\t\t\t\tbool cp[256];\n\t\t\t\tcopy(removed, removed + n, cp);\n\n\t\t\t\tfor (int j = 0; j < cand[i].size(); ++j)\n\t\t\t\t\tif (j != left)\n\t\t\t\t\t\tremoved[j] = true;\n\t\t\t\tmax_swap(res, dfs());\n\n\t\t\t\tcopy(cp, cp + n, removed);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> n, n)\n\t{\n\t\trep (i, n)\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i], --c[i];\n\t\tfill(removed, removed + n, false);\n\t\tcout << dfs() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define REP(i,a) rep((i),0,(a))\nusing namespace std;\n//global\n\nstruct Data{\n\tint x, y,r;\n\tint c;\n};\nData data[24];\nbool dp[1024 * 1024 * 16];\nint min_num;\nint N;\nbool double_check(int i, int j){\n\tint dx, dy, dr;\n\tdx = data[j].x - data[i].x;\n\tdy = data[j].y - data[i].y;\n\tdr = data[j].r + data[i].r;\n\t//printf(\"[%d,%d]%d,%d,%d\\n\", i, j, dx, dy, dr);\n\tif ((dx*dx + dy*dy)<(dr*dr))return(true);\n\telse return(false);\n}\n\nvoid printbit(int x){\n\tREP(i, N){\n\t\tif ((x >> (N - i-1)) & 1)cout << 1;\n\t\telse cout<<0;\n\t}\n\tcout << endl;\n\n\n}\nvoid solve(int num, int rest){\n\t//cout << rest<<endl;\n\t//printbit(rest);\n\tif (min_num > num)min_num = num;\n\tif (num <= 1)return;\n\tif (dp[rest])return;\n\n\tint color[4] = { 0 }, index[4] = { 0 };\n\tREP(i, N){\n\t\tint bit = (1 << i);\n\t\tif ((rest&bit) > 0){\n\t\t\tbool f = true;\n\t\t\trep(j,0,i)if((rest&(1<<j))>0)\n\t\t\tif (double_check(i, j)){\n\t\t\t\tf = false; continue;\n\t\t\t}\n\t\t\tif (f){\n\t\t\t\tcolor[data[i].c] += bit;\n\t\t\t\tindex[data[i].c]++;\n\t\t\t}\n\t\t}\n\t}\n\t//rep(i, 0, 4){printf(\"%d,\",index[i]);printbit(color[i]);}\n\trep(i, 0, 4)\n\tif (index[i]>=2)\n\tif (!(index[i] & 1)){\n\t\tsolve(num - index[i], rest - color[i]);\n\t}\n\telse{\n\t\tint p = 1;\n\t\trep(j, 0, index[j]){\n\t\t\twhile (!(p & 1))p <<= 1;\n\t\t\tsolve(num - index[i] + 1, rest - color[i] + p);\n\n\t\t}\n\n\n\n\t}\n\n\n}\n\n\n\nint main(void){\n\twhile (true){\n\t\tcin >> N;\n\t\tif (N == 0)return(0);\n\t\tmin_num = N;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tREP(i, N){\n\t\t\tcin >> data[i].x >> data[i].y >> data[i].r>>data[i].c;\n\t\t\tdata[i].c--;\n\t\t}\n\t\tsolve(N, (1 << N) - 1);\n\t\tcout << N - min_num << endl;\n\t}}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct circle{\n  double x, y, r;\n  int c;\n  unordered_set<int> up, down;\n};\n \nvoid calcOverlap(int n, circle *disk){\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      double x = disk[i].x - disk[j].x,\n        y = disk[i].y - disk[j].y;\n      if(sqrt(x*x + y*y) + 1e-8< disk[i].r + disk[j].r){\n        disk[j].up.insert(i);\n        disk[i].down.insert(j);\n      }\n    }\n  }\n}\n \nbool canRemove(circle d, circle dd){\n  if(d.c != dd.c)return false;\n  return d.up.empty() and dd.up.empty();\n}\n \nint dfs(int n, circle *disk, bool *removed, int dep = 0){\n  int res = 0;\n  bool f = false;\n  for (int i = 0; i < n; i++) {\n    if(removed[i] == true)continue;\n    for (int j = i + 1; j < n; j++) {\n      if(removed[j] == true)continue;\n      if(not canRemove(disk[i], disk[j]))continue;\n      f = true;\n      removed[i] = true;\n      removed[j] = true;\n      vector<int> erase_i, erase_j;\n      for (int k = 0; k < n; k++) {\n        if(disk[k].up.find(i) != disk[k].up.end()){\n          disk[k].up.erase(i);\n          erase_i.push_back(k);\n        }\n        if(disk[k].up.find(j) != disk[k].up.end()){\n          disk[k].up.erase(j);\n          erase_j.push_back(j);\n        }\n      }\n      res = max(res, dfs(n, disk, removed, dep + 1));\n      for (int k = 0; k < erase_j.size(); k++) {\n        disk[erase_j[k]].up.insert(j);\n      }\n      for (int k = 0; k < erase_i.size(); k++) {\n        disk[erase_i[k]].up.insert(i);\n      }\n      removed[i] = false;\n      removed[j] = false;\n    }\n  }\n  return f?res:dep;\n}\n \nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n, n){\n    circle disk[n];\n    for (int i = 0; i < n; i++) {\n      cin >> disk[i].x >> disk[i].y >> disk[i].r >> disk[i].c;\n    }\n    bool removed[n];\n    memset(removed, false, sizeof(removed));\n    calcOverlap(n, disk);\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        if(not canRemove(disk[i], disk[j]))continue;\n        if(not disk[i].down.empty() or\n           not disk[j].down.empty())continue;\n        removed[i] = true;\n        removed[j] = true;\n        ans++;\n      }\n    }\n    std::cout << 2*(ans + dfs(n, disk, removed)) << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\nusing namespace std;\n\nstruct object{\n\tint id;\n\tint posx;\n\tint posy;\n\tint rad;\n\tint color;\n\tlist<int> parent;\n};\n\nvoid checkcontact(object& upper,object& lower){\n\tif((upper.posx-lower.posx)*(upper.posx-lower.posx)+(upper.posy-lower.posy)*(upper.posy-lower.posy)<(upper.rad+lower.rad)*(upper.rad+lower.rad)){\n\t\tlower.parent.push_back(upper.id);\n\t}\n}\n\nint main(){\n\tint n;\n\tobject tmp; \n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tlist<object> objects;\n\t\tlist<object>::iterator ita,itb,itc,last;\n\t\tbool suc=true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp.id=i;\n\t\t\tcin>>tmp.posx>>tmp.posy>>tmp.rad>>tmp.color;\n\t\t\ttmp.parent.clear();\n\t\t\tlast=objects.end();\n\t\t\tfor(ita=objects.begin();ita!=last;++ita)checkcontact(*ita,tmp);\n\t\t\tobjects.push_back(tmp);\n\t\t}\n\t\twhile(suc){\n\t\t\tsuc=false;\n\t\t\tlast=objects.end();\n\t\t\tfor(ita=objects.begin();ita!=last;++ita){\n\t\t\t\tif((*ita).parent.empty()){\n\t\t\t\t\tfor(itb=objects.begin();itb!=last;++itb){\n\t\t\t\t\t\tif((*itb).color==(*ita).color&&(*itb).parent.empty()&&ita!=itb){\n\t\t\t\t\t\t\tfor(itc=objects.begin();itc!=last;++itc){\n\t\t\t\t\t\t\t\t(*itc).parent.remove((*ita).id);\n\t\t\t\t\t\t\t\t(*itc).parent.remove((*ita).id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tobjects.erase(ita);\n\t\t\t\t\t\t\tobjects.erase(itb);\n\t\t\t\t\t\t\tsuc=true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tif(suc)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif(suc)break;\n\t\t\t}\n\t\t}\n\t\tcout<<n-objects.size()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cinttypes>\n#include <cstring>\n\nusing namespace std;\n\nint n;\nvector<int16_t> x, y, r, c;\nint8_t memo[1 << 24];\n\nint rec(int bits) {\n  int ret = 0;\n  if (memo[bits] != 0) {\n    return memo[bits];\n  }\n  vector<bool> tops(n, true);\n  for (int i = 0; i < n; i++) {\n    if (bits & (1 << i)) {\n      continue;\n    }\n    for (int j = i + 1; j < n; j++) {\n      if (bits & (1 << j)) {\n        continue;\n      }\n      int distance2 = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n      if (distance2 < (r[i] + r[j]) * (r[i] + r[j])) {\n        tops[j] = false;\n      }\n    }\n  }\n\n  for (int i = 0; i < n; i++) {\n    if (bits & (1 << i)) {\n      continue;\n    }\n    if (!tops[i]) {\n      continue;\n    }\n    for (int j = i + 1; j < n; j++) {\n      if (bits & (1 << j)) {\n        continue;\n      }\n      if (!tops[j]) {\n        continue;\n      }\n      if (c[i] != c[j]) {\n        continue;\n      }\n      int r = 2 + rec(bits | (1 << i) | (1 << j));\n      if (r > ret) {\n        ret = r;\n      }\n    }\n  }\n\n  return memo[bits] = ret;\n}\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n    x.resize(n);\n    y.resize(n);\n    r.resize(n);\n\n    c.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n\n    memset(memo, 0, sizeof(memo));\n    cout << rec(0) << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct C {\n  int x, y, r, c;\n};\n\nint n;\nC c[24];\nint on[24];\nint T[1<<24];\n\nint isIntersect(C &a, C &b) {\n  int d1 = a.x - b.x;\n  int d2 = a.y - b.y;\n  int d3 = a.r + b.r;\n  if(d1*d1 + d2*d2 < d3*d3) return 2;\n  //if(d1*d1 + d2*d2 == d3*d3) return 1;\n  return 0;\n}\n\nint make() {\n  fill(on, on+n, 0);\n  for(int i = 0; i < n; ++i) {\n    for(int j = i+1; j < n; ++j) {\n      if(isIntersect(c[i], c[j])) {\n\ton[j] |= (1<<i);\n      }\n    }\n  }\n}\n\nint rec(int S) {\n  if(T[S] != -1) return T[S];\n  int res = 0;\n  for(int i = 0; i < n; ++i) {\n    if(S & (1<<i)) continue;\n    if(on[i] & S != on[i]) continue;\n    for(int j = i+1; j < n; ++j) {\n      if(S & (1<<j)) continue;\n      if(on[j] & S != on[j]) continue;\n      if(c[i].c != c[j].c) continue;\n      int nS = S;\n      nS |= (1<<i);\n      nS |= (1<<j);\n      res = max(res, rec(nS) + 2);\n    }\n  }\n  return T[S] = res;\n}\n\nconst int INF = (1<<24);\n\nint solve() {\n  make();\n  fill(T, T+(1<<n), -1);\n  for(int S = (1<<n)-1; S >= 0; --S) {\n    T[S] = 0;\n    for(int i = 0; i < n; ++i) {\n      if(S & (1<<i)) continue;\n      if(on[i] & S != on[i]) continue;\n      for(int j = i+1; j < n; ++j) {\n\tif(S & (1<<j)) continue;\n\tif(on[j] & S != on[j]) continue;\n\tif(c[i].c != c[j].c) continue;\n\tint nS = S;\n\tnS |= (1<<i);\n\tnS |= (1<<j);\n\tT[S] = max(T[S], T[nS] + 2);\n      }\n    }\n  }\n  return T[0];\n}\n\n\n\nint main() {\n  while((cin >> n) && n) {\n    for(int i = 0; i < n; ++i) {\n      cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n    }\n\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//線分を表す構造体\nstruct Segment{ Point p1, p2; };\n//直線を表す構造体\ntypedef Segment Line;\n//多角形を表す構造体\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// 許容する誤差\n#define EPS (1e-10)\n\n// ベクトルaの絶対値を求める\n//double length = abs(a);\n\n// 2点a,b間の距離を求める\n//double distance = abs(a-b);\n\n/*\n// ベクトルaの単位ベクトルを求める\nPoint b = a / abs(a);\n\n// ベクトルaの法線ベクトルn1,n2を求める\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 点cが直線a,b上にあるかないか\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// 点a,bを通る直線と点cとの距離\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// 線分s1と線分s2の距離\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// 線分sに対する点pの射影\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//線分sを対象軸とした点pの線対称の点\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//点pをangle分だけ時計回りに回転\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//円cと線分lの交点\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//点の内包\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//ベクトルの位置検出\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//凸包\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISEだと内角は180以下（一直線上に並んでいても、頂点として数える）\n        //!= CLOCKWISEだと内角は180未満（一直線上の頂点は数えない）\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //ここも == と != を変更する\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //最も下にある点の中で最も右にある点から反時計回りに並び替え\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//キャリパー法を用いて凸多角形の直径を求める\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//凸多角形の切り取りに使う関数。これがなんなのかはまだ知らない。\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//三角形の面積\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//多角形の面積\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//凸多角形かどうかの判定\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//凹多角形を線分lで切断した際の多角形の数\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\n//i番目を0にする\nint clearBit(int num, int i){\n\tint mask = ~(1 << i);\n\treturn num & mask;\n}\n\n//i番目をvで置き換える\nint updateBit(int num, int i, int v){\n\tint mask = ~(1 << i);\n\treturn (num & mask) | (v << i);\n}\n\nint n, ans;\n\nbool isOver(Circle a, Circle b){\n\tpair<Point,Point> tmp = getCrossPoints(a,b);\n    return isnan(tmp.first.imag());\n}\n\nvoid dfs(vector<vector<int>>& g, int cur, vector<int>& on){\n\tfor(auto to : g[cur]){\n\t\ton[to] = on[to] bitor (1 << cur) bitor on[cur];\n\t\tdfs(g, to, on);\n\t}\n}\n\nvector<bool> memo;\nvoid dfs(int s, vector<int>& on, vector<int> c){\n\tif(memo[s]) return;\n\n\tvector<vector<int>> canTake(4);\n\trep(i,n){\n\t\tif(getBit(s,i)) continue;\n\t\tif((on[i] bitand s) == on[i]){\n\t\t\tcanTake[c[i]].emplace_back(i);\n\t\t}\n\t}\n\n\tvector<int> take(4,0);\n\trep(i,4){\n\t\tfor(auto j : canTake[i]){\n\t\t\ttake[i] = setBit(take[i], j);\n\t\t}\n\t}\n\n\trep(i,4){\n\t\tif(canTake[i].size() >= 2){\n\t\t\tif(canTake[i].size() % 2 == 1){\n\t\t\t\trep(j,canTake[i].size()){\n\t\t\t\t\tdfs(s bitor clearBit(take[i], j), on, c);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdfs(s bitor take[i], on, c);\n\t\t\t}\n\t\t}\n\t}\n\n\tbitset<30> bit(s);\n\tans = max<int>(ans, bit.count());\n\tmemo[s] = true;\n}\n\nint main(){\n    while(scanf(\"%d\",&n),n){\n        vector<Circle> c(n);\n        vector<int> color(n);\n        rep(i,n){\n            double x,y,r;\n            scanf(\"%lf%lf%lf%d\",&x,&y,&r,&color[i]);\n\t\t\tcolor[i]--;\n            c[i] = {Point(x,y),r};\n        }\n\n\t\tvector<vector<int>> g(n);\n\t\tvector<bool> top(n,1);\n\t\trep(i,n){\n\t\t\trange(j,i + 1,n){\n\t\t\t\tif(isOver(c[i], c[j])){\n\t\t\t\t\tg[i].emplace_back(j);\n\t\t\t\t\ttop[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> on(n,0);\n\t\trep(i,n){\n\t\t\tif(not top[i]) continue;\n\t\t\tdfs(g, i, on);\n\t\t}\n\t\t//rep(i,n) show(on[i])\n\n\t\tans = 0;\n\t\tmemo = vector<bool>(1 << n, 0);\n\t\tdfs(0, on, color);\n\t\tcout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\ntypedef pair < int , int > Pt;\nint dp[1 << 24];\nPt pts[24];\nint n, r[24], c[24];\n\nbool intersect( Pt a, Pt b, int r1, int r2){\n  return pow( a.first - b.first, 2) + pow( a.second - b.second, 2) < pow( r1 + r2, 2);\n}\n\nint isnocover( const int& bit, const int& idx ){\n  for(int i = 0 ; i < idx ; i++ ){\n    if( (bit >> i) & 1 && intersect( pts[i], pts[idx], r[i], r[idx])) return false;\n  }\n  return true;\n}\n\nint rec( int bit){\n  if(~dp[bit]) return dp[bit];\n\n  int ret = 0;\n  for(int i = 0 ; i < n ; i++ ){\n    if((bit >> i) & 1){\n      for(int j = i + 1 ; j < n ; j++ ){\n        if( (bit >> j) & 1 && c[i] == c[j] && isnocover( bit, i) && isnocover( bit, j)){\n          ret = max( ret, rec( bit & ~(1 << i) & ~(1 << j)) + 2);\n        }\n      }\n    }\n  }\n  return dp[bit] = ret;\n}\nint main()\n{\n  while(cin >> n, n){\n    fill_n( dp, 1 << 24 , -1);\n    for(int i = 0 ; i < n ; i++ ){\n      cin >> pts[i].first >> pts[i].second >> r[i] >> c[i];\n    }\n    cout << rec((1 << n) - 1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\nusing namespace std;\n\n#define x real()\n#define y imag()\n#define pb push_back \ntypedef double D;\ntypedef complex<D> P;\ntypedef struct circle{\n\tP p;\n\tD r;\n} C;\n\nbool rel[24][24];\nC c[24];\nvector<int> color[4];\nbool used[1<<24];\nint cmax;\n\nbool IC(C a,C b){\n\tD d=norm(a.p-b.p);\n\tD r=(a.r+b.r)*(a.r+b.r);\n\treturn d<r;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n, n){\n\t\tcmax=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\twhile(!color[i].empty())\n\t\t\t\tcolor[i].pop_back();\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tmp;\n\t\t\tcin >> c[i].p.x >> c[i].p.y >> c[i].r;\n\t\t\tcin >> tmp;\n\t\t\tcolor[tmp-1].pb(i);\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(i==j)\n\t\t\t\t\tcontinue;\n\t\t\t\trel[i][j]=IC(c[i],c[j]);\n\t\t\t}\n\t\t}\n\t\tused[0]=true;\n\t\tfor(int u=0;u<(1<<n);u++){\n\t\t\tif(!used[u])\n\t\t\t\tcontinue;\n\t\t\tint res=0;\n\t\t\tint tmp=u;\n\t\t\twhile(tmp){\n\t\t\t\tif(tmp&1)\n\t\t\t\t\tres++;\n\t\t\t\ttmp >>=1;\n\t\t\t}\n\t\t\tcmax=max(cmax,res);\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tfor(int j=0;j<color[i].size();j++){\n\t\t\t\t\tbool jok=true;\n\t\t\t\t\tif(u >>color[i][j]&1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor(int jc=color[i][j]-1;jc>=0;jc--)\n\t\t\t\t\t\tif(rel[ color[i][j] ][jc]&!(u >>jc&1))\n\t\t\t\t\t\t\tjok=false;\n\t\t\t\t\tif(!jok)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tfor(int k=j+1;k<color[i].size();k++){\n\t\t\t\t\t\tbool kok=true;\n\t\t\t\t\t\tif(u >>color[i][k]&1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor(int kc=color[i][k]-1;kc>=0;kc--)\n\t\t\t\t\t\t\tif(rel[color[i][k]][kc]&!(u >>kc&1))\n\t\t\t\t\t\t\t\tkok=false;\n\t\t\t\t\t\tif(!kok)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tused[u|(1<<color[i][j])|(1<<color[i][k])]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cmax << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n\n\nstruct cir{\n    int x,y,r,c;\n};\n\nbool same(cir a,cir b){\n    double r2 = (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n    if((a.r+b.r)*(a.r+b.r)>r2)return true;\n    else return false;\n}\n\nbool used(int n,const vi &vec){\n    rep(i,vec.size()){\n        int to = vec[i];\n        if( (n&(1<<to)) != 0 )return false;\n    }\n    return true;\n}\n\nint main(){\n    int n;\n    while(cin>>n){\n        if(n==0)break;\n        vector<cir> data;\n        \n        rep(i,n){\n            int x,y,r,c;\n            cin>>x>>y>>r>>c;\n            data.pb(cir{x,y,r,c});\n        }\n        \n        \n        vector<int> G[30];\n        \n        for(int i=data.size()-1;i>=0;i--){\n            for(int j=i-1;j>=0;j--){\n                if(same(data[i],data[j])){\n                    G[i].pb(j);\n                }\n            }\n        }\n        \n        static bool dp[1<<24];\n        rep(i,1<<n)dp[i]=false;\n        dp[(1<<n)-1]=true;\n        \n        \n        for(int i=(1<<n)-1;i>=0;i--){\n            if(dp[i]==false)continue;\n            rep(j,n){\n                for(int k=j+1;k<n;k++){\n                    if( (i&(1<<j) )==0 || (i&(1<<k) )==0)continue;\n                    if( data[j].c==data[k].c && used(i,G[j]) && used(i,G[k]) ) dp[(i^(1<<j))^(1<<k)] = true;\n                }\n            }\n        }\n        \n        int ans=100;\n        for(int i=(1<<n)-1;i>=0;i--){\n            if(dp[i]==false)continue;\n            ans = min(ans,__builtin_popcount(i));\n        }\n        cout<<n-ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct circle{\n  double x, y, r;\n  int c;\n  unordered_set<int> overlap;\n};\n\nvoid calcOverlap(int n, circle *disk){\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      int x = disk[i].x - disk[j].x, y = disk[i].y - disk[j].y;\n      if(sqrt(x*x + y*y) + 1e-8< disk[i].r + disk[j].r){\n        disk[j].overlap.insert(i);\n      }\n    }\n  }\n}\n\nint dfs(int n, circle *disk, bool *removed, int dep = 0){\n  int res = 0;\n  bool f = false;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      if(removed[i] == true or removed[j] == true)continue;\n      if(disk[i].c != disk[j].c)continue;\n      if(disk[i].overlap.empty() and disk[j].overlap.empty()){\n        f = true;\n        removed[i] = true;\n        removed[j] = true;\n        for (int k = 0; k < n; k++) {\n          disk[k].overlap.erase(i);\n          disk[k].overlap.erase(j);\n        }\n        res = max(res, dfs(n, disk, removed, dep + 1));\n      }\n    }\n  }\n  return f?res:dep;\n}\n\nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n, n){\n    circle disk[n];\n    for (int i = 0; i < n; i++) {\n      cin >> disk[i].x >> disk[i].y >> disk[i].r >> disk[i].c;\n    }\n    calcOverlap(n, disk);\n    // for (int i = 0; i < n; i++) {\n    //   std::cout << \"i:\" << i << std::endl;\n    //   for (int j :disk[i].overlap) {\n    //     std::cout << j << \" \";\n    //   }\n    //   std::cout << std::endl;\n    // }\n    bool removed[n];\n    memset(removed, false, sizeof(removed));\n    std::cout << 2*dfs(n, disk, removed) << std::endl;\n    // }\n  \n    return 0;\n  }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint sq(int x) { return x * x; }\n\nstruct Circle {\n\tint x, y, r, c;\n\tint tops;\n\tCircle (int _x, int _y, int _r, int _c) : x(_x), y(_y), r(_r), c(_c) {}\n};\n\nbool CC(const Circle& c1, const Circle& c2) {\n\tif (sq(c1.x - c2.x) + sq(c1.y - c2.y) < sq(c1.r + c2.r)) return true;\n\treturn false;\n}\n\nint n;\nvector<Circle> cs;\n\nint memo[1 << 23];\n\nint rec(int cur) {\n\tif (cur < 1 << 23) {\n\t\tif (memo[cur] >= 0) return memo[cur];\n\t}\n\t\n\tint ret = __builtin_popcount(cur);\t// 返す値を用意する\n\tint rmbit = ~cur;\t// bit反転をとる\n\t\n\t// 今取り除ける円盤を見つける\n\tvector<int> cand;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (cur >> i & 1) continue;\t// すでにとりのぞかれている\n\t\t\n\t\tint topsi = cs[i].tops;\n\t\tif ( (topsi & rmbit) != 0) continue;\n\t\t\n\t\t// i番目の円盤は現在のこっている円盤によらずに取り除ける\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (cur >> j & 1) continue;\n\t\t\t\n\t\t\tint topsj = cs[j].tops;\n\t\t\tif ((topsj & rmbit) != 0) continue;\n\t\t\t\n\t\t\t// j番目の円盤も現在のこっている円盤によらずに取り除ける\n\t\t\t\n\t\t\t// 同じ色なら取り除ける\n\t\t\tif (cs[i].c != cs[j].c) continue;\n\t\t\t\n\t\t\t// i と j を取り除いた場合について再帰\n\t\t\tint nxt = cur | (1 << i);\n\t\t\tnxt |= 1 << j;\n\t\t\tret = max(ret, rec(nxt));\n\t\t}\n\t}\n\t\n\treturn memo[cur] = ret;\t// メモしながら返す\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> n; if (n == 0) break;\n\t\t\n\t\tcs.clear();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x, y, r, c; cin >> x >> y >> r >> c;\n\t\t\tcs.push_back(Circle(x, y, r, c));\n\t\t}\n\t\t\n\t\t// 各円盤に対して、どの円盤が取り除かていればその円盤をとりだせるかを入れる\n\t\t// 取り除かなければならない円盤にbitをたてる\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tint tops = 0;\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (CC(cs[i], cs[j])) {\n\t\t\t\t\ttops |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcs[i].tops = tops;\n\t\t}\n\t\t\n\t\t// すべての円盤が残っている状態から開始\t\t\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tcout << rec(0) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nint x[24], y[24], r[24], c[24];\nint on[24];\n\n#define SQ(x) ((x)*(x))\ninline bool isIntersect(int i, int j) {\n  return SQ(x[j]-x[i]) + SQ(y[j]-y[i]) < SQ(r[j]+r[i]);\n}\n\ninline bool isValid(int i, int S) {\n  for(int j=0; j<i; j++) {\n    if((on[i]>>j & 1) && !(S>>j & 1)) return false;\n  }\n  return true;\n}\n\nint memo[1<<24];\nint dfs(int S, const int sum) {\n  int& ret = memo[S];\n  if(ret != -1) return ret;\n  ret = sum;\n  for(int i=0; i<N; i++) {\n    if(S>>i & 1) continue;\n    if(!isValid(i, S)) continue;\n    for(int j=0; j<N; j++) {\n      if(i == j) continue;\n      if(c[i]!=c[j]) continue;\n      if(S>>j & 1) continue;\n      if(!isValid(j, S)) continue;\n      ret = max(ret, dfs(S+(1<<i)+(1<<j), sum+2));\n    }\n  }\n  \n  return ret;\n}\n\nint main() {\n  \n  while(cin >> N && N) {\n    for(int i=0; i<N; i++) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n      on[i] = 0;\n      for(int j=0; j<i; j++) {\n        if(isIntersect(i, j)) on[i] += 1<<j;\n      }\n    }\n    memset(memo, -1, sizeof memo);\n    cout << dfs(0, 0) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <bitset>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef complex<double> P;\n\nstruct C {\n  P p;\n  int r, c;\n};\nint n;\nvector<C> vc;\nint memo[1<<24];\nint solve(int S) {\n  if (memo[S] != -1) return memo[S];\n//  cout << bitset<24>(S) << endl;\n  vector<int> hoge;\n  REP(i,n) {\n    if (S>>i&1) continue;\n    bool f = 0;\n    REP(j,i) {\n      if (S>>j&1) continue;\n      if (abs(vc[i].p-vc[j].p) < vc[i].r+vc[j].r)\n        f = 1;\n    }\n    if (!f)\n      hoge.push_back(i);\n  }\n  int res = 0;\n  // FOR(it, hoge)\n  //   cout << *it << \" \";\n  // cout << endl;\n  REP(i,hoge.size()) {\n    REP(j,i) {\n      if (vc[hoge[i]].c==vc[hoge[j]].c)\n        res = max(res, solve(S|(1<<hoge[i])|(1<<hoge[j])) + 2);\n    }\n  }\n  return memo[S] = res;\n}\n\nint main() {\n  while(cin>>n,n) {\n    vc.clear();\n    REP(i,n) {\n      int x,y,r,cc;\n      cin >> x>>y>>r>>cc;\n      vc.push_back((C){P(x,y),r,cc});\n    }\n    memset(memo,-1,sizeof(memo));\n    cout << solve(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS=1e-10;\nbool EQ(double a,double b){\n\treturn abs(a-b)<EPS;\n}\n\nint n;\nint xs[101];\nint ys[101];\nint rs[101];\nint cs[101];\nint dp[1<<24];\nbool isNoCross(int a,int b){\n\tdouble sumR=rs[a]+rs[b];\n\tdouble dist=sqrt(1.0*(xs[a]-xs[b])*(xs[a]-xs[b])+(ys[a]-ys[b])*(ys[a]-ys[b]));\n\tif(EQ(sumR,dist)||sumR<dist)return true;\n\treturn false;\n}\n\nbool isOver(int a,int b){\n\tif(isNoCross(a,b))return true;\n\treturn a<b;\n}\n\nint dfs(int mask){\n\tif(dp[mask]>=0)return dp[mask];\n\tif(mask==(1<<n)-1)return 0;\n\tint res=0;\n\tint lt[30];\n\tint sz=0;\n\tfor(int i=0;i<n;i++){\n\t\tbool ok=true;\n\t\tif((mask>>i)&1)continue;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i==j)continue;\n\t\t\tif((mask>>j)&1)continue;\n\t\t\tif(!isOver(i,j)){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok)\n\t\t\tlt[sz++]=i;\n\t}\n\tfor(int i=0;i<sz;i++){\n\t\tfor(int j=i+1;j<sz;j++){\n\t\t\tint a=lt[i];\n\t\t\tint b=lt[j];\n\t\t\tif(cs[a]==cs[b]){\n\t\t\t\tint nmask=mask;\n\t\t\t\tnmask|=(1<<a);\n\t\t\t\tnmask|=(1<<b);\n\t\t\t\tres=max(res,dfs(nmask)+2);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[mask]=res;\n}\n\nvoid solve(){\n\n\twhile(cin>>n&&n){\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>xs[i]>>ys[i]>>rs[i]>>cs[i];\n\t\tint res=dfs(0);\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cinttypes>\n\nusing namespace std;\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n\n    if (n == 0) {\n      break;\n    }\n\n    vector<double> x(n);\n    vector<double> y(n);\n    vector<double> r(n);\n    vector<double> c(n);\n    \n\n    for (int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n\n    vector<int8_t> dp(1 << n, 0);\n\n    int ans = 0;\n\n    \n\n    \n    for (int i = 0; i < (1 << n); i++) {\n      int popcnt = 0;\n      for (int j = 0; j < n; j++) {\n        if (i & (1 << j)) {\n          popcnt++;\n        }\n      }\n      if (popcnt % 2 == 1) {\n        continue;\n      }\n      vector<bool> tops(n, true);\n      // テ」ツつづ」ツ?? jテ」ツ?ィkテ」ツ?古・ツ渉姪」ツつ古」ツつ凝」ツ?ェテ」ツつ?\n      for (int a = 0; a < n; a++) {\n        if (i & (1 << a)) {\n          tops[a] = false;\n          continue;\n        }\n        for (int b = a + 1; b < n; b++) {\n          if (i & (1 << b)) {\n            tops[b] = false;\n            continue;\n          }\n          // iテ」ツ?ョテ」ツ?サテ」ツ??」ツ?古「ツ??\n          double distance2 = pow(x[a] - x[b], 2) + pow(y[a] - y[b], 2);\n          if (distance2 < pow(r[a] + r[b], 2)) {\n            tops[b] = false;\n          }\n        }\n      }\n      for (int j = 0; j < n; j++) {\n        for (int k = j + 1; k < n; k++) {\n          if (c[j] == c[k]) {\n            if (tops[j] && tops[k]) {\n              // dp[i | (j, k) << c] = max(dp[i | (j, k) << c], dp[i] + 1);\n              int bit = i | (1 << j) | (1 << k);\n              if (dp[i] + 1 > dp[bit]) {\n                dp[bit] = dp[i] + 1;\n              }\n              if (dp[bit] > ans) {\n                ans = dp[bit];\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    cout << ans * 2<< endl;\n\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ndouble EPS = (1e-10);\n\nstruct Point {\n  double x, y;\n};\n\nstruct Circle {\n  Point p;\n  double r;\n  int id;\n};\n\nbool intersect(Circle a, Circle b) {\n  double x1 = a.p.x, y1 = a.p.y;\n  double x2 = b.p.x, y2 = b.p.y;  \n  double d = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n\n  if ( d - (a.r+b.r) < 0.0 ) return true;  \n  else return false;\n}\n\nvector<Circle> C[4];\nvector<Circle> circles;\nint N;\nunordered_map<int, int> dp;\n\nint dfs(int bit) {\n  //cout << bit << endl;\n  if ( bit == (1<<N)-1 ) return 1;\n  if ( dp[bit] ) return dp[bit];\n\n  int ret = 1;\n  int n;\n  for ( int i = 0; i < 4; i++ ) {\n    n = C[i].size();\n    for ( int a = 0; a < n; a++ ) {\n      Circle c1 = C[i][a];\n      int i1 = c1.id;\n      //if ( bit == 9 && i1 == 1 ) cout << 'a' << endl;\n      if ( bit & (1<<i1) ) continue;\n      bool flag = true;\t\n      for ( int j = 0; j < i1; j++ ) {\n\tif ( !(bit & (1<<j)) && intersect(circles[j], c1) ) {\n\t  flag = false;\n\t  break;\n\t}\n      }\n      //if ( bit == 9 && i1 == 1 ) cout << 'a' << endl;\n      if ( !flag ) continue;\n      //if ( bit == 9 && i1 == 1 ) cout << 'a' << endl;\n      for ( int b = a+1; b < n; b++ ) {\n\tCircle c2 = C[i][b];\n\tint i2 = c2.id;\n\t//if ( i1 == 1 && i2 == 2 ) cout << 'a' << endl;\n\tif ( bit & (1<<i2) ) continue;       \t\n\tfor ( int j = 0; j < i2; j++ ) {\n\t  if ( !(bit & (1<<j)) && intersect(circles[j], c2) ) {\t    \n\t    flag = false;\n\t    break;\n\t  }\n\t}\n\tif ( flag ) {\n\t  ret = max(ret, dfs(bit|(((1<<i1)+(1<<i2))))+2);\t  \n\t}\n      }\n    }\n  }\n  \n  return dp[bit] = ret;  \n}\n\nsigned main() {\n  while ( cin >> N, N ) {\n    for ( int i = 0; i < 4; i++ ) C[i].clear();\n    circles.clear();\n    dp.clear();    \n    \n    for ( int i = 0; i < N; i++ ) {\n      Circle in;\n      double x, y, r;\n      int c;      \n      cin >> x >> y >> r >> c;\n      c--;\n      in.p = Point{x, y};      \n      in.r = r;\n      in.id = i;      \n      C[c].push_back(in);\n      circles.push_back(in);      \n    }\n    \n    cout << dfs(0)-1 << endl;    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#define x first.first\n#define y first.second\n#define r second.first\n#define color second.second\n\nusing namespace std;\n\ntypedef pair<double,double> P;\ntypedef pair<P,P> C;\n\nconst double EPS = 1e-10;\n\ndouble dist(C a,C b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nbool check(C a,C b){\n  return a.r+b.r>dist(a,b);\n}\n\nint dp[(1<<24)];\n\nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<C>c(n);\n    for(int i=0;i<n;i++)\n      cin >> c[i].x >> c[i].y >> c[i].r >> c[i].color;\n    \n    fill(dp,dp+(1<<n),0);\n\n    for(int S=(1<<n)-1;S>=0;S--){\n      for(int i=0;i<n;i++){\n\tfor(int j=i+1;j<n;j++){\n\t  if(!(S>>i&1) || !(S>>j&1))continue;\n\t  if(c[i].color!=c[j].color)continue;\n\n\t  bool fg=false;\n\t  for(int k=0;k<n;k++){\n\t    if(i!=k && check(c[i],c[k]))fg=true;\n\t    if(j!=k && check(c[j],c[k]))fg=true;\n\t  }\n\t  //if(fg)continue;\n\n\t  int nx=S;\n\t  nx&=~(1<<i);\n\t  nx&=~(1<<j);\n\t  dp[nx]=max(dp[nx],dp[S]+2);\n\t}\n      }\n    }\n    int ans=0;\n    for(int i=0;i<(1<<n);i++)ans=max(ans,dp[i]);\n    cout << ans-2 << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ninline int sq(int n) {\n    return n*n;\n}\n\nstruct Circle {\n    int x, y, r, c;\n\n    bool collide(const Circle &other) const {\n        return sq(x-other.x) + sq(y-other.y) < sq(r+other.r);\n    }\n};\n\nint main() {\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        vector<Circle> circles(N);\n        vector<int> blocking(N, 0);\n        for(int i = 0; i < N; ++i) {\n            Circle &circle = circles[i];\n            cin >> circle.x >> circle.y >> circle.r >> circle.c;\n            for(int j = 0; j < i; ++j) {\n                if(circle.collide(circles[j])) {\n                    blocking[i] |= 1<<j;\n                }\n            }\n        }\n\n        int ans = 0;\n        vector<unsigned char> memo(1<<N, 0);\n        queue<int> q;\n        q.push((1<<N)-1);\n        memo[q.front()] = 1;\n        while(!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            ans = max(ans, N - __builtin_popcount(cur));\n\n            for(int i = 0; i < N; ++i) {\n                if((blocking[i] & cur) != 0) continue;\n                if((cur & (1<<i)) == 0) continue;\n                for(int j = 0; j < i; ++j) {\n                    if(circles[i].c != circles[j].c) continue;\n                    if((blocking[j] & cur) != 0) continue;\n                    if((cur & (1<<j)) == 0) continue;\n\n                    int mask = (1<<i) | (1<<j);\n                    int next = cur & ~mask;\n                    if(memo[next]) continue;\n                    memo[next]  = 1;\n                    q.push(next);\n                }\n            }\n        }\n        \n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<complex>\n#include<set>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int M = 24;\nconst int INF = 1000000000;\nconst int C = 5;\n\ntypedef pair<int,int> pii;\n\nint n;\nint x[M];\nint y[M];\nint r[M];\nint c[M];\n\nvector<pii> colpair;\nvector<int> on[M];\n\nbool ok(int state, pii& p){\n\tbool ret = (state&(1<<p.first))==0 && (state&(1<<p.second))==0;\n\trep(i,on[p.first].size()){\n\t\tif((state&(1<<on[p.first][i]))==0)ret = false;\n\t}\n\trep(i,on[p.second].size()){\n\t\tif((state&(1<<on[p.second][i]))==0)ret = false;\n\t}\n\treturn ret;\n}\n\nint memo[1<<M];\nint saiki(int state){\n\tif(memo[state]!=-1)return memo[state];\n\t\n\tint ans = 0;\n\trep(i,colpair.size()){\n\t\tif(ok(state, colpair[i])){\n\t\t\tint v = saiki(state | (1<<colpair[i].first) | (1<<colpair[i].second));\n\t\t\tans = max(ans, v+2);\n\t\t}\n\t}\n\t\n\treturn memo[state]=ans;\n}\n\nvoid init(){\n\trep(i,(1<<n))memo[i]=-1;\n\trep(i,n)on[i].clear();\n\tcolpair.clear();\n\t\n\trep(i,n)reps(j,i+1,n){\n\t\tif(c[i]==c[j])colpair.push_back(pii(i,j));\n\t}\n\t\n\trep(i,n){\n\t\trep(j,i){\n\t\t\tint dx = x[i]-x[j];\n\t\t\tint dy = y[i]-y[j];\n\t\t\tint r2 = r[i]+r[j];\n\t\t\t\n\t\t\tif(dx*dx + dy*dy < r2*r2){\n\t\t\t\ton[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\trep(i,colpair.size()){\n\t\tprintf(\"%d %d\\n\",colpair[i].first, colpair[i].second);\n\t}\n\trep(i,n){\n\t\tprintf(\"on \");\n\t\trep(j,on[i].size())printf(\"%d \",on[i][j]);puts(\"\");\n\t}*/\n}\nint solve(){\n\trep(i,n)cin>>x[i]>>y[i]>>r[i]>>c[i];\n\tinit();\n\t\n\treturn saiki(0);\n}\n\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tprintf(\"%d\\n\",solve());\n\t\t//break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <ctime>\n#include <sstream>\n#include <fstream>\n#include <bitset>\n#include <iomanip>\n#include <assert.h>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef long long LL;\ntypedef long double real;\ntypedef long double LD;\n\n#define mp make_pair\n#define PII pair<int, int>\n#define pb push_back\n#define sz(X) ((int)((X).size()))\n\n#define x first\n#define y second\n\nconst double eps = 1e-8;\nconst double PI = acos(0.) * 2;\nconst int lim = 1000000000;\nconst int inf = ~0U >> 1;\n\ntemplate<class T> T abs(T x){return x < 0 ? -x : x;}\n\nconst int N = 1005;\n\nint x[N], y[N], r[N], c[N];\nshort f[1 << 24];\nint ans, n, fail[N];\nmap<int, int> p;\n\nint low(int i){return i & -i;}\n\nint dfs(int state)\n{\n    if (f[state] != -1) return f[state];\n    f[state] = 0;\n    for (int s1 = state, ii = s1 & -s1; ii; s1 ^= ii, ii = s1 & -s1)\n    {\n        int i = p[ii];\n        if (!(state & (1 << i))) continue;\n        if (fail[i] & state) continue;\n        for (int s2 = s1 ^ ii, jj = s2 & -s2; jj; s2 ^= jj, jj = s2 & -s2)\n        {\n            int j = p[jj];\n            if (!(state & (1 << j))) continue;\n            if (fail[j] & state) continue;\n            if (c[i] != c[j]) continue;\n            int t = dfs(state ^ (1 << i) ^ (1 << j)) + 2;\n            if (t > f[state])\n                f[state] = t;\n        }\n    }\n    return f[state];\n}\n\nint main(){\n    #ifdef edly\n        freopen(\"input.txt\", \"r\", stdin);\n\t#endif\n    while (1)\n    {\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        for (int i = 0; i <n; ++i)\n            scanf(\"%d%d%d%d\", &x[i], &y[i], &r[i], &c[i]);\n        for(int i = 0; i < n; ++i)\n        {\n            fail[i] = 0;\n            for (int j = 0; j < i; ++j)\n            {\n                int dx = abs(x[i] - x[j]);\n                int dy = abs(y[i] - y[j]);\n                int dis = dx * dx + dy * dy;\n                int rr = r[i] + r[j];\n                if (dis < rr * rr)\n                    fail[i] |= (1 << j);\n            }\n            p[1 << i] = i;\n        }\n        ans = 0;\n        for (int i = 0; i < (1 << n); ++i)\n            f[i] = -1;\n        ans = dfs((1 << n) - 1);\n        printf(\"%d\\n\", ans);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<vector>\nstruct S{int c,f,x,y,r;}s[24];\nint A(int x){return x*x;}\nchar m[1<<24];\t//\nint n;\nint F(int f)\n{\n\tif(m[f]>=0)return m[f];\n\tstd::vector<int>v[5];\n\tint i,j,k,r=0,t;\n\tfor(i=0;i<n;++i)\n\t\tif((f&(1<<i))&&!(s[i].f&f))\n\t\t\tv[s[i].c].push_back(i);\n\tfor(k=1;k<5;++k)\n\t{\n\t\tfor(i=0,t=v[k].size();i<t;++i)\n\t\t\tfor(j=i+1;j<t;++j)\n\t\t\t\tr+=2+F(f&~(1<<v[k][i])&~(1<<v[k][j]));\n\t}\n\treturn m[f]=r;\n}\nint main()\n{\n\tint i,j;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tmemset(m,-1,sizeof(m));\n\t\tmemset(s,0,sizeof(s));\n\t\tfor(i=0;i<n;++i)scanf(\"%d%d%d%d\",&s[i].x,&s[i].y,&s[i].r,&s[i].c);\n\t\tfor(i=0;i<n;++i)\n\t\t\tfor(j=i+1;j<n;++j)\n\t\t\t\tif(A(s[i].x-s[j].x)+A(s[i].y-s[j].y)<A(s[i].r+s[j].r))\n\t\t\t\t\ts[j].f|=1<<i;\n\t\tprintf(\"%d\\n\",F((1<<n)-1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint ans = 0;\nbool dp[1 << 24];\n\ntypedef struct\n{\n  bool used;\n  int color, piled;\n} Circle;\n\nvoid solve(vector<Circle>& circle, int bit)\n{\n  ans = max(ans, __builtin_popcount(bit));\n  if (dp[bit])\n    return;\n\n  dp[bit] = true;\n  for (unsigned int i = 0; i < circle.size(); ++i) {\n    if ((circle[i].piled & bit) == circle[i].piled && (~bit & (1 << i))) {\n\n      for (unsigned int j = i+1; j < circle.size(); ++j) {\n\tif ((circle[j].piled & bit) == circle[j].piled && (~bit & (1 << j)) && circle[i].color == circle[j].color) {\n\t  solve(circle, bit | (1 << i) | (1 << j));\n\t}\n      }\n\n    }\n  }\n}\n\nint main()\n{\n  int n;\n  while (~scanf(\"%d\", &n)) {\n    if (n == 0)\n      break;\n\n    vector<int> x(n), y(n), r(n), c(n);\n    for (int i = 0; i < n; ++i)\n      scanf(\"%d %d %d %d\", &x[i], &y[i], &r[i], &c[i]);\n\n    vector<Circle> circle(n);\n    for (int i = n-1; i >= 0; --i) {\n      circle[i].color = c[i];\n      circle[i].piled = 0;\n      for (int j = i-1; j >= 0; --j) {\n\tif ((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j])*(r[i]+r[j]))\n\t  circle[i].piled |= (1 << j);\n      }\n    }\n\n    ans = 0;\n    for (int i = 0; i < (1 << 24); ++i)\n      dp[i] = false;\n    solve(circle, 0);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nstruct en {\n    int x,y,r,c;\n    vector<int> over;\n};\n\nint n, ans;\nvector<en> e;\nchar dp[1<<24];\n\nvoid solve(int bit) {\n    vector<vector<int> > a(5, vector<int>());\n    for (int i = 0; i < n; i++) {\n        if (bit & (1<<i)) continue;\n        bool f = true;\n        for (int j = 0; j < e[i].over.size(); j++) {\n            int t = e[i].over[j];\n            if (!(bit & (1<<t))) f = false;\n        }\n        if (f) a[e[i].c].push_back(i);\n    }\n    \n    \n    if (a[1].size() < 2 && a[2].size() < 2 && a[3].size() < 2 && a[4].size() < 2) {\n        ans = max(ans, dp[bit]-'a');\n        return;\n    }\n    \n    for (int i = 1; i < 5; i++) {\n        if (a[i].size() >= 2) for (int j = 0; j < a[i].size()-1; j++) {\n            for (int k = j+1; k < a[i].size(); k++) {\n                int nbit = bit;\n                nbit |= (1<<a[i][j]);\n                nbit |= (1<<a[i][k]);\n                if (dp[nbit] != 0) continue;\n                dp[nbit] = dp[bit]+2;\n                solve(nbit);\n            }\n        }\n    }\n}\n\nint main(void){\n    while (cin>>n && n) {\n        ans = 0;\n        vector<en> e2(n);\n        e = e2;\n        memset(dp, 0, sizeof(dp));\n        dp[0] = 'a';\n        for (int i = 0; i < n; i++) {\n            cin >> e[i].x >> e[i].y >> e[i].r >> e[i].c;\n            for (int j = 0; j < i; j++) {\n                int tx = e[j].x - e[i].x;\n                int ty = e[j].y - e[i].y;\n                double t = sqrt(tx*tx + ty*ty);\n                if (t < e[i].r + e[j].r) e[i].over.push_back(j);\n            }\n        }\n        \n        solve(0);\n        cout << ans << endl;;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define reps(i,j,k) for(int i=j;i<k;++i)\n#define rep(i,j) reps(i,0,j)\n#define fr first\n#define sc second\n#define fs fr\n#define pb push_back\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long ll;\n\nvi graph[30];\nchar memo[1<<24];\nvi C;\nint n;\n\nint solve(int bit, char cnt){\n\tif(memo[bit]) return memo[bit];\n\tint res = cnt;\n\trep(i,n){\n\t\treps(j,i+1, n){\n\t\t\tif (bit & (1<<i) | bit & (1<<j) | (C[i] != C[j])) continue;\n\t\t\tint bbb = bit | (1 << i) | (1 << j);\n\t\t\tbool f = false;\n\t\t\trep(k,graph[i].size()){\n\t\t\t\tint t = graph[i][k];\n\t\t\t\tif(!(bit & (1<<t))) {f = true; break;}\n\t\t\t}\n\t\t\trep(k,graph[j].size()){\n\t\t\t\tint t = graph[j][k];\n\t\t\t\tif(!(bit & (1<<t))) {f = true; break;}\n\t\t\t}\n\t\t\tif(f) continue;\n\t\t\tres = max(res, solve(bbb, cnt + 2));\n\t\t}\n\t}\n\treturn memo[bit] = res;\n}\n\nint main(){\n\n\twhile(cin >> n,n){\n\t\trep(i,30){\n\t\t\tgraph[i].clear();\n\t\t}\n\t\tvi X(n),Y(n),R(n);\n\t\tC.resize(n);\n\t\tfill(memo, memo + (1<<24), 0);\n\t\trep(i,n){\n\t\t\tint x,y,r,c;\n\t\t\tcin >> x >> y >> r >> c;\t\n\t\t\tX[i] = x;\n\t\t\tY[i] = y;\n\t\t\tR[i] = r;\n\t\t\tC[i] = c;\n\t\t\trep(j,i){\n\t\t\t\tif((X[i]-X[j])*(X[i]-X[j])+(Y[i]-Y[j])*(Y[i]-Y[j]) < (R[i]+R[j])*(R[i]+R[j])){\n\t\t\t\t\tgraph[i].pb(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << solve(0,0) << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n\nvector<double> x;\nvector<double> y;\nvector<double> r;\nvector<double> c;\n\n\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n\n    if (n == 0) {\n      break;\n    }\n\n    x.resize(n);\n    y.resize(n);\n    r.resize(n);\n    c.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n\n    vector<int> dp(1 << n, 0);\n\n    int ans = 0;\n\n    \n\n    \n    for (int i = 0; i < (1 << n); i++) {\n      int popcnt = 0;\n      for (int j = 0; j < n; j++) {\n        if (i & (1 << j)) {\n          popcnt++;\n        }\n      }\n      if (popcnt % 2 == 1) {\n        continue;\n      }\n      vector<bool> tops(n, true);\n      // テ」ツつづ」ツ?? jテ」ツ?ィkテ」ツ?古・ツ渉姪」ツつ古」ツつ凝」ツ?ェテ」ツつ?\n      for (int a = 0; a < n; a++) {\n        if (i & (1 << a)) {\n          tops[a] = false;\n          continue;\n        }\n        for (int b = a + 1; b < n; b++) {\n          if (i & (1 << b)) {\n            tops[b] = false;\n            continue;\n          }\n          // iテ」ツ?ョテ」ツ?サテ」ツ??」ツ?古「ツ??\n          double distance2 = pow(x[a] - x[b], 2) + pow(y[a] - y[b], 2);\n          if (distance2 < pow(r[a] + r[b], 2)) {\n            tops[b] = false;\n          }\n        }\n      }\n      for (int j = 0; j < n; j++) {\n        for (int k = j + 1; k < n; k++) {\n          if (c[j] == c[k]) {\n            if (tops[j] && tops[k]) {\n              // dp[i | (j, k) << c] = max(dp[i | (j, k) << c], dp[i] + 1);\n              int bit = i | (1 << j) | (1 << k);\n              dp[bit] = max(dp[bit], dp[i] + 1);\n              ans = max(ans, dp[bit]);\n            }\n          }\n        }\n      }\n    }\n    \n    cout << ans * 2 << endl;\n\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint main(){\n  int n;\n  cin >> n;\n  while(n!=0){\n    int sum=0;\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    int f=0;\n    int on[24]={};\n    int cc[5]={};\n    while(f==0){\n      f=1;\n      \n      for(i=0;i<24;i++) on[i]=0;\n      for(i=0;i<v.size();i++){\n\tfor(j=i+1;j<v.size();j++){\n\t  if(ch(v[i],v[j])==1) on[j]=1;\n\t}\n      }\n      for(i=0;i<5;i++) cc[i]=0;\n      for(i=0;i<v.size();i++){\n\t//cout << v[i].id<<\":\"<<on[i] <<endl;\n\tif(on[i]==0) cc[v[i].c]++;\n      }\n      for(i=1;i<5;i++){\n\tk=0;\n\tfor(j=v.size()-1;j>=0;j--){\n\t  if(on[j]==0&&v[j].c==i){\n\t    if((cc[i]/2)*2>k) {\n\t      //cout << v[j].id << \" \";\n\t      v.erase(v.begin()+j);\n\t      k++;\n\t      sum++;\n\t      f=0;\n\t    }\n\t  }\n\t}\n      }\n      //cout << f << endl;\n    }\n    //cout << endl;\n    cout << sum << endl;\n    //cout << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\nstruct E{\n\tvector<int> ov;\n\tint color;\n\tint x, y, r;\n\tE(int _x, int _y, int _r, int _c){\n\t\tcolor = _c;\n\t\tx = _x;\n\t\ty = _y;\n\t\tr = _r;\n\t}\n};\n\nbool dp[(1<<25)] = {0};\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tint x, y, r, c, _ans=0;\n\t\tvector<E> e;\n\t\tqueue<int> que;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tE tmp(x,y,r,c);\n\t\t\tfor(int j=0; j<e.size(); j++){\n\t\t\t\tif( (e[j].x-x)*(e[j].x-x) + (e[j].y-y)*(e[j].y-y) < (e[j].r+r)*(e[j].r+r) ){\n\t\t\t\t\ttmp.ov.push_back( j );\n\t\t\t\t}\n\t\t\t}\n\t\t\te.push_back( tmp );\n\t\t}\n\t\tfill(dp, dp+(1<<25), false);\n\t\tdp[0] = true;\n\t\tque.push(0);\n\t\twhile( !que.empty() ){\n\t\t\tint i = que.front();\n\t\t\tque.pop();\n\t\t\tif(!dp[i]){\n\t\t\t\tdp[i] = true;\n\t\t\t\t_ans = max(_ans,i);\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tfor(int l=0; l<n; l++){\n\t\t\t\t\t\tif( k != l && !(i&(1<<k)) && !(i&(1<<l)) && e[k].color == e[l].color){\n\t\t\t\t\t\t\tbool f=true;\n\t\t\t\t\t\t\tfor(int j=0; j<e[k].ov.size(); j++){\n\t\t\t\t\t\t\t\tif( !(i & (1<<e[k].ov[j])) ){\n\t\t\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int j=0; f&&j<e[l].ov.size(); j++){\n\t\t\t\t\t\t\t\tif( !(i & (1<<e[l].ov[j])) ){\n\t\t\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( f ){\n\t\t\t\t\t\t\t//\tdp[ i | (1<<k) | (1<<l) ] = true;\n\t\t\t\t\t\t\t\tque.push( i | (1<<k) | (1<<l) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=1; i<(1<<n); i<<=1){\n\t\t\tif( i & _ans )\n\t\t\t\tans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//And Then. How Many Are There?\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct C{\n  int c; //???\n  int x, y; //????????§?¨?\n  int r; //??????\n  C(){}\n  C(int x, int y, int r, int c){\n    this->x = x;\n    this->y = y;\n    this->r = r;\n    this->c = c;\n  }\n};\n\nint n;\nC data[24];\nint bit[24]; //??????????????¨???????????????\nshort int dp[1<<24];\n\n//a??¨b???????????????true\nbool dis(C a, C b){\n  return (((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y)) < (a.r+b.r)*(a.r+b.r));\n}\n\n//b:??????????????????????????¨???????????????\nint solve(int b, int d){\n  if(dp[b]!=-1)return dp[b];\n\n  int mx=0;\n  for(int i=0; i<n-1; i++){//1???????????????\n    if(bit[i]&b != bit[i])continue;//??????????????????\n    if((b&(1<<i))!=0)continue;//??¢??????????????????\n   \n    for(int j=i+1; j<n; j++){//2???????????????\n      if(bit[j]&b != bit[j])continue;//??????????????????\n      if((b&(1<<j))!=0)continue;//??¢??????????????????\n      if(data[i].c != data[j].c)continue;//????????????\n\n      int tmp_b = (b|(1<<i))|(1<<j);\n      int tmp_mx = solve(tmp_b, d+1)+2;\n      if(mx<tmp_mx)mx=tmp_mx;\n    }\n  }\n  return dp[b]=mx;\n}\n\nint main(){\n  while(cin >> n, !(n==0)){\n    memset(bit, 0, sizeof(bit));\n    memset(dp, -1, sizeof(dp));\n    for(int i=0; i<n; i++){\n      int x, y, r, c;\n      cin >> x >> y >> r >> c;\n      C tmp(x, y, r, c);\n      data[i]=tmp;\n      for(int j=0; j<i; j++){\n\tif(dis(data[i], data[j]))bit[i] = bit[i]|(1<<j);\n      }\n    }\n    cout<<solve(0, 0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvvi color(4);\n\t\tvi x(n), y(n), r(n), c(n);\n\t\tREP(i, n) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t\tc[i]--;\n\t\t\tcolor[c[i]].push_back(i);\n\t\t}\n\t\tvi b(1 << n, 0);\n\t\tb[(1 << n) - 1] = 1;\n\t\tvvi g(n);\n\t\tvi d(n, 0);\n\t\tREP(i, n)FOR(j, i + 1, n) {\n\t\t\tif ((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]) < (r[i] + r[j])*(r[i] + r[j])) {\n\t\t\t\tg[i].push_back(j);\n\t\t\t\td[j]++;\n\t\t\t}\n\t\t}\n\t\tqueue<int> q;\n\t\tq.push((1 << n) - 1);\n\t\twhile (!q.empty()) {\n\t\t\tint bit = q.front(); q.pop();\n\n\t\t\tvi a = d;\n\t\t\tREP(i, n) {\n\t\t\t\tif ((bit&(1 << i)) == 0) {\n\t\t\t\t\tREP(j, g[i].size()) {\n\t\t\t\t\t\ta[g[i][j]]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(i, n)FOR(j, i + 1, n) {\n\t\t\t\tif (c[i] == c[j] && (bit&(1 << i)) && (bit&(1 << j)) && a[i] == 0 && a[j] == 0) {\n\t\t\t\t\tif (b[bit ^ (1 << i) ^ (1 << j)] == 0)q.push(bit ^ (1 << i) ^ (1 << j));\n\t\t\t\t\tb[bit ^ (1 << i) ^ (1 << j)] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tREP(i, 1 << n) {\n\t\t\tif (b[i] == 0)continue;\n\t\t\tint cnt = n;\n\t\t\tREP(j, n)if (i&(1 << j))cnt--;\n\t\t\tchmax(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\nchar bit_count[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n-bit_count[bit];\n\n    for(int i=0;i<n;i++){\n        if(((bit>>i)&1)==0||ok(i,bit)==false)continue;\n        for(int j=i+1;j<n;j++){\n            if((c[i]!=c[j]||(bit>>j)&1)==0||ok(j,bit)==false)continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(!memo[to_bit])ret=max(ret,dfs(to_bit));\n\n        }\n    }\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\nvoid init(){\n    for(int i=0;i<(1<<24);i++){\n        for(int j=0;j<24;j++)if((i>>j)&1){\n            bit_count[i]++;\n        }\n    }\n}\n\nint main(){\n    init();\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nstruct Solver\n{\n\tconst int N;\n\tVI xs, ys, rs, cs;\n\n\tSolver( int n ) : N( n ), xs( n ), ys( n ), rs( n ), cs( n )\n\t{\n\t\treturn;\n\t}\n\n\toperator int()\n\t{\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tcin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n\t\t}\n\n\t\tvector<bool> dp( 1 << N, false );\n\t\tdp[0] = true;\n\n\t\tint res = 0;\n\t\tREP( s, 0, dp.size() )\n\t\t{\n\t\t\tif ( !dp[s] )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tres = max( res, bitCount( s ) );\n\n\t\t\tREP( i, 0, N )\n\t\t\t{\n\t\t\t\tif ( s & 1 << i )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tREP( j, 0, i )\n\t\t\t\t{\n\t\t\t\t\tif ( ( s & 1 << j ) || cs[i] != cs[j] || covered( s, i ) || covered( s,j ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdp[ s | ( 1 << i ) | ( 1 << j ) ] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tbool covered( int s, int p )\n\t{\n\t\tREP( i, 0, p )\n\t\t{\n\t\t\tif ( s & 1 << i )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( sq( xs[i] - xs[p] ) + sq( ys[i] - ys[p] ) < sq( rs[i] + rs[p] ) )\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint sq( int n )\n\t{\n\t\treturn n * n;\n\t}\n\n\tint bitCount( int bits )\n\t{\n\t\tint res = 0;\n\t\tREP( i, 0, 30 )\n\t\t{\n\t\t\tres += ( bits & 1 << i ) ? 1 : 0;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int n; cin >> n, n; )\n\t{\n\t\tcout << Solver( n ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 24;\nint N;\nint color[MAX_N];\nint ride[MAX_N];\nint x[MAX_N];\nint y[MAX_N];\nint r[MAX_N];\nchar d[1 << MAX_N];\n\nbool isCollision ( int x1, int y1, int r1, int x2, int y2, int r2 )\n{\n\tint xx = x1 - x2, yy = y1 - y2, rr = r1 + r2;\n\treturn (xx * xx + yy * yy) < (rr * rr);\n}\n\nint main ( void )\n{\n\twhile (cin >> N, N) {\n\t\tfill(ride, ride+N, 0);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> color[i];\n\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\tif (isCollision(x[i], y[i], r[i], x[j], y[j], r[j])) {\n\t\t\t\t\tride[i] |= (1 << j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfill(d, d+(1 << N), -1);\n\t\tint state = (1 << N) - 1;\n\t\tchar ans = 0;\n\t\td[state] = 0;\n\t\tfor (; state > 0; --state) {\n\t\t\tif (d[state] == -1) { continue; }\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (state & (1 << i) && !(state & ride[i])) {\n\t\t\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\t\t\tif (state & (1 << j) && !(state & ride[j]) && color[i] == color[j]) {\n\t\t\t\t\t\t\tint next = state & ~((1 << i) | (1 << j));\n\t\t\t\t\t\t\td[next] = max<char>(d[next], d[state] + 2);\n\t\t\t\t\t\t\tans = max<char>(ans, d[next]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (int)ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<25];\n\n//dist(i,j)<r[i]+r[j]->ok\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    if(memo[bit]==true)return 0;\n    memo[bit]=true;\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            if(((bit>>i)&1)==0)continue;\n            if(((bit>>j)&1)==0)continue;\n            if(c[i]==c[j]&&ok(i,bit)&&ok(j,bit)){\n                ret=max(ret,dfs((bit^(1<<i))^(1<<j)));\n            }\n        }\n    }\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\nint main(){\n\n    int a=(1<<5)-1;\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nint N;\nint x[30], y[30], r[30], c[30];\nint overlap[30], dp[(1<<24)+1];\n\nint rec(int S) {\n  if (dp[S] >= 0) return dp[S];\n  int ret = 0;\n  // select lhs\n  for (int i = 0; i < N - 1; ++i) {\n    if (S >> i & 1) continue;\n    if (overlap[i] > S) continue;\n    // select rhs\n    for (int j = i+1; j < N; ++j) {\n      if ((S >> j & 1) || c[i] != c[j]) continue;\n      if (overlap[j] > S) continue;\n      // remove\n      ret = max(ret, rec(S|(1<<i)|(1<<j)) + 2);\n    }\n  }\n  return dp[S] = ret;\n}\n\nint solve() {\n  // check overlap\n  memset(overlap, 0, sizeof overlap);\n  for (int i = 1; i < N; ++i) {\n    int lapped = 0;\n    for (int j = 0; j < i; ++j) {\n      int dx = x[i] - x[j], dy = y[i] - y[j], dc = r[i] + r[j];\n      if (dx * dx + dy * dy < dc * dc) lapped |= (1 << j);\n    }\n    overlap[i] = lapped;\n  }\n  memset(dp, -1, sizeof dp);\n  return rec(0);\n}\n\nint main() {\n  while (scanf(\"%d\", &N), N) {\n    rep(i,N) scanf(\"%d%d%d%d\", x+i, y+i, r+i, c+i);\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint n;\nVI xs, ys, rs, cs;\n//VI memo;\nmap<int, int> memo;\nVVI grp;\n\nbool is_top(int i, int used) {\n\tfor (int j = i - 1; j >= 0; j--) {\n\t\tif (1 << j & used) continue;\n\n\t\tint x = (xs[i] - xs[j]) * (xs[i] - xs[j]);\n\t\tint y = (ys[i] - ys[j]) * (ys[i] - ys[j]);\n\t\tint dis = x + y;\n\t\tint dis2 = (rs[i] + rs[j]) * (rs[i] + rs[j]);\n\n\t\tif (dis < dis2) {\t// 重なってる\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint dfs(int used) {\n\tint sum = 0;\n\n//\tif (memo[used] != -1) return memo[used];\n\tif (memo.count(used)) return memo[used];\n\n\tfor(int i = 0;i < n;i++) {\n\t\tfor (auto j : grp[cs[i]]) {\n\t\t\tif(i == j || (1 << i & used) || (1 << j & used)) continue;\n\t\t\tif(cs[i] != cs[j]) continue;\n\t\t\tif(!is_top(i, used) || !is_top(j, used)) continue;\n\n\t\t\tint used_tmp = used;\n\t\t\tused_tmp |= 1 << i;\n\t\t\tused_tmp |= 1 << j;\n\n\t\t\tsum = max(sum, dfs(used_tmp) + 2);\n\t\t}\n\t}\n\n\treturn memo[used] = sum;\n//\treturn sum;\n}\n\nint main(void) {\n\twhile(cin >> n, n){\n\t\txs = VI(n);\n\t\tys = VI(n);\n\t\trs = VI(n);\n\t\tcs = VI(n);\n\t\tgrp = VVI(4);\n\t\tint used = 0;\n//\t\tmemo = VI(1 << n, -1);\n\t\tmemo.clear();\n\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n\t\t\tcs[i]--;\n\t\t\tgrp[cs[i]].push_back(i);\n\t\t}\n\n\t\tcout << dfs(used) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\n\ntypedef struct{\n\tint x;\n\tint y;\n\tint r;\n\tint c;\n}status;\n\nint n;\n\nint dfs(int r,status *s){\n\tint i, j, k, l, c, ret = -1, vc;\n\tstatus t[24];\n\tvector<int> v[4];\n\tfor(i = 0;i < r;i++){\n\t\tfor(j = 0;j < i;j++){\n\t\t\tif((s[i].x - s[j].x) * (s[i].x - s[j].x) + (s[i].y - s[j].y) * (s[i].y - s[j].y) < (s[i].r + s[j].r) * (s[i].r + s[j].r))\n\t\t\t\tbreak;\n\t\t}\n\t\tif(j == i){\n\t\t\tv[s[i].c - 1].push_back(i);\n\t\t}\n\t}\n\tfor(i = 0;i < 4;i++){\n\t\tvc = v[i].size();\n\t\tif(vc > 1){\n\t\t\tif(vc % 2 == 1){\n\t\t\t\tfor(j = 0;j < vc;j++){ // jは配列vの取り除かない番号\n\t\t\t\t\tc = 0;\n\t\t\t\t\tl = 0;\n\t\t\t\t\tfor(k = 0;k < r;k++){\n\t\t\t\t\t\tif(c < vc && v[i][c] == k && v[i][j] != k){\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(v[i][j] == k){\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\tt[l++] = s[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tt[l++] = s[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret = max(ret,dfs(l,t));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tc = 0;\n\t\t\t\tl = 0;\n\t\t\t\tfor(k = 0;k < r;k++){\n\t\t\t\t\tif(c < vc && v[i][c] == k){\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tt[l++] = s[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret = max(ret,dfs(l,t));\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn n - r;\n}\n\n\n\n\n\nint main(void){\n\tint i;\n\tstatus s[24];\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tscanf(\"%d%d%d%d\",&s[i].x,&s[i].y,&s[i].r,&s[i].c);\n\t\t}\n\t\tprintf(\"%d\\n\",dfs(n,s));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct A{\n\tint x,y,r,c;\n};\nint n;\nbool ok[1<<24];\nint over[24];\nmain()\n{\n\twhile(cin>>n,n)\n\t{\n\t\tvector<A>a;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint x,y,r,c;cin>>x>>y>>r>>c;\n\t\t\ta.push_back({x,y,r,c});\n\t\t\tover[i]=0;\n\t\t\tfor(int j=0;j<i;j++)\n\t\t\t{\n\t\t\t\tover[i]|=((x-a[j].x)*(x-a[j].x)+(y-a[j].y)*(y-a[j].y)<(r+a[j].r)*(r+a[j].r))<<j;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<1<<n;i++)ok[i]=0;\n\t\tok[(1<<n)-1]=1;\n\t\tfor(int i=1<<n;i--;)\n\t\t{\n\t\t\tif(!ok[i])continue;\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(i>>j&1&&!(i&over[j]))\n\t\t\t\t{\n\t\t\t\t\tfor(int k=j+1;k<n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(i>>k&1&&!(i&over[k])&&a[j].c==a[k].c)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tok[i&~(1<<j)&~(1<<k)]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=n;\n\t\tfor(int i=0;i<1<<n;i++)\n\t\t{\n\t\t\tif(ok[i])\n\t\t\t{\n\t\t\t\tif(ans>__builtin_popcount(i))ans=__builtin_popcount(i);\n\t\t\t}\n\t\t}\n\t\tcout<<n-ans<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nstruct recedge\n{\n\tint y, next;\n} edge[5555];\nint l, idx[5555], ind[33], x[33], y[33], r[33], c[33], n, ans;\nvoid build(int x, int y)\n{\n\tedge[++l].y = y;\n\tedge[l].next = idx[x];\n\tidx[x] = l;\n}\nint lg(int x)\n{\n\tint rtn = 0;\n\twhile(x) rtn++, x /= 2;\n\treturn rtn - 1;\n}\nvoid dfs(int msk, int d, int c1, int c2, int c3, int c4)\n{\n\tans = max(ans, d);\n\tif(ans == n or ans == n - 1) return;\n\tint I, J, f[n + 1];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tf[i] = true;\n\t\tfor(int p = idx[i + 1]; p; p = edge[p].next) if((1 << (edge[p].y - 1)) & msk)\n\t\t\t{f[i] = false; break;}\n\t}\n\tif(c1 >= 2)\n\t{\n\t\tint msk1 = 0;\n\t\tfor(int i = 0; i < n; i++) if(c[i + 1] == 1 and ind[i + 1] == 0 and ((1 << i) & msk) and f[i])\n\t\t{\n\t\t\tmsk1 += (1 << i);\n\t\t}\n\t\tfor(int i = msk1; i; i -= i & -i) for(int j = i - (i & -i); j; j -= j & -j)\n\t\t{\n\t\t\tdfs(msk - (i & -i) - (j & -j), d + 2, c1 - 2, c2, c3, c4);\n\t\t}\n\t}\n\tif(c2 >= 2)\n\t{\n\t\tint msk1 = 0;\n\t\tfor(int i = 0; i < n; i++) if(c[i + 1] == 2 and ind[i + 1] == 0 and ((1 << i) & msk) and f[i])\n\t\t{\n\t\t\tmsk1 += (1 << i);\n\t\t}\n\t\tfor(int i = msk1; i; i -= i & -i) for(int j = i - (i & -i); j; j -= j & -j)\n\t\t{\n\t\t\tdfs(msk - (i & -i) - (j & -j), d + 2, c1, c2 - 2, c3, c4);\n\t\t}\n\t}\n\tif(c3 >= 2)\n\t{\n\t\tint msk1 = 0;\n\t\tfor(int i = 0; i < n; i++) if(c[i + 1] == 3 and ind[i + 1] == 0 and ((1 << i) & msk) and f[i])\n\t\t{\n\t\t\tmsk1 += (1 << i);\n\t\t}\n\t\tfor(int i = msk1; i; i -= i & -i) for(int j = i - (i & -i); j; j -= j & -j)\n\t\t{\n\t\t\tdfs(msk - (i & -i) - (j & -j), d + 2, c1, c2, c3 - 2, c4);\n\t\t}\n\t}\n\tif(c4 >= 2)\n\t{\n\t\tint msk1 = 0;\n\t\tfor(int i = 0; i < n; i++) if(c[i + 1] == 4 and ind[i + 1] == 0 and ((1 << i) & msk) and f[i])\n\t\t{\n\t\t\tmsk1 += (1 << i);\n\t\t}\n\t\tfor(int i = msk1; i; i -= i & -i) for(int j = i - (i & -i); j; j -= j & -j)\n\t\t{\n\t\t\tdfs(msk - (i & -i) - (j & -j), d + 2, c1, c2, c3, c4 - 2);\n\t\t}\n\t}\n\t\n}\nint main()\n{\n\tfor(;;)\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tif(!n) break;\n\t\tl = 0;\n\t\tint c1 = 0, c2 = 0, c3 = 0, c4 = 0;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tind[i] = 0; idx[i] = 0;\n\t\t\tscanf(\"%d%d%d%d\", &x[i], &y[i], &r[i], &c[i]);\n\t\t\tif(c[i] == 1) c1++;\n\t\t\tif(c[i] == 2) c2++;\n\t\t\tif(c[i] == 3) c3++;\n\t\t\tif(c[i] == 4) c4++;\n\t\t\t\n\t\t\tfor(int j = i - 1; j >= 1; j--)\n\t\t\t{\n\t\t\t\tif(sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j])) < r[i] + r[j])\n\t\t\t\t{\n\t\t\t\t\tbuild(i, j);\n\t\t\t\t//\tprintf(\"%d -> %d\\n\", j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tdfs((1 << n) - 1, 0, c1, c2, c3, c4);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\tfclose(stdin);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define show_bits(b, s) if(opt_debug) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\n// Header under development {{{\n\nint LCM(int a, int b) {\n\t// FIXME\n\treturn a * b;\n}\n\n// Fraction class {{{\n// ref: http://martin-thoma.com/fractions-in-cpp/\nclass Fraction {\n\tpublic:\n\t\tULL numerator;\n\t\tULL denominator;\n\t\tFraction(ULL _numerator, ULL _denominator) {\n\t\t\tassert(_denominator > 0);\n\t\t\tnumerator = _numerator;\n\t\t\tdenominator = _denominator;\n\t\t};\n\n\t\tFraction operator*(const ULL rhs) {\n\t\t\treturn Fraction(this->numerator * rhs, this->denominator);\n\t\t};\n\n\t\tFraction operator*(const Fraction& rhs) {\n\t\t\treturn Fraction(this->numerator * rhs.numerator, this->denominator * rhs.denominator);\n\t\t}\n\n\t\tFraction operator+(const Fraction& rhs) {\n\t\t\tULL lcm = LCM(this->denominator, rhs.denominator);\n\t\t\tULL numer_lhs = this->numerator * (this->denominator / lcm);\n\t\t\tULL numer_rhs = rhs.numerator * (rhs.numerator / lcm);\n\t\t\treturn Fraction(numer_lhs + numer_rhs, lcm);\n\t\t}\n\n\t\tFraction& operator+=(const Fraction& rhs) {\n\t\t\tFraction result = (*this) + rhs;\n\t\t\tthis->numerator = result.numerator;\n\t\t\tthis->denominator = result.denominator;\n\t\t\treturn *this;\n\t\t}\n};\n\nstd::ostream& operator<<(std::ostream &s, const Fraction &a) {\n\tif (a.denominator == 1) {\n\t\ts << a.numerator;\n\t} else {\n\t\ts << a.numerator << \"/\" << a.denominator;\n\t}\n\treturn s;\n}\n\n// }}}\n\n// }}}\n\nbool opt_debug = false;\n\nclass Disk {\n\tprivate:\n\tpublic:\n\t\tint x, y, r, c;\n\t\tset<Disk*> upper_disks;\n\t\tset<Disk*> lower_disks;\n\n\t\tDisk(int _x, int _y, int _r, int _c) : x(_x), y(_y), r(_r), c(_c) {\n\t\t}\n\n\t\tbool overlap(const Disk rhs) {\n\t\t\treturn sqrt(pow(x - rhs.x, 2) + pow(y - rhs.y, 2)) + EPS < r + rhs.r;\n\t\t}\n};\nstd::ostream& operator<<(std::ostream &s, const Disk &d) {\n\ts << \"(\" << d.x << \", \" << d.y << \", \" << d.r << \", \" << d.c << \")\";\n\treturn s;\n}\n\n\nint solve(vector<Disk*> forest) {\n\tif (forest.empty()) { return 0; }\n\n\tdprt(\"Forest:\\n\");\n\tREP (i, forest.size()) {\n\t\tdump(*forest[i]);\n\t}\n\n\tint ret = 0;\n\tREP (i, forest.size()) {\n\t\tFOR (j, i+1, forest.size()) {\n\t\t\tif (forest[i]->c != forest[j]->c) { continue; }\n\t\t\tdump(*forest[i]);\n\t\t\tdump(*forest[j]);\n\n\t\t\tDisk *a = forest[i], *b = forest[j];\n\t\t\tvector<Disk*> new_forest = forest;\n\t\t\tnew_forest.erase(find(ALL(new_forest), a));\n\t\t\tnew_forest.erase(find(ALL(new_forest), b));\n\n\t\t\tEACH (a->lower_disks, itr) {\n\t\t\t\tDisk *d = *itr;\n\t\t\t\td->upper_disks.erase(a);\n\t\t\t\tif (d->upper_disks.empty()) {\n\t\t\t\t\tnew_forest.PB(d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tEACH (b->lower_disks, itr) {\n\t\t\t\tDisk *d = *itr;\n\t\t\t\td->upper_disks.erase(b);\n\t\t\t\tif (d->upper_disks.empty()) {\n\t\t\t\t\tnew_forest.PB(d);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = max(ret, solve(new_forest) + 2);\n\n\t\t\tEACH (a->lower_disks, itr) {\n\t\t\t\tDisk *d = *itr;\n\t\t\t\td->upper_disks.insert(a);\n\t\t\t}\n\t\t\tEACH (b->lower_disks, itr) {\n\t\t\t\tDisk *d = *itr;\n\t\t\t\td->upper_disks.insert(b);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/0.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<Disk*> disks;\n\t\tREP (i, n) {\n\t\t\tint x, y, r, c; cin >> x >> y >> r >> c;\n\t\t\tDisk *d = new Disk(x, y, r, c);\n\t\t\tEACH (disks, itr) {\n\t\t\t\tDisk *rhs = *itr;\n\t\t\t\tif (d->overlap(*rhs)) {\n\t\t\t\t\trhs->lower_disks.insert(d);\n\t\t\t\t\td->upper_disks.insert(rhs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdisks.PB(d);\n\t\t}\n\n\t\tvector<Disk*> forest;\n\t\tEACH (disks, itr) {\n\t\t\tDisk *d = *itr;\n\t\t\tif (d->upper_disks.empty()) {\n\t\t\t\tforest.PB(d);\n\t\t\t}\n\t\t}\n\n\t\tcout << solve(forest) << endl;\n\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct cir {\n\tint num;\n\tint x;\n\tint y;\n\tint r;\n\tint c;\n\tbool top;\n\tset<int> maue;\n\t/*bool operator==(const cir& right) {\n\t\treturn x == right.x && y == right.y && r == right.r && c == right.c && top == right.top && maue == right.maue;\n\t}\n\tbool operator<(const cir& right) {\n\t\treturn x != right.x ? x < right.x : y != right.y ? y < right.y : r != right.r ? r < right.r:true;\n\t}*/\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<cir> circle(n);\n\t\tREP(i, n) {\n\t\t\tcin >> circle[i].x >> circle[i].y >> circle[i].r >> circle[i].c;\n\t\t\tcircle[i].top = true;\n\t\t\tcircle[i].num = i;\n\t\t}\n\t\tREP(i, n / 2)\n\t\t\tswap(circle[i], circle[n - 1 - i]);\n\t\tREP(i, n) {\n\t\t\tREP(j, i) {\n\t\t\t\tif ((circle[i].x - circle[j].x)*(circle[i].x - circle[j].x) +\n\t\t\t\t\t(circle[i].y - circle[j].y)*(circle[i].y - circle[j].y) <\n\t\t\t\t\t(circle[i].r + circle[j].r)*(circle[i].r + circle[j].r)) {\n\t\t\t\t\tcircle[j].top = false;\n\t\t\t\t\tcircle[j].maue.insert(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tqueue<vector<cir>> qvc;\n\t\tset<int> G;\n\t\tint num = 0;\n\t\tREP(i, circle.size())\n\t\t\t\tnum += (1 << circle[i].num);\n\t\tG.insert(num);\n\t\tqvc.push(circle);\n\t\twhile (!qvc.empty())\n\t\t{\n\t\t\tvector<cir> Q = qvc.front();qvc.pop();\n\t\t\tans = max(ans, n - (int)Q.size());\n\t\t\tFOR(i, 1, 5) {\n\t\t\t\tREP(j, Q.size()) {\n\t\t\t\t\tif (Q[j].top&&Q[j].c == i)\n\t\t\t\t\t\tFOR(k, j + 1, Q.size()) {\n\t\t\t\t\t\tif (Q[k].top&&Q[k].c == i) {\n\t\t\t\t\t\t\tvector<cir> Q2 = Q;\n\t\t\t\t\t\t\tREP(l, Q2.size())\n\t\t\t\t\t\t\t\tif (!Q2[l].maue.empty())\n\t\t\t\t\t\t\t\t\tif (EXIST(Q2[l].maue, j)) {\n\t\t\t\t\t\t\t\t\t\tQ2[l].maue.erase(j);\n\t\t\t\t\t\t\t\t\t\tif (Q2[l].maue.empty())\n\t\t\t\t\t\t\t\t\t\t\tQ2[l].top = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tREP(l, Q2.size())\n\t\t\t\t\t\t\t\tif (!Q2[l].maue.empty())\n\t\t\t\t\t\t\t\t\tif (EXIST(Q2[l].maue, k)) {\n\t\t\t\t\t\t\t\t\t\tQ2[l].maue.erase(k);\n\t\t\t\t\t\t\t\t\t\tif (Q2[l].maue.empty())\n\t\t\t\t\t\t\t\t\t\t\tQ2[l].top = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tQ2.erase(Q2.begin() + k);\n\t\t\t\t\t\t\tQ2.erase(Q2.begin() + j);\n\t\t\t\t\t\t\tint num2 = 0;\n\t\t\t\t\t\t\tREP(i, Q2.size())\n\t\t\t\t\t\t\t\t\tnum2 += (1 << Q2[i].num);\n\t\t\t\t\t\t\tif (!EXIST(G, num2)) {\n\t\t\t\t\t\t\t\tqvc.push(Q2);\n\t\t\t\t\t\t\t\tG.insert(num2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <complex>\n\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\ntypedef complex<double> Point;\n\n\nstruct Circle {\n    Point c;\n    double r;\n    int color;\n    Circle(Point c=Point(), double r=0.0,int color=0) :\n        c(c),r(r),color(color){}\n};\ndouble getDistance(Point a,Point b) {\n    return abs(a-b);\n}\n\nbool intersect(Circle c1, Circle c2) {\n    double d=getDistance(c1.c,c2.c);\n    return d<c1.r+c2.r;\n}\nint n;\nbool same_color[30][30];\nbool is_intersect[30][30];\nbool ok(int n,int S) {\n    rep(i,n) {\n        if(!(S>>i&1)&&is_intersect[i][n]) return false;\n    }\n\n    return true;\n}\nint dfs(int S) {\n    int ret=0;\n    rep(i,n) rep(j,n) if(i!=j) {\n        if(((S>>i)&1)) continue;\n        if(((S>>j)&1)) continue;\n        if(!same_color[i][j]) continue;\n        if(!ok(i,S)) continue;\n        if(!ok(j,S)) continue;\n\n        //printf(\"remove %d %d\\n\",i,j);\n        ret=max(ret,dfs(S|(1<<i)|(1<<j))+2);\n    }\n\n    return ret;\n}\nvoid solve() {\n    rep(i,30) rep(j,30) is_intersect[i][j]=false;\n    rep(i,30) rep(j,30) same_color[i][j]=false;\n    vector<Circle> circles;\n    rep(i,n) {\n        double x,y,r;\n        int c;\n        cin>>x>>y>>r>>c;\n        circles.push_back(Circle(Point{x,y},r,c));\n    }\n    rep(i,circles.size()) rep(j,circles.size()) {\n        if(intersect(circles[i],circles[j])) is_intersect[i][j]=true;\n        if(circles[i].color==circles[j].color) same_color[i][j]=true;\n    }\n    cout<<dfs(0)<<endl;\n}\nint main() {\n    while(cin>>n) {\n        if(!n) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 24\nusing namespace std;\n\nint n,x[N],y[N],r[N],c[N],ans,len[N],cn;\nvector<int> v[N];\n\nvoid func(bool erased[N],int cnt,int x){\n  ans=max(ans,cnt);\n  if(cn==1000000) return ;\n  cn++;\n  for(int i=0;i<n;i++){\n    int f=0;\n    if(erased[i]) continue;\n    for(int j=0;j<len[i];j++)\n      if(!erased[v[i][j]]) f=1;\n    if(f) continue;\n    for(int j=i+1;j<n;j++){\n      if(c[i]!=c[j]) continue;\n      if(erased[j]) continue;\n      int f2=0;\n      for(int k=0;k<len[j];k++)\n\tif(!erased[v[j][k]]) f2=1;\n      if(f2) continue;\n      erased[i]=erased[j]=true;\n      func(erased,cnt+2,x+1);\n      erased[i]=erased[j]=false;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    cn=0;\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n      for(int j=i-1;j>=0;j--){\n\tint xl=x[i]-x[j],yl=y[i]-y[j];\n\tint rl=r[i]+r[j];\n\tif(sqrt(xl*xl+yl*yl)<rl)v[i].push_back(n-j-1);\n      }\n    }\n    reverse(x,x+n);\n    reverse(y,y+n);\n    reverse(r,r+n);\n    reverse(c,c+n);\n    reverse(v,v+n);\n    for(int i=0;i<n;i++) len[i]=v[i].size();\n    bool erased[N]={};\n    ans=0;\n    func(erased,0,0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++) v[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#define HIT(a,b) ((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r))\n\nusing namespace std;\n\nstruct DISK {\n\tint x,y,r,c,f;\n};\nint n;\n\nvoid setontop(DISK *D){\n\tint i,j;\n\tfor(i=0;i<n;i++){\n\t\tD[i].f=D[i].r;\n\t\tfor(j=i+1;j<n;j++)\n\t\t\tif(D[j].r && HIT(D[i],D[j])) D[i].f=0;\n\t}\n}\n\nint solve(DISK *D){\n\tint i,j,k,min=30,ret;\n\tsetontop(D);\n\tfor(i=1;i<=4;i++){\n\t\tchar list[6],li=0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(D[j].f&&D[j].c==i) list[li++]=j;\n\t\t}\n\t\tif(li<2)continue;\n\t\tDISK tmp[30];\n\t\tfor(j=0;j<li;j++){\n\t\t\tfor(k=j+1;k<li;k++){\n\t\t\t\tmemcpy(tmp,D,sizeof(tmp));\n\t\t\t\ttmp[list[j]].r=0;\n\t\t\t\ttmp[list[k]].r=0;\n\t\t\t\treturn solve(tmp);\n\t\t\t\tif(ret<min)min=ret;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ret=0,i=0;i<n;i++)if(D[i].r)ret++;\n\tif(ret<min)min=ret;\n\treturn min;\n}\n\nint main(){\n\tint i,j;\n\twhile(cin>>n,n){\n\t\tDISK D[30];\n\t\tfor(i=n;i-->0;) cin>>D[i].x>>D[i].y>>D[i].r>>D[i].c;\n\t\tcout<<n-solve(D)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(long long i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\nDef inf=1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,out;\nvi used;\nvvi in;\nvoid dfs(int a){\n    out=max(out,a);\n    rep(i,n)if(used[i]==0)loop(j,i+1,n)if(used[j]==0&&in[i][3]==in[j][3]){\n        bool h=true;\n        rep(k,i)if(used[k]==0){\n            if((in[i][0]-in[k][0])*(in[i][0]-in[k][0])+\n            (in[i][1]-in[k][1])*(in[i][1]-in[k][1])>=\n            (in[i][2]+in[k][2])*(in[i][2]+in[k][2]));\n            else\n                h=false;\n        }\n        rep(k,j)if(used[k]==0){\n            if((in[j][0]-in[k][0])*(in[j][0]-in[k][0])+\n            (in[j][1]-in[k][1])*(in[j][1]-in[k][1])>=\n            (in[j][2]+in[k][2])*(in[j][2]+in[k][2]));\n            else\n                h=false;\n        }\n        if(!h)continue;\n        used[i]=used[j]=1;\n        dfs(a+2);\n        used[i]=used[j]=0;\n    }\n}\nint main(){\n    while(cin>>n,n){\n        used=vi(n);\n        in=vvi(n,vi(4));\n        rep(i,n)rep(j,4)cin>>in[i][j];\n        out=0;\n        dfs(0);\n        cout<<out<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define MAX_COLORS 6\n#define MAX_CIRCLES 4\n#define MAX_N (MAX_COLORS*MAX_CIRCLES)\n#define MAX_STATES (1<<MAX_N)\n\nint biggest, n;\n\nstruct circle{\n    int x, y, r, c;\n};\n\ncircle C[MAX_N];\nchar dp[MAX_STATES];\n\nbool isOver( circle c1, circle c2 ){\n    int dx, dy;\n    dx = (c1.x - c2.x) * (c1.x - c2.x);\n    dy = (c1.y - c2.y) * (c2.y - c2.y);\n    return dx + dy < (c1.r + c2.r)*(c1.r + c2.r) ? true : false;\n}\n\nbool isDeleted( int state, int num ){\n    return (state & (1<<num)) == 0 ? false : true;\n}\n\nbool isTop( int state, int num ){\n    for( int i = num-1; i >= 0; i-- ){\n        if( isDeleted(state, i) ) continue;\n        if( isOver(C[num], C[i]) ) return false;\n    }\n    //cout << num << endl;\n    return true;\n}\n\nvoid search(){\n    for( int s = 0; s < 1<<n; s++ ){\n        //cout << s << endl;\n        for( int i = 0; i < n; i++ ){\n            if( isDeleted(s, i) ) continue;\n            //cout << \"i: \" << i << endl;\n            for( int j = i+1; j < n; j++ ){\n                if( isDeleted(s, j) ) continue;\n                //cout << \"j: \" << j << endl;\n                if( isTop(s, i) && isTop(s, j) && C[i].c == C[j].c ){\n                    int next = s | 1<<i | 1<<j;\n                    if( dp[next] < dp[s]+2 ) dp[next] = dp[s]+2;\n                    if( biggest < dp[next] ) biggest = dp[next];\n                }\n            }\n        }\n    }\n}\n\nvoid init(){\n    for( int s = 0; s < 1<<n; s++ ){\n        dp[s] = 0;\n    }\n}\n\nint main(){\n    while( cin >> n, n ){\n        for( int i = 0; i < n; i++ ){\n            circle a;\n            scanf(\"%d%d%d%d\", a.x, a.y, a.r, a.c);\n            //cin >> a.x >> a.y >> a.r >> a.c;\n            C[i] = a;\n        }\n        biggest = 0;\n        init();\n        dp[0] = 0;\n        search();\n        printf(\"%d\\n\", biggest);\n        //cout << biggest << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <iostream>\nusing namespace std;\nconst int nmax = 24 + 18, cmax = 4, kmax = 6, emax = nmax * nmax;\n\nint x[nmax], y[nmax], c[nmax], r[nmax];\nint fst[nmax], pnt[emax], nxt[emax], tot;\nint p[nmax], ind[nmax], cnt[nmax];\nint ed[nmax], yes[nmax], gbt;\nint n;\nint ans;\nbool del[nmax];\n\nint gcd(int a, int b)\n{\n  return !b ? a : gcd(b, a % b);\n}\n\nint max(int a, int b)\n{\n  return a > b ? a : b;\n}\n\nint min(int a, int b)\n{\n  return a > b ? b : a;\n}\n\nvoid add(int s, int t)\n{\n  pnt[++tot] = t;\n  nxt[tot] = fst[s];\n  fst[s] = tot;\n}\n\nint sqr(int x)\n{\n  return x * x;\n}\n\nbool inter(int i, int j)\n{\n  return sqr(x[i] - x[j]) + sqr(y[i] - y[j]) < sqr(r[i] + r[j]);\n}\n\nvoid prepare()\n{\n  for (int i = 1; i <= n; ++i)\n    for (int j = i + 1; j <= n; ++j)\n      if (inter(i, j)) {\n\tbool flag = 1;\n\tfor (int k = i + 1; k < j; ++k)\n\t  if (inter(i, k) && inter(k, j)) {\n\t    flag = 0;\n\t    break;\n\t  }\n\tif (flag)\n\t  add(i, j);\n      }\n}\n\n// void dfs(int x)\n// {\n//   if (ed[x] == gbt) return;\n//   ed[x] = gbt;\n//   for (int i = fst[x]; i; i = nxt[i]) {\n//     dfs(pnt[i]);\n//     if (yes[pnt[i]] != gbt) \n//       return;\n//   }\n//   yes[x] = gbt;\n// }\n\nint check()\n{\n  // printf(\".\\n\");\n  int rnt = 0;\n  ++gbt;\n  memset(ind, 0, sizeof(ind));\n  for (int i = 1; i <= n; ++i)\n    for (int j = fst[i]; j; j = nxt[j])\n      ++ind[pnt[j]];\n  for (int i = 1; i <= n; ++i) \n    if (ind[i] == 0)\n      yes[i] = gbt;\n  // qt = 0;\n  // for (int i = 1; i <= n; ++i)\n  //   if (ind[i] == 0) {\n  //     q[++qt] = i;\n  //     yes[i] = gbt;\n  //   }\n  for (bool flag = 1; flag; ) {\n    flag = 0;\n    for (int i = 1; i <= n; ++i)\n      if (ed[i] != gbt && yes[i] == gbt && yes[p[i]] == gbt) {\n\tflag = 1;\n\ted[i] = ed[p[i]] = gbt;\n\trnt += 2;\n\tfor (int j = fst[i]; j; j = nxt[j])\n\t  if ((--ind[pnt[j]]) == 0) {\n\t    yes[pnt[j]] = gbt;\n\t  }\n\tfor (int j = fst[p[i]]; j; j = nxt[j])\n\t  if ((--ind[pnt[j]]) == 0) {\n\t    yes[pnt[j]] = gbt;\n\t  }\n      }\n    // for (int i = 1; i <= qt; ++i)\n    //   if (yes[p[q[i]]]\n  }\n  return rnt;\n}\n\nvoid search(int k)\n{\n  if (k == 0) {\n    search(1);\n    return;\n  }\n  if (k < 0) {\n    k = -k;\n    if (cnt[k] & 1) {\n      for (int i = 1; i <= n; ++i)\n\tif (c[i] == k) {\n\t  del[i] = 1;\n\t  search(-(k - 1));\n\t  del[i] = 0;\n\t}\n    }\n    else\n      search(-(k - 1));\n    return;\n  }\n  if (k * 2 > n) {\n    int tmp = check();\n    if (tmp > ans) {\n      // printf(\"~~~~~~~~~~\\n\");\n      // for (int i = 1; i <= n; ++i) printf(\"(%d %d)\\n\", i, p[i]);\n      ans = tmp;\n    }\n    return;\n  }\n  for (int i = 1; i <= n; ++i)\n    if (!p[i] && !del[i]) {\n      for (int j = i + 1; j <= n; ++j)\n\tif (!del[j] && c[i] == c[j]) {\n\t  // printf(\"(%d, %d)\\n\", i, j);\n\t  p[i] = j;\n\t  p[j] = i;\n\t  search(k + 1);\n\t  p[i] = p[j] = 0;\n\t}\n      return;\n    }\n}\n\nint main()\n{\n  while (1) {\n    scanf(\"%d\", &n);\n    if (!n) break;\n    tot = 0;\n    memset(fst, 0, sizeof(fst));\n    memset(cnt, 0, sizeof(cnt));\n    for (int i = 1; i <= n; ++i) scanf(\"%d%d%d%d\", x + i, y + i, r + i, c + i), ++cnt[c[i]];\n    prepare();\n    memset(p, 0, sizeof(p));\n    ans = 0;\n    // continue;\n    search(-4);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define iota(i,n,b,s) for(int i=int(b);i!=int((b)+(s)*(n));i+=(s))\n#define range(i,n,m) iota(i,(((n)>(m))?((n)-(m)):((m)-(n))),(n),((n)>(m)?-1:1))\n#define rep(i,n) iota(i,(n),0,1)\n#define loop for(;;)\n\n#define INF (1e9)\n#define EPS (1e-9)\n#define cons(a,b) (make_pair(a,b))\n#define car(a) (a.first)\n#define cdr(a) (a.second)\n#define cadr(a) (car(cdr(a)))\n#define cddr(a) (cdr(cdr(a)))\n#define all(a) a.begin(), a.end()\n#define trace(var) cerr<<\">>> \"<<#var<<\" = \"<<var<<endl;\n\ntypedef long long Integer;\ntypedef double Real;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef map<string,int> Dictionary;\nconst Real PI = acos(-1);\n\ntemplate<class S, class T>\nostream& operator<<(ostream& os, pair<S,T> p) {\n  os << '(' << car(p) << \", \" << cdr(p) << ')';\n  return os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T> v) {\n  if (v.size() == 0) {\n    os << \"(empty)\";\n    return os;\n  }\n  os << v[0];\n  for (int i=1, len=v.size(); i<len; ++i) os << ' ' << v[i];\n  return os;\n}\n\nint dx[] = { -1, 0, 1, 0 };\nint dy[] = {  0, -1, 0, 1 };\n\nbool\nintersect(vector<int>&xs, vector<int>&ys, vector<int>&rs, int i, int j) {\n  int x0 = xs[i];\n  int y0 = ys[i];\n  int r0 = rs[i];\n  int x1 = xs[j];\n  int y1 = ys[j];\n  int r1 = rs[j];\n  return pow(x1 - x0, 2) + pow(y1 - y0, 2) < pow(r0 + r1, 2);\n}\n\nstring ni(unsigned int k) {\n  string r = \"\";\n  for (int i = 0; i < 8; ++i) {\n    if (k & (1 << i)) r += \"1\";\n    else r += \"0\";\n  }\n  return r;\n}\n\nint f(vector<vector<bool>>&d, vector<int>&cs) {\n  const int n = d.size();\n\n  stack<pair<unsigned int, int>> s;\n  s.push(cons(0, 0));\n  int ans = 0;\n\n  int cx = 0;\n\n  while (!s.empty()) {\n    auto t = s.top(); s.pop();\n    int r = car(t);\n    int m = cdr(t);\n    ans = max(ans, m);\n    //if (m == 6) trace(cons(ni(r), m));\n    //cout << \"top: \" << cons(ni(r), m) << endl;\n\n    rep (i, n) {\n      if (r & (1 << i)) continue;\n      range (j, i + 1, n) {\n        if (r & (1 << j)) continue;\n        if (cs[i] != cs[j]) continue;\n\n        bool bi = false;\n        rep (k, i) if (!(r & (1 << k)) && d[k][i]) bi = true;\n        if (bi) continue;\n        bool bj = false;\n        rep (k, j) if (!(r & (1 << k)) && d[k][j]) bj = true;\n        if (bj) continue;\n\n        s.push( cons(r | (1 << i) | (1 << j), m + 2) );\n        //cout << \"remove \" << cons(i, j) << endl;\n      }\n    }\n  }\n\n  return ans;\n}\n\nint main() {\n\n  for (int n; cin >> n, n; ) {\n    vector<int> xs;\n    vector<int> ys;\n    vector<int> rs;\n    vector<int> cs;\n\n    rep (i, n) {\n      int x, y, r, c;\n      cin >> x >> y >> r >> c;\n      --c;\n      xs.push_back(x);\n      ys.push_back(y);\n      rs.push_back(r);\n      cs.push_back(c);\n    }\n\n    // d[i][j] = i is on j\n    vector<vector<bool>> d(n, vector<bool>(n, false));\n    rep (i, n) {\n      for (int j = i + 1; j < n; ++j) {\n        d[i][j] = intersect(xs, ys, rs, i, j);\n      }\n    }\n    cout << f(d, cs) << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\n\nint n;\nint x[32], y[32], r[32], c[32];\nbool removed[32];\nbool on(int i, int j)\n{\n\tint dx = x[i] - x[j], dy = y[i] - y[j];\n\tint t = r[i] + r[j];\n\treturn dx * dx + dy * dy < t * t;\n}\nint dfs()\n{\n\tvector<int> cand[4];\n\tfor (;;)\n\t{\n\t\tvector<int> can_rem[4];\n\n\t\tbool top[32];\n\t\tfill(top, top + n, true);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif (removed[i])\n\t\t\t\tcontinue;\n\t\t\tif (top[i])\n\t\t\t\tcan_rem[c[i]].push_back(i);\n\n\t\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\t\tif (on(i, j))\n\t\t\t\t\ttop[j] = false;\n\t\t}\n\n\t\tbool any_rem = false;\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tif (!can_rem[i].empty() && can_rem[i].size() % 2 == 0)\n\t\t\t{\n\t\t\t\tany_rem = true;\n\t\t\t\tfor (int j = 0; j < can_rem[i].size(); ++j)\n\t\t\t\t\tremoved[can_rem[i][j]] = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!any_rem)\n\t\t{\n\t\t\tfor (int i = 0; i < 4; ++i)\n\t\t\t\tif (can_rem[i].size() > 2 && can_rem[i].size() & 1)\n\t\t\t\t\tcand[i] = can_rem[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tint res = count(removed, removed + n, true);\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tif (!cand[i].empty())\n\t\t{\n\t\t\tfor (int left = 0; left < cand[i].size(); ++left)\n\t\t\t{\n\t\t\t\tbool cp[32];\n\t\t\t\tcopy(removed, removed + n, cp);\n\n\t\t\t\tfor (int j = 0; j < cand[i].size(); ++j)\n\t\t\t\t\tif (j != left)\n\t\t\t\t\t\tremoved[cand[i][j]] = true;\n\t\t\t\tmax_swap(res, dfs());\n\n\t\t\t\tcopy(cp, cp + n, removed);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> n, n)\n\t{\n\t\trep (i, n)\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i], --c[i];\n\t\tfill(removed, removed + n, false);\n\t\tcout << dfs() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tint n; cin >> n;\n\t\tif (n == 0) return 0;\n\n\t\tvi x(n), y(n), r(n), c(n);\n\t\trep(i, 0, n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\tbool ison[24][24];\n\t\trep(i, 0, n) rep(j, 0, n)\n\t\t{\n\t\t\tint dd = (x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]);\n\t\t\tint rr = (r[i] + r[j])*(r[i] + r[j]);\n\t\t\tif (dd >= rr)\n\t\t\t\tison[i][j] = false;\n\t\t\telse\n\t\t\t\tison[i][j] = true;\n\t\t}\n\n\t\tvb dp(1 << n, false);\n\t\tdp[0] = true;\n\t\tint ans = 0;\n\t\tint cc;\n\t\tbool ok;\n\t\trep(i, 0, 1 << n)\n\t\t{\n\t\t\tif (!dp[i]) continue;\n\n\t\t\tcc = 0;\n\t\t\trep(j, 0, n) if ((i & (1 << j)) != 0) cc++;\n\t\t\tans = max(ans, cc);\n\n\t\t\trep(j, 1, n)\n\t\t\t{\n\t\t\t\tif ((i & (1 << j)) != 0) continue;\n\t\t\t\tok = true;\n\t\t\t\trep(jj, 0, j) if ((i & (1 << jj)) == 0) if (ison[j][jj]) ok = false;\n\t\t\t\tif (!ok) continue;\n\n\t\t\t\trep(k, 0, j)\n\t\t\t\t{\n\t\t\t\t\tif (c[j] != c[k]) continue;\n\t\t\t\t\tif ((i & (1 << k)) != 0) continue;\n\t\t\t\t\tok = true;\n\t\t\t\t\trep(kk, 0, k) if ((i & (1 << kk)) == 0) if (ison[k][kk]) ok = false;\n\t\t\t\t\tif (!ok) continue;\n\n\t\t\t\t\tdp[(i | (1 << j)) | (1 << k)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,a,b) for(int i = a; i < b; i++)\n\nint n;\nint x[24], y[24], r[24], c[24];\nint dp[1 << 24];\nint ans;\n\nint rec(int s) {\n    if (dp[s] != -1) return dp[s];\n\n    bool flag[n];\n    rep(i,0,n) flag[i] = true;\n\n    rep(i,0,n) {\n        if ((s >> i) & 1) {\n            flag[i] = false;\n            continue;\n        }\n        rep(j,i+1,n) {\n            if ((s >> j) & 1 ) {\n                flag[j] = false;\n            }\n\n            int d1 = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n            int d2 = (r[i] + r[j]) * (r[i] + r[j]);\n            if (d1 < d2) {\n                flag[j] = false;\n            } \n        }\n    }\n\n    int res = 0;\n    rep(i,0,n) {\n        if (!flag[i]) continue;\n        rep(j,i+1,n) {\n            if (!flag[j]) continue;\n            if (c[i] != c[j]) continue;\n            int ns = s | (1 << i) | (1 << j);\n            res = max(res, rec(ns) + 2);\n        }\n    }\n    dp[s] = res;\n    return res;\n}\n\nint main() {\n    while (true) {\n        cin >> n;\n        if (n == 0) break;\n        rep(i,0,n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n        rep(s,0,1<<n) dp[s] = -1;\n        ans = rec(0);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nstruct Data\n{\n    int x;\n    int y;\n    int r;\n    int c;\n};\n\ntypedef struct Data D;\n\nint solve(vector<D> input)\n{\n    int ans = 0;\n    int colornum[5] = {};\n    int n = input.size();\n    cout << \"ho\" << n << endl;\n    for(int i = 0; i < n; i++){\n        bool notcovered = true;\n        // cout << i << \" : \" << input[i].x << \" \" << input[i].y << \" \" << input[i].r << \" \" << input[i].c << endl;\n        for(int j = 0; j < i; j++){\n            // cout << i << \",\" << j << \":\" << pow(input[i].x - input[j].x, 2) + pow(input[i].y - input[j].y, 2) << \" \" << pow(input[i].r + input[j].r, 2) << endl;\n            if(pow(input[i].x - input[j].x, 2) + pow(input[i].y - input[j].y, 2) < pow(input[i].r + input[j].r, 2)){\n                notcovered = false;\n                break;\n            }\n        }\n        if(notcovered) colornum[input[i].c]++;\n    }\n    for(int i = 1; i < 5; i++){\n        if(colornum[i] == 2){\n            vector<D> newinput;\n            for(int j = 0; j < n; j++){\n                if(input[j].c != i) newinput.push_back(input[j]);\n            }\n            ans = max(ans, solve(newinput) + colornum[i]);\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        vector<D> input;\n        for(int i = 0; i < n; i++){\n            D tmpd;\n            cin >> tmpd.x >> tmpd.y >> tmpd.r >> tmpd.c;\n            input.push_back(tmpd);\n        }\n        cout << solve(input) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle {\n    double x, y, r;\n    int c;\n    Circle() {}\n    Circle(double x, double y, double r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    return (a.r + b.r) > sqrt((a.x - b.x) * (a.x - b.x) +\n                              (a.y - b.y) * (a.y - b.y));\n}\n\nint main()\n{\n    int n;\n\n    while (cin >> n, n) {\n        const int N = 1 << n;\n        vector<char> dp(N, 0), up(n, 0);\n        vector<Circle> c(n);\n\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                if (isOverlap(c[i], c[j])) {\n                    if (i < j) // jの上にiがある\n                        up[j] |= 1 << i;\n                    else // iの上にjがある\n                        up[i] |= 1 << j;\n                }\n\n        for (int s = 0; s < N; ++s) {\n            if (dp[s] == -1)\n                continue;\n\n            for (int i = 0; i < n; ++i) {\n                if (s >> i & 1 || s & up[i])  // c[i]が既に置かれているかc[i]が置けない\n                    continue;\n                for (int j = i + 1; j < n; ++j) {\n                    if (c[i].c != c[j].c) // 色が異なる\n                        continue;\n                    if (s >> j & 1 || s & up[j])  // c[j]が既に置かれているかc[j]が置けない\n                        continue;\n                    if (up[i] >> j & 1 || up[j] >> i & 1) // c[i]とc[j]を同時に置けない\n                        continue;\n\n                    int nxt = s | (1 << i) | (1 << j);\n                    dp[nxt] += dp[s] + 2;\n                }\n            }\n        }\n\n        cout << (int)dp[N - 1] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nstruct circle {\n\tint x, y, r;\n};\n\ntypedef pair<circle, int> P;\n\nP circles[30];\n\nbool over(circle a, circle b) {\n\tint distt = (a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y);\n\tif (distt < (a.r + b.r)*(a.r + b.r)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint calc(vector<int> height) {\n\tvector<int> top;\n\tfor (int i = 0; i < height.size(); i++) {\n\t\tif (height[i] == 0) {\n\t\t\ttop.push_back(i);\n\t\t}\n\t}\n\t//cout << top.size() << endl;\n\tint ans = 0;\n\tfor (int i = 0; i < top.size(); i++) {\n\t\tfor (int j = i + 1; j < top.size(); j++) {\n\t\t\tint ii = top[i];\n\t\t\tint jj = top[j];\n\t\t\tif (circles[ii].second == circles[jj].second) {\n\t\t\t\tvector<int> height2 = height;\n\t\t\t\theight2[ii]--;\n\t\t\t\theight2[jj]--;\n\t\t\t\tfor (int k = ii + 1; k < jj; k++) {\n\t\t\t\t\tif (over(circles[ii].first, circles[k].first)) {\n\t\t\t\t\t\theight2[k]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = jj + 1; k < height2.size(); k++) {\n\t\t\t\t\tif (over(circles[ii].first, circles[k].first) || over(circles[jj].first, circles[k].first)) {\n\t\t\t\t\t\theight2[k]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout << 'a' << endl;\n\t\t\t\tans = max(ans, 2 + calc(height2));\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint n;\n\twhile (cin >> n) {\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tint x, y, r, c;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tcircle cc;\n\t\t\tcc.x = x;\n\t\t\tcc.y = y;\n\t\t\tcc.r = r;\n\t\t\tcircles[i] = P(cc, c);\n\t\t}\n\t\tvector<int> height(n, 0);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tif (over(circles[i].first, circles[j].first)) {\n\t\t\t\t\theight[j] = max(height[j], height[i] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}/*\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcout << height[i] << endl;\n\t\t}*/\n\t\tcout << calc(height) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstruct po {int x,y,r,g;};\nvector <po> c[5];\nint ans;\nbool used[1<<24];\nbool check(po a){\n  if(a.x==100000)return false;\n  for(int i=0;i<4;i++)\n    for(int j=0;j<c[i].size();j++){\n      po b = c[i][j];\n      if(a.g>b.g && (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y) < (a.r+b.r)*(a.r+b.r)) return false;\n    }\n  return true;\n}\n\nvoid saiki(int sum,int i,int ima){\n  ans = max(ans,sum);\n  vector <int> J;\n  for(int j=0;j<(int)c[i].size();j++)if(check(c[i][j])==true)J.push_back(j);\n  for(int j=0;j<(int)J.size();j++)\n    for(int k=j+1;k<(int)J.size();k++){\n      int a,b;\n      int nx=(1<<c[i][J[j]].g)|(1<<c[i][J[k]].g)|ima;\n      if(used[nx]==1)continue;\n      used[nx]=1;\n      a=c[i][J[j]].x;\n      b=c[i][J[k]].x;\n      c[i][J[j]].x = c[i][J[k]].x = 100000;\n      for(int l=1;l<4;l++)saiki(sum+2,(i+l)%4,nx);\n      c[i][J[j]].x=a;\n      c[i][J[k]].x=b;\n    }\n}\n\nint main(){\n  while(1){\n    int n;\n    cin>>n;\n    if(n==0)break;\n    int x,y,r,col;\n    for(int j=0;j<(1<<24);j++)used[j]=0;\n    for(int i=0;i<4;i++) c[i].clear();\n    for(int i=0;i<n;i++)cin >>x>>y>>r>>col, c[--col].push_back((po){x,y,r,i});\n\n    ans=0;\n    for(int i=0;i<4;i++) saiki(0,i,0);\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct Disc {\n  int x, y, r, on, id;\n};\n\nconst int MAX_N = 24;\nint N;\nvector<Disc> vd[4];\nchar T[1<<MAX_N];\n\nint isIntersect(const Disc &a, const Disc &b) {\n  int dx = a.x - b.x;\n  int dy = a.y - b.y;\n  int sr = a.r + b.r;\n  if(dx*dx+dy*dy == sr*sr) return 1;\n  if(dx*dx+dy*dy < sr*sr) return 2;\n  return 0;\n}\n\nchar rec(int S) {\n  if(T[S] == -1) {\n    T[S] = 0;\n    for(int i = 0; i < 4; ++i) {\n      for(int j = 0; j < vd[i].size(); ++j) {\n\tif(S & (1<<vd[i][j].id)) continue;\n\tif((S & vd[i][j].on) != vd[i][j].on) continue;\n\tfor(int k = j+1; k < vd[i].size(); ++k) {\n\t  if(S & (1<<vd[i][k].id)) continue;\n\t  if((S & vd[i][k].on) != vd[i][k].on) continue;\n\t  T[S] = max(T[S], (char)( rec(S | (1<<vd[i][j].id) | (1<<vd[i][k].id))+2 ));\n\t  /*\n\t  if(N - T[S] <= 1) {\n\t    for(int i = 0; i < N; ++i) {\n\t      cout << (bool)(S & 1<<i) << \" \";\n\t    }\n\t    cout << endl;\n\t    return T[S];\n\t  }\n\t  */\n\t}\n      }\n    }\n  }\n  return T[S];\n}\n\nint main() {\n  while(cin >> N && N) {\n    int id = 0;\n    for(int i = 0; i < 4; ++i) vd[i].clear();\n    for(int i = 0; i < N; ++i) {\n      Disc d;\n      int c;\n      cin >> d.x >> d.y >> d.r >> c;\n      --c;\n      d.id = id++;\n      d.on = 0;\n      for(int i = 0; i < 4; ++i) {\n\tfor(int j = 0; j < vd[i].size(); ++j) {\n\t  if(isIntersect(d, vd[i][j]) == 2) d.on |= 1<<vd[i][j].id;\n\t}\n      }\n      vd[c].push_back(d);\n    }\n    fill(T, T+(1<<N), (char)(-1));\n    cout << (int)rec(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define sqr(a) ((a) * (a))\n\nusing namespace std;\n\nshort mem[1 << 24];\nint n, x[24], y[24], r[24], c[24];\n\nbool jud(int b,int i){\n\tfor(int j = 0;j < i;j++){\n\t\tif(((b >> j) & 1) == 0 && sqr(x[j] - x[i]) + sqr(y[j] - y[i]) < sqr(r[j] + r[i])){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n\nshort rec(int b){ // iは参照番地\n\tbool end = true;\n\tshort res = 0;\n\tif(mem[b] != -1){\n\t\treturn mem[b];\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tif(((b >> i) & 1) == 0){ // iはとられていないものとられていないもの\n\t\t\tfor(int j = 0;j < i;j++){\n\t\t\t\tif(((b >> j) & 1) == 0){ // jがとられていないもの\n\t\t\t\t\tif(jud(b,i) && jud(b,j) && c[i] == c[j]){\n\t\t\t\t\t\tres = max((int)rec(b | (1 << i) | (1 << j)) + 2,(int)res);\n\t\t\t\t\t\tend = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(end){\n\t\treturn 0;\n\t}\n\treturn mem[b] = res;\n}\n\nint main(void){\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfill(mem,mem + (1 << 24),-1);\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tcout << rec(0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define x first.first\n#define y first.second\n#define r second.first\n#define color second.second\n\nusing namespace std;\n\ntypedef pair<double,double> P;\ntypedef pair<P,P> C;\n\nbool check(C a,C b){\n  return a.r+b.r>sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n \nint count(int bits){\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits =(((bits >> 4) + bits) & 0x0f0f0f0f);\n  bits += bits >> 8;\n  return (bits + (bits >> 16)) & 0xff;\n}\n \nbool dp[(1<<25)];\n \nint main(void){\n \n\tint n;\n\twhile(cin >> n,n){\n\t\tC c[25];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> c[i].x >> c[i].y >> c[i].r >> c[i].color;\n\t\t\t//scanf(\"%lf %lf %lf %lf\",&c[i].x,&c[i].y,&c[i].r,&c[i].color);\n\t\t}\n\t\t\n\t\tfill(dp,dp+(1<<n),false);\n\t\tdp[(1<<n)-1]=true;\n\t\tint ans=0;\n\t\t\n\t\tfor(int S=(1<<n)-1;S>=0;S--){\n\t\t\tif(!dp[S])continue;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\t\n\t\t\t\t\tint nx=S;\n\t\t\t\t\tnx&=~(1<<i);\n\t\t\t\t\tnx&=~(1<<j);\n\t\t\t\t\tif(dp[nx])continue;\n\t\t\t\t\t\n\t\t\t\t\tif(!(S>>i&1) || !(S>>j&1))continue;\n\t\t\t\t\tif(c[i].color!=c[j].color)continue;\n\t\t\t\t\t\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(!(S>>k&1))continue;\n\t\t\t\t\t\tif((k<i && check(c[i],c[k]))||(k<j && check(c[j],c[k])))goto end;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdp[nx]|=dp[S];\n\t\t\t\t\tend:;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp[S])ans=max(ans,n-count(S));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n\nchar dp[1<<24];\nint n;\nint x[24],y[24],r[24],c[24];\n\nint square(int a){\n\treturn a*a;\n}\nbool overlap(int i,int j){\n\treturn square(x[i]-x[j])+square(y[i]-y[j]) < square(r[i]+r[j]);\n}\nbool top(int s,int k){\n\tfor(int i=0;i<k;i++){\n\t\tif(s&1<<i){\n\t\t\tif(overlap(k,i))return false;\n\t\t}\n\t}\n\treturn true;\n}\nint dfs(int s){\n\tif(dp[s]!=-1)return dp[s];\n\tint res=0;\n\tfor(int i=0;i<n;i++){\n\t\tif((s&1<<i)==0 || !top(s,i))continue;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif((s&1<<j)==0 || !top(s,j))continue;\n\t\t\tif(c[i]==c[j])res = max(res,dfs(s&~(1<<i)&~(1<<j))+2);\n\t\t}\n\t}\n\treturn dp[s]=res;\n}\nint main(){\n\twhile(cin>>n&&n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\t}\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tcout<<dfs((1<<n)-1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\n\nstruct disc {\n    int x;\n    int y;\n    int r;\n    int c;\n    vector<int> overlap;\n    disc(int x, int y, int r, int c) : x(x), y(y), r(r), c(c){}\n};\n\nbool is_overlap(disc& a, disc& b)\n{\n    int d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    return d < (a.r + b.r) * (a.r + b.r);\n}\n\nbool remove(vector<disc>& v)\n{\n    vector<int> top;\n\n    for (int i = 0; i < v.size(); ++i){\n        if (v[i].overlap.empty()){\n            top.push_back(i);\n        }\n    }\n    for (int i = 0; i < top.size(); ++i){\n        for (int j = i + 1; j < top.size(); ++j){\n            if (v[top[i]].c == v[top[j]].c){\n                for (auto& k : v){\n                    auto& ol = k.overlap;\n                    if (ol.size() && ol[0] == top[i]) ol.erase(ol.begin());\n                    if (ol.size() && ol[0] == top[j]) ol.erase(ol.begin());\n                }\n                v[top[i]].overlap.push_back(top[i]);\n                v[top[j]].overlap.push_back(top[j]);\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n){\n        vector<disc> v;\n\n        for (int i = 0; i < n; ++i){\n            int x, y, r, c;\n            cin >> x >> y >> r >> c;\n\n            disc d(x, y, r, c);\n            for (int j = 0; j < v.size(); ++j){\n                if (is_overlap(d, v[j])){\n                    d.overlap.push_back(j);\n                }\n            }\n            /*\n            if (d.overlap.empty()) cout << \" -\";\n            else for (int j = 0; j < d.overlap.size(); ++j) cout << \" \" << d.overlap[j];\n            cout << endl;\n            */\n            v.push_back(d);\n        }\n\n        int cnt = 0;\n        while (remove(v)){\n            cnt += 2;\n        }\n        cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <queue>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\ninline double sq(double a) { return a*a; }\n\nint bitcount(int b) { int c = 0; while(b) { b &= b-1; c++; } return c; }\n\nint n, x[64], y[64], r[64], c[64], g[64];\nbool vis[1<<24];\n\nint solve() {\n    memset(vis, 0, sizeof(vis));\n    memset(g, 0, sizeof(g));\n    rep(i, n) for(int j=i+1; j<n; j++) {\n        if(sqrt(sq(x[i]-x[j])+sq(y[i]-y[j]))<r[i]+r[j]) g[i] |= 1<<j;\n    }\n    int ans = 0;\n    queue<int> q;\n    q.push(0);\n    vis[0] = true;\n    while(!q.empty()) {\n        int x = q.front();\n        q.pop();\n        ans = max(ans, bitcount(x));\n        int can = ~x;\n        rep(i, n) if((x&(1<<i))==0) can &= ~g[i];\n        rep(i, n) if(can&(1<<i)) rep(j, i) if(can&(1<<j) && c[i]==c[j]) {\n            const int nx = x|(1<<i)|(1<<j);\n            if(!vis[nx]) q.push(nx), vis[nx] = true;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    for(;;) {\n        scanf(\"%d\", &n);\n        if(n==0) return 0;\n        rep(i, n) scanf(\"%d%d%d%d\", x+i, y+i, r+i, c+i);\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#include<bitset>\n#include<random>\n#include<time.h>\n#include<fstream>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<(ll)m; i++)\n#define FOR(i,n,m) for(long long i=n; i<(ll)m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nmap<ll,ll> dp;\nvector<vector<ll>> co(4);\nvector<P> pos;\nvector<P> cir;\nvector<ll> mask;\nll dfs(ll bit) {\n\tif(dp.count(bit)) return dp[bit];\n\tll ret=0;\n\tbitset<32> bi(bit);\n\tREP(i,4) {\n\t\tREP(j,(ll)co[i].size()) {\n\t\t\tif(bi[co[i][j]]==0||(bit&mask[co[i][j]])!=0) continue;\n\t\t\tREP(k,j) {\n\t\t\t\tif(bi[co[i][k]]==0||(bit&mask[co[i][k]])!=0) continue;\n\t\t\t\tbi[co[i][j]]=0;\n\t\t\t\tbi[co[i][k]]=0;\n\t\t\t\tret=max(ret,2+dfs(bi.to_ullong()));\n\t\t\t\tbi[co[i][j]]=1;\n\t\t\t\tbi[co[i][k]]=1;\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[bit]=ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n==0) return 0;\n\t\tdp.erase(ALL(dp));\n\t\tREP(i,4) co[i].resize(0);\n\t\tpos.resize(n);\n\t\tcir.resize(n);\n\t\tmask.resize(n);\n\t\tREP(i,n) {\n\t\t\tll x,y,r,c;\n\t\t\tcin>>x>>y>>r>>c;\n\t\t\tc--;\n\t\t\tpos[i]=P(x,y);\n\t\t\tcir[i]=P(r,c);\n\t\t}\n\t\tREP(i,n) co[cir[i].second].pb(i);\n\t\tREP(i,n) {\n\t\t\tbitset<32> bi(0);\n\t\t\tREP(j,i) {\n\t\t\t\tif((pos[i].first-pos[j].first)*(pos[i].first-pos[j].first)+(pos[i].second-pos[j].\tsecond)*(pos[i].second-pos[j].second)<(cir[i].first+cir[j].first)*(cir[i].first+cir[j].first)) {\n\t\t\t\t\tbi[j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmask[i]=bi.to_ullong();\n\t\t}\n\t\tcout<<dfs((1ll<<n)-1ll)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i,n) for((i)=0;(i)<(int)n;(i)++)\n#define foreach(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n\nint n, x[30], y[30], r[30], c[30], res;\nint memo[30][30];\n\nbool isOverlap(int a, int b) {\n  if (memo[a][b] != -1) return memo[a][b] == 1;\n  double sub_x = (double)(abs(x[a]-x[b]));\n  double sub_y = (double)(abs(y[a]-y[b]));\n  double dist = sqrt(sub_x*sub_x + sub_y*sub_y);\n  //return dist < r[a] + r[b];\n  memo[a][b] = (dist < r[a] + r[b]) ? 1 : 0 ;\n  return memo[a][b] == 1;\n}\n\nbool isFree(int id, int S) {\n  int i;\n  for (i=0;i<id;i++) if (!((1<<i)&S)) {\n    if (isOverlap(id,i)) return false;\n  }\n  return true;\n}\n\nvoid dfs(int S, int sum) {\n  res = max(res, sum);\n  int i, j;\n  vector<int> v;\n  rep(i,n) if (!((1<<i)&S)) {\n    if (isFree(i,S)) v.push_back(i);\n  }\n  int sz = v.size();\n  //printf(\"call %d %d sz:%d\\n\", S, sum, sz);\n  if (sz <= 1) return;\n  rep(i,sz) rep(j,sz) if (i != j) {\n    int ic = c[v[i]], jc = c[v[j]];\n    if (ic == jc) {\n      int temp = S;\n      temp |= 1<<v[i];\n      temp |= 1<<v[j];\n      dfs(temp, sum+2);\n    }\n  }\n}\n\nint main() {\n  int i, j;\n  while (cin>>n, n) {\n    res = 0;\n    rep(i,n) cin>>x[i]>>y[i]>>r[i]>>c[i];\n    rep(i,n) rep(j,n) memo[i][j] = -1;\n    dfs(0, 0);\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define MAX 30\nusing namespace std;\nint  dp[1<<24];\nint n;\nint x[MAX],y[MAX],r[MAX],c[MAX];\nbool samecol(int a,int b){\n\treturn c[a]==c[b];\n}\nbool check(int a,int b){//kasanaru\n\tif((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b])<(r[a]+r[b])*(r[a]+r[b])){\n\t\treturn 1;\n\t}else\n\t\treturn 0;\n}\nint f(int now,int sum){\n\tif(dp[now]!=-1)\n\t\treturn dp[now];\n\tint ans=0;\n\tbool flag=true;\n\tfor(int i=0;i<n;i++)\n\tfor(int j=i+1;j<n;j++){\n\t\tif((now&(1<<i))&&(now&(1<<j))&&samecol(i,j)&&!check(i,j)){\n\t\t\t\n\t\t\tbool fl=false;\n\t\t\tfor(int k=0;k<j;k++){\n\t\t\t\tif((now&(1<<k))&&check(k,j)){\n\t\t\t\t\tfl=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\tif((now&(1<<k))&&check(i,k)){\n\t\t\t\t\tfl=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!fl){\n\t\t\tint nnow=now;\n\t\t\tnnow=nnow^(1<<i);\n\t\t\tnnow=nnow^(1<<j);\n\t\t\tflag=false;\n\t\t\tans=max(ans,f(nnow,sum+2));\n\t\t\t}\n\t\t}\n\t}\n\tif(flag){\n\t\treturn sum;\n\t}\n\treturn dp[now]=ans;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\t}\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tf((1<<n)-1,0);\n\t\tif(dp[(1<<n)-1]==-1)\n\t\t\tcout<<0<<endl;\n\t\telse\n\t\t\tcout<<dp[(1<<n)-1]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n\nvector<double> x;\nvector<double> y;\nvector<double> r;\nvector<double> c;\n\n\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n\n    if (n == 0) {\n      break;\n    }\n\n    x.resize(n);\n    y.resize(n);\n    r.resize(n);\n    c.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n\n    vector<short> dp(1 << n, 0);\n\n    int ans = 0;\n\n    \n\n    \n    for (int i = 0; i < (1 << n); i++) {\n      int popcnt = 0;\n      for (int j = 0; j < n; j++) {\n        if (i & (1 << j)) {\n          popcnt++;\n        }\n      }\n      if (popcnt % 2 == 1) {\n        continue;\n      }\n      vector<bool> tops(n, true);\n      // テ」ツつづ」ツ?? jテ」ツ?ィkテ」ツ?古・ツ渉姪」ツつ古」ツつ凝」ツ?ェテ」ツつ?\n      for (int a = 0; a < n; a++) {\n        if (i & (1 << a)) {\n          tops[a] = false;\n          continue;\n        }\n        for (int b = a + 1; b < n; b++) {\n          if (i & (1 << b)) {\n            tops[b] = false;\n            continue;\n          }\n          // iテ」ツ?ョテ」ツ?サテ」ツ??」ツ?古「ツ??\n          double distance2 = pow(x[a] - x[b], 2) + pow(y[a] - y[b], 2);\n          if (distance2 < pow(r[a] + r[b], 2)) {\n            tops[b] = false;\n          }\n        }\n      }\n      for (int j = 0; j < n; j++) {\n        for (int k = j + 1; k < n; k++) {\n          if (c[j] == c[k]) {\n            if (tops[j] && tops[k]) {\n              // dp[i | (j, k) << c] = max(dp[i | (j, k) << c], dp[i] + 1);\n              int bit = i | (1 << j) | (1 << k);\n              dp[bit] = max(dp[bit], dp[i] + 1);\n              ans = max(ans, dp[bit]);\n            }\n          }\n        }\n      }\n    }\n    \n    cout << ans * 2 << endl;\n\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\nchar bit_count[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n;i++){\n        if(((bit>>i)&1)==0||ok(i,bit)==false)continue;\n        for(int j=i+1;j<n;j++){\n            if(ok(j,bit)==false||((bit>>j)&1)==0||c[i]!=c[j])continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(!memo[to_bit])ret=max(ret,dfs(to_bit));\n\n        }\n    }\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\nvoid init(){\n    for(int i=0;i<(1<<24);i++){\n        for(int j=0;j<24;j++)if((i>>j)&1){\n            bit_count[i]++;\n        }\n    }\n}\n\nint main(){\n    //init();\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <queue>\n#include <stack>\n#include <map>\nusing namespace std;\n\n#define REP(i, s, e) for (int i = (s); i < (e); i++)\n#define REPI(i, s, e) for (int i = (s); i <= (e); i++)\n#define rep(i, n) REP(i, 0, n)\n#define repi(i, n) REPI(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\n\n#define dump(x) (cout << #x << \" = \" << x << endl)\n#define dump2(x, y) (cout << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl)\n#define dump3(x, y, z) (cout << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \"<< z << \")\" << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define MAX 24\nint n;\nint xs[MAX], ys[MAX], rs[MAX], cs[MAX];\n\nint ans;\n\nint memo[1<<MAX];\n\n#define DBL(x) ((x)*(x))\n\nbool connect(int i, int j)\n{\n\tdouble d = (DBL(xs[i]-xs[j]) + DBL(ys[i]-ys[j]));\n\treturn d < DBL(rs[i]+rs[j]);\n}\n\nbool top(int bit, int i)\n{\n\tfor (int j = i-1; j >= 0; j--)\n\t\tif (!((bit>>j)&1))\n\t\t\tif (connect(i, j))\n\t\t\t\treturn false;\n\treturn true;\n}\n\nint solve(int bit)\n{\n\tif (bit == (1<<n)-1) return 0;\n\tif (memo[bit] != -1) return memo[bit];\n\n\tmemo[bit] = 0;\n\trep(i, n) {\n\t\tif ((bit>>i)&1) continue;\n\t\tif (!top(bit, i)) continue;\n\t\tREP(j, i+1, n) {\n\t\t\tif ((bit>>j)&1) continue;\n\t\t\tif (cs[i] != cs[j]) continue;\n\t\t\tif (!top(bit, j)) continue;\n\t\t\tmemo[bit] = max(memo[bit], solve(bit|(1<<i)|(1<<j))+2);\n\t\t}\n\t}\n\treturn memo[bit];\n}\n\nint main(void)\n{\n\twhile (cin >> n, n) {\n\t\tmemset(memo, -1, sizeof(memo));\n\t\trep(i, n) cin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n\n\t\tcout << solve(0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n\n\nstruct cir{\n    int x,y,r,c;\n};\n\nbool same(cir a,cir b){\n    double r2 = (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n    if((a.r+b.r)*(a.r+b.r)>r2)return true;\n    else return false;\n}\n\nbool used(int n,const vi &vec){\n    rep(i,vec.size()){\n        int to = vec[i];\n        if( (n&(1<<to)) != 0 )return false;\n    }\n    return true;\n}\n\nint main(){\n    int n;\n    while(cin>>n){\n        if(n==0)break;\n        vector<cir> data;\n        \n        rep(i,n){\n            int x,y,r,c;\n            cin>>x>>y>>r>>c;\n            data.pb(cir{x,y,r,c});\n        }\n        \n        \n        vector<int> G[30];\n        \n        for(int i=data.size()-1;i>=0;i--){\n            for(int j=i-1;j>=0;j--){\n                if(same(data[i],data[j])){\n                    G[i].pb(j);\n                }\n            }\n        }\n        \n        static bool dp[1<<24];\n        rep(i,1<<n)dp[i]=false;\n        dp[(1<<n)-1]=true;\n        \n        \n        for(int i=(1<<n)-1;i>=0;i--){\n            if(!dp[i])continue;\n            rep(j,n){\n                if( (i&(1<<j) )==0 )continue;\n                for(int k=j+1;k<n;k++){\n                    if( (i&(1<<k) )==0 )continue;\n                    if( data[j].c==data[k].c && used(i,G[j]) && used(i,G[k]) ) dp[(i^(1<<j))^(1<<k)] = true;\n                }\n            }\n        }\n        \n        int ans=100;\n        for(int i=(1<<n)-1;i>=0;i--){\n            if(!dp[i])continue;\n            ans = min(ans,__builtin_popcount(i));\n        }\n        cout<<n-ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-11;\n\nstruct edge {\n    int to, cost;\n};\n\nint V;\nvector<edge> G[100];\nll d[100];\n\nvoid addedge(int st, int ed, int co) {\n    edge e;\n    e.to = ed;\n    e.cost = co;\n    G[st].push_back(e);\n}\n\nbool bo[100];\nint cir[100][4];\n\nint dfs() {\n    vector<int> vec[4];\n    int rem[4] = {0, 0, 0, 0};\n    for (int i = 0; i < V; i++) {\n        if (!bo[i]) {\n            rem[cir[i][3] - 1]++;\n        }\n    }\n    for (int i = 0; i < V; i++) {\n        if (!bo[i]) {\n            int len = G[i].size();\n            bool ok = true;\n            for (int j = 0; j < len; j++) {\n                if (!bo[G[i][j].to]) {\n                    ok = false;\n                }\n            }\n            if (ok) {\n                int c = cir[i][3];\n                vec[c - 1].push_back(i);\n            }\n        }\n    }\n    int allnum = 0;\n    bool all[4];\n    vector<int> allv[4];\n    fill(all, all + 4, false);\n    for (int i = 0; i < 4; i++) {\n        int len = vec[i].size();\n        if (len == rem[i] && len % 2 == 0 && len > 0) {\n            allnum += len;\n            for (int j = 0; j < len; j++) {\n                bo[vec[i][j]] = true;\n                allv[i].push_back(vec[i][j]);\n            }\n            all[i] = true;\n        }\n    }\n    // for (int i = 0; i < 4; i++) {\n    //     int len = vec[i].size();\n    //     for (int j = 0; j < len; j++) {\n    //         cout << vec[i][j] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    // cout << \"aaa \" << allnum << endl;\n    int ans = 0;\n    for (int i = 0; i < 4; i++) {\n        if (!all[i]) {\n            int len2 = vec[i].size();\n            for (int j = 0; j < len2; j++) {\n                int p = vec[i][j];\n                bo[p] = true;\n                for (int k = j + 1; k < len2; k++) {\n                    int q = vec[i][k];\n                    bo[q] = true;\n                    int num = dfs();\n                    ans = max(ans, num + 2);\n                    bo[q] = false;\n                }\n                bo[p] = false;\n            }\n        } else {\n            int num = dfs();\n            ans = max(ans, num);\n        }\n    }\n    for (int i = 0; i < 4; i++) {\n        if (all[i]) {\n            int len = allv[i].size();\n            for (int j = 0; j < len; j++) {\n                bo[allv[i][j]] = false;\n            }\n        }\n    }\n    return ans + allnum;\n}\n\nint main() {\n    while (1) {\n        int n;\n        cin >> n;\n        V = n;\n        if (n == 0) {\n            break;\n        }\n        fill(bo, bo + V, false);\n        for (int i = 0; i < V; i++) {\n            G[i].clear();\n        }\n        for (int i = 0; i < V; i++) {\n            for (int j = 0; j < 4; j++) {\n                cin >> cir[i][j];\n            }\n        }\n        for (int i = 0; i < V; i++) {\n            for (int j = 0; j < i; j++) {\n                double d = sqrt((cir[i][0] - cir[j][0]) *\n                                (cir[i][0] - cir[j][0])\n                                + (cir[i][1] - cir[j][1]) *\n                                (cir[i][1] - cir[j][1]));\n                if (d + eps < cir[i][2] + cir[j][2]) {\n                    addedge(i, j, 0);\n                }\n            }\n        }\n        ll ans = dfs();\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//And Then. How Many Are There?\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct C{\n  int c; //???\n  int x, y; //????????§?¨?\n  int r; //??????\n  C(){}\n  C(int x, int y, int r, int c){\n    this->x = x;\n    this->y = y;\n    this->r = r;\n    this->c = c;\n  }\n};\n\nint n;\nC data[24];\nint bit[24]; //??????????????¨???????????????\nint dp[1<<24];\n\n//a??¨b???????????????true\nbool dis(C a, C b){\n  return (((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y)) < (a.r+b.r)*(a.r+b.r));\n}\n\n//b:??????????????????????????¨???????????????\nint solve(int b){\n  if(dp[b]!=-1)return dp[b];\n\n  int mx=0;\n  for(int i=0; i<n-1; i++){//1???????????????\n    if(bit[i]&b != bit[i])continue;//??????????????????\n    if((b&(1<<i))!=0)continue;//??¢??????????????????\n   \n    for(int j=i+1; j<n; j++){//2???????????????\n      if(bit[j]&b != bit[j])continue;//??????????????????\n      if((b&(1<<j))!=0)continue;//??¢??????????????????\n      if(data[i].c != data[j].c)continue;//????????????\n\n      int tmp_b = (b|(1<<i))|(1<<j);\n      int tmp_mx = solve(tmp_b)+2;\n      if(mx<tmp_mx)mx=tmp_mx;\n    }\n  }\n  return dp[b]=mx;\n}\n\nint main(){\n  while(cin >> n, !(n==0)){\n    memset(bit, 0, sizeof(bit));\n    memset(dp, -1, sizeof(dp));\n    for(int i=0; i<n; i++){\n      int x, y, r, c;\n      cin >> x >> y >> r >> c;\n      C tmp(x, y, r, c);\n      data[i]=tmp;\n      for(int j=0; j<i; j++){\n\tif(dis(data[i], data[j]))bit[i] = bit[i]|(1<<j);\n      }\n    }\n    cout<<solve(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint dp[1<<24];\n\nint main()\n{\n  int n;\n  int x[25], y[25], r[25], c[25], b[25];\n  while(cin >> n, n) {\n    for(int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i]; b[i] = 0;\n      for(int j = 0; j < i; j++) {\n\tif((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j])*(r[i]+r[j])) b[i] |= (1<<j);\n      }\n    }\n    memset(dp, -1, sizeof(dp));\n    dp[0] = 0;\n    for(int i = 0; i < (1<<n); i++) {\n      if(!~dp[i]) continue;\n      for(int j = 0; j < n-1; j++) {\n\tif(((i >> j) & 1) == 0 && (i & b[j]) == b[j]) {\n\t  for(int k = j+1; k < n; k++) {\n\t    if(c[j] == c[k] && ((i >> k) & 1) == 0 && (i & b[k]) == b[k]) {\n\t      dp[i|(1<<j)|(1<<k)] = max(dp[i|(1<<j)|(1<<k)], dp[i] + 2);\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout << *max_element(dp, dp + (1<<n)) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int N = 24;\n\nint n;\nint ol[N];\nint x[N], y[N], r[N], c[N];\nbool vis[1<<N];\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n    for(int i=0;i<n;i++){\n      ol[i] = 0;\n      for(int j=0;j<i;j++){\n        if((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) < (r[i] + r[j]) * (r[i] + r[j])){\n          ol[i] |= (1<<j);\n        }\n      }\n    }\n    fill(vis, vis+(1<<n), false);\n    queue<int> q;\n    int u = (1<<n) - 1;\n    q.push(u);\n    vis[u] = true;\n    int ans = -2;\n    while(!q.empty()){\n      ans += 2;\n      for(int k=0;k<q.size();k++){\n        u = q.front();q.pop();\n        for(int i=0;i<n;i++){\n          if(u>>i & 1 == 0) continue;\n          for(int j=i+1;j<n;j++){\n            if((u>>j & 1) == 0) continue;\n            if(c[i] != c[j]) continue;\n            int f1 = ((ol[i]&u)>>i)<<i;\n            int f2 = ((ol[j]&u)>>j)<<j;\n            if(f1 < (ol[i]&u) || f2 < (ol[j]&u)) continue;\n            int v = u;\n            v &= ~(1<<i);\n            v &= ~(1<<j);\n            if(vis[v]) continue;\n            vis[v] = true;\n            q.push(v);\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\n\ntypedef struct{\n\tint x;\n\tint y;\n\tint r;\n\tint c;\n}status;\n\nint n;\n\nint dfs(int r,status *s){\n\tint i, j, k, l, c, ret = -1;\n\tstatus t[24];\n\tvector<int> v[4];\n\tfor(i = 0;i < r;i++){\n\t\tfor(j = 0;j < i;j++){\n\t\t\tif((s[i].x - s[j].x) * (s[i].x - s[j].x) + (s[i].y - s[j].y) * (s[i].y - s[j].y) < (s[i].r + s[j].r) * (s[i].r + s[j].r))\n\t\t\t\tbreak;\n\t\t}\n\t\tif(j == i){\n\t\t\tv[s[i].c - 1].push_back(i);\n\t\t}\n\t}\n\tfor(i = 0;i < 4;i++){\n\t\tif(v[i].size() > 1){\n\t\t\tfor(j = 0;j < v[i].size();j++){\n\t\t\t\tfor(k = 0;k < j;k++){\n\t\t\t\t\tc = 0;\n\t\t\t\t\tfor(l = 0;l < r;l++){\n\t\t\t\t\t\tif(v[i][j] != l && v[i][k] != l)\n\t\t\t\t\t\t\tt[c++] = s[l];\n\t\t\t\t\t}\n\t\t\t\t\tret = max(ret,dfs(c,t));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn n - r;\n}\n\n\n\n\n\nint main(void){\n\tint i;\n\tstatus s[24];\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tscanf(\"%d%d%d%d\",&s[i].x,&s[i].y,&s[i].r,&s[i].c);\n\t\t}\n\t\tprintf(\"%d\\n\",dfs(n,s));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 24\nusing namespace std;\n\nint n,x[N],y[N],r[N],c[N],ans,len[N],cn;\nvector<int> v[N];\n\nvoid func(bool erased[N],int cnt,int x){\n  ans=max(ans,cnt);\n  if(cn==1000000) return ;\n  cn++;\n  for(int i=0;i<n;i++){\n    int f=0;\n    if(erased[i]) continue;\n    for(int j=0;j<len[i];j++)\n      if(!erased[v[i][j]]) f=1;\n    if(f) continue;\n    for(int j=i+1;j<n;j++){\n      if(c[i]!=c[j]) continue;\n      if(erased[j]) continue;\n      int f2=0;\n      for(int k=0;k<len[j];k++)\n\tif(!erased[v[j][k]]) f2=1;\n      if(f2) continue;\n      erased[i]=erased[j]=true;\n      func(erased,cnt+2,x+1);\n      erased[i]=erased[j]=false;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    cn=0;\n    for(int i=0;i<n;i++)\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n    reverse(x,x+n);\n    reverse(y,y+n);\n    reverse(r,r+n);\n    reverse(c,c+n);\n    for(int i=0;i<n;i++){\n      for(int j=i-1;j>=0;j--){\n\tint xl=x[i]-x[j],yl=y[i]-y[j];\n\tint rl=r[i]+r[j];\n\tif(sqrt(xl*xl+yl*yl)<rl)v[i].push_back(j);\n      }\n    }\n    for(int i=0;i<n;i++) len[i]=v[i].size();\n    bool erased[N]={};\n    ans=0;\n    func(erased,0,0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++) v[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\nint N;\n\nint X[31],Y[31],R[31],C[31];\n\nbool overlap(int a,int b){\n    int x=X[a]-X[b];\n    int y=Y[a]-Y[b];\n    int r=x*x+y*y;\n    if(r<(R[a]+R[b])*(R[a]+R[b])) return true;\n    else return false;\n}\n\nint dp[(1<<24)];\n\nint rec(int state){\n    if(dp[state]>0) return dp[state];\n    vector<int> col[5];\n    for(int i=0;i<N;i++){\n        if((state&(1<<i))==0) continue;\n        bool ok=true;\n        for(int j=0;j<i;j++){\n            if((state&(1<<j))==0) continue;\n            if(overlap(i,j)){\n                ok=false;\n                break;\n            }\n        }\n        if(ok) col[C[i]].push_back(i);\n    }\n\n    int res=0;\n    for(int i=1;i<=4;i++){\n        for(int j=0;j<col[i].size();j++){\n            for(int k=j+1;k<col[i].size();k++){\n                int nstate=state^(1<<col[i][j]);\n                nstate^=(1<<col[i][k]);\n                res=max(res,rec(nstate)+2);\n            }\n        }\n    }\n    return dp[state]=res;\n}\n\nvoid solve(){\n    for(int i=0;i<(1<<N);i++) dp[i]=0;\n    for(int i=0;i<N;i++) cin>>X[i]>>Y[i]>>R[i]>>C[i];\n\n    cout<<rec((1<<N)-1)<<endl;\n}\n\nint main(){\n  while(1){\n      cin>>N;\n      if(N==0) break;\n      solve();\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n#define HIT(a,b) ((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r))\n\nstruct DISK{\n\tint x,y,r,c,o;\n\tDISK():o(0){}\n};\nint n;\n\nchar visited[1<<24];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tfor(int T=1;cin >> n, n;T++){\n\t\tvector<DISK> D(n);\n\t\tREP(i, n) cin>>D[i].x>>D[i].y>>D[i].r>>D[i].c;\n\t\tREP(j, n)REP(i, j)if(HIT(D[i],D[j])) D[j].o |= 1<<i;\n\t\tint ans = 0;\n\t\tqueue<int> dp;\n\t\tdp.push(0);\n\t\twhile(!dp.empty()){\n\t\t\tconst int b = dp.front(); dp.pop();\n\t\t\tREP(j, n)REP(i, j)if(!((b >> i) & 1)){\n\t\t\t\tif(visited[b|1<<i|1<<j]==T || (b >> i) & 1 || (b>>j) & 1 || D[i].c != D[j].c || ~b & D[i].o || ~b & D[j].o) continue;\n\t\t\t\tdp.push(b|1<<i|1<<j);\n\t\t\t\tvisited[b|1<<i|1<<j]=T;\n\t\t\t}\n\t\t\tans = max(ans, __builtin_popcount(b));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\n#define Max(a, b) ((a) > (b) ? (a) : (b))\n\nstruct Circle\n{\n\tint x, y, radius, color;\n\tbool overlap(const Circle& other) const\n\t{\n\t\tint dis_x = x - other.x;\n\t\tint dis_y = y - other.y;\n\t\tint dis = radius + other.radius;\n\n\t\treturn dis * dis > dis_x * dis_x + dis_y * dis_y;\n\t}\n};\n\nmap<int, int> dp;\nvector<Circle> circles;\n\n\nint next_circle(int state, int index)\n{\n\tfor(int i = index - 1; i >= 0; --i)\n\t{\n\t\tif(state & (1 << i))return i;\n\t}\n\treturn -1;\n}\n\nbool isTop(int state, int index)\n{\n\tbool ret = true;\n\tint on_index = index;\n\t\n\twhile(true)\n\t{\n\t\ton_index = next_circle(state, on_index);\n\t\tif(on_index < 0)break;\n\n\t\tret &= !circles[index].overlap(circles[on_index]);\n\t}\n\treturn ret;\n}\n\nbool removable(int state, int i, int j)\n{\n\tconst auto& now = circles[i];\n\tconst auto& other = circles[j];\n\tif(now.color != other.color)return false;\n\n\treturn isTop(state, i) && isTop(state, j) && !now.overlap(other);\n}\n\nint dfs(int state)\n{\n\tif(dp.find(state) != dp.end())\n\t{\n\t\tif(dp[state] > 0)return dp[state];\n\t}\n\tint ret = 0;\n\n\tfor(int i = 0; i < circles.size(); ++i)\n\t{\n\t\t//?????§??????????????????????????????\n\t\tif(!(state & (1 << i)))continue;\n\n\t\tfor(int j = i - 1; j >= 0; --j)\n\t\t{\n\t\t\t//?????§??????????????????????????????\n\t\t\tif(!(state & (1 << j)))continue;\n\n\t\t\tif(removable(state, i, j))\n\t\t\t{\n\t\t\t\tint removed_circle = ((1 << i) | (1 << j));\n\t\t\t\tint new_state = state & (~removed_circle);\n\n\t\t\t\tret = Max(dfs(new_state) + 2, ret);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[state]= ret;\n}\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tauto n = 0;\n\t\tcin >> n;\n\t\tif(n == 0)break;\n\n\t\tdp.clear();\n\t\tdp[(1 << n) - 1] = 0;\n\n\t\tcircles.clear();\n\t\tcircles.reserve(n);\n\n\t\tfor(auto i = 0; i < n; ++i)\n\t\t{\n\t\t\tint x, y, radius, color;\n\t\t\tcin >> x >> y >> radius >> color;\n\n\t\t\tCircle c = Circle{x, y, radius, color};\n\t\t\tcircles.push_back(c);\n\t\t}\n\n\t\tcout << dfs((1 << n) - 1) << endl;\n\n\t}\n\n\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst double EPS = 1e-10;\n\nint n, x[25], y[25], r[25], c[25];\n\nbool isConnected[25][25];\nbool isRemoved[25];\n\nint square(int x) { return x * x; }\n\nint dfs() {\n  bool isTop[25]; \n  for (int i = 0; i < n; i++) {\n    isTop[i] = false;\n    if (isRemoved[i]) continue;\n    bool flag = true;\n    for (int j = 0; j < i; j++) {\n      if (!isRemoved[j] && isConnected[i][j]) { flag = false; break; }\n    }\n    if (flag) isTop[i] = true;\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      if (isTop[i] && isTop[j] && c[i] == c[j]) {\n        isRemoved[i] = isRemoved[j] = true;\n        ans = max(ans, dfs() + 2);\n        isRemoved[i] = isRemoved[j] = false;\n      }\n    }\n  }\n  return ans;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) scanf(\"%d%d%d%d\", &x[i], &y[i], &r[i], &c[i]);\n    for (int i = 0; i < n; i++) isRemoved[i] = false;\n    for (int i = 0; i < n; i++) for (int j = 0; j < i; j++) {\n      int sum = square(x[i] - x[j]) + square(y[i] - y[j]);\n      if (sum < square(r[i] + r[j])) isConnected[i][j] = true;\n      else isConnected[i][j] = false;\n    }\n    printf(\"%d\\n\", dfs());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define len(v) (int)(v).size()\n\nusing namespace std;\n\nvector<int> G[25];\nint mp[(1 << 24)];\nvector<int> x,y,r,c;\nint p[25];\nint n;\n\nint dfs(int par)\n{\n    if(mp[par] >= 0){\n        return mp[par];\n    }\n    vector<vector<int> > cl(4);\n    rep(i,n){\n        if((par >> i)&1){\n            cl[c[i]].pb(i);\n        }\n    }\n    int mx = 0;\n    rep(i,4){\n        if(len(cl[i])>=2){\n            rep(j,len(cl[i])-1){\n                int npar = par - (1 << cl[i][j]);\n                for(auto& v : G[cl[i][j]]){\n                    p[v] -= (1 << cl[i][j]);\n                    if(p[v]==0) npar += (1 << v);\n                }\n                for(int k=j+1;k<len(cl[i]);k++){\n                    npar -= (1 << cl[i][k]);\n                    for(auto& v : G[cl[i][k]]){\n                        p[v] -= (1 << cl[i][k]);\n                        if(p[v]==0) npar += (1 << v);\n                    }\n                    mx = max(mx,dfs(npar)+2);\n                    for(auto& v : G[cl[i][k]]){\n                        if(p[v]==0) npar -= (1 << v);\n                        p[v] += (1 << cl[i][k]);\n                    }\n                    npar += (1 << cl[i][k]);\n                }\n                for(auto& v : G[cl[i][j]]){\n                    p[v] += (1 << cl[i][j]);\n                }\n            }\n        }\n    }\n    return mx;\n}\n\ninline bool intersect(int i, int j)\n{\n    return (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j])*(r[i]+r[j]);\n}\n\nint main()\n{\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            G[i].clear();\n        }\n        memset(mp,-1,sizeof(mp));\n        x.resize(n),y.resize(n),r.resize(n),c.resize(n);\n        rep(i,n){\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n            p[i] = 0;\n            c[i]--;\n            rep(j,i){\n                if(intersect(i,j)){\n                    G[j].pb(i);\n                    p[i] += (1 << j);\n                }\n            }\n        }\n        int par = 0;\n        rep(i,n){\n            if(p[i] == 0){\n                par += (1 << i);\n            }\n        }\n        cout << dfs(par) << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define mod 1000000007\n#define all(c) begin(c),end(c)\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nusing ll = long long;\nusing vi = vector<int>; using vs = vector<string>;\nint dd[] = { 0, 1, 0, -1, 0 }; //→↓←↑\n\n\n\nvoid solve()\n{\n\tint N;\n\twhile (cin >> N, N)\n\t{\n\t\tvector<int> x(N);\n\t\tvector<int> y(N);\n\t\tvector<int> r(N);\n\t\tvector<int> c(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\t\n\t\tvector<int> G[N];\n\t\t//vector<int> P(N);\n\t/*\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tP[i] = -1;\n\t\t}*/\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t{\n\t\t\t\tint xx = x[i] - x[j];\n\t\t\t\tint yy = y[i] - y[j];\n\t\t\t\tint rr = r[i] + r[j];\n\t\t\t\tif (xx * xx + yy * yy < rr * rr)\n\t\t\t\t{\n\t\t\t\t\tG[j].emplace_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> dp(1 << N, 0);\n\t\tint ans = 0;\n\t\tvector<bool> ok(N, false);\n\t\tfor (int S = 0; S < 1 << N; S++)\n\t\t{\n\t\t\tif (S != 0 && dp[S] == 0)continue;\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t{\n\t\t\t\tif (S >> i & 1)continue;\n\t\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t\t{\n\t\t\t\t\tif (S >> j & 1)continue;\n\t\t\t\t\tif (c[i] != c[j])continue;\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\tfor (int v : G[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((S >> v & 1) == 0) {\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!flag)continue;\n\t\t\t\t\tfor (int v : G[j]) {\n\t\t\t\t\t\tif ((S >> v & 1) == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!flag)continue;\n\n\n\t\t\t\t\tdp[S | (1 << i) | (1 << j)] = dp[S] + 2;\n\t\t\t\t\tans = max(ans, dp[S] + 2);\n\t\t\t\t\t//ok[i] = true;\n\t\t\t\t\t//ok[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << dp[S] << endl;\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nint x[24], y[24], r[24], c[24];\nint on[24];\n\n#define SQ(x) ((x)*(x))\ninline bool isIntersect(int i, int j) {\n  return SQ(x[j]-x[i]) + SQ(y[j]-y[i]) < SQ(r[j]+r[i]);\n}\n\ninline bool isValid(int i, int S) {\n  for(int j=0; j<i; j++) {\n    if((on[i]>>j & 1) && !(S>>j & 1)) return false;\n  }\n  return true;\n}\n\nchar memo[1<<24];\nchar dfs(int S, const int sum) {\n  char& ret = memo[S];\n  if(ret != -1) return ret;\n  ret = sum;\n  for(int i=0; i<N; i++) {\n    if(S>>i & 1) continue;\n    if(!isValid(i, S)) continue;\n    for(int j=0; j<N; j++) {\n      if(i == j) continue;\n      if(c[i]!=c[j]) continue;\n      if(S>>j & 1) continue;\n      if(!isValid(j, S)) continue;\n      ret = max(ret, dfs(S+(1<<i)+(1<<j), sum+2));\n    }\n  }\n  \n  return ret;\n}\n\nint main() {\n  \n  while(cin >> N && N) {\n    for(int i=0; i<N; i++) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n      on[i] = 0;\n      for(int j=0; j<i; j++) {\n        if(isIntersect(i, j)) on[i] += 1<<j;\n      }\n    }\n    memset(memo, -1, sizeof memo);\n    cout << (int)dfs(0, 0) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint N, X[24], Y[24], R[24], C[24];\nbool r[24][24];\nchar dp[16777216];\n\nbool f(char n, int s) {\n  REP(i, 0, n) {\n    if(s & (1 << i)) continue;\n    if(r[n][i]) return false;\n  }\n  return true;\n}\n\nchar dfs(int s, char n) {\n  if(n == N) return N;\n\n  // cout << s << \" \" << (int) n << endl;\n\n  char ret = n;\n  REP(i, 0, N) {\n    if(s & (1 << i) || !f(i, s)) continue;\n    REP(j, i + 1, N) {\n      int ns = s | (1 << i) | (1 << j);\n      if(C[i] != C[j] || (s & (1 << j)) || !f(j, s)) continue;\n      if(dp[ns] >= 0) continue;\n      ret = max(ret, dfs(ns, n + 2));\n    }\n  }\n\n  return dp[s] = ret;\n}\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> X[i] >> Y[i] >> R[i] >> C[i];\n    REP(i, 0, pow(2, N)) dp[i] = -1;\n    REP(i, 0, N) REP(j, 0, N) {\n      if(pow(R[i] + R[j], 2) > pow(X[i] - X[j], 2) + pow(Y[i] - Y[j], 2)) r[i][j] = r[j][i] = true;\n      else r[i][j] = r[i][j] = false;\n    }\n    cout << (int) dfs(0, 0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n\nusing namespace std;\n\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\n#define REP(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define rep(i, n)  REP(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n//\n//int n; //枚数\n//int x[25],y[25],r[25],c[25]; //円盤\n//int b[25]; //各円盤の上に重なっている円盤（ビット管理）\n//\n////円盤iと円盤jが重なっているかの判定\n//bool intersects(int i,int j){\n//    int dist1 = pow(x[i]-x[j],2) + pow(y[i]-y[j],2);\n//    int dist2 = pow(r[i]+r[j],2);\n//\n//    return dist2 > dist1;\n//}\n//\n////DP用\n//char dp[1<<24];\n//\n//int main(void){\n//    while(scanf(\"%d\",&n),n){\n//        rep(i,n){\n//            scanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n//\n//            //円盤iの上に重なっている円盤を全て探す\n//            b[i] = 0;\n//            rep(j,i) if(intersects(i,j)) b[i] |= (1<<j);\n//        }\n//\n//        int ans = 0;\n//        int to = (1<<n);\n//        memset(dp,-1,sizeof(dp));\n//        dp[0] = 0;\n//\n//        rep(i,to){\n//            if(dp[i] == -1) continue;\n//\n//            ans = max(ans,(int)dp[i]);\n//\n//            //消せる円盤のペア(j,k)を探す\n//            rep(j,n-1){\n//                //すでに円盤jは消えている or 円盤jの上の円盤が邪魔して消せない\n//                if((i & (1<<j)) != 0 || (i & b[j]) != b[j]) continue;\n//\n//                REP(k,j+1,n){\n//                    //jとkの色が違う or すでに円盤kは消えている or 円盤kの上の円盤が邪魔\n//                    if(c[j] != c[k] || (i & (1<<k)) != 0 || (i & b[k]) != b[k]) continue;\n//\n//                    int next = i | (1<<j) | (1<<k); //next = 円盤jとkを消した状態(ビット管理)\n//                    dp[next] = max((int)dp[next],dp[i]+2);\n//                }\n//            }\n//        }\n//\n//        printf(\"%d\\n\",ans);\n//    }\n//}\n\n\n\n//重なってればTrueを返す\nbool intersects(int i, int j, vector<int> &x, vector<int> &y, vector<int> &r) {\n    int dist1 = pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2);\n    int dist2 = pow(r[i] + r[j], 2);\n    return dist2 > dist1;\n}\n\nint main() {\n\n    while (true) {\n        int N;\n        cin >> N;\n\n        if (N == 0) break;\n\n        vector<int> x(N), y(N), r(N), c(N);\n        vector<int> b(N);\n        for (int i = 0; i < N; ++i) {\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n            //i番目の円に重なっている円盤jがあれば右からj番目を1にする\n            //1なら重なっている\n            b[i] = 0;\n            for (int j = 0; j < i; j++) {\n                if (intersects(i, j, x, y, r)) {\n                    b[i] |= (1 << j);\n                }\n            }\n        }\n\n        //2^Nの状態を管理する\n        //dp[i]のNビットの右からi番目が1なら円盤iは既に使用されている\n        vector<int> dp(1 << N, -1);\n\n        int ans = 0;\n        int to = (1 << N);\n        dp[0] = 0;\n\n        //すべての状態を全て試す\n        for (int i = 0; i < to; i++) {\n            //状態iにたどり着けないなら\n            if (dp[i] == -1) continue;\n\n            //状態iにおける消した数を確定する\n            ans = max(ans, dp[i]);\n\n            //円盤のペア(j, k)を探す\n            //jの方が、z軸で上にくる\n            //kの方が、z軸で下に来る\n            for (int j = 0; j < N - 1; j++) {\n                //円盤jが使われている\n                //円盤jと重なるものが全て使われてなくなっているか\n                if ((i & (1 << j)) != 0 || (i & b[j]) != b[j]) continue;\n\n\n                //円盤kを探す\n                for (int k = j + 1; k < N; k++) {\n\n                    //色が異なっている\n                    //円盤kが既に使われている\n                    //円盤kと重なるものは全て使用されてなくなっているか\n                    if (c[j] != c[k] || (i & (1 << k)) != 0 || (i & b[k]) != b[k]) continue;\n\n                    //円盤jと円盤kを使う\n                    int next = i | (1 << j) | (1 << k);\n                    dp[next] = max(dp[next], dp[i] + 2);\n\n                }\n\n            }\n\n        }\n\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint sum=0,ds;\nint n;\nvoid rec(vector<circle> vs){\n  //cout << vs.size() << endl;\n  int i,j,k;\n  int f;\n  int on[30]={};\n  vector<int> cc[5];\n  f=1;\n  int ff=0;\n  while(ff==0){\n    ff=1;\n    for(i=0;i<30;i++) on[i]=0;\n    for(i=0;i<5;i++) cc[i].clear();\n    for(i=0;i<vs.size();i++){\n      for(j=i+1;j<vs.size();j++){\n\tif(ch(vs[i],vs[j])==1) on[j]=1;\n      }\n    }\n    for(i=0;i<vs.size();i++){\n      if(on[i]==0) cc[vs[i].c].push_back(i);\n    }\n    for(i=1;i<5;i++){\n      if(cc[i].size()>0&&cc[i].size()%2==0){\n\tfor(j=cc[i].size()-1;j>=0;j--){\n\t  vs.erase(vs.begin()+cc[i][j]);\n\t  ff=0;\n\t  f=0;\n\t}\n      }\n    }\n  }\n  for(i=1;i<5;i++){\n    //cout << cc[i].size() << endl;\n    if(cc[i].size()>=2&&cc[i].size()%2==1){\n      f=0;\n      vector<circle> next(vs);\n      //for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n      for(j=0;j<cc[i].size();j++){\n\tfor(k=cc[i].size()-1;k>=0;k--){\n\t  if(k!=j)\n\t    next.erase(next.begin()+cc[i][k]);\n\t}\n\trec(next);\n      }\n      break;\n    }\n  }\n  int o=n-vs.size();\n  if(f==1) sum=max(sum,o);\n  else{\n    rec(vs);\n  }\n}\n\nint main(){\n  cin >> n;\n  while(n!=0){\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      v.push_back(c);\n    }\n    sum=0;\n    rec(v);\n    cout << sum << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint sum=0,ds;\nint n;\nvoid rec(vector<circle> vs){\n  //cout << vs.size() << endl;\n  int i,j,k;\n  int f;\n  int on[30]={};\n  vector<int> cc[5];\n  f=1;\n  int ff=0;\n  while(ff==0){\n    ff=1;\n    for(i=0;i<30;i++) on[i]=0;\n    for(i=0;i<5;i++) cc[i].clear();\n    for(i=0;i<vs.size();i++){\n      for(j=i+1;j<vs.size();j++){\n\tif(ch(vs[i],vs[j])==1) on[j]=1;\n      }\n    }\n    for(i=0;i<vs.size();i++){\n      if(on[i]==0) cc[vs[i].c].push_back(i);\n    }\n    for(i=1;i<5;i++){\n      if(cc[i].size()>0&&cc[i].size()%2==0){\n\tfor(j=cc[i].size()-1;j>=0;j--){\n\t  vs.erase(vs.begin()+cc[i][j]);\n\t  ff=0;\n\t  f=0;\n\t}\n\tbreak;\n      }\n    }\n  }\n  for(i=0;i<30;i++) on[i]=0;\n  for(i=0;i<5;i++) cc[i].clear();\n  for(i=0;i<vs.size();i++){\n    for(j=i+1;j<vs.size();j++){\n      if(ch(vs[i],vs[j])==1) on[j]=1;\n    }\n  }\n  for(i=0;i<vs.size();i++){\n    if(on[i]==0) cc[vs[i].c].push_back(i);\n  }\n  for(i=1;i<5;i++){\n    //cout << cc[i].size() << endl;\n    if(cc[i].size()>=2&&cc[i].size()%2==1){\n      f=0;\n      vector<circle> next(vs);\n      //for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n      for(j=0;j<cc[i].size();j++){\n\tfor(k=cc[i].size()-1;k>=0;k--){\n\t  if(k!=j)\n\t    next.erase(next.begin()+cc[i][k]);\n\t}\n\trec(next);\n      }\n      break;\n    }\n  }\n  \n  int o=n-vs.size();\n  if(f==1) sum=max(sum,o);\n  else{\n    rec(vs);\n  }\n}\n\nint main(){\n  cin >> n;\n  while(n!=0){\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      v.push_back(c);\n    }\n    int on[30]={};\n    vector<int> cc[5];\n    int f=1;\n    int ff=0;\n    while(ff==0){\n      ff=1;\n      for(i=0;i<30;i++) on[i]=0;\n      for(i=0;i<v.size();i++){\n\tfor(j=i+1;j<v.size();j++){\n\t  if(ch(v[i],v[j])==1) on[j]=1;\n\t}\n      }\n      for(i=0;i<5;i++) cc[i].clear();\n      for(i=0;i<v.size();i++){\n\tif(on[i]==0) cc[v[i].c].push_back(i);\n      }\n      for(i=1;i<5;i++){\n\tif(cc[i].size()>0&&cc[i].size()%2==0){\n\t  for(j=cc[i].size()-1;j>=0;j--){\n\t    v.erase(v.begin()+cc[i][j]);\n\t    ff=0;\n\t    f=0;\n\t  }\n\t  break;\n\t}\n      }\n    }\n    rec(v);\n    cout << sum << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct Disk{ int x,y,r,c; };\n\nint n;\nDisk D[24];\n\nchar dp[1<<24];\nint overlap[24];\n\nint dfs(int used){\n\tif(~dp[used]) return dp[used];\n\n\tint nc[4]={},top[4][6];\n\trep(i,n) if((used&(1<<i))==0 && (overlap[i]&used)==overlap[i]) {\n\t\ttop[D[i].c][nc[D[i].c]++]=i;\n\t}\n\n\tint ans=0;\n\trep(c,4) rep(j,nc[c]) rep(i,j) {\n\t\tans=max(ans,dfs(used|(1<<top[c][i])|(1<<top[c][j]))+2);\n\t}\n\treturn dp[used]=ans;\n}\n\n#define sq(x) ((x)*(x))\n#define sqsum(x,y) (sq(x)+sq(y))\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\trep(S,1<<n) dp[S]=-1;\n\t\trep(i,n) scanf(\"%d%d%d%d\",&D[i].x,&D[i].y,&D[i].r,&D[i].c), D[i].c--;\n\n\t\trep(i,n){\n\t\t\toverlap[i]=0;\n\t\t\trep(j,i) if(sqsum(D[i].x-D[j].x,D[i].y-D[j].y)<sq(D[i].r+D[j].r)) {\n\t\t\t\toverlap[i]|=1<<j;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",dfs(0));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <deque>\n#include <vector>\n#include <numeric>\n#include <iterator>\n#include <array>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\n\n\n#define FF first\n#define SS second\n#define ALL(c) begin((c)), end((c))\n#define REP(i,n) for(ll i=0;i<(ll)n;++i)\ninline int getInt() { int s; scanf(\"%d\", &s); return s; }\n\nstruct circle{\n\tll id,x,y,r,c;\n\tbool operator==(const circle & o) {\n\t\treturn id==o.id;\n\t}\n};\n\nvector<circle> g_table;\n\n\nint main() {\n\n\twhile (true) {\n\t\tll n;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\t\n\t\tg_table.clear();\n\t\tREP(i, n){\n\t\t\tint x,y,r,c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tg_table.push_back(circle{i,x,y,r,c-1});\n\t\t}\n\n\t\tint size = g_table.size();\n\n\t\twhile (true) {\n\t\t\tvector<circle> tops[4];\n\n\t\t\tREP(i, g_table.size()) {\n\t\t\t\tbool top = true;\n\t\t\t\tREP(j, g_table.size()) {\n\t\t\t\t\tif (i==j) continue;\n\t\t\t\t\tll xx = g_table[i].x - g_table[j].x;\n\t\t\t\t\tll yy = g_table[i].y - g_table[j].y;\n\t\t\t\t\tll rr = g_table[i].r + g_table[j].r;\n\t\t\t\t\tif (xx*xx + yy*yy < rr*rr && i>j) {\n\t\t\t\t\t\ttop = false; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (top) tops[g_table[i].c].push_back(g_table[i]);\n\t\t\t}\n\n\t\t\tbool done = false;\n\t\t\tREP(c, 4) while (tops[c].size() >= 2) {\n\t\t\t\tdone = true;\n\t\t\t\tg_table.erase(remove(ALL(g_table), tops[c].back()), g_table.end());\n\t\t\t\ttops[c].pop_back();\n\t\t\t\tg_table.erase(remove(ALL(g_table), tops[c].back()), g_table.end());\n\t\t\t\ttops[c].pop_back();\n\t\t\t}\n\n\t\t\tif (!done) break;\n\t\t}\n\n\t\tcout << size - g_table.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\n\nint sq(int x){ return x * x; }\n\nint n;\nint c[24];\n\nint on[24];\nsigned char memo[1 << 24];\n\nint dfs(int S){\n\tif(memo[S] == -1){\n\t\tvector<vector<int> > v(4);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(S >> i & 1) continue;\n\t\t\tif(on[i] & ~S) continue;\n\t\t\t\n\t\t\tv[c[i] - 1].push_back(i);\n\t\t}\n\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < 4; ++i){\n\t\t\tfor(int j = 1; j < v[i].size(); ++j)\n\t\t\tfor(int k = 0; k < j; ++k){\n\t\t\t\tint T = S | (1 << v[i][j]) | (1 << v[i][k]);\n\t\t\t\tret = max(ret, dfs(T) + 2);\n\t\t\t}\n\t\t}\n\t\tmemo[S] = ret;\n\t}\n\treturn memo[S];\n}\n\n\nint main(){\n\tint x[24], y[24], r[24];\n\twhile(scanf(\"%d\", &n), n){\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d%d%d%d\", &x[i], &y[i], &r[i], &c[i]);\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tint a = 0;\n\t\t\tfor(int j = 0; j < i; ++j){\n\t\t\t\tif(sq(x[i] - x[j]) + sq(y[i] - y[j]) < sq(r[i] + r[j])){\n\t\t\t\t\ta |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t\ton[i] = a;\n\t\t}\n\n\t\tmemset(memo, -1, sizeof memo);\n\t\tprintf(\"%d\\n\", dfs(0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = (a.r + b.r) * (a.r + b.r);\n    int d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    return r > d;\n}\n\nint main()\n{\n    int n;\n\n    while (cin >> n, n) {\n        const int N = 1 << n;\n        vector<char> dp(N, -1), up(n, 0);\n        vector<Circle> c(n);\n\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j) {\n                if (i == j)\n                    continue;\n                if (isOverlap(c[i], c[j])) {\n                    if (i < j) // jの上にiがある\n                        up[j] |= (1 << i);\n                    else // iの上にjがある\n                        up[i] |= (1 << j);\n                }\n            }\n\n        int res = 0;\n        dp[0] = 0; // ビットが立っているならば置かれていない\n        for (int s = 0; s < N; ++s) {\n            if (dp[s] == -1)\n                continue;\n\n            res = max(res, (int)dp[s]);\n            for (int i = 0; i < n; ++i) {\n                if (s >> i & 1 || (~s) & up[i]) // c[i]が置かれていないかc[i]が取り除けない\n                    continue;\n\n                for (int j = i + 1; j < n; ++j) {\n                    if (c[i].c != c[j].c) // 色が異なる\n                        continue;\n                    if (s >> j & 1 || (~s) & up[j])// c[j]が置かれていないかc[j]が取り除けない\n                        continue;\n\n                    int nxt = s | 1 << i | 1 << j;\n                    dp[nxt] = max((int)dp[nxt], dp[s] + 2);\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nstruct Disc{\n\tint x,y,r,c;\n\tDisc(int p_x,int p_y,int p_r,int p_c){\n\t\tx=p_x;y=p_y;r=p_r;c=p_c;\n\t}\n\tDisc(){};\n};\n\nint n;\nint memo[1<<24];\nbool exist[24];\nDisc D[24];\nint ans;\n\nbool touch(Disc a,Disc b){\n\treturn (a.r+b.r)*(a.r+b.r)>(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n}\n\nbool top(int k){\n\tfor(int i=k-1;i>=0;i--){\n\t\tif(exist[i]){\n\t\t\tif(touch(D[k],D[i])) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\n\nint dfs(int bit,int num){\n\tif(memo[bit]>=0) return memo[bit];\n\tint res=num;\n\n\tfor(int i=0;i<n;i++){\n\t\tif(exist[i] && top(i)){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(exist[j] && top(j) && i!=j && D[i].c==D[j].c){\n\t\t\t\t\texist[i]=false;\n\t\t\t\t\texist[j]=false;\n\t\t\t\t\tres=max(res,dfs((bit&(~1<<i))&(~1<<j),num+2));\n\t\t\t\t\texist[i]=true;\n\t\t\t\t\texist[j]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemo[bit]=res;\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin>>n && n!=0){\n\t\tans=0;\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tmemset(exist,true,sizeof(exist));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y,r,c;\n\t\t\tcin>>x>>y>>r>>c;\n\t\t\tD[i]=Disc(x,y,r,c);\n\t\t}\n\t\tcout<<dfs((1<<24)-1,0)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n\nlong long  mod = 1000000007;\n\n\nbool lap[30][30];\n\n\nbool overlap(int i,int j,vector<int> &x,vector<int>&y,vector<int> &r){\n\tint k = 0;\n\tk = (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]);\n\tif(k>= (r[i]+r[j])*(r[i]+r[j]))return 0;\n\treturn 1;\n}\n\n\nint main(){\n\tint n;\n\twhile(cin >> n && n!=0){\n\t\tset<int>st,st2;\n\t\tvector<int>x(n),y(n),r(n),c(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tfor(int i=0;i<30;i++){\n\t\t\tfor(int j=0;j<30;j++){\n\t\t\t\tlap[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(overlap(i,j,x,y,r)==1){\n\t\t\t\t\tlap[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tbool flag = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(lap[i][j]==0){\n\t\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\t\tif(lap[i][k]&&lap[j][k]){\n\t\t\t\t\t\t\t\tlap[i][j]=1;\n\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)break;\n\t\t}\n\t\t/*for(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tcout << i <<  \" \" << j << \" \" << lap[i][j] << endl;\n\t\t\t}\n\t\t}*/\n\n\t\tst.insert((1<<n)-1);\n\t\tst2.insert((1<<n)-1);\n\t\twhile(1){\n\t\t\tbool flag = 1;\n\t\t\tset<int> st3;\n\t\t\tfor(auto s:st2){\n\t\t\t\t//cout << static_cast<bitset<24>>(s) << endl;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\t\tif(c[i]==c[j]){\n\t\t\t\t\t\t\tif((s&(1<<i))&&(s&(1<<j))){\n\t\t\t\t\t\t\t\tbool fl =1;\n\t\t\t\t\t\t\t\tfor(int p=0;p<i;p++){\n\t\t\t\t\t\t\t\t\tif(lap[p][i]==1&&s&(1<<p))fl = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int p=0;p<j;p++){\n\t\t\t\t\t\t\t\t\tif(lap[p][j]==1&&s&(1<<p))fl = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(fl){\n\t\t\t\t\t\t\t\t\tst.insert(s-(1<<i)-(1<<j));\n\t\t\t\t\t\t\t\t\tst3.insert(s-(1<<i)-(1<<j));\n\t\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tst2 = st3;\n\t\t\tif(flag)break;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(auto s:st){\n\t\t\tint c = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(s&(1<<i)){\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans,n-c);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\nstruct E{\n\tvector<int> ov;\n\tint color;\n\tint x, y, r;\n\tE(int _x, int _y, int _r, int _c){\n\t\tcolor = _c;\n\t\tx = _x;\n\t\ty = _y;\n\t\tr = _r;\n\t}\n};\n\nbool dp[(1<<25)] = {0};\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tint x, y, r, c, _ans=0;\n\t\tvector<E> e;\n\t\tqueue<int> que;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tE tmp(x,y,r,c);\n\t\t\tfor(int j=0; j<e.size(); j++){\n\t\t\t\tif( (e[j].x-x)*(e[j].x-x) + (e[j].y-y)*(e[j].y-y) < (e[j].r+r)*(e[j].r+r) ){\n\t\t\t\t\ttmp.ov.push_back( j );\n\t\t\t\t}\n\t\t\t}\n\t\t\te.push_back( tmp );\n\t\t}\n\t\tfill(dp, dp+(1<<25), false);\n\t\tdp[0] = true;\n\t\tque.push(0);\n\t\twhile( !que.empty() ){\n\t\t\tint i = que.front();\n\t\t\tque.pop();\n\t\t\tif(dp[i]){\n\t\t\t//\tdp[i] = true;\n\t\t\t\t_ans = max(_ans,i);\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tfor(int l=0; l<n; l++){\n\t\t\t\t\t\tif( k != l && !(i&(1<<k)) && !(i&(1<<l)) && e[k].color == e[l].color){\n\t\t\t\t\t\t\tbool f=true;\n\t\t\t\t\t\t\tfor(int j=0; j<e[k].ov.size(); j++){\n\t\t\t\t\t\t\t\tif( !(i & (1<<e[k].ov[j])) ){\n\t\t\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int j=0; f&&j<e[l].ov.size(); j++){\n\t\t\t\t\t\t\t\tif( !(i & (1<<e[l].ov[j])) ){\n\t\t\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( f ){\n\t\t\t\t\t\t\t\tif( !dp[ i | (1<<k) | (1<<l) ] ){\n\t\t\t\t\t\t\t\t\tdp[ i | (1<<k) | (1<<l) ] = true;\n\t\t\t\t\t\t\t\t\tque.push( i | (1<<k) | (1<<l) );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=1; i<(1<<n); i<<=1){\n\t\t\tif( i & _ans )\n\t\t\t\tans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//And Then. How Many Are There?\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct C{\n  int c; //???\n  int x, y; //????????§?¨?\n  int r; //??????\n  C(){}\n  C(int x, int y, int r, int c){\n    this->x = x;\n    this->y = y;\n    this->r = r;\n    this->c = c;\n  }\n};\n\nint n;\nC data[24];\nint bit[24]; //??????????????¨???????????????\nint dp[1<<24];\n\n//a??¨b???????????????true\nbool dis(C a, C b){\n  return (((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y)) < (a.r+b.r)*(a.r+b.r));\n}\n\n//b:??????????????????????????¨???????????????\nint solve(int b){\n  if(b == (1<<n)-1)return 0;\n  if(dp[b]!=-1)return dp[b];\n\n  int mx=0;\n  for(int i=0; i<n-1; i++){//1???????????????\n    if(bit[i]&b != bit[i])continue;//??????????????????\n    if((b&(1<<i))!=0)continue;//??¢??????????????????\n   \n    for(int j=i+1; j<n; j++){//2???????????????\n      if(bit[j]&b != bit[j])continue;//??????????????????\n      if((b&(1<<j))!=0)continue;//??¢??????????????????\n      if(data[i].c != data[j].c)continue;//????????????\n\n      int tmp_b = (b|(1<<i))|(1<<j);\n      int tmp_mx = solve(tmp_b)+2;\n      if(mx<tmp_mx)mx=tmp_mx;\n    }\n  }\n  return dp[b]=mx;\n}\n\nint main(){\n  while(cin >> n, !(n==0)){\n    memset(bit, 0, sizeof(bit));\n    memset(dp, -1, sizeof(dp));\n    for(int i=0; i<n; i++){\n      int x, y, r, c;\n      cin >> x >> y >> r >> c;\n      C tmp(x, y, r, c);\n      data[i]=tmp;\n      for(int j=0; j<i; j++){\n\tif(dis(data[i], data[j]))bit[i] = bit[i]|(1<<j);\n      }\n    }\n    cout<<solve(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct state{\n    int x,y,r,c;\n};\n\nbool check(int x1,int y1,int r1,int x2,int y2,int r2){\n    if((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2) >= r1*r1+r2*r2){\n        return 0;\n    }\n    else return 1;\n}\n\nint memo[1<<24];\n\nint dp(vector<state>&v,int now){\n    if(memo[now]!=-1)return memo[now];\n    vector<int>ue(v.size(),0);\n    for(int i=0;i<v.size();++i){\n        for(int j=0;j<i;++j){\n            if(check(v[i].x,v[i].y,v[i].r,v[j].x,v[j].y,v[j].r)){\n                ue[i]++;\n            }\n        }\n    }\n    int ret=0;\n    for(int i=0;i<v.size();++i){\n        for(int j=i+1;j<v.size();++j){\n            if((now>>i)&1 && (now>>j)&1){\n                if(ue[i]==0 && ue[j]==0){\n                    ret=max(ret,dp(v,now-((1<<i)+(1<<j)))+2);\n                }\n            }\n        }\n    }\n    return memo[now]=ret;\n}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        for(int i=0;i<(1<<24);++i){\n            memo[i]=-1;\n        }\n        vector<state>v(n);\n        for(int i=0;i<n;++i){\n            int x,y,r,c;\n            v[i]={x,y,r,c};\n        }\n        dp(v,(1 << n)-1);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint main(){\n  int n;\n  cin >> n;\n  while(n!=0){\n    int sum=0;\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    int f=0;\n    int on[30]={};\n    //int cc[5]={};\n    vector<int> cc[5];\n    while(f==0){\n      f=1;\n      for(i=0;i<30;i++) on[i]=0;\n      for(i=0;i<v.size();i++){\n\tfor(j=i+1;j<v.size();j++){\n\t  if(ch(v[i],v[j])==1) on[j]=1;\n\t}\n      }\n      \n      for(i=0;i<5;i++) cc[i].clear();\n      for(i=0;i<v.size();i++){\n\tif(on[i]==0) cc[v[i].c].push_back(i);\n      }\n      \n      for(i=1;i<5;i++){\n\tif(cc[i].size()>0&&cc[i].size()%2==0){\n\t  for(j=cc[i].size()-1;j>=0;j--){\n\t    v.erase(v.begin()+cc[i][j]);\n\t    f=0;\n\t  }\n\t  break;\n\t}\n      }\n    }\n    cout << n-v.size() << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\n#define For(i,a,b)  for(int i = a;i < b;i++)\n#define rep(i,n)\tFor(i,0,n)\n#define all(n)\t\tn.begin(),n.end()\n\n//(x + a)^2 + (y + b)^2 <= c\n\nstruct Circle{\n\tint x, y, r;\n\tint c;\n\tCircle(){};\n\tCircle(int x, int y, int r, int c) :x(x), y(y), r(r), c(c){}\n\tint inter(Circle cl){\n\t\tint tx = cl.x, ty = cl.y;\n\t\tint t = (x - tx)*(x - tx) + (y - ty)*(y - ty);\n\t\tint R = (r + cl.r)*(r + cl.r);\n\t\tif (t < R)return 1;\n\t\tif (t >= R)return 0;\n\t}\n};\n\nint n;\nvector<Circle> v;\nmap<vector<bool>, int> ma;\n\nint dfs(vector<bool> cf){\n\n\tif (ma.count(cf)){\n\t\treturn ma[cf];\n\t}\n\n\tvector<int> tv[5];\n\trep(i, n)if(!cf[i]){\n\t\tbool tf = true;\n\t\tFor(j,i+1, n)if(!cf[j]){\n\t\t\tif (v[i].inter(v[j]) == 1){\n\t\t\t\ttf = false;\n\t\t\t}\n\t\t}\n\t\tif (tf){\n\t\t\ttv[v[i].c].push_back(i);\n\t\t}\n\t}\n\n\tint ret = 0;\n\tbool f = false;\n\n\trep(i, 5){\n\t\tif (tv[i].size() >= 2){\n\t\t\trep(j, tv[i].size()){\n\t\t\t\tFor(k, j + 1, tv[i].size()){\n\t\t\t\t\t auto tf = cf;\n\n\t\t\t\t\trep(l, v.size()){\n\t\t\t\t\t\tif (tv[i][j] == l || tv[i][k] == l)\n\t\t\t\t\t\t\ttf[l] = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tret = max(ret, dfs(tf));\n\t\t\t\t}\n\t\t\t}\n\t\t\tf = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!f){\n\t\tint cnt = 0;\n\t\trep(i, n){\n\t\t\tif (cf[i]){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\treturn ma[cf] = cnt;\n\t}\n\t\n\treturn ma[cf] = ret;\n}\n\n\nint main()\n{\n\n\twhile (cin >> n && n){\n\t\tma.clear();\n\t\trep(i, n){\n\t\t\tint x, y, r, c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tv.push_back(Circle(x, y, r, c));\n\t\t}\n\n\t\treverse(all(v));\n\n\t\tvector<bool> cf(n+1,0);\n\t\tcout << dfs(cf) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n        //!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //????????? == ??¨ != ????????´??????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //?????????????????????????????§??????????????????????????????????¨??????????????????????\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//?????£?????????????????¨?????????????§???¢?????´???????±???????\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//???????§???¢??????????????????????????¢??°??????????????????????????????????????\\????????????\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//????§???¢?????¢???\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//????§???¢?????¢???\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//???????§???¢?????????l??§??????????????????????§???¢?????°\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\nint n;\n\nbool isOver(Circle a, Circle b){\n    return abs(a.c - b.c) < a.r + b.r;\n}\n\nvoid canUse(Circle c[30], vector<bool> used, int color[30], vector<int> res[4]){\n    //show(\"canUse\")\n    rep(i,n){\n        if(used[i]) continue;\n        bool f = true;\n        range(j,0,i){\n            if(used[j]) continue;\n            if(isOver(c[i], c[j])){\n                f = false;\n                break;\n            }\n        }\n        if(f) res[color[i] - 1].emplace_back(i);\n    }\n}\n\nvoid requireCircleSet(vector<int> circles, int cur, vector<int> use, vector<vector<int>> &cs){\n    //show(\"requireCircleset\")\n    if(cur >= circles.size()){\n        if(use.size() >= 2) cs.emplace_back(use);\n        return;\n    }\n    requireCircleSet(circles, cur + 1, use, cs);\n    use.emplace_back(circles[cur]);\n    requireCircleSet(circles, cur + 1, use, cs);\n}\n\nint ans;\n\nvoid dfs(Circle c[30], int color[30], vector<bool> used){\n    //show(\"dfs\");\n    vector<int> use[4];\n    canUse(c,used,color,use);\n    //rep(i,4){\n    //    if(use[i].empty()) continue;\n    //    show(use[i].size())\n    //}\n\n    rep(i,4){\n        if(use[i].empty()) continue;\n        vector<int> _;\n        vector<vector<int>> circle_set;\n        requireCircleSet(use[i], 0, _, circle_set);\n        for(auto j:circle_set){\n            vector<bool> tmp = used;\n            for(auto k:j){\n                assert(not tmp[k]);\n                tmp[k] = true;\n            }\n            dfs(c, color, tmp);\n        }\n    }\n    int cnt = 0;\n    rep(i,n){ if(used[i]) cnt++; }\n    ans = max(ans, cnt);\n}\n\nint main(){\n    while(cin >> n,n){\n        Circle c[30];\n        int color[30];\n        ans = 0;\n        rep(i,n){\n            double x,y,r;\n            cin >> x >> y >> r >> color[i];\n            c[i] = {Point(x,y),r};\n        }\n        vector<bool> used(30,0);\n        dfs(c,color,used);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n;i++){\n        if(((bit>>i)&1)==0||ok(i,bit)==false)continue;\n        for(int j=i+1;j<n;j++){\n            \n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(((bit>>j)&1)==0||c[i]==c[j]&&ok(j,bit)&&!memo[to_bit]){\n                ret=max(ret,dfs(to_bit));\n            }\n        }\n    }\n\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\n\n\nint main(){\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct C {\n  int x, y, r, c;\n};\n\nint n;\nC c[24];\nint on[24];\nint T[1<<24];\n\nint isIntersect(C &a, C &b) {\n  int d1 = a.x - b.x;\n  int d2 = a.y - b.y;\n  int d3 = a.r + b.r;\n  if(d1*d1 + d2*d2 < d3*d3) return 2;\n  //if(d1*d1 + d2*d2 == d3*d3) return 1;\n  return 0;\n}\n\nint make() {\n  fill(on, on+n, 0);\n  for(int i = 0; i < n; ++i) {\n    for(int j = i+1; j < n; ++j) {\n      if(isIntersect(c[i], c[j])) {\n\ton[j] |= (1<<i);\n      }\n    }\n  }\n}\n\nint rec(int S) {\n  if(T[S] != -1) return T[S];\n  int res = 0;\n  for(int i = 0; i < n; ++i) {\n    if(S & (1<<i)) continue;\n    if(on[i] & S != on[i]) continue;\n    for(int j = i+1; j < n; ++j) {\n      if(S & (1<<j)) continue;\n      if(on[j] & S != on[j]) continue;\n      if(c[i].c != c[j].c) continue;\n      int nS = S;\n      nS |= (1<<i);\n      nS |= (1<<j);\n      res = max(res, rec(nS) + 2);\n    }\n  }\n  return T[S] = res;\n}\n\n\n\nint main() {\n  while((cin >> n) && n) {\n    for(int i = 0; i < n; ++i) {\n      cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n    }\n    make();\n    fill(T, T+(1<<n), -1);\n    cout << rec(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct cir {\n\tint x;\n\tint y;\n\tint r;\n\tint c;\n\tbool top;\n\tset<int> maue;\n};\n\nint main() {\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<cir> circle(n);\n\t\tREP(i, n) {\n\t\t\tcin >> circle[i].x >> circle[i].y >> circle[i].r >> circle[i].c;\n\t\t\tcircle[i].top = true;\n\t\t}\n\t\tREP(i, n / 2)\n\t\t\tswap(circle[i], circle[n - 1 - i]);\n\t\tREP(i, n) {\n\t\t\tREP(j, i) {\n\t\t\t\tif ((circle[i].x - circle[j].x)*(circle[i].x - circle[j].x) +\n\t\t\t\t\t(circle[i].y - circle[j].y)*(circle[i].y - circle[j].y) <\n\t\t\t\t\t(circle[i].r + circle[j].r)*(circle[i].r + circle[j].r)) {\n\t\t\t\t\tcircle[j].top = false;\n\t\t\t\t\tcircle[j].maue.insert(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tqueue<vector<cir>> qvc;\n\t\tqvc.push(circle);\n\t\twhile (!qvc.empty())\n\t\t{\n\t\t\tvector<cir> Q = qvc.front();qvc.pop();\n\t\t\tans = max(ans, n - (int)Q.size());\n\t\t\tFOR(i, 1, 5) {\n\t\t\t\tREP(j, Q.size()) {\n\t\t\t\t\tif (Q[j].top&&Q[j].c == i)\n\t\t\t\t\t\tFOR(k, j + 1, Q.size()) {\n\t\t\t\t\t\tif (Q[k].top&&Q[k].c == i) {\n\t\t\t\t\t\t\tvector<cir> Q2 = Q;\n\t\t\t\t\t\t\tREP(l, Q2.size())\n\t\t\t\t\t\t\t\tif (!Q2[l].maue.empty())\n\t\t\t\t\t\t\t\t\tif (EXIST(Q2[l].maue, j)) {\n\t\t\t\t\t\t\t\t\t\tQ2[l].maue.erase(j);\n\t\t\t\t\t\t\t\t\t\tif (Q2[l].maue.empty())\n\t\t\t\t\t\t\t\t\t\t\tQ2[l].top = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tREP(l, Q2.size())\n\t\t\t\t\t\t\t\tif (!Q2[l].maue.empty())\n\t\t\t\t\t\t\t\t\tif (EXIST(Q2[l].maue, k)) {\n\t\t\t\t\t\t\t\t\t\tQ2[l].maue.erase(k);\n\t\t\t\t\t\t\t\t\t\tif (Q2[l].maue.empty())\n\t\t\t\t\t\t\t\t\t\t\tQ2[l].top = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tQ2.erase(Q2.begin() + k);\n\t\t\t\t\t\t\tQ2.erase(Q2.begin() + j);\n\t\t\t\t\t\t\tqvc.push(Q2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct Disk{ int x,y,r,c; };\n\nint n;\nDisk D[24];\n\nint overlap[24];\n\nint dfs(int used){\n\tint nc[4]={},top[4][6];\n\trep(i,n) if((used&(1<<i))==0 && (overlap[i]&used)==overlap[i]) {\n\t\ttop[D[i].c][nc[D[i].c]++]=i;\n\t}\n\n\tint ans=0;\n\trep(c,4) rep(j,nc[c]) rep(i,j) {\n\t\tans=max(ans,dfs(used|(1<<top[c][i])|(1<<top[c][j]))+2);\n\t}\n\n\treturn ans;\n}\n\n#define sq(x) ((x)*(x))\n#define sqsum(x,y) (sq(x)+sq(y))\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\trep(i,n) scanf(\"%d%d%d%d\",&D[i].x,&D[i].y,&D[i].r,&D[i].c), D[i].c--;\n\n\t\trep(i,n){\n\t\t\toverlap[i]=0;\n\t\t\trep(j,i) if(sqsum(D[i].x-D[j].x,D[i].y-D[j].y)<sq(D[i].r+D[j].r)) {\n\t\t\t\toverlap[i]|=1<<j;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",dfs(0));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define mod 1000000007\n#define all(c) begin(c),end(c)\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nusing ll = long long;\nusing vi = vector<int>; using vs = vector<string>;\nint dd[] = { 0, 1, 0, -1, 0 }; //→↓←↑\n\n\n\nvoid solve()\n{\n\tint N;\n\twhile (cin >> N, N)\n\t{\n\t\tvector<int> x(N);\n\t\tvector<int> y(N);\n\t\tvector<int> r(N);\n\t\tvector<int> c(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\t\n\t\tvector<int> G[30];\n\t\t//vector<int> P(N);\n\t/*\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tP[i] = -1;\n\t\t}*/\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t{\n\t\t\t\tint xx = x[i] - x[j];\n\t\t\t\tint yy = y[i] - y[j];\n\t\t\t\tint rr = r[i] + r[j];\n\t\t\t\tif (xx * xx + yy * yy < rr * rr)\n\t\t\t\t{\n\t\t\t\t\tG[j].emplace_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> dp(1 << 24, 0);\n\t\tint ans = 0;\n\t\tvector<bool> ok(N, false);\n\t\tfor (int S = 0; S < 1 << N; S++)\n\t\t{\n\t\t\tif (S != 0 && dp[S] == 0)continue;\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t{\n\t\t\t\tif (S >> i & 1)continue;\n\t\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t\t{\n\t\t\t\t\tif (S >> j & 1)continue;\n\t\t\t\t\tif (c[i] != c[j])continue;\n\\\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\tfor (int v : G[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!ok[v]) {\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!flag)continue;\n\t\t\t\t\tfor (int v : G[j]) {\n\t\t\t\t\t\tif (!ok[v])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!flag)continue;\n\n\n\t\t\t\t\tchmax(dp[S | (1 << i) | (1 << j)], dp[S] + 2);\n\t\t\t\t\tchmax(ans, dp[S | (1 << i) | (1 << j)]);\n\t\t\t\t\tok[i] = true;\n\t\t\t\t\tok[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << dp[S] << endl;\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=(n);i<(int)(N);i++)\n#define ck(n,a,b) (a)<=(n)&&(n)<=(b)\n#define p(s) cout<<(s)<<endl\n#define F first\n#define S second\ntypedef long long ll;\nusing namespace std;\n\nstruct ST{\n\tint x, y, r, c;\n\tvector<int> up;\n};\nST enban[25];\nint n;\n\nint dfs(bool remove[]){\n\tvector<int> c[4];//enbango\n\n\tREP(i,0,n){\n\t\tbool ok=true;\n\t\tif(remove[i]) continue;\n\t\tfor(auto u: enban[i].up){\n\t\t\tif(!remove[u]){\n\t\t\t\tok=false;\n\t\t\t}\n\t\t}\n\t\tif(ok)c[enban[i].c].push_back(i);\n\t}\n\tbool flag=false;\n\tREP(j,0,4){\n\t\tif(c[j].size()%2) continue;\n\t\tfor(auto v:c[j]) {\n\t\t\tremove[v] = true;\n\t\t\tflag=true;\n\t\t}\n\t}\n\tint ret=0;\n\tif(flag) ret=dfs(remove);\n\tREP(i,0,4){\n\t\tif(c[i].size()==3||c[i].size()==5){\n\t\t\tbool tmp_remove[25];\n\t\t\tREP(j,0,n) tmp_remove[j] = remove[j];\n\t\t\tREP(j,0,c[i].size()){\n\t\t\t\tREP(k,0,c[i].size()){\n\t\t\t\t\ttmp_remove[c[i][k]]=true;\n\t\t\t\t}\n\t\t\t\ttmp_remove[c[i][j]]=false;\n\t\t\t\tret=max(ret,dfs(tmp_remove));\n\t\t\t}\n\t\t}\n\t}\n\treturn max<int>(ret,count(remove,remove+n,true));\n}\n\nint main() {\n\twhile(cin>>n, n){\n\n\t\tbool remove[25];\n\t\tREP(i, 0, 25) remove[i]=false;\n\t\tREP(i, 0, n){\n\t\t\tcin>>enban[i].x>>enban[i].y>>enban[i].r>>enban[i].c;\n\t\t\tenban[i].c--;\n\t\t\tenban[i].up.clear();\n\t\t}\n\n\t\t// ????????????????????????\n\t\tREP(i, 1, n){\n\t\t\tREP(j, 0, i){\n\t\t\t\tint r=(enban[i].x-enban[j].x)*(enban[i].x-enban[j].x)\n\t\t\t\t\t\t\t\t\t\t\t\t+ (enban[i].y-enban[j].y)*(enban[i].y-enban[j].y);\n\t\t\t\tint R=(enban[i].r+enban[j].r) * (enban[i].r+enban[j].r);\n\n\t\t\t\tif(r<R) enban[i].up.push_back(j);\n\t\t\t}\n\t\t}\n\t\t//REP(i,0,n){\n\t\t//cout<<enban[i].up.size()<<endl;\n\t\t//}\n\t\t// dfs\n\t\tp(dfs(remove));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#include<bitset>\n#include<random>\n#include<time.h>\n#include<fstream>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<(ll)m; i++)\n#define FOR(i,n,m) for(long long i=n; i<(ll)m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nmap<ll,ll> dp;\nvector<vector<ll>> co(4);\nvector<P> pos;\nvector<P> cir;\nvector<ll> mask;\nll dfs(ll bit) {\n\tif(dp.count(bit)) return dp[bit];\n\tll ret=0;\n\tbitset<32> bi(bit);\n\tREP(i,4) {\n\t\tREP(j,(ll)co[i].size()) {\n\t\t\tif(bi[co[i][j]]==0||(bit&mask[co[i][j]])!=0) continue;\n\t\t\tREP(k,j) {\n\t\t\t\tif(bi[co[i][k]]==0||(bit&mask[co[i][k]])!=0) continue;\n\t\t\t\tbi[co[i][j]]=0;\n\t\t\t\tbi[co[i][k]]=0;\n\t\t\t\tret=max(ret,2+dfs(bi.to_ullong()));\n\t\t\t\tbi[co[i][j]]=1;\n\t\t\t\tbi[co[i][k]]=1;\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[bit]=ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n==0) return 0;\n\t\tdp.erase(ALL(dp));\n\t\tREP(i,4) co[i].resize(0);\n\t\tpos.resize(n);\n\t\tcir.resize(n);\n\t\tmask.resize(n);\n\t\tREP(i,(1ll<<n)) dp[i]=-1;\n\t\tREP(i,n) {\n\t\t\tll x,y,r,c;\n\t\t\tcin>>x>>y>>r>>c;\n\t\t\tc--;\n\t\t\tpos[i]=P(x,y);\n\t\t\tcir[i]=P(r,c);\n\t\t}\n\t\tREP(i,n) co[cir[i].second].pb(i);\n\t\tREP(i,n) {\n\t\t\tbitset<32> bi(0);\n\t\t\tREP(j,i) {\n\t\t\t\tif((pos[i].first-pos[j].first)*(pos[i].first-pos[j].first)+(pos[i].second-pos[j].\tsecond)*(pos[i].second-pos[j].second)<(cir[i].first+cir[j].first)*(cir[i].first+cir[j].first)) {\n\t\t\t\t\tbi[j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmask[i]=bi.to_ullong();\n\t\t}\n\t\tcout<<dfs((1ll<<n)-1ll)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<algorithm>\nusing namespace std;\nstruct circle\n{\n    double x, y, r;\n    int c;\n}cc[30];\nint dp[(1<<24)];\nint n;\nbool intersect(int i, int j)\n{\n    double x1, y1, x2, y2;\n    double r1, r2;\n    x1 = cc[i].x, y1 = cc[i].y, r1 = cc[i].r;\n    x2 = cc[j].x, y2 = cc[j].y, r2 = cc[j].r;\n\n    if( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) >=  (r1+r2)*(r1+r2))\n    {\n        return false;\n\n    }//騾」蠢?キ夐聞>=蜊雁セ大柱?夂┌逶ク莠、\n    else\n        return true;\n\n}\nbool check(int a, int b, int state)\n{\n    if( ((1<<a-1)&state) == 0 || ((1<<b-1)&state) == 0 )\n    {\n        return false; //蟾イ邯楢「ォ諡ソ襍ー\n    }\n\n    if(cc[a].c != cc[b].c) return false; //鬘剰牡荳榊酔\n\n\n    int p[2];\n    p[0]=a, p[1]=b;\n\n    for(int k=0; k<2; k++)\n    {\n        int x =  (1<<p[k]-1)-1;  // n-p[k]+1蛟?  p[k]-1蛟?\n        if( (x&state) > 0)//state逧а[k]菴榊承驍頑怏1 ((p[k]蜿ッ閭ス陲ォ蜈カ莉也乢蟄占搭菴?        {\n            for(int i=1; i<=p[k]-1; i++)\n            {\n                int test = 1 << i-1;\n                if( (test&state) && intersect(p[k], i) )\n                {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\nint DP(int state)\n{\n    if(state==0) return 0;\n    if(dp[state]!=-1) return dp[state];\n\n    for(int i=1; i<n; i++)\n    {\n        for(int j=i+1; j<=n; j++)\n        {\n            if( check(i,j, state) )\n            {\n                int mask = (1<<i-1) | (1<<j-1);\n\n                dp[state^mask] = DP(state^mask);\n                if(dp[state^mask]+2 > dp[state])\n                    dp[state] = dp[state^mask]+2;\n            }\n        }\n    }\n    return dp[state]==-1? 0:dp[state];\n}\n\nint main()\n{\n\n    while(scanf(\"%d\",&n) && n)\n    {\n        for(int i=1; i<=n; i++)\n            scanf(\"%lf%lf%lf%d\",&cc[i].x, &cc[i].y, &cc[i].r, &cc[i].c);\n\n        int state = (1<<n)-1;\n        for(int i=0; i<=state; i++)\n            dp[i] = -1;\n\n        dp[state] = DP(state);\n\n        printf(\"%d\\n\",dp[state]);\n\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define show_bits(b, s) if(opt_debug) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\nbool opt_debug = false;\n\nclass Disk {\n\tprivate:\n\tpublic:\n\t\tint x, y, r, c;\n\t\tset<Disk*> upper_disks;\n\t\tset<Disk*> lower_disks;\n\n\t\tDisk(int _x, int _y, int _r, int _c) : x(_x), y(_y), r(_r), c(_c) {\n\t\t}\n\n\t\tbool overlap(const Disk rhs) {\n\t\t\treturn sqrt(pow(x - rhs.x, 2) + pow(y - rhs.y, 2)) + EPS < r + rhs.r;\n\t\t}\n};\nstd::ostream& operator<<(std::ostream &s, const Disk &d) {\n\ts << \"(\" << d.x << \", \" << d.y << \", \" << d.r << \", \" << d.c << \")\";\n\treturn s;\n}\n\nmap< vector<Disk*>, int > memo;\nint solve(vector<Disk*> forest) {\n\tif (forest.empty()) { return 0; }\n\tif (EXIST(memo, forest)) {\n\t\treturn memo[forest];\n\t}\n\n\tdprt(\"Forest:\\n\");\n\tREP (i, forest.size()) {\n\t\tdump(*forest[i]);\n\t}\n\n\tint ret = 0;\n\tREP (i, forest.size()) {\n\t\tFOR (j, i+1, forest.size()) {\n\t\t\tif (forest[i]->c != forest[j]->c) { continue; }\n\t\t\tdump(*forest[i]);\n\t\t\tdump(*forest[j]);\n\n\t\t\tDisk *a = forest[i], *b = forest[j];\n\t\t\tvector<Disk*> new_forest = forest;\n\t\t\tnew_forest.erase(find(ALL(new_forest), a));\n\t\t\tnew_forest.erase(find(ALL(new_forest), b));\n\n\t\t\tEACH (a->lower_disks, itr) {\n\t\t\t\tDisk *d = *itr;\n\t\t\t\td->upper_disks.erase(a);\n\t\t\t\tif (d->upper_disks.empty()) {\n\t\t\t\t\tnew_forest.PB(d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tEACH (b->lower_disks, itr) {\n\t\t\t\tDisk *d = *itr;\n\t\t\t\td->upper_disks.erase(b);\n\t\t\t\tif (d->upper_disks.empty()) {\n\t\t\t\t\tnew_forest.PB(d);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = max(ret, solve(new_forest) + 2);\n\n\t\t\tEACH (a->lower_disks, itr) {\n\t\t\t\tDisk *d = *itr;\n\t\t\t\td->upper_disks.insert(a);\n\t\t\t}\n\t\t\tEACH (b->lower_disks, itr) {\n\t\t\t\tDisk *d = *itr;\n\t\t\t\td->upper_disks.insert(b);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn memo[forest] = ret;\n}\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/0.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tint n;\n\twhile (cin >> n, n) {\n\t\tmemo.clear();\n\t\tvector<Disk*> disks;\n\t\tREP (i, n) {\n\t\t\tint x, y, r, c; cin >> x >> y >> r >> c;\n\t\t\tDisk *d = new Disk(x, y, r, c);\n\t\t\tEACH (disks, itr) {\n\t\t\t\tDisk *rhs = *itr;\n\t\t\t\tif (d->overlap(*rhs)) {\n\t\t\t\t\trhs->lower_disks.insert(d);\n\t\t\t\t\td->upper_disks.insert(rhs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdisks.PB(d);\n\t\t}\n\n\t\tvector<Disk*> forest;\n\t\tEACH (disks, itr) {\n\t\t\tDisk *d = *itr;\n\t\t\tif (d->upper_disks.empty()) {\n\t\t\t\tforest.PB(d);\n\t\t\t}\n\t\t}\n\n\t\tcout << solve(forest) << endl;\n\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n;i++){\n        if(((bit>>i)&1)==0||ok(i,bit)==false)continue;\n        for(int j=i+1;j<n;j++){\n            if(((bit>>j)&1)==0||ok(j,bit)==false)continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(c[i]==c[j]&&!memo[to_bit]){\n                ret=max(ret,dfs(to_bit));\n            }\n        }\n    }\n\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\n\n\nint main(){\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble tmp=c.r*c.r-norm(pr-c.c);\n\tif(abs(tmp)<EPS)tmp=0;\n\tdouble t=sqrt(tmp);\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nvi dp;\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<C>in;\n\t\tvi col(n);\n\t\trep(i,n){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tin.pb(C(P(a,b),c));\n\t\t\tcol[i]=d;\n\t\t}\n\t\tdp=vi(1<<n);\n\t\tdp[0]=1;\n\t\tqueue<int>que;\n\t\tque.push(0);\n\t\tint out=0;\n\t\twhile(!que.empty()){\n\t\t\tint t=que.front();\n\t\t\tque.pop();\n\t\t\tint co=0;\n\t\t\trep(i,n)if(t&1<<i)co++;\n\t\t\tout=max(out,co);\n\t\t\trep(i,n)if((t&1<<i)==0)loop(j,i+1,n)if((t&1<<j)==0&&col[i]==col[j]){\n\t\t\t\tbool h=true;\n\t\t\t\trep(k,i)if((t&1<<k)==0&&abs(in[k].c-in[i].c)<in[k].r+in[i].r)h=false;\n\t\t\t\trep(k,j)if((t&1<<k)==0&&abs(in[k].c-in[j].c)<in[k].r+in[j].r)h=false;\n//\t\t\t\tcout<<i<<\" \"<<j<<\" \"<<h<<endl;\n\t\t\t\tif(h){\n\t\t\t\t\tint nt=(t|1<<i)|1<<j;\n\t\t\t\t\tif(dp[nt]==0){\n\t\t\t\t\t\tque.push(nt);\n\t\t\t\t\t\tdp[nt]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\ntemplate <class T, class U>\ninline bool chmax(T& t, const U& f) { return t < f ? t = f, true : false; }\n\ntemplate <class T>\ninline T sqr(T&& x) { return x * x; }\n\nint solve(int n, vector<int>& c, vector<int>& on) {\n    vector<char> mem(1 << n, -1);\n    function<char(int)> dfs = [&](int table) {\n        char& t = mem[table];\n        if (t != -1) return t;\n        char T = __builtin_popcount(table);\n        t = 0;\n        for (int S = table; S > 0; S &= (S - 1)) {\n            int i = __builtin_ctz(S);\n            if (on[i]) continue;\n            for (int U = table & ~((1 << (i + 1)) - 1); U > 0; U &= (U - 1)) {\n                int j = __builtin_ctz(U);\n                if (on[j] or c[i] != c[j]) continue;\n                vector<int> nxt = on;\n                rep(k, n) nxt[k] &= ~(1 << i | 1 << j);\n                on.swap(nxt);\n                chmax(t, dfs(table ^ 1 << i ^ 1 << j) + 2);\n                on.swap(nxt);\n                if (T == t) return t;\n            }\n        }\n        return t;\n    };\n    return dfs((1 << n) - 1);\n}\n\nint main() {\n    for (int n; cin >> n, n;) {\n        vector<int> x(n), y(n), r(n), c(n), on(n);\n        rep(i, n) {\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n            rep(j, i) {\n                if (sqr(x[i] - x[j]) + sqr(y[i] - y[j]) >= sqr(r[i] + r[j])) continue;\n                rep(k, j) if (on[i] >> k & 1 and on[j] >> k & 1) on[i] ^= 1 << k;\n                on[i] |= 1 << j;\n            }\n        }\n        cout << solve(n, c, on) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<vector>\nstruct S{int c,f,x,y,r;}s[24];\nint A(int x){return x*x;}\nchar m[1<<24];\nint n,c[5];\nint F(int f)\n{\n\tif(m[f]>=0)return m[f];\n\tstd::vector<int>v[5];\n\tint i,j,k,r=0,t;\n\tfor(i=0;i<n;++i)\n\t\tif((f&(1<<i))&&!(s[i].f&f))\n\t\t\tv[s[i].c].push_back(i);\n\tfor(k=1;k<5;++k)\n\t{\n\t\tif(c[k]>0&&c[k]%2==0&&c[k]==v[k].size())\n\t\t{\n\t\t\tr+=c[k];\n\t\t\tc[k]=0;\n\t\t\tt=f;\n\t\t\tfor(i=0;i<v[k].size();++i)t^=(1<<v[k][i]);\n\t\t\tr+=F(t);\n\t\t\tc[k]=v[k].size();\n\t\t\treturn m[f]=r;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(i=0;i<v[k].size();++i)\n\t\t\t\tfor(j=i+1;j<v[k].size();++j)\n\t\t\t\t{\n\t\t\t\t\tc[k]-=2;\n\t\t\t\t\tr+=2+F(f&~(1<<v[k][i])&~(1<<v[k][j]));\n\t\t\t\t\tc[k]+=2;\n\t\t\t\t}\n\t\t}\n\t}\n\treturn m[f]=r;\n}\nint main()\n{\n\tint i,j;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tmemset(m,-1,sizeof(m));\n\t\tmemset(s,0,sizeof(s));\n\t\tmemset(c,0,sizeof(c));\n\t\tfor(i=0;i<n;++i)scanf(\"%d%d%d%d\",&s[i].x,&s[i].y,&s[i].r,&s[i].c),++c[s[i].c];\n\t\tfor(i=0;i<n;++i)\n\t\t\tfor(j=i+1;j<n;++j)\n\t\t\t\tif(A(s[i].x-s[j].x)+A(s[i].y-s[j].y)<A(s[i].r+s[j].r))\n\t\t\t\t\ts[j].f|=1<<i;\n\t\tprintf(\"%d\\n\",F((1<<n)-1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\nconst int dx[]={0,0,-1,1};\nconst int dy[]={-1,1,0,0};\n\nint x[25],y[25],r[25],c[25];\nint on[25];\n\nbool check(int i,int j){\n\tint d1=(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);\n\tint d2=(r[i]+r[j])*(r[i]+r[j]);\n\treturn d2>d1;\n}\n\nint main(){\n\t\n\tint n;\n\twhile(cin>>n,n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\t\ton[i]=0;\t\t\t\n\t\t}\n\t\t\n\t\t//j???????????????i???????????????????????£????????????\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(check(i,j)) on[j]|=(1<<i);\n\t\t\t}\n\t\t}\n\n\t\tvector<int> dp(1<<n,-1);\n\t\tdp[0]=0;\n\t\t\n\t\t//0:???????????????????????? 1:????????????????????????\n\t\tfor(int bit=0;bit<(1<<n);bit++){\n\t\t\tif(dp[bit] == -1) continue;\n\n\t\t\tfor(int i=0;i<n;i++){\n\n\t\t\t\t//??¢??????????????????????????? or ?????????????????????(on[i]???1????????¨bit???0??????????¢???£?????????)\n\t\t\t\tif(bit&(1<<i) || (bit&on[i])!=on[i]) continue;\n\t\t\t\t\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\tif(c[i]!=c[j] || bit&(1<<j) || (bit&on[j])!=on[j]) continue;\n\t\t\t\t\t\n\t\t\t\t\t//i??¨j????????????????????¶????????´??°\n\t\t\t\t\tint next=bit | (1<<i) | (1<<j);\n\t\t\t\t\tdp[next]=max(dp[next],dp[bit]+2);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<*max_element(dp.begin(),dp.end())<<endl;\n\t\t\n\t\t\n\t}\n\t\n\treturn 0;\n};"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst double EPS = 1e-10;\n\nint n, x[25], y[25], r[25], c[25];\n\nbool isConnected[25][25];\nbool isRemoved[25];\n\nint square(int x) { return x * x; }\n\nint dfs() {\n  bool isTop[25]; \n  int colorTop[4] = {0, 0, 0, 0};\n  for (int i = 0; i < n; i++) {\n    isTop[i] = false;\n    if (isRemoved[i]) continue;\n    bool flag = true;\n    for (int j = 0; j < i; j++) {\n      if (!isRemoved[j] && isConnected[i][j]) { flag = false; break; }\n    }\n    if (flag) {\n      isTop[i] = true;\n      colorTop[c[i]]++;\n    }\n  }\n  int ans = 0;\n  bool copy[25];\n  for (int i = 0; i < n; i++) copy[i] = isRemoved[i];\n  for (int i = 0; i < n; i++) if (isTop[i]) ans++, isRemoved[i] = true;\n  for (int i = 0; i < 4; i++) if (colorTop[i] % 2 == 1) ans--;\n  if (ans == 0) return 0;\n  int first = ans;\n  for (int c1 = 0; c1 < (colorTop[0] % 2 == 0 ? 1 : n); c1++) {\n    if (!isTop[c1]) continue;\n    if (colorTop[0] % 2 == 1 && c[c1] != 0) continue;\n    for (int c2 = 0; c2 < (colorTop[1] % 2 == 0 ? 1 : n); c2++) {\n      if (!isTop[c2]) continue;\n      if (colorTop[1] % 2 == 1 && c[c2] != 1) continue;\n      for (int c3 = 0; c3 < (colorTop[2] % 2 == 0 ? 1 : n); c3++) {\n        if (!isTop[c3]) continue;\n        if (colorTop[2] % 2 == 1 && c[c3] != 2) continue;\n        for (int c4 = 0; c4 < (colorTop[3] % 2 == 0 ? 1 : n); c4++) {\n          if (!isTop[c4]) continue;\n          if (colorTop[3] % 2 == 1 && c[c4] != 3) continue;\n          if (colorTop[0] % 2 == 1) isRemoved[c1] = false;\n          if (colorTop[1] % 2 == 1) isRemoved[c2] = false;\n          if (colorTop[2] % 2 == 1) isRemoved[c3] = false;\n          if (colorTop[3] % 2 == 1) isRemoved[c4] = false;\n          ans = max(ans, first + dfs());\n          if (colorTop[0] % 2 == 1) isRemoved[c1] = true;\n          if (colorTop[1] % 2 == 1) isRemoved[c2] = true;\n          if (colorTop[2] % 2 == 1) isRemoved[c3] = true;\n          if (colorTop[3] % 2 == 1) isRemoved[c4] = true;\n        }\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) isRemoved[i] = copy[i];\n  return ans;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) scanf(\"%d%d%d%d\", &x[i], &y[i], &r[i], &c[i]), c[i]--;\n    for (int i = 0; i < n; i++) isRemoved[i] = false;\n    for (int i = 0; i < n; i++) for (int j = 0; j < i; j++) {\n      int sum = square(x[i] - x[j]) + square(y[i] - y[j]);\n      if (sum < square(r[i] + r[j])) isConnected[i][j] = true;\n      else isConnected[i][j] = false;\n    }\n    printf(\"%d\\n\", dfs());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint N, X[24], Y[24], R[24], C[24];\nint r[24], m[24];\nchar dp[16777216];\n\nbool f(char n, int s) {\n  // cout << s << \" \" << (int) n << \" \" << r[n] << \" \" << m[n] << endl;\n  return ((s & r[n]) & m[n]) == 0;\n  // REP(i, 0, n) {\n  //   if(s & (1 << i)) continue;\n  //   if(r[n][i]) return false;\n  // }\n  // return true;\n}\n\nchar dfs(int s, char n) {\n  if(n == N) return N;\n\n  // cout << s << \" \" << (int) n << endl;\n\n  char ret = n;\n  REP(i, 0, N) {\n    int mi = (1 << i);\n    if((~s & mi) || !f(i, s)) continue;\n    REP(j, i + 1, N) {\n      int mj = (1 << j);\n      if(C[i] != C[j] || (~s & mj) || !f(j, s)) continue;\n      int ns = ~(~s | mi | mj);\n      if(dp[ns] >= 0) continue;\n      ret = max(ret, dfs(ns, n + 2));\n    }\n  }\n\n  return dp[s] = ret;\n}\n\nint main(void) {\n  m[0] = 0;\n  REP(i, 0, 23) m[i + 1] = m[i] | (1 << i);\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> X[i] >> Y[i] >> R[i] >> C[i];\n    REP(i, 0, pow(2, N)) dp[i] = -1;\n    REP(i, 0, N) r[i] = 0;\n    REP(i, 0, N) REP(j, 0, N) {\n      if(pow(R[i] + R[j], 2) > pow(X[i] - X[j], 2) + pow(Y[i] - Y[j], 2)) {\n        r[i] = r[i] | (1 << j);\n        r[j] = r[j] | (1 << i);\n      }\n    }\n    cout << (int) dfs((1 << N) - 1, 0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint n;\nVI xs, ys, rs, cs;\n//VI memo;\nmap<int, int> memo;\nVI memo2;\nVVI grp;\n\nbool is_top(int i, int used) {\n\tfor (int j = i - 1; j >= 0; j--) {\n\t\tif (1 << j & used) continue;\n\n\t\tint x = (xs[i] - xs[j]) * (xs[i] - xs[j]);\n\t\tint y = (ys[i] - ys[j]) * (ys[i] - ys[j]);\n\t\tint dis = x + y;\n\t\tint dis2 = (rs[i] + rs[j]) * (rs[i] + rs[j]);\n\n\t\tif (dis < dis2) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint dfs(int used) {\n\tint sum = 0;\n\n\tint flg = (1 << (n - 1) & used) ? 0 : 1;\n\n\tif (flg  && memo2[used] != -1) return memo2[used];\n\tif (!flg && memo.count(used)) return memo[used];\n\n\tfor(int i = 0;i < n;i++) {\n\t\tfor (auto j : grp[cs[i]]) {\n\t\t\tif(i == j || (1 << i & used) || (1 << j & used)) continue;\n\t\t\tif(cs[i] != cs[j]) continue;\n\t\t\tif(!is_top(i, used) || !is_top(j, used)) continue;\n\n\t\t\tint used_tmp = used;\n\t\t\tused_tmp |= 1 << i;\n\t\t\tused_tmp |= 1 << j;\n\n\t\t\tsum = max(sum, dfs(used_tmp) + 2);\n\t\t}\n\t}\n\n\treturn (flg ? memo2[used] : memo[used]) = sum;\n//\treturn sum;\n}\n\nint main(void) {\n\twhile(cin >> n, n){\n\t\txs = VI(n);\n\t\tys = VI(n);\n\t\trs = VI(n);\n\t\tcs = VI(n);\n\n\t\tgrp = VVI(4);\n\t\tmemo.clear();\n\t\tmemo2 = VI(1 << (n - 1), -1);\n\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n\t\t\tcs[i]--;\n\t\t\tgrp[cs[i]].push_back(i);\n\t\t}\n\n\t\tint used = 0;\n\t\tcout << dfs(used) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct enban {\n\tint x, y, r, c;\n};\n\nint N;\nenban ita[24];\nint dp[1 << 24];\n//若い番号の方が上になる[若い番号][大きい番号]\nbool iscovered[24][24];\n\nint main() {\n\n\twhile (1) {\n\n\t\tfor (int i = 0; i < (1 << 24); i++)dp[i] = -100;\n\t\tfor (int i = 0; i < 24; i++)for (int j = 0; j < 24; j++)iscovered[i][j] = false;\n\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> ita[i].x >> ita[i].y >> ita[i].r >> ita[i].c;\n\t\t}\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tif (pow(ita[i].x - ita[j].x, 2) + pow(ita[i].y - ita[j].y, 2) < pow(ita[i].r + ita[j].r, 2)) {\n\t\t\t\t\tiscovered[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdp[0] = 0;\n\n\t\tfor (int bit = 0; bit < (1 << N); bit++) {\n\t\t\tif (dp[bit] == -100)continue;\n\n\t\t\tbool cantuse[24] = {};\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\t//i枚目が使えるかどうか\n\t\t\t\tif ((bit >> i) & 1) {\n\t\t\t\t\tcantuse[i] = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (iscovered[j][i] && ((bit >> j) & 1) == 0) {\n\t\t\t\t\t\t//覆われていてかつ、覆ってるものがとられてない\n\t\t\t\t\t\tcantuse[i] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tvector<int> candidate[4];//4色それぞれの候補\n\t\t\tfor (int i = 0; i < N; i++)if (!cantuse[i])candidate[ita[i].c - 1].push_back(i);\n\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t//4色それぞれの候補を見る\n\t\t\t\tif (candidate[i].size() < 2)continue;\n\t\t\t\tfor (int j = 0; j < candidate[i].size(); j++) {\n\t\t\t\t\tfor (int k = j + 1; k < candidate[i].size(); k++) {\n\t\t\t\t\t\t//j番とk番を取り除く\n\t\t\t\t\t\tdp[bit + (1 << candidate[i][j]) + (1 << candidate[i][k])] = \n\t\t\t\t\t\t\tmax(dp[bit + (1 << candidate[i][j]) + (1 << candidate[i][k])], dp[bit] + 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int bit = 0; bit < (1 << N); bit++)ans = max(ans, dp[bit]);\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//9:55\n//10:15\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#define SQR(X) ((X)*(X))\n\nusing namespace std;\n\nint dp[1<<24];\nint x[24],y[24],r[24],c[24];\n\nint rem(int n,int s){\n  if(dp[s]!=-1)return dp[s];\n  bool under[24]={};\n  for(int i=0;i<n;i++){\n    if((s&(1<<i))==0){\n      for(int j=i+1;j<n;j++){\n\tif(SQR(x[i]-x[j])+SQR(y[i]-y[j])<SQR(r[i]+r[j])){\n\t  under[j]=true;\n\t}\n      }\n    }\n  }\n  int mr=0;\n  for(int i=0;i<n;i++){\n    if(((s&(1<<i))==0)&&!under[i]){\n      for(int j=i+1;j<n;j++){\n\tif(((s&(1<<j))==0)&&!under[j]&&c[i]==c[j]){\n\t  mr=max(mr,rem(n,s|(1<<i)|(1<<j))+2);\n\t}\n      }\n    }\n  }\n  dp[s]=mr;\n  return mr;\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    fill_n(dp,1<<n,-1);\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n    }\n    cout<<rem(n,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 30;\nint x[MAXN], y[MAXN], r[MAXN], c[MAXN];\nbool ok[MAXN];\nchar dp[1<<24];\n\nint square(int x) {return x*x;}\n\n// i, j ???????????£?????????????????????\n// ????????£????????? true\nbool check(int i, int j) {\n    int d2 = square(x[i]-x[j]) + square(y[i]-y[j]);\n    return d2 < square(r[i]+r[j]);\n}\n\nchar dfs(int state, int n) {\n    char& ret = dp[state];\n    if (ret >= 0) return ret;\n    ret = 0;\n    // ???????????¨??????????????§??????????????????????????????\n    vector<int> already;\n    memset(ok, true, sizeof(ok));\n    for (int i = 0; i < n; i++) {\n        if ((state>>i)&1) continue;\n        if (ok[i]) {\n            already.push_back(i);\n        }\n        for (int j = i+1; j < n; j++) {\n            if (check(i, j)) ok[j] = false;\n        }\n    }\n    int sz = already.size();\n    for (int i = 0; i < sz; i++) {\n        for (int j = i+1; j < sz; j++) {\n            int ai = already[i], aj = already[j];\n            if (c[ai] == c[aj]) {\n                int nstate = state;\n                nstate |= 1<<ai;\n                nstate |= 1<<aj;\n                ret = max<char>(2+dfs(nstate, n), ret);\n            }\n        }\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while (cin >> n) {\n        if (n==0) break;\n        for (int i = 0; i < n; i++) cin >> x[i] >> y[i] >> r[i] >> c[i];\n        memset(dp, -1, sizeof(dp));\n        cout << (int)dfs(0, n) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\ntypedef double D;\nconst D EPS = 1e-8;\n\nstruct P {\n    D x, y;\n    P(D x_, D y_) : x(x_), y(y_) { }\n    P() {}\n};\n\nP operator -(P a, P b) { return P(a.x - b.x, a.y - b.y); }\nD inp(P a, P b) { return a.x*b.x + a.y*b.y; }\nD norm(P p) { return inp(p, p); }\nD abs(P p) { return sqrt(norm(p)); }\n\nstruct C {\n    P p; D r;\n    C(P p_, D r_) : p(p_), r(r_) { }\n    C() { }\n};\n\nbool iCC(C a, C b) {\n    D d = abs(a.p - b.p);\n    return (a.r + b.r)  - EPS > d;\n}\n\nint bit_count(unsigned int b) {\n    return __builtin_popcount(b);\n}\n\nint bit_right(unsigned int b) {\n    return __builtin_ctz(b);\n}\n\nint bit_left(unsigned int b) {\n    return 31 - __builtin_clz(b);\n}\n\nint N;\nvector<int> color;\nvector<C> circle;\nvector<char> ok;\nint num;\nint ans;\n\n\nvoid solve() {\n    vector<vector<int> > v(4, vector<int>());\n    for(int i = 0; i < N; i++) {\n        if(ok[i]) {\n            bool fr = true;\n            for(int j = i + 1; j < N; j++) {\n                if(ok[j]) {\n                    if(iCC(circle[i], circle[j])) {\n                        fr = false;\n                        break;\n                    }\n                }\n            }\n            if(fr) {\n                v[color[i]].push_back(i);\n            }\n        }\n    }\n#if 0\n    for(int i = 0; i < 4; i++) {\n        cerr << \"color \" << i << \": \";\n        for(int j = 0; j < (int)v[i].size(); j++) {\n            cerr << v[i][j] << \" \";\n        }\n        cerr << endl;\n    }\n#endif\n    for(int i = 0; i < 4; i++) {\n        if(v[i].size() >= 2) {\n            for(int b = 0; b < (1 << v[i].size()); b++) {\n                if(bit_count(b) == 2) {\n                    int n = v[i][bit_right(b)];\n                    int m = v[i][bit_left(b)];\n                    ok[n] = 0;\n                    ok[m] = 0;\n                    num -= 2;\n                    ans = max(ans, N - num);\n                    solve();\n                    ok[n] = 1;\n                    ok[m] = 1;\n                    num += 2;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    for(; cin >> N, N; ) {\n        color = vector<int>(N);\n        circle = vector<C>(N);\n        ok = vector<char>(N, 1);\n        num = N;\n        ans = 0;\n        for(int i = 0; i < N; i++) {\n            cin >> circle[i].p.x >> circle[i].p.y >> circle[i].r >> color[i];\n            color[i]--;\n        }\n        reverse(circle.begin(), circle.end());\n        reverse(color.begin(), color.end());\n        solve();\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 30;\nint x[MAXN], y[MAXN], r[MAXN], c[MAXN];\nint dp[1<<24];\nbool ok[MAXN];\n\nint square(int x) {return x*x;}\n\n// i, j ???????????£?????????????????????\n// ????????£????????? true\nbool check(int i, int j) {\n    int d2 = square(x[i]-x[j]) + square(y[i]-y[j]);\n    return d2 < square(r[i]+r[j]);\n}\n\nint ans;\n\nvoid dfs(int state, int n) {\n    ans = max<int>(ans, __builtin_popcount(state));\n    // ???????????¨??????????????§??????????????????????????????\n    vector<int> already;\n    memset(ok, true, sizeof(ok));\n    for (int i = 0; i < n; i++) {\n        if ((state>>i)&1) continue;\n        if (ok[i]) {\n            already.push_back(i);\n        }\n        for (int j = i+1; j < n; j++) {\n            if (check(i, j)) ok[j] = false;\n        }\n    }\n    int sz = already.size();\n    for (int i = 0; i < sz; i++) {\n        for (int j = i+1; j < sz; j++) {\n            int ai = already[i], aj = already[j];\n            if (c[ai] == c[aj]) {\n                int nstate = state;\n                nstate |= 1<<ai;\n                nstate |= 1<<aj;\n                dfs(nstate, n);\n            }\n        }\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while (cin >> n) {\n        if (n==0) break;\n        for (int i = 0; i < n; i++) cin >> x[i] >> y[i] >> r[i] >> c[i];\n        ans = 0;\n        dfs(0, n);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint n;\nint x[25],y[25],r[25],c[25];\nint cover[25];\nbool check[1<<25];\nint cnt,comb,a,b;\nint m,ans;\nint u;\n\ndouble dis(int i,int j){\n  return sqrt( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j]) * (y[i]-y[j]) );\n}\n\nvoid cov(int a){\n  cover[a] = -1;\n  for(int j=a-1;j>=0;j--){\n    if(dis(a,j)<r[a]+r[j] && u>>j & 1){\n      cover[a] = j;\n      break;\n    }\n  }\n} \n\n  \nvoid rec(void){\n  int cnt;\n  for(int i=1;i<=4;i++){\n    cnt = 0;\n    for(int j=0;j<n;j++){\n      if( (u>>j & 1) && cover[j]<0 && c[j] == i)cnt++;\n    }\n    if(cnt==6){\n      for(int j=0;j<n;j++){\n\tif(c[j] == i)u -= 1<<j;\n      }\n      for(int j=0;j<n;j++)cov(j);\n\n      ans += 6;\n      m = max(m,ans);\n      rec();\n      ans -= 6;\n\n      for(int j=0;j<n;j++){\n\tif(c[j] == i)u += 1<<j;\n      }\n      for(int j=0;j<n;j++)cov(j);\n    }else{\n      for(int j=0;j<n;j++){\n\tif( (u>>j & 1) && cover[j]<0 && c[j] == i){\n\t  for(int k=j+1;k<n;k++){\n\t    if( (u>>k & 1) && cover[k]<0 && c[k] == i){\n\t      u -= 1<<j;\n\t      u -= 1<<k;\n\t      for(int l=0;l<n;l++)cov(l);\n\n\t      ans += 2;\n\t      m = max(m,ans);\n\t      //if(!check[u]){\n\t\trec();\n\t\t//check[u] = true;\n\t\t//}\n\t      ans -= 2;\n\n\t      u += 1<<j;\n\t      u += 1<<k;\n\t      for(int l=0;l<n;l++)cov(l);\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n}\n\n\n\nint main(){\n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    for(int i=0;i<n;i++)cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n    u = (1<<n) - 1;\n    //for(int i=0;i<(1<<n);i++)check[i] = false;\n    for(int i=0;i<n;i++)cov(i);\n\n    \n    m = 0;\n    ans = 0;\n    rec();\n\n    cout << m << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n\nusing namespace std;\n\n#define REP(i, x) for(int i=0;i<(int)(x);i++)\n#define REPS(i, x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i, x) for(int i=(int)(x)-1;i>=0;i--)\n#define RREPS(i, x) for(int i=(int)(x);i>0;i--)\n#define FOR(it, x) for(auto it=x.begin();it!=x.end();++it)\n#define pb push_back\n#define eb emplace_back\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\nint d[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v){\n        os << \"[\";\n        FOR(it, v) os << *it << \", \";\n        return os << \"]\";\n}\n\nint n;\nint g[30], x[30], y[30], r[30], c[30];\nint ans;\n\nint norm(int x, int y){\n        return x*x+y*y;\n}\n\nint main(){\n        while(cin >> n, n){\n                REP(i, n){\n                        cin >> x[i] >> y[i] >> r[i] >> c[i];\n                }\n                memset(g, 0, sizeof(g));\n                vector<pii> p;\n                REP(i, n)REP(j, i){\n                        if(norm(x[i]-x[j], y[i]-y[j]) < (r[i]+r[j])*(r[i]+r[j])) g[i] |= 1 << j;\n                        if(c[i] == c[j]) p.eb(j, i);\n                }\n                vector<unsigned char> dp(1<<n);\n                dp[0] = 1;\n                int ans = 0;\n                REP(i, 1<<n)if(dp[i]){\n                        FOR(it, p){\n                                int j = it->first, k = it->second;\n                                if((1&(i>>j)) || (1&(i>>k)) || (g[j]&~i) || (g[k]&~i)) continue;\n                                dp[i|(1<<j)|(1<<k)] = 1;\n                        }\n                        ans = max(ans, __builtin_popcount(i));\n                }\n                cout << ans << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <bitset>\n#include <map>\nusing namespace std;\n\ntypedef double D;\nconst double EPS = 1e-8;\n\nstruct P {\n  D x, y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\n\nstruct C {\n  P p;\n  D r;\n  C() { }\n  C(P p_, D r_) : p(p_), r(r_) { }\n  C(D x_, D y_, D r_) : p(x_, y_), r(r_) { }\n};\n\nint sig(double a, double b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\n\nbool iCC(C a, C b) {\n  D dx = a.p.x - b.p.x;\n  D dy = a.p.y - b.p.y;\n  D d2 = dx*dx + dy*dy;\n  return sig(d2, (a.r + b.r)*(a.r + b.r)) < 0;\n}\n\nint N;\nC circle[24];\nint color[24];\nbool overlap[24][24];\n\nmap<int, int> memo;\nint solve(int S) {\n  if(memo.count(S)) return memo[S];\n  int top = 0;\n  for(int i = 0; i < N; ++i) {\n    if(((S >> i) & 1) == 0) continue;\n    bool ok = true;\n    for(int j = 0; j < i; ++j) {\n      if(((S >> j) & 1) == 0) continue;\n      if(overlap[i][j]) {\n        ok = false;\n        break;\n      }\n    }\n    if(ok) {\n      top |= (1 << i);\n    }\n  }\n  int res = 0;\n  for(int i = 0; i < N; ++i) {\n    for(int j = i + 1; j < N; ++j) {\n      if(((top >> i) & 1) && ((top >> j) & 1) && color[i] == color[j]) {\n        int B = S;\n        B &= ~(1 << i);\n        B &= ~(1 << j);\n        res = max(res, 2 + solve(B));\n      }\n    }\n  }\n  return memo[S] = res;\n}\n\nint main() {\n  while(true) {\n    memo.clear();\n    cin >> N;\n    if(N == 0) break;\n    for(int i = 0; i < 24; ++i)\n      for(int j = 0; j < 24; ++j)\n        overlap[i][j] = false;\n    for(int i = 0; i < N; ++i) {\n      cin >> circle[i].p.x >> circle[i].p.y >> circle[i].r >> color[i];\n      color[i]--;\n    }\n    for(int i = 0; i < N; ++i) {\n      for(int j = 0; j < i; ++j) {\n        if(iCC(circle[i], circle[j])) {\n          overlap[i][j] = true;\n        }\n      }\n    }\n    cout << solve((1 << N) - 1 ) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nint N, X[24], Y[24], R[24], C[24];\nint no_coverd[24][1 << 24];\n\nbool isCoverd(int i, int j)\n{\n  int x = abs(X[i] - X[j]), y = abs(Y[i] - Y[j]), r = R[i] + R[j];\n  return ((x * x) + (y * y)) < (r * r);\n}\n\nbool noCoverd(int j, int s) {\n  for (int i = 0; i < j; i++)\n    if ( (s >> i & 1) && isCoverd(i, j))\n      return false;\n\n  return true;\n}\n\nchar memo[1 << 24];\nint dfs(int s)\n{\n  if (memo[s] != -1) {\n    return memo[s];\n  }\n  \n  int ans = 0;\n  for (int i = 0; i < N; i++) {\n    for (int j = i + 1; j < N; j++) {\n      if ( C[i] == C[j] && (s >> i & 1) && (s >> j & 1) &&\n           noCoverd(i, s) && noCoverd(j, s) ) {\n        ans = max(ans, dfs(s & ~(1 << i) & ~(1 << j)) + 2);\n      }\n    }\n  }\n  \n  return memo[s] = ans;\n}\n\n\nint main()\n{\n  while (cin >> N && N) {\n    for (int i = 0; i < N; i++) \n      cin >> X[i] >> Y[i] >> R[i] >> C[i];\n\n    memset(memo, -1, sizeof(memo));\n\n    cout << dfs((1 << N) - 1) << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\n#define x real()\n#define y imag()\n#define pb push_back \ntypedef double D;\ntypedef complex<D> P;\ntypedef struct circle{\n\tP p;\n\tD r;\n} C;\n\nint rel[24];\nC c[24];\nvector<int> color[4];\nint use[1<<24];\nint cmax;\n\nbool IC(C a,C b){\n\tD d=norm(a.p-b.p);\n\tD r=(a.r+b.r)*(a.r+b.r);\n\treturn d<r;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n, n){\n\t\tcmax=0;\n\t\tfor(int i=0;i<4;i++){\n\t\t\twhile(!color[i].empty())\n\t\t\t\tcolor[i].pop_back();\n\t\t}\n\t\tfor(int i=0;i<24;i++)\n\t\t\trel[i]=0;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tmp;\n\t\t\tcin >> c[i].p.x >> c[i].p.y >> c[i].r;\n\t\t\tcin >> tmp;\n\t\t\tcolor[tmp-1].pb(i);\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tif(IC(c[i],c[j]))\n\t\t\t\t\trel[i]|=1<<j;\n\t\t\t}\n\t\t}\t\t\n\t\tmemset(use,-1,sizeof(use));\n\t\tuse[0]=0;\n\t\tfor(int u=0;u<(1<<n);u++){\n\t\t\tif(use[u]==-1)\n\t\t\t\tcontinue;\n\t\t\tcmax=max(cmax,(int)use[u]);\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tfor(int j=0;j<color[i].size();j++){\n\t\t\t\t\tif(u >>color[i][j]&1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(rel[color[i][j]]&~u)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor(int k=j+1;k<color[i].size();k++){\n\t\t\t\t\t\tif(u >>color[i][k]&1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif(rel[color[i][k]]&~u)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tuse[u|(1<<color[i][j])|(1<<color[i][k])]=use[u]+2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cmax << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef unsigned int uint;\ntypedef vector<int> VI;\ntypedef vector<double> VD;\ntypedef vector<vector<int> > VV;\n \nconst int INF = 1 << 28;\nconst double EPS = 1e-9;\n \nint n;\nVV par;\nVD x, y, r;\nVI c;\nmap<int,int> m;\n \nstring toString (int era) {\n    string str;\n    for (int i = 0; i < n; i++) {\n        str = (era % 2 ? \"1\" : \"0\") + str;\n    }\n \n    return str;\n}\n \nint dfs (int era) {\n    if (era == ((1 << n) - 1)) return 0;\n    int cera = ((1 << n) - 1) ^ era;\n    if (m.find(cera) != m.end()) {\n        return m[cera];\n    }\n     \n    VV count(5);\n    rep (i,n) {\n        bool flag = true;\n        if (era & (1 << i)) continue; \n        rep(j,par[i].size()) {\n            if (cera & (1 << par[i][j])) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            count[c[i]].push_back(i);\n        }\n    }\n \n    int ret = 0;\n    REP(i,1,5) {\n        if (count[i].size() >= 2) {\n            rep(j,count[i].size()-1) REP(k,j+1,count[i].size()) {\n                int tera = era;\n                tera |= (1 << count[i][j]);\n                tera |= (1 << count[i][k]);\n                ret = max(ret, dfs(tera) + 2);\n            }\n        }\n    }\n \n    return m[cera] = ret;\n}\n \nint main()\n{\n    while (cin >> n, n) {\n        x.resize(n), y.resize(n), r.resize(n), c.resize(n);\n        m.clear();\n         \n        rep(i, n) {\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n         \n        par.clear();\n        par.resize(n);\n        rep(i,n) rep(j,i) {\n            double dis = pow(x[i] - x[j], 2.) + pow(y[i] - y[j], 2.);\n            if (sqrt(dis) < r[i] + r[j]) {\n                par[i].push_back(j);\n            }\n        }\n \n        cout << dfs(0) << endl;\n    }\n                 \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint N, X[30], Y[30], R[30], C[30];\n\nbool f(int n, int s) {\n  REP(i, 0, n) {\n    if(s & (1 << i)) continue;\n    if(pow(R[n] + R[i], 2) > pow(X[n] - X[i], 2) + pow(Y[n] - Y[i], 2)) return false;\n  }\n  return true;\n}\n\nint dfs(int s, int n) {\n  if(n == N) return N;\n\n  int ret = n;\n  REP(i, 0, N) {\n    if(s & (1 << i)) continue;\n    REP(j, i + 1, N) {\n      if(s & (1 << j)) continue;\n      if(C[i] != C[j]) continue;\n      if(!f(i, s) || !f(j, s)) continue;\n      ret = max(ret, dfs(s | (1 << i) | (1 << j), n + 2));\n    }\n  }\n\n  return ret;\n}\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> X[i] >> Y[i] >> R[i] >> C[i];\n    cout << dfs(0, 0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#define HIT(a,b) ((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r))\n\nusing namespace std;\n\nchar Log[90][30];\nint Logcnt;\n\nstruct DISK {\n\tint x,y,r,c,f;\n};\nint n;\n\nvoid setontop(DISK *D){\n\tint i,j;\n\tfor(i=0;i<n;i++){\n\t\tD[i].f=D[i].r;\n\t\tfor(j=i+1;j<n;j++)\n\t\t\tif(D[j].r && HIT(D[i],D[j])) D[i].f=0;\n\t}\n}\n\nint checkLog(DISK *D){\n\tint i,j;\n\tfor(i=0;i<Logcnt;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif((D[i].r && !Log[i][j]) || (!D[i].r && Log[i][j])) break;\n\t\t}\n\t\tif(j==n) return 1;\n\t}\n\treturn 0;\n}\n\nint solve(DISK *D){\n\tint i,j,k,min=30,ret;\n\tif(checkLog(D)) return 30;\n\tsetontop(D);\n\tfor(i=1;i<=4;i++){\n\t\tchar list[6],li=0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(D[j].f&&D[j].c==i) list[li++]=j;\n\t\t}\n\t\tif(li<2)continue;\n\t\tDISK tmp[30];\n\t\tfor(j=0;j<li;j++){\n\t\t\tfor(k=j+1;k<li;k++){\n\t\t\t\tmemcpy(tmp,D,sizeof(tmp));\n\t\t\t\ttmp[list[j]].r=0;\n\t\t\t\ttmp[list[k]].r=0;\n\t\t\t\tret=solve(tmp);\n\t\t\t\tif(ret<min)min=ret;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ret=0,i=0;i<n;i++)if(D[i].r)ret++;\n\tif(ret<min)min=ret;\n\treturn min;\n}\n\nint main(){\n\tint i,j;\n\twhile(cin>>n,n){\n\t\tDISK D[30];\n\t\tLogcnt=0;\n\t\tfor(i=n;i-->0;) cin>>D[i].x>>D[i].y>>D[i].r>>D[i].c;\n\t\tcout<<n-solve(D)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 24;\n\nint n, x[N], y[N], r[N], c[N], p[N];\n//bool vis[1<<N];\n\nbool lap(int a, int b){\n  int d = (x[a] - x[b]) * (x[a] - x[b]) + (y[a] - y[b]) * (y[a] - y[b]);\n  return d < r[a] * r[a] + 2 * r[a] * r[b] + r[b] * r[b];\n}\n\nint rec(int s){\n  int res = 0;\n  //vis[s] = true;\n  for(int i=0;i<n;i++){\n    if((s >> i & 1) == 0) continue;\n    for(int j=i+1;j<n;j++){\n      if((s >> j & 1) == 0) continue;\n      if(c[i] != c[j]) continue;\n      if((p[i] & s) == 0 && (p[j] & s) == 0){\n        s &= ~(1 << i);\n        if((p[j] & s) == 0){\n          s &= ~(1 << j);\n          //if(!vis[s]) \n            res = max(res, rec(s));\n          s |= 1 << j;\n        }\n        s |= 1 << i;\n      }\n    }\n  }\n  if(s == (1 << n) - 1) return res;\n  return res + 2;\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++) cin >> x[i] >> y[i] >> r[i] >> c[i];\n    fill(p, p+n, 0);\n    //fill(vis, vis+(1<<n), false);\n    for(int i=0;i<n;i++) for(int j=0;j<i;j++) if(lap(i, j)) p[i] |= 1 << j;\n    cout << rec((1<<n)-1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#include<bitset>\n#include<random>\n#include<time.h>\n#include<fstream>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<(ll)m; i++)\n#define FOR(i,n,m) for(long long i=n; i<(ll)m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nmap<int,int> dp;\nvector<vector<int>> co(4);\nvector<pair<int,int>> pos;\nvector<pair<int,int>> cir;\nvector<int> mask;\nll dfs(int bit) {\n\tif(dp.count(bit)) return dp[bit];\n\tint ret=0;\n\tbitset<32> bi(bit);\n\tREP(i,4) {\n\t\tREP(j,(ll)co[i].size()) {\n\t\t\tif(bi[co[i][j]]==0||(bit&mask[co[i][j]])!=0) continue;\n\t\t\tREP(k,j) {\n\t\t\t\tif(bi[co[i][k]]==0||(bit&mask[co[i][k]])!=0) continue;\n\t\t\t\tbi[co[i][j]]=0;\n\t\t\t\tbi[co[i][k]]=0;\n\t\t\t\tret=max((ll)ret,2+dfs(bi.to_ullong()));\n\t\t\t\tbi[co[i][j]]=1;\n\t\t\t\tbi[co[i][k]]=1;\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[bit]=ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n==0) return 0;\n\t\tdp.erase(ALL(dp));\n\t\tREP(i,4) co[i].resize(0);\n\t\tpos.resize(n);\n\t\tcir.resize(n);\n\t\tmask.resize(n);\n\t\tREP(i,(1ll<<n)) dp[i]=-1;\n\t\tREP(i,n) {\n\t\t\tll x,y,r,c;\n\t\t\tcin>>x>>y>>r>>c;\n\t\t\tc--;\n\t\t\tpos[i]=P(x,y);\n\t\t\tcir[i]=P(r,c);\n\t\t}\n\t\tREP(i,n) co[cir[i].second].pb(i);\n\t\tREP(i,n) {\n\t\t\tbitset<32> bi(0);\n\t\t\tREP(j,i) {\n\t\t\t\tif((pos[i].first-pos[j].first)*(pos[i].first-pos[j].first)+(pos[i].second-pos[j].\tsecond)*(pos[i].second-pos[j].second)<(cir[i].first+cir[j].first)*(cir[i].first+cir[j].first)) {\n\t\t\t\t\tbi[j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmask[i]=bi.to_ullong();\n\t\t}\n\t\tcout<<dfs((1ll<<n)-1ll)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nstruct Data\n{\n    int x;\n    int y;\n    int r;\n    int c;\n};\n\ntypedef struct Data D;\n\nmap<string, char> m;\nvector<D> input;\n\nint solve(string now)\n{\n    // cout << now << endl;\n    // cout << (m.find(now) == m.end()) << endl;\n    if(m.find(now) != m.end()) return m[now];\n    // cout << \"hey\" << endl;\n    m[now] = 0;\n    vector<vector<int> >  colornum(5);\n    // cout << \"ho\" << n << endl;\n    for(int i = 0; i < input.size(); i++){\n        if(now[i] == '0') continue;\n        bool notcovered = true;\n        // cout << i << \" : \" << input[i].x << \" \" << input[i].y << \" \" << input[i].r << \" \" << input[i].c << endl;\n        for(int j = 0; j < i; j++){\n            if(now[j] == '0') continue;\n            // cout << i << \",\" << j << \":\" << pow(input[i].x - input[j].x, 2) + pow(input[i].y - input[j].y, 2) << \" \" << pow(input[i].r + input[j].r, 2) << endl;\n            if(pow(input[i].x - input[j].x, 2) + pow(input[i].y - input[j].y, 2) < pow(input[i].r + input[j].r, 2)){\n                notcovered = false;\n                break;\n            }\n        }\n        if(notcovered) colornum[input[i].c].push_back(i);\n    }\n    for(int i = 1; i < 5; i++){\n        // cout << \"colornumsize \" << colornum[i].size() << endl;\n        if(colornum[i].size() > 1){\n            for(int j = 0; j < colornum[i].size(); j++){\n                for(int k = j + 1; k < colornum[i].size(); k++){\n                    string newinput = \"\";\n                    for(int l = 0; l < input.size(); l++){\n                        if(now[l] == '0' || l == colornum[i][j] || l == colornum[i][k]) newinput += \"0\";\n                        else newinput += \"1\";\n                    }\n                    // cout << newinput << endl;\n                    m[now] = max((int)m[now], solve(newinput) + 2);   \n                }\n            }\n        }\n    }\n    return m[now];\n}\n\n\n\nint main()\n{\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        input.clear();\n        m.clear();\n        for(int i = 0; i < n; i++){\n            D tmpd;\n            cin >> tmpd.x >> tmpd.y >> tmpd.r >> tmpd.c;\n            input.push_back(tmpd);\n        }\n        string start = \"\";\n        for(int i = 0; i < n; i++){\n            start += \"1\";\n        }\n        cout << solve(start) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\nint main() {\n    int n;\n    while(cin >> n, n){\n        vector<bool> dp(1<<n);\n        vector<int> x(n), y(n), r(n), c(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n        dp.back() = true;\n        int ans = 0;\n        for (int mask = (1<<n)-1; mask >= 0; --mask) {\n            if(!dp[mask]) continue;\n            ans = max(ans, n-__builtin_popcount(mask));\n            for (int i = 0; i < n; ++i) {\n                if(!(mask & (1<<i))) continue;\n                bool ok = true;\n                for (int j = 0; j < i; ++j) {\n                    if(mask & (1<<j)){\n                        if((x[j]-x[i])*(x[j]-x[i]) + (y[j]-y[i])*(y[j]-y[i]) < (r[i]+r[j])*(r[i]+r[j])) ok = false;\n                    }\n                }\n                if(!ok) continue;\n                for (int j = 0; j < n; ++j) {\n                    if(!(mask & (1<<j))) continue;\n                    if(c[i] != c[j]) continue;\n                    if(i == j) continue;\n                    int to = mask ^ (1<<i) ^ (1<<j);\n                    for (int k = 0; k < j; ++k) {\n                        if(mask & (1<<k)){\n                            if((x[k]-x[j])*(x[k]-x[j])+(y[k]-y[j])*(y[k]-y[j]) < (r[k]+r[j])*(r[k]+r[j])) ok = false;\n                        }\n                    }\n                    if(!ok) continue;\n                    dp[to] = true;\n                }\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint N;\nint x[32], y[32], r[32], c[32];\nchar dp[1<<24];\n\nint C(int u, int v){\n  return (SQ(x[u]-x[v])+SQ(y[u]-y[v])) >= SQ(r[u]+r[v]);\n}\n\nint dfs(int bit){\n  int res = 0;\n  vector<int>v;\n  for(int i=0;i<N;i++){\n    if(!((bit>>i)&1)) continue;\n    int f = 1;\n    for(int j=0;j<i;j++) if((bit>>j)&1) f &= C(i, j);\n    if(f) v.push_back(i);\n  }\n\n  rep(i, v.size()) for(int j=i+1;j<v.size();j++){\n    if(c[v[i]] == c[v[j]]) res = max(res, dfs(bit ^ (1<<v[i]) ^ (1<<v[j]))+2);\n  }\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d\", &N) && N){\n    rep(i,N) scanf(\"%d%d%d%d\", x+i, y+i,r+i,c+i);\n    printf(\"%d\\n\", dfs((1<<N)-1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nchar dp[1 << 24];\nint main() {\n    int n;\n    while (cin >> n, n) {\n        memset(dp, -1, sizeof(dp));\n        int x[n], y[n], r[n], c[n];\n        int b[25] = {};\n        for (int i = 0; i < n; i++) {\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n            for (int j = 0; j < i; j++) {\n                int dx = x[i] - x[j];\n                int dy = y[i] - y[j];\n                int dr = r[i] + r[j];\n                if (dx * dx + dy * dy < dr * dr) {\n                    b[i] |= (1 << j);\n                }\n            }\n        }\n        int ans = -1;\n        dp[0] = 0;\n        for (int bit = 0; bit < 1 << n; bit++) {\n            if (dp[bit] == -1) continue;\n            ans = max(ans, (int)dp[bit]);\n            for (int i = 0; i < n; i++) {\n                if ((bit >> i & 1) != 0 || (bit & b[i]) != b[i]) continue;\n                for (int j = i + 1; j < n; j++) {\n                    if ((bit >> j & 1) != 0 || (bit & b[j]) != b[j]) continue;\n                    if (c[i] != c[j]) continue;\n                    int nx = bit | (1 << i) | (1 << j);\n                    dp[nx] = max((int)dp[nx], dp[bit] + 2);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n\nuint8_t DP[1<<24];//LSB???i=0?????????\n\nint main(){\n    int n;\n    int X[24];\n    int Y[24];\n    int R[24];\n    int C[24];\n    int cover[24];//???????????????????????????\n    while(cin>>n,n){\n        for(int i=0;i<n;i++){\n            cin>>X[i]>>Y[i]>>R[i]>>C[i];            \n        }\n        fill(cover,cover+24,0);\n        for(int i=0;i<n;i++){//i???j???????????????????????????\n            for(int j=i+1;j<n;j++){\n                if(hypot(X[i]-X[j],Y[i]-Y[j])<R[i]+R[j]){\n                    cover[j]|=1<<i;\n                }\n            }\n        }\n        fill(DP,DP+(1<<24),0);\n        for(int E=0;E<(1<<n);E++){\n            for(int i=0;i<n;i++){\n                if((E&(1<<i))==0) continue;\n                for(int j=i+1;j<n;j++){\n                    if((E&(1<<j))==0) continue;\n                    if(cover[j]&E) continue;\n                    if(C[i]==C[j]&&DP[E]<DP[E^(1<<i)^(1<<j)]+2){\n                        DP[E]=DP[E^(1<<i)^(1<<j)]+2;\n                    }\n                }\n            }\n        }\n        cout<<(int)DP[(1<<n)-1]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <set>\n#include <map>\n#include <string>\nusing namespace std;\n\n#define For(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define Rep(i,n) For(i,0,n)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\n\n#define INF 1000000000\n\n#define MAX_N 24\n\nstruct disk{\n\tint x, y, r, c;\n\tdisk(int a, int b, int c, int d):x(a),y(b),r(c),c(d){}\n};\n\nint N;\nchar mem[1<<MAX_N];\nvector<disk> D;\n\nbool is_top(int k, int b){\n\tRep(i,k) if((b&(1<<i)) == 0 && ((D[i].x-D[k].x)*(D[i].x-D[k].x)+(D[i].y-D[k].y)*(D[i].y-D[k].y) < (D[i].r+D[k].r)*(D[i].r+D[k].r))) return false;\n\treturn true;\n}\n\nint dfs(int b){\n\tif(mem[b] != -1) return mem[b];\n\tint res = -1;\n\tRep(i,N)For(j,i+1,N){\n\t\tif((b&(1<<i)) == 0 && (b&(1<<j)) == 0){\n\t\t\tif(D[i].c == D[j].c && is_top(i, b) && is_top(j, b)) res = max(dfs(b|(1<<i)|(1<<j)), res);\n\t\t}\n\t}\n\tif(res != -1) return mem[b] = res+2;\n\telse return mem[b] = 0;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\tD.clear();\n\t\tRep(i,N){\n\t\t\tint x, y, r, c;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &r, &c);\n\t\t\tD.pb(disk(x, y, r, c));\n\t\t}\n\t\tRep(i,1<<N) mem[i] = -1;\n\t\tprintf(\"%d\\n\", dfs(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\nchar bit_count[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n-bit_count[bit];\n\n    for(int i=0;i<n;i++){\n        if(((bit>>i)&1)==0||ok(i,bit)==false)continue;\n        for(int j=i+1;j<n;j++){\n            if((bit>>j)&1)==0||ok(j,bit)==false||c[i]!=c[j])continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(!memo[to_bit])ret=max(ret,dfs(to_bit));\n\n        }\n    }\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\nvoid init(){\n    for(int i=0;i<(1<<24);i++){\n        for(int j=0;j<24;j++)if((i>>j)&1){\n            bit_count[i]++;\n        }\n    }\n}\n\nint main(){\n    init();\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define EPS 1e-9\n\nclass circle {\npublic:\n  int c;\n  double x, y, r;\n  circle(double tx, double ty, double tr, int tc) {\n    x = tx;\n    y = ty;\n    r = tr;\n    c = tc;\n  }\n};\n\nvector <circle> tempCirc;\n\nbool collision(circle c1, circle c2) {\n  return c1.r+c2.r-hypot(c1.x-c2.x, c1.y-c2.y) >= EPS;\n}\n\nchar memo[(2<<24)+1];\nint rec(int x) {\n  int n = tempCirc.size();\n  vector <int> field[n];\n\n  if (memo[x] != -1) return memo[x];\n  int ret = 0;\n  for (int i = n-1; i >= 0; i--) {\n    if (! ((x>>i)&1) ) continue;\n    for (int j = i-1; j >= 0; j--) {\n      if (! ((x>>j)&1) ) continue;\n      if (collision(tempCirc[i], tempCirc[j])) {\n\tfield[i].push_back(j);\n      }\n    }\n  }\n\n  vector <int> list;\n  for (int i = 0; i < n; i++) {\n    if (field[i].size() == 0) list.push_back(i);\n  }\n\n  for (int i = 0; i < list.size(); i++) {\n    for (int j = i+1; j < list.size(); j++) {\n      if (! (x&(1<<list[i])) ) continue;\n      if (! (x&(1<<list[j])) ) continue;\n      if (tempCirc[list[i]].c != tempCirc[list[j]].c) continue;\n      ret = max(ret, rec(x^(1<<list[i])^(1<<list[j]))+2 );\n    }\n  }\n\n\n  return memo[x] = ret;\n}\n\nint main() {\n  int n;\n  while(true) {\n    cin >> n;\n    if (n == 0) break;\n    vector <circle> circ;\n    for (int i = 0; i < n; i++) {\n      int c;\n      double x, y, r;\n      cin >> x >> y >> r >> c;\n      circ.push_back(circle(x, y, r, c));\n    }\n    tempCirc = circ;\n\n    memset(memo, -1, sizeof(memo));\n    std::cout << rec((1<<n)-1) << std::endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n;\nint x[111],y[111],r[111],c[111];\nbool used[111];\nchar mem[1<<24];\n\nbool judge(int i,int j){\n\tbool ok=true;\n\trep(k,i){\n\t\tif(used[k])continue;\n\t\tif(pow(x[i]-x[k],2)+pow(y[i]-y[k],2)<pow(r[i]+r[k],2))ok=false;\n\t}\n\trep(k,j){\n\t\tif(used[k])continue;\n\t\tif(pow(x[k]-x[j],2)+pow(y[k]-y[j],2)<pow(r[k]+r[j],2))ok=false;\n\t}\n\treturn ok;\n}\n\nint dfs(int v){\n\tif(mem[v]!=-1)return mem[v];\n\tint res=0;\n\trep(i,n)repl(j,i+1,n){\n\t\tif(!used[i]&&!used[j]&&c[i]==c[j]&&judge(i,j)){\n\t\t\tused[i]=used[j]=true;\n\t\t\tmaxch(res,dfs(v|(1<<i)|(1<<j))+2);\n\t\t\tused[i]=used[j]=false;\n\t\t}\n\t}\n\treturn mem[v]=res;\n}\n\nint main(){\n\t//cin.sync_with_stdio(false);\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\trep(i,n)scanf(\"%d%d%d%d\",x+i,y+i,r+i,c+i);\n\t\tmemset(used,0,sizeof(used));\n\t\tmemset(mem,-1,sizeof(mem));\n\t\tcout<<dfs(0)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint n;\nint x[24],y[24],c[24],r[24];\nbool memo[1<<24];\nint hit(int i,int j){\n\tint L = r[i]*r[i] + r[j]*r[j] + 2 * r[i] * r[j];\n\tint X = (x[i]-x[j])*(x[i]-x[j]);\n\tint Y = (y[i]-y[j])*(y[i]-y[j]);\n\treturn X + Y < L;\n}\nint nocover(int n,int bit){\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( (bit>>i&1) && hit(i,n) ) return false;\n\t}\n\treturn true;\n}\nint ans;\nvoid dfs(int bit){\n\tans = min(ans,__builtin_popcount(bit));\n\tif(memo[bit]) return;\n\telse memo[bit] = true;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tfor(int j = i+1 ; j < n ; j++){\n\t\t\tif( (bit >> j & 1) && (bit >> i & 1) && c[i] == c[j] && nocover(i,bit) && nocover(j,bit) ){\n\t\t\t\tdfs( bit - (1<<j) - (1<<i) );\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nint main(){\n\twhile(cin >> n , n){\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tans = n;\n\t\tmemset(memo,0,sizeof(memo));\n\t\tdfs((1<<n)-1);\n\t\tcout << n-ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint N;\nint r[24], x[24], y[24], c[24];\nvector<int> ue;\n\nshort dp[1 << 24];\nint xx(int x) { return x * x; }\nshort _dp(int k) {\n\tif (k == 0) return 0;\n\tif (dp[k] >= 0) return dp[k];\n\n\tvector<int> w;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif ( (k & (1 << i)) && (k & ue[i]) == 0 ) w.push_back(i);\n\t}\n\tshort ret = 0;\n\tfor (int i = 0; i < w.size(); ++i) {\n\t\tfor (int j = i+1; j < w.size(); ++j) {\n\t\t\tif (c[w[i]] == c[w[j]]) {\n\t\t\t\tret = max<short>(ret, _dp(k ^ (1 << w[i]) ^ (1 << w[j]))+2);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[k] = ret;\n}\nint main() {\n\twhile (cin >> N, N) {\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\n\t\tbool f[24][24] = {0};\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\tif (xx(x[i]-x[j]) + xx(y[i]-y[j]) < xx(r[i]+r[j])) {\n\t\t\t\t\tf[j][i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tue.clear();\n\t\tue.resize(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint b = 0;\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (f[i][j]) b |= (1 << j);\n\t\t\t}\n\t\t\tue[i] = b;\n\t\t}\n\n\t\tfill(&dp[0], &dp[0]+(1<<24), -1);\n\t\tcout << (int)_dp((1 << N) - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, x[26], y[26], r[26], col[26], b[26][26]; short dp[16777222];\nint solve(int bit) {\n\tif (dp[bit]) return dp[bit] - 1;\n\tint ret = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (col[i] != col[j]) continue;\n\t\t\tif ((bit & b[i][j]) == b[i][j]) {\n\t\t\t\tint res = solve(bit + (1 << i) + (1 << j));\n\t\t\t\tret = max(ret, res + 2);\n\t\t\t}\n\t\t}\n\t}\n\tdp[bit] = ret + 1;\n\treturn ret;\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i] >> r[i] >> col[i];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tb[i][j] = 0;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tint disti = (x[k] - x[i]) * (x[k] - x[i]) + (y[k] - y[i]) * (y[k] - y[i]);\n\t\t\t\t\tint distj = (x[k] - x[j]) * (x[k] - x[j]) + (y[k] - y[j]) * (y[k] - y[j]);\n\t\t\t\t\tif (k < i && disti < (r[i] + r[k]) * (r[i] + r[k])) b[i][j] |= 1 << k;\n\t\t\t\t\tif (k < j && distj < (r[j] + r[k]) * (r[j] + r[k])) b[i][j] |= 1 << k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfill(dp, dp + (1 << n), 0);\n\t\tint ret = solve(0);\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cassert>\n\nusing namespace std;\nint N;\n\nstruct Disk {\n  int x;\n  int y;\n  int r;\n  int c;\n  Disk(int x, int y, int r, int c) : x(x), y(y), r(r), c(c) {}\n};\n\nint tree[30];\nchar dp[1 << 24];\n\nvector<Disk> disk_list;\n\ndouble dist(int x1, int y1, int x2, int y2) {\n  int dx = x1 - x2;\n  int dy = y1 - y2;\n  return dx * dx + dy * dy;\n}\n\nbool intersect(int i, int j) {\n  double d = dist(disk_list[i].x, disk_list[i].y, disk_list[j].x, disk_list[j].y);\n  double r2 = (disk_list[i].r + disk_list[j].r);\n  return d < r2 * r2; \n}\n\nvoid print_state(int state) {\n  for (int i = 0; i < N; i++) {\n    if (state & (1 << i)) {\n      printf(\"%d \", i);\n    }\n  }\n  printf(\"\\n\");\n}\n\nint _solve(int state) {\n  int mx = 0;\n  //print_state(state);\n  \n  for (int i = 0; i < N; i++) {\n    if ((1 << i) & state) {\n      for (int j = i + 1; j < N; j++) {\n        if ((1 << j) & state) {\n          if (disk_list[i].c == disk_list[j].c && \n              (tree[i] & state) == 0 &&\n              (tree[j] & state) == 0) {\n            //printf(\"i, j = %d, %d\\n\", i, j);\n            int cur_state = state;\n            cur_state &= ~(1 << i);\n            cur_state &= ~(1 << j);\n            if (dp[cur_state] > 0) {\n              mx = max(dp[cur_state] + 2, mx);\n            } else {\n              int res = _solve(cur_state);\n              dp[cur_state] = res;\n              mx = max(res + 2, mx);\n            }\n          }\n        }\n      }\n    }\n  }\n  //printf(\"end\\n\");\n  return mx;\n}\n\nvoid solve() {\n  int state = (1 << N) - 1;\n  fill(dp, dp + sizeof(dp), -1);\n  printf(\"%d\\n\", _solve(state));\n}\n\nvoid make_tree() {\n  fill(tree, tree + 30, 0);\n  for (int i = 0; i < N; i++) {\n    for (int j = i - 1; j >= 0; j--) {\n      if (intersect(i, j)) {\n        tree[i] |= (1 << j);\n      }\n    }\n  }\n  /*\n  for (int i = 0; i < N; i++) {\n    printf(\"%d:\", i);\n    for (int j = 0; j < N; j++) {\n      if (tree[i] & (1 << j)) {\n        printf(\"%d \", j);\n      }\n    }\n    printf(\"\\n\");\n  }\n  */\n}\n\nint main() {\n  while (true) {\n    scanf(\"%d \", &N);\n    disk_list.clear();\n    if (N == 0) {\n      return 0;\n    }\n    for (int i = 0; i < N; i++) {\n      int x, y, r, c;\n      scanf(\"%d %d %d %d \", &x, &y, &r, &c);\n      disk_list.push_back(Disk(x, y, r, c));\n    }\n    make_tree();\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nstruct Data\n{\n    int x;\n    int y;\n    int r;\n    int c;\n};\n\ntypedef struct Data D;\n\nmap<string, int> m;\nvector<D> input;\n\nint solve(string now)\n{\n    // cout << now << endl;\n    // cout << (m.find(now) == m.end()) << endl;\n    if(m.find(now) != m.end()) return m[now];\n    // cout << \"hey\" << endl;\n    m[now] = 0;\n    vector<vector<int> >  colornum(5);\n    // cout << \"ho\" << n << endl;\n    for(int i = 0; i < input.size(); i++){\n        if(now[i] == '0') continue;\n        bool notcovered = true;\n        // cout << i << \" : \" << input[i].x << \" \" << input[i].y << \" \" << input[i].r << \" \" << input[i].c << endl;\n        for(int j = 0; j < i; j++){\n            if(now[j] == '0') continue;\n            // cout << i << \",\" << j << \":\" << pow(input[i].x - input[j].x, 2) + pow(input[i].y - input[j].y, 2) << \" \" << pow(input[i].r + input[j].r, 2) << endl;\n            if(pow(input[i].x - input[j].x, 2) + pow(input[i].y - input[j].y, 2) < pow(input[i].r + input[j].r, 2)){\n                notcovered = false;\n                break;\n            }\n        }\n        if(notcovered) colornum[input[i].c].push_back(i);\n    }\n    for(int i = 1; i < 5; i++){\n        // cout << \"colornumsize \" << colornum[i].size() << endl;\n        if(colornum[i].size() > 1){\n            for(int j = 0; j < colornum[i].size(); j++){\n                for(int k = j + 1; k < colornum[i].size(); k++){\n                    string newinput = \"\";\n                    for(int l = 0; l < input.size(); l++){\n                        if(now[l] == '0' || l == colornum[i][j] || l == colornum[i][k]) newinput += \"0\";\n                        else newinput += \"1\";\n                    }\n                    // cout << newinput << endl;\n                    m[now] = max(m[now], solve(newinput) + 2);   \n                }\n            }\n        }\n    }\n    return m[now];\n}\n\n\n\nint main()\n{\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        input.clear();\n        m.clear();\n        for(int i = 0; i < n; i++){\n            D tmpd;\n            cin >> tmpd.x >> tmpd.y >> tmpd.r >> tmpd.c;\n            input.push_back(tmpd);\n        }\n        string start = \"\";\n        for(int i = 0; i < n; i++){\n            start += \"1\";\n        }\n        cout << solve(start) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//線分を表す構造体\nstruct Segment{ Point p1, p2; };\n//直線を表す構造体\ntypedef Segment Line;\n//多角形を表す構造体\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// 許容する誤差\n#define EPS (1e-10)\n\n// ベクトルaの絶対値を求める\n//double length = abs(a);\n\n// 2点a,b間の距離を求める\n//double distance = abs(a-b);\n\n/*\n// ベクトルaの単位ベクトルを求める\nPoint b = a / abs(a);\n\n// ベクトルaの法線ベクトルn1,n2を求める\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 点cが直線a,b上にあるかないか\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// 点a,bを通る直線と点cとの距離\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// 線分s1と線分s2の距離\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// 線分sに対する点pの射影\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//線分sを対象軸とした点pの線対称の点\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//点pをangle分だけ時計回りに回転\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//円cと線分lの交点\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//点の内包\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//ベクトルの位置検出\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//凸包\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISEだと内角は180以下（一直線上に並んでいても、頂点として数える）\n        //!= CLOCKWISEだと内角は180未満（一直線上の頂点は数えない）\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //ここも == と != を変更する\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //最も下にある点の中で最も右にある点から反時計回りに並び替え\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//キャリパー法を用いて凸多角形の直径を求める\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//凸多角形の切り取りに使う関数。これがなんなのかはまだ知らない。\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//三角形の面積\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//多角形の面積\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//凸多角形かどうかの判定\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//凹多角形を線分lで切断した際の多角形の数\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\n//i番目を0にする\nint clearBit(int num, int i){\n\tint mask = ~(1 << i);\n\treturn num & mask;\n}\n\n//i番目をvで置き換える\nint updateBit(int num, int i, int v){\n\tint mask = ~(1 << i);\n\treturn (num & mask) | (v << i);\n}\n\nint n, ans;\n\nbool isOver(Circle a, Circle b){\n\tpair<Point,Point> tmp = getCrossPoints(a,b);\n\tdouble na = tmp.first.imag();\n    return std::isnan(na) == 0;\n}\n\nvoid dfs(vector<vector<int>>& g, int cur, vector<int>& on){\n\tfor(auto to : g[cur]){\n\t\ton[to] = on[to] bitor (1 << cur) bitor on[cur];\n\t\tdfs(g, to, on);\n\t}\n}\n\nvector<bool> memo;\nvoid dfs(int s, vector<int>& on, vector<int> c){\n\tif(memo[s]) return;\n\n\tvector<vector<int>> canTake(4);\n\trep(i,n){\n\t\tif(getBit(s,i)) continue;\n\t\tif((on[i] bitand s) == on[i]){\n\t\t\tcanTake[c[i]].emplace_back(i);\n\t\t}\n\t}\n\n\tvector<int> take(4,0);\n\trep(i,4){\n\t\tfor(auto j : canTake[i]){\n\t\t\ttake[i] = setBit(take[i], j);\n\t\t}\n\t}\n\n\trep(i,4){\n\t\tif(canTake[i].size() >= 2){\n\t\t\tif(canTake[i].size() % 2 == 1){\n\t\t\t\trep(j,canTake[i].size()){\n\t\t\t\t\tdfs(s bitor clearBit(take[i], j), on, c);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdfs(s bitor take[i], on, c);\n\t\t\t}\n\t\t}\n\t}\n\n\tbitset<30> bit(s);\n\tans = max<int>(ans, bit.count());\n\tmemo[s] = true;\n}\n\nint main(){\n    while(scanf(\"%d\",&n),n){\n        vector<Circle> c(n);\n        vector<int> color(n);\n        rep(i,n){\n            double x,y,r;\n            scanf(\"%lf%lf%lf%d\",&x,&y,&r,&color[i]);\n\t\t\tcolor[i]--;\n            c[i] = {Point(x,y),r};\n        }\n\n\t\tvector<vector<int>> g(n);\n\t\tvector<bool> top(n,1);\n\t\trep(i,n){\n\t\t\trange(j,i + 1,n){\n\t\t\t\tif(isOver(c[i], c[j])){\n\t\t\t\t\tg[i].emplace_back(j);\n\t\t\t\t\ttop[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> on(n,0);\n\t\trep(i,n){\n\t\t\tif(not top[i]) continue;\n\t\t\tdfs(g, i, on);\n\t\t}\n\t\t//rep(i,n) show(on[i])\n\n\t\tans = 0;\n\t\tmemo = vector<bool>(1 << n, 0);\n\t\tdfs(0, on, color);\n\t\tcout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n\twhile(true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif(!n) {\n\t\t\tbreak;\n\t\t}\n\t\tvector< int > x(n), y(n), r(n), c(n);\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\n\n\t\tvector< bool > dp(1 << n, 0);\n\n\t\tvector< int > on(n, 0);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\t\tif((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) < (r[i] + r[j]) * (r[i] + r[j])) {\n\t\t\t\t\ton[j] |= (1 << i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdp[0] = 1;\n\t\tfor(int i = 0; i < (1 << n); i++) {\n\t\t\tif(!dp[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\t\tif(j == k) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(c[j] == c[k] && (i & on[j]) == on[j] && (i & on[k]) == on[k]) {\n\t\t\t\t\t\tdp[i | (1 << j) | (1 << k)] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < (1 << n); i++) {\n\t\t\tint tmp = 0;\n\t\t\tif(dp[i]) {\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tif(i >> j & 1) {\n\t\t\t\t\t\ttmp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = max(ans, tmp);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define X first.first\n#define Y first.second\n#define R second.first\n#define C second.second\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint main(void){\n    for(int n; cin >> n, n;){\n\n        vector< pair<pii, pii> > discs(n);\n        rep(i, n) cin >> discs[i].X >> discs[i].Y >>\n                         discs[i].R >> discs[i].C;\n    \n        vi confDiscs(n);\n        rep(i, n) rep(j, i){\n            if(sqr(discs[i].X - discs[j].X) + sqr(discs[i].Y - discs[j].Y) < sqr(discs[i].R + discs[j].R))\n                confDiscs[i] |= (1 << j);\n        }\n\n        vector<char> dp(1 << n, -1);\n        dp[0] = 0;\n\n        rep(i, 1 << n){\n            if(dp[i] == -1) continue;\n\n            rep(j, n){\n                if(((1 << j) & i) != 0 || (confDiscs[j] & i) != confDiscs[j])\n                    continue;\n\n                range(k, j + 1, n){\n                    if(((1 << k) & i) != 0 || (confDiscs[k] & i) != confDiscs[k] || discs[j].C != discs[k].C)\n                        continue;\n\n                    int next = i | (1 << j) | (1 << k);\n                    dp[next] = max((int)dp[next], dp[i] + 2);\n                }\n            }\n        }\n        \n        cout << (int)*max_element(all(dp)) << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 24\nusing namespace std;\n\nint n,x[N],y[N],r[N],c[N],ans,len[N],cn;\nvector<int> v[N];\n\nvoid func(bool erased[N],int cnt,int x){\n  if(cn==17000000) return ;\n  cn++;\n  ans=max(ans,cnt);\n  for(int i=0;i<n;i++){\n    int f=0;\n    if(erased[i]) continue;\n    for(int j=0;j<len[i];j++)\n      if(!erased[v[i][j]]) f=1;\n    if(f) continue;\n    for(int j=i+1;j<n;j++){\n      if(c[i]!=c[j]) continue;\n      if(erased[j]) continue;\n      int f2=0;\n      for(int k=0;k<len[j];k++)\n\tif(!erased[v[j][k]]) f2=1;\n      if(f2) continue;\n      erased[i]=erased[j]=true;\n      func(erased,cnt+2,x+1);\n      erased[i]=erased[j]=false;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    cn=0;\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n      for(int j=i-1;j>=0;j--){\n\tint xl=x[i]-x[j],yl=y[i]-y[j];\n\tint rl=r[i]+r[j];\n\tif(xl*xl+yl*yl<rl*rl)v[i].push_back(j);\n      }\n    }\n    for(int i=0;i<n;i++) len[i]=v[i].size();\n    bool erased[N]={};\n    ans=0;\n    func(erased,0,0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++) v[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\n\n#define all(c) ((c).begin()), ((c).end())\n#define debug(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\n\nconst double EPS = 1e-10;\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\n\nstruct C{\n\tP p;\n\tint r;\n\tint c;\n};\n\nmap<int, int> dp;\nint n;\nvector<C> cs;\n\nint next_combination(int p){\n    int lsb = p&-p;\n    int rem = p+lsb;\n    int rit = rem&~p;\n    return rem|(((rit/lsb)>>1)-1);\n}\n\nint go(int mask) {\n\tif(mask == 0) return 0;\n\tif(present(dp, mask)) return dp[mask];\n\tint res = 0;\n\tint bn = __builtin_popcount(mask);\n\tbn -= 2;\n\tif (bn < 0) return 0;\n\tint next = (1 << bn) - 1;\n\tdo {\n\t\tif(next >= (1 << n)) break;\n\t\tif((mask | next) != mask) continue;\n\t\tint use = mask ^ next;\n\t\tint i = __builtin_ctz(use);\n\t\tint j = __builtin_ctz(use >> (i + 1)) + i + 1;\n\t\tif(cs[i].c != cs[j].c) continue;\n\t\tbool ok = true;\n\t\trep(k, i) if(mask & (1 << k)) if (cs[i].r + cs[k].r > abs(cs[i].p - cs[k].p)) ok = false;\n\t\trep(k, j) if(mask & (1 << k)) if (cs[j].r + cs[k].r > abs(cs[j].p - cs[k].p)) ok = false;\n\t\tif(!ok) continue;\n\t\tres = max(res, go(next) + 2);\n\t} while(next != 0 && (next = next_combination(next)));\n\treturn dp[mask] = res;\n}\n\nint main() {\n\tfor (; cin >> n, n != 0; ) {\n\t\tcs.clear();\n\t\trep (i, n) {\n\t\t\tC c; int x, y; cin >> x >> y >> c.r >> c.c;\n\t\t\tc.p = P(x, y);\n\t\t\tcs.pb(c);\n\t\t}\n\t\tdp.clear();\n\t\tcout << go((1 << n) -1) << endl;;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n;i++){\n        if(((bit>>i)&1)==0)continue;\n        for(int j=i+1;j<n;j++){\n            \n            if(((bit>>j)&1)==0)continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(c[i]==c[j]&&ok(i,bit)&&ok(j,bit)&&!memo[to_bit]){\n                ret=max(ret,dfs(to_bit));\n            }\n        }\n    }\n\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\n\n\nint main(){\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\n\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tvl x(n),y(n),r(n),c(n);\n\t\tvvi a(4);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\t\tc[i]--;\n\t\t\ta[c[i]].push_back(i);\n\t\t}\n\t\tvi b(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tbool B=1;\n\t\t\tfor(int j=0;j<i;j++) if(i!=j&&(r[i]+r[j])*(r[i]+r[j])>(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])){\n\t\t\t\tb[i]+=1<<j;\n\t\t\t}\n//\t\t\tcout<<b[i]<<' ';\n\t\t}\n//\t\tcout<<endl;\n\t\tvi dp(1<<n);\n\t\tdp[0]=1;\n\t\tfor(int i=0;i<1<<n;i++) if(dp[i]){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tint m=a[j].size();\n\t\t\t\tfor(int k=0;k<m;k++) if(!(i&1<<a[j][k])&&(i&b[a[j][k]])==b[a[j][k]]) for(int l=k+1;l<m;l++) if(!(i&1<<a[j][l])&&(i&b[a[j][l]])==b[a[j][l]]){\n//\t\t\t\t\tcout<<a[j][k]<<' '<<a[j][l]<<endl;\n\t\t\t\t\tint I=i+(1<<a[j][k])+(1<<a[j][l]);\n\t\t\t\t\tdp[I]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=0;\n\t\tfor(int i=0;i<1<<n;i++) if(dp[i]){\n\t\t\tint tmp=0;\n\t\t\tfor(int j=0;j<n;j++) if(i&1<<j) tmp++;\n\t\t\tres=max(res,tmp);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\n//char bit_count[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            if(((bit>>i)&1)==0)continue;\n            if(((bit>>j)&1)==0)continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(c[i]==c[j]&&ok(i,bit)&&ok(j,bit)&&!memo[to_bit]){\n                ret=max(ret,dfs(to_bit));\n            }\n        }\n    }\n\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n/*\nvoid init(){\n    for(int i=0;i<(1<<24);i++){\n        for(int j=0;j<24;j++)if((i>>j)&1){\n            bit_count[i]++;\n        }\n    }\n}*/\n\nint main(){\n    //init();\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint N,ans;\nbool* state;\n\nstruct Info{\n\tInfo(){\n\t\tx = y = r = 0.0;\n\t\tcolor = 0;\n\t}\n\tdouble x,y,r;\n\tint color;\n};\n\n\nbool isOverlap(Info left,Info right){\n\tdouble dist = sqrt((left.x-right.x)*(left.x-right.x)+(left.y-right.y)*(left.y-right.y));\n\treturn dist <  left.r + right.r;\n}\n\n\nint makeCode(bool removed[]){\n\n\tint ret = 0;\n\n\tint S = 1;\n\tfor(int i = 0; i <= N-1; i++){\n\t\tif(removed[i]){\n\t\t\tret += S;\n\t\t}\n\t\tS *= 2;\n\t}\n\treturn ret;\n}\n\n\nvoid recursive(Info info[],bool removed[],int count){\n\n\tif(ans == N)return;\n\n\tans = max(ans,count);\n\n\tbool check[N],over_rapFLG;\n\n\tfor(int i = 0; i < N; i++)check[i] = false;\n\n\tfor(int i = N-1; i >= 0; i--){\n\n\t\tif(removed[i] == true)continue;\n\n\t\tover_rapFLG = false;\n\n\t\tfor(int j = i-1; j >=0; j--){\n\n\t\t\tif(removed[j] == true)continue;\n\n\t\t\tif(isOverlap(info[i],info[j])){\n\t\t\t\tover_rapFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!over_rapFLG){\n\t\t\tcheck[i] = true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N-1; i++){\n\t\tfor(int k = i+1; k < N; k++){\n\t\t\tif(check[i] == true && check[k] == true && info[i].color == info[k].color){\n\t\t\t\tif(count == N-2){\n\t\t\t\t\tans = N;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tbool next_removed[N];\n\t\t\t\tfor(int i = 0; i < N; i++)next_removed[i] = removed[i];\n\t\t\t\tnext_removed[i] = true;\n\t\t\t\tnext_removed[k] = true;\n\n\t\t\t\tint code = makeCode(next_removed);\n\n\t\t\t\tif(state[code] == false){\n\t\t\t\t\tstate[code] = true;\n\t\t\t\t\trecursive(info,next_removed,count+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid func(){\n\tInfo info[N];\n\n\tint limit = pow(2,N);\n\n\tfor(int i = 0; i < limit; i++)state[i] = false;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf %d\",&info[i].x,&info[i].y,&info[i].r,&info[i].color);\n\t}\n\n\tans = 0;\n\n\tbool removed[N];\n\tfor(int i = 0; i < N; i++)removed[i] = false;\n\n\trecursive(info,removed,0);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tstate = new bool[16777216];\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//線分を表す構造体\nstruct Segment{ Point p1, p2; };\n//直線を表す構造体\ntypedef Segment Line;\n//多角形を表す構造体\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// 許容する誤差\n#define EPS (1e-10)\n\n// ベクトルaの絶対値を求める\n//double length = abs(a);\n\n// 2点a,b間の距離を求める\n//double distance = abs(a-b);\n\n/*\n// ベクトルaの単位ベクトルを求める\nPoint b = a / abs(a);\n\n// ベクトルaの法線ベクトルn1,n2を求める\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 点cが直線a,b上にあるかないか\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// 点a,bを通る直線と点cとの距離\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// 線分s1と線分s2の距離\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// 線分sに対する点pの射影\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//線分sを対象軸とした点pの線対称の点\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//点pをangle分だけ時計回りに回転\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//円cと線分lの交点\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//点の内包\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//ベクトルの位置検出\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//凸包\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISEだと内角は180以下（一直線上に並んでいても、頂点として数える）\n        //!= CLOCKWISEだと内角は180未満（一直線上の頂点は数えない）\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //ここも == と != を変更する\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //最も下にある点の中で最も右にある点から反時計回りに並び替え\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//キャリパー法を用いて凸多角形の直径を求める\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//凸多角形の切り取りに使う関数。これがなんなのかはまだ知らない。\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//三角形の面積\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//多角形の面積\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//凸多角形かどうかの判定\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//凹多角形を線分lで切断した際の多角形の数\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\n//i番目を0にする\nint clearBit(int num, int i){\n\tint mask = ~(1 << i);\n\treturn num & mask;\n}\n\n//i番目をvで置き換える\nint updateBit(int num, int i, int v){\n\tint mask = ~(1 << i);\n\treturn (num & mask) | (v << i);\n}\n\nint n, ans;\n\nbool isOver(Circle a, Circle b){\n    return abs(a.c - b.c) < a.r + b.r;\n}\n\nvoid dfs(vector<vector<int>>& g, int cur, vector<int>& on){\n\tfor(auto to : g[cur]){\n\t\ton[to] = on[to] bitor (1 << cur) bitor on[cur];\n\t\tdfs(g, to, on);\n\t}\n}\n\nvector<bool> memo;\nvoid dfs(int s, vector<int>& on, int c[30]){\n\tif(memo[s]) return;\n\n\tvector<vector<int>> canTake(4);\n\trep(i,n){\n\t\tif(getBit(s,i)) continue;\n\t\tif((on[i] bitand s) == on[i]){\n\t\t\tcanTake[c[i]].emplace_back(i);\n\t\t}\n\t}\n\n\tvector<int> take(4,0);\n\trep(i,4){\n\t\tfor(auto j : canTake[i]){\n\t\t\ttake[i] = setBit(take[i], j);\n\t\t}\n\t}\n\n\trep(i,4){\n\t\tif(canTake[i].size() >= 2){\n\t\t\tif(canTake[i].size() % 2 == 1){\n\t\t\t\trep(j,canTake[i].size()){\n\t\t\t\t\tdfs(s bitor clearBit(take[i], j), on, c);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdfs(s bitor take[i], on, c);\n\t\t\t}\n\t\t}\n\t}\n\n\tbitset<24> bit(s);\n\tans = max<int>(ans, bit.count());\n\tmemo[s] = true;\n}\n\nint main(){\n    while(scanf(\"%d\",&n),n){\n        Circle c[30];\n        int color[30];\n        rep(i,n){\n            double x,y,r;\n            scanf(\"%lf%lf%lf%d\",&x,&y,&r,&color[i]);\n\t\t\tcolor[i]--;\n            c[i] = {Point(x,y),r};\n        }\n\n\t\tvector<vector<int>> g(n);\n\t\tvector<bool> top(n,1);\n\t\trep(i,n){\n\t\t\trange(j,i + 1,n){\n\t\t\t\tif(isOver(c[i], c[j])){\n\t\t\t\t\tg[i].emplace_back(j);\n\t\t\t\t\ttop[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> on(n,0);\n\t\trep(i,n){\n\t\t\tif(not top[i]) continue;\n\t\t\tdfs(g, i, on);\n\t\t}\n\t\t//rep(i,n) show(on[i])\n\n\t\tans = 0;\n\t\tmemo = vector<bool>(1 << 24, 0);\n\t\tdfs(0, on, color);\n\t\tcout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst double eps = 1e-8;\n\ntemplate<typename T> inline T sqr(T x){return x * x;}\ntemplate<typename T> inline void chmax(T& t, T f){if(t < f)t = f;}\n\nstruct Circle : Point {\n    double r;\n    int c;\n    Circle(const Point &a, double r, int c):Point(a), r(r), c(c){}\n};\n\nint overlap(Circle &c1, Circle &c2){\n    if(sqr(c1.r + c2.r) < norm(c1 - c2))return 0;\n    if(abs(c1 - c2) + c1.r < c2.r + eps)return -1;\n    if(c2.r < c1.r && abs(c1 - c2) + c2.r < c1.r + eps)return 1;\n    if(abs(abs(c1 - c2) - c1.r - c2.r) < eps)return -2;\n    return 2;\n}\n\nint n;\nvector<Circle> disc;\n\nint dfs(map<int, set<int> > cur){\n    int res = n - (int)cur.size();\n    for(auto i=cur.begin(); i!=cur.end(); ++i){\n        if(!i->second.empty())continue;\n        auto j = i;\n        for(j++; j!=cur.end(); ++j){\n            if(!j->second.empty() || disc[i->first].c != disc[j->first].c)continue;\n            map<int, set<int> > nxt(cur);\n            for(auto& x: nxt){\n                if(x.second.count(i->first))x.second.erase(i->first);\n                if(x.second.count(j->first))x.second.erase(j->first);\n            }\n            nxt.erase(i->first);\n            nxt.erase(j->first);\n            chmax(res, dfs(nxt));\n        }\n    }\n    return res;\n}\n\nint solve(){\n    map<int, set<int> > indeg;\n    rep(i, n){\n        // indeg.emplace(i, set<int>());\n        indeg.insert(make_pair(i, set<int>()));\n        rep(j, i){\n            int chk = overlap(disc[i], disc[j]);\n            if(chk == 0 || chk == -2)continue;\n            rep(k, j)if(indeg[i].count(k) && indeg[j].count(k))indeg[i].erase(k);\n            indeg[i].insert(j);\n        }\n    }\n    return dfs(indeg);\n}\n\nint main(){\n    while(cin >> n, n){\n        disc.clear();\n        rep(i, n){\n            int x, y, r, c;\n            cin >> x >> y >> r >> c;\n            disc.emplace_back(Point(x, y), r, c);\n        }\n        cout << solve() << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n\nint N;\nint x[30],y[30],r[30],color[30];\nint dp[25][(1<<24)+10];\n\nint sqr(int x){ return x*x; }\n\nbool cover(int a, int b){\n  return (r[a] + r[b] > sqrt(sqr(x[a] - x[b]) + sqr(y[a] - y[b])));\n}\n\nint remove(int state, int a, int b){\n  int res = state;\n  res &= ~(1<<a);\n  res &= ~(1<<b);\n  return res;\n}\n\nint dfs(int depth, int get, int state){\n  int i,j,res=0;\n\n  if(dp[get][state] != -1) return dp[get][state];\n  if(depth == N) return get;\n\n  REP(i,N) if(((state>>i)&1) == 1){\n    for(j = i; j >= 0; j--) if(((state>>j)&1) == 1 && cover(i,j)) continue;\n    for(j = i+1; j < N; j++) if(((state>>j)&1) == 1 && color[i] == color[j] && !cover(i,j)){\n      res = max(res,dfs(depth+1, get, state));\n      res = max(res,dfs(depth+1, get+2, remove(state,i,j)));\n    }\n  }\n\n  return (dp[get][state] = res);\n}\n\nint main(){\n  int i,j;\n\n  while(1){\n    cin >> N;\n    if(N == 0) break;\n    REP(i,N) cin >> x[i] >> y[i] >> r[i] >> color[i];\n\n    int all = (1<<N)-1;\n    REP(i,24) REP(j,1<<24) dp[i][j] = -1;\n    printf(\"%d\\n\",dfs(0,0,all));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\n\n#define all(c) ((c).begin()), ((c).end())\n#define debug(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\n\nconst double EPS = 1e-10;\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\n\nstruct C{\n\tP p;\n\tint r;\n\tint c;\n};\n\nchar dp[1 << 24];\nint main() {\n\tfor (int n; cin >> n, n != 0; ) {\n\t\tvector<C> cs;\n\t\trep (i, n) {\n\t\t\tC c; int x, y; cin >> x >> y >> c.r >> c.c;\n\t\t\tc.p = P(x, y);\n\t\t\tcs.pb(c);\n\t\t}\n\t\tint cover[24];\n\t\trep(i, n) {\n\t\t\tint mask = 0;\n\t\t\trep(j, i) if(cs[i].r + cs[j].r > abs(cs[i].p - cs[j].p)) mask |= 1 << j;\n\t\t\tcover[i] = mask;\n\t\t}\n\t\trep(mask, 1 << n) {\n\t\t\tdp[mask] = 0;\n\t\t\trep (i, n) if (mask & (1 << i)) REP (j, i + 1, n - 1) if (mask & (1 << j)) {\n\t\t\t\tif(cs[i].c != cs[j].c) continue;\n\t\t\t\tif((mask & cover[i]) || (mask & cover[j])) continue;\n\t\t\t\tdp[mask] = max((int)dp[mask], dp[mask ^ (1 << i) ^ (1 << j)] + 2);\n\t\t\t}\n\t\t}\n\t\tcout << (int)dp[(1 << n) -1] <<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,dp[(1<<24)];\nint x[24],y[24],r[24],c[24];\nint dist(int a,int b){return (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);}\n\nint rec(int S){\n  if(dp[S]!=-1)return dp[S];\n  int res=0;\n  bool f[n];\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    f[i]=true;\n    for(int j=i-1;j>=0;j--){\n      if((S>>j)&1)continue;\n      if(dist(i,j)>=(r[i]+r[j])*(r[i]+r[j]))continue;\n      f[i]=false;\n    }\n  }\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    if(!f[i])continue;\n    for(int j=i+1;j<n;j++){\n      if((S>>j)&1)continue;\n      if(!f[j])continue;\n      if(c[i]!=c[j])continue;\n      res=max(res,2+rec(S+(1<<i)+(1<<j)));\n    }\n  }\n  return dp[S]=res;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<(1<<n);i++)dp[i]=-1;\n    for(int i=0;i<n;i++)\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n    cout<<rec(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nstruct Circle {\n\tint x, y, r, c, t;\n\tCircle(int x_, int y_, int r_, int c_)\n\t\t: x(x_), y(y_), r(r_), c(c_), t(0) {}\n};\n\nint N;\nint ans;\nvector<Circle> circles;\n\nbool intersect(Circle c1, Circle c2) {\n\tint a = c1.x - c2.x;\n\tint b = c1.y - c2.y;\n\tint r = c1.r + c2.r;\t\n\treturn (a*a + b*b < r*r);\n}\n\nvoid dfs(int used, vector<Circle> circles, int cnt) {\n\t\n\tint n = circles.size();\n\tans = max(ans, cnt);\n\n\t// ??????????????????????????¢???\n\tfor(int i = 0; i < n; ++i) {\n\t\tCircle c1 = circles[i];\n\t\tif(c1.t != 0 || (used & (1<<i))) continue; \t\n\t\tfor(int j = i+1; j < n; ++j) {\n\t\t\tif(circles[j].t != 0 || (used & (1<<j)) || c1.c != circles[j].c) continue; \n\t\t\tvector<Circle> tmp = circles;\n\t\t\tfor(int k = i+1; k < n; ++k) {\n\t\t\t\tif(intersect(c1, tmp[k])) tmp[k].t -= 1;\t\t\t\n\t\t\t}\n\t\t\tCircle c2 = tmp[j];\n\t\t\tfor(int k = j+1; k < n; ++k) {\n\t\t\t\tif(intersect(c2, tmp[k])) tmp[k].t -= 1;\t\t\t\n\t\t\t}\n\t\t\tdfs((used | (1<<i) | (1<<j)), tmp, cnt + 2);\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\twhile(cin >> N, N) {\n\t\tint x, y, r, c;\n\t\tcircles.clear();\n\t\trep(nth, N) {\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tCircle circle = Circle(x, y, r, c);\t\n\t\t\t// ????????????????????????\n\t\t\trep(i, circles.size()) {\n\t\t\t\tif(intersect(circles[i], circle)) {\n\t\t\t\t\tcircle.t += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcircles.push_back(circle);\n\t\t}\n\t\t\n\t\tans = 0;\n\t\tint used = 0; \n\t\tdfs(used, circles, 0);\n\t\tcout << ans << endl;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\nint n;\nchar dp[1 << 24], up[24];\n//vector<char> dp, up;\nvector<Circle> c;\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = (a.r + b.r) * (a.r + b.r);\n    int d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    return r > d;\n}\n\nchar Rec(char s)\n{\n    if (~dp[s])\n        return dp[s];\n\n    int res = 0;\n    // 取り除く2つの円の選択\n    for (int i = 0; i < n; ++i) {\n        // c[i]がないか取り除けない\n        if (!(s >> i & 1) || s & up[i])\n            continue;\n\n        for (int j = i + 1; j < n; ++j) {\n            // c[i]とc[j]の色が異なる\n            if (c[i].c != c[j].c)\n                continue;\n            // c[j]がないか取り除けない\n            if (!(s >> j & 1) || s & up[j])\n                continue;\n\n            int nxt = s & ~(1 << i) & ~(1 << j);\n            res = max(res, (int)Rec(nxt) + 2);\n        }\n    }\n\n    return dp[s] = res;\n}\n\nint main()\n{\n    while (cin >> n, n) {\n        memset(dp, -1, sizeof(dp));\n        for (int i = 0; i < n; ++i)\n            up[i] = 0;\n        c.resize(n);\n\n        // 円の入力\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        // 円の重なり，上下関係\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                if (isOverlap(c[i], c[j]))\n                    up[j] |= (1 << i);\n\n        cout << (int)Rec((1 << n) - 1) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define MAX_COLORS 6\n#define MAX_CIRCLES 4\n#define MAX_N (MAX_COLORS*MAX_CIRCLES)\n#define MAX_STATES (1<<MAX_N)\n\nint biggest, n;\n\nstruct circle{\n    int x, y, r, c;\n};\n\ncircle C[MAX_N];\nchar dp[MAX_STATES];\n\nbool isOver( circle c1, circle c2 ){\n    int dx, dy;\n    dx = (c1.x - c2.x) * (c1.x - c2.x);\n    dy = (c1.y - c2.y) * (c2.y - c2.y);\n    return dx + dy < (c1.r + c2.r)*(c1.r + c2.r) ? true : false;\n}\n\nbool isDeleted( int state, int num ){\n    return (state & (1<<num)) == 0 ? false : true;\n}\n\nbool isTop( int state, int num ){\n    for( int i = num-1; i >= 0; i-- ){\n        if( isDeleted(state, i) ) continue;\n        if( isOver(C[num], C[i]) ) return false;\n    }\n    //cout << num << endl;\n    return true;\n}\n\nvoid search(){\n    for( int s = 0; s < 1<<n; s++ ){\n        //cout << s << endl;\n        for( int i = 0; i < n; i++ ){\n            if( isDeleted(s, i) ) continue;\n            //cout << \"i: \" << i << endl;\n            for( int j = i+1; j < n; j++ ){\n                if( isDeleted(s, j) ) continue;\n                //cout << \"j: \" << j << endl;\n                if( isTop(s, i) && isTop(s, j) && C[i].c == C[j].c ){\n                    int next = s | 1<<i | 1<<j;\n                    if( dp[next] < dp[s]+2 ) dp[next] = dp[s]+2;\n                    if( biggest < dp[next] ) biggest = dp[next];\n                }\n            }\n        }\n    }\n}\n\nvoid init(){\n    for( int s = 0; s < 1<<n; s++ ){\n        dp[s] = 0;\n    }\n}\n\nint main(){\n    while( cin >> n, n ){\n        for( int i = 0; i < n; i++ ){\n            circle a;\n            cin >> a.x >> a.y >> a.r >> a.c;\n            C[i] = a;\n        }\n        biggest = 0;\n        init();\n        dp[0] = 0;\n        search();\n        cout << biggest << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <deque>\n#include <vector>\n#include <numeric>\n#include <iterator>\n#include <array>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\n\n\n#define FF first\n#define SS second\n#define ALL(c) begin((c)), end((c))\n#define REP(i,n) for(ll i=0;i<(ll)n;++i)\ninline int getInt() { int s; scanf(\"%d\", &s); return s; }\n/*\n#define SIZE 500000\nvector<ll> table(SIZE);\n\n\n\nvoid sieve_of_eratosthenes() {\n\tiota(ALL(table), 0);\n\tfor (int i = 2; i < SIZE; ++i)\n\t\ttable[i] = i;\n\tfor (int i = 2; i*i < SIZE; ++i)\n\tif (table[i])\n\tfor (int j = i*i; j < SIZE; j += i)\n\t\ttable[j] = 0;\n}*/\n\n/*\ntypedef array<array<int, 10>, 10> Table;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nvoid dd(Table &state, int from, int to) {\n\tif (from==to) return;\n\tvector<pair<int,int>> stack;\n\tstack.emplace_back(1,1);\n\twhile (!stack.empty()) {\n\t\tauto p = stack.back();\n\t\tstack.pop_back();\n\t\tint x = p.FF;\n\t\tint y = p.SS;\n\n\t\tREP(i, 4) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (state[ny][nx] == from) {\n\t\t\t\tstack.emplace_back(nx,ny);\n\t\t\t\tstate[ny][nx] = to;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint g_c;\n\nint cc(Table & state) {\n\tvector<pair<int, int>> stack;\n\tstack.emplace_back(1, 1);\n\tint cnt = 0;\n\twhile (!stack.empty()) {\n\t\tauto p = stack.back();\n\t\tstack.pop_back();\n\t\tint x = p.FF;\n\t\tint y = p.SS;\n\n\t\tREP(i, 4) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (state[ny][nx] == g_c) {\n\t\t\t\tstack.emplace_back(nx, ny);\n\t\t\t\tcnt++;\n\t\t\t\tstate[ny][nx] = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint walk(int depth, Table state) {\n\tif (depth == 5) {\n\t\tTable ntable = state;\n\t\tntable[1][1] = g_c;\n\t\tdd(ntable, state[1][1], g_c);\n\t\treturn cc(ntable);\n\t}\n\tint cnt = 1;\n\tREP(i, 6) {\n\t\tTable ntable = state;\n\t\tntable[1][1] = i;\n\t\tdd(ntable, state[1][1], i); //色変\n\t\tcnt = max(walk(depth+1, ntable),cnt);\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tfreopen(\"Text.txt\", \"r\", stdin);\n\n\n\twhile (true) {\n\t\tll h,w;\n\t\tcin >> h >> w >> g_c;\n\t\tif (h == 0) break;\n\t\tg_c--;\n\t\tTable table;\n\t\tREP(y, 10) REP(x, 10) table[y][x] = -1;\n\t\tREP(y, h) REP(x, w) {\n\t\t\tcin >> table[y + 1][x + 1];\n\t\t\ttable[y + 1][x + 1]--;\n\t\t}\n\n\t\tcout << walk(1, table) << endl;\n\t}\n}\n*/\nstruct circle{\n\tll id,x,y,r;\n};\n\nvector<circle> g_table[4];\n\n\nint main() {\n\twhile (true) {\n\t\tll n;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\tarray<bool,4> active;\n\t\tactive.fill(true);\n\n\t\tREP(c, 4) g_table[c].clear();\n\t\tREP(i, n){\n\t\t\tint x,y,r,c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tg_table[c - 1].push_back(circle{i,x,y,r});\n\t\t}\n\n\t\tvector<int> removableColor;\n\t\tdo{\n\t\t\twhile (!removableColor.empty()) {\n\t\t\t\tactive[removableColor.back()] = false;\n\t\t\t\tremovableColor.pop_back();\n\t\t\t}\n\n\t\t\tarray<vector<circle>,4> tops;\n\t\t\tREP(c1, 4) for (auto it1 = g_table[c1].begin(); it1 != g_table[c1].end(); ++it1) {\n\t\t\t\tif(!active[c1]) continue;\n\t\t\t\tbool top = true;\n\t\t\t\tREP(c2, 4) for (auto it2 = g_table[c2].begin(); it2 != g_table[c2].end(); ++it2) {\n\t\t\t\t\tif (!active[c2]) continue;\n\t\t\t\t\tif (c1==c2 && it1 == it2) continue;\n\t\t\t\t\tll xx = (it1->x - it2->x);\n\t\t\t\t\tll yy = (it1->y - it2->y);\n\t\t\t\t\tll rr = (it1->r + it2->r);\n\t\t\t\t\tif (xx*xx + yy*yy < rr*rr && it1->id > it2->id) {\n\t\t\t\t\t\ttop = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (top) tops[c1].push_back(*it1);\n\t\t\t}\n\n\t\t\tREP(c,4) if ((!g_table[c].empty()) && tops[c].size() == g_table[c].size()) removableColor.push_back(c);\n\t\t} while (!removableColor.empty());\n\n\t\tint count = 0;\n\t\tREP(c, 4) if (!active[c]) count += g_table[c].size();\n\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ndouble EPS = (1e-10);\n\nstruct Point {\n  double x, y;\n};\n\nstruct Circle {\n  Point p;\n  double r;\n  int id;\n};\n\nbool intersect(Circle a, Circle b) {\n  double x1 = a.p.x, y1 = a.p.y;\n  double x2 = b.p.x, y2 = b.p.y;  \n  double d = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n\n  if ( d - (a.r+b.r) <= -EPS ) return true;  \n  else return false;\n}\n\nvector<Circle> C[4];\nvector<Circle> circles;\nint N;\nunordered_map<int, int> dp;\n\nint dfs(int bit) {\n  //cout << bit << endl;\n  if ( bit == (1<<N)-1 ) return 1;\n  if ( dp[bit] ) return dp[bit];\n\n  int ret = 1;\n  int n;\n  for ( int i = 0; i < 4; i++ ) {\n    n = C[i].size();\n    for ( int a = 0; a < n; a++ ) {\n      Circle c1 = C[i][a];\n      int i1 = c1.id;\n      //if ( bit == 9 && i1 == 1 ) cout << 'a' << endl;\n      if ( bit & (1<<i1) ) continue;\n      bool flag = true;\t\n      for ( int j = 0; j < i1; j++ ) {\n\tif ( !(bit & (1<<j)) && intersect(circles[j], c1) ) {\n\t  flag = false;\n\t  break;\n\t}\n      }\n      //if ( bit == 9 && i1 == 1 ) cout << 'a' << endl;\n      if ( !flag ) continue;\n      //if ( bit == 9 && i1 == 1 ) cout << 'a' << endl;\n      for ( int b = a+1; b < n; b++ ) {\n\tCircle c2 = C[i][b];\n\tint i2 = c2.id;\n\t//if ( i1 == 1 && i2 == 2 ) cout << 'a' << endl;\n\tif ( bit & (1<<i2) ) continue;       \t\n\tfor ( int j = 0; j < i2; j++ ) {\n\t  if ( !(bit & (1<<j)) && intersect(circles[j], c2) ) {\t    \n\t    flag = false;\n\t    break;\n\t  }\n\t}\n\tif ( flag ) {\n\t  ret = max(ret, dfs(bit|(((1<<i1)+(1<<i2))))+2);\t  \n\t}\n      }\n    }\n  }\n  \n  return dp[bit] = ret;  \n}\n\nsigned main() {\n  while ( cin >> N, N ) {\n    for ( int i = 0; i < 4; i++ ) C[i].clear();\n    circles.clear();\n    dp.clear();    \n    \n    for ( int i = 0; i < N; i++ ) {\n      Circle in;\n      double x, y, r;\n      int c;      \n      cin >> x >> y >> r >> c;\n      c--;\n      in.p = Point{x, y};      \n      in.r = r;\n      in.id = i;      \n      C[c].push_back(in);\n      circles.push_back(in);      \n    }\n    \n    cout << dfs(0)-1 << endl;    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\nint n, ans;\nvector<char> dp, up;\nvector<Circle> c;\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = (a.r + b.r) * (a.r + b.r);\n    int d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    return r > d;\n}\n\nchar Rec(char s, int num)\n{\n    if (dp[s] != -1)\n        return dp[s];\n\n    int res = num;\n    // 取り除く2つの円の選択\n    for (int i = 0; i < n; ++i) {\n        // c[i]がないか取り除けない\n        if (!(s >> i & 1) || s & up[i])\n            continue;\n\n        for (int j = i + 1; j < n; ++j) {\n            // c[i]とc[j]の色が異なる\n            if (c[i].c != c[j].c)\n                continue;\n            // c[j]がないか取り除けない\n            if (!(s >> j & 1) || s & up[j])\n                continue;\n\n            int nxt = s & ~(1 << i) & ~(1 << j);\n            res = Rec(nxt, num + 2);\n        }\n    }\n\n    ans = max(ans, res);\n\n    return dp[s] = res;\n}\n\nint main()\n{\n    while (cin >> n, n) {\n        dp.assign(1 << n, -1);\n        up.assign(n, 0);\n        c.resize(n);\n\n        // 円の入力\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        // 円の重なり，上下関係\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                if (isOverlap(c[i], c[j]))\n                    up[j] |= (1 << i);\n\n        ans = 0;\n        Rec((1 << n) - 1, 0);\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<complex>\n#include<set>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int M = 24;\nconst int INF = 1000000000;\nconst int C = 5;\n\ntypedef pair<int,int> pii;\n\nint n;\nint x[M];\nint y[M];\nint r[M];\nint c[M];\n\nvector<pii> colpair;\nvector<int> on[M];\nmap<int,int> memo;\n\nbool ok(int state, pii& p){\n\tbool ret = (state&(1<<p.first))==0 && (state&(1<<p.second))==0;\n\tif(ret==false)return ret;\n\t\n\trep(i,on[p.first].size()){\n\t\tif((state&(1<<on[p.first][i]))==0)ret = false;\n\t}\n\trep(i,on[p.second].size()){\n\t\tif((state&(1<<on[p.second][i]))==0)ret = false;\n\t}\n\treturn ret;\n}\n\nint saiki(int state){\n\tif(memo.find(state)!=memo.end())return memo[state];\n\t\n\tint ans = 0;\n\trep(i,colpair.size()){\n\t\tif(ok(state, colpair[i])){\n\t\t\tint v = saiki(state | (1<<colpair[i].first) | (1<<colpair[i].second));\n\t\t\tans = max(ans, v+2);\n\t\t}\n\t}\n\t\n\treturn memo[state]=ans;\n}\n\nvoid init(){\n\tmemo.clear();\n\trep(i,n)on[i].clear();\n\tcolpair.clear();\n\t\n\trep(i,n)reps(j,i+1,n){\n\t\tif(c[i]==c[j])colpair.push_back(pii(i,j));\n\t}\n\t\n\trep(i,n){\n\t\trep(j,i){\n\t\t\tint dx = x[i]-x[j];\n\t\t\tint dy = y[i]-y[j];\n\t\t\tint r2 = r[i]+r[j];\n\t\t\t\n\t\t\tif(dx*dx + dy*dy < r2*r2){\n\t\t\t\ton[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\trep(i,colpair.size()){\n\t\tprintf(\"%d %d\\n\",colpair[i].first, colpair[i].second);\n\t}\n\trep(i,n){\n\t\tprintf(\"on \");\n\t\trep(j,on[i].size())printf(\"%d \",on[i][j]);puts(\"\");\n\t}*/\n}\nint solve(){\n\trep(i,n)cin>>x[i]>>y[i]>>r[i]>>c[i];\n\tinit();\n\t\n\treturn saiki(0);\n}\n\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tprintf(\"%d\\n\",solve());\n\t\t//break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\t#include <iostream>\n\t#include <string.h>\n\t#define HIT(a,b) ((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r))\n\n\tusing namespace std;\n\n\tstruct DISK {\n\t\tint x,y,r,c,f;\n\t};\n\tint n;\n\n\tvoid setontop(DISK *D){\n\t\tint i,j;\n\t\tfor(i=0;i<n;i++){\n\t\t\tD[i].f=D[i].r;\n\t\t\tfor(j=i+1;j<n;j++)\n\t\t\t\tif(D[j].r && HIT(D[i],D[j])) D[i].f=0;\n\t//\t\tprintf(\"ontop%d %d\\n\", i, D[i].f);\n\t\t}\n\t}\n\n\tint solve(DISK *D){\n\t\tint i,j,k,min=30,ret;\n\t\tsetontop(D);\n\t\tfor(i=1;i<=4;i++){\n\t\t\tchar list[6],li=0;\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tif(D[j].f&&D[j].c==i) list[li++]=j;\n\t\t\t}\n\t//\t\tprintf(\"%d %d\\n\",i,li);\n\t\t\tif(li<2)continue;\n\t\t\tDISK tmp[30];\n\t\t\tfor(j=0;j<li;j++){\n\t\t\t\tfor(k=j+1;k<li;k++){\n\t//\t\t\t\tprintf(\"remove(%d,%d)\", list[j],list[k]);\n\t\t\t\t\tmemcpy(tmp,D,sizeof(tmp));\n\t\t\t\t\ttmp[list[j]].r=0;\n\t\t\t\t\ttmp[list[k]].r=0;\n\t\t\t\t\tret=solve(tmp);\n\t\t\t\t\tif(ret<min)min=ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(ret=0,i=0;i<n;i++)if(D[i].r)ret++;\n\t\tif(ret<min)min=ret;\n\t//\tprintf(\"return %d\\n\", min);\n\t\treturn min;\n\t}\n\n\tint main(){\n\t\tint i,j;\n\t\twhile(cin>>n,n){\n\t\t\tDISK D[30];\n\t\t\tfor(i=n;i-->0;) cin>>D[i].x>>D[i].y>>D[i].r>>D[i].c;\n\t\t\tcout<<n-solve(D)<<endl;\n\t\t}\n\t\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\nusing namespace std;\n#define repeat(i,n) for (int i = 0; i < (n); ++i)\n#define repeat_from(i,m,n) for (int i = m; i < (n); ++i)\ntypedef set<int> seti;\n\n#ifdef DEBUG\n#include <cassert>\n#define debug(a) a\n#else\n#define debug(a)\n#endif\n\n// pos\nstruct pos { int x, y; };\npos operator+(const pos & p, const pos & q) { return (pos){p.x + q.x, p.y + q.y}; }\npos operator-(const pos & p) { return (pos){- p.x, - p.y}; }\npos operator-(const pos & p, const pos & q) { return p + (- q); }\nint dot(const pos & p, const pos & q) { return p.x * q.x + p.y * q.y; }\nint length_squared(const pos & p) { return dot(p,p); }\nistream & operator>>(istream & input, pos & p) { return input >> p.x >> p.y; }\n\n// circle\nstruct circle { pos p; int r; };\nint sq(int a) { return a * a; }\nbool is_intersected(const circle & a, const circle & b) { return length_squared(a.p - b.p) < sq(a.r + b.r); }\nistream & operator>>(istream & input, circle & a) { return input >> a.p >> a.r; }\n\n#define MAX_N 24\n#define MAX_COLOR 4\nint n;\ncircle c[MAX_N];\nint clr[MAX_N]; // in { 1, 2, 3, 4 }, so 0 is used for removed-flag\nbool over[MAX_N][MAX_N]; // over[i][j] requires i < j\n\nbool top(int i) {\n    debug(assert(clr[i]));\n    repeat (j,i) if (clr[j] and over[i][j]) return false;\n    return true;\n}\n\nint solve() {\n    int result = 0;\n    repeat (i,n) if (clr[i] and top(i)) {\n        repeat_from (j,i+1,n) if (clr[j] == clr[i] and top(j)) {\n            int ci = clr[i]; clr[i] = 0;\n            int cj = clr[j]; clr[j] = 0;\n            result = max(result, solve()) + 2;\n            clr[i] = ci;\n            clr[j] = cj;\n        }\n    }\n    return result;\n}\n\nint main() {\n    while (true) {\n        cin >> n;\n        if (n == 0) break;\n        repeat (i,n) {\n            cin >> c[i] >> clr[i];\n            repeat (j,i) over[i][j] = is_intersected(c[i],c[j]);\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nint x[24], y[24], r[24], c[24];\nint on[24];\n\n#define SQ(x) ((x)*(x))\ninline bool isIntersect(int i, int j) {\n  return SQ(x[j]-x[i]) + SQ(y[j]-y[i]) < SQ(r[j]+r[i]);\n}\n\ninline bool isValid(int i, int S) {\n  for(int j=0; j<i; j++) {\n    if((on[i]>>j & 1) && !(S>>j & 1)) return false;\n  }\n  return true;\n}\n\nchar memo[1<<24];\nint dfs(int S, const int sum) {\n  char& ret = memo[S];\n  if(ret != -1) return ret;\n  ret = sum;\n  for(int i=0; i<N; i++) {\n    if(S>>i & 1) continue;\n    if(!isValid(i, S)) continue;\n    for(int j=0; j<N; j++) {\n      if(i == j) continue;\n      if(c[i]!=c[j]) continue;\n      if(S>>j & 1) continue;\n      if(!isValid(j, S)) continue;\n      ret = max(ret, dfs(S+(1<<i)+(1<<j), sum+2));\n    }\n  }\n  \n  return ret;\n}\n\nint main() {\n  \n  while(cin >> N && N) {\n    for(int i=0; i<N; i++) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n      on[i] = 0;\n      for(int j=0; j<i; j++) {\n        if(isIntersect(i, j)) on[i] += 1<<j;\n      }\n    }\n    memset(memo, -1, sizeof memo);\n    cout << dfs(0, 0) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nstruct Cir{\n\tint x,y,r,c;\n\tCir(int x,int y,int r,int c):\n\t\tx(x), y(y), r(r), c(c) {}\n};\nbool ontop(Cir c,Cir d){\n\tint x = c.x - d.x;\n\tint y = c.y - d.y;\n\tint dis = x*x+y*y;\n\tif(dis < (c.r + d.r)*(c.r+d.r)) return true;\n\telse return false;\n}\n/*\nvector<Cir> cir;\nmap<int,int> memo;\nint dfs(int S){\n\tcout<<memo.size()<<endl;\n\tif(memo.count(S))return memo[S];\n\tint n = cir.size();\n\tbool onthe[25]={};\n\tREP(i,n) FOR(j,i+1,n){\n\t\tif((S | 1<<i) == S) continue;\n\t\tif(ontop(cir[i],cir[j])) {\n\t\t\tonthe[j] = true;\n\t\t}\n\t}\n\tint ret = 0;\n\tREP(i,n) {\n\t\tFOR(j,i+1,n){\n\t\t\tif(cir[i].c == cir[j].c && !onthe[i] && !onthe[j] && (S | 1<<i) != S && (S | 1<<j) != S){\n\t\t\t\tret = max(ret, dfs(S | 1<<i | 1<<j)+2);\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[S] = ret;\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tcir.clear();\n\t\tmemo.clear();\n\t\tREP(i,n){\n\t\t\tint x,y,r,c;\n\t\t\tcin>>x>>y>>r>>c;\n\t\t\tcir.push_back(Cir(x,y,r,c));\n\t\t}\n\t\tcout<<dfs(0)<<endl;\n\t}\n\treturn 0;\n}\n*/\nchar dp[1<<24]={};\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<Cir> cir;\n\t\tREP(i,n){\n\t\t\tint x,y,r,c;\n\t\t\tcin>>x>>y>>r>>c;\n\t\t\tcir.push_back(Cir(x,y,r,c));\n\t\t}\n\t\tbool on[24][24] = {};\n\t\tREP(i,n)REP(j,n)on[i][j] = ontop(cir[i],cir[j]);\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tdp[0] = 0;\n\t\tint ans = 0;\n\t\tfor(int S = 0; S < 1<<n; S++){\n\t\t\tif(dp[S]==-1)continue;\n\t\t\tans = max((int)dp[S],ans);\n\t\t\tbool notuseable[24] = {};\n\t\t\tREP(i,n)notuseable[i] = S>>i&1;\n\t\t\tbool over[24] = {};\n\t\t\tREP(i,n)REP(j,i)if(!notuseable[j]&&on[i][j])over[i] = true;\n\t\t\tREP(i,n)if(!notuseable[i]&&!over[i]){\n\t\t\t\tFOR(j,i+1,n)if(!notuseable[j]&&!over[j]){\n\t\t\t\t\tif(cir[i].c == cir[j].c) dp[S|1<<i|1<<j] = dp[S] + 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <map>\n\nint n;\nint x[32];\nint y[32];\nint r[32];\nint c[32];\n\nvoid Load() {\n  scanf(\"%d\", &n);\n  for(int i = 0; i < (int)n; ++i) {\n    scanf(\"%d\", &x[i]);\n    scanf(\"%d\", &y[i]);\n    scanf(\"%d\", &r[i]);\n    scanf(\"%d\", &c[i]);\n  }\n}\n\nclass Solve_ {\npublic:\n  int operator () () {\n    /*\n    int res = 0;\n    int valid[32] = {}; // not removed\n    for(int i = 0; i < n; ++i) valid[i] = true;\n    for(;;) {\n      bool remove_flag = false;\n      bool top[32]   = {}; // not overlaped\n      for(int i = 0; i < n; ++i) top[i] = true;\n      for(int i = 0; i < n; ++i) {\n        if( not valid[i] ) continue;\n        for(int j = 0; j < i; ++j) {\n          if( not valid[j] ) continue;\n          if( (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) < (r[i] + r[j]) * (r[i] + r[j]) ) {\n            top[i] = false;\n          }\n        }\n      }\n      for(int i = 0; i < n; ++i) {\n        if( not valid[i] ) continue;\n        if( not top[i] ) continue;\n      }\n      for(int i = 0; i < n; ++i) {\n        if( not valid[i] ) continue;\n        if( not top[i] ) continue;\n        for(int j = i + 1; j < n; ++j) {\n          if( not valid[j] ) continue;\n          if( not top[j] ) continue;\n          if( c[i] != c[j] ) continue;\n          valid[i] = false;\n          valid[j] = false;\n          remove_flag = true;\n          res += 2;\n        }\n      }\n      if( not remove_flag ) break;\n    }\n    */\n    for(int i = 0; i < (1 << 24); ++i) {\n      memo[i] = 0;\n    }\n    bool valid[32] = {};\n    for(int i = 0; i < n; ++i) valid[i] = true;\n    int res = dfs(valid);\n    return res;\n  }\n  int dfs(bool valid[32]) {\n    int memoid = CalcMemoId(valid);\n    if( memo[memoid] != 0 ) {\n      return memo[memoid];\n    }\n    int res = 0;\n    bool top[32];\n    calc_top(valid, top);\n    for(int i = 0; i < n; ++i) {\n      if( not valid[i] ) continue;\n      if( not top[i] ) continue;\n      for(int j = 0; j < i; ++j) {\n        if( not valid[j] ) continue;\n        if( not top[j] ) continue;\n        if( c[i] != c[j] ) continue;\n\n        valid[i] = valid[j] = false;\n        res = std::max(res, dfs(valid) + 2);\n        valid[i] = valid[j] = true;\n        if( res == 24 ) return res;\n      }\n    }\n    memo[memoid] = res;\n    return res;\n  }\n  void calc_top(bool valid[32], bool top[32]) {\n    for(int i = 0; i < n; ++i) {\n      top[i] = (valid[i] ? true : false);\n    }\n    for(int i = 0; i < n; ++i) {\n      if( not valid[i] ) continue;\n      for(int j = 0; j < i; ++j) {\n        if( not valid[j] ) continue;\n        if( (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) < (r[i] + r[j]) * (r[i] + r[j]) ) {\n          top[i] = false;\n        }\n      }\n    }        \n  }\n  int CalcMemoId(bool valid[32]) {\n    int res = 0;\n    for(int i = 0; i < n; ++i) {\n      if( valid[i] ) {\n        res |= (1 << i);\n      }\n    }\n    return res;\n  }\nprivate:\n  int memo[1<<24];\n};\nSolve_ Solve;\n\nint main() {\n  for(;;) {\n    Load();\n    if( n == 0 ) break;\n    int res = Solve();\n    printf(\"%d\\n\", res);\n  }  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct circle{\n  double x, y, r;\n  int c;\n  unordered_set<int> up, down;\n};\n\nvoid calcOverlap(int n, circle *disk){\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      int x = disk[i].x - disk[j].x, y = disk[i].y - disk[j].y;\n      if(sqrt(x*x + y*y) + 1e-8< disk[i].r + disk[j].r){\n        disk[j].up.insert(i);\n        disk[i].down.insert(j);\n      }\n    }\n  }\n}\n\nbool canRemove(circle d, circle dd){\n  if(d.c != dd.c)return false;\n  if(not d.up.empty() or\n     not dd.up.empty())return false;\n  return true;\n}\n\nint dfs(int n, circle *disk, bool *removed, int dep = 0){\n  int res = 0;\n  bool f = false;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      if(removed[i] == true or removed[j] == true)continue;\n      if(not canRemove(disk[i], disk[j]))continue;\n      f = true;\n      removed[i] = true;\n      removed[j] = true;\n      for (int k = 0; k < n; k++) {\n        disk[k].up.erase(i);\n        disk[k].up.erase(j);\n      }\n      res = max(res, dfs(n, disk, removed, dep + 1));\n      removed[i] = false;\n      removed[j] = false;\n    }\n  }\n  return f?res:dep;\n}\n\nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n, n){\n    circle disk[n];\n    for (int i = 0; i < n; i++) {\n      cin >> disk[i].x >> disk[i].y >> disk[i].r >> disk[i].c;\n    }\n    bool removed[n];\n    memset(removed, false, sizeof(removed));\n    calcOverlap(n, disk);\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        if(not canRemove(disk[i], disk[j]))continue;\n        if(not disk[i].down.empty() or\n           not disk[j].down.empty())continue;\n        removed[i] = true;\n        removed[j] = true;\n        ans++;\n      }\n    }\n    std::cout << 2*(ans + dfs(n, disk, removed)) << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//And Then. How Many Are There?\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct C{\n  int c; //???\n  int x, y; //????????§?¨?\n  int r; //??????\n  C(){}\n  C(int x, int y, int r, int c){\n    this->x = x;\n    this->y = y;\n    this->r = r;\n    this->c = c;\n  }\n};\n\nint n;\nC data[24];\nint bit[24]; //??????????????¨???????????????\nshort int dp[1<<24];\n\n//a??¨b???????????????true\nbool dis(C a, C b){\n  return (((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y)) < (a.r+b.r)*(a.r+b.r));\n}\n\n//b:??????????????????????????¨???????????????\nint solve(int b, int d){\n  cout<<d<<endl;\n  if(dp[b]!=-1)return dp[b];\n\n  int mx=0;\n  for(int i=0; i<n-1; i++){//1???????????????\n    if(bit[i]&b != bit[i])continue;//??????????????????\n    if((b&(1<<i))!=0)continue;//??¢??????????????????\n   \n    for(int j=i+1; j<n; j++){//2???????????????\n      if(bit[j]&b != bit[j])continue;//??????????????????\n      if((b&(1<<j))!=0)continue;//??¢??????????????????\n      if(data[i].c != data[j].c)continue;//????????????\n\n      int tmp_b = (b|(1<<i))|(1<<j);\n      int tmp_mx = solve(tmp_b, d+1)+2;\n      if(mx<tmp_mx)mx=tmp_mx;\n    }\n  }\n  return dp[b]=mx;\n}\n\nint main(){\n  while(cin >> n, !(n==0)){\n    memset(bit, 0, sizeof(bit));\n    memset(dp, -1, sizeof(dp));\n    for(int i=0; i<n; i++){\n      int x, y, r, c;\n      cin >> x >> y >> r >> c;\n      C tmp(x, y, r, c);\n      data[i]=tmp;\n      for(int j=0; j<i; j++){\n\tif(dis(data[i], data[j]))bit[i] = bit[i]|(1<<j);\n      }\n    }\n    cout<<solve(0, 0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint sum=0,ds;\nint n;\nvoid rec(vector<circle> vs){\n  //cout << vs.size() << endl;\n  int i,j,k;\n  int f;\n  int on[30]={};\n  vector<int> cc[5];\n  f=1;\n  int ff=0;\n  while(ff==0){\n    ff=1;\n    for(i=0;i<30;i++) on[i]=0;\n    for(i=0;i<5;i++) cc[i].clear();\n    for(i=0;i<vs.size();i++){\n      for(j=i+1;j<vs.size();j++){\n\tif(ch(vs[i],vs[j])==1) on[j]=1;\n      }\n    }\n    for(i=0;i<vs.size();i++){\n      if(on[i]==0) cc[vs[i].c].push_back(i);\n    }\n    for(i=1;i<5;i++){\n      if(cc[i].size()>0&&cc[i].size()%2==0){\n\tfor(j=cc[i].size()-1;j>=0;j--){\n\t  vs.erase(vs.begin()+cc[i][j]);\n\t  ff=0;\n\t  f=0;\n\t}\n      }\n    }\n  }\n  for(i=1;i<5;i++){\n    //cout << cc[i].size() << endl;\n    if(cc[i].size()>=2&&cc[i].size()%2==1){\n      f=0;\n      vector<circle> next;\n      for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n      for(j=0;j<cc[i].size();j++){\n\tfor(k=cc[i].size()-1;k>=0;k--){\n\t  if(k!=j)\n\t    next.erase(next.begin()+cc[i][k]);\n\t}\n\trec(next);\n      }\n      break;\n    }\n  }\n  int o=n-vs.size();\n  if(f==1) sum=max(sum,o);\n  else{\n    rec(vs);\n  }\n}\n\nint main(){\n  cin >> n;\n  while(n!=0){\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    sum=0;\n    rec(v);\n    cout << sum << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nchar memo[1<<25];\n\n//dist(i,j)<r[i]+r[j]->ok\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    if(memo[bit]!=-1)return memo[bit];\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            if(((bit>>i)&1)==0)continue;\n            if(((bit>>j)&1)==0)continue;\n            if(c[i]==c[j]&&ok(i,bit)&&ok(j,bit)){\n                ret=max(ret,dfs((bit^(1<<i))^(1<<j)));\n            }\n        }\n    }\n    return memo[bit]=ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,-1);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\nint main(){\n\n    int a=(1<<5)-1;\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\nchar bit_count[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n-bit_count[bit];\n\n    for(int i=0;i<n;i++){\n        if(((bit>>i)&1)==0||ok(i,bit)==false)continue;\n        for(int j=i+1;j<n;j++){\n            if((c[i]!=c[j]||(bit>>j)&1)==0||ok(j,bit)==false)continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(!memo[to_bit])ret=max(ret,dfs(to_bit));\n\n        }\n    }\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\nvoid init(){\n    for(int i=0;i<(1<<24);i++){\n        for(int j=0;j<24;j++)if((i>>j)&1){\n            bit_count[i]++;\n        }\n    }\n}\n\nint main(){\n    init();\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 9;\nusing Graph = vector<vector<int>>;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ninline int sgn(double a, double b = 0) { return a < b - EPS ? -1 : a > b + EPS ? 1 : 0; }\n\nstruct C {\n    P p;\n    double r;\n    C(){}\n    C(P _p, double _r) : p(_p), r(_r) {}\n    C(double _x, double _y, double _r) : p(_x, _y), r(_r) {}\n    void print() {\n        cerr << p.real() << \" \" << p.imag() << \" \" << r << endl;\n    }\n};\n\nC readC() {\n    double x, y, r;\n    cin >> x >> y >> r;\n    return C(x, y, r);\n}\n\nint relationCC(C c1, C c2) {\n    double d = abs(c1.p - c2.p);\n    if (sgn(d, c1.r + c2.r) == 1)       return 4; // distant\n    if (sgn(d, c1.r + c2.r) == 0)       return 3; // touch outside\n    if (sgn(d, abs(c1.r - c2.r)) == -1) return 0; // c1 in c2\n    if (sgn(d, abs(c1.r - c2.r)) == 0)  return 1; // c1 touches in c2\n    return 2; // two crosspoints\n}\n\nint n;\nvvi id_by_color;\nbool on[24][24];\nbool visited[1 << 24];\nint ans;\n\nbool valid(int i, int state) {\n    rep(k, i) {\n        if ((state >> k & 1) && on[k][i]) return false;\n    }\n    return true;\n}\n\nvoid dfs(int state, int num) {\n    if (visited[state]) return;\n    visited[state] = true;\n    chmax(ans, n - num);\n    if (num <= 1) return;\n\n    for (auto v_id : id_by_color) {\n        int m = v_id.size();\n        rep(i, m) {\n            if (!(state >> v_id[i] & 1)) continue;\n            rep2(j, i + 1, m) {\n                if (!(state >> v_id[j] & 1)) continue;\n                if (valid(v_id[i], state) && valid(v_id[j], state)) {\n                    dfs((state & ~(1 << v_id[i])) & ~(1 << v_id[j]), num - 2);\n                }\n            }\n        }\n    }\n}\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    while (cin >> n, n) {\n        vector<C> circles(n);\n        id_by_color.clear(); id_by_color.resize(4);\n        rep(i, n) {\n            circles[i] = readC();\n            int c;\n            cin >> c;\n            c--;\n            id_by_color[c].emplace_back(i);\n        }\n\n        rep(i, n) {\n            rep2(j, i + 1, n) {\n                on[i][j] = (relationCC(circles[i], circles[j]) <= 2);\n            }\n        }\n\n        rep(i, 1 << n) visited[i] = false;\n        ans = 0;\n        dfs((1 << n) - 1, n);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nstruct Circle {\n    int x, y, r, c;\n};\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector<Circle> circles;\n        REP(i, n) {\n            int x, y, r, c;\n            cin >> x >> y >> r >> c;\n            circles.push_back({x, y, r, c});\n        }\n\n        vi overlap(n);\n        REP(i, n-1) {\n            FOR(j, i+1, n) {\n                Circle c1 = circles[i];\n                Circle c2 = circles[j];\n                if (\n                    pow(c1.x - c2.x, 2) + pow(c1.y - c2.y, 2) < pow(c1.r + c2.r, 2)\n                ) {\n                    overlap[j] |= 1 << i;\n                }\n            }\n        }\n\n        vi dp(1 << n);\n        dp[(1 << n) - 1] = true;\n        for (int m = (1 << n) - 1; m >= 0; m--) {\n            if (!dp[m]) continue;\n            REP(i, n-1) {\n                FOR(j, i+1, n) {\n                    if (m & (1 << i) && m & (1 << j) &&\n                        circles[i].c == circles[j].c &&\n                        (overlap[i] & m) == 0 && (overlap[j] & m) == 0) {\n                        int mm = m & ~(1 << i) & ~(1 << j);\n                        dp[mm] = true;\n                    }\n                }\n            }\n        }\n\n        int res = 0;\n        REP(m, 1 << n) {\n            if (dp[m]) {\n                res = max(res, n - __builtin_popcount(m));\n            }\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <bitset>\nusing namespace std;\n\ntypedef double D;\nconst double EPS = 1e-8;\n\nstruct P {\n  D x, y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\n\nstruct C {\n  P p;\n  D r;\n  C() { }\n  C(P p_, D r_) : p(p_), r(r_) { }\n  C(D x_, D y_, D r_) : p(x_, y_), r(r_) { }\n};\n\nint sig(double a, double b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\n\nbool iCC(C a, C b) {\n  D dx = a.p.x - b.p.x;\n  D dy = a.p.y - b.p.y;\n  D d2 = dx*dx + dy*dy;\n  return sig(d2, (a.r + b.r)*(a.r + b.r)) < 0;\n}\n\nint N;\nC circle[24];\nint color[24];\nbool overlap[24][24];\n\nint solve(int S) {\n  int top = 0;\n  for(int i = 0; i < N; ++i) {\n    if(((S >> i) & 1) == 0) continue;\n    bool ok = true;\n    for(int j = 0; j < i; ++j) {\n      if(((S >> j) & 1) == 0) continue;\n      if(overlap[i][j]) {\n        ok = false;\n        break;\n      }\n    }\n    if(ok) {\n      top |= (1 << i);\n    }\n  }\n  int res = 0;\n  for(int i = 0; i < N; ++i) {\n    for(int j = i + 1; j < N; ++j) {\n      if(((top >> i) & 1) && ((top >> j) & 1) && color[i] == color[j]) {\n        int B = S;\n        B &= ~(1 << i);\n        B &= ~(1 << j);\n        res = max(res, 2 + solve(B));\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(true) {\n    cin >> N;\n    if(N == 0) break;\n    for(int i = 0; i < 24; ++i)\n      for(int j = 0; j < 24; ++j)\n        overlap[i][j] = false;\n    for(int i = 0; i < N; ++i) {\n      cin >> circle[i].p.x >> circle[i].p.y >> circle[i].r >> color[i];\n      color[i]--;\n    }\n    for(int i = 0; i < N; ++i) {\n      for(int j = 0; j < i; ++j) {\n        if(iCC(circle[i], circle[j])) {\n          overlap[i][j] = true;\n        }\n      }\n    }\n    cout << solve((1 << N) - 1 ) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nstruct Circle {\n    int x, y, r, c;\n};\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector<Circle> circles;\n        REP(i, n) {\n            int x, y, r, c;\n            cin >> x >> y >> r >> c;\n            circles.push_back({x, y, r, c});\n        }\n\n        vi overlap(n);\n        REP(i, n-1) {\n            FOR(j, i+1, n) {\n                Circle c1 = circles[i];\n                Circle c2 = circles[j];\n                if (\n                    pow(c1.x - c2.x, 2) + pow(c1.y - c2.y, 2) < pow(c1.r + c2.r, 2)\n                ) {\n                    overlap[j] |= 1 << i;\n                }\n            }\n        }\n\n        vb dp(1 << n);\n        dp[(1 << n) - 1] = true;\n        for (int m = (1 << n) - 1; m >= 0; m--) {\n            if (!dp[m]) continue;\n            REP(i, n-1) {\n                FOR(j, i+1, n) {\n                    if (m & (1 << i) && m & (1 << j) &&\n                        circles[i].c == circles[j].c &&\n                        (overlap[i] & m) == 0 && (overlap[j] & m) == 0) {\n                        int mm = m & ~(1 << i) & ~(1 << j);\n                        dp[mm] = true;\n                    }\n                }\n            }\n        }\n\n        int res = 0;\n        REP(m, 1 << n) {\n            if (dp[m]) {\n                res = max(res, n - __builtin_popcount(m));\n            }\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n \nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n \nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\n\nmap<int,int> m;\n\nint n,d[30][30],abosum[30],ans;\nbool abo[30][30],exist[30];\n\nint check(bool tmp[30]){\n\tint ret = 0,bit = 1;\n\tfor(int i = 1;i <= n;i++){\n\t\tif(tmp[i] == true){\n\t\t\tret += bit;\n\t\t}\n\t\tbit *= 2;\n\t}\n\treturn ret;\n}\n\nvoid solve(int tmpans,bool texist[30],int tabosum[30]){\n\tans = max(ans,tmpans);\n\tint bit = check(texist);\n\tauto itr = m.find(bit);\n\tif(itr != m.end()) return;\n\tm[bit] = 1;\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = i+1;j <= n;j++){\n\t\t\tif(texist[i] == false || texist[j] == false)continue;\n\t\t\tif(tabosum[i] != 0 || tabosum[j] != 0) continue;\n\t\t\tif(d[i][3] != d[j][3]) continue;\n\t\t\ttexist[i] = false; texist[j] = false;\n\t\t\tbit = check(texist);\n\t\t\tauto itr = m.find(bit);\n\t\t\ttexist[i] = true; texist[j] = true;\n\t\t\tif(itr != m.end()) continue;\n\t\t\tbool tmpexist[30];\n\t\t\tfor(int k = 1;k <= n;k++){\n\t\t\t\ttmpexist[k] = texist[k];\n\t\t\t\tif(k == i || k == j) tmpexist[k] = false;\n\t\t\t}\n\t\t\tint tmpabosum[30];\n\t\t\tfor(int k = 1;k <= n;k++){\n\t\t\t\ttmpabosum[k] = tabosum[k];\n\t\t\t\tif( abo[i][k] == true && i < k )tmpabosum[k]--;\n\t\t\t\tif( abo[j][k] == true && j < k )tmpabosum[k]--;\n\t\t\t}\n\t\t\tsolve(tmpans+2,tmpexist,tmpabosum);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0)break;\n\t\tans = 0;\n\t\tm.clear();\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tabo[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\texist[i] = true;\n\t\t\tabosum[i] = 0;\n\t\t\tfor(int j = 0;j < 4;j++){\n\t\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\t\t//cin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = i+1;j <= n;j++){\n\t\t\t\tif(  (d[i][0]-d[j][0])*(d[i][0]-d[j][0]) + (d[i][1]-d[j][1])*(d[i][1]-d[j][1]) < (d[i][2]+d[j][2])*(d[i][2]+d[j][2])    ){\n\t\t\t\t\tabo[i][j] = true; abo[j][i] = true;\n\t\t\t\t\tabosum[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve(0,exist,abosum);\n\t//\tfor(int i = 1;i <= n;i++) cout << \"abo\" << i << \" \" << abosum[i] << endl;\n/*\n\t\tbool flag = true;\n\t\twhile(flag == true){\n\t\t\tflag = false;\n\t\t\tfor(int i = 1;i <= n;i++){\n\t\t\t\tfor(int j = i+1;j <= n;j++){\n\t\t\t\t\tif(exist[i] == false || exist[j] == false)continue;\n\t\t\t\t\tif(abosum[i] != 0 || abosum[j] != 0) continue;\n\t\t\t\t\tif(d[i][3] != d[j][3]) continue;\n\t\t\t\t\tans += 2;\n\t\t\t\t\texist[i] = false; exist[j] = false;\n\t\t\t\t\tflag = true;\n\t\t\t\t\tfor(int k = i+1;k <= n;k++){\n\t\t\t\t\t\tif(abo[i][k] == true){\n\t\t\t\t\t\t\tabosum[k]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = j+1;k <= n;k++){\n\t\t\t\t\t\tif(abo[j][k] == true){\n\t\t\t\t\t\t\tabosum[k]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\nchar bit_count[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            if(((bit>>i)&1)==0)continue;\n            if(((bit>>j)&1)==0)continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(c[i]==c[j]&&ok(i,bit)&&ok(j,bit)&&!memo[to_bit]){\n                ret=max(ret,dfs(to_bit));\n            }\n        }\n    }\n\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\nvoid init(){\n    for(int i=0;i<(1<<24);i++){\n        for(int j=0;j<24;j++)if((i>>j)&1){\n            bit_count[i]++;\n        }\n    }\n}\n\nint main(){\n    //init();\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\nbool G[24][24];\nint dp[1<<24],n,over[24],x[24],y[24],r[24],c[24];\nint norm(int x,int y) { return x*x+y*y; }\nvector<int> col[4];\nint dfs(int x){\n\tif(dp[x]!=-1) return dp[x];\n\tdp[x]=0;\n\tbool use[24]={};\n\trep(i,n) use[i]=(x>>i)&1;\n\trep(i,4){\n\t\trep(a,col[i].size()){\n\t\t\tif(use[col[i][a]] || over[col[i][a]]>0) continue;\n\t\t\tint p=col[i][a];\n\t\t\trep(b,a){\n\t\t\t\tif(use[col[i][b]] || over[col[i][b]]>0) continue;\n\t\t\t\tint q=col[i][b];\n\t\t\t\tfor(int j=p+1;j<n;j++) if(G[j][p]) over[j]--;\n\t\t\t\tfor(int j=q+1;j<n;j++) if(G[j][q]) over[j]--;\n\t\t\t\tdp[x]=max(dp[x],2+dfs(x+(1<<p)+(1<<q)));\n\t\t\t\tfor(int j=p+1;j<n;j++) if(G[j][p]) over[j]++;\n\t\t\t\tfor(int j=q+1;j<n;j++) if(G[j][q]) over[j]++;\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[x];\n}\nint main(){\n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\trep(i,n) rep(j,n) G[i][j]=0;\n\t\trep(i,n) over[i]=0;\n\t\trep(i,n) cin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\trep(i,4) col[i].clear();\n\t\trep(i,n){\n\t\t\tc[i]--;\n\t\t\tcol[c[i]].pb(i);\n\t\t}\n\t\trep(i,n) rep(j,i) if(norm(x[i]-x[j],y[i]-y[j])<norm(r[i]+r[j],0)) G[i][j]=1,over[i]++;\n\t\trep(i,1<<n) dp[i]=-1;\n\t\tcout << dfs(0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\n#define x real()\n#define y imag()\n#define pb push_back \ntypedef double D;\ntypedef complex<D> P;\ntypedef struct circle{\n\tP p;\n\tD r;\n} C;\n\nint rel[24];\nC c[24];\nvector<int> color[4];\nchar use[1<<24];\nint cmax;\n\nbool IC(C a,C b){\n\tD d=norm(a.p-b.p);\n\tD r=(a.r+b.r)*(a.r+b.r);\n\treturn d<r;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n, n){\n\t\tcmax=0;\n\t\tfor(int i=0;i<4;i++){\n\t\t\twhile(!color[i].empty())\n\t\t\t\tcolor[i].pop_back();\n\t\t}\n\t\tfor(int i=0;i<24;i++)\n\t\t\trel[i]=0;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tmp;\n\t\t\tcin >> c[i].p.x >> c[i].p.y >> c[i].r;\n\t\t\tcin >> tmp;\n\t\t\tcolor[tmp-1].pb(i);\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tif(IC(c[i],c[j]))\n\t\t\t\t\trel[i]|=1<<j;\n\t\t\t}\n\t\t}\t\t\n\t\tmemset(use,-1,sizeof(use));\n\t\tuse[0]=0;\n\t\tfor(int u=0;u<(1<<n);u++){\n\t\t\tif(use[u]==-1)\n\t\t\t\tcontinue;\n\t\t\tcmax=max(cmax,(int)use[u]);\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tfor(int j=0;j<color[i].size();j++){\n\t\t\t\t\tif(u >>color[i][j]&0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(rel[color[i][j]]&~u)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor(int k=j+1;k<color[i].size();k++){\n\t\t\t\t\t\tif(u >>color[i][k]&0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif(rel[color[i][k]]&~u)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tuse[u|(1<<color[i][j])|(1<<color[i][k])]=use[u]+2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (int)cmax << endl;\n\t\tfor(int i=0;i<16;i++)\n\t\t\tcout << i << \" \" << (int)use[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\ntypedef double D;\ntypedef pair<int, int> pii;\n\nD EPS = 1e-9;\n\nstruct Circle {\n\tD x, y, r;\n\tint c;\n\tCircle (D _x, D _y, D _r, int _c) : x(_x), y(_y), r(_r), c(_c) {}\n};\n\nbool CircleIntersect(const Circle& a, const Circle& b) {\n\tD dist = sqrt( (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y) );\n\tif (a.r + b.r <= dist) return 0;\n\treturn 1;\n}\n\nvector< Circle > circles;\nvector< bool > rem;\n\nint n;\n\nint rec(int cur) {\n\tvector< bool > able(n, false);\n\tfor (int i=n-1; i>=0; i--) {\n\t\tif (rem[i]) continue;\n\t\t\n\t\tbool collision = false;\n\t\tfor (int j=0; j<i; j++) {\n\t\t\tif (rem[j]) continue;\n\t\t\tif (CircleIntersect(circles[i], circles[j]) != 0) collision = true;\n\t\t}\n\t\t\n\t\tif (!collision) {\n\t\t\table[i] = true;\n\t\t}\n\t}\n\t\n\tvector< pii > ablep;\n\tfor (int i=0; i<n; i++) {\n\t\tif (!able[i]) continue;\n\t\t\n\t\tfor (int j=i+1; j<n; j++) {\n\t\t\tif (!able[j]) continue;\n\t\t\t\n\t\t\tif (circles[i].c == circles[j].c) ablep.push_back( make_pair(i, j) );\n\t\t}\n\t}\n\t\n\tint ret = cur;\n\tfor (int i=0; i<(int)ablep.size(); i++) {\n\t\tpii p = ablep[i];\n\t\trem[p.first] = true;\n\t\trem[p.second] = true;\n\t\t\n\t\tret = max(ret, rec(cur+2));\n\t\t\n\t\trem[p.first] = false;\n\t\trem[p.second] = false;\n\t}\n\t\n\treturn ret;\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> n; if (n==0) break;\n\t\t\n\t\tcircles.assign(n, Circle(0, 0, 0, 0));\n\t\trem.assign(n, false);\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tD x, y, r; int c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tcircles[i] = ( Circle(x, y, r, c) );\n\t\t}\n\t\t\n\t\tcout << rec(0) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nstruct Circle {\n\tint x, y, r, c, t = 0;\n\tCircle(int x_, int y_, int r_, int c_)\n\t\t: x(x_), y(y_), r(r_), c(c_) {}\n};\n\nint N;\nint ans;\nvector<Circle> circles;\n\nbool intersect(Circle c1, Circle c2) {\n\tint a = c1.x - c2.x;\n\tint b = c1.y - c2.y;\n\tint r = c1.r + c2.r;\t\n\treturn (a*a + b*b < r*r);\n}\n\nvoid dfs(int used, vector<Circle> circles, int cnt) {\n\t\n\tint n = circles.size();\n\tans = max(ans, cnt);\n\n\t// ??????????????????????????¢???\n\tfor(int i = 0; i < n; ++i) {\n\t\tCircle c1 = circles[i];\n\t\tif(c1.t != 0 || (used & (1<<i))) continue; \t\n\t\tfor(int j = i+1; j < n; ++j) {\n\t\t\tif(circles[j].t != 0 || (used & (1<<j)) || c1.c != circles[j].c) continue; \n\t\t\tvector<Circle> tmp = circles;\n\t\t\tfor(int k = i+1; k < n; ++k) {\n\t\t\t\tif(intersect(c1, tmp[k])) tmp[k].t -= 1;\t\t\t\n\t\t\t}\n\t\t\tCircle c2 = tmp[j];\n\t\t\tfor(int k = j+1; k < n; ++k) {\n\t\t\t\tif(intersect(c2, tmp[k])) tmp[k].t -= 1;\t\t\t\n\t\t\t}\n\t\t\tdfs((used | (1<<i) | (1<<j)), tmp, cnt + 2);\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\twhile(cin >> N, N) {\n\t\tint x, y, r, c;\n\t\tcircles.clear();\n\t\trep(nth, N) {\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tCircle circle = Circle(x, y, r, c);\t\n\t\t\t// ????????????????????????\n\t\t\trep(i, circles.size()) {\n\t\t\t\tif(intersect(circles[i], circle)) {\n\t\t\t\t\tcircle.t += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcircles.push_back(circle);\n\t\t}\n\t\t\n\t\tans = 0;\n\t\tint used = 0; \n\t\tdfs(used, circles, 0);\n\t\tcout << ans << endl;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\ntypedef pair < int , int > Pt;\nbool dp[1 << 24];\nPt pts[24];\nint n, r[24], c[24];\nint hoge[24];\nconst int INF = 1 << 28;\nbool intersect( Pt a, Pt b, int r1, int r2){\n  return pow( a.first - b.first, 2) + pow( a.second - b.second, 2) < pow( r1 + r2, 2);\n}\n\nint rec( int bit){\n  if(dp[bit]++) return -INF;\n  int ret = 0;\n\n  for(int i = 0 ; i < n ; i++ ){\n    if((bit >> i) & 1){\n      for(int j = i + 1 ; j < n ; j++ ){\n        if( (bit >> j) & 1 && c[i] == c[j] && !(bit & hoge[i]) && !(bit & hoge[j])){\n          ret = max( ret, rec( bit & ~(1 << i) & ~(1 << j)) + 2);\n        }\n      }\n    }\n  }\n  return ret;\n}\nint main()\n{\n  while(cin >> n, n){\n    fill_n( dp, 1 << 24 , false);\n    fill_n( hoge, 24 , 0);\n\n    for(int i = 0 ; i < n ; i++ ){\n      cin >> pts[i].first >> pts[i].second >> r[i] >> c[i];\n      for(int j = 0 ; j < i ; j++ ){\n        if(intersect(pts[i],pts[j],r[i],r[j])) hoge[i] |= 1 << j;\n      }\n    }\n    cout << rec((1 << n) - 1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<algorithm>\n#define INIT 100\nusing namespace std;\nstruct circle\n{\n    int x, y, r;\n    int c;\n}cc[24];\nchar dp[(1<<24)];\nint n;\nbool intersect(int i, int j)\n{\n    int x1, y1, x2, y2;\n    int r1, r2;\n    x1 = cc[i].x, y1 = cc[i].y, r1 = cc[i].r;\n    x2 = cc[j].x, y2 = cc[j].y, r2 = cc[j].r;\n\n    if( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) >=  (r1+r2)*(r1+r2))\n    {\n        return false;\n\n    }//騾」蠢?キ夐聞>=蜊雁セ大柱?夂┌逶ク莠、\n    else\n        return true;\n\n}\nbool check(int a, int b, int state)\n{\n    if( ((1<<a-1)&state) == 0 || ((1<<b-1)&state) == 0 )\n    {\n        return false; //蟾イ邯楢「ォ諡ソ襍ー\n    }\n\n    if(cc[a].c != cc[b].c) return false; //鬘剰牡荳榊酔\n\n\n    int p[2];\n    p[0]=a, p[1]=b;\n\n    for(int k=0; k<2; k++)\n    {\n        int x =  (1<<p[k]-1)-1;  // n-p[k]+1蛟?  p[k]-1蛟?\n        if( (x&state) > 0)//state逧а[k]菴榊承驍頑怏1 ((p[k]蜿ッ閭ス陲ォ蜈カ莉也乢蟄占搭菴?        {\n            for(int i=1; i<=p[k]-1; i++)\n            {\n                int test = 1 << i-1;\n                if( (test&state) && intersect(p[k], i) )\n                {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\nint DP(int state)\n{\n    if(state==0) return 0;\n    if(dp[state]!=INIT) return dp[state];\n\n    for(int i=1; i<n; i++)\n    {\n        for(int j=i+1; j<=n; j++)\n        {\n            if( check(i,j, state) )\n            {\n                int mask = (1<<i-1) | (1<<j-1);\n\n                dp[state^mask] = DP(state^mask);\n                if(dp[state^mask]+2 > dp[state] || dp[state]==INIT)\n                    dp[state] = dp[state^mask]+2;\n            }\n        }\n    }\n    return dp[state]==INIT? 0:dp[state];\n}\n\nint main()\n{\n\n    while(scanf(\"%d\",&n) && n)\n    {\n        for(int i=1; i<=n; i++)\n            scanf(\"%d%d%d%d\",&cc[i].x, &cc[i].y, &cc[i].r, &cc[i].c);\n\n        int state = (1<<n)-1;\n        for(int i=0; i<=state; i++)\n            dp[i] = INIT;\n\n        dp[state] = DP(state);\n\n        printf(\"%d\\n\",dp[state]);\n\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>/*{{{*/\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i, b, e) for (typeof(b) i = (b); assert((i) <= (e)), i != (e); ++i)\n#define SZ(a) ((int)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(),(v).rend())\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((n) >> (m) & 1)\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\nstatic const double PI (3.14159265358979323846);\nstatic const double EPS (1e-10);\n\nusing namespace std;\ntypedef long long int ll;\ntypedef complex<double> P;/*}}}*/\n\nint n;\n\nstruct plate {\n\tint x, y, r;\n\n\tint id;\n\tint color;\n\tbool top;\n\tvector<plate*> downers;\n\tint upper_set; // bitset\n\t/*\n\tinline bool operator < (const plate &p) const {\n\t\tif (top == p.top) {\n\t\t\treturn color < p.color;\n\t\t} else {\n\t\t\treturn top;\n\t\t}\n\t}\n\t*/\n};\nvector<plate> plates;\n\nvoid show_bit(ll set, int width)\n{\n\tfor (int i = width - 1; i >= 0; --i) {\n\t\tprintf(\"%lld\", BITOF(set, i));\n\t}\n\tcout << endl;\n}\n\n/* bug\nvoid show_top() {\n\tFOR(i, 0, plates.size()) {\n\t\tif (plates[i].top) {\n\t\t\tprintf(\"1\");\n\t\t} else {\n\t\t\tprintf(\"0\");\n\t\t}\n\t}\n\tcout << endl;\n}\n*/\n\nvoid remove(int a, int b)/*{{{*/\n{\n\tplate* p[2] = {&(plates[a]), &(plates[b])};\n\tfor (int i = 0; i < 2; ++i) {\n\t\tplate* r = p[i]; // removal\n\t\tfor (int j = 0; j < r->downers.size(); ++j) {\n\t\t\tplate* d = r->downers[j];\n\t\t\td->upper_set &= ~((int)BIT(r->id));\n\t\t\tif (d->upper_set == 0) {\n\t\t\t\td->top = true;\n\t\t\t}\n\t\t}\n\t}\n}/*}}}*/\n\nvoid restore(int a, int b)/*{{{*/\n{\n\tplate* p[2] = {&(plates[a]), &(plates[b])};\n\tfor (int i = 0; i < 2; ++i) {\n\t\tplate* r = p[i]; // removal\n\t\tfor (int j = 0; j < r->downers.size(); ++j) {\n\t\t\tplate* d = r->downers[j];\n\t\t\tif (d->upper_set == 0) {\n\t\t\t\td->top = false;\n\t\t\t}\n\t\t\td->upper_set |= ~((int)BIT(r->id));\n\t\t}\n\t}\n}/*}}}*/\n\nint rec (int condition)/*{{{*/\n{\n\t//printf(\"condition: \"); show_bit(condition, n);\n\tint res = 0;\n\tFOR(i, 0, plates.size()) {\n\t\tplate p = plates[i];\n\t\tif (!p.top || BITOF(condition, i) == 0) { // not top or already removed\n\t\t\tcontinue;\n\t\t}\n\n\t\tFOR(j, i+1, plates.size()) {\n\t\t\tif (BITOF(condition, j) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tplate r = plates[j]; // removal\n\t\t\tif (!r.top || p.color != r.color) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// remove i and j\n\t\t\tint save = condition;\n\t\t\tcondition &= ~((int)BIT(i));\n\t\t\tcondition &= ~((int)BIT(j));\n\t\t\tremove(i, j);\n\t\t\tres = max(res, rec(condition) + 2);\n\t\t\trestore(i, j);\n\t\t\tcondition = save;\n\t\t}\n\t}\n\treturn res;\n}/*}}}*/\n\nint main(int argc, char const* argv[])/*{{{*/\n{\n\twhile (cin >> n, n) {\n\t\tplates.clear();\n\t\t// input\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y, r, c;\n\t\t\tcin >> x >> y >> r >> c;\n\n\t\t\tplate p;\n\t\t\tp.id = i; p.x = x; p.y = y; p.r = r; p.color = c;\n\t\t\tp.top = true; p.upper_set = 0;\n\t\t\tplates.PB(p);\n\t\t}\n\t\t// check overlay\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = i - 1; j >= 0; --j) {\n\t\t\t\tplate *p = &(plates[i]), *q = &(plates[j]);\n\t\t\t\tif ( (double)(p->r + q->r) > sqrt( pow(p->x - q->x, 2) + pow(p->y - q->y, 2) ) ) {\n\t\t\t\t\t// q is upper than p\n\t\t\t\t\tp->upper_set |= BIT(q->id);\n\t\t\t\t\tp->top = false;\n\t\t\t\t\tq->downers.PB(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << rec(-1) << endl;\n\t}\n\treturn 0;\n}/*}}}*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\nint n;\nint x[24];\nint y[24];\nint r[24];\nint c[24];\nint ans;\nbool memo[1 << 24];\n\ninline int dbl(int x){ return x * x; }\n\nvoid solve(int flag){\n  if(memo[flag]) return;\n  memo[flag] = true;\n\n  ans = max(ans, n - __builtin_popcount(flag));\n\n  bool top[24]; REP(i,n) top[i] = true;\n\n  for(int i = 0; i < n; i++){\n    if(flag & (1 << i)){\n      for(int j = i + 1; j < n; j++){\n        if(flag & (1 << j)){\n          if(dbl(x[i] - x[j]) + dbl(y[i] - y[j]) < dbl(r[i] + r[j]))\n            top[j] = false;\n        }\n      }\n    }\n  }\n\n  for(int i = 0; i < n; i++){\n    if(top[i]){\n      for(int j = 0; j < n; j++){\n        if(top[j] && c[i] == c[j]){\n          int next = flag ^ (1 << i) ^ (1 << j);\n          solve(next);\n        }\n      }\n    }\n  }\n}\n\nint main(){\n  while(scanf(\"%d\", &n), n){\n    REP(i,n) scanf(\"%d%d%d%d\", x+i, y+i, r+i, c+i);\n    memset(memo, 0, sizeof(memo)); ans = 0;\n    solve((1 << n) - 1);\n    print(ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//????????????2???????????§??????????????????????????????????????????????¬??????¨NG. ???????????¨??¢?´¢????????????\n//??????????????????????????????????????????????????£?????????????????????????????????O(2^n)????????????????????°??§?????????\n//?????????????????????????????????????????£?????????)???????????°????????¶?????????????????????????????§???????????????????§???????????¢??????????????????§?????¨?????????????????????????????????????????§????????????\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint n;\nint x[24], y[24], r[24], c[24];\nint dp[1 << 24];\n\n//rem???i??????????????????i????????£???????????°1, ??????????????????????????°0\n//????????????????????????????????????????????°????????§???\nint dfs(int rem) {\n\tbool isOut[24];\t//isOut[i] = ???i??????????????????????????°true\n\tint i, j;\n\t\n\tif (rem == 0) return 0;\n\tif (dp[rem] >= 0) return dp[rem];\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif ((rem >> j) % 2 == 0) continue;\t//??¢????????????????????????\n\t\t\tint dd = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n\t\t\tint rr = (r[i] + r[j]) * (r[i] + r[j]);\n\t\t\tif (dd < rr) break;\n\t\t}\n\t\tisOut[i] = (j == i);\n\t}\n\t\n\tint ret = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tif ((rem >> i) % 2 == 0 || !isOut[i]) continue;\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tif ((rem >> j) % 2 == 0 || !isOut[j]) continue;\n\t\t\tif (c[i] != c[j]) continue;\n\t\t\t//???i, j????????????????????????\n\t\t\tret = max(ret, dfs(rem - (1 << i) - (1 << j)) + 2);\n\t\t}\n\t}\n\treturn (dp[rem] = ret);\n}\n\nint main() {\n\twhile (cin >> n) {\n\t\tif (!n) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tfor (int i = 0; i < (1<<n); i++) {\n\t\t\tdp[i] = -1;\n\t\t}\n\t\tcout << dfs((1 << n) - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <stack>\n#include <bitset>\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vi2;\n\nconst int INF = 1 << 30;\n\nint solve();\n\nint main(void) {\n\n\twhile (solve()){}\n\n\treturn 0;\n\n}\n\nint solve() {\n\n\tint n;\n\tcin >> n;\n\tif (!n) { return 0; }\n\n\t//input\n\tvector<bool> visited((1 << n),false);\n\n\n\tvi x(n), y(n), r(n), c(n);\n\tvi2 con(n, vi(n,0));\n\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\n\t//are circles touching\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint dx, dy, dr, d;\n\t\t\t\tdx = x[i] - x[j];\n\t\t\t\tdy = y[i] - y[j];\n\t\t\t\tdr = r[i] + r[j];\n\t\t\t\td = dx*dx + dy*dy;\n\t\t\t//d:??????????????¢\n\t\t\tif (dr*dr > d) {\n\t\t\t\tcon[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcout << con[j][i] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\t//depth first search\n\n\tint ans = 0;\n\n\tstack<int> q;\n\tq.push( 0 );\n\n\twhile ( !q.empty() && ans < n ) {\n\n\t\tint p = q.top();\n\t\tq.pop();\n\t\tvisited.at(p) = true;\n\n\t\tans = max(ans,(int)bitset<32>(p).count());\n\t\t\n\t\t//remove two circles\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\tif (p & (1 << i)) { continue; }\n\n\t\t\tfor (int j = i+1; j < n; j++) {\n\n\t\t\t\tif (p & (1 << j)) { continue; }\n\t\t\t\tif (c[i] != c[j]) { continue; }\n\n\t\t\t\tbool b = false;\n\t\t\t\tfor (int k = 0; k < i && b == false; k++) {\n\t\t\t\t\tb |= (con[k][i] != 0 && ( ( p & ( 1 << k ) ) == 0 ) );\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < j && b == false; k++) {\n\t\t\t\t\tb |= (con[k][j] != 0 && ( ( p & ( 1 << k ) ) == 0 ) );\n\t\t\t\t}\n\n\t\t\t\tif ( !b ) {\n\n\t\t\t\t\tint next = (p | (1 << i) | (1 << j));\n\t\t\t\t\tif (!visited.at(next)) {\n\t\t\t\t\t\tq.push(next);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t}\n\tcout << ans << endl;\n\n\treturn 1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>/*{{{*/\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i, b, e) for (typeof(b) i = (b); assert((i) <= (e)), i != (e); ++i)\n#define SZ(a) ((int)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(),(v).rend())\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((n) >> (m) & 1)\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\nstatic const double PI (3.14159265358979323846);\nstatic const double EPS (1e-10);\n\nusing namespace std;\ntypedef long long int ll;\ntypedef complex<double> P;/*}}}*/\n\nint n;\n\nstruct plate {\n\tint x, y, r;\n\n\tint id;\n\tint color;\n\tbool top;\n\tvector<plate*> downers;\n\tint upper_set; // bitset\n\t/*\n\tinline bool operator < (const plate &p) const {\n\t\tif (top == p.top) {\n\t\t\treturn color < p.color;\n\t\t} else {\n\t\t\treturn top;\n\t\t}\n\t}\n\t*/\n};\nvector<plate> plates;\n\nvoid show_bit(ll set, int width)\n{\n\tfor (int i = width - 1; i >= 0; --i) {\n\t\tprintf(\"%lld\", BITOF(set, i));\n\t}\n\tcout << endl;\n}\n\n/* bug\nvoid show_top() {\n\tFOR(i, 0, plates.size()) {\n\t\tif (plates[i].top) {\n\t\t\tprintf(\"1\");\n\t\t} else {\n\t\t\tprintf(\"0\");\n\t\t}\n\t}\n\tcout << endl;\n}\n*/\n\nvoid remove(int a, int b)/*{{{*/\n{\n\tplate* p[2] = {&(plates[a]), &(plates[b])};\n\tfor (int i = 0; i < 2; ++i) {\n\t\tplate* r = p[i]; // removal\n\t\tfor (int j = 0; j < r->downers.size(); ++j) {\n\t\t\tplate* d = r->downers[j];\n\t\t\td->upper_set &= ~((int)BIT(r->id));\n\t\t\tif (d->upper_set == 0) {\n\t\t\t\td->top = true;\n\t\t\t}\n\t\t}\n\t}\n}/*}}}*/\n\nvoid restore(int a, int b)/*{{{*/\n{\n\tplate* p[2] = {&(plates[a]), &(plates[b])};\n\tfor (int i = 0; i < 2; ++i) {\n\t\tplate* r = p[i]; // removal\n\t\tfor (int j = 0; j < r->downers.size(); ++j) {\n\t\t\tplate* d = r->downers[j];\n\t\t\tif (d->upper_set == 0) {\n\t\t\t\td->top = false;\n\t\t\t}\n\t\t\td->upper_set |= ~((int)BIT(r->id));\n\t\t}\n\t}\n}/*}}}*/\n\nint memo[1 << 24];\nint rec (unsigned int condition)/*{{{*/\n{\n\tif (memo[condition] != -1) {\n\t\treturn memo[condition];\n\t}\n\t//printf(\"condition: \"); show_bit(condition, n);\n\tint res = 0;\n\tFOR(i, 0, plates.size()) {\n\t\tplate p = plates[i];\n\t\tif (!p.top || BITOF(condition, i) == 0) { // not top or already removed\n\t\t\tcontinue;\n\t\t}\n\n\t\tFOR(j, i+1, plates.size()) {\n\t\t\tif (BITOF(condition, j) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tplate r = plates[j]; // removal\n\t\t\tif (!r.top || p.color != r.color) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// remove i and j\n\t\t\tint save = condition;\n\t\t\tcondition &= ~((int)BIT(i));\n\t\t\tcondition &= ~((int)BIT(j));\n\t\t\tremove(i, j);\n\t\t\tres = max(res, rec(condition) + 2);\n\t\t\trestore(i, j);\n\t\t\tcondition = save;\n\t\t}\n\t}\n\tmemo[condition] = res;\n\treturn res;\n}/*}}}*/\n\nint main(int argc, char const* argv[])/*{{{*/\n{\n\twhile (cin >> n, n) {\n\t\tplates.clear();\n\t\t// input\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y, r, c;\n\t\t\tcin >> x >> y >> r >> c;\n\n\t\t\tplate p;\n\t\t\tp.id = i; p.x = x; p.y = y; p.r = r; p.color = c;\n\t\t\tp.top = true; p.upper_set = 0;\n\t\t\tplates.PB(p);\n\t\t}\n\t\t// check overlay\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = i - 1; j >= 0; --j) {\n\t\t\t\tplate *p = &(plates[i]), *q = &(plates[j]);\n\t\t\t\tif ( (double)(p->r + q->r) > sqrt( pow(p->x - q->x, 2) + pow(p->y - q->y, 2) ) ) {\n\t\t\t\t\t// q is upper than p\n\t\t\t\t\tp->upper_set |= BIT(q->id);\n\t\t\t\t\tp->top = false;\n\t\t\t\t\tq->downers.PB(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// init memo\n\t\tFOR(i, 0, 1 << 24) {\n\t\t\tmemo[i] = -1;\n\t\t}\n\t\tint condition = 0xFFFFFF;\n\t\tcout << rec(condition) << endl;\n\t}\n\treturn 0;\n}/*}}}*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define reps(i,j,k) for(int i=j;i<k;++i)\n#define rep(i,j) reps(i,0,j)\n#define fr first\n#define sc second\n#define fs fr\n#define pb push_back\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long ll;\n\nvi graph[30];\nint memo[1<<24];\nvi C;\nint n;\n\nint solve(int bit, int cnt){\n\tif(memo[bit]) return memo[bit];\n\tint res = cnt;\n\trep(i,n){\n\t\treps(j,i+1, n){\n\t\t\tif (bit & (1<<i) | bit & (1<<j) | (C[i] != C[j])) continue;\n\t\t\tint bbb = bit | (1 << i) | (1 << j);\n\t\t\tbool f = false;\n\t\t\trep(k,graph[i].size()){\n\t\t\t\tint t = graph[i][k];\n\t\t\t\tif(!(bit & (1<<t))) {f = true; break;}\n\t\t\t}\n\t\t\trep(k,graph[j].size()){\n\t\t\t\tint t = graph[j][k];\n\t\t\t\tif(!(bit & (1<<t))) {f = true; break;}\n\t\t\t}\n\t\t\tif(f) continue;\n\t\t\tres = max(res, solve(bbb, cnt + 2));\n\t\t}\n\t}\n\treturn memo[bit] = res;\n}\n\nint main(){\n\n\twhile(cin >> n,n){\n\t\trep(i,30){\n\t\t\tgraph[i].clear();\n\t\t}\n\t\tvi X(n),Y(n),R(n);\n\t\tC.resize(n);\n\t\tfill(memo, memo + (1<<24), 0);\n\t\trep(i,n){\n\t\t\tint x,y,r,c;\n\t\t\tcin >> x >> y >> r >> c;\t\n\t\t\tX[i] = x;\n\t\t\tY[i] = y;\n\t\t\tR[i] = r;\n\t\t\tC[i] = c;\n\t\t\trep(j,i){\n\t\t\t\tif((X[i]-X[j])*(X[i]-X[j])+(Y[i]-Y[j])*(Y[i]-Y[j]) < (R[i]+R[j])*(R[i]+R[j])){\n\t\t\t\t\tgraph[i].pb(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << solve(0,0) << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<iostream>\n\n\n#define rep(i,n) for(i=0;i<n;i++)\n\nusing namespace std;\n\n\n\nchar memo[1<<24];\n\nint di[25][4];\nint ma;\nint n;\n\nconst int X=0;\nconst int Y=1;\nconst int R=2;\nconst int C=3;\n\n\n\nvoid solve(int p,int score){\n\tif(memo[p]==1)return;\n\t\n\tif(ma<score)ma=score;\n\t\n\tint kouho[4][6];\n\tint kouhon[4];\n\tint i,j,k;\n\tbool f;\n\t\n\t//fill(kouhon,kouhon+4,0);\n\tkouhon[0]=kouhon[1]=kouhon[2]=kouhon[3]=0;\n\t\n\trep(i,n){\n\t\tf=true;\n\t\t//for(j=0;j<i;j++){\n\t\tif(p&(1<<i))continue;\n\t\t\n\t\trep(j,i){\n\t\t\tif(p&(1<<j))continue;\n\t\t\t\n\t\t\tif(i==j)continue;\n\t\t\t//printf(\"(i,j)=(%d,%d)  %d %d \\n\",i,j,(di[i][X]-di[j][X])*(di[i][X]-di[j][X])+(di[i][Y]-di[j][Y])*(di[i][Y]-di[j][Y]),(di[i][R]+di[j][R])*(di[i][R]+di[j][R]));\n\t\t\t\n\t\t\tif(\n\t\t\t\t(di[i][X]-di[j][X])*(di[i][X]-di[j][X])+(di[i][Y]-di[j][Y])*(di[i][Y]-di[j][Y])<(di[i][R]+di[j][R])*(di[i][R]+di[j][R])//2乗距離\n\t\t\t){\n\t\t\t\t//puts(\"false\");\n\t\t\t\tf=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(f){\n\t\t\tkouho[di[i][C]][kouhon[di[i][C]]++]=i;\n\t\t}\n\t}\n\t\n\t//printf(\"kouhon[0]=%d\\n\",kouhon[0]);\n\t\n\trep(i,4){\n\t\tif(kouhon[i]<2)continue;\n\t\t//int bp=p;\n\t\trep(j,kouhon[i]){\n\t\t\tfor(k=j+1;k<kouhon[i];k++){\n\t\t\t\tsolve(p|(1<<kouho[i][j])|(1<<kouho[i][k]),score+2);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tmemo[p]=1;\n}\n\n\nint main(){\n\t\n\t\n\tint i;\n\tint x,y,r,c;\n\t\n\t\n\twhile(true){\n\t\t\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)return 0;\n\t\t\n\t\trep(i,n){\n\t\t\tscanf(\"%d %d %d %d\",&di[i][0],&di[i][1],&di[i][2],&di[i][3]);\n\t\t\tdi[i][C]--;\n\t\t}\n\t\t\n\t\tfill(memo,memo+(1<<24),0);\n\t\tma=0;\n\t\t\n\t\tsolve(0,0);\n\t\t\n\t\tprintf(\"%d\\n\",ma);\n\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nconst int N = 6*4;\nchar dp[1 << N];\nint cover[N];\nint x[N], y[N], r[N], c[N];\nint n;\n\nint rec(int bits){\n\tif (bits == 0) return 0;\n\n\tchar &res = dp[bits];\n\tif (res >= 0) return res;\n\tres = 0;\n\tfor (int i = 0; i < n; ++i){\n\t\tif (~bits&(1 << i)) continue;\n\t\tif (bits&cover[i]) continue;\n\t\tfor (int j = i+1; j < n; ++j){\n\t\t\tif (~bits&(1 << j)) continue;\n\t\t\tif (bits&cover[j]) continue;\n\t\t\tif (c[i] != c[j]) continue;\n\t\t\tres = max((int)res, 2 + rec(bits&~(1 << i)&~(1 << j)));\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tauto sq = [](int x){return x*x; };\n\twhile (cin >> n, n){\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t\tcover[i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tfor (int j = 0; j < i; ++j){\n\t\t\t\tif (sq(x[i] - x[j]) + sq(y[i] - y[j]) >= sq(r[i] + r[j])) continue;\n\t\t\t\tcover[i] |= 1<<j;\n\t\t\t}\n\t\t}\n\n\t\tcout << rec((1 << n) - 1) << '\\n';\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct state{\n    int x,y,r,c;\n};\n\nbool check(int x1,int y1,int r1,int x2,int y2,int r2){\n    if((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2) >= r1*r1+r2*r2){\n        return 0;\n    }\n    else return 1;\n}\n\nint memo[1<<24];\n\nint dp(vector<state>&v,int now){\n    if(memo[now]!=-1)return memo[now];\n    vector<int>ue(v.size(),0);\n    for(int i=0;i<v.size();++i){\n        for(int j=0;j<i;++j){\n            if(check(v[i].x,v[i].y,v[i].r,v[j].x,v[j].y,v[j].r)){\n                ue[i]++;\n            }\n        }\n    }\n    int ret=0;\n    for(int i=0;i<v.size();++i){\n        for(int j=i+1;j<v.size();++j){\n            if((now>>i)&1 && (now>>j)&1){\n                if(ue[i]==0 && ue[j]==0){\n                    ret=max(ret,dp(v,now-((1<<i)+(1<<j))));\n                }\n            }\n        }\n    }\n    return memo[now]=ret;\n}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        for(int i=0;i<(1<<24);++i){\n            memo[i]=-1;\n        }\n        vector<state>v(n);\n        for(int i=0;i<n;++i){\n            int x,y,r,c;\n            v[i]={x,y,r,c};\n        }\n        dp(v,(1 << n)-1);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// 2点間の距離\ndouble dist(double x1, double y1, double x2, double y2){\n\treturn sqrt( (x1-x2) * (x1-x2) + (y1-y2) * (y1-y2) );\n}\n\nstruct Circle{\n\tint x, y, r, c;\n\t// コンストラクタで初期化\n\tCircle(int x_, int y_, int r_, int c_){\n\t\tx = x_; y = y_; r = r_; c = c_;\n\t};\n\t// 円 cir が上に重なっているかどうか \n\tbool is_intersect(Circle cir){\n\t\tdouble d = dist( this->x , this->y , cir.x , cir.y );\n\t\treturn ( this->r + cir.r > d );\n\t}\n};\n\n\nint main(){\n\tint n;\n\twhile( cin >> n , n ){\n\t\t// グラフ : G[i][j] := ノード i がノード j の上にある.\n\t\tint G[24][24] = {0};\n\t\t// v[i] := i 番目の円を返す\n\t\tvector<Circle> v;\n\t\t// h[i] := ノード i の色\n\t\tint h[24] = {0};\n\t\t// color[i] := 色 i の円の個数\n\t\tint color[5] = {0};\n\t\t// d[i] := ノード i の入次数\n\t\tint d[24] = {0};\n\t\t\n\t\t// 入力\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint x, y, r, c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\t\n\t\t\tCircle cir( x , y , r , c );\n\t\t\th[i] = c;\n\t\t\tcolor[c]++;\n\t\t\tv.push_back( cir );\n\t\t}\n\t\t\n\t\t// 重なる円盤をチェックする\n\t\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\t\tfor(int j=i+1 ; j < v.size() ; j++ ){\n\t\t\t\tif( v[i].is_intersect(v[j]) ){\n\t\t\t\t\td[j]++;\n\t\t\t\t\tG[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*cout << \"[debug]\" << endl;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\tcout << G[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\t\n\t\t// 取り除ける色を探す\n\t\tint ans = 0;\n\t\tbool flag = true;\n\t\tbool is_remove[5] = {0};\n\t\twhile( flag ){\n\t\t\tflag = false;\n\t\t\tfor(int c=1 ; c <= 4 ; c++ ){\n\t\t\t\tif( is_remove[c] ) continue;\n\t\t\t\t// 取り除くことのできるノードのあつまり\n\t\t\t\tvector<int> vc;\n\t\t\t\t\n\t\t\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\t\t\t// 色 c で上に重なっているものがないとき\n\t\t\t\t\tif( d[i] == 0 && h[i] == c ){\n\t\t\t\t\t\tvc.push_back( i );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 色 c の円すべてについて上に重なっていなければ取り除く\n\t\t\t\tif( color[c] == vc.size() && vc.size() > 0 ){\n\t\t\t\t\tfor(int i=0 ; i < vc.size() ; i++ ){\n\t\t\t\t\t\tint v = vc[i];\n\t\t\t\t\t\tfor(int j=0 ; j < 24 ; j++ ){\n\t\t\t\t\t\t\tif( G[v][j] ){\n\t\t\t\t\t\t\t\tG[v][j] = 0;\n\t\t\t\t\t\t\t\td[j]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//cout << \"add : \" << vc.size() << endl;\n\t\t\t\t\tis_remove[c] = true;\n\t\t\t\t\tans += vc.size();\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint n;\nint x[25],y[25],r[25],c[25];\nint cover[25];\ndouble d[25][25];\nbool check[1<<25];\nint cnt,comb,a,b;\nint m,ans;\nint u;\n\ndouble dis(int i,int j){\n  return sqrt( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j]) * (y[i]-y[j]) );\n}\n\nvoid cov(int a){\n  cover[a] = -1;\n  for(int j=a-1;j>=0;j--){\n    if(d[j][a]<r[a]+r[j] && u>>j & 1){\n      cover[a] = j;\n      break;\n    }\n  }\n} \n\n  \nvoid rec(void){\n  int cnt;\n\n  if(check[u])return;\n  check[u] = true;\n\n  for(int i=1;i<=4;i++){\n    cnt = 0;\n    /*\n    for(int j=0;j<n;j++){\n      if( (u>>j & 1) && cover[j]<0 && c[j] == i)cnt++;\n    }\n    if(cnt==6){\n      for(int j=0;j<n;j++){\n\tif(c[j] == i)u -= 1<<j;\n      }\n      for(int j=0;j<n;j++)cov(j);\n\n      ans += 6;\n      m = max(m,ans);\n      if(!check[u]){\n        check[u] = true;\n\trec();\n\tif(!u)return;\n      }\n      ans -= 6;\n\n      for(int j=0;j<n;j++){\n\tif(c[j] == i)u += 1<<j;\n      }\n      for(int j=0;j<n;j++)cov(j);\n    }else{\n    */\n      for(int j=0;j<n;j++){\n\tif( (u>>j & 1) && cover[j]<0 && c[j] == i){\n\t  for(int k=j+1;k<n;k++){\n\t    if( (u>>k & 1) && cover[k]<0 && c[k] == i){\n\t      u -= 1<<j;\n\t      u -= 1<<k;\n\t      for(int l=0;l<n;l++)cov(l);\n\n\t      ans += 2;\n\t      m = max(m,ans);\n\t      rec();\n\t      if(!u)return;\n\t      ans -= 2;\n\n\t      u += 1<<j;\n\t      u += 1<<k;\n\t      for(int l=0;l<n;l++)cov(l);\n\t    }\n\t  }\n\t}\n      }\n      //}\n  }\n}\n\n\n\nint main(){\n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    for(int i=0;i<n;i++)cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++)d[i][j] = dis(i,j);\n    }\n\n    u = (1<<n) - 1;\n    for(int i=0;i<(1<<n);i++)check[i] = false;\n    for(int i=0;i<n;i++)cov(i);\n\n    \n    m = 0;\n    ans = 0;\n    rec();\n\n    cout << m << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse if (dis < eps) {\n\t\tconst ld ar = min(l.r, r.r);\n\t\treturn ar*ar*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\nvector<Circle>cs;\nvector<int>colors;\nchar memo[1 << 24];\nint getans(const vector<vector<int>>&edges, vector<int>&nums,bitset<24>&used) {\n\tif (memo[used.to_ulong()] != -1)return memo[used.to_ulong()];\n\tvector<vector<int>>colorids(4);\n\tfor (int i = 0; i < used.size(); ++i) {\n\t\tif (!used[i]) {\n\t\t\tif (!nums[i]) {\n\t\t\t\tcolorids[colors[i]].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tfor (int a = 0; a < colorids[i].size(); ++a) {\n\t\t\tint aid = colorids[i][a];\n\t\t\tfor (int b = a + 1; b < colorids[i].size(); ++b) {\n\t\t\t\tconst int bid = colorids[i][b];\n\t\t\t\tused[aid] = true;\n\t\t\t\tused[bid] = true;\n\t\t\t\tfor (auto e : edges[aid]) {\n\t\t\t\t\tnums[e]--;\n\t\t\t\t}\n\t\t\t\tfor (auto e : edges[bid]) {\n\t\t\t\t\tnums[e]--;\n\t\t\t\t}\n\t\t\t\tans = max(ans,2 + getans(edges, nums, used));\n\t\t\t\tused[aid] = false;\n\t\t\t\tused[bid] = false;\n\t\t\t\tfor (auto e : edges[aid]) {\n\t\t\t\t\tnums[e]++;\n\t\t\t\t}\n\t\t\t\tfor (auto e : edges[bid]) {\n\t\t\t\t\tnums[e]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[used.to_ulong()]=ans;\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 1 << 24; ++i) {\n\t\t\tmemo[i] = -1;\n\t\t}\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tcs.clear();\n\t\tcolors.clear();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y, r, c; cin >> x >> y >> r >> c;\n\t\t\tc--;\n\t\t\tcs.emplace_back(Point(x, y), r);\n\t\t\tcolors.push_back(c);\n\t\t}\n\t\tvector<vector<int>>edges(N);\n\t\tvector<int>nums(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tif (two_circle_area(cs[i],cs[j])>eps) {\n\t\t\t\t\tedges[i].push_back(j);\n\t\t\t\t\tnums[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbitset<24>bs;\n\t\tint ans = getans(edges, nums,bs);\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n#define For(i,a,b)  for(int i = a;i < b;i++)\n#define rep(i,n)\tFor(i,0,n)\n#define all(n)\t\tn.begin(),n.end()\n\n//(x + a)^2 + (y + b)^2 <= c\n\nstruct Circle{\n\tint x, y, r;\n\tint c;\n\tCircle(){};\n\tCircle(int x, int y, int r, int c) :x(x), y(y), r(r), c(c){}\n\tint inter(Circle cl){\n\t\tint tx = cl.x, ty = cl.y;\n\t\tint t = (x - tx)*(x - tx) + (y - ty)*(y - ty);\n\t\tint R = (r + cl.r)*(r + cl.r);\n\t\tif (t < R)return 1;\n\t\tif (t >= R)return 0;\n\t}\n};\n\nint n;\n\nint dfs(vector<Circle> v){\n\n\tvector<int> tv[5];\n\trep(i, v.size()){\n\t\tbool tf = true;\n\t\tFor(j,i+1, v.size()){\n\t\t\tif (v[i].inter(v[j]) == 1){\n\t\t\t\ttf = false;\n\t\t\t}\n\t\t}\n\t\tif (tf){\n\t\t\ttv[v[i].c].push_back(i);\n\t\t}\n\t}\n\n\tint ret = 0;\n\tbool f = false;\n\n\trep(i, 5){\n\t\tif (tv[i].size() >= 2){\n\t\t\tif (tv[i].size() % 2){\n\t\t\t\trep(j, tv[i].size()){\n\t\t\t\t\tFor(k, j + 1, tv[i].size()){\n\t\t\t\t\t\tvector<Circle> tmpv;\n\n\t\t\t\t\t\trep(l, v.size()){\n\t\t\t\t\t\t\tif (tv[i][j] != l && tv[i][k] != l)\n\t\t\t\t\t\t\t\ttmpv.push_back(v[l]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tret = max(ret, dfs(tmpv));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvector<Circle> tmpv;\n\t\t\t\tbool cf[100]; memset(cf, 0, sizeof cf);\n\t\t\t\trep(j, tv[i].size()){\n\t\t\t\t\tcf[tv[i][j]] = true;\n\t\t\t\t}\n\t\t\t\trep(j, v.size()){\n\t\t\t\t\tif (!cf[j])\n\t\t\t\t\ttmpv.push_back(v[j]);\n\t\t\t\t}\n\t\t\t\tret = max(ret, dfs(tmpv));\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!f){\n\t\treturn n - v.size();\n\t}\n\t\n\treturn ret;\n}\n\n\nint main()\n{\n\n\twhile (cin >> n && n){\n\n\t\tvector<Circle> v;\n\t\trep(i, n){\n\t\t\tint x, y, r, c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tv.push_back(Circle(x, y, r, c));\n\t\t}\n\n\t\treverse(all(v));\n\n\t\tcout << dfs(v) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "def xx(x):\n    return x * x\n    \ndef pop(overlaps, i, lis):\n    for k in lis:\n        if i > k and overlaps[i][k]: return False\n    return True\n\ndef search(disks, overlaps, lis):\n    if len(lis) < 2: return 0\n    res = 0\n    for i in lis:\n        if not pop(overlaps, i, lis): continue\n        #print(\"OK\", i)\n        for k in lis:\n            if i == k: continue\n            if disks[i][3] != disks[k][3]: continue\n            if not pop(overlaps, k, lis): continue\n            #print(\"Good\", k)\n            giv = list(lis)\n            giv.remove(i)\n            giv.remove(k)\n            res = max(res, 2 + search(disks, overlaps, giv))\n    return res\n\nwhile True:\n    n = int(input())\n    if n == 0: break\n    disks = [\n        list(map(int, input().split(\" \")))\n        for _ in range(n)\n    ]\n    \n    overlaps = []\n    for i in range(n):\n        res = []\n        for k in range(n):\n            a = disks[i]; b = disks[k]\n            res.append(xx(a[0] - b[0]) + xx(a[1] - b[1]) < xx(a[2] + b[2]))\n        overlaps.append(res)\n    #print(overlaps)\n\n    print(search(disks, overlaps, list(range(n))))\n          \n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\n\nconst int MAX = 24;\nint n;\nint x[MAX], y[MAX], r[MAX], c[MAX];\nbool under[MAX];\nint memo[1 << MAX];\n\nint dfs(int rest) {\n\tif(memo[rest] >= 0)\n\t\treturn memo[rest];\n\n\tint can = rest;\n\tfor(int i = 0; i < n; ++i)\n\t\tcan &= ~under[i];\n\n\tint res = 0;\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(can & (1 << i)) {\n\t\t\tconst int tmp = rest & (~(1 << i));\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tif(c[i] == c[j] && (can & (1 << j))) {\n\t\t\t\t\tconst int next = tmp & (~(1 << j));\n\t\t\t\t\tchmax(res, dfs(next) + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn memo[rest] = res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\n\t\tmemset(under, 0, sizeof(under));\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tfor(int j = i + 1; j < n; ++j)\n\t\t\t\tif(hypot(x[i] - x[j], y[i] - y[j]) <= r[i] + r[j])\n\t\t\t\t\tunder[i] |= (1 << j);\n\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tcout << dfs((1 << n) - 1) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define sq(a) ((a) * (a))\n\nint n;\nint x[24], y[24], r[24], c[24];\nint s[24];\nint dp[1 << 24];\n\nint calc(int bit)\n{\n\tif (~dp[bit]) return dp[bit];\n\tint res = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < i; j++){\n\t\t\tif (bit & (1 << i)) continue;\n\t\t\tif (bit & (1 << j)) continue;\n\t\t\tif (c[i] != c[j]) continue;\n\t\t\tif (s[i] & ~bit) continue;\n\t\t\tif (s[j] & ~bit) continue;\n\t\t\tres = max(res, 2 + calc(bit | (1 << i) | (1 << j)));\n\t\t}\n\t}\n\treturn dp[bit] = res;\n}\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\tmemset(s, 0, sizeof(s));\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < i; j++){\n\t\t\t\tif (sq(x[i] - x[j]) + sq(y[i] - y[j]) < sq(r[i] + r[j])){\n\t\t\t\t\ts[i] |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << calc(0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\n\nint n,res;\nint dx[24],dy[24],dr[24];\nint cx[4][6],cy[4][6],cr[4][6],cz[4][6],cc[4];\nbool flag[1<<24];\nint link[24][24];\n\nvoid dfs(int bit,int cnt){\n\tif(flag[bit])return;\n\tflag[bit]=true;\n\tres=max(res,cnt);\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=0;j<cc[i];j++){\n\t\t\tif((bit >> cz[i][j]) & 1)continue;\n\t\t\tfor(int k=j+1;k<cc[i];k++){\n\t\t\t\tif((bit >> cz[i][k]) & 1)continue;\n\t\t\t\tint flag2=0;\n\t\t\t\tfor(int l=0;l<cz[i][k];l++){\n\t\t\t\t\tif((bit >> l) & 1)continue;\n\t\t\t\t\tif(cz[i][j]>l && link[l][cz[i][j]]==1){\n\t\t\t\t\t\tflag2=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(link[l][cz[i][k]]==1){\n\t\t\t\t\t\tflag2=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag2==0){\n\t\t\t\t\tint nbit=bit;\n\t\t\t\t\tnbit|=1<<cz[i][j];\n\t\t\t\t\tnbit|=1<<cz[i][k];\n\t\t\t\t\tdfs(nbit,cnt+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tres=0;\n\t\tmemset(flag,false,sizeof(flag));\n\t\tmemset(link,0,sizeof(link));\n\t\tmemset(cx,0,sizeof(cx));\n\t\tmemset(cy,0,sizeof(cy));\n\t\tmemset(cz,0,sizeof(cz));\n\t\tmemset(cc,0,sizeof(cc));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c;\n\t\t\tscanf(\"%d %d %d %d\",&dx[i],&dy[i],&dr[i],&c);\n\t\t\tc--;\n\t\t\tcx[c][cc[c]]=dx[i];\n\t\t\tcy[c][cc[c]]=dy[i];\n\t\t\tcr[c][cc[c]]=dr[i];\n\t\t\tcz[c][cc[c]]=i;\n\t\t\tcc[c]++;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(sqrt(pow(dx[i]-dx[j],2)+pow(dy[i]-dy[j],2))<(double)dr[i]+dr[j]){\n\t\t\t\t\tlink[i][j]=link[j][i]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(0,0);\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<set>\nusing namespace std;\nint ret=0;\nint x[30];\nint y[30];\nint r[30];\nint c[30];\nvector<int>used;\nset<vector<int> >dp;\nint n;\nint now;\nvoid solve(){\n\tif(dp.count(used))return;\n\tdp.insert(used);\n\tret=max(ret,now);\n\tint can[30];\n\tfor(int i=0;i<n;i++)can[i]=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(used[i])continue;\n\t\tcan[i]=1;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(!used[j]&&(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])<(r[i]+r[j])*(r[i]+r[j]))can[i]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++){\n\t\tif(can[i]&&can[j]&&c[i]==c[j]){\n\t\t\tnow+=2;\n\t\t\tused[i]=used[j]=1;\n\t\t\tsolve();\n\t\t\tused[i]=used[j]=0;\n\t\t\tnow-=2;\n\t\t}\n\t}\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=a-1;i>=0;i--)scanf(\"%d%d%d%d\",x+i,y+i,r+i,c+i);\n\t\tret=0;n=a;\n\t\tused=vector<int>(a);\n\t\tdp.clear();\n\t\tnow=0;\n\t\tsolve();\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\nconst int MAXN=30;\nconst int INF=1e9;\nint n;\nbool dp[1<<24];\ndouble x[25],y[25],r[25];\nint c[25];\ndouble ans=INF;\ntemplate<typename A,size_t N,typename T>\nvoid Fill(A (&array)[N],const T &val)\n{\n  std::fill( (T*)array,(T*)(array+N),val );\n}\n\nbool distjudge(double x,double y,double r)\n{\n  if(sqrt(x*x+y*y)>=r) return true;\n  else return false;\n}\n\nint bitcount(int x,int n)\n{\n  int ret=0;\n  for(int i=0;i<n;i++)\n  {\n    if(x&(1<<i)) ret++;\n  }\n  return ret;\n}\n\nint main(void)\n{\n  while(cin >> n)\n  {\n    memset(dp,false,sizeof(dp));\n    dp[(1<<n)-1]=true;\n    for (int i = 0; i < n; i++)\n    {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n    int ans=0;\n    for(int i=(1<<n)-1;i>=0;i--)\n    {\n      if(dp[i])\n      {\n        for(int j=0;j<n;j++)\n        {\n          bool canj=true;\n          for(int l=0;l<j;l++) if((i&(1<<l)) && !distjudge(abs(x[j]-x[l]),abs(y[j]-y[l]),r[j]+r[l])) canj=false;\n          if(canj && i&(1<<j))\n          {\n            for(int k=j;k<n;k++)\n            {\n              bool cank=true;\n              for(int l=0;l<k;l++) if((i&(1<<l)) && !distjudge(abs(x[k]-x[l]),abs(y[k]-y[l]),r[k]+r[l])) cank=false;\n              if(cank && j!=k && i&(1<<k) && distjudge(abs(x[j]-x[k]),abs(y[j]-y[k]),r[j]+r[k]))\n              {\n                if(c[j]==c[k])\n                {\n                  int mask=i;\n                  mask&=~(1<<j);\n                  mask&=~(1<<k);\n                  dp[mask]=true;\n                }\n              }\n            }\n          }\n        }\n      }\n      if(dp[i]==true) ans=max(ans,n-bitcount(i,n));\n    }\n    if(n!=0) cout << ans << endl;\n  }\n  return 0;\n \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\nusing namespace std;\n\n#define x real()\n#define y imag()\n#define pb push_back \ntypedef double D;\ntypedef complex<D> P;\ntypedef struct circle{\n\tP p;\n\tD r;\n} C;\n\nint rel[24];\nC c[24];\nvector<int> color[4];\nbool used[1<<24];\nint cmax;\n\nbool IC(C a,C b){\n\tD d=norm(a.p-b.p);\n\tD r=(a.r+b.r)*(a.r+b.r);\n\treturn d<r;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n, n){\n\t\tcmax=0;\n\t\tfor(int i=0;i<4;i++){\n\t\t\twhile(!color[i].empty())\n\t\t\t\tcolor[i].pop_back();\n\t\t}\n\t\tfor(int i=0;i<24;i++)\n\t\t\trel[i]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tmp;\n\t\t\tcin >> c[i].p.x >> c[i].p.y >> c[i].r;\n\t\t\tcin >> tmp;\n\t\t\tcolor[tmp-1].pb(i);\n\t\t}\n\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<i;j++)\n\t\t\t\trel[i]=(rel[i]|(IC(c[i],c[j])<<j);\n\n\t\tuse[(1<<n)-1]=true;\n\t\tfor(int u=(1<<n)-1;u>=0;u--){\n\t\t\tif(!use[u])\n\t\t\t\tcontinue;\n\t\t\tint res=0;\n\t\t\tint tmp=u;\n\t\t\twhile(tmp){\n\t\t\t\tif(tmp&1)\n\t\t\t\t\tres++;\n\t\t\t\ttmp >>=1;\n\t\t\t}\n\t\t\tcmax=max(cmax,n-res);\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tfor(int j=0;j<color[i].size();j++){\n\t\t\t\t\tif(u >>color[i][j]&0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(rel[color[i][j]]&u)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor(int k=j+1;k<color[i].size();k++){\n\t\t\t\t\t\tif(u >>color[i][k]&0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif(rel[color[i][k]]&u)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tused[u|(1<<color[i][j])|(1<<color[i][k])]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cmax << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <bitset>\nusing namespace std;\n\ntypedef complex< int > Point;\n\nint N;\nPoint p[24];\nint R[24], C[24];\nshort f[1 << 24];\n\nvoid read_plate(void);\nvoid solve(void);\nshort dp(int);\nbool is_valid(int, int);\n\nint main() {\n  while (cin >> N, N) {\n    read_plate();\n    solve();\n  }\n\n  return 0;\n}\n\nvoid read_plate(void) {\n  for (int i = 0; i < N; ++i) {\n    int x, y;\n    cin >> x >> y >> R[i] >> C[i];\n    p[i] = Point(x, y);\n  }\n}\n\nvoid solve(void) {\n  fill(&f[0], &f[1 << N], short(-1));\n  cout << dp((1 << N) - 1) << endl;\n}\n\nshort dp(int m) {\n  if (f[m] != -1) return f[m];\n  if (m == 0)     return short(0);\n\n  f[m] = short(0);\n//  cout << \"m = \" << bitset< 7 >(m) << endl;\n  for (int i = 0; i < N; ++i)\n    if ((1 << i & m) && is_valid(i, m))\n      for (int j = 0; j < N; ++j)\n        if ((1 << j & m) && i != j && C[i] == C[j] && is_valid(j, m))\n          f[m] = max(f[m], short(dp(m & ~(1 << i) & ~(1 << j)) + 2));\n\n  return f[m];\n}\n\nbool is_valid(int qi, int qm) {\n  for (int i = qi - 1; i >= 0; --i)\n    if ((1 << i & qm) && norm(p[i] - p[qi]) < (R[i] + R[qi]) * (R[i] + R[qi]))\n      return false;\n  return true;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n\nlong long  mod = 1000000007;\n\n\nbool lap[30][30];\n\n\nbool overlap(int i,int j,vector<int> &x,vector<int>&y,vector<int> &r){\n\tint k = 0;\n\tk = (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]);\n\tif(k>= (r[i]+r[j])*(r[i]+r[j]))return 0;\n\treturn 1;\n}\nint n;\nmap<int,char> dp;\nchar dfs(int s,vector<int>&c){\n\tif(dp[s] == n) return dp[s];\n\tchar k = 0;\n\tfor(int i=0;i<n;i++){\n\t\tif(s&(1<<i)){\n\t\t\tk++;\n\t\t}\n\t}\n\tdp[s] = k;\n\tchar res= k;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(c[i]==c[j]){\n\t\t\t\tif((s&(1<<i))&&(s&(1<<j))){\n\t\t\t\t\tbool fl =1;\n\t\t\t\t\tfor(int p=0;p<i;p++){\n\t\t\t\t\t\tif(lap[p][i]==1&&(s&(1<<p)))fl = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int p=0;p<j;p++){\n\t\t\t\t\t\tif(lap[p][j]==1&&(s&(1<<p)))fl = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(fl){\n\t\t\t\t\t\tres = min(res,dfs(s-(1<<i)-(1<<j),c));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[s] = res;\n}\n\nint main(){\n\twhile(cin >> n && n!=0){\n\t\tvector<int>x(n),y(n),r(n),c(n);\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tfor(int i=0;i<30;i++){\n\t\t\tfor(int j=0;j<30;j++){\n\t\t\t\tlap[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(overlap(i,j,x,y,r)==1){\n\t\t\t\t\tlap[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tbool flag = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\tif(lap[i][j]==0){\n\t\t\t\t\t\tfor(int k=i+1;k<j;k++){\n\t\t\t\t\t\t\tif(lap[i][k]&&lap[k][j]){\n\t\t\t\t\t\t\t\tlap[i][j]=1;\n\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)break;\n\t\t}\n\t\t/*for(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tcout << i <<  \" \" << j << \" \" << lap[i][j] << endl;\n\t\t\t}\n\t\t}*/\n\n\t\tcout << n-(int)dfs((1<<n)-1,c) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint n;\nVI xs, ys, rs, cs;\n//VI memo;\nmap<int, int> memo;\nVVI grp;\n\nVVB nears;\n\nbool is_top(int i, int used) {\n\tfor (int j = i - 1; j >= 0; j--) {\n\t\tif (1 << j & used) continue;\n\n\t\tif (nears[i][j]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint dfs(int used) {\n\tint sum = 0;\n\n//\tif (memo[used] != -1) return memo[used];\n\tif (memo.count(used)) return memo[used];\n\n\tfor(int i = 0;i < n;i++) {\n\t\tfor (auto j : grp[cs[i]]) {\n\t\t\tif(i == j || (1 << i & used) || (1 << j & used)) continue;\n\t\t\tif(cs[i] != cs[j]) continue;\n\t\t\tif(!is_top(i, used) || !is_top(j, used)) continue;\n\n\t\t\tint used_tmp = used;\n\t\t\tused_tmp |= 1 << i;\n\t\t\tused_tmp |= 1 << j;\n\n\t\t\tsum = max(sum, dfs(used_tmp) + 2);\n\t\t}\n\t}\n\n\treturn memo[used] = sum;\n//\treturn sum;\n}\n\nint main(void) {\n\twhile(cin >> n, n){\n\t\txs = VI(n);\n\t\tys = VI(n);\n\t\trs = VI(n);\n\t\tcs = VI(n);\n\n\t\tgrp = VVI(4);\n//\t\tmemo = VI(1 << n, -1);\n\t\tmemo.clear();\n\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n\t\t\tcs[i]--;\n\t\t\tgrp[cs[i]].push_back(i);\n\t\t}\n\n\t\tnears = VVB(n, VB(n));\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint x = (xs[i] - xs[j]) * (xs[i] - xs[j]);\n\t\t\t\tint y = (ys[i] - ys[j]) * (ys[i] - ys[j]);\n\t\t\t\tint dis = x + y;\n\t\t\t\tint dis2 = (rs[i] + rs[j]) * (rs[i] + rs[j]);\n\n\t\t\t\tnears[i][j] = dis < dis2;\n\t\t\t}\n\t\t}\n\n\t\tint used = 0;\n\t\tcout << dfs(used) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n \nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n \nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\n\n\nint n,d[30][30],abosum[30],ans;\nbool abo[30][30],exist[30];\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0)break;\n\t\tans = 0;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tabo[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\texist[i] = true;\n\t\t\tabosum[i] = 0;\n\t\t\tfor(int j = 0;j < 4;j++){\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = i+1;j <= n;j++){\n\t\t\t\tif(  (d[i][0]-d[j][0])*(d[i][0]-d[j][0]) + (d[i][1]-d[j][1])*(d[i][1]-d[j][1]) < (d[i][2]+d[j][2])*(d[i][2]+d[j][2])    ){\n\t\t\t\t\tabo[i][j] = true; abo[j][i] = true;\n\t\t\t\t\tabosum[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t//\tfor(int i = 1;i <= n;i++) cout << \"abo\" << i << \" \" << abosum[i] << endl;\n\n\t\tbool flag = true;\n\t\twhile(flag == true){\n\t\t\tflag = false;\n\t\t\tfor(int i = 1;i <= n;i++){\n\t\t\t\tfor(int j = i+1;j <= n;j++){\n\t\t\t\t\tif(exist[i] == false || exist[j] == false)continue;\n\t\t\t\t\tif(abosum[i] != 0 || abosum[j] != 0) continue;\n\t\t\t\t\tif(d[i][3] != d[j][3]) continue;\n\t\t\t\t\tans += 2;\n\t\t\t\t\texist[i] = false; exist[j] = false;\n\t\t\t\t\tflag = true;\n\t\t\t\t\tfor(int k = i+1;k <= n;k++){\n\t\t\t\t\t\tif(abo[i][k] == true){\n\t\t\t\t\t\t\tabosum[k]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = j+1;k <= n;k++){\n\t\t\t\t\t\tif(abo[j][k] == true){\n\t\t\t\t\t\t\tabosum[k]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nstruct cp {\n    int a, b;\n    vector<int> ul;\n};\nstruct circle {\n    int x, y, r, c;\n};\nchar done[1<<24];\nvector<cp> pl;\nint n;\n\nbool intersect(circle &c1, circle &c2) {\n    int dx = c1.x - c2.x;\n    int dy = c1.y - c2.y;\n    int dst2 = dx*dx + dy*dy;\n    return dst2 < (c1.r + c2.r) * (c1.r + c2.r);\n}\n\nbool get(int state, int pos) {\n    return (state>>pos)&1;\n}\n\nint dfs(int state) {\n    int ret = n - __builtin_popcount(state);\n    if(state == 0) return ret;\n    if(done[state]) return 0;\n    done[state] = 1;\n\n    rep(i, pl.size()) {\n        if(get(state, pl[i].a) and get(state, pl[i].b)) {\n            bool ok = true;\n            vector<int> &ul = pl[i].ul;\n            rep(j, ul.size()) {\n                if(get(state, ul[j])) ok = false;\n            }\n            if(ok) {\n                int next_state = state;\n                next_state -= (1<<pl[i].a);\n                next_state -= (1<<pl[i].b);\n                ret = max(ret, dfs(next_state));\n            }\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    while(cin >> n, n) {\n        memset(done, 0, sizeof(done));\n        vector<circle> cv;\n        rep(i, n) {\n            int x, y, r, c;\n            cin >> x >> y >> r >> c;\n            cv.pb((circle){x, y, r, c});\n        }\n\n        pl.clear();\n        rep(i, n) repi(j, i+1, n) if(cv[i].c == cv[j].c && !intersect(cv[i], cv[j])){\n            cp tcp;\n            tcp.a = i, tcp.b = j;\n            rep(k, n) if((k < i && intersect(cv[k], cv[i])) or\n                         (k < j && intersect(cv[k], cv[j]))) tcp.ul.pb(k);\n            pl.pb(tcp);\n        }\n\n        cout << dfs((1<<n) - 1) << endl;\n    }\n\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint solve(const vector<int>&cs,const vector<vector<int> >& cover,int bit,vector<char>& memo)\n{\n\tif(memo[bit]!=-1)\n\t\treturn memo[bit];\n\tint n=cs.size();\n\tint res=0;\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(cs[i]!=cs[j])\n\t\t\t\tcontinue;\n\t\t\tif((bit&1<<i) || (bit&1<<j))\n\t\t\t\tcontinue;\n\t\t\tbool ok=true;\n\t\t\tfor(int k=0;k<i;k++)\n\t\t\t\tok&=(bit&1<<k) || cover[i][k]==0;\n\t\t\tfor(int k=0;k<j;k++)\n\t\t\t\tok&=(bit&1<<k) || cover[j][k]==0;\n\t\t\tif(!ok)\n\t\t\t\tcontinue;\n\t\t\tres=max(res,2+solve(cs,cover,bit|1<<i|1<<j,memo));\n\t\t}\n\treturn memo[bit]=res;\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tvector<int> xs(n),ys(n),rs(n),cs(n);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>xs[i]>>ys[i]>>rs[i]>>cs[i];\n\t\tvector<vector<int> > cover(n,vector<int>(n));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tint x=xs[j]-xs[i],y=ys[j]-ys[i],r=rs[i]+rs[j];\n\t\t\t\tif(x*x+y*y<r*r)\n\t\t\t\t\tcover[i][j]=1;\n\t\t\t}\n\t\t}\n\t\tvector<char> memo(1<<n,-1);\n\t\tint res=solve(cs,cover,0,memo);\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nvector<int> x,y,r,c,cover;\nvector<bool> already;\nint dfs(int n,int sta){\n  if(already[sta]) return 0;\n  already[sta]=true;\n  int answer=0;\n  REP(j,n){\n    if((cover[j]&sta)||((1<<j)&(~sta))) continue;\n    REP(i,j){\n      if((cover[i]&sta)||((1<<i)&(~sta))) continue;\n      if(c[i]==c[j]) answer=max(answer,2+dfs(n,sta&(~(1<<i))&(~(1<<j))));\n    }\n  }\n  return answer;\n}\nint solve(int n){\n  x.resize(n);\n  y.resize(n);\n  r.resize(n);\n  c.resize(n);\n  REP(i,n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n  cover.assign(n,0);\n  REP(j,n) REP(i,j){\n    if((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])<(r[i]+r[j])*(r[i]+r[j]))\n      cover[j]=(cover[j]|(1<<i));\n  }\n  already.assign((1<<n),false);\n  return dfs(n,(1<<n)-1);\n}\nint main(void)\n{\n  for(;;){\n    int n;\n    cin >> n;\n    if(!n) return 0;\n    cout << solve(n) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<vector>\n#include<algorithm>\n#define F first\n#define S second\n#define pb push_back\n#define EPS 1e-10\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint n,ans;\nbool used[1000];\nvector<PP> p;\nvector<int> rank;\n\nvoid ranking(){\n  for(int i=0;i<p.size();i++)rank.pb(1);\n\n  for(int i=0;i<p.size();i++){\n    for(int j=i+1;j<p.size();j++){\n      double r1 = p[i].S.F,r2 = p[i].S.F,d = sqrt(pow(p[i].F.F-p[j].F.F,2)+pow(p[i].F.S-p[j].F.S,2));\n      if(fabs(r1-r2) < d  && d < (r1+r2) ){ //cross each other on two different points\n\trank[j]++;\n      }\n      else if(fabs(d-(r1+r2)) < EPS){ //be circumscribed\n      }\n      else if(fabs(d-fabs(r1-r2)) < EPS){ // be inscribed\n\trank[j]++;\n      }\n      else{\n      }\n    }\n  }\n}\n\n\nvoid rankIncrease(int x,int y){\n \n  for(int i=0;i<rank.size();i++){\n    if(y == i)continue;\n    if(i == x){\n      rank[i]++;\n      continue;\n    }\n double r1 = p[x].S.F,r2 = p[i].S.F,d = sqrt(pow(p[x].F.F-p[i].F.F,2)+pow(p[x].F.S-p[i].F.S,2));\n if(fabs(r1-r2) < d  && d < (r1+r2) && x<i){ //cross each other on two different points\n\trank[i]++;\n      }\n      else if(fabs(d-(r1+r2)) < EPS && x<i){ //be circumscribed\n      }\n      else if(fabs(d-fabs(r1-r2)) < EPS && x<i){ // be inscribed\n\trank[i]++;\n      }\n      else{\n      }\n  }\n}\n\n  void rankDecrease(int x,int y){\n  for(int i=0;i<rank.size();i++){\n    if(i == y)continue;\n    if(i == x){\n      rank[i]--;\n      continue;\n    }\n    double r1 = p[x].S.F,r2 = p[i].S.F,d = sqrt(pow(p[x].F.F-p[i].F.F,2)+pow(p[x].F.S-p[i].F.S,2));\n if(x<i && fabs(r1-r2) < d  && d < (r1+r2)){ //cross each other on two different pointsq\n\t  rank[i]--;\n      }\n      else if(x<i && fabs(d-(r1+r2)) < EPS){ //be circumscribed\n      }\n      else if(x<i && fabs(d-fabs(r1-r2)) < EPS){ // be inscribed\n\trank[i]--;\n      }\n      else{\n      }\n  }\n}\n\n\n\n\n\nvoid rec2(int cnt){\n \n   for(int i=0;i<rank.size();i++){\n    //cout << ans << endl;\n    if(rank[i] == 1 ){\n      for(int j=0;j<rank.size();j++){\n\tif(i == j || rank[j] <= 0)continue;\n\tif(p[i].S.S == p[j].S.S && rank[j] == 1){//usedつかったrtsdkrkm\t\n\n  rankDecrease(i,j); rankDecrease(j,i);\n \n\t  rec2(cnt+2);\n\t  rankIncrease(i,j); rankIncrease(j,i);\n\t}\n      }\n    }\n  }\n \n  ans = max(ans,cnt);\n}\n\nint main(){\n  \n  while(cin >> n && n){ \n    ans = 0;\n    for(int i=0;i<n;i++)used[i] = false;\n    p.clear(); rank.clear();\n    for(int i=0;i<n;i++){\n      int x,y,r,c;\n      cin >> x >> y >> r >> c;\n      p.pb(PP(P(x,y),P(r,c)));\n    }\n    ranking();\n   \n     rec2(0);   \n \n     cout << ans << endl;\n  }\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n\nvoid rec(int cnt){\n\n  int j=0,flag = 0;\n  bool fl = true;\n  while(fl){ \n\n    if(rank[j] == 0){\n    \n    j++;\n      if(j%n == 0 && j!=0){\n\tj=0;\n\tif(finish()){\n\t  ans = max(ans,cnt);\n\t  fl = false;\n\t  return;\n\t}\n\tflag = 0;\n      }\n      continue;\n    }\n\n    if(rank[j] == 1){\n      for(int i=0;i<rank.size();i++){      \n\tif(i == j || rank[i] <= 0)continue;\n\tif(rank[i] == 1 && p[j].S.S == p[i].S.S){\n\t  flag++;\n\t  rankDecrease(i);\n\t  rankDecrease(j);\n\t  rec(cnt+2);\n\t  rankIncrease(i);\n\t  rankIncrease(j);\n\t  flag--;\n\t}\n      }\n    }\n\n    j++;\n\n    if(j%n == 0 && j!=0){\n      j=0;\n      if(finish()){\n\tans = max(ans,cnt);\n\tfl = false;\n\treturn;\n      }\n      flag= 0;\n    }\n  }\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=200005,INF=1<<28;\nconst int MAX_N=20000000;\nconst double eps=1e-07;\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N;cin>>N;\n        vector<int> dp(1<<N);\n        if(N==0) break;\n        vector<double> x(N),y(N),r(N),c(N);\n        for(int i=0;i<N;i++){\n            cin>>x[i]>>y[i]>>r[i]>>c[i];\n            c[i]--;\n        }\n        \n        dp[0]=1;\n        \n        for(int bit=0;bit<(1<<N);bit++){\n            if(!dp[bit]) continue;\n            \n            vector<vector<int>> use(4,vector<int>());\n            \n            for(int j=0;j<N;j++){\n                if(bit&(1<<j)) continue;\n                bool ok=true;\n                \n                for(int k=0;k<j;k++){\n                    if(bit&(1<<k)) continue;\n                    \n                    if(hypot(x[j]-x[k],y[j]-y[k])<=r[j]+r[k]-eps){\n                        ok=false;\n                        break;\n                    }\n                }\n                \n                if(ok) use[c[j]].push_back(j);\n            }\n            \n            for(int i=0;i<4;i++){\n                if(use[i].size()<=1) continue;\n                \n                for(int j=0;j<(1<<use[i].size());j++){\n                    if(__builtin_popcount(j)!=2) continue;\n                    int to=bit;\n                    \n                    for(int k=0;k<use[i].size();k++){\n                        if(j&(1<<k)) to|=(1<<use[i][k]);\n                    }\n                    \n                    dp[to]=1;\n                }\n            }\n        }\n        \n        int ans=0;\n        \n        for(int bit=0;bit<(1<<N);bit++){\n            if(dp[bit]) ans=max(ans,__builtin_popcount(bit));\n        }\n        \n        cout<<ans<<endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <iostream>\n\nusing namespace std;\n\nint pow2(int m){\n\treturn m * m;\n};\n\nint n, m, c[24], d, p[24];\n\nint bitnum(int n){\n\tint cnt;\n\tcnt = 0;\n\twhile(n){\n\t\tif(n % 2 == 1) cnt++;\n\t\tn /= 2;\n\t}\n\treturn cnt;\n}\n\nint main(void){\n\tint x[24], y[24], r[24], i, j, k, dp[1 << 24];\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n\t\tmemset(p,0,sizeof(p));\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < i;j++)\n\t\t\t\tif(sqrt((double)pow2(x[i] - x[j]) + pow2(y[i] - y[j])) < r[i] + r[j]) p[i] += 1 << j;\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0] = 1;\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i]){\n\t\t\t\tfor(j = 0;j < n - 1;j++){\n\t\t\t\t\tfor(k = j + 1;k < n;k++)\n\t\t\t\t\t\tif(c[j] == c[k] && ~i & (1 << j) && ~i & (1 << k) && (i & p[j]) == p[j] && (i & p[k]) == p[k]) dp[i + (1 << j) + (1 << k)] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tm = 0;\n\t\tfor(i = 0;i < 1 << n;i++){\n\t\t\tif(dp[i])\n\t\t\t\tm = max(m,bitnum(i));\n\t\t}\n\t\tprintf(\"%d\\n\",m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#define HIT(a,b) ((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r))\n\nusing namespace std;\n\nchar Log[90][30];\nint Logcnt;\n\nstruct DISK {\n\tint x,y,r,c,f;\n};\nint n;\n\nvoid setontop(DISK *D){\n\tint i,j;\n\tfor(i=0;i<n;i++){\n\t\tD[i].f=D[i].r;\n\t\tfor(j=i+1;j<n;j++)\n\t\t\tif(D[j].r && HIT(D[i],D[j])) D[i].f=0;\n//\t\tprintf(\"ontop%d %d\\n\", i, D[i].f);\n\t}\n}\n\nint checkLog(DISK *D){\n\tint i,j;\n\tfor(i=0;i<Logcnt;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif((D[j].r && !Log[i][j]) || (!D[j].r && Log[i][j])) break;\n\t\t}\n\t\tif(j==n){\n\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint solve(DISK *D){\n\tint i,j,k,min=30,ret;\n\tif(checkLog(D)) return 30;\n\tfor(i=0;i<n;i++) Log[Logcnt][i]=D[i].r;\n\tLogcnt ++;\n\tsetontop(D);\n\tfor(i=1;i<=4;i++){\n\t\tchar list[6],li=0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(D[j].f&&D[j].c==i) list[li++]=j;\n\t\t}\n//\t\tprintf(\"%d %d\\n\",i,li);\n\t\tif(li<2)continue;\n\t\tDISK tmp[30];\n\t\tfor(j=0;j<li;j++){\n\t\t\tfor(k=j+1;k<li;k++){\n//\t\t\t\tprintf(\"remove(%d,%d)\", list[j],list[k]);\n\t\t\t\tmemcpy(tmp,D,sizeof(tmp));\n\t\t\t\ttmp[list[j]].r=0;\n\t\t\t\ttmp[list[k]].r=0;\n\t\t\t\tret=solve(tmp);\n\t\t\t\tif(ret<min)min=ret;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ret=0,i=0;i<n;i++)if(D[i].r)ret++;\n\tif(ret<min)min=ret;\n//\tprintf(\"return %d\\n\", min);\n\treturn min;\n}\n\nint main(){\n\tint i,j;\n\twhile(cin>>n,n){\n\t\tDISK D[30];\n\t\tLogcnt=0;\n\t\tfor(i=n;i-->0;) cin>>D[i].x>>D[i].y>>D[i].r>>D[i].c;\n\t\tcout<<n-solve(D)<<endl;\n\t}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    return (a.r + b.r) > sqrt((a.x - b.x) * (a.x - b.x) +\n                              (a.y - b.y) * (a.y - b.y));\n}\n\nint main()\n{\n    int n;\n\n    while (cin >> n, n) {\n        vector<int> dp(1 << n, 0), up(n, 0);\n        vector<Circle> c(n);\n\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                if (isOverlap(c[i], c[j])) {\n                    if (i < j) // jの上にiがある\n                        up[j] |= 1 << i;\n                    else // iの上にjがある\n                        up[i] |= 1 << j;\n                }\n\n        for (int s = 0; s < 1 << n; ++s) {\n            for (int i = 0; i < n; ++i) {\n                if (s >> i & 1 || s & up[i])  // c[i]が既に置かれているかc[i]が置けない\n                    continue;\n                for (int j = i + 1; j < n; ++j) {\n                    if (c[i].c != c[j].c) // 色が異なる\n                        continue;\n                    if (s >> j & 1 || s & up[j])  // c[j]が既に置かれているかc[j]が置けない\n                        continue;\n                    if (up[i] >> j & 1 || up[j] >> i & 1) // c[i]とc[j]を同時に置けない\n                        continue;\n                    int nxt = s | 1 << i;\n                    nxt = nxt | 1 << j;\n                    dp[nxt] += dp[s] + 2;\n                }\n            }\n        }\n\n        cout << dp[(1 << n) - 1] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define FOR(i,a,n) for(int i=a;i<n;++i)\n#define REP(i,n) FOR(i,0,n)\n\nstruct disk{\n\tint x,y,r,c,n;\n};\nbool on(disk l,disk r){\n\treturn(pow(l.r+r.r,2.0)>pow(l.x-r.x,2.0)+pow(l.y-r.y,2.0));\n}\nstruct tree{\n\tdisk d;\n\tvector<tree> children;\n\tint depth;\n\ttree(disk d,int depth):d(d),depth(depth){\n\t}\n\ttree(){d.n=-1;depth=0;}\n\tvoid add(disk &other){\n\t\tif(!add_r(other)){\n\t\t\tchildren.push_back(tree(other,depth+1));\n\t\t}\n\t}\n\tbool add_r(disk &other){\n\t\tif(children.empty()){\n\t\t\tif(on(d,other)){\n\t\t\t\tchildren.push_back(tree(other,depth+1));\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].add_r(other)){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\tif(on(d,other)){\n\t\t\t\t\tchildren.push_back(tree(other,depth+1));\n\t\t\t\t\treturn true;\n\t\t\t\t}else{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tvoid leaves(vector<tree*> &trees){\n\t\tif(children.empty()){\n\t\t\ttrees.push_back(this);\n\t\t}else{\n\t\t\tREP(i,children.size()){\n\t\t\t\tchildren[i].leaves(trees);\n\t\t\t}\n\t\t}\n\t}\n\tbool dlt(disk &dd){\n\t\tif(children.empty()){\n\t\t\treturn false;\n\t\t}\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].d.n==dd.n){\n\t\t\t\tchildren.erase(children.begin()+i);\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\tif(children[i].dlt(dd))return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n/*\nint dfs(tree &t){\n\tvector<disk> leaves;\n\tt.leaves(leaves);\n\tint best=0;\n\tREP(i,leaves.size()){\n\t\tFOR(j,i+1,leaves.size()){\n\t\t\tif(leaves[i].c==leaves[j].c){\n\t\t\t\ttree nt(t);\n\t\t\t\tnt.dlt(leaves[i]);\n\t\t\t\tnt.dlt(leaves[j]);\n\t\t\t\tbest=max(best,dfs(nt)+2);\n\t\t\t}\n\t\t}\n\t}\n\treturn best;\n}\n*/\n\nbool pred(tree *l,tree *r){\n\treturn l->depth>r->depth;\n}\nint greedy(tree &t){\n\tvector<tree*> leaves;\n\tt.leaves(leaves);\n\tsort(leaves.begin(),leaves.end(),pred);\n\tREP(i,leaves.size()){\n\t\tFOR(j,i+1,leaves.size()){\n\t\t\tif(leaves[i]->d.c==leaves[j]->d.c){\n\t\t\t\ttree nt(t);\n\t\t\t\tnt.dlt(leaves[i]->d);\n\t\t\t\tnt.dlt(leaves[j]->d);\n\t\t\t\treturn greedy(nt)+2;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\ttree t;\n\t\tvector<disk> disks;\n\t\tREP(i,n){\n\t\t\tdisk d;\n\t\t\tcin>>d.x>>d.y>>d.r>>d.c;\n\t\t\td.n=i;\n\t\t\tdisks.push_back(d);\n\t\t}\n\t\tREP(i,n){\n\t\t\tt.add(disks[n-i-1]);\n\t\t}\n\t\tcout<<greedy(t)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\n\n#define REP(i, n) for (int (i) = 0; (i) < (int)(n); ++(i))\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) {\n    return s << '<' << P.first << \", \" << P.second << '>';\n}\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) {\n    for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s << endl;\n}\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) {\n    EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl;\n}\ntemplate<class T> void print(T a, T b) { \n    for (T i = a; i != b; ++i) { if (i != a) { cout << \" \"; } cout << *i; } cout << endl; \n}\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n\n\ndouble abs(double x, double y) { return sqrt(x*x+y*y); }\n          \nint c[40];\nint cover[40];\nshort dp[(1<<24)+100];\n\nint n;\ndouble x[40], y[40], r[40];\n\nint rec(int bit) {\n    if (dp[bit] != -1) return dp[bit];\n    \n    if (bit == 0) return 0;\n    if (__builtin_popcount(bit) == 1) return 0;\n    \n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        if ((bit & cover[i]) || !(bit & (1<<i))) continue;\n        for (int j = i+1; j < n; ++j) {\n            if ((bit & cover[j]) || !(bit & (1<<j))) continue;\n            \n            if (c[i] == c[j]) {\n                int nbit = bit ^ (1<<i) ^ (1<<j);\n                int tmp = rec(nbit);\n                res = max(res, tmp + 2);\n            }\n        }\n    }\n    \n    //cout << bitset<7>(bit) << \" : \" << res << endl;\n                \n    return dp[bit] = res;\n}\n\nint main() {\n    while (cin >> n) {\n        if (n == 0) break;\n    \n        for (int i = 0; i < n; ++i) {\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n            \n            cover[i] = 0;\n            for (int j = 0; j < i; ++j) {\n                if ( abs(x[i]-x[j], y[i]-y[j]) < r[i]+r[j]-1e-9 ) {\n                    cover[i] |= (1<<j);\n                }\n            }\n            //cout << i << \" : \" << cover[i] << endl;\n        }\n        \n        memset(dp, -1, sizeof(dp));\n        cout << rec( (1<<n)-1 ) << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint n;\nint x[25],y[25],r[25],c[25];\nint cover[25];\ndouble d[25][25];\nbool check[1<<25];\nint cnt,comb,a,b;\nint m,ans;\nint u;\n\ndouble dis(int i,int j){\n  return sqrt( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j]) * (y[i]-y[j]) );\n}\n\nvoid cov(int a){\n  cover[a] = -1;\n  for(int j=a-1;j>=0;j--){\n    if(d[j][a]<r[a]+r[j] && u>>j & 1){\n      cover[a] = j;\n      break;\n    }\n  }\n} \n\n  \nvoid rec(void){\n  int cnt;\n  for(int i=1;i<=4;i++){\n    cnt = 0;\n    /*\n    for(int j=0;j<n;j++){\n      if( (u>>j & 1) && cover[j]<0 && c[j] == i)cnt++;\n    }\n    if(cnt==6){\n      for(int j=0;j<n;j++){\n\tif(c[j] == i)u -= 1<<j;\n      }\n      for(int j=0;j<n;j++)cov(j);\n\n      ans += 6;\n      m = max(m,ans);\n      if(!check[u]){\n\trec();\n\tcheck[u] = true;\n      }\n      ans -= 6;\n\n      for(int j=0;j<n;j++){\n\tif(c[j] == i)u += 1<<j;\n      }\n      for(int j=0;j<n;j++)cov(j);\n    }else{\n    */\n      for(int j=0;j<n;j++){\n\tif( (u>>j & 1) && cover[j]<0 && c[j] == i){\n\t  for(int k=j+1;k<n;k++){\n\t    if( (u>>k & 1) && cover[k]<0 && c[k] == i){\n\t      u -= 1<<j;\n\t      u -= 1<<k;\n\t      for(int l=0;l<n;l++)cov(l);\n\n\t      ans += 2;\n\t      m = max(m,ans);\n\t      if(!check[u]){\n\t\trec();\n\t\tcheck[u] = true;\n\t      }\n\t      ans -= 2;\n\n\t      u += 1<<j;\n\t      u += 1<<k;\n\t      for(int l=0;l<n;l++)cov(l);\n\t    }\n\t  }\n\t}\n      }\n      //}\n  }\n}\n\n\n\nint main(){\n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    for(int i=0;i<n;i++)cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++)d[i][j] = dis(i,j);\n    }\n\n    u = (1<<n) - 1;\n    for(int i=0;i<(1<<n);i++)check[i] = false;\n    for(int i=0;i<n;i++)cov(i);\n\n    \n    m = 0;\n    ans = 0;\n    rec();\n\n    cout << m << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <stack>\n#include <bitset>\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vi2;\n\nint solve();\n\nint main(void) {\n\n\twhile (solve()){}\n\n\treturn 0;\n\n}\n\nint solve() {\n\n\tint n;\n\tcin >> n;\n\tif (!n) { return 0; }\n\n\t//input\n\tvector<bool> visited((1 << n),false);\n\n\n\tvi x(n), y(n), r(n), c(n);\n\tvi2 con(n, vi(n,0));\n\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\n\t//are circles touching\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint dx, dy, dr, d;\n\t\t\t\tdx = x[i] - x[j];\n\t\t\t\tdy = y[i] - y[j];\n\t\t\t\tdr = r[i] + r[j];\n\t\t\t\td = dx*dx + dy*dy;\n\t\t\tif (dr*dr > d) {\n\t\t\t\tcon[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t//depth first search\n\n\tint ans = 0;\n\n\tstack<int> q;\n\tq.push( 0 );\n\n\twhile ( !q.empty() && ans < n ) {\n\n\t\tint p = q.top();\n\t\tq.pop();\n\t\tvisited.at(p) = true;\n\n\t\tans = max(ans,(int)bitset<32>(p).count());\n\t\t\n\t\t//remove two disks\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\tif (p & (1 << i)) { continue; }\n\n\t\t\tfor (int j = i+1; j < n; j++) {\n\n\t\t\t\tif (p & (1 << j)) { continue; }\n\t\t\t\tif (c[i] != c[j]) { continue; }\n\n\t\t\t\tbool b = false;\n\t\t\t\tfor (int k = 0; k < i && b == false; k++) {\n\t\t\t\t\tb |= (con[k][i] != 0 && ( ( p & ( 1 << k ) ) == 0 ) );\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < j && b == false; k++) {\n\t\t\t\t\tb |= (con[k][j] != 0 && ( ( p & ( 1 << k ) ) == 0 ) );\n\t\t\t\t}\n\n\t\t\t\tif ( !b ) {\n\n\t\t\t\t\tint next = (p | (1 << i) | (1 << j));\n\t\t\t\t\tif (!visited.at(next)) {\n\t\t\t\t\t\tq.push(next);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t}\n\tcout << ans << endl;\n\n\treturn 1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n \nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n \nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\n\n\nint n,d[30][30],abosum[30],ans;\nbool abo[30][30],exist[30];\n\nvoid solve(int tmpans,bool texist[30],int tabosum[30]){\n\tans = max(ans,tmpans);\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = i+1;j <= n;j++){\n\t\t\tif(texist[i] == false || texist[j] == false)continue;\n\t\t\tif(tabosum[i] != 0 || tabosum[j] != 0) continue;\n\t\t\tif(d[i][3] != d[j][3]) continue;\n\t\t\tbool tmpexist[30];\n\t\t\tfor(int k = 1;k <= n;k++){\n\t\t\t\ttmpexist[k] = texist[k];\n\t\t\t\tif(k == i || k == j) tmpexist[k] = false;\n\t\t\t}\n\t\t\tint tmpabosum[30];\n\t\t\tfor(int k = 1;k <= n;k++){\n\t\t\t\ttmpabosum[k] = tabosum[k];\n\t\t\t\tif( abo[i][k] == true && i < k )tmpabosum[k]--;\n\t\t\t\tif( abo[j][k] == true && j < k )tmpabosum[k]--;\n\t\t\t}\n\t\t\tsolve(tmpans+2,tmpexist,tmpabosum);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0)break;\n\t\tans = 0;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tabo[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\texist[i] = true;\n\t\t\tabosum[i] = 0;\n\t\t\tfor(int j = 0;j < 4;j++){\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = i+1;j <= n;j++){\n\t\t\t\tif(  (d[i][0]-d[j][0])*(d[i][0]-d[j][0]) + (d[i][1]-d[j][1])*(d[i][1]-d[j][1]) < (d[i][2]+d[j][2])*(d[i][2]+d[j][2])    ){\n\t\t\t\t\tabo[i][j] = true; abo[j][i] = true;\n\t\t\t\t\tabosum[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve(0,exist,abosum);\n\t//\tfor(int i = 1;i <= n;i++) cout << \"abo\" << i << \" \" << abosum[i] << endl;\n/*\n\t\tbool flag = true;\n\t\twhile(flag == true){\n\t\t\tflag = false;\n\t\t\tfor(int i = 1;i <= n;i++){\n\t\t\t\tfor(int j = i+1;j <= n;j++){\n\t\t\t\t\tif(exist[i] == false || exist[j] == false)continue;\n\t\t\t\t\tif(abosum[i] != 0 || abosum[j] != 0) continue;\n\t\t\t\t\tif(d[i][3] != d[j][3]) continue;\n\t\t\t\t\tans += 2;\n\t\t\t\t\texist[i] = false; exist[j] = false;\n\t\t\t\t\tflag = true;\n\t\t\t\t\tfor(int k = i+1;k <= n;k++){\n\t\t\t\t\t\tif(abo[i][k] == true){\n\t\t\t\t\t\t\tabosum[k]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = j+1;k <= n;k++){\n\t\t\t\t\t\tif(abo[j][k] == true){\n\t\t\t\t\t\t\tabosum[k]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint foo(int S, vector<int>& c, vector<int>& a) {\n\tint n = c.size(), cnt = 0;\n\tvector< vector<int> > v(4);\n\tfor (int i = 0; i < n; i++)\n\t\tif (S & (1 << i)) {\n\t\t\tcnt++;\n\t\t\tif (!(S & a[i])) v[c[i] - 1].push_back(i);\n\t\t}\t\n\tint mini = cnt;\n\tfor (int j = 0; j < 4; j++) {\n\t\tint m = v[j].size();\n\t\tfor (int k = 0; k < m; k++)\n\t\t\tfor (int _k = k + 1; _k < m; _k++) {\n\t\t\t\tint _S = S - (1 << v[j][k]) - (1 << v[j][_k]);\n\t\t\t\tmini = min(mini, foo(_S, c, a));\n\t\t\t}\n\t}\n\treturn mini;\n}\n\nint main() {\n\tfor (;;) {\n\t\tint n; cin >> n;\n\t\tif (n == 0) break;\n\t\tvector<int> x(n), y(n), r(n), c(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tint dx = x[i] - x[j], dy = y[i] - y[j], d = r[i] + r[j];\n\t\t\t\tif (dx * dx + dy * dy < d * d) a[i] |= (1 << j);\n\t\t\t}\n\t\tcout << n - foo((1 << n) - 1, c, a) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\nll inf =  1e9;\ntypedef pair<mp,ll> mmp;\n\nint main(){\n    while(1){\n\tint n;\n\tcin>>n;\n\tif(n==0)break;\n\tvector<mmp> cir(n);\n\tvector<ll> c(n);\n\tfor(int i=0;i<n;i++){\n\t    int x,y,r;\n\t    cin>>x>>y>>r>>c[i];\n\t    cir[i] = mmp(mp(x,y),r );\n\t}\n\tvector<vector<int>> g(n);\n\tfor(int i=0;i<n;i++){\n\t    for(int j=i-1;j>=0;j--){\n\t\tint dis = (cir[i].first.first-cir[j].first.first)*(cir[i].first.first-cir[j].first.first) + (cir[i].first.second-cir[j].first.second)*(cir[i].first.second-cir[j].first.second);\n\t\tint rM = ( cir[i].second + cir[j].second);\n\t\trM = rM * rM;\n\t\tint rm = (cir[i].second-cir[j].second);\n\t\trm = rm*rm;\n\t\t//if( rm < dis && dis < rM){\n\t\tif( dis < rM ){\n\t\t    g[i].push_back(j);\n\t\t    //break;\n\t\t}\n\t    }\n\t}\n\tint res = 0;\n\tvector<bool> dp(1<<n,false);\n\tdp[(1<<n)-1] = true;\n\t//for(int i=0;i<g.size();i++)cout<<g[i]<<endl;\n\tfor(int i= (1<<n)-1 ;i>=0;i--){\n\t    if(dp[i]){\n\t\t//cout<<i<<':'<<endl;\n\t\tint cnt = 0;\n\t\tfor(int j=0;j<n;j++)if( ((i>>j) & 1) == 0 ) cnt++; \n\t\tres = max(res,cnt);\n\t\tvector<int> use;\n\t\tfor(int j=0;j<n;j++){\n\t\t    if( ((i>>j) & 1) == 0) continue;\n\t\t    \n\t\t    int now = j;\n\t\t    bool flag = true;\n\t\t    for(int k=0;k<g[j].size();k++){\n\t\t\tif( ( (i>>g[j][k] ) & 1 )==1 ){\n\t\t\t    flag = false;\n\t\t\t    //cout<<g[now]<<endl;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if(flag)use.push_back(j);\n\t\t}\n\t\t//for(int j=0;j<use.size();j++) cout<<use[j]<<endl;\n\t\t//for(int j=0;j<use.size();j++) if(  ((i>>use[j])&1) == 0 ) cout<<\"ERROR\"<<endl;\n\t\tfor(int j=0;j<use.size();j++){\n\t\t    for(int k=j+1;k<use.size();k++){\n\t\t\tif( c[use[j]] == c[ use[k] ] ){\n\t\t\t    dp[ i ^ (1<<use[j] ) ^(1<<use[k]) ] = true;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tcout<<res<<endl;\n\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst double EPS = 1e-9;\n\nstruct Circle{\n    point p;\n    double r;\n    int c;\n    Circle(int x,int y,double r,int c) : p(x,y),r(r),c(c) {}\n};\n\nbool is_intersected_circle(const Circle& a,const Circle& b){\n    return abs(a.p-b.p)<(a.r + b.r)-EPS;\n}\n\ninline int popcount(int x){\n    int ret = 0;\n    while(x){\n        x &= x-1;\n        ret++;\n    }\n    return ret;\n}\n\nvoid cerr_bits(int x,int n){\n    for(int i=0;i<n;i++){\n        cerr << ((x&(1 << i)) != 0) << \" \";\n    }\n    cerr << endl;\n}\nint solve(const vector<Circle>& cs){\n    int n = cs.size();\n\n    vector<vector<char> > override(n,vector<char>(n,false));\n    for(int i=0;i<n;i++){\n        for(int j=i;j<n;j++){\n            if(is_intersected_circle(cs[i],cs[j])){\n                override[i][j] = override[j][i] = true;\n            }\n        }\n    }\n\n    stack<int> S;\n    int ret = 0;\n    S.push(0);\n    set<int> alr;\n    while(not S.empty()){\n        int cur = S.top();\n        S.pop();\n        if(alr.find(cur) != alr.end()) continue;\n        alr.insert(cur);\n        ret = max(ret,popcount(cur));\n        vector<char> ov(n,false);\n        for(int i=0;i<n;i++){\n            if(cur & (1 << i)) continue;\n            for(int j=i+1;j<n;j++){\n                if(cur & (1 << j)) continue;\n                if(override[i][j]){\n                    ov[j] = true;\n                }\n            }\n        }\n        for(int i=0;i<n;i++){\n            if((cur & (1 << i)) || ov[i]) continue;\n            if(ov[i]) continue;\n            for(int j=i+1;j<n;j++){\n                if((cur & (1 << j)) || ov[j]) continue;\n                if(cs[i].c == cs[j].c){\n                    int here = cur;\n                    here |= (1 << i);\n                    here |= (1 << j);\n                    S.push(here);\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nint main(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n        vector<Circle> cs;\n        for(int i=0;i<n;i++){\n            int x,y,r,c;\n            cin >> x >> y >> r >> c;\n            cs.push_back(Circle(x,y,r,c));\n        }\n        cout << solve(cs) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\nchar bit_count[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            if(((bit>>i)&1)==0)continue;\n            if(((bit>>j)&1)==0)continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(c[i]==c[j]&&ok(i,bit)&&ok(j,bit)&&!memo[to_bit]){\n                ret=max(ret,dfs(to_bit));\n            }\n        }\n    }\n\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\nvoid init(){\n    for(int i=0;i<(1<<24);i++){\n        for(int j=0;j<24;j++)if((i>>j)&1){\n            bit_count[i]++;\n        }\n    }\n}\n\nint main(){\n    init();\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define REP(i, n) FOR(i, 0, n)\n\nint sq(int a)\n{\n\treturn a * a;\n}\n\nint n;\nint x[24], y[24], r[24], c[24];\n\nint dist(int i, int j)\n{\n\treturn sq(x[i] - x[j]) + sq(y[i] - y[j]);\n}\n\nbool isec(int i, int j)\n{\n\treturn dist(i, j) < sq(r[i] + r[j]);\n}\n\nvector<pair<int, int>> v;\nint ng[24];\nint dp[1 << 24];\n\nint calc(int bit)\n{\n\tif (~dp[bit]) return dp[bit];\n\t\n\tint res = 0;\n\t\n\tfor (auto p : v){\n\t\tint c = (1 << p.first) | (1 << p.second);\n\t\tif (bit & c) continue;\n\t\tif (~bit & ng[p.first]) continue;\n\t\tif (~bit & ng[p.second]) continue;\n\t\tres = max(res, 2 + calc(bit | c));\n\t}\n\t\n\treturn dp[bit] = res;\n}\n\nint solve()\n{\n\tv.clear();\n\tREP(i, n) FOR(j, i + 1, n){\n\t\tif (isec(i, j)) continue;\n\t\tif (c[i] != c[j]) continue;\n\t\tv.push_back(make_pair(i, j));\n\t}\n\t\n\tmemset(ng, 0, sizeof ng);\n\tREP(i, n) FOR(j, 0, i){\n\t\tif (isec(i, j)) ng[i] |= 1 << j;\n\t}\n\t\n\tmemset(dp, -1, sizeof dp);\n\treturn calc(0);\n}\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\tREP(i, n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\ninline double sq(double a) { return a*a; }\n\nint bitcount(int b) { int c = 0; while(b) { b &= b-1; c++; } return c; }\n\nint n, x[64], y[64], r[64], c[64], g[64];\nbool vis[1<<24];\n\nint solve() {\n    memset(vis, 0, sizeof(vis));\n    memset(g, 0, sizeof(g));\n    rep(i, n) for(int j=i+1; j<n; j++) {\n        if(sqrt(sq(x[i]-x[j])+sq(y[i]-y[j]))<r[i]+r[j]) g[i] |= 1<<j;\n    }\n    vector<int> cs[4];\n    rep(i, n) cs[c[i]-1].push_back(i);\n    int ans = 0;\n    queue<int> q;\n    q.push(0);\n    vis[0] = true;\n    while(!q.empty()) {\n        int x = q.front();\n        q.pop();\n        ans = max(ans, bitcount(x));\n        int can = ~x;\n        rep(i, n) if((x&(1<<i))==0) can &= ~g[i];\n        rep(k, 4) rep(i, cs[k].size()) if(can&(1<<cs[k][i])) {\n            rep(j, i) if(can&(1<<cs[k][j])) {\n                const int nx = x|(1<<cs[k][i])|(1<<cs[k][j]);\n                if(!vis[nx]) q.push(nx), vis[nx] = true;\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    for(;;) {\n        scanf(\"%d\", &n);\n        if(n==0) return 0;\n        rep(i, n) scanf(\"%d%d%d%d\", x+i, y+i, r+i, c+i);\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint sum,ds;\nint n;\nvector<circle>  v;\nint on[30][30]={{}};\nvoid rec(int bit){\n  //cout << vs.size() << endl;\n  int i,j,k;\n  int o=0;\n  for(i=0;i<n;i++) if(bit>>i&1) o++;\n  sum=max(n-o,sum);\n  int f=0;\n  for(i=0;i<n;i++){\n    if(!(bit>>i&1)) continue;\n    f=0;\n    for(j=i+1;j<n;j++) if((bit>>j&1)&&on[i][j]==1) f=1;\n    if(f==1) continue;\n    for(j=i+1;j<n;j++){\n      if(!(bit>>j&1)) continue;\n      f=0;\n      for(k=j+1;k<n;k++) if((bit>>k&1)&&on[j][k]==1) f=1;\n      if(f==1) continue;\n      rec((bit&~(1<<i))&~(1<<j));\n    }\n  }\n}\n\nint main(){\n  cin >> n;\n  while(n!=0){\n    circle c;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      v.push_back(c);\n    }\n    sum=0;\n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n        on[i][j]=ch(v[i],v[j]);\n      }\n    }\n    rec((1<<n)-1);\n    cout << sum << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cstdio>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define fr first\n#define sc second\n#define mp make_pair\n\ntypedef long long int64;\ntypedef pair< int, int > iP;\ntypedef pair< iP, int > iiP;\n\nconst int INF = 2 << 28;\nconst double EPS = 1e-10;\n\nstruct disk {\n    int x, y, r, color;\n};\n\nint n;\nmap< int, int > dp;\nvector< disk > disks;\n\nint rec(int used) {\n    if(dp[used]) return dp[used];\n    vector< int > idx;\n    for(int i = n - 1; i >= 0; i--) {\n        if(!(used >> i & 1)) {\n            bool judge = true;\n            for(int j = i - 1; j >= 0; j--) {\n                if(!(used >> j & 1)) {\n                    if(pow(abs(disks[i].x - disks[j].x), 2) + pow(abs(disks[i].y - disks[j].y), 2) < pow(disks[i].r + disks[j].r, 2))\n                        judge = false;\n                }\n            }\n            if(judge) idx.push_back(i);\n        }\n    }\n\n    int ret = 0;\n    if(idx.size() < 2) return 0;\n    else {\n        for(int i = 0; i < idx.size(); i++) {\n            for(int j = i + 1; j < idx.size(); j++) {\n                if(disks[idx[i]].color == disks[idx[j]].color) {\n                    ret = max(ret, rec(used | (1 << idx[i] | 1 << idx[j])) + 2);\n                }\n            }\n        }\n        return dp[used] = ret;\n    }\n}\n\nint main() {\n\n    while(cin >> n, n) {\n        for(int i = 0; i < n; i++) {\n            int x, y, c, r; cin >> x >> y >> r >> c;\n            disks.push_back((disk){x, y, r, c});\n        }\n\n        cout << rec(0) << endl;\n        disks.clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cstring>\nusing namespace std;\n#define HIT(a,b) ((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r))\n\nstruct DISK{\n\tint x,y,r,c,o;\n} D[25];\nint n;\nset<int> dp;\n\nint main(){\n\tint i,j,ans;\n\tset <int>::iterator it;\n\twhile(cin>>n,n){\n\t\tmemset(D, 0, sizeof(D));\n\t\tdp.clear();\n\t\tans=0;\n\t\t\n\t\tfor(i=0;i<n;i++) cin>>D[i].x>>D[i].y>>D[i].r>>D[i].c;\n\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=i+1;j<n;j++)\n\t\t\t\tif(HIT(D[i],D[j])) D[j].o |= 1<<i;\n\t\t}\n\n\t\tdp.insert(0);\n\t\tfor(it=dp.begin();it!=dp.end();it++){\n\t\t\tfor(i=0;i<n-1;i++){\n\t\t\t\tif((*it >> i) & 1) continue;\n\t\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\t\tif((*it>>j) & 1 || D[i].c != D[j].c\n\t\t\t\t\t||~*it & D[i].o || ~*it & D[j].o) continue;\n\t\t\t\t\tdp.insert(*it|1<<i|1<<j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans, __builtin_popcount(*it));\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <complex>\n\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\ntypedef complex<double> Point;\n\n\nstruct Circle {\n    Point c;\n    double r;\n    int color;\n    Circle(Point c=Point(), double r=0.0,int color=0) :\n        c(c),r(r),color(color){}\n};\ndouble getDistance(Point a,Point b) {\n    return abs(a-b);\n}\n\nbool intersect(Circle c1, Circle c2) {\n    double d=getDistance(c1.c,c2.c);\n    return d<c1.r+c2.r;\n}\nint n;\nbool same_color[30][30];\nbool is_intersect[30][30];\nbool ok(int n,int S) {\n    rep(i,n) {\n        if(!(S>>i&1)&&is_intersect[i][n]) return false;\n    }\n\n    return true;\n}\nshort dp[1<<24];\nint dfs(int S) {\n    if(dp[S]!=-1) return dp[S];\n    int ret=0;\n    rep(i,n) rep(j,n) if(i!=j) {\n        if(((S>>i)&1)) continue;\n        if(((S>>j)&1)) continue;\n        if(!same_color[i][j]) continue;\n        if(!ok(i,S)) continue;\n        if(!ok(j,S)) continue;\n\n        //printf(\"remove %d %d\\n\",i,j);\n        ret=max(ret,dfs(S|(1<<i)|(1<<j))+2);\n    }\n\n    return dp[S]=ret;\n}\nvoid solve() {\n    memset(dp,-1,sizeof(dp));\n    rep(i,30) rep(j,30) is_intersect[i][j]=false;\n    rep(i,30) rep(j,30) same_color[i][j]=false;\n    vector<Circle> circles;\n    rep(i,n) {\n        double x,y,r;\n        int c;\n        cin>>x>>y>>r>>c;\n        circles.push_back(Circle(Point{x,y},r,c));\n    }\n    rep(i,circles.size()) rep(j,circles.size()) {\n        if(intersect(circles[i],circles[j])) is_intersect[i][j]=true;\n        if(circles[i].color==circles[j].color) same_color[i][j]=true;\n    }\n    cout<<dfs(0)<<endl;\n}\nint main() {\n    while(cin>>n) {\n        if(!n) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<map>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 24;\nconst double eps = 1e-10;\ntypedef complex<double> P;\nclass st{\npublic:\n  P a;\n  double r;\n  int color;\n  int id;\n  bool operator<(const st & a)const{\n    if (color != a.color)return color < a.color;\n    return id < a.id;\n  }\n};\n\nint over[N];\n\nint is_intersected_circle(P a,P b,double r1,double r2){\n  double d=abs(a-b);\n  if (d < eps && abs(r1-r2) < eps)return 3;\n  if (d+r2 < r1)return 0;\n  if (d+r1 < r2)return 1;\n  if (d > r1+r2) return 4;\n  if (abs((r1+r2)-d) < eps)return 4;\n  return 2;\n}\n\nvector<int> edge[N];\nshort dp[(1<<N)];\nint colorstart[5];\n\nshort search(int state,st *in,int n){\n  if (state == (1<<n))return 0;\n  short &ret = dp[state];\n  if (ret == -1){\n    ret=0;\n    //color1\n    rep(k,4){\n      REP(i,colorstart[k],colorstart[k+1]){\n        int now=in[i].id;\n        if (((1<<now)&state) != 0)continue;\n        if ((over[now]&state) == over[now]);\n        else continue;\n        REP(j,i+1,colorstart[k+1]){\n          int next=in[j].id;\n          if (((1<<next)&state) != 0)continue;\n          if ((over[next]&state) == over[next]);\n          else continue;\n          //cout <<\"remove \" << now <<\" \" << next << endl;\n          ret=max(ret,2+search(state|(1<<now)|(1<<next),in,n));\n        }\n      }\n    }\n  }\n  return ret;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    rep(i,(1<<n))dp[i]=-1;\n    rep(i,n)edge[i].clear();\n    st in[n];\n    rep(i,n){\n      cin>>in[i].a.real()>>in[i].a.imag()>>in[i].r>>in[i].color;\n      in[i].id=i;\n    }\n    sort(in,in+n);\n    rep(i,n){\n      rep(j,n){\n        if (in[i].id <= in[j].id)continue;\n        int tmp=is_intersected_circle(in[i].a,in[j].a,in[i].r,in[j].r);\n        if (tmp == 0 || tmp == 1 || tmp == 2 || tmp == 3){\n          edge[in[i].id].push_back(in[j].id);\n        }\n      }\n    }\n\n    rep(i,n){\n      int now=in[i].id;\n      over[now]=0;\n      rep(j,edge[now].size()){\n        int next=edge[now][j];\n        over[now]|=(1<<next);\n        //cout <<next << \" is over \" << now << endl;\n      }\n      //cout << now <<\" hoge \" << over[now] << endl;\n    }\n    rep(i,5)colorstart[i]=n;\n    rep(i,n){\n      colorstart[in[i].color-1]=min(colorstart[in[i].color-1],i);\n    }\n\n    //rep(i,5)cout << colorstart[i] << \" \";cout << endl;\n    cout << search(0,in,n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Circle {\n    int x;\n    int y;\n    int r;\n    int c;\n};\n\nbool overwrap(const Circle& c1, const Circle& c2)\n{\n    const int d = c1.r + c2.r;\n    const int R = (c1.x - c2.x) * (c1.x - c2.x) + (c1.y - c2.y) * (c1.y - c2.y);\n    return d * d > R;\n}\n\nint n;\nint dp(vector<int>& table, const vector<vector<bool>>& wrap, const int state, const vector<Circle>& circle)\n{\n    if (table[state] != -1) {\n        return table[state];\n    } else {\n        vector<int> sub(4, 0);\n        vector<vector<int>> top(4, vector<int>(0));\n        for (int j = 0; j < n; j++) {\n            if (state & (1 << j)) {\n                bool ok = true;\n                for (int i = 0; i < j; i++) {\n                    if (state & (1 << i)) {\n                        if (wrap[i][j]) {\n                            ok = false;\n                            break;\n                        }\n                    }\n                }\n                if (ok) {\n                    sub[circle[j].c] += (1 << j);\n                    top[circle[j].c].push_back(j);\n                }\n            }\n        }\n        for (int i = 0; i < 4; i++) {\n            const int size = top[i].size();\n            if (size <= 1) {\n                continue;\n            }\n            if (size % 2 == 0) {\n                const int val = dp(table, wrap, state - sub[i], circle);\n                table[state] = val + size;\n                return val + size;\n            } else {\n                int maxi = 0;\n                for (int j = 0; j < size; j++) {\n                    const int val = dp(table, wrap, state - sub[i] + (1 << top[i][j]), circle);\n                    maxi = max(maxi, val);\n                }\n                table[state] = maxi + (size / 2 * 2);\n                return maxi + (size / 2 * 2);\n            }\n        }\n        table[state] = 0;\n        return 0;\n    }\n}\n\nint main()\n{\n    while (true) {\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        vector<Circle> circle(n);\n        for (int i = 0; i < n; i++) {\n            int x, y, r;\n            int c;\n            cin >> x >> y >> r >> c;\n            c--;\n            circle[i] = Circle{x, y, r, c};\n        }\n\n        vector<vector<bool>> wrap(n, vector<bool>(n, false));  // j?????????i?????????\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                wrap[i][j] = overwrap(circle[i], circle[j]);\n            }\n        }\n\n        const int maximum = 1 << n;\n        vector<int> table(maximum, -1);\n        table[0] = 0;\n        cout << dp(table, wrap, maximum - 1, circle) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <deque>\n#include <vector>\n#include <numeric>\n#include <iterator>\n#include <array>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\n\n\n#define FF first\n#define SS second\n#define ALL(c) begin((c)), end((c))\n#define REP(i,n) for(ll i=0;i<(ll)n;++i)\ninline int getInt() { int s; scanf(\"%d\", &s); return s; }\n\nstruct circle{\n\tll id,x,y,r,c;\n\tbool operator==(const circle & o) {\n\t\treturn id==o.id;\n\t}\n};\n\nvector<circle> g_table;\n\n\nint main() {\n\twhile (true) {\n\t\tll n;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\t\n\t\tg_table.clear();\n\t\tREP(i, n){\n\t\t\tint x,y,r,c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tg_table.push_back(circle{i,x,y,r,c});\n\t\t}\n\n\t\tint size = g_table.size();\n\n\t\twhile (true) {\n\t\t\tvector<circle> tops[4];\n\n\t\t\tREP(i, g_table.size()) {\n\t\t\t\tbool top = true;\n\t\t\t\tREP(j, g_table.size()) {\n\t\t\t\t\tif (i==j) continue;\n\t\t\t\t\tll xx = g_table[i].x - g_table[j].x;\n\t\t\t\t\tll yy = g_table[i].y - g_table[j].y;\n\t\t\t\t\tll rr = g_table[i].r + g_table[j].r;\n\t\t\t\t\tif (xx*xx + yy*yy < rr*rr && i>j) {\n\t\t\t\t\t\ttop = false; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (top) tops[g_table[i].c].push_back(g_table[i]);\n\t\t\t}\n\n\t\t\tbool done = false;\n\t\t\tREP(c, 4) while (tops[c].size() >= 2) {\n\t\t\t\tdone = true;\n\t\t\t\tg_table.erase(remove(ALL(g_table), tops[c].back()), g_table.end());\n\t\t\t\ttops[c].pop_back();\n\t\t\t\tg_table.erase(remove(ALL(g_table), tops[c].back()), g_table.end());\n\t\t\t\ttops[c].pop_back();\n\t\t\t}\n\n\t\t\tif (!done) break;\n\t\t}\n\n\t\tcout << size - g_table.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nstruct Circle{\n\tint cx,cy,r,color;\n};\n\n// ð·»è\nbool cross(Circle c1,Circle c2){\n\treturn (c1.cx-c2.cx)*(c1.cx-c2.cx)+(c1.cy-c2.cy)*(c1.cy-c2.cy) < (c1.r+c2.r)*(c1.r+c2.r);\n}\n\nchar dp[1<<24];\nCircle circles[30];\nint n;\n\nint dfs(int s){\n\tif(dp[s]!=-1)\n\t\treturn dp[s];\n\tif(s==0)\n\t\treturn 0;\n\n\t// ¡êÔãÉ é~ðßé\n\tbool up[30];\n\tfill(up,up+30,false);\n\tfor(int i = 0; i < n; i++){\n\t\tbool f = false;\n\t\tif((((s>>i)&1)==0))\n\t\t\tcontinue;\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif(i==j||(((s>>j)&1)==0))\n\t\t\t\tcontinue;\n\t\t\t// SÌ~Æä×ÄêÔãÉ é©Ç¤©ðÝé\n\t\t\tif(cross(circles[i],circles[j])){\n\t\t\t\tif(i>j){\n\t\t\t\t\tf=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!f){\n\t\t\tup[i]=true;\n\t\t}\n\t}\n\n\t// æè­û@ð·×Ä·\n\tint maxNum=0;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = i+1; j < n; j++){\n\t\t\tif(up[i]&&up[j]&&circles[i].color==circles[j].color){\n\t\t\t\tint ns=s;\n\t\t\t\tns &= ~(1<<i);\n\t\t\t\tns &= ~(1<<j);\n\t\t\t\tmaxNum=max(maxNum,dfs(ns)+2);\n\t\t\t}\n\t\t}\n\t}\n\tdp[s]=maxNum;\n\treturn maxNum;\n}\n\nint main(){\n\n\twhile(cin>>n&&n!=0){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tCircle cc;\n\t\t\tcin>>cc.cx>>cc.cy>>cc.r>>cc.color;\n\t\t\tcircles[i]=cc;\n\t\t}\n\t\tfill(dp,dp+(1<<24),-1);\n\t\tcout<<dfs((1<<(n))-1)<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\ntypedef struct a \n{\n\tbool exist[24];\n}state;\n\nvoid init_state(bool exist[24],int n)\n{\n\tfor (int i=0;i<n;++i) exist[i] = true;\n}\n\nint cal_state(bool exist[24],int n)\n{\n\tint res = 0;\n\tfor (int i=0;i<n;++i)\n\t{\n\t\tif (exist[i]) res += 1<<i; \n\t}\n\treturn res;\n}\n\nint cal_number(bool exist[24], int n)\n{\n\tint res = 0;\n\tfor (int i=0;i<n;++i)\n\t{\n\t\tif (exist[i]) ++res;\n\t}\n\treturn res;\n}\n\nbool overlap(int x1,int y1,int r1,int x2,int y2,int r2)\n{\n\tif ((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1) < (r1+r2)*(r1+r2)) return true;\n\telse return false;\n}\n\nint main()\n{\n\tint n = 0;\n\tint x[24];\n\tint y[24];\n\tint r[24];\n\tint c[24];\n\n\tcin >> n;\n\twhile (n)\n\t{\n\t\tint res = 0;\n\t\tqueue<state> q;\n\t\tbool ontop[24];\n\t\t//bool s[1<<24] = {false};\n\t\tbool s[200000] = {false};\n\n\t\tfor (int i=0;i<n;++i)\n\t\t{\n\t\t\tcin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\t}\n\t\t\n\t\tstate tmp;\n\t\tinit_state(tmp.exist,n);\n\t\tq.push(tmp);\n\t\t\n\t\twhile (!q.empty())\n\t\t{\n\t\t\ttmp = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tinit_state(ontop,n);\n\t\t\tres = max(res,n-cal_number(tmp.exist,n));\n\t\t\t\n\t\t\tif (res == n) break;\n\t\t\t\n\t\t\tfor (int i=0;i<n;++i)\n\t\t\t{\n\t\t\t\tif (tmp.exist[i])\n\t\t\t\t{\n\t\t\t\t\tfor (int j = i+1; j<n; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tmp.exist[j]&&ontop[j])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (overlap(x[i],y[i],r[i],x[j],y[j],r[j])) ontop[j] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i=0;i<n;++i)\n\t\t\t{\n\t\t\t\tif (tmp.exist[i]&&ontop[i])\n\t\t\t\t{\n\t\t\t\t\tfor (int j=i+1;j<n;++j) \n\t\t\t\t\t{\n\t\t\t\t\t\tif (tmp.exist[j]&&ontop[j]&&(c[i] == c[j]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmp.exist[i] = false;\n\t\t\t\t\t\t\ttmp.exist[j] = false;\n\t\t\t\t\t\t\tif (!s[cal_state(tmp.exist,n)])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ts[cal_state(tmp.exist,n)] = true;\n\t\t\t\t\t\t\t\tq.push(tmp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\tcout << res << endl;\n\t\tcin >>n;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 24\n\nint N,x[MAX],y[MAX],r[MAX],c[MAX];\n\ndouble dist(int a,int b){\n    return sqrt((x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]));\n}\n\nbool check(int a,int b){\n    double d = dist(a,b);\n    return ((abs(r[b]-r[a]) < d && d < (r[b]+r[a]))\n            || d <= abs(r[b]-r[a]));\n}\n\nint main(){\n    while(cin >> N, N){\n        for(int i = 0 ; i < N ; i++){\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n        int bit[MAX] = {0};\n        for(int i = 0 ; i < N ; i++){\n            for(int j = 0 ; j < i ; j++){\n                if(check(i,j)) bit[i] |= (1<<j);\n            }\n        }\n        vector<bool> dp(1<<N,0);\n        dp[(1<<N)-1] = 1;\n        int res = 0;\n        for(int i = (1<<N)-1 ; i >= 0 ; i--){\n            if(dp[i] == 0) continue;\n            if(N%2 == 0 && __builtin_popcount(i) % 2 == 1) continue;\n            if(N%2 == 1 && __builtin_popcount(i) % 2 == 0) continue;\n            for(int j = 0 ; j < N ; j++){\n                for(int k = j+1 ; k < N ; k++){\n                    if(c[j] != c[k]) continue;\n                    if(__builtin_popcount(i&bit[j]) > 0) continue;\n                    if(__builtin_popcount(i&bit[k]) > 0) continue;\n                    int S = i & ~((1<<j) | (1<<k));\n                    dp[S] = 1;\n                    res = max(res,N-__builtin_popcount(i));\n                }\n            }\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint main(){\n  int n;\n  cin >> n;\n  while(n!=0){\n    int sum=0;\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    int f=0;\n    int on[30]={};\n    //int cc[5]={};\n    vector<int> cc[5];\n    while(f==0){\n      f=1;\n      for(i=0;i<30;i++) on[i]=0;\n      for(i=0;i<v.size();i++){\n\tfor(j=i+1;j<v.size();j++){\n\t  if(ch(v[i],v[j])==1) on[j]=1;\n\t}\n      }\n      \n      for(i=0;i<5;i++) cc[i].clear();\n      for(i=0;i<v.size();i++){\n\tif(on[i]==0) cc[v[i].c].push_back(i);\n      }\n      \n      for(i=1;i<5;i++){\n\tif(cc[i].size()%2==0){\n\t  for(j=cc[i].size()-1;j>=0;j--){\n\t    v.erase(v.begin()+cc[i][j]);\n\t    f=0;\n\t  }\n\t}\n      }\n    }\n    cout << n-v.size() << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#define HIT(a,b) ((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r))\n\nusing namespace std;\n\nchar Log[90][30];\nint Logcnt;\n\nstruct DISK {\n\tint x,y,r,c,f;\n};\nint n;\n\nvoid setontop(DISK *D){\n\tint i,j;\n\tfor(i=0;i<n;i++){\n\t\tD[i].f=D[i].r;\n\t\tfor(j=i+1;j<n;j++)\n\t\t\tif(D[j].r && HIT(D[i],D[j])) D[i].f=0;\n//\t\tprintf(\"ontop%d %d\\n\", i, D[i].f);\n\t}\n}\n\nint checkLog(DISK *D){\n\tint i,j;\n\tfor(i=0;i<Logcnt;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif((D[j].r && !Log[i][j]) || (!D[j].r && Log[i][j])) break;\n\t\t}\n\t\tif(j==n){\n\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint solve(DISK *D){\n\tint i,j,k,min=30,ret;\n\tif(checkLog(D)) return 30;\n\tfor(i=0;i<n;i++) Log[Logcnt][i]=D[i].r;\n\tLogcnt ++;\n\tif(Logcnt>=90) return 30;\n\tsetontop(D);\n\tfor(i=1;i<=4;i++){\n\t\tchar list[6],li=0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(D[j].f&&D[j].c==i) list[li++]=j;\n\t\t}\n//\t\tprintf(\"%d %d\\n\",i,li);\n\t\tif(li<2)continue;\n\t\tDISK tmp[30];\n\t\tfor(j=0;j<li;j++){\n\t\t\tfor(k=j+1;k<li;k++){\n//\t\t\t\tprintf(\"remove(%d,%d)\", list[j],list[k]);\n\t\t\t\tmemcpy(tmp,D,sizeof(tmp));\n\t\t\t\ttmp[list[j]].r=0;\n\t\t\t\ttmp[list[k]].r=0;\n\t\t\t\tret=solve(tmp);\n\t\t\t\tif(ret<min)min=ret;\n\t\t\t}\n\t\t}\n\t}\n\tfor(ret=0,i=0;i<n;i++)if(D[i].r)ret++;\n\tif(ret<min)min=ret;\n//\tprintf(\"return %d\\n\", min);\n\treturn min;\n}\n\nint main(){\n\tint i,j;\n\twhile(cin>>n,n){\n\t\tDISK D[30];\n\t\tLogcnt=0;\n\t\tfor(i=n;i-->0;) cin>>D[i].x>>D[i].y>>D[i].r>>D[i].c;\n\t\tcout<<n-solve(D)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nmain {\n  while (true) {\n    int n = in();\n    if (n == 0) break;\n    vector<int> x(n), y(n), r(n), c(n);\n    rep(i, n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n    auto intersectCC = [&](int i, int j) {\n      int r2 = (r[i] + r[j]) * (r[i] + r[j]);\n      int d = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n      return d < r2;\n    };\n    auto intersect = [&](int t, int used) {\n      bool f = false;\n      rep(i, t) f |= (~used >> i & 1) && intersectCC(t, i);\n      return f;\n    };\n    vector<int32_t> dp(1 << n, -1);\n    function<int(int)> dfs = [&](int used) {\n      if (dp[used] != -1) return dp[used];\n      cmax(dp[used], 0);\n      rep(i, n) loop(j, i + 1, n) {\n        if ((used >> i & 1) || (used >> j & 1) || c[i] != c[j]) continue;\n        if (intersect(i, used) || intersect(j, used)) continue;\n        cmax(dp[used], dfs(used | (1 << i) | (1 << j)) + 2);\n      }\n      return dp[used];\n    };\n    cout << dfs(0) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <map>\n#include <bitset>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){\n    rep(i,v.size()) os << v[i] << (i+1==v.size()?\"\":\" \");\n    return os;\n}\n\ndouble eps = 1e-9;\n\nint n;\nint x[24], y[24], r[24], c[24];\nbool hit[24][24];\nchar dp[1<<24];\n\nchar dfs(int S){\n    char & res = dp[S];\n    if(res!=-1) return res;\n    res = 0;\n    rep(i,n){\n        if(S>>i & 1){\n            rep(j,i){\n                if(S>>j & 1){\n                    if(hit[i][j] || c[i]!=c[j]) continue;\n                    bool ok = true;\n                    rep(k,i) if(hit[i][k] && (S>>k & 1)) ok = false;\n                    rep(k,j) if(hit[j][k] && (S>>k & 1)) ok = false;\n                    if(!ok) continue;\n                    S ^= 1<<i;\n                    S ^= 1<<j;\n                    res = max<char>(dfs(S)+2, res);\n                    S ^= 1<<i;\n                    S ^= 1<<j;\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(cin>>n && n){\n        memset(dp,-1,sizeof(dp));\n        rep(i,n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n        rep(i,n)rep(j,i){\n            int dx=x[i]-x[j], dy=y[i]-y[j];\n            int d = dx*dx+dy*dy;\n            hit[i][j] = hit[j][i] = d < (r[i]+r[j])*(r[i]+r[j]);\n        }\n        int S = 0;\n        rep(i,n) S |= 1<<i;\n        cout << (int)dfs(S) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nstruct Circle\n{\n\tint x,y,r,c,m;\n};\n\nint N;\nint mem[1<<24];\nCircle s[24];\n\nint solve(int state)\n{\n\tif(mem[state]>=0)\n\t{\n\t\treturn mem[state];\n\t}\n\n\tvector<int> del[4];\n\tfor(int i=0; i<N; i++)\n\t{\n\t\tif(state & (1<<i))\n\t\t{\n\t\t\tif(state & s[i].m) continue;\n\t\t\tdel[s[i].c].push_back(i);\n\t\t}\n\t}\n\n\tint res=0;\n\n\tfor(int k=0;   k<4; k++)\n\tfor(int i=0;   i<del[k].size(); i++)\n\tfor(int j=i+1; j<del[k].size(); j++)\n\t{\n\t\tint newstate = state;\n\t\tnewstate &= ~(1<<del[k][i]);\n\t\tnewstate &= ~(1<<del[k][j]);\n\t\tres = max(res, solve(newstate)+2);\n\t}\n\n\tmem[state] = res;\n\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin>>N, N)\n\t{\n\t\tmemset(mem, -1, sizeof(mem));\n\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tcin>>s[i].x>>s[i].y>>s[i].r>>s[i].c;\n\t\t}\n\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\ts[i].m=0;\n\t\t\tfor(int j=0; j<i; j++)\n\t\t\t{\n\t\t\t\tint dx = s[i].x-s[j].x;\n\t\t\t\tint dy = s[i].y-s[j].y;\n\t\t\t\tint dr = s[i].r+s[j].r;\n\t\t\t\tif(dx*dx+dy*dy < dr*dr)\n\t\t\t\t{\n\t\t\t\t\ts[i].m |= 1<<j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << solve((1<<N)-1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint foo(int S, vector<int>& c, vector<int>& a, vector<char>& memo) {\n\tif (memo[S] != -1) return memo[S];\n\tint n = c.size(), cnt = 0;\n\tvector< vector<int> > v(4);\n\tfor (int i = 0; i < n; i++)\n\t\tif (S & (1 << i)) {\n\t\t\tcnt++;\n\t\t\tif (!(S & a[i])) v[c[i] - 1].push_back(i);\n\t\t}\t\n\tint mini = cnt;\n\tfor (int j = 0; j < 4; j++) {\n\t\tint m = v[j].size();\n\t\tfor (int k = 0; k < m; k++)\n\t\t\tfor (int _k = k + 1; _k < m; _k++) {\n\t\t\t\tint _S = S - (1 << v[j][k]) - (1 << v[j][_k]);\n\t\t\t\tmini = min(mini, foo(_S, c, a, memo));\n\t\t\t}\n\t}\n\treturn memo[S] = mini;\n}\n\nint main() {\n\tfor (;;) {\n\t\tint n; cin >> n;\n\t\tif (n == 0) break;\n\t\tvector<int> x(n), y(n), r(n), c(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tint dx = x[i] - x[j], dy = y[i] - y[j], d = r[i] + r[j];\n\t\t\t\tif (dx * dx + dy * dy < d * d) a[i] |= (1 << j);\n\t\t\t}\n\t\tvector<char> memo(1 << n, -1);\n\t\tcout << n - foo((1 << n) - 1, c, a, memo) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    int n; cin >> n;\n    if (!n) break;\n    V<> x(n), y(n), r(n), c(n); for (int i = 0; i < n; ++i) cin >> x[i] >> y[i] >> r[i] >> c[i], --c[i];\n    V<bool> b(n, true);\n    int res = 0;\n    for (int _ = 0; _ < 2; ++_) {\n      VV<> idx(4);\n      for (int i = 0; i < n; ++i) if (b[i]) {\n        bool ok = true;\n        for (int j = 0; j < i; ++j) if (b[j]) {\n          if ((x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]) < (r[i] + r[j]) * (r[i] + r[j])) {\n            ok = false;\n            break;\n          }\n        }\n        if (ok) idx[c[i]].push_back(i);\n      }\n      for (int i = 0; i < 4; ++i) {\n        while (idx[i].size() >= 2) {\n          for (int _ = 0; _ < 2; ++_) {\n            b[idx[i].back()] = false;\n            idx[i].pop_back();\n          }\n          res += 2;\n        }\n      }\n    }\n    cout << res << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define iota(i,n,b,s) for(int i=int(b);i!=int((b)+(s)*(n));i+=(s))\n#define range(i,n,m) iota(i,(((n)>(m))?((n)-(m)):((m)-(n))),(n),((n)>(m)?-1:1))\n#define rep(i,n) iota(i,(n),0,1)\n#define loop for(;;)\n\n#define INF (1e9)\n#define EPS (1e-9)\n#define cons(a,b) (make_pair(a,b))\n#define car(a) (a.first)\n#define cdr(a) (a.second)\n#define cadr(a) (car(cdr(a)))\n#define cddr(a) (cdr(cdr(a)))\n#define all(a) a.begin(), a.end()\n#define trace(var) cerr<<\">>> \"<<#var<<\" = \"<<var<<endl;\n\ntypedef long long Integer;\ntypedef double Real;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef map<string,int> Dictionary;\nconst Real PI = acos(-1);\n\ntemplate<class S, class T>\nostream& operator<<(ostream& os, pair<S,T> p) {\n  os << '(' << car(p) << \", \" << cdr(p) << ')';\n  return os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T> v) {\n  if (v.size() == 0) {\n    os << \"(empty)\";\n    return os;\n  }\n  os << v[0];\n  for (int i=1, len=v.size(); i<len; ++i) os << ' ' << v[i];\n  return os;\n}\n\nint dx[] = { -1, 0, 1, 0 };\nint dy[] = {  0, -1, 0, 1 };\n\nbool\nintersect(vector<int>&xs, vector<int>&ys, vector<int>&rs, int i, int j) {\n  int x0 = xs[i];\n  int y0 = ys[i];\n  int r0 = rs[i];\n  int x1 = xs[j];\n  int y1 = ys[j];\n  int r1 = rs[j];\n  return pow(x1 - x0, 2) + pow(y1 - y0, 2) < pow(r0 + r1, 2);\n}\n\nstring ni(unsigned int k) {\n  string r = \"\";\n  for (int i = 0; i < 8; ++i) {\n    if (k & (1 << i)) r += \"1\";\n    else r += \"0\";\n  }\n  return r;\n}\n\nint f(vector<vector<bool>>&d, vector<int>&cs) {\n  const int n = d.size();\n\n  stack<pair<unsigned int, int>> s;\n  s.push(cons(0, 0));\n  int ans = 0;\n\n  int cx = 0;\n\n  while (!s.empty()) {\n    auto t = s.top(); s.pop();\n    int r = car(t);\n    int m = cdr(t);\n    ans = max(ans, m);\n    if (ans == n) return n;\n    //if (m == 6) trace(cons(ni(r), m));\n    //cout << \"top: \" << cons(ni(r), m) << endl;\n\n    rep (i, n) {\n      if (r & (1 << i)) continue;\n      range (j, i + 1, n) {\n        if (r & (1 << j)) continue;\n        if (cs[i] != cs[j]) continue;\n\n        bool bi = false;\n        rep (k, i) if (!(r & (1 << k)) && d[k][i]) bi = true;\n        if (bi) continue;\n        bool bj = false;\n        rep (k, j) if (!(r & (1 << k)) && d[k][j]) bj = true;\n        if (bj) continue;\n\n        s.push( cons(r | (1 << i) | (1 << j), m + 2) );\n        //cout << \"remove \" << cons(i, j) << endl;\n      }\n    }\n  }\n\n  return ans;\n}\n\nint main() {\n\n  for (int n; cin >> n, n; ) {\n    vector<int> xs;\n    vector<int> ys;\n    vector<int> rs;\n    vector<int> cs;\n\n    rep (i, n) {\n      int x, y, r, c;\n      cin >> x >> y >> r >> c;\n      --c;\n      xs.push_back(x);\n      ys.push_back(y);\n      rs.push_back(r);\n      cs.push_back(c);\n    }\n\n    // d[i][j] = i is on j\n    vector<vector<bool>> d(n, vector<bool>(n, false));\n    rep (i, n) {\n      for (int j = i + 1; j < n; ++j) {\n        d[i][j] = intersect(xs, ys, rs, i, j);\n      }\n    }\n    cout << f(d, cs) << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <bitset>\n#include <unordered_map>\nusing namespace std;\n\ntypedef double D;\nconst double EPS = 1e-8;\n\nstruct P {\n  D x, y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\n\nstruct C {\n  P p;\n  D r;\n  C() { }\n  C(P p_, D r_) : p(p_), r(r_) { }\n  C(D x_, D y_, D r_) : p(x_, y_), r(r_) { }\n};\n\nint sig(double a, double b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\n\nbool iCC(C a, C b) {\n  D dx = a.p.x - b.p.x;\n  D dy = a.p.y - b.p.y;\n  D d2 = dx*dx + dy*dy;\n  return sig(d2, (a.r + b.r)*(a.r + b.r)) < 0;\n}\n\nint N;\nC circle[24];\nint color[24];\nbool overlap[24][24];\n\nunordered_map<int, int> memo;\nint solve(int S) {\n  if(memo.count(S)) return memo[S];\n  int top = 0;\n  for(int i = 0; i < N; ++i) {\n    if(((S >> i) & 1) == 0) continue;\n    bool ok = true;\n    for(int j = 0; j < i; ++j) {\n      if(((S >> j) & 1) == 0) continue;\n      if(overlap[i][j]) {\n        ok = false;\n        break;\n      }\n    }\n    if(ok) {\n      top |= (1 << i);\n    }\n  }\n  int res = 0;\n  for(int i = 0; i < N; ++i) {\n    for(int j = i + 1; j < N; ++j) {\n      if(((top >> i) & 1) && ((top >> j) & 1) && color[i] == color[j]) {\n        int B = S;\n        B &= ~(1 << i);\n        B &= ~(1 << j);\n        res = max(res, 2 + solve(B));\n      }\n    }\n  }\n  return memo[S] = res;\n}\n\nint main() {\n  while(true) {\n    memo.clear();\n    cin >> N;\n    if(N == 0) break;\n    for(int i = 0; i < 24; ++i)\n      for(int j = 0; j < 24; ++j)\n        overlap[i][j] = false;\n    for(int i = 0; i < N; ++i) {\n      cin >> circle[i].p.x >> circle[i].p.y >> circle[i].r >> color[i];\n      color[i]--;\n    }\n    for(int i = 0; i < N; ++i) {\n      for(int j = 0; j < i; ++j) {\n        if(iCC(circle[i], circle[j])) {\n          overlap[i][j] = true;\n        }\n      }\n    }\n    cout << solve((1 << N) - 1 ) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n#define HIT(a,b) ((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r))\n\nstruct DISK{\n\tint x,y,r,c,o;\n\tDISK():o(0){}\n};\nint n;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n, n){\n\t\tvector<DISK> D(n);\n\t\tREP(i, n) cin>>D[i].x>>D[i].y>>D[i].r>>D[i].c;\n\t\tREP(j, n)REP(i, j)if(HIT(D[i],D[j])) D[j].o |= 1<<i;\n\t\tint ans = 0;\n\t\tvi dp(1<<n);\n\t\tdp[0] = 1;\n\t\tREP(b, 1<<n)if(dp[b]){\n\t\t\tREP(j, n)REP(i, j)if(!((b >> i) & 1)){\n\t\t\t\tif((b >> i) & 1 || (b>>j) & 1 || D[i].c != D[j].c || ~b & D[i].o || ~b & D[j].o) continue;\n\t\t\t\tdp[b|1<<i|1<<j] = 1;\n\t\t\t}\n\t\t\tans = max(ans, __builtin_popcount(b));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <bitset>\n#include <iostream>\n#include <string>\n#include <stack>\n#include <queue>\nusing namespace std;\n\nint pow2(int a){\n    return a*a;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<int> x(n), y(n), r(n), c(n);\n        for(int i=0; i<n; ++i)\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n        vector<vector<bool> > cant(n, vector<bool>(n, false));\n        for(int i=0; i<n; ++i){\n            for(int j=i+1; j<n; ++j){\n                if(i == j)\n                    continue;\n                if(pow2(x[i]-x[j]) + pow2(y[i]-y[j]) < pow2(r[i] + r[j]))\n                    cant[j][i] = true;\n            }\n        }\n\n        vector<bool> dp(1<<n, false);\n        dp[0] = true;\n        queue<int> q;\n        q.push(0);\n\n        int ret = 0;\n        while(!q.empty()){\n            bitset<24> bs(q.front());\n            q.pop();\n            ret = max(ret, (int)bs.count());\n\n            vector<bool> remove(n, true);\n            for(int i=0; i<n; ++i){\n                for(int j=0; j<n; ++j){\n                    if(bs[i] || (cant[i][j] && !bs[j]))\n                        remove[i] = false;\n                }\n            }\n\n            for(int i=0; i<n; ++i){\n                for(int j=0; j<i; ++j){\n                    if(remove[i] && remove[j] && c[i] == c[j]){\n                        bs[i] = bs[j] = true;\n                        if(!dp[bs.to_ulong()]){\n                            dp[bs.to_ulong()] = true;\n                            q.push(bs.to_ulong());\n                        }\n                        bs[i] = bs[j] = false;\n                    }\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\n\n#define all(c) ((c).begin()), ((c).end())\n#define debug(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\n\nconst double EPS = 1e-10;\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\n\nstruct C{\n\tP p;\n\tint r;\n\tint c;\n};\n\nmap<int, int> dp;\nint n;\nvector<C> cs;\n\nint go(int mask) {\n\tif(present(dp, mask)) return dp[mask];\n\tint res = 0;\n\trep (i, n) if (mask & (1 << i)) REP (j, i + 1, n - 1) if (mask & (1 << j)) {\n\t\tif(cs[i].c != cs[j].c) continue;\n\t\tbool ok = true;\n\t\trep(k, i) if(mask & (1 << k)) if (cs[i].r + cs[k].r > abs(cs[i].p - cs[k].p)) ok = false;\n\t\trep(k, j) if(mask & (1 << k)) if (cs[j].r + cs[k].r > abs(cs[j].p - cs[k].p)) ok = false;\n\t\tif(!ok) continue;\n\t\tres = max(res, go(mask ^ (1 << i) ^ (1 << j)) + 2);\n\t}\n\treturn dp[mask] = res;\n}\n\nint main() {\n\tfor (; cin >> n, n != 0; ) {\n\t\tcs.clear();\n\t\trep (i, n) {\n\t\t\tC c; int x, y; cin >> x >> y >> c.r >> c.c;\n\t\t\tc.p = P(x, y);\n\t\t\tcs.pb(c);\n\t\t}\n\t\tdp.clear();\n\t\tcout << go((1 << n) -1) << endl;;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<cassert>\n#include<vector>\n#include<algorithm>\n#define F first\n#define S second\n#define pb push_back\n#define EPS 1e-10\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint n;\nvector<PP> p;\nvector<int> rank;\n\nvoid ranking(){\n  for(int i=0;i<p.size();i++)rank.pb(1);\n\n  for(int i=0;i<p.size();i++){\n    for(int j=i+1;j<p.size();j++){\n      double r1 = p[i].S.F,r2 = p[i].S.F,d = sqrt(pow(p[i].F.F-p[j].F.F,2)+pow(p[i].F.S-p[j].F.S,2));\n      if(fabs(r1-r2) < d  && d < (r1+r2) ){ //cross each other on two different points\n\trank[j]++;\n      }\n      else if(fabs(d-(r1+r2)) < EPS){ //be circumscribed\n      }\n      else if(fabs(d-fabs(r1-r2)) < EPS){ // be inscribed\n\trank[j]++;\n      }\n      else{\n      }\n    }\n  }\n}\n\n\nvoid rankDecrease(int x){\n  for(int i=0;i<rank.size();i++){\n    if(i == x){\n      rank[i]--;\n      continue;\n    }\n double r1 = p[x].S.F,r2 = p[i].S.F,d = sqrt(pow(p[x].F.F-p[i].F.F,2)+pow(p[x].F.S-p[i].F.S,2));\n      if(fabs(r1-r2) < d  && d < (r1+r2) ){ //cross each other on two different points\n\trank[i]--;\n      }\n      else if(fabs(d-(r1+r2)) < EPS){ //be circumscribed\n      }\n      else if(fabs(d-fabs(r1-r2)) < EPS){ // be inscribed\n\trank[i]--;\n      }\n      else{\n      }\n\n\n  }\n}\n\n\nint main(){\n\n  while(cin >> n && n){ int cnt = 0;\n    p.clear(); rank.clear();\n    for(int i=0;i<n;i++){\n      int x,y,r,c;\n      cin >> x >> y >> r >> c;\n      p.pb(PP(P(x,y),P(r,c)));\n    }\n    ranking();\n\n   \n\n    int j=0,flag = 0;\n    bool fl = true;\n    while(fl){ \n\n      if(rank[j] == 0){\n\tj++;\n\tif(j%n == 0 && j!=0){\n\t  j=0;\n\t  if(flag == 0){\n\t    fl = false;\n\t  }\n\t  flag = 0;\n\t}\n\tcontinue;\n      }\n\n      if(rank[j] == 1){\n\tfor(int i=0;i<rank.size();i++){      \n\t  if(i == j || rank[i] == 0)continue;\n\t  if(rank[i] == 1 && p[j].S.S == p[i].S.S){\n\t    cnt += 2;\n\t    flag++;\n\t    rankDecrease(i);\n\t    rankDecrease(j);\n\t    break;\n\t  }\n\t}\n      }\n\n      j++;\n      if(j%n == 0 && j!=0){\n\tj=0;\n\tif(flag == 0){\n\t  fl = false;\n\t}\n\tflag= 0;\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\nconstexpr int MAX_N = 1 << 24;\nchar dp[MAX_N];\nint b[25];\n\nbool intersects(vector<int> &x, vector<int> &y, vector<int> &r, int i, int j) {\n    int dx = (x[i] - x[j]) * (x[i] - x[j]);\n    int dy = (y[i] - y[j]) * (y[i] - y[j]);\n    int dist1 = dx + dy;\n    int dist2 = (r[i] + r[j]) * (r[i] + r[j]);\n    return dist1 < dist2;\n}\n\nint main() {\n\n    while (true) {\n\n        int N;\n        cin >> N;\n\n        if (N == 0) break;\n\n        vector<int> x(N), y(N), r(N), c(N);\n        for (int i = 0; i < N; i++) cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n        //上からi枚目\n        for (int i = 0; i < N; i++) {\n            b[i] = 0;\n            //i枚目よりあとに降ってきたものを見る\n            for (int j = 0; j < i; j++) {\n                if (intersects(x, y, r, i, j)) b[i] |= (1 << j);\n            }\n        }\n\n        int ans = 0;\n        memset(dp, -1, sizeof(dp));\n\n        dp[0] = 0;\n\n        //すべての円の使い方の状態を見る\n        for (int i = 0; i < (1 << N); i++) {\n            //このような円の状態はありえない\n            if (dp[i] == -1) continue;\n\n            //消せる円盤のペア(j, k)を探す\n            for (int j = 0; j < N - 1; j++) {\n                if ((i & (1 << j)) != 0 || (i & b[j]) != b[j]) continue;\n\n                //jより下にあるkをさがす\n                for (int k = j + 1; k < N; k++) {\n                    if (c[j] != c[k] || (i & (1 << k)) != 0 || (i & b[k]) != b[k]) continue;\n\n                    int next = i | (1 << j) | (i << k);\n                    dp[next] = dp[i] + 1;\n                }\n            }\n        }\n\n        for (int i = 0; i < (1 << N); i++) ans = max(ans, (int) dp[i]);\n        cout << ans * 2 << endl;\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\n#define pb push_back\n\nint anss = 0;\n\nint calculate(int x,int y,int r,int xx,int yy,int rr){\n    int d = (x-xx)*(x-xx)+(y-yy)*(y-yy);\n    if(d >= (r+rr)*(r+rr)) return 0;\n    else return 1;\n}\n\nvoid play(int n,int top[],int col[],vector <int> colors[]){\n    //cout << endl << endl;\n    vector <int> pos[6];\n    int ans=0;\n    for(int i = 0 ; i < n ; i++){\n        //cout << \"t \" << i << \" \" << top[i] << endl;\n        if(top[i] == 0){\n            pos[col[i]].pb(i);\n        }\n        if(top[i] == -1) ans++;\n    }\n\n    anss = max(ans,anss);\n    /*\n    for(int i = 1 ; i < 4 ; i++){\n        //cout << i << \" : \";\n        for(int j = 0 ; j < pos[i].size() ; j++) cout << pos[i][j] << \" \";\n        cout << endl;\n    }\n    */\n    for(int i = 1 ; i < 4 ; i++){\n        if(pos[i].size() == 6){\n            int topp[30];\n\n            for(int j = 0 ; j < n ; j++) topp[j] = top[j];\n\n            for(int jj = 0 ; jj < 6 ; jj++){\n                for(int j = 0 ; j < n ; j++){\n                    //cout << \"shift \" << pos[i][0] << \" \" << pos[i][1] << endl;\n                    //cout << \"shiff \" << j << \" \" << topp[j] << \" \" << (topp[j] & (1<<pos[i][0])) << endl;\n\n                    if( (topp[j] & (1<<pos[i][jj])) > 0 && topp[j] > 0 ) topp[j] -= 1<<pos[i][jj];\n                }\n                topp[pos[i][jj] ] = -1;\n            }\n            play(n,topp,col,colors);\n        }\n        else if(pos[i].size() >= 2){\n            do{\n                int topp[30];\n\n                for(int j = 0 ; j < n ; j++) topp[j] = top[j];\n\n                for(int j = 0 ; j < n ; j++){\n                    //cout << \"shift \" << pos[i][0] << \" \" << pos[i][1] << endl;\n                    //cout << \"shiff \" << j << \" \" << topp[j] << \" \" << (topp[j] & (1<<pos[i][0])) << endl;\n\n                    if( (topp[j] & (1<<pos[i][0])) > 0 && topp[j] > 0 ) topp[j] -= 1<<pos[i][0];\n                    if( (topp[j] & (1<<pos[i][1])) > 0 && topp[j] > 0 ) topp[j] -= 1<<pos[i][1];\n                }\n\n                topp[pos[i][0] ] = -1;\n                topp[pos[i][1] ] = -1;\n                play(n,topp,col,colors);\n            }while(next_permutation( pos[i].begin(),pos[i].end() ) );\n        }\n    }\n\n    //cout << \"end\" << endl;\n}\nmain(){\n    //freopen(\"D.txt\",\"r\",stdin);\n    int n;\n\n    while(cin >> n,n>0){\n        int top[30]={0};\n        int xx[30];\n        int yy[30];\n        int rad[30];\n        int col[30];\n        vector <int> colors[6];\n\n        for(int i = 0 ; i < n ; i++){\n            cin >> xx[n-i-1] >> yy[n-1-i] >> rad[n-1-i] >> col[n-1-i];\n\n            colors[col[n-1-i]].pb(n-1-i);\n        }\n\n        for(int i = 0; i < n ; i++){\n            for(int j = 0 ; j < i ; j++){\n                if(calculate(xx[j],yy[j],rad[j],xx[i],yy[i],rad[i])==1){\n                    top[j]+=1<<i;\n                }\n            }\n        }\n\n        anss = 0;\n        play(n,top,col,colors);\n\n        cout << anss << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n\nclass C{\n    public:\n        int x, y, r, c;\n};\n\nint calDis(C a, C b){\n    int c = a.x - b.x, d = a.y - b.y;\n    return c * c + d * d;\n}\n\nint calSum(int num){\n    int ret = 0;\n    for(int i = 1; i <= num; i *= 2) if((num & i) != 0) ret++;\n    return ret;\n}\n\nint main(){\n    int n;\n    while(cin >>n && n){\n        vector<C> discs(n); REP(i, n) cin >>discs[i].x >>discs[i].y >>discs[i].r >>discs[i].c;\n        vector<int> overlap(n, 0);\n        REP(i, n){\n            REP(j, i){\n                int tmp = discs[i].r + discs[j].r;\n                if(tmp * tmp > calDis(discs[i], discs[j])) overlap[i] = overlap[i] | (1 << j) | overlap[j];\n            }\n        }\n        int ans = 0;\n        vector<bool> bitdp(1 << n, false);\n        bitdp[0] = true;\n        REP(i, bitdp.size()){\n            if(!bitdp[i]) continue;\n            REP(j, n){\n                FOR(k, j + 1, n){\n                    if(discs[j].c != discs[k].c || (i & (1 << j)) != 0 || (i & (1 << k)) != 0 || (overlap[j] & i) != overlap[j] || (overlap[k] & i) != overlap[k]) continue;\n                    int next = i | (1 << j) | (1 << k);\n                    bitdp[next] = true;\n                }\n            }\n            ans = max(ans, calSum(i));\n        }\n        cout <<ans <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nbool inter(int x1, int y1, int r1, int x2, int y2, int r2){\n  int dx = x1-x2, dy = y1-y2;\n  return dx*dx+dy*dy < (r1+r2)*(r1+r2);\n}\n\nint N;\nint pv[24];\nbool dp[1<<24];\n\nint bc(int x){\n  int res = 0;\n  while(x>0) res += x&1,  x>>=1;\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>N, N){\n\tVI xs(N), ys(N), rs(N), cols(N);\n\tREP(i,N) cin >> xs[i] >> ys[i] >> rs[i] >> cols[i];\n\n\tfill(pv, pv+24, 0);\n\tREP(i,N) FOR(j,i+1,N){\n\t  if(inter(xs[i], ys[i], rs[i], xs[j], ys[j], rs[j]))\n\t\tpv[j] |= 1<<i;\n\t}\n\n\tfill(dp, dp+(1<<24), false);\n\tdp[0] = true;\n\tfor(int b=0;b<1<<N;++b){\n\t  if(!dp[b]) continue;\n\t  for(int j=0;j<N;++j){\n\t\tif(b>>j&1) continue;\n\t\tfor(int k=j+1;k<N;++k){\n\t\t  if(b>>k&1 || cols[j] != cols[k]) continue;\n\t\t  bool ok = (b & (pv[j] | pv[k])) == (pv[j] | pv[k]);\n\t\t  dp[b|(1<<j)|(1<<k)] = dp[b|(1<<j)|(1<<k)] || ok;\n\t\t}\n\t  }\n\t}\n\n\tint ans = 0;\n\tfor(int b=0;b<1<<N;++b) if(dp[b]) ans=max(ans,bc(b));\n\tcout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint n;\nint x[25],y[25],r[25],c[25];\nint cover[25];\ndouble d[25][25];\nbool check[1<<25];\nint cnt,comb,a,b;\nint m,ans;\nint u;\n\ndouble dis(int i,int j){\n  return sqrt( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j]) * (y[i]-y[j]) );\n}\n\nvoid cov(int a){\n  cover[a] = -1;\n  for(int j=a-1;j>=0;j--){\n    if(d[j][a]<r[a]+r[j] && u>>j & 1){\n      cover[a] = j;\n      break;\n    }\n  }\n} \n\n  \nvoid rec(void){\n  int cnt;\n\n  if(check[u])return;\n  check[u] = true;\n\n  for(int i=1;i<=4;i++){\n    cnt = 0;\n    /*\n    for(int j=0;j<n;j++){\n      if( (u>>j & 1) && cover[j]<0 && c[j] == i)cnt++;\n    }\n    if(cnt==6){\n      for(int j=0;j<n;j++){\n\tif(c[j] == i)u -= 1<<j;\n      }\n      for(int j=0;j<n;j++)cov(j);\n\n      ans += 6;\n      m = max(m,ans);\n      if(!check[u]){\n        check[u] = true;\n\trec();\n\tif(!u)return;\n      }\n      ans -= 6;\n\n      for(int j=0;j<n;j++){\n\tif(c[j] == i)u += 1<<j;\n      }\n      for(int j=0;j<n;j++)cov(j);\n    }else{\n    */\n      for(int j=0;j<n;j++){\n\tif( (u>>j & 1) && cover[j]<0 && c[j] == i){\n\t  for(int k=j+1;k<n;k++){\n\t    if( (u>>k & 1) && cover[k]<0 && c[k] == i){\n\t      u -= 1<<j;\n\t      u -= 1<<k;\n\t      for(int l=0;l<n;l++)cov(l);\n\n\t      ans += 2;\n\t      m = max(m,ans);\n\t      rec();\n\t      //if(!u)return;\n\t      ans -= 2;\n\n\t      u += 1<<j;\n\t      u += 1<<k;\n\t      for(int l=0;l<n;l++)cov(l);\n\t    }\n\t  }\n\t}\n      }\n      //}\n  }\n}\n\n\n\nint main(){\n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    for(int i=0;i<n;i++)cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++)d[i][j] = dis(i,j);\n    }\n\n    u = (1<<n) - 1;\n    for(int i=0;i<(1<<n);i++)check[i] = false;\n    for(int i=0;i<n;i++)cov(i);\n\n    \n    m = 0;\n    ans = 0;\n    rec();\n\n    cout << m << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n\n\nstruct Disc{\n\tint x,y,r,c;\n\tDisc(int p_x,int p_y,int p_r,int p_c){\n\t\tx=p_x;y=p_y;r=p_r;c=p_c;\n\t}\n\tDisc(){};\n};\n\nint n;\nint memo[1<<24];\nbool exist[24];\nDisc D[24];\nint ans;\n\nbool touch(Disc a,Disc b){\n\treturn (a.r+b.r)*(a.r+b.r)>(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n}\n\nbool top(int k){\n\tfor(int i=k-1;i>=0;i--){\n\t\tif(exist[i]){\n\t\t\tif(touch(D[k],D[i])) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint dfs(int bit,int num){\n\tif(memo[bit]>=0) return memo[bit];\n\tint res=num;\n\n\tfor(int i=0;i<n;i++){\n\t\tif(exist[i] && top(i)){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(exist[j] && top(j) && i!=j && D[i].c==D[j].c){\n\t\t\t\t\texist[i]=false;\n\t\t\t\t\texist[j]=false;\n\t\t\t\t\tres=dfs((bit&(~(1<<i)))&(~(1<<j)),num+2);\n\t\t\t\t\texist[i]=true;\n\t\t\t\t\texist[j]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemo[bit]=res;\n\tans=max(ans,res);\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin>>n && n!=0){\n\t\tans=0;\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tmemset(exist,true,sizeof(exist));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y,r,c;\n\t\t\tcin>>x>>y>>r>>c;\n\t\tD[i]=Disc(x,y,r,c);\n\t\t}\n\t\tans=0;\n\t\tdfs((1<<24)-1,0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define REP(i, n) FOR(i, 0, n)\n\nint sq(int a)\n{\n\treturn a * a;\n}\n\nint n;\nint x[24], y[24], r[24], c[24];\n\nint dist(int i, int j)\n{\n\treturn sq(x[i] - x[j]) + sq(y[i] - y[j]);\n}\n\nbool isec(int i, int j)\n{\n\treturn dist(i, j) < sq(r[i] + r[j]);\n}\n\nvector<pair<int, int>> v;\nint ng[24];\nint dp[1 << 24];\n\nint calc(int bit)\n{\n\tif (~dp[bit]) return dp[bit];\n\t\n\tint res = 0;\n\t\n\tfor (auto p : v){\n\t\tint c = (1 << p.first) | (1 << p.second);\n\t\tif (bit & c) continue;\n\t\tif (~bit & ng[p.first]) continue;\n\t\tif (~bit & ng[p.second]) continue;\n\t\tres = max(res, 2 + calc(bit | c));\n\t}\n\t\n\treturn dp[bit] = res;\n}\n\nint solve()\n{\n\tv.clear();\n\tREP(i, n) FOR(j, i + 1, n){\n\t\tif (isec(i, j)) continue;\n\t\tif (c[i] != c[j]) continue;\n\t\tv.emplace_back(i, j);\n\t}\n\t\n\tmemset(ng, 0, sizeof ng);\n\tREP(i, n) FOR(j, 0, i){\n\t\tif (isec(i, j)) ng[i] |= 1 << j;\n\t}\n\t\n\tmemset(dp, -1, sizeof dp);\n\treturn calc(0);\n}\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\tREP(i, n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint N, X[24], Y[24], R[24], C[24];\nint r[24], m[24];\nchar dp[16777216];\n\nint f(char n, int s) { return ((s & r[n]) & m[n]) == 0; }\n\nint main(void) {\n  m[0] = 0;\n  REP(i, 0, 23) m[i + 1] = m[i] | (1 << i);\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> X[i] >> Y[i] >> R[i] >> C[i];\n    REP(i, 0, pow(2, N)) dp[i] = -1;\n    REP(i, 0, N) r[i] = 0;\n    REP(i, 0, N) REP(j, 0, N) {\n      if(pow(R[i] + R[j], 2) > pow(X[i] - X[j], 2) + pow(Y[i] - Y[j], 2)) {\n        r[i] = r[i] | (1 << j);\n        r[j] = r[j] | (1 << i);\n      }\n    }\n    char ans = dp[(1 << N) - 1] = 0;\n    for(int s = (1 << N) - 1; s >= 0; s--) {\n      if(dp[s] == -1) continue;\n\n      ans = max(ans, dp[s]);\n\n      REP(i, 0, N) {\n        int mi = (1 << i);\n        if((~s & mi) || !f(i, s)) continue;\n        REP(j, i + 1, N) {\n          int mj = (1 << j);\n          if(C[i] != C[j] || (~s & mj) || !f(j, s)) continue;\n          int ns = ~(~s | mi | mj);\n          dp[ns] = dp[s] + 2;\n        }\n      }\n    }\n    cout << (int) ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-9\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nint N;\n\nmap<vec,int> m;\n\nint dfs(mat &rank, vec &used, vec &C) {\n    if (m.find(used) != m.end()) return m[used];\n    int res = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j) continue;\n            if (!used[i] && !used[j] && C[i] == C[j] && !(rank[i][j] || rank[j][i])) {\n                bool flag = true;\n                for (int k = 0; k < N; k++) {\n                    if (k == i || k == j) continue;\n                    if (rank[i][k] && !used[k]) flag = false;\n                    if (rank[j][k] && !used[k]) flag = false;\n                }\n\n                if (flag) {\n                    used[i] = used[j] = 1;\n                    res = max(dfs(rank, used, C) + 1, res);\n                    used[i] = used[j] = 0;\n                }\n            }\n        }\n    }\n\n    return m[used] = res;\n}\n\nint main() {\n    while (cin >> N, N) {\n        m.clear();\n        vector<double> X(N), Y(N), R(N);\n        vector<int> C(N);\n        for (int i = 0; i < N; i++) {\n            cin >> X[i] >> Y[i] >> R[i] >> C[i];\n        }\n\n        mat rank(N, vec(N));\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                double dis = sqrt(pow(X[i] - X[j], 2.) + pow(Y[i] - Y[j], 2.));\n                if (dis < R[i] + R[j]) {\n                    rank[j][i] = 1;\n                }\n            }\n        }\n\n\n        vec used(N);\n        cout << 2 * dfs(rank, used, C) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\nusing namespace std;\nint dp[(1<<24)];\nint n,x[24],y[24],r[24],c[24],s[24];\nint dist(int a,int b){return (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);}\n\nbool check(int a,int b){\n  int ra=r[a]+r[b];\n  return dist(a,b) < ra*ra;\n}\n\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++)\n      scanf(\"%d %d %d %d\",&x[i],&y[i],&r[i],&c[i]);\n    for(int i=0;i<n;i++){\n      s[i]=0;\n      for(int j=i-1;j>=0;j--)s[i]+=(check(i,j)<<j);\n    }\n    for(int k=1;k<=n;k++){\n      int comb=(1<<k)-1;\n      while(comb<1<<n){\n\tdp[comb]=0;\n\tfor(int i=0;i<n;i++){\n\t  if((comb>>i&1)==0)continue;\n\t  if(comb&s[i])continue;\n\t  for(int j=0;j<n;j++){\n\t    if(c[i]!=c[j]||i==j)continue;\n\t    if((comb>>j&1)==0)continue;\n\t    if(comb&s[j])continue;\n\t    dp[comb]=max(dp[comb],2+dp[comb-(1<<i)-(1<<j)]);\n\t  }\n\t}\n\t\n\tint x=comb&-comb,y=comb+x;\n\tcomb=((comb&~y)/x>>1)|y;\n      }\n    }\n    cout<<dp[(1<<n)-1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 24\nusing namespace std;\n\nint n,x[N],y[N],r[N],c[N],ans,len[N];\nvector<int> v[N];\n\nvoid func(bool erased[N],int cnt,int x){\n  ans=max(ans,cnt);\n  for(int i=x;i<n;i++){\n    int f=0;\n    if(erased[i]) continue;\n    for(int j=0;j<len[i];j++)\n      if(!erased[v[i][j]]) f=1;\n    if(f) continue;\n    for(int j=i+1;j<n;j++){\n      if(c[i]!=c[j]) continue;\n      if(erased[j]) continue;\n      int f2=0;\n      for(int k=0;k<len[j];k++)\n\tif(!erased[v[j][k]]) f2=1;\n      if(f2) continue;\n      erased[i]=erased[j]=true;\n      func(erased,cnt+2,i+1);\n      erased[i]=erased[j]=false;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n      for(int j=i-1;j>=0;j--){\n\tint xl=x[i]-x[j],yl=y[i]-y[j];\n\tint rl=r[i]+r[j];\n\tif(sqrt(xl*xl+yl*yl)<rl)v[i].push_back(j);\n      }\n    }\n    for(int i=0;i<n;i++) len[i]=v[i].size();\n    bool erased[N]={};\n    ans=0;\n    func(erased,0,0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++) v[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\ndouble sqr(double x) { return x*x; }\n\nstruct circle\n{\n  int x, y, r, c;\n  bool covers(const circle& a) const\n  {\n    return sqrt(sqr(x - a.x) + sqr(y - a.y)) < r + a.r;\n  }\n};\n\nint N;\ncircle cs[24];\n\nmap<int,int> memo;\nint dfs(int used)\n{\n  map<int,int>::iterator it = memo.find(used);\n  if (it != memo.end()) {\n    return it->second;\n  }\n  int& ans = memo[used];\n\n  ans = 0;\n  bool top[24];\n  fill_n(top, 24, true);\n  for (int i = 0; i < N; i++) {\n    if (used & (1<<i)) {\n      continue;\n    }\n    for (int j = i+1; j < N; j++) {\n      if (used & (1<<j)) {\n        continue;\n      }\n      if (cs[i].covers(cs[j])) {\n        top[j] = false;\n      }\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    if (used & (1<<i)) {\n      continue;\n    }\n    if (!top[i]) {\n      continue;\n    }\n    for (int j = i+1; j < N; j++) {\n      if (used & (1<<j)) {\n        continue;\n      }\n      if (!top[j]) {\n        continue;\n      }\n      if (cs[i].c == cs[j].c) {\n        ans = max(ans, 2 + dfs(used | (1<<i) | (1<<j)));\n      }\n    }\n  }\n  return ans;\n}\n\nint main()\n{\n  while (cin >> N && N != 0) {\n    for (int i = 0; i < N; i++) {\n      cin >> cs[i].x >> cs[i].y >> cs[i].r >> cs[i].c;\n    }\n    memo.clear();\n    cout << dfs(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nvector<int>x,y,r,c;\nvector<int>memo;\nint n;\nbool intersectCC(int a,int b){\n    int dis = (x[a]-x[b])*(x[a]-x[b]) +(y[a]-y[b])*(y[a]-y[b]);\n    return dis < (r[a]+r[b])*(r[a]+r[b]);\n}\nbool toreru(int bit,int id){\n    rep(i,id){\n        if(intersectCC(i,id) and !(bit >> i & 1)) return false;\n    }\n    return true;\n}\nint dfs(int bit){\n    if(memo[bit] != -INF)return  memo[bit];\n    memo[bit] = 0;\n    for(int i = 0; i < n; i++){\n        for(int j = i+1; j < n;j++){\n            if( bit >> i & 1 or bit >> j &1)continue;\n            if(c[i] != c[j])continue;\n            if(toreru(bit, i) and toreru(bit, j)){\n                cmax(memo[bit], dfs(bit | 1 << i | 1 << j)+2);\n            }\n        }\n    }\n    return memo[bit];\n}\nsigned main(){\n    while(cin >> n,n){\n        x.clear();y.clear();r.clear();c.clear();\n        rep(i,n){\n            int _x,_y,_r,_c;\n            cin >> _x >> _y >> _r >> _c;\n            x.push_back(_x); y.push_back(_y);\n            r.push_back(_r); c.push_back(_c);\n        }\n        memo.assign(1 << n,-INF);\n        cout << dfs(0) << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\nconst int dx[]={0,0,-1,1};\nconst int dy[]={-1,1,0,0};\n\nint x[25],y[25],r[25],c[25];\nint on[25];\n\nbool check(int i,int j){\n\tint d1=(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);\n\tint d2=(r[i]+r[j])*(r[i]+r[j]);\n\treturn d2>d1;\n}\n\nint main(){\n\t\n\tint n;\n\twhile(cin>>n,n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\t\ton[i]=0;\t\t\t\n\t\t}\n\t\t\n\t\t//j???????????????i???????????????????????£????????????\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(check(i,j)) on[j]|=(1<<i);\n\t\t\t}\n\t\t}\n\n\t\t//int??§???MLE\n\t\tvector<char> dp(1<<n,-1);\n\t\tdp[0]=0;\n\t\t\n\t\t//0:???????????????????????? 1:????????????????????????\n\t\tfor(int bit=0;bit<(1<<n);bit++){\n\t\t\tif(dp[bit] == -1) continue;\n\n\t\t\tfor(int i=0;i<n;i++){\n\n\t\t\t\t//??¢??????????????????????????? or ?????????????????????(on[i]???1????????¨bit???0??????????¢???£?????????)\n\t\t\t\tif(bit&(1<<i) || (bit&on[i])!=on[i]) continue;\n\t\t\t\t\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\tif(c[i]!=c[j] || bit&(1<<j) || (bit&on[j])!=on[j]) continue;\n\t\t\t\t\t\n\t\t\t\t\t//i??¨j????????????????????¶????????´??°\n\t\t\t\t\tint next=bit | (1<<i) | (1<<j);\n\t\t\t\t\tdp[next]=max(dp[next],(char)(dp[bit]+2));\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<(int)*max_element(dp.begin(),dp.end())<<endl;\n\t\t\n\t\t\n\t}\n\t\n\treturn 0;\n};"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\nint n;\nint circle[24][4];\nint bitDP[(1<<24)]; // ??????????????????bit??§??????\nint overlap[24]; // ?????????????????????bit??§??????\n\nint main()\n{\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcin >> circle[i][0];\n\t\t\tcin >> circle[i][1];\n\t\t\tcin >> circle[i][2];\n\t\t\tcin >> circle[i][3];\n\t\t\t\n\t\t\toverlap[i] = 0;\n\t\t\tfor(int j = 0; j < i; j++) {\n\t\t\t\tint distance_x = circle[i][0] - circle[j][0];\n\t\t\t\tint distance_y = circle[i][1] - circle[j][1];\n\t\t\t\tdouble distance_circle = sqrt(pow(distance_x, 2) + pow(distance_y, 2));\n\t\t\t\tif(circle[i][2] + circle[j][2] > distance_circle) {\n\t\t\t\t\toverlap[i] += (1 << j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int bit = 0; bit < (1 << n); bit++) {\n\t\t\tbitDP[bit] = 0;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int bit = 0; bit < (1 << n); bit++) {\n\t\t\tif(bit != 0 && bitDP[bit] == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tif(((1 << i) & bit)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int j = i+1; j < n; j++) {\n\t\t\t\t\tif(((1 << i) | (1 << j)) & bit) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(!(((overlap[i] & bit) == overlap[i]) && ((overlap[j] & bit) == overlap[j]))) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(circle[i][3] == circle[j][3]) {\n\t\t\t\t\t\tint next = (((1 << i) | (1 << j)) | bit);\n\t\t\t\t\t\tif(bitDP[next] < bitDP[bit] + 2) {\n\t\t\t\t\t\t\tbitDP[next] = bitDP[bit] + 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ans < bitDP[next]) {\n\t\t\t\t\t\t\tans = bitDP[next];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nstruct E{\n\tvector<int> ov;\n\tint color;\n\tint x, y, r;\n\tE(int _x, int _y, int _r, int _c){\n\t\tcolor = _c;\n\t\tx = _x;\n\t\ty = _y;\n\t\tr = _r;\n\t}\n};\n\nbool dp[(1<<30)] = {0};\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tint x, y, r, c, _ans=0;\n\t\tvector<E> e;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tE tmp(x,y,r,c);\n\t\t\tfor(int j=0; j<e.size(); j++){\n\t\t\t\tif( (e[j].x-x)*(e[j].x-x) + (e[j].y-y)*(e[j].y-y) < (e[j].r+r)*(e[j].r+r) ){\n\t\t\t\t\ttmp.ov.push_back( j );\n\t\t\t\t}\n\t\t\t}\n\t\t\te.push_back( tmp );\n\t\t}\n\t\tdp[0] = true;\n\t\tfor(int i=0; i<(1<<n); i++){\n\t\t\tif(dp[i]){\n\t\t\t\t_ans = i;\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tfor(int l=0; l<n; l++){\n\t\t\t\t\t\tif( k != l && e[k].color == e[l].color){\n\t\t\t\t\t\t\tbool f=true;\n\t\t\t\t\t\t\tfor(int j=0; j<e[k].ov.size(); j++){\n\t\t\t\t\t\t\t\tif( !(i & (1<<e[k].ov[j])) ){\n\t\t\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int j=0; f&&j<e[l].ov.size(); j++){\n\t\t\t\t\t\t\t\tif( !(i & (1<<e[l].ov[j])) ){\n\t\t\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( f ){\n\t\t\t\t\t\t\t\tdp[ i | (1<<k) | (1<<l) ] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=1; i<(1<<n); i<<=1){\n\t\t\tif( i & _ans )\n\t\t\t\tans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    int n; cin >> n;\n    if (!n) break;\n    V<> x(n), y(n), r(n), c(n); for (int i = 0; i < n; ++i) cin >> x[i] >> y[i] >> r[i] >> c[i], --c[i];\n    int bit = ~(~0 << n);\n    V<bool> b(1 << n);\n    int res = 0;\n    auto dfs = [&](const auto& dfs) -> void {\n      if (b[bit]) return;\n      b[bit] = true;\n      res = max(res, n - __builtin_popcount(bit));\n      VV<> idx(4);\n      for (int i = 0; i < n; ++i) if (bit >> i & 1) {\n        bool ok = true;\n        for (int j = 0; j < i; ++j) if (bit >> j & 1) {\n          if ((x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]) < (r[i] + r[j]) * (r[i] + r[j])) {\n            ok = false;\n            break;\n          }\n        }\n        if (ok) idx[c[i]].push_back(i);\n      }\n      for (auto&& v : idx) if (v.size() >= 2) {\n        for (int i : v) for (int j : v) if (i < j) {\n          bit &= ~(1 << i);\n          bit &= ~(1 << j);\n          dfs(dfs);\n          bit |= 1 << i;\n          bit |= 1 << j;\n        }\n      }\n    };\n    dfs(dfs);\n    cout << res << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <map>\n#include <bitset>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){\n    rep(i,v.size()) os << v[i] << (i+1==v.size()?\"\":\" \");\n    return os;\n}\n\ndouble eps = 1e-9;\n\nint n;\nint x[24], y[24], r[24], c[24];\nbool hit[24][24];\nbool erase[24];\nmap<int,int> dp;\n\nint dfs(int S){\n    if(dp.count(S)) return dp[S];\n    int & res = dp[S];\n    res = 0;\n    rep(i,n){\n        if(S>>i & 1){\n            rep(j,i){\n                if(S>>j & 1){\n                    if(hit[i][j] || c[i]!=c[j]) continue;\n                    bool ok = true;\n                    rep(k,i) if(hit[i][k] && (S>>k & 1)) ok = false;\n                    rep(k,j) if(hit[j][k] && (S>>k & 1)) ok = false;\n                    if(!ok) continue;\n                    S ^= 1<<i;\n                    S ^= 1<<j;\n                    res = max(dfs(S)+2, res);\n                    S ^= 1<<i;\n                    S ^= 1<<j;\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(cin>>n && n){\n        rep(i,n) rep(j,n) hit[i][j] = false;\n        rep(i,n) erase[i] = false;\n        rep(i,n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n        rep(i,n)rep(j,i){\n            int dx=x[i]-x[j], dy=y[i]-y[j];\n            double d = sqrt(dx*dx+dy*dy);\n            if(d < r[i]+r[j]-eps){\n                hit[i][j] = hit[j][i] = true;\n            }\n        }\n        int S = 0;\n        rep(i,n) S |= 1<<i;\n        cout << dfs(S) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n\nlong long  mod = 1000000007;\n\n\nbool lap[20][20];\n\n\nbool overlap(int i,int j,vector<int> &x,vector<int>&y,vector<int> &r){\n\tint k = 0;\n\tk = (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]);\n\tif(k>= (r[i]+r[j])*(r[i]+r[j]))return 0;\n\treturn 1;\n}\n\n\nint main(){\n\tint n;\n\twhile(cin >> n && n!=0){\n\t\tset<int>st,st2;\n\t\tvector<int>x(n),y(n),r(n),c(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tfor(int i=0;i<20;i++){\n\t\t\tfor(int j=0;j<20;j++){\n\t\t\t\tlap[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(overlap(i,j,x,y,r)==1){\n\t\t\t\t\tlap[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tbool flag = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(lap[i][j]==0){\n\t\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\t\tif(lap[i][k]&&lap[j][k]){\n\t\t\t\t\t\t\t\tlap[i][j]=1;\n\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)break;\n\t\t}\n\t\t/*for(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tcout << i <<  \" \" << j << \" \" << lap[i][j] << endl;\n\t\t\t}\n\t\t}*/\n\n\t\tst.insert((1<<n)-1);\n\t\tst2.insert((1<<n)-1);\n\t\twhile(1){\n\t\t\tbool flag = 1;\n\t\t\tset<int> st3;\n\t\t\tfor(auto s:st2){\n\t\t\t\t//cout << static_cast<bitset<24>>(s) << endl;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\t\tif(c[i]==c[j]){\n\t\t\t\t\t\t\tif((s&(1<<i))&&(s&(1<<j))){\n\t\t\t\t\t\t\t\tbool fl =1;\n\t\t\t\t\t\t\t\tfor(int p=0;p<i;p++){\n\t\t\t\t\t\t\t\t\tif(lap[p][i]==1&&s&(1<<p))fl = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int p=0;p<j;p++){\n\t\t\t\t\t\t\t\t\tif(lap[p][j]==1&&s&(1<<p))fl = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(fl){\n\t\t\t\t\t\t\t\t\tst.insert(s-(1<<i)-(1<<j));\n\t\t\t\t\t\t\t\t\tst3.insert(s-(1<<i)-(1<<j));\n\t\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tst2 = st3;\n\t\t\tif(flag)break;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(auto s:st){\n\t\t\tint c = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(s&(1<<i)){\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans,n-c);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nconst int limit=10;\nint n,ans;\nint num[limit],x[limit],y[limit],r[limit],v[limit];\nbool visit[limit];\nbool link__[limit][limit];\nusing namespace std;\n\nvoid dfs(int step)\n{\n\tif(step-1>ans) ans=step-1;\n\tfor(int i=1;i<=n;i++) \n\tif ((!visit[i])&&(num[i]==0))\n\t\tfor(int j=1;j<=n;j++) if ((v[i]==v[j])&&(i!=j)&&(!visit[j])&&(num[j]==0)) \n\t\t{\n\t\t\tvisit[i]=true; visit[j]=true;\n\t\t\tfor(int k=1;k<=n;k++) \n\t\t\t{\n\t\t\t\tif(link__[i][k]) num[k]--;\n\t\t\t\tif(link__[j][k]) num[k]--;\n\t\t\t}\n\t\t\tdfs(step+1);\n\t\t\tvisit[i]=false; visit[j]=false;\n\t\t\tfor(int k=1;k<=n;k++) \n\t\t\t{\n\t\t\t\tif(link__[i][k]) num[k]++;\n\t\t\t\tif(link__[j][k]) num[k]++;\n\t\t\t}\n\t\t}\n}\nint main()\n{\n\t//freopen(\"input.txt\",\"r\",stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n\tcin>>n;\n\twhile(n!=0)\n\t{\n\t\tans=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tnum[i]=0;\n\t\t\tfor(int j=1;j<=n;j++) link__[i][j]=false;\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tvisit[i]=false;\n\t\t \tcin>>x[i]>>y[i]>>r[i]>>v[i];\n\t\t \tfor(int j=1;j<i;j++) if((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])<(r[i]+r[j])*(r[i]+r[j]))\n\t\t \t{\n\t\t \t\tlink__[j][i]=true;\n\t\t \t\tnum[i]++;\n\t\t \t}\n\t    }\n\t    dfs(1);\n\t    cout<<ans*2<<endl;\n\t    cin>>n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint n;\nVI xs, ys, rs, cs;\nVI memo;\n\n\nbool is_top(int i, int used) {\n\tfor (int j = i - 1; j >= 0; j--) {\n\t\tif (1 << j & used) continue;\n\n\t\tint x = (xs[i] - xs[j]) * (xs[i] - xs[j]);\n\t\tint y = (ys[i] - ys[j]) * (ys[i] - ys[j]);\n\t\tint dis = x + y;\n\t\tint dis2 = (rs[i] + rs[j]) * (rs[i] + rs[j]);\n\n\t\tif (dis < dis2) {\t// 重なってる\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint dfs(int used) {\n\tint sum = 0;\n\n\tif (memo[used] != -1) return memo[used];\n\n\tfor(int i = 0;i < n;i++) {\n\t\tfor(int j = 0;j < n;j++) {\n\t\t\tif(i == j || (1 << i & used) || (1 << j & used)) continue;\n\t\t\tif(!is_top(i, used) || !is_top(j, used)) continue;\n\n\t\t\tint x = (xs[i] - xs[j]) * (xs[i] - xs[j]);\n\t\t\tint y = (ys[i] - ys[j]) * (ys[i] - ys[j]);\n\t\t\tint dis = x + y;\n\t\t\tint dis2 = (rs[i] + rs[j]) * (rs[i] + rs[j]);\n\n\t\t\tif(dis >= dis2 && cs[i] == cs[j]) {\n\t\t\t\tint used_tmp = used;\n\t\t\t\tused_tmp |= 1 << i;\n\t\t\t\tused_tmp |= 1 << j;\n\n\t\t\t\tsum = max(sum, dfs(used_tmp) + 2);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn memo[used] = sum;\n}\n\nint main(void) {\n\twhile(cin >> n, n){\n\t\txs = VI(n);\n\t\tys = VI(n);\n\t\trs = VI(n);\n\t\tcs = VI(n);\n\t\tint used = 0;\n\t\tmemo = VI(1 << n, -1);\n\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n\t\t}\n\n\t\tcout << dfs(used) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-10\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1 << 28;\n\nint n;\nvector<double> x, y, r;\nvector<int> c;\n\nvector<vector<int> > create (set<int> era) {\n    vector<vector<int> > par(n);\n    for (int i = 0; i < n; i++) {\n        if (era.find(i) != era.end()) {\n            par[i].push_back(INF);\n            continue;\n        }\n        for (int j = 0; j < i; j++) {\n            double dis = pow(x[j] - x[i], 2.0) +  pow(y[j] - y[i], 2.0);\n            if (sqrt(dis) < r[i] + r[j] && era.find(j) == era.end()) {\n                par[i].push_back(j);\n            }\n        }\n    }\n    \n    return par;\n}\n\nint dfs (vector<vector<int> > par, set<int> era) {\n    vector<vector<int> > count(5);\n    for (int i = 0; i < n; i++) {\n        bool flag = true;\n        for (int j = 0; j < par[i].size(); j++) {\n            if (era.find(par[i][j]) == era.end()) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            count[c[i]].push_back(i);\n        }\n    }\n\n    int ret = 0;\n    for (int i = 1; i < count.size(); i++) {\n        if (count[i].size() >= 2) {\n            int tmp = (count[i].size() / 2) * 2;\n            for (int sx = 0; sx < count[i].size(); sx++) {\n                for (int sy = sx + 1; sy < count[i].size(); sy++) {\n                    if (sx == sy) continue;\n                    set<int> t_era(era);\n                    t_era.insert(count[i][sx]);\n                    t_era.insert(count[i][sy]);\n                    vector<vector<int> > t_par(create(t_era));\n                    ret = max(ret, (dfs(t_par, t_era) + tmp));\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nint main () {\n    while (cin >> n, n) {\n        x.resize(n), y.resize(n), r.resize(n), c.resize(n);\n        for (int i = 0; i < n; i++) {\n            cin  >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n        vector<vector<int> > par(create(set<int>()));\n\n        cout << dfs(par, set<int>()) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nstringstream __ss__;\n#define debug __ss__\n#endif\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) debug << *i << \" \"; debug << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;i--)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);i--)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define SS stringstream\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nint x[30],y[30],r[30],c[30],removed[30],top[30];\n\nint main() {\n\tint n;\n\tIL{\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\trep(i,n){\n\t\t\tcin>>x[i]>>y[i]>>r[i]>>c[i];\n\t\t\tremoved[i]=0;\n\t\t}\n\t\twhile(true){\n\t\t\tmemset(top,-1,sizeof(top));\n\t\t\trep(i,n){\n\t\t\t\tif(removed[i]==1){\n\t\t\t\t\ttop[i]=0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trep(j,i){\n\t\t\t\t\tif(removed[j]==1)continue;\n\t\t\t\t\tif((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])<(r[i]+r[j])*(r[i]+r[j])){\n\t\t\t\t\t\ttop[i]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,n){\n\t\t\t\tif(top[i]==0)continue;\n\t\t\t\trepn(j,i+1,n-1){\n\t\t\t\t\tif(top[j]==0)continue;\n\t\t\t\t\tif(c[i]==c[j]){\n\t\t\t\t\t\tremoved[i]=removed[j]=1;\n\t\t\t\t\t\tgoto next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tnext:;\n\t\t}\n\t\tint res=0;\n\t\trep(i,n){\n\t\t\tif(removed[i]==1)++res;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//線分を表す構造体\nstruct Segment{ Point p1, p2; };\n//直線を表す構造体\ntypedef Segment Line;\n//多角形を表す構造体\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// 許容する誤差\n#define EPS (1e-10)\n\n// ベクトルaの絶対値を求める\n//double length = abs(a);\n\n// 2点a,b間の距離を求める\n//double distance = abs(a-b);\n\n/*\n// ベクトルaの単位ベクトルを求める\nPoint b = a / abs(a);\n\n// ベクトルaの法線ベクトルn1,n2を求める\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 点cが直線a,b上にあるかないか\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// 点a,bを通る直線と点cとの距離\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// 線分s1と線分s2の距離\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// 線分sに対する点pの射影\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//線分sを対象軸とした点pの線対称の点\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//点pをangle分だけ時計回りに回転\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//円cと線分lの交点\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//点の内包\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//ベクトルの位置検出\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//凸包\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISEだと内角は180以下（一直線上に並んでいても、頂点として数える）\n        //!= CLOCKWISEだと内角は180未満（一直線上の頂点は数えない）\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //ここも == と != を変更する\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //最も下にある点の中で最も右にある点から反時計回りに並び替え\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//キャリパー法を用いて凸多角形の直径を求める\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//凸多角形の切り取りに使う関数。これがなんなのかはまだ知らない。\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//三角形の面積\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//多角形の面積\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//凸多角形かどうかの判定\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//凹多角形を線分lで切断した際の多角形の数\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\n//i番目を0にする\nint clearBit(int num, int i){\n\tint mask = ~(1 << i);\n\treturn num & mask;\n}\n\n//i番目をvで置き換える\nint updateBit(int num, int i, int v){\n\tint mask = ~(1 << i);\n\treturn (num & mask) | (v << i);\n}\n\nint n, ans;\n\nbool isOver(Circle a, Circle b){\n\treturn abs(a.c - b.c) < a.r + b.r;\n\n\tpair<Point,Point> tmp = getCrossPoints(a,b);\n\tdouble na = tmp.first.imag();\n\n\tint dist1 = pow(a.c.imag()-b.c.imag(),2) + pow(a.c.real()-b.c.real(),2);\n\tint dist2 = pow(a.r+b.r,2);\n\treturn dist2 > dist1;\n\n\n    return std::isnan(na) == 0;\n}\n\nvoid dfs(vector<vector<int>>& g, int cur, vector<int>& on){\n\tfor(auto to : g[cur]){\n\t\ton[to] = on[to] bitor (1 << cur) bitor on[cur];\n\t\tdfs(g, to, on);\n\t}\n}\n\nvector<int> memo;\nint dfs(int s, vector<int>& on, vector<int>& c){\n\tif(memo[s] != -1) return memo[s];\n\n\tint canTake[4][6] = {{0}};\n\tint size[4] = {0};\n\trep(i,n){\n\t\tif(getBit(s,i)) continue;\n\t\tif((on[i] bitand s) == on[i]){\n\t\t\tcanTake[c[i]][size[c[i]]++] = i;\n\t\t}\n\t}\n\n\tint res = 0;\n\trep(i,4){\n\t\trep(j,size[i]){\n\t\t\trange(k,j + 1, size[i]){\n\t\t\t\tint nxt = setBit(setBit(s, canTake[i][j]), canTake[i][k]);\n\t\t\t\tres = max(res, dfs(nxt, on, c) + 2);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn memo[s] = res;\n}\n\nint solve(vector<int>& on, vector<int>& c){\n\n\tvector<vector<int>> canTake(4);\n\n\tint ans = 0;\n\tvector<short> dp(1 << n,0);\n\tshow(\"JI\")\n\t\tshow((1 << n) * n * n)\n\trep(s, 1 << n){\n\t\tans = max<int>(ans, dp[s]);\n\t\trep(i,n - 1){\n\t\t\tif(getBit(s,i)) continue;\n\t\t\tif((on[i] bitand s) != on[i]) continue;\n\t\t\trange(j,i + 1, n){\n\t\t\t\tif(getBit(s,j)) continue;\n\t\t\t\tif((on[j] bitand s) != on[j]) continue;\n\t\t\t\tif(c[i] != c[j]) continue;\n\n\t\t\t\tint nxt = setBit(setBit(s,i),j);\n\t\t\t\tdp[nxt] = max<int>(dp[nxt], dp[s] + 2);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n    while(scanf(\"%d\",&n),n){\n        vector<Circle> c(n);\n        vector<int> color(n), on(n,0);\n        rep(i,n){\n            double x,y,r;\n            scanf(\"%lf%lf%lf%d\",&x,&y,&r,&color[i]);\n\t\t\tcolor[i]--;\n            c[i] = {Point(x,y),r};\n\t\t\trep(j,i){\n\t\t\t\tif(isOver(c[i], c[j])) on[i] = setBit(on[i], j);\n\t\t\t}\n        }\n\t\tans = 0;\n\t\tmemo = vector<int>(1 << n, -1);\n\t\tcout << dfs(0, on, color) << endl;\n\t\tcontinue;\n\n\t\t//vector<vector<int>> g(n);\n\t\t//vector<bool> top(n,1);\n\t\t//rep(i,n){\n\t\t//\trange(j,i + 1,n){\n\t\t//\t\tif(isOver(c[i], c[j])){\n\t\t//\t\t\tg[i].emplace_back(j);\n\t\t//\t\t\ttop[j] = false;\n\t\t//\t\t}\n\t\t//\t}\n\t\t//}\n\n\t\t//rep(i,n){\n\t\t//\tif(not top[i]) continue;\n\t\t//\tdfs(g, i, on);\n\t\t//}\n\t\t//rep(i,n) show(bitset<24>(on[i]))\n\n\t\t//ans = 0;\n\t\t//memo = vector<bool>(1 << n, 0);\n\t\t//dfs(0, on, color);\n\t\t//cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define REP(i,n) for(long long i = 0;i < n;++i)    \n#define seg_size 524288\nvector<tuple<int, int, int, int>> en;\nint bad[30] = {};\nint already_done[1LL << 24LL];\nint cnt[30] = {};\nint kasane(int x1, int y1, int c1, int x2, int y2, int c2) {\n\tint hoge = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n\tif (hoge >= (c1 + c2) * (c1 + c2)) return 0;\n\treturn 1;\n}\nint solve(int now) {\n\tif (already_done[now] == 1) return 0;\n\talready_done[now] = 1;\n\tint ans = 0;\n\tfor (int i = 0; i < en.size(); ++i) {\n\t\tif (cnt[i] == 0 && bad[i] == 0) {\n\t\t\tfor (int q = i + 1; q < en.size(); ++q) {\n\t\t\t\tif (cnt[q] == 0 && bad[q] == 0) {\n\t\t\t\t\tif (get<3>(en[q]) == get<3>(en[i])) {\n\t\t\t\t\t\tbad[i] = 1;\n\t\t\t\t\t\tbad[q] = 1;\n\t\t\t\t\t\tfor (int j = i + 1; j < en.size(); ++j) {\n\t\t\t\t\t\t\tint hoge = kasane(get<0>(en[i]), get<1>(en[i]), get<2>(en[i]), get<0>(en[j]), get<1>(en[j]), get<2>(en[j]));\n\t\t\t\t\t\t\tif (hoge == 1) {\n\t\t\t\t\t\t\t\tcnt[j]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int j = q + 1; j < en.size(); ++j) {\n\t\t\t\t\t\t\tint hoge = kasane(get<0>(en[q]), get<1>(en[q]), get<2>(en[q]), get<0>(en[j]), get<1>(en[j]), get<2>(en[j]));\n\t\t\t\t\t\t\tif (hoge == 1) {\n\t\t\t\t\t\t\t\tcnt[j]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans = max(ans, solve(now + (1 << i)+(1 << q))+2);\n\t\t\t\t\t\tbad[i] = 0;\n\t\t\t\t\t\tbad[q] = 0;\n\t\t\t\t\t\tfor (int j = i + 1; j < en.size(); ++j) {\n\t\t\t\t\t\t\tint hoge = kasane(get<0>(en[i]), get<1>(en[i]), get<2>(en[i]), get<0>(en[j]), get<1>(en[j]), get<2>(en[j]));\n\t\t\t\t\t\t\tif (hoge == 1) {\n\t\t\t\t\t\t\t\tcnt[j]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int j = q + 1; j < en.size(); ++j) {\n\t\t\t\t\t\t\tint hoge = kasane(get<0>(en[q]), get<1>(en[q]), get<2>(en[q]), get<0>(en[j]), get<1>(en[j]), get<2>(en[j]));\n\t\t\t\t\t\t\tif (hoge == 1) {\n\t\t\t\t\t\t\t\tcnt[j]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\twhile (true) {\n\t\ten.clear();\n\t\tREP(i, 1 << 24) {\n\t\t\talready_done[i] = 0;\n\t\t}\n\t\tREP(q, 30) {\n\t\t\tcnt[q] = 0;\n\t\t\tbad[q] = 0;\n\t\t}\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0) return 0;\n\t\tREP(i, n) {\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ten.push_back(make_tuple(a, b, c, d));\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int q = i + 1; q < n; ++q) {\n\t\t\t\tif (kasane(get<0>(en[q]), get<1>(en[q]), get<2>(en[q]), get<0>(en[i]), get<1>(en[i]), get<2>(en[i])) == 1) {\n\t\t\t\t\tcnt[q]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << solve(0) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<vector>\n#include<algorithm>\nstruct S{int c,f,x,y,r;}s[24];\nint A(int x){return x*x;}\nchar m[1<<24];\nint n,c[5];\nint F(int f)\n{\n\tif(m[f]>=0)return m[f];\n\tstd::vector<int>v[5];\n\tint i,j,k,r=0,maxr=0,t;\n\tfor(i=0;i<n;++i)\n\t\tif((f&(1<<i))&&!(s[i].f&f))\n\t\t\tv[s[i].c].push_back(i);\n\tfor(k=1;k<5;++k)\n\t{\n\t\tif(c[k]>0&&c[k]%2==0&&c[k]==v[k].size())\n\t\t{\n\t\t\tr+=c[k];\n\t\t\tc[k]=0;\n\t\t\tt=f;\n\t\t\tfor(i=0;i<v[k].size();++i)t^=(1<<v[k][i]);\n\t\t\tr+=F(t);\n\t\t\tc[k]=v[k].size();\n\t\t\treturn m[f]=r;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(i=0;i<v[k].size();++i)\n\t\t\t\tfor(j=i+1;j<v[k].size();++j)\n\t\t\t\t{\n\t\t\t\t\tc[k]-=2;\n\t\t\t\t\tr=2+F(f&~(1<<v[k][i])&~(1<<v[k][j]));\n\t\t\t\t\tmaxr=std::max(maxr,r);\n\t\t\t\t\tc[k]+=2;\n\t\t\t\t}\n\t\t}\n\t}\n\treturn m[f]=maxr;\n}\nint main()\n{\n\tint i,j;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tmemset(m,-1,sizeof(m));\n\t\tmemset(s,0,sizeof(s));\n\t\tmemset(c,0,sizeof(c));\n\t\tfor(i=0;i<n;++i)scanf(\"%d%d%d%d\",&s[i].x,&s[i].y,&s[i].r,&s[i].c),++c[s[i].c];\n\t\tfor(i=0;i<n;++i)\n\t\t\tfor(j=i+1;j<n;++j)\n\t\t\t\tif(A(s[i].x-s[j].x)+A(s[i].y-s[j].y)<A(s[i].r+s[j].r))\n\t\t\t\t\ts[j].f|=1<<i;\n\t\tprintf(\"%d\\n\",F((1<<n)-1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 24\nusing namespace std;\n\nint n,x[N],y[N],r[N],c[N],ans,len[N],cn;\nvector<int> v[N];\n\nvoid func(bool erased[N],int cnt,int x){\n  if(cn==10000000) return ;\n  cn++;\n  ans=max(ans,cnt);\n  for(int i=0;i<n;i++){\n    int f=0;\n    if(erased[i]) continue;\n    for(int j=0;j<len[i];j++)\n      if(!erased[v[i][j]]) f=1;\n    if(f) continue;\n    for(int j=i+1;j<n;j++){\n      if(c[i]!=c[j]) continue;\n      if(erased[j]) continue;\n      int f2=0;\n      for(int k=0;k<len[j];k++)\n\tif(!erased[v[j][k]]) f2=1;\n      if(f2) continue;\n      erased[i]=erased[j]=true;\n      func(erased,cnt+2,x+1);\n      erased[i]=erased[j]=false;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    cn=0;\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n      for(int j=i-1;j>=0;j--){\n\tint xl=x[i]-x[j],yl=y[i]-y[j];\n\tint rl=r[i]+r[j];\n\tif(xl*xl+yl*yl<rl*rl)v[i].push_back(j);\n      }\n    }\n    for(int i=0;i<n;i++) len[i]=v[i].size();\n    bool erased[N]={};\n    ans=0;\n    func(erased,0,0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++) v[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\n#define For(i,a,b)  for(int i = a;i < b;i++)\n#define rep(i,n)\tFor(i,0,n)\n#define all(n)\t\tn.begin(),n.end()\n\n//(x + a)^2 + (y + b)^2 <= c\n\nstruct Circle{\n\tint x, y, r;\n\tint c;\n\tCircle(){};\n\tCircle(int x, int y, int r, int c) :x(x), y(y), r(r), c(c){}\n\tint inter(Circle cl){\n\t\tint tx = cl.x, ty = cl.y;\n\t\tint t = (x - tx)*(x - tx) + (y - ty)*(y - ty);\n\t\tint R = (r + cl.r)*(r + cl.r);\n\t\tif (t < R)return 1;\n\t\tif (t >= R)return 0;\n\t}\n};\n\nint n;\n\nint dfs(vector<Circle> v){\n\n\tvector<int> tv[5];\n\trep(i, v.size()){\n\t\tbool tf = true;\n\t\tFor(j,i+1, v.size()){\n\t\t\tif (v[i].inter(v[j]) == 1){\n\t\t\t\ttf = false;\n\t\t\t}\n\t\t}\n\t\tif (tf){\n\t\t\ttv[v[i].c].push_back(i);\n\t\t}\n\t}\n\n\tint ret = 0;\n\tbool f = false;\n\n\trep(i, 5){\n\t\tif (tv[i].size() >= 2){\n\t\t\tif (tv[i].size() % 2){\n\t\t\t\trep(j, tv[i].size()){\n\t\t\t\t\tFor(k, j + 1, tv[i].size()){\n\t\t\t\t\t\tvector<Circle> tmpv;\n\n\t\t\t\t\t\trep(l, v.size()){\n\t\t\t\t\t\t\tif (tv[i][j] != l && tv[i][k] != l)\n\t\t\t\t\t\t\t\ttmpv.push_back(v[l]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tret = max(ret, dfs(tmpv));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvector<Circle> tmpv;\n\t\t\t\tbool cf[100]; memset(cf, 0, sizeof cf);\n\t\t\t\trep(j, tv[i].size()){\n\t\t\t\t\tcf[tv[i][j]] = true;\n\t\t\t\t}\n\t\t\t\trep(j, v.size()){\n\t\t\t\t\tif (!cf[j])\n\t\t\t\t\ttmpv.push_back(v[j]);\n\t\t\t\t}\n\t\t\t\tret = max(ret, dfs(tmpv));\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!f){\n\t\treturn n - v.size();\n\t}\n\t\n\treturn ret;\n}\n\n\nint main()\n{\n\n\twhile (cin >> n && n){\n\n\t\tvector<Circle> v;\n\t\trep(i, n){\n\t\t\tint x, y, r, c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tv.push_back(Circle(x, y, r, c));\n\t\t}\n\n\t\treverse(all(v));\n\n\t\tcout << dfs(v) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 24;\nint N;\nint xs[MAX_N], ys[MAX_N], rs[MAX_N], cs[MAX_N];\nint overs[MAX_N];\nbool dp[1<<MAX_N];\n\nint sq(int x){\n\treturn x*x;\n}\n\nvoid init(){\n\tmemset(overs, 0, sizeof(overs));\n\tfor(int i=0; i<N; i++)for(int j=i+1; j<N; j++){\n\t\tint dist = sq(xs[i] - xs[j]) + sq(ys[i] - ys[j]);\n\t\tint r = sq(rs[i] + rs[j]);\n\t\tif(dist < r){\n\t\t\tovers[j] |= 1<<i;\n\t\t}\n\t}\n}\n\nint solve(){\n\tinit();\n\n\tmemset(dp, 0, sizeof(dp));\n\tdp[0] = true;\n\tfor(int bit=0; bit<(1<<N); bit++)if(dp[bit]){\n\t\tfor(int i=0; i<N; i++)if(!((bit>>i)&1) && (overs[i]&bit)==overs[i]){\n\t\t\tfor(int j=i+1; j<N; j++)if(cs[i] == cs[j] && !((bit>>j)&1) && (overs[j]&bit)==overs[j]){\n\t\t\t\tdp[bit | (1<<i) | (1<<j)] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 0;\n\tfor(int i=0; i<(1<<N); i++)if(dp[i]){\n\t\tret = max(ret, __builtin_popcount(i));\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(scanf(\"%d\",&N),N){\n\t\tfor(int i=0; i<N; i++){\n\t\t\tscanf(\"%d%d%d%d\",xs+i,ys+i,rs+i,cs+i);\n\t\t}\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-9\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nint N;\n\nmap<int,int> m;\n\nint to_i (vec &used) {\n    int res = 0;\n    for (int i = 0; i < N; i++) {\n        if (used[i])\n            res |= 1 << i;\n    }\n}\n\nint dfs(mat &rank, vec &used, vec &C) {\n    int toI = to_i(used);\n    if (m.find(toI) != m.end()) return m[toI];\n    int res = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j) continue;\n            if (!used[i] && !used[j] && C[i] == C[j]) {\n                bool flag = true;\n                for (int k = 0; k < N; k++) {\n                    if (rank[i][k] && !used[k]) flag = false;\n                    if (rank[j][k] && !used[k]) flag = false;\n                }\n\n                if (flag) {\n                    used[i] = used[j] = 1;\n                    res = max(dfs(rank, used, C) + 1, res);\n                    used[i] = used[j] = 0;\n                }\n            }\n        }\n    }\n\n    return m[toI] = res;\n}\n\nint main() {\n    while (cin >> N, N) {\n        m.clear();\n        vector<double> X(N), Y(N), R(N);\n        vector<int> C(N);\n        for (int i = 0; i < N; i++) {\n            cin >> X[i] >> Y[i] >> R[i] >> C[i];\n        }\n\n        mat rank(N, vec(N));\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                double dis = sqrt(pow(X[i] - X[j], 2.) + pow(Y[i] - Y[j], 2.));\n                if (dis < R[i] + R[j]) {\n                    rank[j][i] = 1;\n                }\n            }\n        }\n\n        vec used(N);\n        cout << 2 * dfs(rank, used, C) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstruct Disk{\n\tdouble x, y, r;\n\tint c, id;\n}disk[30];\nvector<Disk> colors[6];\nint dp[1<<24];\ndouble dis[25][25];\nbool iscover(int a, int b){\n\tdouble r = (disk[a].r+disk[b].r)*(disk[a].r+disk[b].r);\n\tif(dis[a][b] < r){\n\t\treturn true;\n\t}\n\treturn false;\n}\nbool ontop(int a, int state){\n\tfor(int i = 0; i < a; i++)\n\t\tif(!((state >> i) & 1) && iscover(i, a)){\n\t\t\treturn false;\n\t\t}\n\treturn true;\n}\nbool pairable(int a, int b, int state){\n\tif(!iscover(a, b) && ontop(a, state) && ontop(b, state))\n\t\treturn true;\n\treturn false;\n}\nint main(){\n\tint n;\n\twhile(scanf(\"%d\", &n), n){\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor(int i = 1; i <= 4; i++)\n\t\t\tcolors[i].clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%lf%lf%lf%d\", &disk[i].x, &disk[i].y, &disk[i].r, &disk[i].c);\n\t\t\tdisk[i].id = i;\n\t\t\tcolors[disk[i].c].push_back(disk[i]);\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\tdis[i][j] = (disk[i].x-disk[j].x)*(disk[i].x-disk[j].x)+(disk[i].y-disk[j].y)*(disk[i].y-disk[j].y);\n\t\tint M = 1 << n;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tif(i > 0 && !dp[i])\n\t\t\t\tcontinue;\n\t\t\tfor(int c = 1; c <= 4; c++){\n\t\t\t\tfor(int j = 0; j < colors[c].size(); j++){\n\t\t\t\t\tif((1<<colors[c][j].id)& i)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor(int k = j+1; k < colors[c].size(); k++){\n\t\t\t\t\t\t\tif((1<<colors[c][k].id) & i)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t//printf(\"(%d, %d)\\n\", colors[c][j].id, colors[c][k].id);\n\t\t\t\t\t\t\tif(pairable(colors[c][j].id, colors[c][k].id, i)){\n\t\t\t\t\t\t\t\tint nstate = i | (1<<colors[c][j].id) | (1<<colors[c][k].id);\n\t\t\t\t\t\t\t\tdp[nstate] = max(dp[nstate], dp[i]+2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < M; i++)\n\t\t\tans = max(ans, dp[i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define iota(i,n,b,s) for(int i=int(b);i!=int((b)+(s)*(n));i+=(s))\n#define range(i,n,m) iota(i,(((n)>(m))?((n)-(m)):((m)-(n))),(n),((n)>(m)?-1:1))\n#define rep(i,n) iota(i,(n),0,1)\n#define loop for(;;)\n\n#define INF (1e9)\n#define EPS (1e-9)\n#define cons(a,b) (make_pair(a,b))\n#define car(a) (a.first)\n#define cdr(a) (a.second)\n#define cadr(a) (car(cdr(a)))\n#define cddr(a) (cdr(cdr(a)))\n#define all(a) a.begin(), a.end()\n#define trace(var) cerr<<\">>> \"<<#var<<\" = \"<<var<<endl;\n\ntypedef long long Integer;\ntypedef double Real;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef map<string,int> Dictionary;\nconst Real PI = acos(-1);\n\ntemplate<class S, class T>\nostream& operator<<(ostream& os, pair<S,T> p) {\n  os << '(' << car(p) << \", \" << cdr(p) << ')';\n  return os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T> v) {\n  if (v.size() == 0) {\n    os << \"(empty)\";\n    return os;\n  }\n  os << v[0];\n  for (int i=1, len=v.size(); i<len; ++i) os << ' ' << v[i];\n  return os;\n}\n\nint dx[] = { -1, 0, 1, 0 };\nint dy[] = {  0, -1, 0, 1 };\n\nbool\nintersect(vector<int>&xs, vector<int>&ys, vector<int>&rs, int i, int j) {\n  int x0 = xs[i];\n  int y0 = ys[i];\n  int r0 = rs[i];\n  int x1 = xs[j];\n  int y1 = ys[j];\n  int r1 = rs[j];\n  return pow(x1 - x0, 2) + pow(y1 - y0, 2) < pow(r0 + r1, 2);\n}\n\nstring ni(unsigned int n) {\n  string r = \"\";\n  rep (i, 10) r += n & (1 << i) ? \"1\" : \"0\";\n  return r;\n}\n\nint f(vector<vector<bool>>&d, vector<int>&cs) {\n  const int n = d.size();\n\n  vector<bool> memo(1 << n, false);\n\n  stack<pair<unsigned int, int>> s;\n  s.push(cons(0, 0));\n  int ans = 0;\n\n  int cx = 0;\n\n  while (!s.empty()) {\n    auto t = s.top(); s.pop();\n    int r = car(t);\n    int m = cdr(t);\n    ans = max(ans, m);\n    if (ans == n) return n;\n\n    if (memo[r]) continue;\n    memo[r] = true;\n    //trace(ni(r));\n\n    rep (i, n) {\n      if (r & (1 << i)) continue;\n      range (j, i + 1, n) {\n        if (r & (1 << j)) continue;\n        if (cs[i] != cs[j]) continue;\n\n        bool bi = false;\n        rep (k, i) if (!(r & (1 << k)) && d[k][i]) bi = true;\n        if (bi) continue;\n        bool bj = false;\n        rep (k, j) if (!(r & (1 << k)) && d[k][j]) bj = true;\n        if (bj) continue;\n\n        s.push( cons(r | (1 << i) | (1 << j), m + 2) );\n        //cout << \"remove \" << cons(i, j) << endl;\n      }\n    }\n  }\n\n  return ans;\n}\n\nint main() {\n\n  for (int n; cin >> n, n; ) {\n    vector<int> xs;\n    vector<int> ys;\n    vector<int> rs;\n    vector<int> cs;\n\n    rep (i, n) {\n      int x, y, r, c;\n      cin >> x >> y >> r >> c;\n      --c;\n      xs.push_back(x);\n      ys.push_back(y);\n      rs.push_back(r);\n      cs.push_back(c);\n    }\n\n    // d[i][j] = i is on j\n    vector<vector<bool>> d(n, vector<bool>(n, false));\n    rep (i, n) {\n      for (int j = i + 1; j < n; ++j) {\n        d[i][j] = intersect(xs, ys, rs, i, j);\n      }\n    }\n    cout << f(d, cs) << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define MAX_COLORS 6\n#define MAX_CIRCLES 4\n#define MAX_N (MAX_COLORS*MAX_CIRCLES)\n#define MAX_STATES (1<<MAX_N)\n\nint biggest, n;\n\nstruct circle{\n    int x, y, r, c;\n};\n\ncircle C[MAX_N];\nchar dp[MAX_STATES];\n\nbool isOver( circle c1, circle c2 ){\n    int dx, dy;\n    dx = (c1.x - c2.x) * (c1.x - c2.x);\n    dy = (c1.y - c2.y) * (c2.y - c2.y);\n    return dx + dy < (c1.r + c2.r)*(c1.r + c2.r) ? true : false;\n}\n\nbool isDeleted( int state, int num ){\n    return (state & (1<<num)) == 0 ? false : true;\n}\n\nbool isTop( int state, int num ){\n    for( int i = num-1; i >= 0; i-- ){\n        if( isDeleted(state, i) ) continue;\n        if( isOver(C[num], C[i]) ) return false;\n    }\n    //cout << num << endl;\n    return true;\n}\n\nvoid search(){\n    for( int s = 0; s < 1<<n; s++ ){\n        //cout << s << endl;\n        if( dp[s] == -1 ) continue;\n        for( int i = 0; i < n; i++ ){\n            if( isDeleted(s, i) ) continue;\n            //cout << \"i: \" << i << endl;\n            for( int j = i+1; j < n; j++ ){\n                if( isDeleted(s, 1<<j) ) continue;\n                //cout << \"j: \" << j << endl;\n                if( isTop(s, i) && isTop(s, j) && C[i].c == C[j].c ){\n                    int next = s | 1<<i | 1<<j;\n                    dp[next] = (dp[next] < dp[s]+2) ? dp[s]+2 : dp[next];\n                    biggest = (biggest < dp[next]) ? dp[next] : biggest;\n                }\n            }\n        }\n    }\n}\n\nvoid init(){\n    for( int s = 0; s < 1<<n; s++ ){\n        dp[s] = -1;\n    }\n}\n\nint main(){\n    while( cin >> n, n ){\n        for( int i = 0; i < n; i++ ){\n            circle a;\n            cin >> a.x >> a.y >> a.r >> a.c;\n            C[i] = a;\n        }\n        biggest = 0;\n        init();\n        dp[0] = 0;\n        search();\n        cout << biggest << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// #include <iostream>\n// #include <cmath>\n// #include <vector>\n\n// using namespace std;\n\n// struct Circle {\n//     int x, y, r, c;\n//     Circle() {}\n//     Circle(int x, int y, int r, int c)\n//         : x(x), y(y), r(r), c(c) {}\n// };\n\n// int n, ans;\n// vector<char> dp, up;\n// vector<Circle> c;\n\n// inline bool isOverlap(const Circle &a, const Circle &b)\n// {\n//     int r = (a.r + b.r) * (a.r + b.r);\n//     int d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n//     return r > d;\n// }\n\n// char Rec(char s)\n// {\n//     if (dp[s] != -1)\n//         return dp[s];\n\n//     int res = 0;\n//     // 取り除く2つの円の選択\n//     for (int i = 0; i < n; ++i) {\n//         // c[i]がないか取り除けない\n//         if (!(s >> i & 1) || s & up[i])\n//             continue;\n\n//         for (int j = i + 1; j < n; ++j) {\n//             // c[i]とc[j]の色が異なる\n//             if (c[i].c != c[j].c)\n//                 continue;\n//             // c[j]がないか取り除けない\n//             if (!(s >> j & 1) || s & up[j])\n//                 continue;\n\n//             int nxt = s & ~(1 << i) & ~(1 << j);\n//             res = max(res, (int)Rec(nxt) + 2);\n//         }\n//     }\n\n//     ans = max(ans, res);\n\n//     return dp[s] = res;\n// }\n\n// int main()\n// {\n//     while (cin >> n, n) {\n//         dp.assign(1 << n, -1);\n//         up.assign(n, 0);\n//         c.resize(n);\n\n//         // 円の入力\n//         for (int i = 0; i < n; ++i)\n//             cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n//         // 円の重なり，上下関係\n//         for (int i = 0; i < n; ++i)\n//             for (int j = i + 1; j < n; ++j)\n//                 if (isOverlap(c[i], c[j]))\n//                     up[j] |= (1 << i);\n\n//         ans = 0;\n//         Rec((1 << n) - 1);\n\n//         cout << ans << endl;\n//     }\n\n//     return 0;\n// }\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint n;\nint x[24],y[24],c[24],r[24];\nchar memo[1<<24];\nint hit(int i,int j){\n\tint L = r[i]*r[i] + r[j]*r[j] + 2 * r[i] * r[j];\n\tint X = (x[i]-x[j])*(x[i]-x[j]);\n\tint Y = (y[i]-y[j])*(y[i]-y[j]);\n\treturn X + Y < L;\n}\nint nocover(int n,int bit){\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( (bit>>i&1) && hit(i,n) ) return false;\n\t}\n\treturn true;\n}\nint dfs(int bit){\n\tif(~memo[bit]) return memo[bit];\n\tint ans = 0;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tfor(int j = i+1 ; j < n ; j++){\n\t\t\tif( (bit >> j & 1) && (bit >> i & 1) && c[i] == c[j] && nocover(i,bit) && nocover(j,bit) ){\n\t\t\t\tans = max(ans , dfs( bit & ~(1<<j) & ~(1<<i) ) + 2);\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[bit] = ans;\n}\nint main(){\n\twhile(cin >> n , n){\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tcout << dfs((1<<n)-1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nint n;\nint x[24],y[24],r[24],c[24];\nint dist(int a,int b){return (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);}\n \nint rec(int S){\n  int res=0;\n  bool f[n];\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    f[i]=true;\n    for(int j=i-1;j>=0;j--){\n      if((S>>j)&1)continue;\n      if(dist(i,j)>=(r[i]+r[j])*(r[i]+r[j]))continue;\n      f[i]=false;\n    }\n  }\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    if(!f[i])continue;\n    for(int j=i+1;j<n;j++){\n      if((S>>j)&1)continue;\n      if(!f[j])continue;\n      if(c[i]!=c[j])continue;\n      return 2+rec(S+(1<<i)+(1<<j));\n    }\n  }\n  return 0;\n}\n \nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++)\n      scanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n    cout<<rec(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n\nlong long  mod = 1000000007;\n\n\nbool lap[20][20];\n\n\nbool overlap(int i,int j,vector<int> &x,vector<int>&y,vector<int> &r){\n\tint k = 0;\n\tk = (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]);\n\tif(k>= (r[i]+r[j])*(r[i]+r[j]))return 0;\n\treturn 1;\n}\n\n\nint main(){\n\tint n;\n\twhile(cin >> n && n!=0){\n\t\tset<int>st,st2;\n\t\tvector<int>x(n),y(n),r(n),c(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tfor(int i=0;i<20;i++){\n\t\t\tfor(int j=0;j<20;j++){\n\t\t\t\tlap[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(overlap(i,j,x,y,r)==1){\n\t\t\t\t\tlap[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tbool flag = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(lap[i][j]==0){\n\t\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\t\tif(lap[i][k]&&lap[j][k]){\n\t\t\t\t\t\t\t\tlap[i][j]=1;\n\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)break;\n\t\t}\n\t\t/*for(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tcout << i <<  \" \" << j << \" \" << lap[i][j] << endl;\n\t\t\t}\n\t\t}*/\n\n\t\tst.insert((1<<n)-1);\n\t\tst2.insert((1<<n)-1);\n\t\twhile(1){\n\t\t\tbool flag = 1;\n\t\t\tset<int> st3;\n\t\t\tfor(auto s:st2){\n\t\t\t\t//cout << static_cast<bitset<24>>(s) << endl;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\t\tif(c[i]==c[j]){\n\t\t\t\t\t\t\tif((s&(1<<i))&&(s&(1<<j))){\n\t\t\t\t\t\t\t\tbool fl =1;\n\t\t\t\t\t\t\t\tfor(int p=0;p<i;p++){\n\t\t\t\t\t\t\t\t\tif(lap[p][i]==1&&s&(1<<p))fl = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int p=0;p<j;p++){\n\t\t\t\t\t\t\t\t\tif(lap[p][j]==1&&s&(1<<p))fl = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(fl){\n\t\t\t\t\t\t\t\t\tst.insert(s-(1<<i)-(1<<j));\n\t\t\t\t\t\t\t\t\tst3.insert(s-(1<<i)-(1<<j));\n\t\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tst2 = st3;\n\t\t\tif(flag)break;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(auto s:st){\n\t\t\tint c = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(s&(1<<i)){\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans,n-c);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nchar dp[1 << 24];\nvector<int> v[25];\nint xx(int x) { return x * x; }\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tint r[24], x[24], y[24], c[24];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\n\t\tbool f[24][24] = {0}; // f[a][b]: a??????b????????????????????????\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\tif (xx(x[i]-x[j]) + xx(y[i]-y[j]) < xx(r[i]+r[j])) {\n\t\t\t\t\tf[j][i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 25; ++i) v[i].clear();\n\t\tfor (int i = 0; i < (1 << N); ++i) {\n\t\t\tv[__builtin_popcount(i)].push_back(i);\n\t\t}\n\n\t\tvector<int> ue(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint b = 0;\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (f[i][j]) b |= (1 << j);\n\t\t\t}\n\t\t\tue[i] = b;\n\t\t}\n\n\t\tfill(&dp[0], &dp[0]+(1<<24), 0);\n\t\tfor (int t = N%2; t <= N; t += 2) {\n\t\t\tfor (int l = 0; l < v[t].size(); ++l) {\n\t\t\t\tint k = v[t][l];\n\t\t\t\tvector<int> w;\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tif ( (k & (1 << i)) && (k & ue[i]) == 0 ) w.push_back(i);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < w.size(); ++i) {\n\t\t\t\t\tfor (int j = i+1; j < w.size(); ++j) {\n\t\t\t\t\t\tif (c[w[i]] == c[w[j]]) {\n\t\t\t\t\t\t\tdp[k] = max<short>(dp[k], dp[k ^ (1 << w[i]) ^ (1 << w[j])]+2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (int)dp[(1 << N)-1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint N;\nint x[32], y[32], r[32], c[32];\nchar dp[1<<24];\n\nint C(int u, int v){\n  return (SQ(x[u]-x[v])+SQ(y[u]-y[v])) >= SQ(r[u]+r[v]);\n}\n\nchar dfs(int bit){\n  char &res = dp[bit];\n  if(res >= 0) return res;\n  res = 0;\n  vector<int>v;\n  for(int i=0;i<N;i++){\n    if(!((bit>>i)&1)) continue;\n    int f = 1;\n    for(int j=0;j<i;j++) if((bit>>j)&1) f &= C(i, j);\n    if(f) v.push_back(i);\n  }\n\n  rep(i, v.size()) for(int j=i+1;j<v.size();j++){\n    if(c[v[i]] == c[v[j]]) res = max(res, (char)(dfs(bit ^ (1<<v[i]) ^ (1<<v[j]))+2));\n  }\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d\", &N) && N){\n    memset(dp, -1, sizeof(dp));\n    rep(i,N) scanf(\"%d%d%d%d\", x+i, y+i,r+i,c+i);\n    printf(\"%d\\n\", dfs((1<<N)-1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int MAXN = 30;\nint x[MAXN], y[MAXN], r[MAXN], c[MAXN];\nbool ok[MAXN];\nmap<int, int> dp;\n\nint square(int x) {return x*x;}\n\n// i, j が重なってるかを調べる\n// 重なってたら true\nbool check(int i, int j) {\n    int d2 = square(x[i]-x[j]) + square(y[i]-y[j]);\n    return d2 < square(r[i]+r[j]);\n}\n\nint dfs(int state, int n) {\n    int ret = 0;\n    if (dp.find(state) != dp.end()) return dp[state];\n    // まだ存在するやつで一番上にあるのを列挙\n    vector<int> already;\n    memset(ok, true, sizeof(ok));\n    for (int i = 0; i < n; i++) {\n        if ((state>>i)&1) continue;\n        if (ok[i]) {\n            already.push_back(i);\n        }\n        for (int j = i+1; j < n; j++) {\n            if (check(i, j)) ok[j] = false;\n        }\n    }\n    int sz = already.size();\n    for (int i = 0; i < sz; i++) {\n        for (int j = i+1; j < sz; j++) {\n            int ai = already[i], aj = already[j];\n            if (c[ai] == c[aj]) {\n                int nstate = state;\n                nstate |= 1<<ai;\n                nstate |= 1<<aj;\n                ret = max(2+dfs(nstate, n), ret);\n            }\n        }\n    }\n    return dp[state] = ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while (cin >> n) {\n        if (n==0) break;\n        for (int i = 0; i < n; i++) cin >> x[i] >> y[i] >> r[i] >> c[i];\n        dp.clear();\n        cout << dfs(0, n) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define X first.first\n#define Y first.second\n#define R second.first\n#define C second.second\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint n, res;\nvector< pair<pii, pii> > discs(n);\nvvi isConf;\n\nvoid dfs(vi used, int pos, int cnt){\n    if(n <= pos){\n        res = max(res, cnt);\n        return;\n    }\n\n    dfs(used, pos + 1, cnt);\n\n    if(used[pos]) return;\n    rep(i, pos) if(isConf[pos][i]) return;\n\n    used[pos] = true;\n    rep(i, n){\n        if(used[i] || discs[pos].C != discs[i].C ||\n           isConf[pos][i]) continue;\n\n        bool ok = true;\n        rep(j, i){\n            if(used[j]) continue;\n            if(isConf[i][j]){\n                ok = false;\n            }\n        }\n\n        if(ok){\n            used[i] = true;\n            dfs(used, pos + 1, cnt + 2);\n            used[i] = false;\n        }\n    }\n}\n\nint main(void){\n    for(; cin >> n, n; cout << res << endl){\n        res = 0;\n\n        discs = vector< pair<pii, pii> >(n);\n        rep(i, n) cin >> discs[i].X >> discs[i].Y >>\n                         discs[i].R >> discs[i].C;\n    \n        isConf = vvi(n, vi(n));\n\n        //衝突判定\n        rep(i, n){\n            rep(j, n){\n                if(sqr(discs[i].X - discs[j].X) + sqr(discs[i].Y - discs[j].Y) < sqr(discs[i].R + discs[j].R)){\n                    isConf[i][j] = true;\n                }\n            }\n        }\n\n        vi used(n);\n        dfs(used, 0, 0);\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint ans,now,n,x[100],y[100],c[100],r[100];\nint bo[100];\nint chonghe[100][100];\nbool judge(int p){\n  for (int i=1;i<p;i++)\n    if (bo[i] && chonghe[i][p]) return false;\n  return true;\n}\nvoid try1(int k){\n  if (k>n)\n  {\n    if (now>ans) ans=now;\n  } else\n  {\n  if (bo[k] && judge(k))\n\t{\n      for (int i=k+1;i<=n;i++)\n\t    if (bo[i] && c[i]==c[k] && judge(i))\n\t    {bo[i]=false;bo[k]=false;now+=2;try1(k+1);now-=2;bo[i]=true;bo[k]=true;}\n\t}\t\n    try1(k+1);\n  }\n}\nint main(){\n  scanf(\"%d\",&n);\n  while (n!=0){\n    for (int i=1;i<=90;i++) bo[i]=true;\n\tans=0;now=0;\n    for (int i=1;i<=n;i++) scanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n\t for (int i=1;i<=n;i++)\n\t  for (int j=1;j<=n;j++)\n\t   if ((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])<(r[i]+r[j])*(r[i]+r[j]))\n\t   chonghe[i][j]=true; else chonghe[i][j]=false;\n\t/*for (int i=1;i<=n;i++)\n\t{  for (int j=1;j<=n;j++)\n\t   printf(\"%d\",chonghe[i][j]);\n\t  printf(\"\\n\");\n\t}*/\n\ttry1(1);\n    printf(\"%d\\n\",ans);\n    scanf(\"%d\",&n);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define repn(i, m, n) for (int i = m; i < int(n); ++i)\n\nchar mem[1<<24];\nint a[4], x[4][6], y[4][6], r[4][6];\nint over[4][6];\n\nint f(int bit) {\n  if (mem[bit] != -1) return mem[bit];\n  //cout << bit << endl;\n  int res = 0;\n  rep (i, 4) {\n    rep (j, a[i]) {\n      int bit1 = 1 << (i * 6 + j);\n      //cout << i << \" \" << j << \" \" << over[i][j] << endl;\n      if (bit & over[i][j] || !(bit & bit1)) continue;\n      repn (k, j + 1, a[i]) {\n\tint bit2 = 1 << (i * 6 + k);\n\t//cout << bit << \" \" << bit1 << \" \" << bit2 << endl;\n\tif (bit & over[i][k] || !(bit & bit2)) continue;\n\tres = max(res, f(bit ^ bit1 ^ bit2) + 2);\n      }\n    }\n  }\n  return mem[bit] = res;\n}\n\nint main() {\n  int n;\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n    memset(a, 0, sizeof(a));\n    memset(mem, -1, sizeof(mem));\n    memset(over, 0, sizeof(over));\n    rep (i, n) {\n      int xx, yy, rr, cc;\n      cin >> xx >> yy >> rr >> cc;\n      --cc;\n      x[cc][a[cc]] = xx;\n      y[cc][a[cc]] = yy;\n      r[cc][a[cc]] = rr;\n      rep (i, 4) rep (j, a[i]) {\n\tif ((x[i][j] - xx) * (x[i][j] - xx) + (y[i][j] - yy) * (y[i][j] - yy) >= (r[i][j] + rr) * (r[i][j] + rr)) continue;\n\tover[cc][a[cc]] |= 1 << (i * 6 + j);\n      }\n      //cout << cc << \" \" << a[cc] << \" \" << over[cc][a[cc]] << endl;\n      ++a[cc];\n    }\n    int bit = (1 << a[0]) - 1;\n    bit |= (1 << 6 << a[1]) - (1 << 6);\n    bit |= (1 << 12 << a[2]) - (1 << 12);\n    bit |= (1 << 18 << a[3]) - (1 << 18);\n    cout << f(bit) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define mp make_pair\n#define pb push_back\n#define EB emplace_back\n#define fi first\n#define se second\n#define all(v) ALL(v)\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\nconstexpr double eps = 1e-14; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint N;\nvector<int> x,y,r,c;\n\nint dfs(vector<bool> &u){\n    //cout << u << endl;\n    int ret = 0;\n    for(int i=0;i<N;i++) for(int j=i+1;j<N;j++) if(c[i]==c[j]){\n        if(!u[i] or !u[j]) continue;\n        //bool ch=false;\n        //if(i==1 and j==3) ch = true;\n        bool oki=true;\n        for(int k=i-1;k>-1;k--){\n            if(!u[k]) continue;\n            double d=sqrt((x[i]-x[k])*(x[i]-x[k])+(y[i]-y[k])*(y[i]-y[k]));\n            //if(ch){\n            //    cout << \"ri + rk : \" << r[i]+r[k] << endl;\n            //    cout << \"d : \" << d << endl;\n            //}\n            if(!(r[i]+r[k]<=d)){\n                oki=false;\n                break;\n            }\n        }\n        if(oki==false) continue;\n        bool okj=true;\n        for(int k=j-1;k>-1;k--){\n            if(!u[k]) continue;\n            double d=sqrt((x[j]-x[k])*(x[j]-x[k])+(y[j]-y[k])*(y[j]-y[k]));\n            //if(ch){\n            //    cout << \"k : \" << k << endl;\n            //    cout << \"rj + rk : \" << r[j]+r[k] << endl;\n            //    cout << \"d : \" << d << endl;\n            //}\n            if(!(r[j]+r[k]<=d)){\n                okj=false;\n                break;\n            }\n        }\n        if(okj==false) continue;\n\n        //auto t = u;\n        u[i] = false;\n        u[j] = false;\n        int x = dfs(u);\n        u[i] = true;\n        u[j] = true;\n        ret = max(ret,x+2);\n    }\n\n    return ret;\n}\n\n\nvoid solve(){\n    x.assign(N,0);\n    y.assign(N,0);\n    r.assign(N,0);\n    c.assign(N,0);\n    rep(i,N){\n        cin >> x[i] >> y[i] >> r[i] >> c[i];\n        c[i]--;\n    }\n\n    vector<bool> u(N,true);\n    cout << dfs(u) << endl;\n}\n\nint main(){\n    while(cin>>N){\n        if(N==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\nconst double EPS = 1e-8;\n\ndouble dist(double x1, double y1, double x2, double y2){\n    return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));\n}\nbool f[30][30];\nbool d[1 << 25];\n\nint bitnum(int n){\n    int res = 0;\n    while(n > 0){\n        if(n % 2 == 1) res++;\n        n /= 2;\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        rep(i, 0, 1 << n) d[i] = false;\n        vector<double> x(n), y(n), r(n);\n        vector<int> c(n);\n        rep(i, 0, n){\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n        }\n        rep(i, 0, n){\n            rep(j, i + 1, n){\n                f[i][j] = false;\n                double tmp = dist(x[i], y[i], x[j], y[j]);\n                if(tmp < r[i] + r[j] - EPS){\n                    f[i][j] = true;\n                }\n            }\n        }\n        d[0] = true;\n        for(int mask = 0; mask < (1 << n); mask++){\n            if(!d[mask]) continue;\n            rep(i, 0, n){\n                if(mask & (1 << i)) continue;\n                bool cani = true;\n                rep(j, 0, n){\n                    if(mask & (1 << j)) continue;\n                    if(f[j][i]){\n                        cani = false;\n                        break;\n                    }\n                }\n                if(!cani) continue;\n                rep(j, i + 1, n){\n                    if(mask & (1 << j)) continue;\n                    if(c[i] != c[j]) continue;\n                    bool canj = true;\n                    rep(k, 0, n){\n                        if(mask & (1 << k)) continue;\n                        if(f[k][j]){\n                            canj = false;\n                            break;\n                        }\n                    }\n                    if(canj){\n                        d[mask | (1 << i) | (1 << j)] = true;\n                    }\n                }\n            }\n        }\n        int ans = 0;\n        rep(i, 0, 1 << n){\n            if(!d[i]) continue;\n            int tmp = bitnum(i);\n            ans = max(ans, tmp);\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\nint n;\nvector<char> dp, up;\nvector<Circle> c;\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = (a.r + b.r) * (a.r + b.r);\n    int d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    return r > d;\n}\n\nchar Rec(char s)\n{\n    if (dp[s] != -1)\n        return dp[s];\n\n    int res = 0;\n    // 取り除く2つの円の選択\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            // c[i]とc[j]の色が異なる\n            if (c[i].c != c[j].c)\n                continue;\n            // c[j]がないか取り除けない\n            if (!(s >> j & 1) || s & up[j])\n                continue;\n            // c[i]がないか取り除けない\n            if (!(s >> i & 1) || s & up[i])\n                continue;\n\n\n            int nxt = s & ~(1 << i) & ~(1 << j);\n            res = max(res, (int)Rec(nxt) + 2);\n        }\n    }\n\n    return dp[s] = res;\n}\n\nint main()\n{\n    while (cin >> n, n) {\n        dp.assign(1 << n, -1);\n        up.assign(n, 0);\n        c.resize(n);\n\n        // 円の入力\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        // 円の重なり，上下関係\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                if (isOverlap(c[i], c[j]))\n                    up[j] |= (1 << i);\n\n        cout << (int)Rec((1 << n) - 1) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cinttypes>\n\nusing namespace std;\n\nint n;\nvector<int16_t> x, y, r, c;\nint8_t memo[1 << 24];\n\nint rec(int bits) {\n  int ret = 0;\n\n  vector<bool> tops(n, true);\n  for (int i = 0; i < n; i++) {\n    if (bits & (1 << i)) {\n      continue;\n    }\n    for (int j = i + 1; j < n; j++) {\n      if (bits & (1 << j)) {\n        continue;\n      }\n      int distance2 = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n      if (distance2 < (r[i] + r[j]) * (r[i] + r[j])) {\n        tops[j] = false;\n      }\n    }\n  }\n\n  for (int i = 0; i < n; i++) {\n    if (bits & (1 << i)) {\n      continue;\n    }\n    if (!tops[i]) {\n      continue;\n    }\n    for (int j = i + 1; j < n; j++) {\n      if (bits & (1 << j)) {\n        continue;\n      }\n      if (!tops[j]) {\n        continue;\n      }\n      if (c[i] != c[j]) {\n        continue;\n      }\n      int r = 1 + rec(bits | (1 << i) | (1 << j));\n      if (r > ret) {\n        ret = r;\n      }\n    }\n  }\n\n  return ret;\n}\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n    x.resize(n);\n    y.resize(n);\n    r.resize(n);\n\n    c.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n\n    cout << 2 * rec(0) << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\nusing namespace std;\n\nstruct object{\n// 各円を示す構造体\n\tint id;\n\tint posx;\n\tint posy;\n\tint rad;\n\tint color;\n\tlist<int> parent;\n\n\tbool operator==(object tgt){\n\t\treturn id==tgt.id;\n\t}\n};\n\nvoid checkcontact(object& upper,object& lower){\n//　2つの円の重なりを調べ、下の円に自分の上にある円のidを記録\n\tif((upper.posx-lower.posx)*(upper.posx-lower.posx)+(upper.posy-lower.posy)*(upper.posy-lower.posy)<(upper.rad+lower.rad)*(upper.rad+lower.rad)){\n\t\tlower.parent.push_back(upper.id);\n\t}\n}\n\n\nlist<object>::iterator nexttop(list<object>::iterator itcur,list<object>::iterator& itl){\n// 現在iteratorと末端iteratorから、次の回収可能円を示すiterator又は末端iteratorを返却\n\tdo{\n\t\t++itcur;\n\t\tif(itcur==itl)return itcur;\n\t}while(!(*itcur).parent.empty());\n\treturn itcur;\n}\n\n\nunsigned int cal(list<object>& base){\n\tlist<object> cop;\n\tlist<object>::iterator ita,itb,itc,itl;\n\tunsigned int submax=-1,subret;\n\titl=base.end();\n\tfor(ita=base.begin();ita!=itl;ita=nexttop(ita,itl)){\n\t\tfor(itb=nexttop(ita,itl);itb!=itl;itb=nexttop(itb,itl)){\n\t\t\tif((*itb).color==(*ita).color){\n\t\t\t\tcop=base;\n\t\t\t\tcop.remove(*ita);\n\t\t\t\tcop.remove(*itb);\n\t\t\t\tfor(itc=cop.begin();itc!=cop.end();++itc){\n\t\t\t\t\t(*itc).parent.remove((*ita).id);\n\t\t\t\t\t(*itc).parent.remove((*itb).id);\n\t\t\t\t}\n\t\t\t\tsubret=cal(cop);\n\t\t\t\tif(subret<submax)submax=subret;\n\t\t\t}\n\t\t}\n\t}\n\tsubret=base.size();\n\tif(subret<submax)submax=subret;\n\treturn submax;\n}\nint main(){\n\tint n;\n\tobject tmp; \n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tlist<object> objects;\n\t\tlist<object>::iterator ita,itl;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp.id=i;\n\t\t\tcin>>tmp.posx>>tmp.posy>>tmp.rad>>tmp.color;\n\t\t\ttmp.parent.clear();\n\t\t\titl=objects.end();\n\t\t\tfor(ita=objects.begin();ita!=itl;++ita)checkcontact(*ita,tmp);\n\t\t\tobjects.push_back(tmp);\n\t\t}\n\t\tcout<<n-cal(objects)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Circle {\n    int x;\n    int y;\n    int r;\n    int c;\n};\n\nbool overwrap(const Circle& c1, const Circle& c2)\n{\n    const int d = c1.r + c2.r;\n    const int R = (c1.x - c2.x) * (c1.x - c2.x) + (c1.y - c2.y) * (c1.y - c2.y);\n    return d * d > R;\n}\n\nint n;\nint dp(map<int, int>& table, const vector<vector<bool>>& wrap, const int state, const vector<Circle>& circle)\n{\n    if (table.find(state) != table.end()) {\n        return table[state];\n    } else {\n        vector<int> sub(4, 0);\n        vector<vector<int>> top(4, vector<int>(0));\n        for (int j = 0; j < n; j++) {\n            if (state & (1 << j)) {\n                bool ok = true;\n                for (int i = 0; i < j; i++) {\n                    if (state & (1 << i)) {\n                        if (wrap[i][j]) {\n                            ok = false;\n                            break;\n                        }\n                    }\n                }\n                if (ok) {\n                    sub[circle[j].c] += (1 << j);\n                    top[circle[j].c].push_back(j);\n                }\n            }\n        }\n        int maxi = 0;\n        for (int i = 0; i < 4; i++) {\n            const int size = top[i].size();\n            if (size <= 1) {\n                continue;\n            }\n\n            for (int j = 0; j < size; j++) {\n                for (int k = j + 1; k < size; k++) {\n                    const int val = dp(table, wrap, state - (1 << top[i][j]) - (1 << top[i][k]), circle);\n                    maxi = max(maxi, val + 2);\n                }\n            }\n\n            // if (size % 2 == 0) {\n            //     const int val = dp(table, wrap, state - sub[i], circle);\n            //     maxi = max(maxi, val + size);\n            // } else {\n            //     int maxi = 0;\n            //     for (int j = 0; j < size; j++) {\n            //         const int val = dp(table, wrap, state - sub[i] + (1 << top[i][j]), circle);\n            //         maxi = max(maxi, val + (size / 2 * 2));\n            //     }\n            // }\n        }\n        table[state] = maxi;\n        return maxi;\n    }\n}\n\nint main()\n{\n    while (true) {\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        vector<Circle> circle(n);\n        for (int i = 0; i < n; i++) {\n            int x, y, r;\n            int c;\n            cin >> x >> y >> r >> c;\n            c--;\n            circle[i] = Circle{x, y, r, c};\n        }\n\n        vector<vector<bool>> wrap(n, vector<bool>(n, false));  // j?????????i?????????\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                wrap[i][j] = overwrap(circle[i], circle[j]);\n            }\n        }\n\n        const int maximum = 1 << n;\n        map<int, int> table;\n        table[0] = 0;\n        cout << dp(table, wrap, maximum - 1, circle) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n\nint pow2(int m){\n\treturn m * m;\n};\n\n\nint main(void){\n\tint i, j, k, l, m, n, f, x[24], y[24], r[24], c[24], t, ans;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n\t\tans = 0;\n\t\twhile(1){\n\t\t\tf = 0;\n\t\t\tfor(i = 1;i <= 4;i++){\n\t\t\t\tfor(j = 0;j < n - 1;j++){\n\t\t\t\t\tif(c[j] == i){\n\t\t\t\t\t\tfor(k = j + 1;k < n;k++){\n\t\t\t\t\t\t\tif(c[k] == i){\n\t\t\t\t\t\t\t\tfor(l = 0;l < j;l++){\n\t\t\t\t\t\t\t\t\tif(sqrt((double)(pow2(x[l] - x[j]) + pow2(y[l] - y[j]))) < r[l] + r[j])\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(m = 0;m < k;m++){\n\t\t\t\t\t\t\t\t\tif(sqrt((double)(pow2(x[m] - x[k]) + pow2(y[m] - y[k]))) < r[m] + r[k])\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(l == j && m == k){\n\t\t\t\t\t\t\t\t\tans+=2;\n\t\t\t\t\t\t\t\t\tf = 1;\n\t\t\t\t\t\t\t\t\tfor(m = 0;m < 2;m++){\n\t\t\t\t\t\t\t\t\t\tif(m == 0)\n\t\t\t\t\t\t\t\t\t\t\tt = k;\n\t\t\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t\t\t\tt = j;\n\t\t\t\t\t\t\t\t\t\tfor(l = t;l < n - 1;l++){\n\t\t\t\t\t\t\t\t\t\t\tx[l] = x[l + 1];\n\t\t\t\t\t\t\t\t\t\t\ty[l] = y[l + 1];\n\t\t\t\t\t\t\t\t\t\t\tr[l] = r[l + 1];\n\t\t\t\t\t\t\t\t\t\t\tc[l] = c[l + 1];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!f)\n\t\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\ntypedef pair < int , int > Pt;\nbool dp[1 << 24];\nPt pts[24];\nint n, r[24], c[24];\nint hoge[24];\nconst int INF = 1 << 28;\nbool intersect( Pt a, Pt b, int r1, int r2){\n  return pow( a.first - b.first, 2) + pow( a.second - b.second, 2) < pow( r1 + r2, 2);\n}\n\nint isnocover( const int& bit, const int& idx ){\n  for(int i = 0 ; i < idx ; i++ ){\n    if( (bit >> i) & 1 && (hoge[idx] >> i) & 1) return false;\n  }\n  return true;\n}\n\nint rec( int bit){\n  if(dp[bit]++) return -INF;\n  int ret = 0;\n  for(int i = 0 ; i < n ; i++ ){\n    if((bit >> i) & 1){\n      for(int j = i + 1 ; j < n ; j++ ){\n        if( (bit >> j) & 1 && c[i] == c[j] && isnocover( bit, i) && isnocover( bit, j)){\n          ret = max( ret, rec( bit & ~(1 << i) & ~(1 << j)) + 2);\n        }\n      }\n    }\n  }\n  return ret;\n}\nint main()\n{\n  while(cin >> n, n){\n    fill_n( dp, 1 << 24 , false);\n    fill_n( hoge, 24 , 0);\n\n    for(int i = 0 ; i < n ; i++ ){\n      cin >> pts[i].first >> pts[i].second >> r[i] >> c[i];\n      for(int j = 0 ; j < i ; j++ ){\n        if(intersect(pts[i],pts[j],r[i],r[j])) hoge[i] |= 1 << j;\n      }\n    }\n    cout << rec((1 << n) - 1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint n;\nint x[24],y[24],r[24],c[24];\n\ninline bool intersect(int p, int q)\n{\n    double dist=sqrt((x[p]-x[q])*(x[p]-x[q])+(y[p]-y[q])*(y[p]-y[q]));\n    return dist<(r[p]+r[q]);\n}\n\nint dp[1<<24];\nint dfs(int state)\n{\n    if(dp[state]>=0) return dp[state];\n    if(__builtin_popcount(state)<2) return 0;\n\n    int ret=0;\n    rep(i,n)\n    {\n        if(state>>i&1)\n        {\n            bool av=true;\n            rep(j,i)\n            {\n                if(state>>j&1 && intersect(i,j))\n                {\n                    av=false;\n                    break;\n                }\n            }\n\n            if(!av) continue;\n\n            rep(j,n)\n            {\n                if(i==j) continue;\n                if(c[i]!=c[j]) continue;\n\n                if(state>>j&1)\n                {\n                    bool av2=true;\n                    rep(k,j)\n                    {\n                        if(state>>k&1 && intersect(j,k))\n                        {\n                            av2=false;\n                            break;\n                        }\n                    }\n\n                    if(!av2) continue;\n\n                    ret = max(ret,dfs(state-(1<<i)-(1<<j))+2);\n                }\n            }\n        }\n    }\n\n    return dp[state]=ret;\n}\n\nint main()\n{\n    while(cin >>n,n)\n    {\n        rep(i,n) scanf(\" %d %d %d %d\", &x[i], &y[i], &r[i], &c[i]);\n        memset(dp,-1,sizeof(dp));\n        cout << dfs((1<<n)-1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\n\n#define all(c) ((c).begin()), ((c).end())\n#define debug(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\n\nconst double EPS = 1e-10;\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\n\nstruct C{\n\tP p;\n\tint r;\n\tint c;\n};\n\nmap<int, int> dp;\nint n;\nvector<C> cs;\n\nint next_combination(int p){\n    int lsb = p&-p;\n    int rem = p+lsb;\n    int rit = rem&~p;\n    return rem|(((rit/lsb)>>1)-1);\n}\n\nint go(int mask) {\n\tif(present(dp, mask)) return dp[mask];\n\tint res = 0;\n\tint bn = __builtin_popcount(mask);\n\tbn -= 2;\n\tif(bn < 0) return 0;\n\tfor(int next = (1 << bn) - 1; next < (1 << n); next = next_combination(next)) {\n\t\tif((mask | next) != mask) continue;\n\t\tint use = mask ^ next;\n\t\tint i = __builtin_ctz(use);\n\t\tint j = __builtin_ctz(use >> (i + 1)) + i + 1;\n\t\tif(cs[i].c != cs[j].c) continue;\n\t\tbool ok = true;\n\t\trep(k, i) if(mask & (1 << k)) if (cs[i].r + cs[k].r > abs(cs[i].p - cs[k].p)) ok = false;\n\t\trep(k, j) if(mask & (1 << k)) if (cs[j].r + cs[k].r > abs(cs[j].p - cs[k].p)) ok = false;\n\t\tif(!ok) {\n\t\t\tif(next) continue;\n\t\t\telse break;\n\t\t}\n\t\tres = max(res, go(next) + 2);\n\t}\n\treturn dp[mask] = res;\n}\n\nint main() {\n\tfor (; cin >> n, n != 0; ) {\n\t\tcs.clear();\n\t\trep (i, n) {\n\t\t\tC c; int x, y; cin >> x >> y >> c.r >> c.c;\n\t\t\tc.p = P(x, y);\n\t\t\tcs.pb(c);\n\t\t}\n\t\tdp.clear();\n\t\tcout << go((1 << n) -1) << endl;;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#define N 10000007\nusing namespace std;\nint t[N];\nint n,x[24],y[24],r[24],c[24];\nint dist(int a,int b){return (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);}\n\n\nint hash2(int x){\n  return 1 + x%(N-1);\n}\n  \ninline int hash1(int x){\n  return x%N;\n}\n  \nint find(int x){\n  int y=hash2(x);\n  int i=hash1(x);\n  while(1){\n    if(t[i]==-1)return -1;\n    else if(t[i]==x)return t[i];\n    i=hash1(i+y);\n  }\n}\n  \nvoid insert(int x,int value){\n  int y=hash2(x);\n  int i=x%N;\n  while(1){\n    if(t[i]==x)return;\n    if(t[i]==-1){\n      t[i]=value;\n      return;\n    }\n    i=(i+y)%N;\n  }\n}\n\nint rec(int S){\n  int e=find(S);\n  if(e!=-1)return e;\n\n  int res=0;\n  bool f[n];\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    f[i]=true;\n    for(int j=i-1;j>=0;j--){\n      if((S>>j)&1)continue;\n      if(dist(i,j)>=(r[i]+r[j])*(r[i]+r[j]))continue;\n      f[i]=false;\n    }\n  }\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    if(!f[i])continue;\n    for(int j=i+1;j<n;j++){\n      if((S>>j)&1)continue;\n      if(!f[j])continue;\n      if(c[i]!=c[j])continue;\n      res=max(res,2+rec(S+(1<<i)+(1<<j)));\n    }\n  }\n  insert(S,res);\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<N;i++)t[i]=-1;\n\n    for(int i=0;i<n;i++)\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n    cout<<rec(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n\nlong long  mod = 1000000007;\n\n\nbool lap[30][30];\n\n\nbool overlap(int i,int j,vector<int> &x,vector<int>&y,vector<int> &r){\n\tint k = 0;\n\tk = (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]);\n\tif(k>= (r[i]+r[j])*(r[i]+r[j]))return 0;\n\treturn 1;\n}\n\n\nint main(){\n\tint n;\n\twhile(cin >> n && n!=0){\n\t\tset<int>st,st2;\n\t\tvector<int>x(n),y(n),r(n),c(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tfor(int i=0;i<30;i++){\n\t\t\tfor(int j=0;j<30;j++){\n\t\t\t\tlap[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(overlap(i,j,x,y,r)==1){\n\t\t\t\t\tlap[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tbool flag = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\tif(lap[i][j]==0){\n\t\t\t\t\t\tfor(int k=i+1;k<j;k++){\n\t\t\t\t\t\t\tif(lap[i][k]&&lap[k][j]){\n\t\t\t\t\t\t\t\tlap[i][j]=1;\n\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)break;\n\t\t}\n\t\t/*for(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tcout << i <<  \" \" << j << \" \" << lap[i][j] << endl;\n\t\t\t}\n\t\t}*/\n\n\t\tst.insert((1<<n)-1);\n\t\tst2.insert((1<<n)-1);\n\t\twhile(1){\n\t\t\tbool flag = 1;\n\t\t\tset<int> st3;\n\t\t\tfor(auto s:st2){\n\t\t\t\tcout << static_cast<bitset<24>>(s) << endl;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\t\t\tif(st.count(s-(1<<i)-(1<<j))==1)continue;\n\t\t\t\t\t\tif(c[i]==c[j]){\n\t\t\t\t\t\t\tif((s&(1<<i))&&(s&(1<<j))){\n\t\t\t\t\t\t\t\tbool fl =1;\n\t\t\t\t\t\t\t\tfor(int p=0;p<i;p++){\n\t\t\t\t\t\t\t\t\tif(lap[p][i]==1&&(s&(1<<p)))fl = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(int p=0;p<j;p++){\n\t\t\t\t\t\t\t\t\tif(lap[p][j]==1&&(s&(1<<p)))fl = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(fl){\n\t\t\t\t\t\t\t\t\tst.insert(s-(1<<i)-(1<<j));\n\t\t\t\t\t\t\t\t\tst3.insert(s-(1<<i)-(1<<j));\n\t\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tst2 = st3;\n\t\t\tif(flag)break;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(auto s:st){\n\t\t\tint c = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(s&(1<<i)){\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = max(ans,n-c);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\n\n#define all(c) ((c).begin()), ((c).end())\n#define debug(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\n\nconst double EPS = 1e-10;\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\n\nstruct C{\n\tP p;\n\tint r;\n\tint c;\n};\n\n\nint dp[1 << 24];\nint main(){\n\tfor (int n; cin >> n, n != 0; ) {\n\t\tvector<C> cs;\n\t\trep (i, n) {\n\t\t\tC c; int x, y; cin >> x >> y >> c.r >> c.c;\n\t\t\tc.p = P(x, y);\n\t\t\tcs.pb(c);\n\t\t}\n\t\t\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor (int mask = 0; mask < (1 << n); mask++) {\n\t\t\tint res = 0;\n\t\t\trep (i, n) if (mask & (1 << i)) REP (j, i + 1, n - 1) if (mask & (1 << j)) {\n\t\t\t\tif(cs[i].c != cs[j].c) continue;\n\t\t\t\tbool ok = true;\n\t\t\t\trep(k, i) if(mask & (1 << k)) if (cs[i].r + cs[k].r > abs(cs[i].p - cs[k].p)) ok = false;\n\t\t\t\trep(k, j) if(mask & (1 << k)) if (cs[j].r + cs[k].r > abs(cs[j].p - cs[k].p)) ok = false;\n\t\t\t\tif(!ok) continue;\n\t\t\t\tres = max(res, dp[mask ^ (1 << i) ^ (1 << j)] + 2);\n\t\t\t}\n\t\t\tdp[mask] = res;\n\t\t}\n\t\tcout << dp[(1 << n) - 1] << endl;;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <deque>\n#include <vector>\n#include <numeric>\n#include <iterator>\n#include <array>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\n\n\n#define FF first\n#define SS second\n#define ALL(c) begin((c)), end((c))\n#define REP(i,n) for(ll i=0;i<(ll)n;++i)\ninline int getInt() { int s; scanf(\"%d\", &s); return s; }\n\nstruct circle{\n\tll id,x,y,r,c;\n\tbool operator==(const circle & o) {\n\t\treturn id==o.id;\n\t}\n};\n\n\n\nint main() {\n\n\tll n;\n\tcin >> n;\n\tvector<circle> g_table;\n\tREP(i, n){\n\t\tint x,y,r,c;\n\t\tcin >> x >> y >> r >> c;\n\t\tg_table.push_back(circle{i,x,y,r,c-1});\n\t}\n\twhile (true) {\n\t\tvector<circle> tops[4];\n\n\t\tREP(i, g_table.size()) {\n\t\t\tbool top = true;\n\t\t\tREP(j, g_table.size()) {\n\t\t\t\tll xx = g_table[i].x - g_table[j].x;\n\t\t\t\tll yy = g_table[i].y - g_table[j].y;\n\t\t\t\tll rr = g_table[i].r + g_table[j].r;\n\t\t\t\tif (xx*xx + yy*yy < rr*rr && i>j) {\n\t\t\t\t\ttop = false; break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (top) tops[g_table[i].c].push_back(g_table[i]);\n\t\t}\n\n\t\tbool done = false;\n\t\tREP(c, 4) while (tops[c].size() >= 2) {\n\t\t\tdone = true;\n\t\t\tg_table.erase(remove(ALL(g_table), tops[c].back()), g_table.end());\n\t\t\ttops[c].pop_back();\n\t\t\tg_table.erase(remove(ALL(g_table), tops[c].back()), g_table.end());\n\t\t\ttops[c].pop_back();\n\t\t}\n\n\t\tif (!done) break;\n\t}\n\n\tcout << n - g_table.size() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstruct Disk{\n\tdouble x, y, r;\n\tint c, id;\n}disk[30];\nvector<Disk> colors[6];\nchar dp[1<<24];\ndouble dis[25][25];\nbool iscover(int a, int b){\n\tdouble r = (disk[a].r+disk[b].r)*(disk[a].r+disk[b].r);\n\tif(dis[a][b] < r){\n\t\treturn true;\n\t}\n\treturn false;\n}\nbool ontop(int a, int state){\n\tfor(int i = 0; i < a; i++)\n\t\tif(!((state >> i) & 1) && iscover(i, a)){\n\t\t\treturn false;\n\t\t}\n\treturn true;\n}\nbool pairable(int a, int b, int state){\n\tif(!iscover(a, b) && ontop(a, state) && ontop(b, state))\n\t\treturn true;\n\treturn false;\n}\nint main(){\n\tint n;\n\twhile(scanf(\"%d\", &n), n){\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor(int i = 1; i <= 4; i++)\n\t\t\tcolors[i].clear();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%lf%lf%lf%d\", &disk[i].x, &disk[i].y, &disk[i].r, &disk[i].c);\n\t\t\tdisk[i].id = i;\n\t\t\tcolors[disk[i].c].push_back(disk[i]);\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\tdis[i][j] = (disk[i].x-disk[j].x)*(disk[i].x-disk[j].x)+(disk[i].y-disk[j].y)*(disk[i].y-disk[j].y);\n\t\tint M = 1 << n;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tif(i > 0 && !dp[i])\n\t\t\t\tcontinue;\n\t\t\tfor(int c = 1; c <= 4; c++){\n\t\t\t\tfor(int j = 0; j < colors[c].size(); j++){\n\t\t\t\t\tif((1<<colors[c][j].id)& i)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor(int k = j+1; k < colors[c].size(); k++){\n\t\t\t\t\t\t\tif((1<<colors[c][k].id) & i)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tif(pairable(colors[c][j].id, colors[c][k].id, i)){\n\t\t\t\t\t\t\t\tint nstate = i | (1<<colors[c][j].id) | (1<<colors[c][k].id);\n\t\t\t\t\t\t\t\tif(dp[nstate] < dp[i] + 2)\n\t\t\t\t\t\t\t\t\tdp[nstate] = dp[i]+2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < M; i++)\n\t\t\tif(ans < dp[i])\n\t\t\t\tans = dp[i];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n\nstruct Circle {\n\tint x, y, r, c;\n\tbool has_intersection(const Circle& that) const {\n\t\treturn (x - that.x) * (x - that.x) + (y - that.y) * (y - that.y) < (r + that.r) * (r + that.r);\n\t}\n};\nbool is_overwrapped(const std::vector<Circle>& circles, const int i, const int state) {\n\tbool has_overwrap = false;\n\tfor (auto j = 0; j < i && !has_overwrap; ++j) if ((state & (1 << j)) == 0) {\n\t\thas_overwrap = circles[i].has_intersection(circles[j]);\n\t}\n\treturn has_overwrap;\n}\nint max_removable(const std::vector<Circle>& circles, const int state, std::unordered_map<int, int>& memo) {\n\tif (memo.find(state) != memo.end()) return memo[state];\n\tint res = 0;\n\tfor (auto i = 0; i < circles.size(); ++i) if ((state & (1 << i)) == 0) {\n\t\tif (!is_overwrapped(circles, i, state)) {\n\t\t\tfor (auto j = 0; j < i; ++j) if ((state & (1 << j)) == 0 && circles[i].c == circles[j].c && !is_overwrapped(circles, j, state)) {\n\t\t\t\tres = std::max(res, max_removable(circles, state | (1 << i) | (1 << j), memo) + 2);\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[state] = res;\n}\nint main() {\n\twhile (true) {\n\t\tint n; std::cin >> n; if (n == 0) break;\n\t\tstd::vector<Circle> circles(n);\n\t\tfor (auto& c : circles) std::cin >> c.x >> c.y >> c.r >> c.c;\n\t\tstd::unordered_map<int, int> memo;\n\t\tstd::cout << max_removable(circles, 0, memo) << '\\n';\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nvector<double> x;\nvector<double> y;\nvector<double> r;\nvector<double> c;\nvector<int> dp;\n\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n\n    if (n == 0) {\n      break;\n    }\n\n    x.resize(n);\n    y.resize(n);\n    r.resize(n);\n    c.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n    }\n\n\n    int ans = 0;\n\n    \n    dp.resize(1 << n, 0);\n    \n    for (int i = 0; i < (1 << n); i++) {\n      int popcnt = 0;\n      for (int j = 0; j < n; j++) {\n        if (i & (1 << j)) {\n          popcnt++;\n        }\n      }\n      if (popcnt % 2 == 1) {\n        continue;\n      }\n      vector<bool> tops(n, true);\n      // テ」ツつづ」ツ?? jテ」ツ?ィkテ」ツ?古・ツ渉姪」ツつ古」ツつ凝」ツ?ェテ」ツつ?\n      for (int a = 0; a < n; a++) {\n        if (i & (1 << a)) {\n          tops[a] = false;\n          continue;\n        }\n        for (int b = a + 1; b < n; b++) {\n          if (i & (1 << b)) {\n            tops[b] = false;\n            continue;\n          }\n          // iテ」ツ?ョテ」ツ?サテ」ツ??」ツ?古「ツ??\n          double distance2 = pow(x[a] - x[b], 2) + pow(y[a] - y[b], 2);\n          if (distance2 < pow(r[a] + r[b], 2)) {\n            tops[b] = false;\n          }\n        }\n      }\n      for (int j = 0; j < n; j++) {\n        for (int k = j + 1; k < n; k++) {\n          if (c[j] == c[k]) {\n            if (tops[j] && tops[k]) {\n              // dp[i | (j, k) << c] = max(dp[i | (j, k) << c], dp[i] + 1);\n              int bit = i | (1 << j) | (1 << k);\n              dp[bit] = max(dp[bit], dp[i] + 1);\n              ans = max(ans, dp[bit]);\n            }\n          }\n        }\n      }\n    }\n    \n    cout << ans * 2 << endl;\n\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "int n; //枚数\nint x[25],y[25],r[25],c[25]; //円盤\nint b[25]; //各円盤の上に重なっている円盤（ビット管理）\n\n//円盤iと円盤jが重なっているかの判定\nbool intersects(int i,int j){\n  int dist1 = pow(x[i]-x[j],2) + pow(y[i]-y[j],2);\n  int dist2 = pow(r[i]+r[j],2);\n\n  return dist2 > dist1;\n}\n\n//DP用\nchar dp[1<<24];\n\nint main(void){\n  while(scanf(\"%d\",&n),n){\n    rep(i,n){\n      scanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n\n      //円盤iの上に重なっている円盤を全て探す\n      b[i] = 0;\n      rep(j,i) if(intersects(i,j)) b[i] |= (1<<j);\n    }\n\n    int ans = 0;\n    int to = (1<<n);\n    memset(dp,-1,sizeof(dp));\n    dp[0] = 0;\n\n    rep(i,to){\n      if(dp[i] == -1) continue;\n\n      ans = max(ans,(int)dp[i]);\n\n      //消せる円盤のペア(j,k)を探す\n      rep(j,n-1){\n        //すでに円盤jは消えている or 円盤jの上の円盤が邪魔して消せない\n        if((i & (1<<j)) != 0 || (i & b[j]) != b[j]) continue;\n\n        REP(k,j+1,n){\n          //jとkの色が違う or すでに円盤kは消えている or 円盤kの上の円盤が邪魔\n          if(c[j] != c[k] || (i & (1<<k)) != 0 || (i & b[k]) != b[k]) continue;\n\n          int next = i | (1<<j) | (1<<k); //next = 円盤jとkを消した状態(ビット管理)\n          dp[next] = max((int)dp[next],dp[i]+2);\n        }\n      }\n    }\n\n    printf(\"%d\\n\",ans);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//木を実装する\ntypedef struct _node{\n    int element;\n    struct _node *left;\n    struct _node *right;\n    struct _node *par;\n}node;\n\ntypedef struct _tree{\n    node *root;\n}tree;\n\n//リストを生成する関数\ntree *create(){\n    tree *T = (tree *)malloc(sizeof(tree));\n    T->root = (node *)malloc(sizeof(node));\n    T->root->left = NULL;\n    T->root->right = NULL;\n    T->root->par = NULL;\n    T->root->element = -1;\n    return T;\n}\n\nvoid make_tree(tree *T, string s){\n    node *ptr = T->root;\n\n    for(int i = 0; i < (int) s.size(); i++){\n\n        if(s[i] == '('){\n            //どっちかににノードを足す\n            node *add = (node *)malloc(sizeof(node));\n            add->element = -1;\n            add->left = NULL;\n            add->right = NULL;\n            add->par = ptr;\n\n            //左\n            if(ptr->left == NULL){\n                ptr->left = add;\n                ptr = add;\n            }else{\n                ptr->right = add;\n                ptr = add;\n            }\n        }else if(s[i] == ')'){\n            //戻る\n            ptr = ptr->par;\n        }else if(s[i] == '['){\n            string str;\n            int j;\n            for(j = i + 1; s[j] != ']'; j++) str.push_back(s[j]);\n            int num = stoi(str);\n            ptr->element = num;\n            i = j;\n        }\n    }\n}\n\nvoid print_tree(node *v){\n    if(v == NULL || v->element == -1){\n        cout << \")\";\n        return;\n    }\n\n    cout << \"(\";\n    print_tree(v->left);\n    cout << \"[\" << v->element << \"]\";\n    cout << \"(\";\n    print_tree(v->right);\n    if(v->par != NULL) cout << \")\";\n    return;\n}\n\nvoid sum_tree(node *v1, node *v2, node *v3){\n    v3->element = v1->element + v2->element;\n\n    if(v1->left != NULL && v2->left != NULL && v1->left->element != -1 && v2->left->element != -1){\n        node *add = (node *)malloc(sizeof(node));\n        add->element = -1;\n        add->left = NULL;\n        add->right = NULL;\n        add->par = v3;\n        v3->left = add;\n        sum_tree(v1->left, v2->left, v3->left);\n    }\n    \n    if(v1->right != NULL && v2->right != NULL && v1->right->element != -1 && v2->right->element != -1){\n        node *add = (node *)malloc(sizeof(node));\n        add->element = -1;\n        add->left = NULL;\n        add->right = NULL;\n        add->par = v3;\n        v3->right = add;        \n        sum_tree(v1->right, v2->right, v3->right);\n    }\n    \n    //if(v->par != NULL) cout << \")\";\n    return;\n    \n}\n\nint main(){\n\n    string s1, s2; cin >> s1 >> s2;\n    tree *T1 = create();\n    tree *T2 = create();\n    tree *T3 = create();    \n    make_tree(T1, s1);\n    make_tree(T2, s2);\n    sum_tree(T1->root, T2->root, T3->root); \n    print_tree(T3->root);\n    cout << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\n\nint main(){\n\n    while(1){\n        int n; cin >> n;\n        if(!n) break;\n        vector<int> x(n);\n        vector<int> y(n);\n        vector<int> r(n);\n        vector<int> c(n);        \n\n        for(int i = 0; i < n; i++) cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n        vector<vector<bool> > canTake(n, vector<bool> (n, false));\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                int d = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n                if(d < (r[i] + r[j]) * (r[i] + r[j])) canTake[j][i] = true;\n            }\n        }\n\n        /*for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                cout << canTake[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        cout << endl;*/\n\n        //ワーシャルフロイド\n        for(int k = 0; k < n; k++){\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    canTake[i][j] = canTake[i][j] || canTake[i][k] && canTake[k][j];\n                }\n            }\n        }\n\n        /*for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                cout << canTake[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        cout << endl;\n        /*\n        //幅優先探索\n        vector<bool> visited((1<<n), false);\n        queue<pair<int, int> > q;\n        q.push({0, (1<<n) - 1});\n        visited[(1<<n) - 1] = true;\n\n        int ans = 0;\n\n        while(!q.empty()){\n\n            int now_bit = q.front().second;\n            int now_cost = q.front().first;\n            ans = max(ans, now_cost);\n            q.pop();\n\n            for(int i = 0; i < n; i++){\n                for(int j = i + 1; j < n; j++){\n\n                    //i番目 と j番目が取り出せるか\n                    if(!((1<<i) & now_bit)) continue;\n                    if(!((1<<j) & now_bit)) continue;                    \n                    //色が違うならダメ\n                    if(c[i] != c[j]) continue;\n                \n                    //iの上に何かあればダメ\n                    bool flagi = true;\n                    for(int k = 0; k < n; k++){\n                        if(canTake[i][k] && (now_bit & (1<<k))){\n                            flagi = false;\n                            break;\n                        }\n                    }\n\n\n                    if(!flagi) continue;\n                \n                    bool flagj = true;\n                    for(int k = 0; k < n; k++){\n                        if(canTake[j][k] && (now_bit & (1<<k))){\n                            flagj = false;\n                            break;\n                        }\n                    }\n\n                    if(!flagj) continue;\n\n                    int next_bit = now_bit & (~((1<<i) | (1<<j)));\n                    if(!visited[next_bit]){\n                        visited[next_bit] = true;\n                        q.push({now_cost + 1, next_bit});\n                    }\n                }\n            }\n        }\n\n        cout << 2 * ans << endl;\n    }\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\nconst double EPS = 1e-7;\n\n//2点間の距離\ndouble dist(double x1,double y1,double x2,double y2){\n    return sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n}\nlong long dist2(long long x1, long long y1, long long x2, long long y2){\n   return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n}\n\nint bitnum(int n){\n    int ret = 0;\n    while(n > 0){\n        ret += (n & 1); n >>= 1;\n    }\n    return ret;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    while(cin >> n, n){\n        vector<double> x(n), y(n), r(n);\n        vector<int> c(n);\n        vector<int> d[4]; \n        rep(i, 0, n){\n            cin >> x[i] >> y[i] >> r[i] >> c[i];\n            c[i]--;\n            d[c[i]].push_back(i);\n        }\n        bool f[25][25] = {};\n        rep(i, 0, n){\n            rep(j, i + 1, n){\n                double tmp = dist(x[i], y[i], x[j], y[j]);\n                // cout << tmp << endl;\n                if(tmp < r[i] + r[j] - EPS){\n                    f[i][j] = true;\n                }\n            }\n        }\n        int ans = 0;\n        queue<int> q;\n        q.push(0);\n        while(!q.empty()){\n            int mask = q.front(); q.pop();\n            ans = max(ans, bitnum(mask));\n            rep(k, 0, 4){\n                rep(i, 0, d[k].size()){\n                    int x = d[k][i];\n                    if(mask & (1LL << x)) continue; \n                    bool flag = false;                   \n                    rep(j, 0, x){\n                        int z = j;\n                        if(!(mask & (1LL << z)) && f[z][x]){\n                            flag = true; break;\n                        } \n                    }\n                    if(flag) continue;\n                    rep(j, i + 1, d[k].size()){\n                        int y = d[k][j];\n                        if(mask & (1LL << y)) continue;\n                        bool flag1 = false;\n                        rep(l, 0, y){\n                            int u = l;\n                            if(!(mask & (1LL << u)) && f[u][y]){\n                                flag1 = true; break;\n                            }\n                        }\n                        if(flag1) continue;\n                        int nxt = mask | (1LL << x) | (1LL << y);\n                        q.push(nxt);\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct cir {\n\tint num;\n\tint x;\n\tint y;\n\tint r;\n\tint c;\n\tbool top;\n\tset<int> maue;\n\t/*bool operator==(const cir& right) {\n\t\treturn x == right.x && y == right.y && r == right.r && c == right.c && top == right.top && maue == right.maue;\n\t}\n\tbool operator<(const cir& right) {\n\t\treturn x != right.x ? x < right.x : y != right.y ? y < right.y : r != right.r ? r < right.r:true;\n\t}*/\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<cir> circle(n);\n\t\tREP(i, n) {\n\t\t\tcin >> circle[i].x >> circle[i].y >> circle[i].r >> circle[i].c;\n\t\t\tcircle[i].top = true;\n\t\t\tcircle[i].num = i;\n\t\t}\n\t\tREP(i, n / 2)\n\t\t\tswap(circle[i], circle[n - 1 - i]);\n\t\tREP(i, n) {\n\t\t\tREP(j, i) {\n\t\t\t\tif ((circle[i].x - circle[j].x)*(circle[i].x - circle[j].x) +\n\t\t\t\t\t(circle[i].y - circle[j].y)*(circle[i].y - circle[j].y) <\n\t\t\t\t\t(circle[i].r + circle[j].r)*(circle[i].r + circle[j].r)) {\n\t\t\t\t\tcircle[j].top = false;\n\t\t\t\t\tcircle[j].maue.insert(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tqueue<vector<cir>> qvc;\n\t\tset<int> G;\n\t\tint num = 0;\n\t\tREP(i, circle.size())\n\t\t\tif (circle[i].num == i)\n\t\t\t\tnum += (1 << i);\n\t\tG.insert(num);\n\t\tqvc.push(circle);\n\t\twhile (!qvc.empty())\n\t\t{\n\t\t\tvector<cir> Q = qvc.front();qvc.pop();\n\t\t\tans = max(ans, n - (int)Q.size());\n\t\t\tFOR(i, 1, 5) {\n\t\t\t\tREP(j, Q.size()) {\n\t\t\t\t\tif (Q[j].top&&Q[j].c == i)\n\t\t\t\t\t\tFOR(k, j + 1, Q.size()) {\n\t\t\t\t\t\tif (Q[k].top&&Q[k].c == i) {\n\t\t\t\t\t\t\tvector<cir> Q2 = Q;\n\t\t\t\t\t\t\tREP(l, Q2.size())\n\t\t\t\t\t\t\t\tif (!Q2[l].maue.empty())\n\t\t\t\t\t\t\t\t\tif (EXIST(Q2[l].maue, j)) {\n\t\t\t\t\t\t\t\t\t\tQ2[l].maue.erase(j);\n\t\t\t\t\t\t\t\t\t\tif (Q2[l].maue.empty())\n\t\t\t\t\t\t\t\t\t\t\tQ2[l].top = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tREP(l, Q2.size())\n\t\t\t\t\t\t\t\tif (!Q2[l].maue.empty())\n\t\t\t\t\t\t\t\t\tif (EXIST(Q2[l].maue, k)) {\n\t\t\t\t\t\t\t\t\t\tQ2[l].maue.erase(k);\n\t\t\t\t\t\t\t\t\t\tif (Q2[l].maue.empty())\n\t\t\t\t\t\t\t\t\t\t\tQ2[l].top = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tQ2.erase(Q2.begin() + k);\n\t\t\t\t\t\t\tQ2.erase(Q2.begin() + j);\n\t\t\t\t\t\t\tint num2 = 0;\n\t\t\t\t\t\t\tREP(i, Q2.size())\n\t\t\t\t\t\t\t\tif (Q2[i].num == i)\n\t\t\t\t\t\t\t\t\tnum2 += (1 << i);\n\t\t\t\t\t\t\tif (!EXIST(G, num2)) {\n\t\t\t\t\t\t\t\tqvc.push(Q2);\n\t\t\t\t\t\t\t\tG.insert(num2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <set>\n\nusing namespace std;\n\nint col[24], on[24];\nset<int> S;\n\nint search(int cur, int n){\n\tif(S.count(cur)) return 0;\n\tS.insert(cur);\n\tint res = 0;\n\tfor(int i=0;i<n;i++){\n\t\tif(!(cur&(1<<i))||(on[i]&cur)) continue;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(col[i]!=col[j]||!(cur&(1<<j))||(on[j]&cur)) continue;\n\t\t\tres = max(res, 2+search(cur^(1<<i)^(1<<j), n));\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n;\n\tint x[24], y[24], r[24];\n\twhile(cin >> n, n){\n\t\tS.clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> col[i];\n\t\t\ton[i] = 0;\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tif(hypot(x[i]-x[j], y[i]-y[j]) < r[i]+r[j]-1e-8) on[i] |= (1<<j);\n\t\t\t}\n\t\t}\n\t\tcout << search((1<<n)-1, n) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nstruct Node{\n\tint x;\n\tint y;\n\tint r;\n\tint c;\n\tint rm;\n};\nstruct Node nodes[100];\nint memo[20000000];\n\n\nint recur(int bit){\n\tint id[N];\n\tint len = 0;\n\tif(memo[bit] != -1){\n\t\treturn memo[bit];\n\t}\n\n\tfor(int i = 0; i< N; i++){\n\t\tif(bit & (1 << i)){\n\t\t\tint x = nodes[i].x;\n\t\t\tint y = nodes[i].y;\n\t\t\tint r = nodes[i].r;\n\t\t\tint flg = 1;\n\t\t\tfor(int j = 0; j < i; j++){\n\t\t\t\tif(bit & (1 << j)){\n\t\t\t\t\tint xx = x - nodes[j].x;\n\t\t\t\t\tint yy = y - nodes[j].y;\n\t\t\t\t\tint rr = r + nodes[j].r;\n\t\t\t\t\tif(xx * xx + yy * yy < rr * rr){\n\t\t\t\t\t\tflg = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg) id[len++] = i;\n\t\t}\n\t}\n\n\tint ret = 0;\n\tfor(int i = 0; i < len; i++){\n\t\tfor(int j = i + 1; j < len; j++){\n\t\t\tint id1 = id[i];\n\t\t\tint id2 = id[j];\n\t\t\tif(nodes[id1].c == nodes[id2].c){\n\t\t\t\tint nb = bit;\n\t\t\t\t\n\t\t\t\tnb = nb & ~(1 << id1);\n\t\t\t\tnb = nb & ~(1 << id2);\n\t\t\t\tret = max(ret, recur(nb) + 2);\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[bit] = ret;\n}\n\nint main(){\n\twhile(cin >> N, N){\n\t\tfor(int i = 0; i < 20000000; i++){\n\t\t\tmemo[i] = -1;\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint x, y, r, c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tnodes[i].x = x;\n\t\t\tnodes[i].y = y;\n\t\t\tnodes[i].r = r;\n\t\t\tnodes[i].c = c;\n\t\t\tnodes[i].rm = 1;\n\t\t}\n\t\tint bit = 0;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tbit = (bit << 1) | 1;\n\t\t}\n\t\tcout << recur(bit) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nvvi data(24, vi(4));\nvvi covered(24, vi(24));\n\nint bitnum(int n) {\n\tint res = 0;\n\tREP(i, 32) {\n\t\tif(n&(1<<i)) {\n\t\t\tres++;\n\t\t}\n\t}\n\treturn res;\n}\n\nbool cover(int i, int j) {\n\tint xd = data[i][0]-data[j][0];\n\tint yd = data[i][1]-data[j][1];\n\tint rd = data[i][2]+data[j][2];\n\t\n\treturn xd*xd+yd*yd < rd*rd;\n}\n\nbool exist(int st, int i) {\n\treturn st&(1<<i);\n}\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tvvi data(n, vi(4));\n\t\tvvi covered(n, vi(n, 0));\n\n\t\tREP(i, n) {\n\t\t\tREP(j, 4) {\n\t\t\t\tcin >> data[i][j];\n\t\t\t}\n\t\t}\n\n\t\tREP(i, n) {\n\t\t\tREP(j, i) {\n\t\t\t\tint xd = data[i][0]-data[j][0];\n\t\t\t\tint yd = data[i][1]-data[j][1];\n\t\t\t\tint rd = data[i][2]+data[j][2];\n\n\t\t\t\tif(xd*xd+yd*yd < rd*rd) {\n\t\t\t\t\tcovered[j][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<bool> memo(1<<n, false);\n\t\tmemo[(1<<n)-1] = true;\n\t\tstack<int> S;\n\t\tS.push((1<<n)-1);\n\t\tint ans = 0;\n\t\twhile(!S.empty()) {\n\t\t\tint st = S.top();\n\t\t\tS.pop();\n\t\t\tint nst;\n\n\t\t\tREP(i, n) {\n\t\t\t\tif(!exist(st, i)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tREP(k, i) {\n\t\t\t\t\tif(exist(st, k) && covered[k][i]) {\n\t\t\t\t\t\tgoto nexti;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tREP(j, i) {\n\t\t\t\t\tif(!exist(st, j) || data[i][3] != data[j][3]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tREP(k, j) {\n\t\t\t\t\t\tif(exist(st, k) && covered[k][j]) {\n\t\t\t\t\t\t\tgoto nextj;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tnst = st^(1<<i)^(1<<j);\n\t\t\t\t\tif(memo[nst]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmemo[nst] = true;\n\t\t\t\t\tans = max(ans, n-bitnum(nst));\n\t\t\t\t\tS.push(nst);\n\n\t\t\t\t\tnextj:;\n\t\t\t\t}\n\t\t\t\tnexti:;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct circle{\n  double x, y, r;\n  int c;\n  unordered_set<int> up, down;\n};\n \nvoid calcOverlap(int n, circle *disk){\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      double x = disk[i].x - disk[j].x,\n        y = disk[i].y - disk[j].y;\n      if(sqrt(x*x + y*y) + 1e-8 < disk[i].r + disk[j].r){\n        disk[j].up.insert(i);\n        disk[i].down.insert(j);\n      }\n    }\n  }\n}\n \nbool canRemove(circle d, circle dd){\n  if(d.c != dd.c)return false;\n  return d.up.empty() and dd.up.empty();\n}\n \nint dfs(int n, circle *disk, bool *removed, int dep = 0){\n  int res = dep;\n  for (int i = 0; i < n; i++) {\n    if(removed[i] == true)continue;\n    for (int j = i + 1; j < n; j++) {\n      if(removed[j] == true)continue;\n      if(not canRemove(disk[i], disk[j]))continue;\n      removed[i] = true;\n      removed[j] = true;\n      vector<int> erase_i, erase_j;\n      for (int k = 0; k < n; k++) {\n        if(disk[k].up.find(i) != disk[k].up.end()){\n          disk[k].up.erase(i);\n          erase_i.push_back(k);\n        }\n        if(disk[k].up.find(j) != disk[k].up.end()){\n          disk[k].up.erase(j);\n          erase_j.push_back(k);\n        }\n      }\n      res = max(res, dfs(n, disk, removed, dep + 1));\n      for (int k = 0; k < erase_j.size(); k++) {\n        disk[erase_j[k]].up.insert(j);\n      }\n      for (int k = 0; k < erase_i.size(); k++) {\n        disk[erase_i[k]].up.insert(i);\n      }\n      removed[i] = false;\n      removed[j] = false;\n    }\n  }\n  return res;\n}\n \nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n, n){\n    circle disk[n];\n    for (int i = 0; i < n; i++) {\n      cin >> disk[i].x >> disk[i].y >> disk[i].r >> disk[i].c;\n    }\n    bool removed[n];\n    memset(removed, false, sizeof(removed));\n    calcOverlap(n, disk);\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n      if(removed[i] == true)continue;\n      for (int j = i + 1; j < n; j++) {\n        if(not canRemove(disk[i], disk[j]))continue;\n        if(not disk[i].down.empty() or\n           not disk[j].down.empty())continue;\n        if(removed[j] == true)continue;\n        removed[i] = true;\n        removed[j] = true;\n        ans++;\n        break;\n      }\n    }\n    std::cout << 2*(ans + dfs(n, disk, removed)) << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool overlap[24][24];\nbool memo[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++)if((bit>>i)&1){\n        if(overlap[a][i])return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n-1;i++){\n        if(((bit>>i)&1)==0||ok(i,bit)==false)continue;\n        for(int j=i+1;j<n;j++){\n            if(c[i]!=c[j]||((bit>>j)&1)==0)continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(ok(j,bit)&&!memo[to_bit]){\n                ret=max(ret,dfs(to_bit));\n            }\n        }\n    }\n\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            int dist=(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);\n            int sum=(r[i]+r[j])*(r[i]+r[j]);\n            overlap[i][j]=dist<sum;\n        }\n    }\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\n\n\nint main(){\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, x[30], y[30], r[30], c[30];\nint flag[30], ans;\nset<int> s;\n\nvoid rec(int bit){\n\tans = max(ans, n - __builtin_popcount(bit));\n\tif(s.count(bit)) return;\n\ts.insert(bit);\n\trep(i, n) if((bit & 1 << i) && !(flag[i] & bit)) for(int j = i + 1; j < n; j++)\n\tif((bit & 1 << j) && c[i] == c[j] && !(flag[j] & bit)){\n\t\trec(bit ^ 1 << i ^ 1 << j);\n\t}\n}\n\nint main(){\n\twhile(cin >> n, n){\n\t\trep(i, n) cin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\ts.clear();\n\t\tmemset(flag, 0, sizeof(flag));\n\t\trep(j, n) rep(i, j){\n\t\t\tif(r[i] + r[j] - EPS > hypot(x[i] - x[j], y[i] - y[j]))\n\t\t\tflag[j] |= 1 << i;\n\t\t}\n\t\tans = 0;\n\t\trec((1 << n) - 1);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint dp[(1<<24)];\nint n,x[24],y[24],r[24],c[24],s[24];\nint dist(int a,int b){return (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);}\n\nbool check(int a,int b){\n  int ra=r[a]+r[b];\n  return dist(a,b) < ra*ra;\n}\n\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++)\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n    for(int i=0;i<n;i++){\n      s[i]=0;\n      for(int j=i-1;j>=0;j--)s[i]+=(check(i,j)<<j);\n    }\n    for(int k=1;k<=n;k++){\n      int comb=(1<<k)-1;\n      while(comb<1<<n){\n\t\n\tfor(int i=0;i<n;i++){\n\t  if((comb>>i&1)==0)continue;\n\t  if(comb&s[i])continue;\n\t  for(int j=0;j<n;j++){\n\t    if(c[i]!=c[j]||i==j)continue;\n\t    if((comb>>j&1)==0)continue;\n\t    if(comb&s[j])continue;\n\t    dp[comb]=max(dp[comb],2+dp[comb-(1<<i)-(1<<j)]);\n\t  }\n\t}\n\t\n\tint x=comb&-comb,y=comb+x;\n\tcomb=((comb&~y)/x>>1)|y;\n      }\n    }\n    cout<<dp[(1<<n)-1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\n\nstruct P {\n\tint x, y, r, c;\n\n\tP() : x(0), y(0), r(0), c(0) {}\n\tP(int x, int y, int r, int c) : x(x), y(y), r(r), c(c) {}\n};\n\nint n, ans;\nvector<P> v;\nset<int> memo;\n\nvoid dfs(int S) {\n\tif(memo.find(S) != memo.end()) return;\n\tmemo.insert(S);\n\n\tans = max(ans, __builtin_popcount(S));\n\tif(ans == n) return;\n\n\tbool up[50];\n\tmemset(up, 0, sizeof(up));\n\tfor(int i = n-1; i >= 0; i--) {\n\t\tif(S & (1<<i)) continue;\n\n\t\tbool flag = true;\n\t\tfor(int j = i-1; j >= 0; j--) {\n\t\t\tif(S & (1<<j)) continue;\n\t\t\tint dist = (v[j].x - v[i].x) * (v[j].x - v[i].x) + (v[j].y - v[i].y) * (v[j].y - v[i].y);\n\t\t\tint len = (v[i].r + v[j].r) * (v[i].r + v[j].r);\n\n\t\t\tif(dist < len) {\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\n\t\tif(!flag) up[i] = true;\n\t}\n\n\tset<int> st[5];\n\tfor(int i = n-1; i >= 0; i--) {\n\t\tif((S & (1<<i)) || up[i]) continue;\n\n\t\tbool flag = true;\n\n\t\tfor(int j = i-1; j >= 0; j--) {\n\t\t\tif((S & (1<<j)) || up[j]) continue;\n\n\t\t\tint dist = (v[j].x - v[i].x) * (v[j].x - v[i].x) + (v[j].y - v[i].y) * (v[j].y - v[i].y);\n\t\t\tint len = (v[i].r + v[j].r) * (v[i].r + v[j].r);\n\n\t\t\tif(dist >= len && v[i].c == v[j].c) {\n\t\t\t\tdfs(S + (1<<i) + (1<<j));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(cin >> n && n) {\n\n\t\tv.clear();\n\t\tmemo.clear();\n\n\t\trep(i, n) {\n\t\t\tint x, y, r, c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tv.push_back(P(x, y, r, c));\n\t\t}\n\n\t\tvector<bool> used(n);\n\t\trep(i, n) used[i] = false;\n\n\t\tans = 0;\n\t\tint S = 0;\n\t\tdfs(S);\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint n;\nVI xs, ys, rs, cs;\n\nmap<int, int> memo;\nmap<PII, int> memo2;\n\nbool is_top(int i, int used) {\n\tPII key = make_pair(i, used);\n\tif (memo2.count(key)) return memo2[key];\n\n\tfor (int j = i - 1; j >= 0; j--) {\n\t\tif (1 << j & used) continue;\n\n\t\tint x = (xs[i] - xs[j]) * (xs[i] - xs[j]);\n\t\tint y = (ys[i] - ys[j]) * (ys[i] - ys[j]);\n\t\tint dis = x + y;\n\t\tint dis2 = (rs[i] + rs[j]) * (rs[i] + rs[j]);\n\n\t\tif (dis < dis2) {\t// 重なってる\n\t\t\treturn memo2[key] = false;\n\t\t}\n\t}\n\n\treturn memo2[key] = true;\n}\n\nint dfs(int used) {\n\tint sum = 0;\n\n\tif (memo.count(used)) return memo[used];\n\n\tfor(int i = 0;i < n;i++) {\n\t\tfor(int j = 0;j < n;j++) {\n\t\t\tif(i == j || (1 << i & used) || (1 << j & used)) continue;\n\t\t\tif(!is_top(i, used) || !is_top(j, used)) continue;\n\n\t\t\tint x = (xs[i] - xs[j]) * (xs[i] - xs[j]);\n\t\t\tint y = (ys[i] - ys[j]) * (ys[i] - ys[j]);\n\t\t\tint dis = x + y;\n\t\t\tint dis2 = (rs[i] + rs[j]) * (rs[i] + rs[j]);\n\n\t\t\tif(dis >= dis2 && cs[i] == cs[j]) {\n\t\t\t\tint used_tmp = used;\n\t\t\t\tused_tmp |= 1 << i;\n\t\t\t\tused_tmp |= 1 << j;\n\n\t\t\t\tsum = max(sum, dfs(used_tmp) + 2);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn memo[used] = sum;\n}\n\nint main(void) {\n\twhile(cin >> n, n){\n\t\txs = VI(n);\n\t\tys = VI(n);\n\t\trs = VI(n);\n\t\tcs = VI(n);\n\t\tint used = 0;\n\t\tmemo.clear();\n\t\tmemo2.clear();\n\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> xs[i] >> ys[i] >> rs[i] >> cs[i];\n\t\t}\n\n\t\tcout << dfs(used) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\nint n;\ndouble x[24], y[24], r[24];\nint c[24], p[24];\n\nint dp[1 << 25];\n\nint f(int s) {\n\tif(dp[s] != -1) return -1;\n\tif(s == 0) return 0;\n\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++) if((s & (1 << i)) && ((s & p[i]) == 0)) {\n\t\tfor(int j = i + 1; j < n; j++) if((s & (1 << j)) && ((s & p[j]) == 0)) {\n\t\t\tif(c[i] != c[j]) continue;\n\t\t\tint ns = s ^ (1 << i) ^ (1 << j);\n\t\t\tret = max(ret, 2 + f(ns));\n\t\t}\n\t}\n\treturn dp[s] = ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\n\t\tmemset(p, 0, sizeof p);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < i; j++) {\n\t\t\t\tdouble d = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n\t\t\t\tif(d < (r[i] + r[j]) * (r[i] + r[j])) {\n\t\t\t\t\tp[i] |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(dp, -1, sizeof dp);\n\t\tcout << f((1 << n) - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nstruct Circle {\n\tint x, y, r, c, t;\n\tCircle(int x_, int y_, int r_, int c_)\n\t\t: x(x_), y(y_), r(r_), c(c_), t(0) {}\n};\n\nint N;\nint ans;\nvector<Circle> circles;\n\nbool intersect(Circle c1, Circle c2) {\n\tint a = c1.x - c2.x;\n\tint b = c1.y - c2.y;\n\tint r = c1.r + c2.r;\t\n\treturn (a*a + b*b < r*r);\n}\n\nvector<bool> is_visited;\n\nvoid dfs(int used, vector<Circle> circles, int cnt) {\n\t\n\tint n = circles.size();\n\tans = max(ans, cnt);\n\tif(is_visited[used]) return;\n\tis_visited[used] = true;\n\t// ??????????????????????????¢???\n\tfor(int i = 0; i < n; ++i) {\n\t\tCircle c1 = circles[i];\n\t\tif(c1.t != 0 || (used & (1<<i))) continue; \t\n\t\tfor(int j = i+1; j < n; ++j) {\n\t\t\tif(circles[j].t != 0 || (used & (1<<j)) || c1.c != circles[j].c) continue; \n\t\t\tvector<Circle> tmp = circles;\n\t\t\tfor(int k = i+1; k < n; ++k) {\n\t\t\t\tif(intersect(c1, tmp[k])) tmp[k].t -= 1;\t\t\t\n\t\t\t}\n\t\t\tCircle c2 = tmp[j];\n\t\t\tfor(int k = j+1; k < n; ++k) {\n\t\t\t\tif(intersect(c2, tmp[k])) tmp[k].t -= 1;\t\t\t\n\t\t\t}\n\t\t\tdfs((used | (1<<i) | (1<<j)), tmp, cnt + 2);\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\twhile(cin >> N, N) {\n\t\tint x, y, r, c;\n\t\tcircles.clear();\n\t\trep(nth, N) {\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tCircle circle = Circle(x, y, r, c);\t\n\t\t\t// ????????????????????????\n\t\t\trep(i, circles.size()) {\n\t\t\t\tif(intersect(circles[i], circle)) {\n\t\t\t\t\tcircle.t += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcircles.push_back(circle);\n\t\t}\n\t\t\n\t\tans = 0;\n\t\tint used = 0;\n\t\tis_visited.assign((1<<N), false);\n\t\tdfs(used, circles, 0);\n\t\tcout << ans << endl;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n\nusing namespace std;\n\n#define REP(i, x) for(int i=0;i<(int)(x);i++)\n#define REPS(i, x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i, x) for(int i=(int)(x)-1;i>=0;i--)\n#define RREPS(i, x) for(int i=(int)(x);i>0;i--)\n#define FOR(it, x) for(auto it=x.begin();it!=x.end();++it)\n#define pb push_back\n#define eb emplace_back\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\nint d[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v){\n        os << \"[\";\n        FOR(it, v) os << *it << \", \";\n        return os << \"]\";\n}\n\nint n;\nint g[30], x[30], y[30], r[30], c[30];\nint ans;\n\nint norm(int x, int y){\n        return x*x+y*y;\n}\n\nint main(){\n        while(cin >> n, n){\n                REP(i, n){\n                        cin >> x[i] >> y[i] >> r[i] >> c[i];\n                }\n                memset(g, 0, sizeof(g));\n                vector<pii> p;\n                REP(i, n)REP(j, i){\n                        if(norm(x[i]-x[j], y[i]-y[j]) < (r[i]+r[j])*(r[i]+r[j])) g[i] |= 1 << j;\n                        if(c[i] == c[j]) p.eb(j, i);\n                }\n                vi dp(1<<n);\n                dp[0] = 1;\n                int ans = 0;\n                REP(i, 1<<n)if(dp[i]){\n                        FOR(it, p){\n                                int j = it->first, k = it->second;\n                                if((1&(i>>j)) || (1&(i>>k)) || (g[j]&~i) || (g[k]&~i)) continue;\n                                dp[i|(1<<j)|(1<<k)] = 1;\n                        }\n                        ans = max(ans, __builtin_popcount(i));\n                }\n                cout << ans << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nstruct Circle {\n    int x, y, r, c;\n    Circle() {}\n    Circle(int x, int y, int r, int c)\n        : x(x), y(y), r(r), c(c) {}\n};\n\nint n;\nchar dp[1 << 24];\n//char up[24];\n//vector<char> dp, up;\nvector<Circle> c;\n\ninline bool isOverlap(const Circle &a, const Circle &b)\n{\n    int r = (a.r + b.r) * (a.r + b.r);\n    int d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    return r > d;\n}\n\nbool isUp(char s, int v)\n{\n    for (int i = 0; i < v; ++i)\n        if ((s >> i & 1) && isOverlap(c[v], c[i]))\n            return true;\n    return false;\n}\n\nchar Rec(char s)\n{\n    if (~dp[s])\n        return dp[s];\n\n    int res = 0;\n    // 取り除く2つの円の選択\n    for (int i = 0; i < n; ++i) {\n        // c[i]がないか取り除けない\n        if (!(s >> i & 1) || isUp(s, i))\n            continue;\n        // if (!(s >> i & 1) || s & up[i])\n        //     continue;\n\n        for (int j = i + 1; j < n; ++j) {\n            // c[i]とc[j]の色が異なる\n            if (c[i].c != c[j].c)\n                continue;\n            // c[j]がないか取り除けない\n            // if (!(s >> j & 1) || s & up[j])\n            //     continue;\n            if (!(s >> j & 1) || isUp(s, j))\n                continue;\n\n            int nxt = s & ~(1 << i) & ~(1 << j);\n            res = max(res, (int)Rec(nxt) + 2);\n        }\n    }\n\n    return dp[s] = res;\n}\n\nint main()\n{\n    while (cin >> n, n) {\n        memset(dp, -1, sizeof(dp));\n//        memset(up, 0, sizeof(up));\n        c.resize(n);\n\n        // 円の入力\n        for (int i = 0; i < n; ++i)\n            cin >> c[i].x >> c[i].y >> c[i].r >> c[i].c;\n\n        // // 円の重なり，上下関係\n        // for (int i = 0; i < n; ++i)\n        //     for (int j = i + 1; j < n; ++j)\n        //         if (isOverlap(c[i], c[j]))\n        //             up[j] |= (1 << i);\n\n        cout << (int)Rec((1 << n) - 1) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 24\nusing namespace std;\n\nint n,x[N],y[N],r[N],c[N],ans;\nvector<int> v[N];\n\nvoid func(bool erased[N],int cnt,int x){\n  ans=max(ans,cnt);\n  for(int i=0;i<n;i++){\n    int f=0;\n    if(erased[i]) continue;\n    for(int j=0;j<(int)v[i].size();j++)\n      if(!erased[v[i][j]]) f=1;\n    if(f) continue;\n    for(int j=i+1;j<n;j++){\n      if(c[i]!=c[j]) continue;\n      if(erased[j]) continue;\n      int f2=0;\n      for(int k=0;k<(int)v[j].size();k++)\n\tif(!erased[v[j][k]]) f2=1;\n      if(f2) continue;\n      erased[i]=erased[j]=true;\n      func(erased,cnt+2,x+1);\n      erased[i]=erased[j]=false;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n      for(int j=i-1;j>=0;j--){\n\tint xl=x[i]-x[j],yl=y[i]-y[j];\n\tint rl=r[i]+r[j];\n\tif(xl*xl+yl*yl<rl*rl)v[i].push_back(j);\n      }\n    }\n    bool erased[N]={};\n    /*    for(int i=0;i<n;i++){\n      cout<<\"i=\"<<i<<' ';\n      for(int j=0;j<v[i].size();j++) cout<<v[i][j]<<' ';\n      cout<<endl;\n      }*/\n    ans=0;\n    func(erased,0,0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++) v[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n\nclass C{\n    public:\n        int x, y, r, c;\n};\n\nint calDis(C a, C b){\n    int c = a.x - b.x, d = a.y - b.y;\n    return c * c + d * d;\n}\n\nint main(){\n    int n;\n    while(cin >>n && n){\n        vector<C> discs(n); REP(i, n) cin >>discs[i].x >>discs[i].y >>discs[i].r >>discs[i].c;\n        vector<int> overlap(n, 0);\n        REP(i, n){\n            REP(j, i){\n                int tmp = discs[i].r + discs[j].r;\n                if(tmp * tmp > calDis(discs[i], discs[j])) overlap[i] = overlap[i] | (1 << j) | overlap[j];\n            }\n        }\n        int ans = 0;\n        vector<int> bitdp(1 << n, -1);\n        bitdp[0] = 0;\n        REP(i, bitdp.size()){\n            if(bitdp[i] == -1) continue;\n            REP(j, n){\n                FOR(k, j + 1, n){\n                    if(discs[j].c != discs[k].c || (i & (1 << j)) != 0 || (i & (1 << k)) != 0 || (overlap[j] & i) != overlap[j] || (overlap[k] & i) != overlap[k]) continue;\n                    int next = i | (1 << j) | (1 << k);\n                    bitdp[next] = max(bitdp[next], bitdp[i] + 2);\n                }\n            }\n            ans = max(ans, bitdp[i]);\n        }\n        cout <<ans <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cstring>\n\n#define HIT(a,b) ((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r))\n\nusing namespace std;\n\nstruct DISK {\n\tint x,y,r,c;\n\tint o;\n} D[30];\nint n;\nset<int> dp;\n\nint main(){\n\tint i,j,ans;\n\tset <int>::iterator it;\n\twhile(cin>>n,n){\n\t\tmemset(D, 0, sizeof(D));\n\t\tdp.clear();\n\t\tans=0;\n\t\t\n\t\tfor(i=0;i<n;i++) cin>>D[i].x>>D[i].y>>D[i].r>>D[i].c;\n\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=i+1;j<n;j++)\n\t\t\t\tif(HIT(D[i],D[j])) D[j].o |= 1<<i;\n\t\t}\n\n\t\tdp.insert(0);\n\t\tfor(it=dp.begin();it!=dp.end();it++){\n\t\t\tfor(i=0;i<n-1;i++){\n\t\t\t\tif((*it >> i) & 1) continue;\n\t\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\t\tif(D[i].c != D[j].c) continue;\n\t\t\t\t\tif((*it >> j) & 1) continue;\n\n\t\t\t\t\tif(~*it & D[i].o || ~*it & D[j].o) continue;\n\t\t\t\t\tdp.insert(*it | 1 << i | 1 << j);\n\t\t\t\t\tans = max(ans, __builtin_popcount(*it | 1 << i | 1 << j ));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define sq(a) ((a) * (a))\n\nint n;\nint x[24], y[24], r[24], c[24];\nint s[24];\nint dp[1 << 24];\n\nint calc(int bit)\n{\n\tif (~dp[bit]) return dp[bit];\n\tint res = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tif (bit & (1 << i)) continue;\n\t\tif (s[i] & ~bit) continue;\n\t\tfor (int j = 0; j < i; j++){\n\t\t\tif (bit & (1 << j)) continue;\n\t\t\tif (c[i] != c[j]) continue;\n\t\t\tif (s[j] & ~bit) continue;\n\t\t\tres = max(res, 2 + calc(bit | (1 << i) | (1 << j)));\n\t\t}\n\t}\n\treturn dp[bit] = res;\n}\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\tmemset(s, 0, sizeof(s));\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < i; j++){\n\t\t\t\tif (sq(x[i] - x[j]) + sq(y[i] - y[j]) < sq(r[i] + r[j])){\n\t\t\t\t\ts[i] |= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << calc(0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#include<bitset>\n#include<random>\n#include<time.h>\n#include<fstream>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<(ll)m; i++)\n#define FOR(i,n,m) for(long long i=n; i<(ll)m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nmap<int,int> dp;\nvector<vector<int>> co(4);\nvector<pair<int,int>> pos;\nvector<pair<int,int>> cir;\nvector<int> mask;\nll dfs(int bit) {\n\tif(dp.count(bit)) return dp[bit];\n\tint ret=0;\n\tbitset<32> bi(bit);\n\tREP(i,4) {\n\t\tREP(j,(ll)co[i].size()) {\n\t\t\tif(bi[co[i][j]]==0||(bit&mask[co[i][j]])!=0) continue;\n\t\t\tREP(k,j) {\n\t\t\t\tif(bi[co[i][k]]==0||(bit&mask[co[i][k]])!=0) continue;\n\t\t\t\tbi[co[i][j]]=0;\n\t\t\t\tbi[co[i][k]]=0;\n\t\t\t\tret=max((ll)ret,2+dfs(bi.to_ullong()));\n\t\t\t\tbi[co[i][j]]=1;\n\t\t\t\tbi[co[i][k]]=1;\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[bit]=ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n==0) return 0;\n\t\tdp.erase(ALL(dp));\n\t\tREP(i,4) co[i].resize(0);\n\t\tpos.resize(n);\n\t\tcir.resize(n);\n\t\tmask.resize(n);\n\t\tREP(i,n) {\n\t\t\tll x,y,r,c;\n\t\t\tcin>>x>>y>>r>>c;\n\t\t\tc--;\n\t\t\tpos[i]=P(x,y);\n\t\t\tcir[i]=P(r,c);\n\t\t}\n\t\tREP(i,n) co[cir[i].second].pb(i);\n\t\tREP(i,n) {\n\t\t\tbitset<32> bi(0);\n\t\t\tREP(j,i) {\n\t\t\t\tif((pos[i].first-pos[j].first)*(pos[i].first-pos[j].first)+(pos[i].second-pos[j].\tsecond)*(pos[i].second-pos[j].second)<(cir[i].first+cir[j].first)*(cir[i].first+cir[j].first)) {\n\t\t\t\t\tbi[j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmask[i]=bi.to_ullong();\n\t\t}\n\t\tcout<<dfs((1ll<<n)-1ll)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//????????????2???????????§??????????????????????????????????????????????¬??????¨NG. ???????????¨??¢?´¢????????????\n//??????????????????????????????????????????????????£?????????????????????????????????O(2^n)????????????????????°??§?????????\n//?????????????????????????????????????????£?????????)???????????°????????¶?????????????????????????????§???????????????????§???????????¢??????????????????§?????¨?????????????????????????????????????????§????????????\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint n;\nint x[24], y[24], r[24], c[24];\nshort int dp[1 << 24];\n\n//rem???i??????????????????i????????£???????????°1, ??????????????????????????°0\n//????????????????????????????????????????????°????????§???\nint dfs(int rem) {\n\tbool isOut[24];\t//isOut[i] = ???i??????????????????????????°true\n\tint i, j;\n\t\n\tif (rem == 0) return 0;\n\tif (dp[rem] >= 0) return dp[rem];\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif ((rem >> j) % 2 == 0) continue;\t//??¢????????????????????????\n\t\t\tint dd = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n\t\t\tint rr = (r[i] + r[j]) * (r[i] + r[j]);\n\t\t\tif (dd < rr) break;\n\t\t}\n\t\tisOut[i] = (j == i);\n\t}\n\t\n\tint ret = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tif ((rem >> i) % 2 == 0 || !isOut[i]) continue;\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tif ((rem >> j) % 2 == 0 || !isOut[j]) continue;\n\t\t\tif (c[i] != c[j]) continue;\n\t\t\t//???i, j????????????????????????\n\t\t\tret = max(ret, dfs(rem - (1 << i) - (1 << j)) + 2);\n\t\t}\n\t}\n\treturn (dp[rem] = ret);\n}\n\nint main() {\n\twhile (cin >> n) {\n\t\tif (!n) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tfor (int i = 0; i < (1<<n); i++) {\n\t\t\tdp[i] = -1;\n\t\t}\n\t\tcout << dfs((1 << n) - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nchar dp[1<<24];\nint n, x[25], y[25], r[25], c[25], up[25];\n\nint main(){\n\tint i, j,k, ans;\n\twhile(1){\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tans = 0;\n\t\tfor(i=0;i<(1<<n);i++) dp[i]=-1;\n\t\tfor(i=0;i<24;i++) up[i] = 0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tcin >> x[j] >> y[j] >> r[j] >> c[j];\n\t\t}\n\t\tfor(i=0;i<n-1;i++){\n\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\tif(pow(x[i]-x[j],2)+pow(y[i]-y[j],2) < pow(r[i]+r[j],2)){\n\t\t\t\t\tup[j] += 1<<i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[(1<<n)-1]=0;\n\t\tfor(i=(1<<n)-1;i>=0;i--){\n\t\t\tans = max(ans, (int)dp[i]);\n\t\t\tif(dp[i]==-1)continue;\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tif((i&(1<<j))==0||(up[j]&i)) continue;\n\t\t\t\tfor(k=j+1;k<n;k++){\n\t\t\t\t\tif((i&(1<<k))==0||(up[k]&i)||(c[j]!=c[k])) continue;\n\t\t\t\t\tint yy = i - (1<<j) - (1<<k);\n\t\t\t\t\tdp[yy] = max((int)dp[i]+2,(int)dp[yy]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n\nconst int MAXN = 30;\nint x[MAXN], y[MAXN], r[MAXN], c[MAXN];\nbool ok[MAXN];\nmap<int, int> dp;\n\nint square(int x) {return x*x;}\n\nbool check(int i, int j) {\n    int d2 = square(x[i]-x[j]) + square(y[i]-y[j]);\n    return d2 < square(r[i]+r[j]);\n}\n\nint dfs(int state, int n) {\n    int ret = 0;\n    if (dp.find(state) != dp.end()) return dp[state];\n    vector<int> already;\n    memset(ok, true, sizeof(ok));\n    for (int i = 0; i < n; i++) {\n        if ((state>>i)&1) continue;\n        if (ok[i]) {\n            already.push_back(i);\n        }\n        for (int j = i+1; j < n; j++) {\n            if (check(i, j)) ok[j] = false;\n        }\n    }\n    int sz = already.size();\n    for (int i = 0; i < sz; i++) {\n        for (int j = i+1; j < sz; j++) {\n            int ai = already[i], aj = already[j];\n            if (c[ai] == c[aj]) {\n                int nstate = state;\n                nstate |= 1<<ai;\n                nstate |= 1<<aj;\n                ret = max(2+dfs(nstate, n), ret);\n            }\n        }\n    }\n    return dp[state] = ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while(scanf(\"%d\", &n) && n){\n      for (int i = 0; i < n; i++) scanf(\"%d %d %d %d\", &x[i],&y[i],&r[i],&c[i]);\n      dp.clear();\n      cout << dfs(0, n) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n\n\nstruct Disc{\n\tint x,y,r,c;\n\tDisc(int p_x,int p_y,int p_r,int p_c){\n\t\tx=p_x;y=p_y;r=p_r;c=p_c;\n\t}\n\tDisc(){};\n};\n\nint n;\nint memo[1<<24];\nbool exist[24];\nDisc D[24];\nint ans;\n\nbool touch(Disc a,Disc b){\n\treturn (a.r+b.r)*(a.r+b.r)>(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n}\n\nbool top(int k){\n\tfor(int i=k-1;i>=0;i--){\n\t\tif(exist[i]){\n\t\t\tif(touch(D[k],D[i])) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint dfs(int bit,int num){\n\tif(memo[bit]>=0) return memo[bit];\n\tint res=num;\n\n\tfor(int i=0;i<n;i++){\n\t\tif(exist[i] && top(i)){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(exist[j] && top(j) && i!=j && D[i].c==D[j].c){\n\t\t\t\t\texist[i]=false;\n\t\t\t\t\texist[j]=false;\n\t\t\t\t\tres=max(res,dfs((bit&(~1<<i))&(~1<<j),num+2));\n\t\t\t\t\texist[i]=true;\n\t\t\t\t\texist[j]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemo[bit]=res;\n\tans=max(ans,res);\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin>>n && n!=0){\n\t\tans=0;\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tmemset(exist,true,sizeof(exist));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y,r,c;\n\t\t\tcin>>x>>y>>r>>c;\n\t\tD[i]=Disc(x,y,r,c);\n\t\t}\n\t\tans=0;\n\t\tdfs((1<<24)-1,0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define MAX_COLORS 6\n#define MAX_CIRCLES 4\n#define MAX_N (MAX_COLORS*MAX_CIRCLES)\n#define MAX_STATES (1<<MAX_N)\n\nint biggest, n;\n\n/*\nstruct circle{\n    int x, y, r, c;\n};*/\n\nint X[MAX_N];\nint Y[MAX_N];\nint R[MAX_N];\nint C[MAX_N];\n\n//circle C[MAX_N];\nchar dp[MAX_STATES];\n\nbool isOver( int c1, int c2 ){\n    int dx, dy;\n    dx = (X[c1] - X[c2]) * (X[c1] - X[c2]);\n    dy = (Y[c1] - Y[c2]) * (Y[c1] - Y[c2]);\n    return dx + dy < (R[c1] + R[c2])*(R[c1] + R[c2]) ? true : false;\n}\n\nbool isDeleted( int state, int num ){\n    return (state & (1<<num)) == 0 ? false : true;\n}\n/*\nvoid pbit(int num){\n    //cout << \"bit: \";\n    do{\n        printf(\"%d\", num&1);\n        num = num>>1;\n    }while(num);\n    //printf(\"\\n\");\n}*/\n\nbool isTop( int state, int num ){\n    //pbit(state);\n    for( int i = num-1; i >= 0; i-- ){\n        if( isDeleted(state, i) ) continue;\n        if( isOver(num, i) ) return false;\n    }\n    //cout << num << \" is top\" << endl;\n    return true;\n}\n\nvoid search(int s){\n    //for( int s = 0; s < 1<<n; s++ ){\n        /*cout << \"s: \";\n        pbit(s);\n        cout << endl;\n        */\n        for( int i = 0; i < n; i++ ){\n            if( isDeleted(s, i) ) continue;\n            //cout << \"i: \" << i << endl;\n            for( int j = i+1; j < n; j++ ){\n                if( isDeleted(s, j) ) continue;\n                //cout << \"i: \" << i << endl;\n                //cout << \"j: \" << j << endl;\n                if( isTop(s, i) && isTop(s, j) && C[i] == C[j] ){\n                    int next = s | 1<<i | 1<<j;\n                    bool visited;\n                    visited = dp[next] == -1 ? false : true;\n                    //next(s);\n                    //cout << \",\" << i << \",\" << j << endl;\n                    if( dp[next] < dp[s]+2 ) dp[next] = dp[s]+2;\n                    if( biggest < dp[next] ) biggest = dp[next];\n                    if( (next|1) != (1<<n)-1 && !visited ) search(next);\n                }\n            }\n        }\n    //}\n}\n\nvoid init(){\n    for( int s = 0; s < 1<<n; s++ ){\n        dp[s] = -1;\n    }\n}\n\nint main(){\n    while( cin >> n, n ){\n        for( int i = 0; i < n; i++ ){\n            //circle a;\n            //scanf(\"%d%d%d%d\", a.x, a.y, a.r, a.c);\n            cin >> X[i] >> Y[i] >> R[i] >> C[i];\n            // C[i] = a;\n        }\n        biggest = 0;\n        init();\n        dp[0] = 0;\n        search(0);\n        printf(\"%d\\n\", biggest);\n        //cout << \"ans: \" << biggest << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint n,x[30],y[30],r[30],c[30],cover[30];\nbool dp[1<<24];\n\nint main(){\n  while(cin >> n, n){\n    for(int i=0;i<n;i++)cin >> x[i] >> y[i] >> r[i] >> c[i];\n    \n    vector<pii> same_col;\n    for(int i=0;i<n;i++){\n      cover[i] = 0;\n      for(int j=0;j<i;j++){\n\tif( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) < (r[i]+r[j])*(r[i]+r[j]) ){\n\t  cover[i] |= 1<<j;\n\t}\n\tif(c[i] == c[j])same_col.push_back(pii(i,j));\n      }\n    }\n\n    memset(dp,0,sizeof(dp));\n    dp[0] = true;\n\n    for(int bit=0;bit<(1<<n);bit++){\n      if(!dp[bit])continue;\n      for(int i=0;i<(int)same_col.size();i++){\n\tconst int a = same_col[i].first, b = same_col[i].second;\n\tif( (~bit)&((1<<a) | (1<<b)) ){\n\t  if( (~bit)&cover[a] || (~bit)&cover[b])continue;\n\t  dp[bit | (1<<a) | (1<<b)] = true;\n\t}\n      }\n    }\n\n    int ans = 0;\n    for(int bit=0;bit<(1<<n);bit++){\n      if(dp[bit])ans = max(ans, __builtin_popcount(bit));\n    }\n    cout << ans << endl;\n  }\t  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nstruct Node{\n\tint x;\n\tint y;\n\tint r;\n\tint c;\n\tint rm;\n};\nstruct Node nodes[100];\n\nint recur(){\n\tint id[N];\n\tint len = 0;\n\n\tfor(int i = 0; i< N; i++){\n\t\tif(nodes[i].rm){\n\t\t\tint x = nodes[i].x;\n\t\t\tint y = nodes[i].y;\n\t\t\tint r = nodes[i].r;\n\t\t\tint flg = 1;\n\t\t\tfor(int j = 0; j < i; j++){\n\t\t\t\tif(nodes[j].rm){\n\t\t\t\t\tint xx = x - nodes[j].x;\n\t\t\t\t\tint yy = y - nodes[j].y;\n\t\t\t\t\tint rr = r + nodes[j].r;\n\t\t\t\t\tif(xx * xx + yy * yy < rr * rr){\n\t\t\t\t\t\tflg = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg) id[len++] = i;\n\t\t}\n\t}\n\n\tint ret = 0;\n\tfor(int i = 0; i < len; i++){\n\t\tfor(int j = i + 1; j < len; j++){\n\t\t\tint id1 = id[i];\n\t\t\tint id2 = id[j];\n\t\t\tif(nodes[id1].c == nodes[id2].c){\n\t\t\t\tnodes[id1].rm = 0;\n\t\t\t\tnodes[id2].rm = 0;\n\t\t\t\tret = max(ret, recur() + 2);\n\t\t\t\tnodes[id1].rm = 1;\n\t\t\t\tnodes[id2].rm = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(cin >> N, N){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint x, y, r, c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tnodes[i].x = x;\n\t\t\tnodes[i].y = y;\n\t\t\tnodes[i].r = r;\n\t\t\tnodes[i].c = c;\n\t\t\tnodes[i].rm = 1;\n\t\t}\n\t\tcout << recur() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint sum=0,ds;\nint n;\nvoid rec(vector<circle> vs){\n  //cout << vs.size() << endl;\n  int i,j,k;\n  int f;\n  int on[24]={};\n  vector<int> cc[5];\n  vector<circle> next;\n  \n  f=1;\n  for(i=0;i<24;i++) on[i]=0;\n  for(i=0;i<vs.size();i++){\n    for(j=i+1;j<vs.size();j++){\n      if(ch(vs[i],vs[j])==1) on[j]=1;\n    }\n  }\n  for(i=0;i<vs.size();i++){\n    if(on[i]==0) cc[vs[i].c].push_back(i);\n  }\n  for(i=1;i<5;i++){\n    //cout << cc[i].size() << endl;\n    if(cc[i].size()>=2){\n      next.clear();\n      for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n      for(j=0;j<cc[i].size();j++){\n\tfor(k=j+1;k<cc[i].size();k++){\n\t  next.erase(next.begin()+cc[i][k]);\n\t  next.erase(next.begin()+cc[i][j]);\n\t  rec(next);\n\t  f=1;\n\t}\n      }\n    }\n  }\n  int o=n-vs.size();\n  if(f==1) sum=max(sum,o);\n}\n\nint main(){\n  cin >> n;\n  while(n!=0){\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    sum=0;\n    rec(v);\n    cout << sum << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\n\nclass Main{\n\tpublic:\n\n\tmap<int,int> dp;\n\n\tint dfs(){\n\t// \tDUMP(rmv);DUMP(dp.count(rmv));DUMP(canrmv);\n\t\tif(dp.count(rmv))return dp[rmv];\n\t\tint rM=0;\n\t\t//color\n\t\tREP(c,4){\n\t\t\t//canrmvから2つ選ぶ\n\t\t\tREP(i,N)if(cs[i]==c && (canrmv>>i&1)==1 && (rmv>>i&1)!=1)REP(j,N)if(i<j)if(cs[j]==c &&(canrmv>>j&1)==1 && (rmv>>j&1)!=1){\n\t\t\t\trmv|=1<<i;rmv|=1<<j;\n\t\t\t\t//ref\n\t\t\t\trefresh();\n\t\t\t\trM=max(rM,dfs()+2);\n\t\t\t\trmv&=~(1<<i);rmv&=~(1<<j);\n\t\t\t\trefresh();\n\t\t\t}\n\t\t}\n\t\treturn dp[rmv]=rM;\n\t}\n\n\tint N;\n\tvector<int> xs,ys,rs,cs;\n\t\n\tint canrmv;\n\tint rmv;\n\n\tvoid refresh(){\n\t\tcanrmv=0;REP(i,N)canrmv|=1<<i;\n\t\tREP(i,N)if((rmv>>i&1)!=1)REP(j,N)if((rmv>>j&1)!=1)if(i<j){\n\t\t\tif(hypot(xs[i]-xs[j],ys[i]-ys[j])<rs[i]+rs[j])canrmv&=~(1<<j);\n\t\t}\n\t}\n\n\tvoid run(){\n\t\t// ifstream cin(\"D2\");\n//\t\tofstream cout( \"D2.out\" );\n\t\t\n\t\twhile(true){\n\t\t\tcin >> N;if(N==0)break;\n\t\t\txs=vector<int>(N);ys=vector<int>(N);\n\t\t\trs=vector<int>(N);cs=vector<int>(N);\n\t\t\tREP(i,N) {\n\t\t\t\tcin >> xs[i] >> ys[i]>>rs[i]>>cs[i];cs[i]--;\n\t\t\t }\n\t\t\tdp=map<int,int>();\n\t\t\t canrmv=rmv=0;\n\t\t\trefresh();\n\t\t\tcout << dfs() <<endl;\n\t\t}\n\t}\n\n\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\n#include <cctype>\n\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//constexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\nbool intersect(int x1, int y1, int r1, int x2, int y2, int r2) {\n\tx1 -= x2;\n\ty1 -= y2;\n\tr1 += r2;\n\treturn x1 * x1 + y1 * y1 < r1 * r1;\n}\n\nvoid solve() {\n\tint n; cin >> n; if (n == 0) exit(0);\n\tvector<int> x(n), y(n), r(n), c(n);\n\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i] >> r[i] >> c[i], c[i]--;\n\tvector<vector<bool>> bad(n, vector<bool>(n));\n\tfor (int i = 0; i < n; i++) for (int j = i + 1; j < n; j++) {\n\t\tif (intersect(x[i], y[i], r[i], x[j], y[j], r[j])) {\n\t\t\tbad[j][i] = true;\n\t\t}\n\t}\n\tvector<bool> dp(1 << n);\n\tdp[(1 << n) - 1] = true;\n\tint res = 0;\n\tfor (int S = (1 << n) - 1; S >= 0; S--) {\n\t\tif (!dp[S]) continue;\n\t\tvector<int> v;\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (S >> i & 1) {\n\t\t\t\tv.emplace_back(i);\n\t\t\t}\n\t\t\telse cnt++;\n\t\t}\n\t\tfor (int i = 0; i < v.size(); i++) for (int j = i + 1; j < v.size(); j++) {\n\t\t\tint p = v[i], q = v[j];\n\t\t\tif (c[p] != c[q]) continue;\n\t\t\tint nS = S - (1 << p) - (1 << q);\n\t\t\tbool ok = true;\n\t\t\tfor (int k = 0; k < j; k++) {\n\t\t\t\tif (k != i and bad[p][v[k]]) ok = false;\n\t\t\t\tif (k != j and bad[q][v[k]]) ok = false;\n\t\t\t}\n\t\t\tif (ok) dp[nS] = true;\n\t\t}\n\t\tchmax(res, cnt);\n\t}\n\tcout << res << \"\\n\";\n}\nint main()\n{\n\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint kkt = 89;\n\twhile (kkt) {\n\t\tsolve();\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nbool visit[1<<24];\nbool lap[24][24];\nint c[24];\nint key[24];\nint n;\n\nvoid dfs(int x) {\n\tvisit[x] = true;\n\tfor(int i=0; i<n; i++) {\n\t\tif(x & (1<<i)) continue;\n\t\tbool ok = true;\n\t\tfor(int ii=0; ii<n; ii++) {\n\t\t\tif( !(x&(1<<ii)) && (key[i]&(1<<ii)) ) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok) continue;\n\n\t\tfor(int j=i+1; j<n; j++) {\n\t\t\tif(x & (1<<j)) continue;\n\t\t\tif(c[i] != c[j]) continue;\n\t\t\tif( visit[x | (1<<i) | (1<<j)] ) continue;\n\t\t\tfor(int jj=0; jj<n; jj++) {\n\t\t\t\tif( !(x&(1<<jj)) && (key[j]&(1<<jj)) ) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok) {\n\t\t\t\tdfs(x | (1<<i) | (1<<j));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(cin >> n, n) {\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tvi x(n), y(n), r(n);\n\t\trep(i, n) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\t\tmemset(key, 0, sizeof(key));\n\t\trep(i, n) {\n\t\t\tfor(int j=i-1; j>=0; j--) {\n\t\t\t\tdouble d = (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]);\n\t\t\t\tif(d < (r[i]+r[j])*(r[i]+r[j])) {\n\t\t\t\t\tkey[i] |= (1<<j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdfs(0);\n\n\t\tint maxi = 0;\n\t\trep(i, (1<<n)) {\n\t\t\tif(visit[i]) {\n\t\t\t\tmaxi = max(maxi, __builtin_popcount(i));\n\t\t\t}\n\t\t}\n\t\tcout << maxi << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\nint x[24], y[24], r[24], c[24];\n\nbool intersect(int i, int j)\n{\n    return (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) < (r[i] + r[j]) * (r[i] + r[j]);\n}\n\nint rec(int i, int s)\n{\n    if (i == n)\n        return 0;\n\n    for (int j = 0; j < i; ++j)\n        if (!(s & (1 << j)))\n            if (intersect(i, j))\n                return rec(i + 1, s);\n\n    int ans = 0;\n    for (int j = i + 1; j < n; ++j) {\n        if (c[i] != c[j])\n            continue;\n\n        if (s & (1 << j))\n            continue;\n\n        bool f = false;\n        for (int k = 0; k < j && !f; ++k)\n            if (intersect(j, k))\n                f = true;\n        if (f)\n            continue;\n\n        ans = max(ans, rec(i + 1, s | (1 << i) | (1 << j)) + 2);\n    }\n    return ans;\n}\n\nint main()\n{\n    for (;;) {\n        scanf(\"%d\", &n);\n        if (n == 0)\n            break;\n\n        for (int i = 0; i < n; ++i)\n            scanf(\"%d %d %d %d\", &x[i], &y[i], &r[i], &c[i]);\n\n        int ans = rec(0, 0);\n        printf(\"%d\\n\", ans);\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint N,ans;\nbool* state;\n\nstruct Info{\n\tInfo(){\n\t\tx = y = r = 0.0;\n\t\tcolor = 0;\n\t}\n\tdouble x,y,r;\n\tint color;\n};\n\n\nbool isOverlap(Info left,Info right){\n\tdouble dist = sqrt((left.x-right.x)*(left.x-right.x)+(left.y-right.y)*(left.y-right.y));\n\treturn dist <  left.r + right.r;\n}\n\n\nint makeCode(bool removed[]){\n\n\tint ret = 0;\n\n\tint S = 1;\n\tfor(int i = 0; i <= N-1; i++){\n\t\tif(removed[i]){\n\t\t\tret += S;\n\t\t}\n\t\tS *= 2;\n\t}\n\treturn ret;\n}\n\n\nvoid recursive(Info info[],bool removed[],int count){\n\n\tif(count == N || ans == N)return;\n\n\tans = max(ans,count);\n\n\tbool check[N],over_rapFLG;\n\n\tfor(int i = 0; i < N; i++)check[i] = false;\n\n\tfor(int i = N-1; i >= 0; i--){\n\n\t\tif(removed[i] == true)continue;\n\n\t\tover_rapFLG = false;\n\n\t\tfor(int j = i-1; j >=0; j--){\n\n\t\t\tif(removed[j] == true)continue;\n\n\t\t\tif(isOverlap(info[i],info[j])){\n\t\t\t\tover_rapFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!over_rapFLG){\n\t\t\tcheck[i] = true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N-1; i++){\n\t\tfor(int k = i+1; k < N; k++){\n\t\t\tif(check[i] == true && check[k] == true && info[i].color == info[k].color){\n\t\t\t\tbool next_removed[N];\n\t\t\t\tfor(int i = 0; i < N; i++)next_removed[i] = removed[i];\n\t\t\t\tnext_removed[i] = true;\n\t\t\t\tnext_removed[k] = true;\n\n\t\t\t\tint code = makeCode(next_removed);\n\n\t\t\t\tif(state[code] == false){\n\t\t\t\t\tstate[code] = true;\n\t\t\t\t\trecursive(info,next_removed,count+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid func(){\n\tInfo info[N];\n\n\tint limit = pow(2,N);\n\n\tfor(int i = 0; i < limit; i++)state[i] = false;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf %d\",&info[i].x,&info[i].y,&info[i].r,&info[i].color);\n\t}\n\n\tans = 0;\n\n\tbool removed[N];\n\tfor(int i = 0; i < N; i++)removed[i] = false;\n\n\trecursive(info,removed,0);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tstate = new bool[16777216];\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\nconst double EPS = 1e-9;\n\n\nstruct Circle{\n  P p;\n  double r;\n  int c;\n  bool upper(const Circle &e){\n    double b = abs( p - e.p );\n    if( b < r + e.r - EPS ) return true;\n    return false;\n  }\n\n};\n\nint N;\nCircle c[25];\nbool dp[(1<<24)];\n\n\n\nint main(){\n  while( cin >> N && N ){\n    for(int i=0;i<N;i++){\n      int x,y,r,s;\n      cin >> x >> y >> r >> s;\n      c[i] = (Circle){P(x,y),r,s};\n    }\n    memset(dp,0,sizeof(dp));\n    dp[0] = true;\n    int res = 0;\n    for(int i=0;i<(1<<N);i++){\n      int bf[25]={};\n      if( !dp[i] ) continue;\n      res = max( res, __builtin_popcount(i) );\n      // cout << bitset<16>(i) << endl;\n      for(int j=0;j<N;j++){\n        if( i & (1<<j) ) {\n          bf[j] = true; continue;\n        }\n        for(int k=0;k<j;k++){\n          if( !(i&(1<<k)) && c[j].upper(c[k]) ){\n            bf[j] = true; break;\n          }\n        }\n        //  cout << bf[j] << endl;\n      }\n      for(int j=0;j<N;j++){\n        if( bf[j] ) continue;\n        for(int k=j+1;k<N;k++){\n          if( bf[k] ) continue;\n          if(c[j].c == c[k].c)\n            dp[i|(1<<j)|(1<<k)] = true; \n        }\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint n;\n\nstruct Circle {\n    int x, y, r;\n    int c;\n    Circle() {}\n    Circle(int x, int y, int r, int c) : x(x), y(y), r(r), c(c) {}\n};\n\nbool intersect(Circle& a, Circle& b) {\n    return (a.r+b.r) * (a.r+b.r) > (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y);\n}\n\nvector<Circle> cs;\nvector< vector<int> > upper;\nvoid init() {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (intersect(cs[i], cs[j])) {\n                upper[i].push_back(j);\n            }\n        }\n    }\n}\n \nint dp[1<<25];\nint remove(int used=0) {\n    if (dp[used] >= 0) return dp[used];\n    vector<int> tops;\n    for (int i = 0; i < n; i++) {\n        if (used & (1<<i)) continue;\n        bool cover = false;\n        for (int j = 0; j < upper[i].size(); j++) {\n            if (!(used & (1<<upper[i][j]))) {\n                cover = true;\n                break;\n            }\n        }\n        if (!cover) tops.push_back(i);\n    }\n    int cnt = 0;\n    for (int i = 0; i < tops.size(); i++) {\n        for (int j = 0; j < tops.size(); j++) {\n            if (i == j) continue;\n            if (cs[tops[i]].c == cs[tops[j]].c) {\n                used |= (1<<tops[i]);\n                used |= (1<<tops[j]);\n                cnt = max(cnt, remove(used)+2);\n                used ^= (1<<tops[i]);\n                used ^= (1<<tops[j]);\n            }\n        }\n    }\n    return dp[used] = cnt;\n}\n\nint main() {\n    while (cin >> n, n) {\n        cs = vector<Circle>(n);\n        upper = vector< vector<int> >(n);\n        for (int i = 0; i < n; i++) {\n            int x, y, r, c;\n            cin >> x >> y >> r >> c;\n            cs[i] = Circle(x, y, r, c);\n        }\n        init();\n        memset(dp, -1, sizeof(dp));\n        cout << remove() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n\nstruct Disc{\n\tint x,y,r,c;\n\tDisc(int p_x,int p_y,int p_r,int p_c){\n\t\tx=p_x;y=p_y;r=p_r;c=p_c;\n\t}\n\tDisc(){};\n};\n\nint n;\nint memo[1<<24];\nbool exist[24];\nDisc D[24];\nint ans;\nbool is_memo[24][1<<24];\nbool top_memo[24][1<<24];\n\nbool touch(Disc a,Disc b){\n\treturn (a.r+b.r)*(a.r+b.r)>(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n}\n\nbool top(int k,int bit){\n\tif(is_memo[k][bit]) return top_memo[k][bit];\n\tis_memo[k][bit]=true; \n\tfor(int i=k-1;i>=0;i--){\n\t\tif(exist[i]){\n\t\t\tif(touch(D[k],D[i])){top_memo[k][bit]=false; return false;}\n\t\t}\n\t}\n\ttop_memo[k][bit]=true;\n\treturn true;\n}\n\nint dfs(int bit,int num){\n\tif(memo[bit]>=0) return memo[bit];\n\tint res=num;\n\n\tfor(int i=0;i<n;i++){\n\t\tif(exist[i] && top(i,bit)){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(exist[j] && top(j,bit) && i!=j && D[i].c==D[j].c){\n\t\t\t\t\texist[i]=false;\n\t\t\t\t\texist[j]=false;\n\t\t\t\t\tres=dfs((bit&(~(1<<i)))&(~(1<<j)),num+2);\n\t\t\t\t\texist[i]=true;\n\t\t\t\t\texist[j]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemo[bit]=res;\n\tans=max(ans,res);\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin>>n && n!=0){\n\t\tans=0;\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tmemset(exist,true,sizeof(exist));\n\t\tmemset(is_memo,false,sizeof(is_memo));\n\t\tmemset(top_memo,false,sizeof(top_memo));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y,r,c;\n\t\t\tcin>>x>>y>>r>>c;\n\t\tD[i]=Disc(x,y,r,c);\n\t\t}\n\t\tans=0;\n\t\tdfs((1<<24)-1,0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n//bool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n//int index(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\ntypedef complex<double> Point;\nstruct Circle\n{\n\tPoint p; double r; int color;\n\tCircle(Point a, double b, int c) :p(a), r(b), color(c) {};\n};\n\nbool isis_cc(Circle c1, Circle c2)\n{\n\tdouble d = abs(c1.p - c2.p);\n\treturn (d-c1.r-c2.r < -EPS);\n}\n\nint n;\nvector<Circle> cs;\nmap<int, int> mp;\n\nint solve(int bit)\n{\n\tif (mp.find(bit) != mp.end()) return mp[bit];\n\tvector<vi> v(4);\n\tvi c;\n\tREP(i, n)\n\t{\n\t\tif ((bit >> i) & 1) c.push_back(i);\n\t}\n\tfor (int i = c.size() - 1; i >= 0; i--)\n\t{\n\t\tCircle tmp = cs[c[i]];\n\t\tbool f = true;\n\t\tFOR(j, i + 1, c.size())\n\t\t{\n\t\t\tif (isis_cc(tmp, cs[c[j]])) f = false;\n\t\t}\n\t\tif (f) v[tmp.color].push_back(c[i]);\n\t}\n\tbool isend = true;\n\tREP(i, 4)\n\t{\n\t\tif (v[i].size() > 1) isend = false;\n\t}\n\tif (isend) return 0;\n\tint res = 0;\n\tREP(i, 4)REP(j, v[i].size())REP(k, j)\n\t{\n\t\tint copy = bit;\n\t\tcopy ^= (1 << v[i][j]);\n\t\tcopy ^= (1 << v[i][k]);\n\t\tchmax(res, solve(copy) + 2);\n\t}\n\treturn mp[bit] = res;\n}\n\nint main()\n{\n\twhile (cin >> n, n)\n\t{\n\t\tcs.clear();\n\t\tmp.clear();\n\t\tREP(i, n)\n\t\t{\n\t\t\tint x, y, r, c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tc--;\n\t\t\tcs.push_back(Circle(Point(x, y), r, c));\n\t\t}\n\t\treverse(ALL(cs));\n\t\tint bit = (1 << n) - 1;\n\t\tcout << solve(bit) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\nusing namespace std;\nint n,x[24],y[24],r[24],c[24];\nmap<int,int> dp,vd;\nint dist(int a,int b){return (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);}\n\nint rec(int S){\n  if(vd[S]!=0)return dp[S];\n  vd[S]=1;\n  int res=0;\n  bool f[n];\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    f[i]=true;\n    for(int j=i-1;j>=0;j--){\n      if((S>>j)&1)continue;\n      if(dist(i,j)>=(r[i]+r[j])*(r[i]+r[j]))continue;\n      f[i]=false;\n    }\n  }\n  for(int i=0;i<n;i++){\n    if((S>>i)&1)continue;\n    if(!f[i])continue;\n    for(int j=i+1;j<n;j++){\n      if((S>>j)&1)continue;\n      if(!f[j])continue;\n      if(c[i]!=c[j])continue;\n      res=max(res,2+rec(S+(1<<i)+(1<<j)));\n    }\n  }\n  return dp[S]=res;\n}\n\nint main(){\n  while(1){\n    vd.clear();\n    dp.clear();\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++)\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n    cout<<rec(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint x[24],y[24],r[24],c[24];\nbool memo[1<<24];\nchar bit_count[1<<24];\n\nbool ok(int a,int bit){\n    for(int i=0;i<a;i++){\n        if(((bit>>i)&1)==0)continue;\n        int dist=(x[i]-x[a])*(x[i]-x[a])+(y[i]-y[a])*(y[i]-y[a]);\n        int sum=(r[i]+r[a])*(r[i]+r[a]);\n        if(dist<sum)return false;\n    }\n    return true;\n}\n\nint dfs(int bit){\n    memo[bit]=true;\n\n    int ret=n;\n    for(int i=0;i<n;i++)if((bit>>i)&1)ret--;\n\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            if(((bit>>i)&1)==0)continue;\n            if(((bit>>j)&1)==0)continue;\n            int to_bit=(bit^(1<<i))^(1<<j);\n            if(c[i]==c[j]&&ok(i,bit)&&ok(j,bit)&&!memo[to_bit]){\n                ret=max(ret,dfs(to_bit));\n            }\n        }\n    }\n\n\n    return ret;\n}\n\nvoid solve(){\n    fill_n(memo,1<<n,false);\n\n    cout<<dfs((1<<n)-1)<<endl;\n}\n\nbool input(){\n    cin>>n;\n    if(!n)return false;\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i]>>c[i];\n    return true;\n}\n\nvoid init(){\n    for(int i=0;i<(1<<24);i++){\n        for(int j=0;j<24;j++)if((i>>j)&1){\n            bit_count[i]++;\n        }\n    }\n}\n\nint main(){\n    init();\n    while(input())solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\n\nconst int MAX = 24;\nint n;\nint x[MAX], y[MAX], r[MAX], c[MAX];\nint under[MAX];\nshort memo[1 << MAX];\n\nshort dfs(int rest) {\n\tif(memo[rest] >= 0)\n\t\treturn memo[rest];\n\n\tint can = rest;\n\tfor(int i = 0; i < n; ++i)\n\t\tif(rest & (1 << i))\n\t\t\tcan &= ~under[i];\n\n\tint res = 0;\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(can & (1 << i)) {\n\t\t\tconst int tmp = rest & (~(1 << i));\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tif(c[i] == c[j] && (can & (1 << j))) {\n\t\t\t\t\tconst int next = tmp & (~(1 << j));\n\t\t\t\t\tchmax(res, dfs(next) + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn memo[rest] = res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\n\t\tmemset(under, 0, sizeof(under));\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tfor(int j = i + 1; j < n; ++j)\n\t\t\t\tif(hypot(x[i] - x[j], y[i] - y[j]) < r[i] + r[j])\n\t\t\t\t\tunder[i] |= (1 << j);\n\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tcout << dfs((1 << n) - 1) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n#define For(i,a,b)  for(int i = a;i < b;i++)\n#define rep(i,n)\tFor(i,0,n)\n#define all(n)\t\tn.begin(),n.end()\n\n//(x + a)^2 + (y + b)^2 <= c\n\nstruct Circle{\n\tint x, y, r;\n\tint c;\n\tCircle(){};\n\tCircle(int x, int y, int r, int c) :x(x), y(y), r(r), c(c){}\n\tint inter(Circle cl){\n\t\tint tx = cl.x, ty = cl.y;\n\t\tint t = (x - tx)*(x - tx) + (y - ty)*(y - ty);\n\t\tint R = (r + cl.r)*(r + cl.r);\n\t\tif (t < R)return 1;\n\t\tif (t >= R)return 0;\n\t}\n};\n\nint n;\n\nint dfs(vector<Circle> v){\n\n\tvector<int> tv[5];\n\trep(i, v.size()){\n\t\tbool tf = true;\n\t\tFor(j,i+1, v.size()){\n\t\t\tif (v[i].inter(v[j]) == 1){\n\t\t\t\ttf = false;\n\t\t\t}\n\t\t}\n\t\tif (tf){\n\t\t\ttv[v[i].c].push_back(i);\n\t\t}\n\t}\n\n\tint ret = 0;\n\tbool f = false;\n\n\trep(i, 5){\n\t\tif (tv[i].size() >= 2){\n\t\t\trep(j, tv[i].size()){\n\t\t\t\tFor(k, j + 1, tv[i].size()){\n\t\t\t\t\tvector<Circle> tmpv;\n\n\t\t\t\t\trep(l, v.size()){\n\t\t\t\t\t\tif (tv[i][j] != l && tv[i][k] != l)\n\t\t\t\t\t\ttmpv.push_back(v[l]);\n\t\t\t\t\t}\n\n\t\t\t\t\tret = max(ret, dfs(tmpv));\n\t\t\t\t}\n\t\t\t}\n\t\t\tf = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!f){\n\t\treturn n - v.size();\n\t}\n\t\n\treturn ret;\n}\n\n\nint main()\n{\n\n\twhile (cin >> n && n){\n\n\t\tvector<Circle> v;\n\t\trep(i, n){\n\t\t\tint x, y, r, c;\n\t\t\tcin >> x >> y >> r >> c;\n\t\t\tv.push_back(Circle(x, y, r, c));\n\t\t}\n\n\t\treverse(all(v));\n\n\t\tcout << dfs(v) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i,n) for((i)=0;(i)<(int)n;(i)++)\n#define foreach(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n\nint n, x[30], y[30], r[30], c[30], res;\nint memo[30];\n\nbool isOverlap(int a, int b) {\n  double sub_x = (double)(abs(x[a]-x[b]));\n  double sub_y = (double)(abs(y[a]-y[b]));\n  double dist = sqrt(sub_x*sub_x + sub_y*sub_y);\n  return (dist < r[a] + r[b]) ? 1 : 0 ;\n}\n\nvoid dfs(int S, int sum) {\n  //printf(\"%d %d\\n\", S, sum);\n  res = max(res, sum);\n  int i, j;\n  rep(i,n) if (!((1<<i)&S) && (S & memo[i]) == memo[i]) {\n    rep(j,n) if (!((1<<j)&S) && (S & memo[j]) == memo[j]) {\n      if (i == j || c[i] != c[j]) continue;\n      dfs(S|(1<<i)|(1<<j), sum + 2);\n    }\n  }\n}\n\nint main() {\n  int i, j;\n  while (cin>>n, n) {\n    res = 0;\n    rep(i,n) cin>>x[i]>>y[i]>>r[i]>>c[i];\n    rep(i,n)\n    rep(i,n) {\n      memo[i] = 0;\n      rep(j,i) if (isOverlap(i,j)) memo[i] |= (1<<j);\n    }\n    dfs(0, 0);\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint x[30], y[30], r[30], c[30], n, ans;\n// d[i][j] i?????????j????????£?????????1\nbool d[30][30];\nvoid dfs(ll m) {\n  //cout << bitset<24>(m) << endl;\n  //???????????£?????????????????°???????????¨?????°??????\n  VI cnt[6];\n  REP(i, n) {\n    //i????????¨??????????????£??????continue\n    if(m>>i&1) continue;\n    bool flag = true;\n    REP(j, n) {\n      //j????????¨??????????????£??????continue\n      if(m>>j&1) continue;\n      if(d[i][j]) flag = false;\n    }\n    if(flag) cnt[c[i]].PB(i);\n  }\n\n  bool g = false;\n  FOR(i, 1, 5) if(cnt[i].size()>=2) g = true;\n  //????????£????????????\n  if(!g) {\n    int sum=0;\n    REP(i, n) {\n      if(m>>i&1) sum++;\n    }\n    ans = max(ans, sum);\n    return;\n  }\n\n  FOR(i, 1, 5) {\n    //cout << \"i:\" << cnt[i].size() << endl;\n    if(cnt[i].size()<=1) continue;\n    REP(j, cnt[i].size()) REP(k, j) {\n      //cout << j << \":\" << k << endl;\n      ll tmp = m;\n      tmp |= 1<<cnt[i][j];\n      tmp |= 1<<cnt[i][k];\n      dfs(tmp);\n    }\n  }\n\n  return;\n}\n\nsigned main(void)\n{\n  while(true) {\n    cin >> n;\n    if(!n) break;\n    REP(i, 30) REP(j, 30) d[i][j] = 0;\n    REP(i, n) {\n      cin >> x[i] >> y[i] >> r[i] >> c[i];\n      for(int j=i-1; j>=0; --j) {\n        // ??????i??¨??????j???????????£??????????????????i???????????????j????????¨????????????\n        double dist = sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j])), rr = r[i] + r[j];\n        //cout << dist << \" \" << rr << endl;\n        if(dist < rr) d[i][j] = true;\n      }\n    }\n    /*REP(i, n) {\n      REP(j, n) {\n        cout << d[i][j] << \" \";\n      }\n      cout << endl;\n    }*/\n    ans = 0;\n    dfs(0);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n\nint N;\nint x[30],y[30],r[30],color[30];\nint dp[24][1<<24];\n\nint sqr(int x){ return x*x; }\n\nbool cover(int a, int b){\n  return (r[a] + r[b] > sqrt(sqr(x[a] - x[b]) + sqr(y[a] - y[b])));\n}\n\nint remove(int state, int a, int b){\n  int res = state;\n  res &= ~(1<<a);\n  res &= ~(1<<b);\n  return res;\n}\n\nint dfs(int depth, int get, int state){\n  int i,j,res=0;\n\n  if(dp[get][state] != -1) return dp[get][state];\n  if(depth == N) return get;\n\n  REP(i,N) if(((state>>i)&1) == 1){\n    for(j = i; j >= 0; j--) if(((state>>j)&1) == 1 && cover(i,j)) continue;\n    for(j = i+1; j < N; j++) if(((state>>j)&1) == 1 && color[i] == color[j] && !cover(i,j)){\n      res = max(res,dfs(depth+1, get, state));\n      res = max(res,dfs(depth+1, get+2, remove(state,i,j)));\n    }\n  }\n\n  return (dp[get][state] = res);\n}\n\nint main(){\n  int i,j;\n\n  while(1){\n    cin >> N;\n    if(N == 0) break;\n    REP(i,N) cin >> x[i] >> y[i] >> r[i] >> color[i];\n\n    int all = (1<<N)-1;\n    REP(i,24) REP(j,1<<24) dp[i][j] = -1;\n    printf(\"%d\\n\",dfs(0,0,all));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\n\nconst double EPS=1e-6;\ndouble dist(int x0,int y0,int x1,int y1){\n    int x=x0-x1;\n    int y=y0-y1;\n    return sqrt(x*x+y*y)+EPS;\n}\n\nint dfs(int s,vector<int>& x,vector<int>& y,vector<int>& r,vector<int> &c,vector<int> &dp){\n    if(dp[s]!=-1) return dp[s];\n    vector<vector<int>> rem(4);\n    for(int i=0;i<n;i++){\n        if(s&(1<<i)){\n            bool isok=true;\n            for(int j=0;j<i;j++){\n                isok&=!(s&(1<<j) && dist(x[i],y[i],x[j],y[j])<r[i]+r[j]);\n            }\n            if(isok){\n                rem[c[i]].push_back(i);\n            }\n        }\n    }\n    int res=0;\n    for(int i=0;i<4;i++){\n        for(int j=0;j<rem[i].size();j++){\n            for(int k=0;k<j;k++){\n                int tos=s-(1<<rem[i][j])-(1<<rem[i][k]);\n                res=max(res,dfs(tos,x,y,r,c,dp)+2);\n            }\n        }\n    }    \n    return dp[s]=res;\n}\nint main(){\n    while(cin>>n,n){\n        vector<int> x(n),y(n),r(n),c(n);\n        for(int i=0;i<n;i++){\n            cin>>x[i]>>y[i]>>r[i]>>c[i];\n            c[i]--;\n        }\n        vector<int> dp(1<<n,-1);\n        cout<<dfs((1<<n)-1,x,y,r,c,dp)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 24\nusing namespace std;\n\nint n,x[N],y[N],r[N],c[N],ans,len[N];\nvector<int> v[N];\n\nvoid func(bool e[N]){\n  int flag=0;\n  for(int i=0;i<n;i++){\n    if(e[i]) continue;\n    int f=0;\n    for(int j=0;j<len[i];j++)\n      if(!e[v[i][j]]) f=1;\n    if(f) continue;\n    for(int j=i+1;j<n;j++){\n      if(e[j]) continue;\n      f=0;\n      for(int k=0;k<len[j];k++)\n\tif(!e[v[j][k]]) f=1;\n      if(f) continue;\n      if(c[i]!=c[j]) continue;\n      e[i]=e[j]=true;\n      int f2=0;\n      for(int k=0;k<n;k++){\n\tfor(int l=0;l<len[k];l++)\n\t  if(v[k][l]==i||v[k][l]==j) f2=1;\n      }\n      if(f2) flag=1,func(e);\n      e[i]=e[j]=false;\n    }\n  }\n  if(flag==0){\n    for(int i=0;i<n;i++){\n      if(e[i]) continue;\n      int f=0;\n      for(int j=0;j<len[i];j++)\n\tif(!e[v[i][j]]) f=1;\n      if(f) continue;\n      for(int j=i+1;j<n;j++){\n\tif(e[j]) continue;\n\tf=0;\n\tfor(int k=0;k<len[j];k++)\n\t  if(!e[v[j][k]]) f=1;\n\tif(f) continue;\n\tif(c[i]!=c[j]) continue;\n\te[i]=e[j]=true;\n      }\n    }\n    int cnt=0;\n    for(int i=0;i<n;i++)\n      if(e[i]) cnt++;\n    ans=max(ans,cnt);\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n      for(int j=i-1;j>=0;j--){\n\tint xl=x[i]-x[j],yl=y[i]-y[j];\n\tint rl=r[i]+r[j];\n\tif(sqrt(xl*xl+yl*yl)<rl)v[i].push_back(j);\n      }\n    }\n    for(int i=0;i<n;i++) len[i]=v[i].size();\n    ans=0;\n    bool e[N]={};\n    func(e);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++) v[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c,id;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint main(){\n  int n;\n  cin >> n;\n  while(n!=0){\n    int sum=0;\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      c.id=i;\n      v.push_back(c);\n    }\n    int f=0;\n    int on[100]={};\n    //int cc[5]={};\n    vector<int> cc[5];\n    while(f==0){\n      f=1;\n      /*\n      for(i=0;i<24;i++) on[i]=0;\n      for(i=0;i<v.size();i++){\n\tfor(j=i+1;j<v.size();j++){\n\t  if(ch(v[i],v[j])==1) on[j]=1;\n\t}\n      }\n      for(i=0;i<5;i++) cc[i]=0;\n      for(i=0;i<v.size();i++){\n\tif(on[i]==0) cc[v[i].c]++;\n      }\n      */\n      int ff=0;\n      //while(ff==0){\n\tff=1;\n\tfor(i=0;i<100;i++) on[i]=0;\n\tfor(i=0;i<5;i++) cc[i].clear();\n\tfor(i=0;i<v.size();i++){\n\t  for(j=i+1;j<v.size();j++){\n\t    if(ch(v[i],v[j])==1) on[j]=1;\n\t  }\n\t}\n\tfor(i=0;i<v.size();i++){\n\t  if(on[i]==0) cc[v[i].c].push_back(i);\n\t}\n\tfor(i=1;i<5;i++){\n\t  if(cc[i].size()>0&&cc[i].size()%2==0){\n\t    for(j=cc[i].size()-1;j>=0;j--){\n\t      v.erase(v.begin()+cc[i][j]);\n\t      ff=0;\n\t      f=0;\n\t    }\n\t  }\n\t}\n\t//}\n      \n      for(i=1;i<5;i++){\n\tk=0;\n\tfor(j=v.size()-1;j>=0;j--){\n\t  if(on[j]==0&&v[j].c==i){\n\t    if((cc[i].size()/2)*2>k) {\n\t      //cout << v[j].id << \" \";\n\t      v.erase(v.begin()+j);\n\t      k++;\n\t      f=0;\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout << n-v.size() << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint sum=0,ds;\nint n;\nvoid rec(vector<circle> vs){\n  //cout << vs.size() << endl;\n  int i,j,k;\n  int f;\n  int on[30]={};\n  vector<int> cc[5];\n  f=1;\n  int ff=0;\n  while(ff==0){\n    ff=1;\n    for(i=0;i<30;i++) on[i]=0;\n    for(i=0;i<5;i++) cc[i].clear();\n    for(i=0;i<vs.size();i++){\n      for(j=i+1;j<vs.size();j++){\n\tif(ch(vs[i],vs[j])==1) on[j]=1;\n      }\n    }\n    for(i=0;i<vs.size();i++){\n      if(on[i]==0) cc[vs[i].c].push_back(i);\n    }\n    for(i=1;i<5;i++){\n      if(cc[i].size()>0&&cc[i].size()%2==0){\n\tfor(j=cc[i].size()-1;j>=0;j--){\n\t  vs.erase(vs.begin()+cc[i][j]);\n\t  ff=0;\n\t  f=0;\n\t}\n\tbreak;\n      }\n    }\n  }\n  if(f==1){\n  for(i=1;i<5;i++){\n    //cout << cc[i].size() << endl;\n    if(cc[i].size()>=2&&cc[i].size()%2==1){\n      f=0;\n      vector<circle> next(vs);\n      //for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n      for(j=0;j<cc[i].size();j++){\n\tfor(k=cc[i].size()-1;k>=0;k--){\n\t  if(k!=j)\n\t    next.erase(next.begin()+cc[i][k]);\n\t}\n\trec(next);\n      }\n      break;\n    }\n  }\n  }\n  int o=n-vs.size();\n  if(f==1) sum=max(sum,o);\n  else{\n    rec(vs);\n  }\n}\n\nint main(){\n  cin >> n;\n  while(n!=0){\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      v.push_back(c);\n    }\n    sum=0;\n    rec(v);\n    cout << sum << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct circle{\n  double x,y,r;\n  int c;\n};\nint ch(circle a,circle b){\n  if((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r)) return 1;\n  return 0;\n}\nint sum=0,ds;\nint n;\nvoid rec(vector<circle> vs){\n  //cout << vs.size() << endl;\n  int i,j,k;\n  int f;\n  int on[30]={};\n  vector<int> cc[5];\n  f=1;\n  int ff=0;\n  while(ff==0){\n    ff=1;\n    for(i=0;i<30;i++) on[i]=0;\n    for(i=0;i<5;i++) cc[i].clear();\n    for(i=0;i<vs.size();i++){\n      for(j=i+1;j<vs.size();j++){\n\tif(ch(vs[i],vs[j])==1) on[j]=1;\n      }\n    }\n    for(i=0;i<vs.size();i++){\n      if(on[i]==0) cc[vs[i].c].push_back(i);\n    }\n    for(i=1;i<5;i++){\n      if(cc[i].size()>0&&cc[i].size()%2==0){\n\tfor(j=cc[i].size()-1;j>=0;j--){\n\t  vs.erase(vs.begin()+cc[i][j]);\n\t  ff=0;\n\t  f=0;\n\t}\n\tbreak;\n      }\n    }\n  }\n  for(i=1;i<5;i++){\n    //cout << cc[i].size() << endl;\n    if(cc[i].size()>=2&&cc[i].size()%2==1){\n      f=0;\n      vector<circle> next(vs);\n      //for(j=0;j<vs.size();j++) next.push_back(vs[j]);\n      for(j=0;j<cc[i].size();j++){\n\tfor(k=cc[i].size()-1;k>=0;k--){\n\t  if(k!=j)\n\t    next.erase(next.begin()+cc[i][k]);\n\t}\n\trec(next);\n      }\n      break;\n    }\n  }\n  int o=n-vs.size();\n  if(f==1) sum=max(sum,o);\n  else{\n    rec(vs);\n  }\n}\n\nint main(){\n  cin >> n;\n  while(n!=0){\n    circle c;\n    vector<circle>  v;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> c.x >> c.y >> c.r >> c.c;\n      v.push_back(c);\n    }\n    sum=0;\n    rec(v);\n    cout << sum << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nshort dp[(1<<24)+1];\nint main(){\n  int n;;\n  while(cin>>n,n){\n    int col[n],ans=0;\n    double r[n],x[n],y[n];\n    for(int i=0;i<n;i++)\n      cin>>x[i]>>y[i]>>r[i]>>col[i];\n    memset(dp,0,sizeof(dp));\n    dp[((1<<n)-1)]=1;\n  \n    for(int i=1<<n;i>=0;i--)if(dp[i])\n\tfor(int j=n-1;j>=0;j--)if((1<<j)&i)\n\t    for(int k=j-1;k>=0;k--)\n\t      if(((1<<k)&i)&&col[j]==col[k]){\n\t\tfor(int l=j-1;l>=0;l--)if((i&(1<<l))&&abs(sqrt((x[l]-x[j])*(x[l]-x[j])+(y[l]-y[j])*(y[l]-y[j])))<r[j]+r[l])goto L;\n\t        for(int l=k-1;l>=0;l--)if((i&(1<<l))&&abs(sqrt((x[l]-x[k])*(x[l]-x[k])+(y[l]-y[k])*(y[l]-y[k])))<r[k]+r[l])goto L;\n\t\tdp[i-(1<<j)-(1<<k)] =dp[i]+2;\n\t\tans=max(ans,(int)dp[i-(1<<j)-(1<<k)]);\n\t      L:;\n\t      }\n    cout<<ans-1<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n\nstruct Disc{\n\tint x,y,r,c;\n\tDisc(int p_x,int p_y,int p_r,int p_c){\n\t\tx=p_x;y=p_y;r=p_r;c=p_c;\n\t}\n\tDisc(){};\n};\n\nint n;\nchar memo[1<<24];\nbool exist[24];\nDisc D[24];\nint ans;\n\nbool touch(Disc a,Disc b){\n\treturn (a.r+b.r)*(a.r+b.r)>(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n}\n\nbool top(int k){\n\tfor(int i=k-1;i>=0;i--){\n\t\tif(exist[i]){\n\t\t\tif(touch(D[k],D[i])){return false;}\n\t\t}\n\t}\n\treturn true;\n}\n\nint dfs(int bit,int num){\n\tif(memo[bit]>=0) return memo[bit];\n\tint res=num;\n\n\tfor(int i=0;i<n;i++){\n\t\tif(exist[i] && top(i)){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(exist[j] && top(j) && i!=j && D[i].c==D[j].c){\n\t\t\t\t\texist[i]=false;\n\t\t\t\t\texist[j]=false;\n\t\t\t\t\tres=dfs((bit&(~(1<<i)))&(~(1<<j)),num+2);\n\t\t\t\t\texist[i]=true;\n\t\t\t\t\texist[j]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemo[bit]=res;\n\tans=max(ans,res);\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin>>n && n!=0){\n\t\tans=0;\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tmemset(exist,true,sizeof(exist));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y,r,c;\n\t\t\tcin>>x>>y>>r>>c;\n\t\tD[i]=Disc(x,y,r,c);\n\t\t}\n\t\tans=0;\n\t\tdfs((1<<24)-1,0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint foo(int S, vector<char>& c, vector<int>& a, vector<char>& memo) {\n\tif (memo[S] != -1) return memo[S];\n\tint n = c.size(), cnt = 0;\n\tvector< vector<int> > v(4);\n\tfor (int i = 0; i < n; i++)\n\t\tif (S & (1 << i)) {\n\t\t\tcnt++;\n\t\t\tif (!(S & a[i])) v[c[i] - 1].push_back(i);\n\t\t}\t\n\tint mini = cnt;\n\tfor (int j = 0; j < 4; j++) {\n\t\tint m = v[j].size();\n\t\tfor (int k = 0; k < m; k++)\n\t\t\tfor (int _k = k + 1; _k < m; _k++) {\n\t\t\t\tint _S = S - (1 << v[j][k]) - (1 << v[j][_k]);\n\t\t\t\tmini = min(mini, foo(_S, c, a, memo));\n\t\t\t}\n\t}\n\treturn memo[S] = mini;\n}\n\nint main() {\n\tfor (;;) {\n\t\tint n; cin >> n;\n\t\tif (n == 0) break;\n\t\tvector<int> x(n), y(n), r(n);\n\t\tvector<char> c(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tint dx = x[i] - x[j], dy = y[i] - y[j], d = r[i] + r[j];\n\t\t\t\tif (dx * dx + dy * dy < d * d) a[i] |= (1 << j);\n\t\t\t}\n\t\tvector<char> memo(1 << n, -1);\n\t\tcout << n - foo((1 << n) - 1, c, a, memo) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\n\nstruct Circle {\n    ll x;\n    ll y;\n    ll r;\n    int c;\n};\n\nbool overwrap(const Circle& c1, const Circle& c2)\n{\n    const ll d = c1.r + c2.r;\n    const ll R = (c1.x - c2.x) * (c1.x - c2.x) + (c1.y - c2.y) * (c1.y - c2.y);\n    return d * d > R;\n}\n\nint n;\nint dp(vector<int>& table, const vector<vector<bool>>& wrap, const int state, const vector<Circle>& circle)\n{\n    if (table[state] != -1) {\n        return table[state];\n    } else {\n        vector<int> sub(4, 0);\n        vector<vector<int>> top(4, vector<int>(0));\n        for (int j = 0; j < n; j++) {\n            if (state & (1 << j)) {\n                bool ok = true;\n                for (int i = 0; i < j; i++) {\n                    if (state & (1 << i)) {\n                        if (wrap[i][j]) {\n                            ok = false;\n                            break;\n                        }\n                    }\n                }\n                if (ok) {\n                    sub[circle[j].c] += (1 << j);\n                    top[circle[j].c].push_back(j);\n                }\n            }\n        }\n        for (int i = 0; i < 4; i++) {\n            const int size = top[i].size();\n            if (size <= 1) {\n                continue;\n            }\n            if (size % 2 == 0) {\n                const int val = dp(table, wrap, state - sub[i], circle);\n                table[state] = val + size;\n                return val + size;\n            } else {\n                int maxi = 0;\n                for (int j = 0; j < size; j++) {\n                    const int val = dp(table, wrap, state - sub[i] + (1 << top[i][j]), circle);\n                    maxi = max(maxi, val);\n                }\n                table[state] = maxi + (size / 2 * 2);\n                return maxi + (size / 2 * 2);\n            }\n        }\n        table[state] = 0;\n        return 0;\n    }\n}\n\nint main()\n{\n    while (true) {\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        vector<Circle> circle(n);\n        for (int i = 0; i < n; i++) {\n            ll x, y, r;\n            int c;\n            cin >> x >> y >> r >> c;\n            c--;\n            circle[i] = Circle{x, y, r, c};\n        }\n\n        vector<vector<bool>> wrap(n, vector<bool>(n, false));  // j?????????i?????????\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                wrap[i][j] = overwrap(circle[i], circle[j]);\n            }\n        }\n\n        const int maximum = 1 << n;\n        vector<int> table(maximum, -1);\n        table[0] = 0;\n        cout << dp(table, wrap, maximum - 1, circle) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Circle {\n    short x;\n    short y;\n    short r;\n    short c;\n};\n\nbool overwrap(const Circle& c1, const Circle& c2)\n{\n    const short d = c1.r + c2.r;\n    const short R = (c1.x - c2.x) * (c1.x - c2.x) + (c1.y - c2.y) * (c1.y - c2.y);\n    return d * d > R;\n}\n\nshort n;\nshort dp(vector<short>& table, const vector<vector<bool>>& wrap, const short state, const vector<Circle>& circle)\n{\n    if (table[state] != -1) {\n        return table[state];\n    } else {\n        vector<short> sub(4, 0);\n        vector<vector<short>> top(4, vector<short>(0));\n        for (short j = 0; j < n; j++) {\n            if (state & (1 << j)) {\n                bool ok = true;\n                for (short i = 0; i < j; i++) {\n                    if (state & (1 << i)) {\n                        if (wrap[i][j]) {\n                            ok = false;\n                            break;\n                        }\n                    }\n                }\n                if (ok) {\n                    sub[circle[j].c] += (1 << j);\n                    top[circle[j].c].push_back(j);\n                }\n            }\n        }\n        for (short i = 0; i < 4; i++) {\n            const short size = top[i].size();\n            if (size <= 1) {\n                continue;\n            }\n            if (size % 2 == 0) {\n                const short val = dp(table, wrap, state - sub[i], circle);\n                table[state] = val + size;\n                return val + size;\n            } else {\n                short maxi = 0;\n                for (short j = 0; j < size; j++) {\n                    const short val = dp(table, wrap, state - sub[i] + (1 << top[i][j]), circle);\n                    maxi = max(maxi, val);\n                }\n                table[state] = maxi + (size / 2 * 2);\n                return maxi + (size / 2 * 2);\n            }\n        }\n        table[state] = 0;\n        return 0;\n    }\n}\n\nshort main()\n{\n    while (true) {\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        vector<Circle> circle(n);\n        for (short i = 0; i < n; i++) {\n            short x, y, r;\n            short c;\n            cin >> x >> y >> r >> c;\n            c--;\n            circle[i] = Circle{x, y, r, c};\n        }\n\n        vector<vector<bool>> wrap(n, vector<bool>(n, false));  // j?????????i?????????\n        for (short i = 0; i < n; i++) {\n            for (short j = i + 1; j < n; j++) {\n                wrap[i][j] = overwrap(circle[i], circle[j]);\n            }\n        }\n\n        const short maximum = 1 << n;\n        vector<short> table(maximum, -1);\n        table[0] = 0;\n        cout << dp(table, wrap, maximum - 1, circle) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint n;\nint x[24],y[24],r[24],c[24];\n\ninline bool intersect(int p, int q)\n{\n    double dist=sqrt((x[p]-x[q])*(x[p]-x[q])+(y[p]-y[q])*(y[p]-y[q]));\n    return dist<(r[p]+r[q]);\n}\n\ninline bool available(int p, int state)\n{\n    rep(i,p)\n    {\n        if(state>>i&1 && intersect(p,i)) return false;\n    }\n    return true;\n}\n\nunordered_map<int,int> dp;\nint dfs(int state)\n{\n    if(dp.find(state) != dp.end()) return dp[state];\n    if(__builtin_popcount(state)<2) return 0;\n\n    int ret=0;\n    rep(i,n)\n    {\n        if(state>>i&1)\n        {\n            if(!available(i,state)) continue;\n\n            rep(j,n)\n            {\n                if(i==j) continue;\n                if(c[i]!=c[j]) continue;\n\n                if(state>>j&1)\n                {\n                    if(!available(j,state)) continue;\n                    ret = max(ret,dfs(state-(1<<i)-(1<<j))+2);\n                }\n            }\n        }\n    }\n\n    return dp[state]=ret;\n}\n\nint main()\n{\n    while(cin >>n,n)\n    {\n        rep(i,n) scanf(\" %d %d %d %d\", &x[i], &y[i], &r[i], &c[i]);\n        dp.clear();\n        cout << dfs((1<<n)-1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint n;\nint x[25],y[25],r[25],c[25];\nint cover[25];\nbool check[1<<25];\nint cnt,comb,a,b;\nint m,ans;\nint u;\n\ndouble dis(int i,int j){\n  return sqrt( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j]) * (y[i]-y[j]) );\n}\n\nvoid cov(int a){\n  cover[a] = -1;\n  for(int j=a-1;j>=0;j--){\n    if(dis(a,j)<r[a]+r[j] && u>>j & 1){\n      cover[a] = j;\n      break;\n    }\n  }\n} \n\n  \nvoid rec(void){\n  int cnt;\n  for(int i=1;i<=4;i++){\n    cnt = 0;\n    for(int j=0;j<n;j++){\n      if( (u>>j & 1) && cover[j]<0 && c[j] == i)cnt++;\n    }\n    if(cnt==6){\n      for(int j=0;j<n;j++){\n\tif(c[j] == i)u -= 1<<j;\n      }\n      for(int j=0;j<n;j++)cov(j);\n\n      ans += 6;\n      m = max(m,ans);\n      if(!check[u]){\n\trec();\n\tcheck[u] = true;\n      }\n      ans -= 6;\n\n      for(int j=0;j<n;j++){\n\tif(c[j] == i)u += 1<<j;\n      }\n      for(int j=0;j<n;j++)cov(j);\n    }else{\n      for(int j=0;j<n;j++){\n\tif( (u>>j & 1) && cover[j]<0 && c[j] == i){\n\t  for(int k=j+1;k<n;k++){\n\t    if( (u>>k & 1) && cover[k]<0 && c[k] == i){\n\t      u -= 1<<j;\n\t      u -= 1<<k;\n\t      for(int l=0;l<n;l++)cov(l);\n\n\t      ans += 2;\n\t      m = max(m,ans);\n\t      if(!check[u]){\n\t\trec();\n\t\tcheck[u] = true;\n\t      }\n\t      ans -= 2;\n\n\t      u += 1<<j;\n\t      u += 1<<k;\n\t      for(int l=0;l<n;l++)cov(l);\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n}\n\n\n\nint main(){\n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    for(int i=0;i<n;i++)cin >> x[i] >> y[i] >> r[i] >> c[i];\n\n    u = (1<<n) - 1;\n    for(int i=0;i<(1<<n);i++)check[i] = false;\n    for(int i=0;i<n;i++)cov(i);\n\n    \n    m = 0;\n    ans = 0;\n    rec();\n\n    cout << m << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstruct po {int x,y,r,g;};\nvector <po> c[5];\nint ans;\nbool used[1<<24];\n\nbool check(po a){\n  if(a.x==100000)return 0;\n  for(int i=0;i<4;i++)\n    for(int j=0;j<c[i].size();j++){\n      po b = c[i][j];\n      if(a.g>b.g && (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y) < (a.r+b.r)*(a.r+b.r)) return false;\n    }\n  return 1;\n}\n\nvoid saiki(int sum,int i,int bit){\n  ans=max(ans,sum);\n  vector <int> J;\n  for(int j=0;j<c[i].size();j++)if(check(c[i][j]))J.push_back(j);\n  for(int j=0;j<J.size();j++)\n    for(int k=j+1;k<J.size();k++){\n      int nbit=(1<<c[i][J[j]].g)|(1<<c[i][J[k]].g)|bit;\n      if(used[nbit])continue;\n      used[nbit]=1;\n      int a=c[i][J[j]].x, b=c[i][J[k]].x;\n      c[i][J[j]].x = c[i][J[k]].x = 100000;\n      for(int l=0;l<4;l++)saiki(sum+2,l,nbit);\n      c[i][J[j]].x=a;\n      c[i][J[k]].x=b;\n    }\n}\n\nint main(){\n  while(1){\n    int n;\n    cin>>n;\n    if(n==0)break;\n    int x,y,r,col;\n    for(int i=0;i<(1<<24);i++)used[i]=0;\n    for(int i=0;i<4;i++) c[i].clear();\n    for(int i=0;i<n;i++)cin >>x>>y>>r>>col, c[--col].push_back((po){x,y,r,i});\n    ans=0;\n    for(int i=0;i<4;i++) saiki(0,i,0);\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nstruct C {\n    P p;\n    R r;\n    C() {}\n    C(P p, R r) : p(p), r(r) {}\n};\nconst int MN = 24;\n\nint n;\nbool g[MN][MN];\nint col[MN];\n\n\nshort dp[1<<MN];\n\nint calc(int m) {\n    if (dp[m] != -1) return dp[m];\n    int ma = 0;\n    bool can[MN];\n    for (int i = 0; i < n; i++) {\n        can[i] = true;\n        for (int j = 0; j < i; j++) {\n            if (m & (1<<j)) continue;\n            if (g[i][j]) {\n                can[i] = false;\n                break;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            if (col[i] != col[j]) continue;\n            if (m & (1<<i)) continue;\n            if (m & (1<<j)) continue;\n            if (!can[i]) continue;\n            if (!can[j]) continue;\n            ma = max(ma, 2+calc(m | (1<<i) | (1<<j)));\n        }\n    }\n    return dp[m] = ma;\n}\n\nbool solve() {\n    cin >> n;\n    if (!n) return false;\n    C c[MN];\n\n    for (int i = 0; i < n; i++) {\n        R x, y, r;\n        cin >> x >> y >> r >> col[i];\n        c[i] = C(P(x, y), r);\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            g[i][j] = (abs(c[i].p - c[j].p) < c[i].r+c[j].r);\n        }\n    }\n    memset(dp, -1, sizeof(dp));\n    cout << calc(0) << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double R;//double long double ??????????????? cmath?????¢??°??????????????????????????????????????????????????§????????????\ntypedef complex<R> Point;\ntypedef pair<Point , Point> Line;\ntypedef pair<Point ,R > Circle;\ntypedef vector<Point> Poly;\n\n#define EPS (1e-10)//??????\n#define EQ(a,b) (abs((a)-(b)) < EPS)//??????????????°???????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )//????????????????????????????????????\n#define mp make_pair\n#define ft first\n#define sd second\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nR dot(Point a,Point b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nR cross(Point a,Point b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\nbool is_orthogonal(Line a,Line b){//2??´????????´?????????\n    return EQ(dot(a.ft - a.sd,b.ft - b.sd),0.0);\n}\nbool is_parallel(Line a,Line b){//2??´??????????????????\n    return EQ(cross(a.ft - a.sd,b.ft - b.sd),0.0);\n}\n\n////////////////////????????????\n\nint ccw(Point a,Point b,Point c){//ok\n    b -= a; c -= a;\n    if(cross(b,c) > EPS) return 1;//a???b??§???????¨???¨???????????????b???c\n    if(cross(b,c) < -EPS) return -1;//a???b??§????¨???¨???????????????b???c\n    if(dot(b,c) < -EPS) return 2;//c--a--b on same line\n    if(norm(c) - norm(b) > EPS) return -2;//a--b--c(abs??????????????????????????????????????????????????????????)\n    return 0;//a--c--b?????????b==c\n}\n\nbool is_intersection_ll(Line l,Line m){//???????????´??????????????????\n    return abs(cross(l.sd - l.ft,m.sd - m.ft)) > EPS || //????????§??????\n        abs(cross(l.sd - l.ft,m.ft - l.ft)) < EPS; //?????????????????????\n}\n\nbool is_intersection_ls(Line l,Line s){//??´???l??¨??????s???????????????\n    return cross(l.sd - l.ft, s.ft-l.ft)*       // s[0] is left of l\n        cross(l.sd - l.ft, s.sd - l.ft) < EPS; // s[1] is right of l\n}\n\nbool is_intersection_lp(Line l,Point p){//??´???l??¨???p???????????????\n    return abs(cross(l.sd - p,l.ft - p));\n}\n\nbool is_intersection_ss(Line a,Line b){//??????????????????????????????ok\n    return ccw(a.ft,a.sd,b.ft)*ccw(a.ft,a.sd,b.sd) <= 0 && ccw(b.ft,b.sd,a.ft)*ccw(b.ft,b.sd,a.sd) <= 0;\n}\n\nbool is_intersection_sp(Line s,Point p){//????????¨?????????????????? ????§??????????????????¨\n    return abs(s.ft - p) + abs(s.sd - p) - abs(s.ft - s.sd) < EPS;\n}\n\n/////////////?????¢\n\nR dis_lp(Line l,Point p){//??´???l??¨???p????????¢\n    return abs(cross(l.sd - l.ft,p - l.ft)) / abs(l.sd - l.ft);\n}\n\nR dis_ll(Line l,Line m){//???????????´???????????¢\n    return is_intersection_ll(l,m) ? 0.0 : dis_lp(l,m.ft);\n}\n\nR dis_ls(Line l,Line s){//??´???l??¨??????s????????¢\n    if(is_intersection_ls(l,s)) return 0.0;\n    return min(dis_lp(l,s.ft),dis_lp(l,s.sd));\n}\n\nR dis_sp(Line s,Point p){//??????s??¨???p????????¢\n    if(dot(s.sd - s.ft,p - s.ft) < EPS) return abs(p - s.ft);\n    if(dot(s.ft - s.sd,p - s.sd) < EPS) return abs(p - s.sd);\n    return dis_lp(s,p);\n}\n\nR dis_ss(Line s,Line t){//???????????????????????¢\n    if(is_intersection_ss(s,t)) return 0.0;\n    return min(min(dis_sp(s,t.ft),dis_sp(s,t.sd)),\n            min(dis_sp(t,s.ft),dis_sp(t,s.sd)));\n}\n\n//////////////?°???±??¨????°?\n\nPoint projection(Line l,Point p){//?°???±????±???????\n    R t = dot(p - l.ft,l.ft - l.sd) / norm(l.ft - l.sd);\n    return l.ft + t * (l.ft - l.sd);\n}\n\nPoint reflection(Line l,Point p){//????°?????±???????\n    return p + 2.0 * (projection(l,p) - p);\n}\n\n//////////////??????(????????????????¨???????????????¨??????????????????????????????????????£??????)\n\nPoint intersection_ll(Line l,Line m){//????????????????????????????????????????????????\n    R A = cross(l.sd - l.ft,m.sd - m.ft);\n    R B = cross(l.sd - l.ft,l.sd - m.ft);\n    if(abs(A) < EPS && abs(B) < EPS) return m.ft;//?????????\n    //if(abs(A) < EPS)assert(false);//????????§????????????\n    return m.ft + B / A * (m.sd - m.ft);\n}\n\nLine intersection_of_two_circles(Circle c1,Circle c2){//ok ????????????????????????Line?????\\????????????(r1 + r2 > sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2))???????????????????????????\n    R a =  abs(c2.ft - c1.ft);\n    R b = c1.sd;\n    R c = c2.sd;\n\n    R rc = (a  * a + b * b - c * c) / (2.0 * a);\n    R rs = sqrt(b * b - rc * rc);//C++ ??§???????????????????????????????????§???????????????sqrt ????????? float ?????????????????? long double ????????????????????????????????????????????¨?????§???????????? C ????????°????????§??????sqrt ????????? double ??????????????£??????????????????\n    Point diff = (c2.ft - c1.ft) / a;\n\n    Line p ;\n    p.ft = c1.ft + diff * rc + diff * Point(0,1) * rs;\n    p.sd = c1.ft + diff * rc + diff * Point(0,-1) * rs;\n\n    return p;\n}\n\n\nLine conver_line(Line a,Point maxi,Point mini){//??????????????´??????????????? maxi???????????????????????? mini?????????\n\n    if(abs(dot(a.sd - a.ft,Point(1.0,0.0))) < EPS){//??????x???????????´??????\n        ;\n    }\n}\n\n/////////////////////////polygon\n\n#define currP(P,i) P[i]//????????????\n#define nextP(P,i) P[(i + 1)%P.size()]//?¬??????????\n\nint is_contains_p_in_Poly(Poly po,Point p){//??????????§???¢????????¨(1)????¢????(-1)????????¨(0)??????????????????????????????\n    bool in = false;\n    REP(i,po.size()){\n        Point a = currP(po,i) - p,b = nextP(po,i) - p;\n        if(a.imag() > b.imag())swap(a,b);\n        if(a.imag() < EPS && -EPS < b.imag())\n            if(cross(a,b) < -EPS) in = !in;\n        if(abs(cross(a,b)) == 0.0 && dot(a,b) < EPS)return  -1;\n    }\n    return in;\n}\n\nR area2(Poly po){//????§???¢?????¢????????????????±???????\n    R A = 0.0;\n    REP(i,po.size())\n        A += cross(currP(po,i),nextP(po, i));\n    return A;\n}\n\n///////////////////////////???\n\nPoly convex_hull(Poly ps){\n    int n = ps.size(),k = 0;\n    Poly ch(2*n);\n    for(int i = 0;i < n;ch[k++] = ps[i++])// lower-hull\n        while(k >= 2 && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0) --k;\n    for(int i = n - 2,t = k + 1;i >= 0;ch[k++] = ps[i--])//upper-hull\n        while(k >= t && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\n#define prevP(P, i) P[(i+P.size()-1) % P.size()]\nbool isconvex(Poly P){\n    for(int i = 0;i < P.size();++i)\n        if(ccw(prevP(P,i),currP(P,i),nextP(P,i)) > 0) return false;\n    return true;\n}\n\nbool kosa(Circle c1, Circle c2) {\n  return abs(c1.ft-c2.ft)<(c1.sd+c2.sd);\n}\n\n#define MAX_N 24\n\nint n;\nCircle cs[MAX_N];\nint cc[MAX_N];\n\nbool input() {\n  cin>>n;\n  int x, y, r;\n  REP(i, n) {\n    cin>>x>>y>>r>>cc[i];\n    cs[i] = mp(Point(x, y), r);\n  }\n  return n!=0;\n}\n\nint dp[1<<MAX_N];\n\nbool totta[MAX_N],toreru[MAX_N];\n\nint saiki(int S) {\n  if(dp[S] > -1)\n    return dp[S];\n  REP(i,n){totta[i] = S&(1<<i);toreru[i] = true;}\n  REP(i,n){\n    if(totta[i]){\n      toreru[i] = false;\n      continue;\n    }\n    REP(j,i){\n      if(!totta[j] && kosa(cs[i],cs[j])){\n        toreru[i] = false;\n        break;\n      }\n    }\n  }\n  bool f=false;\n  REP(i, n)f=f||toreru[i];\n  if(!f)return 0;\n  int maxi = 0;\n  REP(i,n){\n    if(toreru[i]){\n      FOR(j,i+1,n){\n        if(toreru[j] && cc[i] == cc[j])\n          maxi = max( maxi, saiki(S|(1<<i)|(1<<j))+2 );\n      }\n    }\n  }\n  return maxi;\n}\n\nvoid solve() {\n  REP(i,1<<n)\n    dp[i] = -1;\n  cout<<saiki(0)<<endl;\n}\n\nint main() {\n  \n  while(input()) {\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 24\nusing namespace std;\n\nint n,x[N],y[N],r[N],c[N],ans,len[N];\nvector<int> v[N];\nset<string> s;\n\nvoid func(bool erased[N],int cnt){\n  ans=max(ans,cnt);\n  for(int i=0;i<n;i++){\n    int f=0;\n    if(erased[i]) continue;\n    for(int j=0;j<len[i];j++)\n      if(!erased[v[i][j]]) f=1;\n    if(f) continue;\n    for(int j=i+1;j<n;j++){\n      if(c[i]!=c[j]) continue;\n      if(erased[j]) continue;\n      int f2=0;\n      for(int k=0;k<len[j];k++)\n\tif(!erased[v[j][k]]) f2=1;\n      if(f2) continue;\n      erased[i]=erased[j]=true;\n      string str;\n      for(int k=0;k<n;k++){\n\tif(erased[k]) str+='1';\n\telse str+='0';\n      }\n      if(s.find(str)!=s.end()) continue;\n      else s.insert(str);\n      func(erased,cnt+2);\n      erased[i]=erased[j]=false;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n) break;\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>r[i]>>c[i];\n      for(int j=i-1;j>=0;j--){\n\tint xl=x[i]-x[j],yl=y[i]-y[j];\n\tint rl=r[i]+r[j];\n\tif(sqrt(xl*xl+yl*yl)<rl)v[i].push_back(j);\n      }\n    }\n    for(int i=0;i<n;i++) len[i]=v[i].size();\n    bool erased[N]={};\n    ans=0;\n    func(erased,0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++) v[i].clear();\n    s.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint N;\nint r[24], x[24], y[24], c[24];\nvector<int> ue;\n\nshort dp[1 << 24];\nint xx(int x) { return x * x; }\nshort _dp(int k) {\n\tif (k == 0) return 0;\n\tif (dp[k] >= 0) return dp[k];\n\n\tvector<int> w;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif ( (k & (1 << i)) && (k & ue[i]) == 0 ) w.push_back(i);\n\t}\n\tshort ret = 0;\n\tfor (int i = 0; i < w.size(); ++i) {\n\t\tfor (int j = i+1; j < w.size(); ++j) {\n\t\t\tif (c[w[i]] == c[w[j]]) {\n\t\t\t\tret = max<short>(dp[k], _dp(k ^ (1 << w[i]) ^ (1 << w[j]))+2);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[k] = ret;\n}\nint main() {\n\twhile (cin >> N, N) {\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> x[i] >> y[i] >> r[i] >> c[i];\n\t\t}\n\n\t\tbool f[24][24] = {0}; // f[a][b]: a??????b????????????????????????\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\tif (xx(x[i]-x[j]) + xx(y[i]-y[j]) < xx(r[i]+r[j])) {\n\t\t\t\t\tf[j][i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tue.clear();\n\t\tue.resize(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint b = 0;\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (f[i][j]) b |= (1 << j);\n\t\t\t}\n\t\t\tue[i] = b;\n\t\t}\n\n\t\tfill(&dp[0], &dp[0]+(1<<24), -1);\n\t\tcout << (int)_dp((1 << N) - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(x) (int)(x.size())\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\n\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\n\nstruct Circle {\n  double x, y, r;\n};\n\ndouble distpow(double x1, double y1, double x2, double y2) {\n  return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n}\n\nbool kasanari(Circle c1, Circle c2) {\n  return (c1.r + c2.r) * (c1.r + c2.r) > distpow(c1.x, c1.y, c2.x, c2.y) + eps;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  while(1) {\n    int n; cin >> n;\n    if(n == 0) break;\n    vector<int> col(n);\n    vector<Circle> circles(n);\n    for(int i=0;i<n;++i) {\n      cin >> circles[i].x >> circles[i].y >> circles[i].r >> col[i];\n    }\n\n    vector<int> over(n, 0);\n    for(int i=0;i<n;++i) {\n      for(int j=0;j<i;++j) {\n        if(kasanari(circles[i], circles[j])) {\n          over[i] |= 1<<j;\n        }\n      }\n    }\n/*     for(int i=0;i<n;++i) {\n      cout << bitset<4>(over[i]) << endl;\n    } */\n\n    vector<int> dp(1<<n, -1);\n    dp[(1<<n)-1] = 0;\n    for(int i=(1<<n)-1;i>=0;--i) {\n      if(dp[i] == -1) continue;\n      for(int j=0;j<n;++j) {\n        if(((i>>j)&1) == 0) continue;\n        for(int k=j+1;k<n;++k) {\n          if(((i>>k)&1) == 0) continue;\n          \n          if(col[j] != col[k]) continue;\n          //cout << i << \":\" << j << \":\" << k << endl;\n          if(((i & over[j]) != 0) || ((i & over[k]) != 0)) continue;\n          \n          dp[i ^ (1<<j) ^ (1<<k)] = dp[i] + 2;\n        }\n      }\n    }\n    //printv(dp);\n\n    int ma = 0;\n    for(int i=0;i<(1<<n);++i) {\n      ma = max(ma, dp[i]);\n    }\n    cout << ma << endl;\n\n  }\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint n;\n\nstruct Circle {\n    int x, y, r;\n    int c;\n    Circle() {}\n    Circle(int x, int y, int r, int c) : x(x), y(y), r(r), c(c) {}\n};\n\nbool intersect(Circle& a, Circle& b) {\n    return (a.r+b.r) * (a.r+b.r) > (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y);\n}\n\nvector<Circle> cs;\nvector< vector<int> > upper;\nbool used[25];\nvoid init() {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (intersect(cs[i], cs[j])) {\n                upper[i].push_back(j);\n            }\n        }\n    }\n}\n \nint remove() {\n    vector<int> tops;\n    for (int i = 0; i < n; i++) {\n        if (used[i]) continue;\n        bool cover = false;\n        for (int j = 0; j < upper[i].size(); j++) {\n            if (!used[upper[i][j]]) {\n                cover = true;\n                break;\n            }\n        }\n        if (!cover) tops.push_back(i);\n    }\n    int cnt = 0;\n    for (int i = 0; i < tops.size(); i++) {\n        for (int j = 0; j < tops.size(); j++) {\n            if (i == j) continue;\n            if (cs[tops[i]].c == cs[tops[j]].c) {\n                used[tops[i]] = used[tops[j]] = true;\n                cnt = max(cnt, remove()+2);\n                used[tops[i]] = used[tops[j]] = false;\n            }\n        }\n    }\n    return cnt;\n}\n\nint main() {\n    while (cin >> n, n) {\n        cs = vector<Circle>(n);\n        upper = vector< vector<int> >(n);\n        for (int i = 0; i < n; i++) {\n            int x, y, r, c;\n            cin >> x >> y >> r >> c;\n            cs[i] = Circle(x, y, r, c);\n        }\n        init();\n        memset(used, 0, sizeof(used));\n        cout << remove() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1175: And Then. How Many Are There?\n// 2017.12.21 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\ntypedef struct { int s, del, m; } Q;\nQ q[100000]; int top;\ntypedef struct { int x, y, r, c; } T;\nT d[25]; int n;\ntypedef struct { int n, id[25]; } S;\nS up[25];\t\t\t// ?????????????????????????????°??¨??????\nchar visited[16777216];\n\nint main()\n{\n\tint i, j, k, a, s, del, m, ans;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tfor (i = 0; i < n; i++) scanf(\"%d%d%d%d\", &d[i].x, &d[i].y, &d[i].r, &d[i].c);\n\t\tmemset(up, 0, sizeof(up));\n\t\tfor (i = 0; i < n; i++) for (j = i+1; j < n; j++) {\n\t\t\tif (hypot(d[i].x-d[j].x, d[i].y-d[j].y) < d[i].r+d[j].r) {\n\t\t\t\tup[j].id[up[j].n++] = i;\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tq[0].s = 0, q[0].del = 0, q[0].m = n, top = 1;\n\t\twhile (top) {\n\t\t\ts = q[--top].s, del = q[top].del, m = q[top].m;\n\n\t\t\tif (m == 1 || visited[s]) continue;\n\t\t\tvisited[s] = 1;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tif (s & (1<<i)) continue;\n\t\t\t\tfor (k = 0; k < up[i].n; k++) {\n\t\t\t\t\ta = up[i].id[k];\n\t\t\t\t\tif (!(s & (1<<a))) goto next;\n\t\t\t\t}\n\n\t\t\t\tfor (j = i+1; j < n; j++) {\n\t\t\t\t\tif (s & (1<<j)) continue;\n\t\t\t\t\tif (d[j].c != d[i].c) continue;\n\t\t\t\t\tfor (k = 0; k < up[j].n; k++) {\n\t\t\t\t\t\ta = up[j].id[k];\n\t\t\t\t\t\tif (!(s & (1<<a))) goto next2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (del+2 > ans) ans = del+2;\n\t\t\t\t\tq[top].s = s|(1<<i) | (1<<j), q[top].del = del+2, q[top++].m = m-2;\n\n\t\t\t\t\tnext2:;\n\t\t\t\t}\n\t\t\t\tnext:;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<string.h>\nconst double EPS = 0.1;\nint N,X[50],Y[50],R[50],C[50],i,j;\nint dp[1<<25];\n\nint isOver(int a,int b)\n{\n\tdouble x=sqrt((double)(X[a]-X[b])*(X[a]-X[b])+(Y[a]-Y[b])*(Y[a]-Y[b])),y=R[a]+R[b];\n\tif(y>x)return 1;\n\treturn 0;\n}\n\nint ch(int n,int f)\n{\n\tint i;\n\tfor(i=0;i<n;i++)\n\t\tif(i!=n&&!((f>>i)&1)&&isOver(i,n))\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint dfs(int d,int f)\n{\n\tint i,r=0,t,n;\n\tif(dp[f]!=-1)return dp[f];\n\tif(d==N)\n\t\treturn 0;\n\tfor(n=0;n<N;n++)\n\t{\n\t\tif(!((f>>n)&1)&&ch(n,f))\n\t\t{\n\t\t\tfor(i=0;i<N;i++)\n\t\t\t\tif(i!=n&&C[i]==C[n]&&!((f>>i)&1)&&ch(i,f))\n\t\t\t\t{\n\t\t\t\t\tf^=(1<<i);\n\t\t\t\t\tf^=(1<<n);\n\t\t\t\t\tt=dfs(d+1,f)+2;\n\t\t\t\t\tr=r<t?t:r;\n\t\t\t\t\tf^=(1<<i);\n\t\t\t\t\tf^=(1<<n);\n\t\t\t\t}\n\t\t}\n\t}\n\treturn dp[f]=r;\n}\n\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(i=0;i<N;i++)\n\t\t\tscanf(\"%d%d%d%d\",&X[i],&Y[i],&R[i],&C[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\n\nint N, X[24], Y[24], R[24], C[24];\nint r[24], m[24];\nchar dp[16777216];\n\nint f(char n, int s) { return ((s & r[n]) & m[n]) == 0; }\nchar max(char a, char b) { return a > b ? a : b; }\n\nchar dfs(int s, char n) {\n  if(n == N) return N;\n\n  char ret = n;\n  REP(i, 0, N) {\n    int mi = (1 << i);\n    if((~s & mi) || !f(i, s)) continue;\n    REP(j, i + 1, N) {\n      int mj = (1 << j);\n      if(C[i] != C[j] || (~s & mj) || !f(j, s)) continue;\n      int ns = ~(~s | mi | mj);\n      if(dp[ns] >= 0) continue;\n      ret = max(ret, dfs(ns, n + 2));\n    }\n  }\n\n  return dp[s] = ret;\n}\n\nint main(void) {\n  m[0] = 0;\n  REP(i, 0, 23) m[i + 1] = m[i] | (1 << i);\n  while(scanf(\"%d\", &N), N) {\n    REP(i, 0, N) scanf(\"%d %d %d %d\", X + i, Y + i, R + i, C + i);\n    REP(i, 0, pow(2, N)) dp[i] = -1;\n    REP(i, 0, N) r[i] = 0;\n    REP(i, 0, N) REP(j, 0, N) {\n      if(pow(R[i] + R[j], 2) > pow(X[i] - X[j], 2) + pow(Y[i] - Y[j], 2)) {\n        r[i] = r[i] | (1 << j);\n        r[j] = r[j] | (1 << i);\n      }\n    }\n    printf(\"%d\\n\", dfs((1 << N) - 1, 0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define max(x,y) x>y?x:y\n\n#define bool int\n#define false 0\n#define true 1\n\nint n;\nint x[111],y[111],r[111],c[111];\nbool used[111];\nchar mem[1<<24];\n\nbool judge(int i,int j){\n\tbool ok=true;\n\trep(k,i){\n\t\tif(used[k])continue;\n\t\tif(pow(x[i]-x[k],2)+pow(y[i]-y[k],2)<pow(r[i]+r[k],2))ok=false;\n\t}\n\trep(k,j){\n\t\tif(used[k])continue;\n\t\tif(pow(x[k]-x[j],2)+pow(y[k]-y[j],2)<pow(r[k]+r[j],2))ok=false;\n\t}\n\treturn ok;\n}\n\nint dfs(int v){\n\tif(mem[v]!=-1)return mem[v];\n\tint res=0;\n\trep(i,n)repl(j,i+1,n){\n\t\tif(!used[i]&&!used[j]&&c[i]==c[j]&&judge(i,j)){\n\t\t\tused[i]=used[j]=true;\n\t\t\tres=max(res,dfs(v|(1<<i)|(1<<j))+2);\n\t\t\tused[i]=used[j]=false;\n\t\t}\n\t}\n\treturn mem[v]=res;\n}\n\nint main(){\n\t//cin.sync_with_stdio(false);\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\trep(i,n)scanf(\"%d%d%d%d\",x+i,y+i,r+i,c+i);\n\t\tmemset(used,0,sizeof(used));\n\t\tmemset(mem,-1,sizeof(mem));\n\t\tprintf(\"%d\\n\", dfs(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1175: And Then. How Many Are There?\n// 2017.12.21 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\ntypedef struct { int s, del, m; } Q;\nQ q[100000]; int top;\ntypedef struct { int x, y, r; } T;\nT d[25];\nint col[4][6], clen[4]; char f[5];\nint up[25][25], ulen[25];\t\t// ?????????????????????????????°??¨??????\nchar visited[16777216];\n\nint main()\n{\n\tint n, i, j, k, a, c, cmax, p, r, s, del, m, ans;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tmemset(clen, 0, sizeof(clen)), memset(f, -1, sizeof(f)), cmax = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &d[i].x, &d[i].y, &d[i].r, &c);\n\t\t\tif  (f[c] >= 0)          c = f[c];\n\t\t\telse f[c] = cmax++, c = cmax-1;\n\n\t\t\tcol[c][clen[c]++] = i;\n\t\t}\n\n\t\tmemset(ulen, 0, sizeof(ulen));\n\t\tfor (i = 0; i < n; i++) for (j = i+1; j < n; j++) {\n\t\t\tif (hypot(d[i].x-d[j].x, d[i].y-d[j].y) < d[i].r+d[j].r) up[j][ulen[j]++] = i;\n\t\t}\n\n\t\tans = 0;\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tq[0].s = 0, q[0].del = 0, q[0].m = n, top = 1;\n\t\twhile (top) {\n\t\t\ts = q[--top].s, del = q[top].del, m = q[top].m;\n\n\t\t\tif (m == 1 || visited[s]) continue;\n\t\t\tvisited[s] = 1;\n\t\t\tfor (c = 0; c < cmax; c++)if (clen[c] >= 2) for (p = 0; p < clen[c]; p++) {\n\t\t\t\ti = col[c][p];\n\t\t\t\tif (s & (1<<i)) continue;\n\t\t\t\tfor (k = 0; k < ulen[i]; k++) {\n\t\t\t\t\ta = up[i][k];\n\t\t\t\t\tif (!(s & (1<<a))) goto next;\n\t\t\t\t}\n\n\t\t\t\tfor (r = 0; r < clen[c]; r++) {\n\t\t\t\t\tif (r == p) continue;\n\t\t\t\t\tj = col[c][r];\n\t\t\t\t\tif (s & (1<<j)) continue;\n\t\t\t\t\tfor (k = 0; ; k++) {\n\t\t\t\t\t\tif (k == ulen[j]) {\n\t\t\t\t\t\t\tif (del+2 > ans) ans = del+2;\n\t\t\t\t\t\t\tq[top].s = s|(1<<i) | (1<<j), q[top].del = del+2, q[top++].m = m-2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ta = up[j][k];\n\t\t\t\t\t\tif (!(s & (1<<a))) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnext:;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define DISK_NUM 24\n#define COLOR_NUM 4\n\n/* int 型をビット表示 (デバッグ用) */\n/*\nvoid showBit(int x){\n\tint i;\n\tfor (i = 31; i >= 0; i--) printf(\"%d\", (x>>i) & 1);\n\tprintf(\"\\n\");\n}\n*/\n\n/* 円盤 */\ntypedef struct Disk{\n\tint x, y, r, c;\n\tint u;  /* i 番目の円盤がこの円盤の上にあるか否かをビットの桁で表す */\n} Disk;\n\n/* 二つの円盤が重なっているかを返す */\nint isCollide(Disk a, Disk b){\n\tif ((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) < (a.r + b.r) * (a.r + b.r)) return 1;\n\treturn 0;\n}\n\nint B[DISK_NUM];\n\nint n;\nDisk d[DISK_NUM];\nint f;  /* 円盤が存在するかのフラグ */\n\nint dp[1<<DISK_NUM];  /* f をキーとしたメモ化再帰 */\n#define unknown -1\n\nint search(){\n\tint max = 0, m, i, j;\n\tint list;\n\n\tif (dp[f] != unknown) return dp[f];\n\n\t/* 取ることのできる円盤の一覧を生成する */\n\tlist = f;\n\tfor (i = 0; i < n; i++) if ((list & B[i]) != 0 && (d[i].u & f) != 0) list ^= B[i];\n\n\t/* 全ての円盤の組み合わせを調べる */\n\tfor (i = 1; i < n; i++){\n\t\tif ((list & B[i]) == 0) continue;\n\n\t\tf ^= B[i];  /* 取る */\n\t\tfor (j = 0; j < i; j++){\n\t\t\tif ((list & B[j]) == 0) continue;\n\n\t\t\t/* 色が同じなら取り除ける */\n\t\t\tif (d[i].c == d[j].c){\n\t\t\t\tf ^= B[j];  /* 取る */\n\t\t\t\tm = 2 + search();\n\t\t\t\tif (m > max) max = m;\n\t\t\t\tf ^= B[j];  /* 戻す */\n\t\t\t}\n\t\t}\n\t\tf ^= B[i];  /* 戻す */\n\t}\n\n\treturn dp[f] = max;\n}\n\nint main(void){\n\tint i, j;\n\n\tfor (i = 0; i < DISK_NUM; i++) B[i] = 1 << i;\n\n\twhile (scanf(\"%d\", &n) == 1 && n > 0 && n <= DISK_NUM){\n\t\t/* 入力 */\n\t\tfor (i = 0; i < n; i++){\n\t\t\tscanf(\"%d%d%d%d\", &(d[i].x), &(d[i].y), &(d[i].r), &(d[i].c));\n\t\t\t/* 重なりの状態を調べる (番号が小さいほうが上) */\n\t\t\td[i].u = 0;\n\t\t\tfor (j = 0; j < i; j++){\n\t\t\t\tif (isCollide(d[i], d[j])){\n\t\t\t\t\td[i].u |= B[j];  /* d[j] が d[i] の上にある */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* 初期化 */\n\t\tf = 0;\n\t\tfor (i = 0; i < n; i++) f |= B[i];\n\t\tfor (i = 0; i < (1<<n); i++) dp[i] = unknown;\n\n\t\tprintf(\"%d\\n\", search());\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define repl(i,a,b) for(i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define max(x,y) x>y?x:y\n\n#define bool int\n#define false 0\n#define true 1\n\nint n;\nint x[111],y[111],r[111],c[111];\nbool used[111];\nchar mem[1<<24];\n\nbool judge(int i,int j){\n\tbool ok=true;\n\tint k;\n\trep(k,i){\n\t\tif(used[k])continue;\n\t\tif(pow(x[i]-x[k],2)+pow(y[i]-y[k],2)<pow(r[i]+r[k],2))ok=false;\n\t}\n\trep(k,j){\n\t\tif(used[k])continue;\n\t\tif(pow(x[k]-x[j],2)+pow(y[k]-y[j],2)<pow(r[k]+r[j],2))ok=false;\n\t}\n\treturn ok;\n}\n\nint dfs(int v){\n\tif(mem[v]!=-1)return mem[v];\n\tint res=0;\n\tint i,j;\n\trep(i,n)repl(j,i+1,n){\n\t\tif(!used[i]&&!used[j]&&c[i]==c[j]&&judge(i,j)){\n\t\t\tused[i]=used[j]=true;\n\t\t\tres=max(res,dfs(v|(1<<i)|(1<<j))+2);\n\t\t\tused[i]=used[j]=false;\n\t\t}\n\t}\n\treturn mem[v]=res;\n}\n\nint main(){\n\t//cin.sync_with_stdio(false);\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tint i;\n\t\trep(i,n)scanf(\"%d%d%d%d\",x+i,y+i,r+i,c+i);\n\t\tmemset(used,0,sizeof(used));\n\t\tmemset(mem,-1,sizeof(mem));\n\t\tprintf(\"%d\\n\", dfs(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_NUM 24\n\n#define SQUARE(x) ((x) * (x))\n#define MAX(x, y) ((x) > (y) ? (x) : (y))\n\nint n;\nint x[MAX_NUM];\nint y[MAX_NUM];\nint r[MAX_NUM];\nint c[MAX_NUM];\n\nint overlap[MAX_NUM];\n\n// bit\n// i番の円盤がない（取り除いた）とき、LSBから数えてi桁目を1とする\nchar maxRemovableNum[1 << MAX_NUM];\nbool isVisited[1 << MAX_NUM];\n\nvoid init()\n{\n\tint i;\n\tfor (i = 0; i < 1 << MAX_NUM; ++i)\n\t{\n\t\tmaxRemovableNum[i] = 0;\n\t\tisVisited[i] = false;\n\t}\n}\n\nbool overlapBetween(int a, int b) { return SQUARE(r[a] + r[b]) > SQUARE(x[a] - x[b]) + SQUARE(y[a] - y[b]); }\n\nbool exist(int a, long stateNumber) { return (stateNumber & 1L << a) == 0L; }\n\nbool isTop(int a, long stateNumber)\n{\n\tint i;\n\tfor (i = 0; i < a; ++i)\n\t{\n\t\tif (!exist(i, stateNumber)) { continue; }\n\t\tif (overlap[a] & 1 << i) { return false; }\n\t}\n\n\treturn true;\n}\n\nchar solve(long stateNumber)\n{\n\tif (isVisited[stateNumber]) { return maxRemovableNum[stateNumber]; }\n\n\tint i, j;\n\tfor (i = 0; i < n; ++i)\n\t{\n\t\tif (!exist(i, stateNumber) || !isTop(i, stateNumber)) { continue; }\n\n\t\tfor (j = i + 1; j < n; ++j)\n\t\t{\n\t\t\tif (!exist(j, stateNumber) || !isTop(j, stateNumber) || c[i] != c[j]) { continue; }\n\n\t\t\tmaxRemovableNum[stateNumber] = MAX(maxRemovableNum[stateNumber],\n\t\t\t                                   (char)(solve(stateNumber | 1 << i | 1 << j) + 2));\n\t\t}\n\t}\n\n\tisVisited[stateNumber] = true;\n\treturn maxRemovableNum[stateNumber];\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\t//region DataInput\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0) { break; }\n\n\t\tinit();\n\n\t\tint i, j;\n\t\tfor (i = 0; i < n; ++i)\n\t\t{\n\t\t\tscanf(\"%d %d %d %d\", &x[i], &y[i], &r[i], &c[i]);\n\n\t\t\toverlap[i] = 0;\n\t\t\tfor (j = 0; j < i; ++j)\n\t\t\t{\n\t\t\t\tif (overlapBetween(i, j)) { overlap[i] |= 1 << j; }\n\t\t\t}\n\t\t}\n\t\t//endregion\n\n\t\tprintf(\"%d\\n\", solve(0L));\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n\n#define N_BIT (1<<24)\n\n#define isDeleted(i,s) (s & (1<<i)) ? 1:0\n#define removeDisc(i,j,s) (s | (1<<i) | (1<<j))\n\n\ntypedef struct data{\n\tint x;\n\tint y;\n\tint r;\n\tint c;\n}disc;\n\nint n;\t\t\t\t//Disc????????°\nint max;\t\t//?????????????????°????????§???\nint dp[N_BIT];\t\t//??¶????????????????????¨??????????????¶????????¢?????¢?´¢????????§???????????????????????¨?????????\ndisc* d;\t\t\t//Disc???????´?????????????\n\n\ndouble discDistance(int i,int j){\t\t//i,j?????????Disc????????¢?????????\n\tdisc s = d[i];\n\tdisc t = d[j];\n\treturn sqrt((s.x-t.x)*(s.x-t.x) + (s.y-t.y)*(s.y-t.y));\n}\n\n/*\nint isDeleted(int i,int s){\t\t\t//??¶???s????????????i?????????Disc?????????????????§?????????\n\tint i_bit = 1 << i;\t\t\t\t//i?????????????????????1\n\treturn (s & i_bit) ? 1 : 0;\t\t\t//s???i?????????1??????1,0??????0?????????\n}\n*/\n\nint isRemovable(int i,int s){\t\t\t//??¶???s????????????i?????????Disc?????????????????§?????????\n\tint k;\n\tif(isDeleted(i,s)){\t\t\t//??¢?????????????????????0?????????\n\t\treturn 0;\n\t}\n\tfor(k=i-1;k>=0;k--){\n\t\tif(isDeleted(k,s)){\t\t//k???????????¢??????????????????????£???°???\n\t\t\tcontinue;\n\t\t}\n\t\tif(d[i].r + d[k].r > discDistance(i,k)){\t\t//?????¢?????¢???????????????\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint deletedDiscNumber(int s){\t\t//??¶???s???????????????????????????Disc????????°\n\tint cnt = 0;\n\twhile(s){\t\t//s=0??????????????§?????????\n\t\tif(s & 1){\t\t//s????????????????????????1\n\t\t\tcnt++;\t\t//????????????\n\t\t}\n\t\ts = s >> 1;\t\t//????????????(??????????????????????¶????)\n\t}\n\treturn cnt;\n}\n\n/*\nint removeDisc(int i,int j,int s){\t\t//i,j?????????Disc?????????????????¶???????????????????????????\n\tint i_bit = 1 << i;\t\t\t\t//i?????????????????????1\n\tint j_bit = 1 << j;\t\t\t\t//j?????????????????????1\n\treturn (s | i_bit | j_bit);\t\t\t//i,j?????????????????????1(????????????)?????????\n}\n*/\n\nvoid initDP(){\t\t//dp??????????????????\n\tint i;\n\tfor(i=0;i<N_BIT;i++){\n\t\tdp[i] = 0;\t\t\t//??¨????????¢?´¢??¨??????\n\t}\n}\n\n//??±???????????¢?´¢(?????¢????????°)\nvoid dfsearch(int s){\t\t//s?????¶????????????\n\tint i,j,deleted;\n\tif(dp[s] == 1){\t\t//??¶???s?????¢?????¢?´¢????????§????????°?¨?????????????\n\t\treturn;\n\t}else{\n\t\tdp[s] = 0;\t\t//??¢?´¢????????¨??????\n\t}\n\tdeleted = deletedDiscNumber(s);\t\t//??¶???s??§?????????????????????Disc?????°\n\tif(deleted > max){\n\t\tmax = deleted;\t\t\t//?????§????????´??°\n\t}\n\tif(n - max <= 1){\t\t//Disc?????????1?????\\?????????????????\\???????????????\n\t\treturn;\n\t}\n\tfor(i=0;i<n;i++){\n\t\tif(isRemovable(i,s)){\t\t//??¶???s????????????i?????????Disc???????????????Disc???????????£??????????????´???\n\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\tif(isRemovable(j,s) && d[i].c == d[j].c){\t//??¶???s????????????j?????????Disc???????????????Disc???????????£????????????,?????????j????????¨?????????????????´???\n\t\t\t\t\tdfsearch(removeDisc(i,j,s));\t\t//i,j?????????Disc????????????????????°\n\t\t\t\t\tif(n - max <= 1){\t\t//Disc?????????1?????\\?????????????????\\???????????????\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tint i;\n\tclock_t t1 = clock();\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\td = (disc*)malloc(n*sizeof(disc));\t\t//Disc?????????\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&d[i].x,&d[i].y,&d[i].r,&d[i].c);\n\t\t}\n\t\tmax = 0;\t\t//?????§???????????????\n\t\tinitDP();\t\t//??¢?´¢??????????????????\n\t\tdfsearch(0);\t//s=0:??¨??????Disc????????¨????????¶???\n\t\tprintf(\"%d\\n\",max);\n\t\tfree(d);\n\t}\n\tclock_t t2 = clock();\n\tprintf(\"%f\\n\",(double)(t2-t1)/CLOCKS_PER_SEC);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<studio.h>\n\nint main(void){\nreturn 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n\nint n;\nint circle[24][4];\nchar bitDP[(1<<24)]; // ??????????????????bit??§??????\nint overlap[24]; // ?????????????????????bit??§??????\n\nint main()\n{\n\tint i, j, bit;\n\tint next, ans;\n\t\n\twhile(scanf(\"%d\",&n) != EOF) {\n\t\tif(n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(i = 0; i < n; i++) {\n\t\t\tscanf(\"%d\",&circle[i][0]);\n\t\t\tscanf(\"%d\",&circle[i][1]);\n\t\t\tscanf(\"%d\",&circle[i][2]);\n\t\t\tscanf(\"%d\",&circle[i][3]);\n\t\t\t\n\t\t\toverlap[i] = 0;\n\t\t\tfor(j = 0; j < i; j++) {\n\t\t\t\tint distance_x = circle[i][0] - circle[j][0];\n\t\t\t\tint distance_y = circle[i][1] - circle[j][1];\n\t\t\t\tdouble distance_circle = sqrt(pow(distance_x, 2) + pow(distance_y, 2));\n\t\t\t\tif(circle[i][2] + circle[j][2] > distance_circle) {\n\t\t\t\t\toverlap[i] += (1 << j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(bitDP, -1, sizeof(bitDP));\n\t\tbitDP[0] = 0;\n\t\t\n\t\tans = 0;\n\t\tfor(bit = 0; bit < (1 << n); bit++) {\n\t\t\tif(bitDP[bit] == -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(ans < bitDP[next]) {\n\t\t\t\tans = bitDP[next];\n\t\t\t}\n\t\t\t\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tif(((1 << i) & bit) || !((overlap[i] & bit) == overlap[i])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(j = i+1; j < n; j++) {\n\t\t\t\t\tif(((1 << i) | (1 << j)) & bit) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(!((overlap[j] & bit) == overlap[j])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(circle[i][3] != circle[j][3]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tnext = (((1 << i) | (1 << j)) | bit);\n\t\t\t\t\tif(bitDP[next] < bitDP[bit] + 2) {\n\t\t\t\t\t\tbitDP[next] = bitDP[bit] + 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<string.h>\nconst double EPS = 0.1;\nint N,X[50],Y[50],R[50],C[50],i,j,f[50],F[30][30][30];\n\nint isOver(int a,int b)\n{\n\tdouble x=sqrt((double)(X[a]-X[b])*(X[a]-X[b])+(Y[a]-Y[b])*(Y[a]-Y[b])),y=R[a]+R[b];\n\tif(y>x)return 1;\n\treturn 0;\n}\n\nint ch(int n)\n{\n\tint i;\n\tfor(i=0;i<n;i++)\n\t\tif(i!=n&&!f[i]&&isOver(n,i))\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint dfs(int d)\n{\n\tint i,r=0,t,n;\n\tif(d==N)\n\t\treturn 0;\n\tfor(n=0;n<N;n++)\n\t{\n\t\tif(!f[n]&&ch(n))\n\t\t{\n\t\t\tfor(i=0;i<N;i++)\n\t\t\t\tif(!F[d][n][i]&&i!=n&&C[i]==C[n]&&!f[i]&&ch(i))\n\t\t\t\t{\n\t\t\t\t\tF[d][n][i]=1;\n\t\t\t\t\t//printf(\"%d %d\\n\",n,i);\n\t\t\t\t\tf[n]=f[i]=1;\n\t\t\t\t\tt=dfs(d+1)+2;\n\t\t\t\t\tr=r<t?t:r;\n\t\t\t\t\tf[n]=f[i]=0;\n\t\t\t\t}\n\t\t}\n\t}\n\treturn r;\n}\n\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tmemset(F,0,sizeof(F));\n\t\tfor(i=0;i<N;i++)\n\t\t\tscanf(\"%d%d%d%d\",&X[i],&Y[i],&R[i],&C[i]);\n\t\tprintf(\"%d\\n\",dfs(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1175: And Then. How Many Are There?\n// 2017.12.21 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\ntypedef struct { int x, y, r, c; } T;\nT d[25]; int n;\nchar rel[25][25];\t// rel[i][j]???1??¨????????????i???j??????????????£??????j?????????????????¶???\ntypedef struct { int n, id[25]; } S;\nS up[25];\t\t\t// ?????????????????????????????°??¨??????\nchar none[16];\nchar visited[16777216];\nint ans;\n\nvoid dfs(int s, int del, int m)\n{\n\tint i, j, k, a;\n\n\tif (m == 1) return;\n\tif (visited[s]) return;\n\tvisited[s] = 1;\n\tfor (i = 0; i < n; i++) {\n\t\tif (none[i]) continue;\n\t\tfor (k = 0; k < up[i].n; k++) {\n\t\t\ta = up[i].id[k];\n\t\t\tif (!none[a]) break;\n\t\t}\n\t\tif (k != up[i].n) continue;\n\n\t\tfor (j = i+1; j < n; j++) {\n\t\t\tif (none[j]) continue;\n\t\t\tif (d[j].c != d[i].c) continue;\n\t\t\tfor (k = 0; k < up[j].n; k++) {\n\t\t\t\ta = up[j].id[k];\n\t\t\t\tif (!none[a]) break;\n\t\t\t}\n\t\t\tif (k != up[j].n) continue;\n\n\t\t\tif (del+2 > ans) ans = del+2;\n\t\t\tnone[i] = none[j] = 1;\n\t\t\tdfs(s|(1<<i) | (1<<j), del+2, m-2);\n\t\t\tnone[i] = none[j] = 0;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i, j;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tfor (i = 0; i < n; i++) scanf(\"%d%d%d%d\", &d[i].x, &d[i].y, &d[i].r, &d[i].c);\n\t\tmemset(rel, 0, sizeof(rel));\n\t\tmemset(up, 0, sizeof(up));\n\t\tfor (i = 0; i < n; i++) for (j = i+1; j < n; j++) {\n\t\t\tif (hypot(d[i].x-d[j].x, d[i].y-d[j].y) < d[i].r+d[j].r) {\n\t\t\t\trel[i][j] = 1;\n\t\t\t\tup[j].id[up[j].n++] = i;\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\t\tmemset(none, 0, sizeof(none));\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tdfs(0, 0, n);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1175: And Then. How Many Are There?\n// 2017.12.21 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\ntypedef struct { int s, del, m; } Q;\nQ q[100000]; int top;\ntypedef struct { int x, y, r; } T;\nT d[25];\nint col[4][6], clen[4]; char f[5];\nint up[25][25], ulen[25];\t\t// ?????????????????????????????°??¨??????\nchar visited[16777216];\n\nint main()\n{\n\tint n, i, j, k, a, c, cmax, p, r, s, del, m, ans;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tmemset(clen, 0, sizeof(clen)), memset(f, -1, sizeof(f)), cmax = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &d[i].x, &d[i].y, &d[i].r, &c);\n\t\t\tif  (f[c] >= 0)          c = f[c];\n\t\t\telse f[c] = cmax++, c = cmax-1;\n\n\t\t\tcol[c][clen[c]++] = i;\n\t\t}\n\n\t\tmemset(ulen, 0, sizeof(ulen));\n\t\tfor (i = 0; i < n; i++) for (j = i+1; j < n; j++) {\n\t\t\tif (hypot(d[i].x-d[j].x, d[i].y-d[j].y) < d[i].r+d[j].r) up[j][ulen[j]++] = i;\n\t\t}\n\n\t\tans = 0;\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tq[0].s = 0, q[0].del = 0, q[0].m = n, top = 1;\n\t\twhile (top) {\n\t\t\ts = q[--top].s, del = q[top].del, m = q[top].m;\n\n\t\t\tif (m == 1 || visited[s]) continue;\n\t\t\tvisited[s] = 1;\n\t\t\tfor (c = 0; c < cmax; c++)if (clen[c] >= 2) for (p = 0; p < clen[c]; p++) {\n\t\t\t\ti = col[c][p];\n\t\t\t\tif (s & (1<<i)) continue;\n\t\t\t\tfor (k = 0; k < ulen[i]; k++) {\n\t\t\t\t\ta = up[i][k];\n\t\t\t\t\tif (!(s & (1<<a))) goto next;\n\t\t\t\t}\n\n\t\t\t\tfor (r = p+1; r < clen[c]; r++) {\n\t\t\t\t\tif (r == p) continue;\n\t\t\t\t\tj = col[c][r];\n\t\t\t\t\tif (s & (1<<j)) continue;\n\t\t\t\t\tfor (k = 0; ; k++) {\n\t\t\t\t\t\tif (k == ulen[j]) {\n\t\t\t\t\t\t\tif (del+2 > ans) ans = del+2;\n\t\t\t\t\t\t\tq[top].s = s|(1<<i) | (1<<j), q[top].del = del+2, q[top++].m = m-2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ta = up[j][k];\n\t\t\t\t\t\tif (!(s & (1<<a))) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnext:;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<string.h>\nconst double EPS = 0.1;\nint N,X[50],Y[50],R[50],C[50],i,j,f[50];\n\nint isOver(int a,int b)\n{\n\tdouble x=sqrt((double)(X[a]-X[b])*(X[a]-X[b])+(Y[a]-Y[b])*(Y[a]-Y[b])),y=R[a]+R[b];\n\tif(y>x)return 1;\n\treturn 0;\n}\n\nint ch(int n)\n{\n\tint i;\n\tfor(i=0;i<n;i++)\n\t\tif(i!=n&&!f[i]&&isOver(n,i))\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint dfs(int d)\n{\n\tint i,r=0,t,n;\n\tif(d==N)\n\t\treturn 0;\n\tfor(n=0;n<N;n++)\n\t{\n\t\tif(!f[n]&&ch(n))\n\t\t{\n\t\t\tfor(i=0;i<N;i++)\n\t\t\t\tif(i!=n&&C[i]==C[n]&&!f[i]&&ch(i))\n\t\t\t\t{\n\t\t\t\t\tf[n]=f[i]=1;\n\t\t\t\t\tt=dfs(d+1)+2;\n\t\t\t\t\tr=r<t?t:r;\n\t\t\t\t\tf[n]=f[i]=0;\n\t\t\t\t}\n\t\t}\n\t}\n\treturn r;\n}\n\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(i=0;i<N;i++)\n\t\t\tscanf(\"%d%d%d%d\",&X[i],&Y[i],&R[i],&C[i]);\n\t\tprintf(\"%d\\n\",dfs(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<string.h>\nconst double EPS = 0.000001;\nint N,X[50],Y[50],R[50],C[50],i,j,f[50];\n\nint isOver(int a,int b)\n{\n\tdouble x=sqrt((double)(X[a]-X[b])*(X[a]-X[b])+(Y[a]-Y[b])*(Y[a]-Y[b])),y=R[a]+R[b];\n\tif(y>x)return 1;\n\treturn 0;\n}\n\nint ch(int n)\n{\n\tint i;\n\tfor(i=0;i<n;i++)\n\t\tif(!f[i]&&isOver(n,i))\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint dfs(int n)\n{\n\tint i,r=0,t;\n\tif(n==N)return 0;\n\tif(!f[n]&&ch(n))\n\t{\n\t\tfor(i=0;i<N;i++)\n\t\t\tif(i!=n&&C[i]==C[n]&&!f[i]&&ch(i))\n\t\t\t{\n\t\t\t\tf[n]=f[i]=1;\n\t\t\t\tt=dfs(n+1)+2;\n\t\t\t\tr=r<t?t:r;\n\t\t\t}\n\t}\n\tt=dfs(n+1);\n\tr=r<t?t:r;\n\treturn r;\n}\n\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(i=0;i<N;i++)\n\t\t\tscanf(\"%d%d%d%d\",&X[i],&Y[i],&R[i],&C[i]);\n\t\tprintf(\"%d\\n\",dfs(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n\n#define N_BIT (1<<24)\n#define N 24\n\n#define isDeleted(i,s) (s & (1<<i)) ? 1:0\n#define removeDisc(i,j,s) (s | (1<<i) | (1<<j))\n#define max(x,y) (x>y) ? x:y\n\nint x[N],y[N],r[N],c[N],st[N];\n\nint n;\t\t\t\t//Disc????????°\nchar dp[N_BIT];\t\t//????????¶????????????????????????????????°????????§??????????´?????????????(?????¢?´¢?????´??????-1)\n\n\nint isRemovable(int i,int j,int s){\t\t\t//??¶???s????????????i?????????Disc?????????????????§?????????\n\tint k;\n\tfor(k=i-1;k>=0;k--){\n\t\tif(st[k]){\t\t//k???????????¢??????????????????????£???°???\n\t\t\tcontinue;\n\t\t}\n\t\tif((r[i]+r[k])*(r[i]+r[k]) > (x[i]-x[k])*(x[i]-x[k])+(y[i]-y[k])*(y[i]-y[k])){\t\t//?????¢?????¢???????????????\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(k=j-1;k>=0;k--){\n\t\tif(st[k]){\t\t//k???????????¢??????????????????????£???°???\n\t\t\tcontinue;\n\t\t}\n\t\tif((r[j]+r[k])*(r[j]+r[k]) > (x[j]-x[k])*(x[j]-x[k])+(y[j]-y[k])*(y[j]-y[k])){\t\t//?????¢?????¢???????????????\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n//??±???????????¢?´¢(?????¢????????°)\nint dfsearch(int s){\t\t//s?????¶????????????\n\tif(dp[s] != -1){\t\t//??¶???s?????¢?????¢?´¢????????§????????°?¨?????????????\n\t\treturn dp[s];\n\t}\n\tint i,j,value=0;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=i+1;j<n;j++){\n\t\t\t//??¶???s????????????i,j?????????Disc???????????????Disc???????????£????????????,??????????????§??????,?????????i,j??????????????????????????´???\n\t\t\tif(isRemovable(i,j,s) && !st[i] && !st[j] && c[i] == c[j]){\n\t\t\t\tst[i] = st[j] = 1;\n\t\t\t\tvalue = max(value,dfsearch(removeDisc(i,j,s))+2);\t\t//i,j???2???????????? + i,j????????????????????\\?????§????????§????????¢?´¢??§?±???????\n\t\t\t\tst[i] = st[j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[s] = value;\n}\n\nint main(void){\n\tint i;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&x[i],&y[i],&r[i],&c[i]);\n\t\t\tst[i] = 0;\n\t\t}\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tprintf(\"%d\\n\",dfsearch(0));\t\t//s=0:??¨??????Disc????????¨????????¶???\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define REP(i, a, n) for(i = (a); i < (n); i++)\n\nint N, X[24], Y[24], R[24], C[24];\nint r[24], m[24];\nchar dp[16777216];\n\nint f(char n, int s) { return ((s & r[n]) & m[n]) == 0; }\nchar max(char a, char b) { return a > b ? a : b; }\n\nchar dfs(int s, char n) {\n  if(n == N) return N;\n\n  char ret = n;\n  int i, j;\n  REP(i, 0, N) {\n    int mi = (1 << i);\n    if((~s & mi) || !f(i, s)) continue;\n    REP(j, i + 1, N) {\n      int mj = (1 << j);\n      if(C[i] != C[j] || (~s & mj) || !f(j, s)) continue;\n      int ns = ~(~s | mi | mj);\n      if(dp[ns] >= 0) continue;\n      ret = max(ret, dfs(ns, n + 2));\n    }\n  }\n\n  return dp[s] = ret;\n}\n\nint main(void) {\n  int i, j;\n  m[0] = 0;\n  REP(i, 0, 23) m[i + 1] = m[i] | (1 << i);\n  while(scanf(\"%d\", &N), N) {\n    REP(i, 0, N) scanf(\"%d %d %d %d\", X + i, Y + i, R + i, C + i);\n    REP(i, 0, pow(2, N)) dp[i] = -1;\n    REP(i, 0, N) r[i] = 0;\n    REP(i, 0, N) REP(j, 0, N) {\n      if(pow(R[i] + R[j], 2) > pow(X[i] - X[j], 2) + pow(Y[i] - Y[j], 2)) {\n        r[i] = r[i] | (1 << j);\n        r[j] = r[j] | (1 << i);\n      }\n    }\n    printf(\"%d\\n\", dfs((1 << N) - 1, 0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<string.h>\nint N,X[50],Y[50],R[50],C[50],i,j,f[50];\n\nint isOver(int a,int b)\n{\n\tdouble x=sqrt((double)(X[a]-X[b])*(X[a]-X[b])+(Y[a]-Y[b])*(Y[a]-Y[b])),y=R[a]+R[b];\n\tif(y>x)return 1;\n\treturn 0;\n}\n\nint ch(int n)\n{\n\tint i;\n\tfor(i=0;i<n;i++)\n\t\tif(!f[i]&&isOver(n,i))\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint dfs(int n)\n{\n\tint i,r=0,t;\n\tif(n==N)return 0;\n\tif(!f[n])\n\t{\n\t\tfor(i=0;i<N;i++)\n\t\t\tif(i!=n&&C[i]==C[n]&&!f[i]&&ch(i))\n\t\t\t{\n\t\t\t\tf[n]=f[i]=1;\n\t\t\t\tt=dfs(n+1)+2;\n\t\t\t\tr=r<t?t:r;\n\t\t\t}\n\t}\n\telse\n\t\tr=dfs(n+1);\n\treturn r;\n}\n\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(i=0;i<N;i++)\n\t\t\tscanf(\"%d%d%d%d\",&X[i],&Y[i],&R[i],&C[i]);\n\t\tprintf(\"%d\\n\",dfs(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define N 24\n#define SQ(X) \\\n  ( (int)(X) * (int)(X) )\n#define MAX(A,B) \\\n  ( (A) > (B) ? (A) : (B) )\n\nstatic unsigned char x[ N ];\nstatic unsigned char y[ N ];\nstatic unsigned char r[ N ];\nstatic unsigned char c[ N ];\nstatic int           n;\n\nstatic signed char k_operafan[ 1 << N ];\n\nstatic signed char\ndpFSA (\n  const unsigned int rq\n  )\n{\n  int i, j, k;\n\n  if ( ~k_operafan[ rq ] )\n  {\n    printf ( \"==>%u\\n\", ~k_operafan[ rq ] );\n  }\n  if ( ~k_operafan[ rq ] ) ;\n  else\n  {\n    k_operafan[ rq ] = 0;\n\n    for ( i = 0; i < n; ++i )\n    {\n      if ( !( rq & ( 1 << i ) ) ) continue ;\n      for ( j = i + 1; j < n; ++j )\n      {\n        if ( !( rq & ( 1 << j ) ) ) continue ;\n        if ( c[ i ] != c[ j ] )     continue ;\n\n        for ( k = 0; k < j; ++k )\n        {\n          if ( !( rq & ( 1 << k ) ) ) continue ;\n          if ( SQ( x[ k ] - x[ j ] ) + SQ( y[ k ] - y[ j ] )\n             < SQ( r[ k ] + r[ j ] ) ) break ;\n          if ( k < i\n            && SQ( x[ k ] - x[ i ] ) + SQ( y[ k ] - y[ i ] )\n             < SQ( r[ k ] + r[ i ] ) ) break ;\n        }\n        if ( k == j )\n        {\n          const unsigned char res\n            = dpFSA ( rq & ~( 1 << i ) & ~( 1 << j ) ) + 2;\n\n          k_operafan[ rq ] = MAX( k_operafan[ rq ], res );\n        }\n      }\n    }\n  }\n\n  return ( k_operafan[ rq ] );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    scanf ( \"%d\", &n );\n    if ( !( n ) ) break ;\n\n    for ( i = 0; i < n; ++i )\n    {\n      unsigned int tx, ty, tr, tc;\n\n      scanf ( \"%u%u%u%u\", &tx, &ty, &tr, &tc );\n      x[ i ] = tx; y[ i ] = ty; r[ i ] = tr; c[ i ] = tc;\n    }\n\n    memset ( k_operafan, -1, sizeof ( k_operafan ) );\n    printf ( \"%d\\n\", dpFSA ( ( 1 << n ) - 1 ) );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n\nint n;\nint circle[24][4];\nint bitDP[(1<<24)]; // ??????????????????bit??§??????\nint overlap[24]; // ?????????????????????bit??§??????\n\nint main()\n{\n\tint i, j, bit;\n\tint next, ans;\n\t\n\twhile(scanf(\"%d\",&n) != EOF) {\n\t\tif(n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(i = 0; i < n; i++) {\n\t\t\tscanf(\"%d\",&circle[i][0]);\n\t\t\tscanf(\"%d\",&circle[i][1]);\n\t\t\tscanf(\"%d\",&circle[i][2]);\n\t\t\tscanf(\"%d\",&circle[i][3]);\n\t\t\t\n\t\t\toverlap[i] = 0;\n\t\t\tfor(j = 0; j < i; j++) {\n\t\t\t\tint distance_x = circle[i][0] - circle[j][0];\n\t\t\t\tint distance_y = circle[i][1] - circle[j][1];\n\t\t\t\tdouble distance_circle = sqrt(pow(distance_x, 2) + pow(distance_y, 2));\n\t\t\t\tif(circle[i][2] + circle[j][2] > distance_circle) {\n\t\t\t\t\toverlap[i] += (1 << j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(bitDP, 0, sizeof(bitDP));\n\t\t\n\t\tans = 0;\n\t\tfor(bit = 0; bit < (1 << n); bit++) {\n\t\t\tif(bit != 0 && bitDP[bit] == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(ans < bitDP[next]) {\n\t\t\t\tans = bitDP[next];\n\t\t\t}\n\t\t\t\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tif(((1 << i) & bit) || !((overlap[i] & bit) == overlap[i])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(j = i+1; j < n; j++) {\n\t\t\t\t\tif(((1 << i) | (1 << j)) & bit) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(!((overlap[j] & bit) == overlap[j])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(circle[i][3] != circle[j][3]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tnext = (((1 << i) | (1 << j)) | bit);\n\t\t\t\t\tif(bitDP[next] < bitDP[bit] + 2) {\n\t\t\t\t\t\tbitDP[next] = bitDP[bit] + 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n  double x;\n  double y;\n  double r;\n  int c;\n  int under;\n} circle;\n// distance between (x1,y1) and (x2,y2)\ndouble cdis(double x1, double y1, double x2, double y2) {\n  return sqrtl((x1 - x2) * (x1 - x2) +\n               (y1 - y2) * (y1 - y2));\n}\nint max(int x, int y) {\n  if(x > y)\n    return x;\n  else\n    return y;\n}\n\ncircle data[30];\ncircle zero;\n// removed?\nint check[100000000] = {0};\nint cntc[4] = {0};\nint cdata[4][10] = {0};\nint n;\n\nvoid memoset();\nint solve(int now);\n\nint main() {\n  int i, j;\n  zero.x = zero.y = zero.r = 0.0;\n  zero.under = zero.c = 0;\n  while(1) {\n    scanf(\"%d\", &n);\n    if(n == 0) break;\n    for(i = 0; i < 4; ++i)\n      for(j = 0; j < 6; ++j) cdata[i][j] = -1;\n    for(i = 0; i < 4; ++i) cntc[i] = 0;\n    for(i = 0; i < (1 << n); ++i) check[i] = -1;\n    for(i = 0; i < n; ++i) data[i] = zero;\n    for(i = 0; i < n; ++i) {\n      scanf(\"%lf %lf %lf %d\", &data[i].x, &data[i].y,\n            &data[i].r, &data[i].c);\n      --data[i].c;\n      cdata[data[i].c][cntc[data[i].c]] = i;\n      ++cntc[data[i].c];\n    }\n    memoset();\n    printf(\"%d\\n\", solve(0));\n  }\n  return 0;\n}\n\nvoid memoset() {\n  int i, j;\n  for(i = 0; i < n; ++i)\n    for(j = i + 1; j < n; ++j) {\n      double rsum = data[i].r + data[j].r;\n      if(rsum >\n         cdis(data[i].x, data[i].y, data[j].x, data[j].y))\n        data[j].under += (1 << i);\n    }\n}\nint solve(int now) {\n  if(check[now] != -1) return check[now];\n  int ans = 0, next = 0, i, j, k;\n  for(i = 0; i < 4; ++i) {\n    for(j = 0; j < cntc[i]; ++j)\n      for(k = 0; k < cntc[i]; ++k) {\n        next = now;\n        int nx = cdata[i][j], ny = cdata[i][k];\n        if(j != k && ((1 << nx) & now) != (1 << nx) &&\n           ((1 << ny) & now) != (1 << ny) &&\n           ((data[nx].under & now) == data[nx].under) &&\n           ((data[ny].under & now) == data[ny].under)) {\n          next += (1 << nx) + (1 << ny);\n          ans = max(ans, solve(next) + 2);\n        }\n      }\n  }\n  check[now] = ans;\n  return ans;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<fstream>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<iomanip>\n#include<ctime>\n#include<cstring>\n#include<climits>\n#include<string>\n#include<vector>\n#include<map>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<stack>\n#include<deque>\n#include<list>\n#include<vector>\n#define LL long long\n/*\n#ifdef unix\n#define INT64 \"%lld\"\n#else\n#define INT64 \"%I64d\"\n#endif\n*/\nusing namespace std;\nint n,m,cnt,snt,K,times;\nLL oo=1000000007;\nstruct dic\n{\n\tint x,y,r;\n\tint c;\n}p[110];\nint num[110];\nint ans;\nbool vis[110];\nbool f[16777216];\nint dis(int x1,int y1,int x2,int y2)\n{\n\treturn (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n}\nbool cover(int pos,int state)\n{\n\tfor (int i=1;i<pos;i++)\n\tif (((state>>(i-1))&1)&&dis(p[i].x,p[i].y,p[pos].x,p[pos].y)<(p[i].r+p[pos].r)*(p[i].r+p[pos].r)) \n\treturn true;\n\treturn false;\n}\nvoid dp(int state)\n{\n\tint sum=0;\n\tfor (int i=0;i<n;i++) if ((state>>i)&1) sum++;\n\tans=max(ans,n-sum);\n\tif (f[state]) return;\n\tf[state]=true;\n\tfor (int i=1;i<=n;i++)\n\tif (((state>>(i-1))&1)&&!cover(i,state))\n\tfor (int j=i+1;j<=n;j++)\n\tif (((state>>(j-1))&1)&&p[i].c==p[j].c&&!cover(j,state))\n\t{\n\t\tint tstate=state^(1<<(i-1))^(1<<(j-1));\n\t\tdp(tstate);\n\t}\n}\nvoid work()\n{\n\tmemset(p,0,sizeof(p));\n\tfor (int i=1;i<=n;i++)\n\tscanf(\"%d%d%d%d\",&p[i].x,&p[i].y,&p[i].r,&p[i].c);\n\tans=0;\n\tmemset(f,0,sizeof(f));\n\tdp((1<<n)-1);\n\tprintf(\"%d\\n\",ans);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\twhile (n!=0)\n\t{\n\t\twork();\n\t\tscanf(\"%d\",&n);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#include<string.h>\n#define max(x,y) ((x)<(y)?(y):(x))\n#define REP(i,j,n) for(int i=(j);(i)<(n);(i)++)\n#define rep(i,n) for(int i=0;(i)<(n);(i)++)\nint n;\nint x[25],y[25],c[25],r[25];\nint b[25];\nchar dp[1<<24];\nint power(int x,int n){\n    int ans=1;\n    rep(i,n) ans*=x;\n    return ans;\n}\nint intersects(int i,int j){\n    int dist1=power(x[i]-x[j],2)+power(y[i]-y[j],2);\n    int dist2=power(r[i]+r[j],2);\n    return dist2 > dist1;\n}\nint main(){\n    int n;\n    while(1){\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        rep(i,n){\n            scanf(\"%d%d%d%d\",&x[i],&y[i],&r[i],&c[i]);\n            b[i]=0;\n            rep(j,i) if(intersects(i,j)) b[i]|=(1<<j);\n        }\n        int ans=0;\n        int to=(1<<n);\n        memset(dp,-1,sizeof(dp));\n        dp[0]=0;\n        rep(i,to){\n            if(dp[i]==-1) continue;\n            ans=max(ans,(int)dp[i]);\n            //消せる円盤のペア(j,k)を探す\n            rep(j,n-1){\n                //すでに円盤jは消えている or 円盤jの上の円盤が邪魔して消せない\n                if((i & (1<<j)) != 0 || (i & b[j]) != b[j]) continue;\n                \n                for(int k=j+1;k<n;k++){\n                    //jとkの色が違う or すでに円盤kは消えている or 円盤kの上の円盤が邪魔\n                    if(c[j] != c[k] || (i & (1<<k)) != 0 || (i & b[k]) != b[k]) continue;\n                    //next = 円盤jとkを消した状態(ビット管理)\n                    int next = i | (1<<j) | (1<<k);\n                    dp[next] = max((int)dp[next],dp[i]+2);\n                }\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define N 24\n#define SQ(X) \\\n  ( (int)(X) * (int)(X) )\n#define MAX(A,B) \\\n  ( (A) > (B) ? (A) : (B) )\n\nstatic unsigned char x[ N ];\nstatic unsigned char y[ N ];\nstatic unsigned char r[ N ];\nstatic unsigned char c[ N ];\nstatic int           n;\n\nstatic signed char k_operafan[ 1 << N ];\n\nstatic signed char\ndpFSA (\n  const unsigned int rq\n  )\n{\n  int i, j, k;\n\n  if ( ~k_operafan[ rq ] ) ;\n  else\n  {\n    k_operafan[ rq ] = 0;\n\n    for ( i = 0; i < n; ++i )\n    {\n      if ( !( rq & ( 1 << i ) ) ) continue ;\n      for ( j = i + 1; j < n; ++j )\n      {\n        if ( !( rq & ( 1 << j ) ) ) continue ;\n        if ( c[ i ] != c[ j ] )     continue ;\n\n        for ( k = 0; k < j; ++k )\n        {\n          if ( !( rq & ( 1 << k ) ) ) continue ;\n          if ( SQ( x[ k ] - x[ j ] ) + SQ( y[ k ] - y[ j ] )\n             < SQ( r[ k ] + r[ j ] ) ) break ;\n          if ( k < i\n            && SQ( x[ k ] - x[ i ] ) + SQ( y[ k ] - y[ i ] )\n             < SQ( r[ k ] + r[ i ] ) ) break ;\n        }\n        if ( k == j )\n        {\n          const unsigned char res\n            = dpFSA ( rq & ~( 1 << i ) & ~( 1 << j ) ) + 2;\n\n          k_operafan[ rq ] = MAX( k_operafan[ rq ], res );\n        }\n      }\n    }\n  }\n\n  return ( k_operafan[ rq ] );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    scanf ( \"%d\", &n );\n    if ( !( n ) ) break ;\n\n    for ( i = 0; i < n; ++i )\n    {\n      unsigned int tx, ty, tr, tc;\n\n      scanf ( \"%u%u%u%u\", &tx, &ty, &tr, &tc );\n      x[ i ] = tx; y[ i ] = ty; r[ i ] = tr; c[ i ] = tc;\n    }\n\n    memset ( k_operafan, -1, sizeof ( k_operafan ) );\n    printf ( \"%d\\n\", dpFSA ( ( 1 << n ) - 1 ) );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nstruct A {\n    int x;\n    int y;\n    int r;\n    int c;\n}a[30];\nchar dp[1<<25];\nint n;\ninline bool cover(int qq,int x) {\n    int tmp,i;\n    for(i=qq-1;i>=0;i--) {\n        if(((x>>i)&1)==0) continue;\n        tmp=(a[qq].x-a[i].x)*(a[qq].x-a[i].x)+(a[qq].y-a[i].y)*(a[qq].y-a[i].y);\n        if((a[qq].r+a[i].r)*(a[qq].r+a[i].r)>tmp) break;\n    }\n    return i!=-1;\n}\nchar maxnum(char x) {\n    if(dp[x]!=-1) return dp[x];\n    int i,j,k,tmp;\n    char ans=0,y;\n    for(i=0;i<n;i++) {\n        if(((x>>i)&1)==0) continue;\n        if(cover(i,x)) continue;\n        for(j=i+1;j<n;j++) {\n            if(((x>>j)&1)==0) continue;\n            if(a[i].c!=a[j].c) continue;\n            if(cover(j,x)) continue;\n            y=x-(1<<i)-(1<<j);\n            tmp=maxnum(y)+2;\n            if(ans<tmp) ans=tmp;\n        }\n    }\n    dp[x]=ans;\n    return ans;\n}\nint main() {\n    int i;\n    while(scanf(\"%d\",&n),n) {\n        for(i=0;i<n;i++) {\n            scanf(\"%d %d %d %d\",&a[i].x,&a[i].y,&a[i].r,&a[i].c);\n            dp[1<<i]=0;\n        }\n        for(i=0;i<(1<<n);i++)\n            dp[i]=-1;\n        dp[0]=0;\n        printf(\"%d\\n\",maxnum((1<<n)-1));\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<string.h>\nconst double EPS = 0.1;\nint N,X[50],Y[50],R[50],C[50],i,j;\nchar dp[1<<25];\n\nint isOver(int a,int b)\n{\n\tdouble x=sqrt((double)(X[a]-X[b])*(X[a]-X[b])+(Y[a]-Y[b])*(Y[a]-Y[b])),y=R[a]+R[b];\n\tif(y>x)return 1;\n\treturn 0;\n}\n\nint ch(int n,int f)\n{\n\tint i;\n\tfor(i=0;i<n;i++)\n\t\tif(i!=n&&!((f>>i)&1)&&isOver(i,n))\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint dfs(int d,int f)\n{\n\tint i,r=0,t,n;\n\tif(dp[f]!=-1)return dp[f];\n\tif(d==N)\n\t\treturn 0;\n\tfor(n=0;n<N;n++)\n\t{\n\t\tif(!((f>>n)&1)&&ch(n,f))\n\t\t{\n\t\t\tfor(i=0;i<N;i++)\n\t\t\t\tif(i!=n&&C[i]==C[n]&&!((f>>i)&1)&&ch(i,f))\n\t\t\t\t{\n\t\t\t\t\tf^=(1<<i);\n\t\t\t\t\tf^=(1<<n);\n\t\t\t\t\tt=dfs(d+1,f)+2;\n\t\t\t\t\tr=r<t?t:r;\n\t\t\t\t\tf^=(1<<i);\n\t\t\t\t\tf^=(1<<n);\n\t\t\t\t}\n\t\t}\n\t}\n\treturn dp[f]=r;\n}\n\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(i=0;i<N;i++)\n\t\t\tscanf(\"%d%d%d%d\",&X[i],&Y[i],&R[i],&C[i]);\n\t\tprintf(\"%d\\n\",dfs(0,0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1175: And Then. How Many Are There?\n// 2017.12.21 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\ntypedef struct { int x, y, r, c; } T;\nT d[25]; int n;\n\nchar rel[25][25];\t// rel[i][j]???1??¨????????????i???j??????????????£??????j?????????????????¶???\ntypedef struct { int n, id[25]; } S;\nS up[25];\t\t\t// ?????????????????????????????°??¨??????\nchar none[16];\nint ans;\n\nvoid dfs(int del, int m)\n{\n\tint i, j, k, a;\n\n\tif (m == 1) return;\n\tfor (i = 0; i < n; i++) {\n\t\tif (none[i]) continue;\n\t\tfor (k = 0; k < up[i].n; k++) {\n\t\t\ta = up[i].id[k];\n\t\t\tif (!none[a]) break;\n\t\t}\n\t\tif (k != up[i].n) continue;\n\n\t\tfor (j = i+1; j < n; j++) {\n\t\t\tif (none[j]) continue;\n\t\t\tfor (k = 0; k < up[j].n; k++) {\n\t\t\t\ta = up[j].id[k];\n\t\t\t\tif (!none[a]) break;\n\t\t\t}\n\t\t\tif (k != up[j].n) continue;\n\n\t\t\tif (d[i].c == d[j].c) {\n\t\t\t\tif (del+2 > ans) ans = del+2;\n\t\t\t\tnone[i] = none[j] = 1;\n\t\t\t\tdfs(del+2, m-2);\n\t\t\t\tnone[i] = none[j] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i, j;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &d[i].x, &d[i].y, &d[i].r, &d[i].c);\n\t\t}\n\t\tmemset(rel, 0, sizeof(rel));\n\t\tmemset(up, 0, sizeof(up));\n\t\tfor (i = 0; i < n; i++) for (j = i+1; j < n; j++) {\n\t\t\tif (hypot(d[i].x-d[j].x, d[i].y-d[j].y) < d[i].r+d[j].r) {\n\t\t\t\trel[i][j] = 1;\n\t\t\t\tup[j].id[up[j].n++] = i;\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\t\tmemset(none, 0, sizeof(none));\n\t\tdfs(0, n);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1175: And Then. How Many Are There?\n// 2017.12.21 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int s, del, m; } Q;\nQ q[1000]; int top;\ntypedef struct { int x, y, r; } T;\nT d[25];\nint col[4][6], clen[4]; char f[5];\nint up[25][25], ulen[25];\t\t// ?????????????????????????????°??¨??????\nchar visited[16777216];\n\nint main()\n{\n\tint n, i, j, k, a, c, cmax, l, p, r, s, del, m, ans;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tmemset(clen, 0, sizeof(clen)), memset(f, -1, sizeof(f)), cmax = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &d[i].x, &d[i].y, &d[i].r, &c);\n\t\t\tif  (f[c] >= 0)     c = f[c];\n\t\t\telse f[c] = cmax++, c = cmax-1;\n\t\t\tcol[c][clen[c]++] = i;\n\t\t}\n\n\t\tmemset(ulen, 0, sizeof(ulen));\n\t\tfor (i = 0; i < n; i++) for (j = i+1; j < n; j++) {\n\t\t\tint dx = d[i].x - d[j].x, dy = d[i].y - d[j].y, rr = d[i].r+d[j].r;\n\t\t\tif (dx*dx + dy*dy < rr*rr) up[j][ulen[j]++] = i;\n\t\t}\n\n\t\tans = 0;\n\t\tmemset(visited, 0, 1 << n);\n\t\tq[0].s = 0, q[0].del = 0, q[0].m = n, top = 1;\n\t\twhile (top) {\n\t\t\ts = q[--top].s, del = q[top].del, m = q[top].m;\n\t\t\tif (m <= 1) break;\n\t\t\tif (visited[s]) continue;\n\t\t\tvisited[s] = 1;\n\t\t\tfor (c = 0; c < cmax; c++)if ((l = clen[c]) >= 2) for (p = 0; p < l; p++) {\n\t\t\t\ti = col[c][p];\n\t\t\t\tif (s & (1<<i)) continue;\n\t\t\t\tfor (k = 0; k < ulen[i]; k++) {\n\t\t\t\t\ta = up[i][k];\n\t\t\t\t\tif (!(s & (1<<a))) goto next;\n\t\t\t\t}\n\n\t\t\t\tfor (r = p+1; r < l; r++) {\n\t\t\t\t\tj = col[c][r];\n\t\t\t\t\tif (s & (1<<j)) continue;\n\t\t\t\t\tfor (k = 0; ; k++) {\n\t\t\t\t\t\tif (k == ulen[j]) {\n\t\t\t\t\t\t\tif (del+2 > ans) ans = del+2;\n\t\t\t\t\t\t\tq[top].s = s|(1<<i) | (1<<j), q[top].del = del+2, q[top++].m = m-2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ta = up[j][k];\n\t\t\t\t\t\tif (!(s & (1<<a))) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnext:;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n\n#define N_BIT (1<<24)\n\n#define isDeleted(i,s) (s & (1<<i)) ? 1:0\n#define removeDisc(i,j,s) (s | (1<<i) | (1<<j))\n#define max(x,y) (x>y) ? x:y\n\n\ntypedef struct data{\n\tint x;\n\tint y;\n\tint r;\n\tint c;\n\tint st;\t\t//??????????????????1,????????§???????????°0\n}disc;\n\nint n;\t\t\t\t//Disc????????°\nchar dp[N_BIT];\t\t//????????¶????????????????????????????????°????????§??????????´?????????????(?????¢?´¢?????´??????-1)\ndisc* d;\t\t\t//Disc???????´?????????????\n\n\ndouble discDistance(int i,int j){\t\t//i,j?????????Disc????????¢?????????\n\tdisc s = d[i];\n\tdisc t = d[j];\n\treturn ((s.x-t.x)*(s.x-t.x) + (s.y-t.y)*(s.y-t.y));\n}\n\nint isRemovable(int i,int j,int s){\t\t\t//??¶???s????????????i?????????Disc?????????????????§?????????\n\tint k;\n\tfor(k=i-1;k>=0;k--){\n\t\tif(d[k].st){\t\t//k???????????¢??????????????????????£???°???\n\t\t\tcontinue;\n\t\t}\n\t\tif((d[i].r + d[k].r)*(d[i].r + d[k].r) > discDistance(i,k)){\t\t//?????¢?????¢???????????????\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(k=j-1;k>=0;k--){\n\t\tif(d[k].st){\t\t//k???????????¢??????????????????????£???°???\n\t\t\tcontinue;\n\t\t}\n\t\tif((d[j].r + d[k].r)*(d[j].r + d[k].r) > discDistance(j,k)){\t\t//?????¢?????¢???????????????\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid initDP(){\t\t//dp??????????????????\n\tint i;\n\tfor(i=0;i<N_BIT;i++){\n\t\tdp[i] = -1;\t\t\t//??¨????????¢?´¢??¨??????\n\t}\n}\n\n//??±???????????¢?´¢(?????¢????????°)\nint dfsearch(int s){\t\t//s?????¶????????????\n\tif(dp[s] != -1){\t\t//??¶???s?????¢?????¢?´¢????????§????????°?¨?????????????\n\t\treturn dp[s];\n\t}\n\tint i,j,value=0;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=i+1;j<n;j++){\n\t\t\t//??¶???s????????????i,j?????????Disc???????????????Disc???????????£????????????,??????????????§??????,?????????i,j??????????????????????????´???\n\t\t\tif(isRemovable(i,j,s) && !d[i].st && !d[j].st && d[i].c == d[j].c){\n\t\t\t\td[i].st = d[j].st = 1;\n\t\t\t\tvalue = max(value,dfsearch(removeDisc(i,j,s))+2);\t\t//i,j???2???????????? + i,j????????????????????\\?????§????????§????????¢?´¢??§?±???????\n\t\t\t\td[i].st = d[j].st = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[s] = value;\n}\n\nint main(void){\n\tint i;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\td = (disc*)malloc(n*sizeof(disc));\t\t//Disc?????????\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&d[i].x,&d[i].y,&d[i].r,&d[i].c);\n\t\t\td[i].st = 0;\n\t\t}\n\t\tinitDP();\t\t//??¢?´¢??????????????????\n\t\tprintf(\"%d\\n\",dfsearch(0));\t\t//s=0:??¨??????Disc????????¨????????¶???\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1175: And Then. How Many Are There?\n// 2017.12.21 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\ntypedef struct { int s, del, m; } Q;\nQ q[10000]; int top;\ntypedef struct { int x, y, r; } T;\nT d[25];\nint col[4][6], clen[4]; char f[5];\nint up[25][25], ulen[25];\t\t// ?????????????????????????????°??¨??????\nchar visited[16777216];\n\nint main()\n{\n\tint n, i, j, k, a, c, cmax, l, p, r, s, del, m, ans;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tmemset(clen, 0, sizeof(clen)), memset(f, -1, sizeof(f)), cmax = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &d[i].x, &d[i].y, &d[i].r, &c);\n\t\t\tif  (f[c] >= 0)          c = f[c];\n\t\t\telse f[c] = cmax++, c = cmax-1;\n\n\t\t\tcol[c][clen[c]++] = i;\n\t\t}\n\n\t\tmemset(ulen, 0, sizeof(ulen));\n\t\tfor (i = 0; i < n; i++) for (j = i+1; j < n; j++) {\n\t\t\tif (hypot(d[i].x-d[j].x, d[i].y-d[j].y) < d[i].r+d[j].r) up[j][ulen[j]++] = i;\n\t\t}\n\n\t\tans = 0;\n\t\tmemset(visited, 0, 1 << n);\n\t\tq[0].s = 0, q[0].del = 0, q[0].m = n, top = 1;\n\t\twhile (top) {\n\t\t\ts = q[--top].s, del = q[top].del, m = q[top].m;\n\n\t\t\tif (m == 1 || visited[s]) continue;\n\t\t\tvisited[s] = 1;\n\t\t\tfor (c = 0; c < cmax; c++)if ((l = clen[c]) >= 2) for (p = 0; p < l; p++) {\n\t\t\t\ti = col[c][p];\n\t\t\t\tif (s & (1<<i)) continue;\n\t\t\t\tfor (k = 0; k < ulen[i]; k++) {\n\t\t\t\t\ta = up[i][k];\n\t\t\t\t\tif (!(s & (1<<a))) goto next;\n\t\t\t\t}\n\n\t\t\t\tfor (r = p+1; r < l; r++) {\n\t\t\t\t\tj = col[c][r];\n\t\t\t\t\tif (s & (1<<j)) continue;\n\t\t\t\t\tfor (k = 0; ; k++) {\n\t\t\t\t\t\tif (k == ulen[j]) {\n\t\t\t\t\t\t\tif (del+2 > ans) ans = del+2;\n\t\t\t\t\t\t\tq[top].s = s|(1<<i) | (1<<j), q[top].del = del+2, q[top++].m = m-2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ta = up[j][k];\n\t\t\t\t\t\tif (!(s & (1<<a))) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnext:;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n\n#define N_BIT (1<<24)\n\n#define isDeleted(i,s) (s & (1<<i)) ? 1:0\n#define removeDisc(i,j,s) (s | (1<<i) | (1<<j))\n#define max(x,y) (x>y) ? x:y\n\n\ntypedef struct data{\n\tint x;\n\tint y;\n\tint r;\n\tint c;\n\tint st;\t\t//??????????????????1,????????§???????????°0\n}disc;\n\nint n;\t\t\t\t//Disc????????°\nint max;\t\t//?????????????????°????????§???\nint dp[N_BIT];\t\t//????????¶????????????????????????????????°????????§??????????´?????????????(?????¢?´¢?????´??????-1)\ndisc* d;\t\t\t//Disc???????´?????????????\n\n\ndouble discDistance(int i,int j){\t\t//i,j?????????Disc????????¢?????????\n\tdisc s = d[i];\n\tdisc t = d[j];\n\treturn ((s.x-t.x)*(s.x-t.x) + (s.y-t.y)*(s.y-t.y));\n}\n\nint isRemovable(int i,int j,int s){\t\t\t//??¶???s????????????i?????????Disc?????????????????§?????????\n\tint k;\n\tfor(k=i-1;k>=0;k--){\n\t\tif(d[k].st){\t\t//k???????????¢??????????????????????£???°???\n\t\t\tcontinue;\n\t\t}\n\t\tif((d[i].r + d[k].r)*(d[i].r + d[k].r) > discDistance(i,k)){\t\t//?????¢?????¢???????????????\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(k=j-1;k>=0;k--){\n\t\tif(d[k].st){\t\t//k???????????¢??????????????????????£???°???\n\t\t\tcontinue;\n\t\t}\n\t\tif((d[j].r + d[k].r)*(d[j].r + d[k].r) > discDistance(j,k)){\t\t//?????¢?????¢???????????????\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid initDP(){\t\t//dp??????????????????\n\tint i;\n\tfor(i=0;i<N_BIT;i++){\n\t\tdp[i] = -1;\t\t\t//??¨????????¢?´¢??¨??????\n\t}\n}\n\n//??±???????????¢?´¢(?????¢????????°)\nint dfsearch(int s){\t\t//s?????¶????????????\n\tif(dp[s] != -1){\t\t//??¶???s?????¢?????¢?´¢????????§????????°?¨?????????????\n\t\treturn dp[s];\n\t}\n\tint i,j,value=0;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=i+1;j<n;j++){\n\t\t\t//??¶???s????????????i,j?????????Disc???????????????Disc???????????£????????????,??????????????§??????,?????????i,j??????????????????????????´???\n\t\t\tif(isRemovable(i,j,s) && !d[i].st && !d[j].st && d[i].c == d[j].c){\n\t\t\t\td[i].st = d[j].st = 1;\n\t\t\t\tvalue = max(value,dfsearch(removeDisc(i,j,s))+2);\t\t//i,j???2???????????? + i,j????????????????????\\?????§????????§????????¢?´¢??§?±???????\n\t\t\t\td[i].st = d[j].st = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[s] = value;\n}\n\nint main(void){\n\tint i;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\td = (disc*)malloc(n*sizeof(disc));\t\t//Disc?????????\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&d[i].x,&d[i].y,&d[i].r,&d[i].c);\n\t\t\td[i].st = 0;\n\t\t}\n\t\tinitDP();\t\t//??¢?´¢??????????????????\n\t\tprintf(\"%d\\n\",dfsearch(0));\t\t//s=0:??¨??????Disc????????¨????????¶???\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint n;\n\tbyte[] mem;\n\tCoin[] coins;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tcoins = new Coin[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tcoins[i] = new Coin(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\t}\n\t\t\tmem = new byte[(1<<n)];\n\t\t\tfill(mem, (byte)-1);\n\t\t\tSystem.out.println(solve((1<<n)-1));\n\t\t}\n\t}\n\t\n\tbyte solve( int S ) {\n\t\tif( mem[S]>=0 ) return mem[S];\n\t\tbyte cnt = 0;\n\t\tboolean[] rap = new boolean[n];\n\t\t\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif( ((S>>i) & 1) == 0 ) {\n\t\t\t\trap[i] = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif( ((S>>j) & 1) == 0 ) continue;\n\t\t\t\trap[j] = coins[i].israpped(coins[j]); \n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(rap[i]) continue;\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif(rap[j])continue;\n\t\t\t\tif( coins[i].c == coins[j].c ) {\n\t\t\t\t\tcnt = (byte) max(cnt, solve( S - ((1<<i) + (1<<j)) ) + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn mem[S] = cnt;\n\t}\n\t\n\t\n\t\n\tclass Coin {\n\t\tint x, y, r, c;\n\t\tCoin (int x, int y, int r, int c) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t}\n\t\t\n\t\tboolean israpped(Coin c) {\n\t\t\treturn (c.x-x) * (c.x-x) + (c.y-y) * (c.y-y) < (r+c.r) * (r+c.r);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic BitSet cleared = new BitSet();\n\tstatic PriorityQueue<double[]>[] pQ;\n\tstatic double[][] c;\n\n\tstatic int isIntersection(double x1, double y1, double r1, double x2, double y2, double r2) {\n\t\tdouble d = Math.sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));\n\t\tdouble rr = r1 + r2;\n\t\treturn Math.abs(d - rr) < 1e-10 ? 1 : (d < rr ? 2 : 0);\n\t}\n\n\tstatic boolean isOk(int idx) {\n\t\tdouble[] t = c[idx];\n\t\tfor (int i=0; i<idx; i++) {\n\t\t\tif (cleared.get(i)) continue;\n\t\t\tif (isIntersection(t[0], t[1], t[2], c[i][0], c[i][1], c[i][2]) > 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic boolean clear() {\n\t\tfor (int i=0; i<4; i++) {\n\t\t\tdouble[] tmp = null;\n\t\t\tfor (double[] p : pQ[i]) {\n\t\t\t\tif (isOk((int)p[3])) {\n\t\t\t\t\tif (tmp == null) {\n\t\t\t\t\t\ttmp = p;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcleared.set((int)tmp[3]);\n\t\t\t\t\t\tcleared.set((int)p[3]);\n\t\t\t\t\t\tpQ[i].remove(tmp);\n\t\t\t\t\t\tpQ[i].remove(p);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tstatic boolean solve() {\n\t\tint n = in.nextInt();\n\t\tif (n == 0) return false;\n\n\t\tpQ = new PriorityQueue[4];\n\t\tfor (int i=0; i<4; i++) {\n\t\t\tpQ[i] = new PriorityQueue<double[]>(new Comparator<double[]>(){\n\t\t\t\tpublic int compare(double[] a, double[] b) {\n\t\t\t\t\treturn (int)(a[3] - b[3]);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tc = new double[n][4];\n\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tc[i][0] = in.nextInt();\n\t\t\tc[i][1] = in.nextInt();\n\t\t\tc[i][2] = in.nextInt();\n\t\t\tint color = in.nextInt() - 1;\n\t\t\tc[i][3] = i;\n\t\t\tpQ[color].add(c[i]);\n\t\t}\n\n\t\tint cnt = 0;\n\n\t\twhile (clear()) {\n\t\t\tcnt += 2;\n\t\t}\n\n\t\tout.println(cnt);\n\t\tcleared.clear();\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.currentTimeMillis();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.currentTimeMillis();\n\t\tdump((end-start) + \"ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tnew Main().start();\n\t}\n\n\n\tArrayList<Circle> topCircles;\n\tvoid start(){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tCircle[] circles = new Circle[n];\n\t\t\ttopCircles = new ArrayList<Circle>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tCircle c = new Circle(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\t\tcircles[n-1-i] = c;\n\t\t\t}\n\t\t\tfor(int i = 0; i < circles.length; i++){\n\t\t\t\tCircle c = circles[i];\n\t\t\t\tfor(int j = i-1; j >= 0; j--){\n\t\t\t\t\tcircles[j].putC(c);\n\t\t\t\t}\n\t\t\t\tc.level += 1;\n\t\t\t}\n\t\t\tfor(Circle c : circles){\n\t\t\t\tif(c.aboveList.isEmpty())topCircles.add(c);\n\t\t\t}\n//\t\t\tfor(Circle c : circles){\n//\t\t\t\tSystem.out.print(c);\n//\t\t\t}\n\t\t\tint count = 0;\n\t\t\tboolean isChanged = false;\n\t\t\tdo{\n\t\t\t\tisChanged = false;\n\t\t\t\tfor(int i = 0; i < topCircles.size()-1; i++){\n\t\t\t\t\tCircle c1 = topCircles.get(i);\n\t\t\t\t\tfor(int j = i+1; j < topCircles.size(); j++){\n\t\t\t\t\t\tCircle c2 = topCircles.get(j);\n\t\t\t\t\t\tif(c1.c == c2.c){\n\t\t\t\t\t\t\tc1.remove();\n\t\t\t\t\t\t\tc2.remove();\n\t\t\t\t\t\t\tisChanged = true;\n\t\t\t\t\t\t\tcount += 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(isChanged){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}while(isChanged);\n\t\t\tSystem.out.println(count);\n\t\t}\n\t\tin.close();\n\t}\n\tclass Circle{\n\t\tint x, y, r, c;\n\t\tArrayList<Circle> clist;\n\t\tArrayList<Circle> aboveList;\n\t\tint level = 0;\n\t\tCircle(int x, int y, int r, int c){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t\tclist = new ArrayList<Circle>();\n\t\t\taboveList = new ArrayList<Circle>();\n\t\t}\n\t\tvoid putC(Circle c){\n\t\t\tif((x-c.x)*(x-c.x) + (y-c.y)*(y-c.y) < (r+c.r)*(r+c.r)){\n\t\t\t\tif(level >= c.level){\n\t\t\t\t\tc.clist.add(this);\n\t\t\t\t\tthis.aboveList.add(c);\n\t\t\t\t\tc.level = level;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvoid remove(){\n\t\t\ttopCircles.remove(this);\n\t\t\tfor(Circle c : clist){\n\t\t\t\tc.aboveList.remove(this);\n\t\t\t\tif(c.aboveList.isEmpty()){\n\t\t\t\t\ttopCircles.add(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String toString(){\n\t\t\tString s = \"(\" + x +\",\" + y + \")\" + r +\":\" + c + \",\" + level + \"\\n\";\n//\t\t\ts += \"below\\n\";\n//\t\t\tfor(Circle c : clist){\n//\t\t\t\ts += \"\\t\" + \"(\" + c.x +\",\" + c.y + \")\" + c.r +\":\" + c.c + \",\" + c.level + \"\\n\";;\n//\t\t\t}\n//\t\t\ts+= \"above\\n\";\n//\t\t\tfor(Circle c : aboveList){\n//\t\t\t\ts += \"\\t\" + \"(\" + c.x +\",\" + c.y + \")\" + c.r +\":\" + c.c + \",\" + c.level + \"\\n\";;\n//\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tclass Circle {\n\t\tint x, y, r, c;\n\t\tCircle (int x, int y, int r, int c) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\tfinal boolean DEBUG = false;\n\tfinal int MAX_N = 4 * 6;\n\tCircle[] circles;\n\tboolean[] isVisited;\n\tint n, ans;\n\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scan.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\treturn;\n\t\t\tcircles = new Circle[n];\n\t\t\tisVisited = new boolean[1 << 24];\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = scan.nextInt();\n\t\t\t\tint y = scan.nextInt();\n\t\t\t\tint r = scan.nextInt();\n\t\t\t\tint c = scan.nextInt();\n\t\t\t\tcircles[i] = new Circle(x, y, r, c);\n\t\t\t}\n\t\t\tans = 0;\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tint deleteCount(int bit) {\n\t\tint count = 0;\n\t\twhile (bit != 0) {\n\t\t\tif ((bit & 1) != 0)\n\t\t\t\tcount++;\n\t\t\tbit >>= 1;\n\t\t}\n\t\treturn count;\n\t}\n\t\n\tboolean isTop(int bit, int circle) {\n\t\tif ((bit & (1 << circle)) != 0)\n\t\t\treturn false;\n\t\t\n\t\tfor (int i = circle - 1; i >= 0; i--) {\n\t\t\tif ((bit & (1 << i)) != 0)\n\t\t\t\tcontinue;\n\t\t\tint dx = circles[i].x - circles[circle].x;\n\t\t\tint dy = circles[i].y - circles[circle].y;\n\t\t\tif (circles[i].r + circles[circle].r > Math.sqrt(dx * dx + dy * dy))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tvoid dfs(int bit) {\n\t\tif (isVisited[bit])\n\t\t\treturn;\n\t\tisVisited[bit] = true;\n\t\tif (DEBUG)\n\t\t\tSystem.out.println(bit);\n\n\t\tans = Math.max(ans, deleteCount(bit));\n\t\tif (n - ans <= 1)\n\t\t\treturn;\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(i + \" \" + !isTop(bit, i));\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (!isTop(bit, i))\n\t\t\t\tcontinue;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.println(\"j: \" + j + \" \" + !isTop(bit, j));\n\t\t\t\t}\n\t\t\t\tif (!isTop(bit, j))\n\t\t\t\t\tcontinue;\n\t\t\t\tif(circles[i].c == circles[j].c) {\n\t\t\t\t\tdfs(bit | (1 << i) | (1 << j));\n\t\t\t\t\tif (n - ans <= 1)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tfinal int MAX = Integer.MAX_VALUE;\n\tScanner sc = new Scanner(System.in);\n\tvoid doIt() {\n\t\tnew And_Then_How_Many_Are_There().main();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doIt();\n\t}\n\tclass And_Then_How_Many_Are_There{\n\t\tSet<Integer> status;\n\t\tNode v[];\n\t\tvoid main() {\n\t\t\twhile(true) {\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tif(n == 0) return;\n\t\t\t\tstatus = new HashSet<>();\n\t\t\t\tv = new Node[n];\n\t\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\tv[i] = new Node(i, sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\t\t\t\tv[i].over(v[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tList<Node> use = new ArrayList<>();\n\t\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\tif(v[i].dps == 0) use.add(v[i]);\n\t\t\t\t}\n\t\t\t\t//Nodeの親子を出力\n\t\t\t\t/*\n\t\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\tNode node = v[i];\n\t\t\t\t\tSystem.out.println(node.idx +\" :: \" + node.dps);\n\t\t\t\t\t\tSystem.out.println(node.idx +  \":\"  + node.dps  +  \" -> \" + node.parentToString());\n\t\t\t\t\t\tSystem.out.println(node.idx +  \":\"  + node.dps  +  \" <- \" + node.childrenToString());\n\t\t\t\t}\n\t\t\t\t */\n\n\t\t\t\tsearch(use, 0);\n\t\t\t\tint max = 0;\n\t\t\t\tint maxint = 0;\n\t\t\t\tfor(int i : status) {\n\t\t\t\t\tmax = Math.max(Integer.bitCount(i), max);\n\t\t\t\t\t//System.out.println(Integer.toBinaryString(i));\n\t\t\t\t}\n\t\t\t\tSystem.out.println(max);\n\n\t\t\t}\n\n\n\t\t}\n\t\tvoid search(List<Node> use, int sta) {\n\t\t\t//useの状態、bitを出力\n\t\t\t/*System.out.print(\"[\");\n\t\t\tfor(Node n : use) System.out.print(n.idx + \", \");\n\t\t\tSystem.out.println(\"]\");\n\t\t\tSystem.out.println(Integer.toBinaryString(has) +\" : \"+ Integer.bitCount(has));\n\t\t\t */\n\t\t\tif(status.contains(sta))return;\n\t\t\tstatus.add(sta);\n\t\t\t//System.out.println(Integer.toBinaryString(has));\n\t\t\tfor(Node i : use) {\n\t\t\t\tif((sta >> i.idx & 1) == 1) continue;\n\t\t\t\tfor(Node j : use) {\n\t\t\t\t\tif((sta >> j.idx & 1) == 1) continue;\n\t\t\t\t\tif(i.equals(j)) continue;\n\t\t\t\t\tif(i.color == j.color && !status.contains(sta + (1 << i.idx) + (1 << j.idx))) {\n\t\t\t\t\t\tList<Node> next = new ArrayList<>(use);\n\t\t\t\t\t\tnext.remove(i); \n\t\t\t\t\t\tnext.remove(j);\n\t\t\t\t\t\t//for(Node node : next) System.out.print(node.idx + \" \");\n\t\t\t\t\t\t//System.out.println();\n\t\t\t\t\t\tfor(Node k : i.children) {\n\t\t\t\t\t\t\t//System.out.println(i);\n\t\t\t\t\t\t\tk.parent.remove(i);\n\t\t\t\t\t\t\t//System.out.println(k + \" \" + k.parent.isEmpty() +  \": \" + k.parentToString());\n\t\t\t\t\t\t\tif(k.parent.isEmpty()) {\n\t\t\t\t\t\t\t\tnext.add(k);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(Node k : j.children) {\n\t\t\t\t\t\t\tk.parent.remove(j);\n\t\t\t\t\t\t\tif(k.parent.size() == 0) {\n\t\t\t\t\t\t\t\tnext.add(k);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//System.out.println(Integer.toBinaryString(has) + \"->\");\n\t\t\t\t\t\tint _has = sta;\n\t\t\t\t\t\t_has += (1 << i.idx);\n\t\t\t\t\t\t_has += (1 << j.idx);\n\t\t\t\t\t\t//System.out.println(Integer.toBinaryString(_has));\n\t\t\t\t\t\t//System.out.println();\n\t\t\t\t\t\t//System.out.println(ans + \" \" + search(ans + 2, next, _has));\n\t\t\t\t\t\tsearch(next, _has);\n\t\t\t\t\t\tfor(Node k : i.children) {\n\t\t\t\t\t\t\tk.parent.add(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(Node k : j.children) {\n\t\t\t\t\t\t\tk.parent.add(j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\n\t\tclass Node{\n\t\t\tList<Node> parent;\n\t\t\tList<Node> children = new ArrayList<>();\n\t\t\tint idx, color, dps;\n\t\t\tint x, y, r;\n\t\t\tNode(int i, int x, int y, int r, int c){\n\t\t\t\tidx = i;\n\t\t\t\tthis.x = x; this.y = y; this.r = r;\n\t\t\t\tcolor = c;\n\t\t\t\tdps = 0;\n\t\t\t\tparent = new ArrayList<>();\n\t\t\t}\n\t\t\tvoid over(Node v) {\n\t\t\t\tif(isOver(this.x, this.y, this.r, v.x, v.y, v.r)) {\n\t\t\t\t\tif(this.idx < v.idx) {\n\t\t\t\t\t\t//System.out.println(v.idx + \"=>\" + this.idx);\n\t\t\t\t\t\tif(v.dps <= this.dps) {\n\t\t\t\t\t\t\tv.dps = this.dps + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv.parent.add(this);\n\t\t\t\t\t\tthis.children.add(v);\n\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t//System.out.println(this.idx + \"=>\" + v.idx);\n\t\t\t\t\t\tif(v.dps >= this.dps) {\n\n\t\t\t\t\t\t\tthis.dps = v.dps + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.parent.add(v);\n\t\t\t\t\t\tv.children.add(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//else System.out.println(this.idx + \"<>\" + v.idx);\n\n\t\t\t}\n\t\t\tString parentToString() {\n\t\t\t\tString s = \"\";\n\t\t\t\tfor(Node i : parent) {\n\t\t\t\t\ts += i.idx + \" \";\n\t\t\t\t}\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tString childrenToString() {\n\t\t\t\tString s = \"\";\n\t\t\t\tfor(Node i : children) {\n\t\t\t\t\ts += i.idx + \" \";\n\t\t\t\t}\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tboolean isOver(int x, int y, int r, int x2, int y2, int r2) {\n\t\t\t\tif(r + r2 > Math.sqrt((x - x2) * (x - x2) + (y - y2) * (y - y2))){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse return false;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.Stack;\n\n\npublic class Main {\n\t\n\tpublic static boolean is_covered(int node, int bit, boolean[][] adj){\n\t\tfor(int upper = node - 1; upper >= 0; upper--){\n\t\t\tif((bit & (1 << upper)) != 0){\n\t\t\t\tcontinue;\n\t\t\t}else if(adj[upper][node]){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] x_pos  = new int[n];\n\t\t\tint[] y_pos  = new int[n];\n\t\t\tint[] rs     = new int[n];\n\t\t\tint[] colors = new int[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tx_pos[i]  = sc.nextInt();\n\t\t\t\ty_pos[i]  = sc.nextInt();\n\t\t\t\trs[i]     = sc.nextInt();\n\t\t\t\tcolors[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] cover = new boolean[n][n];\n\t\t\t\n\t\t\tfor(int upper = 0; upper < n; upper++){\n\t\t\t\tfor(int lower = upper + 1; lower < n; lower++){\n\t\t\t\t\tfinal int x_diff = (x_pos[upper] - x_pos[lower]);\n\t\t\t\t\tfinal int y_diff = (y_pos[upper] - y_pos[lower]);\n\t\t\t\t\tfinal int r_diff = (rs[upper] + rs[lower]);\n\t\t\t\t\t\n\t\t\t\t\tif(x_diff * x_diff + y_diff * y_diff < r_diff * r_diff){\n\t\t\t\t\t\tcover[upper][lower] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal int bit_max = 1 << n;\n\t\t\t\n\t\t\tint[] dp = new int[bit_max];\n\t\t\tArrays.fill(dp, -1);\n\t\t\tdp[0] = 0;\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tfor(int bit = 0; bit < bit_max; bit++){\n\t\t\t\tif(dp[bit] < 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tmax = Math.max(max, dp[bit]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println(dp[bit]);\n\t\t\t\t\n\t\t\t\tfor(int left = 0; left < n; left++){\n\t\t\t\t\tif((bit & (1 << left)) != 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(is_covered(left, bit, cover)){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//System.out.println(\"come\");\n\t\t\t\t\t\n\t\t\t\t\tfor(int right = left + 1; right < n; right++){\n\t\t\t\t\t\tif((bit & (1 << right)) != 0){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(is_covered(right, bit, cover)){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(colors[left] != colors[right]){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfinal int next_bit = ((bit | (1 << left)) | (1 << right));\n\t\t\t\t\t\t//System.out.println(next_bit);\n\t\t\t\t\t\t\n\t\t\t\t\t\tdp[next_bit] = Math.max(dp[next_bit], dp[bit] + 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n  \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n  \n    public static void main(String[] args) {\n        new Main(); \n    }\n  \n    public Main() {\n        new aoj1155().doIt();\n    }\n    class aoj1155{\n    \tArrayList<Circle> cc = new ArrayList<Circle>();\n    \tboolean color[] = new boolean[5];\n    \tvoid set(){\n    \t\tfor(int i = 0;i < 5;i++)color[i] = false;\n    \t\tcc.clear();\n    \t}\n    \tboolean Circle_check(int num,int length){\n    \t\tfor(int i = 0;i < length;i++){\n    \t\t\tif(cc.get(i).color == num){\n    \t\t\t\tfor(int j = i + 1;j < length;j++){\n    \t\t\t\t\tPoint2D p1 = cc.get(i).p;\n    \t\t\t\t\tPoint2D p2 = cc.get(j).p;\n    \t\t\t\t\tdouble rr = cc.get(i).dis + cc.get(j).dis;\n    \t\t\t\t\tdouble dis = p1.distance(p2);\n    \t\t\t\t\tif(dis < rr)return false;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\treturn true;\n    \t}\n    \tint Circle_remove(int num,int length){\n    \t\tint result = 0;\n    \t\tfor(int i = length - 1;i >= 0;i--){\n    \t\t\tif(cc.get(i).color == num){\n    \t\t\t\tcc.remove(i);\n    \t\t\t\tresult++;\n    \t\t\t}\n    \t\t}\n    \t\treturn result;\n    \t}\n    \tint ans(int n){\n    \t\tint result = 0;\n    \t\tfor(int i = 1;i < 5;i++){\n    \t\t\tif(!color[i])continue;\n    \t\t\tfor(int j = 1;j < 5;j++){\n        \t\t\tif(!color[j])continue;\n        \t\t\tif(Circle_check(j,cc.size())){\n        \t\t\t\tcolor[j] = false;\n        \t\t\t\tresult = result + Circle_remove(j,cc.size());\n        \t\t\t}\n        \t\t}\n    \t\t}\n    \t\treturn result;\n    \t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tint n = sc.nextInt();\n    \t\t\tif(n == 0)break;\n    \t\t\tset();\n    \t\t\tCircle[] c = new Circle[n];\n    \t\t\tfor(int i = 0;i < n;i++){\n    \t\t\t\tPoint2D p = new Point2D.Double(sc.nextDouble(),sc.nextDouble());\n    \t\t\t\tcc.add(0,new Circle(p,sc.nextDouble(),sc.nextInt()));\n    \t\t\t\tcolor[cc.get(0).color] = true;\n    \t\t\t}\n    \t\t\tSystem.out.println(ans(n));\n    \t\t}\n    \t}\n    \tclass Circle{\n    \t\tPoint2D p;\n    \t\tdouble dis;\n    \t\tint color;\n    \t\tpublic Circle(Point2D p,double dis,int color){\n    \t\t\tthis.p = p;\n    \t\t\tthis.dis = dis;\n    \t\t\tthis.color = color;\n    \t\t}\n    \t}\n     }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tint [] x,y,r,c;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tx = new int[n];\n\t\t\ty = new int[n];\n\t\t\tr = new int[n];\n\t\t\tc = new int[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t\tr[i] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint len = 1 << n;\n\t\t\tboolean [][] dp = new boolean[len][n/2 + 1];\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tArrays.fill(dp[i],false);\n\t\t\t}\n\t\t\tdp[0][0] = true;\n\t\t\tint ans = 0;\n\t\t\tfor(int i=0; i < n/2;i++){\n\t\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\t\tif(dp[j][i] == false) continue;\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\t\tfor(int l = k+1; l < n; l++){\n\t\t\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\t\t\tif(! issameC(k,l)) continue;\n\t\t\t\t\t\t\tif(isOVL(k,j) || isOVL(l,j)) continue;\n\t\t\t\t\t\t\tint num;\n\t\t\t\t\t\t\tint kInd = 1 << k;\n\t\t\t\t\t\t\tint lInd = 1 << l;\n\t\t\t\t\t\t\tnum = j | kInd;\n\t\t\t\t\t\t\tnum = num | lInd;\n\t\t\t\t\t\t\t//System.out.println(\"num= \"+num + \" j= \" + j +  \" k = \"+ k + \" l= \" + l );\n\t\t\t\t\t\t\tdp[num][i+1] = true;\n\t\t\t\t\t\t\tans = (i+1)*2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\t//TODO debug\n//\t\t\tfor(int i= 0; i < len; i++){\n//\t\t\t\tfor(int j = 0; j < n+1; j++){\n//\t\t\t\t\tif(dp[i][j]){\n//\t\t\t\t\t\tSystem.out.print(\"1 \");\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tSystem.out.print(\"0 \");\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate boolean isOVL(int a,int num) {\n\t\tif(a == 0) return false;\n\t\tint ax = x[a];\n\t\tint ay = y[a];\n\t\tint ar= r[a];\n\t\tfor(int i = a-1; i >= 0; i--){\n\t\t\tif(((1 << i) & num) != 0) continue;\n\t\t\tint ix = x[i];\n\t\t\tint iy = y[i];\n\t\t\tint ir = r[i];\n\t\t\tdouble dis = Point2D.Double.distance(ax, ay, ix, iy);\n\t\t\tint rr = ir + ar;\n\t\t\tif(dis < rr)return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean issameC(int a, int b) {\n\t\tif(c[a] == c[b]) return true;\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int n;\n\tstatic int[] x;\n\tstatic int[] y;\n\tstatic int[] r;\n\tstatic int[] c;\n\tstatic boolean[][] cover;\n\tstatic HashMap<Integer, Integer> dp;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx = new int[n];\n\t\t\ty = new int[n];\n\t\t\tr = new int[n];\n\t\t\tc = new int[n];\n\t\t\tcover = new boolean[n][n];\n\t\t\tdp = new HashMap<Integer, Integer>();\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t\tr[i] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt()-1;\n\t\t\t\tfor(int j=0;j<i;j++) {\n\t\t\t\t\tint dx = x[j] - x[i];\n\t\t\t\t\tint dy = y[j] - y[i];\n\t\t\t\t\tint rs = r[i] + r[j];\n\t\t\t\t\tif (dx*dx+dy*dy<rs*rs) {\n\t\t\t\t\t\tcover[j][i] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dfs(0));\n\t\t}\n\t}\n\n\tpublic static int dfs(int used) {\n\t\tif (dp.containsKey(used)) {\n\t\t\treturn dp.get(used);\n\t\t}\n\t\tint[][] canuse = new int[4][6];\n\t\tint[] canusenum = new int[4];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (((1<<i)&used) == 0) {\n\t\t\t\tboolean flag = true;\n\t\t\t\tfor(int j=0;j<i;j++) {\n\t\t\t\t\tif (((1<<j)&used) == 0 && cover[j][i]) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tcanuse[c[i]][canusenum[c[i]]++] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tboolean flag = false;\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tif (canusenum[i] >= 2) {\n\t\t\t\tfor(int j=0;j<canusenum[i]-1;j++) {\n\t\t\t\t\tfor(int k=j+1;k<canusenum[i];k++) {\n\t\t\t\t\t\tint usednext = used | (1<<canuse[i][j]) | (1<<canuse[i][k]);\n\t\t\t\t\t\tret = Math.max(ret, dfs(usednext));\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret = flag ? ret + 2 : 0;\n\t\tdp.put(used, ret);\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport javax.swing.Box.Filler;\n\npublic class Main {\n\tCoin[] coins;\n\tScanner sc = new Scanner(System.in);\n\tboolean[] lapped;\n\tint n;\n\tint[] state;\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\tcoins = new Coin[n];\n\t\t\tlapped = new boolean[n];\n\t\t\tfor(int i=0;i<n;i++) coins[i] = new Coin();\n\t\t\tint S=(1<<n)-1;\n\t\t\tstate = new int[1<<n];\n\t\t\tfor(int i=0;i<(1<<n);i++) state[i] = -1;\n\t\t\tSystem.out.println(solve(S));\n\t\t}\n\t}\n\t\n\tint solve( int S ) {\n//\t\tSystem.out.println(S);\n\t\tif( S == 0 ) return 0;\n\t\tif (state[S] >= 0) return state[S];\n\t\tanalyseLapped(S);\n//\t\tfor(int i=0;i<n;i++) System.out.print(lapped[i] + \" \");\n//\t\tSystem.out.println();\n//\t\tsc.next();\n\t\tint cnt = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif( ((S>>i) & 1) != 1 || lapped[i] ) continue;\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif ( ((S>>j) & 1) == 1 && !lapped[j] && coins[i].c == coins[j].c ) {\n\t\t\t\t\tcnt = Math.max(cnt, solve(S-((1<<i) + (1<<j)))+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn state[S] = cnt;\n\t}\n\t\n\tvoid analyseLapped(int S) {\n\t\tfor(int i=0;i<n;i++) lapped[i] = false;\n\t\tfor(int i=0;i<n;i++) {\n//\t\t\tSystem.out.println( (S>>i) & 1 );\n\t\t\tif( ((S>>i) & 1) != 1 ) continue;\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif( ((S>>j) & 1) != 1 ) continue;\n//\t\t\t\tSystem.out.println(coins[i].isLapped(coins[j]));\n\t\t\t\tif( coins[i].isLapped(coins[j]) ) lapped[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\tprotected class Coin {\n\t\tint x, y, r, c;\n\t\t\n\t\tpublic Coin() {\n\t\t\tscan();\n\t\t}\n\t\t\n\t\tvoid scan() {\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\t\t\tr = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t}\n\t\t\n\t\tboolean isLapped( Coin c ) {\n\t\t\treturn (c.x-x)*(c.x-x)+(c.y-y)*(c.y-y) < (r+c.r)*(r+c.r);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int n;\n\tList<Disc> discs = new ArrayList<Disc>();\n\tSet<Disc> ups = new HashSet<Disc>();\n\tSet<Disc> used = new HashSet<Disc>();\n\tMap<Set<Disc>, Integer> memo = new HashMap<Set<Disc>, Integer>();\n\tint max = -1;\n\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\n\t\t\t// init\n\t\t\tMain m =new Main();\n\t\t\tm.dfs(0);\n\t\t\tSystem.out.println(m.max-2);\n\t\t}\n\t}\n\n\tMain() {\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tDisc d = new Disc(sc, i);\n\t\t\tint deep = 0;\n\t\t\tfor(Disc op : discs) {\n\t\t\t\tif( d.butsu(op) ) deep = Math.max(deep, op.deep);\n\t\t\t}\n\t\t\tdeep++;\n\t\t\tif(deep == 1) ups.add(d);\n\t\t\tdiscs.add(d);\n\t\t}\n\t}\n\n\tvoid dfs(int m) {\n\t\t// memo\n\t\tif( memo.containsKey(used) ) return;\n\n\t\t// max\n\t\tmax = Math.max(max, m);\n\n\t\t// go\n\t\tList<Disc> tmp = new ArrayList<Disc>(ups);\n\t\tfor(int i=0; i<tmp.size(); i++) {\n\t\t\tDisc d = tmp.get(i);\n\t\t\tfor(int j=i+1; j<tmp.size(); j++) {\n\t\t\t\tDisc op = tmp.get(j);\n\t\t\t\tif(d.equals(op)) continue;\n\t\t\t\tif(d.c == op.c) {\n\t\t\t\t\tpush(d, op);\n\t\t\t\t\tdfs(m+2);\n\t\t\t\t\tpush(d, op);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid push(Disc a, Disc b) {\n\t\tpushSub(a);\n\t\tpushSub(b);\n\t}\n\tprivate void pushSub(Disc a) {\n\t\tused.add(a);\n\t\tdiscs.remove(a);\n\t\tups.remove(a);\n\t\tups.addAll(underAll(a));\n\t}\n\n\tvoid pop(Disc a, Disc b) {\n\t\tpopSub(a);\n\t\tpopSub(b);\n\t}\n\tprivate void popSub(Disc a) {\n\t\tused.remove(a);\n\t\tdiscs.add(a);\n\t\tups.removeAll(underAll(a));\n\t\tups.add(a);\n\t}\n\n\tboolean butsuAny(Disc d) {\n\t\tfor(Disc op : discs) {\n\t\t\tif( d.butsu(op) ) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tSet<Disc> butsuAll(Disc d) {\n\t\tSet<Disc> res = new HashSet<Disc>();\n\t\tfor(Disc op : discs) {\n\t\t\tif( d.butsu(op) ) res.add(op);\n\t\t}\n\t\treturn res;\n\t}\n\n\tSet<Disc> underAll(Disc d) {\n\t\tSet<Disc> res = new HashSet<Disc>();\n\t\tfor(Disc op : discs) {\n\t\t\tif( d.butsu(op) && d.deep == op.deep+1 ) res.add(op);\n\t\t}\n\t\treturn res;\n\t}\n\n}\n\n\nclass Disc {\n\tint x, y, r, c;\n\tint id;\n\tint deep;\n\n\tDisc(Scanner sc, int i) {\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\t\tr = sc.nextInt();\n\t\tc = sc.nextInt();\n\t\tid = i;\n\t}\n\n\tboolean butsu(Disc op) {\n\t\treturn false;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tnew AOJ1175().doIt(n);\n\t\t}\n\t}\n\n\n\tclass AOJ1175{\n\t\tint cnt[][];\n\t\tint dfs(long bit,int num){\n\t\t\tif(memo[(int)bit]>=0)return memo[(int)bit];\n//\t\t\tSystem.out.println(Long.toBinaryString(bit));\n\t\t\tint result = num;\n\t\t\tArrays.fill(cnt[num/2],0);\n\t\t\tfor(int i=0;i<n;i++)for(int s=i-1;s>=0;s--)if((bit>>i)%2==1&&(bit>>s)%2==1){\n\t\t\t\tif(Point2D.distance(data[i].x, data[i].y, data[s].x, data[s].y)<data[s].r+data[i].r)cnt[num/2][i]++;\n\t\t\t}\n\t\t\tfor(int c=1;c<=4;c++){//color\n\t\t\t\tfor(int i=0;i<n;i++)for(int s=i+1;s<n;s++)if(data[i].color==c&&data[s].color==c&&cnt[num/2][i]==0&&cnt[num/2][s]==0){\n\t\t\t\t\tif(i==s||((bit>>i)%2==0)||((bit>>s)%2==0))continue;\n\t\t\t\t\tbit -= 1 << i;\n\t\t\t\t\tbit -= 1 << s;\n//\t\t\t\t\tSystem.out.println(i+\" \"+s);\n\t\t\t\t\tresult = Math.max(result, dfs(bit,num+2));\n\t\t\t\t\tbit += 1 << i;\n\t\t\t\t\tbit += 1 << s;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn memo[(int)bit] = result;\n\t\t}\n\t\tint[] memo = new int[(1<<24)];\n\t\tint n;\n\t\tData data[];\n\t\tvoid doIt(int n){//<=24\n\t\t\tcnt = new int[24][n];\n\t\t\tArrays.fill(memo, -1);\n\t\t\tthis.n = n;\n\t\t\tdata = new Data[n];\n\t\t\tfor(int i=0;i<n;i++)data[i] = new Data(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\tlong bit=0;\n\t\t\tfor(int i=0;i<n;i++)bit += 1 << i;\n\t\t\tint result = dfs(bit,0);\n\t\t\tSystem.out.println(result);\n\t\t}\n\n\t\tclass Data{\n\t\t\tint x,y,color,r;\n\t\t\tpublic Data(int x,int y,int r,int color) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.r = r;\n\t\t\t\tthis.color = color;\n\t\t\t}\n\t\t}\n\t}\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int n;\n\tstatic int[] x;\n\tstatic int[] y;\n\tstatic int[] r;\n\tstatic int[] c;\n\tstatic boolean[][] cover;\n\tstatic byte[] dp;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx = new int[n];\n\t\t\ty = new int[n];\n\t\t\tr = new int[n];\n\t\t\tc = new int[n];\n\t\t\tcover = new boolean[n][n];\n\t\t\tdp = new byte[(1<<n)/8+1];\n\t\t\tArrays.fill(dp, (byte)-1);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t\tr[i] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt()-1;\n\t\t\t\tfor(int j=0;j<i;j++) {\n\t\t\t\t\tint dx = x[j] - x[i];\n\t\t\t\t\tint dy = y[j] - y[i];\n\t\t\t\t\tint rs = r[i] + r[j];\n\t\t\t\t\tif (dx*dx+dy*dy<rs*rs) {\n\t\t\t\t\t\tcover[j][i] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dfs(0));\n\t\t}\n\t}\n\n\tpublic static int dfs(int used) {\n\t\tif (dp[used]!=-1) {\n\t\t\treturn dp[used];\n\t\t}\n\t\tint[][] canuse = new int[4][6];\n\t\tint[] canusenum = new int[4];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (((1<<i)&used) == 0) {\n\t\t\t\tboolean flag = true;\n\t\t\t\tfor(int j=0;j<i;j++) {\n\t\t\t\t\tif (((1<<j)&used) == 0 && cover[j][i]) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tcanuse[c[i]][canusenum[c[i]]++] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tboolean flag = false;\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tif (canusenum[i] >= 2) {\n\t\t\t\tfor(int j=0;j<canusenum[i]-1;j++) {\n\t\t\t\t\tfor(int k=j+1;k<canusenum[i];k++) {\n\t\t\t\t\t\tint usednext = used | (1<<canuse[i][j]) | (1<<canuse[i][k]);\n\t\t\t\t\t\tret = Math.max(ret, dfs(usednext));\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret = flag ? ret + 2 : 0;\n\t\tdp[used] = (byte) ret;\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static int n;\n    static Circle circle[] = new Circle[24];\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        while (true){\n            n = sc.nextInt();\n            if (n==0) break;\n\n            for (int i = 0; i < n; i++) {\n                circle[i] = new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt());\n                overCircle(i);\n            }\n\n            System.out.println(remove(0));\n        }\n    }\n\n    static void overCircle(int i) {\n        for (int j = 0; j < i; j++) {\n            int l = (int)(Math.pow(circle[j].x-circle[i].x,2)+Math.pow(circle[j].y-circle[i].y,2));\n            if (Math.pow(circle[j].r+circle[i].r,2)>l){\n                circle[i].over[j] = 1;\n                circle[i].cnt++;\n            }\n        }\n    }\n\n    static int remove(int num) {\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (circle[i].flag==1) continue;\n            for (int j = i+1; j < n; j++) {\n                if (circle[j].cnt==0&&circle[i].c==circle[j].c){\n                    cnt += 2;\n                    for (int k = 0; k < n; k++) {\n                        if (circle[i].over[i]==1) cnt--;\n                    }\n                }\n            }\n        }\n        return cnt;\n    }\n\n    static class Circle{\n        int x, y, r, c;\n        int[] over = new int[24];\n        int cnt = 0, flag = 0;\n        Circle(int s, int t, int u, int v){\n            x = s; y = t; r = u; c = v;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static boolean is_not_covered(final int n, final int purpos, int[] x_array, int[] y_array, int[] r_array, int bit){\t\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif((bit & (1 << j)) == 0){\n\t\t\t\tcontinue;\n\t\t\t}else if(purpos == j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\n\t\t\tfinal int diff_x = (x_array[purpos] - x_array[j]) * (x_array[purpos] - x_array[j]);\n\t\t\tfinal int diff_y = (y_array[purpos] - y_array[j]) * (y_array[purpos] - y_array[j]);\n\t\t\tfinal int diff_r = (r_array[purpos] + r_array[j]) * (r_array[purpos] + r_array[j]);\n\t\t\t\t\n\t\t\tif(diff_x + diff_y < diff_r && purpos > j){\n\t\t\t\t//System.out.println(purpos + \" \" + j);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//System.out.println(\"ok\");\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static int dfs(int bit, final int n, int[] x_array, int[] y_array, int[] r_array, int[] c_array, int[] memo){\n\t\tif(memo[bit] >= 0){\n\t\t\treturn memo[bit];\n\t\t}\n\t\t\n\t\t//System.out.println(Integer.toBinaryString(bit));\n\t\t\n\t\tint max = 0;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif((bit & (1 << i)) == 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tif((bit & (1 << j)) == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(c_array[i] != c_array[j]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(is_not_covered(n, i, x_array, y_array, r_array, bit) && is_not_covered(n, j, x_array, y_array, r_array, bit)){\n\t\t\t\t\tfinal int next_bit = (bit & (~(1 << i))) & (~(1 << j));\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(bit + \" => \" + next_bit);\n\t\t\t\t\t\n\t\t\t\t\tmax = Math.max(max, dfs(next_bit, n, x_array, y_array, r_array, c_array, memo) + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn memo[bit] = max;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] x_array = new int[n];\n\t\t\tint[] y_array = new int[n];\n\t\t\tint[] r_array = new int[n];\n\t\t\tint[] c_array = new int[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tx_array[i] = sc.nextInt();\n\t\t\t\ty_array[i] = sc.nextInt();\n\t\t\t\tr_array[i] = sc.nextInt();\n\t\t\t\tc_array[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] memo = new int[1 << n];\n\t\t\tArrays.fill(memo, -1);\n\t\t\t\n\t\t\tSystem.out.println(dfs((1 << n) - 1, n, x_array, y_array, r_array, c_array, memo));\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\npublic class Main{\n\n\tstatic int INF = 2 << 27;\n\tstatic int m;\n\tstatic int n;\n\tstatic int k;\n\tstatic int d;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tData[] data = new Data[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdata[i] = new Data(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\t\t\tboolean check = check(data,i,j);\n\t\t\t\t\tif(check) data[j].up |= (1 << i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[] dp = new boolean[1 << n];\n\t\t\tdp[0] = true;\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tif(!dp[i]) continue;\n\t\t\t\tArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tlist.add(new ArrayList<Integer>());\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tif((i & (1 << j)) != 0) continue;\n\t\t\t\t\tif((i & data[j].up) != data[j].up) continue;\n\t\t\t\t\tlist.get(data[j].c).add(j);\n\t\t\t\t}\n\t\t\t\tfor(int j = 1; j < 5; j++) {\n\t\t\t\t\tfor(int k = 0; k < list.get(j).size()-1; k++) {\n\t\t\t\t\t\tfor(int l = k + 1; l < list.get(j).size(); l++) {\n\t\t\t\t\t\t\tint next = i | (1 << list.get(j).get(k) | (1 << list.get(j).get(l)));\n\t\t\t\t\t\t\tdp[next] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tif(dp[i]) max = Math.max(max, Integer.bitCount(i));\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t\t\n\t\t}\n\t}\n\tstatic boolean check(Data[] data, int a, int b) {\n\t\tint dis = (int)(Math.pow(data[a].x - data[b].x, 2) + Math.pow(data[a].y - data[b].y, 2));\n\t\treturn dis < Math.pow(data[a].r + data[b].r,2);\n\t}\n\tstatic class Data {\n\t\tint up = 0;\n\t\tint x;\n\t\tint y;\n\t\tint r;\n\t\tint c;\n\t\tData(int a, int b, int c, int d) {\n\t\t\tthis.x = a;\n\t\t\tthis.y = b;\n\t\t\tthis.r = c;\n\t\t\tthis.c = d;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.Stack;\n\n\npublic class D {\n\t\n\tpublic static boolean is_covered(int node, int bit, boolean[][] adj){\n\t\tfor(int upper = node - 1; upper >= 0; upper--){\n\t\t\tif((bit & (1 << upper)) != 0){\n\t\t\t\tcontinue;\n\t\t\t}else if(adj[upper][node]){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] x_pos  = new int[n];\n\t\t\tint[] y_pos  = new int[n];\n\t\t\tint[] rs     = new int[n];\n\t\t\tint[] colors = new int[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tx_pos[i]  = sc.nextInt();\n\t\t\t\ty_pos[i]  = sc.nextInt();\n\t\t\t\trs[i]     = sc.nextInt();\n\t\t\t\tcolors[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] cover = new boolean[n][n];\n\t\t\t\n\t\t\tfor(int upper = 0; upper < n; upper++){\n\t\t\t\tfor(int lower = upper + 1; lower < n; lower++){\n\t\t\t\t\tfinal int x_diff = (x_pos[upper] - x_pos[lower]);\n\t\t\t\t\tfinal int y_diff = (y_pos[upper] - y_pos[lower]);\n\t\t\t\t\tfinal int r_diff = (rs[upper] + rs[lower]);\n\t\t\t\t\t\n\t\t\t\t\tif(x_diff * x_diff + y_diff * y_diff < r_diff * r_diff){\n\t\t\t\t\t\tcover[upper][lower] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal int bit_max = 1 << n;\n\t\t\t\n\t\t\tint[] dp = new int[bit_max];\n\t\t\tArrays.fill(dp, -1);\n\t\t\tdp[0] = 0;\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tfor(int bit = 0; bit < bit_max; bit++){\n\t\t\t\tif(dp[bit] < 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tmax = Math.max(max, dp[bit]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println(dp[bit]);\n\t\t\t\t\n\t\t\t\tfor(int left = 0; left < n; left++){\n\t\t\t\t\tif((bit & (1 << left)) != 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(is_covered(left, bit, cover)){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//System.out.println(\"come\");\n\t\t\t\t\t\n\t\t\t\t\tfor(int right = left + 1; right < n; right++){\n\t\t\t\t\t\tif((bit & (1 << right)) != 0){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(is_covered(right, bit, cover)){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(colors[left] != colors[right]){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfinal int next_bit = ((bit | (1 << left)) | (1 << right));\n\t\t\t\t\t\t//System.out.println(next_bit);\n\t\t\t\t\t\t\n\t\t\t\t\t\tdp[next_bit] = Math.max(dp[next_bit], dp[bit] + 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tSystem.setIn(new FileInputStream(\"src/aoj1174/input.txt\"));\n\t\t\t//System.setOut(new PrintStream(new FileOutputStream(\"src/aoj1172/result.txt\")));\n\t\t} catch (FileNotFoundException e) {\n\t\t}\n\t\tnew Main().run();\n\t}\n\n\tScanner sc;\n\tvoid run() {\n\t\tsc = new Scanner(System.in);\n\t\twhile (sc.hasNext()) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tsolve(n);\n\t\t}\n\t}\n\n\tvoid solve(int n) {\n\t\tint[] xs = new int[n];\n\t\tint[] ys = new int[n];\n\t\tint[] rs = new int[n];\n\t\tint[] cs = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\txs[i] = sc.nextInt();\n\t\t\tys[i] = sc.nextInt();\n\t\t\trs[i] = sc.nextInt();\n\t\t\tcs[i] = sc.nextInt();\n\t\t}\n\t\tboolean[][] isOver = new boolean[n][n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif ((xs[i] - xs[j]) * (xs[i] - xs[j]) + (ys[i] - ys[j]) * (ys[i] - ys[j]) < (rs[i] + rs[j]) * (rs[i] + rs[j])) {\n\t\t\t\t\tisOver[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\tint ans = 0;\n\t\tboolean[] visited = new boolean[1 << n];\n\t\tvisited[(1 << n) - 1] = true;\n\t\tfor (int set = (1 << n) - 1; set >= 0; set--) {\n\t\t\tif (!visited[set]) continue;\n\t\t\tans = max(ans, n - Integer.bitCount(set));\n\n\t\t\tfor (int i = 0; i < n; i++) if ((set >> i & 1) == 1)\n\t\t\t\tfor (int j = i + 1; j < n; j++) if ((set >> j & 1) == 1)\n\t\t\t\t\tif (cs[i] == cs[j]){\n\t\t\t\t\t\tboolean ok = true;\n\t\t\t\t\t\tfor (int k = i - 1; k >= 0; k--) if ((set >> k & 1) == 1 && isOver[k][i]) ok = false;\n\t\t\t\t\t\tfor (int k = j - 1; k >= 0; k--) if ((set >> k & 1) == 1 && isOver[k][j]) ok = false;\n\n\t\t\t\t\t\tif (ok) {\n\t\t\t\t\t\t\tint nset = set;\n\t\t\t\t\t\t\tnset ^= (1 << i);\n\t\t\t\t\t\t\tnset ^= (1 << j);\n\t\t\t\t\t\t\tvisited[nset] = true;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tC [] data;\n\tclass C{\n\t\tint x,y,r,c;\n\t\tpublic C(int x, int y, int r, int c) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\tint n,len,ans;\n\t\t//boolean [][] dp = new boolean[1 << 24][13];\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdata = new C[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tdata[i] = new C(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t\t}\n\t\t\tlen = 1 << n;\n\t\t\tArrayList<Integer> dp2 = new ArrayList<Integer>();\n\t\t\tdp2.add(0);\n\t\t\tans = 0;\n\t\t\tfor(int i=0; i < n/2;i++){\n\t\t\t\tfor(int j: dp2){\n\t\t\t\t\tArrayList<Integer> used = new ArrayList<Integer>();\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\t\tfor(int l = k+1; l < n; l++){\n\t\t\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\t\t\tif(! issameC(k,l)) continue;\n\t\t\t\t\t\t\tif(isOVL(k,j) || isOVL(l,j)) continue;\n\t\t\t\t\t\t\tint num;\n\t\t\t\t\t\t\tnum = j | (1 << k);\n\t\t\t\t\t\t\tnum = num | (1 << l);\n\t\t\t\t\t\t\tint res = Integer.bitCount(num);\n\t\t\t\t\t\t\t//System.out.println(\"num= \" + num);\n\t\t\t\t\t\t\tans = Math.max(ans, res);\n\t\t\t\t\t\t\tused.add(num);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp2 = new ArrayList<Integer>(used);\n\t\t\t\t}\n\t\t\t}\n//\t\t\t//TODO debug\n//\t\t\tfor(int i= 0; i < len; i++){\n//\t\t\t\tfor(int j = 0; j < n+1; j++){\n//\t\t\t\t\tif(dp[i][j]){\n//\t\t\t\t\t\tSystem.out.print(\"1 \");\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tSystem.out.print(\"0 \");\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate boolean isOVL(int a,int num) {\n\t\tif(a == 0) return false;\n\t\tint ax = data[a].x;\n\t\tint ay = data[a].y;\n\t\tint ar= data[a].r;\n\t\tint ix,iy,ir,rr;\n\t\tdouble dis;\n\t\tfor(int i = a-1; i >= 0; i--){\n\t\t\tif(((1 << i) & num) != 0) continue;\n\t\t\tix = data[i].x;\n\t\t\tiy = data[i].y;\n\t\t\tir = data[i].r;\n\t\t\tdis = Point2D.Double.distance(ax, ay, ix, iy);\n\t\t\trr = ir + ar;\n\t\t\tif(dis < rr)return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean issameC(int a, int b) {\n\t\tif(data[a].c == data[b].c) return true;\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int n;\n\tstatic int[] x;\n\tstatic int[] y;\n\tstatic int[] r;\n\tstatic int[] c;\n\tstatic boolean[][] cover;\n\tstatic int[] dp;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx = new int[n];\n\t\t\ty = new int[n];\n\t\t\tr = new int[n];\n\t\t\tc = new int[n];\n\t\t\tcover = new boolean[n][n];\n\t\t\tdp = new int[(1<<n)];\n\t\t\tArrays.fill(dp, -1);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t\tr[i] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt()-1;\n\t\t\t\tfor(int j=0;j<i;j++) {\n\t\t\t\t\tint dx = x[j] - x[i];\n\t\t\t\t\tint dy = y[j] - y[i];\n\t\t\t\t\tint rs = r[i] + r[j];\n\t\t\t\t\tif (dx*dx+dy*dy<rs*rs) {\n\t\t\t\t\t\tcover[j][i] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dfs(0));\n\t\t}\n\t}\n\n\tpublic static int dfs(int used) {\n\t\tif (dp[used]!=-1) {\n\t\t\treturn dp[used];\n\t\t}\n\t\tint[][] canuse = new int[4][6];\n\t\tint[] canusenum = new int[4];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (((1<<i)&used) == 0) {\n\t\t\t\tboolean flag = true;\n\t\t\t\tfor(int j=0;j<i;j++) {\n\t\t\t\t\tif (((1<<j)&used) == 0 && cover[j][i]) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tcanuse[c[i]][canusenum[c[i]]++] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tboolean flag = false;\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tif (canusenum[i] >= 2) {\n\t\t\t\tfor(int j=0;j<canusenum[i]-1;j++) {\n\t\t\t\t\tfor(int k=j+1;k<canusenum[i];k++) {\n\t\t\t\t\t\tint usednext = used | (1<<canuse[i][j]) | (1<<canuse[i][k]);\n\t\t\t\t\t\tret = Math.max(ret, dfs(usednext));\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret = flag ? ret + 2 : 0;\n\t\tdp[used] = ret;\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//And Then. How Many Are There?\npublic class Main{\n\n\tint n;\n\tint[][] c;\n\tint[] col;\n\n\tboolean f(int i, int j, int x){\n\t\tif(col[i]!=col[j])return false;\n\t\tfor(int k=0;k<i;k++){\n\t\t\tif((x&(1<<k))==0)continue;\n\t\t\tif(Math.hypot(c[i][0]-c[k][0], c[i][1]-c[k][1]) < c[i][2]+c[k][2])return false;\n\t\t}\n\t\tfor(int k=0;k<j;k++){\n\t\t\tif((x&(1<<k))==0)continue;\n\t\t\tif(Math.hypot(c[j][0]-c[k][0], c[j][1]-c[k][1]) < c[j][2]+c[k][2])return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tc = new int[n][3];\n\t\t\tcol = new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tc[i][j]=sc.nextInt();\n\t\t\t\t}\n\t\t\t\tcol[i] = sc.nextInt();\n\t\t\t}\n\t\t\tList<Integer> l = new ArrayList<Integer>();\n\t\t\tl.add((1<<n)-1);\n\t\t\tboolean[] u = new boolean[1<<n];\n\t\t\tu[(1<<n)-1] = true;\n\t\t\tint step = 0;\n\t\t\twhile(!l.isEmpty()){\n\t\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\t\tfor(int s:l){\n\t\t\t\t\tint i = 0;\n\t\t\t\t\twhile(i<n){\n\t\t\t\t\t\tif((s&(1<<i))>0){\n\t\t\t\t\t\t\tint j = i+1;\n\t\t\t\t\t\t\twhile(j<n){\n\t\t\t\t\t\t\t\tif((s&(1<<j))>0){\n\t\t\t\t\t\t\t\t\tint x = s - (1<<i) - (1<<j);\n\t\t\t\t\t\t\t\t\tif(!u[x] && f(i, j, s)){\n\t\t\t\t\t\t\t\t\t\tnext.add(x);\n\t\t\t\t\t\t\t\t\t\tu[x] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl = next;\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tSystem.out.println((step-1)*2);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static boolean is_not_covered(final int n, final int purpos, int[] x_array, int[] y_array, int[] r_array, int bit){\t\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif((bit & (1 << j)) == 0){\n\t\t\t\tcontinue;\n\t\t\t}else if(purpos == j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\n\t\t\tfinal int diff_x = (x_array[purpos] - x_array[j]) * (x_array[purpos] - x_array[j]);\n\t\t\tfinal int diff_y = (y_array[purpos] - y_array[j]) * (y_array[purpos] - y_array[j]);\n\t\t\tfinal int diff_r = (r_array[purpos] + r_array[j]) * (r_array[purpos] + r_array[j]);\n\t\t\t\t\n\t\t\tif(diff_x + diff_y < diff_r && purpos > j){\n\t\t\t\t//System.out.println(purpos + \" \" + j);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//System.out.println(\"ok\");\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static int dfs(int bit, final int n, int[] x_array, int[] y_array, int[] r_array, int[] c_array, int[] memo){\n\t\tif(memo[bit] >= 0){\n\t\t\treturn memo[bit];\n\t\t}\n\t\t\n\t\t//System.out.println(Integer.toBinaryString(bit));\n\t\t\n\t\tint max = 0;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif((bit & (1 << i)) == 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tif((bit & (1 << j)) == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(c_array[i] != c_array[j]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(is_not_covered(n, i, x_array, y_array, r_array, bit) && is_not_covered(n, j, x_array, y_array, r_array, bit)){\n\t\t\t\t\tfinal int next_bit = (bit & (~(1 << i))) & (~(1 << j));\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(bit + \" => \" + next_bit);\n\t\t\t\t\t\n\t\t\t\t\tmax = Math.max(max, dfs(next_bit, n, x_array, y_array, r_array, c_array, memo) + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn memo[bit] = max;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] x_array = new int[n];\n\t\t\tint[] y_array = new int[n];\n\t\t\tint[] r_array = new int[n];\n\t\t\tint[] c_array = new int[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tx_array[i] = sc.nextInt();\n\t\t\t\ty_array[i] = sc.nextInt();\n\t\t\t\tr_array[i] = sc.nextInt();\n\t\t\t\tc_array[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] memo = new int[1 << n];\n\t\t\tArrays.fill(memo, -1);\n\t\t\t\n\t\t\tSystem.out.println(dfs((1 << n) - 1, n, x_array, y_array, r_array, c_array, memo));\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tCoin[] coins;\n\tScanner sc = new Scanner(System.in);\n\tboolean[] lapped;\n\tint n;\n\tint[] state;\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\tcoins = new Coin[n];\n\t\t\tlapped = new boolean[n];\n\t\t\tfor(int i=0;i<n;i++) coins[i] = new Coin();\n\t\t\tint S=(1<<n)-1;\n\t\t\tstate = new int[1<<n];\n\t\t\tfor(int i=0;i<(1<<n);i++) state[i] = -1;\n\t\t\tSystem.out.println(solve(S));\n\t\t}\n\t}\n\t\n\tint solve( int S ) {\n//\t\tSystem.out.println(S);\n\t\tif (state[S] >= 0) return state[S];\n\t\tanalyseLapped(S);\n//\t\tfor(int i=0;i<n;i++) System.out.print(lapped[i] + \" \");\n//\t\tSystem.out.println();\n//\t\tsc.next();\n\t\tint cnt = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif( lapped[i] ) continue;\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif ( !lapped[j] && coins[i].c == coins[j].c ) {\n\t\t\t\t\tcnt = Math.max(cnt, solve(S-((1<<i) + (1<<j)))+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn state[S] = cnt;\n\t}\n\t\n\tvoid analyseLapped(int S) {\n\t\tfor(int i=0;i<n;i++) lapped[i] = false;\n\t\tfor(int i=0;i<n;i++) {\n//\t\t\tSystem.out.println( (S>>i) & 1 );\n\t\t\tif( ((S>>i) & 1) != 1 ) { lapped[i] = true ; continue; }\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif( ((S>>j) & 1) != 1 ) { lapped[j] = true; continue; }\n//\t\t\t\tSystem.out.println(coins[i].isLapped(coins[j]));\n\t\t\t\tif( coins[i].isLapped(coins[j]) ) lapped[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\tprotected class Coin {\n\t\tint x, y, r, c;\n\t\t\n\t\tpublic Coin() {\n\t\t\tscan();\n\t\t}\n\t\t\n\t\tvoid scan() {\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\t\t\tr = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t}\n\t\t\n\t\tboolean isLapped( Coin c ) {\n\t\t\treturn (c.x-x)*(c.x-x)+(c.y-y)*(c.y-y) < (r+c.r)*(r+c.r);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tfinal int MOD = 1000000007;\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tint n;\n\tint[] x, y, r, c;\n\tint[][] memo;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) return;\n\t\t\tx = new int[n];\n\t\t\ty = new int[n];\n\t\t\tr = new int[n];\n\t\t\tc = new int[n];\n\t\t\tmemo = new int[n][1 << n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t\tr[i] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt();\n\t\t\t\tArrays.fill(memo[i], -1);\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\t// ????????????????????????????????????????±???????\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tL: for (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (c[i] != c[j])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int k = j - 1; k >= 0; k--) {\n\t\t\t\t\t\tint pDis_j = (x[k] - x[j]) * (x[k] - x[j])\n\t\t\t\t\t\t\t\t+ (y[k] - y[j]) * (y[k] - y[j]);\n\t\t\t\t\t\tint rDis_j = (r[k] + r[j]) * (r[k] + r[j]);\n\t\t\t\t\t\tint pDis_i = (x[k] - x[i]) * (x[k] - x[i])\n\t\t\t\t\t\t\t\t+ (y[k] - y[i]) * (y[k] - y[i]);\n\t\t\t\t\t\tint rDis_i = (r[k] + r[i]) * (r[k] + r[i]);\n\t\t\t\t\t\t// k?????????????????£??????????????§????????????\n\t\t\t\t\t\tif (pDis_j < rDis_j)\n\t\t\t\t\t\t\tcontinue L;\n\t\t\t\t\t\tif (k < i && pDis_i < rDis_i)\n\t\t\t\t\t\t\tcontinue L;\n\t\t\t\t\t}\n\t\t\t\t\tmax = Math.max(max, 2 + bitDP(i, 1 << i | 1 << j));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tint bitDP(int v, int mask) {\n\t\tif (memo[v][mask] != -1)\n\t\t\treturn memo[v][mask];\n\n\t\t// ?¬????i???????????????(???????????\\?????????????????????)\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tL: for (int j = i + 1; j < n; j++) {\n\t\t\t\t// ??¢???i or j????????£?????????\n\t\t\t\tif ((mask & (1 << i)) != 0 || (mask & (1 << j)) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int k = j - 1; k >= 0; k--) {\n\t\t\t\t\t// ??¢???k???????????????????????????\n\t\t\t\t\tif ((mask & k) == 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint pDis_j = (x[k] - x[j]) * (x[k] - x[j]) + (y[k] - y[j])\n\t\t\t\t\t\t\t* (y[k] - y[j]);\n\t\t\t\t\tint rDis_j = (r[k] + r[j]) * (r[k] + r[j]);\n\t\t\t\t\tint pDis_i = (x[k] - x[i]) * (x[k] - x[i]) + (y[k] - y[i])\n\t\t\t\t\t\t\t* (y[k] - y[i]);\n\t\t\t\t\tint rDis_i = (r[k] + r[i]) * (r[k] + r[i]);\n\n\t\t\t\t\t// k?????????????????£??????????????§????????????\n\t\t\t\t\tif (pDis_j < rDis_j)\n\t\t\t\t\t\tcontinue L;\n\t\t\t\t\tif (k < i && pDis_i < rDis_i)\n\t\t\t\t\t\tcontinue L;\n\t\t\t\t}\n\t\t\t\tres = Math.max(res, 2 + bitDP(i, mask | (1 << i | 1 << j)));\n\t\t\t}\n\t\t}\n\t\treturn memo[v][mask] = res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(long[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (a[i] >= border)\n\tint lower_bound(int a[], int border) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (border <= a[mid]) {\n\t\t\t\tr = mid;\n\t\t\t} else {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n  Scanner sc;\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Disk {\n    int x;\n    int y;\n    int c;\n    int r;\n\n    boolean isIn(Disk disk) {\n      return Math.pow(this.r + disk.r, 2) > Math.pow(this.x - disk.x, 2) + Math.pow(this.y - disk.y, 2);\n    }\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      Disk[] list = new Disk[n];\n      for (int i = 0; i < n; ++i) {\n        Disk d = new Disk();\n        d.x = ni();\n        d.y = ni();\n        d.r = ni();\n        d.c = ni();\n        list[i] = d;\n      }\n\n      int[] dp = new int[1 << n];\n      Arrays.fill(dp, -1);\n      dp[0] = 0;\n      for (int i = 0; i < 1 << n; ++i) {\n        if (dp[i] < 0) {\n          continue;\n        }\n        for (int j = 0; j < n; ++j) {\n          if (((i >> j) & 1) == 1) {\n            continue;\n          }\n          boolean flag = true;\n          for (int a = 0; a < j; ++a) {\n            if (((i >> a) & 1) == 1) {\n              continue;\n            }\n            flag &= !list[j].isIn(list[a]);\n          }\n          if (!flag) {\n            continue;\n          }\n          for (int k = j + 1; k < n; ++k) {\n            if (((i >> k) & 1) == 1) {\n              continue;\n            }\n            boolean glag = true;\n            for (int a = 0; a < k; ++a) {\n              if (((i >> a) & 1) == 1) {\n                continue;\n              }\n              glag &= !list[k].isIn(list[a]);\n            }\n            if (!glag) {\n              continue;\n            }\n            if (list[j].c != list[k].c) {\n              continue;\n            }\n\n//            debug(j, k);\n\n            dp[i | (1 << j) | (1 << k)] = Math.max(dp[i] + 1, dp[i | (1 << j) | (1 << k)]);\n          }\n        }\n      }\n      int max = 0;\n      for (int i = 0; i < 1 << n; ++i) {\n        max = Math.max(max, dp[i]);\n      }\n\n      System.out.println(max * 2);\n    }\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tnew AOJ1175().doIt(n);\n\t\t}\n\t}\n\n\n\tclass AOJ1175{\n\t\tint cnt[][];\n\t\tint dfs(long bit,int num){\n\t\t\tif(memo[(int)bit]>=0)return memo[(int)bit];\n//\t\t\tSystem.out.println(Long.toBinaryString(bit));\n\t\t\tint result = num;\n\t\t\tArrays.fill(cnt[num/2],0);\n\t\t\tfor(int i=0;i<n;i++)for(int s=i-1;s>=0;s--)if((bit>>i)%2==1&&(bit>>s)%2==1){\n\t\t\t\tif(Point2D.distance(data[i].x, data[i].y, data[s].x, data[s].y)<data[s].r+data[i].r)cnt[num/2][i]++;\n\t\t\t}\n\t\t\tfor(int c=1;c<=4;c++){//color\n\t\t\t\tfor(int i=0;i<n;i++)for(int s=i+1;s<n;s++)if(data[i].color==c&&data[s].color==c&&cnt[num/2][i]==0&&cnt[num/2][s]==0){\n\t\t\t\t\tif(i==s||((bit>>i)%2==0)||((bit>>s)%2==0))continue;\n\t\t\t\t\tbit -= 1 << i;\n\t\t\t\t\tbit -= 1 << s;\n//\t\t\t\t\tSystem.out.println(i+\" \"+s);\n\t\t\t\t\tresult = Math.max(result, dfs(bit,num+2));\n\t\t\t\t\tbit += 1 << i;\n\t\t\t\t\tbit += 1 << s;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn memo[(int)bit] = result;\n\t\t}\n\t\tint[] memo = new int[(1<<24)];\n\t\tint n;\n\t\tData data[];\n\t\tvoid doIt(int n){//<=24\n\t\t\tcnt = new int[n][n];\n\t\t\tArrays.fill(memo, -1);\n\t\t\tthis.n = n;\n\t\t\tdata = new Data[n];\n\t\t\tfor(int i=0;i<n;i++)data[i] = new Data(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\tlong bit=0;\n\t\t\tfor(int i=0;i<n;i++)bit += 1 << i;\n\t\t\tint result = dfs(bit,0);\n\t\t\tSystem.out.println(result);\n\t\t}\n\n\t\tclass Data{\n\t\t\tint x,y,color,r;\n\t\t\tpublic Data(int x,int y,int r,int color) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.r = r;\n\t\t\t\tthis.color = color;\n\t\t\t}\n\t\t}\n\t}\n\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint INF = 100000000;\n\tHashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\n\tclass Circle {\n\t\tint x;\n\t\tint y;\n\t\tint r;\n\t\tint c;\n\t\t\n\t\tCircle(int x, int y, int r, int c) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\t\n\tboolean intersect(Circle c1, Circle c2) {\n\t\tdouble dx = c1.x - c2.x, dy = c1.y - c2.y;\n\t\tdouble a = (c1.r + c2.r) * (c1.r + c2.r);\n\t\tdouble b = dx * dx + dy * dy;\n\t\treturn a > b;\n\t}\n\t\n\tint calc(Circle[] circle, int bit) {\n\t\t\n\t\tif (map.containsKey(bit)) return map.get(bit);\n\t\t\n\t\tint n = circle.length;\n\t\tint res = n - Integer.bitCount(bit);\n\t\t\n\t\tboolean[] can = new boolean[n];\n\t\tArrays.fill(can, true);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (((bit >> i) & 1) == 0) continue;\n\t\t\t\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (((bit >> j) & 1) == 0) continue;\n\t\t\t\tif (intersect(circle[i], circle[j])) {\n\t\t\t\t\tcan[i] = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (((1 << i) & bit) == 0 || !can[i]) continue;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (((1 << j) & bit) == 0 || !can[j]) continue;\n\t\t\t\tif (circle[i].c != circle[j].c) continue;\n\t\t\t\t\n\t\t\t\tint nbit = bit;\n\t\t\t\tnbit -= (1 << i);\n\t\t\t\tnbit -= (1 << j);\n\t\t\t\t\n\t\t\t\tres = Math.max(res, calc(circle, nbit));\n\t\t\t}\n\t\t}\n\t\t\n\t\tmap.put(bit, res);\n\t\treturn res;\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tCircle[] circle = new Circle[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tcircle[i] = new Circle(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\t}\n\t\t\t\n\t\t\tmap.clear();\n\t\t\tout.println(calc(circle, (1 << n) - 1));\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1175();\n\t}\n\tfinal int INF=1<<28;\n\t\n\tclass AOJ1175{\n\t\tAOJ1175(){\n\t\t\tccc = new Circle[25][2];\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tCircle[] c;\n\t\tCircle[][] ccc;\n\t\tHashSet<Integer> vtd;\n\t\tint N;\n\t\tvoid solve(){\n\t\t\tc=new Circle[N];\n\t\t\tfor(int i=0; i<N; ++i)\tc[i]=new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt()-1);\n\t\t\tvtd = new HashSet<Integer>();\n\t\t\tSystem.out.println(dfs(c, 0));\n\t\t}\n\t\tint dfs(Circle[] c,int depth){\n//\t\t\tSystem.out.println(depth+\" \"+Arrays.toString(c));\n\t\t\tint ret=0,hash=0;\n\t\t\tfor(int i=0; i<N; ++i){\n\t\t\t\tif(c[i]==null)\t++ret;\n\t\t\t\telse\t\t\thash |= 1<<i;\n\t\t\t}\n\t\t\tif(vtd.contains(hash))\treturn ret;\n\t\t\tvtd.add(hash);\n\t\t\tArrayList<ArrayList<Integer>> list=list(c);\n//\t\t\tSystem.out.println(depth+\" \"+list);\n\t\t\tfor(int i=0; i<4; ++i){\n\t\t\t\tif(list.get(i).size() >= 2){\n\t\t\t\t\tint n=list.get(i).size(), b=(1<<n)-1;\n\t\t\t\t\tfor(int j=3; j<=b; ++j)if(Integer.bitCount(j)==2){\n\t\t\t\t\t\tfor(int k=0,l=0; k<n; ++k)if((j&(1<<k))>0){\n\t\t\t\t\t\t\tccc[depth][l++]=c[list.get(i).get(k)];\n\t\t\t\t\t\t\tc[list.get(i).get(k)]=null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret = max(ret, dfs(c, depth+1));\n\t\t\t\t\t\tfor(int k=0,l=0; k<n; ++k)if((j&(1<<k))>0)\tc[list.get(i).get(k)]=ccc[depth][l++];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tArrayList<ArrayList<Integer>> list(Circle[] c){\n\t\t\tArrayList<ArrayList<Integer>> ret=new ArrayList<ArrayList<Integer>>(4);\n\t\t\tfor(int i=0; i<4; ++i)\tret.add(new ArrayList<Integer>());\n\t\t\tfor(int i=0; i<N; ++i)if(c[i]!=null){\n\t\t\t\tboolean flg=true;\n\t\t\t\tfor(int j=0; j<i; ++j)if(c[j]!=null){\n\t\t\t\t\tflg = (c[i].r+c[j].r) <= (c[i].p.distance(c[j].p));\n\t\t\t\t\tif(!flg)\tbreak;\n\t\t\t\t}\n\t\t\t\tif(flg)\tret.get(c[i].c).add(i);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tclass Circle{\n\t\t\tPoint2D p;\n\t\t\tdouble r;\n\t\t\tint c;\n\t\t\tCircle(double x,double y,double r,int c){\n\t\t\t\tthis.p=new Point2D.Double(x,y);\n\t\t\t\tthis.r=r;\n\t\t\t\tthis.c=c;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn p.getX()+\",\"+p.getY()+\",\"+r+\" \"+c;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n \npublic class Main {\n    Scanner in = new Scanner(System.in);\n    public static void main(String[] args) {\n        new Main();\n    }\n \n    public Main() {\n        AOJ1175 obj = new AOJ1175();\n        while(true){\n            int n = in.nextInt();\n            if(n==0)break;\n            obj.doIt(n);\n        }\n    }\n \n    class AOJ1175{\n        boolean[] memo = new boolean[(1<<24)];\n        void doIt(int n){\n            Arrays.fill(memo,false);\n            Data[] data = new Data[n];\n            for(int i=0;i<n;i++)data[i] = new Data(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n            long bit = 0;\n            for(int i=0;i<n;i++)bit += 1 << i;\n            LinkedList<State> q = new LinkedList<State>();\n            q.add(new State(bit, 0));\n            int cnt[] = new int[n];\n            int result = -1;\n            while(q.size()>0){\n                State now = q.remove();\n                bit = now.bit;\n                memo[(int)bit] = true;\n                result = Math.max(result, now.num);\n                Arrays.fill(cnt,0);\n                for(int i=0;i<n;i++)for(int s=i-1;s>=0;s--)if((bit>>i)%2==1&&(bit>>s)%2==1){\n                    if(Point2D.distance(data[i].x, data[i].y, data[s].x, data[s].y)<data[s].r+data[i].r)cnt[i]++;\n                }\n                for(int i=0;i<n;i++)for(int s=i+1;s<n;s++)if(data[i].color==data[s].color&&cnt[i]==0&&cnt[s]==0){\n                    if(i==s||((bit>>i)%2==0)||((bit>>s)%2==0))continue;\n                    long bit2 = bit-(1<<i)-(1<<s);\n                    if(memo[(int)bit2])continue;\n                    q.add(new State(bit2,now.num+2));\n                }\n            }\n            System.out.println(result);\n        }\n \n        class State{\n            long bit;\n            int num;\n            public State(long bit,int num){\n                this.bit = bit;\n                this.num = num;\n            }\n        }\n \n        class Data{\n            int x,y,color,r;\n            public Data(int x,int y,int r,int color) {\n                this.x = x;\n                this.y = y;\n                this.r = r;\n                this.color = color;\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tnew AOJ1175().doIt(n);\n\t\t}\n\t}\n\n\tclass AOJ1175{\n\t\tvoid doIt(int n){\n\t\t\tboolean[] memo = new boolean[(1<<n)];\n\t\t\tArrays.fill(memo,false);\n\t\t\tData[] data = new Data[n];\n\t\t\tfor(int i=0;i<n;i++)data[i] = new Data(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\tlong bit = 0;\n\t\t\tfor(int i=0;i<n;i++)bit += 1 << i;\n\t\t\tLinkedList<State> q = new LinkedList<State>();\n\t\t\tq.add(new State(bit, 0));\n\t\t\tint cnt[] = new int[n];\n\t\t\tint result = -1;\n\t\t\twhile(q.size()>0){\n\t\t\t\tState now = q.remove();\n\t\t\t\tbit = now.bit;\n\t\t\t\tresult = Math.max(result, now.num);\n\t\t\t\tArrays.fill(cnt,0);\n\t\t\t\tfor(int i=0;i<n;i++)for(int s=i-1;s>=0;s--)if((bit>>i)%2==1&&(bit>>s)%2==1){\n\t\t\t\t\tif(Point2D.distance(data[i].x, data[i].y, data[s].x, data[s].y)<data[s].r+data[i].r)cnt[i]++;\n\t\t\t\t}\n\n\t\t\t\tfor(int i=0;i<n;i++)for(int s=i+1;s<n;s++)if(data[i].color==data[s].color&&cnt[i]==0&&cnt[s]==0){\n\t\t\t\t\tif(i==s||((bit>>i)%2==0)||((bit>>s)%2==0))continue;\n\t\t\t\t\tlong bit2 = bit-(1<<i)-(1<<s);\n\t\t\t\t\tq.add(new State(bit2,now.num+2));\n\t\t\t\t}\n\n\t\t\t\tif(memo[(int)bit])continue;\n\t\t\t\tmemo[(int)bit] = true;\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\n\t\tclass State{\n\t\t\tlong bit;\n\t\t\tint num;\n\t\t\tpublic State(long bit,int num){\n\t\t\t\tthis.bit = bit;\n\t\t\t\tthis.num = num;\n\t\t\t}\n\t\t}\n\n\t\tclass Data{\n\t\t\tint x,y,color,r;\n\t\t\tpublic Data(int x,int y,int r,int color) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.r = r;\n\t\t\t\tthis.color = color;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n  \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n  \n    public static void main(String[] args) {\n        new Main(); \n    }\n  \n    public Main() {\n        new aoj1155().doIt();\n    }\n    class aoj1155{\n    \tint dp_table(int n){\n    \t\tCircle[] c=new Circle[n];\n            int[] a=new int[n];\n            for(int i=0; i<n; i++){\n                c[i]=new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt()-1);\n                for(int j=0; j<i;j++){\n                \tif(c[i].dis+c[j].dis > c[i].p.distance(c[j].p)) a[i] |= (1<<j);\n                }\n            }\n            int ans=n;\n            boolean[] dp=new boolean[1<<n];\n            dp[(1<<n)-1]=true;\n            for(int i=(1<<n)-1; i>=0; i--){\n            \tif(dp[i]){\n            \t\tfor(int j=0; j<n; j++){\n            \t\t\tif((i&(1<<j))>0 && (i&a[j])==0){\n            \t\t\t\tfor(int k=j+1; k<n; k++){\n            \t\t\t\t\tif(j!=k && (i&(1<<k))>0 && (i&a[k])==0 && c[j].color==c[k].color){\n            \t\t\t\t\t\tint tmp=(1<<j)|(1<<k);\n            \t\t\t\t\t\tint next=i&(((1<<n)-1)^tmp);\n            \t\t\t\t\t\tdp[next]=true;\n            \t\t\t\t\t\tans = Math.min(ans, Integer.bitCount(next));\n            \t\t\t\t\t}\n            \t\t\t\t}\n            \t\t\t}\n                    }\n                }\n            }\n            return -(ans - n);\n    \t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tint n = sc.nextInt();\n    \t\t\tif(n == 0)break;\n                System.out.println(dp_table(n));\n    \t\t}\n    \t}\n    \tclass Circle{\n    \t\tPoint2D p;\n    \t\tdouble dis;\n    \t\tint color;\n    \t\tpublic Circle(double x,double y,double dis,int color){\n    \t\t\tthis.p = new Point2D.Double(x,y);\n    \t\t\tthis.dis = dis;\n    \t\t\tthis.color = color;\n    \t\t}\n    \t}\n     }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n  class Circle {\n    byte x, y, r, c;\n\n    Circle(byte x, byte y, byte r, byte c) {\n      this.x = x;\n      this.y = y;\n      this.r = r;\n      this.c = c;\n    }\n\n    boolean intersect(Circle o) {\n      return ( (int) r + o.r ) * ( (int) r + o.r ) > ( (int) x - o.x )\n          * ( (int) x - o.x ) + ( (int) y - o.y ) * ( (int) y - o.y );\n    }\n  }\n\n  int n;\n  Circle[] list;\n  boolean[] done;\n\n  byte[] memo;\n  boolean[] fill;\n\n  byte dfs(int BITS) {\n    if ( fill[ BITS ] ) {\n      return memo[ BITS ];\n    }\n    byte max = 0;\n\n    for ( int i = 0; i < n; ++i ) {\n      if ( done[ i ] || !isTop( i ) )\n        continue;\n      for ( int j = i - 1; 0 <= j; --j ) {\n        if ( done[ j ] || !isTop( j ) )\n          continue;\n\n        if ( list[ i ].c == list[ j ].c ) {\n          done[ i ] = done[ j ] = true;\n          max = (byte) Math\n              .max( max, 2 + dfs( BITS | ( 1 << i ) | ( 1 << j ) ) );\n          done[ i ] = done[ j ] = false;\n        }\n      }\n    }\n\n    fill[ BITS ] = true;\n    memo[ BITS ] = max;\n    return max;\n  }\n\n  boolean isTop(int index) {\n    boolean flag = true;\n    for ( int i = index - 1; 0 <= i; --i ) {\n      flag &= done[ i ] | !list[ i ].intersect( list[ index ] );\n    }\n    return flag;\n  }\n\n  void run() {\n    for ( ;; ) {\n      n = ni();\n      if ( n == 0 ) {\n        break;\n      }\n\n      list = new Circle[n];\n      done = new boolean[n];\n      fill = new boolean[1 << n];\n      memo = new byte[1 << n];\n      for ( int i = 0; i < n; ++i ) {\n        byte x = ni();\n        byte y = ni();\n        byte r = ni();\n        byte c = ni();\n        list[ i ] = new Circle( x, y, r, c );\n        // debug(isTop(i));\n      }\n\n      System.out.println( dfs( 0 ) );\n    }\n  }\n\n  Main() {\n    sc = new Scanner( System.in );\n  }\n\n  byte ni() {\n    return (byte) sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println( Arrays.deepToString( os ) );\n  }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tnew AOJ1175().doIt(n);\n\t\t}\n\t}\n\t\n\t\n\tclass AOJ1175{\n\t\tvoid doIt(int n){//<=24\n\t\t\tData[] data = new Data[n];\n\t\t\tfor(int i=0;i<n;i++)data[i] = new Data(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\tboolean sw = true;\n\t\t\tboolean[] remove = new boolean[n];\n\t\t\tArrays.fill(remove, true);\n\t\t\twhile(sw){\n\t\t\t\tsw = false;\n\t\t\t\tArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();\n\t\t\t\tfor(int i=0;i<n;i++)list.add(new ArrayList<Integer>());\n\t\t\t\tfor(int i=0;i<n;i++)if(remove[i]){\n\t\t\t\t\tPoint2D p1 = new Point2D.Double(data[i].x,data[i].y);\n\t\t\t\t\tfor(int s=i-1;s>=0;s--)if(p1.distance(new Point2D.Double(data[s].x, data[s].y))<data[s].r+data[i].r\n\t\t\t\t\t\t\t&&remove[s])list.get(i).add(s);\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(list);\n\t\t\t\tint flg[] = new int[5];\n\t\t\t\tfor(int i=0;i<n;i++)if(remove[i]&&list.get(i).size()==0)flg[data[i].color]++;\n\t\t\t\tfor(int i=0;i<n;i++)if(remove[i]){\n\t\t\t\t\tif(flg[data[i].color]==2){\n\t\t\t\t\t\tremove[i] = false;\n\t\t\t\t\t\tsw = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 0;\n\t\t\tfor(int i=0;i<n;i++)if(!remove[i])cnt++;\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t\tclass Data{\n\t\t\tint x,y,color,r;\n\t\t\tpublic Data(int x,int y,int r,int color) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.r = r;\n\t\t\t\tthis.color = color;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tfinal double EPS = 1.0e-08;\n\tC [] data;\n\tclass C{\n\t\tint x,y,r,c;\n\t\tpublic C(int x, int y, int r, int c) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\tint n,len,ans;\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdata = new C[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tdata[i] = new C(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t\t}\n\t\t\tlen = 1 << n;\n\t\t\tboolean [] dp = new boolean[len];\n\t\t\tdp[0] = true;\n\t\t\tans = 0;\n\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\tif(! dp[j]) continue;\n\t\t\t\tArrayList<Integer> checked = new ArrayList<Integer>();\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\tif(isOVL(k,j)) continue;\n\t\t\t\t\t\n\t\t\t\t\tfor(int l = 0; l < checked.size(); l++){\n\t\t\t\t\t\tint pair = checked.get(l);\n\t\t\t\t\t\tif(! issameC(k,pair)) continue;\n\t\t\t\t\t\tint num;\n\t\t\t\t\t\tnum = j | (1 << k);\n\t\t\t\t\t\tnum = num | (1 << pair);\n\t\t\t\t\t\tdp[num] = true;\n\t\t\t\t\t\tint res = Integer.bitCount(num);\n\t\t\t\t\t\tans = Math.max(ans, res);\n\t\t\t\t\t}\n\t\t\t\t\t//store\n\t\t\t\t\tchecked.add(k);\n\t\t\t\t}\n\t\t\t}\n//\t\t\t//TODO debug\n//\t\t\tfor(int i= 0; i < len; i++){\n//\t\t\t\tfor(int j = 0; j < n+1; j++){\n//\t\t\t\t\tif(dp[i][j]){\n//\t\t\t\t\t\tSystem.out.print(\"1 \");\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tSystem.out.print(\"0 \");\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate boolean isOVL(int a,int num) {\n\t\tif(a == 0) return false;\n\t\tint ax = data[a].x;\n\t\tint ay = data[a].y;\n\t\tint ar= data[a].r;\n\t\tint ix,iy,ir,rr;\n\t\tdouble dis;\n\t\tfor(int i = a-1; i >= 0; i--){\n\t\t\tif(((1 << i) & num) != 0) continue;\n\t\t\tix = data[i].x;\n\t\t\tiy = data[i].y;\n\t\t\tir = data[i].r;\n\t\t\tdis = Point2D.Double.distance(ax, ay, ix, iy);\n\t\t\trr = ir + ar;\n\t\t\tif(dis + EPS < rr)return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean issameC(int a, int b) {\n\t\tif(data[a].c == data[b].c) return true;\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1175();\n\t}\n\tfinal int INF=1<<28;\n\t\n\tclass AOJ1175{\n\t\tAOJ1175(){\n\t\t\tccc = new Circle[25][2];\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tCircle[] c;\n\t\tCircle[][] ccc;\n\t\tint N;\n\t\tvoid solve(){\n\t\t\tc=new Circle[N];\n\t\t\tfor(int i=0; i<N; ++i)\tc[i]=new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt()-1);\n\t\t\t\n\t\t\tSystem.out.println(dfs(c, 0));\n\t\t}\n\t\tint dfs(Circle[] c,int depth){\n//\t\t\tSystem.out.println(depth+\" \"+Arrays.toString(c));\n\t\t\tint ret=0;\n\t\t\tfor(int i=0; i<N; ++i)if(c[i]==null)\t++ret;\n\t\t\tArrayList<ArrayList<Integer>> list=list(c);\n//\t\t\tSystem.out.println(depth+\" \"+list);\n\t\t\tfor(int i=0; i<4; ++i){\n\t\t\t\tif(list.get(i).size() >= 2){\n\t\t\t\t\tint n=list.get(i).size(), b=(1<<n)-1;\n\t\t\t\t\tfor(int j=3; j<=b; ++j)if(Integer.bitCount(j)==2){\n\t\t\t\t\t\tfor(int k=0,l=0; k<n; ++k)if((j&(1<<k))>0){\n\t\t\t\t\t\t\tccc[depth][l++]=c[list.get(i).get(k)];\n\t\t\t\t\t\t\tc[list.get(i).get(k)]=null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret = max(ret, dfs(c, depth+1));\n\t\t\t\t\t\tfor(int k=0,l=0; k<n; ++k)if((j&(1<<k))>0)\tc[list.get(i).get(k)]=ccc[depth][l++];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tArrayList<ArrayList<Integer>> list(Circle[] c){\n\t\t\tArrayList<ArrayList<Integer>> ret=new ArrayList<ArrayList<Integer>>(4);\n\t\t\tfor(int i=0; i<4; ++i)\tret.add(new ArrayList<Integer>());\n\t\t\tfor(int i=0; i<N; ++i)if(c[i]!=null){\n\t\t\t\tboolean flg=true;\n\t\t\t\tfor(int j=0; j<i; ++j)if(c[j]!=null){\n\t\t\t\t\tflg = (c[i].r+c[j].r) <= (c[i].p.distance(c[j].p));\n\t\t\t\t\tif(!flg)\tbreak;\n\t\t\t\t}\n\t\t\t\tif(flg)\tret.get(c[i].c).add(i);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tclass Circle{\n\t\t\tPoint2D p;\n\t\t\tdouble r;\n\t\t\tint c;\n\t\t\tCircle(double x,double y,double r,int c){\n\t\t\t\tthis.p=new Point2D.Double(x,y);\n\t\t\t\tthis.r=r;\n\t\t\t\tthis.c=c;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn p.getX()+\",\"+p.getY()+\",\"+r+\" \"+c;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n  Scanner sc;\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Disk {\n    byte x;\n    byte y;\n    byte c;\n    byte r;\n\n    boolean isIn(Disk disk) {\n      return Math.pow(this.r + disk.r, 2) > Math.pow(this.x - disk.x, 2) + Math.pow(this.y - disk.y, 2);\n    }\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      Disk[] list = new Disk[n];\n      for (int i = 0; i < n; ++i) {\n        Disk d = new Disk();\n        d.x = (byte) ni();\n        d.y = (byte) ni();\n        d.r = (byte) ni();\n        d.c = (byte) ni();\n        list[i] = d;\n      }\n\n      byte[] dp = new byte[1 << n];\n      Arrays.fill(dp, (byte) -1);\n      dp[0] = 0;\n      for (int i = 0; i < 1 << n; ++i) {\n        if (dp[i] < 0) {\n          continue;\n        }\n        for (int j = 0; j < n; ++j) {\n          if (((i >> j) & 1) == 1) {\n            continue;\n          }\n          boolean flag = true;\n          for (int a = 0; a < j; ++a) {\n            if (((i >> a) & 1) == 1) {\n              continue;\n            }\n            flag &= !list[j].isIn(list[a]);\n          }\n          if (!flag) {\n            continue;\n          }\n          for (int k = j + 1; k < n; ++k) {\n            if (((i >> k) & 1) == 1) {\n              continue;\n            }\n            boolean glag = true;\n            for (int a = 0; a < k; ++a) {\n              if (((i >> a) & 1) == 1) {\n                continue;\n              }\n              glag &= !list[k].isIn(list[a]);\n            }\n            if (!glag) {\n              continue;\n            }\n            if (list[j].c != list[k].c) {\n              continue;\n            }\n\n//            debug(j, k);\n\n            dp[i | (1 << j) | (1 << k)] = (byte) Math.max(dp[i] + 1, dp[i | (1 << j) | (1 << k)]);\n          }\n        }\n      }\n      int max = 0;\n      for (int i = 0; i < 1 << n; ++i) {\n        max = Math.max(max, dp[i]);\n      }\n\n      System.out.println(max * 2);\n    }\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint n;\n\tint[] x, y, r, c;\n\tbyte[] memo;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) return;\n\t\t\tx = new int[n];\n\t\t\ty = new int[n];\n\t\t\tr = new int[n];\n\t\t\tc = new int[n];\n\t\t\tmemo = new byte[1 << n];\n\t\t\tfor (int i = 0; i < 1 << n; i++) memo[i] = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t\tr[i] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\t// ????????????????????????????????????????±???????\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (c[i] != c[j]) continue;\n\t\t\t\t\tif (!noCover(i , j , 0)) continue;\n\t\t\t\t\tmax = Math.max(max, 2 + bitDP(1 << i | 1 << j));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tint bitDP(int mask) {\n\t\tif (memo[mask] != -1) return memo[mask];\n\n\t\tbyte res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (c[i] != c[j]) continue;\n\t\t\t\t// ??¢???i or j????????£?????????\n\t\t\t\tif ((mask & (1 << i)) != 0 || (mask & (1 << j)) != 0) continue;\n\t\t\t\tif (!noCover(i, j, mask)) continue;\n\t\t\t\tres = (byte) Math.max(res, 2 + bitDP(mask | (1 << i | 1 << j)));\n\t\t\t}\n\t\t}\n\t\treturn memo[mask] = res;\n\t}\n\n\tboolean noCover(int i, int j, int mask) {\n\t\tfor (int k = j - 1; k >= 0; k--) {\n\t\t\t// ??¢???k???????????????????????????\n\t\t\tif ((mask & 1 << k) != 0) continue;\n\t\t\tint pDis_j = (x[k] - x[j]) * (x[k] - x[j]) + (y[k] - y[j]) * (y[k] - y[j]);\n\t\t\tint rDis_j = (r[k] + r[j]) * (r[k] + r[j]);\n\t\t\tint pDis_i = (x[k] - x[i]) * (x[k] - x[i]) + (y[k] - y[i]) * (y[k] - y[i]);\n\t\t\tint rDis_i = (r[k] + r[i]) * (r[k] + r[i]);\n\t\t\t// k?????????????????£??????????????§????????????\n\t\t\tif (pDis_j < rDis_j) return false;\n\t\t\tif (k < i && pDis_i < rDis_i) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\npublic class Main{\n\n\tstatic int INF = 2 << 27;\n\tstatic int m;\n\tstatic int n;\n\tstatic int k;\n\tstatic int d;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tData[] data = new Data[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdata[i] = new Data(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\t\t\tboolean check = check(data,i,j);\n\t\t\t\t\tif(check) data[j].up |= (1 << i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[] dp = new boolean[1 << n];\n\t\t\tdp[0] = true;\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tif(!dp[i]) continue;\n\t\t\t\tArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tlist.add(new ArrayList<Integer>());\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tif((i & (1 << j)) != 0) continue;\n\t\t\t\t\tif((i & data[j].up) != data[j].up) continue;\n\t\t\t\t\tlist.get(data[j].c).add(j);\n\t\t\t\t}\n\t\t\t\tIN:for(int j = 1; j < 5; j++) {\n\t\t\t\t\tif(list.get(j).size() < 2) continue;\n\t\t\t\t\tfor(int k = 0; k < list.get(j).size(); k++) {\n\t\t\t\t\t\tfor(int l = k + 1; l < list.get(j).size(); l++) {\n\t\t\t\t\t\t\tint next = i;\n\t\t\t\t\t\t\tnext |= (1 << list.get(j).get(k));\n\t\t\t\t\t\t\tnext |= (1 << list.get(j).get(l));\n\t\t\t\t\t\t\tdp[next] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tif(dp[i]) max = Math.max(max, Integer.bitCount(i));\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t\t\n\t\t}\n\t}\n\tstatic boolean check(Data[] data, int a, int b) {\n\t\tint dis = (int)(Math.pow(data[a].x - data[b].x, 2) + Math.pow(data[a].y - data[b].y, 2));\n\t\treturn dis < Math.pow(data[a].r + data[b].r,2);\n\t}\n\tstatic class Data {\n\t\tint up = 0;\n\t\tint x;\n\t\tint y;\n\t\tint r;\n\t\tint c;\n\t\tData(int a, int b, int c, int d) {\n\t\t\tthis.x = a;\n\t\t\tthis.y = b;\n\t\t\tthis.r = c;\n\t\t\tthis.c = d;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint INF = 100000000;\n\tBitSet visited;\n\t\n\tclass Circle {\n\t\tint x;\n\t\tint y;\n\t\tint r;\n\t\tint c;\n\t\t\n\t\tCircle(int x, int y, int r, int c) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\t\n\tboolean intersect(Circle c1, Circle c2) {\n\t\tdouble dx = c1.x - c2.x, dy = c1.y - c2.y;\n\t\tdouble a = (c1.r + c2.r) * (c1.r + c2.r);\n\t\tdouble b = dx * dx + dy * dy;\n\t\treturn a > b;\n\t}\n\t\n\tint res = 0;\n\tint[] mask;\n\tvoid calc(Circle[] circle, int bit) {\n\t\tif (visited.get(bit)) return;\n\t\t\n\t\tint n = circle.length;\n\t\tres = Math.max(res, n - Integer.bitCount(bit));\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (((1 << i) & bit) == 0 || (mask[i] & bit) != 0) continue;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (((1 << j) & bit) == 0 || (mask[j] & bit) != 0) continue;\n\t\t\t\tif (circle[i].c != circle[j].c) continue;\n\t\t\t\t\n\t\t\t\tint nbit = bit;\n\t\t\t\tnbit -= (1 << i);\n\t\t\t\tnbit -= (1 << j);\n\t\t\t\t\n\t\t\t\tcalc(circle, nbit);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvisited.set(bit);\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tCircle[] circle = new Circle[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tcircle[i] = new Circle(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\t}\n\t\t\t\n\t\t\tvisited = new BitSet(1 << n);\n\t\t\tmask = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (intersect(circle[i], circle[j])) mask[i] |= (1 << j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = 0;\n\t\t\tcalc(circle, (1 << n) - 1);\n\t\t\tout.println(res);\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static int n;\n    static ArrayList<Circle> circles;\n    static int max;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            n = sc.nextInt();\n            if (n == 0) {\n                break;\n            }\n            circles = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                int r = sc.nextInt();\n                int c = sc.nextInt();\n                circles.add(new Circle(x, y, r, c, i));\n            }\n            for (int i = 0; i < n - 1; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    Circle c1 = circles.get(i);\n                    Circle c2 = circles.get(j);\n                    if (c1.dip(c2)) {\n                        c1.children.add(c2);\n                        c2.parents.add(c1);\n                    }\n                }\n            }\n            max = Integer.MIN_VALUE;\n            dp(0);\n            System.out.println(max * 2);\n        }\n    }\n\n    static void dp(int k) {\n        max = Math.max(max, k);\n\n        ArrayList<Circle> tops = new ArrayList<>();\n        for (Circle c: circles) {\n            if (c.parents.isEmpty()) {\n                tops.add(c);\n            }\n        }\n\n        for (int i = 1; i <= 4; i++) {\n            ArrayList<Circle> items = new ArrayList<>();\n            for (Circle c: tops) {\n                if (c.c == i) {\n                    items.add(c);\n                }\n            }\n\n            if (items.size() < 2) {\n                continue;\n            }\n            // TODO: sum6 ?????????\n            if (items.size() == 6) {\n                circles.removeAll(items);\n                for (Circle c: items) {\n                    for (Circle t : c.children) {\n                        t.parents.remove(c);\n                    }\n                }\n                dp(k + 3);\n                for (Circle c: items) {\n                    for (Circle t : c.children) {\n                        t.parents.add(c);\n                    }\n                }\n                circles.addAll(items);\n            } else {\n                for (int j = 0; j < items.size() - 1; j++) {\n                    for (int l = j + 1; l < items.size(); l++) {\n                        Circle c1 = items.get(j);\n                        Circle c2 = items.get(l);\n                        circles.remove(c1);\n                        circles.remove(c2);\n                        for (Circle c : c1.children) {\n                            c.parents.remove(c1);\n                        }\n                        for (Circle c : c2.children) {\n                            c.parents.remove(c2);\n                        }\n                        dp(k + 1);\n                        circles.add(c1);\n                        circles.add(c2);\n                        for (Circle c : c1.children) {\n                            c.parents.add(c1);\n                        }\n                        for (Circle c : c2.children) {\n                            c.parents.add(c2);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    static class Circle {\n        int x, y, r, c, id;\n        ArrayList<Circle> parents;\n        ArrayList<Circle> children;\n        Circle (int x, int y, int r, int c, int id) {\n            this.x = x;\n            this.y = y;\n            this.r = r;\n            this.c = c;\n            this.id = id;\n            parents = new ArrayList<>();\n            children = new ArrayList<>();\n        }\n\n        public boolean dip(Circle c) {\n            return Math.pow(this.r + c.r, 2) > Math.pow(this.x - c.x, 2) + Math.pow(this.y - c.y, 2);\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint n;\n\tbyte[] mem;\n\tCoin[] coins;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tcoins = new Coin[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tcoins[i] = new Coin(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\t}\n\t\t\tmem = new byte[(1<<n)];\n\t\t\tfill(mem, (byte)-1);\n\t\t\tSystem.out.println(solve((1<<n)-1));\n\t\t}\n\t}\n\t\n\tbyte solve( int S ) {\n\t\tif( mem[S]>=0 ) return mem[S];\n\t\tbyte cnt = 0;\n\t\tboolean[] rap = new boolean[n];\n\t\t\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif( ((S>>i) & 1) == 0 ) {\n\t\t\t\trap[i] = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif( ((S>>j) & 1) == 0 ) continue;\n\t\t\t\trap[j] = coins[i].israpped(coins[j]); \n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(rap[i]) continue;\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif(rap[j])continue;\n\t\t\t\tif( coins[i].c == coins[j].c ) {\n\t\t\t\t\tcnt = (byte) max(cnt, solve( S - (1<<i) - (1<<j) ) + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn mem[S] = cnt;\n\t}\n\t\n\t\n\t\n\tclass Coin {\n\t\tint x, y, r, c;\n\t\tCoin (int x, int y, int r, int c) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t}\n\t\t\n\t\tboolean israpped(Coin c) {\n\t\t\treturn (c.x-x) * (c.x-x) + (c.y-y) * (c.y-y) < (r+c.r) * (r+c.r);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport javax.swing.Box.Filler;\n\npublic class Main {\n\tCoin[] coins;\n\tScanner sc = new Scanner(System.in);\n\tboolean[] lapped;\n\tint n;\n\tbyte[] state;\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\tcoins = new Coin[n];\n\t\t\tlapped = new boolean[n];\n\t\t\tfor(int i=0;i<n;i++) coins[i] = new Coin();\n\t\t\tint S=(1<<n)-1;\n\t\t\tstate = new byte[1<<n];\n\t\t\tfor(int i=0;i<(1<<n);i++) state[i] = -1;\n\t\t\tSystem.out.println(solve(S));\n\t\t}\n\t}\n\t\n\tbyte solve( int S ) {\n//\t\tSystem.out.println(S);\n\t\tif (state[S] >= 0) return state[S];\n\t\tanalyseLapped(S);\n//\t\tfor(int i=0;i<n;i++) System.out.print(lapped[i] + \" \");\n//\t\tSystem.out.println();\n//\t\tsc.next();\n\t\tbyte cnt = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif( lapped[i] ) continue;\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif ( !lapped[j] && coins[i].c == coins[j].c ) {\n\t\t\t\t\tcnt = (byte) Math.max(cnt, solve(S-((1<<i) + (1<<j)))+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn state[S] = cnt;\n\t}\n\t\n\tvoid analyseLapped(int S) {\n\t\tfor(int i=0;i<n;i++) lapped[i] = false;\n\t\tfor(int i=0;i<n;i++) {\n//\t\t\tSystem.out.println( (S>>i) & 1 );\n\t\t\tif( ((S>>i) & 1) != 1 ) { lapped[i] = true ; continue; }\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif( ((S>>j) & 1) != 1 ) { lapped[j] = true; continue; }\n//\t\t\t\tSystem.out.println(coins[i].isLapped(coins[j]));\n\t\t\t\tif( coins[i].isLapped(coins[j]) ) lapped[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\tclass Coin {\n\t\tint x, y, r, c;\n\t\t\n\t\tpublic Coin() {\n\t\t\tscan();\n\t\t}\n\t\t\n\t\tvoid scan() {\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\t\t\tr = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t}\n\t\t\n\t\tboolean isLapped( Coin c ) {\n\t\t\treturn (c.x-x)*(c.x-x)+(c.y-y)*(c.y-y) < (r+c.r)*(r+c.r);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tprivate static Scanner sc = new Scanner(System.in);\n\n\t\tclass circle{\n\t\t\tint x;\n\t\t\tint y;\n\t\t\tint r;\n\t\t\tint c;\n\t  \t\t\t\n\t  \t\t\tcircle(Scanner sc){\n\t  \t\t\t\tthis.x=sc.nextInt();\n\t  \t\t\t\tthis.y=sc.nextInt();\n\t  \t\t\t\tthis.r=sc.nextInt();\n\t  \t\t\t\tthis.c=sc.nextInt();\n\t  \t\t}\n\t  \t\t\t\n\t  \t\t\tBoolean isCoveredBy(circle another){\n\t  \t\t\t\t\treturn Math.sqrt((this.x-another.x)*(this.x-another.x)+(this.y-another.y)*(this.y-another.y))<this.r+another.r;\n\t  \t\t\t\t\t  \t\t\t\t\n\t  \t\t\t}\n\t  \t\n\t  \n  }\n\n\t\tprivate void cal() throws IOException{\n\t\t\t\n\t\t\tfor(;;){\t\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tif(n==0)\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcircle[] circles=new circle[n];\n\t\t\t\tint[] coverbit=new int[n];\n\t\t\t\t\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tcircles[i]=new circle(sc);\n\t\t\t\t\t\n\t\t\t\t\tfor(int j=i-1;j>=0;j--)\n\t\t\t\t\t    if(circles[i].isCoveredBy(circles[j]))\n\t\t\t\t\t\tcoverbit[i]|=(1<<j);\n\t\t\t\t\t\t\n\t\t\t\t\t    \n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint Max=0;\n\t\t\t\tboolean PossibleBit[]=new boolean[1<<n];\n\t\t\t\tPossibleBit[0]=true;\n\t\t\t\t\n\t\t\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\t\t\t\n\t\t\t\t\tif(!PossibleBit[i])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\t\tMax=Math.max(Integer.bitCount(i),Max);\n\t\t\t\t\tfor(int first=0;first<n;first++){\n\t\t\t\t\t    if((~i & coverbit[first])!=0 || (i&1<<first)!=0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor(int second=first+1;second<n;second++){\n\t\t\t\t\t\t\tif((~i & coverbit[second])!=0 || (i&1<<second)!=0)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tif(circles[first].c!=circles[second].c)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tPossibleBit[i|(1<<first)|(1<<second)]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\n\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t\tSystem.out.println(Integer.toString(Max));\n\t\t\t\t\n\t\t\t}\n\t\t}\n\n\tpublic static void main ( String [] args ) throws IOException{\n    \t\n\t  new Main().cal();\n    }\n\t\n    \n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tfinal double EPS = 1.0e-08;\n\tC [] data;\n\tclass C{\n\t\tint x,y,r,c;\n\t\tpublic C(int x, int y, int r, int c) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\tint n,len,ans;\n\t\t//boolean [][] dp = new boolean[1 << 24][13];\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdata = new C[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tdata[i] = new C(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t\t}\n\t\t\tlen = 1 << n;\n\t\t\tArrayList<Integer> dp2 = new ArrayList<Integer>();\n\t\t\tdp2.add(0);\n\t\t\tans = 0;\n\t\t\tfor(int i=0; i < n/2;i++){\n\t\t\t\tfor(int j: dp2){\n\t\t\t\t\tArrayList<Integer> used = new ArrayList<Integer>();\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\t\tfor(int l = k+1; l < n; l++){\n\t\t\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\t\t\tif(! issameC(k,l)) continue;\n\t\t\t\t\t\t\tif(isOVL(k,j) || isOVL(l,j)) continue;\n\t\t\t\t\t\t\tint num;\n\t\t\t\t\t\t\tnum = j | (1 << k);\n\t\t\t\t\t\t\tnum = num | (1 << l);\n\t\t\t\t\t\t\tint res = Integer.bitCount(num);\n\t\t\t\t\t\t\t//System.out.println(\"num= \" + num);\n\t\t\t\t\t\t\tans = Math.max(ans, res);\n\t\t\t\t\t\t\tused.add(num);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp2 = new ArrayList<Integer>(used);\n\t\t\t\t}\n\t\t\t}\n//\t\t\t//TODO debug\n//\t\t\tfor(int i= 0; i < len; i++){\n//\t\t\t\tfor(int j = 0; j < n+1; j++){\n//\t\t\t\t\tif(dp[i][j]){\n//\t\t\t\t\t\tSystem.out.print(\"1 \");\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tSystem.out.print(\"0 \");\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate boolean isOVL(int a,int num) {\n\t\tif(a == 0) return false;\n\t\tint ax = data[a].x;\n\t\tint ay = data[a].y;\n\t\tint ar= data[a].r;\n\t\tint ix,iy,ir,rr;\n\t\tdouble dis;\n\t\tfor(int i = a-1; i >= 0; i--){\n\t\t\tif(((1 << i) & num) != 0) continue;\n\t\t\tix = data[i].x;\n\t\t\tiy = data[i].y;\n\t\t\tir = data[i].r;\n\t\t\tdis = Point2D.Double.distance(ax, ay, ix, iy);\n\t\t\trr = ir + ar;\n\t\t\tif(dis + EPS < rr)return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean issameC(int a, int b) {\n\t\tif(data[a].c == data[b].c) return true;\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Scanner;\n\npublic class disc {\n\n\tprivate static Scanner sc = new Scanner(System.in);\n\n\t\tclass circle{\n\t\t\tint x;\n\t\t\tint y;\n\t\t\tint r;\n\t\t\tint c;\n\t  \t\t\t\n\t  \t\t\tcircle(Scanner sc){\n\t  \t\t\t\tthis.x=sc.nextInt();\n\t  \t\t\t\tthis.y=sc.nextInt();\n\t  \t\t\t\tthis.r=sc.nextInt();\n\t  \t\t\t\tthis.c=sc.nextInt();\n\t  \t\t}\n\t  \t\t\t\n\t  \t\t\tBoolean isCoveredBy(circle another){\n\t  \t\t\t\t\treturn Math.sqrt((this.x-another.x)^2+(this.y-another.y)^2)<this.r+another.r;\n\t  \t\t\t\t\t  \t\t\t\t\n\t  \t\t\t}\n\t  \t\n\t  \n  }\n\n\t\tprivate String cal() throws IOException{\n\t\t\t\n\t\t\tfor(;;){\t\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tif(n==0)\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcircle[] circles=new circle[n];\n\t\t\t\tint[] coverbit=new int[n];\n\t\t\t\t\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tcircles[i]=new circle(sc);\n\t\t\t\t\t\n\t\t\t\t\tfor(int j=0;j<i;j--)\n\t\t\t\t\t\tif(circles[i].isCoveredBy(circles[j]))\n\t\t\t\t\t\t\tcoverbit[i]|=(1<<j);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint Max=0;\n\t\t\t\tboolean PossibleBit[]=new boolean[1<<n];\n\t\t\t\tPossibleBit[0]=true;\n\t\t\t\t\n\t\t\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\t\t\t\n\t\t\t\t\tif(!PossibleBit[i])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tMax=Math.max(Integer.bitCount(i),Max);\n\t\t\t\t\t\n\t\t\t\t\tfor(int first=0;first<n;first++){\n\t\t\t\t\t\tif((~i & coverbit[first])!=0 || (i&1<<first)!=0) \n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int second=first+1;second<n;second++){\n\t\t\t\t\t\t\tif((~i & coverbit[second])!=0 || (i&1<<second)!=0)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tif(circles[first].c!=circles[second].c)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tPossibleBit[i|(1<<first)|(1<<second)]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\n\n\t\t\t\t\treturn Integer.toString(Max);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\treturn null;\n\n\t\t}\n\t  \n\tpublic static void main ( String [] args ) throws IOException{\n    \t\n\t  new disc().cal();\n    }\n\t\n    \n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tnew AOJ1175().doIt(n);\n\t\t}\n\t}\n\n\n\tclass AOJ1175{\n\t\tint dfs(long bit,int num){\n\t\t\tif(map.containsKey(bit))return map.get(bit);\n//\t\t\tSystem.out.println(Long.toBinaryString(bit));\n\t\t\tint result = Integer.MAX_VALUE;\n\t\t\tArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor(int i=0;i<n;i++)list.add(new ArrayList<Integer>());\n\t\t\tfor(int i=0;i<n;i++)if((bit>>i)%2==1){\n\t\t\t\tPoint2D p1 = new Point2D.Double(data[i].x,data[i].y);\n\t\t\t\tfor(int s=i-1;s>=0;s--)if(p1.distance(new Point2D.Double(data[s].x, data[s].y))<data[s].r+data[i].r\n\t\t\t\t\t\t&&(bit>>s)%2==1)list.get(i).add(s);\n\t\t\t}\n\t\t\tboolean sw = false;\n//\t\t\tSystem.out.println(list);\n\t\t\tfor(int c=1;c<=4;c++){//color\n\t\t\t\tfor(int i=0;i<n;i++)for(int s=i+1;s<n;s++)if(data[i].color==c&&data[i].color==c&&list.get(i).size()==0&&list.get(s).size()==0){\n\t\t\t\t\tif(i==s||((bit>>i)%2==0)||((bit>>s)%2==0))continue;\n\t\t\t\t\tbit -= 1 << i;\n\t\t\t\t\tbit -= 1 << s;\n//\t\t\t\t\tSystem.out.println(i+\" \"+s);\n\t\t\t\t\tresult = Math.min(result, dfs(bit,num+2));\n\t\t\t\t\tbit += 1 << i;\n\t\t\t\t\tbit += 1 << s;\n\t\t\t\t\tsw = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!sw)return num;\n\t\t\tmap.put(bit, result);\n\t\t\treturn result; \n\t\t}\n\t\tHashMap<Long,Integer> map;\n\t\tint n;\n\t\tData data[];\n\t\tvoid doIt(int n){//<=24\n\t\t\tthis.n = n;\n\t\t\tmap = new HashMap<Long, Integer>();\n\t\t\tdata = new Data[n];\n\t\t\tfor(int i=0;i<n;i++)data[i] = new Data(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\tlong bit=0;\n\t\t\tfor(int i=0;i<n;i++)bit += 1 << i;\n\t\t\tint result = dfs(bit,0);\n\t\t\tSystem.out.println(result);\n\t\t}\n\n\t\tclass Data{\n\t\t\tint x,y,color,r;\n\t\t\tpublic Data(int x,int y,int r,int color) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.r = r;\n\t\t\t\tthis.color = color;\n\t\t\t}\n\t\t}\n\t}\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n  Scanner sc;\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Disk {\n    LinkedList<Disk> parents = new LinkedList<>();\n    LinkedList<Disk> children = new LinkedList<>();\n    int x;\n    int y;\n    int c;\n    int r;\n\n    boolean isIn(Disk disk) {\n      return Math.pow(this.r + disk.r, 2) > Math.pow(this.x - disk.x, 2) + Math.pow(this.y - disk.y, 2);\n    }\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      ArrayList<Disk> list = new ArrayList<>();\n      for (int i = 0; i < n; ++i) {\n        Disk d = new Disk();\n        d.x = ni();\n        d.y = ni();\n        d.r = ni();\n        d.c = ni();\n\n        for (int j = 0; j < i; ++j) {\n          Disk e = list.get(j);\n          if (e.isIn(d)) {\n            e.children.add(d);\n            d.parents.add(e);\n          }\n        }\n        list.add(d);\n      }\n\n      int cnt = 0;\n      for (; ; ) {\n        boolean flag = true;\n        HashMap<Integer, Disk> map = new HashMap<>();\n        for (Disk d : list) {\n          if (d.parents.size() == 0) {\n            if (map.containsKey(d.c)) {\n              Disk e = map.get(d.c);\n              e.children.forEach(c -> c.parents.remove(e));\n              d.children.forEach(c -> c.parents.remove(d));\n              list.remove(d);\n              list.remove(e);\n              ++cnt;\n              flag = false;\n              break;\n            } else {\n              map.put(d.c, d);\n            }\n          }\n        }\n        if (flag) {\n          break;\n        }\n      }\n      System.out.println(cnt * 2);\n    }\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tAOJ1175 obj = new AOJ1175();\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tobj.doIt(n);\n\t\t}\n\t}\n\n\tclass AOJ1175{\n\t\tboolean[] memo = new boolean[(1<<24)];\n\t\tvoid doIt(int n){\n\t\t\tArrays.fill(memo,false);\n\t\t\tData[] data = new Data[n];\n\t\t\tfor(int i=0;i<n;i++)data[i] = new Data(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\tlong bit = 0;\n\t\t\tfor(int i=0;i<n;i++)bit += 1 << i;\n\t\t\tLinkedList<State> q = new LinkedList<State>();\n\t\t\tq.add(new State(bit, 0));\n\t\t\tint cnt[] = new int[n];\n\t\t\tint result = -1;\n\t\t\twhile(q.size()>0){\n\t\t\t\tState now = q.remove();\n\t\t\t\tbit = now.bit;\n\t\t\t\tresult = Math.max(result, now.num);\n\t\t\t\tArrays.fill(cnt,0);\n\t\t\t\tfor(int i=0;i<n;i++)for(int s=i-1;s>=0;s--)if((bit>>i)%2==1&&(bit>>s)%2==1){\n\t\t\t\t\tif(Point2D.distance(data[i].x, data[i].y, data[s].x, data[s].y)<data[s].r+data[i].r)cnt[i]++;\n\t\t\t\t}\n\n\t\t\t\tfor(int i=0;i<n;i++)for(int s=i+1;s<n;s++)if(data[i].color==data[s].color&&cnt[i]==0&&cnt[s]==0){\n\t\t\t\t\tif(i==s||((bit>>i)%2==0)||((bit>>s)%2==0))continue;\n\t\t\t\t\tlong bit2 = bit-(1<<i)-(1<<s);\n\t\t\t\t\tq.add(new State(bit2,now.num+2));\n\t\t\t\t}\n\n\t\t\t\tif(memo[(int)bit])continue;\n\t\t\t\tmemo[(int)bit] = true;\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\n\t\tclass State{\n\t\t\tlong bit;\n\t\t\tint num;\n\t\t\tpublic State(long bit,int num){\n\t\t\t\tthis.bit = bit;\n\t\t\t\tthis.num = num;\n\t\t\t}\n\t\t}\n\n\t\tclass Data{\n\t\t\tint x,y,color,r;\n\t\t\tpublic Data(int x,int y,int r,int color) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.r = r;\n\t\t\t\tthis.color = color;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.TreeMap;\n\npublic class Main {\n\tint n;\n\tTreeMap<Integer, Integer> dp;\n\tint[] x, y, r, c;\n\n\tint dp(int bit) {\n\t\tif (dp.containsKey(bit)) {\n\t\t\treturn dp.get(bit);\n\t\t}\n\t\tboolean[] f = new boolean[n];\n\t\tboolean[] flag = new boolean[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (0 < (bit & (1 << i))) {\n\t\t\t\tf[i] = true;\n\t\t\t\tflag[i] = true;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!f[i])\n\t\t\t\tcontinue;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (!f[j])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (isIntersect(i, j)) {\n\t\t\t\t\tflag[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!flag[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (!flag[j]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (c[i] != c[j]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (isIntersect(i, j)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint nbit = bit;\n\t\t\t\tnbit ^= (1 << i);\n\t\t\t\tnbit ^= (1 << j);\n\t\t\t\tres = Math.max(res, dp(nbit) + 2);\n\t\t\t}\n\t\t}\n\n\t\tdp.put(bit, res);\n\t\treturn res;\n\t}\n\n\tboolean isIntersect(int i, int j) {\n\t\tint len = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n\t\treturn len < (r[i] + r[j]) * (r[i] + r[j]);\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx = new int[n];\n\t\t\ty = new int[n];\n\t\t\tr = new int[n];\n\t\t\tc = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint xi = sc.nextInt();\n\t\t\t\tint yi = sc.nextInt();\n\t\t\t\tint ri = sc.nextInt();\n\t\t\t\tint ci = sc.nextInt();\n\t\t\t\tx[i] = xi;\n\t\t\t\ty[i] = yi;\n\t\t\t\tr[i] = ri;\n\t\t\t\tc[i] = ci;\n\t\t\t}\n\n\t\t\tint mask = (1 << n) - 1;\n\t\t\tdp = new TreeMap<Integer, Integer>();\n\t\t\tSystem.out.println(dp(mask));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Scanner;\n\npublic class disc {\n\n\tprivate static Scanner sc = new Scanner(System.in);\n\n\t\tclass circle{\n\t\t\tint x;\n\t\t\tint y;\n\t\t\tint r;\n\t\t\tint c;\n\t  \t\t\t\n\t  \t\t\tcircle(Scanner sc){\n\t  \t\t\t\tthis.x=sc.nextInt();\n\t  \t\t\t\tthis.y=sc.nextInt();\n\t  \t\t\t\tthis.r=sc.nextInt();\n\t  \t\t\t\tthis.c=sc.nextInt();\n\t  \t\t}\n\t  \t\t\t\n\t  \t\t\tBoolean isCoveredBy(circle another){\n\t  \t\t\t\t\treturn Math.sqrt((this.x-another.x)*(this.x-another.x)+(this.y-another.y)*(this.y-another.y))<this.r+another.r;\n\t  \t\t\t\t\t  \t\t\t\t\n\t  \t\t\t}\n\t  \t\n\t  \n  }\n\n\t\tprivate void cal() throws IOException{\n\t\t\t\n\t\t\tfor(;;){\t\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tif(n==0)\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcircle[] circles=new circle[n];\n\t\t\t\tint[] coverbit=new int[n];\n\t\t\t\t\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tcircles[i]=new circle(sc);\n\t\t\t\t\t\n\t\t\t\t\tfor(int j=i-1;j>=0;j--)\n\t\t\t\t\t    if(circles[i].isCoveredBy(circles[j]))\n\t\t\t\t\t\tcoverbit[i]|=(1<<j);\n\t\t\t\t\t\t\n\t\t\t\t\t    \n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint Max=0;\n\t\t\t\tboolean PossibleBit[]=new boolean[1<<n];\n\t\t\t\tPossibleBit[0]=true;\n\t\t\t\t\n\t\t\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\t\t\t\n\t\t\t\t\tif(!PossibleBit[i])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\t\tMax=Math.max(Integer.bitCount(i),Max);\n\t\t\t\t\tfor(int first=0;first<n;first++){\n\t\t\t\t\t    if((~i & coverbit[first])!=0 || (i&1<<first)!=0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor(int second=first+1;second<n;second++){\n\t\t\t\t\t\t\tif((~i & coverbit[second])!=0 || (i&1<<second)!=0)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tif(circles[first].c!=circles[second].c)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tPossibleBit[i|(1<<first)|(1<<second)]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\n\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t\tSystem.out.println(Integer.toString(Max));\n\t\t\t\t\n\t\t\t}\n\t\t}\n\n\tpublic static void main ( String [] args ) throws IOException{\n    \t\n\t  new disc().cal();\n    }\n\t\n    \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport javax.swing.Box.Filler;\n\npublic class Main {\n\tCoin[] coins;\n\tScanner sc = new Scanner(System.in);\n\tboolean[] lapped;\n\tint n;\n\tint[] state;\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\tcoins = new Coin[n];\n\t\t\tlapped = new boolean[n];\n\t\t\tfor(int i=0;i<n;i++) coins[i] = new Coin();\n\t\t\tint S=(1<<n)-1;\n\t\t\tstate = new int[1<<n];\n\t\t\tfor(int i=0;i<(1<<n);i++) state[i] = -1;\n\t\t\tSystem.out.println(solve(S));\n\t\t}\n\t}\n\t\n\tint solve( int S ) {\n//\t\tSystem.out.println(S);\n\t\tif (state[S] >= 0) return state[S];\n\t\tanalyseLapped(S);\n//\t\tfor(int i=0;i<n;i++) System.out.print(lapped[i] + \" \");\n//\t\tSystem.out.println();\n//\t\tsc.next();\n\t\tint cnt = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif( lapped[i] ) continue;\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif ( !lapped[j] && coins[i].c == coins[j].c ) {\n\t\t\t\t\tcnt = Math.max(cnt, solve(S-((1<<i) + (1<<j)))+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn state[S] = cnt;\n\t}\n\t\n\tvoid analyseLapped(int S) {\n\t\tfor(int i=0;i<n;i++) lapped[i] = false;\n\t\tfor(int i=0;i<n;i++) {\n//\t\t\tSystem.out.println( (S>>i) & 1 );\n\t\t\tif( ((S>>i) & 1) != 1 ) { lapped[i] = true ; continue; }\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif( ((S>>j) & 1) != 1 ) { lapped[j] = true; continue; }\n//\t\t\t\tSystem.out.println(coins[i].isLapped(coins[j]));\n\t\t\t\tif( coins[i].isLapped(coins[j]) ) lapped[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\tclass Coin {\n\t\tint x, y, r, c;\n\t\t\n\t\tpublic Coin() {\n\t\t\tscan();\n\t\t}\n\t\t\n\t\tvoid scan() {\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\t\t\tr = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t}\n\t\t\n\t\tboolean isLapped( Coin c ) {\n\t\t\treturn (c.x-x)*(c.x-x)+(c.y-y)*(c.y-y) < (r+c.r)*(r+c.r);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.TreeSet;\n\npublic class Main {\n\tint n;\n\tTreeSet<Integer> dp;\n\tint[] x, y, r, c;\n\n\tvoid dp(int bit) {\n\t\tif (dp.contains(bit)) {\n\t\t\treturn;\n\t\t}\n\t\tboolean[] f = new boolean[n];\n\t\tboolean[] flag = new boolean[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (0 < (bit & (1 << i))) {\n\t\t\t\tf[i] = true;\n\t\t\t\tflag[i] = true;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!f[i])\n\t\t\t\tcontinue;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (!f[j])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (isIntersect(i, j)) {\n\t\t\t\t\tflag[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!flag[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (!flag[j]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (c[i] != c[j]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (isIntersect(i, j)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint nbit = bit;\n\t\t\t\tnbit ^= (1 << i);\n\t\t\t\tnbit ^= (1 << j);\n\t\t\t\tdp(nbit);\n\t\t\t}\n\t\t}\n\t\tdp.add(bit);\n\t}\n\n\tboolean isIntersect(int i, int j) {\n\t\tint len = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n\t\treturn len < (r[i] + r[j]) * (r[i] + r[j]);\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx = new int[n];\n\t\t\ty = new int[n];\n\t\t\tr = new int[n];\n\t\t\tc = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint xi = sc.nextInt();\n\t\t\t\tint yi = sc.nextInt();\n\t\t\t\tint ri = sc.nextInt();\n\t\t\t\tint ci = sc.nextInt();\n\t\t\t\tx[i] = xi;\n\t\t\t\ty[i] = yi;\n\t\t\t\tr[i] = ri;\n\t\t\t\tc[i] = ci;\n\t\t\t}\n\n\t\t\tint mask = (1 << n) - 1;\n\t\t\tdp = new TreeSet<Integer>();\n\t\t\tdp(mask);\n\t\t\tint max = 0;\n\t\t\tfor (Integer bit: dp) {\n\t\t\t\tmax = Math.max(max, n - Integer.bitCount(bit));\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t\tSystem.gc();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport javax.swing.Box.Filler;\n\npublic class Main {\n\tCoin[] coins;\n\tScanner sc = new Scanner(System.in);\n\tboolean[] lapped;\n\tint n;\n\tint[] state;\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\tcoins = new Coin[n];\n\t\t\tlapped = new boolean[n];\n\t\t\tfor(int i=0;i<n;i++) coins[i] = new Coin();\n\t\t\tint S=(1<<n)-1;\n\t\t\tstate = new int[1<<n];\n\t\t\tfor(int i=0;i<(1<<n);i++) state[i] = -1;\n\t\t\tSystem.out.println(solve(S));\n\t\t}\n\t}\n\t\n\tint solve( int S ) {\n//\t\tSystem.out.println(S);\n\t\tif (state[S] >= 0) return state[S];\n\t\tanalyseLapped(S);\n//\t\tfor(int i=0;i<n;i++) System.out.print(lapped[i] + \" \");\n//\t\tSystem.out.println();\n//\t\tsc.next();\n\t\tint cnt = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif( ((S>>i) & 1) != 1 || lapped[i] ) continue;\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif ( ((S>>j) & 1) == 1 && !lapped[j] && coins[i].c == coins[j].c ) {\n\t\t\t\t\tcnt = Math.max(cnt, solve(S-((1<<i) + (1<<j)))+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn state[S] = cnt;\n\t}\n\t\n\tvoid analyseLapped(int S) {\n\t\tfor(int i=0;i<n;i++) lapped[i] = false;\n\t\tfor(int i=0;i<n;i++) {\n//\t\t\tSystem.out.println( (S>>i) & 1 );\n\t\t\tif( ((S>>i) & 1) != 1 ) continue;\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif( ((S>>j) & 1) != 1 ) continue;\n//\t\t\t\tSystem.out.println(coins[i].isLapped(coins[j]));\n\t\t\t\tif( coins[i].isLapped(coins[j]) ) lapped[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\tclass Coin {\n\t\tint x, y, r, c;\n\t\t\n\t\tpublic Coin() {\n\t\t\tscan();\n\t\t}\n\t\t\n\t\tvoid scan() {\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\t\t\tr = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t}\n\t\t\n\t\tboolean isLapped( Coin c ) {\n\t\t\treturn (c.x-x)*(c.x-x)+(c.y-y)*(c.y-y) < (r+c.r)*(r+c.r);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tnew AOJ1175().doIt(n);\n\t\t}\n\t}\n\n\n\tclass AOJ1175{\n\t\tint dfs(long bit,int num){\n\t\t\tif(map.containsKey(bit))return map.get(bit);\n//\t\t\tSystem.out.println(Long.toBinaryString(bit));\n\t\t\tint result = num;\n\t\t\tArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor(int i=0;i<n;i++)list.add(new ArrayList<Integer>());\n\t\t\tfor(int i=0;i<n;i++)if((bit>>i)%2==1){\n\t\t\t\tPoint2D p1 = new Point2D.Double(data[i].x,data[i].y);\n\t\t\t\tfor(int s=i-1;s>=0;s--)if(p1.distance(new Point2D.Double(data[s].x, data[s].y))<data[s].r+data[i].r\n\t\t\t\t\t\t&&(bit>>s)%2==1)list.get(i).add(s);\n\t\t\t}\n//\t\t\tSystem.out.println(list);\n\t\t\tfor(int c=1;c<=4;c++){//color\n\t\t\t\tfor(int i=0;i<n;i++)for(int s=i+1;s<n;s++)if(data[i].color==c&&data[s].color==c&&list.get(i).size()==0&&list.get(s).size()==0){\n\t\t\t\t\tif(i==s||((bit>>i)%2==0)||((bit>>s)%2==0))continue;\n\t\t\t\t\tbit -= 1 << i;\n\t\t\t\t\tbit -= 1 << s;\n//\t\t\t\t\tSystem.out.println(i+\" \"+s);\n\t\t\t\t\tresult = Math.max(result, dfs(bit,num+2));\n\t\t\t\t\tbit += 1 << i;\n\t\t\t\t\tbit += 1 << s;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(result == num)return num;\n\t\t\tmap.put(bit, result);\n\t\t\treturn result; \n\t\t}\n\t\tHashMap<Long,Integer> map;\n\t\tint n;\n\t\tData data[];\n\t\tvoid doIt(int n){//<=24\n\t\t\tthis.n = n;\n\t\t\tmap = new HashMap<Long, Integer>();\n\t\t\tdata = new Data[n];\n\t\t\tfor(int i=0;i<n;i++)data[i] = new Data(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\tlong bit=0;\n\t\t\tfor(int i=0;i<n;i++)bit += 1 << i;\n\t\t\tint result = dfs(bit,0);\n\t\t\tSystem.out.println(result);\n\t\t}\n\n\t\tclass Data{\n\t\t\tint x,y,color,r;\n\t\t\tpublic Data(int x,int y,int r,int color) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.r = r;\n\t\t\t\tthis.color = color;\n\t\t\t}\n\t\t}\n\t}\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.function.Predicate;\n\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int n;\n\t//\n\tList<Disc> discs = new ArrayList<Disc>();\n\tint max = 0;\n\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\n\t\t\tnew Main();\n\t\t}\n\t}\n\n\tMain() {\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tdiscs.add( new Disc(sc, i) );\n\t\t}\n\n\t\tdfs(new HashSet<Disc>());\n\n\t\tSystem.out.println(max);\n\t}\n\n\tvoid dfs(Set<Disc> rems) {\n\t\t// pre\n\t\tList<Disc> ups = new ArrayList<Disc>();\n\t\tPredicate<Disc> booAny = d -> {\n\t\t\tfor(int i=d.m-1; i>=0; i--) {\n\t\t\t\tDisc op = discs.get(i);\n\t\t\t\tif(rems.contains(op)) continue;\n\t\t\t\tif(d.boo(op)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor(Disc d : discs) {\n\t\t\tif(rems.contains(d)) continue;\n\t\t\tif( ! booAny.test(d) ) ups.add(d);\n\t\t}\n\n\t//\tSystem.out.println(ups);\n\n\t\t// dfs\n\t\tfor(int i=0; i<ups.size(); i++) {\n\t\t\tfor(int j=i+1; j<ups.size(); j++) {\n\t\t\t\tDisc a = ups.get(i);\n\t\t\t\tDisc b = ups.get(j);\n\t\t\t\tif(a.c == b.c) {\n\t\t\t\t\trems.add(a); rems.add(b);\n\t\t\t\t\tmax = Math.max(max, rems.size());\n\t\t\t\t//\tSystem.out.println(a+\",\"+b+\" \"+max);\n\t\t\t\t\tdfs(rems);\n\t\t\t\t\trems.remove(a); rems.remove(b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\n}\n\n\nclass Disc {\n\tint x, y, r, c;\n\tint m;\n\n\tDisc(Scanner sc, int n) {\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\t\tr = sc.nextInt();\n\t\tc = sc.nextInt();\n\t\tm = n;\n\t}\n\n\tboolean boo(Disc op) {\n\t\tint kyo = (x-op.x)*(x-op.x) + (y-op.y)*(y-op.y);\n\t\tint rs = (r+op.r)*(r+op.r);\n\t\treturn kyo < rs;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"\"+m;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\npublic class Main{\n\n\tstatic int INF = 2 << 27;\n\tstatic int m;\n\tstatic int n;\n\tstatic int k;\n\tstatic int d;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tData[] data = new Data[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdata[i] = new Data(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\t\t\tboolean check = check(data,i,j);\n\t\t\t\t\tif(check) data[j].up |= (1 << i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[] dp = new boolean[1 << n];\n\t\t\tdp[0] = true;\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tif(!dp[i]) continue;\n\t\t\t\tArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tlist.add(new ArrayList<Integer>());\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tif((i & (1 << j)) != 0 || (i & data[j].up) != data[j].up) continue;\n\t\t\t\t\tlist.get(data[j].c).add(j);\n\t\t\t\t}\n\t\t\t\tfor(int j = 1; j < 5; j++) {\n\t\t\t\t\tArrayList<Integer> lX = list.get(j);\n\t\t\t\t\tfor(int k = 0; k < lX.size()-1; k++) {\n\t\t\t\t\t\tfor(int l = k + 1; l < lX.size(); l++) {\n\t\t\t\t\t\t\tint next = i | (1 << lX.get(k) | (1 << lX.get(l)));\n\t\t\t\t\t\t\tdp[next] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tif(dp[i]) max = Math.max(max, Integer.bitCount(i));\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t\t\n\t\t}\n\t}\n\tstatic boolean check(Data[] data, int a, int b) {\n\t\tint dis = (int)(Math.pow(data[a].x - data[b].x, 2) + Math.pow(data[a].y - data[b].y, 2));\n\t\treturn dis < Math.pow(data[a].r + data[b].r,2);\n\t}\n\tstatic class Data {\n\t\tint up = 0;\n\t\tint x;\n\t\tint y;\n\t\tint r;\n\t\tint c;\n\t\tData(int a, int b, int c, int d) {\n\t\t\tthis.x = a;\n\t\t\tthis.y = b;\n\t\t\tthis.r = c;\n\t\t\tthis.c = d;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint n, max;\n\tint[] c;\n\tboolean[] f;\n\tboolean[][] a;\n\n\tvoid dfs(int d){\n\t\tboolean flag;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(f[i]==true) continue;\n\t\t\tflag = false;\n\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\tif(f[j]==false && a[i][j]==true){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==false){\n\t\t\t\tfor(int j=i+1;j<n;j++){\t\n\t\t\t\t\tif(f[j]==true || c[i]!=c[j]) continue;\n\t\t\t\t\tfor(int k=j-1;k>=0;k--){\n\t\t\t\t\t\tif(f[k]==false && a[j][k]==true){\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==false){\n\t\t\t\t\t\tf[i] = true;\n\t\t\t\t\t\tf[j] = true;\n\t\t\t\t\t\tdfs(d+1);\n\t\t\t\t\t\tf[i] = false;\n\t\t\t\t\t\tf[j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmax = Math.max(max, d);\n\t}\n\t\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tf = new boolean[n];\n\t\t\ta = new boolean[n][n];\n\t\t\tc = new int[n];\n\t\t\t\n\t\t\tint[][] b = new int[n][3];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<3;j++) b[i][j] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt();\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tif(Math.sqrt((b[i][0]-b[j][0])*(b[i][0]-b[j][0])+(b[i][1]-b[j][1])*(b[i][1]-b[j][1]))<b[i][2]+b[j][2]){\n\t\t\t\t\t\ta[i][j] = true; //jがiの上にのってる\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmax = 0;\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(max*2);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tfinal int MOD = 1000000007;\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tint n;\n\tint[] x, y, r, c;\n\tbyte[] memo;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\treturn;\n\t\t\tx = new int[n];\n\t\t\ty = new int[n];\n\t\t\tr = new int[n];\n\t\t\tc = new int[n];\n\t\t\tmemo = new byte[1 << n];\n\t\t\tfor(int i=0;i<1<<n;i++) memo[i] = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t\tr[i] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\t// ????????????????????????????????????????±???????\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tL: for (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (c[i] != c[j])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int k = j - 1; k >= 0; k--) {\n\t\t\t\t\t\tint pDis_j = (x[k] - x[j]) * (x[k] - x[j]) + (y[k] - y[j]) * (y[k] - y[j]);\n\t\t\t\t\t\tint rDis_j = (r[k] + r[j]) * (r[k] + r[j]);\n\t\t\t\t\t\tint pDis_i = (x[k] - x[i]) * (x[k] - x[i]) + (y[k] - y[i]) * (y[k] - y[i]);\n\t\t\t\t\t\tint rDis_i = (r[k] + r[i]) * (r[k] + r[i]);\n\t\t\t\t\t\t// k?????????????????£??????????????§????????????\n\t\t\t\t\t\tif (pDis_j < rDis_j) continue L;\n\t\t\t\t\t\tif (k < i && pDis_i < rDis_i) continue L;\n\t\t\t\t\t}\n\t\t\t\t\tmax = Math.max(max, 2 + bitDP( 1 << i | 1 << j));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tint bitDP(int mask) {\n\t\tif (memo[mask] != -1) return memo[mask];\n\n\t\t// ?¬????i???????????????(???????????\\?????????????????????)\n\t\tbyte res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tL: for (int j = i + 1; j < n; j++) {\n\t\t\t\tif (c[i] != c[j]) continue;\n\t\t\t\t// ??¢???i or j????????£?????????\n\t\t\t\tif ((mask & (1 << i)) != 0 || (mask & (1 << j)) != 0) continue;\n\t\t\t\tfor (int k = j - 1; k >= 0; k--) {\n\t\t\t\t\t// ??¢???k???????????????????????????\n\t\t\t\t\tif ((mask & 1 << k) != 0) continue;\n\t\t\t\t\tint pDis_j = (x[k] - x[j]) * (x[k] - x[j]) + (y[k] - y[j]) * (y[k] - y[j]);\n\t\t\t\t\tint rDis_j = (r[k] + r[j]) * (r[k] + r[j]);\n\t\t\t\t\tint pDis_i = (x[k] - x[i]) * (x[k] - x[i]) + (y[k] - y[i]) * (y[k] - y[i]);\n\t\t\t\t\tint rDis_i = (r[k] + r[i]) * (r[k] + r[i]);\n\n\t\t\t\t\t// k?????????????????£??????????????§????????????\n\t\t\t\t\tif (pDis_j < rDis_j) continue L;\n\t\t\t\t\tif (k < i && pDis_i < rDis_i) continue L;\n\t\t\t\t}\n\t\t\t\tres = (byte)Math.max(res, 2 + bitDP(mask | (1 << i | 1 << j)));\n\t\t\t}\n\t\t}\n\t\treturn memo[mask] = res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(long[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (a[i] >= border)\n\tint lower_bound(int a[], int border) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (border <= a[mid]) {\n\t\t\t\tr = mid;\n\t\t\t} else {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static int n;\n    static ArrayList<Circle> circles;\n    static int max;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            n = sc.nextInt();\n            if (n == 0) {\n                break;\n            }\n            circles = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                int r = sc.nextInt();\n                int c = sc.nextInt();\n                circles.add(new Circle(x, y, r, c, i));\n            }\n            for (int i = 0; i < n - 1; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    Circle c1 = circles.get(i);\n                    Circle c2 = circles.get(j);\n                    if (c1.dip(c2)) {\n                        c1.children.add(c2);\n                        c2.parents.add(c1);\n                    }\n                }\n            }\n            max = Integer.MIN_VALUE;\n            dp(0);\n            System.out.println(max * 2);\n        }\n    }\n\n    static void dp(int k) {\n        max = Math.max(max, k);\n\n        ArrayList<Circle> tops = new ArrayList<>();\n        for (Circle c: circles) {\n            if (c.parents.isEmpty()) {\n                tops.add(c);\n            }\n        }\n\n        for (int i = 1; i <= 4; i++) {\n            ArrayList<Circle> items = new ArrayList<>();\n            for (Circle c: tops) {\n                if (c.c == i) {\n                    items.add(c);\n                }\n            }\n\n            if (items.size() < 2) {\n                continue;\n            }\n            // TODO: sum6 ?????????\n            if (items.size() < 6) {\n                circles.removeAll(items);\n                for (Circle c: items) {\n                    for (Circle t : c.children) {\n                        t.parents.remove(c);\n                    }\n                }\n                dp(k + 1);\n                for (Circle c: items) {\n                    for (Circle t : c.children) {\n                        t.parents.add(c);\n                    }\n                }\n                circles.addAll(items);\n            } else {\n                for (int j = 0; j < items.size() - 1; j++) {\n                    for (int l = j + 1; l < items.size(); l++) {\n                        Circle c1 = items.get(j);\n                        Circle c2 = items.get(l);\n                        circles.remove(c1);\n                        circles.remove(c2);\n                        for (Circle c : c1.children) {\n                            c.parents.remove(c1);\n                        }\n                        for (Circle c : c2.children) {\n                            c.parents.remove(c2);\n                        }\n                        dp(k + 1);\n                        circles.add(c1);\n                        circles.add(c2);\n                        for (Circle c : c1.children) {\n                            c.parents.add(c1);\n                        }\n                        for (Circle c : c2.children) {\n                            c.parents.add(c2);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    static class Circle {\n        int x, y, r, c, id;\n        ArrayList<Circle> parents;\n        ArrayList<Circle> children;\n        Circle (int x, int y, int r, int c, int id) {\n            this.x = x;\n            this.y = y;\n            this.r = r;\n            this.c = c;\n            this.id = id;\n            parents = new ArrayList<>();\n            children = new ArrayList<>();\n        }\n\n        public boolean dip(Circle c) {\n            return Math.pow(this.r + c.r, 2) > Math.pow(this.x - c.x, 2) + Math.pow(this.y - c.y, 2);\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass cir {\n\t\tint x;\n\t\tint y;\n\t\tint r;\n\t\tint c;\n\n\t\tcir(Scanner sc) {\n\t\t\tthis.x = sc.nextInt();\n\t\t\tthis.y = sc.nextInt();\n\t\t\tr = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t}\n\n\t\tboolean is(cir tar) {\n\t\t\treturn (x - tar.x) * (x - tar.x) + (y - tar.y) * (y - tar.y) < (r+tar.r)\n\t\t\t\t\t* (r+tar.r);\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcir[] cc = new cir[n];\n\t\t\tint[] ic = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tcc[i] = new cir(sc);\n\n\t\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\t\tif(cc[i].is(cc[j])){\n\t\t\t\t\t\tic[i] |= 1<<j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean[] dp  = new boolean[1 << n];\n\t\t\tdp[0] = true;\n\t\t\tint res = 0;\n\t\t\tfor(int i = 0; i < 1<<n; i++){\n\t\t\t\tif(!dp[i]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tres = Math.max(Integer.bitCount(i),res);\n\t\t\t\tfor(int bi = 0 ; bi < n; bi++){\n\t\t\t\t\tif((~i & ic[bi]) != 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif((i & (1<<bi)) != 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int bi2 = bi+1 ; bi2 < n; bi2++){\n\t\t\t\t\t\tif((~(i | ic[bi]) & ic[bi2]) != 0){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif((i & (1<<bi2)) != 0){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(cc[bi].c != cc[bi2].c){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i |(1<< bi) |(1<< bi2)] = true;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint n = nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[][] cir = new int[n][4];\n\t\t\tint[] above = new int[n];// 上に重なってる円盤\n\n\t\t\tint[] bitDP = new int[1 << n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = nextInt();\n\t\t\t\tint y = nextInt();\n\t\t\t\tint r = nextInt();\n\t\t\t\tint c = nextInt();\n\t\t\t\tcir[i][0] = x;\n\t\t\t\tcir[i][1] = y;\n\t\t\t\tcir[i][2] = r;\n\t\t\t\tcir[i][3] = c;\n\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\t// 重なっている円盤があるかの判定\n\t\t\t\t\tint jx = cir[j][0] - x;\n\t\t\t\t\tint jy = cir[j][1] - y;\n\t\t\t\t\tint jr = cir[j][2];\n\t\t\t\t\tdouble dist = Math.sqrt(jx * jx + jy * jy);\n\t\t\t\t\tif (dist < r + jr) {\n\t\t\t\t\t\tabove[i] += (1 << j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint max = 0;\n\t\t\tfor (int bit = 0; bit < bitDP.length; bit++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\t\t// 到達しうる遷移か\n\t\t\t\t\t\tif (bit != 0 && bitDP[bit] == 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 円iとjが取り除かれていないかチェック\n\t\t\t\t\t\tif ((bit & ((1 << i) + (1 << j))) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// iとjの上に載っている円が全部取り除かれている\n\t\t\t\t\t\tif ((above[i] & bit) != above[i] || (above[j] & bit) != above[j]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 色が一緒かどうか\n\t\t\t\t\t\tif (cir[i][3] == cir[j][3]) {\n\t\t\t\t\t\t\tint newbit = bit + (1 << i) + (1 << j);\n\t\t\t\t\t\t\tbitDP[newbit] = Math.max(bitDP[newbit], bitDP[bit] + 2);\n\t\t\t\t\t\t\tmax = Math.max(max, bitDP[newbit]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(max);\n\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.util.*;\n\nimport javax.swing.JFrame;\nimport javax.swing.Box.Filler;\n\npublic class Main {\n\tCoin[] coins;\n\tScanner sc = new Scanner(System.in);\n\tint n;\n\tbyte[] state;\n\tVisualizer vis;\n\t\n\tvoid run() {\n//\t\tvis = new Visualizer();\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\tcoins = new Coin[n];\n\t\t\tfor(int i=0;i<n;i++) coins[i] = new Coin();\n\t\t\tint S=(1<<n)-1;\n\t\t\tstate = new byte[1<<n];\n\t\t\tfor(int i=0;i<(1<<n);i++) state[i] = -1;\n\t\t\tSystem.out.println(solve(S));\n\t\t}\n\t}\n\t\n\tbyte solve( int S ) {\n\t//\tSystem.out.println(S);\n\t\tif (state[S] >= 0) return state[S];\n\t\tboolean[] lapped = new boolean[n];\n\t\tanalyseLapped(S, lapped);\n//\t\tfor(int i=0;i<n;i++) System.out.print((S>>i)&1);\n//\t\tSystem.out.println();\n//\t\tvis.setS(S);\n//\t\tvis.repaint();\n//\t\tsc.next();\n\t\tbyte cnt = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif( lapped[i] ) continue;\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif ( !lapped[j] && coins[i].c == coins[j].c ) {\n\t\t\t\t\tcnt = (byte) Math.max(cnt, solve(S-((1<<i) + (1<<j)))+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn state[S] = cnt;\n\t}\n\t\n\tvoid analyseLapped(int S, boolean[] lapped) {\n\t\tfor(int i=0;i<n;i++) lapped[i] = false;\n\t\tfor(int i=0;i<n;i++) {\n//\t\t\tSystem.out.println( (S>>i) & 1 );\n\t\t\tif( ((S>>i) & 1) != 1 ) { lapped[i] = true ; continue; }\n\t\t\tfor(int j=i+1;j<n;j++) {\n//\t\t\t\tSystem.out.println(coins[i].isLapped(coins[j]));\n\t\t\t\tif( coins[i].isLapped(coins[j]) ) lapped[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\tclass Coin {\n\t\tint x, y, r, c;\n\t\t\n\t\tpublic Coin() {\n\t\t\tscan();\n\t\t}\n\t\t\n\t\tvoid scan() {\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\t\t\tr = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t}\n\t\t\n\t\tboolean isLapped( Coin c ) {\n\t\t\treturn (c.x-x)*(c.x-x)+(c.y-y)*(c.y-y) < (r+c.r)*(r+c.r);\n\t\t}\n\t}\n\tclass Visualizer extends JFrame {\n\t\tint offset = 100;\n\t\tint S;\n\t\tVisualizer () {\n\t\t\tthis.setSize(300, 300);\n\t\t\tthis.setVisible(true);\n\t\t\tS = 1<<n-1;\n\t\t}\n\t\tvoid setS(int S) {\n\t\t\tthis.S = S;\n\t\t}\n\t\tpublic void paint(Graphics g) {\n\t\t\tg.clearRect(0, 0, 300, 300);\n\t\t\tfor(int i=n-1;i>=0;i--) {\n\t\t\t\tif(((S>>i)&1) == 1 )oval(coins[i], g);\n\t\t\t}\n\t\t}\n\t\tColor[] colors = {Color.black, Color.BLUE, Color.red, Color.gray, Color.green, Color.yellow};\n\t\tvoid oval (Coin c, Graphics g) {\n\t\t\tg.setColor(colors[c.c-1]);\n\t\t\tg.fillOval(offset+c.x-c.r, offset+c.y-c.r, 2*c.r, 2*c.r);\n\t\t\tg.setColor(Color.white);\n\t\t\tg.drawOval(offset+c.x-c.r, offset+c.y-c.r, 2*c.r, 2*c.r);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tboolean[] f = new boolean[1<<n];\n\t\t\tboolean[][] a = new boolean[n][n];\n\t\t\tint[] c = new int[n];\n\t\t\t\n\t\t\tint[][] b = new int[n][3];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<3;j++) b[i][j] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt() - 1;\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tif(Math.sqrt((b[i][0]-b[j][0])*(b[i][0]-b[j][0])+(b[i][1]-b[j][1])*(b[i][1]-b[j][1]))<b[i][2]+b[j][2]){\n\t\t\t\t\t\ta[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tf[(1<<n)-1] = true;\n\t\t\tint max = 0;\n\t\t\tboolean flag;\n\t\t\tint sum;\n\t\t\tfor(int i=(1<<n)-1;i>=0;i--){\n\t\t\t\tsum = 0;\n\t\t\t\tif(f[i]==false) continue;\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(((i>>j)&1)==0) sum++;\n\t\t\t\t\tif(((i>>j)&1)==0) continue;\n\t\t\t\t\tflag = false;\n\t\t\t\t\tfor(int k=j-1;k>=0;k--){\n\t\t\t\t\t\tif(((i>>k)&1)==1 && a[j][k]==true){\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==true) continue;\n\t\t\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\t\t\tif(((i>>j)&1)==0 || c[j]!=c[k]) continue;\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tfor(int s=k-1;s>=0;s--){\n\t\t\t\t\t\t\tif(((i>>s)&1)==1 && a[k][s]==true){\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flag==true) continue;\n\t\t\t\t\t\tf[i^(1<<j)^(1<<k)] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, sum);\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tfinal int MOD = 1000000007;\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tint n;\n\tint[] x, y, r, c;\n\tint[] memo;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\treturn;\n\t\t\tx = new int[n];\n\t\t\ty = new int[n];\n\t\t\tr = new int[n];\n\t\t\tc = new int[n];\n\t\t\tmemo = new int[1 << n];\n\t\t\tArrays.fill(memo, -1);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t\tr[i] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\t// ????????????????????????????????????????±???????\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tL: for (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (c[i] != c[j])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int k = j - 1; k >= 0; k--) {\n\t\t\t\t\t\tint pDis_j = (x[k] - x[j]) * (x[k] - x[j]) + (y[k] - y[j]) * (y[k] - y[j]);\n\t\t\t\t\t\tint rDis_j = (r[k] + r[j]) * (r[k] + r[j]);\n\t\t\t\t\t\tint pDis_i = (x[k] - x[i]) * (x[k] - x[i]) + (y[k] - y[i]) * (y[k] - y[i]);\n\t\t\t\t\t\tint rDis_i = (r[k] + r[i]) * (r[k] + r[i]);\n\t\t\t\t\t\t// k?????????????????£??????????????§????????????\n\t\t\t\t\t\tif (pDis_j < rDis_j) continue L;\n\t\t\t\t\t\tif (k < i && pDis_i < rDis_i) continue L;\n\t\t\t\t\t}\n\t\t\t\t\tmax = Math.max(max, 2 + bitDP( 1 << i | 1 << j));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tint bitDP(int mask) {\n\t\tif (memo[mask] != -1) return memo[mask];\n\n\t\t// ?¬????i???????????????(???????????\\?????????????????????)\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tL: for (int j = i + 1; j < n; j++) {\n\t\t\t\tif (c[i] != c[j]) continue;\n\t\t\t\t// ??¢???i or j????????£?????????\n\t\t\t\tif ((mask & (1 << i)) != 0 || (mask & (1 << j)) != 0) continue;\n\t\t\t\tfor (int k = j - 1; k >= 0; k--) {\n\t\t\t\t\t// ??¢???k???????????????????????????\n\t\t\t\t\tif ((mask & 1 << k) != 0) continue;\n\t\t\t\t\tint pDis_j = (x[k] - x[j]) * (x[k] - x[j]) + (y[k] - y[j]) * (y[k] - y[j]);\n\t\t\t\t\tint rDis_j = (r[k] + r[j]) * (r[k] + r[j]);\n\t\t\t\t\tint pDis_i = (x[k] - x[i]) * (x[k] - x[i]) + (y[k] - y[i]) * (y[k] - y[i]);\n\t\t\t\t\tint rDis_i = (r[k] + r[i]) * (r[k] + r[i]);\n\n\t\t\t\t\t// k?????????????????£??????????????§????????????\n\t\t\t\t\tif (pDis_j < rDis_j) continue L;\n\t\t\t\t\tif (k < i && pDis_i < rDis_i) continue L;\n\t\t\t\t}\n\t\t\t\tres = Math.max(res, 2 + bitDP(mask | (1 << i | 1 << j)));\n\t\t\t}\n\t\t}\n\t\treturn memo[mask] = res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(long[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (a[i] >= border)\n\tint lower_bound(int a[], int border) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (border <= a[mid]) {\n\t\t\t\tr = mid;\n\t\t\t} else {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int n;\n\tstatic int[] x;\n\tstatic int[] y;\n\tstatic int[] r;\n\tstatic int[] c;\n\tstatic boolean[][] cover;\n\tstatic int[] dp;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx = new int[n];\n\t\t\ty = new int[n];\n\t\t\tr = new int[n];\n\t\t\tc = new int[n];\n\t\t\tcover = new boolean[n][n];\n\t\t\tdp = new int[(1<<n)];\n\t\t\tArrays.fill(dp, -1);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t\tr[i] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt();\n\t\t\t\tfor(int j=0;j<i;j++) {\n\t\t\t\t\tint dx = x[j] - x[i];\n\t\t\t\t\tint dy = y[j] - y[i];\n\t\t\t\t\tint rs = r[i] + r[j];\n\t\t\t\t\tif (dx*dx+dy*dy<rs*rs) {\n\t\t\t\t\t\tcover[j][i] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dfs(0));\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static int dfs(int used) {\n\t\tif (dp[used]!=-1) {\n\t\t\treturn dp[used];\n\t\t}\n\t\tArrayList<Integer>[] canuse = new ArrayList[4];\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tcanuse[i] = new ArrayList<Integer>();\n\t\t}\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (((1<<i)&used) == 0) {\n\t\t\t\tboolean flag = true;\n\t\t\t\tfor(int j=0;j<i;j++) {\n\t\t\t\t\tif (((1<<j)&used) == 0 && cover[j][i]) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tcanuse[c[i]].add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tboolean flag = false;\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tif (canuse[i].size() >= 2) {\n\t\t\t\tfor(int j=0;j<canuse[i].size()-1;j++) {\n\t\t\t\t\tfor(int k=j+1;k<canuse[i].size();k++) {\n\t\t\t\t\t\tint usednext = used | (1<<canuse[i].get(j)) | (1<<canuse[i].get(k));\n\t\t\t\t\t\tret = Math.max(ret, dfs(usednext));\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret = flag ? ret + 2 : 0;\n\t\tdp[used] = ret;\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint n = nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[][] cir = new int[n][4];\n\t\t\tint[] above = new int[n];// 上に重なってる円盤\n\n\t\t\tint[] bitDP = new int[1 << n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = nextInt();\n\t\t\t\tint y = nextInt();\n\t\t\t\tint r = nextInt();\n\t\t\t\tint c = nextInt();\n\t\t\t\tcir[i][0] = x;\n\t\t\t\tcir[i][1] = y;\n\t\t\t\tcir[i][2] = r;\n\t\t\t\tcir[i][3] = c;\n\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\t// 重なっている円盤があるかの判定\n\t\t\t\t\tint jx = cir[j][0] - x;\n\t\t\t\t\tint jy = cir[j][1] - y;\n\t\t\t\t\tint jr = cir[j][2];\n\t\t\t\t\tdouble dist = Math.sqrt(jx * jx + jy * jy);\n\t\t\t\t\tif (dist < r + jr) {\n\t\t\t\t\t\tabove[i] += (1 << j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint max = 0;\n\t\t\tfor (int bit = 0; bit < bitDP.length; bit++) {\n\t\t\t\t// 到達しうる遷移か\n\t\t\t\tif (bit != 0 && bitDP[bit] == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t// 円iとjが取り除かれていないかチェック\n\t\t\t\t\tif ((bit & (1 << i)) != 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\t\t// 円iとjが取り除かれていないかチェック\n\t\t\t\t\t\tif ((bit & ((1 << i) + (1 << j))) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// iとjの上に載っている円が全部取り除かれている\n\t\t\t\t\t\tif ((above[i] & bit) != above[i] || (above[j] & bit) != above[j]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 色が一緒かどうか\n\t\t\t\t\t\tif (cir[i][3] == cir[j][3]) {\n\t\t\t\t\t\t\tint newbit = bit + (1 << i) + (1 << j);\n\t\t\t\t\t\t\tbitDP[newbit] = Math.max(bitDP[newbit], bitDP[bit] + 2);\n\t\t\t\t\t\t\tmax = Math.max(max, bitDP[newbit]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(max);\n\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint INF = 100000000;\n\tHashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\n\tclass Circle {\n\t\tint x;\n\t\tint y;\n\t\tint r;\n\t\tint c;\n\t\t\n\t\tCircle(int x, int y, int r, int c) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\t\n\tboolean intersect(Circle c1, Circle c2) {\n\t\tdouble dx = c1.x - c2.x, dy = c1.y - c2.y;\n\t\tdouble a = (c1.r + c2.r) * (c1.r + c2.r);\n\t\tdouble b = dx * dx + dy * dy;\n\t\treturn a > b;\n\t}\n\t\n\tint[] mask;\n\tint calc(Circle[] circle, int bit) {\n\t\t\n\t\tif (map.containsKey(bit)) return map.get(bit);\n\t\t\n\t\tint n = circle.length;\n\t\tint res = n - Integer.bitCount(bit);\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (((1 << i) & bit) == 0 || (mask[i] & bit) != 0) continue;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (((1 << j) & bit) == 0 || (mask[j] & bit) != 0) continue;\n\t\t\t\tif (circle[i].c != circle[j].c) continue;\n\t\t\t\t\n\t\t\t\tint nbit = bit;\n\t\t\t\tnbit -= (1 << i);\n\t\t\t\tnbit -= (1 << j);\n\t\t\t\t\n\t\t\t\tres = Math.max(res, calc(circle, nbit));\n\t\t\t}\n\t\t}\n\t\t\n\t\tmap.put(bit, res);\n\t\treturn res;\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tCircle[] circle = new Circle[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tcircle[i] = new Circle(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\t}\n\t\t\t\n\t\t\tmap.clear();\n\t\t\t\n\t\t\tmask = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (intersect(circle[i], circle[j])) mask[i] |= (1 << j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(calc(circle, (1 << n) - 1));\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static int n;\n    static Circle circle[] = new Circle[24];\n    static int[] state = new int[20000000];\n    static int[] two = new int[25];\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        powTwo();\n\n        while (true){\n            n = sc.nextInt();\n            if (n==0) break;\n\n            for (int i = 0; i < 20000000; i++) {\n                state[i] = 0;\n            }\n            for (int i = 0; i < n; i++) {\n                circle[i] = new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt());\n                overCircle(i);\n            }\n\n            System.out.println(remove(0, 0));\n        }\n    }\n\n    static void powTwo() {\n        two[0] = 1;\n        for (int i = 1; i < 25; i++) {\n            two[i] = two[i-1]*2;\n        }\n    }\n\n    static void overCircle(int i) {\n        for (int j = 0; j < i; j++) {\n            int l = (int)(Math.pow(circle[j].x-circle[i].x,2)+Math.pow(circle[j].y-circle[i].y,2));\n            if (Math.pow(circle[j].r+circle[i].r,2)>l){\n                circle[i].over[j] = 1;\n                circle[i].cnt++;\n            }\n        }\n    }\n\n    static int remove(int cnt, int s) {\n        state[s] = 1;\n        int ans = cnt;\n\n        for (int i = 0; i < n; i++) {\n            if (circle[i].flag==1 || circle[i].cnt>0) continue;\n\n            for (int j = i+1; j < n; j++) {\n                if (circle[j].flag==0&&circle[j].cnt==0&&circle[i].c==circle[j].c){\n                    if (state[s+two[i]+two[j]]==1) continue;\n                    circle[i].flag = circle[j].flag = 1;\n                    for (int k = 0; k < n; k++) {\n                        if (circle[k].over[i]==1) circle[k].cnt--;\n                        if (circle[k].over[j]==1) circle[k].cnt--;\n                    }\n                    ans = Math.max(remove(cnt+2, s+two[i]+two[j]), ans);\n                    circle[i].flag = circle[j].flag = 0;\n                    for (int k = 0; k < n; k++) {\n                        if (circle[k].over[i]==1) circle[k].cnt++;\n                        if (circle[k].over[j]==1) circle[k].cnt++;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n\n    static class Circle{\n        int x, y, r, c;\n        int[] over = new int[24];\n        int cnt = 0, flag = 0;\n        Circle(int s, int t, int u, int v){\n            x = s; y = t; r = u; c = v;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tint [] x,y,r,c;\n\tboolean [] used;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tx = new int[n];\n\t\t\ty = new int[n];\n\t\t\tr = new int[n];\n\t\t\tc = new int[n];\n\t\t\tused = new boolean[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t\tr[i] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint len = 1 << n;\n\t\t\tboolean [][] dp = new boolean[len][n+1];\n\t\t\tdp[0][0] = true;\n\t\t\tint ans = 0;\n\t\t\tfor(int i=0; i < n;i+=2){\n\t\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\t\tif(dp[j][i] == false) continue;\n\t\t\t\t\t\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\t\tfor(int l = k+1; l < n; l++){\n\t\t\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\t\t\tif(! issameC(k,l)) continue;\n\t\t\t\t\t\t\tif(isOVL(k) || isOVL(l)) continue;\n\t\t\t\t\t\t\tint num;\n\t\t\t\t\t\t\tint kInd = 1 << k;\n\t\t\t\t\t\t\tint lInd = 1 << l;\n\t\t\t\t\t\t\tused[k] = true;\n\t\t\t\t\t\t\tused[l] = true;\n\t\t\t\t\t\t\tnum = j | kInd;\n\t\t\t\t\t\t\tnum = num | lInd;\n\t\t\t\t\t\t\t//System.out.println(\"num= \"+num + \" j= \" + j +  \" k = \"+ k + \" l= \" + l );\n\t\t\t\t\t\t\tdp[num][i+2] = true;\n\t\t\t\t\t\t\tans = i+2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\t//TODO debug\n//\t\t\tfor(int i= 0; i < len; i++){\n//\t\t\t\tfor(int j = 0; j < n+1; j++){\n//\t\t\t\t\tif(dp[i][j]){\n//\t\t\t\t\t\tSystem.out.print(\"1 \");\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tSystem.out.print(\"0 \");\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate boolean isOVL(int a) {\n\t\tif(a == 0) return false;\n\t\tint ax = x[a];\n\t\tint ay = y[a];\n\t\tint ar= r[a];\n\t\tfor(int i = a-1; i >= 0; i--){\n\t\t\tif(used[i]) continue;\n\t\t\tint ix = x[i];\n\t\t\tint iy = y[i];\n\t\t\tint ir = r[i];\n\t\t\tdouble dis = Point2D.Double.distance(ax, ay, ix, iy);\n\t\t\tint rr = ir + ar;\n\t\t\tif(dis < rr)return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean issameC(int a, int b) {\n\t\tif(c[a] == c[b]) return true;\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static int[] color;\n\tpublic static int[] state;\n\tpublic static int[] cnum;\n\tpublic static int n;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = in.nextInt();\n\t\t\tif(n == 0) return;\n\t\t\tCircle[] cir = new Circle[n];\n\t\t\tcolor = new int[4];\n\t\t\tstate = new int[n];\n\t\t\tcnum = new int[4];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tcir[i] = new Circle(in.nextInt()\n\t\t\t\t\t\t, in.nextInt()\n\t\t\t\t\t\t, in.nextInt()\n\t\t\t\t\t\t, in.nextInt()-1);\n\t\t\t\tcolor[cir[i].color] |= 1<<i;\n\t\t\t\tcnum[cir[i].color]++;\n\t\t\t\tfor(int j=0; j<i; j++){\n\t\t\t\t\tif(cir[i].cross(cir[j])) state[i] |= 1<<j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = n;\n\t\t\tset = new HashSet<Integer>();\n\t\t\tdfs((1<<n)-1);\n\t\t\tSystem.out.println(n-res);\n\t\t}\n\t}\n\t\n\tpublic static HashSet<Integer> set;\n\tpublic static int res;\n\tpublic static void dfs(int all){\n\t\tif(set.contains(all)) return;\n\t\tset.add(all);\n\t\tres = Math.min(res, Integer.bitCount(all));\n\t\tfor(int i=0; i<4; i++){\n\t\t\tint col = color[i] & all;\n\t\t\tif(Integer.bitCount(col) < 2) continue;\n\t\t\tfor(int j=1, i1=0; i1<n; i1++,j<<=1){\n\t\t\t\tif((col&j) == 0 || (state[i1]&all) > 0) continue;\n\t\t\t\tfor(int k=j<<1, i2=i1+1; i2<n; i2++,k<<=1){\n\t\t\t\t\tif((col&k) == 0 || (state[i2]&all) > 0) continue;\n\t\t\t\t\tdfs(all&~j&~k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Circle{\n\tint x, y, r;\n\tint color;\n\tpublic Circle(int x, int y, int r, int color){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.r = r;\n\t\tthis.color = color;\n\t}\n\t\n\tpublic boolean cross(Circle c){\n\t\treturn sq(x-c.x)+sq(y-c.y) < sq(r+c.r);\n\t}\n\t\n\tpublic int sq(int a){\n\t\treturn a*a;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.Stack;\n\n\npublic class Main {\n\t\n\tpublic static boolean is_covered(int node, int bit, boolean[][] adj){\n\t\tfor(int upper = node - 1; upper >= 0; upper--){\n\t\t\tif((bit & (1 << upper)) != 0){\n\t\t\t\tcontinue;\n\t\t\t}else if(adj[upper][node]){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] x_pos  = new int[n];\n\t\t\tint[] y_pos  = new int[n];\n\t\t\tint[] rs     = new int[n];\n\t\t\tint[] colors = new int[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tx_pos[i]  = sc.nextInt();\n\t\t\t\ty_pos[i]  = sc.nextInt();\n\t\t\t\trs[i]     = sc.nextInt();\n\t\t\t\tcolors[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] cover = new boolean[n][n];\n\t\t\t\n\t\t\tfor(int upper = 0; upper < n; upper++){\n\t\t\t\tfor(int lower = upper + 1; lower < n; lower++){\n\t\t\t\t\tfinal int x_diff = (x_pos[upper] - x_pos[lower]);\n\t\t\t\t\tfinal int y_diff = (y_pos[upper] - y_pos[lower]);\n\t\t\t\t\tfinal int r_diff = (rs[upper] + rs[lower]);\n\t\t\t\t\t\n\t\t\t\t\tif(x_diff * x_diff + y_diff * y_diff < r_diff * r_diff){\n\t\t\t\t\t\tcover[upper][lower] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal int bit_max = 1 << n;\n\t\t\t\n\t\t\tint[] dp = new int[bit_max];\n\t\t\tArrays.fill(dp, -1);\n\t\t\tdp[0] = 0;\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tfor(int bit = 0; bit < bit_max; bit++){\n\t\t\t\tif(dp[bit] < 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tmax = Math.max(max, dp[bit]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println(dp[bit]);\n\t\t\t\t\n\t\t\t\tfor(int left = 0; left < n; left++){\n\t\t\t\t\tif((bit & (1 << left)) != 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(is_covered(left, bit, cover)){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//System.out.println(\"come\");\n\t\t\t\t\t\n\t\t\t\t\tfor(int right = left + 1; right < n; right++){\n\t\t\t\t\t\tif((bit & (1 << right)) != 0){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(is_covered(right, bit, cover)){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(colors[left] != colors[right]){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfinal int next_bit = ((bit | (1 << left)) | (1 << right));\n\t\t\t\t\t\t//System.out.println(next_bit);\n\t\t\t\t\t\t\n\t\t\t\t\t\tdp[next_bit] = Math.max(dp[next_bit], dp[bit] + 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[][] cir = new int[n][4];\n\t\t\tint[] above = new int[n];// 上に重なってる円盤\n\n\t\t\tint[] bitDP = new int[1 << n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tcir[i][0] = x;\n\t\t\t\tcir[i][1] = y;\n\t\t\t\tcir[i][2] = r;\n\t\t\t\tcir[i][3] = c;\n\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\t// 重なっている円盤があるかの判定\n\t\t\t\t\tint jx = cir[j][0] - x;\n\t\t\t\t\tint jy = cir[j][1] - y;\n\t\t\t\t\tint jr = cir[j][2];\n\t\t\t\t\tdouble dist = Math.sqrt(jx * jx + jy * jy);\n\t\t\t\t\tif (dist < r + jr) {\n\t\t\t\t\t\tabove[i] += (1 << j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint max = 0;\n\t\t\tfor (int bit = 0; bit < bitDP.length; bit++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\t\t// 到達しうる遷移か\n\t\t\t\t\t\tif (bit != 0 && bitDP[bit] == 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 円iとjが取り除かれていないかチェック\n\t\t\t\t\t\tif ((bit & ((1 << i) + (1 << j))) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// iとjの上に載っている円が全部取り除かれている\n\t\t\t\t\t\tif ((above[i] & bit) != above[i] || (above[j] & bit) != above[j]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 色が一緒かどうか\n\t\t\t\t\t\tif (cir[i][3] == cir[j][3]) {\n\t\t\t\t\t\t\tint newbit = bit + (1 << i) + (1 << j);\n\t\t\t\t\t\t\tbitDP[newbit] = Math.max(bitDP[newbit], bitDP[bit] + 2);\n\t\t\t\t\t\t\tmax = Math.max(max, bitDP[newbit]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(max);\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1175();\n\t}\n\tfinal int INF=1<<28;\n\t\n\tclass AOJ1175{\n\t\tAOJ1175(){\n\t\t\tccc = new Circle[25][2];\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tCircle[] c;\n\t\tCircle[][] ccc;\n\t\tint N;\n\t\tvoid solve(){\n\t\t\tc=new Circle[N];\n\t\t\tfor(int i=0; i<N; ++i)\tc[i]=new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt()-1);\n\t\t\t\n\t\t\tSystem.out.println(dfs(c, 0));\n\t\t}\n\t\tint dfs(Circle[] c,int depth){\n//\t\t\tSystem.out.println(depth+\" \"+Arrays.toString(c));\n\t\t\tint ret=0;\n\t\t\tfor(int i=0; i<N; ++i)if(c[i]==null)\t++ret;\n\t\t\tArrayList<ArrayList<Integer>> list=list(c);\n//\t\t\tSystem.out.println(depth+\" \"+list);\n\t\t\tfor(int i=0; i<4; ++i){\n\t\t\t\tif(list.get(i).size() >= 2){\n\t\t\t\t\tint n=list.get(i).size(), b=(1<<n)-1;\n\t\t\t\t\tfor(int j=3; j<=b; ++j)if(Integer.bitCount(j)==2){\n\t\t\t\t\t\tfor(int k=0,l=0; k<n; ++k)if((j&(1<<k))>0){\n\t\t\t\t\t\t\tccc[depth][l++]=c[list.get(i).get(k)];\n\t\t\t\t\t\t\tc[list.get(i).get(k)]=null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret = max(ret, dfs(c, depth+1));\n\t\t\t\t\t\tfor(int k=0,l=0; k<n; ++k)if((j&(1<<k))>0)\tc[list.get(i).get(k)]=ccc[depth][l++];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tArrayList<ArrayList<Integer>> list(Circle[] c){\n\t\t\tArrayList<ArrayList<Integer>> ret=new ArrayList<ArrayList<Integer>>(4);\n\t\t\tfor(int i=0; i<4; ++i)\tret.add(new ArrayList<Integer>());\n\t\t\tfor(int i=0; i<N; ++i)if(c[i]!=null){\n\t\t\t\tboolean flg=true;\n\t\t\t\tfor(int j=0; j<i; ++j)if(c[j]!=null){\n\t\t\t\t\tflg = (c[i].r+c[j].r) <= (c[i].p.distance(c[j].p));\n\t\t\t\t\tif(!flg)\tbreak;\n\t\t\t\t}\n\t\t\t\tif(flg)\tret.get(c[i].c).add(i);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tclass Circle{\n\t\t\tPoint2D p;\n\t\t\tdouble r;\n\t\t\tint c;\n\t\t\tCircle(double x,double y,double r,int c){\n\t\t\t\tthis.p=new Point2D.Double(x,y);\n\t\t\t\tthis.r=r;\n\t\t\t\tthis.c=c;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn p.getX()+\",\"+p.getY()+\",\"+r+\" \"+c;\n\t\t\t}\n\t\t}\n\t}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tnew AOJ1175().doIt(n);\n\t\t}\n\t}\n\n\n\tclass AOJ1175{\n\t\tvoid doIt(int n){\n\t\t\tboolean[] memo = new boolean[(1<<n)];\n\t\t\tArrays.fill(memo,false);\n\t\t\tData[] data = new Data[n];\n\t\t\tfor(int i=0;i<n;i++)data[i] = new Data(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\tlong bit = 0;\n\t\t\tfor(int i=0;i<n;i++)bit += 1 << i;\n\t\t\tLinkedList<State> q = new LinkedList<State>();\n\t\t\tq.add(new State(bit, 0));\n\t\t\tint cnt[] = new int[n];\n\t\t\tint result = -1;\n\t\t\twhile(q.size()>0){\n\t\t\t\tState now = q.remove();\n//\t\t\t\tSystem.out.println(bit);\n\t\t\t\tbit = now.bit;\n\t\t\t\tif(memo[(int)bit])continue;\n\t\t\t\tmemo[(int)bit] = true;\n\t\t\t\tresult = Math.max(result, now.num);\n//\t\t\t\tSystem.out.println(Long.toBinaryString(bit));\n\t\t\t\tboolean sw = false;\n\t\t\t\tArrays.fill(cnt,0);\n\t\t\t\tfor(int i=0;i<n;i++)for(int s=i-1;s>=0;s--)if((bit>>i)%2==1&&(bit>>s)%2==1){\n\t\t\t\t\tif(Point2D.distance(data[i].x, data[i].y, data[s].x, data[s].y)<data[s].r+data[i].r)cnt[i]++;\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(Arrays.toString(cnt));\n\t\t\t\tfor(int c=1;c<=4;c++){//color\n\t\t\t\t\tfor(int i=0;i<n;i++)for(int s=i+1;s<n;s++)if(data[i].color==c&&data[s].color==c&&cnt[i]==0&&cnt[s]==0){\n\t\t\t\t\t\tif(i==s||((bit>>i)%2==0)||((bit>>s)%2==0))continue;\n\t\t\t\t\t\tlong bit2 = bit-(1<<i)-(1<<s);\n//\t\t\t\t\t\tSystem.out.println(bit2);\n\t\t\t\t\t\tq.add(new State(bit2,now.num+2));\n\t\t\t\t\t\tsw = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(sw==false)break;\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t\t\n\t\tclass State{\n\t\t\tlong bit;\n\t\t\tint num;\n\t\t\tpublic State(long bit,int num){\n\t\t\t\tthis.bit = bit;\n\t\t\t\tthis.num = num;\n\t\t\t}\n\t\t}\n\n\t\tclass Data{\n\t\t\tint x,y,color,r;\n\t\t\tpublic Data(int x,int y,int r,int color) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.r = r;\n\t\t\t\tthis.color = color;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1175();\n\t}\n\tfinal int INF=1<<28;\n\t\n\tclass AOJ1175{\n\t\tAOJ1175(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tCircle[] c;\n\t\tboolean[][] b;\n\t\tHashSet<Integer> vtd;\n\t\tint N;\n\t\tvoid solve(){\n\t\t\tc=new Circle[N];\n\t\t\tfor(int i=0; i<N; ++i)\tc[i]=new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt()-1);\n\t\t\tb=new boolean[N][N];\n\t\t\tfor(int i=0; i<N; ++i)for(int j=0; j<i; ++j)\tb[i][j]=(c[i].r+c[j].r <= c[i].p.distance(c[j].p));\n\t\t\tvtd = new HashSet<Integer>();\n\t\t\tint ret=dfs((1<<N)-1);\n\t\t\tSystem.out.println(N-ret);\n\t\t}\n\t\tint dfs(int cc){\n//\t\t\tSystem.out.println(Integer.toBinaryString(cc));\n\t\t\tint ret=Integer.bitCount(cc);\n\t\t\tif(vtd.contains(cc))\treturn ret;\n\t\t\tvtd.add(cc);\n\t\t\t\n\t\t\tint cand=0;\n\t\t\tfor(int i=0; i<N; ++i)if((cc&(1<<i))>0){\n\t\t\t\tboolean flg=true;\n\t\t\t\tfor(int j=0; j<i; ++j)if((cc&(1<<j))>0 && !b[i][j]){\n\t\t\t\t\tflg=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(flg)\tcand |= (1<<i);\n\t\t\t}\n//\t\t\tSystem.out.println(Integer.toBinaryString(cand));\n\t\t\tfor(int i=0; i<N; ++i)if((cand&(1<<i))>0){\n\t\t\t\tfor(int j=0; j<N; ++j)if(i!=j && (cand&(1<<j))>0 && c[i].c==c[j].c){\n\t\t\t\t\tint tmp=(1<<i)|(1<<j);\n\t\t\t\t\tcc ^= tmp;\n\t\t\t\t\tret = min(ret, dfs(cc));\n\t\t\t\t\tcc |= tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tclass Circle{\n\t\t\tPoint2D p;\n\t\t\tdouble r;\n\t\t\tint c;\n\t\t\tCircle(double x,double y,double r,int c){\n\t\t\t\tthis.p=new Point2D.Double(x,y);\n\t\t\t\tthis.r=r;\n\t\t\t\tthis.c=c;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.util.*;\n\nimport javax.swing.JFrame;\nimport javax.swing.Box.Filler;\n\npublic class Main {\n\tCoin[] coins;\n\tScanner sc = new Scanner(System.in);\n\tint n;\n\tbyte[] state;\n\tVisualizer vis;\n\t\n\tvoid run() {\n//\t\tvis = new Visualizer();\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\tcoins = new Coin[n];\n\t\t\tfor(int i=0;i<n;i++) coins[i] = new Coin();\n\t\t\tint S=(1<<n)-1;\n\t\t\tstate = new byte[1<<n];\n\t\t\tfor(int i=0;i<(1<<n);i++) state[i] = -1;\n\t\t\tSystem.out.println(solve(S));\n\t\t}\n\t}\n\t\n\tbyte solve( int S ) {\n\t//\tSystem.out.println(S);\n\t\tif (state[S] >= 0) return state[S];\n\t\tboolean[] lapped = new boolean[n];\n\t\tanalyseLapped(S, lapped);\n//\t\tfor(int i=0;i<n;i++) System.out.print((S>>i)&1);\n//\t\tSystem.out.println();\n//\t\tvis.setS(S);\n//\t\tvis.repaint();\n//\t\tsc.next();\n\t\tbyte cnt = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif( lapped[i] ) continue;\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif ( !lapped[j] && coins[i].c == coins[j].c ) {\n\t\t\t\t\tcnt = (byte) Math.max(cnt, solve(S-((1<<i) + (1<<j)))+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn state[S] = cnt;\n\t}\n\t\n\tvoid analyseLapped(int S, boolean[] lapped) {\n\t\tfor(int i=0;i<n;i++) lapped[i] = false;\n\t\tfor(int i=0;i<n;i++) {\n//\t\t\tSystem.out.println( (S>>i) & 1 );\n\t\t\tif( ((S>>i) & 1) != 1 ) { lapped[i] = true ; continue; }\n\t\t\tfor(int j=i+1;j<n;j++) {\n//\t\t\t\tSystem.out.println(coins[i].isLapped(coins[j]));\n\t\t\t\tif( coins[i].isLapped(coins[j]) ) lapped[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\tclass Coin {\n\t\tint x, y, r, c;\n\t\t\n\t\tpublic Coin() {\n\t\t\tscan();\n\t\t}\n\t\t\n\t\tvoid scan() {\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\t\t\tr = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t}\n\t\t\n\t\tboolean isLapped( Coin c ) {\n\t\t\treturn (c.x-x)*(c.x-x)+(c.y-y)*(c.y-y) < (r+c.r)*(r+c.r);\n\t\t}\n\t}\n\tclass Visualizer extends JFrame {\n\t\tint offset = 100;\n\t\tint S;\n\t\tVisualizer () {\n\t\t\tthis.setSize(300, 300);\n\t\t\tthis.setVisible(true);\n\t\t\tS = 1<<n-1;\n\t\t}\n\t\tvoid setS(int S) {\n\t\t\tthis.S = S;\n\t\t}\n\t\tpublic void paint(Graphics g) {\n\t\t\tg.clearRect(0, 0, 300, 300);\n\t\t\tfor(int i=n-1;i>=0;i--) {\n\t\t\t\tif(((S>>i)&1) == 1 )oval(coins[i], g);\n\t\t\t}\n\t\t}\n\t\tColor[] colors = {Color.black, Color.BLUE, Color.red, Color.gray, Color.green, Color.yellow};\n\t\tvoid oval (Coin c, Graphics g) {\n\t\t\tg.setColor(colors[c.c-1]);\n\t\t\tg.fillOval(offset+c.x-c.r, offset+c.y-c.r, 2*c.r, 2*c.r);\n\t\t\tg.setColor(Color.white);\n\t\t\tg.drawOval(offset+c.x-c.r, offset+c.y-c.r, 2*c.r, 2*c.r);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tnew AOJ1175().doIt(n);\n\t\t}\n\t}\n\n\n\tclass AOJ1175{\n\t\tvoid doIt(int n){\n\t\t\tboolean[] memo = new boolean[(1<<24)];\n\t\t\tArrays.fill(memo,false);\n\t\t\tData[] data = new Data[n];\n\t\t\tfor(int i=0;i<n;i++)data[i] = new Data(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\tlong bit = 0;\n\t\t\tfor(int i=0;i<n;i++)bit += 1 << i;\n\t\t\tLinkedList<State> q = new LinkedList<State>();\n\t\t\tq.add(new State(bit, 0));\n\t\t\tint cnt[] = new int[n];\n\t\t\tint result = -1;\n\t\t\twhile(q.size()>0){\n\t\t\t\tState now = q.remove();\n//\t\t\t\tSystem.out.println(bit);\n\t\t\t\tbit = now.bit;\n\t\t\t\tif(memo[(int)bit])continue;\n\t\t\t\tmemo[(int)bit] = true;\n\t\t\t\tresult = Math.max(result, now.num);\n//\t\t\t\tSystem.out.println(Long.toBinaryString(bit));\n\t\t\t\tboolean sw = false;\n\t\t\t\tArrays.fill(cnt,0);\n\t\t\t\tfor(int i=0;i<n;i++)for(int s=i-1;s>=0;s--)if((bit>>i)%2==1&&(bit>>s)%2==1){\n\t\t\t\t\tif(Point2D.distance(data[i].x, data[i].y, data[s].x, data[s].y)<data[s].r+data[i].r)cnt[i]++;\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(Arrays.toString(cnt));\n\t\t\t\tfor(int c=1;c<=4;c++){//color\n\t\t\t\t\tfor(int i=0;i<n;i++)for(int s=i+1;s<n;s++)if(data[i].color==c&&data[s].color==c&&cnt[i]==0&&cnt[s]==0){\n\t\t\t\t\t\tif(i==s||((bit>>i)%2==0)||((bit>>s)%2==0))continue;\n\t\t\t\t\t\tlong bit2 = bit-(1<<i)-(1<<s);\n//\t\t\t\t\t\tSystem.out.println(bit2);\n\t\t\t\t\t\tq.add(new State(bit2,now.num+2));\n\t\t\t\t\t\tsw = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(sw==false)break;\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t\t\n\t\tclass State{\n\t\t\tlong bit;\n\t\t\tint num;\n\t\t\tpublic State(long bit,int num){\n\t\t\t\tthis.bit = bit;\n\t\t\t\tthis.num = num;\n\t\t\t}\n\t\t}\n\n\t\tclass Data{\n\t\t\tint x,y,color,r;\n\t\t\tpublic Data(int x,int y,int r,int color) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.r = r;\n\t\t\t\tthis.color = color;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N, ans;\n\tstatic int[] X = new int[24];\n\tstatic int[] Y = new int[24];\n\tstatic int[] R = new int[24];\n\tstatic int[] C = new int[24];\n\tstatic int[] mask = new int[24];\n\tstatic BitSet visited;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tX[i] = sc.nextInt();\n\t\t\t\tY[i] = sc.nextInt();\n\t\t\t\tR[i] = sc.nextInt();\n\t\t\t\tC[i] = sc.nextInt();\n\t\t\t}\n\t\t\tvisited = new BitSet(1 << N);\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic int solve() {\n\t\tans = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tmask[i] = 0;\n\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\tif (cover(i, j)) mask[i] |= (1 << j);\n\t\t\t}\n\t\t}\n\t\tdfs((1 << N) - 1);\n\t\treturn ans;\n\t}\n\n\tstatic void dfs(int rest) {\n\t\tif (visited.get(rest)) return;\n\t\tans = Math.max(ans, N - Integer.bitCount(rest));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif ((rest & (1 << i)) == 0) continue;\n\t\t\tif ((rest & mask[i]) != 0) continue;\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tif (C[i] != C[j]) continue;\n\t\t\t\tif ((rest & (1 << j)) == 0) continue;\n\t\t\t\tif ((rest & mask[j]) != 0) continue;\n\t\t\t\tdfs(rest - (1 << i) - (1 << j));\n\t\t\t}\n\t\t}\n\t\tvisited.set(rest);\n\t}\n\n\tstatic boolean cover(int i, int j) {\n\t\treturn (X[j] - X[i]) * (X[j] - X[i]) + (Y[j] - Y[i]) * (Y[j] - Y[i]) < (R[i] + R[j]) * (R[i] + R[j]);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n@SuppressWarnings(\"unchecked\")\npublic class Main {\n\tint n, max;\n\tint[] c;\n\tboolean[] f;\n\tboolean[][] a;\n\t\n\t\n\tvoid dfs(){\n\t\tboolean flag;\n\t\tArrayList<Integer>[] list = new ArrayList[4];\n\t\t\n\t\twhile(true){\n\t\t\tfor(int i=0;i<4;i++) list[i] = new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tflag = false;\n\t\t\t\tif(f[i]==false){\n\t\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\t\tif(f[j]==false && a[i][j]==true) flag = true;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==false) list[c[i]].add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tflag = false;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(list[i].size()==2 || list[i].size()==4 || list[i].size()==6){\n\t\t\t\t\tfor(int j=0;j<list[i].size();j++) f[list[i].get(j)] = true;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==false) break;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint s = list[i].size();\n\t\t\tif(s==3 || s==5){\n\t\t\t\tfor(int j=0;j<s;j++){\n\t\t\t\t\tfor(int k=0;k<s;k++){\n\t\t\t\t\t\tif(k!=j) f[list[i].get(k)] = true;\n\t\t\t\t\t}\n\t\t\t\t\tdfs();\n\t\t\t\t\tfor(int k=0;k<s;k++){\n\t\t\t\t\t\tf[list[i].get(k)] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint sum = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(f[i]==true) sum++;\n\t\t}\n\t\tmax = Math.max(max, sum);\n\t}\n\t\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tf = new boolean[n];\n\t\t\ta = new boolean[n][n];\n\t\t\tc = new int[n];\n\t\t\t\n\t\t\tint[][] b = new int[n][3];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<3;j++) b[i][j] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt() - 1;\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tif(Math.sqrt((b[i][0]-b[j][0])*(b[i][0]-b[j][0])+(b[i][1]-b[j][1])*(b[i][1]-b[j][1]))<b[i][2]+b[j][2]){\n\t\t\t\t\t\ta[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmax = 0;\n\t\t\tdfs();\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\npublic class Main{\n\n\tstatic int INF = 2 << 27;\n\tstatic int m;\n\tstatic int n;\n\tstatic int k;\n\tstatic int d;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tData[] data = new Data[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdata[i] = new Data(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\t\t\tboolean check = check(data,i,j);\n\t\t\t\t\tif(check) data[j].up |= (1 << i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[] dp = new boolean[1 << n];\n\t\t\tdp[0] = true;\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tif(!dp[i]) continue;\n\t\t\t\tArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tlist.add(new ArrayList<Integer>());\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tif((i & (1 << j)) != 0 || (i & data[j].up) != data[j].up) continue;\n\t\t\t\t\tlist.get(data[j].c).add(j);\n\t\t\t\t}\n\t\t\t\tfor(int j = 1; j < 5; j++) {\n\t\t\t\t\tfor(int k = 0; k < list.get(j).size()-1; k++) {\n\t\t\t\t\t\tfor(int l = k + 1; l < list.get(j).size(); l++) {\n\t\t\t\t\t\t\tArrayList<Integer> lX = list.get(j);\n\t\t\t\t\t\t\tint next = i | (1 << lX.get(k) | (1 << lX.get(l)));\n\t\t\t\t\t\t\tdp[next] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tif(dp[i]) max = Math.max(max, Integer.bitCount(i));\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t\t\n\t\t}\n\t}\n\tstatic boolean check(Data[] data, int a, int b) {\n\t\tint dis = (int)(Math.pow(data[a].x - data[b].x, 2) + Math.pow(data[a].y - data[b].y, 2));\n\t\treturn dis < Math.pow(data[a].r + data[b].r,2);\n\t}\n\tstatic class Data {\n\t\tint up = 0;\n\t\tint x;\n\t\tint y;\n\t\tint r;\n\t\tint c;\n\t\tData(int a, int b, int c, int d) {\n\t\t\tthis.x = a;\n\t\t\tthis.y = b;\n\t\t\tthis.r = c;\n\t\t\tthis.c = d;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n  class Circle {\n    byte x, y, r, c;\n\n    Circle(byte x, byte y, byte r, byte c) {\n      this.x = x;\n      this.y = y;\n      this.r = r;\n      this.c = c;\n    }\n\n    boolean intersect(Circle o) {\n      return ( (int) r + o.r ) * ( (int) r + o.r ) > ( (int) x - o.x )\n          * ( (int) x - o.x ) + ( (int) y - o.y ) * ( (int) y - o.y );\n    }\n  }\n\n  int n = 24;\n  Circle[] list = new Circle[n];\n  boolean[] done = new boolean[n];\n  byte[] memo = new byte[1 << n];\n  boolean[] fill = new boolean[1 << n];\n\n  byte dfs(int BITS) {\n    if ( fill[ BITS ] ) {\n      return memo[ BITS ];\n    }\n    byte max = 0;\n\n    for ( int i = 0; i < n; ++i ) {\n      if ( done[ i ] || !isTop( i ) )\n        continue;\n      for ( int j = i - 1; 0 <= j; --j ) {\n        if ( done[ j ] || !isTop( j ) )\n          continue;\n\n        if ( list[ i ].c == list[ j ].c ) {\n          done[ i ] = done[ j ] = true;\n          max = (byte) Math\n              .max( max, 2 + dfs( BITS | ( 1 << i ) | ( 1 << j ) ) );\n          done[ i ] = done[ j ] = false;\n        }\n      }\n    }\n\n    fill[ BITS ] = true;\n    memo[ BITS ] = max;\n    return max;\n  }\n\n  boolean isTop(int index) {\n    boolean flag = true;\n    for ( int i = index - 1; 0 <= i; --i ) {\n      flag &= done[ i ] | !list[ i ].intersect( list[ index ] );\n    }\n    return flag;\n  }\n\n  void run() {\n    for ( ;; ) {\n      n = ni();\n      if ( n == 0 ) {\n        break;\n      }\n\n      Arrays.fill( done, false );\n      Arrays.fill( fill, false );\n      for ( int i = 0; i < n; ++i ) {\n        byte x = ni();\n        byte y = ni();\n        byte r = ni();\n        byte c = ni();\n        list[ i ] = new Circle( x, y, r, c );\n        // debug(isTop(i));\n      }\n\n      System.out.println( dfs( 0 ) );\n    }\n  }\n\n  Main() {\n    sc = new Scanner( System.in );\n  }\n\n  byte ni() {\n    return (byte) sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println( Arrays.deepToString( os ) );\n  }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tC [] data;\n\tclass C{\n\t\tint x,y,r,c;\n\t\tpublic C(int x, int y, int r, int c) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\tint n,len,ans;\n\t\t//boolean [][] dp = new boolean[1 << 24][13];\n\t\tArrayList<ArrayList<Integer>> dp2 = new ArrayList<ArrayList<Integer>>();\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdata = new C[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tdata[i] = new C(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t\t}\n\t\t\tlen = 1 << n;\n\t\t\tdp2.clear();\n\t\t\tfor(int i=0; i < n / 2 + 1; i++){\n\t\t\t\tdp2.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t\tdp2.get(0).add(0);\n\t\t\tans = 0;\n\t\t\tfor(int i=0; i < n/2;i++){\n\t\t\t\tfor(int j: dp2.get(i)){\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\t\tfor(int l = k+1; l < n; l++){\n\t\t\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\t\t\tif(! issameC(k,l)) continue;\n\t\t\t\t\t\t\tif(isOVL(k,j) || isOVL(l,j)) continue;\n\t\t\t\t\t\t\tint num;\n\t\t\t\t\t\t\tnum = j | (1 << k);\n\t\t\t\t\t\t\tnum = num | (1 << l);\n\t\t\t\t\t\t\tdp2.get(i+1).add(num);\n\t\t\t\t\t\t\tans = (i+1)*2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\t//TODO debug\n//\t\t\tfor(int i= 0; i < len; i++){\n//\t\t\t\tfor(int j = 0; j < n+1; j++){\n//\t\t\t\t\tif(dp[i][j]){\n//\t\t\t\t\t\tSystem.out.print(\"1 \");\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tSystem.out.print(\"0 \");\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate boolean isOVL(int a,int num) {\n\t\tif(a == 0) return false;\n\t\tint ax = data[a].x;\n\t\tint ay = data[a].y;\n\t\tint ar= data[a].r;\n\t\tint ix,iy,ir,rr;\n\t\tdouble dis;\n\t\tfor(int i = a-1; i >= 0; i--){\n\t\t\tif(((1 << i) & num) != 0) continue;\n\t\t\tix = data[i].x;\n\t\t\tiy = data[i].y;\n\t\t\tir = data[i].r;\n\t\t\tdis = Point2D.Double.distance(ax, ay, ix, iy);\n\t\t\trr = ir + ar;\n\t\t\tif(dis < rr)return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean issameC(int a, int b) {\n\t\tif(data[a].c == data[b].c) return true;\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tfinal double EPS = 1.0e-08;\n\tC [] data;\n\tclass C{\n\t\tint x,y,r,c;\n\t\tpublic C(int x, int y, int r, int c) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\tint n,len,ans;\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdata = new C[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tdata[i] = new C(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t\t}\n\t\t\tlen = 1 << n;\n\t\t\tboolean [] dp = new boolean[len];\n\t\t\tdp[0] = true;\n\t\t\tans = 0;\n\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\tif(! dp[j]) continue;\n\t\t\t\tArrayList<Integer> checked = new ArrayList<Integer>();\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\tif(isOVL(k,j)) continue;\n\t\t\t\t\t\n\t\t\t\t\tint removeInd = -1;\n\t\t\t\t\tfor(int l = 0; l < checked.size(); l++){\n\t\t\t\t\t\tint pair = checked.get(l);\n\t\t\t\t\t\tif(! issameC(k,pair)) continue;\n\t\t\t\t\t\tint num;\n\t\t\t\t\t\tnum = j | (1 << k);\n\t\t\t\t\t\tnum = num | (1 << pair);\n\t\t\t\t\t\tdp[num] = true;\n\t\t\t\t\t\tint res = Integer.bitCount(num);\n\t\t\t\t\t\tans = Math.max(ans, res);\n\t\t\t\t\t\tremoveInd = l;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//store\n\t\t\t\t\tif(removeInd == -1){\n\t\t\t\t\t\tchecked.add(k);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tchecked.remove(removeInd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\t//TODO debug\n//\t\t\tfor(int i= 0; i < len; i++){\n//\t\t\t\tfor(int j = 0; j < n+1; j++){\n//\t\t\t\t\tif(dp[i][j]){\n//\t\t\t\t\t\tSystem.out.print(\"1 \");\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tSystem.out.print(\"0 \");\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate boolean isOVL(int a,int num) {\n\t\tif(a == 0) return false;\n\t\tint ax = data[a].x;\n\t\tint ay = data[a].y;\n\t\tint ar= data[a].r;\n\t\tint ix,iy,ir,rr;\n\t\tdouble dis;\n\t\tfor(int i = a-1; i >= 0; i--){\n\t\t\tif(((1 << i) & num) != 0) continue;\n\t\t\tix = data[i].x;\n\t\t\tiy = data[i].y;\n\t\t\tir = data[i].r;\n\t\t\tdis = Point2D.Double.distance(ax, ay, ix, iy);\n\t\t\trr = ir + ar;\n\t\t\tif(dis + EPS < rr)return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean issameC(int a, int b) {\n\t\tif(data[a].c == data[b].c) return true;\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tfinal double EPS = 1.0e-08;\n\tC [] data;\n\tclass C{\n\t\tint x,y,r,c;\n\t\tpublic C(int x, int y, int r, int c) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\tint n,len,ans;\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdata = new C[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tdata[i] = new C(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t\t}\n\t\t\tlen = 1 << n;\n\t\t\tboolean [] dp = new boolean[len];\n\t\t\tdp[0] = true;\n\t\t\tans = 0;\n\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\tif(! dp[j]) continue;\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\tfor(int l = k+1; l < n; l++){\n\t\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\t\tif(! issameC(k,l)) continue;\n\t\t\t\t\t\tif(isOVL(k,j) || isOVL(l,j)) continue;\n\t\t\t\t\t\tint num;\n\t\t\t\t\t\tnum = j | (1 << k);\n\t\t\t\t\t\tnum = num | (1 << l);\n\t\t\t\t\t\tdp[num] = true;\n\t\t\t\t\t\tint res = Integer.bitCount(num);\n\t\t\t\t\t\t//System.out.println(\"num= \" + num);\n\t\t\t\t\t\tans = Math.max(ans, res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\t//TODO debug\n//\t\t\tfor(int i= 0; i < len; i++){\n//\t\t\t\tfor(int j = 0; j < n+1; j++){\n//\t\t\t\t\tif(dp[i][j]){\n//\t\t\t\t\t\tSystem.out.print(\"1 \");\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tSystem.out.print(\"0 \");\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate boolean isOVL(int a,int num) {\n\t\tif(a == 0) return false;\n\t\tint ax = data[a].x;\n\t\tint ay = data[a].y;\n\t\tint ar= data[a].r;\n\t\tint ix,iy,ir,rr;\n\t\tdouble dis;\n\t\tfor(int i = a-1; i >= 0; i--){\n\t\t\tif(((1 << i) & num) != 0) continue;\n\t\t\tix = data[i].x;\n\t\t\tiy = data[i].y;\n\t\t\tir = data[i].r;\n\t\t\tdis = Point2D.Double.distance(ax, ay, ix, iy);\n\t\t\trr = ir + ar;\n\t\t\tif(dis + EPS < rr)return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean issameC(int a, int b) {\n\t\tif(data[a].c == data[b].c) return true;\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n  class Circle {\n    int x, y, r, c;\n\n    Circle(int x, int y, int r, int c) {\n      this.x = x;\n      this.y = y;\n      this.r = r;\n      this.c = c;\n    }\n\n    boolean intersect(Circle o) {\n      return ( r + o.r ) * ( r + o.r ) > ( x - o.x ) * ( x - o.x ) + ( y - o.y )\n          * ( y - o.y );\n    }\n  }\n\n  int n;\n  Circle[] list;\n  boolean[] done;\n\n  byte[] memo;\n  boolean[] fill;\n\n  byte dfs(int BITS) {\n    if ( fill[ BITS ] ) {\n      return memo[ BITS ];\n    }\n    byte max = 0;\n\n    for ( int i = 0; i < n; ++i ) {\n      if ( done[ i ] || !isTop( i ) )\n        continue;\n      for ( int j = i - 1; 0 <= j; --j ) {\n        if ( done[ j ] || !isTop( j ) )\n          continue;\n\n        if ( list[ i ].c == list[ j ].c ) {\n          done[ i ] = done[ j ] = true;\n          max = (byte) Math\n              .max( max, 2 + dfs( BITS | ( 1 << i ) | ( 1 << j ) ) );\n          done[ i ] = done[ j ] = false;\n        }\n      }\n    }\n\n    fill[ BITS ] = true;\n    memo[ BITS ] = max;\n    return max;\n  }\n\n  boolean isTop(int index) {\n    boolean flag = true;\n    for ( int i = index - 1; 0 <= i; --i ) {\n      flag &= done[ i ] | !list[ i ].intersect( list[ index ] );\n    }\n    return flag;\n  }\n\n  void run() {\n    for ( ;; ) {\n      n = ni();\n      if ( n == 0 ) {\n        break;\n      }\n\n      list = new Circle[n];\n      done = new boolean[n];\n      fill = new boolean[1 << n];\n      memo = new byte[1 << n];\n      for ( int i = 0; i < n; ++i ) {\n        int x = ni();\n        int y = ni();\n        int r = ni();\n        int c = ni();\n        list[ i ] = new Circle( x, y, r, c );\n        // debug(isTop(i));\n      }\n\n      System.out.println( dfs( 0 ) );\n    }\n  }\n\n  Main() {\n    sc = new Scanner( System.in );\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println( Arrays.deepToString( os ) );\n  }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tC [] data;\n\tclass C{\n\t\tint x,y,r,c;\n\t\tpublic C(int x, int y, int r, int c) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\tint n,len,ans;\n\t\t//boolean [][] dp = new boolean[1 << 24][13];\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdata = new C[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tdata[i] = new C(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t\t}\n\t\t\tlen = 1 << n;\n\t\t\tArrayList<ArrayList<Integer>> dp2 = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor(int i=0; i < n / 2 + 1; i++){\n\t\t\t\tdp2.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t\tdp2.get(0).add(0);\n\t\t\tans = 0;\n\t\t\tfor(int i=0; i < n/2;i++){\n\t\t\t\tfor(int j: dp2.get(i)){\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\t\tfor(int l = k+1; l < n; l++){\n\t\t\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\t\t\tif(! issameC(k,l)) continue;\n\t\t\t\t\t\t\tif(isOVL(k,j) || isOVL(l,j)) continue;\n\t\t\t\t\t\t\tint num;\n\t\t\t\t\t\t\tnum = j | (1 << k);\n\t\t\t\t\t\t\tnum = num | (1 << l);\n\t\t\t\t\t\t\tdp2.get(i+1).add(num);\n\t\t\t\t\t\t\tans = (i+1)*2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\t//TODO debug\n//\t\t\tfor(int i= 0; i < len; i++){\n//\t\t\t\tfor(int j = 0; j < n+1; j++){\n//\t\t\t\t\tif(dp[i][j]){\n//\t\t\t\t\t\tSystem.out.print(\"1 \");\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tSystem.out.print(\"0 \");\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate boolean isOVL(int a,int num) {\n\t\tif(a == 0) return false;\n\t\tint ax = data[a].x;\n\t\tint ay = data[a].y;\n\t\tint ar= data[a].r;\n\t\tint ix,iy,ir,rr;\n\t\tdouble dis;\n\t\tfor(int i = a-1; i >= 0; i--){\n\t\t\tif(((1 << i) & num) != 0) continue;\n\t\t\tix = data[i].x;\n\t\t\tiy = data[i].y;\n\t\t\tir = data[i].r;\n\t\t\tdis = Point2D.Double.distance(ax, ay, ix, iy);\n\t\t\trr = ir + ar;\n\t\t\tif(dis < rr)return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean issameC(int a, int b) {\n\t\tif(data[a].c == data[b].c) return true;\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint n, max;\n\tint[] c;\n\tboolean[] f;\n\tboolean[][] a;\n\t\n\t\n\tvoid dfs(){\n\t\tboolean flag;\n\t\tArrayList<Integer>[] list = new ArrayList[4];\n\t\t\n\t\twhile(true){\n\t\t\tfor(int i=0;i<4;i++) list[i] = new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tflag = false;\n\t\t\t\tif(f[i]==false){\n\t\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\t\tif(f[j]==false && a[i][j]==true) flag = true;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==false) list[c[i]].add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tflag = false;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(list[i].size()==2 || list[i].size()==4 || list[i].size()==6){\n\t\t\t\t\tfor(int j=0;j<list[i].size();j++) f[list[i].get(j)] = true;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==false) break;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint s = list[i].size();\n\t\t\tif(s==3 || s==5){\n\t\t\t\tfor(int j=0;j<s;j++){\n\t\t\t\t\tfor(int k=0;k<s;k++){\n\t\t\t\t\t\tif(k!=j) f[list[i].get(k)] = true;\n\t\t\t\t\t}\n\t\t\t\t\tdfs();\n\t\t\t\t\tfor(int k=0;k<s;k++){\n\t\t\t\t\t\tf[list[i].get(k)] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint sum = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(f[i]==true) sum++;\n\t\t}\n\t\tmax = Math.max(max, sum);\n\t}\n\t\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tf = new boolean[n];\n\t\t\ta = new boolean[n][n];\n\t\t\tc = new int[n];\n\t\t\t\n\t\t\tint[][] b = new int[n][3];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<3;j++) b[i][j] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt() - 1;\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tif(Math.sqrt((b[i][0]-b[j][0])*(b[i][0]-b[j][0])+(b[i][1]-b[j][1])*(b[i][1]-b[j][1]))<b[i][2]+b[j][2]){\n\t\t\t\t\t\ta[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmax = 0;\n\t\t\tdfs();\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int n;\n\tList<Disc> discs = new ArrayList<Disc>();\n\tSet<Disc> ups = new HashSet<Disc>();\n\tSet<Disc> used = new HashSet<Disc>();\n\tMap<Set<Disc>, Integer> memo = new HashMap<Set<Disc>, Integer>();\n\tint max = -1;\n\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\n\t\t\t// init\n\t\t\tMain m =new Main();\n\t\t\tm.dfs(0);\n\t\t\tSystem.out.println(m.max);\n\t\t}\n\t}\n\n\tMain() {\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tDisc d = new Disc(sc, i);\n\t\t\tint deep = 0;\n\t\t\tfor(Disc op : discs) {\n\t\t\t\tif( d.butsu(op) ) {\n\t\t\t\t\t//System.out.println(op);\n\t\t\t\t\tdeep = Math.max(deep, op.deep);\n\t\t\t\t}\n\t\t\t}\n\t\t\td.deep = deep+1;\n\t\t\tif(d.deep == 1) ups.add(d);\n\t\t\tdiscs.add(d);\n\t\t}\n\t}\n\n\tvoid dfs(int m) {\n\t\t// memo\n\t\tif( memo.containsKey(used) ) return;\n\n\t\t// max\n\t\tmax = Math.max(max, m);\n\n\t\t// go\n\t\tList<Disc> tmp = new ArrayList<Disc>(ups);\n\t\tfor(int i=0; i<tmp.size(); i++) {\n\t\t\tDisc d = tmp.get(i);\n\t\t\tfor(int j=i+1; j<tmp.size(); j++) {\n\t\t\t\tDisc op = tmp.get(j);\n\t\t\t\tif(d.c == op.c) {\n\t\t\t\t//\tSystem.out.println(d + \",\" + op);\n\t\t\t\t//\tSystem.out.println(discs);\n\t\t\t\t\tpush(d, op);\n\t\t\t\t//\tSystem.out.println(ups);\n\t\t\t\t\tdfs(m+2);\n\t\t\t\t\tpop(d, op);\n\t\t\t\t//\tSystem.out.println(discs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid push(Disc a, Disc b) {\n\t\tpushSub(a);\n\t\tpushSub(b);\n\t}\n\tprivate void pushSub(Disc a) {\n\t\tused.add(a);\n\t\tdiscs.remove(a);\n\t\tups.remove(a);\n\t\tups.addAll(underAll(a));\n\t}\n\n\tvoid pop(Disc a, Disc b) {\n\t\tpopSub(a);\n\t\tpopSub(b);\n\t}\n\tprivate void popSub(Disc a) {\n\t\tused.remove(a);\n\t\tdiscs.add(a);\n\t\tups.removeAll(underAll(a));\n\t\tups.add(a);\n\t}\n\n\tboolean butsuAny(Disc d) {\n\t\tfor(Disc op : discs) {\n\t\t\tif( d.butsu(op) ) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tSet<Disc> butsuAll(Disc d) {\n\t\tSet<Disc> res = new HashSet<Disc>();\n\t\tfor(Disc op : discs) {\n\t\t\tif( d.butsu(op) ) res.add(op);\n\t\t}\n\t\treturn res;\n\t}\n\n\tSet<Disc> underAll(Disc d) {\n\t\tSet<Disc> res = new HashSet<Disc>();\n\t\tfor(Disc op : discs) {\n\t\t\tif( d.butsu(op) && d.deep == op.deep-1 ) res.add(op);\n\t\t}\n\t//\tSystem.out.println(\"**\"+res);\n\t\treturn res;\n\t}\n\n}\n\n\nclass Disc {\n\tint x, y, r, c;\n\tint id;\n\tint deep;\n\n\tDisc(Scanner sc, int i) {\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\t\tr = sc.nextInt();\n\t\tc = sc.nextInt();\n\t\tid = i;\n\t}\n\n\tboolean butsu(Disc op) {\n\t\tint kyo = (x-op.x)*(x-op.x) + (y-op.y)*(y-op.y);\n\t\tint rr = (r+op.r)*(r+op.r);\n\t\treturn kyo < rr;\n\t}\n\n\tpublic String toString() {\n\t\treturn id+\":\"+deep+\",\"+c;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\npublic class Main{\n\n\tstatic int INF = 2 << 27;\n\tstatic int m;\n\tstatic int n;\n\tstatic int k;\n\tstatic int d;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tData[] data = new Data[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdata[i] = new Data(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\t\t\tboolean check = check(data,i,j);\n\t\t\t\t\tif(check) data[j].up |= (1 << i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[] dp = new boolean[1 << n];\n\t\t\tdp[0] = true;\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tif(!dp[i]) continue;\n\t\t\t\tArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tlist.add(new ArrayList<Integer>());\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tif((i & (1 << j)) != 0 || (i & data[j].up) != data[j].up) continue;\n\t\t\t\t\tlist.get(data[j].c).add(j);\n\t\t\t\t}\n\t\t\t\tfor(int j = 1; j < 5; j++) {\n\t\t\t\t\tArrayList<Integer> lX = list.get(j);\n\t\t\t\t\tint TMP = lX.size()-1;\n\t\t\t\t\tint TMPA = lX.size();\n\t\t\t\t\tfor(int k = 0; k < TMP; k++) {\n\t\t\t\t\t\tfor(int l = k + 1; l < TMPA; l++) {\n\t\t\t\t\t\t\tint next = i | (1 << lX.get(k) | (1 << lX.get(l)));\n\t\t\t\t\t\t\tdp[next] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tif(dp[i]) max = Math.max(max, Integer.bitCount(i));\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t\t\n\t\t}\n\t}\n\tstatic boolean check(Data[] data, int a, int b) {\n\t\tint dis = (int)(Math.pow(data[a].x - data[b].x, 2) + Math.pow(data[a].y - data[b].y, 2));\n\t\treturn dis < Math.pow(data[a].r + data[b].r,2);\n\t}\n\tstatic class Data {\n\t\tint up = 0;\n\t\tint x;\n\t\tint y;\n\t\tint r;\n\t\tint c;\n\t\tData(int a, int b, int c, int d) {\n\t\t\tthis.x = a;\n\t\t\tthis.y = b;\n\t\t\tthis.r = c;\n\t\t\tthis.c = d;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint n = nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[][] cir = new int[n][4];\n\t\t\tint[] above = new int[n];// 上に重なってる円盤\n\n\t\t\tint[] bitDP = new int[1 << n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = nextInt();\n\t\t\t\tint y = nextInt();\n\t\t\t\tint r = nextInt();\n\t\t\t\tint c = nextInt();\n\t\t\t\tcir[i][0] = x;\n\t\t\t\tcir[i][1] = y;\n\t\t\t\tcir[i][2] = r;\n\t\t\t\tcir[i][3] = c;\n\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\t// 重なっている円盤があるかの判定\n\t\t\t\t\tint jx = cir[j][0] - x;\n\t\t\t\t\tint jy = cir[j][1] - y;\n\t\t\t\t\tint jr = cir[j][2];\n\t\t\t\t\tdouble dist = Math.sqrt(jx * jx + jy * jy);\n\t\t\t\t\tif (dist < r + jr) {\n\t\t\t\t\t\tabove[i] += (1 << j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint max = 0;\n\t\t\tfor (int bit = 0; bit < bitDP.length; bit++) {\n\t\t\t\t// 到達しうる遷移か\n\t\t\t\tif (bit != 0 && bitDP[bit] == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t// 円iとjが取り除かれていないかチェック\n\t\t\t\t\tif ((bit & (1 << i)) != 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\t\t// 円iとjが取り除かれていないかチェック\n\t\t\t\t\t\tif ((bit & ((1 << i) + (1 << j))) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// iとjの上に載っている円が全部取り除かれている\n\t\t\t\t\t\tif ((above[i] & bit) != above[i] || (above[j] & bit) != above[j]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 色が一緒かどうか\n\t\t\t\t\t\tif (cir[i][3] == cir[j][3]) {\n\t\t\t\t\t\t\tint newbit = bit + (1 << i) + (1 << j);\n\t\t\t\t\t\t\tbitDP[newbit] = Math.max(bitDP[newbit], bitDP[bit] + 2);\n\t\t\t\t\t\t\tmax = Math.max(max, bitDP[newbit]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(max);\n\t\t\tSystem.gc();\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\tstatic int[] dp = new int[1 << 24];\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint n = ir.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\treturn;\n\t\t\tArrays.fill(dp, -1);\n\t\t\tint[][] a = new int[n][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = ir.nextIntArray(4);\n\t\t\tGraph[] g = new Graph[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tg[i] = new Graph();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (Math.sqrt((a[i][0] - a[j][0]) * (a[i][0] - a[j][0])\n\t\t\t\t\t\t\t+ (a[i][1] - a[j][1]) * (a[i][1] - a[j][1])) < (double) a[i][2] + a[j][2])\n\t\t\t\t\t\tg[i].add(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(dfs((1 << n) - 1, n, g, a));\n\t\t}\n\t}\n\n\tstatic int dfs(int m, int n, Graph[] g, int[][] a) {\n\t\tif (dp[m] >= 0)\n\t\t\treturn dp[m];\n\t\tArrayList<Integer> buf = new ArrayList<Integer>();\n\t\touter: for (int i = 0; i < n; i++) {\n\t\t\tif (((1 << i) & m) != 0) {\n\t\t\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\t\t\tif (((1 << g[i].get(j)) & m) != 0)\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t\tbuf.add(i);\n\t\t\t}\n\t\t}\n\t\tif (buf.size() < 2)\n\t\t\treturn 0;\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < buf.size(); i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (a[buf.get(i)][3] == a[buf.get(j)][3]) {\n\t\t\t\t\tret = Math.max(ret, dfs(m ^ ((1 << buf.get(i)) | (1 << buf.get(j))), n, g, a) + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[m] = ret;\n\t}\n\n\tstatic class Graph extends ArrayList<Integer> {\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static int n;\n    static ArrayList<Circle> circles;\n    static int max;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            n = sc.nextInt();\n            if (n == 0) {\n                break;\n            }\n            circles = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                int r = sc.nextInt();\n                int c = sc.nextInt();\n                circles.add(new Circle(x, y, r, c, i));\n            }\n            for (int i = 0; i < n - 1; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    Circle c1 = circles.get(i);\n                    Circle c2 = circles.get(j);\n                    if (c1.dip(c2)) {\n                        c1.children.add(c2);\n                        c2.parents.add(c1);\n                    }\n                }\n            }\n            max = Integer.MIN_VALUE;\n            dp(0);\n            System.out.println(max * 2);\n        }\n    }\n\n    static void dp(int k) {\n        max = Math.max(max, k);\n\n        ArrayList<Circle> tops = new ArrayList<>();\n        for (Circle c: circles) {\n            if (c.parents.isEmpty()) {\n                tops.add(c);\n            }\n        }\n\n        for (int i = 1; i <= 4; i++) {\n            ArrayList<Circle> items = new ArrayList<>();\n            for (Circle c: tops) {\n                if (c.c == i) {\n                    items.add(c);\n                }\n            }\n\n            if (items.size() < 2) {\n                continue;\n            }\n            // TODO: sum6 ?????????\n\n            for (int j = 0; j < items.size() - 1; j++) {\n                for (int l = j + 1; l < items.size(); l++) {\n                    Circle c1 = items.get(j);\n                    Circle c2 = items.get(l);\n                    circles.remove(c1);\n                    circles.remove(c2);\n                    for (Circle c: c1.children) {\n                        c.parents.remove(c1);\n                    }\n                    for (Circle c: c2.children) {\n                        c.parents.remove(c2);\n                    }\n                    dp(k + 1);\n                    circles.add(c1);\n                    circles.add(c2);\n                    for (Circle c: c1.children) {\n                        c.parents.add(c1);\n                    }\n                    for (Circle c: c2.children) {\n                        c.parents.add(c2);\n                    }\n                }\n            }\n        }\n    }\n\n    static class Circle {\n        int x, y, r, c, id;\n        ArrayList<Circle> parents;\n        ArrayList<Circle> children;\n        Circle (int x, int y, int r, int c, int id) {\n            this.x = x;\n            this.y = y;\n            this.r = r;\n            this.c = c;\n            this.id = id;\n            parents = new ArrayList<>();\n            children = new ArrayList<>();\n        }\n\n        public boolean dip(Circle c) {\n            return Math.pow(this.r + c.r, 2) > Math.pow(this.x - c.x, 2) + Math.pow(this.y - c.y, 2);\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n@SuppressWarnings(\"unchecked\")\npublic class Main {\n\tint n, max;\n\tint[] c;\n\tboolean[] f;\n\tboolean[][] a;\n\tLinkedList<Integer>[] rem;\n\t\n\t\n\tvoid remadd(){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(f[j]==true) continue;\n\t\t\t\tif(c[j]==i && rem[i].contains(j)==false){\n\t\t\t\t\tboolean flag = false;\n\t\t\t\t\tfor(int k=j-1;k>=0;k--){\n\t\t\t\t\t\tif(f[k]==false && a[j][k]==true){\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==false) rem[i].add(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n\t\n\t\n\tvoid dfs(){\n\t\tboolean flag;\n\t\twhile(true){\n\t\t\tflag = false;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(rem[i].size()==2 || rem[i].size()==4 || rem[i].size()==6){\n\t\t\t\t\tflag = true;\n\t\t\t\t\twhile(rem[i].size()!=0) f[rem[i].pop()] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tremadd();\n\t\t\tif(flag==false) break;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(rem[i].size()==3 || rem[i].size()==5){\n\t\t\t\tfor(int j=0;j<rem[i].size();j++){\n\t\t\t\t\tLinkedList<Integer> tmp = new LinkedList<Integer>();\n\t\t\t\t\tint t = rem[i].get(j);\n\t\t\t\t\tfor(int k=0;k<rem[i].size();k++){\n\t\t\t\t\t\tif(k!=j){\n\t\t\t\t\t\t\ttmp.add(rem[i].get(k));\n\t\t\t\t\t\t\tf[rem[i].get(k)] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trem[i].clear();\n\t\t\t\t\trem[i].add(t);\n\t\t\t\t\tdfs();\n\t\t\t\t\tfor(int k=0;k<tmp.size();k++){\n\t\t\t\t\t\trem[i].add(tmp.get(k));\n\t\t\t\t\t\tf[tmp.get(k)] = false;\n\t\t\t\t\t}\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(flag==false){\n\t\t\tint cnt = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(f[i]==true) cnt++;\n\t\t\t}\n\t\t\tmax = Math.max(max, cnt);\n\t\t}\n\t}\n\t\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tf = new boolean[n];\n\t\t\ta = new boolean[n][n];\n\t\t\tc = new int[n];\n\t\t\trem = new LinkedList[4];\n\t\t\tfor(int i=0;i<4;i++) rem[i] = new LinkedList<Integer>();\n\t\t\t\n\t\t\tint[][] b = new int[n][3];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<3;j++) b[i][j] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt() - 1;\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tif(Math.sqrt((b[i][0]-b[j][0])*(b[i][0]-b[j][0])+(b[i][1]-b[j][1])*(b[i][1]-b[j][1]))<b[i][2]+b[j][2]){\n\t\t\t\t\t\ta[i][j] = true; //jがiの上にのってる\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tremadd();\n\t\t\t\n\t\t\tmax = 0;\n\t\t\tdfs();\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n  Scanner sc;\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Disk {\n    LinkedList<Disk> parents = new LinkedList<>();\n    LinkedList<Disk> children = new LinkedList<>();\n    int x;\n    int y;\n    int i;\n    int c;\n    int r;\n\n    boolean isIn(Disk disk) {\n      return Math.pow(this.r + disk.r, 2) > Math.pow(this.x - disk.x, 2) + Math.pow(this.y - disk.y, 2);\n    }\n\n    public String toString() {\n      return \"\" + i;\n    }\n  }\n\n  int dfs(ArrayList<Disk> list) {\n    HashMap<Integer, ArrayList<Disk>> map = new HashMap<>();\n    for (Disk d : list) {\n      if (d.parents.size() == 0) {\n        if (!map.containsKey(d.c)) {\n          map.put(d.c, new ArrayList<>());\n        }\n        map.get(d.c).add(d);\n      }\n    }\n    int cnt = 0;\n    for (int color : map.keySet()) {\n      int subcnt = 0;\n      int subsubcnt = map.get(color).size() / 2;\n      if (map.get(color).size() < 2) {\n        continue;\n      }\n      if (map.get(color).size() % 2 == 1) {\n        ArrayList<Disk> arr = map.get(color);\n\n        for (ListIterator<Disk> ite = arr.listIterator(); ite.hasNext(); ) {\n          Disk atom = ite.next();\n          ite.remove();\n          ArrayList<Disk> del = new ArrayList<>();\n          for (ListIterator<Disk> jte = arr.listIterator(); jte.hasNext(); ) {\n            Disk d = jte.next();\n            Disk e = jte.next();\n            d.children.forEach(c -> c.parents.remove(d));\n            e.children.forEach(c -> c.parents.remove(e));\n            list.remove(d);\n            list.remove(e);\n            del.add(d);\n            del.add(e);\n          }\n          debug(\"\\t\", list, \",,,\", map.get(color), \", \", map.get(color).size());\n          subcnt = Math.max(subcnt, dfs(list));\n          for (Disk v : del) {\n            v.children.forEach(c -> c.parents.add(v));\n            list.add(v);\n          }\n          ite.add(atom);\n        }\n      } else {\n        ArrayList<Disk> arr = map.get(color);\n        ArrayList<Disk> del = new ArrayList<>();\n        for (ListIterator<Disk> ite = arr.listIterator(); ite.hasNext(); ) {\n          Disk d = ite.next();\n          Disk e = ite.next();\n          d.children.forEach(c -> c.parents.remove(d));\n          e.children.forEach(c -> c.parents.remove(e));\n          list.remove(d);\n          list.remove(e);\n          del.add(d);\n          del.add(e);\n        }\n        subcnt = dfs(list);\n        for (Disk v : del) {\n          v.children.forEach(c -> c.parents.add(v));\n          list.add(v);\n        }\n      }\n      cnt += subcnt;\n      cnt += subsubcnt;\n    }\n\n    return cnt;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      ArrayList<Disk> list = new ArrayList<>();\n      for (int i = 0; i < n; ++i) {\n        Disk d = new Disk();\n        d.x = ni();\n        d.y = ni();\n        d.i = i;\n        d.r = ni();\n        d.c = ni();\n\n        for (int j = 0; j < i; ++j) {\n          Disk e = list.get(j);\n          if (e.isIn(d)) {\n            e.children.add(d);\n            d.parents.add(e);\n          }\n        }\n        list.add(d);\n      }\n\n      System.out.println(dfs(list) * 2);\n    }\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tnew AOJ1175().doIt(n);\n\t\t}\n\t}\n\n\n\tclass AOJ1175{\n\t\tint cnt[];\n\t\tint dfs(long bit,int num){\n\t\t\tif(map.containsKey(bit))return map.get(bit);\n//\t\t\tSystem.out.println(Long.toBinaryString(bit));\n\t\t\tint result = num;\n\t\t\tArrays.fill(cnt,0);\n\t\t\tfor(int i=0;i<n;i++)for(int s=i-1;s>=0;s--)if((bit>>i)%2==1&&(bit>>s)%2==1){\n\t\t\t\tif(Point2D.distance(data[i].x, data[i].y, data[s].x, data[s].y)<data[s].r+data[i].r)cnt[i]++;\n\t\t\t}\n//\t\t\tSystem.out.println(Arrays.toString(cnt));\n\t\t\tfor(int c=1;c<=4;c++){//color\n\t\t\t\tfor(int i=0;i<n;i++)for(int s=i+1;s<n;s++)if(data[i].color==c&&data[s].color==c&&cnt[i]==0&&cnt[s]==0){\n\t\t\t\t\tif(i==s||((bit>>i)%2==0)||((bit>>s)%2==0))continue;\n\t\t\t\t\tbit -= 1 << i;\n\t\t\t\t\tbit -= 1 << s;\n//\t\t\t\t\tSystem.out.println(i+\" \"+s);\n\t\t\t\t\tresult = Math.max(result, dfs(bit,num+2));\n\t\t\t\t\tbit += 1 << i;\n\t\t\t\t\tbit += 1 << s;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(result == num)return num;\n\t\t\tmap.put(bit, result);\n\t\t\treturn result; \n\t\t}\n\t\tHashMap<Long,Integer> map;\n\t\tint n;\n\t\tData data[];\n\t\tvoid doIt(int n){//<=24\n\t\t\tcnt = new int[n];\n\t\t\tthis.n = n;\n\t\t\tmap = new HashMap<Long, Integer>();\n\t\t\tdata = new Data[n];\n\t\t\tfor(int i=0;i<n;i++)data[i] = new Data(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\tlong bit=0;\n\t\t\tfor(int i=0;i<n;i++)bit += 1 << i;\n\t\t\tint result = dfs(bit,0);\n\t\t\tSystem.out.println(result);\n\t\t}\n\n\t\tclass Data{\n\t\t\tint x,y,color,r;\n\t\t\tpublic Data(int x,int y,int r,int color) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.r = r;\n\t\t\t\tthis.color = color;\n\t\t\t}\n\t\t}\n\t}\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int n;\n\tstatic int[] x;\n\tstatic int[] y;\n\tstatic int[] r;\n\tstatic int[] c;\n\tstatic boolean[][] cover;\n\tstatic byte[] dp;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx = new int[n];\n\t\t\ty = new int[n];\n\t\t\tr = new int[n];\n\t\t\tc = new int[n];\n\t\t\tcover = new boolean[n][n];\n\t\t\tdp = new byte[(1<<n)];\n\t\t\tArrays.fill(dp, (byte)-1);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t\tr[i] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt()-1;\n\t\t\t\tfor(int j=0;j<i;j++) {\n\t\t\t\t\tint dx = x[j] - x[i];\n\t\t\t\t\tint dy = y[j] - y[i];\n\t\t\t\t\tint rs = r[i] + r[j];\n\t\t\t\t\tif (dx*dx+dy*dy<rs*rs) {\n\t\t\t\t\t\tcover[j][i] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dfs(0));\n\t\t}\n\t}\n\n\tpublic static int dfs(int used) {\n\t\tif (dp[used]!=-1) {\n\t\t\treturn dp[used];\n\t\t}\n\t\tint[][] canuse = new int[4][6];\n\t\tint[] canusenum = new int[4];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (((1<<i)&used) == 0) {\n\t\t\t\tboolean flag = true;\n\t\t\t\tfor(int j=0;j<i;j++) {\n\t\t\t\t\tif (((1<<j)&used) == 0 && cover[j][i]) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tcanuse[c[i]][canusenum[c[i]]++] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tboolean flag = false;\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tif (canusenum[i] >= 2) {\n\t\t\t\tfor(int j=0;j<canusenum[i]-1;j++) {\n\t\t\t\t\tfor(int k=j+1;k<canusenum[i];k++) {\n\t\t\t\t\t\tint usednext = used | (1<<canuse[i][j]) | (1<<canuse[i][k]);\n\t\t\t\t\t\tret = Math.max(ret, dfs(usednext));\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret = flag ? ret + 2 : 0;\n\t\tdp[used] = (byte) ret;\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tfinal int MOD = 1000000007;\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tint n;\n\tint[] x, y, r, c;\n\tint[] memo;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) return;\n\t\t\tx = new int[n];\n\t\t\ty = new int[n];\n\t\t\tr = new int[n];\n\t\t\tc = new int[n];\n\t\t\tmemo = new int[1 << n];\n\t\t\tArrays.fill(memo, -1);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t\tr[i] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\t// ????????????????????????????????????????±???????\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tL: for (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (c[i] != c[j])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int k = j - 1; k >= 0; k--) {\n\t\t\t\t\t\tint pDis_j = (x[k] - x[j]) * (x[k] - x[j])\n\t\t\t\t\t\t\t\t+ (y[k] - y[j]) * (y[k] - y[j]);\n\t\t\t\t\t\tint rDis_j = (r[k] + r[j]) * (r[k] + r[j]);\n\t\t\t\t\t\tint pDis_i = (x[k] - x[i]) * (x[k] - x[i])\n\t\t\t\t\t\t\t\t+ (y[k] - y[i]) * (y[k] - y[i]);\n\t\t\t\t\t\tint rDis_i = (r[k] + r[i]) * (r[k] + r[i]);\n\t\t\t\t\t\t// k?????????????????£??????????????§????????????\n\t\t\t\t\t\tif (pDis_j < rDis_j)\n\t\t\t\t\t\t\tcontinue L;\n\t\t\t\t\t\tif (k < i && pDis_i < rDis_i)\n\t\t\t\t\t\t\tcontinue L;\n\t\t\t\t\t}\n\t\t\t\t\tmax = Math.max(max, 2 + bitDP(i, 1 << i | 1 << j));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tint bitDP(int v, int mask) {\n\t\tif (memo[mask] != -1) return memo[mask];\n\n\t\t// ?¬????i???????????????(???????????\\?????????????????????)\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tL: for (int j = i + 1; j < n; j++) {\n\t\t\t\t// ??¢???i or j????????£?????????\n\t\t\t\tif ((mask & (1 << i)) != 0 || (mask & (1 << j)) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int k = j - 1; k >= 0; k--) {\n\t\t\t\t\t// ??¢???k???????????????????????????\n\t\t\t\t\tif ((mask & k) == 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint pDis_j = (x[k] - x[j]) * (x[k] - x[j]) + (y[k] - y[j]) * (y[k] - y[j]);\n\t\t\t\t\tint rDis_j = (r[k] + r[j]) * (r[k] + r[j]);\n\t\t\t\t\tint pDis_i = (x[k] - x[i]) * (x[k] - x[i]) + (y[k] - y[i]) * (y[k] - y[i]);\n\t\t\t\t\tint rDis_i = (r[k] + r[i]) * (r[k] + r[i]);\n\n\t\t\t\t\t// k?????????????????£??????????????§????????????\n\t\t\t\t\tif (pDis_j < rDis_j)\n\t\t\t\t\t\tcontinue L;\n\t\t\t\t\tif (k < i && pDis_i < rDis_i)\n\t\t\t\t\t\tcontinue L;\n\t\t\t\t}\n\t\t\t\tres = Math.max(res, 2 + bitDP(i, mask | (1 << i | 1 << j)));\n\t\t\t}\n\t\t}\n\t\treturn memo[mask] = res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(long[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (a[i] >= border)\n\tint lower_bound(int a[], int border) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (border <= a[mid]) {\n\t\t\t\tr = mid;\n\t\t\t} else {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint n;\n\tbyte[] mem;\n\tCoin[] coins;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tcoins = new Coin[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tcoins[i] = new Coin(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\t}\n\t\t\tmem = new byte[(1<<n)];\n\t\t\tfill(mem, (byte)-1);\n\t\t\tSystem.out.println(solve((1<<n)-1));\n\t\t}\n\t}\n\t\n\tbyte solve( int S ) {\n\t\tif( mem[S]>=0 ) return mem[S];\n\t\tbyte cnt = 0;\n\t\tboolean[] rap = new boolean[n];\n\t\t\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif( ((S>>i) & 1) == 0 ) {\n\t\t\t\trap[i] = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif( ((S>>j) & 1) == 0 ) continue;\n\t\t\t\trap[j] = coins[i].israpped(coins[j]); \n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(rap[i]) continue;\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif(rap[j])continue;\n\t\t\t\tif( coins[i].c == coins[j].c ) {\n\t\t\t\t\tcnt = (byte) max(cnt, solve( S - (1<<i) - (1<<j) ) + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn mem[S] = cnt;\n\t}\n\t\n\t\n\t\n\tclass Coin {\n\t\tint x, y, r, c;\n\t\tCoin (int x, int y, int r, int c) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t}\n\t\t\n\t\tboolean israpped(Coin c) {\n\t\t\treturn (c.x-x) * (c.x-x) + (c.y-y) * (c.y-y) < (r+c.r) * (r+c.r);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tnew Main().start();\n\t}\n\tArrayList<Circle> topCircles = new ArrayList<Circle>();\n\tvoid start(){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tCircle[] circles = new Circle[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tCircle c = new Circle(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\t\tcircles[n-1-i] = c;\n\t\t\t}\n\t\t\tfor(int i = 0; i < circles.length; i++){\n\t\t\t\tCircle c = circles[i];\n\t\t\t\tArrayList<Circle> removalCircles = new ArrayList<Circle>();\n\t\t\t\tfor(int j = i-1; j >= 0; j--){\n\t\t\t\t\tCircle topCircle = circles[j];\n\t\t\t\t\tif(topCircle.putC(c)) removalCircles.add(topCircle);\n\t\t\t\t}\n\t\t\t\tc.level += 1;\n\t\t\t\tfor(Circle cc : removalCircles){\n\t\t\t\t\ttopCircles.remove(cc);\n\t\t\t\t}\n\t\t\t\ttopCircles.add(c);\n\t\t\t}\n//\t\t\tfor(Circle c : circles){\n//\t\t\t\tSystem.out.println(c);\n//\t\t\t}\n\t\t\tint count = 0;\n\t\t\tboolean isChanged = false;\n\t\t\tdo{\n\t\t\t\tisChanged = false;\n\n\t\t\t\tfor(int i = 0; i < topCircles.size()-1; i++){\n\t\t\t\t\tCircle c1 = topCircles.get(i);\n\t\t\t\t\tfor(int j = i+1; j < topCircles.size(); j++){\n\t\t\t\t\t\tCircle c2 = topCircles.get(j);\n\t\t\t\t\t\tif(c1.c == c2.c){\n\t\t\t\t\t\t\tc1.remove();\n\t\t\t\t\t\t\tc2.remove();\n\t\t\t\t\t\t\tisChanged = true;\n\t\t\t\t\t\t\tcount += 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}while(isChanged);\n\t\t\tSystem.out.println(count);\n\t\t}\n\t\tin.close();\n\t}\n\tclass Circle{\n\t\tint x, y, r, c;\n\t\tArrayList<Circle> clist;\n\t\tArrayList<Circle> aboveList;\n\t\tint level = 0;\n\t\tCircle(int x, int y, int r, int c){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t\tclist = new ArrayList<Circle>();\n\t\t\taboveList = new ArrayList<Circle>();\n\t\t}\n\t\tboolean putC(Circle c){\n\t\t\tif((x-c.x)*(x-c.x) + (y-c.y)*(y-c.y) < (r+c.r)*(r+c.r)){\n\t\t\t\tif(level >= c.level){\n\t\t\t\t\tc.clist.add(this);\n\t\t\t\t\tthis.aboveList.add(c);\n\t\t\t\t\tc.level = level;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tvoid remove(){\n\t\t\ttopCircles.remove(this);\n\t\t\tfor(Circle c : clist){\n\t\t\t\tc.aboveList.remove(this);\n\t\t\t\tif(c.clist.isEmpty()){\n\t\t\t\t\ttopCircles.add(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String toString(){\n\t\t\tString s = \"(\" + x +\",\" + y + \")\" + r +\":\" + c + \",\" + level + \"\\n\";\n\t\t\ts += \"below\\n\";\n\t\t\tfor(Circle c : clist){\n\t\t\t\ts += \"\\t\" + \"(\" + c.x +\",\" + c.y + \")\" + c.r +\":\" + c.c + \",\" + c.level + \"\\n\";;\n\t\t\t}\n\t\t\ts+= \"above\\n\";\n\t\t\tfor(Circle c : aboveList){\n\t\t\t\ts += \"\\t\" + \"(\" + c.x +\",\" + c.y + \")\" + c.r +\":\" + c.c + \",\" + c.level + \"\\n\";;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint n = nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[][] cir = new int[n][4];\n\t\t\tint[] above = new int[n];// テ、ツクツ甘」ツ?ォテゥツ?催」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツつ凝・ツ??ァツ崢、\n\n\t\t\tint[] bitDP = new int[1 << n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = nextInt();\n\t\t\t\tint y = nextInt();\n\t\t\t\tint r = nextInt();\n\t\t\t\tint c = nextInt();\n\t\t\t\tcir[i][0] = x;\n\t\t\t\tcir[i][1] = y;\n\t\t\t\tcir[i][2] = r;\n\t\t\t\tcir[i][3] = c;\n\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\t// テゥツ?催」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝・ツ??ァツ崢、テ」ツ?古」ツ?づ」ツつ凝」ツ?凝」ツ?ョテ・ツ按、テ・ツョツ?\n\t\t\t\t\tint jx = cir[j][0] - x;\n\t\t\t\t\tint jy = cir[j][1] - y;\n\t\t\t\t\tint jr = cir[j][2];\n\t\t\t\t\tdouble dist = Math.sqrt(jx * jx + jy * jy);\n\t\t\t\t\tif (dist < r + jr) {\n\t\t\t\t\t\tabove[i] += (1 << j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint max = 0;\n\t\t\tfor (int bit = 0; bit < bitDP.length; bit++) {\n\t\t\t\t// テ・ツ按ーテゥツ?氾」ツ?療」ツ??」ツつ凝ゥツ?キテァツァツサテ」ツ??\n\t\t\t\tif (bit != 0 && bitDP[bit] == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t// テ・ツ??テ」ツ?ィjテ」ツ?古・ツ渉姪」ツつ甘ゥツ卍、テ」ツ?凝」ツつ古」ツ?ヲテ」ツ??」ツ?ェテ」ツ??」ツ?凝」ツδ?」ツつァテ」ツδε」ツつッ\n\t\t\t\t\tif ((bit & (1 << i)) != 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\t\t// テ・ツ??テ」ツ?ィjテ」ツ?古・ツ渉姪」ツつ甘ゥツ卍、テ」ツ?凝」ツつ古」ツ?ヲテ」ツ??」ツ?ェテ」ツ??」ツ?凝」ツδ?」ツつァテ」ツδε」ツつッ\n\t\t\t\t\t\tif ((bit & ((1 << i) + (1 << j))) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// iテ」ツ?ィjテ」ツ?ョテ、ツクツ甘」ツ?ォティツシツ嘉」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝・ツ??」ツ?古・ツ?ィテゥツδィテ・ツ渉姪」ツつ甘ゥツ卍、テ」ツ?凝」ツつ古」ツ?ヲテ」ツ??」ツつ?\n\t\t\t\t\t\tif ((above[i] & bit) != above[i] || (above[j] & bit) != above[j]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// ティツ可イテ」ツ?古、ツクツ?ァツキツ津」ツ?凝」ツ?ゥテ」ツ??」ツ??\n\t\t\t\t\t\tif (cir[i][3] == cir[j][3]) {\n\t\t\t\t\t\t\tint newbit = bit + (1 << i) + (1 << j);\n\t\t\t\t\t\t\tbitDP[newbit] = Math.max(bitDP[newbit], bitDP[bit] + 2);\n\t\t\t\t\t\t\tmax = Math.max(max, bitDP[newbit]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(max);\n\t\t\tSystem.gc();\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n  Scanner sc;\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Disk {\n    byte x;\n    byte y;\n    byte c;\n    byte r;\n\n    boolean isIn(Disk disk) {\n      return (this.r + disk.r) * (this.r + disk.r) > (this.x - disk.x) * (this.x - disk.x) + (this.y - disk.y) * (this.y - disk.y);\n    }\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      Disk[] list = new Disk[n];\n      for (int i = 0; i < n; ++i) {\n        Disk d = new Disk();\n        d.x = (byte) ni();\n        d.y = (byte) ni();\n        d.r = (byte) ni();\n        d.c = (byte) ni();\n        list[i] = d;\n      }\n\n      byte[] dp = new byte[1 << n];\n      Arrays.fill(dp, (byte) -1);\n      dp[0] = 0;\n      for (int i = 0; i < 1 << n; ++i) {\n        if (dp[i] < 0) {\n          continue;\n        }\n        for (int j = 0; j < n; ++j) {\n          if (((i >> j) & 1) == 1) {\n            continue;\n          }\n          boolean flag = true;\n          for (int a = 0; a < j; ++a) {\n            if (((i >> a) & 1) == 1) {\n              continue;\n            }\n            flag &= !list[j].isIn(list[a]);\n          }\n          if (!flag) {\n            continue;\n          }\n          for (int k = j + 1; k < n; ++k) {\n            if (((i >> k) & 1) == 1) {\n              continue;\n            }\n            boolean glag = true;\n            for (int a = 0; a < k; ++a) {\n              if (((i >> a) & 1) == 1) {\n                continue;\n              }\n              glag &= !list[k].isIn(list[a]);\n            }\n            if (!glag) {\n              continue;\n            }\n            if (list[j].c != list[k].c) {\n              continue;\n            }\n\n//            debug(j, k);\n\n            dp[i | (1 << j) | (1 << k)] = (byte) Math.max(dp[i] + 1, dp[i | (1 << j) | (1 << k)]);\n          }\n        }\n      }\n      int max = 0;\n      for (int i = 0; i < 1 << n; ++i) {\n        max = Math.max(max, dp[i]);\n      }\n\n      System.out.println(max * 2);\n    }\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n  Scanner sc;\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Disk {\n    int x;\n    int y;\n    int c;\n    int r;\n\n    boolean isIn(Disk disk) {\n      return Math.pow(this.r + disk.r, 2) > Math.pow(this.x - disk.x, 2) + Math.pow(this.y - disk.y, 2);\n    }\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      Disk[] list = new Disk[n];\n      for (int i = 0; i < n; ++i) {\n        Disk d = new Disk();\n        d.x = ni();\n        d.y = ni();\n        d.r = ni();\n        d.c = ni();\n        list[i] = d;\n      }\n\n      int[] dp = new int[1 << n];\n      boolean[] done = new boolean[1 << n];\n      done[0] = true;\n      for (int i = 0; i < 1 << n; ++i) {\n        if (!done[i]) {\n          continue;\n        }\n        for (int j = 0; j < n; ++j) {\n          if (((i >> j) & 1) == 1) {\n            continue;\n          }\n          boolean flag = true;\n          for (int a = 0; a < j; ++a) {\n            if (((i >> a) & 1) == 1) {\n              continue;\n            }\n            flag &= !list[j].isIn(list[a]);\n          }\n          if (!flag) {\n            continue;\n          }\n          for (int k = j + 1; k < n; ++k) {\n            if (((i >> k) & 1) == 1) {\n              continue;\n            }\n            boolean glag = true;\n            for (int a = 0; a < k; ++a) {\n              if (((i >> a) & 1) == 1) {\n                continue;\n              }\n              glag &= !list[k].isIn(list[a]);\n            }\n            if (!glag) {\n              continue;\n            }\n            if (list[j].c != list[k].c) {\n              continue;\n            }\n\n//            debug(j, k);\n\n            dp[i | (1 << j) | (1 << k)] = Math.max(dp[i] + 1, dp[i | (1 << j) | (1 << k)]);\n            done[i | (1 << j) | (1 << k)] |= true;\n          }\n        }\n      }\n      int max = 0;\n      for (int i = 0; i < 1 << n; ++i) {\n        max = Math.max(max, dp[i]);\n      }\n\n      System.out.println(max * 2);\n    }\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n \npublic class Main {\n    Scanner in = new Scanner(System.in);\n    public static void main(String[] args) {\n        new Main();\n    }\n \n    public Main() {\n        AOJ1175 obj = new AOJ1175();\n        while(true){\n            int n = in.nextInt();\n            if(n==0)break;\n            obj.doIt(n);\n        }\n    }\n \n    class AOJ1175{\n        boolean[] memo = new boolean[(1<<24)];\n        void doIt(int n){\n            Arrays.fill(memo,false);\n            Data[] data = new Data[n];\n            for(int i=0;i<n;i++)data[i] = new Data(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n            long bit = 0;\n            for(int i=0;i<n;i++)bit += 1 << i;\n            LinkedList<State> q = new LinkedList<State>();\n            q.add(new State(bit, 0));\n            int cnt[] = new int[n];\n            int result = -1;\n            while(q.size()>0){\n                State now = q.remove();\n                bit = now.bit;\n                result = Math.max(result, now.num);\n                Arrays.fill(cnt,0);\n                for(int i=0;i<n;i++)for(int s=i-1;s>=0;s--)if((bit>>i)%2==1&&(bit>>s)%2==1){\n                    if(Point2D.distance(data[i].x, data[i].y, data[s].x, data[s].y)<data[s].r+data[i].r)cnt[i]++;\n                }\n                for(int i=0;i<n;i++)for(int s=i+1;s<n;s++)if(data[i].color==data[s].color&&cnt[i]==0&&cnt[s]==0){\n                    if(i==s||((bit>>i)%2==0)||((bit>>s)%2==0))continue;\n                    long bit2 = bit-(1<<i)-(1<<s);\n                    if(memo[(int)bit2])continue;\n                    q.add(new State(bit2,now.num+2));\n                }\n                memo[(int)bit] = true;\n            }\n            System.out.println(result);\n        }\n \n        class State{\n            long bit;\n            int num;\n            public State(long bit,int num){\n                this.bit = bit;\n                this.num = num;\n            }\n        }\n \n        class Data{\n            int x,y,color,r;\n            public Data(int x,int y,int r,int color) {\n                this.x = x;\n                this.y = y;\n                this.r = r;\n                this.color = color;\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\npublic class Main{\n\n\tstatic int INF = 2 << 27;\n\tstatic int m;\n\tstatic int n;\n\tstatic int k;\n\tstatic int d;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tData[] data = new Data[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdata[i] = new Data(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\t\t\tboolean check = check(data,i,j);\n\t\t\t\t\tif(check) data[j].up |= (1 << i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[] dp = new boolean[1 << n];\n\t\t\tdp[0] = true;\n\t\t\t\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tif(!dp[i]) continue;\n\t\t\t\tArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tlist.add(new ArrayList<Integer>());\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tif((i & (1 << j)) != 0) continue;\n\t\t\t\t\tif((i & data[j].up) != data[j].up) continue;\n\t\t\t\t\tlist.get(data[j].c).add(j);\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tif(list.get(j).size() < 2) continue;\n\t\t\t\t\tint next = i;\n\t\t\t\t\tfor(int k = 0; k < list.get(j).size(); k++) {\n\t\t\t\t\t\tnext |= (1 << list.get(j).get(k));\n\t\t\t\t\t}\n\t\t\t\t\tdp[next] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tif(dp[i]) max = Math.max(max, Integer.bitCount(i));\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t\t\n\t\t}\n\t}\n\tstatic boolean check(Data[] data, int a, int b) {\n\t\tdouble dis = Math.sqrt(Math.pow(data[a].x - data[b].x, 2) + Math.pow(data[a].y - data[b].y, 2));\n\t\treturn dis < data[a].r + data[b].r;\n\t}\n\tstatic class Data {\n\t\tint up = 0;\n\t\tint x;\n\t\tint y;\n\t\tint r;\n\t\tint c;\n\t\tData(int a, int b, int c, int d) {\n\t\t\tthis.x = a;\n\t\t\tthis.y = b;\n\t\t\tthis.r = c;\n\t\t\tthis.c = d;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tfinal double EPS = 1.0e-08;\n\tC [] data;\n\tclass C{\n\t\tint x,y,r,c;\n\t\tpublic C(int x, int y, int r, int c) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\tint n,len,ans;\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdata = new C[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tdata[i] = new C(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t\t}\n\t\t\tlen = 1 << n;\n\t\t\tboolean [] dp = new boolean[len];\n\t\t\tdp[0] = true;\n\t\t\tans = 0;\n\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\tif(! dp[j]) continue;\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\tif(isOVL(k,j)) continue;\n\t\t\t\t\tfor(int l = k+1; l < n; l++){\n\t\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\t\tif(! issameC(k,l)) continue;\n\t\t\t\t\t\tif(isOVL(l,j)) continue;\n\t\t\t\t\t\tint num;\n\t\t\t\t\t\tnum = j | (1 << k);\n\t\t\t\t\t\tnum = num | (1 << l);\n\t\t\t\t\t\tdp[num] = true;\n\t\t\t\t\t\tint res = Integer.bitCount(num);\n\t\t\t\t\t\t//System.out.println(\"num= \" + num);\n\t\t\t\t\t\tans = Math.max(ans, res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\t//TODO debug\n//\t\t\tfor(int i= 0; i < len; i++){\n//\t\t\t\tfor(int j = 0; j < n+1; j++){\n//\t\t\t\t\tif(dp[i][j]){\n//\t\t\t\t\t\tSystem.out.print(\"1 \");\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tSystem.out.print(\"0 \");\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate boolean isOVL(int a,int num) {\n\t\tif(a == 0) return false;\n\t\tint ax = data[a].x;\n\t\tint ay = data[a].y;\n\t\tint ar= data[a].r;\n\t\tint ix,iy,ir,rr;\n\t\tdouble dis;\n\t\tfor(int i = a-1; i >= 0; i--){\n\t\t\tif(((1 << i) & num) != 0) continue;\n\t\t\tix = data[i].x;\n\t\t\tiy = data[i].y;\n\t\t\tir = data[i].r;\n\t\t\tdis = Point2D.Double.distance(ax, ay, ix, iy);\n\t\t\trr = ir + ar;\n\t\t\tif(dis + EPS < rr)return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean issameC(int a, int b) {\n\t\tif(data[a].c == data[b].c) return true;\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n  class Circle {\n    int x, y, r, c;\n\n    Circle(int x, int y, int r, int c) {\n      this.x = x;\n      this.y = y;\n      this.r = r;\n      this.c = c;\n    }\n\n    boolean intersect(Circle o) {\n      return ( r + o.r ) * ( r + o.r ) > ( x - o.x ) * ( x - o.x ) + ( y - o.y )\n          * ( y - o.y );\n    }\n  }\n\n  int n;\n  Circle[] list;\n  boolean[] done;\n\n  int dfs() {\n    int max = 0;\n\n    for ( int i = 0; i < n; ++i ) {\n      if ( done[ i ] || !isTop(i) )\n        continue;\n      for ( int j = i - 1; 0 <= j; --j ) {\n        if ( done[ j ] || !isTop(j) )\n          continue;\n\n        if ( list[i].c == list[j].c ) {\n          done[ i ] = done[ j ] = true;\n          max = Math.max( max, 2 + dfs() );\n          done[ i ] = done[ j ] = false;\n        }\n      }\n    }\n\n    return max;\n  }\n  \n  boolean isTop(int index) {\n    boolean flag = true;\n    for(int i = index - 1; 0 <= i; --i) {\n      flag &= done[i] | !list[i].intersect( list[index] );\n    }\n    return flag;\n  }\n\n  void run() {\n    for ( ;; ) {\n      n = ni();\n      if ( n == 0 ) {\n        break;\n      }\n\n      list = new Circle[n];\n      done = new boolean[n];\n      for ( int i = 0; i < n; ++i ) {\n        int x = ni();\n        int y = ni();\n        int r = ni();\n        int c = ni();\n        list[ i ] = new Circle( x, y, r, c );\n//        debug(isTop(i));\n      }\n      \n      System.out.println( dfs() );\n    }\n  }\n\n  Main() {\n    sc = new Scanner( System.in );\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println( Arrays.deepToString( os ) );\n  }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint n;\n\tint[] x, y, r, c;\n\tbyte[] memo;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) return;\n\t\t\tx = new int[n];\n\t\t\ty = new int[n];\n\t\t\tr = new int[n];\n\t\t\tc = new int[n];\n\t\t\tmemo = new byte[1 << n];\n\t\t\tfor (int i = 0; i < 1 << n; i++) memo[i] = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t\tr[i] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\t// ????????????????????????????????????????±???????\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tL: for (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (c[i] != c[j]) continue;\n\t\t\t\t\tfor (int k = j - 1; k >= 0; k--) {\n\t\t\t\t\t\tint pDis_j = (x[k] - x[j]) * (x[k] - x[j]) + (y[k] - y[j]) * (y[k] - y[j]);\n\t\t\t\t\t\tint rDis_j = (r[k] + r[j]) * (r[k] + r[j]);\n\t\t\t\t\t\tint pDis_i = (x[k] - x[i]) * (x[k] - x[i]) + (y[k] - y[i]) * (y[k] - y[i]);\n\t\t\t\t\t\tint rDis_i = (r[k] + r[i]) * (r[k] + r[i]);\n\t\t\t\t\t\t// k?????????????????£??????????????§????????????\n\t\t\t\t\t\tif (pDis_j < rDis_j) continue L;\n\t\t\t\t\t\tif (k < i && pDis_i < rDis_i) continue L;\n\t\t\t\t\t}\n\t\t\t\t\tmax = Math.max(max, 2 + bitDP(1 << i | 1 << j));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tint bitDP(int mask) {\n\t\tif (memo[mask] != -1) return memo[mask];\n\n\t\tbyte res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tL: for (int j = i + 1; j < n; j++) {\n\t\t\t\tif (c[i] != c[j]) continue;\n\t\t\t\t// ??¢???i or j????????£?????????\n\t\t\t\tif ((mask & (1 << i)) != 0 || (mask & (1 << j)) != 0) continue;\n\t\t\t\tfor (int k = j - 1; k >= 0; k--) {\n\t\t\t\t\t// ??¢???k???????????????????????????\n\t\t\t\t\tif ((mask & 1 << k) != 0) continue;\n\t\t\t\t\tint pDis_j = (x[k] - x[j]) * (x[k] - x[j]) + (y[k] - y[j]) * (y[k] - y[j]);\n\t\t\t\t\tint rDis_j = (r[k] + r[j]) * (r[k] + r[j]);\n\t\t\t\t\tint pDis_i = (x[k] - x[i]) * (x[k] - x[i]) + (y[k] - y[i]) * (y[k] - y[i]);\n\t\t\t\t\tint rDis_i = (r[k] + r[i]) * (r[k] + r[i]);\n\n\t\t\t\t\t// k?????????????????£??????????????§????????????\n\t\t\t\t\tif (pDis_j < rDis_j) continue L;\n\t\t\t\t\tif (k < i && pDis_i < rDis_i) continue L;\n\t\t\t\t}\n\t\t\t\tres = (byte) Math.max(res, 2 + bitDP(mask | (1 << i | 1 << j)));\n\t\t\t}\n\t\t}\n\t\treturn memo[mask] = res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tfinal double EPS = 1.0e-08;\n\tC [] data;\n\tclass C{\n\t\tint x,y,r,c;\n\t\tpublic C(int x, int y, int r, int c) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\tint n,len,ans;\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdata = new C[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tdata[i] = new C(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t\t}\n\t\t\tlen = 1 << n;\n\t\t\tboolean [] dp = new boolean[len];\n\t\t\tdp[0] = true;\n\t\t\tans = 0;\n\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\tif(! dp[j]) continue;\n\t\t\t\tArrayList<Integer> checked = new ArrayList<Integer>();\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\tif(isOVL(k,j)) continue;\n\t\t\t\t\t\n\t\t\t\t\tfor(int l = 0; l < checked.size(); l++){\n\t\t\t\t\t\tint pair = checked.get(l);\n\t\t\t\t\t\tif(! issameC(k,pair)) continue;\n\t\t\t\t\t\tint num;\n\t\t\t\t\t\tnum = j | (1 << k);\n\t\t\t\t\t\tnum = num | (1 << pair);\n\t\t\t\t\t\tdp[num] = true;\n\t\t\t\t\t\tint res = Integer.bitCount(num);\n\t\t\t\t\t\tans = Math.max(ans, res);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//store\n\t\t\t\t\tchecked.add(k);\n\t\t\t\t}\n\t\t\t}\n//\t\t\t//TODO debug\n//\t\t\tfor(int i= 0; i < len; i++){\n//\t\t\t\tfor(int j = 0; j < n+1; j++){\n//\t\t\t\t\tif(dp[i][j]){\n//\t\t\t\t\t\tSystem.out.print(\"1 \");\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tSystem.out.print(\"0 \");\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate boolean isOVL(int a,int num) {\n\t\tif(a == 0) return false;\n\t\tint ax = data[a].x;\n\t\tint ay = data[a].y;\n\t\tint ar= data[a].r;\n\t\tint ix,iy,ir,rr;\n\t\tdouble dis;\n\t\tfor(int i = a-1; i >= 0; i--){\n\t\t\tif(((1 << i) & num) != 0) continue;\n\t\t\tix = data[i].x;\n\t\t\tiy = data[i].y;\n\t\t\tir = data[i].r;\n\t\t\tdis = Point2D.Double.distance(ax, ay, ix, iy);\n\t\t\trr = ir + ar;\n\t\t\tif(dis + EPS < rr)return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean issameC(int a, int b) {\n\t\tif(data[a].c == data[b].c) return true;\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static int n;\n    static Circle circle[] = new Circle[24];\n    static int[] state = new int[20000000];\n    static int[] two = new int[25];\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        powTwo();\n\n        while (true){\n            n = sc.nextInt();\n            if (n==0) break;\n\n            for (int i = 0; i < 20000000; i++) {\n                state[i] = 0;\n            }\n            for (int i = 0; i < n; i++) {\n                circle[i] = new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt());\n                overCircle(i);\n            }\n\n            System.out.println(remove(0, 0));\n        }\n    }\n\n    static void powTwo() {\n        two[0] = 1;\n        for (int i = 1; i < 25; i++) {\n            two[i] = two[i-1]*2;\n        }\n    }\n\n    static void overCircle(int i) {\n        for (int j = 0; j < i; j++) {\n            int l = (int)(Math.pow(circle[j].x-circle[i].x,2)+Math.pow(circle[j].y-circle[i].y,2));\n            if (Math.pow(circle[j].r+circle[i].r,2)>l){\n                circle[i].over[j] = 1;\n                circle[i].cnt++;\n            }\n        }\n    }\n\n    static int remove(int cnt, int s) {\n        state[s] = 1;\n        int ans = cnt;\n\n        for (int i = 0; i < n; i++) {\n            if (circle[i].flag==1 || circle[i].cnt>0) continue;\n\n            for (int j = i+1; j < n; j++) {\n                if (circle[j].flag==0&&circle[j].cnt==0&&circle[i].c==circle[j].c){\n                    if (state[s+two[i]+two[j]]==1) continue;\n                    circle[i].flag = circle[j].flag = 1;\n                    for (int k = 0; k < n; k++) {\n                        if (circle[k].over[i]==1) circle[k].cnt--;\n                        if (circle[k].over[j]==1) circle[k].cnt--;\n                    }\n                    ans = Math.max(remove(cnt+2, s+two[i]+two[j]), ans);\n                    circle[i].flag = circle[j].flag = 0;\n                    for (int k = 0; k < n; k++) {\n                        if (circle[k].over[i]==1) circle[k].cnt++;\n                        if (circle[k].over[j]==1) circle[k].cnt++;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n\n    static class Circle{\n        int x, y, r, c;\n        int[] over = new int[24];\n        int cnt = 0, flag = 0;\n        Circle(int s, int t, int u, int v){\n            x = s; y = t; r = u; c = v;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int n;\n\tList<Disc> discs = new ArrayList<Disc>();\n\tSet<Disc> ups = new HashSet<Disc>();\n\tSet<Disc> used = new HashSet<Disc>();\n\tMap<Set<Disc>, Integer> memo = new HashMap<Set<Disc>, Integer>();\n\tint max = -1;\n\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\n\t\t\t// init\n\t\t\tMain m =new Main();\n\t\t\tm.dfs(0);\n\t\t\tSystem.out.println(m.max-2);\n\t\t}\n\t}\n\n\tMain() {\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tDisc d = new Disc(sc, i);\n\t\t\tint deep = 0;\n\t\t\tfor(Disc op : discs) {\n\t\t\t\tif( d.butsu(op) ) deep = Math.max(deep, op.deep);\n\t\t\t}\n\t\t\tdeep++;\n\t\t\tif(deep == 1) ups.add(d);\n\t\t\tdiscs.add(d);\n\t\t}\n\t}\n\n\tvoid dfs(int m) {\n\t\t// memo\n\t\tif( memo.containsKey(used) ) return;\n\n\t\t// max\n\t\tmax = Math.max(max, m);\n\n\t\t// go\n\t\tList<Disc> tmp = new ArrayList<Disc>(ups);\n\t\tfor(int i=0; i<tmp.size(); i++) {\n\t\t\tDisc d = tmp.get(i);\n\t\t\tfor(int j=i+1; j<tmp.size(); j++) {\n\t\t\t\tDisc op = tmp.get(j);\n\t\t\t\tif(d.equals(op)) continue;\n\t\t\t\tif(d.c == op.c) {\n\t\t\t\t\tpush(d, op);\n\t\t\t\t\tdfs(m+2);\n\t\t\t\t\tpush(d, op);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid push(Disc a, Disc b) {\n\t\tpushSub(a);\n\t\tpushSub(b);\n\t}\n\tprivate void pushSub(Disc a) {\n\t\tused.add(a);\n\t\tdiscs.remove(a);\n\t\tups.remove(a);\n\t\tups.addAll(underAll(a));\n\t}\n\n\tvoid pop(Disc a, Disc b) {\n\t\tpopSub(a);\n\t\tpopSub(b);\n\t}\n\tprivate void popSub(Disc a) {\n\t\tused.remove(a);\n\t\tdiscs.add(a);\n\t\tups.removeAll(underAll(a));\n\t\tups.add(a);\n\t}\n\n\tboolean butsuAny(Disc d) {\n\t\tfor(Disc op : discs) {\n\t\t\tif( d.butsu(op) ) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tSet<Disc> butsuAll(Disc d) {\n\t\tSet<Disc> res = new HashSet<Disc>();\n\t\tfor(Disc op : discs) {\n\t\t\tif( d.butsu(op) ) res.add(op);\n\t\t}\n\t\treturn res;\n\t}\n\n\tSet<Disc> underAll(Disc d) {\n\t\tSet<Disc> res = new HashSet<Disc>();\n\t\tfor(Disc op : discs) {\n\t\t\tif( d.butsu(op) && d.deep == op.deep+1 ) res.add(op);\n\t\t}\n\t\treturn res;\n\t}\n\n}\n\n\nclass Disc {\n\tint x, y, r, c;\n\tint id;\n\tint deep;\n\n\tDisc(Scanner sc, int i) {\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\t\tr = sc.nextInt();\n\t\tc = sc.nextInt();\n\t\tid = i;\n\t}\n\n\tboolean butsu(Disc op) {\n\t\treturn false;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n  class Circle {\n    int x, y, r, c;\n\n    Circle(int x, int y, int r, int c) {\n      this.x = x;\n      this.y = y;\n      this.r = r;\n      this.c = c;\n    }\n\n    boolean intersect(Circle o) {\n      return ( r + o.r ) * ( r + o.r ) > ( x - o.x ) * ( x - o.x ) + ( y - o.y )\n          * ( y - o.y );\n    }\n  }\n\n  int n;\n  Circle[] list;\n  boolean[] done;\n  \n  int[] memo;\n  boolean[] fill;\n\n  int dfs(int BITS) {\n    if(fill[BITS]) {\n      return memo[BITS];\n    }\n    int max = 0;\n\n    for ( int i = 0; i < n; ++i ) {\n      if ( done[ i ] || !isTop(i) )\n        continue;\n      for ( int j = i - 1; 0 <= j; --j ) {\n        if ( done[ j ] || !isTop(j) )\n          continue;\n\n        if ( list[i].c == list[j].c ) {\n          done[ i ] = done[ j ] = true;\n          max = Math.max( max, 2 + dfs(BITS | (1 << i) | (1 << j)) );\n          done[ i ] = done[ j ] = false;\n        }\n      }\n    }\n\n    fill[BITS] = true;\n    memo[BITS] = max;\n    return max;\n  }\n  \n  boolean isTop(int index) {\n    boolean flag = true;\n    for(int i = index - 1; 0 <= i; --i) {\n      flag &= done[i] | !list[i].intersect( list[index] );\n    }\n    return flag;\n  }\n\n  void run() {\n    for ( ;; ) {\n      n = ni();\n      if ( n == 0 ) {\n        break;\n      }\n\n      list = new Circle[n];\n      done = new boolean[n];\n      fill = new boolean[1 << n];\n      memo = new int[1 << n];\n      for ( int i = 0; i < n; ++i ) {\n        int x = ni();\n        int y = ni();\n        int r = ni();\n        int c = ni();\n        list[ i ] = new Circle( x, y, r, c );\n//        debug(isTop(i));\n      }\n      \n      System.out.println( dfs(0) );\n    }\n  }\n\n  Main() {\n    sc = new Scanner( System.in );\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println( Arrays.deepToString( os ) );\n  }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tnew AOJ1175().doIt(n);\n\t\t}\n\t}\n\n\n\tclass AOJ1175{\n\t\tint cnt[];\n\t\tint dfs(long bit,int num){\n\t\t\tif(memo[(int)bit]>=0)return memo[(int)bit];\n//\t\t\tSystem.out.println(Long.toBinaryString(bit));\n\t\t\tint result = num;\n\t\t\tArrays.fill(cnt,0);\n\t\t\tfor(int i=0;i<n;i++)for(int s=i-1;s>=0;s--)if((bit>>i)%2==1&&(bit>>s)%2==1){\n\t\t\t\tif(Point2D.distance(data[i].x, data[i].y, data[s].x, data[s].y)<data[s].r+data[i].r)cnt[i]++;\n\t\t\t}\n//\t\t\tSystem.out.println(Arrays.toString(cnt));\n\t\t\tfor(int c=1;c<=4;c++){//color\n\t\t\t\tfor(int i=0;i<n;i++)for(int s=i+1;s<n;s++)if(data[i].color==c&&data[s].color==c&&cnt[i]==0&&cnt[s]==0){\n\t\t\t\t\tif(i==s||((bit>>i)%2==0)||((bit>>s)%2==0))continue;\n\t\t\t\t\tbit -= 1 << i;\n\t\t\t\t\tbit -= 1 << s;\n//\t\t\t\t\tSystem.out.println(i+\" \"+s);\n\t\t\t\t\tresult = Math.max(result, dfs(bit,num+2));\n\t\t\t\t\tbit += 1 << i;\n\t\t\t\t\tbit += 1 << s;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn memo[(int)bit] = result;\n\t\t}\n//\t\tHashMap<Long,Integer> map;\n\t\tint[] memo = new int[(1<<24)];\n\t\tint n;\n\t\tData data[];\n\t\tvoid doIt(int n){//<=24\n\t\t\tcnt = new int[n];\n\t\t\tArrays.fill(memo, -1);\n\t\t\tthis.n = n;\n\t\t\tdata = new Data[n];\n\t\t\tfor(int i=0;i<n;i++)data[i] = new Data(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\tlong bit=0;\n\t\t\tfor(int i=0;i<n;i++)bit += 1 << i;\n\t\t\tint result = dfs(bit,0);\n\t\t\tSystem.out.println(result);\n\t\t}\n\n\t\tclass Data{\n\t\t\tint x,y,color,r;\n\t\t\tpublic Data(int x,int y,int r,int color) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.r = r;\n\t\t\t\tthis.color = color;\n\t\t\t}\n\t\t}\n\t}\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\n\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int n;\n\t//\n\tList<Disc> discs = new ArrayList<Disc>();\n\tint max = 0;\n\tSet<Set<Disc>> memo = new HashSet<Set<Disc>>();\n\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\n\t\t\tnew Main();\n\t\t}\n\t}\n\n\tMain() {\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tdiscs.add( new Disc(sc, i) );\n\t\t}\n\n\t\tdfs(new HashSet<Disc>());\n\n\t\tSystem.out.println(max);\n\t}\n\n\tvoid dfs(Set<Disc> rems) {\n\t\t// memo\n\t\tif(memo.contains(rems)) return;\n\n\t\t// pre\n\t\tList<Disc> ups = new ArrayList<Disc>();\n//\t\tPredicate<Disc> booAny = d -> {\n//\t\t\tfor(int i=d.m-1; i>=0; i--) {\n//\t\t\t\tDisc op = discs.get(i);\n//\t\t\t\tif(rems.contains(op)) continue;\n//\t\t\t\tif(d.boo(op)) {\n//\t\t\t\t\treturn true;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\treturn false;\n//\t\t};\n\t\tfor(Disc d : discs) {\n\t\t\tif(rems.contains(d)) continue;\n\t\t\tif( ! booAny(d, rems) ) ups.add(d);\n\t\t}\n\n\t//\tSystem.out.println(ups);\n\n\t\t// dfs\n\t\tfor(int i=0; i<ups.size(); i++) {\n\t\t\tfor(int j=i+1; j<ups.size(); j++) {\n\t\t\t\tDisc a = ups.get(i);\n\t\t\t\tDisc b = ups.get(j);\n\t\t\t\tif(a.c == b.c) {\n\t\t\t\t\trems.add(a); rems.add(b);\n\t\t\t\t\tmax = Math.max(max, rems.size());\n\t\t\t\t//\tif(max == n) return;\n\t\t\t\t//\tSystem.out.println(a+\",\"+b+\" \"+max);\n\t\t\t\t\tdfs(rems);\n\t\t\t\t//\tif(max == n) return;\n\t\t\t\t\trems.remove(a); rems.remove(b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemo.add(rems);\n\t}\n\n\tboolean booAny(Disc d, Set<Disc> rems) {\n\t\tfor(int i=d.m-1; i>=0; i--) {\n\t\t\tDisc op = discs.get(i);\n\t\t\tif(rems.contains(op)) continue;\n\t\t\tif(d.boo(op)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n}\n\n\nclass Disc {\n\tint x, y, r, c;\n\tint m;\n\n\tDisc(Scanner sc, int n) {\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\t\tr = sc.nextInt();\n\t\tc = sc.nextInt();\n\t\tm = n;\n\t}\n\n\tboolean boo(Disc op) {\n\t\tint kyo = (x-op.x)*(x-op.x) + (y-op.y)*(y-op.y);\n\t\tint rs = (r+op.r)*(r+op.r);\n\t\treturn kyo < rs;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"\"+m;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tAOJ1175 obj = new AOJ1175();\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tobj.doIt(n);\n\t\t}\n\t}\n\n\tclass AOJ1175{\n\t\tboolean[] memo = new boolean[(1<<24)];\n\t\tvoid doIt(int n){\n\t\t\tArrays.fill(memo,false);\n\t\t\tData[] data = new Data[n];\n\t\t\tfor(int i=0;i<n;i++)data[i] = new Data(in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\tlong bit = 0;\n\t\t\tfor(int i=0;i<n;i++)bit += 1 << i;\n\t\t\tLinkedList<State> q = new LinkedList<State>();\n\t\t\tq.add(new State(bit, 0));\n\t\t\tint cnt[] = new int[n];\n\t\t\t\n\t\t\tint result = -1;\n\t\t\twhile(q.size()>0){\n\t\t\t\tState now = q.remove();\n\t\t\t\tbit = now.bit;\n\t\t\t\tresult = Math.max(result, now.num);\n\t\t\t\tArrays.fill(cnt,0);\n\t\t\t\tfor(int i=0;i<n;i++)for(int s=i-1;s>=0;s--)if((bit>>i)%2==1&&(bit>>s)%2==1){\n\t\t\t\t\tif(Point2D.distance(data[i].x, data[i].y, data[s].x, data[s].y)<data[s].r+data[i].r)cnt[i]++;\n\t\t\t\t}\n\n\t\t\t\tfor(int i=0;i<n;i++)for(int s=i+1;s<n;s++)if(data[i].color==data[s].color&&cnt[i]==0&&cnt[s]==0){\n\t\t\t\t\tif(i==s||((bit>>i)%2==0)||((bit>>s)%2==0))continue;\n\t\t\t\t\tlong bit2 = bit-(1<<i)-(1<<s);\n\t\t\t\t\tif(memo[(int)bit2])continue;\n\t\t\t\t\tmemo[(int)bit2] = true;\n\t\t\t\t\tq.add(new State(bit2,now.num+2));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\n\t\tclass State{\n\t\t\tlong bit;\n\t\t\tint num;\n\t\t\tpublic State(long bit,int num){\n\t\t\t\tthis.bit = bit;\n\t\t\t\tthis.num = num;\n\t\t\t}\n\t\t}\n\n\t\tclass Data{\n\t\t\tint x,y,color,r;\n\t\t\tpublic Data(int x,int y,int r,int color) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.r = r;\n\t\t\t\tthis.color = color;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n \npublic class Main {\n  Scanner sc;\n \n  class Circle {\n    byte x, y, r, c;\n \n    Circle(byte x, byte y, byte r, byte c) {\n      this.x = x;\n      this.y = y;\n      this.r = r;\n      this.c = c;\n    }\n \n    boolean intersect(Circle o) {\n      return ( (int) r + o.r ) * ( (int) r + o.r ) > ( (int) x - o.x )\n          * ( (int) x - o.x ) + ( (int) y - o.y ) * ( (int) y - o.y );\n    }\n  }\n \n  int n = 24;\n  Circle[] list = new Circle[n];\n  boolean[] done = new boolean[n];\n  byte[] memo = new byte[1 << n];\n  boolean[] fill = new boolean[1 << n];\n \n  byte dfs(int BITS) {\n    if ( fill[ BITS ] ) {\n      return memo[ BITS ];\n    }\n    byte max = 0;\n \n    for ( int i = 0; i < n; ++i ) {\n      if ( done[ i ] || !isTop( i ) )\n        continue;\n      for ( int j = i - 1; 0 <= j; --j ) {\n        if ( done[ j ] || !isTop( j ) )\n          continue;\n \n        if ( list[ i ].c == list[ j ].c ) {\n          done[ i ] = done[ j ] = true;\n          max = (byte) Math\n              .max( max, 2 + dfs( BITS | ( 1 << i ) | ( 1 << j ) ) );\n          done[ i ] = done[ j ] = false;\n        }\n      }\n    }\n \n    fill[ BITS ] = true;\n    memo[ BITS ] = max;\n    return max;\n  }\n \n  boolean isTop(int index) {\n    boolean flag = true;\n    for ( int i = index - 1; 0 <= i; --i ) {\n      flag &= done[ i ] | !list[ i ].intersect( list[ index ] );\n    }\n    return flag;\n  }\n \n  void run() {\n    for ( ;; ) {\n      n = ni();\n      if ( n == 0 ) {\n        break;\n      }\n \n      Arrays.fill( done, false );\n      Arrays.fill( fill, false );\n      for ( int i = 0; i < n; ++i ) {\n        byte x = ni();\n        byte y = ni();\n        byte r = ni();\n        byte c = ni();\n        list[ i ] = new Circle( x, y, r, c );\n        // debug(isTop(i));\n      }\n \n      System.out.println( dfs( 0 ) );\n    }\n  }\n \n  Main() {\n    sc = new Scanner( System.in );\n  }\n \n  byte ni() {\n    return (byte) sc.nextInt();\n  }\n \n  public static void main(String[] args) {\n    new Main().run();\n  }\n \n  void debug(Object... os) {\n    System.err.println( Arrays.deepToString( os ) );\n  }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\n\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int n;\n\t//\n\tList<Disc> discs = new ArrayList<Disc>();\n\tint max = 0;\n\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\n\t\t\tnew Main();\n\t\t}\n\t}\n\n\tMain() {\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tdiscs.add( new Disc(sc, i) );\n\t\t}\n\n\t\tdfs(new HashSet<Disc>());\n\n\t\tSystem.out.println(max);\n\t}\n\n\tvoid dfs(Set<Disc> rems) {\n\t\t// pre\n\t\tList<Disc> ups = new ArrayList<Disc>();\n//\t\tPredicate<Disc> booAny = d -> {\n//\t\t\tfor(int i=d.m-1; i>=0; i--) {\n//\t\t\t\tDisc op = discs.get(i);\n//\t\t\t\tif(rems.contains(op)) continue;\n//\t\t\t\tif(d.boo(op)) {\n//\t\t\t\t\treturn true;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\treturn false;\n//\t\t};\n\t\tfor(Disc d : discs) {\n\t\t\tif(rems.contains(d)) continue;\n\t\t\tif( ! booAny(d, rems) ) ups.add(d);\n\t\t}\n\n\t//\tSystem.out.println(ups);\n\n\t\t// dfs\n\t\tfor(int i=0; i<ups.size(); i++) {\n\t\t\tfor(int j=i+1; j<ups.size(); j++) {\n\t\t\t\tDisc a = ups.get(i);\n\t\t\t\tDisc b = ups.get(j);\n\t\t\t\tif(a.c == b.c) {\n\t\t\t\t\trems.add(a); rems.add(b);\n\t\t\t\t\tmax = Math.max(max, rems.size());\n\t\t\t\t\tif(max == n) return;\n\t\t\t\t//\tSystem.out.println(a+\",\"+b+\" \"+max);\n\t\t\t\t\tdfs(rems);\n\t\t\t\t\tif(max == n) return;\n\t\t\t\t\trems.remove(a); rems.remove(b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tboolean booAny(Disc d, Set<Disc> rems) {\n\t\tfor(int i=d.m-1; i>=0; i--) {\n\t\t\tDisc op = discs.get(i);\n\t\t\tif(rems.contains(op)) continue;\n\t\t\tif(d.boo(op)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n}\n\n\nclass Disc {\n\tint x, y, r, c;\n\tint m;\n\n\tDisc(Scanner sc, int n) {\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\t\tr = sc.nextInt();\n\t\tc = sc.nextInt();\n\t\tm = n;\n\t}\n\n\tboolean boo(Disc op) {\n\t\tint kyo = (x-op.x)*(x-op.x) + (y-op.y)*(y-op.y);\n\t\tint rs = (r+op.r)*(r+op.r);\n\t\treturn kyo < rs;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"\"+m;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n  Scanner sc;\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Disk {\n    LinkedList<Disk> parents = new LinkedList<>();\n    LinkedList<Disk> children = new LinkedList<>();\n    int x;\n    int y;\n    int i;\n    int c;\n    int r;\n\n    boolean isIn(Disk disk) {\n      return Math.pow(this.r + disk.r, 2) > Math.pow(this.x - disk.x, 2) + Math.pow(this.y - disk.y, 2);\n    }\n\n    public String toString() {\n      return \"\" + i;\n    }\n  }\n\n  int dfs(ArrayList<Disk> list) {\n    HashMap<Integer, ArrayList<Disk>> map = new HashMap<>();\n    for (Disk d : list) {\n      if (d.parents.size() == 0) {\n        if (!map.containsKey(d.c)) {\n          map.put(d.c, new ArrayList<>());\n        }\n        map.get(d.c).add(d);\n      }\n    }\n    int cnt = 0;\n    for (int color : map.keySet()) {\n      int subcnt = 0;\n      int subsubcnt = map.get(color).size() / 2;\n      if (map.get(color).size() < 2) {\n        continue;\n      }\n      if (map.get(color).size() % 2 == 1) {\n        ArrayList<Disk> arr = map.get(color);\n\n        for (ListIterator<Disk> ite = arr.listIterator(); ite.hasNext(); ) {\n          Disk atom = ite.next();\n          ite.remove();\n          ArrayList<Disk> del = new ArrayList<>();\n          for (ListIterator<Disk> jte = arr.listIterator(); jte.hasNext(); ) {\n            Disk d = jte.next();\n            Disk e = jte.next();\n            d.children.forEach(c -> c.parents.remove(d));\n            e.children.forEach(c -> c.parents.remove(e));\n            list.remove(d);\n            list.remove(e);\n            del.add(d);\n            del.add(e);\n          }\n          subcnt = Math.max(subcnt, dfs(list));\n          for (Disk v : del) {\n            v.children.forEach(c -> c.parents.add(v));\n            list.add(v);\n          }\n          ite.add(atom);\n        }\n      } else {\n        ArrayList<Disk> arr = map.get(color);\n        ArrayList<Disk> del = new ArrayList<>();\n        for (ListIterator<Disk> ite = arr.listIterator(); ite.hasNext(); ) {\n          Disk d = ite.next();\n          Disk e = ite.next();\n          d.children.forEach(c -> c.parents.remove(d));\n          e.children.forEach(c -> c.parents.remove(e));\n          list.remove(d);\n          list.remove(e);\n          del.add(d);\n          del.add(e);\n        }\n        subcnt = dfs(list);\n        for (Disk v : del) {\n          v.children.forEach(c -> c.parents.add(v));\n          list.add(v);\n        }\n      }\n      cnt += subcnt;\n      cnt += subsubcnt;\n    }\n\n    return cnt;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      ArrayList<Disk> list = new ArrayList<>();\n      for (int i = 0; i < n; ++i) {\n        Disk d = new Disk();\n        d.x = ni();\n        d.y = ni();\n        d.i = i;\n        d.r = ni();\n        d.c = ni();\n\n        for (int j = 0; j < i; ++j) {\n          Disk e = list.get(j);\n          if (e.isIn(d)) {\n            e.children.add(d);\n            d.parents.add(e);\n          }\n        }\n        list.add(d);\n      }\n\n      System.out.println(dfs(list) * 2);\n    }\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1175();\n\t}\n\tfinal int INF=1<<28;\n\t\n\tclass AOJ1175{\n\t\tAOJ1175(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tCircle[] c;\n\t\tboolean[][] b;\n\t\tHashSet<Integer> vtd;\n\t\tint N;\n\t\tvoid solve(){\n\t\t\tc=new Circle[N];\n\t\t\tfor(int i=0; i<N; ++i)\tc[i]=new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt()-1);\n\t\t\tb=new boolean[N][N];\n\t\t\tfor(int i=0; i<N; ++i)for(int j=0; j<N; ++j)\tb[i][j]=(c[i].r+c[j].r <= c[i].p.distance(c[j].p));\n\t\t\tvtd = new HashSet<Integer>();\n\t\t\tint ret=dfs((1<<N)-1);\n\t\t\tSystem.out.println(N-ret);\n\t\t}\n\t\tint dfs(int cc){\n//\t\t\tSystem.out.println(Integer.toBinaryString(cc));\n\t\t\tint ret=Integer.bitCount(cc);\n\t\t\tif(vtd.contains(cc))\treturn ret;\n\t\t\tvtd.add(cc);\n\t\t\tArrayList<ArrayList<Integer>> list=list(cc);\n//\t\t\tSystem.out.println(list);\n\t\t\t\n\t\t\tfor(int i=0; i<4; ++i){\n\t\t\t\tif(list.get(i).size() >= 2){\n\t\t\t\t\tint n=list.get(i).size(), b=(1<<n)-1;\n\t\t\t\t\tfor(int j=3; j<=b; ++j)if(Integer.bitCount(j)==2){\n\t\t\t\t\t\tint tmp=0;\n\t\t\t\t\t\tfor(int k=0; k<n; ++k)if((j&(1<<k))>0)\ttmp |= (1<<list.get(i).get(k));\n\t\t\t\t\t\tcc ^= tmp;\n\t\t\t\t\t\tret = min(ret, dfs(cc));\n\t\t\t\t\t\tcc |= tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tArrayList<ArrayList<Integer>> list(int cc){\n\t\t\tArrayList<ArrayList<Integer>> ret=new ArrayList<ArrayList<Integer>>(4);\n\t\t\tfor(int i=0; i<4; ++i)\tret.add(new ArrayList<Integer>());\n\t\t\tfor(int i=0; i<N; ++i)if((cc&(1<<i))>0){\n\t\t\t\tboolean flg=true;\n\t\t\t\tfor(int j=0; j<i; ++j)if((cc&(1<<j))>0){\n\t\t\t\t\tflg = b[i][j];\n\t\t\t\t\tif(!flg)\tbreak;\n\t\t\t\t}\n\t\t\t\tif(flg)\tret.get(c[i].c).add(i);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tclass Circle{\n\t\t\tPoint2D p;\n\t\t\tdouble r;\n\t\t\tint c;\n\t\t\tCircle(double x,double y,double r,int c){\n\t\t\t\tthis.p=new Point2D.Double(x,y);\n\t\t\t\tthis.r=r;\n\t\t\t\tthis.c=c;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tC [] data;\n\tclass C{\n\t\tint x,y,r,c;\n\t\tpublic C(int x, int y, int r, int c) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\tint n,len,ans;\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdata = new C[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tdata[i] = new C(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t\t}\n\t\t\tlen = 1 << n;\n\t\t\tboolean [][] dp = new boolean[len][n/2 + 1];\n\t\t\tdp[0][0] = true;\n\t\t\tans = 0;\n\t\t\tfor(int i=0; i < n/2;i++){\n\t\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\t\tif(dp[j][i] == false) continue;\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\t\tfor(int l = k+1; l < n; l++){\n\t\t\t\t\t\t\tif((j & (1 << k)) != 0) continue;\n\t\t\t\t\t\t\tif(! issameC(k,l)) continue;\n\t\t\t\t\t\t\tif(isOVL(k,j) || isOVL(l,j)) continue;\n\t\t\t\t\t\t\tint num;\n\t\t\t\t\t\t\tnum = j | (1 << k);\n\t\t\t\t\t\t\tnum = num | (1 << l);\n\t\t\t\t\t\t\t//System.out.println(\"num= \"+num + \" j= \" + j +  \" k = \"+ k + \" l= \" + l );\n\t\t\t\t\t\t\tdp[num][i+1] = true;\n\t\t\t\t\t\t\tans = (i+1)*2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\t//TODO debug\n//\t\t\tfor(int i= 0; i < len; i++){\n//\t\t\t\tfor(int j = 0; j < n+1; j++){\n//\t\t\t\t\tif(dp[i][j]){\n//\t\t\t\t\t\tSystem.out.print(\"1 \");\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tSystem.out.print(\"0 \");\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tprivate boolean isOVL(int a,int num) {\n\t\tif(a == 0) return false;\n\t\tint ax = data[a].x;\n\t\tint ay = data[a].y;\n\t\tint ar= data[a].r;\n\t\tint ix,iy,ir,rr;\n\t\tdouble dis;\n\t\tfor(int i = a-1; i >= 0; i--){\n\t\t\tif(((1 << i) & num) != 0) continue;\n\t\t\tix = data[i].x;\n\t\t\tiy = data[i].y;\n\t\t\tir = data[i].r;\n\t\t\tdis = Point2D.Double.distance(ax, ay, ix, iy);\n\t\t\trr = ir + ar;\n\t\t\tif(dis < rr)return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean issameC(int a, int b) {\n\t\tif(data[a].c == data[b].c) return true;\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n  Scanner sc;\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Disk {\n    int x;\n    int y;\n    int c;\n    int r;\n\n    boolean isIn(Disk disk) {\n      return Math.pow(this.r + disk.r, 2) > Math.pow(this.x - disk.x, 2) + Math.pow(this.y - disk.y, 2);\n    }\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      Disk[] list = new Disk[n];\n      for (int i = 0; i < n; ++i) {\n        Disk d = new Disk();\n        d.x = ni();\n        d.y = ni();\n        d.r = ni();\n        d.c = ni();\n        list[i] = d;\n      }\n\n      byte[] dp = new byte[1 << n];\n      Arrays.fill(dp, (byte) -1);\n      dp[0] = 0;\n      for (int i = 0; i < 1 << n; ++i) {\n        if (dp[i] < 0) {\n          continue;\n        }\n        for (int j = 0; j < n; ++j) {\n          if (((i >> j) & 1) == 1) {\n            continue;\n          }\n          boolean flag = true;\n          for (int a = 0; a < j; ++a) {\n            if (((i >> a) & 1) == 1) {\n              continue;\n            }\n            flag &= !list[j].isIn(list[a]);\n          }\n          if (!flag) {\n            continue;\n          }\n          for (int k = j + 1; k < n; ++k) {\n            if (((i >> k) & 1) == 1) {\n              continue;\n            }\n            boolean glag = true;\n            for (int a = 0; a < k; ++a) {\n              if (((i >> a) & 1) == 1) {\n                continue;\n              }\n              glag &= !list[k].isIn(list[a]);\n            }\n            if (!glag) {\n              continue;\n            }\n            if (list[j].c != list[k].c) {\n              continue;\n            }\n\n//            debug(j, k);\n\n            dp[i | (1 << j) | (1 << k)] = (byte) Math.max(dp[i] + 1, dp[i | (1 << j) | (1 << k)]);\n          }\n        }\n      }\n      int max = 0;\n      for (int i = 0; i < 1 << n; ++i) {\n        max = Math.max(max, dp[i]);\n      }\n\n      System.out.println(max * 2);\n    }\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\npublic class Main{\n\n\tstatic int INF = 2 << 27;\n\tstatic int m;\n\tstatic int n;\n\tstatic int k;\n\tstatic int d;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tData[] data = new Data[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdata[i] = new Data(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\t\t\tboolean check = check(data,i,j);\n\t\t\t\t\tif(check) data[j].up |= (1 << i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[] dp = new boolean[1 << n];\n\t\t\tdp[0] = true;\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tif(!dp[i]) continue;\n\t\t\t\tArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tlist.add(new ArrayList<Integer>());\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tif((i & (1 << j)) != 0 || (i & data[j].up) != data[j].up) continue;\n\t\t\t\t\tlist.get(data[j].c).add(j);\n\t\t\t\t}\n\t\t\t\tfor(int j = 1; j < 5; j++) {\n\t\t\t\t\tArrayList<Integer> lX = list.get(j);\n\t\t\t\t\tfor(int k = 0; k < lX.size()-1; k++) {\n\t\t\t\t\t\tfor(int l = k + 1; l < lX.size(); l++) {\n\t\t\t\t\t\t\tint next = i | (1 << lX.get(k) | (1 << lX.get(l)));\n\t\t\t\t\t\t\tdp[next] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tif(dp[i]) max = Math.max(max, Integer.bitCount(i));\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t\t\n\t\t}\n\t}\n\tstatic boolean check(Data[] data, int a, int b) {\n\t\tint dis = (data[a].x - data[b].x) * (data[a].x - data[b].x) + (data[a].y - data[b].y) * (data[a].y - data[b].y);\n\t\treturn dis < (data[a].r + data[b].r) * (data[a].r + data[b].r);\n\t}\n\tstatic class Data {\n\t\tint up = 0;\n\t\tint x;\n\t\tint y;\n\t\tint r;\n\t\tint c;\n\t\tData(int a, int b, int c, int d) {\n\t\t\tthis.x = a;\n\t\t\tthis.y = b;\n\t\t\tthis.r = c;\n\t\t\tthis.c = d;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic BitSet cleared = new BitSet();\n\tstatic PriorityQueue<double[]>[] pQ;\n\tstatic double[][] c;\n\n\tstatic int isIntersection(double x1, double y1, double r1, double x2, double y2, double r2) {\n\t\tdouble d = (x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2);\n\t\tdouble rr = r1 + r2;\n\t\treturn Math.abs(d - rr*rr) < 1e-10 ? 1 : (d < rr*rr ? 2 : 0);\n\t}\n\n\tstatic boolean isOk(int idx) {\n\t\tdouble[] t = c[idx];\n\t\tfor (int i=0; i<idx; i++) {\n\t\t\tif (cleared.get(i)) continue;\n\t\t\tif (isIntersection(t[0], t[1], t[2], c[i][0], c[i][1], c[i][2]) > 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic boolean clear() {\n\t\tfor (int i=0; i<4; i++) {\n\t\t\tdouble[] tmp = null;\n\t\t\tfor (double[] p : pQ[i]) {\n\t\t\t\tif (isOk((int)p[3])) {\n\t\t\t\t\tif (tmp == null) {\n\t\t\t\t\t\ttmp = p;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcleared.set((int)tmp[3]);\n\t\t\t\t\t\tcleared.set((int)p[3]);\n\t\t\t\t\t\tpQ[i].remove(tmp);\n\t\t\t\t\t\tpQ[i].remove(p);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tstatic boolean solve() {\n\t\tint n = in.nextInt();\n\t\tif (n == 0) return false;\n\n\t\tpQ = new PriorityQueue[4];\n\t\tfor (int i=0; i<4; i++) {\n\t\t\tpQ[i] = new PriorityQueue<double[]>(new Comparator<double[]>(){\n\t\t\t\tpublic int compare(double[] a, double[] b) {\n\t\t\t\t\treturn (int)(a[3] - b[3]);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tc = new double[n][4];\n\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tc[i][0] = in.nextInt();\n\t\t\tc[i][1] = in.nextInt();\n\t\t\tc[i][2] = in.nextInt();\n\t\t\tint color = in.nextInt() - 1;\n\t\t\tc[i][3] = i;\n\t\t\tpQ[color].add(c[i]);\n\t\t}\n\n\t\tint cnt = 0;\n\n\t\twhile (clear()) {\n\t\t\tcnt += 2;\n\t\t}\n\n\t\tout.println(cnt);\n\t\tcleared.clear();\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.currentTimeMillis();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.currentTimeMillis();\n\t\tdump((end-start) + \"ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, max;\n    int[] S, color;\n    HashSet<Integer> set;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            n = sc.nextInt();\n            if(n==0) break;\n\n            int[] x = new int[n], y = new int[n], r = new int[n];\n            color = new int[n];\n            for(int i=0; i<n; i++){\n                x[i] = sc.nextInt(); y[i] = sc.nextInt();\n                r[i] = sc.nextInt(); color[i] = sc.nextInt();\n            }\n            S = new int[n];\n            for(int i=0; i<n; i++){\n                int T = 0;\n                for(int j=0; j<i; j++){\n                    if(i==j) continue;\n                    int dist = (x[i]-x[j]) * (x[i]-x[j]) + (y[i]-y[j]) * (y[i]-y[j]);\n                    int hankei = (r[i]+r[j]) * (r[i]+r[j]);\n                    if(dist<hankei) T = T | (1<<j);\n                }\n                S[i] = T;\n            }\n\n            max = 0;\n            set = new HashSet<Integer>();\n            rec((1<<n)-1);\n            System.out.println(max);\n        }\n    }\n\n    void rec(int T){\n        if(!set.add(T)) return;\n        else max = Math.max(max, n - Integer.bitCount(T));\n        for(int i=0; i<n; i++){\n            if((T&(1<<i))==0 || (S[i]&T)!=0) continue;\n            for(int j=i+1; j<n; j++){\n                if((T&(1<<j))==0 || (S[j]&T)!=0) continue;\n                if(color[i]==color[j]){\n                    int newT = T;\n                    newT ^= (1<<i); newT^= (1<<j);\n                    rec(newT);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int n;\n\tstatic int r[];\n\tstatic int x[];\n\tstatic int y[];\n\tstatic int c[];\n\n\tstatic int on[][];\n\tstatic boolean dp[];\n\tstatic boolean table[][];\n\n\tstatic void solve() {\n\t\t//int bit = 0;\n\t\tdp[0] = true;\n\t\tmakeTable();\n\t\t//0の時に円盤を2枚取れるか全て計算\n\t\t//\t\tfor (int s = 0; s < n; s++) {\n\t\t//\t\t\t//s + 1ビット目が0なら\n\t\t//\t\t\t//System.out.println(\"s = \" + s);\n\t\t//\t\t\tfor (int k = s + 1; k < n; k++) {\n\t\t//\t\t\t\tif (canGet(bit, s, k)) {\n\t\t//\t\t\t\t\tdp[(1 << s) + (1 << k)] = true;\n\t\t//\t\t\t\t}\n\t\t//\t\t\t}\n\t\t//\t\t}\n\t\t//\n\t\t//\t\tfor (int i = 0; i < n; i++) {\n\t\t//\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t//\t\t\t\tbit = (1 << i) + (1 << j);\n\t\t//\n\t\t//\t\t\t\tif (dp[bit] == true) {\n\t\t//\t\t\t\t\tfor (int s = 0; s < n; s++) {\n\t\t//\t\t\t\t\t\tif ((bit >> s & 1) == 0) {\n\t\t//\t\t\t\t\t\t\tfor (int k = s + 1; k < n; k++) {\n\t\t//\t\t\t\t\t\t\t\tif ((bit >> k & 1) == 0) {\n\t\t//\t\t\t\t\t\t\t\t\tif (canGet(bit, s, k)) {\n\t\t//\t\t\t\t\t\t\t\t\t\tdp[bit + (1 << s) + (1 << k)] = true;\n\t\t//\t\t\t\t\t\t\t\t\t}\n\t\t//\t\t\t\t\t\t\t\t}\n\t\t//\t\t\t\t\t\t\t}\n\t\t//\t\t\t\t\t\t}\n\t\t//\t\t\t\t\t}\n\t\t//\t\t\t\t}\n\t\t//\n\t\t//\t\t\t}\n\t\t//\t\t}\n\t\tint len = 1 << n;\n\t\tfor(int bit = 0; bit < len; bit++){\n\t\t\tif(dp[bit]){\n\t\t\t\tfor (int s = 0; s < n; s++) {\n\t\t\t\t\tif ((bit >> s & 1) == 0) {\n\t\t\t\t\t\tfor (int k = s + 1; k < n; k++) {\n\t\t\t\t\t\t\tif ((bit >> k & 1) == 0) {\n\t\t\t\t\t\t\t\tif (canGet(bit, s, k)) {\n\t\t\t\t\t\t\t\t\tdp[bit + (1 << s) + (1 << k)] = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\t//printDP();\n\n\t\tprintAns();\n\t}\n\t\n\tstatic void printDP(){\n\t\tfor(boolean a : dp){\n\t\t\tSystem.out.print(a + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tstatic void printAns() {\n\t\tint max = 0;\n\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\tif (dp[i]) {\n\t\t\t\t// iの1の数を計算\n\t\t\t\tint count = 0;\n\t\t\t\tint k = i;\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (((k & 1) == 1)) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\tk = k >> 1;\n\t\t\t\t}\n\t\t\t\tmax = count > max ? count : max;\n\t\t\t}\n\n\t\t}\n\n\t\tSystem.out.println(max);\n\t}\n\n\tstatic void makeTable() {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t//重なっていればtrue\n\t\t\t\ttable[i][j] = d(x[i] - x[j]) + d(y[i] - y[j]) < d(r[i] + r[j]) ? true : false;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int d(int a){\n\t\treturn a*a;\n\t}\n\n\tstatic boolean canGet(int bit, int s, int k) {\n\t\tif (c[s] != c[k]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif ((bit >> i & 1) == 0) {\n\t\t\t\tif (table[s][i] || table[k][i]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic public boolean read() {\n\t\tn = sc.nextInt();\n\t\tif (n == 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\ton = new int[n][n];\n\t\tdp = new boolean[1 << n];\n\t\t//Arrays.fill(dp, false);\n\t\ttable = new boolean[n][n];\n\t\tx = new int[n];\n\t\ty = new int[n];\n\n\t\tr = new int[n];\n\t\tc = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tr[i] = sc.nextInt();\n\t\t\tc[i] = sc.nextInt();\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void test(){\n\t\tint i = 16;\n\t\tSystem.out.println(i);\n\t\tSystem.out.println(i << 2);\n\t\tSystem.out.println(i);\n\t}\n\t\n\tpublic static void doIt(){\n\t\twhile (read())\n\t\t\tsolve();\n\t}\n\n\tpublic static void main(String args[]) {\n\t\t//test();\n\t\tdoIt();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int n;\n\tstatic int[] x;\n\tstatic int[] y;\n\tstatic int[] r;\n\tstatic int[] c;\n\tstatic boolean[][] cover;\n\tstatic int[] dp;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx = new int[n];\n\t\t\ty = new int[n];\n\t\t\tr = new int[n];\n\t\t\tc = new int[n];\n\t\t\tcover = new boolean[n][n];\n\t\t\tdp = new int[(1<<n)];\n\t\t\tArrays.fill(dp, -1);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t\tr[i] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt()-1;\n\t\t\t\tfor(int j=0;j<i;j++) {\n\t\t\t\t\tint dx = x[j] - x[i];\n\t\t\t\t\tint dy = y[j] - y[i];\n\t\t\t\t\tint rs = r[i] + r[j];\n\t\t\t\t\tif (dx*dx+dy*dy<rs*rs) {\n\t\t\t\t\t\tcover[j][i] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dfs(0));\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static int dfs(int used) {\n\t\tif (dp[used]!=-1) {\n\t\t\treturn dp[used];\n\t\t}\n\t\tArrayList<Integer>[] canuse = new ArrayList[4];\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tcanuse[i] = new ArrayList<Integer>();\n\t\t}\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (((1<<i)&used) == 0) {\n\t\t\t\tboolean flag = true;\n\t\t\t\tfor(int j=0;j<i;j++) {\n\t\t\t\t\tif (((1<<j)&used) == 0 && cover[j][i]) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tcanuse[c[i]].add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tboolean flag = false;\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tif (canuse[i].size() >= 2) {\n\t\t\t\tfor(int j=0;j<canuse[i].size()-1;j++) {\n\t\t\t\t\tfor(int k=j+1;k<canuse[i].size();k++) {\n\t\t\t\t\t\tint usednext = used | (1<<canuse[i].get(j)) | (1<<canuse[i].get(k));\n\t\t\t\t\t\tret = Math.max(ret, dfs(usednext));\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret = flag ? ret + 2 : 0;\n\t\tdp[used] = ret;\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\n\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int n;\n\t//\n\tList<Disc> discs = new ArrayList<Disc>();\n\tint max = 0;\n\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\n\t\t\tnew Main();\n\t\t}\n\t}\n\n\tMain() {\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tdiscs.add( new Disc(sc, i) );\n\t\t}\n\n\t\tdfs(new HashSet<Disc>());\n\n\t\tSystem.out.println(max);\n\t}\n\n\tvoid dfs(Set<Disc> rems) {\n\t\t// pre\n\t\tList<Disc> ups = new ArrayList<Disc>();\n//\t\tPredicate<Disc> booAny = d -> {\n//\t\t\tfor(int i=d.m-1; i>=0; i--) {\n//\t\t\t\tDisc op = discs.get(i);\n//\t\t\t\tif(rems.contains(op)) continue;\n//\t\t\t\tif(d.boo(op)) {\n//\t\t\t\t\treturn true;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\treturn false;\n//\t\t};\n\t\tfor(Disc d : discs) {\n\t\t\tif(rems.contains(d)) continue;\n\t\t\tif( ! booAny(d, rems) ) ups.add(d);\n\t\t}\n\n\t//\tSystem.out.println(ups);\n\n\t\t// dfs\n\t\tfor(int i=0; i<ups.size(); i++) {\n\t\t\tfor(int j=i+1; j<ups.size(); j++) {\n\t\t\t\tDisc a = ups.get(i);\n\t\t\t\tDisc b = ups.get(j);\n\t\t\t\tif(a.c == b.c) {\n\t\t\t\t\trems.add(a); rems.add(b);\n\t\t\t\t\tmax = Math.max(max, rems.size());\n\t\t\t\t//\tSystem.out.println(a+\",\"+b+\" \"+max);\n\t\t\t\t\tdfs(rems);\n\t\t\t\t\trems.remove(a); rems.remove(b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tboolean booAny(Disc d, Set<Disc> rems) {\n\t\tfor(int i=d.m-1; i>=0; i--) {\n\t\t\tDisc op = discs.get(i);\n\t\t\tif(rems.contains(op)) continue;\n\t\t\tif(d.boo(op)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n}\n\n\nclass Disc {\n\tint x, y, r, c;\n\tint m;\n\n\tDisc(Scanner sc, int n) {\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\t\tr = sc.nextInt();\n\t\tc = sc.nextInt();\n\t\tm = n;\n\t}\n\n\tboolean boo(Disc op) {\n\t\tint kyo = (x-op.x)*(x-op.x) + (y-op.y)*(y-op.y);\n\t\tint rs = (r+op.r)*(r+op.r);\n\t\treturn kyo < rs;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"\"+m;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\npublic class Main{\n\n\tstatic int INF = 2 << 27;\n\tstatic int m;\n\tstatic int n;\n\tstatic int k;\n\tstatic int d;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tData[] data = new Data[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdata[i] = new Data(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\t\t\tboolean check = check(data,i,j);\n\t\t\t\t\tif(check) data[j].up |= (1 << i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[] dp = new boolean[1 << n];\n\t\t\tdp[0] = true;\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tif(!dp[i]) continue;\n\t\t\t\tArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tlist.add(new ArrayList<Integer>());\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tif((i & (1 << j)) != 0) continue;\n\t\t\t\t\tif((i & data[j].up) != data[j].up) continue;\n\t\t\t\t\tlist.get(data[j].c).add(j);\n\t\t\t\t}\n\t\t\t\tIN:for(int j = 1; j < 5; j++) {\n\t\t\t\t\tif(list.get(j).size() < 2) continue;\n\t\t\t\t\tfor(int k = 0; k < list.get(j).size()-1; k++) {\n\t\t\t\t\t\tfor(int l = k + 1; l < list.get(j).size(); l++) {\n\t\t\t\t\t\t\tint next = i;\n\t\t\t\t\t\t\tnext |= (1 << list.get(j).get(k));\n\t\t\t\t\t\t\tnext |= (1 << list.get(j).get(l));\n\t\t\t\t\t\t\tdp[next] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tif(dp[i]) max = Math.max(max, Integer.bitCount(i));\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t\t\n\t\t}\n\t}\n\tstatic boolean check(Data[] data, int a, int b) {\n\t\tint dis = (int)(Math.pow(data[a].x - data[b].x, 2) + Math.pow(data[a].y - data[b].y, 2));\n\t\treturn dis < Math.pow(data[a].r + data[b].r,2);\n\t}\n\tstatic class Data {\n\t\tint up = 0;\n\t\tint x;\n\t\tint y;\n\t\tint r;\n\t\tint c;\n\t\tData(int a, int b, int c, int d) {\n\t\t\tthis.x = a;\n\t\t\tthis.y = b;\n\t\t\tthis.r = c;\n\t\t\tthis.c = d;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1175();\n\t}\t\n\tclass AOJ1175{\n\t\tAOJ1175(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tint N;\n\t\tvoid solve(){\n\t\t\tCircle[] c=new Circle[N];\n\t\t\tint[] a=new int[N];\n\t\t\tfor(int i=0; i<N; ++i){\n\t\t\t\tc[i]=new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt()-1);\n\t\t\t\tfor(int j=0; j<i; ++j)if(c[i].r+c[j].r > c[i].p.distance(c[j].p))\ta[i] |= (1<<j);\n\t\t\t}\n\t\t\tint ans=N;\n\t\t\tboolean[] dp=new boolean[1<<N];\n\t\t\tdp[(1<<N)-1]=true;\n\t\t\tfor(int i=(1<<N)-1; i>=0; --i)if(dp[i]){\n\t\t\t\tfor(int j=0; j<N; ++j)if((i&(1<<j))>0 && (i&a[j])==0){\n\t\t\t\t\tfor(int k=j+1; k<N; ++k)if(j!=k && (i&(1<<k))>0 && (i&a[k])==0 && c[j].c==c[k].c){\n\t\t\t\t\t\tint tmp=(1<<j)|(1<<k);\n\t\t\t\t\t\tint next=i&(((1<<N)-1)^tmp);\n//\t\t\t\t\t\tSystem.out.println(Integer.toBinaryString(i)+\" \"+Integer.toBinaryString(tmp)+\" \"+Integer.toBinaryString(next));\n\t\t\t\t\t\tdp[next]=true;\n\t\t\t\t\t\tans=min(ans, Integer.bitCount(next));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(N-ans);\n\t\t}\n\t\tclass Circle{\n\t\t\tPoint2D p;\n\t\t\tdouble r;\n\t\t\tint c;\n\t\t\tCircle(double x,double y,double r,int c){\n\t\t\t\tthis.p=new Point2D.Double(x,y);\n\t\t\t\tthis.r=r;\n\t\t\t\tthis.c=c;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "def d(u)(u.combination(2).map{|i,j|(@d[i][0]-@d[j][0])**2+(@d[i][1]-@d[j][1])**2<(@d[i][2]+@d[j][2])**2?i:-1}-[-1]).uniq.combination(2).map{|i,j|@d[i][3]==@d[j][3]?2+d(u-[i,j]):0}.max||0\nend\nwhile(@d=[];gets.to_i.times{@d<<gets.split.map(&:to_i)})>0\np d(Array 0...@d.size)\nend"
  },
  {
    "language": "Ruby",
    "code": "def overlap(d1,d2)\n    Math.sqrt((d2[0] - d1[0])**2 + (d2[1] - d1[1])**2) < d1[2] + d2[2]\nend\ndef dfs(ds, on)\n    if (top = ds.size.times.select{|i| on[i].size == 0}).size > 0\n        max = 0\n        top.combination(2) do |a,b|\n            next if ds[a][3] != ds[b][3]\n            onn = Marshal.load(Marshal.dump(on))\n            onn[a].push(-1)\n            onn[b].push(-1)\n            onn.size.times do |i|\n                onn[i].delete(a)\n                onn[i].delete(b)\n            end\n            res = 2 + dfs(ds,onn)\n            max = res if res > max\n        end\n    end\n    return max\nend\nloop do\n    n = gets.to_i\n    break if n == 0\n    ds = n.times.map{gets.split.map(&:to_i)}\n    on = Array.new(n).map{Array.new}\n    ds.each_with_index do |d1, i|\n        (i+1).upto(n-1) do |j|\n            d2 = ds[j]\n            if overlap(d1,d2)\n                on[j].push(i)\n            end\n        end\n    end\n    p dfs(ds,on)\nend"
  },
  {
    "language": "Ruby",
    "code": "module Memoizable\n\tdef memoize(name)\n\t\toriginal = \"__original_#{name}__\"\n\t\t([Class, Module].include?(self.class) ? self : self.class).class_eval {\n\t\t\talias_method(original, name)\n\t\t\tprivate(original)\n\t\t\tcache = {}\n\t\t\tdefine_method(name){|*args|\n\t\t\t\tcache[args] ||= send(original, *args)\n\t\t\t}\n\t\t}\n\tend \nend\n\ninclude Memoizable\n\nrequire 'set'\n\ndef f(graph, color, taken)\n\theads = (0..graph.size-1).select {|i| !taken.include?(i) && graph[i].all? {|j| taken.include?(j)}}\n\tmax = 0\n\theads.combination(2) do |i, j|\n\t\tnext if color[i] != color[j]\n\t\tr = 2 + f(graph, color, taken + [i, j])\n\t\tmax = r if r > max\n\tend\n\tmax\nend\n\nmemoize :f\n\nloop do\n\tn = gets.to_i\n\tbreak if n == 0\n\tdisks = (1..n).map { gets.split.map(&:to_i)\t}\n\tcolor = disks.map(&:last)\n\tgraph = {}\n\t(disks.size-1).downto(0) do |i|\n\t\tgraph[i] = Set.new\n\t\tx1, y1, r1, c1 = disks[i]\n\t\t(0..i-1).each do |j|\n\t\t\tx2, y2, r2, c2 = disks[j]\n\t\t\tif (x1 - x2) ** 2 + (y1 - y2) ** 2 < (r1 + r2) ** 2\n\t\t\t\tgraph[i] << j\n\t\t\tend\n\t\tend\n\tend\n\tp f(graph, color, Set.new)\nend"
  },
  {
    "language": "Ruby",
    "code": "def d(u)(u.combination(2).map{|i,j|(@d[i][0]-@d[j][0])**2+(@d[i][1]-@d[j][1])**2<(@d[i][2]+@d[j][2])**2?i:-1}-[-1]).combination(2).map{|i,j|@d[i][3]==@d[j][3]?2+d(u-[i,j]):0}.max||0\nend\nwhile(@d=[];gets.to_i.times{@d<<gets.split.map(&:to_i)})>0\np d(Array 0...@d.size)\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_C = 4\n\n### subroutines\n\ndef overwrap?(dsk0, dsk1)\n  x0, y0, r0 = dsk0\n  x1, y1, r1 = dsk1\n  (x1 - x0) ** 2 + (y1 - y0) ** 2 < (r0 + r1) ** 2\nend\n\ndef count_rec(n, clrs, ovs, used)\n  max_cnt = 0\n\n  for ids in clrs\n    len = ids.length\n    for cid0 in (0...len)\n      id0 = ids[cid0]\n      next if used[id0] || ! ovs[id0].select{|id| ! used[id]}.empty?\n\n      for cid1 in ((cid0 + 1)...len)\n        id1 = ids[cid1]\n        next if used[id1] || ! ovs[id1].select{|id| ! used[id]}.empty?\n\n        used[id0] = used[id1] = true\n        cnt = 2 + count_rec(n, clrs, ovs, used)\n        used[id0] = used[id1] = false\n\n        max_cnt = cnt if max_cnt < cnt\n      end\n    end\n  end    \n  \n  max_cnt\nend\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  dsks = []\n  clrs = MAX_C.times.map{[]}\n  \n  for i in (0...n)\n    xi, yi, ri, ci = gets.split.map(&:to_i)\n    ci -= 1\n    dsk = [xi, yi, ri, ci]\n    dsks << dsk\n    clrs[ci] << i\n  end\n  #p dsks\n  #p clrs\n\n  ovs = n.times.map{[]}\n  \n  for i in (0...n)\n    dski = dsks[i]\n    for j in ((i + 1)...n)\n      dskj = dsks[j]\n      if overwrap?(dski, dskj)\n        ovs[j] << i\n      end\n    end\n  end\n  #p ovs\n\n  cnt = count_rec(n, clrs, ovs, n.times.map{false})\n  puts cnt\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef f(color, g)\n    tops = g.keys.select {|i| g[i].empty?}\n    cache = $memo[tops]\n    return cache if cache\n\n    min = g.keys.size\n    groups = tops.group_by {|i| color[i]}\n    groups.values.each do |group|\n        group.combination(2) do |i, j|\n            copy = g.map {|k, a| [k, a]}.to_h\n            copy.delete(i)\n            copy.keys.each {|k| copy[k].delete(i)}\n            copy.delete(j)\n            copy.keys.each {|k| copy[k].delete(j)}\n            m = f(color, copy)\n            min = m if m < min\n        end\n    end\n\n    $memo[tops] = min\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n\n    circles = []\n    color = []\n    n.times do\n        x, y, r, c = gets.split.map(&:to_i)\n        circles << [x, y, r]\n        color << c\n    end\n\n    g = {}\n    (0..n-1).each {|i| g[i] = Set.new}\n\n    (0..n-1).to_a.combination(2) do |i, j|\n        x1, y1, r1 = circles[i]\n        x2, y2, r2 = circles[j]\n        if Math.hypot(x1 - x2, y1 - y2) < r1 + r2\n            g[j] << i\n        end\n    end\n    \n    $memo = {}\n    p n - f(color, g)\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_C = 4\n\n### subroutines\n\ndef overwrap?(dsk0, dsk1)\n  x0, y0, r0 = dsk0\n  x1, y1, r1 = dsk1\n  (x1 - x0) ** 2 + (y1 - y0) ** 2 < (r0 + r1) ** 2\nend\n\ndef count_rec(n, clrs, ovs, used)\n  max_cnt = 0\n\n  \n  max_cnt\nend\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  dsks = []\n  clrs = MAX_C.times.map{[]}\n  ovs = n.times.map{0}\n  \n  for i in (0...n)\n    xi, yi, ri, ci = gets.split.map(&:to_i)\n    ci -= 1\n    dsk = [xi, yi, ri, ci]\n    dsks << dsk\n    clrs[ci] << i\n\n    for j in (0...i)\n      dskj = dsks[j]\n      if overwrap?(dskj, dsk)\n        ovs[i] |= (1 << j)\n      end\n    end\n  end\n  #p dsks\n  #p clrs\n  #p ovs\n\n  max_cnt = 0\n  st = (1 << n) - 1\n  dists = (0..st).map{-1}\n  dists[st] = 0\n  q = [st]\n\n  while ! q.empty?\n    ubits = q.shift\n    ud = dists[ubits]\n\n    max_cnt = ud if max_cnt < ud\n\n    nvd = ud + 2\n    \n    for ids in clrs\n      len = ids.length\n      for cid0 in (0...len)\n        id0 = ids[cid0]\n        bit0 = (1 << id0)\n        next if (ubits & bit0) == 0 || (ubits & ovs[id0]) != 0\n\n        for cid1 in ((cid0 + 1)...len)\n          id1 = ids[cid1]\n          bit1 = (1 << id1)\n          next if (ubits & bit1) == 0 || (ubits & ovs[id1]) != 0\n\n          vbits = ubits & ~(bit0 | bit1)\n          if dists[vbits] < 0\n            dists[vbits] = nvd\n            q << vbits\n          end\n        end\n      end\n    end\n  end\n\n  puts max_cnt\nend"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    while True:\n        n = I()\n        if n == 0:\n            break\n\n        a = [LI() for _ in range(n)]\n        s = [set() for _ in range(n)]\n        d = collections.defaultdict(list)\n        for i in range(n):\n            d[a[i][3]].append(i)\n            for j in range(i):\n                k = (a[i][0] - a[j][0]) ** 2 + (a[i][1] - a[j][1]) ** 2\n                l = (a[i][2] + a[j][2]) ** 2\n                if k < l:\n                    s[i].add(j)\n\n        ps = None\n        for v in d.values():\n            l = len(v) // 2\n            vs = set(map(lambda x: tuple(sorted([tuple(sorted([x[i*2], x[i*2+1]])) for i in range(l)])), itertools.permutations(v)))\n            vl = list(vs)\n            if ps is None:\n                ps = vl\n            else:\n                ps = list(map(lambda x: list(x[0]) + list(x[1]),itertools.product(ps,vl)))\n\n        r = 0\n        for pa in ps:\n            f = True\n            ts = set(range(n))\n            pas = set(pa)\n            tr = 0\n            while f:\n                f = False\n                for p in list(pas):\n                    if len(ts & s[p[0]]) == 0 and len(ts & s[p[1]]) == 0:\n                        ts.remove(p[0])\n                        ts.remove(p[1])\n                        pas.remove(p)\n                        f = True\n                        tr += 2\n            if r < tr:\n                r = tr\n\n        rr.append(r)\n\n    return '\\n'.join(map(str, rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "def xx(x):\n    return x * x\n    \ndef pop(overlaps, i, lis):\n    for k in lis:\n        if i > k and overlaps[i][k]: return False\n    return True\n\ndef search(disks, overlaps, lis):\n    if len(lis) < 2: return 0\n    res = 0\n    for i in lis:\n        if not pop(overlaps, i, lis): continue\n        #print(\"OK\", i)\n        for k in lis:\n            if i == k: continue\n            if disks[i][3] != disks[k][3]: continue\n            if not pop(overlaps, k, lis): continue\n            #print(\"Good\", k)\n            giv = list(lis)\n            giv.remove(i)\n            giv.remove(k)\n            res = max(res, 2 + search(disks, overlaps, giv))\n    return res\n\nwhile True:\n    n = int(input())\n    if n == 0: break\n    disks = [\n        list(map(int, input().split(\" \")))\n        for _ in range(n)\n    ]\n    \n    overlaps = []\n    for i in range(n):\n        res = []\n        for k in range(n):\n            a = disks[i]; b = disks[k]\n            res.append(xx(a[0] - b[0]) + xx(a[1] - b[1]) < xx(a[2] + b[2]))\n        overlaps.append(res)\n    #print(overlaps)\n\n    print(search(disks, overlaps, list(range(n))))\n          \n"
  }
]