[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Python",
    "code": "def solve(shuffled_str, substring):\n    n_length = len(shuffled_str) - len(str(len(shuffled_str) - len(substring)))\n    \n    def check_valid(num):\n        num_str = str(num)\n        if len(num_str) != n_length:\n            return False\n        \n        shuffled_chars = list(shuffled_str)\n        num_chars = list(num_str)\n        k_str = str(len(num_str))\n        k_chars = list(k_str)\n        \n        for char in num_chars + k_chars:\n            if char in shuffled_chars:\n                shuffled_chars.remove(char)\n        \n        return len(shuffled_chars) == 0\n    \n    def contains_substring(num):\n        return substring in str(num)\n    \n    smallest_n = float('inf')\n    for n in range(10 ** (n_length - 1), 10 ** n_length):\n        if contains_substring(n) and check_valid(n):\n            smallest_n = min(smallest_n, n)\n    \n    return smallest_n\n\nshuffled_str = input().strip()\nsubstring = input().strip()\nprint(solve(shuffled_str, substring))",
    "timestamp": "2025-08-05 17:32:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Python",
    "code": "from collections import defaultdict\n\ndef solve():\n    s = input().strip()\n    t = input().strip()\n    \n    count_s = defaultdict(int)\n    for c in s:\n        count_s[c] += 1\n    \n    count_t = defaultdict(int)\n    for c in t:\n        count_t[c] += 1\n    \n    # Subtract the counts of t from s to get the counts for the number and its length\n    for c in count_t:\n        count_s[c] -= count_t[c]\n        assert count_s[c] >= 0\n    \n    # The remaining digits form the number n and its length k (as digits)\n    # We need to find k such that the total digits is len(n) + len(str(len(n))) = len(s)\n    # The digits available are count_s\n    \n    # Try all possible k lengths\n    max_possible_k_length = min(len(str(10**6)), len(s))  # since len(n) <= 1e6 digits\n    \n    best_n = None\n    \n    for k_len in range(1, max_possible_k_length + 1):\n        remaining_length = len(s) - k_len\n        if remaining_length <= 0:\n            continue\n        \n        # The k is the number of digits in n, so k must be equal to remaining_length\n        k = remaining_length\n        k_str = str(k)\n        \n        # Check if the digits in k_str are available in count_s\n        temp_count = count_s.copy()\n        possible = True\n        for c in k_str:\n            if temp_count[c] <= 0:\n                possible = False\n                break\n            temp_count[c] -= 1\n        if not possible:\n            continue\n        \n        # Now, the digits for n are the remaining in temp_count (plus t's digits)\n        # We need to combine t and the remaining digits to form the smallest n\n        \n        # All digits in temp_count are part of n (along with t)\n        # To form the smallest n, we need to arrange all digits (from temp_count + t) in the smallest possible order\n        \n        # Collect all digits for n\n        digits_n = []\n        for c in temp_count:\n            digits_n.extend([c] * temp_count[c])\n        for c in count_t:\n            digits_n.extend([c] * count_t[c])\n        \n        digits_n.sort()\n        \n        # Now, construct the smallest n. It cannot start with 0 unless n is 0.\n        # Also, t must be a substring of n.\n        \n        # Case 1: t starts with '0'. Then n must start with '0' (but n can't have leading zeros unless it's 0)\n        # So if t starts with '0', n must be 0 followed by something, but since t is \"0\", n is 0\n        if t[0] == '0':\n            if len(digits_n) == 1 and digits_n[0] == '0':\n                candidate = '0'\n                if t in candidate:\n                    if best_n is None or candidate < best_n:\n                        best_n = candidate\n            continue\n        \n        # Find the smallest arrangement where t is a substring and no leading zeros\n        if not digits_n:\n            continue\n        \n        # The smallest n is built by placing the smallest possible digits first, but ensuring t is a substring\n        # and no leading zeros\n        \n        # The idea is to find the earliest position where t can be placed, with the remaining digits arranged as small as possible\n        \n        # The minimal n is either:\n        # 1. [smallest non-zero][other digits in order] with t inserted somewhere\n        # 2. t itself if it starts with the smallest non-zero and the rest can be arranged around it\n        \n        # Collect all digits (digits_n is already sorted)\n        # We need to use all digits_n + t's digits (but t is already included in digits_n via count_t)\n        \n        # The minimal n starts with the smallest non-zero digit, then the rest in order, inserting t where possible\n        \n        # Find the first non-zero digit in digits_n\n        first_non_zero = -1\n        for i in range(len(digits_n)):\n            if digits_n[i] != '0':\n                first_non_zero = i\n                break\n        \n        if first_non_zero == -1:\n            # All zeros. n must be 0\n            candidate = '0'\n            if t in candidate:\n                if best_n is None or candidate < best_n:\n                    best_n = candidate\n            continue\n        \n        # Construct the candidate\n        # The minimal n starts with digits_n[first_non_zero], then the remaining digits (including the rest of digits_n and t)\n        # But we need to ensure t is a substring\n        \n        # The best way is to merge the digits_n (sorted) with t, ensuring t is a substring\n        # The minimal n is to arrange digits_n in sorted order, and find the earliest position to place t\n        \n        # The digits available are digits_n (sorted) and t (which is already included in digits_n)\n        # So we can think of digits_n as the multiset of all digits in n\n        \n        # We need to arrange digits_n to form the smallest number that contains t as a substring\n        \n        # Approach:\n        # The minimal number is to find the earliest occurrence in the sorted digits where t can be inserted\n        \n        # Remove the digits of t from digits_n (since they are part of t)\n        # We already subtracted t's digits in count_t, so digits_n is the remaining digits\n        \n        # Now, the digits for n consist of digits_n (remaining) + t's digits (count_t)\n        # But digits_n already includes t's digits (since count_s was original s minus t, then we added back t via count_t)\n        # Wait, no: count_s was s minus t, then temp_count is count_s minus k_str's digits\n        # digits_n is temp_count's digits plus t's digits\n        \n        # So digits_n is all digits in n (including t's digits)\n        \n        # We need to arrange digits_n to form the smallest number that includes t as a substring\n        \n        # The minimal number is to find the smallest prefix before t, then t, then the remaining digits in order\n        \n        # To find the minimal n:\n        # 1. Find all possible positions to place t in the sorted digits_n, ensuring the remaining digits are arranged in order\n        # 2. The minimal n is the one where t is placed as early as possible, with the prefix being the smallest possible\n        \n        # To implement this:\n        # - Try to find the earliest occurrence of t's first character in digits_n that allows the entire t to be placed\n        # - Then arrange the remaining digits around it\n        \n        # The minimal n can be constructed by:\n        # - The smallest possible prefix (smallest digits, no leading zeros) followed by t, then the rest\n        # - Or t followed by the rest if t starts with the smallest possible digit\n        \n        # So the candidates are:\n        # 1. [smallest non-zero][other digits in order, but inserting t at earliest possible position]\n        # 2. t followed by the remaining digits in order\n        # 3. t preceded by some digits in order, but ensuring the entire number is minimal\n        \n        # Let's proceed by building the minimal candidate\n        \n        # Case 1: use the first non-zero as the first digit, then arrange the rest to include t\n        remaining_digits = digits_n.copy()\n        # Remove the first non-zero digit\n        first_char = remaining_digits.pop(first_non_zero)\n        \n        # Now, we have to arrange remaining_digits + t to form the smallest number, with t as a substring\n        # But remaining_digits are already sorted\n        \n        # The minimal arrangement is to find the earliest position where t can be inserted into remaining_digits\n        # So that the resulting string is minimal\n        \n        # Merge remaining_digits and t's digits to form the minimal string containing t as a substring\n        \n        # The optimal way is to find the earliest position in remaining_digits where t can be placed\n        # and the rest of the digits are as small as possible\n        \n        # The minimal candidate is [first_char] + (smallest string made from remaining_digits containing t)\n        \n        # To construct the smallest string from remaining_digits that contains t:\n        # We can try to find the earliest occurrence of t in the sorted remaining_digits\n        \n        # The minimal string is to find the leftmost occurrence of t's first character, then check if the subsequent characters match t\n        \n        # But since remaining_digits is sorted, t may not appear consecutively\n        \n        # Alternative approach: the minimal string is to place t at the earliest possible position where the rest can be arranged in order\n        \n        # So, the minimal candidate is:\n        # first_char + (remaining_digits arranged to include t as a substring, with the rest in order)\n        \n        # To find this, we can try to find the earliest position to insert t in remaining_digits such that the resulting string is minimal\n        \n        # The minimal candidate is first_char + merge_to_include_t(remaining_digits, t)\n        \n        def merge_to_include_t(sorted_digits, t):\n            # sorted_digits is sorted list of chars\n            # We need to find the smallest string that includes t as a substring, using all digits in sorted_digits and t\n            # But t is already included in sorted_digits (since digits_n includes t's digits)\n            \n            # So we can think of this as arranging sorted_digits to include t as a substring\n            \n            # The minimal string is to find the earliest occurrence where t can be placed in the sorted_digits\n            \n            # The minimal string is the lex smallest string that can be formed by inserting t into sorted_digits\n            \n            # The optimal way is to find the leftmost position where t can be inserted, and the rest are in order\n            \n            # The minimal string is the lex smallest between:\n            # - inserting t at the earliest possible position in sorted_digits\n            # - or placing t first if possible\n            \n            # We can try all possible positions to insert t into sorted_digits and pick the lex smallest\n            \n            min_str = None\n            t_len = len(t)\n            digits_str = ''.join(sorted_digits)\n            \n            # Try all possible insertion points\n            for i in range(len(sorted_digits) + 1):\n                candidate_str = digits_str[:i] + t + digits_str[i:]\n                # Check if this candidate uses the correct counts (i.e., contains exactly the digits in sorted_digits and t)\n                # But since digits_n includes t's digits, this should be fine\n                if min_str is None or candidate_str < min_str:\n                    min_str = candidate_str\n            \n            # Also consider cases where t is split across the insertion (but that's more complicated)\n            # For simplicity, we'll just consider inserting the entire t at some position\n            \n            return min_str\n        \n        merged = merge_to_include_t(remaining_digits, t)\n        candidate = first_char + merged\n        \n        if best_n is None or candidate < best_n:\n            best_n = candidate\n        \n        # Case 2: t starts with the smallest possible digit, so the minimal n might start with t\n        if t[0] == digits_n[first_non_zero]:\n            # The candidate could be t followed by the remaining digits in order\n            # Remove t's digits from digits_n\n            temp_digits = digits_n.copy()\n            t_list = list(t)\n            # Try to remove t's digits from temp_digits\n            # Since temp_digits is sorted, we can proceed in order\n            ptr = 0\n            t_ptr = 0\n            to_remove = []\n            # Use two pointers to find and mark the digits to remove (t's digits)\n            temp_t = list(t)\n            temp_t.sort()\n            temp_digits_sorted = temp_digits.copy()\n            temp_digits_sorted.sort()\n            t_ptr = 0\n            d_ptr = 0\n            to_remove = []\n            while t_ptr < len(temp_t) and d_ptr < len(temp_digits_sorted):\n                if temp_t[t_ptr] == temp_digits_sorted[d_ptr]:\n                    to_remove.append(d_ptr)\n                    t_ptr += 1\n                    d_ptr += 1\n                elif temp_t[t_ptr] < temp_digits_sorted[d_ptr]:\n                    # Missing a digit, not possible\n                    break\n                else:\n                    d_ptr += 1\n            else:\n                if t_ptr == len(temp_t):\n                    # Successfully found all t's digits in temp_digits_sorted\n                    # Remove the marked indices\n                    remaining_for_case2 = []\n                    remove_ptr = 0\n                    for i in range(len(temp_digits_sorted)):\n                        if remove_ptr < len(to_remove) and i == to_remove[remove_ptr]:\n                            remove_ptr += 1\n                        else:\n                            remaining_for_case2.append(temp_digits_sorted[i])\n                    candidate_case2 = t + ''.join(remaining_for_case2)\n                    if best_n is None or candidate_case2 < best_n:\n                        best_n = candidate_case2\n    \n    print(best_n)\n\nsolve()",
    "timestamp": "2025-08-05 17:34:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def restore_integer(received, remembered):\n    from collections import Counter\n\n    # Count all elements in the received string\n    count_received = Counter(received)\n\n    # Possible lengths for n\n    possible_lengths = []\n    for k in set(received):\n        num_count = Counter(received[:count_received[k]])\n        length = count_received[k] - num_count[k]\n        if str(length) in received:\n            possible_lengths.append(length)\n\n    smallest_n = None\n    for length in possible_lengths:\n        # Counts if matching the condition\n        cnt = dict(Counter(received))\n        cnt[str(length)] -= 1\n\n        substr_condition = Counter(remembered)\n        if all(substr_condition[digit] <= cnt.get(digit, 0) for digit in remembered):\n            # Try to generate the smallest valid number n\n            digits = []\n            for digit in \"0123456789\":\n                digits.extend([digit] * min(cnt.get(digit, 0), substr_condition.get(digit, 0)))\n\n            length_remaining = length - len(digits)\n            if length_remaining >= 0:\n                # Add remaining digits\n                for digit in \"0123456789\":\n                    if digit > '0':  # skip leading zeros unless n is zero itself\n                        digits.extend([digit] * (cnt[digit] - substr_condition.get(digit, 0)))\n                # Attempt at forming the smallest n\n                candidate = int(''.join(sorted(digits)))\n                if candidate < int(''.join(received)):\n                    if smallest_n is None or candidate < smallest_n:\n                        smallest_n = candidate\n\n    return smallest_n\n\n# Input reading\nimport sys\ninput = sys.stdin.read\nreceived, remembered = input().split()\nprint(restore_integer(received, remembered))",
    "timestamp": "2025-08-12 21:54:29"
  }
]