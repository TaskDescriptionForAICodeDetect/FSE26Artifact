[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool isPeriodic(char* str, int len, int period) {\n    for (int i = 0; i < len - period; i++) {\n        if (str[i] != str[i + period]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool canMakePeriodic(char* str, int l, int r, int period) {\n    int mismatchCount = 0;\n    int n = r - l + 1;\n    \n    for (int i = 0; i < n - period; i++) {\n        if (str[l + i] != str[l + i + period]) {\n            mismatchCount++;\n            \n            if (mismatchCount > 1) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    char S[100005];\n    int Q, l, r, t;\n    \n    scanf(\"%s\", S);\n    scanf(\"%d\", &Q);\n    \n    while (Q--) {\n        scanf(\"%d %d %d\", &l, &r, &t);\n        l--; r--;  // 0-based indexing\n        \n        if (canMakePeriodic(S, l, r, t)) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:53:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAXN 100000\n\nint prefix[MAXN + 1][26];\n\nint main() {\n    char S[MAXN + 1];\n    int Q;\n    scanf(\"%s\", S);\n    scanf(\"%d\", &Q);\n    int n = strlen(S);\n\n    for (int i = 0; i < n; ++i) {\n        for (int c = 0; c < 26; ++c) {\n            prefix[i + 1][c] = prefix[i][c] + (S[i] == 'a' + c);\n        }\n    }\n\n    while (Q--) {\n        int l, r, t;\n        scanf(\"%d %d %d\", &l, &r, &t);\n        l--; // convert to 0-based\n\n        if (t >= r - l) {\n            printf(\"YES\\n\");\n            continue;\n        }\n\n        int len = r - l;\n        int groups = len / t;\n        int rem = len % t;\n        int possible = 0;\n\n        for (int c = 0; c < 26 && !possible; ++c) {\n            int total = 0;\n            for (int k = 0; k < t; ++k) {\n                int group_k = (k < rem) ? groups + 1 : groups;\n                int cnt = prefix[l + k + 1 * group_k][c] - prefix[l + k][c];\n                // The above line is incorrect, need to fix the calculation\n                // Correct approach: for each position congruent to k mod t, count the occurrences of c\n                // Let's re-calculate properly\n                cnt = 0;\n                for (int pos = l + k; pos < r; pos += t) {\n                    if (S[pos] == 'a' + c) {\n                        cnt++;\n                    }\n                }\n                total += group_k - cnt;\n            }\n            if (total <= 1) {\n                possible = 1;\n            }\n        }\n        printf(possible ? \"YES\\n\" : \"NO\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:54:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nint prefix[MAXN][26];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    string S;\n    cin >> S;\n    int N = S.size();\n\n    for (int i = 0; i < N; ++i) {\n        for (int c = 0; c < 26; ++c) {\n            prefix[i + 1][c] = prefix[i][c] + (S[i] - 'a' == c);\n        }\n    }\n\n    int Q;\n    cin >> Q;\n    while (Q--) {\n        int l, r, t;\n        cin >> l >> r >> t;\n        l--; r--;\n\n        if (t >= r - l + 1) {\n            cout << \"YES\\n\";\n            continue;\n        }\n\n        int total_groups = (r - l + 1) / t;\n        int rem = (r - l + 1) % t;\n\n        bool possible = false;\n        for (int c = 0; c < 26 && !possible; ++c) {\n            int cnt = 0;\n            for (int k = 0; k < t; ++k) {\n                int group_len = total_groups + (k < rem ? 1 : 0);\n                int current = prefix[l + k + group_len * t][c] - prefix[l + k][c];\n                cnt += group_len - current;\n                if (cnt > 1) break;\n            }\n            if (cnt <= 1) possible = true;\n        }\n\n        cout << (possible ? \"YES\" : \"NO\") << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:54:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\n\npublic class PeriodicSubstringChecker {\n    static int[][] prefixCount;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        String S = br.readLine();\n        int n = S.length();\n        prefixCount = new int[n + 1][26];\n        for (int i = 1; i <= n; i++) {\n            System.arraycopy(prefixCount[i - 1], 0, prefixCount[i], 0, 26);\n            prefixCount[i][S.charAt(i - 1) - 'a']++;\n        }\n\n        int Q = Integer.parseInt(br.readLine());\n        while (Q-- > 0) {\n            String[] query = br.readLine().split(\" \");\n            int l = Integer.parseInt(query[0]) - 1;\n            int r = Integer.parseInt(query[1]) - 1;\n            int t = Integer.parseInt(query[2]);\n\n            if (t >= (r - l + 1)) {\n                bw.write(\"YES\\n\");\n                continue;\n            }\n\n            int groups = (r - l + 1) / t;\n            int remainder = (r - l + 1) % t;\n            int totalErrors = 0;\n\n            for (int i = 0; i < t; i++) {\n                int maxFreq = 0;\n                int totalChars = 0;\n                for (int j = 0; j < groups; j++) {\n                    int pos = l + j * t + i;\n                    if (pos > r) break;\n                    totalChars++;\n                }\n                if (i < remainder) {\n                    int pos = l + groups * t + i;\n                    if (pos <= r) {\n                        totalChars++;\n                    }\n                }\n                if (totalChars == 0) continue;\n\n                int start = l + i;\n                int end = l + groups * t + i;\n                if (end > r) end = r;\n                else if (i < remainder) end++;\n\n                for (int c = 0; c < 26; c++) {\n                    int cnt = prefixCount[end + 1][c] - prefixCount[start][c];\n                    if (cnt > maxFreq) {\n                        maxFreq = cnt;\n                    }\n                }\n                totalErrors += totalChars - maxFreq;\n                if (totalErrors > 1) break;\n            }\n\n            if (totalErrors <= 1) {\n                bw.write(\"YES\\n\");\n            } else {\n                bw.write(\"NO\\n\");\n            }\n        }\n\n        bw.flush();\n        bw.close();\n        br.close();\n    }\n}",
    "timestamp": "2025-08-05 21:54:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class PeriodicStringQueries {\n    public static void solve(String S, int Q, int[] l, int[] r, int[] t) {\n        PrintWriter out = new PrintWriter(System.out);\n        \n        for (int q = 0; q < Q; q++) {\n            int left = l[q], right = r[q], period = t[q];\n            String substr = S.substring(left, right + 1);\n            \n            if (isPossiblePeriodic(substr, period)) {\n                out.println(\"YES\");\n            } else {\n                out.println(\"NO\");\n            }\n        }\n        \n        out.close();\n    }\n    \n    private static boolean isPossiblePeriodic(String substr, int period) {\n        int n = substr.length();\n        \n        // Check if substring length is smaller than period\n        if (n < period) return false;\n        \n        // Try changing each character\n        for (int changeIndex = 0; changeIndex < n; changeIndex++) {\n            for (char newChar = 'a'; newChar <= 'z'; newChar++) {\n                StringBuilder modified = new StringBuilder(substr);\n                modified.setCharAt(changeIndex, newChar);\n                \n                if (checkPeriodic(modified.toString(), period)) {\n                    return true;\n                }\n            }\n        }\n        \n        // If no change works, check original string\n        return checkPeriodic(substr, period);\n    }\n    \n    private static boolean checkPeriodic(String s, int period) {\n        for (int i = 0; i < s.length() - period; i++) {\n            if (s.charAt(i) != s.charAt(i + period)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        \n        // Input parsing\n        String S = br.readLine();\n        int Q = Integer.parseInt(br.readLine());\n        \n        int[] l = new int[Q];\n        int[] r = new int[Q];\n        int[] t = new int[Q];\n        \n        for (int i = 0; i < Q; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            l[i] = Integer.parseInt(st.nextToken()) - 1;\n            r[i] = Integer.parseInt(st.nextToken()) - 1;\n            t[i] = Integer.parseInt(st.nextToken());\n        }\n        \n        solve(S, Q, l, r, t);\n    }\n}",
    "timestamp": "2025-08-05 21:55:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool is_periodic(const string& s, int period) {\n    for (int i = 0; i < s.length() - period; ++i) {\n        if (s[i] != s[i + period]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool solve_query(string s, int l, int r, int period) {\n    // Check if already periodic\n    if (is_periodic(s.substr(l, r - l + 1), period)) {\n        return true;\n    }\n    \n    // Try changing each character\n    for (int i = l; i <= r; ++i) {\n        char original = s[i];\n        for (char c = 'a'; c <= 'z'; ++c) {\n            if (c == original) continue;\n            s[i] = c;\n            if (is_periodic(s.substr(l, r - l + 1), period)) {\n                return true;\n            }\n        }\n        s[i] = original;\n    }\n    \n    return false;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    string S;\n    int Q;\n    cin >> S >> Q;\n    \n    while (Q--) {\n        int l, r, t;\n        cin >> l >> r >> t;\n        \n        // Convert to 0-based indexing\n        l--; r--;\n        \n        cout << (solve_query(S, l, r, t) ? \"Yes\" : \"No\") << '\\n';\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:55:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_pseudo_periodic(S, queries):\n    def check_period(substring, t):\n        n = len(substring)\n        # Define a lambda function to check periodicity\n        is_periodic = lambda x: all(substring[i] == substring[i + x] for i in range(n - x))\n        if is_periodic(t):\n            return True\n        \n        # Try changing one character\n        for i in range(n):\n            original_char = substring[i]\n            # Check periodicity for each character change\n            for j in range(n):\n                if j != i and substring[j] != original_char:\n                    temp_list = list(substring)\n                    temp_list[i] = substring[j]  # Change character\n                    if is_periodic(t, temp_list):\n                        return True\n            substring[i] = original_char  # Revert the change\n        return False\n    \n    results = []\n    for l_i, r_i, t_i in queries:\n        results.append(check_period(S[l_i-1:r_i], t_i))\n    return results\n\n# Example usage:\nS = \"abacabadabacaba\"\nqueries = [(1, 5, 2), (1, 5, 3), (8, 13, 4)]\nprint(is_pseudo_periodic(S, queries))",
    "timestamp": "2025-08-13 08:02:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class PeriodicStringChecker {\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        String S = sc.nextLine();\n        int Q = sc.nextInt();\n        \n        for (int q = 0; q < Q; q++) {\n            int l = sc.nextInt() - 1;\n            int r = sc.nextInt() - 1;\n            int t = sc.nextInt();\n            \n            boolean result = checkPeriodic(S, l, r, t);\n            System.out.println(result ? \"Yes\" : \"No\");\n        }\n        \n        sc.close();\n    }\n    \n    private static boolean checkPeriodic(String s, int l, int r, int t) {\n        int length = r - l + 1;\n        \n        if (t > length) {\n            return false;\n        }\n        \n        int[] differenceCount = new int[t];\n        \n        for (int i = l; i <= r; i++) {\n            int shiftedIndex = (i - l) % t;\n            if (s.charAt(i) != s.charAt(l + shiftedIndex)) {\n                differenceCount[shiftedIndex]++;\n            }\n        }\n        \n        int maxDifferences = Arrays.stream(differenceCount).max().orElse(0);\n        \n        return maxDifferences <= 1;\n    }\n}",
    "timestamp": "2025-08-13 08:02:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool isPeriodicWithChange(char *s, int l, int r, int t) {\n    int length = r - l + 1;\n    int mismatchCount = 0;\n    \n    for (int i = l; i < r - t + 1; ++i) {\n        if (s[i] != s[i + t]) {\n            mismatchCount++;\n            if (mismatchCount > 1) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    char S[100005];\n    int Q;\n    \n    scanf(\"%s\", S);\n    scanf(\"%d\", &Q);\n    \n    while (Q--) {\n        int l, r, t;\n        scanf(\"%d %d %d\", &l, &r, &t);\n        // Convert to 0-based index for internal processing\n        l--; r--;\n        \n        if (isPeriodicWithChange(S, l, r, t)) {\n            printf(\"Yes\\n\");\n        } else {\n            printf(\"No\\n\");\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 08:02:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_periodic(s, period):\n    n = len(s)\n    for i in range(n - period):\n        if s[i] != s[i + period]:\n            return False\n    return True\n\ndef can_make_periodic(s, l, r, period):\n    substring = s[l:r+1]\n    n = len(substring)\n    \n    if n % period != 0:\n        return False\n    \n    # Try changing each character to make it periodic\n    for change_pos in range(n):\n        for new_char in set(substring):\n            modified = list(substring)\n            modified[change_pos] = new_char\n            modified = ''.join(modified)\n            \n            if is_periodic(modified, period):\n                return True\n    \n    # Check if original substring is already periodic\n    if is_periodic(substring, period):\n        return True\n    \n    return False\n\ndef solve(S, queries):\n    results = []\n    \n    for l, r, period in queries:\n        result = can_make_periodic(S, l-1, r-1, period)\n        results.append('Yes' if result else 'No')\n    \n    return results\n\n# Example usage\nS = input().strip()\nQ = int(input())\nqueries = []\n\nfor _ in range(Q):\n    l, r, t = map(int, input().split())\n    queries.append((l, r, t))\n\nresults = solve(S, queries)\nfor result in results:\n    print(result)",
    "timestamp": "2025-08-13 08:02:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    S = input[ptr]\n    ptr += 1\n    Q = int(input[ptr])\n    ptr += 1\n    n = len(S)\n    \n    # Precompute prefix sums for each character and each possible mod t (up to sqrt(n))\n    max_t = int(n**0.5) + 2\n    prefix = [ [ [0]*(n+1) for _ in range(t) ] for t in range(max_t+1) ]\n    \n    for t in range(1, max_t+1):\n        for mod in range(t):\n            for i in range(1, n+1):\n                c = 1 if (i-1) % t == mod else 0\n                prefix[t][mod][i] = prefix[t][mod][i-1] + (1 if S[i-1] == S[mod] else 0)\n    \n    output = []\n    for _ in range(Q):\n        l = int(input[ptr]) - 1\n        r = int(input[ptr+1]) - 1\n        t = int(input[ptr+2])\n        ptr += 3\n        length = r - l + 1\n        if t >= length:\n            output.append(\"YES\")\n            continue\n        \n        if t <= max_t:\n            # Use precomputed data\n            mod = l % t\n            cnt = prefix[t][mod][r+1] - prefix[t][mod][l]\n            if cnt >= length - 1:\n                output.append(\"YES\")\n            else:\n                output.append(\"NO\")\n        else:\n            # Brute force check\n            ok = True\n            mismatch = 0\n            first_char = S[l]\n            for i in range(l, r+1):\n                expected_char = S[l + (i - l) % t]\n                if S[i] != expected_char:\n                    mismatch += 1\n                    if mismatch > 1:\n                        ok = False\n                        break\n            if ok:\n                output.append(\"YES\")\n            else:\n                output.append(\"NO\")\n    \n    print('\\n'.join(output))\n\nsolve()",
    "timestamp": "2025-08-13 08:02:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nbool isPeriodicWithOneChange(const std::string& s, int l, int r, int t) {\n    int n = r - l + 1;\n    int diffCount = 0;\n\n    for (int i = 0; i < n - t; ++i) {\n        if (s[l + i] != s[l + i + t]) {\n            ++diffCount;\n        }\n    }\n\n    return diffCount <= 1;\n}\n\nint main() {\n    std::string S;\n    int Q;\n    std::cin >> S >> Q;\n\n    while (Q--) {\n        int l, r, t;\n        std::cin >> l >> r >> t;\n        --l; // Convert to 0-based index\n        --r; // Convert to 0-based index\n\n        if (isPeriodicWithOneChange(S, l, r, t)) {\n            std::cout << \"YES\\n\";\n        } else {\n            std::cout << \"NO\\n\";\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:42:58"
  }
]