[
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\n// 1-indexed\nclass rolling_hash {\npublic:\n    rolling_hash(std::string const& s)\n        : n(s.size()),\n          mod({999999937LL, 1000000007LL})\n    {\n        for(int i = 0; i < 2; ++i) {\n            hs[i].resize(n + 1);\n            p[i].resize(n + 1);\n            hs[i][0] = 0;\n            p[i][0] = 1;\n            for(int j = 0; j < n; ++j) {\n                hs[i][j + 1] = (hs[i][j] * base + s[j]) % mod[i];\n                p[i][j + 1] = p[i][j] * base % mod[i];\n            }\n        }\n    }\n\n    // s[i...]\n    long long query(int idx, int i) const {\n        return hs[i][idx];\n    }\n    // s[l + 1...r]\n    long long query(int l, int r, int i) const {\n        return ((hs[i][r] - hs[i][l] * p[i][r - l]) % mod[i] + mod[i]) % mod[i];\n    }\n\n    long long query(int l, int r, int idx, char before, char after) {\n        long long res = query(l, r, 0);\n        if(idx <= l || r < idx) {\n            return res;\n        }\n        res = (res - (before - after) * p[0][r - idx]) % mod[0];\n        res = (res + mod[0]) % mod[0];\n        return res;\n    }\n\nprivate:\n    int n;\n    std::vector<long long> hs[2];\n    std::vector<long long> p[2];\n\n    const std::array<long long, 2> mod;\n    static const long long base = 29LL;\n};\n\n\nint main() {\n    string S;\n    cin >> S;\n    rolling_hash hs(S);\n    int Q;\n    cin >> Q;\n    while(Q--) {\n        int l, r, t;\n        cin >> l >> r >> t;\n        if(hs.query(l - 1, r - t, 0) == hs.query(l + t - 1, r, 0)) {\n            cout << \"Yes\" << endl;\n        } else {\n            int lb = 0, ub = r - l + 1 - t;\n            while(ub - lb > 1) {\n                int m = (lb + ub) / 2;\n                if(hs.query(l - 1 + m, r - t, 0) != hs.query(l + t - 1 + m, r, 0)) {\n                    lb = m;\n                } else {\n                    ub = m;\n                }\n            }\n\n            char before1 = S[l + t - 1 + lb];\n            char after1 = S[l - 1 + lb];\n            char before2 = S[l - 1 + lb];\n            char after2 = S[l - 1 + lb + t];\n            if(hs.query(l + t - 1, r, l + t + lb, before1, after1) == hs.query(l - 1, r - t, l + t + lb, before1, after1)\n                || hs.query(l + t - 1, r, l + lb, before2, after2) == hs.query(l - 1, r - t, l + lb, before2, after2)) {\n                cout << \"Yes\" << endl;\n            } else {\n                cout << \"No\" << endl;\n            }\n            //cout << \"bef1: \" << before1 << \" aft1: \" << after1 << endl;\n            //cout << \"bef2: \" << before2 << \" aft2: \" << after2 << endl;\n            //cout << \"idx1: \" << l + t + lb << endl;\n            //cout << \"idx2: \" << l + lb << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nconst ull B = 1777771;\null PB[100001];\null S[100001];\nstring str;\n\null get(int l,int r){return S[r]-S[l]*PB[r-l];}\null get(int l,int r,int x,char ch){\n  ull res=get(l,r);\n  if(x<l||r<=x) return res;\n  res-=str[x]*PB[r-x-1];\n  res+=ch*PB[r-x-1];\n  return res;\n}\n\n\nint search(int a,int b,int x,int ch){\n  int L=0,M,R=str.size();\n  while(L<R){\n    M = (L+R)/2;\n    if(get(a,a+M,x,ch)!=get(b,b+M,x,ch)) R = M;\n    else L = M+1;\n  }\n  return L;\n}\n\n\nbool check(int l,int r,int t){\n  int x = min(r,l+t+search(l,l+t,-1,0));\n  if(--x==r)return 0;\n  return min(r+1,l+t+search(l,l+t,x,str[l+(x-l-t)%t])) == r+1;\n}\n\nint main(){\n  cin>>str;\n  for(int i=0;i<(int)str.size();i++) S[i+1]=S[i]*B+str[i];\n  PB[0]=1;\n  for(int i=01;i<=(int)str.size();i++) PB[i]=PB[i-1]*B;\n  int q;\n  cin>>q;\n  while(q--){\n    int l,r,t;\n    cin>>l>>r>>t;l--;\n    cout<<(check(l,r,t)? \"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef unsigned long long ull;\n\nconst ull M=(1e9+7);\n\nstring s;\nint q;\null H[N], D[N];\n\nvoid cal_hash(){\n  ull h=0;\n  for(int i=0;i<s.size();i++){\n    h=h*M+s[i];\n    H[i+1]=h;\n  }\n  h=1;\n  for(int i=0;i<N;i++){\n    D[i]=h;\n    h*=M;\n  }\n  s='X'+s;\n}\n\nint get_first_diff_idx(int l, int r, int t){\n  \n  int L=0, R=r-l-t+2;\n  \n  while(L<R){\n    \n    int Mid=(L+R)/2;\n    ull v1=H[l+Mid]-H[l-1]*D[Mid+1];\n    ull v2=H[l+Mid+t]-H[l+t-1]*D[Mid+1];\n    \n    if(v1==v2) L=Mid+1;\n    else R=Mid;\n  }\n  \n  return L;\n}\n\nbool isSame(int l, int r, int t, int A, int B){\n  \n  int i1=l+t, i2=r;\n  ull h1, h2;\n  \n  if(i1<=A&&A<=i2){\n    \n    if(i1<A&&A<i2) h1=H[i2]+((H[A-1]-H[i1-1]*D[A-i1])*D[1]+s[B])*D[i2-A];\n    else if(A==i1) h1=H[i2]-H[i1]*D[i2-i1]+s[B]*D[i2-i1];\n    else if(A==i2) h1=s[B]+(H[i2-1]-H[i1-1]*D[i2-i1])*D[1];\n    \n  }else h1=H[i2]-H[i1-1]*D[i2-i1+1];\n  \n  i1=l, i2=r-t;\n  \n  if(i1<=A&&A<=i2){\n    \n    if(i1<A&&A<i2) h2=H[i2]+((H[A-1]-H[i1-1]*D[A-i1])*D[1]+s[B])*D[i2-A];\n    else if(A==i1) h2=H[i2]-H[i1]*D[i2-i1]+s[B]*D[i2-i1];\n    else if(A==i2) h2=s[B]+(H[i2-1]-H[i1-1]*D[i2-i1])*D[1];\n    \n  }else h2=H[i2]-H[i1-1]*D[i2-i1+1];\n  \n  return h1==h2;\n}\n\nbool check(int l, int r, int t){\n  \n  /*if((r-l+1)%t!=0) return false;\n    if((r-l+1)==t) return true;*/\n  \n  int idx=get_first_diff_idx(l, r, t);\n\n  int i1=l+idx, i2=l+t+idx;\n  cout<<idx<<endl;\n  return isSame(l, r, t, i1, i2) | isSame(l, r, t, i2, i1);\n}\n\nint main(){\n  \n  cin>>s;\n  \n  cal_hash();\n  \n  cin>>q;\n  \n  int l, r, t;\n  \n  for(int i=0;i<q;i++){\n    scanf(\"%d %d %d\", &l, &r, &t);\n    if(check(l, r, t)) printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 100009, mul1 = 1000007;\n\tstatic const ll add0 = 10000120007, add1 = 10032333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tstring filename = \"1340-out1.txt\";\n\tifstream read_file(\"D:/D_Download/Visual Studio 2015/Projects/programing_contest_c++/Debug/1340-out1.txt\");\n\tstring ast;\n\tvector<int>anss;\n\twhile (read_file >>ast) {\n\t\tanss.push_back(ast== \"Yes\");\n\t\t\n\t}\n\tread_file.close();\n\t\n\tcin >> st;\n\trh.init(st);\n\tmap<char, int>mp;\n\tfor (auto c : st)mp[c]++;\n\tint N; cin >> N;\n\tint num = -1;\n\twhile (N--) {\n\t\tnum++;\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\tif (L == 43245 && R == 50827 && T == 2190) {\n\t\t\tint a = 0; a++;\n\n\t\t}\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tif (L + nt * 3 + p <= R)ok = false;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L, L + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(rsame){\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L, L + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassert(issame(L, L + nt, nt - 1).first);\n\t\t\t}\n\t\t}\n\t\tassert(ok==anss[num]);\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=575;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  assert(b-a==r-l);\n\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  assert(b-a==r-l);\n\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n\n  if ( calc(l+as,r-t ,l+as+t,r) && (   eq(l,l+as,r-t,r-t+as) ||   eq(l,l+as,r-t-t,r-t-t+as) ) )\n  if (   eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-t,r-t+as) || calc(l,l+as,r-t-t,r-t-t+as) ) )\n\n  if ( calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) ) )\n  if ( eq(l,r-as-t ,l+t,r-as) && ( calc(l,l+as,r-as,r) || calc(l+t,l+t+as,r-as,r) ) )return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n\n  for(int i=0;i<n;i++){\n    s[i]+=19;\n  }\n\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  assert(b-a==r-l);\n\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  assert(b-a==r-l);\n\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n\n  //  if ( calc(l+as,r-t ,l+as+t,r) && ( eq(l,l+as,r-t,r-t+as) || eq(l,l+as,r-t-t,r-t-t+as) ) )return true;\n  if ( eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-t,r-t+as) || calc(l,l+as,r-t-t,r-t-t+as) ) )return true;\n\n  if ( calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) ) )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && ( calc(l,l+as,r-as,r) || calc(l+t,l+t+as,r-as,r) ) )return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n\n  for(int i=0;i<n;i++){\n    s[i]+=19;\n  }\n\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned __int128 Hash;\n\n// h[x] = str[0..x)\nvector<Hash> diffs;\n\nHash h[100010];\nHash p[100010];\nHash w = 9001;\n\n// [l,r)\nHash substr(int l,int r){\n\treturn h[r] - h[l] * p[r-l];\n}\nHash concat(Hash a,Hash b,int blen){\n\treturn a * p[blen] + b;\n}\n\nHash makestr(int l,int r,int t){\n\tint len = r - l;\n\tint Q = len / t;\n\tint R = len % t;\n\tHash res = 0;\n\n\tif( l + t <= r ){\n\n\t\tHash x = substr(l,l+t);\n\t\tint xlen = t;\n\t\n\t\tfor(int i = 0 ; xlen <= len ; i++){\n\t\t\tif( Q >> i & 1 ){\n\t\t\t\tres = concat(res,x,xlen);\n\t\t\t}\n\n\t\t\tx = concat(x,x,xlen);\n\t\t\txlen *= 2;\n\t\t}\n\t}\n\n\tres = concat(res,substr(l,l+R),R);\n\t//cout << res << endl;\n\treturn res;\t\n}\n\n\nHash makestr2(int l,int r,int t){\n\tint len = r - l;\n\tint Q = len / t;\n\tint R = len % t;\n\tint xlen = t;\n\tHash x = substr(l+t,l+2*t);\n\tHash res = 0;\n\tfor(int i = 0 ; xlen <= len ; i++){\n\t\tif( Q >> i & 1 ){\n\t\t\tres = concat(res,x,xlen);\n\t\t}\n\n\t\tx = concat(x,x,xlen);\n\t\txlen *= 2;\n\t}\n\n\tres = concat(res,substr(l,l+R),R);\n\t//cout << res << endl;\n\treturn res;\t\n}\n\n\nint main(){\n\tp[0] = 1;\n\tfor(int i = 1 ; i <= 100000 ; i++)\n\t\tp[i] = p[i-1] * w;\n\tstring S;\n\tcin >> S;\n\th[0] = 0;\n\tfor(int i = 0 ; i < S.size() ; i++){\n\t\th[i+1] = h[i] * w + S[i];\n\t}\n\n\t\n\tdiffs.push_back(0);\n\tfor(char c =0 ; c < 26 ; c++){\n\t\tfor(int i = 0 ; i < 100000 ; i++){\n\t\t\tdiffs.push_back(c*p[i]);\n\t\t\tdiffs.push_back(-c*p[i]);\n\t\t}\n\t}\n\tsort(diffs.begin(),diffs.end());\n\t\n\t\n\tint Q;\n\tcin >> Q;\n\n\tfor(int i = 0 ; i < Q ; i++){\n\t\tint l,r,t;\n\t\tcin >> l >> r >> t;\n\t\t--l;\n\t\t//cout << substr(l,r) - makestr(l,r,t)<< endl;\n\t\t\n\t\tif( binary_search(diffs.begin(),diffs.end(), makestr(l,r,t) - substr(l,r) ) ){\n\t\t\tcout << \"Yes\" << endl;\n\t\t\t\n\t\t}else if( l+2*t <= S.size() and binary_search(diffs.begin(),diffs.end(), makestr2(l,r,t) - substr(l,r) ) ){\n\t\t\t\tcout << \"Yes\" << endl;\n\t\t}else{\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=57577;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n  //  calc(l+as,r-t,l+as+t,r);\n\n  if ( calc(l+as,r-t ,l+as+t,r) && (eq(l,l+as,r-as,r) ||eq(l,l+as,r-as-t,r-t) ) )return true;\n  if ( eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-as,r) || calc(l,l+as,r-as-t,r-t) ) )return true;\n\n  if ( calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) ) )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && ( calc(l,l+as,r-as,r) || calc(l+t,l+t+as,r-as,r) ) )return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n\tvoid change_st(const int index, const ll from, const ll to)const {\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans = ar - al;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(1, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt / 2,L+nt, nt / 2 - 1).first;;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > R) {\n\t\t\t\t\t\t\t\trsame = true;\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trsame = getha(l3, r3) == getha(l4, r4);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  assert(b-a==r-l);\n\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  assert(b-a==r-l);\n\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n  /*\n  if (( calc(l+as,r-t ,l+as+t,r) && (   eq(l,l+as,r-t,r-t+as) ||   eq(l,l+as,r-t-t,r-t-t+as) ) ) ||\n       (eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-t,r-t+as) || calc(l,l+as,r-t-t,r-t-t+as) )) )\n  */\n\n  if(eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-t,r-t+as) || calc(l,l+as,r-t-t,r-t-t+as) )){\n\n    if ( (calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) )) ||\n           ( eq(l,r-as-t ,l+t,r-as) && ( calc(l,l+as,r-as,r) || calc(l+t,l+t+as,r-as,r) ) )\n           )return true;\n\n  }\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n\n  for(int i=0;i<n;i++){\n    s[i]+=19;\n  }\n\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n//#define M 1e9+7\n#define M 1777771\nusing namespace std;\ntypedef unsigned long long ull;\n\nstring s;\nint q;\null H[N], D[N];\n\nvoid cal_hash(){\n  ull h=0;\n  for(int i=0;i<s.size();i++){\n    h=h*M+s[i];\n    H[i+1]=h;\n  }\n  h=1;\n  for(int i=0;i<N;i++){\n    D[i]=h;\n    h*=M;\n  }\n  s='X'+s;\n}\n\nint get_first_diff_idx(int l, int r, int t){\n  \n  int L=0, R=r-l-t+2;\n  \n  while(L<R){\n    \n    int Mid=(L+R)/2;\n    ull v1=H[l+Mid]-H[l-1]*D[Mid+1];\n    ull v2=H[l+Mid+t]-H[l+t-1]*D[Mid+1];\n    cout<<v1<<' '<<v2<<endl;\n    if(v1==v2) L=Mid+1;\n    else R=Mid;    \n  }\n  \n  return L;\n}\n\nbool isSame(int l, int r, int t, int A, int B){\n  \n  int i1=l, i2=r-t;\n  ull h1, h2;\n  \n  if(i1<=A&&A<=i2){\n    \n    if(i1<A&&A<i2) h1=H[i2]+((H[A-1]-H[i1-1]*D[A-i1])*D[1]+s[B])*D[i2-A];\n    else if(A==i1) h1=H[i2]-H[i1]*D[i2-i1]+s[B]*D[i2-i1];\n    else if(A==i2) h1=s[B]+(H[i2-1]-H[i1-1]*D[i2-i1])*D[1];\n    \n  }else h1=H[i2]-H[i1-1]*D[i2-i1+1];\n  \n  i1=l+t, i2=r;\n  \n  if(i1<=B&&B<=i2){\n    \n    if(i1<B&&B<i2) h2=H[i2]+((H[B-1]-H[i1-1]*D[B-i1])*D[1]+s[A])*D[i2-B];\n    else if(B==i1) h2=H[i2]-H[i1]*D[i2-i1]+s[A]*D[i2-i1];\n    else if(B==i2) h2=s[A]+(H[i2-1]-H[i1-1]*D[i2-i1])*D[1];\n    \n  }else h2=H[i2]-H[i1-1]*D[i2-i1+1];\n  \n  return h1==h2;\n}\n\nbool check(int l, int r, int t){\n  \n  /*if((r-l+1)%t!=0) return false;\n    if((r-l+1)==t) return true;*/\n  \n  int idx=get_first_diff_idx(l, r, t);\n\n  int i1=l+idx, i2=l+t+idx;\n  cout<<idx<<endl;\n  return isSame(l, r, t, i1, i2) | isSame(l, r, t, i2, i1);\n}\n\nint main(){\n  \n  cin>>s;\n  \n  cal_hash();\n  \n  cin>>q;\n  \n  int l, r, t;\n  \n  for(int i=0;i<q;i++){\n    scanf(\"%d %d %d\", &l, &r, &t);\n    if(check(l, r, t)) printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint NN,k;\nint ran[100005];\nint tmp[100005];\nint sa[100005];\n\nbool compare_sa(int i,int j)\n{\n\tif(ran[i] != ran[j]) return ran[i] < ran[j];\n\telse\n\t{\n\t\tint ri = i+k<=NN ? ran[i+k]: -1;\n\t\tint rj = j+k<=NN ? ran[j+k]: -1;\n\t\t\n\t\treturn ri < rj;\n\t}\n}\n\nvoid construct_sa(string S)\n{\n\tNN = S.size();\n\tfor(int i=0;i<=NN;i++)\n\t{\n\t\tsa[i] = i;\n\t\tran[i] = i<NN?S[i]:-1;\n\t}\n\t\n\tfor(k=1;k<=NN;k*=2)\n\t{\n\t\tsort(sa,sa+NN+1,compare_sa);\n\t\t\n\t\ttmp[sa[0]] = 0;\n\t\tfor(int i=1;i<=NN;i++)\n\t\t{\n\t\t\ttmp[sa[i]] = tmp[sa[i-1]] + compare_sa(sa[i-1],sa[i]);\n\t\t}\n\t\tfor(int i=0;i<=NN;i++)\n\t\t{\n\t\t\tran[i] = tmp[i];\n\t\t}\n\t}\n}\nint lcp[100005];\nvoid construct_lcp(string S)\n{\n\tint n = S.size();\n\tfor(int i=0;i<=n;i++) ran[sa[i]] = i;\n\t\n\tint h = 0;\n\tlcp[0] = 0;\n\t\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint j = sa[ran[i]-1];\n\t\t\n\t\tif(h) h--;\n\t\tfor(;j+h<n && i+h<n;h++)\n\t\t{\n\t\t\tif(S[j+h] != S[i+h]) break;\n\t\t}\n\t\tlcp[ran[i]-1] = h;\n\t}\n}\n\nint seg[(1<<18)+5];\nvoid update(int k,int a){\n\tk+=(1<<17)-1; seg[k] = a;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tseg[k]=min(seg[k*2+1],seg[k*2+2]);\n\t}\n}\nint query(int a,int b,int k,int l,int r){\n\tif(r<a || b<l) return INF;\n\tif(a<=l && r<=b) return seg[k];\n\telse{\n\t\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\tint vr=query(a,b,k*2+2,(l+r)/2+1,r);\n\t\treturn min(vl,vr);\n\t}\n}\nstring s;\nint main(){\n\tcin >> s;\n\tconstruct_sa(s);\n\tconstruct_lcp(s);\n\tfor(int i=0;i<s.size();i++){\n\t\tupdate(i,lcp[i]);\n\t}\n\tint q; cin >> q;\n\tfor(int i=0;i<q;i++){\n\t\tint L,R,T; cin >> L >> R >> T;\n\t\tif(R-L+1 <= T){\n\t\t\tputs(\"Yes\"); continue;\n\t\t}\n\t\tint P = ran[L-1];\n\t\tint Q = ran[L+T-1];\n\t\tint len = query(min(P,Q),max(P,Q)-1,0,0,(1<<17)-1); //cout << len << endl;\n\t\tif(len >= R-L+1-T){\n\t\t\tputs(\"Yes\");\n\t\t}\n\t\telse{\n\t\t\tP = ran[L-1+len+1];\n\t\t\tQ = ran[L+T-1+len+1];\n\t\t\tint len2 = query(min(P,Q),max(P,Q)-1,0,0,(1<<17)-1);//cout << len << endl;\n\t\t\tint D = (T-1-len%T); D = min(D,R-L-T-len);//cout << D ;\n\t\t\tif(len2<D) puts(\"No\");\n\t\t\telse{\n\t\t\t\tif(D != T-1-len%T) puts(\"Yes\");\n\t\t\t\telse{\n\t\t\t\t\tif(L-1+T+T+len+D+1 <= R){\n\t\t\t\t\t\tP = ran[L-1+T+len+D+1]; \n\t\t\t\t\t\tQ = ran[L-1+T+T+len+D+1];\n\t\t\t\t\t\tint len3 = query(min(P,Q),max(P,Q)-1,0,0,(1<<17)-1);\n\t\t\t\t\t\tif(len3 < R-L-T-T-len-D){\n\t\t\t\t\t\t\tputs(\"No\"); continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tP = ran[L-1];\n\t\t\t\t\tQ = ran[L-1+T+len+D+1];\n\t\t\t\t\tint len4 = query(min(P,Q),max(P,Q)-1,0,0,(1<<17)-1);\n\t\t\t\t\tint E = min(T,R-L-T-len-D);\n\t\t\t\t\tputs(len4 >= E?\"Yes\":\"No\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt / 2,L+nt, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tassert(rsame);\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define All(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long LL;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst LL mod[] = { 999999937, 1000000007 }, base = 10000103;\n\nstruct RollingHash\n{\n\tint n;\n\tvector<LL> hs[2], pw[2];\n\tRollingHash() {};\n\tRollingHash(const string& s)\n\t{\n\t\tn = s.size();\n\t\tREP(i, 2)\n\t\t{\n\t\t\ths[i].assign(n + 1, 0);\n\t\t\tpw[i].assign(n + 1, 0);\n\t\t\ths[i][0] = 0;\n\t\t\tpw[i][0] = 1;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tpw[i][j + 1] = pw[i][j] * base%mod[i];\n\t\t\t\ths[i][j + 1] = (hs[i][j] * base + s[j]) % mod[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tLL hash(int l, int r, int i)\n\t{\n\t\treturn ((hs[i][r] - hs[i][l] * pw[i][r - l]) % mod[i] + mod[i]) % mod[i];\n\t}\n\n\tbool match(int l1, int r1, int l2, int r2)\n\t{\n\t\treturn (hash(l1, r1, 0) == hash(l2, r2, 0)) && (hash(l1, r1, 1) == hash(l2, r2, 1));\n\t}\n};\n\nstring s;\n\nbool check(int ll, int lr, int rl, int rr, int p, RollingHash& rh)\n{\n\tint len = lr - ll;\n\tLL lh0 = rh.hash(ll, lr + 1, 0), rh0 = rh.hash(rl, rr + 1, 0);\n\tLL lh1 = rh.hash(ll, lr + 1, 1), rh1 = rh.hash(rl, rr + 1, 1);\n\n \tif (ll + p < rl || rl + p > lr)\n\t{\n\t\tlh0 = (lh0 + mod[0] - s[ll + p] * rh.pw[0][len - p] % mod[0]) % mod[0];\n\t\tlh1 = (lh1 + mod[1] - s[ll + p] * rh.pw[1][len - p] % mod[1]) % mod[1];\n\t\trh0 = (rh0 + mod[0] - s[rl + p] * rh.pw[0][len - p] % mod[0]) % mod[0];\n\t\trh1 = (rh1 + mod[1] - s[rl + p] * rh.pw[1][len - p] % mod[1]) % mod[1];\n\t}\n\telse\n\t{\n\t\tint tp = p + ll;\n\t\tif (s[rl + tp - ll] != s[ll + tp - rl]) return false;\n\t\tlh0 = ((lh0 + s[rl + tp - ll] * rh.pw[0][lr - tp] % mod[0]) % mod[0] - s[tp] * rh.pw[0][lr - tp] % mod[0]) % mod[0];\n\t\tlh1 = ((lh1 + s[rl + tp - ll] * rh.pw[1][lr - tp] % mod[1]) % mod[1] - s[tp] * rh.pw[1][lr - tp] % mod[1]) % mod[1];\n\t\trh0 = ((rh0 + s[ll + tp - rl] * rh.pw[0][rr - tp] % mod[0]) % mod[0] - s[tp] * rh.pw[0][rr - tp] % mod[0]) % mod[0];\n\t\trh1 = ((rh1 + s[ll + tp - rl] * rh.pw[1][rr - tp] % mod[1]) % mod[1] - s[tp] * rh.pw[1][rr - tp] % mod[1]) % mod[1];\n\t}\n\treturn lh0 == rh0 && lh1 == rh1;\n}\n\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tcin >> s;\n\tRollingHash rh(s);\n\tint q; cin >> q;\n\twhile (q--)\n\t{\n\t\tint l, r, t;\n\t\tcin >> l >> r >> t;\n\t\tl--; r--;\n\t\tbool ans = false;\n\t\tif (r - l <= t) ans = true;\n\t\telse if (rh.match(l, r - t + 1, l + t, r + 1)) ans = true;\n\t\telse\n\t\t{\n\t\t\tint ll = l, rl = l + t;\n\t\t\tint len = r - l - t;\n\t\t\tint lb = 0, ub = len + 1;\n\t\t\tint p;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tp = (ub + lb) / 2;\n\t\t\t\tif (s[ll + p] != s[rl + p]) break;\n\t\t\t\tif (rh.match(ll, ll + p, rl, rl + p)) lb = p;\n\t\t\t\telse ub = p;\n\t\t\t}\n\t\t\tif (check(ll, r - t, rl, r, p, rh)) ans = true;\n\t\t\telse ans = false;\n\t\t}\n\t\tcout << (ans ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 100009, mul1 = 1000007;\n\tstatic const ll add0 = 10000120007, add1 = 10032333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\tint num = -1;\n\twhile (N--) {\n\t\tnum++;\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize  >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tif (L + nt * 3 + p <= R)ok = false;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\tassert(issame(L, L + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(rsame){\n\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassert(issame(L, L + nt, nt - 1).first);\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nconst int MAX = 500000, MS = 2;\nconst long long mod[] = {999999937LL, 1000000007LL}, base = 9973;\nstruct rolling_hash {\n    int n;\n    vector<long long> hs[MS], pw[MS];\n    rolling_hash(){}\n    rolling_hash(const string &s) {\n        n = s.size();\n        for (int i = 0; i < MS; i++) {\n            hs[i].assign(n+1,0);\n            pw[i].assign(n+1,0);\n            hs[i][0] = 0;\n            pw[i][0] = 1;\n            for (int j = 0; j < n; j++) {\n                pw[i][j+1] = pw[i][j]*base%mod[i];\n                hs[i][j+1] = (hs[i][j]*base+s[j])%mod[i];\n            }\n        }\n    }\n\n    long long hash(int l, int r, int i) { return ((hs[i][r]-hs[i][l]*pw[i][r-l])%mod[i]+mod[i])%mod[i]; }\n\n    bool match(int l1, int r1, int l2, int r2) {\n        bool ret = 1;\n        for (int i = 0; i < MS; i++) ret &= hash(l1,r1,i)==hash(l2,r2,i);\n        return ret;\n    }\n\n    bool match(int l, int r, long long h[]) {\n        bool ret = 1;\n        for (int i = 0; i < MS; i++) ret &= hash(l,r,i)==h[i];\n        return ret;\n    }\n};\n\n\nint main(){\n    string s;\n    cin >> s;\n    int q;\n    cin >> q;\n    int cnt =0;\n    rolling_hash rh(s);\n    for(int i=0;i<q;i++){\n        int l,r,t;\n        cin >> l >> r >> t;\n        l--;r--;\n        int l1,r1,l2,r2;\n        l1 = l;\n        l2 = l+t;\n        r1 = r-t;\n        r2 = r;\n        cnt++;\n        if(rh.match(l1,r1,l2,r2)||(l+t==r+1)){\n            cout << \"Yes\" << endl;\n        }else{\n            int ok = -1;\n            int ng = r1-l1;\n            while(ng-ok!=1){\n                int mid = (ng+ok)/2;\n                if(rh.match(l1,l1+mid,l2,l2+mid)){\n                    ok = mid;\n                }else{\n                    ng = mid;\n                }\n            }\n            bool flag = 0;\n            if(l2>=l1+ng){\n                bool fflag = 1;\n                for(int i=0;i<2;i++){\n                    ll x = rh.hash(l1,r1+1,i);\n                    ll y = rh.hash(l2,r2+1,i);\n                    x = (x+(rh.pw[i][r1-l1-ng+1]*(mod[i]+s[l2+ng-1]-s[l1+ng-1])%mod[i]))%mod[i];\n                    \n                    if(x!=y)fflag = 0;\n                }\n                if(fflag)flag = 1;\n            }else{\n                bool fflag = 1;\n                for(int i=0;i<2;i++){\n                    ll x = rh.hash(l1,r1+1,i);\n                    ll y = rh.hash(l2,r2+1,i);\n                    \n                    x = (x+(rh.pw[i][r1-l1-ng+1]*(mod[i]+s[l2+ng-1]-s[l1+ng-1])%mod[i]))%mod[i];\n                    y = (y+(rh.pw[i][r2-l1-ng+1]*(mod[i]+s[l2+ng-1]-s[l1+ng-1])%mod[i]))%mod[i];\n                    \n                    if(x!=y)fflag = 0;\n                }\n\n                if(fflag)flag = 1;\n            }   \n            if(l2+ng<r1){\n                bool fflag = 1;\n                for(int i=0;i<2;i++){\n                    ll x = rh.hash(l1,r1+1,i);\n                    ll y = rh.hash(l2,r2+1,i);\n                    x = (x+(rh.pw[i][r1-l2-ng+1]*(mod[i]+s[l1+ng-1]-s[l2+ng-1])%mod[i]))%mod[i];\n                    y = (y+(rh.pw[i][r2-l2-ng+1]*(mod[i]+s[l1+ng-1]-s[l2+ng-1])%mod[i]))%mod[i];\n                    if(x!=y)fflag = 0;\n                }\n\n                if(fflag)flag = 1;\n            }else{\n                bool fflag = 1;\n                for(int i=0;i<2;i++){\n                    ll x = rh.hash(l1,r1+1,i);\n                    ll y = rh.hash(l2,r2+1,i);\n                    y = (y+(rh.pw[i][r2-l2-ng+1]*(mod[i]+s[l1+ng-1]-s[l2+ng-1])%mod[i]))%mod[i];\n                    if(x!=y)fflag = 0;    \n                }\n\n                if(fflag)flag = 1;\n            } \n            if(flag){\n                cout << \"Yes\" << endl;\n            }else{\n                cout << \"No\" << endl;\n            }  \n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll po(const ll p, const ll n, const ll mod)\n{\n    if (n == 0) { return 1; }\n    if (n % 2 == 1) {\n        return po(p, n - 1, mod) * p % mod;\n    } else {\n        const ll pp = po(p, n / 2, mod);\n        return pp * pp % mod;\n    }\n}\nconstexpr ll inv(const ll p, const ll mod) { return po(p, mod - 2, mod); }\nconstexpr ll BASE1 = 186398169LL;\nconstexpr ll MOD1 = 1000000007LL;\nconstexpr ll INV1 = inv(BASE1, MOD1);\nconstexpr ll BASE2 = 238173201LL;\nconstexpr ll MOD2 = 1000000009LL;\nconstexpr ll INV2 = inv(BASE2, MOD2);\nconstexpr int MAX = 100000;\nP power[MAX], inverse[MAX], h[MAX];\nmap<P, int> phash;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string S;\n    cin >> S;\n    for (ll i = 0, p1 = 1, p2 = 1, i1 = 1, i2 = 1, h1 = 0, h2 = 0; i < S.size(); i++, (p1 *= BASE1) %= MOD1, (p2 *= BASE2) %= MOD2, (i1 *= INV1) %= MOD1, (i2 *= INV2) %= MOD2) {\n        (h1 += (S[i] - 'a') * p1 % MOD1) %= MOD1, (h2 += (S[i] - 'a') * p2 % MOD2) %= MOD2, h[i] = {h1, h2}, inverse[i] = {i1, i2}, power[i] = {p1, p2};\n        for (int j = 1; j < 26; j++) { phash[{p1 * j % MOD1, p2 * j % MOD2}] = i; }\n    };\n\n    auto add = [](const P& p1, const P& p2) -> P { return {(p1.first + p2.first) % MOD1, (p1.second + p2.second) % MOD2}; };\n    auto sub = [](const P& p1, const P& p2) -> P { return {(p1.first + MOD1 - p2.first) % MOD1, (p1.second + MOD2 - p2.second) % MOD2}; };\n    auto mul = [](const P& p1, const P& p2) -> P { return {(p1.first * p2.first) % MOD1, (p1.second * p2.second) % MOD2}; };\n    auto getHash = [&](const int s, const int l) -> P { return l == 0 ? P{0, 0} : s == 0 ? h[s + l - 1] : mul(sub(h[s + l - 1], h[s - 1]), inverse[s]); };\n    auto getSum = [&](const ll p, const ll n, const ll mod) -> ll { return p == 1 ? n : (po(p, n, mod) - 1) * inv(p - 1, mod) % mod; };\n    auto getPoly = [&](const int t, const int rep) -> P { return {getSum(power[t].first, rep, MOD1), getSum(power[t].second, rep, MOD2)}; };\n    auto judge = [&](const P& diff, const int L) -> bool { return diff == P{0, 0} or (phash.find(diff) != phash.end() and phash[diff] < L) or (phash.find(sub({0, 0}, diff)) != phash.end() and phash[sub({0, 0}, diff)] < L); };\n    assert(phash.size() == 25 * S.size());\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; q++) {\n        int l, r, t;\n        (cin >> l >> r >> t), l--;\n        const int L = r - l, rep = L / t, rest = L % t;\n        const P Hash = getHash(l, L);\n        const P Tail = getHash(l + t * rep, rest);\n        if (rep == 1) {\n            const P mask1 = add(getHash(l, t), mul(power[t * rep], getHash(l, rest)));\n            const P diff = sub(mask1, Hash);\n            cout << (judge(diff, L) ? \"Yes\\n\" : \"No\\n\");\n        } else {\n            const P poly = getPoly(t, rep);\n            const P mask1 = add(mul(poly, getHash(l, t)), mul(power[t * rep], Tail));\n            const P diff1 = sub(mask1, Hash);\n            const P mask2 = add(mul(poly, getHash(l + t, t)), mul(power[t * rep], Tail));\n            const P diff2 = sub(mask2, Hash);\n            cout << (judge(diff1, L) or judge(diff2, L) ? \"Yes\\n\" : \"No\\n\");\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define DEBUG(...)\n#endif\n\n#define size(v) v.size()\n\ntemplate <class S> vector<int> build_sa(const S& s) {\n  int n = size(s);\n  vector<int> sa(n), id(begin(s), end(s)), buf(n);\n  iota(rbegin(sa), rend(sa), 0);\n  stable_sort(begin(sa), end(sa), [&](int i, int j) { return s[i] < s[j]; });\n  for (int m = 1; m < n; m *= 2) {\n    for (int k = 0; k < n; ++k) {\n      int i = sa[k], p = k ? sa[k - 1] : n, j = i + m / 2, q = p + m / 2;\n      buf[i] = p + m < n and id[i] == id[p] and id[j] == id[q] ? buf[p] : k;\n    }\n    swap(id, buf);\n    iota(begin(buf), end(buf), 0);\n    auto nsa = sa;\n    for (int k = 0, i; k < n; ++k)\n      if ((i = sa[k] - m) >= 0) nsa[buf[id[i]]++] = i;\n    swap(sa, nsa);\n  }\n  return sa;\n}\n\ntemplate <class T> struct sparse_table {\n  vector<vector<T>> t;\n  sparse_table(const vector<T>& v = {}) : t{v} {\n    for (int k = 1, n = size(v); 1 << k <= n; ++k) {\n      t.emplace_back(n - (1 << k) + 1);\n      for (int i = 0; i + (1 << k) <= n; ++i)\n        t[k][i] = min(t[k - 1][i], t[k - 1][i + (1 << (k - 1))]);\n    }\n  }\n  T fold(int l, int r) const {\n    assert(l < r);\n    int k = __lg(r - l);\n    return min(t[k][l], t[k][r - (1 << k)]);\n  }\n};\n\ntemplate <class S> struct suffix_array {\n  S s;\n  int n;\n  vector<int> sa, rank, h;\n  sparse_table<int> st;\n  suffix_array(const S& _s = S()) : s(_s), n(size(s)), rank(n), h(n) {\n    sa = build_sa(s);\n    for (int k = 0; k < n; ++k) rank[sa[k]] = k;\n    for (int i = 0, m = 0; i < n; ++i, m = max(m - 1, 0)) {\n      int j = rank[i] + 1 < n ? sa[rank[i] + 1] : n;\n      while (max(i, j) + m < n and s[i + m] == s[j + m]) ++m;\n      h[rank[i]] = m;\n    }\n    st = {h};\n  }\n  int lcp(int i, int j) const {\n    if (i == j) return n - i;\n    if (rank[i] > rank[j]) swap(i, j);\n    return st.fold(rank[i], rank[j]);\n  }\n  int cmp(int i, int j, int len) const {\n    int m = lcp(i, j);\n    return m < len ? s[i + m] - s[j + m] : 0;\n  }\n};\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  string s;\n  cin >> s;\n  int n = size(s);\n  int q;\n  cin >> q;\n  struct query {\n    int l, r, t;\n  };\n  vector<query> qs(q);\n  for (auto&& e : qs) {\n    cin >> e.l >> e.r >> e.t;\n    --e.l;\n  }\n  vector<bool> res(q);\n  for (int _ = 2; _--; ) {\n    suffix_array<string> sa(s);\n    for (int qi = 0; qi < q; ++qi) {\n      int l = qs[qi].l;\n      int r = qs[qi].r;\n      int t = qs[qi].t;\n      if (r - l <= t + 1) {\n        res[qi] = true;\n        continue;\n      }\n      int k = sa.lcp(l, l + t);\n      int m = l + t + k + 1;\n      if (m >= r) {\n        res[qi] = true;\n        continue;\n      }\n      if (r - m > t and m + t + sa.lcp(m, m + t) < r) {\n        continue;\n      }\n      int x = (k + 1) % t;\n      if (x == 0) {\n        if (sa.cmp(l, m, min(t, r - m)) == 0) {\n          res[qi] = true;\n        }\n      } else if (r - m <= t - x) {\n        if (sa.cmp(l + x, m, r - m) == 0) {\n          res[qi] = true;\n        }\n      } else {\n        if (sa.cmp(l + x, m, t - x) == 0 and sa.cmp(l, m + (t - x), min(x, r - (m + (t - x)))) == 0) {\n          res[qi] = true;\n        }\n      }\n    }\n    reverse(begin(s), end(s));\n    for (auto&& e : qs) {\n      tie(e.l, e.r) = make_pair(n - e.r, n - e.l);\n    }\n  }\n  for (auto e : res) {\n    cout << (e ? \"Yes\\n\" : \"No\\n\");\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10005349, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l,r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r+1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r+1 - index - 1].second);\n\t}\n\tvoid change_st(const int index, const ll from, const ll to)const {\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const pair<int, int>a, const pair<int, int>b) {\n\tint al = a.first, ar = a.second;\n\tint bl = b.first, br = b.second;\n\tint lans = -1;\n\tint rans = ar-al;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans+1, ar) == rh.hash(bl + rans+1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind,st[changeind],changeto,l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool,int> issame(pair<int,int>a, pair<int,int>b) {\n\tif (b.first > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b.first <= R);\n\t\tint len = min(a.second - a.first, R - b.first);\n\t\tbool same=  getha(a.first,a.first+len) == getha(b.first,b.first+len);\n\t\tif (same)return make_pair(1, -1);\n\t\telse {\n\n\t\t\tint acheck = check(make_pair(a.first,a.first+len), (make_pair(b.first,b.first+len)));\n\t\t\treturn make_pair(false,acheck);\n\t\t}\n\t}\n}\nint main() { \n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize*2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(make_pair(L, L + nt - 1), make_pair(L + nt, L + nt * 2 - 1));\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = getha(L, L  + nt / 2 - 1) == getha(L  + nt / 2, L +nt-1);\n\t\t\t\t\t\tbool rsame;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > R) {\n\t\t\t\t\t\t\t\trsame = true;\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trsame = getha(l3, r3) == getha(l4, r4);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define All(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long LL;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst LL mod[] = { 999999937, 1000000007 }, base = 10000103;\n\nstruct RollingHash\n{\n\tint n;\n\tvector<LL> hs[2], pw[2];\n\tRollingHash() {};\n\tRollingHash(const string& s)\n\t{\n\t\tn = s.size();\n\t\tREP(i, 2)\n\t\t{\n\t\t\ths[i].assign(n + 1, 0);\n\t\t\tpw[i].assign(n + 1, 0);\n\t\t\ths[i][0] = 0;\n\t\t\tpw[i][0] = 1;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tpw[i][j + 1] = pw[i][j] * base%mod[i];\n\t\t\t\ths[i][j + 1] = (hs[i][j] * base + s[j]) % mod[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tLL hash(int l, int r, int i)\n\t{\n\t\treturn ((hs[i][r] - hs[i][l] * pw[i][r - l]) % mod[i] + mod[i]) % mod[i];\n\t}\n\n\tbool match(int l1, int r1, int l2, int r2)\n\t{\n\t\treturn (hash(l1, r1, 0) == hash(l2, r2, 0)) && (hash(l1, r1, 1) == hash(l2, r2, 1));\n\t}\n};\n\nstring s;\n\nbool check(int ll, int lr, int rl, int rr, int p, RollingHash& rh)\n{\n\tint len = lr - ll;\n\tLL lh0 = rh.hash(ll, lr + 1, 0), rh0 = rh.hash(rl, rr + 1, 0);\n\tLL lh1 = rh.hash(ll, lr + 1, 1), rh1 = rh.hash(rl, rr + 1, 1);\n\n \tif (ll + p < rl || rl + p > lr)\n\t{\n\t\tlh0 = (lh0 + mod[0] - s[ll + p] * rh.pw[0][len - p] % mod[0]) % mod[0];\n\t\tlh1 = (lh1 + mod[1] - s[ll + p] * rh.pw[1][len - p] % mod[1]) % mod[1];\n\t\trh0 = (rh0 + mod[0] - s[rl + p] * rh.pw[0][len - p] % mod[0]) % mod[0];\n\t\trh1 = (rh1 + mod[1] - s[rl + p] * rh.pw[1][len - p] % mod[1]) % mod[1];\n\t}\n\telse\n\t{\n\t\tint tp = p + ll;\n\t\tlh0 = ((lh0 + s[rl + tp - ll] * rh.pw[0][lr - tp] % mod[0]) % mod[0] - s[tp] * rh.pw[0][lr - tp] % mod[0]) % mod[0];\n\t\tlh1 = ((lh1 + s[rl + tp - ll] * rh.pw[1][lr - tp] % mod[1]) % mod[1] - s[tp] * rh.pw[1][lr - tp] % mod[1]) % mod[1];\n\t\trh0 = ((rh0 + s[ll + tp - rl] * rh.pw[0][rr - tp] % mod[0]) % mod[0] - s[tp] * rh.pw[0][rr - tp] % mod[0]) % mod[0];\n\t\trh1 = ((rh1 + s[ll + tp - rl] * rh.pw[1][rr - tp] % mod[1]) % mod[1] - s[tp] * rh.pw[1][rr - tp] % mod[1]) % mod[1];\n\t}\n\treturn lh0 == rh0 && lh1 == rh1;\n}\n\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tcin >> s;\n\tRollingHash rh(s);\n\tint q; cin >> q;\n\twhile (q--)\n\t{\n\t\tint l, r, t;\n\t\tcin >> l >> r >> t;\n\t\tl--; r--;\n\t\tbool ans = false;\n\t\tif (r - l <= t) ans = true;\n\t\telse if (rh.match(l, r - t + 1, l + t, r + 1)) ans = true;\n\t\telse\n\t\t{\n\t\t\tint ll = l, rl = l + t;\n\t\t\tint len = r - l - t;\n\t\t\tint lb = 0, ub = len + 1;\n\t\t\tint p;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tp = (ub + lb) / 2;\n\t\t\t\tif (s[ll + p] != s[rl + p]) break;\n\t\t\t\tif (rh.match(ll, ll + p, rl, rl + p)) lb = p;\n\t\t\t\telse ub = p;\n\t\t\t}\n\t\t\tif (check(ll, r - t, rl, r, p, rh)) ans = true;\n\t\t\telse ans = false;\n\t\t}\n\t\tcout << (ans ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 100009, mul1 = 1000007;\n\tstatic const ll add0 = 10000120007, add1 = 10032333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\t/*string filename = \"1340-out1.txt\";\n\tifstream read_file(\"D:/D_Download/Visual Studio 2015/Projects/programing_contest_c++/Debug/1340-out1.txt\");\n\tstring ast;\n\tvector<int>anss;\n\twhile (read_file >>ast) {\n\t\tanss.push_back(ast== \"Yes\");\n\t\t\n\t}\n\tread_file.close();*/\n\t\n\tcin >> st;\n\trh.init(st);\n\tmap<char, int>mp;\n\tfor (auto c : st)mp[c]++;\n\tint N; cin >> N;\n\tint num = -1;\n\twhile (N--) {\n\t\tnum++;\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\tif (L == 43245 && R == 50827 && T == 2190) {\n\t\t\tint a = 0; a++;\n\n\t\t}\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tif (L + nt * 3 + p <= R)ok = false;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L, L + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(rsame){\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L, L + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassert(issame(L, L + nt, nt - 1).first);\n\t\t\t}\n\t\t}\n\t\t//assert(ok==anss[num]);\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconst ll mod = 1e9 + 7;\nconst ll b1 = 1009, b2 = 10007;\n\nll Pow(ll a, ll b) {\n\tll res = 1; a %= mod;\n\twhile (b) {\n\t\tif (b & 1) {\n\t\t\tres = (res * a) % mod;\n\t\t}\n\t\ta = (a * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nclass RollingHash {\n\tint N;\n\tstring s;\n\tvector<ll> r1, r2, h1, h2, rh1, rh2;\npublic:\n\tRollingHash(const string& s_)\n\t\t: N((int)s_.size()), s(s_), r1(N + 1), r2(N + 1), h1(N + 1), h2(N + 1), rh1(N + 1), rh2(N + 1) {\n\t\tr1[0] = r2[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) r1[i] = r1[i - 1] * b1 % mod;\n\t\tfor (int i = 1; i <= N; i++) r2[i] = r2[i - 1] * b2 % mod;\n\n\t\th1[0] = h2[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) h1[i] = (h1[i - 1] * b1 + s[i - 1]) % mod;\n\t\tfor (int i = 1; i <= N; i++) h2[i] = (h2[i - 1] * b2 + s[i - 1]) % mod;\n\t}\n\tP get(int l, int r) {\n\t\treturn P((h1[r + 1] - h1[l] * r1[r - l + 1] % mod + mod) % mod, (h2[r + 1] - h2[l] * r2[r - l + 1] % mod + mod) % mod);\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint Q;\n\tstring S;\n\tcin >> S >> Q;\n\tint N = S.size();\n\tRollingHash rh(S);\n\tvector<P> dis;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = -25; j <= 25; j++) {\n\t\t\tdis.push_back(P(Pow(b1, i) * (mod + j) % mod, Pow(b2, i) * (mod + j) % mod));\n\t\t}\n\t}\n\tsort(dis.begin(), dis.end());\n\tfor (int i = 0, l, r, t; i < Q; i++) {\n\t\tcin >> l >> r >> t; l--; r--;\n\t\tauto lrh = rh.get(l, r - t), rrh = rh.get(l + t, r);\n\t\tll d1 = (lrh.first - rrh.first + mod) % mod, d2 = (lrh.second - rrh.second + mod) % mod;\n\t\tif (r - l + 1 > t * 2) {\n\t\t\tif (binary_search(dis.begin(), dis.end(), P(d1, d2))) {\n\t\t\t\tputs(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint w = r - l + 1 , fl = (r - l + 1) / t * t;\n\t\t\t\tif (w == fl && rh.get(l, l + t - 1) != rh.get(r - t + 1, r)) {\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (w != fl && (rh.get(l, l + w - fl - 1) != rh.get(r - (w - fl - 1), r) || rh.get(l + w - fl, l + t - 1) != rh.get(r - t + 1, r - (w - fl)))) {\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tll lb = t - 1, ub = r - l + 1 - t;\n\t\t\t\twhile (lb + 1 < ub) {\n\t\t\t\t\tll c = (lb + ub) / 2;\n\t\t\t\t\tlrh = rh.get(l, l + c - 1), rrh = rh.get(l + t, l + t + c - 1);\n\t\t\t\t\td1 = (lrh.first - rrh.first + mod) % mod, d2 = (lrh.second - rrh.second + mod) % mod;\n\t\t\t\t\tif (binary_search(dis.begin(), dis.end(), P(d1, d2))) {\n\t\t\t\t\t\tlb = c;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tub = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tll tmp = lb;\n\t\t\t\tlb = t - 1, ub = r - l + 1 - t;\n\t\t\t\twhile (lb + 1 < ub) {\n\t\t\t\t\tll c = (lb + ub) / 2;\n\t\t\t\t\tlrh = rh.get(r - t - c + 1, r - t), rrh = rh.get(r - c + 1, r);\n\t\t\t\t\td1 = (lrh.first - rrh.first + mod) % mod, d2 = (lrh.second - rrh.second + mod) % mod;\n\t\t\t\t\tif (binary_search(dis.begin(), dis.end(), P(d1, d2))) {\n\t\t\t\t\t\tlb = c;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tub = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tputs(tmp + lb == r - l || lb == r - l + 1 - t ? \"Yes\" : \"No\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tputs(binary_search(dis.begin(), dis.end(), P(d1, d2)) ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n  //  calc(l+as,r-t,l+as+t,r);\n\n  if ( calc(l+as,r-t ,l+as+t,r) && (eq(l,l+as,r-as,r) ||eq(l,l+as,r-as-t,r-t) ) )return true;\n  if ( eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-as,r) || calc(l,l+as,r-as-t,r-t) ) )return true;\n\n  if ( calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) ) )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && ( calc(l,l+as,r-as,r) || calc(l+t,l+t+as,r-as,r) ) )return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  assert(b-a==r-l);\n\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  assert(b-a==r-l);\n\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n\n  if ( calc(l+as,r-t ,l+as+t,r) && (   eq(l,l+as,r-t,r-t+as) ||   eq(l,l+as,r-t-t,r-t-t+as) ) )return true;\n  if (   eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-t,r-t+as) || calc(l,l+as,r-t-t,r-t-t+as) ) )return true;\n\n  if ( calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) ) )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && ( calc(l,l+as,r-as,r) || calc(l+t,l+t+as,r-as,r) ) )return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n\n  for(int i=0;i<n;i++){\n    s[i]+=19;\n  }\n\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll po(const ll p, const ll n, const ll mod)\n{\n    if (n == 0) { return 1; }\n    if (n % 2 == 1) {\n        return po(p, n - 1, mod) * p % mod;\n    } else {\n        const ll pp = po(p, n / 2, mod);\n        return pp * pp % mod;\n    }\n}\nconstexpr ll inv(const ll p, const ll mod) { return po(p, mod - 2, mod); }\nconstexpr ll BASE1 = 186398169LL;\nconstexpr ll MOD1 = 1000000007LL;\nconstexpr ll INV1 = inv(BASE1, MOD1);\nconstexpr ll BASE2 = 238173201LL;\nconstexpr ll MOD2 = 1000000009LL;\nconstexpr ll INV2 = inv(BASE2, MOD2);\nconstexpr int MAX = 100000;\nP power[MAX], inverse[MAX], h[MAX];\nmap<P, int> phash;\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string S;\n    cin >> S;\n    for (ll i = 0, p1 = 1, p2 = 1, i1 = 1, i2 = 1, h1 = 0, h2 = 0; i < S.size(); i++, (p1 *= BASE1) %= MOD1, (i1 *= INV1) %= MOD1, (p2 *= BASE2) %= MOD2, (i2 *= INV2) %= MOD2) {\n        (h1 += (S[i] - 'a') * p1 % MOD1) %= MOD1, (h2 += (S[i] - 'a') * p2 % MOD2) %= MOD2;\n        power[i] = {p1, p2}, inverse[i] = {i1, i2}, h[i] = {h1, h2};\n        for (int j = 1; j < 26; j++) { phash[{p1 * j % MOD1, p2 * j % MOD2}] = i; }\n    };\n    auto add = [](const P& p1, const P& p2) -> P { return {(p1.first + p2.first) % MOD1, (p1.second + p2.second) % MOD2}; };\n    auto sub = [](const P& p1, const P& p2) -> P { return {(p1.first + MOD1 - p2.first) % MOD1, (p1.second + MOD2 - p2.second) % MOD2}; };\n    auto mul = [](const P& p1, const P& p2) -> P { return {(p1.first * p2.first) % MOD1, (p1.second * p2.second) % MOD2}; };\n    auto getHash = [&](const int s, const int l) -> P { return l == 0 ? P{0, 0} : s == 0 ? h[s + l - 1] : mul(sub(h[s + l - 1], h[s - 1]), inverse[s]); };\n    auto getPoly = [&](const int t, const int rep) -> P { return {(po(power[t].first, rep, MOD1) + MOD1 - 1) * inv(power[t].first + MOD1 - 1, MOD1) % MOD1, (po(power[t].second, rep, MOD2) + MOD2 - 1) * inv(power[t].second + MOD2 - 1, MOD2) % MOD2}; };\n    auto judge = [&](const P& diff, const int L) -> bool { return diff == P{0, 0} or (phash.find(diff) != phash.end() and phash[diff] < L) or (phash.find({(MOD1 - diff.first) % MOD1, (MOD2 - diff.second) % MOD2}) != phash.end() and phash[{-diff.first, -diff.second}] < L); };\n    assert(phash.size() == 25 * S.size());\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; q++) {\n        int l, r, t;\n        (cin >> l >> r >> t), l--;\n        const int L = r - l, rep = L / t, rest = L % t;\n        const P Hash = getHash(l, L);\n        if (rep == 1) {\n            const P mask1 = add(getHash(l, t), mul(power[t * rep], getHash(l + t * rep, rest)));\n            const P diff = sub(mask1, Hash);\n            cout << (judge(diff, L) ? \"Yes\\n\" : \"No\\n\");\n        } else {\n            const P poly = getPoly(t, rep);\n            const P m1 = getHash(l, t);\n            const P mask1 = add(mul(poly, m1), mul(power[t * rep], getHash(l + t * rep, rest)));\n            const P diff1 = sub(mask1, Hash);\n            const P m2 = getHash(l + t, t);\n            const P mask2 = add(mul(poly, m2), mul(power[t * rep], getHash(l + t * rep, rest)));\n            const P diff2 = sub(mask2, Hash);\n            cout << (judge(diff1, L) or judge(diff2, L) ? \"Yes\\n\" : \"No\\n\");\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconst ll mod = 1e9 + 7;\nconst ll b1 = 1009, b2 = 10007;\n\nll Pow(ll a, ll b) {\n\tll res = 1; a %= mod;\n\twhile (b) {\n\t\tif (b & 1) {\n\t\t\tres = (res * a) % mod;\n\t\t}\n\t\ta = (a * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nclass RollingHash {\n\tint N;\n\tstring s;\n\tvector<ll> r1, r2, h1, h2, rh1, rh2;\npublic:\n\tRollingHash(const string& s_)\n\t\t: N((int)s_.size()), s(s_), r1(N + 1), r2(N + 1), h1(N + 1), h2(N + 1), rh1(N + 1), rh2(N + 1) {\n\t\tr1[0] = r2[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) r1[i] = r1[i - 1] * b1 % mod;\n\t\tfor (int i = 1; i <= N; i++) r2[i] = r2[i - 1] * b2 % mod;\n\n\t\th1[0] = h2[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) h1[i] = (h1[i - 1] * b1 + s[i - 1]) % mod;\n\t\tfor (int i = 1; i <= N; i++) h2[i] = (h2[i - 1] * b2 + s[i - 1]) % mod;\n\t}\n\tP get(int l, int r) {\n\t\treturn P((h1[r + 1] - h1[l] * r1[r - l + 1] % mod + mod) % mod, (h2[r + 1] - h2[l] * r2[r - l + 1] % mod + mod) % mod);\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint Q;\n\tstring S;\n\tcin >> S >> Q;\n\tint N = S.size();\n\tRollingHash rh(S);\n\tvector<P> dis;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = -25; j <= 25; j++) {\n\t\t\tdis.push_back(P(Pow(b1, i) * (mod + j) % mod, Pow(b2, i) * (mod + j) % mod));\n\t\t}\n\t}\n\tsort(dis.begin(), dis.end());\n\tfor (int i = 0, l, r, t; i < Q; i++) {\n\t\tcin >> l >> r >> t; l--; r--;\n\t\tauto lrh = rh.get(l, r - t), rrh = rh.get(l + t, r);\n\t\tll d1 = (lrh.first - rrh.first + mod) % mod, d2 = (lrh.second - rrh.second + mod) % mod;\n\t\tif (r - l + 1 > t * 2) {\n\t\t\tif (binary_search(dis.begin(), dis.end(), P(d1, d2))) {\n\t\t\t\tputs(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tll lb = t - 1, ub = r - l + 1 - t;\n\t\t\t\twhile (lb + 1 < ub) {\n\t\t\t\t\tll c = (lb + ub) / 2;\n\t\t\t\t\tlrh = rh.get(l, l + c - 1), rrh = rh.get(l + t, l + t + c - 1);\n\t\t\t\t\td1 = (lrh.first - rrh.first + mod) % mod, d2 = (lrh.second - rrh.second + mod) % mod;\n\t\t\t\t\tif (binary_search(dis.begin(), dis.end(), P(d1, d2))) {\n\t\t\t\t\t\tlb = c;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tub = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tll tmp = lb;\n\t\t\t\tlb = t - 1, ub = r - l + 1 - t;\n\t\t\t\twhile (lb + 1 < ub) {\n\t\t\t\t\tll c = (lb + ub) / 2;\n\t\t\t\t\tlrh = rh.get(l + t - c + 1, l + t), rrh = rh.get(r - c + 1, r);\n\t\t\t\t\td1 = (lrh.first - rrh.first + mod) % mod, d2 = (lrh.second - rrh.second + mod) % mod;\n\t\t\t\t\tif (binary_search(dis.begin(), dis.end(), P(d1, d2))) {\n\t\t\t\t\t\tlb = c;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tub = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tputs(tmp + lb >= r - l && (t > 1 || S[l] == S[r]) ? \"Yes\" : \"No\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tputs(binary_search(dis.begin(), dis.end(), P(d1, d2)) ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10005349, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l,r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r+1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r+1 - index - 1].second);\n\t}\n\tvoid change_st(const int index, const ll from, const ll to)const {\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const pair<int, int>a, const pair<int, int>b) {\n\tint al = a.first, ar = a.second;\n\tint bl = b.first, br = b.second;\n\tint lans = -1;\n\tint rans = ar-al;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans+1, ar) == rh.hash(bl + rans+1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind,st[changeind],changeto,l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool,int> issame(int al, int bl,int len) {\n\tif (bl > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(bl <= R);\n\t\tint checklen = min(len, R - bl);\n\t\tbool same=  getha(a.first,a.first+ checklen) == getha(b.first,b.first+ checklen);\n\t\tif (same)return make_pair(1, -1);\n\t\telse {\n\n\t\t\tint acheck = check(make_pair(al,al+checklen), (make_pair(bl,bl+checklen)));\n\t\t\treturn make_pair(false,acheck);\n\t\t}\n\t}\n}\nint main() { \n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize*2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = getha(L, L  + nt / 2 - 1) == getha(L  + nt / 2, L +nt-1);\n\t\t\t\t\t\tbool rsame;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > R) {\n\t\t\t\t\t\t\t\trsame = true;\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trsame = getha(l3, r3) == getha(l4, r4);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tassert(rans != len);\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt / 2,L+nt, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define All(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long LL;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst LL mod[] = { 999999937, 1000000007 }, base = 10000103;\n\nstruct RollingHash\n{\n\tint n;\n\tvector<LL> hs[2], pw[2];\n\tRollingHash() {};\n\tRollingHash(const string& s)\n\t{\n\t\tn = s.size();\n\t\tREP(i, 2)\n\t\t{\n\t\t\ths[i].assign(n + 1, 0);\n\t\t\tpw[i].assign(n + 1, 0);\n\t\t\ths[i][0] = 0;\n\t\t\tpw[i][0] = 1;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tpw[i][j + 1] = pw[i][j] * base%mod[i];\n\t\t\t\ths[i][j + 1] = (hs[i][j] * base + s[j]) % mod[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tLL hash(int l, int r, int i)\n\t{\n\t\treturn ((hs[i][r] - hs[i][l] * pw[i][r - l]) % mod[i] + mod[i]) % mod[i];\n\t}\n\n\tbool match(int l1, int r1, int l2, int r2)\n\t{\n\t\treturn (hash(l1, r1, 0) == hash(l2, r2, 0)) && (hash(l1, r1, 1) == hash(l2, r2, 1));\n\t}\n};\n\nstring s;\n\nbool check(int ll, int lr, int rl, int rr, int p, RollingHash& rh)\n{\n\tint len = lr - ll;\n\tLL lh0 = rh.hash(ll, lr + 1, 0), rh0 = rh.hash(rl, rr + 1, 0);\n\tLL lh1 = rh.hash(ll, lr + 1, 1), rh1 = rh.hash(rl, rr + 1, 1);\n\n \tif (ll + p < rl || rl + p > lr)\n\t{\n\t\tlh0 = (lh0 + mod[0] - s[ll + p] * rh.pw[0][len - p] % mod[0]) % mod[0];\n\t\tlh1 = (lh1 + mod[1] - s[ll + p] * rh.pw[1][len - p] % mod[1]) % mod[1];\n\t\trh0 = (rh0 + mod[0] - s[rl + p] * rh.pw[0][len - p] % mod[0]) % mod[0];\n\t\trh1 = (rh1 + mod[1] - s[rl + p] * rh.pw[1][len - p] % mod[1]) % mod[1];\n\t}\n\telse\n\t{\n\t\tint tp = p + ll;\n\t\tlh0 = ((lh0 + s[rl + tp - ll] * rh.pw[0][lr - tp] % mod[0]) % mod[0] - s[tp] * rh.pw[0][lr - tp] % mod[0]) % mod[0];\n\t\tlh1 = ((lh1 + s[rl + tp - ll] * rh.pw[1][lr - tp] % mod[1]) % mod[0] - s[tp] * rh.pw[1][lr - tp] % mod[1]) % mod[1];\n\t\trh0 = ((rh0 + s[ll + tp - rl] * rh.pw[0][rr - tp] % mod[0]) % mod[0] - s[tp] * rh.pw[0][rr - tp] % mod[0]) % mod[0];\n\t\trh1 = ((rh1 + s[ll + tp - rl] * rh.pw[1][rr - tp] % mod[1]) % mod[0] - s[tp] * rh.pw[1][rr - tp] % mod[1]) % mod[1];\n\t}\n\treturn lh0 == rh0 && lh1 == rh1;\n}\n\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tcin >> s;\n\tRollingHash rh(s);\n\tint q; cin >> q;\n\twhile (q--)\n\t{\n\t\tint l, r, t;\n\t\tcin >> l >> r >> t;\n\t\tl--; r--;\n\t\tbool ans = false;\n\t\tif (r - l <= t) ans = true;\n\t\telse if (rh.match(l, r - t + 1, l + t, r + 1)) ans = true;\n\t\telse\n\t\t{\n\t\t\tint ll = l, rl = l + t;\n\t\t\tint len = r - l - t;\n\t\t\tint lb = 0, ub = len + 1;\n\t\t\tint p;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tp = (ub + lb) / 2;\n\t\t\t\tif (s[ll + p] != s[rl + p]) break;\n\t\t\t\tif (rh.match(ll, ll + p, rl, rl + p)) lb = p;\n\t\t\t\telse ub = p;\n\t\t\t}\n\t\t\tif (check(ll, r - t, rl, r, p, rh)) ans = true;\n\t\t\telse ans = false;\n\t\t}\n\t\tcout << (ans ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l,r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r+1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r+1 - index - 1].second);\n\t}\n\tvoid change_st(const int index, const ll from, const ll to)const {\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const pair<int, int>&a, const pair<int, int>&b) {\n\tint al = a.first, ar = a.second;\n\tint bl = b.first, br = b.second;\n\tint lans = -1;\n\tint rans = ar-al;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans+1, ar) == rh.hash(bl + rans+1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind,st[changeind],changeto,l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\n//bool issame(const int l1,  int r1, const int l2,  int r2) {\n//\tif (l2 > R) {\n//\t\treturn true;\n//\t}\n//\telse {\n//\t\tif (r2 > R) {\n//\t\t\tr2 = R;\n//\t\t\tassert(l2 <= R);\n//\t\t}\n//\t\treturn  getha(l3, r3) == getha(l4, r4);\n//\t\tif (r3 < L + nt + p&&L + nt + p < r3)rflag = true;\n//\t}\n//}\nint main() { \n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize*2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tconst int l1 = L;\n\t\t\tint r1 = L + nt - 1;\n\t\t\tconst int l2 = L + nt;\n\t\t\tint r2 = L + 2 * nt - 1;\n\t\t\tif (r2 > R) {\n\t\t\t\tr2 = R;\n\t\t\t\tr1 = l1 + r2 - l2;\n\t\t\t\tassert(l2 <= R);\n\t\t\t}\n\t\t\tha ha1 = getha(l1, r1);\n\t\t\tha ha2 = getha(l2,r2);\n\t\t\tif (ha1 == ha2)continue;\n\t\t\telse {\n\t\t\t\tint p(check(make_pair(l1, r1), make_pair(l2, r2)));\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = getha(l1, l1 + nt / 2 - 1) == getha(l1 + nt / 2, l1+nt-1);\n\t\t\t\t\t\tbool rsame;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > R) {\n\t\t\t\t\t\t\t\trsame = true;\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trsame = getha(l3, r3) == getha(l4, r4);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < r3)rflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = l2 + p;\n\t\t\t\t\t\t\t\tchangeto = st[l1 + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = l1 + p;\n\t\t\t\t\t\t\t\tchangeto = st[l2 + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = l2 + p;\n\t\t\t\t\t\t\t\tchangeto = st[l1 + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = l1 + p;\n\t\t\t\t\t\t\t\tchangeto = st[l2 + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L, L + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(rsame){\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L, L + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassert(issame(L, L + nt, nt - 1).first);\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(rsame){\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef unsigned long long ull;\n\n//const ull M=(1e9+7);\nconst ull M=100;\nstring s;\nint q;\null H[N], D[N];\n\nvoid cal_hash(){\n  ull h=0;\n  for(int i=0;i<s.size();i++){\n    h=h*M+s[i];\n    H[i+1]=h;\n  }\n  h=1;\n  for(int i=0;i<N;i++){\n    D[i]=h;\n    h*=M;\n  }\n  s='X'+s;\n}\n\nint get_first_diff_idx(int l, int r, int t){\n  \n  int L=0, R=r-l-t+2;\n  \n  while(L<R){\n    \n    int Mid=(L+R)/2;\n    ull v1=H[l+Mid]-H[l-1]*D[Mid+1];\n    ull v2=H[l+Mid+t]-H[l+t-1]*D[Mid+1];\n    \n    if(v1==v2) L=Mid+1;\n    else R=Mid;\n  }\n  \n  return L;\n}\n\nbool isSame(int l, int r, int t, int A, int B){\n  \n  int i1=l+t, i2=r;\n  ull h1, h2;\n  \n  if(i1<=A&&A<=i2){\n    \n    if(i1<A&&A<i2) h1=H[i2]-H[A]*D[i2-A]+((H[A-1]-H[i1-1]*D[A-i1])*D[1]+s[B])*D[i2-A];\n    else if(A==i1) h1=H[i2]-H[i1]*D[i2-i1]+s[B]*D[i2-i1];\n    else if(A==i2) h1=s[B]+(H[i2-1]-H[i1-1]*D[i2-i1])*D[1];\n    \n  }else h1=H[i2]-H[i1-1]*D[i2-i1+1];\n  \n  i1=l, i2=r-t;\n  \n  if(i1<=A&&A<=i2){\n    \n    if(i1<A&&A<i2) h2=H[i2]-H[A]*D[i2-A]+((H[A-1]-H[i1-1]*D[A-i1])*D[1]+s[B])*D[i2-A];\n    else if(A==i1) h2=H[i2]-H[i1]*D[i2-i1]+s[B]*D[i2-i1];\n    else if(A==i2) h2=s[B]+(H[i2-1]-H[i1-1]*D[i2-i1])*D[1];\n    \n  }else h2=H[i2]-H[i1-1]*D[i2-i1+1];\n  cout<<h1<<' '<<h2<<endl;\n  return h1==h2;\n}\n\nbool check(int l, int r, int t){\n  \n  /*if((r-l+1)%t!=0) return false;\n    if((r-l+1)==t) return true;*/\n  \n  int idx=get_first_diff_idx(l, r, t);\n\n  int i1=l+idx, i2=l+t+idx;\n  cout<<i1<<' '<<i2<<' '<<idx<<endl;\n  return isSame(l, r, t, i1, i2) | isSame(l, r, t, i2, i1);\n}\n\nint main(){\n  \n  cin>>s;\n  \n  cal_hash();\n  \n  cin>>q;\n  \n  int l, r, t;\n  \n  for(int i=0;i<q;i++){\n    scanf(\"%d %d %d\", &l, &r, &t);\n    if(check(l, r, t)) printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Long __int128_t\n#define int long long\n#define REP(i, n) for (int i = 0; i < (n); i++)\n\nLong modpow(Long a, Long n, Long mod) {\n    if (n == 0) return 1;\n    if (n % 2 == 0) {\n        Long t = modpow(a, n / 2, mod);\n        return t * t % mod;\n    }\n    return a * modpow(a, n - 1, mod) % mod;\n}\n\nLong modinv(Long a, Long mod) { return modpow(a, mod - 2, mod); }\n\nmap<Long, Long> memo[101010];\n\n// a^0 + a^1 + ... + a^{n-1}\nLong powsum(Long a, Long n, Long mod) {\n    if (memo[n].count(a)) return memo[n][a];\n    if (n == 0) return 0;\n    if (n % 2 == 0) {\n        Long t = powsum(a, n / 2, mod);\n        return memo[n][a] = (1 + modpow(a, n / 2, mod)) * t % mod;\n    }\n    return memo[n][a] = (modpow(a, n - 1, mod) + powsum(a, n - 1, mod)) % mod;\n}\n\ntemplate <Long mod, Long p = 257>\nstruct RollingHash {\n    int n;\n    vector<Long> table;\n    vector<Long> pows;\n    RollingHash(const string &s) : n(s.size()), table(n + 1), pows(n + 1) {\n        table[0] = 1;\n        pows[0] = 1;\n        for (int i = 0; i < n; i++) {\n            table[i + 1] = (table[i] * p + s[i]) % mod;\n            pows[i + 1] = pows[i] * p % mod;\n        }\n    }\n\n    // [l, r)\n    Long hash_substr(int l, int r) {\n        Long ret = (table[r] - table[l] * pows[r - l]) % mod;\n        if (ret < 0) ret += mod;\n        return ret;\n    }\n\n    // [sl, sr)が[tl, tr) + [tl2, tr2)を繰り返したものになっているか\n    bool is_periodic(int sl, int sr, int tl, int tr, int tl2 = 0, int tr2 = 0) {\n        int slen = sr - sl, tlen = tr - tl, tlen2 = tr2 - tl2;\n        int k = slen / (tlen + tlen2);\n        Long target = (hash_substr(tl, tr) * pows[tlen2] % mod + hash_substr(tl2, tr2)) *\n                      powsum(pows[tlen + tlen2], k, mod) % mod;\n        int need = slen % (tlen + tlen2);\n        target = target * pows[need] % mod;\n        if (need <= tlen) {\n            target += hash_substr(tl, tl + need);\n        } else {\n            need -= tlen;\n            Long add = hash_substr(tl, tr);\n            add = add * pows[need] % mod;\n            add += hash_substr(tl2, tl2 + need);\n            target += add;\n        }\n        target %= mod;\n        return target == hash_substr(sl, sr);\n    }\n};\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    string s;\n    cin >> s;\n\n    RollingHash<4611686018427387903> rh(s);\n\n    auto hoge = [&](int l, int r, int t) {\n        int len = r - l;\n        int L = 0, R = len;\n        while (L < R - 1) {\n            int M = (L + R) / 2;\n            if (rh.is_periodic(l, l + M, l, l + t)) {\n                L = M;\n            } else {\n                R = M;\n            }\n        }\n        int amari = (L + 1) % t;\n        return rh.is_periodic(l + L + 1, r, l + amari, l + t, l, l + amari);\n    };\n\n    int q;\n    cin >> q;\n    while (q--) {\n        int l, r, t;\n        cin >> l >> r >> t;\n        l--;\n        if (rh.is_periodic(l, r, l, l + t)) {\n            cout << \"Yes\" << '\\n';\n            continue;\n        }\n\n        if (hoge(l, r, t)) {\n            cout << \"Yes\" << '\\n';\n            continue;\n        }\n\n        if (r - l < t * 2) {\n            cout << \"No\" << '\\n';\n            continue;\n        }\n\n        if (!rh.is_periodic(l + t, r, l + t, l + t + t)) {\n            cout << \"No\" << '\\n';\n            continue;\n        }\n\n        if (hoge(l, l + 2 * t, t)) {\n            cout << \"Yes\" << '\\n';\n            continue;\n        }\n\n        cout << \"No\" << '\\n';\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n   \null B=5575777;\null mem[MAX_N];\n   \null pow(int x){\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n   \nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n   \null get(int l,int r){\n  return p[r]-p[l]*pow(r-l);\n}\n   \null get(int l,int r,int x,char ch){\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n   \nbool eq(int a,int b,int l,int r){\n  return ( get(a,b) == get(l,r) );\n}\n   \nbool eq(int a,int b,int l,int r, int x,char ch){\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n   \nbool calc(int a,int b,int l,int r){\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n   \n   \nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if( calc(l,r-t,l+t,r) )return true;  \n  return false;\n}\n   \nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n   \n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n   \n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n   \n    l--;\n   \n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstruct RollingHash{\n    static const int MD = 2;\n    static const vector<ll> hash_base, hash_mod;\n\n    int n;\n    vector<ll> hs[MD], pw[MD];\n\n    RollingHash(){}\n    RollingHash(const string &s){\n        n = s.size();\n        rep(i,MD){\n            hs[i].assign(n+1,0);\n            pw[i].assign(n+1,0);\n            hs[i][0] = 0;\n            pw[i][0] = 1;\n            rep(j,n){\n                pw[i][j+1] = pw[i][j]*hash_base[i] % hash_mod[i];\n                hs[i][j+1] = (hs[i][j]*hash_base[i]+s[j]) % hash_mod[i];\n            }\n        }\n    }\n\n    // 1-index\n    ll hash_value(int l, int r, int i){\n        return ((hs[i][r] - hs[i][l]*pw[i][r-l])%hash_mod[i]+hash_mod[i])%hash_mod[i];\n    }\n\n    bool match(int l1, int r1, int l2, int r2){\n        bool ret = true;\n        rep(i,MD) ret &= (hash_value(l1-1,r1,i) == hash_value(l2-1,r2,i));\n        return ret;\n    }\n\n    vector<ll> calc(int l, int r){\n        vector<ll> ret(MD);\n        rep(i,MD) ret[i]=hash_value(l-1,r,i);\n        return ret;\n    }\n};\nconst vector<ll> RollingHash::hash_base{1009,1021};\nconst vector<ll> RollingHash::hash_mod{1000000009,1000000007};\n\nint main(){\n    string s;\n    int Q;\n    cin >>s >>Q;\n    int S = s.size();\n\n    string rev = s;\n    reverse(all(rev));\n\n    RollingHash H(s),T(rev);\n\n    while(Q--){\n        int l,r,t;\n        scanf(\" %d %d %d\", &l, &r, &t);\n\n        vector<int> check;\n        // prefix\n        int L = l, R = r;\n        int ok = L+t-1, ng = R+1;\n        rep(i,2){\n            // printf(\" binary s %d %d \\n\",ok,ng);\n            // dbg(L);\n            while(ng-ok>1){\n                int mid = (ok+ng)/2;\n                if(H.match(L+t,mid,L,mid-t)) ok = mid;\n                else ng = mid;\n            }\n            if(l<=ok+1 && ok+1<=r) check.pb(ok+1);\n            // dbg(ok+1);\n            L = ok+2-t;\n            ok = L+t-1;\n            ng = R+1;\n        }\n\n        // suffix\n        int cv_l = S-r+1, cv_r = S-l+1;\n        L = cv_l;\n        R = cv_r;\n        ok = L+t-1;\n        ng = R+1;\n        rep(i,2){\n            // printf(\" binary s %d %d \\n\",ok,ng);\n            // dbg(L);\n            while(ng-ok>1){\n                int mid = (ok+ng)/2;\n                if(T.match(L+t,mid,L,mid-t)) ok = mid;\n                else ng = mid;\n            }\n            if(l<=S+1 - (ok+1) && S+1 - (ok+1)<=r) check.pb(S+1 - (ok+1));\n            // dbg(ok+1);\n            // dbg(S+1 - (ok+1));\n            L = ok+2-t;\n            ok = L+t-1;\n            ng = R+1;\n        }\n\n        set<int> IDX;\n        for(int i:check){\n            for(int j=-1; j<=1; ++j){\n                int idx = i + j*t;\n                if(l<=idx && idx<=r) IDX.insert(idx);\n            }\n        }\n        map<char,int> mm;\n        for(int idx:IDX){\n            // printf(\" FOCUS :: %d %c\\n\",idx,s[idx-1]);\n            ++mm[s[idx-1]];\n        }\n\n        bool ans = true;\n        if(mm.size() > 2) ans = false;\n        else if(mm.size() == 2){\n            vector<int> v;\n            for(const auto p:mm) v.pb(p.se);\n            if(min(v[0],v[1])>1) ans = false;\n        }\n\n        printf(\"%s\\n\", (ans?\"Yes\":\"No\"));\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Ti = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nusing ull = unsigned long long;\nstruct RollingHash {\n  string s;\n  ull base, mod;\n  vector<ull> hashed, power;\n  RollingHash(const string& s):s(s), base(9973ll), mod(999999937ll){\n    int sz = s.size();\n    hashed.resize(sz+1, 0);\n    power.resize(sz+1, 0);\n    power[0] = 1;\n    for(int i = 0; i < sz; i++) {\n      power[i+1] = power[i]*base%mod;\n      hashed[i+1] = (hashed[i]*base%mod+s[i])%mod;\n    }\n  }\n  ull get(int l, int r) {\n    return (hashed[r]-hashed[l]*power[r-l]%mod+mod)%mod;\n  }\n  ull concat(ull h1, ull h2, int len) {\n    return (h1*power[len]%mod+h2)%mod;\n  }\n  ull rehash(int l, int r, int i, char c) {\n    if(i < l || r <= i) return get(l, r);\n    //cout << r-l << \" \" << s.substr(l, r-l) << \" \" << s.substr(l, i-l) << endl;\n    ull h = get(l, i);\n    //cout << l << \" \" << r << \" \" << i << \" \" << c <<  \" \" << h << endl;\n    h = (h*base%mod + c)%mod;\n    return concat(h, get(i+1, r), r-(i+1));\n  }\n};\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  string s;\n  cin >> s;\n  RollingHash rh(s);\n\n  int q;\n  cin >> q;\n  while(q--) {\n    int l, r, t;\n    cin >> l >> r >> t;\n    --l;\n    if(rh.get(l, r-t) == rh.get(l+t, r)) {\n      cout << \"Yes\" << endl;\n      continue;\n    }\n    int lb = 0, ub = r-l+1;\n    while(lb+1 < ub) {\n      int mb = (lb+ub)/2;\n      //assert(l+t+mb <= s.size());\n      if(l+t+mb <= (int)s.size() && rh.get(l, l+mb) == rh.get(l+t, l+t+mb)) lb = mb;\n      else ub = mb;\n    }\n    //cout << rh.get(l, l+lb) << \" \" << rh.get(l+t, l+t+lb) << endl;\n    //cout << lb << \" \" << s[l+lb] << \" \" << s[l+t+lb] << endl;\n    //cout << rh.rehash(l, r-t, l+lb, s[l+lb]) << \" \" << rh.get(l, r-t) << endl;\n    //cout << rh.rehash(l+t, r, l+t+lb, s[l+lb]) <<  \" \" << rh.get(l+t, r) << endl;\n    if((rh.rehash(l, r-t, l+lb, s[l+t+lb]) == rh.rehash(l+t, r, l+lb, s[l+t+lb])) ||\n       (rh.rehash(l, r-t, l+t+lb, s[l+lb]) == rh.rehash(l+t, r, l+t+lb, s[l+lb]))) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  assert(b-a==r-l);\n\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  assert(b-a==r-l);\n\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L])  );\n  //  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n  //  calc(l+as,r-t,l+as+t,r);\n\n  //  if ( calc(l+as,r-t ,l+as+t,r) && ( eq(l,l+as,r-t,r-t+as) || eq(l,l+as,r-t-t,r-t-t+as) ) )return true;\n  //  if ( eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-t,r-t+as) || calc(l,l+as,r-t-t,r-t-t+as) ) )return true;\n\n  if ( calc(l,r-as-t ,l+t,r-as) && eq(l,l+as,r-as,r)  )return true;\n  if ( calc(l+t,r-as ,l,r-as-t) && eq(l+t,l+t+as,r-as,r)  )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && calc(l,l+as,r-as,r)  )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && calc(r-as,r,l,l+as)  )return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n\n  for(int i=0;i<n;i++){\n    s[i]+=19;\n  }\n\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10005349, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n\tvoid change_st(const int index, const ll from, const ll to)const {\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const pair<int, int>a, const pair<int, int>b) {\n\tint al = a.first, ar = a.second;\n\tint bl = b.first, br = b.second;\n\tint lans = -1;\n\tint rans = ar - al;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b,int len) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(len, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(1, -1);\n\t\telse {\n\n\t\t\tint acheck = check(make_pair(a, a + len), (make_pair(b, b + len)));\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2).first;\n\t\t\t\t\t\tbool rsame;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > R) {\n\t\t\t\t\t\t\t\trsame = true;\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trsame = getha(l3, r3) == getha(l4, r4);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n  //  calc(l+as,r-t,l+as+t,r);\n\n  if ( calc(l+as,r-t ,l+as+t,r) && (eq(l,l+as,r-as,r) ||eq(l,l+as,r-as-t,r-t) ) )return true;\n  if ( eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-as,r) || calc(l,l+as,r-as-t,r-t) ) )return true;\n\n  if ( calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) ) )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && ( calc(l,l+as,r-as,r) || calc(l+t,l+t+as,r-as,r) ) )return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n\n  for(int i=0;i<n;i++){\n    s[i]+=19;\n  }\n\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP, rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size());\n    LCP[0] = 0;\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i] + 1] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (LCP[k]);\n  }\n\n  size_t size() const\n  {\n    return (LCP.size());\n  }\n};\n\n\nconst int INF = 1 << 30;\n\nstruct SegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n\n\nint main()\n{\n  string S;\n  int Q;\n\n  cin >> S;\n  cin >> Q;\n\n  SuffixArray sa;\n  LongestCommonPrefixArray lcp;\n  SegmentTree tree(S.size());\n\n  sa.Build_SA(S);\n  lcp.Build_LCP(sa);\n  for(int i = 0; i < S.size(); i++) tree.set(i, lcp[i]);\n  tree.build();\n\n  auto getLCP = [&](int a, int b)\n  {\n    if(a > S.size() || b > S.size()) return (INF);\n    a = lcp.rank[a], b = lcp.rank[b];\n    if(a > b) swap(a, b);\n    return (tree.rmq(a + 1, b + 1));\n  };\n\n  while(Q--) {\n    int l, r, t;\n    cin >> l >> r >> t;\n\n    int l1 = --l, r1 = r - t;\n    int l2 = l1 + t, r2 = r;\n    int length = r1 - l1;\n\n    int lcp1 = getLCP(l1, l2);\n\n    /*\n    cout << S.substr(l1, r1 - l1) << endl;\n    cout << string(t, ' ') + S.substr(l2, r2 - l2) << endl;\n    */\n\n    // (>_<)\n    if(lcp1 >= length) {\n      cout << \"Yes\" << endl;\n      continue;\n    }\n\n    int lcp2 = getLCP(l1 + lcp1 + 1, l2 + lcp1 + 1);\n\n    if(lcp1 + 1 + lcp2 >= length) {\n      if(l1 + lcp1 < l2 || l2 + lcp1 >= r1) {\n        cout << \"Yes\" << endl;\n      } else {\n        cout << \"No\" << endl;\n      }\n      continue;\n    }\n\n    if(l1 + lcp1 + 1 + lcp2 < l2) {\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    if(l1 + lcp1 < l2 && lcp2 + 1 == t && S[l1 + lcp1] == S[l2 + lcp1 + t]) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nconst ull B = 1777771;\null S[100010],PB[100010]={1};\nint n;\nstring str;\n\n\null get(int l,int r){return S[r]-S[l]*PB[r-l];}\null get(int l,int r,int x,char ch){\n  ull res=get(l,r);\n  if(x<l||r<=x) return res;\n  return res+ch*PB[r-x-1]-str[x]*PB[r-x-1];\n}\n\nint search(int a,int b,int x,int ch){\n  int L=0,M,R=1e5+1;\n  while(L<R){\n    M = (L+R)/2;\n    if(max(a,b)+M>n||get(a,a+M,x,ch)!=get(b,b+M,x,ch)) R = M;\n    else L = M+1;\n  }\n  return L-1;\n}\n\n\nbool check(int l,int r,int t){\n  int x =l+t+search(l,l+t,-1,0);\n  char ch=str[l+(x-l-t)%t];\n  int a=get(l,r-t,l+(x-l-t)%t,str[x])==get(l+t,r,l+(x-l-t)%t,str[x]);\n  return a||get(l,r-t,x,ch)==get(l+t,r,x,ch);\n}\n\nint main(){\n  cin>>str;\n  n = str.size();\n  for(int i=0;i<n;i++) S[i+1]=S[i]*B+str[i];\n  for(int i=1;i<n;i++) PB[i]=PB[i-1]*B;\n  \n  int q;\n  cin>>q;\n  while(q--){\n    int l,r,t;\n    cin>>l>>r>>t;\n    cout<<(check(l-1,r,t)? \"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  assert(b-a==r-l);\n\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  assert(b-a==r-l);\n\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n  //  calc(l+as,r-t,l+as+t,r);\n\n  if ( calc(l+as,r-t ,l+as+t,r) && (eq(l,l+as,r-as,r) ||eq(l,l+as,r-as-t,r-t) ) )return true;\n  if ( eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-t,r-t+as) || calc(l,l+as,r-t-t,r-t-t+as) ) )return true;\n\n  if ( calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) ) )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && ( calc(l,l+as,r-as,r) || calc(l+t,l+t+as,r-as,r) ) )return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n\n  for(int i=0;i<n;i++){\n    s[i]+=19;\n  }\n\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nstruct RollingHash {\n\tstatic const ll mo0=1000000007,mo1=1000000009; static ll mul0,mul1;\n    static vector<ll> pmo[2];\n\tstring s; int sz; vector<ll> hash_[2];\n\tvoid init(string s) {\n\t\tthis->s=s; sz=(int)s.size();\n\t\thash_[0].resize(sz+1,0),hash_[1].resize(sz+1,0);\n\t\tif(!mul0) mul0=10009+(((ll)&mul0)>>5)%259,mul1=10007+(((ll)&mul1)>>5)%257;\n\t\tif(pmo[0].empty()) pmo[0].pb(1),pmo[1].pb(1);\n\t\trep(i,sz) hash_[0][i+1]=(hash_[0][i]*mul0+s[i])%mo0;\t//hash_[0][i]はインデックス0~i-1までの文字列のハッシュ値\n\t\trep(i,sz) hash_[1][i+1]=(hash_[1][i]*mul1+s[i])%mo1;\n\t}\n\tpair<ll,ll> hash(int l,int r){\t//文字列sのインデックス[l,r]までの部分文字列のハッシュ値\n\t\tif(l>r) return make_pair(0,0);\n\t\twhile((int)pmo[0].size()<r+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n\t\treturn make_pair((hash_[0][r+1]+(mo0-hash_[0][l]*pmo[0][r+1-l]%mo0))%mo0,\n\t\t\t             (hash_[1][r+1]+(mo1-hash_[1][l]*pmo[1][r+1-l]%mo1))%mo1);\n\t}\n    pair<ll,ll> update_hash(int l, int r, int k, char c){  //文字列sのs[k]をcに変えたときの[l,r]までの部分文字列のハッシュ値\n        if(l > k || r < k){\n            return hash(l,r);\n        }\n        while((int)pmo[0].size()<r+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n        return make_pair((hash_[0][r+1]+(mo0-hash_[0][l]*pmo[0][r+1-l]%mo0)+pmo[0][r-k]*((int)c - (int)s[k]))%mo0,\n                         (hash_[1][r+1]+(mo1-hash_[1][l]*pmo[1][r+1-l]%mo1)+pmo[1][r-k]*((int)c - (int)s[k]))%mo1);\n    }\n\tpair<ll,ll> hash(string s) { init(s); return hash(0,(int)s.size()-1); }\t//文字列s全体のハッシュ値\n\tstatic pair<ll,ll> concat(pair<ll,ll> L,pair<ll,ll> R,int RL) { //文字列L+Rのハッシュ値,RLはRの文字列の長さ\n\t\twhile((int)pmo[0].size()<RL+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n\t\treturn make_pair((R.first + L.first*pmo[0][RL])%mo0,(R.second + L.second*pmo[1][RL])%mo1);\n\t}\n};\nvector<ll> RollingHash::pmo[2]; ll RollingHash::mul0,RollingHash::mul1;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    RollingHash rh;\n    rh.init(s);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int x,y,z;\n        cin >> x >> y >> z;\n        --x,--y;\n        pll p1 = rh.hash(x,y-z), p2 = rh.hash(x+z,y);\n        if(p1 == p2){\n            cout << \"Yes\\n\";\n            continue;\n        }\n        int l = 0,r = y-x-z+1;\n        while(r-l>1){\n            int mid = (l+r)/2;\n            if(rh.hash(x,x+l) == rh.hash(x+z,x+z+l)){\n                l = mid;\n            }else{\n                r = mid;\n            }\n        }\n        if(rh.update_hash(x,y-z,x+l,s[x+z+l]) == rh.update_hash(x+z,y,x+l,s[x+z+l])){\n            cout << \"Yes\\n\";\n        }else{\n            if(rh.update_hash(x,y-z,x+z+l,s[x+l]) == rh.update_hash(x+z,y,x+z+l,s[x+l])){\n                cout << \"Yes\\n\";\n            }else{\n                cout << \"No\\n\";\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long Hash;\n\n// h[x] = str[0..x)\nvector<Hash> diffs;\n\nHash h[100010];\nHash p[100010];\nHash w = 8999;\n\n// [l,r)\nHash substr(int l,int r){\n\treturn h[r] - h[l] * p[r-l];\n}\nHash concat(Hash a,Hash b,int blen){\n\treturn a * p[blen] + b;\n}\n\nHash makestr(int l,int r,int t){\n\tint len = r - l;\n\tint Q = len / t;\n\tint R = len % t;\n\tHash res = 0;\n\n\tif( l + t <= r ){\n\n\t\tHash x = substr(l,l+t);\n\t\tint xlen = t;\n\t\n\t\tfor(int i = 0 ; xlen <= len ; i++){\n\t\t\tif( Q >> i & 1 ){\n\t\t\t\tres = concat(res,x,xlen);\n\t\t\t}\n\n\t\t\tx = concat(x,x,xlen);\n\t\t\txlen *= 2;\n\t\t}\n\t}\n\n\tres = concat(res,substr(l,l+R),R);\n\t//cout << res << endl;\n\treturn res;\t\n}\n\n\nHash makestr2(int l,int r,int t){\n\tint len = r - l;\n\tint Q = len / t;\n\tint R = len % t;\n\tint xlen = t;\n\tHash x = substr(l+t,l+2*t);\n\tHash res = 0;\n\tfor(int i = 0 ; xlen <= len ; i++){\n\t\tif( Q >> i & 1 ){\n\t\t\tres = concat(res,x,xlen);\n\t\t}\n\n\t\tx = concat(x,x,xlen);\n\t\txlen *= 2;\n\t}\n\n\tres = concat(res,substr(l,l+R),R);\n\t//cout << res << endl;\n\treturn res;\t\n}\n\n\nint main(){\n\tp[0] = 1;\n\tfor(int i = 1 ; i <= 100000 ; i++)\n\t\tp[i] = p[i-1] * w;\n\tstring S;\n\tcin >> S;\n\th[0] = 0;\n\tfor(int i = 0 ; i < S.size() ; i++){\n\t\th[i+1] = h[i] * w + S[i];\n\t}\n\n\t\n\tdiffs.push_back(0);\n\tfor(char c =0 ; c < 26 ; c++){\n\t\tfor(int i = 0 ; i < 100000 ; i++){\n\t\t\tdiffs.push_back(c*p[i]);\n\t\t\tdiffs.push_back(-c*p[i]);\n\t\t}\n\t}\n\tsort(diffs.begin(),diffs.end());\n\t\n\t\n\tint Q;\n\tcin >> Q;\n\n\tfor(int i = 0 ; i < Q ; i++){\n\t\tint l,r,t;\n\t\tcin >> l >> r >> t;\n\t\t--l;\n\t\t//cout << substr(l,r) - makestr(l,r,t)<< endl;\n\t\t\n\t\tif( binary_search(diffs.begin(),diffs.end(), makestr(l,r,t) - substr(l,r) ) ){\n\t\t\tcout << \"Yes\" << endl;\n\t\t\t\n\t\t}else if( l+2*t <= S.size() and binary_search(diffs.begin(),diffs.end(), makestr2(l,r,t) - substr(l,r) ) ){\n\t\t\t\tcout << \"Yes\" << endl;\n\t\t}else{\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll po(const ll p, const ll n, const ll mod)\n{\n    if (n == 0) { return 1; }\n    if (n % 2 == 1) {\n        return po(p, n - 1, mod) * p % mod;\n    } else {\n        const ll pp = po(p, n / 2, mod);\n        return pp * pp % mod;\n    }\n}\nconstexpr ll inv(const ll p, const ll mod) { return po(p, mod - 2, mod); }\nconstexpr ll BASE1 = 186398169LL;\nconstexpr ll MOD1 = 1000000007LL;\nconstexpr ll INV1 = inv(BASE1, MOD1);\nconstexpr ll BASE2 = 238173201LL;\nconstexpr ll MOD2 = 1000000009LL;\nconstexpr ll INV2 = inv(BASE2, MOD2);\nconstexpr int MAX = 100000;\nP power[MAX], inverse[MAX], h[MAX];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string S;\n    cin >> S;\n    for (ll i = 0, p1 = 1, p2 = 1, i1 = 1, i2 = 1, h1 = 0, h2 = 0; i < S.size(); i++, (p1 *= BASE1) %= MOD1, (p2 *= BASE2) %= MOD2, (i1 *= INV1) %= MOD1, (i2 *= INV2) %= MOD2) { (h1 += (S[i] - 'a') * p1 % MOD1) %= MOD1, (h2 += (S[i] - 'a') * p2 % MOD2) %= MOD2, h[i] = {h1, h2}, inverse[i] = {i1, i2}, power[i] = {p1, p2}; };\n    auto add = [](const P& p1, const P& p2) -> P { return {(p1.first + p2.first) % MOD1, (p1.second + p2.second) % MOD2}; };\n    auto sub = [](const P& p1, const P& p2) -> P { return {(p1.first + MOD1 - p2.first) % MOD1, (p1.second + MOD2 - p2.second) % MOD2}; };\n    auto mul = [](const P& p1, const P& p2) -> P { return {(p1.first * p2.first) % MOD1, (p1.second * p2.second) % MOD2}; };\n    auto getHash = [&](const int s, const int l) -> P { return l == 0 ? P{0, 0} : s == 0 ? h[s + l - 1] : mul(sub(h[s + l - 1], h[s - 1]), inverse[s]); };\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; q++) {\n        int l, r, t;\n        (cin >> l >> r >> t), l--;\n        const int L = r - l;\n        int inf = 0, sup = L - t;\n        while (sup - inf > 1) {\n            const int mid = (inf + sup) / 2;\n            if (getHash(l, mid) == getHash(l + t, mid)) {\n                inf = mid;\n            } else {\n                sup = mid;\n            }\n        }\n        bool ok = false;\n        for (int i = 0; i < 26; i++) {\n            for (int j = 0; j < 2; j++) {\n                const int pos = j == 0 ? inf : inf + t;\n                const P ch = sub({i, i}, {S[pos + l] - 'a', S[pos + l] - 'a'});\n                const P off1 = (pos < L - t ? power[pos] : P{0, 0});\n                const P off2 = (pos >= t ? power[pos - t] : P{0, 0});\n                if (add(getHash(l, L - t), mul(off1, ch)) == add(getHash(l + t, L - t), mul(off2, ch))) {\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        cout << (ok ? \"Yes\\n\" : \"No\\n\");\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  assert(b-a==r-l);\n\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  assert(b-a==r-l);\n\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L])  );\n  //  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n  //  calc(l+as,r-t,l+as+t,r);\n\n  //  if ( calc(l+as,r-t ,l+as+t,r) && ( eq(l,l+as,r-t,r-t+as) || eq(l,l+as,r-t-t,r-t-t+as) ) )return true;\n  //  if ( eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-t,r-t+as) || calc(l,l+as,r-t-t,r-t-t+as) ) )return true;\n\n  if ( calc(l,r-as-t ,l+t,r-as) && eq(l,l+as,r-as,r)  )return true;\n  if ( calc(l+t,r-as ,l,r-as-t) && eq(l+t,l+t+as,r-as,r)  )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && calc(l,l+as,r-as,r)  )return true;\n  \n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n\n  for(int i=0;i<n;i++){\n    s[i]+=19;\n  }\n\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll po(const ll p, const ll n, const ll mod)\n{\n    if (n == 0) { return 1; }\n    if (n % 2 == 1) {\n        return po(p, n - 1, mod) * p % mod;\n    } else {\n        const ll pp = po(p, n / 2, mod);\n        return pp * pp % mod;\n    }\n}\nconstexpr ll inv(const ll p, const ll mod) { return po(p, mod - 2, mod); }\nconstexpr ll BASE1 = 186398169LL;\nconstexpr ll MOD1 = 1000000007LL;\nconstexpr ll INV1 = inv(BASE1, MOD1);\nconstexpr ll BASE2 = 238173201LL;\nconstexpr ll MOD2 = 1000000009LL;\nconstexpr ll INV2 = inv(BASE2, MOD2);\nconstexpr int MAX = 100000;\nP power[MAX], inverse[MAX], h[MAX];\nmap<P, int> phash;\nint main()\n{\n    string S;\n    cin >> S;\n    for (ll i = 0, p1 = 1, p2 = 1, i1 = 1, i2 = 1, h1 = 0, h2 = 0; i < S.size(); i++, (p1 *= BASE1) %= MOD1, (i1 *= INV1) %= MOD1, (p2 *= BASE2) %= MOD2, (i2 *= INV2) %= MOD2) {\n        (h1 += (S[i] - 'a') * p1 % MOD1) %= MOD1, (h2 += (S[i] - 'a') * p2 % MOD2) %= MOD2;\n        power[i] = {p1, p2}, inverse[i] = {i1, i2}, h[i] = {h1, h2};\n        for (int j = 1; j < 26; j++) { phash[{p1 * j % MOD1, p2 * j % MOD2}] = i; }\n    };\n    auto add = [](const P& p1, const P& p2) -> P { return {(p1.first + p2.first) % MOD1, (p1.second + p2.second) % MOD2}; };\n    auto sub = [](const P& p1, const P& p2) -> P { return {(p1.first + MOD1 - p2.first) % MOD1, (p1.second + MOD2 - p2.second) % MOD2}; };\n    auto mul = [](const P& p1, const P& p2) -> P { return {(p1.first * p2.first) % MOD1, (p1.second * p2.second) % MOD2}; };\n    auto getHash = [&](const int s, const int l) -> P { return l == 0 ? P{0, 0} : s == 0 ? h[s + l - 1] : mul(sub(h[s + l - 1], h[s - 1]), inverse[s]); };\n    auto getPoly = [&](const int t, const int rep) -> P { return {(po(power[t].first, rep, MOD1) + MOD1 - 1) * inv(power[t].first + MOD1 - 1, MOD1) % MOD1, (po(power[t].second, rep, MOD2) + MOD2 - 1) * inv(power[t].second + MOD2 - 1, MOD2) % MOD2}; };\n    auto judge = [&](const P& diff, const int L) -> bool { return diff == P{0, 0} or (phash.find(diff) != phash.end() and phash[diff] < L) or (phash.find({(MOD1 - diff.first) % MOD1, (MOD2 - diff.second) % MOD2}) != phash.end() and phash[{-diff.first, -diff.second}] < L); };\n    assert(phash.size() == 25 * S.size());\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; q++) {\n        int l, r, t;\n        (cin >> l >> r >> t), l--;\n        const int L = r - l, rep = L / t, rest = L % t;\n        const P Hash = getHash(l, L);\n        if (rep == 1) {\n            const P mask1 = add(getHash(l, t), mul(power[t * rep], getHash(l + t * rep, rest)));\n            const P diff = sub(mask1, Hash);\n            cout << (judge(diff, L) ? \"Yes\" : \"No\") << endl;\n        } else {\n            const P poly = getPoly(t, rep);\n            const P m1 = getHash(l, t);\n            const P mask1 = add(mul(poly, m1), mul(power[t * rep], getHash(l + t * rep, rest)));\n            const P diff1 = sub(mask1, Hash);\n            const P m2 = getHash(l + t, t);\n            const P mask2 = add(mul(poly, m2), mul(power[t * rep], getHash(l + t * rep, rest)));\n            const P diff2 = sub(mask2, Hash);\n            cout << (judge(diff1, L) or judge(diff2, L) ? \"Yes\" : \"No\") << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tassert(!lsame||rsame);\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  assert(a!=l);\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  assert(b-a==r-l);\n  assert(a!=l);\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  assert(a!=l);\n\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L])  );\n  //  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool intersect(int a,int b,int l,int r){\n  if( b<=l || r<=a ) return false;\n  else return true;\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n  //  calc(l+as,r-t,l+as+t,r);\n\n    if ( calc(l+as,r-t ,l+as+t,r) && ( eq(l,l+as,r-t,r-t+as) || eq(l,l+as,r-t-t,r-t-t+as) ) )return true;\n    if ( eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-t,r-t+as) || calc(l,l+as,r-t-t,r-t-t+as) ) )return true;\n\n  /*\n  if ( calc(l,r-as-t ,l+t,r-as) && eq(l,l+as,r-as,r)  )return true;\n  if ( calc(l+t,r-as ,l,r-as-t) && eq(l+t,l+t+as,r-as,r)  )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && calc(l,l+as,r-as,r)  )return true;\n  */\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n\n  for(int i=0;i<n;i++){\n    s[i]+=19;\n  }\n\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n\tvoid change_st(const int index, const ll from, const ll to)const {\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans = ar - al;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(1, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = getha(L, L + nt / 2 - 1) == getha(L + nt / 2, L + nt - 1);\n\t\t\t\t\t\tbool rsame;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > R) {\n\t\t\t\t\t\t\t\trsame = true;\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trsame = getha(l3, r3) == getha(l4, r4);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP, rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size());\n    LCP[0] = 0;\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i] + 1] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (LCP[k]);\n  }\n\n  size_t size() const\n  {\n    return (LCP.size());\n  }\n};\n\n\nconst int INF = 1 << 30;\n\nstruct SegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n\n\nint main()\n{\n  string S;\n  int Q;\n\n  cin >> S;\n  cin >> Q;\n\n  SuffixArray sa;\n  LongestCommonPrefixArray lcp;\n  SegmentTree tree(S.size());\n\n  sa.Build_SA(S);\n  lcp.Build_LCP(sa);\n  for(int i = 0; i < S.size(); i++) tree.set(i, lcp[i]);\n  tree.build();\n\n  auto getLCP = [&](int a, int b)\n  {\n    if(a > S.size() || b > S.size()) return (INF);\n    a = lcp.rank[a], b = lcp.rank[b];\n    if(a > b) swap(a, b);\n    return (tree.rmq(a + 1, b + 1));\n  };\n\n  while(Q--) {\n    int l, r, t;\n    cin >> l >> r >> t;\n\n    int l1 = --l, r1 = r - t;\n    int l2 = l1 + t, r2 = r;\n    int length = r1 - l1;\n\n    int lcp1 = getLCP(l1, l2);\n\n    /*\n    cout << S.substr(l1, r1 - l1) << endl;\n    cout << string(t, ' ') + S.substr(l2, r2 - l2) << endl;\n    */\n\n    // (>_<)\n    if(lcp1 >= length) {\n      cout << \"Yes\" << endl;\n      continue;\n    }\n\n    int lcp2 = getLCP(l1 + lcp1 + 1, l2 + lcp1 + 1);\n\n    if(lcp1 + 1 + lcp2 >= length) {\n      if(l1 + lcp1 < l2 || l2 + lcp1 >= r1) {\n        cout << \"Yes\" << endl;\n      } else {\n        cout << \"No\" << endl;\n      }\n      continue;\n    }\n\n    if(l1 + lcp1 + 1 + lcp2 < l2) {\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    if(lcp2 + 1 == t && S[l1 + lcp1 + lcp2 + 1 - lcp2 - 1] == S[l1 + lcp1 + lcp2 + 1 + 1 + lcp2]) {\n\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-12;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nclass seg{\npublic:\n\tvector<int>val;\n\tseg(void){val.res(262144);\n\t\tfor(int i=0;i<262144;i++){val[i]=mod;}\n\t}\n\tint ask(int hda,int mgi){\n\t\thda+=131072;\n\t\tmgi+=131072;\n\t\tint ans=mod;\n\t\twhile(hda+1<mgi){\n\t\t\tif(hda%2==0){mineq(ans,val[hda+1]);}\n\t\t\tif(mgi%2==1){mineq(ans,val[mgi-1]);}\n\t\t\thda/=2;mgi/=2;\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid cha(int bas,int num){\n\t\tbas+=131072;\n\t\twhile(bas>1){\n\t\t\tmineq(val[bas],num);\n\t\t\tbas/=2;\n\t\t}\n\t}\n};\nstruct SuffixArray{\n\tvector<int> SA;\n\tvector<int>GYA;//SAの逆\n\tvector<int>LCP;\n\tseg ki;\n\tstring s;\n\tvoid Build_SA(const string& str){\n\t\ts = str;\n\t\tSA.resize(s.size());\n\t\tiota(begin(SA), end(SA), 0);\n\t\tsort(begin(SA), end(SA), [&](const int& a, const int& b)\n\t\t{\n\t\t\tif(s[a] == s[b]) {return(a > b);}\n\t\t\treturn (s[a] < s[b]);\n\t\t});\n\t\tvector< int > classes(s.size()), c(s.size()), cnt(s.size());\n\t\tfor(int i = 0; i < s.size(); i++) {c[i] = s[i];}\n\t\tfor(int len = 1; len < s.size(); len <<= 1) {\n\t\t\tfor(int i = 0; i < s.size(); i++) {\n\t\t\t\tif(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n\t\t\t\t\tclasses[SA[i]] = classes[SA[i - 1]];\n\t\t\t\t} else {\n\t\t\t\t\tclasses[SA[i]] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tiota(begin(cnt), end(cnt), 0);\n\t\t\tcopy(begin(SA), end(SA), begin(c));\n\t\t\tfor(int i = 0; i < s.size(); i++) {\n\t\t\t\tint s1 = c[i] - len;\n\t\t\t\tif(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n\t\t\t}\n\t\t\tclasses.swap(c);\n\t\t}\n\t\tint ss=s.size();\n\t\tSA.insert(SA.begin(),ss);\n\t}\n\tint operator[](int k) const{return (SA[k]);}\n\tint size() const{return (s.size()+1);}\n\tbool lt_substr(string& t, int si = 0, int ti = 0)\n\t{\n\t\tint sn = s.size(), tn = t.size();\n\t\twhile(si < sn && ti < tn) {\n\t\t\tif(s[si] < t[ti]) return (true);\n\t\t\tif(s[si] > t[ti]) return (false);\n\t\t\t++si, ++ti;\n\t\t}\n\t\treturn (si >= sn && ti < tn);\n\t}\n\tint lower_bound(string& t)\n\t{\n\t\tint low = -1, high = SA.size();\n\t\twhile(high - low > 1) {\n\t\t\tint mid = (low + high) >> 1;\n\t\t\tif(lt_substr(t, SA[mid])) low = mid;\n\t\t\telse high = mid;\n\t\t}\n\t\treturn (high);\n\t}\n\tpair< int, int > lower_upper_bound(string& t)\n\t{\n\t\tint idx = lower_bound(t);\n\t\tint low = idx - 1, high = SA.size();\n\t\tt.back()++;\n\t\twhile(high - low > 1) {\n\t\t\tint mid = (low + high) >> 1;\n\t\t\tif(lt_substr(t, SA[mid])) low = mid;\n\t\t\telse high = mid;\n\t\t}\n\t\tt.back()--;\n\t\treturn (make_pair(idx, high));\n\t}\n\tvoid output()\n\t{\n\t\tfor(int i = 0; i < size(); i++) {\n\t\t\tcout << i << \": \" << s.substr(SA[i]) <<\" \"<<LCP[i]<< endl;\n\t\t}\n\t}\n\tvoid Build_LCP(void){\n\t\tGYA.resize(s.size()+1);\n\t\tLCP.resize(s.size()+1);\n\t\tint n=s.size(),i;\n\t\tfor(i=0;i<=n;i++){GYA[SA[i]]=i;}\n\t\tint h=0;LCP[0]=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tint j=SA[GYA[i]-1];\n\t\t\tif(h>0){h--;}\n\t\t\tfor(;j+h<n&&i+h<n;h++){\n\t\t\t\tif(s[j+h]!=s[i+h]){break;}\n\t\t\t}\n\t\t\tLCP[GYA[i]-1]=h;\n\t\t\tki.cha(GYA[i],h);\n\t\t}\n\t}\n\tint LCP_mozi(int l,int r){//何文字一致?\n\t\tl=GYA[l];r=GYA[r];\n\t\tif(l>r){swap(l,r);}\n\t\treturn ki.ask(l,r+1);\n\t}\n};\nint main(void){\n\tcout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);\n\tstring s;cin>>s;s.pub('#');\n\tSuffixArray sa;\n\tsa.Build_SA(s);\n\t\n\tsa.Build_LCP();\n\t//sa.output();\n\tint Q;cin>>Q;\n\twhile(Q--){\n\t\tint l,r,t,T;cin>>l>>r>>t;l--;\n\t\tT=t;\n\t\twhile(T*2<r-l){T*=2;}\n\t\tint kai=0,hen=0;\n\t\tbool can=true;\n\t\twhile(T>=t){\n\t\t\t//cerr<<\"T=\"<<T<<endl;\n\t\t\tint iti=sa.LCP_mozi(l,l+T);\n\t\t\t//cerr<<\"iti=\"<<iti<<endl;\n\t\t\tif(kai==0){\n\t\t\t\tif(iti<r-l-T){\n\t\t\t\t\then=1;\n\t\t\t\t\tint bas=l+iti;//当たった場所\n\t\t\t\t\tif(sa.LCP_mozi(bas+1,bas+1+T)+iti+1<r-l-T){can=false;break;}\n\t\t\t\t\tint aaa=(iti>=T/2?iti-T/2:iti+T/2);\n\t\t\t\t\tif(s[l+iti]!=s[l+aaa]){l=r-T;}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(kai==1){\n\t\t\t\tif(iti<T){\n\t\t\t\t\tif(hen>0){can=false;break;}\n\t\t\t\t\tint bas=l+iti;//当たった場所\n\t\t\t\t\tif(sa.LCP_mozi(bas+1,bas+1+T)+iti+1<T){can=false;break;}//2回ダメ来た\n\t\t\t\t\tint zyu=r-l-T-T;//重複度\n\t\t\t\t\tint aaa=(iti>=T/2?iti-T/2:iti+T/2);\n\t\t\t\t\t//cerr<<\"aaa=\"<<aaa<<endl;\n\t\t\t\t\tif(iti+T<zyu){can=false;break;}\n\t\t\t\t\telse if(iti>=zyu&&s[l+iti]!=s[l+aaa]){l+=T;}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(iti<T){can=false;break;}\n\t\t\t}\n\t\t\tkai++;T/=2;\n\t\t}\n\t\tcout<<(can?\"Yes\":\"No\")<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n#define B 10007\n\nll mod_pow(ll a,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*a%mod;\n    a=a*a%mod;\n    n>>=1;\n  }\n  return res;\n}\n\nll N,Q;\nstring S;\nll hsum[100010];\n\nll calchash(ll l,ll r){\n  return ((hsum[r]-hsum[l]+mod)%mod)*mod_pow(mod_pow(B,l),mod-2)%mod;\n}\n\nll calchash2(ll l,ll r,ll k,char c){\n  return (calchash(l,k)+c*mod_pow(B,k-l)%mod+calchash(k+1,r)*mod_pow(B,k+1-l)%mod)%mod;\n}\n\nint main(){\n  cin>>S;\n  N=S.size();\n  ll p=1;\n  rep(i,N){\n    hsum[i+1]=(hsum[i]+S[i]*p)%mod;\n    (p*=B)%=mod;\n  }\n\n  cin>>Q;\n  while(Q--){\n    ll L,R,T;\n    cin>>L>>R>>T;\n    L--;\n    ll lb=L,ub=R-T+1;\n    while(ub-lb>1){\n      ll mid=(lb+ub)/2;\n      if(calchash(L,mid)==calchash(L+T,mid+T))lb=mid;\n      else ub=mid;\n    }\n    if(lb==R-T){\n      cout<<\"Yes\"<<endl;\n      continue;\n    }\n\n    { // lb\n      ll v1=calchash2(L,R-T,lb,S[lb+T]);\n      ll v2;\n      if(lb<L+T){\n        v2=calchash(L+T,R);\n      }else{\n        v2=calchash2(L+T,R,lb,S[lb+T]);\n      }\n      if(v1==v2){\n        cout<<\"Yes\"<<endl;\n        continue;\n      }\n    }\n    { // lb+T\n      ll v1;\n      if(lb+T>=R-T){\n        v1=calchash(L,R-T);\n      }else{\n        v1=calchash2(L,R-T,lb+T,S[lb]);\n      }\n      ll v2=calchash2(L+T,R,lb+T,S[lb]);\n      if(v1==v2){\n        cout<<\"Yes\"<<endl;\n        continue;\n      }\n    }\n    cout<<\"No\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Ti = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nusing ull = unsigned long long;\nstruct RollingHash {\n  string s;\n  ull base, mod;\n  vector<ull> hashed, power;\n  RollingHash(const string& s):s(s), base(9973ll), mod(999999937ll){\n    int sz = s.size();\n    hashed.resize(sz+1, 0);\n    power.resize(sz+1, 0);\n    power[0] = 1;\n    for(int i = 0; i < sz; i++) {\n      power[i+1] = power[i]*base%mod;\n      hashed[i+1] = (hashed[i]*base%mod+s[i])%mod;\n    }\n  }\n  ull get(int l, int r) {\n    return (hashed[r]-hashed[l]*power[r-l]%mod+mod)%mod;\n  }\n  ull concat(ull h1, ull h2, int len) {\n    return (h1*power[len]%mod+h2)%mod;\n  }\n  ull rehash(int l, int r, int i, char c) {\n    if(i < l || r <= i) return get(l, r);\n    //cout << r-l << \" \" << s.substr(l, r-l) << \" \" << s.substr(l, i-l) << endl;\n    ull h = get(l, i);\n    //cout << l << \" \" << r << \" \" << i << \" \" << c <<  \" \" << h << endl;\n    h = (h*base%mod + c)%mod;\n    return concat(h, get(i+1, r), r-(i+1));\n  }\n};\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  string s;\n  cin >> s;\n  RollingHash rh(s);\n\n  int q;\n  cin >> q;\n  while(q--) {\n    int l, r, t;\n    cin >> l >> r >> t;\n    --l;\n    if(rh.get(l, r-t) == rh.get(l+t, r)) {\n      cout << \"Yes\" << endl;\n      continue;\n    }\n    int lb = 0, ub = r-l+1;\n    while(lb+1 < ub) {\n      int mb = (lb+ub)/2;\n      if(rh.get(l, l+mb) == rh.get(l+t, l+t+mb)) lb = mb;\n      else ub = mb;\n    }\n    //cout << rh.get(l, l+lb) << \" \" << rh.get(l+t, l+t+lb) << endl;\n    //cout << lb << \" \" << s[l+lb] << \" \" << s[l+t+lb] << endl;\n    //cout << rh.rehash(l, r-t, l+lb, s[l+lb]) << \" \" << rh.get(l, r-t) << endl;\n    //cout << rh.rehash(l+t, r, l+t+lb, s[l+lb]) <<  \" \" << rh.get(l+t, r) << endl;\n    if((rh.rehash(l, r-t, l+lb, s[l+t+lb]) == rh.rehash(l+t, r, l+lb, s[l+t+lb])) ||\n       (rh.rehash(l, r-t, l+t+lb, s[l+lb]) == rh.rehash(l+t, r, l+t+lb, s[l+lb]))) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n  if ( calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) ) )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && ( calc(l,l+as,r-as,r) || calc(l+t,l+t+as,r-as,r) ) )return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long Hash;\n\n// h[x] = str[0..x)\nvector<Hash> diffs;\n\nHash h[100010];\nHash p[100010];\nHash w = 8999;\n\n// [l,r)\nHash substr(int l,int r){\n\treturn h[r] - h[l] * p[r-l];\n}\nHash concat(Hash a,Hash b,int blen){\n\treturn a * p[blen] + b;\n}\n\nHash makestr(int l,int r,int t){\n\tint len = r - l;\n\tint Q = len / t;\n\tint R = len % t;\n\tint xlen = t;\n\tHash x = substr(l,l+t);\n\tHash res = 0;\n\tfor(int i = 0 ; i < 17 ; i++){\n\t\tif( Q >> i & 1 ){\n\t\t\tres = concat(res,x,xlen);\n\t\t}\n\n\t\tx = concat(x,x,xlen);\n\t\txlen *= 2;\n\t}\n\n\tres = concat(res,substr(l,l+R),R);\n\t//cout << res << endl;\n\treturn res;\t\n}\n\n\nHash makestr2(int l,int r,int t){\n\tint len = r - l;\n\tint Q = len / t;\n\tint R = len % t;\n\tint xlen = t;\n\tHash x = substr(l+t,l+2*t);\n\tHash res = 0;\n\tfor(int i = 0 ; i < 17 ; i++){\n\t\tif( Q >> i & 1 ){\n\t\t\tres = concat(res,x,xlen);\n\t\t}\n\n\t\tx = concat(x,x,xlen);\n\t\txlen *= 2;\n\t}\n\n\tres = concat(res,substr(l,l+R),R);\n\t//cout << res << endl;\n\treturn res;\t\n}\n\n\nint main(){\n\tp[0] = 1;\n\tfor(int i = 1 ; i <= 100000 ; i++)\n\t\tp[i] = p[i-1] * w;\n\tstring S;\n\tcin >> S;\n\th[0] = 0;\n\tfor(int i = 0 ; i < S.size() ; i++){\n\t\th[i+1] = h[i] * w + S[i];\n\t}\n\t\n\tdiffs.push_back(0);\n\tfor(char c =0 ; c < 26 ; c++){\n\t\tfor(int i = 0 ; i < 100000 ; i++){\n\t\t\tdiffs.push_back(c*p[i]);\n\t\t\tdiffs.push_back(-c*p[i]);\n\t\t}\n\t}\n\tsort(diffs.begin(),diffs.end());\n\t\n\t\n\tint Q;\n\tcin >> Q;\n\n\tfor(int i = 0 ; i < Q ; i++){\n\t\tint l,r,t;\n\t\tcin >> l >> r >> t;\n\t\t--l;\n\t\t//cout << substr(l,r) - makestr(l,r,t)<< endl;\n\t\tif( binary_search(diffs.begin(),diffs.end(), makestr(l,r,t) - substr(l,r) ) ){\n\t\t\tcout << \"Yes\" << endl;\n\t\t}else if( l+2*t <= S.size() and binary_search(diffs.begin(),diffs.end(), makestr2(l,r,t) - substr(l,r) ) ){\n\t\t\t\tcout << \"Yes\" << endl;\n\t\t}else{\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  assert(b-a==r-l);\n\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  assert(b-a==r-l);\n\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n\n  if (( calc(l+as,r-t ,l+as+t,r) && (   eq(l,l+as,r-t,r-t+as) ||   eq(l,l+as,r-t-t,r-t-t+as) ) ) ||\n       (eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-t,r-t+as) || calc(l,l+as,r-t-t,r-t-t+as) )) )\n\n    if ( (calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) )) ||\n           ( eq(l,r-as-t ,l+t,r-as) && ( calc(l,l+as,r-as,r) || calc(l+t,l+t+as,r-as,r) ) )\n           )return true;\n\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n\n  for(int i=0;i<n;i++){\n    s[i]+=19;\n  }\n\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n\tvoid change_st(const int index, const ll from, const ll to)const {\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const pair<int, int>a, const pair<int, int>b) {\n\tint al = a.first, ar = a.second;\n\tint bl = b.first, br = b.second;\n\tint lans = -1;\n\tint rans = ar - al;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(1, -1);\n\t\telse {\n\n\t\t\tint acheck = check(make_pair(a, a + len), (make_pair(b, b + len)));\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = getha(L, L + nt / 2 - 1) == getha(L + nt / 2, L + nt - 1);\n\t\t\t\t\t\tbool rsame;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > R) {\n\t\t\t\t\t\t\t\trsame = true;\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trsame = getha(l3, r3) == getha(l4, r4);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint NN,k;\nint ran[100005];\nint tmp[100005];\nint sa[100005];\n\nbool compare_sa(int i,int j)\n{\n\tif(ran[i] != ran[j]) return ran[i] < ran[j];\n\telse\n\t{\n\t\tint ri = i+k<=NN ? ran[i+k]: -1;\n\t\tint rj = j+k<=NN ? ran[j+k]: -1;\n\t\t\n\t\treturn ri < rj;\n\t}\n}\n\nvoid construct_sa(string S)\n{\n\tNN = S.size();\n\tfor(int i=0;i<=NN;i++)\n\t{\n\t\tsa[i] = i;\n\t\tran[i] = i<NN?S[i]:-1;\n\t}\n\t\n\tfor(k=1;k<=NN;k*=2)\n\t{\n\t\tsort(sa,sa+NN+1,compare_sa);\n\t\t\n\t\ttmp[sa[0]] = 0;\n\t\tfor(int i=1;i<=NN;i++)\n\t\t{\n\t\t\ttmp[sa[i]] = tmp[sa[i-1]] + compare_sa(sa[i-1],sa[i]);\n\t\t}\n\t\tfor(int i=0;i<=NN;i++)\n\t\t{\n\t\t\tran[i] = tmp[i];\n\t\t}\n\t}\n}\nint lcp[100005];\nvoid construct_lcp(string S)\n{\n\tint n = S.size();\n\tfor(int i=0;i<=n;i++) ran[sa[i]] = i;\n\t\n\tint h = 0;\n\tlcp[0] = 0;\n\t\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint j = sa[ran[i]-1];\n\t\t\n\t\tif(h) h--;\n\t\tfor(;j+h<n && i+h<n;h++)\n\t\t{\n\t\t\tif(S[j+h] != S[i+h]) break;\n\t\t}\n\t\tlcp[ran[i]-1] = h;\n\t}\n}\n\nint seg[(1<<18)+5];\nvoid update(int k,int a){\n\tk+=(1<<17)-1; seg[k] = a;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tseg[k]=min(seg[k*2+1],seg[k*2+2]);\n\t}\n}\nint query(int a,int b,int k,int l,int r){\n\tif(r<a || b<l) return INF;\n\tif(a<=l && r<=b) return seg[k];\n\telse{\n\t\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\tint vr=query(a,b,k*2+2,(l+r)/2+1,r);\n\t\treturn min(vl,vr);\n\t}\n}\nstring s;\nint main(){\n\tcin >> s;\n\tconstruct_sa(s);\n\tconstruct_lcp(s);\n\tfor(int i=0;i<s.size();i++){\n\t\tupdate(i,lcp[i]);\n\t}\n\tint q; cin >> q;\n\tfor(int i=0;i<q;i++){\n\t\tint L,R,T; cin >> L >> R >> T;\n\t\tif(R-L+1 <= T){\n\t\t\tputs(\"Yes\"); continue;\n\t\t}\n\t\tint P = ran[L-1];\n\t\tint Q = ran[L+T-1];\n\t\tint len = query(min(P,Q),max(P,Q)-1,0,0,(1<<17)-1); //cout << len << endl;\n\t\tif(len >= R-L+1-T){\n\t\t\tputs(\"Yes\");\n\t\t}\n\t\telse{\n\t\t\tP = ran[L-1+len+1];\n\t\t\tQ = ran[L+T-1+len+1];\n\t\t\tint len2 = query(min(P,Q),max(P,Q)-1,0,0,(1<<17)-1);//cout << len << endl;\n\t\t\tint D = (T-1-len%T); D = min(D,R-L-T-len);//cout << D ;\n\t\t\tif(len2<D) puts(\"No\");\n\t\t\telse{\n\t\t\t\tif(D != T-1-len%T) puts(\"Yes\");\n\t\t\t\telse{\n\t\t\t\t\tif(L-1+T+T+len+D+1 <= R){\n\t\t\t\t\t\tP = ran[L-1+T+len+D+1]; \n\t\t\t\t\t\tQ = ran[L-1+T+T+len+D+1];\n\t\t\t\t\t\tint len3 = query(min(P,Q),max(P,Q)-1,0,0,(1<<17)-1);\n\t\t\t\t\t\tif(len3 < R-L-T-T-len-D){\n\t\t\t\t\t\t\tputs(\"No\"); continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tP = ran[L-1];\n\t\t\t\t\tQ = ran[L-1+T+len+D+1];\n\t\t\t\t\tint len4 = query(min(P,Q),max(P,Q)-1,0,0,(1<<17)-1);\n\t\t\t\t\tint E = min(T,R-L-T-len-D);\n\t\t\t\t\tP = ran[L-1+len+D+1];\n\t\t\t\t\tQ = ran[L-1+T+len+D+1];\n\t\t\t\t\tint len5 = query(min(P,Q),max(P,Q)-1,0,0,(1<<17)-1);\n\t\t\t\t\tint F = min(T,R-L-T-len-D);\n\t\t\t\t\tputs((len4 >= E)||(len5 >= F)?\"Yes\":\"No\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(rsame){\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassert(issame(L, L + nt, nt - 1).first);\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nll n,m,a,b,p,q;\n\nint main(){\n\tcin>>n>>m>>a>>b>>p>>q;\n\tvl x;\n\tbool B=0;\n\tdo{\n\t\tif(p+q>m) B=1;\n\t\tx.push_back(p+q);\n\t\tif(INF/p>a) p*=a;\n\t\telse break;\n\t\tif(INF/q>b) q*=b;\n\t\telse break;\n\t}while(!B);\n\tint S=x.size(),S2=S/2,T=S-S2;\n\tvl c(1<<S2);\n\tfor(int i=0;i<1<<S2;i++){\n\t\tfor(int j=0;j<S2;j++) if(i&1<<j) c[i]+=x[j];\n\t}\n\tsort(c.begin(),c.end());\n\tll res=INF;\n\tfor(int i=0;i<1<<T;i++){\n\t\tll tmp=0;\n\t\tfor(int j=0;j<T;j++) if(i&1<<j) tmp+=x[S2+j];\n\t\tauto it=lower_bound(c.begin(),c.end(),m-tmp);\n\t\tif(it!=c.end()) res=min(res,abs(m-tmp-*it));\n\t\tif(it!=c.begin()) res=min(res,abs(m-tmp-*(it-1)));\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconst ll mod = 1e9 + 7;\nconst ll b1 = 1009, b2 = 10007;\n\nll Pow(ll a, ll b) {\n\tll res = 1; a %= mod;\n\twhile (b) {\n\t\tif (b & 1) {\n\t\t\tres = (res * a) % mod;\n\t\t}\n\t\ta = (a * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nclass RollingHash {\n\tint N;\n\tstring s;\n\tvector<ll> r1, r2, h1, h2, rh1, rh2;\npublic:\n\tRollingHash(const string& s_)\n\t\t: N((int)s_.size()), s(s_), r1(N + 1), r2(N + 1), h1(N + 1), h2(N + 1), rh1(N + 1), rh2(N + 1) {\n\t\tr1[0] = r2[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) r1[i] = r1[i - 1] * b1 % mod;\n\t\tfor (int i = 1; i <= N; i++) r2[i] = r2[i - 1] * b2 % mod;\n\n\t\th1[0] = h2[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) h1[i] = (h1[i - 1] * b1 + s[i - 1]) % mod;\n\t\tfor (int i = 1; i <= N; i++) h2[i] = (h2[i - 1] * b2 + s[i - 1]) % mod;\n\t}\n\tP get(int l, int r) {\n\t\treturn P((h1[r + 1] - h1[l] * r1[r - l + 1] % mod + mod) % mod, (h2[r + 1] - h2[l] * r2[r - l + 1] % mod + mod) % mod);\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint Q;\n\tstring S;\n\tcin >> S >> Q;\n\tint N = S.size();\n\tRollingHash rh(S);\n\tvector<P> dis;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = -25; j <= 25; j++) {\n\t\t\tdis.push_back(P(Pow(b1, i) * (mod + j) % mod, Pow(b2, i) * (mod + j) % mod));\n\t\t}\n\t}\n\tsort(dis.begin(), dis.end());\n\tfor (int i = 0, l, r, t; i < Q; i++) {\n\t\tcin >> l >> r >> t; l--; r--;\n\t\tauto lrh = rh.get(l, r - t), rrh = rh.get(l + t, r);\n\t\tll d1 = (lrh.first - rrh.first + mod) % mod, d2 = (lrh.second - rrh.second + mod) % mod;\n\t\tif (r - l + 1 > t * 2) {\n\t\t\tif (binary_search(dis.begin(), dis.end(), P(d1, d2))) {\n\t\t\t\tputs(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint w = r - l + 1 , fl = (r - l + 1) / t * t;\n\t\t\t\tif (w == fl && rh.get(l, l + t - 1) != rh.get(r - t + 1, r)) {\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (w != fl && (rh.get(l, l + w - fl - 1) != rh.get(r - (w - fl - 1), r) || rh.get(l + w - fl, l + t - 1) != rh.get(r - t + 1, r - (w - fl)))) {\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tll lb = t - 1, ub = r - l + 1 - t;\n\t\t\t\twhile (lb + 1 < ub) {\n\t\t\t\t\tll c = (lb + ub) / 2;\n\t\t\t\t\tlrh = rh.get(l, l + c - 1), rrh = rh.get(l + t, l + t + c - 1);\n\t\t\t\t\td1 = (lrh.first - rrh.first + mod) % mod, d2 = (lrh.second - rrh.second + mod) % mod;\n\t\t\t\t\tif (binary_search(dis.begin(), dis.end(), P(d1, d2))) {\n\t\t\t\t\t\tlb = c;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tub = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tll tmp = lb;\n\t\t\t\tlb = t - 1, ub = r - l + 1 - t;\n\t\t\t\twhile (lb + 1 < ub) {\n\t\t\t\t\tll c = (lb + ub) / 2;\n\t\t\t\t\tlrh = rh.get(r - t - c + 1, r - t), rrh = rh.get(r - c + 1, r);\n\t\t\t\t\td1 = (lrh.first - rrh.first + mod) % mod, d2 = (lrh.second - rrh.second + mod) % mod;\n\t\t\t\t\tif (binary_search(dis.begin(), dis.end(), P(d1, d2))) {\n\t\t\t\t\t\tlb = c;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tub = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tputs(tmp + lb >= r - l ? \"Yes\" : \"No\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tputs(binary_search(dis.begin(), dis.end(), P(d1, d2)) ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long Hash;\n\n// h[x] = str[0..x)\nvector<Hash> diffs;\n\nHash h[100010];\nHash p[100010];\nHash w = 8999;\n\n// [l,r)\nHash substr(int l,int r){\n\treturn h[r] - h[l] * p[r-l];\n}\nHash concat(Hash a,Hash b,int blen){\n\treturn a * p[blen] + b;\n}\n\nHash makestr(int l,int r,int t){\n\tint len = r - l;\n\tint Q = len / t;\n\tint R = len % t;\n\tHash res = 0;\n\n\tif( l + t <= r ){\n\n\t\tHash x = substr(l,l+t);\n\t\tint xlen = t;\n\t\n\t\tfor(int i = 0 ; xlen <= len ; i++){\n\t\t\tif( Q >> i & 1 ){\n\t\t\t\tres = concat(res,x,xlen);\n\t\t\t}\n\n\t\t\tx = concat(x,x,xlen);\n\t\t\txlen *= 2;\n\t\t}\n\t}\n\n\tres = concat(res,substr(l,l+R),R);\n\t//cout << res << endl;\n\treturn res;\t\n}\n\n\nHash makestr2(int l,int r,int t){\n\tint len = r - l;\n\tint Q = len / t;\n\tint R = len % t;\n\tint xlen = t;\n\tHash x = substr(l+t,l+2*t);\n\tHash res = 0;\n\tfor(int i = 0 ; xlen <= len ; i++){\n\t\tif( Q >> i & 1 ){\n\t\t\tres = concat(res,x,xlen);\n\t\t}\n\n\t\tx = concat(x,x,xlen);\n\t\txlen *= 2;\n\t}\n\n\tres = concat(res,substr(l+t,l+t+R),R);\n\t//cout << res << endl;\n\treturn res;\t\n}\n\n\nint main(){\n\tp[0] = 1;\n\tfor(int i = 1 ; i <= 100000 ; i++)\n\t\tp[i] = p[i-1] * w;\n\tstring S;\n\tcin >> S;\n\th[0] = 0;\n\tfor(int i = 0 ; i < S.size() ; i++){\n\t\th[i+1] = h[i] * w + S[i];\n\t}\n\n\t\n\tdiffs.push_back(0);\n\tfor(char c =0 ; c < 26 ; c++){\n\t\tfor(int i = 0 ; i < 100000 ; i++){\n\t\t\tdiffs.push_back(c*p[i]);\n\t\t\tdiffs.push_back(-c*p[i]);\n\t\t}\n\t}\n\tsort(diffs.begin(),diffs.end());\n\t\n\t\n\tint Q;\n\tcin >> Q;\n\n\tfor(int i = 0 ; i < Q ; i++){\n\t\tint l,r,t;\n\t\tcin >> l >> r >> t;\n\t\t--l;\n\t\t//cout << substr(l,r) - makestr(l,r,t)<< endl;\n\t\t\n\t\tif( binary_search(diffs.begin(),diffs.end(), makestr(l,r,t) - substr(l,r) ) ){\n\t\t\tcout << \"Yes\" << endl;\n\t\t\t\n\t\t}else if( l+2*t <= S.size() and binary_search(diffs.begin(),diffs.end(), makestr2(l,r,t) - substr(l,r) ) ){\n\t\t\t\tcout << \"Yes\" << endl;\n\t\t}else{\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n\ntypedef long long ll;\n\n\ntemplate<class T>\nstruct RollingHash {\n\tstatic const int NN = 2; // the number of hash table\n\tT base[NN] = {1009, 1007};\n\tT PMOD[NN] = {1000000007, 1000000009};\n\tvector<T> hash[NN];\n\tvector<T> mypow[NN];\n\tint sz;\n\tvoid init(string s) {\n\t\tsz = s.size();\n\t\tfor(int i = 0; i < NN; i++) {\n\t\t\thash[i].assign(sz + 1, 0);\n\t\t\tmypow[i].assign(sz + 1, 0);\n\t\t\tmypow[i][0] = 1;\n\t\t}\n\t\tfor(int i = 0; i < NN; i++) {\n\t\t\tfor(int j = 0; j < sz; j++) {\n\t\t\t\thash[i][j + 1] = (hash[i][j] * base[i] + s[j]) % PMOD[i];\n\t\t\t\tmypow[i][j + 1] = mypow[i][j] * base[i] % PMOD[i];\n\t\t\t}\n\t\t}\n\t}\n\tRollingHash() {\n\t}\n\t// hash[t] value of s[l..r]\n\tT get(int l, int r, int t) {\n\t\tT ret = (hash[t][r + 1] - hash[t][l] * mypow[t][r - l + 1] % PMOD[t] + PMOD[t]) % PMOD[t];\n\t\treturn ret;\n\t}\n\t// compare s[a..b] and s[c..d] O(1)\n\tbool comp(int a, int b, int c, int d) {\n\t\tif(a < 0 || sz <= b || c < 0 || sz <= d) return false;\n\t\tfor(int i = 0; i < NN; i++) {\n\t\t\tif(get(a, b, i) != get(c, d, i)) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t// longest common extension s[l..LCE(l,r)] == s[r..LCE(l,r)] && s[l..LCE(l,r)+1] != s[r..LCE(l,r)+1]\n\tint LCE(int l,int r){\n\t\ttie(l,r)=minmax(l,r);\n\t\tif(l==r) return sz-r+1;\n\t\tint ll = 0;\n\t\tint rr = sz;\n\t\twhile(rr-ll>1){\n\t\t\tint mid = (ll+rr)>>1;\n\t\t\tif(comp(l,l+mid-1,r,r+mid-1)) ll=mid;\n\t\t\telse rr=mid;\n\t\t}\n\t\treturn ll;\n\t}\n};\n\n\nint main(){\n\tstring s;\n\tcin>>s;\n\tint Q;\n\tcin>>Q;\n\tRollingHash<ll> rh;\n\trh.init(s);\n\trep(_,Q){\n\t\tint l, r, t;\n\t\tcin>>l>>r>>t;\n\t\tl--;\n\t\tr--;\n\t\tbool ok = false;\n\t\tif(r-l+1==t){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint a = rh.LCE(l,l+t);\n\t\tif(l+a>=r+1-t){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint nl = l+a+1;\n\t\ta = rh.LCE(nl, nl+t);\n\t\tif(nl+a>=r+1-t){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(a==t-1){\n\t\t\tif(s[nl-1]==s[nl+2*t-1]){\n\t\t\t\tnl += a+1;\n\t\t\t\ta = rh.LCE(nl, nl+t);\n\t\t\t\tif(nl+a>=r+1-t){\n\t\t\t\t\tcout<<\"Yes\"<<endl;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<\"No\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define M 1e9+7\n//#define M 1777771\nusing namespace std;\ntypedef unsigned long long ull;\n\nstring s;\nint q;\null H[N], D[N];\n\nvoid cal_hash(){\n  ull h=0;\n  for(int i=0;i<s.size();i++){\n    h=h*M+s[i];\n    H[i+1]=h;\n  }\n  h=1;\n  for(int i=0;i<N;i++){\n    D[i]=h;\n    h*=M;\n  }\n  s='X'+s;\n}\n\nint get_first_diff_idx(int l, int r, int t){\n  \n  int L=0, R=r-l-t+2;\n  \n  while(L<R){\n    \n    int Mid=(L+R)/2;\n    ull v1=H[l+Mid]-H[l-1]*D[Mid+1];\n    ull v2=H[l+Mid+t]-H[l+t-1]*D[Mid+1];\n    cout<<v1<<' '<<v2<<endl;\n    if(v1==v2) L=Mid+1;\n    else R=Mid;\n  }\n  \n  return L;\n}\n\nbool isSame(int l, int r, int t, int A, int B){\n  \n  int i1=l+t, i2=r;\n  ull h1, h2;\n  \n  if(i1<=A&&A<=i2){\n    \n    if(i1<A&&A<i2) h1=H[i2]+((H[A-1]-H[i1-1]*D[A-i1])*D[1]+s[B])*D[i2-A];\n    else if(A==i1) h1=H[i2]-H[i1]*D[i2-i1]+s[B]*D[i2-i1];\n    else if(A==i2) h1=s[B]+(H[i2-1]-H[i1-1]*D[i2-i1])*D[1];\n    \n  }else h1=H[i2]-H[i1-1]*D[i2-i1+1];\n  \n  i1=l, i2=r-t;\n  \n  if(i1<=B&&B<=i2){\n    \n    if(i1<B&&B<i2) h2=H[i2]+((H[B-1]-H[i1-1]*D[B-i1])*D[1]+s[A])*D[i2-B];\n    else if(B==i1) h2=H[i2]-H[i1]*D[i2-i1]+s[A]*D[i2-i1];\n    else if(B==i2) h2=s[A]+(H[i2-1]-H[i1-1]*D[i2-i1])*D[1];\n    \n  }else h2=H[i2]-H[i1-1]*D[i2-i1+1];\n  \n  return h1==h2;\n}\n\nbool check(int l, int r, int t){\n  \n  /*if((r-l+1)%t!=0) return false;\n    if((r-l+1)==t) return true;*/\n  \n  int idx=get_first_diff_idx(l, r, t);\n\n  int i1=l+idx, i2=l+t+idx;\n  cout<<idx<<endl;\n  return isSame(l, r, t, i1, i2) | isSame(l, r, t, i2, i1);\n}\n\nint main(){\n  \n  cin>>s;\n  \n  cal_hash();\n  \n  cin>>q;\n  \n  int l, r, t;\n  \n  for(int i=0;i<q;i++){\n    scanf(\"%d %d %d\", &l, &r, &t);\n    if(check(l, r, t)) printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=575;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  assert(b-a==r-l);\n\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  assert(b-a==r-l);\n\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n\n  if ( calc(l+as,r-t ,l+as+t,r) && (   eq(l,l+as,r-t,r-t+as) ||   eq(l,l+as,r-t-t,r-t-t+as) ) )return true;\n  if (   eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-t,r-t+as) || calc(l,l+as,r-t-t,r-t-t+as) ) )return true;\n\n  if ( calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) ) )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && ( calc(l,l+as,r-as,r) || calc(l+t,l+t+as,r-as,r) ) )return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n\n  for(int i=0;i<n;i++){\n    s[i]+=19;\n  }\n\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n\tvoid change_st(const int index, const ll from, const ll to)const {\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans = ar - al;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(1, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > R) {\n\t\t\t\t\t\t\t\trsame = true;\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trsame = getha(l3, r3) == getha(l4, r4);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  assert(a!=l);\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  assert(b-a==r-l);\n  assert(a!=l);\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  assert(a!=l);\n\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  // return ( eq(a,b,l,r, l+L, s[a+L])  );\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool intersect(int a,int b,int l,int r){\n  if( b<=l || r<=a ) return false;\n  else return true;\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n  //  calc(l+as,r-t,l+as+t,r);\n  //  if ( calc(l+as,r-t ,l+as+t,r) && ( eq(l,l+as,r-t,r-t+as) || eq(l,l+as,r-t-t,r-t-t+as) ) )return true;\n  if ( eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-t,r-t+as) || calc(l,l+as,r-t-t,r-t-t+as) ) )return true;\n \n  if ( calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) ) )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && ( calc(l,l+as,r-as,r) || calc(l+t,l+t+as,r-as,r) ) )return true;\n\n  /*\n  if ( calc(l,r-as-t ,l+t,r-as) && eq(l,l+as,r-as,r)  )return true;\n  if ( calc(l+t,r-as ,l,r-as-t) && eq(l+t,l+t+as,r-as,r)  )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && calc(l,l+as,r-as,r)  )return true;\n  */\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n\n\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  assert(b-a==r-l);\n\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  assert(b-a==r-l);\n\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n\n  //  if ( calc(l+as,r-t ,l+as+t,r) && ( eq(l,l+as,r-t,r-t+as) || eq(l,l+as,r-t-t,r-t-t+as) ) )return true;\n  //  if ( eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-t,r-t+as) || calc(l,l+as,r-t-t,r-t-t+as) ) )return true;\n\n  if ( calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) ) )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && ( calc(l,l+as,r-as,r) || calc(l+t,l+t+as,r-as,r) ) )return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n\n  for(int i=0;i<n;i++){\n    s[i]+=19;\n  }\n\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n// #include\"../RollingHash.cpp\"\n#include<bits/stdc++.h>\n\nnamespace ProconLib{\n    using Hash=__int128;\n    \n    template<typename Iter>\n    class RollingHash{\n        int N;\n        const static Hash MOD=Hash(1e18l)+9;\n        const static Hash A=Hash(1e12l)+39;\n        std::vector<Hash> powA;\n        std::vector<Hash> h;\n        public:\n        // RollingHash():N(xs.size()),powA(N+1),h(N+1){\n        //     for(int i=0;i<N;i++) h[i+1]=(h[i]*A+xs[i])%MOD;\n        //     powA[0]=1;\n        //     for(int i=0;i+1<N;i++) powA[i+1]=(powA[i]*A)%MOD;\n        // }\n        RollingHash(Iter begin,Iter end):N(0),h(1,0){\n            for(;begin!=end;begin++){\n                h.push_back((h[N]*A+(*begin))%MOD);\n                N++;\n            }\n            powA.resize(N+1);\n            powA[0]=1;\n            for(int i=0;i+1<=N;i++) powA[i+1]=(powA[i]*A)%MOD;\n        }\n        Hash get(int l,int r){\n            return (h[r]+(MOD-(h[l]*powA[r-l])%MOD))%MOD;\n        }\n        Hash getA(){return A;}\n        Hash getMOD(){return MOD;}\n    };\n\n    \n};\n\nusing namespace std;\nusing namespace ProconLib;\nint main(){\n    string s;\n    cin>>s;\n    int q;\n    cin>>q;\n    RollingHash<string::iterator> rh(s.begin(),s.end());\n    const Hash MOD=rh.getMOD();\n    const Hash A=rh.getA();\n    vector<Hash> powA(2*1e6);\n    powA[0]=1;\n    for(int i=0;i+1<powA.size();i++){\n        powA[i+1]=powA[i]*A%MOD;\n    }\n    auto calc=[&](int l,int r,int l1,int r1,int l2,int r2,int t){\n        Hash hv=(rh.get(l1,r1)*powA[r2-l2]+rh.get(l2,r2))%MOD;\n        vector<Hash> rept(21);\n        rept[0]=hv;\n        for(int i=0;i<20;i++){\n            if((1LL<<i)*t<=s.size()+1) rept[i+1]=(rept[i]*powA[(1<<i)*t]+rept[i])%MOD;\n        }\n        // cerr<<(long long)(rept[1])<<endl;\n        // cerr<<(long long)(rh.get(0,6))<<endl;\n        for(int i=20;i>=0;i--){\n            long long ub=(1LL<<i)*t+l;\n            if(ub>r) continue;\n            Hash h=rh.get(l,ub);\n            if(h==rept[i]){\n                l=ub;\n            }\n        }\n        int lb=l,ub=min(r,l+t)+1;\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            int len=mid-l;\n            Hash h=0;\n            if(r1-l1<len){\n                len=mid-l-(r1-l1);\n                h=rh.get(l1,r1)*powA[len]+rh.get(l2,l2+len);\n            }\n            else{\n                h=rh.get(l1,l1+len);\n            }\n            if(rh.get(l,mid)==h) lb=mid;\n            else ub=mid;\n        }\n        return lb;\n    };\n    while(q--){\n        int l,r,t;\n        cin>>l>>r>>t;\n        l--;\n        int x=calc(l,r,l,l+t,l,l,t);\n        x++;\n        x=calc(x,r,(x-l)%t+l,l+t,l,(x-l)%t+l,t);\n        int y=-1;\n        if(l+2*t<=s.size()){\n            y=calc(l,r,l+t,l+2*t,l,l,t);\n            y++;\n            y=calc(y,r,(y-l)%t+l+t,l+2*t,l+t,(y-l)%t+l+t,t);\n        }\n        cout<<((x>=r || y>=r) ? \"Yes\" : \"No\")<<endl;\n    }\n\n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  assert(a!=l);\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  assert(b-a==r-l);\n  assert(a!=l);\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  assert(a!=l);\n\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  // return ( eq(a,b,l,r, l+L, s[a+L])  );\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool intersect(int a,int b,int l,int r){\n  if( b<=l || r<=a ) return false;\n  else return true;\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n  //  calc(l+as,r-t,l+as+t,r);\n  //  if ( calc(l+as,r-t ,l+as+t,r) && ( eq(l,l+as,r-t,r-t+as) || eq(l,l+as,r-t-t,r-t-t+as) ) )return true;\n  if ( eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-t,r-t+as) || calc(l,l+as,r-t-t,r-t-t+as) ) )return true;\n \n  //if ( calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) ) )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && ( calc(l,l+as,r-as,r) || calc(l+t,l+t+as,r-as,r) ) )return true;\n\n  /*\n  if ( calc(l,r-as-t ,l+t,r-as) && eq(l,l+as,r-as,r)  )return true;\n  if ( calc(l+t,r-as ,l,r-as-t) && eq(l+t,l+t+as,r-as,r)  )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && calc(l,l+as,r-as,r)  )return true;\n  */\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n\n\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  assert(b-a==r-l);\n\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  assert(b-a==r-l);\n\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n  //  calc(l+as,r-t,l+as+t,r);\n\n  if ( calc(l+as,r-t ,l+as+t,r) && (eq(l,l+as,r-as,r) ||eq(l,l+as,r-as-t,r-t) ) )return true;\n  if ( eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-as,r) || calc(l,l+as,r-as-t,r-t) ) )return true;\n\n  if ( calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) ) )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && ( calc(l,l+as,r-as,r) || calc(l+t,l+t+as,r-as,r) ) )return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n\n  for(int i=0;i<n;i++){\n    s[i]+=19;\n  }\n\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  assert(b-a==r-l);\n\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  assert(b-a==r-l);\n\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n  //  calc(l+as,r-t,l+as+t,r);\n\n  if ( calc(l+as,r-t ,l+as+t,r) && ( eq(l,l+as,r-t,r-t+as) || eq(l,l+as,r-t-t,r-t-t+as) ) )return true;\n  if ( eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-t,r-t+as) || calc(l,l+as,r-t-t,r-t-t+as) ) )return true;\n\n  if ( calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) ) )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && ( calc(l,l+as,r-as,r) || calc(l+t,l+t+as,r-as,r) ) )return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n\n  for(int i=0;i<n;i++){\n    s[i]+=19;\n  }\n\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nconst int MAX = 500000, MS = 2;\nconst long long mod[] = {999999937LL, 1000000007LL}, base = 9973;\nstruct rolling_hash {\n    int n;\n    vector<long long> hs[MS], pw[MS];\n    rolling_hash(){}\n    rolling_hash(const string &s) {\n        n = s.size();\n        for (int i = 0; i < MS; i++) {\n            hs[i].assign(n+1,0);\n            pw[i].assign(n+1,0);\n            hs[i][0] = 0;\n            pw[i][0] = 1;\n            for (int j = 0; j < n; j++) {\n                pw[i][j+1] = pw[i][j]*base%mod[i];\n                hs[i][j+1] = (hs[i][j]*base+s[j])%mod[i];\n            }\n        }\n    }\n\n    long long hash(int l, int r, int i) { return ((hs[i][r]-hs[i][l]*pw[i][r-l])%mod[i]+mod[i])%mod[i]; }\n\n    bool match(int l1, int r1, int l2, int r2) {\n        bool ret = 1;\n        for (int i = 0; i < MS; i++) ret &= hash(l1,r1,i)==hash(l2,r2,i);\n        return ret;\n    }\n\n    bool match(int l, int r, long long h[]) {\n        bool ret = 1;\n        for (int i = 0; i < MS; i++) ret &= hash(l,r,i)==h[i];\n        return ret;\n    }\n};\n\n\nint main(){\n    string s;\n    cin >> s;\n    int q;\n    cin >> q;\n    int cnt =0;\n    rolling_hash rh(s);\n    for(int i=0;i<q;i++){\n        int l,r,t;\n        cin >> l >> r >> t;\n        l--;r--;\n        int l1,r1,l2,r2;\n        l1 = l;\n        l2 = l+t;\n        r1 = r-t;\n        r2 = r;\n        cnt++;\n        if(rh.match(l1,r1,l2,r2)||(l+t==r+1)){\n            cout << \"Yes\" << endl;\n        }else{\n            int ok = -1;\n            int ng = r1-l1+1;\n            while(ng-ok!=1){\n                int mid = (ng+ok)/2;\n                if(rh.match(l1,l1+mid,l2,l2+mid)){\n                    ok = mid;\n                }else{\n                    ng = mid;\n                }\n            }\n            bool flag = 0;\n            if(l2>l1+ng){\n                bool fflag = 1;\n                for(int i=0;i<2;i++){\n                    ll x = rh.hash(l1,r1+1,i);\n                    ll y = rh.hash(l2,r2+1,i);\n                    x = (x+(rh.pw[i][r1-l1-ng+1]*(mod[i]+s[l2+ng-1]-s[l1+ng-1])%mod[i]))%mod[i];\n                    \n                    if(x!=y)fflag = 0;\n                }\n                if(fflag)flag = 1;\n            }else{\n                bool fflag = 1;\n                for(int i=0;i<2;i++){\n                    ll x = rh.hash(l1,r1+1,i);\n                    ll y = rh.hash(l2,r2+1,i);\n                    \n                    x = (x+(rh.pw[i][r1-l1-ng+1]*(mod[i]+s[l2+ng-1]-s[l1+ng-1])%mod[i]))%mod[i];\n                    y = (y+(rh.pw[i][r2-l1-ng+1]*(mod[i]+s[l2+ng-1]-s[l1+ng-1])%mod[i]))%mod[i];\n                    \n                    if(x!=y)fflag = 0;\n                }\n\n                if(fflag)flag = 1;\n            }   \n            if(l2+ng<=r1){\n                bool fflag = 1;\n                for(int i=0;i<2;i++){\n                    ll x = rh.hash(l1,r1+1,i);\n                    ll y = rh.hash(l2,r2+1,i);\n                    x = (x+(rh.pw[i][r1-l2-ng+1]*(mod[i]+s[l1+ng-1]-s[l2+ng-1])%mod[i]))%mod[i];\n                    y = (y+(rh.pw[i][r2-l2-ng+1]*(mod[i]+s[l1+ng-1]-s[l2+ng-1])%mod[i]))%mod[i];\n                    if(x!=y)fflag = 0;\n                }\n\n                if(fflag)flag = 1;\n            }else{\n                bool fflag = 1;\n                for(int i=0;i<2;i++){\n                    ll x = rh.hash(l1,r1+1,i);\n                    ll y = rh.hash(l2,r2+1,i);\n                    y = (y+(rh.pw[i][r2-l2-ng+1]*(mod[i]+s[l1+ng-1]-s[l2+ng-1])%mod[i]))%mod[i];\n                    if(x!=y)fflag = 0;    \n                }\n\n                if(fflag)flag = 1;\n            } \n            if(flag){\n                cout << \"Yes\" << endl;\n            }else{\n                cout << \"No\" << endl;\n            }  \n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll po(const ll p, const ll n, const ll mod)\n{\n    if (n == 0) { return 1; }\n    if (n % 2 == 1) {\n        return po(p, n - 1, mod) * p % mod;\n    } else {\n        const ll pp = po(p, n / 2, mod);\n        return pp * pp % mod;\n    }\n}\nconstexpr ll inv(const ll p, const ll mod) { return po(p, mod - 2, mod); }\nconstexpr ll BASE1 = 186398169LL;\nconstexpr ll MOD1 = 1000000007LL;\nconstexpr ll INV1 = inv(BASE1, MOD1);\nconstexpr ll BASE2 = 238173201LL;\nconstexpr ll MOD2 = 1000000009LL;\nconstexpr ll INV2 = inv(BASE2, MOD2);\nconstexpr int MAX = 100000;\nP power[MAX], inverse[MAX], h[MAX];\nmap<P, int> phash;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string S;\n    cin >> S;\n    for (ll i = 0, p1 = 1, p2 = 1, i1 = 1, i2 = 1, h1 = 0, h2 = 0; i < S.size(); i++, (p1 *= BASE1) %= MOD1, (p2 *= BASE2) %= MOD2, (i1 *= INV1) %= MOD1, (i2 *= INV2) %= MOD2) {\n        (h1 += (S[i] - 'a') * p1 % MOD1) %= MOD1, (h2 += (S[i] - 'a') * p2 % MOD2) %= MOD2, h[i] = {h1, h2}, inverse[i] = {i1, i2}, power[i] = {p1, p2};\n        for (int j = 1; j < 26; j++) { phash[{p1 * j % MOD1, p2 * j % MOD2}] = i; }\n    };\n\n    auto add = [](const P& p1, const P& p2) -> P { return {(p1.first + p2.first) % MOD1, (p1.second + p2.second) % MOD2}; };\n    auto sub = [](const P& p1, const P& p2) -> P { return {(p1.first + MOD1 - p2.first) % MOD1, (p1.second + MOD2 - p2.second) % MOD2}; };\n    auto mul = [](const P& p1, const P& p2) -> P { return {(p1.first * p2.first) % MOD1, (p1.second * p2.second) % MOD2}; };\n    auto getHash = [&](const int s, const int l) -> P { return l == 0 ? P{0, 0} : s == 0 ? h[s + l - 1] : mul(sub(h[s + l - 1], h[s - 1]), inverse[s]); };\n    auto getSum = [&](const ll p, const ll n, const ll mod) -> ll { return p == 1 ? n : (po(p, n, mod) - 1) * inv(p - 1, mod) % mod; };\n    auto getPoly = [&](const int t, const int rep) -> P { return {getSum(power[t].first, rep, MOD1), getSum(power[t].second, rep, MOD2)}; };\n    auto judge = [&](const P& diff, const int L) -> bool { return diff == P{0, 0} or (phash.find(diff) != phash.end() and phash[diff] < L) or (phash.find(sub({0, 0}, diff)) != phash.end() and phash[sub({0, 0}, diff)] < L); };\n    assert(phash.size() == 25 * S.size());\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; q++) {\n        int l, r, t;\n        (cin >> l >> r >> t), l--;\n        const int L = r - l, rep = L / t, rest = L % t;\n        const P Hash = getHash(l, L);\n        if (rep == 1) {\n            const P mask1 = add(getHash(l, t), mul(power[t * rep], getHash(l, rest)));\n            const P diff = sub(mask1, Hash);\n            cout << (judge(diff, L) ? \"Yes\\n\" : \"No\\n\");\n        } else {\n            const P poly = getPoly(t, rep);\n            const P mask1 = add(mul(poly, getHash(l, t)), mul(power[t * rep], getHash(l, rest)));\n            const P diff1 = sub(mask1, Hash);\n            const P mask2 = add(mul(poly, getHash(l + t, t)), mul(power[t * rep], getHash(l + t, rest)));\n            const P diff2 = sub(mask2, Hash);\n            cout << (judge(diff1, L) or judge(diff2, L) ? \"Yes\\n\" : \"No\\n\");\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l,r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r+1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r+1 - index - 1].second);\n\t}\n\tvoid change_st(const int index, const ll from, const ll to)const {\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const pair<int, int>a, const pair<int, int>b) {\n\tint al = a.first, ar = a.second;\n\tint bl = b.first, br = b.second;\n\tint lans = -1;\n\tint rans = ar-al;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans+1, ar) == rh.hash(bl + rans+1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind,st[changeind],changeto,l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool,int> issame(pair<int,int>a, pair<int,int>b) {\n\tif (b.first > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b.first <= R);\n\t\tint len = min(a.second - a.first, R - b.first);\n\t\tbool same=  getha(a.first,a.first+len) == getha(b.first,b.first+len);\n\t\tif (same)return make_pair(1, -1);\n\t\telse {\n\n\t\t\tint acheck = check(make_pair(a.first,a.first+len), (make_pair(b.first,b.first+len)));\n\t\t\treturn make_pair(false,acheck);\n\t\t}\n\t}\n}\nint main() { \n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize*2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(make_pair(L, L + nt - 1), make_pair(L + nt, L + nt * 2 - 1));\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = getha(L, L  + nt / 2 - 1) == getha(L  + nt / 2, L +nt-1);\n\t\t\t\t\t\tbool rsame;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > R) {\n\t\t\t\t\t\t\t\trsame = true;\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trsame = getha(l3, r3) == getha(l4, r4);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return eq(a,b,l,r, l+L, s[a+L]);\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n  return ( calc(l,r-as-t ,l+t,r-as) && calc(l+as,r-t,l+as+t,r) );\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  assert(b-a==r-l);\n\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  assert(b-a==r-l);\n\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n  //  calc(l+as,r-t,l+as+t,r);\n\n  if ( calc(l+as,r-t ,l+as+t,r) && ( eq(l,l+as,r-t,r-t+as) || eq(l,l+as,r-t-t,r-t-t+as) ) )return true;\n  if ( eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-t,r-t+as) || calc(l,l+as,r-t-t,r-t-t+as) ) )return true;\n\n  if ( calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) ) )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && ( calc(l,l+as,r-as,r) || calc(l+t,l+t+as,r-as,r) ) )return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n\n  for(int i=0;i<n;i++){\n    s[i]+=19;\n  }\n\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP, rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size());\n    LCP[0] = 0;\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i] + 1] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (LCP[k]);\n  }\n\n  size_t size() const\n  {\n    return (LCP.size());\n  }\n};\n\n\nconst int INF = 1 << 30;\n\nstruct SegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n\n\nint main()\n{\n  string S;\n  int Q;\n\n  cin >> S;\n  cin >> Q;\n\n  SuffixArray sa;\n  LongestCommonPrefixArray lcp;\n  SegmentTree tree(S.size());\n\n  sa.Build_SA(S);\n  lcp.Build_LCP(sa);\n  for(int i = 0; i < S.size(); i++) tree.set(i, lcp[i]);\n  tree.build();\n\n  auto getLCP = [&](int a, int b)\n  {\n    if(a > S.size() || b > S.size()) return (INF);\n    a = lcp.rank[a], b = lcp.rank[b];\n    if(a > b) swap(a, b);\n    return (tree.rmq(a + 1, b + 1));\n  };\n\n  while(Q--) {\n    int l, r, t;\n    cin >> l >> r >> t;\n\n    int l1 = --l, r1 = r - t;\n    int l2 = l1 + t, r2 = r;\n    int length = r1 - l1;\n\n    int lcp1 = getLCP(l1, l2);\n\n    if(lcp1 >= length) {\n      cout << \"Yes\" << endl;\n      continue;\n    }\n\n    int lcp2 = getLCP(l1 + lcp1 + 1, l2 + lcp1 + 1);\n\n    if(lcp1 + 1 + lcp2 >= length) {\n      if(l1 + lcp1 < l2 || l2 + lcp1 >= r1) {\n        cout << \"Yes\" << endl;\n      } else {\n        cout << \"No\" << endl;\n      }\n      continue;\n    }\n    if(lcp2 + 1 == t && S[l1 + lcp1] == S[l2 + lcp1 + t]) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n\n/*\n    cout << S.substr(l1, r1 - l1) << endl;\n    cout << string(t, ' ') + S.substr(l2, r2 - l2) << endl;\n\n    cout << lcp2 << endl;\n*/\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  assert(a!=l);\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  assert(b-a==r-l);\n  assert(a!=l);\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  assert(a!=l);\n\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L])  );\n  //return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool intersect(int a,int b,int l,int r){\n  if( b<=l || r<=a ) return false;\n  else return true;\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return ( calc(l,l+(len-t),r-(len-t),r)   ||  calc(r-(len-t),r,l,l+(len-t)) );\n  }\n\n\n  if(len%t==0){\n    return ( calc(l,r-t,l+t,r) || calc(l+t,r,l,r-t) );\n  }\n  int as=len%t;\n\n  //  calc(l+as,r-t,l+as+t,r);\n  //  if ( calc(l+as,r-t ,l+as+t,r) && ( eq(l,l+as,r-t,r-t+as) || eq(l,l+as,r-t-t,r-t-t+as) ) )return true;\n  //if ( eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-t,r-t+as) || calc(l,l+as,r-t-t,r-t-t+as) ) )return true;\n \n  //if ( calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) ) )return true;\n  //if ( eq(l,r-as-t ,l+t,r-as) && ( calc(l,l+as,r-as,r) || calc(l+t,l+t+as,r-as,r) ) )return true;\n\n\n  if ( calc(l,r-as-t ,l+t,r-as) && eq(l,l+as,r-as,r)  )return true;\n  if ( calc(l+t,r-as ,l,r-as-t) && eq(l+t,l+t+as,r-as,r)  )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && calc(l,l+as,r-as,r)  )return true;\n\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n\n    l--;\n\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10005349, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l,r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r+1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r+1 - index - 1].second);\n\t}\n\tvoid change_st(const int index, const ll from, const ll to)const {\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const pair<int, int>a, const pair<int, int>b) {\n\tint al = a.first, ar = a.second;\n\tint bl = b.first, br = b.second;\n\tint lans = -1;\n\tint rans = ar-al;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans+1, ar) == rh.hash(bl + rans+1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind,st[changeind],changeto,l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool,int> issame(int al, int bl,int len) {\n\tif (bl > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(bl <= R);\n\t\tint checklen = min(len, R - bl);\n\t\tbool same=  getha(al,al+checklen) == getha(bl,bl+ checklen);\n\t\tif (same)return make_pair(1, -1);\n\t\telse {\n\n\t\t\tint acheck = check(make_pair(al,al+checklen), (make_pair(bl,bl+checklen)));\n\t\t\treturn make_pair(false,acheck);\n\t\t}\n\t}\n}\nint main() { \n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize*2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L, L + nt / 2,nt/2).first;\n\t\t\t\t\t\tbool rsame=issame(L+nt,L+nt+nt/2,nt/2).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tif (rsame) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tassert(!lsame||rsame);\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 100009, mul1 = 1000007;\n\tstatic const ll add0 = 10000120007, add1 = 10032333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tmap<char, int>mp;\n\tfor (auto c : st)mp[c]++;\n\tint N; cin >> N;\n\tint num = -1;\n\twhile (N--) {\n\t\tnum++;\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\tif (L == 43245 && R == 50827 && T == 2190) {\n\t\t\tint a = 0; a++;\n\n\t\t}\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tif (L + nt * 3 + p <= R)ok = false;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\tassert(issame(L, L + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(rsame){\n\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassert(issame(L, L + nt, nt - 1).first);\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nconst int MAX = 500000, MS = 2;\nconst long long mod[] = {999999937LL, 1000000007LL}, base = 9973;\nstruct rolling_hash {\n    int n;\n    vector<long long> hs[MS], pw[MS];\n    rolling_hash(){}\n    rolling_hash(const string &s) {\n        n = s.size();\n        for (int i = 0; i < MS; i++) {\n            hs[i].assign(n+1,0);\n            pw[i].assign(n+1,0);\n            hs[i][0] = 0;\n            pw[i][0] = 1;\n            for (int j = 0; j < n; j++) {\n                pw[i][j+1] = pw[i][j]*base%mod[i];\n                hs[i][j+1] = (hs[i][j]*base+s[j])%mod[i];\n            }\n        }\n    }\n\n    long long hash(int l, int r, int i) { return ((hs[i][r]-hs[i][l]*pw[i][r-l])%mod[i]+mod[i])%mod[i]; }\n\n    bool match(int l1, int r1, int l2, int r2) {\n        bool ret = 1;\n        for (int i = 0; i < MS; i++) ret &= hash(l1,r1,i)==hash(l2,r2,i);\n        return ret;\n    }\n\n    bool match(int l, int r, long long h[]) {\n        bool ret = 1;\n        for (int i = 0; i < MS; i++) ret &= hash(l,r,i)==h[i];\n        return ret;\n    }\n};\n\n\nint main(){\n    string s;\n    cin >> s;\n    int q;\n    cin >> q;\n    rolling_hash rh(s);\n    for(int i=0;i<q;i++){\n        int l,r,t;\n        cin >> l >> r >> t;\n        l--;r--;\n        int l1,r1,l2,r2;\n        l1 = l;\n        l2 = l+t;\n        r1 = r-t;\n        r2 = r;\n        if(rh.match(l1,r1,l2,r2)||(l+t==r+1)){\n            cout << \"Yes\" << endl;\n        }else{\n            int ok = -1;\n            int ng = r1-l1;\n            while(ng-ok!=1){\n                int mid = (ng+ok)/2;\n                if(rh.match(l1,l1+mid,l2,l2+mid)){\n                    ok = mid;\n                }else{\n                    ng = mid;\n                }\n            }\n            bool flag = 0;\n            if(l2>l1+ng-1){\n                bool fflag = 1;\n                for(int i=0;i<2;i++){\n                    ll x = rh.hash(l1,r1+1,i);\n                    ll y = rh.hash(l2,r2+1,i);\n                    x = (x+(rh.pw[i][r1-l1-ng+1]*(mod[i]+s[l2+ng-1]-s[l1+ng-1])%mod[i]))%mod[i];\n                    if(x!=y)fflag = 0;\n                }\n                if(fflag)flag = 1;\n            }else{\n                bool fflag = 1;\n                for(int i=0;i<2;i++){\n                    ll x = rh.hash(l1,r1+1,i);\n                    ll y = rh.hash(l2,r2+1,i);\n                    \n                    x = (x+(rh.pw[i][r1-l1-ng+1]*(mod[i]+s[l2+ng-1]-s[l1+ng-1])%mod[i]))%mod[i];\n                    y = (y+(rh.pw[i][r2-l1-ng+1]*(mod[i]+s[l2+ng-1]-s[l1+ng-1])%mod[i]))%mod[i];\n                    \n                    if(x!=y)fflag = 0;\n                }\n\n                if(fflag)flag = 1;\n            }   \n            if(l2+ng-1<=r1){\n\n                bool fflag = 1;\n                for(int i=0;i<2;i++){\n                    ll x = rh.hash(l1,r1+1,i);\n                    ll y = rh.hash(l2,r2+1,i);\n                    x = (x+(rh.pw[i][r1-l2-ng+1]*(mod[i]+s[l1+ng-1]-s[l2+ng-1])%mod[i]))%mod[i];\n                    y = (y+(rh.pw[i][r2-l2-ng+1]*(mod[i]+s[l1+ng-1]-s[l2+ng-1])%mod[i]))%mod[i];\n                    if(x!=y)fflag = 0;\n                }\n\n                if(fflag)flag = 1;\n            }else{\n                bool fflag = 1;\n                for(int i=0;i<2;i++){\n                    ll x = rh.hash(l1,r1+1,i);\n                    ll y = rh.hash(l2,r2+1,i);\n                    y = (y+(rh.pw[i][r2-l2-ng+1]*(mod[i]+s[l1+ng-1]-s[l2+ng-1])%mod[i]))%mod[i];\n                    if(x!=y)fflag = 0;    \n                }\n\n                if(fflag)flag = 1;\n            } \n            if(flag){\n                cout << \"Yes\" << endl;\n            }else{\n                cout << \"No\" << endl;\n            }  \n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 100009, mul1 = 1000007;\n\tstatic const ll add0 = 10000120007, add1 = 10032333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tstring filename = \"1340-out1.txt\";\n\tifstream read_file(\"D:/D_Download/Visual Studio 2015/Projects/programing_contest_c++/Debug/1340-out1.txt\");\n\tstring ast;\n\tvector<int>anss;\n\twhile (read_file >>ast) {\n\t\tanss.push_back(ast== \"Yes\");\n\t\t\n\t}\n\tread_file.close();\n\t\n\tcin >> st;\n\trh.init(st);\n\tmap<char, int>mp;\n\tfor (auto c : st)mp[c]++;\n\tint N; cin >> N;\n\tint num = -1;\n\twhile (N--) {\n\t\tnum++;\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L, L + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(rsame){\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L, L + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassert(issame(L, L + nt, nt - 1).first);\n\t\t\t}\n\t\t}\n\t\tassert(ok==anss[num]);\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tassert(!lsame||rsame);\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tassert(issame(L, L + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  assert(b-a==r-l);\n\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  assert(b-a==r-l);\n\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L]) );\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n  //  calc(l+as,r-t,l+as+t,r);\n\n  if ( calc(l+as,r-t ,l+as+t,r) && ( eq(l,l+as,r-t,r-t+as) || eq(l,l+as,r-t-t,r-t-t+as) ) )return true;\n  if ( eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-t,r-t+as) || calc(l,l+as,r-t-t,r-t-t+as) ) )return true;\n\n  if ( calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) ) )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && ( calc(l,l+as,r-as,r) || calc(l+t,l+t+as,r-as,r) ) )return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n\n  for(int i=0;i<n;i++){\n    s[i]+=19;\n  }\n\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tassert(!lsame||rsame);\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP, rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size());\n    LCP[0] = 0;\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i] + 1] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (LCP[k]);\n  }\n\n  size_t size() const\n  {\n    return (LCP.size());\n  }\n};\n\n\nconst int INF = 1 << 30;\n\nstruct SegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n\n\nint main()\n{\n  string S;\n  int Q;\n\n  cin >> S;\n  cin >> Q;\n\n  SuffixArray sa;\n  LongestCommonPrefixArray lcp;\n  SegmentTree tree(S.size());\n\n  sa.Build_SA(S);\n  lcp.Build_LCP(sa);\n  for(int i = 0; i < S.size(); i++) tree.set(i, lcp[i]);\n  tree.build();\n\n  auto getLCP = [&](int a, int b)\n  {\n    if(a > S.size() || b > S.size()) return (INF);\n    a = lcp.rank[a], b = lcp.rank[b];\n    if(a > b) swap(a, b);\n    return (tree.rmq(a + 1, b + 1));\n  };\n\n  while(Q--) {\n    int l, r, t;\n    cin >> l >> r >> t;\n\n    int l1 = --l, r1 = r - t;\n    int l2 = l1 + t, r2 = r;\n    int length = r1 - l1;\n\n    int lcp1 = getLCP(l1, l2);\n\n    /*\n    cout << S.substr(l1, r1 - l1) << endl;\n    cout << string(t, ' ') + S.substr(l2, r2 - l2) << endl;\n    */\n\n    // (>_<)\n    if(lcp1 >= length) {\n      cout << \"Yes\" << endl;\n      continue;\n    }\n\n    int lcp2 = getLCP(l1 + lcp1 + 1, l2 + lcp1 + 1);\n\n    if(lcp1 + 1 + lcp2 >= length) {\n      if(l1 + lcp1 < l2 || l2 + lcp1 >= r1) {\n        cout << \"Yes\" << endl;\n      } else {\n        cout << \"No\" << endl;\n      }\n      continue;\n    }\n\n    if(l1 + lcp1 + 1 + lcp2 < l2) {\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    if(lcp2 + 1 == t && S[l1 - lcp2] == S[l2 + lcp1 + 1 + lcp2 + lcp2]) {\n\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L, L + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(rsame){\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tassert(issame(L, L + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L, L + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tassert(issame(L , L  + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassert(issame(L, L + nt, nt - 1).first);\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  assert(a!=l);\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  assert(b-a==r-l);\n  assert(a!=l);\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  assert(a!=l);\n\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L])  );\n  //  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool intersect(int a,int b,int l,int r){\n  if( b<=l || r<=a ) return false;\n  else return true;\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n  //  calc(l+as,r-t,l+as+t,r);\n  //  if ( calc(l+as,r-t ,l+as+t,r) && ( eq(l,l+as,r-t,r-t+as) || eq(l,l+as,r-t-t,r-t-t+as) ) )return true;\n  if ( eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-t,r-t+as) || calc(l,l+as,r-t-t,r-t-t+as) ) )return true;\n \n  if ( calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) ) )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && ( calc(l,l+as,r-as,r) || calc(l+t,l+t+as,r-as,r) ) )return true;\n\n  /*\n  if ( calc(l,r-as-t ,l+t,r-as) && eq(l,l+as,r-as,r)  )return true;\n  if ( calc(l+t,r-as ,l,r-as-t) && eq(l+t,l+t+as,r-as,r)  )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && calc(l,l+as,r-as,r)  )return true;\n  */\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n\n  for(int i=0;i<n;i++){\n    s[i]+=19;\n  }\n\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP, rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size());\n    LCP[0] = 0;\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i] + 1] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (LCP[k]);\n  }\n\n  size_t size() const\n  {\n    return (LCP.size());\n  }\n};\n\n\nconst int INF = 1 << 30;\n\nstruct SegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n\n\nint main()\n{\n  string S;\n  int Q;\n\n  cin >> S;\n  cin >> Q;\n\n  SuffixArray sa;\n  LongestCommonPrefixArray lcp;\n  SegmentTree tree(S.size());\n\n  sa.Build_SA(S);\n  lcp.Build_LCP(sa);\n  for(int i = 0; i < S.size(); i++) tree.set(i, lcp[i]);\n  tree.build();\n\n  auto getLCP = [&](int a, int b)\n  {\n    if(a > S.size() || b > S.size()) return (INF);\n    a = lcp.rank[a], b = lcp.rank[b];\n    if(a > b) swap(a, b);\n    return (tree.rmq(a + 1, b + 1));\n  };\n\n  while(Q--) {\n    int l, r, t;\n    cin >> l >> r >> t;\n\n    int l1 = --l, r1 = r - t;\n    int l2 = l1 + t, r2 = r;\n    int length = r1 - l1;\n\n    int lcp1 = getLCP(l1, l2);\n\n    if(lcp1 >= length) {\n      cout << \"Yes\" << endl;\n      continue;\n    }\n\n    int lcp2 = getLCP(l1 + lcp1 + 1, l2 + lcp1 + 1);\n\n    if(lcp1 + 1 + lcp2 >= length) {\n      if(l1 + lcp1 < l2) {\n        cout << \"Yes\" << endl;\n      } else {\n        cout << \"No\" << endl;\n      }\n      continue;\n    }\n\n    if(l1 + lcp1 + 1 + lcp2 < l2) {\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    if(lcp2 + 1 == t && S[l1 + lcp1] == S[l2 + lcp1 + t]) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n\n/*\n    cout << S.substr(l1, r1 - l1) << endl;\n    cout << string(t, ' ') + S.substr(l2, r2 - l2) << endl;\n\n    cout << lcp2 << endl;\n*/\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return eq(a,b,l,r, l+L, s[a+L]);\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n  return ( calc(l,r-as-t ,l+t,r-as) && calc(l+as,r-t,l+as+t,r) );\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n \nusing namespace std;\n \ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n \nconst int MAX_N = 100005;\n \nstruct RollingHash {\n    static const ll mo0=1000000007,mo1=1000000009; static ll mul0,mul1; static const ll add0=1000010007,add1=1003333331;\n    static vector<ll> pmo[2];\n    string s; int sz; vector<ll> hash_[2];\n    void init(string s) {\n        this->s=s; sz=(int)s.size();\n        hash_[0].resize(sz+1,0),hash_[1].resize(sz+1,0);\n        if(!mul0) mul0=10009+(((ll)&mul0)>>5)%259,mul1=10007+(((ll)&mul1)>>5)%257;\n        if(pmo[0].empty()) pmo[0].pb(1),pmo[1].pb(1);\n        rep(i,sz) hash_[0][i+1]=(hash_[0][i]*mul0+add0+s[i])%mo0;    //hash_[0][i]はインデックス0~i-1までの文字列のハッシュ値\n        rep(i,sz) hash_[1][i+1]=(hash_[1][i]*mul1+add1+s[i])%mo1;\n    }\n    pair<ll,ll> hash(int l,int r){    //文字列sのインデックス[l,r]までの部分文字列のハッシュ値\n        if(l>r) return make_pair(0,0);\n        while((int)pmo[0].size()<r+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n        return make_pair((hash_[0][r+1]+(mo0-hash_[0][l]*pmo[0][r+1-l]%mo0))%mo0,\n                         (hash_[1][r+1]+(mo1-hash_[1][l]*pmo[1][r+1-l]%mo1))%mo1);\n    }\n    pair<ll,ll> update_hash(int l, int r, int k, char c){  //文字列sのs[k]をcに変えたときの[l,r]までの部分文字列のハッシュ値\n        if(l > k || r < k) return hash(l,r);\n        while((int)pmo[0].size()<r+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n        return make_pair((hash_[0][r+1]+(mo0-hash_[0][l]*pmo[0][r+1-l]%mo0)+pmo[0][r-k]*(c - s[k]+mo0))%mo0,\n                         (hash_[1][r+1]+(mo1-hash_[1][l]*pmo[1][r+1-l]%mo1)+pmo[1][r-k]*(c - s[k]+mo1))%mo1);\n    }\n    pair<ll,ll> hash(string s) { init(s); return hash(0,(int)s.size()-1); }   //文字列s全体のハッシュ値\n    static pair<ll,ll> concat(pair<ll,ll> L,pair<ll,ll> R,int RL) { //文字列L+Rのハッシュ値,RLはRの文字列の長さ\n        while((int)pmo[0].size()<RL+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n        return make_pair((R.first + L.first*pmo[0][RL])%mo0,(R.second + L.second*pmo[1][RL])%mo1);\n    }\n};\nvector<ll> RollingHash::pmo[2]; ll RollingHash::mul0,RollingHash::mul1;\n \nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    RollingHash rh;\n    rh.init(s);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int x,y,z;\n        cin >> x >> y >> z;\n        --x,--y;\n        pll p1 = rh.hash(x,y-z), p2 = rh.hash(x+z,y);\n        if(p1 == p2){\n            cout << \"Yes\\n\";\n            continue;\n        }\n        int l = 0,r = y-x-z+1;\n        while(r-l>1){\n            int mid = (l+r)/2;\n            if(rh.hash(x,x+mid-1) == rh.hash(x+z,x+z+mid-1)){\n                l = mid;\n            }else{\n                r = mid;\n            }\n        }\n        if(rh.update_hash(x,y-z,x+l,s[x+z+l]) == rh.update_hash(x+z,y,x+l,s[x+z+l])){\n            cout << \"Yes\\n\";\n        }else{\n            if(rh.update_hash(x,y-z,x+z+l,s[x+l]) == rh.update_hash(x+z,y,x+z+l,s[x+l])){\n                cout << \"Yes\\n\";\n            }else{\n                cout << \"No\\n\";\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tassert(!lsame||rsame);\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n \null B=5575777;\null mem[MAX_N];\n \null pow(int x){\n  assert(0<=x && x<MAX_N);\n \n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n \nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n \null get(int l,int r){\n  if(l==r)return 0;\n \n  return p[r]-p[l]*pow(r-l);\n}\n \null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n \n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n \nbool eq(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  assert(a!=l);\n  return ( get(a,b) == get(l,r) );\n}\n \nbool eq(int a,int b,int l,int r, int x,char ch){\n  assert(b-a==r-l);\n  assert(a!=l);\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n \nbool calc(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  assert(a!=l);\n \n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L])  );\n  //return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n \nbool intersect(int a,int b,int l,int r){\n  if( b<=l || r<=a ) return false;\n  else return true;\n}\n \nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return ( calc(l,l+(len-t),r-(len-t),r)   ||  calc(r-(len-t),r,l,l+(len-t)) );\n  }\n \n \n  if(len%t==0){\n    return ( calc(l,r-t,l+t,r) || calc(l+t,r,l,r-t) );\n  }\n  int as=len%t;\n \n  //  calc(l+as,r-t,l+as+t,r);\n  //  if ( calc(l+as,r-t ,l+as+t,r) && ( eq(l,l+as,r-t,r-t+as) || eq(l,l+as,r-t-t,r-t-t+as) ) )return true;\n  //if ( eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-t,r-t+as) || calc(l,l+as,r-t-t,r-t-t+as) ) )return true;\n  \n  //if ( calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) ) )return true;\n  //if ( eq(l,r-as-t ,l+t,r-as) && ( calc(l,l+as,r-as,r) || calc(l+t,l+t+as,r-as,r) ) )return true;\n \n \n  if ( calc(l,r-as-t ,l+t,r-as) && eq(l,l+as,r-as,r)  )return true;\n  if ( calc(l+t,r-as ,l,r-as-t) && eq(l+t,l+t+as,r-as,r)  )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && calc(l,l+as,r-as,r)  )return true;\n \n  return false;\n}\n \nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n \n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n \n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n \n    l--;\n \n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nstring str;\n\nstruct rollinghash{\n\tstatic const int MD=3;\n\tstatic const int MAX=100005;\n\tconst ll base[MD]={1007LL,1009LL,1009LL};\n\tconst ll mods[MD]={999999937LL, 1000000007LL,912941443LL};\n\tll hash[MD][MAX+1];\n\tll pw[MD][MAX+1];\n\tvoid init(){\n\t\tfor(int i=0;i<MD;i++){\n\t\t\tpw[i][0]=1;\n\t\t\tfor(int j=0;j<MAX;j++){\n\t\t\t\tpw[i][j+1]=pw[i][j]*base[i]%mods[i];\n\t\t\t}\n\t\t}\n\t}\n\tvoid construct(const string &str){\n\t\tint n=str.size();\n\t\tfor(int i=0;i<MD;i++){\n\t\t\thash[i][0]=0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\thash[i][j+1]=(hash[i][j]*base[i]%mods[i]+str[j])%mods[i];\n\t\t\t}\n\t\t}\n\t}\n\n\t// calc hash value [l,r)\n\tll hash_value(int l,int r,int i){\n\t\treturn ((hash[i][r]-hash[i][l]*pw[i][r-l])%mods[i]+mods[i])%mods[i];\n\t}\n\n\tll hash_value2(int l,int r,int pos,int v,int i){\n\t\tll val=((hash[i][r]-hash[i][l]*pw[i][r-l])%mods[i]+mods[i])%mods[i];\n\t\tif(l<=pos && pos<r){\n\t\t\tll dif=v-str[pos];\n\t\t\tval+=dif*pw[i][r-pos-1]%mods[i];\n\t\t\tval%=mods[i];\n\t\t\tif(val<0)val+=mods[i];\n\t\t}\n\t\treturn val;\n\t}\n\n\tPP hash_value(int l,int r){\n\t\treturn PP(hash_value(l,r,0),P(hash_value(l,r,1),hash_value(l,r,2)));\n\t}\n\n\n\n\tPP hash_value2(int l,int r,int pos,int v){\n\t\treturn PP(hash_value2(l,r,pos,v,0),P(hash_value2(l,r,pos,v,1),hash_value2(l,r,pos,v,2)));\n\t}\n};\n\nrollinghash rh; \n\nbool solve(int l,int r,int t){\n\tif(rh.hash_value(l,r-t)==rh.hash_value(l+t,r))return true;\n\tint pl=0,pr=r-l+1;\n\twhile(pl+1<pr){\n\t\tint mid=(pl+pr)/2;\n\t\tif(rh.hash_value(l,l+mid)==rh.hash_value(l+t,l+t+mid)){\n\t\t\tpl=mid;\n\t\t}else{\n\t\t\tpr=mid;\n\t\t}\n\t}\n\tif(rh.hash_value2(l,r-t,l+pl,str[l+t+pl])==rh.hash_value2(l+t,r,l+pl,str[l+t+pl]))return true;\n\tif(rh.hash_value2(l,r-t,l+t+pl,str[l+pl])==rh.hash_value2(l+t,r,l+t+pl,str[l+pl]))return true;\n\treturn false;\n}\n\nint main(void){\n\tcin >> str;\n\trh.init();\n\trh.construct(str);\n\tint q;\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tint l,r,t;\n\t\tscanf(\"%d%d%d\",&l,&r,&t);\n\t\tl--;\n\t\tprintf(\"%s\\n\",solve(l,r,t)?\"Yes\":\"No\");\n\t\t\n\t}\n\t\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define All(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long LL;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst LL mod[] = { 999999937, 1000000007 }, base = 10000103;\n\nstruct RollingHash\n{\n\tint n;\n\tvector<LL> hs[2], pw[2];\n\tRollingHash() {};\n\tRollingHash(const string& s)\n\t{\n\t\tn = s.size();\n\t\tREP(i, 2)\n\t\t{\n\t\t\ths[i].assign(n + 1, 0);\n\t\t\tpw[i].assign(n + 1, 0);\n\t\t\ths[i][0] = 0;\n\t\t\tpw[i][0] = 1;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tpw[i][j + 1] = pw[i][j] * base%mod[i];\n\t\t\t\ths[i][j + 1] = (hs[i][j] * base + s[j]) % mod[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tLL hash(int l, int r, int i)\n\t{\n\t\treturn ((hs[i][r] - hs[i][l] * pw[i][r - l]) % mod[i] + mod[i]) % mod[i];\n\t}\n\n\tbool match(int l1, int r1, int l2, int r2)\n\t{\n\t\treturn (hash(l1, r1, 0) == hash(l2, r2, 0)) && (hash(l1, r1, 1) == hash(l2, r2, 1));\n\t}\n};\n\nstring s;\n\nbool check(int ll, int lr, int rl, int rr, int p, RollingHash& rh)\n{\n\tint len = lr - ll;\n\tLL lh0 = rh.hash(ll, lr + 1, 0), rh0 = rh.hash(rl, rr + 1, 0);\n\tLL lh1 = rh.hash(ll, lr + 1, 1), rh1 = rh.hash(rl, rr + 1, 1);\n\n \tif (ll + p < rl || rl + p > lr)\n\t{\n\t\tlh0 = (lh0 + mod[0] - s[ll + p] * rh.pw[0][len - p] % mod[0]) % mod[0];\n\t\tlh1 = (lh1 + mod[1] - s[ll + p] * rh.pw[1][len - p] % mod[1]) % mod[1];\n\t\trh0 = (rh0 + mod[0] - s[rl + p] * rh.pw[0][len - p] % mod[0]) % mod[0];\n\t\trh1 = (rh1 + mod[1] - s[rl + p] * rh.pw[1][len - p] % mod[1]) % mod[1];\n\t}\n\telse\n\t{\n\t\tint tp = p + ll;\n\t\tlh0 = (lh0 + s[rl + p] * rh.pw[0][lr - tp] % mod[0] - s[tp] * rh.pw[0][lr - tp] % mod[0]) % mod[0];\n\t\tlh1 = (lh1 + s[rl + p] * rh.pw[1][lr - tp] % mod[1] - s[tp] * rh.pw[1][lr - tp] % mod[1]) % mod[1];\n\t\trh0 = (rh0 + s[ll + tp - rl] * rh.pw[0][rr - tp] % mod[0] - s[tp] * rh.pw[0][rr - tp] % mod[0]) % mod[0];\n\t\trh1 = (rh1 + s[ll + tp - rl] * rh.pw[1][rr - tp] % mod[1] - s[tp] * rh.pw[1][rr - tp] % mod[1]) % mod[1];\n\t}\n\n\t/*\n\tlh0 = (lh0 + mod[0] - s[ll + p] * rh.pw[0][len - p] % mod[0]) % mod[0];\n\trh0 = (rh0 + mod[0] - s[rl + p] * rh.pw[0][len - p] % mod[0]) % mod[0];\n\tlh1 = (lh1 + mod[1] - s[ll + p] * rh.pw[1][len - p] % mod[1]) % mod[1];\n\trh1 = (rh1 + mod[1] - s[rl + p] * rh.pw[1][len - p] % mod[1]) % mod[1];\n\t\n\tint lp = p - ll, rp = p - rl;\n\tif (lp >= 0 && lp < lr - ll)\n\t{\n\t\tlh0 = (lh0 + mod[0] - s[p] * rh.pw[0][len - lp] % mod[0]) % mod[0];\n\t\tlh1 = (lh1 + mod[1] - s[p] * rh.pw[1][len - lp] % mod[1]) % mod[1];\n\t}\n\tif (rp >= 0 && rp < rr - rl)\n\t{\n\t\trh0 = (rh0 + mod[0] - s[p] * rh.pw[0][len - rp] % mod[0]) % mod[0];\n\t\trh1 = (rh1 + mod[1] - s[p] * rh.pw[1][len - rp] % mod[1]) % mod[1];\n\t}\n\t*/\n\treturn lh0 == rh0 && lh1 == rh1;\n}\n\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tcin >> s;\n\tRollingHash rh(s);\n\tint q; cin >> q;\n\twhile (q--)\n\t{\n\t\tint l, r, t;\n\t\tcin >> l >> r >> t;\n\t\tl--; r--;\n\t\tbool ans = false;\n\t\tif (r - l <= t) ans = true;\n\t\telse if (rh.match(l, r - t + 1, l + t, r + 1)) ans = true;\n\t\telse\n\t\t{\n\t\t\tint ll = l, rl = l + t;\n\t\t\tint len = r - l - t;\n\t\t\tint lb = 0, ub = len + 1;\n\t\t\tint p;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tp = (ub + lb) / 2;\n\t\t\t\tif (s[ll + p] != s[rl + p]) break;\n\t\t\t\tif (rh.match(ll, ll + p, rl, rl + p)) lb = p;\n\t\t\t\telse ub = p;\n\t\t\t}\n\t\t\tif (check(ll, r - t, rl, r, p, rh)) ans = true;\n\t\t\telse ans = false;\n\t\t}\n\t\tcout << (ans ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n  \null B=5575777;\null mem[MAX_N];\n  \null pow(int x){\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n  \nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n  \null get(int l,int r){\n  return p[r]-p[l]*pow(r-l);\n}\n  \null get(int l,int r,int x,char ch){\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n  \nbool eq(int a,int b,int l,int r){\n  return ( get(a,b) == get(l,r) );\n}\n  \nbool eq(int a,int b,int l,int r, int x,char ch){\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n  \nbool calc(int a,int b,int l,int r){\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n  \n  \nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if( calc(l,r-t,l+t,r) )return true;  \n  return false;\n}\n  \nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n  \n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n  \n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n  \n    l--;\n  \n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l,r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r+1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r+1 - index - 1].second);\n\t}\n\tvoid change_st(const int index, const ll from, const ll to)const {\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const pair<int, int>&a, const pair<int, int>&b) {\n\tint al = a.first, ar = a.second;\n\tint bl = b.first, br = b.second;\n\tint lans = -1;\n\tint rans = ar-al;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans+1, ar) == rh.hash(bl + rans+1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind,st[changeind],changeto,l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\nbool issame(const int l1,  int r1, const int l2,  int r2) {\n\tif (l2 > R) {\n\t\treturn true;\n\t}\n\telse {\n\t\tif (r2 > R) {\n\t\t\tr2 = R;\n\t\t\tassert(l2 <= R);\n\t\t}\n\t\treturn  getha(l3, r3) == getha(l4, r4);\n\t\tif (r3 < L + nt + p&&L + nt + p < r3)rflag = true;\n\t}\n}\nint main() { \n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize*2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tconst int l1 = L;\n\t\t\tint r1 = L + nt - 1;\n\t\t\tconst int l2 = L + nt;\n\t\t\tint r2 = L + 2 * nt - 1;\n\t\t\tif (r2 > R) {\n\t\t\t\tr2 = R;\n\t\t\t\tr1 = l1 + r2 - l2;\n\t\t\t\tassert(l2 <= R);\n\t\t\t}\n\t\t\tha ha1 = getha(l1, r1);\n\t\t\tha ha2 = getha(l2,r2);\n\t\t\tif (ha1 == ha2)continue;\n\t\t\telse {\n\t\t\t\tint p(check(make_pair(l1, r1), make_pair(l2, r2)));\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = getha(l1, l1 + nt / 2 - 1) == getha(l1 + nt / 2, l1+nt-1);\n\t\t\t\t\t\tbool rsame;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > R) {\n\t\t\t\t\t\t\t\trsame = true;\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trsame = getha(l3, r3) == getha(l4, r4);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < r3)rflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = l2 + p;\n\t\t\t\t\t\t\t\tchangeto = st[l1 + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = l1 + p;\n\t\t\t\t\t\t\t\tchangeto = st[l2 + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = l2 + p;\n\t\t\t\t\t\t\t\tchangeto = st[l1 + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = l1 + p;\n\t\t\t\t\t\t\t\tchangeto = st[l2 + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nconst ull B = 1777771;\null S[100010],PB[100010]={1};\nint n;\nstring str;\n\null get(int l,int r){return S[r]-S[l]*PB[r-l];}\null get(int l,int r,int x,char ch){\n  ull res=get(l,r);\n  if(x<l||r<=x) return res;\n  return res+ch*PB[r-x-1]-str[x]*PB[r-x-1];\n}\n\nint search(int a,int b,int x,int ch){\n  int L=0,M,R=1e5+1;\n  while(L<R){\n    M = (L+R)/2;\n    if(max(a,b)+M>n||get(a,a+M,x,ch)!=get(b,b+M,x,ch)) R = M;\n    else L = M+1;\n  }\n  return L-1;\n}\n\nbool check(int l,int r,int t){\n  int p = l+t+search(l,l+t,-1,0);\n  int q = l+(p-l-t)%t;\n  return get(l,r-t,p,str[q])==get(l+t,r,p,str[q])||\n    get(l,r-t,q,str[p])==get(l+t,r,q,str[p]);\n}\n\nint main(){\n  cin>>str;\n  n = str.size();\n  for(int i=0;i<n;i++) S[i+1]=S[i]*B+str[i];\n  for(int i=1;i<n;i++) PB[i]=PB[i-1]*B;\n  \n  int q;\n  cin>>q;\n  while(q--){\n    int l,r,t;\n    scanf(\"%d%d%d\",&l,&r,&t);\n    cout<<(check(l-1,r,t)? \"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconst ll mod = 1e9 + 7;\nconst ll b1 = 9973, b2 = 100000007;\n\nll Pow(ll a, ll b) {\n\tll res = 1; a %= mod;\n\twhile (b) {\n\t\tif (b & 1) {\n\t\t\tres = (res * a) % mod;\n\t\t}\n\t\ta = (a * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nclass RollingHash {\n\tint N;\n\tstring s;\n\tvector<ll> r1, r2, h1, h2, rh1, rh2;\npublic:\n\tRollingHash(const string& s_)\n\t\t: N((int)s_.size()), s(s_), r1(N + 1), r2(N + 1), h1(N + 1), h2(N + 1), rh1(N + 1), rh2(N + 1) {\n\t\tr1[0] = r2[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) r1[i] = r1[i - 1] * b1 % mod;\n\t\tfor (int i = 1; i <= N; i++) r2[i] = r2[i - 1] * b2 % mod;\n\n\t\th1[0] = h2[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) h1[i] = (h1[i - 1] * b1 + s[i - 1]) % mod;\n\t\tfor (int i = 1; i <= N; i++) h2[i] = (h2[i - 1] * b2 + s[i - 1]) % mod;\n\t}\n\tP get(int l, int r) {\n\t\treturn P((h1[r + 1] - h1[l] * r1[r - l + 1] % mod + mod) % mod, (h2[r + 1] - h2[l] * r2[r - l + 1] % mod + mod) % mod);\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint Q;\n\tstring S;\n\tcin >> S >> Q;\n\tint N = S.size();\n\tRollingHash rh(S);\n\tvector<P> dis;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = -25; j <= 25; j++) {\n\t\t\tdis.push_back(P(Pow(b1, i) * (mod + j) % mod, Pow(b2, i) * (mod + j) % mod));\n\t\t}\n\t}\n\tsort(dis.begin(), dis.end());\n\tfor (int i = 0, l, r, t; i < Q; i++) {\n\t\tcin >> l >> r >> t; l--; r--;\n\t\tauto lrh = rh.get(l, r - t), rrh = rh.get(l + t, r);\n\t\tll d1 = (lrh.first - rrh.first + mod) % mod, d2 = (lrh.second - rrh.second + mod) % mod;\n\t\tif (r - l + 1 > t * 2) {\n\t\t\tif (binary_search(dis.begin(), dis.end(), P(d1, d2))) {\n\t\t\t\tputs(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint w = r - l + 1 , fl = (r - l + 1) / t * t;\n\t\t\t\tif (w == fl && rh.get(l, l + t - 1) != rh.get(r - t + 1, r)) {\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (w != fl && (rh.get(l, l + w - fl - 1) != rh.get(r - (w - fl - 1), r) || rh.get(l + w - fl, l + t - 1) != rh.get(r - t + 1, r - (w - fl)))) {\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tll lb = t - 1, ub = r - l + 1 - t;\n\t\t\t\twhile (lb + 1 < ub) {\n\t\t\t\t\tll c = (lb + ub) / 2;\n\t\t\t\t\tlrh = rh.get(l, l + c - 1), rrh = rh.get(l + t, l + t + c - 1);\n\t\t\t\t\td1 = (lrh.first - rrh.first + mod) % mod, d2 = (lrh.second - rrh.second + mod) % mod;\n\t\t\t\t\tif (binary_search(dis.begin(), dis.end(), P(d1, d2))) {\n\t\t\t\t\t\tlb = c;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tub = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tll tmp = lb;\n\t\t\t\tlb = t - 1, ub = r - l + 1 - t;\n\t\t\t\twhile (lb + 1 < ub) {\n\t\t\t\t\tll c = (lb + ub) / 2;\n\t\t\t\t\tlrh = rh.get(r - t - c + 1, r - t), rrh = rh.get(r - c + 1, r);\n\t\t\t\t\td1 = (lrh.first - rrh.first + mod) % mod, d2 = (lrh.second - rrh.second + mod) % mod;\n\t\t\t\t\tif (binary_search(dis.begin(), dis.end(), P(d1, d2))) {\n\t\t\t\t\t\tlb = c;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tub = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tputs(tmp + lb >= r - l ? \"Yes\" : \"No\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tputs(binary_search(dis.begin(), dis.end(), P(d1, d2)) ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP, rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size());\n    LCP[0] = 0;\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i] + 1] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (LCP[k]);\n  }\n\n  size_t size() const\n  {\n    return (LCP.size());\n  }\n};\n\n\nconst int INF = 1 << 30;\n\nstruct SegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n\n\nint main()\n{\n  string S;\n  int Q;\n\n  cin >> S;\n  cin >> Q;\n\n  SuffixArray sa;\n  LongestCommonPrefixArray lcp;\n  SegmentTree tree(S.size());\n\n  sa.Build_SA(S);\n  lcp.Build_LCP(sa);\n  for(int i = 0; i < S.size(); i++) tree.set(i, lcp[i]);\n  tree.build();\n\n  auto getLCP = [&](int a, int b)\n  {\n    if(a > S.size() || b > S.size()) return (INF);\n    a = lcp.rank[a], b = lcp.rank[b];\n    if(a > b) swap(a, b);\n    return (tree.rmq(a + 1, b + 1));\n  };\n\n  while(Q--) {\n    int l, r, t;\n    cin >> l >> r >> t;\n\n    int l1 = --l, r1 = r - t;\n    int l2 = l1 + t, r2 = r;\n    int length = r1 - l1;\n\n    int lcp1 = getLCP(l1, l2);\n\n    if(lcp1 >= length) {\n      cout << \"Yes\" << endl;\n      continue;\n    }\n\n    int lcp2 = getLCP(l1 + lcp1 + 1, l2 + lcp1 + 1);\n\n    if(lcp1 + 1 + lcp2 >= length) {\n      if(l1 + lcp1 < l2 || l2 + lcp1 >= r1) {\n        cout << \"Yes\" << endl;\n      } else {\n        cout << \"No\" << endl;\n      }\n      continue;\n    }\n\n    if(l1 + lcp1 + 1 + lcp2 < l2) {\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    if(lcp2 + 1 == t && S[l1 + lcp1] == S[l2 + lcp1 + 1 + lcp2]) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n\n/*\n    cout << S.substr(l1, r1 - l1) << endl;\n    cout << string(t, ' ') + S.substr(l2, r2 - l2) << endl;\n\n    cout << lcp2 << endl;\n*/\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nstruct RollingHash {\n\tstatic const ll mo0=1000000007,mo1=1000000009; static ll mul0,mul1;\n    static vector<ll> pmo[2];\n\tstring s; int sz; vector<ll> hash_[2];\n\tvoid init(string s) {\n\t\tthis->s=s; sz=(int)s.size();\n\t\thash_[0].resize(sz+1,0),hash_[1].resize(sz+1,0);\n\t\tif(!mul0) mul0=10009+(((ll)&mul0)>>5)%259,mul1=10007+(((ll)&mul1)>>5)%257;\n\t\tif(pmo[0].empty()) pmo[0].pb(1),pmo[1].pb(1);\n\t\trep(i,sz) hash_[0][i+1]=(hash_[0][i]*mul0+s[i])%mo0;\t//hash_[0][i]はインデックス0~i-1までの文字列のハッシュ値\n\t\trep(i,sz) hash_[1][i+1]=(hash_[1][i]*mul1+s[i])%mo1;\n\t}\n\tpair<ll,ll> hash(int l,int r){\t//文字列sのインデックス[l,r]までの部分文字列のハッシュ値\n\t\tif(l>r) return make_pair(0,0);\n\t\twhile((int)pmo[0].size()<r+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n\t\treturn make_pair((hash_[0][r+1]+(mo0-hash_[0][l]*pmo[0][r+1-l]%mo0))%mo0,\n\t\t\t             (hash_[1][r+1]+(mo1-hash_[1][l]*pmo[1][r+1-l]%mo1))%mo1);\n\t}\n    pair<ll,ll> update_hash(int l, int r, int k, char c){  //文字列sのs[k]をcに変えたときの[l,r]までの部分文字列のハッシュ値\n        if(l > k || r < k) return hash(l,r);\n        while((int)pmo[0].size()<r+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n        return make_pair((hash_[0][r+1]+(mo0-hash_[0][l]*pmo[0][r+1-l]%mo0)+pmo[0][r-k]*(c - s[k]+mo0))%mo0,\n                         (hash_[1][r+1]+(mo1-hash_[1][l]*pmo[1][r+1-l]%mo1)+pmo[1][r-k]*(c - s[k]+mo1))%mo1);\n    }\n\tpair<ll,ll> hash(string s) { init(s); return hash(0,(int)s.size()-1); }\t//文字列s全体のハッシュ値\n\tstatic pair<ll,ll> concat(pair<ll,ll> L,pair<ll,ll> R,int RL) { //文字列L+Rのハッシュ値,RLはRの文字列の長さ\n\t\twhile((int)pmo[0].size()<RL+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n\t\treturn make_pair((R.first + L.first*pmo[0][RL])%mo0,(R.second + L.second*pmo[1][RL])%mo1);\n\t}\n};\nvector<ll> RollingHash::pmo[2]; ll RollingHash::mul0,RollingHash::mul1;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    RollingHash rh;\n    rh.init(s);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int x,y,z;\n        cin >> x >> y >> z;\n        --x,--y;\n        pll p1 = rh.hash(x,y-z), p2 = rh.hash(x+z,y);\n        if(p1 == p2){\n            cout << \"Yes\\n\";\n            continue;\n        }\n        int l = 0,r = y-x-z+1;\n        while(r-l>1){\n            int mid = (l+r)/2;\n            if(rh.hash(x,x+mid-1) == rh.hash(x+z,x+z+mid-1)){\n                l = mid;\n            }else{\n                r = mid;\n            }\n        }\n        if(rh.update_hash(x,y-z,x+l,s[x+z+l]) == rh.update_hash(x+z,y,x+l,s[x+z+l])){\n            cout << \"Yes\\n\";\n        }else{\n            if(rh.update_hash(x,y-z,x+z+l,s[x+l]) == rh.update_hash(x+z,y,x+z+l,s[x+l])){\n                cout << \"Yes\\n\";\n            }else{\n                cout << \"No\\n\";\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L, L + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(rsame){\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L, L + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassert(issame(L, L + nt, nt - 1).first);\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct SuffixArray{\n  Int n,k;\n  string S;\n  vector<Int> sa,lcp,r2;\n  SuffixArray(){}\n  SuffixArray(string& S):S(S){init();}\n  void init(){\n    n=S.length();\n    S.push_back('$');\n    build_sa();\n    build_lcp();\n    build_rmq();\n    //for(Int i=0;i<=n;i++) cout<<i<<\":\"<<S.substr(sa[i])<<endl;\n  }\n  void build_sa(){\n    sa.clear();\n    sa.resize(n+1,0);\n    iota(sa.begin(),sa.end(),0);\n    sort(sa.begin(),sa.end(),\n\t [&](Int a,Int b){\n\t   if(S[a]==S[b]) return a>b;\n\t   return S[a]<S[b];\n\t });\n    vector<Int> c(n+1,0),r(n+1),cnt(n+1),s(n+1);\n    for(Int i=0;i<=n;i++) r[i]=S[i];\n    for(Int len=1;len<=n;len*=2){\n      for(Int i=0;i<=n;i++){\n\t c[sa[i]]=\n\t   i>0 &&\n\t   r[sa[i-1]]==r[sa[i]] &&\n\t   sa[i-1]+len<=n &&\n\t   r[sa[i-1]+len/2]==r[sa[i]+len/2] ?\n\t   c[sa[i-1]]:i;\n      }\n      iota(cnt.begin(),cnt.end(),0);\n      copy(sa.begin(),sa.end(),r.begin());\n      for(Int i=0;i<=n;i++){\n\tInt s1=r[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n      c.swap(r);\n    }\n  }\n  \n  bool lt_substr(string &T,Int si=0,Int ti=0){\n    Int sn=S.size(),tn=T.size();\n    while(si<sn&&ti<tn){\n      if(S[si]<T[ti]) return 1;\n      if(S[si]>T[ti]) return 0;\n      si++;ti++;\n    }\n    return si>=sn&&ti<tn;\n  }\n  \n  Int lower_bound(string& T){\n    Int low=0,high=n+1;\n    while(low+1<high){\n      Int mid=(low+high)/2;\n      if(lt_substr(T,sa[mid],0)) low=mid;\n      else high=mid;\n    }\n    return high;\n  }\n  \n  Int upper_bound(string& T){\n    T.back()++;\n    Int res=lower_bound(T);\n    T.back()--;\n    return res;\n  }\n  \n  // O(|T|*log|S|)\n  Int count(string& T){\n    return upper_bound(T)-lower_bound(T);\n  }\n  \n  void build_lcp(){\n    lcp.clear();\n    lcp.resize(n+1,0);\n    r2.resize(n+1);\n    for(Int i=0;i<=n;i++) r2[sa[i]]=i;\n    Int h=0;\n    lcp[0]=0;\n    for(Int i=0;i<n;i++){\n      Int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  Int getlcp(Int p,string &T,Int d){\n    Int i=0;\n    Int len=min((Int)T.length()-d,(Int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    Int n;\n    vector<Int> dat;\n    const Int def=INT_MAX;\n    RMQ(){}\n    void init(Int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(Int n_, vector<Int>& a){\n      for(Int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(Int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    Int query(Int a,Int b,Int k,Int l,Int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tInt vl=query(a,b,k*2+1,l,(l+r)/2);\n\tInt vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    Int query(Int a,Int b){\n      if(a>b) swap(a,b);\n      //cout<<n<<\":\"<<a<<\" \"<<b<<endl;\n      return query(max(a,0),b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n};\n\n\nsigned main(){\n  string s;\n  cin>>s;\n  string t=s;\n  reverse(t.begin(),t.end());\n  SuffixArray sa(s),ta(t);\n  auto &srmq=sa.rmq;\n  auto &trmq=ta.rmq;\n  Int q;\n  cin>>q;\n  Int n=s.size();\n  for(Int i=0;i<q;i++){\n    Int l,r,u;\n    cin>>l>>r>>u;\n    l--;\n    if(r-l==u){\n      cout<<\"Yes\"<<endl;\n      continue;\n    }\n    //cout<<s.substr(l,r-l)<<endl;\n    //cout<<string(u,' ')+s.substr(l,r-l)<<endl;\n    Int x=srmq.query(sa.r2[l],sa.r2[l+u]);\n    Int y=trmq.query(ta.r2[n-r],ta.r2[n-r+u]);\n    if((x+1+y)>=((r-l)-u)){\n      cout<<\"Yes\"<<endl;\n      continue;\n    }\n    if((l+x+u)!=(r-(u+y+1))||s[l+x]!=s[r-(y+1)]){\n      cout<<\"No\"<<endl;\n      continue;\n    }\n    Int z=srmq.query(sa.r2[l+x+u+1],sa.r2[l+x+1]);\n    if(0){\n      cout<<x<<\" \"<<y<<endl;\n      cout<<s[l+x+u]<<\" \"<<s[r-(y+1)]<<endl;\n      cout<<s[l+x]<<\" \"<<s[r-(u+y+1)]<<endl;\n      cout<<s.substr(l+x+u+1,((r-(y+1))-(l+x+u+1)))<<endl;\n      cout<<s.substr(l+x+1,((r-(u+y+1))-(l+x+1)))<<endl;\n      cout<<z<<endl;\n      cout<<(x+1+z+1+y)<<\" \"<<((r-l)-u)<<endl;\n    }\n    cout<<((x+1+z+1+y>=(r-l)-u)?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nconst int MAX = 500000, MS = 2;\nconst long long mod[] = {999999937LL, 1000000007LL}, base = 9973;\nstruct rolling_hash {\n    int n;\n    vector<long long> hs[MS], pw[MS];\n    rolling_hash(){}\n    rolling_hash(const string &s) {\n        n = s.size();\n        for (int i = 0; i < MS; i++) {\n            hs[i].assign(n+1,0);\n            pw[i].assign(n+1,0);\n            hs[i][0] = 0;\n            pw[i][0] = 1;\n            for (int j = 0; j < n; j++) {\n                pw[i][j+1] = pw[i][j]*base%mod[i];\n                hs[i][j+1] = (hs[i][j]*base+s[j])%mod[i];\n            }\n        }\n    }\n\n    long long hash(int l, int r, int i) { return ((hs[i][r]-hs[i][l]*pw[i][r-l])%mod[i]+mod[i])%mod[i]; }\n\n    bool match(int l1, int r1, int l2, int r2) {\n        bool ret = 1;\n        for (int i = 0; i < MS; i++) ret &= hash(l1,r1,i)==hash(l2,r2,i);\n        return ret;\n    }\n\n    bool match(int l, int r, long long h[]) {\n        bool ret = 1;\n        for (int i = 0; i < MS; i++) ret &= hash(l,r,i)==h[i];\n        return ret;\n    }\n};\n\n\nint main(){\n    string s;\n    cin >> s;\n    int q;\n    cin >> q;\n    rolling_hash rh(s);\n    for(int i=0;i<q;i++){\n        int l,r,t;\n        cin >> l >> r >> t;\n        l--;r--;\n        int l1,r1,l2,r2;\n        l1 = l;\n        l2 = l+t;\n        r1 = r-t;\n        r2 = r;\n        if(rh.match(l1,r1,l2,r2)||(l+t==r+1)){\n            cout << \"Yes\" << endl;\n        }else{\n            int ok = -1;\n            int ng = r1-l1;\n            while(ng-ok!=1){\n                int mid = (ng+ok)/2;\n                if(rh.match(l1,l1+mid,l2,l2+mid)){\n                    ok = mid;\n                }else{\n                    ng = mid;\n                }\n            }\n            bool flag = 0;\n            if(l2>l1+ng){\n                bool fflag = 1;\n                for(int i=0;i<2;i++){\n                    ll x = rh.hash(l1,r1+1,i);\n                    ll y = rh.hash(l2,r2+1,i);\n                    x = (x+(rh.pw[i][r1-l1-ng+1]*(mod[i]+s[l2+ng-1]-s[l1+ng-1])%mod[i]))%mod[i];\n                    \n                    if(x!=y)fflag = 0;\n                }\n                if(fflag)flag = 1;\n            }else{\n                bool fflag = 1;\n                for(int i=0;i<2;i++){\n                    ll x = rh.hash(l1,r1+1,i);\n                    ll y = rh.hash(l2,r2+1,i);\n                    \n                    x = (x+(rh.pw[i][r1-l1-ng+1]*(mod[i]+s[l2+ng-1]-s[l1+ng-1])%mod[i]))%mod[i];\n                    y = (y+(rh.pw[i][r2-l1-ng+1]*(mod[i]+s[l2+ng-1]-s[l1+ng-1])%mod[i]))%mod[i];\n                    \n                    if(x!=y)fflag = 0;\n                }\n\n                if(fflag)flag = 1;\n            }   \n            if(l2+ng<=r1){\n                bool fflag = 1;\n                for(int i=0;i<2;i++){\n                    ll x = rh.hash(l1,r1+1,i);\n                    ll y = rh.hash(l2,r2+1,i);\n                    x = (x+(rh.pw[i][r1-l2-ng+1]*(mod[i]+s[l1+ng-1]-s[l2+ng-1])%mod[i]))%mod[i];\n                    y = (y+(rh.pw[i][r2-l2-ng+1]*(mod[i]+s[l1+ng-1]-s[l2+ng-1])%mod[i]))%mod[i];\n                    if(x!=y)fflag = 0;\n                }\n\n                if(fflag)flag = 1;\n            }else{\n                bool fflag = 1;\n                for(int i=0;i<2;i++){\n                    ll x = rh.hash(l1,r1+1,i);\n                    ll y = rh.hash(l2,r2+1,i);\n                    y = (y+(rh.pw[i][r2-l2-ng+1]*(mod[i]+s[l1+ng-1]-s[l2+ng-1])%mod[i]))%mod[i];\n                    if(x!=y)fflag = 0;    \n                }\n\n                if(fflag)flag = 1;\n            } \n            if(flag){\n                cout << \"Yes\" << endl;\n            }else{\n                cout << \"No\" << endl;\n            }  \n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n\tvoid change_st(const int index, const ll from, const ll to)const {\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const pair<int, int>a, const pair<int, int>b) {\n\tint al = a.first, ar = a.second;\n\tint bl = b.first, br = b.second;\n\tint lans = -1;\n\tint rans = ar - al;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b,int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R-b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(1, -1);\n\t\telse {\n\n\t\t\tint acheck = check(make_pair(a, a + len), (make_pair(b, b+ len)));\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L,L+nt,nt);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = getha(L, L + nt / 2 - 1) == getha(L + nt / 2, L + nt - 1);\n\t\t\t\t\t\tbool rsame;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > R) {\n\t\t\t\t\t\t\t\trsame = true;\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trsame = getha(l3, r3) == getha(l4, r4);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll po(const ll p, const ll n, const ll mod)\n{\n    if (n == 0) { return 1; }\n    if (n % 2 == 1) {\n        return po(p, n - 1, mod) * p % mod;\n    } else {\n        const ll pp = po(p, n / 2, mod);\n        return pp * pp % mod;\n    }\n}\nconstexpr ll inv(const ll p, const ll mod) { return po(p, mod - 2, mod); }\nconstexpr ll BASE1 = 186398169LL;\nconstexpr ll MOD1 = 1000000007LL;\nconstexpr ll INV1 = inv(BASE1, MOD1);\nconstexpr ll BASE2 = 238173201LL;\nconstexpr ll MOD2 = 1000000009LL;\nconstexpr ll INV2 = inv(BASE2, MOD2);\nconstexpr int MAX = 100000;\nP power[MAX], inverse[MAX], h[MAX];\nmap<P, int> phash;\nint main()\n{\n    string S;\n    cin >> S;\n    for (ll i = 0, p1 = 1, p2 = 1, i1 = 1, i2 = 1, h1 = 0, h2 = 0; i < S.size(); i++, (p1 *= BASE1) %= MOD1, (i1 *= INV1) %= MOD1, (p2 *= BASE2) %= MOD2, (i2 *= INV2) %= MOD2) {\n        (h1 += (S[i] - 'a') * p1 % MOD1) %= MOD1, (h2 += (S[i] - 'a') * p2 % MOD2) %= MOD2;\n        power[i] = {p1, p2}, inverse[i] = {i1, i2}, h[i] = {h1, h2};\n        for (int j = 1; j < 26; j++) { phash[{p1 * j % MOD1, p2 * j % MOD2}] = i; }\n        for (int j = -25; j < 0; j++) { phash[{p1 * (MOD1 + j) % MOD1, p2 * (MOD2 + j) % MOD2}] = i; }\n    };\n    auto add = [](const P& p1, const P& p2) -> P { return {(p1.first + p2.first) % MOD1, (p1.second + p2.second) % MOD2}; };\n    auto sub = [](const P& p1, const P& p2) -> P { return {(p1.first + MOD1 - p2.first) % MOD1, (p1.second + MOD2 - p2.second) % MOD2}; };\n    auto mul = [](const P& p1, const P& p2) -> P { return {(p1.first * p2.first) % MOD1, (p1.second * p2.second) % MOD2}; };\n    auto getHash = [&](const int s, const int l) -> P { return l == 0 ? P{0, 0} : s == 0 ? h[s + l - 1] : mul(sub(h[s + l - 1], h[s - 1]), inverse[s]); };\n    auto getPoly = [&](const int t, const int rep) -> P { return {(po(power[t].first, rep, MOD1) + MOD1 - 1) * inv(power[t].first + MOD1 - 1, MOD1) % MOD1, (po(power[t].second, rep, MOD2) + MOD2 - 1) * inv(power[t].second + MOD2 - 1, MOD2) % MOD2}; };\n    assert(phash.size() == 50 * S.size());\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; q++) {\n        int l, r, t;\n        (cin >> l >> r >> t), l--;\n        const int L = r - l, rep = L / t, rest = L % t;\n        const P Hash = getHash(l, L);\n        if (rep == 1) {\n            const P mask1 = add(getHash(l, t), mul(power[t * rep], getHash(l + t * rep, rest)));\n            const P diff = sub(mask1, Hash);\n            if (diff == P{0, 0} or (phash.find(P{diff}) != phash.end() and phash[diff] < L)) {\n                cout << \"Yes\" << endl;\n            } else {\n                cout << \"No\" << endl;\n            }\n        } else {\n            const P poly = getPoly(t, rep);\n            const P m1 = getHash(l, t);\n            const P mask1 = add(mul(poly, m1), mul(power[t * rep], getHash(l + t * rep, rest)));\n            const P diff1 = sub(mask1, Hash);\n            if (diff1 == P{0, 0} or (phash.find(P{diff1}) != phash.end() and phash[diff1] < L)) {\n                cout << \"Yes\" << endl;\n                continue;\n            }\n            const P m2 = getHash(l + t, t);\n            const P mask2 = add(mul(poly, m2), mul(power[t * rep], getHash(l + t * rep, rest)));\n            const P diff2 = sub(mask2, Hash);\n            if (diff2 == P{0, 0} or (phash.find(P{diff2}) != phash.end() and phash[diff2] < L)) {\n                cout << \"Yes\" << endl;\n            } else {\n                cout << \"No\" << endl;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 100009, mul1 = 1000007;\n\tstatic const ll add0 = 10000120007, add1 = 10032333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tstring filename = \"1340-out1.txt\";\n\t/*ifstream read_file(\"D:/D_Download/Visual Studio 2015/Projects/programing_contest_c++/Debug/1340-out1.txt\");\n\tstring ast;\n\tvector<int>anss;\n\twhile (read_file >>ast) {\n\t\tanss.push_back(ast== \"Yes\");\n\t\t\n\t}\n\tread_file.close();\n\t*/\n\tcin >> st;\n\trh.init(st);\n\tmap<char, int>mp;\n\tfor (auto c : st)mp[c]++;\n\tint N; cin >> N;\n\tint num = -1;\n\twhile (N--) {\n\t\tnum++;\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L, L + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(rsame){\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L, L + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassert(issame(L, L + nt, nt - 1).first);\n\t\t\t}\n\t\t}\n\t\tassert(ok==anss[num]);\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP, rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size());\n    LCP[0] = 0;\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i] + 1] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (LCP[k]);\n  }\n\n  size_t size() const\n  {\n    return (LCP.size());\n  }\n};\n\n\nconst int INF = 1 << 30;\n\nstruct SegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n\n\nint main()\n{\n  string S;\n  int Q;\n\n  cin >> S;\n  cin >> Q;\n\n  SuffixArray sa;\n  LongestCommonPrefixArray lcp;\n  SegmentTree tree(S.size());\n\n  sa.Build_SA(S);\n  lcp.Build_LCP(sa);\n  for(int i = 0; i < S.size(); i++) tree.set(i, lcp[i]);\n  tree.build();\n\n  auto getLCP = [&](int a, int b)\n  {\n    if(a > S.size() || b > S.size()) return (INF);\n    a = lcp.rank[a], b = lcp.rank[b];\n    if(a > b) swap(a, b);\n    return (tree.rmq(a + 1, b + 1));\n  };\n\n  while(Q--) {\n    int l, r, t;\n    cin >> l >> r >> t;\n\n    int l1 = --l, r1 = r - t;\n    int l2 = l1 + t, r2 = r;\n    int length = r1 - l1;\n\n    int lcp1 = getLCP(l1, l2);\n\n    if(lcp1 >= length) {\n      cout << \"Yes\" << endl;\n      continue;\n    }\n\n    int lcp2 = getLCP(l1 + lcp1 + 1, l2 + lcp1 + 1);\n\n    if(lcp1 + 1 + lcp2 >= length) {\n      if(l1 + lcp1 < l2 || l2 + lcp1 >= r1) {\n        cout << \"Yes\" << endl;\n      } else {\n        cout << \"No\" << endl;\n      }\n      continue;\n    }\n\n    if(l1 + lcp1 + 1 + lcp2 < l2) {\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    if(S[l1 + lcp1] == S[l2 + lcp1 + 1 + lcp2]) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n\n/*\n    cout << S.substr(l1, r1 - l1) << endl;\n    cout << string(t, ' ') + S.substr(l2, r2 - l2) << endl;\n\n    cout << lcp2 - lcp1 << endl;\n*/\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nconst ull B = 1777771;\null S[100010],PB[100010]={1};\nint n;\nstring str;\n\null get(int l,int r){return S[r]-S[l]*PB[r-l];}\null get(int l,int r,int x,char ch){\n  ull res=get(l,r);\n  if(x<l||r<=x) return res;\n  return res+ch*PB[r-x-1]-str[x]*PB[r-x-1];\n}\n\nint search(int a,int b,int x,int ch){\n  int L=0,M,R=1e5+1;\n  while(L<R){\n    M = (L+R)/2;\n    if(max(a,b)+M>n||get(a,a+M,x,ch)!=get(b,b+M,x,ch)) R = M;\n    else L = M+1;\n  }\n  return L-1;\n}\n\nbool check(int l,int r,int t){\n  int p = l+t+search(l,l+t,-1,0);\n  int q = l+(p-l-t)%t;\n  return get(l,r-t,p,str[q])==get(l+t,r,p,str[q])||\n    get(l,r-t,q,str[p])==get(l+t,r,q,str[p]);\n}\n\nint main(){\n  cin>>str;\n  n = str.size();\n  for(int i=0;i<n;i++) S[i+1]=S[i]*B+str[i];\n  for(int i=1;i<n;i++) PB[i]=PB[i-1]*B;\n  \n  int q;\n  cin>>q;\n  while(q--){\n    int l,r,t;\n    cin>>l>>r>>t;\n    cout<<(check(l-1,r,t)? \"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2711\"\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define call_from_test\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n#endif\n//BEGIN CUT HERE\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n//END CUT HERE\n#ifndef call_from_test\nsigned main(){\n  return 0;\n}\n#endif\n\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\n#endif\n//BEGIN CUT HERE\nstruct SuffixArray{\n  string s;\n  vector<int> sa,rev;\n\n  SuffixArray(){}\n  SuffixArray(const string &S):s(S){\n    int n=s.size();\n    s.push_back('$');\n    sa.resize(n+1);\n    iota(sa.begin(),sa.end(),0);\n    sort(sa.begin(),sa.end(),\n         [&](int a,int b){\n           if(s[a]==s[b]) return a>b;\n           return s[a]<s[b];\n         });\n    vector<int> cs(n+1,0),rs(n+1),cnt(n+1);\n    for(int i=0;i<=n;i++) rs[i]=s[i];\n    for(int len=1;len<=n;len*=2){\n      for(int i=0;i<=n;i++){\n        cs[sa[i]]=i;\n        if(i>0 &&\n           rs[sa[i-1]]==rs[sa[i]] &&\n           sa[i-1]+len<=n &&\n           rs[sa[i-1]+len/2]==rs[sa[i]+len/2]) cs[sa[i]]=cs[sa[i-1]];\n      }\n      iota(cnt.begin(),cnt.end(),0);\n      copy(sa.begin(),sa.end(),rs.begin());\n      for(int i=0;i<=n;i++){\n        int s1=rs[i]-len;\n        if(s1>=0) sa[cnt[cs[s1]]++]=s1;\n      }\n      cs.swap(rs);\n    }\n    rev.resize(n+1);\n    for(int i=0;i<=n;i++) rev[sa[i]]=i;\n  }\n  int operator[](int i) const{return sa[i];}\n\n  bool lt_substr(string &t,int si,int ti){\n    int sn=s.size(),tn=t.size();\n    while(si<sn&&ti<tn){\n      if(s[si]<t[ti]) return 1;\n      if(s[si]>t[ti]) return 0;\n      si++;ti++;\n    }\n    return si==sn&&ti<tn;\n  }\n\n  int lower_bound(string& t){\n    int l=0,r=s.size();\n    while(l+1<r){\n      int m=(l+r)>>1;\n      if(lt_substr(t,sa[m],0)) l=m;\n      else r=m;\n    }\n    return r;\n  }\n\n  int upper_bound(string& t){\n    t.back()++;\n    int res=lower_bound(t);\n    t.back()--;\n    return res;\n  }\n\n  // O(|T|*log|S|)\n  int count(string& T){\n    return upper_bound(T)-lower_bound(T);\n  }\n};\n//END CUT HERE\n\n#ifndef call_from_test\n//INSERT ABOVE HERE\nsigned JOI2009HO_A(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  int n,m;\n  string s;\n  cin>>n>>m>>s;\n  SuffixArray sa(s);\n  string t=\"I\";\n  for(int i=0;i<n;i++) t+=\"OI\";\n  cout<<sa.count(t)<<endl;\n  return 0;\n}\n/*\n  verified on 2019/10/28\n  https://atcoder.jp/contests/joi2009ho/tasks/joi2009ho_a\n*/\n\nsigned main(){\n  JOI2009HO_A();\n  return 0;\n};\n#endif\n\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define call_from_test\n#include \"suffixarray.cpp\"\n#undef call_from_test\n\n#endif\n//BEGIN CUT HERE\nstruct LongestCommonPrefix{\n  SuffixArray sa;\n\n  vector<int> ht;\n  vector< vector<int> > dat;\n  LongestCommonPrefix(string &s):sa(s){\n    int n=s.size();\n    vector<int> lcp(n,0);\n\n    int t=0;\n    lcp[0]=0;\n    for(int i=0;i<n;i++){\n      int j=sa[sa.rev[i]-1];\n      if(t>0) t--;\n      for(;j+t<n&&i+t<n;t++){\n        if(sa.s[j+t]!=sa.s[i+t]) break;\n      }\n      lcp[sa.rev[i]-1]=t;\n    }\n\n    int h=1;\n    while((1<<h)<n) h++;\n    dat.assign(h,vector<int>(n));\n    ht.assign(n+1,0);\n    for(int j=2;j<=n;j++) ht[j]=ht[j>>1]+1;\n\n    for(int j=0;j<n;j++) dat[0][j]=lcp[j];\n    for(int i=1,p=1;i<h;i++,p<<=1)\n      for(int j=0;j<n;j++)\n        dat[i][j]=min(dat[i-1][j],dat[i-1][min(j+p,n-1)]);\n  }\n\n  // a, b are indices for suffix array\n  int query(int a,int b){\n    assert(a!=b);\n    if(a>b) swap(a,b);\n    int l=b-a;\n    return min(dat[ht[l]][a],dat[ht[l]][b-(1<<ht[l])]);\n  }\n\n  // a, b are indices for string\n  int lcp(int a,int b){\n    return query(sa.rev[a],sa.rev[b]);\n  }\n};\n//END CUT HERE\n#ifndef call_from_test\n\n#define call_from_test\n#include \"../tools/fastio.cpp\"\n#include \"../tools/chminmax.cpp\"\n#undef call_from_test\n\n//INSERT ABOVE HERE\nsigned ARC060_F(){\n  string s;\n  cin>>s;\n  int n=s.size();\n  {\n    string t(s);\n    t.erase(unique(t.begin(),t.end()),t.end());\n    if(t.size()==1u){\n      cout<<n<<endl<<1<<endl;\n      return 0;\n    }\n  }\n\n  vector<vector<int> > v(n+1);\n  for(int i=1;i<=n;i++)\n    for(int j=i+i;j<=n;j+=i)\n      v[j].emplace_back(i);\n\n  LongestCommonPrefix lcp(s);\n  auto check=\n    [&](int l,int r)->int{\n      for(int x:v[r-l])\n        if(lcp.lcp(l,l+x)>=r-l-x) return 0;\n      return 1;\n    };\n\n  if(check(0,n)){\n    cout<<1<<endl<<1<<endl;\n    return 0;\n  }\n\n  int ans=0;\n  for(int i=1;i<n;i++)\n    ans+=check(0,i)&&check(i,n);\n\n  cout<<2<<endl<<ans<<endl;\n  return 0;\n}\n/*\n  verified on 2019/10/25\n  https://atcoder.jp/contests/arc060/tasks/arc060_d\n*/\n\nsigned main(){\n  ARC060_F();\n  return 0;\n};\n#endif\n\n#undef call_from_test\n\nsigned main(){\n  string s;\n  cin>>s;\n  LongestCommonPrefix lcp(s);\n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int l,r,t;\n    cin>>l>>r>>t;\n    l--;\n    int x=lcp.lcp(l,l+t);\n    if(l+t+x+1>=r){\n      cout<<\"Yes\\n\";\n      continue;\n    }\n    int y=lcp.lcp(l+x+1,l+t+x+1);\n    if(l+t+x+1+y>=r){\n      cout<<\"Yes\\n\";\n      continue;\n    }\n    if(l+x+1+y<l+t){\n      cout<<\"No\\n\";\n      continue;\n    }\n    int z=lcp.lcp(l+x+1+y+1,l+t+x+1+y+1);\n    //cout<<x<<\" \"<<y<<\" \"<<z<<endl;\n    if(l+t+x+1+y+1+z<r){\n      cout<<\"No\\n\";\n      continue;\n    }\n    if(x+t==x+1+y&&s[l+x]==s[l+x+t+t]) cout<<\"Yes\\n\";\n    else cout<<\"No\\n\";\n  }\n  cout<<flush;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l,r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r+1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r+1 - index - 1].second);\n\t}\n\tvoid change_st(const int index, const ll from, const ll to)const {\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const pair<int, int>&a, const pair<int, int>&b) {\n\tint al = a.first, ar = a.second;\n\tint bl = b.first, br = b.second;\n\tint lans = -1;\n\tint rans = ar-al;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans+1, ar) == rh.hash(bl + rans+1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind,st[changeind],changeto,l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint main() { \n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tint l, r, t; cin >> l >> r >> t;\n\t\tl--; r--;\n\t\tint asize = r - l + 1;\n\t\tint nt = t;\n\t\twhile (asize*2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != t) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tconst int l1 = l;\n\t\t\tint r1 = l + nt - 1;\n\t\t\tconst int l2 = l + nt;\n\t\t\tint r2 = l + 2 * nt - 1;\n\t\t\tif (r2 > r) {\n\t\t\t\tr2 = r;\n\t\t\t\tr1 = l1 + r2 - l2;\n\t\t\t\tassert(l2 <= r);\n\t\t\t}\n\t\t\tha ha1 = getha(l1, r1);\n\t\t\tha ha2 = getha(l2,r2);\n\t\t\tif (ha1 == ha2)continue;\n\t\t\telse {\n\t\t\t\tint p(check(make_pair(l1, r1), make_pair(l2, r2)));\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if (nt == t) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = getha(l1, l1 + nt / 2 - 1) == getha(l1 + nt / 2, l1+nt-1);\n\t\t\t\t\t\tbool rsame;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = l + nt;\n\t\t\t\t\t\t\tint r3 = l + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = l + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = l + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > r) {\n\t\t\t\t\t\t\t\trsame = true;\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > r) {\n\t\t\t\t\t\t\t\t\tr4 = r;\n\t\t\t\t\t\t\t\t\tassert(l4 <= r);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trsame = getha(l3, r3) == getha(l4, r4);\n\t\t\t\t\t\t\t\tif (r3 < l + nt + p&&l + nt + p < r3)rflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = l2 + p;\n\t\t\t\t\t\t\t\tchangeto = st[l1 + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = l1 + p;\n\t\t\t\t\t\t\t\tchangeto = st[l2 + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = l2 + p;\n\t\t\t\t\t\t\t\tchangeto = st[l1 + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = l1 + p;\n\t\t\t\t\t\t\t\tchangeto = st[l2 + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP, rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size());\n    LCP[0] = 0;\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i] + 1] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (LCP[k]);\n  }\n\n  size_t size() const\n  {\n    return (LCP.size());\n  }\n};\n\n\nconst int INF = 1 << 30;\n\nstruct SegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n\n\nint main()\n{\n  string S;\n  int Q;\n\n  cin >> S;\n  cin >> Q;\n\n  SuffixArray sa;\n  LongestCommonPrefixArray lcp;\n  SegmentTree tree(S.size());\n\n  sa.Build_SA(S);\n  lcp.Build_LCP(sa);\n  for(int i = 0; i < S.size(); i++) tree.set(i, lcp[i]);\n  tree.build();\n\n  auto getLCP = [&](int a, int b)\n  {\n    if(a > S.size() || b > S.size()) return (INF);\n    a = lcp.rank[a], b = lcp.rank[b];\n    if(a > b) swap(a, b);\n    return (tree.rmq(a + 1, b + 1));\n  };\n\n  while(Q--) {\n    int l, r, t;\n    cin >> l >> r >> t;\n\n    int l1 = --l, r1 = r - t;\n    int l2 = l1 + t, r2 = r;\n    int length = r1 - l1;\n\n    int lcp1 = getLCP(l1, l2);\n\n    if(lcp1 >= length) {\n      cout << \"Yes\" << endl;\n      continue;\n    }\n\n    int lcp2 = getLCP(l1 + lcp1 + 1, l2 + lcp1 + 1);\n\n    if(lcp1 + 1 + lcp2 >= length) {\n      if(l1 + lcp1 < l2 || l2 + lcp1 >= r1) {\n        cout << \"Yes\" << endl;\n      } else {\n        cout << \"No\" << endl;\n      }\n      continue;\n    }\n\n    if(l1 + lcp1 + 1 + lcp2 < l2) {\n      cout << \"No\" << endl;\n      continue;\n    }\n    if(lcp1 + 1 == t && S[l1 + lcp1] == S[l2 + lcp1 + 1 + lcp2]) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n// #include\"../RollingHash.cpp\"\n#include<bits/stdc++.h>\n\nnamespace ProconLib{\n    using Hash=__int128;\n    \n    template<typename Iter>\n    class RollingHash{\n        int N;\n        const static Hash MOD=Hash(1e18l)+9;\n        const static Hash A=Hash(1e12l)+39;\n        std::vector<Hash> powA;\n        std::vector<Hash> h;\n        public:\n        // RollingHash():N(xs.size()),powA(N+1),h(N+1){\n        //     for(int i=0;i<N;i++) h[i+1]=(h[i]*A+xs[i])%MOD;\n        //     powA[0]=1;\n        //     for(int i=0;i+1<N;i++) powA[i+1]=(powA[i]*A)%MOD;\n        // }\n        RollingHash(Iter begin,Iter end):N(0),h(1,0){\n            for(;begin!=end;begin++){\n                h.push_back((h[N]*A+(*begin))%MOD);\n                N++;\n            }\n            powA.resize(N+1);\n            powA[0]=1;\n            for(int i=0;i+1<=N;i++) powA[i+1]=(powA[i]*A)%MOD;\n        }\n        Hash get(int l,int r){\n            return (h[r]+(MOD-(h[l]*powA[r-l])%MOD))%MOD;\n        }\n        Hash getA(){return A;}\n        Hash getMOD(){return MOD;}\n    };\n\n    \n};\n\nusing namespace std;\nusing namespace ProconLib;\nint main(){\n    string s;\n    cin>>s;\n    int q;\n    cin>>q;\n    RollingHash<string::iterator> rh(s.begin(),s.end());\n    const Hash MOD=rh.getMOD();\n    const Hash A=rh.getA();\n    vector<Hash> powA(2*1e6);\n    powA[0]=1;\n    for(int i=0;i+1<powA.size();i++){\n        powA[i+1]=powA[i]*A%MOD;\n    }\n    auto calc=[&](int l,int r,int l1,int r1,int l2,int r2,int t){\n        Hash hv=(rh.get(l1,r1)*powA[r2-l2]+rh.get(l2,r2))%MOD;\n        vector<Hash> rept(21);\n        rept[0]=hv;\n        for(int i=0;i<20;i++){\n            if((1LL<<i)*t<=s.size()+1) rept[i+1]=(rept[i]*powA[(1LL<<i)*t]+rept[i])%MOD;\n        }\n        // cerr<<(long long)(rept[1])<<endl;\n        // cerr<<(long long)(rh.get(0,6))<<endl;\n        for(int i=20;i>=0;i--){\n            long long ub=(1LL<<i)*t+l;\n            if(ub>r) continue;\n            Hash h=rh.get(l,ub);\n            if(h==rept[i]){\n                l=ub;\n            }\n        }\n        int lb=l,ub=min(r,l+t)+1;\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            int len=mid-l;\n            Hash h=0;\n            if(r1-l1<len){\n                len=mid-l-(r1-l1);\n                h=(rh.get(l1,r1)*powA[len]+rh.get(l2,l2+len))%MOD;\n            }\n            else{\n                h=rh.get(l1,l1+len);\n            }\n            if(rh.get(l,mid)==h) lb=mid;\n            else ub=mid;\n        }\n        return lb;\n    };\n    while(q--){\n        int l,r,t;\n        cin>>l>>r>>t;\n        l--;\n        int x=calc(l,r,l,l+t,l,l,t);\n        x++;\n        x=calc(x,r,(x-l)%t+l,l+t,l,(x-l)%t+l,t);\n        int y=-1;\n        if(l+2*t<=s.size()){\n            y=calc(l,r,l+t,l+2*t,l,l,t);\n            y++;\n            y=calc(y,r,(y-l)%t+l+t,l+2*t,l+t,(y-l)%t+l+t,t);\n        }\n        cout<<((x>=r || y>=r) ? \"Yes\" : \"No\")<<endl;\n    }\n\n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int M = 1000000007;\n\nclass suffix_array {\n    // compare (rank[i], rank[i + k]) and (rank[j], rank[j + k])\n    static bool compare_sa(int n, const vector<int>& rank, int i, int j, int k) {\n        if (rank[i] != rank[j]) return rank[i] < rank[j];\n        int ri = i + k <= n ? rank[i + k] : -1;\n        int rj = j + k <= n ? rank[j + k] : -1;\n        return ri < rj;\n    }\npublic:\n    static vector<int> construct_sa(const string& s) {\n        int n = s.length();\n        vector<int> sa(n + 1), rank(n + 1);\n        for (int i = 0; i <= n; ++i) {\n            sa[i] = i;\n            rank[i] = i < n ? s[i] : -1;\n        }\n        for (int k = 1; k <= n; k <<= 1) {\n            sort(sa.begin(), sa.end(), [&n, &k, &rank](const int& a, const int& b){ return compare_sa(n, rank, a, b, k); });\n\n            vector<int> tmp(n + 1);\n            for (int i = 1; i <= n; ++i)\n                tmp[sa[i]] = tmp[sa[i - 1]] + compare_sa(n, rank, sa[i - 1], sa[i], k);\n            for (int i = 0; i <= n; ++i)\n                rank[i] = tmp[i];\n        }\n        return sa;\n    }\n    static vector<int> construct_lcp(const string& s, const vector<int>& sa) {\n        int n = s.length();\n        vector<int> rank(n + 1), lcp(n + 1);\n        for (int i = 0; i <= n; ++i) rank[sa[i]] = i;\n\n        int h = 0;\n        for (int i = 0; i < n; ++i) {\n            if (h > 0) --h;\n            for (int j = sa[rank[i] - 1]; j + h < n && i + h < n; ++h)\n                if (s[j + h] != s[i + h]) break;\n\n            lcp[rank[i] - 1] = h;\n        }\n        return lcp;\n    }\n};\n\nclass segtree {\nprivate:\n    int n, s, t;\n    vector<int> tr;\n    const int ex = M;\n\n    int q(int k, int l, int r) {\n        return r <= s || t <= l ? ex : s <= l && r <= t ? tr[k]\n                : min(q(k << 1 | 1, l, (l + r) >> 1), q((k + 1) << 1, (l + r) >> 1, r));\n    }\n\npublic:\n    segtree(int m) {\n        n = 1;\n        while (n < m) n <<= 1;\n        tr.clear();\n        tr.resize((n << 1) - 1, ex);\n    }\n    void update(int j, const int& x) {\n        int i = j + n - 1;\n        tr[i] = x;\n        while (i > 0) { i = (i - 1) >> 1; tr[i] = min(tr[i << 1 | 1], tr[(i + 1) << 1]); }\n    }\n    // [s, t)\n    int run(int _s, int _t) { s = _s; t = _t; return q(0, 0, n); }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    string s;\n    int q;\n    cin >> s >> q;\n    int n = s.length();\n    vector<int> sa = suffix_array::construct_sa(s);\n    vector<int> rank(n + 1);\n    for (int i = 0; i <= n; ++i) rank[sa[i]] = i;\n    vector<int> lcp = suffix_array::construct_lcp(s, sa);\n    segtree sg(n + 1);\n    for (int i = 0; i <= n; ++i) {\n        sg.update(i, lcp[i]);\n    }\n    auto run = [&](const int& a, const int& b){ return sg.run(min(a, b), max(a, b)); };\n    for (int _ = 0; _ < q; ++_) {\n        int l, r, t;\n        cin >> l >> r >> t;\n        --l;\n        int l1 = run(rank[l], rank[l + t]);\n        if (l + t + l1 >= r) {\n            cout << \"Yes\\n\";\n        }\n        else {\n            bool b1 = (l1 < t || s[l + l1 - t] == s[l + l1 + t]) && (l + l1 + t * 2 >= r || s[l + l1 + t] == s[l + l1 + t * 2]);\n            bool b2 = l + l1 + t * 2 >= r || s[l + l1] == s[l + l1 + t * 2];\n            int l2 = run(rank[l + l1 + 1], rank[l + l1 + 1 + t]);\n            int l3 = l + l1 + 1 + t * 2 >= r ? 0 : run(rank[l + l1 + t + 1], rank[l + l1 + t * 2 + 1]);\n            // cout << l2 << ' ' << l3 << '\\n';\n            if ((l2 == t - 1 || l + l1 + 1 + t + l2 >= r) && l + l1 + 1 + t * 2 + l3 >= r && (b1 || b2)) {\n                cout << \"Yes\\n\";\n            }\n            else\n                cout << \"No\\n\";\n        }\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP, rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size());\n    LCP[0] = 0;\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i] + 1] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (LCP[k]);\n  }\n\n  size_t size() const\n  {\n    return (LCP.size());\n  }\n};\n\n\nconst int INF = 1 << 30;\n\nstruct SegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n\n\nint main()\n{\n  string S;\n  int Q;\n\n  cin >> S;\n  cin >> Q;\n\n  SuffixArray sa;\n  LongestCommonPrefixArray lcp;\n  SegmentTree tree(S.size());\n\n  sa.Build_SA(S);\n  lcp.Build_LCP(sa);\n  for(int i = 0; i < S.size(); i++) tree.set(i, lcp[i]);\n  tree.build();\n\n  auto getLCP = [&](int a, int b)\n  {\n    if(a > S.size() || b > S.size()) return (INF);\n    a = lcp.rank[a], b = lcp.rank[b];\n    if(a > b) swap(a, b);\n    return (tree.rmq(a + 1, b + 1));\n  };\n\n  while(Q--) {\n    int l, r, t;\n    cin >> l >> r >> t;\n\n    int l1 = --l, r1 = r - t;\n    int l2 = l1 + t, r2 = r;\n    int length = r1 - l1;\n\n    int lcp1 = getLCP(l1, l2);\n\n    if(lcp1 >= length) {\n      cout << \"Yes\" << endl;\n      continue;\n    }\n\n    int lcp2 = getLCP(l1 + lcp1 + 1, l2 + lcp1 + 1);\n\n    if(lcp1 + 1 + lcp2 >= length) {\n      if(l1 + lcp1 < l2 || l2 + lcp1 >= r1) {\n        cout << \"Yes\" << endl;\n      } else {\n        cout << \"No\" << endl;\n      }\n      continue;\n    }\n\n    if(l1 + lcp1 + 1 + lcp2 < l2) {\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    if(lcp2 - lcp1 + 1 == t && S[l1 + lcp1] == S[l2 + lcp1 + 1 + lcp2]) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n\n/*\n    cout << S.substr(l1, r1 - l1) << endl;\n    cout << string(t, ' ') + S.substr(l2, r2 - l2) << endl;\n\n    cout << lcp2 - lcp1 << endl;\n*/\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\telse if (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n  if ( calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) ) )return true;\n\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconst ll mod = 1e9 + 7;\nconst ll b1 = 1009, b2 = 10007;\n\nll Pow(ll a, ll b) {\n\tll res = 1; a %= mod;\n\twhile (b) {\n\t\tif (b & 1) {\n\t\t\tres = (res * a) % mod;\n\t\t}\n\t\ta = (a * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nclass RollingHash {\n\tint N;\n\tstring s;\n\tvector<ll> r1, r2, h1, h2, rh1, rh2;\npublic:\n\tRollingHash(const string& s_)\n\t\t: N((int)s_.size()), s(s_), r1(N + 1), r2(N + 1), h1(N + 1), h2(N + 1), rh1(N + 1), rh2(N + 1) {\n\t\tr1[0] = r2[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) r1[i] = r1[i - 1] * b1 % mod;\n\t\tfor (int i = 1; i <= N; i++) r2[i] = r2[i - 1] * b2 % mod;\n\n\t\th1[0] = h2[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) h1[i] = (h1[i - 1] * b1 + s[i - 1]) % mod;\n\t\tfor (int i = 1; i <= N; i++) h2[i] = (h2[i - 1] * b2 + s[i - 1]) % mod;\n\t}\n\tP get(int l, int r) {\n\t\treturn P((h1[r + 1] - h1[l] * r1[r - l + 1] % mod + mod) % mod, (h2[r + 1] - h2[l] * r2[r - l + 1] % mod + mod) % mod);\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint Q;\n\tstring S;\n\tcin >> S >> Q;\n\tint N = S.size();\n\tRollingHash rh(S);\n\tvector<P> dis;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = -25; j <= 25; j++) {\n\t\t\tdis.push_back(P(Pow(b1, i) * (mod + j) % mod, Pow(b2, i) * (mod + j) % mod));\n\t\t}\n\t}\n\tsort(dis.begin(), dis.end());\n\tfor (int i = 0, l, r, t; i < Q; i++) {\n\t\tcin >> l >> r >> t; l--; r--;\n\t\tauto lrh = rh.get(l, r - t), rrh = rh.get(l + t, r);\n\t\tll d1 = (lrh.first - rrh.first + mod) % mod, d2 = (lrh.second - rrh.second + mod) % mod;\n\t\tif (r - l + 1 > t * 2) {\n\t\t\tif (binary_search(dis.begin(), dis.end(), P(d1, d2))) {\n\t\t\t\tputs(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint w = r - l + 1 , fl = (r - l + 1) / t * t;\n\t\t\t\tif (w == fl && rh.get(l, l + t - 1) != rh.get(r - t + 1, r)) {\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (w != fl && (rh.get(l, l + w - fl - 1) != rh.get(r - (w - fl - 1), r) || rh.get(l + w - fl, l + t - 1) != rh.get(r - t + 1, r - (w - fl)))) {\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tll lb = t - 1, ub = r - l + 1 - t;\n\t\t\t\twhile (lb + 1 < ub) {\n\t\t\t\t\tll c = (lb + ub) / 2;\n\t\t\t\t\tlrh = rh.get(l, l + c - 1), rrh = rh.get(l + t, l + t + c - 1);\n\t\t\t\t\td1 = (lrh.first - rrh.first + mod) % mod, d2 = (lrh.second - rrh.second + mod) % mod;\n\t\t\t\t\tif (binary_search(dis.begin(), dis.end(), P(d1, d2))) {\n\t\t\t\t\t\tlb = c;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tub = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tll tmp = lb;\n\t\t\t\tlb = t - 1, ub = r - l + 1 - t;\n\t\t\t\twhile (lb + 1 < ub) {\n\t\t\t\t\tll c = (lb + ub) / 2;\n\t\t\t\t\tlrh = rh.get(l + t - c + 1, l + t), rrh = rh.get(r - c + 1, r);\n\t\t\t\t\td1 = (lrh.first - rrh.first + mod) % mod, d2 = (lrh.second - rrh.second + mod) % mod;\n\t\t\t\t\tif (binary_search(dis.begin(), dis.end(), P(d1, d2))) {\n\t\t\t\t\t\tlb = c;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tub = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tputs(tmp + lb >= r - l ? \"Yes\" : \"No\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tputs(binary_search(dis.begin(), dis.end(), P(d1, d2)) ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 100009, mul1 = 1000007;\n\tstatic const ll add0 = 10000120007, add1 = 10032333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tstring filename = \"1340-out1.txt\";\n\t/*ifstream read_file(\"D:/D_Download/Visual Studio 2015/Projects/programing_contest_c++/Debug/1340-out1.txt\");\n\tstring ast;\n\tvector<int>anss;\n\twhile (read_file >>ast) {\n\t\tanss.push_back(ast== \"Yes\");\n\t\t\n\t}\n\tread_file.close();\n\t*/\n\tcin >> st;\n\trh.init(st);\n\tmap<char, int>mp;\n\tfor (auto c : st)mp[c]++;\n\tint N; cin >> N;\n\tint num = -1;\n\twhile (N--) {\n\t\tnum++;\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L, L + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(rsame){\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L, L + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tif (!issame(L, L + nt / 2, nt / 2 - 1).first) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassert(issame(L, L + nt, nt - 1).first);\n\t\t\t}\n\t\t}\n\t\t//assert(ok==anss[num]);\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll po(const ll p, const ll n, const ll mod)\n{\n    if (n == 0) { return 1; }\n    if (n % 2 == 1) {\n        return po(p, n - 1, mod) * p % mod;\n    } else {\n        const ll pp = po(p, n / 2, mod);\n        return pp * pp % mod;\n    }\n}\nconstexpr ll inv(const ll p, const ll mod) { return po(p, mod - 2, mod); }\nconstexpr ll BASE1 = 186398169LL;\nconstexpr ll MOD1 = 1000000007LL;\nconstexpr ll INV1 = inv(BASE1, MOD1);\nconstexpr ll BASE2 = 238173201LL;\nconstexpr ll MOD2 = 1000000009LL;\nconstexpr ll INV2 = inv(BASE2, MOD2);\nconstexpr int MAX = 100000;\nP power[MAX], inverse[MAX], h[MAX];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string S;\n    cin >> S;\n    for (ll i = 0, p1 = 1, p2 = 1, i1 = 1, i2 = 1, h1 = 0, h2 = 0; i < S.size(); i++, (p1 *= BASE1) %= MOD1, (p2 *= BASE2) %= MOD2, (i1 *= INV1) %= MOD1, (i2 *= INV2) %= MOD2) { (h1 += (S[i] - 'a') * p1 % MOD1) %= MOD1, (h2 += (S[i] - 'a') * p2 % MOD2) %= MOD2, h[i] = {h1, h2}, inverse[i] = {i1, i2}, power[i] = {p1, p2}; };\n    auto add = [](const P& p1, const P& p2) -> P { return {(p1.first + p2.first) % MOD1, (p1.second + p2.second) % MOD2}; };\n    auto sub = [](const P& p1, const P& p2) -> P { return {(p1.first + MOD1 - p2.first) % MOD1, (p1.second + MOD2 - p2.second) % MOD2}; };\n    auto mul = [](const P& p1, const P& p2) -> P { return {(p1.first * p2.first) % MOD1, (p1.second * p2.second) % MOD2}; };\n    auto getHash = [&](const int s, const int l) -> P { return l == 0 ? P{0, 0} : s == 0 ? h[s + l - 1] : mul(sub(h[s + l - 1], h[s - 1]), inverse[s]); };\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; q++) {\n        int l, r, t;\n        (cin >> l >> r >> t), l--;\n        const int L = r - l;\n        int inf = 0, sup = L - t;\n        while (sup - inf > 1) {\n            const int mid = (inf + sup) / 2;\n            if (getHash(l, mid) == getHash(l + t, mid)) {\n                inf = mid;\n            } else {\n                sup = mid;\n            }\n        }\n        bool ok = false;\n        for (int i = 0; i < 26; i++) {\n            for (int j = 0; j < 2; j++) {\n                const int pos = j == 0 ? inf : inf + t;\n                const P ch = sub({i, i}, {S[pos + l] - 'a', S[pos + l] - 'a'});\n                const P off1 = (pos < r - t ? power[pos] : P{0, 0});\n                const P off2 = (pos >= t ? power[pos - t] : P{0, 0});\n                if (add(getHash(l, L - t), mul(off1, ch)) == add(getHash(l + t, L - t), mul(off2, ch))) {\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        cout << (ok ? \"Yes\\n\" : \"No\\n\");\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nconst ull B = (1e9)+7;\null PB[100001];\null S[100001];\nstring str;\n\null get(int l,int r){return S[r]-S[l]*PB[r-l];}\null get(int l,int r,int x,char ch){\n  ull res=get(l,r);\n  if(x<l||r<=x) return res;\n  res-=str[x]*PB[r-x-1];\n  res+=ch*PB[r-x-1];\n  return res;\n}\n\n\nint search(int a,int b,int x,int ch){\n  int L=0,M,R=str.size();\n  while(L<R){\n    M = (L+R)/2;\n    if(get(a,a+M,x,ch)!=get(b,b+M,x,ch)) R = M;\n    else L = M+1;\n  }\n  return L;\n}\n\n\nbool check(int l,int r,int t){\n  int x = min(r,l+t+search(l,l+t,-1,0));\n  if(--x==r)return 0;\n  return min(r+1,l+t+search(l,l+t,x,str[l+(x-l-t)%t])) == r+1;\n}\n\nint main(){\n  cin>>str;\n  for(int i=0;i<(int)str.size();i++) S[i+1]=S[i]*B+str[i];\n  PB[0]=1;\n  for(int i=01;i<=(int)str.size();i++) PB[i]=PB[i-1]*B;\n  int q;\n  cin>>q;\n  while(q--){\n    int l,r,t;\n    cin>>l>>r>>t;l--;\n    cout<<(check(l,r,t)? \"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP, rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size());\n    LCP[0] = 0;\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i] + 1] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (LCP[k]);\n  }\n\n  size_t size() const\n  {\n    return (LCP.size());\n  }\n};\n\n\nconst int INF = 1 << 30;\n\nstruct SegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n\n\nint main()\n{\n  string S;\n  int Q;\n\n  cin >> S;\n  cin >> Q;\n\n  SuffixArray sa;\n  LongestCommonPrefixArray lcp;\n  SegmentTree tree(S.size());\n\n  sa.Build_SA(S);\n  lcp.Build_LCP(sa);\n  for(int i = 0; i < S.size(); i++) tree.set(i, lcp[i]);\n  tree.build();\n\n  auto getLCP = [&](int a, int b)\n  {\n    if(a > S.size() || b > S.size()) return (INF);\n    a = lcp.rank[a], b = lcp.rank[b];\n    if(a > b) swap(a, b);\n    return (tree.rmq(a + 1, b + 1));\n  };\n\n  while(Q--) {\n    int l, r, t;\n    cin >> l >> r >> t;\n\n    int l1 = --l, r1 = r - t;\n    int l2 = l1 + t, r2 = r;\n    int length = r1 - l1;\n\n    int lcp1 = getLCP(l1, l2);\n\n    /*\n    cout << S.substr(l1, r1 - l1) << endl;\n    cout << string(t, ' ') + S.substr(l2, r2 - l2) << endl;\n    */\n\n    // (>_<)\n    if(lcp1 >= length) {\n      cout << \"Yes\" << endl;\n      continue;\n    }\n\n    int lcp2 = getLCP(l1 + lcp1 + 1, l2 + lcp1 + 1);\n\n    if(lcp1 + 1 + lcp2 >= length) {\n      if(l1 + lcp1 < l2 || l2 + lcp1 >= r1) {\n        cout << \"Yes\" << endl;\n      } else {\n        cout << \"No\" << endl;\n      }\n      continue;\n    }\n/*\n    if(l1 + lcp1 + 1 + lcp2 < l2) {\n      cout << \"No\" << endl;\n      continue;\n    }\n*/\n    if(lcp2 + 1 == t && S[l1 + lcp1] == S[l2 + lcp1 + t]) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  assert(a!=l);\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  assert(b-a==r-l);\n  assert(a!=l);\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  assert(b-a==r-l);\n  assert(a!=l);\n\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L])  );\n  //  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool intersect(int a,int b,int l,int r){\n  if( b<=l || r<=a ) return false;\n  else return true;\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n  //  calc(l+as,r-t,l+as+t,r);\n\n  //  if ( calc(l+as,r-t ,l+as+t,r) && ( eq(l,l+as,r-t,r-t+as) || eq(l,l+as,r-t-t,r-t-t+as) ) )return true;\n  //  if ( eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-t,r-t+as) || calc(l,l+as,r-t-t,r-t-t+as) ) )return true;\n\n\n  if ( calc(l,r-as-t ,l+t,r-as) && eq(l,l+as,r-as,r)  )return true;\n  if ( calc(l+t,r-as ,l,r-as-t) && eq(l+t,l+t+as,r-as,r)  )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && calc(l,l+as,r-as,r)  )return true;\n\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n\n  for(int i=0;i<n;i++){\n    s[i]+=19;\n  }\n\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef unsigned long long ull;\n\nconst ull M=(1e9+7);\nstring s;\nint q;\null H[N], D[N];\n\nvoid cal_hash(){\n  ull h=0;\n  for(int i=0;i<s.size();i++){\n    h=h*M+s[i];\n    H[i+1]=h;\n  }\n  h=1;\n  for(int i=0;i<N;i++){\n    D[i]=h;\n    h*=M;\n  }\n  s='X'+s;\n}\n\nint get_first_diff_idx(int l, int r, int t){\n  \n  int L=0, R=r-l-t+2;\n  \n  while(L<R){\n    \n    int Mid=(L+R)/2;\n    ull v1=H[l+Mid]-H[l-1]*D[Mid+1];\n    ull v2=H[l+Mid+t]-H[l+t-1]*D[Mid+1];\n    \n    if(v1==v2) L=Mid+1;\n    else R=Mid;\n  }\n  \n  return L;\n}\n\nbool isSame(int l, int r, int t, int A, int B){\n  \n  int i1=l+t, i2=r;\n  ull h1=0, h2=0;\n  \n  if(i1<=A&&A<=i2){\n    \n    if(i1<A&&A<i2) h1=H[i2]-H[A]*D[i2-A]+((H[A-1]-H[i1-1]*D[A-i1])*D[1]+s[B])*D[i2-A];\n    else if(A==i1) h1=H[i2]-H[i1]*D[i2-i1]+s[B]*D[i2-i1];\n    else if(A==i2) h1=s[B]+(H[i2-1]-H[i1-1]*D[i2-i1])*D[1];\n    \n  }else h1=H[i2]-H[i1-1]*D[i2-i1+1];\n  \n  i1=l, i2=r-t;\n  \n  if(i1<=A&&A<=i2){\n    \n    if(i1<A&&A<i2) h2=H[i2]-H[A]*D[i2-A]+((H[A-1]-H[i1-1]*D[A-i1])*D[1]+s[B])*D[i2-A];\n    else if(A==i1) h2=H[i2]-H[i1]*D[i2-i1]+s[B]*D[i2-i1];\n    else if(A==i2) h2=s[B]+(H[i2-1]-H[i1-1]*D[i2-i1])*D[1];\n    \n  }else h2=H[i2]-H[i1-1]*D[i2-i1+1];\n  \n  return h1==h2;\n}\n\nbool check(int l, int r, int t){\n  \n  int idx=get_first_diff_idx(l, r, t);\n\n  int i1=l+idx, i2=l+t+idx;\n  \n  return isSame(l, r, t, i1, i2) | isSame(l, r, t, i2, i1);\n}\n\nint main(){\n  \n  cin>>s;\n  \n  cal_hash();\n  \n  cin>>q;\n  \n  int l, r, t;\n  \n  for(int i=0;i<q;i++){\n    scanf(\"%d %d %d\", &l, &r, &t);\n    if(check(l, r, t)) printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP, rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size());\n    LCP[0] = 0;\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i] + 1] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (LCP[k]);\n  }\n\n  size_t size() const\n  {\n    return (LCP.size());\n  }\n};\n\n\nconst int INF = 1 << 30;\n\nstruct SegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n\n\nint main()\n{\n  string S;\n  int Q;\n\n  cin >> S;\n  cin >> Q;\n\n  SuffixArray sa;\n  LongestCommonPrefixArray lcp;\n  SegmentTree tree(S.size());\n\n  sa.Build_SA(S);\n  lcp.Build_LCP(sa);\n  for(int i = 0; i < S.size(); i++) tree.set(i, lcp[i]);\n  tree.build();\n\n  auto getLCP = [&](int a, int b)\n  {\n    if(a > S.size() || b > S.size()) return (INF);\n    a = lcp.rank[a], b = lcp.rank[b];\n    if(a > b) swap(a, b);\n    return (tree.rmq(a + 1, b + 1));\n  };\n\n  while(Q--) {\n    int l, r, t;\n    cin >> l >> r >> t;\n\n    int l1 = --l, r1 = r - t;\n    int l2 = l1 + t, r2 = r;\n    int length = r1 - l1;\n\n    int lcp1 = getLCP(l1, l2);\n\n    /*\n    cout << S.substr(l1, r1 - l1) << endl;\n    cout << string(t, ' ') + S.substr(l2, r2 - l2) << endl;\n    */\n\n    // (>_<)\n    if(r - l == t || lcp1 >= length) {\n      cout << \"Yes\" << endl;\n      continue;\n    }\n\n    int lcp2 = getLCP(l1 + lcp1 + 1, l2 + lcp1 + 1);\n\n    if(lcp1 + 1 + lcp2 >= length) {\n      if(l1 + lcp1 < l2 || l2 + lcp1 >= r1) {\n        cout << \"Yes\" << endl;\n      } else {\n        cout << \"No\" << endl;\n      }\n      continue;\n    }\n\n    if(l1 + lcp1 + 1 + lcp2 < l2) {\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    if(lcp2 + 1 == t && S[l1 + lcp1] == S[l2 + lcp1 + t]) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Ti = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nusing ull = unsigned long long;\nstruct RollingHash {\n  //string s;\n  ull base, mod;\n  vector<ull> hashed, power;\n  RollingHash(const string& s):/*s(s),*/ base(9973ll), mod(999999937ll){\n    int sz = s.size();\n    hashed.resize(sz+1, 0);\n    power.resize(sz+1, 0);\n    power[0] = 1;\n    for(int i = 0; i < sz; i++) {\n      power[i+1] = power[i]*base%mod;\n      hashed[i+1] = (hashed[i]*base%mod+s[i])%mod;\n    }\n  }\n  ull get(int l, int r) {\n    return (hashed[r]-hashed[l]*power[r-l]%mod+mod)%mod;\n  }\n  ull concat(ull h1, ull h2, int len) {\n    return (h1*power[len]%mod+h2)%mod;\n  }\n  ull rehash(int l, int r, int i, char c) {\n    if(i < l || r <= i) return get(l, r);\n    //cout << r-l << \" \" << s.substr(l, r-l) << \" \" << s.substr(l, i-l) << endl;\n    ull h = get(l, i);\n    //cout << l << \" \" << r << \" \" << i << \" \" << c <<  \" \" << h << endl;\n    h = (h*base%mod + c)%mod;\n    return concat(h, get(i+1, r), r-(i+1));\n  }\n};\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  string s;\n  cin >> s;\n  RollingHash rh(s);\n\n  int q;\n  cin >> q;\n  while(q--) {\n    int l, r, t;\n    cin >> l >> r >> t;\n    --l;\n    if(rh.get(l, r-t) == rh.get(l+t, r)) {\n      cout << \"Yes\" << endl;\n      continue;\n    }\n    int lb = 0, ub = r-l+1;\n    while(lb+1 < ub) {\n      int mb = (lb+ub)/2;\n      if(rh.get(l, l+mb) == rh.get(l+t, l+t+mb)) lb = mb;\n      else ub = mb;\n    }\n    //cout << rh.get(l, l+lb) << \" \" << rh.get(l+t, l+t+lb) << endl;\n    //cout << lb << \" \" << s[l+lb] << \" \" << s[l+t+lb] << endl;\n    //cout << rh.rehash(l, r-t, l+lb, s[l+lb]) << \" \" << rh.get(l, r-t) << endl;\n    //cout << rh.rehash(l+t, r, l+t+lb, s[l+lb]) <<  \" \" << rh.get(l+t, r) << endl;\n    if((rh.rehash(l, r-t, l+lb, s[l+t+lb]) == rh.rehash(l+t, r, l+lb, s[l+t+lb])) ||\n       (rh.rehash(l, r-t, l+t+lb, s[l+lb]) == rh.rehash(l+t, r, l+t+lb, s[l+lb]))) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n  return ( calc(l,r-as-t ,l+t,r-as) && calc(l+as,r-t,l+as+t,r) );\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll po(const ll p, const ll n, const ll mod)\n{\n    if (n == 0) { return 1; }\n    if (n % 2 == 1) {\n        return po(p, n - 1, mod) * p % mod;\n    } else {\n        const ll pp = po(p, n / 2, mod);\n        return pp * pp % mod;\n    }\n}\nconstexpr ll inv(const ll p, const ll mod) { return po(p, mod - 2, mod); }\nconstexpr ll BASE1 = 186398169LL;\nconstexpr ll MOD1 = 1000000007LL;\nconstexpr ll INV1 = inv(BASE1, MOD1);\nconstexpr ll BASE2 = 238173201LL;\nconstexpr ll MOD2 = 1000000009LL;\nconstexpr ll INV2 = inv(BASE2, MOD2);\nconstexpr int MAX = 100000;\nP power[MAX], inverse[MAX], h[MAX];\nmap<P, int> phash;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string S;\n    cin >> S;\n    for (ll i = 0, p1 = 1, p2 = 1, i1 = 1, i2 = 1, h1 = 0, h2 = 0; i < S.size(); i++, (p1 *= BASE1) %= MOD1, (p2 *= BASE2) %= MOD2, (i1 *= INV1) %= MOD1, (i2 *= INV2) %= MOD2) {\n        (h1 += (S[i] - 'a') * p1 % MOD1) %= MOD1, (h2 += (S[i] - 'a') * p2 % MOD2) %= MOD2, h[i] = {h1, h2}, inverse[i] = {i1, i2}, power[i] = {p1, p2};\n        for (int j = 1; j < 26; j++) { phash[{p1 * j % MOD1, p2 * j % MOD2}] = i; }\n    };\n\n    auto add = [](const P& p1, const P& p2) -> P { return {(p1.first + p2.first) % MOD1, (p1.second + p2.second) % MOD2}; };\n    auto sub = [](const P& p1, const P& p2) -> P { return {(p1.first + MOD1 - p2.first) % MOD1, (p1.second + MOD2 - p2.second) % MOD2}; };\n    auto mul = [](const P& p1, const P& p2) -> P { return {(p1.first * p2.first) % MOD1, (p1.second * p2.second) % MOD2}; };\n    auto getHash = [&](const int s, const int l) -> P { return l == 0 ? P{0, 0} : s == 0 ? h[s + l - 1] : mul(sub(h[s + l - 1], h[s - 1]), inverse[s]); };\n    auto getSum = [&](const ll p, const ll n, const ll mod) -> ll { return p == 1 ? n : (po(p, n, mod) - 1) * inv(p - 1, mod) % mod; };\n    auto getPoly = [&](const int t, const int rep) -> P { return {getSum(power[t].first, rep, MOD1), getSum(power[t].second, rep, MOD2)}; };\n    auto judge = [&](const P& diff, const int L) -> bool { return diff == P{0, 0} or (phash.find(diff) != phash.end() and phash[diff] < L) or (phash.find(sub({0, 0}, diff)) != phash.end() and phash[sub({0, 0}, diff)] < L); };\n    assert(phash.size() == 25 * S.size());\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; q++) {\n        int l, r, t;\n        (cin >> l >> r >> t), l--;\n        const int L = r - l, rep = L / t, rest = L % t;\n        const P Hash = getHash(l, L);\n        const P Tail = getHash(l, rest);\n        if (rep == 1) {\n            const P mask1 = add(getHash(l, t), mul(power[t * rep], Tail));\n            const P diff = sub(mask1, Hash);\n            cout << (judge(diff, L) ? \"Yes\\n\" : \"No\\n\");\n        } else {\n            const P poly = getPoly(t, rep);\n            const P mask1 = add(mul(poly, getHash(l, t)), mul(power[t * rep], Tail));\n            const P diff1 = sub(mask1, Hash);\n            const P mask2 = add(mul(poly, getHash(l + t, t)), mul(power[t * rep], Tail));\n            const P diff2 = sub(mask2, Hash);\n            cout << (judge(diff1, L) or judge(diff2, L) ? \"Yes\\n\" : \"No\\n\");\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l,r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r+1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r+1 - index - 1].second);\n\t}\n\tvoid change_st(const int index, const ll from, const ll to)const {\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const pair<int, int>a, const pair<int, int>b) {\n\tint al = a.first, ar = a.second;\n\tint bl = b.first, br = b.second;\n\tint lans = -1;\n\tint rans = ar-al;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans+1, ar) == rh.hash(bl + rans+1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind,st[changeind],changeto,l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool,int> issame(pair<int,int>a, pair<int,int>b) {\n\tif (b.first > R) {\n\t\treturn make_pair(1, -1);\n\t}\n\telse {\n\t\tassert(b.first <= R);\n\t\tint len = min(a.second - a.first, R - b.first);\n\t\tbool same=  getha(a.first,a.first+len) == getha(b.first,b.first+len);\n\t\tif (same)return make_pair(1, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a, b);\n\t\t\treturn make_pair(false,acheck);\n\t\t}\n\t}\n}\nint main() { \n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize*2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto aa = issame(make_pair(L, L + nt-1), make_pair(L + nt, L + nt * 2 - 1));\n\t\t\tif (aa.first)continue;\n\t\t\telse {\n\t\t\t\tint p(aa.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = getha(L, L + nt / 2 - 1) == getha(L + nt / 2, L +nt-1);\n\t\t\t\t\t\tbool rsame;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > R) {\n\t\t\t\t\t\t\t\trsame = true;\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trsame = getha(l3, r3) == getha(l4, r4);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L+nt+ p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L+ p;\n\t\t\t\t\t\t\t\tchangeto = st[L+nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l,r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r+1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r+1 - index - 1].second);\n\t}\n\tvoid change_st(const int index, const ll from, const ll to)const {\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const pair<int, int>&a, const pair<int, int>&b) {\n\tint al = a.first, ar = a.second;\n\tint bl = b.first, br = b.second;\n\tint lans = -1;\n\tint rans = ar-al;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans+1, ar) == rh.hash(bl + rans+1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind,st[changeind],changeto,l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\n//bool issame(const int l1,  int r1, const int l2,  int r2) {\n//\tif (l2 > R) {\n//\t\treturn true;\n//\t}\n//\telse {\n//\t\tif (r2 > R) {\n//\t\t\tr2 = R;\n//\t\t\tassert(l2 <= R);\n//\t\t}\n//\t\treturn  getha(l3, r3) == getha(l4, r4);\n//\t\tif (r3 < L + nt + p&&L + nt + p < r3)rflag = true;\n//\t}\n//}\nint main() { \n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize*2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tconst int l1 = L;\n\t\t\tint r1 = L + nt - 1;\n\t\t\tconst int l2 = L + nt;\n\t\t\tint r2 = L + 2 * nt - 1;\n\t\t\tif (r2 > R) {\n\t\t\t\tr2 = R;\n\t\t\t\tr1 = l1 + r2 - l2;\n\t\t\t\tassert(l2 <= R);\n\t\t\t}\n\t\t\tha ha1 = getha(l1, r1);\n\t\t\tha ha2 = getha(l2,r2);\n\t\t\tif (ha1 == ha2)continue;\n\t\t\telse {\n\t\t\t\tint p(check(make_pair(l1, r1), make_pair(l2, r2)));\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = getha(l1, l1 + nt / 2 - 1) == getha(l1 + nt / 2, l1+nt-1);\n\t\t\t\t\t\tbool rsame;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > R) {\n\t\t\t\t\t\t\t\trsame = true;\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trsame = getha(l3, r3) == getha(l4, r4);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = l2 + p;\n\t\t\t\t\t\t\t\tchangeto = st[l1 + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = l1 + p;\n\t\t\t\t\t\t\t\tchangeto = st[l2 + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = l2 + p;\n\t\t\t\t\t\t\t\tchangeto = st[l1 + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = l1 + p;\n\t\t\t\t\t\t\t\tchangeto = st[l2 + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll po(const ll p, const ll n, const ll mod)\n{\n    if (n == 0) { return 1; }\n    if (n % 2 == 1) {\n        return po(p, n - 1, mod) * p % mod;\n    } else {\n        const ll pp = po(p, n / 2, mod);\n        return pp * pp % mod;\n    }\n}\nconstexpr ll inv(const ll p, const ll mod) { return po(p, mod - 2, mod); }\nconstexpr ll BASE1 = 186398169LL;\nconstexpr ll MOD1 = 1000000007LL;\nconstexpr ll INV1 = inv(BASE1, MOD1);\nconstexpr ll BASE2 = 238173201LL;\nconstexpr ll MOD2 = 1000000009LL;\nconstexpr ll INV2 = inv(BASE2, MOD2);\nconstexpr int MAX = 100000;\nP power[MAX], inverse[MAX], h[MAX];\nmap<P, int> phash;\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string S;\n    cin >> S;\n    for (ll i = 0, p1 = 1, p2 = 1, i1 = 1, i2 = 1, h1 = 0, h2 = 0; i < S.size(); i++, (p1 *= BASE1) %= MOD1, (p2 *= BASE2) %= MOD2, (i1 *= INV1) %= MOD1, (i2 *= INV2) %= MOD2) {\n        (h1 += (S[i] - 'a') * p1 % MOD1) %= MOD1, (h2 += (S[i] - 'a') * p2 % MOD2) %= MOD2, h[i] = {h1, h2}, inverse[i] = {i1, i2}, power[i] = {p1, p2};\n        for (int j = 1; j < 26; j++) { phash[{p1 * j % MOD1, p2 * j % MOD2}] = i; }\n    };\n\n    auto add = [](const P& p1, const P& p2) -> P { return {(p1.first + p2.first) % MOD1, (p1.second + p2.second) % MOD2}; };\n    auto sub = [](const P& p1, const P& p2) -> P { return {(p1.first + MOD1 - p2.first) % MOD1, (p1.second + MOD2 - p2.second) % MOD2}; };\n    auto mul = [](const P& p1, const P& p2) -> P { return {(p1.first * p2.first) % MOD1, (p1.second * p2.second) % MOD2}; };\n    auto getHash = [&](const int s, const int l) -> P { return l == 0 ? P{0, 0} : s == 0 ? h[s + l - 1] : mul(sub(h[s + l - 1], h[s - 1]), inverse[s]); };\n    auto getSum = [&](const ll p, const ll n, const ll mod) -> ll { return p == 1 ? n : (po(p, n, mod) - 1) * inv(p - 1, mod) % mod; };\n    auto getPoly = [&](const int t, const int rep) -> P { return {getSum(power[t].first, rep, MOD1), getSum(power[t].second, rep, MOD2)}; };\n    auto judge = [&](const P& diff, const int L) -> bool { return diff == P{0, 0} or (phash.find(diff) != phash.end() and phash[diff] < L) or (phash.find(sub({0, 0}, diff)) != phash.end() and phash[sub({0, 0}, diff)] < L); };\n    assert(phash.size() == 25 * S.size());\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; q++) {\n        int l, r, t;\n        (cin >> l >> r >> t), l--;\n        const int L = r - l, rep = L / t, rest = L % t;\n        const P Hash = getHash(l, L);\n        const P Tail = getHash(l + t * rep, rest);\n        if (rep == 1) {\n            const P mask1 = add(getHash(l, t), mul(power[t * rep], Tail));\n            const P diff = sub(mask1, Hash);\n            cout << (judge(diff, L) ? \"Yes\\n\" : \"No\\n\");\n        } else {\n            const P poly = getPoly(t, rep);\n            const P mask1 = add(mul(poly, getHash(l, t)), mul(power[t * rep], Tail));\n            const P diff1 = sub(mask1, Hash);\n            const P mask2 = add(mul(poly, getHash(l + t, t)), mul(power[t * rep], Tail));\n            const P diff2 = sub(mask2, Hash);\n            cout << (judge(diff1, L) or judge(diff2, L) ? \"Yes\\n\" : \"No\\n\");\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP, rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size());\n    LCP[0] = 0;\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i] + 1] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (LCP[k]);\n  }\n\n  size_t size() const\n  {\n    return (LCP.size());\n  }\n};\n\n\nconst int INF = 1 << 30;\n\nstruct SegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n\n\nint main()\n{\n  string S;\n  int Q;\n\n  cin >> S;\n  cin >> Q;\n\n  SuffixArray sa;\n  LongestCommonPrefixArray lcp;\n  SegmentTree tree(S.size());\n\n  sa.Build_SA(S);\n  lcp.Build_LCP(sa);\n  for(int i = 0; i < S.size(); i++) tree.set(i, lcp[i]);\n  tree.build();\n\n  auto getLCP = [&](int a, int b)\n  {\n    if(a > S.size() || b > S.size()) return (INF);\n    a = lcp.rank[a], b = lcp.rank[b];\n    if(a > b) swap(a, b);\n    return (tree.rmq(a + 1, b + 1));\n  };\n\n  while(Q--) {\n    int l, r, t;\n    cin >> l >> r >> t;\n\n    int l1 = --l, r1 = r - t;\n    int l2 = l1 + t, r2 = r;\n    int length = r1 - l1;\n\n    int lcp1 = getLCP(l1, l2);\n\n    /*\n    cout << S.substr(l1, r1 - l1) << endl;\n    cout << string(t, ' ') + S.substr(l2, r2 - l2) << endl;\n    */\n\n    // (>_<)\n    if(lcp1 >= length) {\n      cout << \"Yes\" << endl;\n      continue;\n    }\n\n    int lcp2 = getLCP(l1 + lcp1 + 1, l2 + lcp1 + 1);\n\n    if(lcp1 + 1 + lcp2 >= length) {\n      cout << \"Yes\" << endl;\n      //  continue;\n      continue;\n    }\n\n    if(l1 + lcp1 + 1 + lcp2 < l2) {\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    if(lcp2 + 1 == t && S[l1 + lcp1] == S[l2 + lcp1 + t]) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l,r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r+1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r+1 - index - 1].second);\n\t}\n\tvoid change_st(const int index, const ll from, const ll to)const {\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const pair<int, int>a, const pair<int, int>b) {\n\tint al = a.first, ar = a.second;\n\tint bl = b.first, br = b.second;\n\tint lans = -1;\n\tint rans = ar-al;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans+1, ar) == rh.hash(bl + rans+1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind,st[changeind],changeto,l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool,int> issame(pair<int,int>a, pair<int,int>b) {\n\tif (b.first > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b.first <= R);\n\t\tint len = min(a.second - a.first, R - b.first);\n\t\tbool same=  getha(a.first,a.first+len) == getha(b.first,b.first+len);\n\t\tif (same)return make_pair(1, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a, b);\n\t\t\treturn make_pair(false,acheck);\n\t\t}\n\t}\n}\nint main() { \n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize*2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tconst int l1 = L;\n\t\t\tint r1 = L + nt - 1;\n\t\t\tconst int l2 = L + nt;\n\t\t\tint r2 = L + 2 * nt - 1;\n\t\t\tif (r2 > R) {\n\t\t\t\tr2 = R;\n\t\t\t\tr1 = l1 + r2 - l2;\n\t\t\t\tassert(l2 <= R);\n\t\t\t}\n\t\t\tha ha1 = getha(l1, r1);\n\t\t\tha ha2 = getha(l2,r2);\n\t\t\tif (ha1 == ha2)continue;\n\t\t\telse {\n\t\t\t\tint p(check(make_pair(l1, r1), make_pair(l2, r2)));\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = getha(L, L  + nt / 2 - 1) == getha(L  + nt / 2, L +nt-1);\n\t\t\t\t\t\tbool rsame;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > R) {\n\t\t\t\t\t\t\t\trsame = true;\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trsame = getha(l3, r3) == getha(l4, r4);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nstruct RollingHash {\n\tstatic const ll mo0=1000000007,mo1=1000000009; static ll mul0,mul1;\n    static vector<ll> pmo[2];\n\tstring s; int sz; vector<ll> hash_[2];\n\tvoid init(string s) {\n\t\tthis->s=s; sz=(int)s.size();\n\t\thash_[0].resize(sz+1,0),hash_[1].resize(sz+1,0);\n\t\tif(!mul0) mul0=10009+(((ll)&mul0)>>5)%259,mul1=10007+(((ll)&mul1)>>5)%257;\n\t\tif(pmo[0].empty()) pmo[0].pb(1),pmo[1].pb(1);\n\t\trep(i,sz) hash_[0][i+1]=(hash_[0][i]*mul0+s[i])%mo0;\t//hash_[0][i]はインデックス0~i-1までの文字列のハッシュ値\n\t\trep(i,sz) hash_[1][i+1]=(hash_[1][i]*mul1+s[i])%mo1;\n\t}\n\tpair<ll,ll> hash(int l,int r){\t//文字列sのインデックス[l,r]までの部分文字列のハッシュ値\n\t\tif(l>r) return make_pair(0,0);\n\t\twhile((int)pmo[0].size()<r+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n\t\treturn make_pair((hash_[0][r+1]+(mo0-hash_[0][l]*pmo[0][r+1-l]%mo0))%mo0,\n\t\t\t             (hash_[1][r+1]+(mo1-hash_[1][l]*pmo[1][r+1-l]%mo1))%mo1);\n\t}\n    pair<ll,ll> update_hash(int l, int r, int k, char c){  //文字列sのs[k]をcに変えたときの[l,r]までの部分文字列のハッシュ値\n        if(l>r) return make_pair(0,0);\n        while((int)pmo[0].size()<r+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n        return make_pair((hash_[0][r+1]+(mo0-hash_[0][l]*pmo[0][r+1-l]%mo0)+pmo[0][r-k]*((int)c - (int)s[k]))%mo0,\n                         (hash_[1][r+1]+(mo1-hash_[1][l]*pmo[1][r+1-l]%mo1)+pmo[1][r-k]*((int)c - (int)s[k]))%mo1);\n    }\n\tpair<ll,ll> hash(string s) { init(s); return hash(0,(int)s.size()-1); }\t//文字列s全体のハッシュ値\n\tstatic pair<ll,ll> concat(pair<ll,ll> L,pair<ll,ll> R,int RL) { //文字列L+Rのハッシュ値,RLはRの文字列の長さ\n\t\twhile((int)pmo[0].size()<RL+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n\t\treturn make_pair((R.first + L.first*pmo[0][RL])%mo0,(R.second + L.second*pmo[1][RL])%mo1);\n\t}\n};\nvector<ll> RollingHash::pmo[2]; ll RollingHash::mul0,RollingHash::mul1;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    RollingHash rh;\n    rh.init(s);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int x,y,z;\n        cin >> x >> y >> z;\n        --x,--y;\n        pll p1 = rh.hash(x,y-z), p2 = rh.hash(x+z,y);\n        if(p1 == p2){\n            cout << \"Yes\\n\";\n            continue;\n        }\n        int l = 0,r = y-x-z+1;\n        while(r-l>1){\n            int mid = (l+r)/2;\n            if(rh.hash(x,x+l) == rh.hash(x+z,x+z+l)){\n                l = mid;\n            }else{\n                r = mid;\n            }\n        }\n        if(rh.update_hash(x,y-z,x+l,s[x+z+l]) == p2){\n            cout << \"Yes\\n\";\n        }else{\n            cout << \"No\\n\";\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP, rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size());\n    LCP[0] = 0;\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i] + 1] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (LCP[k]);\n  }\n\n  size_t size() const\n  {\n    return (LCP.size());\n  }\n};\n\n\nconst int INF = 1 << 30;\n\nstruct SegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n\n\nint main()\n{\n  string S;\n  int Q;\n\n  cin >> S;\n  cin >> Q;\n\n  SuffixArray sa;\n  LongestCommonPrefixArray lcp;\n  SegmentTree tree(S.size());\n\n  sa.Build_SA(S);\n  lcp.Build_LCP(sa);\n  for(int i = 0; i < S.size(); i++) tree.set(i, lcp[i]);\n  tree.build();\n\n  auto getLCP = [&](int a, int b)\n  {\n    if(a > S.size() || b > S.size()) return (INF);\n    a = lcp.rank[a], b = lcp.rank[b];\n    if(a > b) swap(a, b);\n    return (tree.rmq(a + 1, b + 1));\n  };\n\n  while(Q--) {\n    int l, r, t;\n    cin >> l >> r >> t;\n\n    int l1 = --l, r1 = r - t;\n    int l2 = l1 + t, r2 = r;\n    int length = r1 - l1;\n\n    int lcp1 = getLCP(l1, l2);\n\n    if(lcp1 >= length) {\n      cout << \"Yes\" << endl;\n      continue;\n    }\n\n    int lcp2 = getLCP(l1 + lcp1 + 1, l2 + lcp1 + 1);\n\n    if(lcp1 + 1 + lcp2 >= length) {\n      if(l1 + lcp1 < l2 || l2 + lcp1 >= r1) {\n        cout << \"Yes\" << endl;\n      } else {\n        cout << \"No\" << endl;\n      }\n      continue;\n    }\n\n    if(l1 + lcp1 + 1 + lcp2 < l2) {\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    if(lcp1 + 2 /*_*/ == t && S[l1 + lcp1] == S[l2 + lcp1 + 1 + lcp2]) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n\n/*\n    cout << S.substr(l1, r1 - l1) << endl;\n    cout << string(t, ' ') + S.substr(l2, r2 - l2) << endl;\n\n    cout << (lcp1+1+lcp2+1)-lcp2 << endl;\n*/\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct SuffixArray{\n  Int n,k;\n  string S;\n  vector<Int> sa,lcp,r2;\n  SuffixArray(){}\n  SuffixArray(string& S):S(S){init();}\n  void init(){\n    n=S.length();\n    S.push_back('$');\n    build_sa();\n    build_lcp();\n    build_rmq();\n    //for(Int i=0;i<=n;i++) cout<<i<<\":\"<<S.substr(sa[i])<<endl;\n  }\n  void build_sa(){\n    sa.clear();\n    sa.resize(n+1,0);\n    iota(sa.begin(),sa.end(),0);\n    sort(sa.begin(),sa.end(),\n\t [&](Int a,Int b){\n\t   if(S[a]==S[b]) return a>b;\n\t   return S[a]<S[b];\n\t });\n    vector<Int> c(n+1,0),r(n+1),cnt(n+1),s(n+1);\n    for(Int i=0;i<=n;i++) r[i]=S[i];\n    for(Int len=1;len<=n;len*=2){\n      for(Int i=0;i<=n;i++){\n\t c[sa[i]]=\n\t   i>0 &&\n\t   r[sa[i-1]]==r[sa[i]] &&\n\t   sa[i-1]+len<=n &&\n\t   r[sa[i-1]+len/2]==r[sa[i]+len/2] ?\n\t   c[sa[i-1]]:i;\n      }\n      iota(cnt.begin(),cnt.end(),0);\n      copy(sa.begin(),sa.end(),r.begin());\n      for(Int i=0;i<=n;i++){\n\tInt s1=r[i]-len;\n\tif(s1>=0) sa[cnt[c[s1]]++]=s1;\n      }\n      c.swap(r);\n    }\n  }\n  \n  bool lt_substr(string &T,Int si=0,Int ti=0){\n    Int sn=S.size(),tn=T.size();\n    while(si<sn&&ti<tn){\n      if(S[si]<T[ti]) return 1;\n      if(S[si]>T[ti]) return 0;\n      si++;ti++;\n    }\n    return si>=sn&&ti<tn;\n  }\n  \n  Int lower_bound(string& T){\n    Int low=0,high=n+1;\n    while(low+1<high){\n      Int mid=(low+high)/2;\n      if(lt_substr(T,sa[mid],0)) low=mid;\n      else high=mid;\n    }\n    return high;\n  }\n  \n  Int upper_bound(string& T){\n    T.back()++;\n    Int res=lower_bound(T);\n    T.back()--;\n    return res;\n  }\n  \n  // O(|T|*log|S|)\n  Int count(string& T){\n    return upper_bound(T)-lower_bound(T);\n  }\n  \n  void build_lcp(){\n    lcp.clear();\n    lcp.resize(n+1,0);\n    r2.resize(n+1);\n    for(Int i=0;i<=n;i++) r2[sa[i]]=i;\n    Int h=0;\n    lcp[0]=0;\n    for(Int i=0;i<n;i++){\n      Int j=sa[r2[i]-1];\n      if(h>0) h--;\n      for(;j+h<n&&i+h<n;h++){\n\tif(S[j+h]!=S[i+h]) break;\n      }\n      lcp[r2[i]-1]=h;\n    }\n  }\n  \n  Int getlcp(Int p,string &T,Int d){\n    Int i=0;\n    Int len=min((Int)T.length()-d,(Int)S.length()-p-d);\n    while(i<len&&S[p+d+i]==T[d+i]) i++;\n    return i;\n  }\n\n  struct RMQ{\n    Int n;\n    vector<Int> dat;\n    const Int def=INT_MAX;\n    RMQ(){}\n    void init(Int n_){\n      n=1;\n      while(n<n_) n*=2;\n      dat.clear();\n      dat.resize(2*n-1,def);\n    }\n    void build(Int n_, vector<Int>& a){\n      for(Int i=0;i<n_;i++) dat[i+n-1]=a[i];\n      for(Int i=n-2;i>=0;i--)\n\tdat[i]=min(dat[i*2+1],dat[i*2+2]);\n    }\n    Int query(Int a,Int b,Int k,Int l,Int r){\n      if(r<=a||b<=l) return def;\n      if(a<=l&&r<=b) return dat[k];\n      else{\n\tInt vl=query(a,b,k*2+1,l,(l+r)/2);\n\tInt vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(vl,vr);\n      }\n    }\n    Int query(Int a,Int b){\n      if(a>b) swap(a,b);\n      //cout<<n<<\":\"<<a<<\" \"<<b<<endl;\n      return query(max(a,Int(0)),b,0,0,n);\n    }\n  };\n  \n  RMQ rmq;\n  void build_rmq(){\n    rmq.init(n);\n    rmq.build(n,lcp);\n  }\n};\n\n\nsigned main(){\n  string s;\n  cin>>s;\n  string t=s;\n  reverse(t.begin(),t.end());\n  SuffixArray sa(s),ta(t);\n  auto &srmq=sa.rmq;\n  auto &trmq=ta.rmq;\n  Int q;\n  cin>>q;\n  Int n=s.size();\n  for(Int i=0;i<q;i++){\n    Int l,r,u;\n    cin>>l>>r>>u;\n    l--;\n    if(r-l==u){\n      cout<<\"Yes\"<<endl;\n      continue;\n    }\n    //cout<<s.substr(l,r-l)<<endl;\n    //cout<<string(u,' ')+s.substr(l,r-l)<<endl;\n    Int x=srmq.query(sa.r2[l],sa.r2[l+u]);\n    Int y=trmq.query(ta.r2[n-r],ta.r2[n-r+u]);\n    if((x+1+y)>=((r-l)-u)){\n      cout<<\"Yes\"<<endl;\n      continue;\n    }\n    if((l+x+u)!=(r-(u+y+1))||s[l+x]!=s[r-(y+1)]){\n      cout<<\"No\"<<endl;\n      continue;\n    }\n    Int z=srmq.query(sa.r2[l+x+u+1],sa.r2[l+x+1]);\n    if(0){\n      cout<<x<<\" \"<<y<<endl;\n      cout<<s[l+x+u]<<\" \"<<s[r-(y+1)]<<endl;\n      cout<<s[l+x]<<\" \"<<s[r-(u+y+1)]<<endl;\n      cout<<s.substr(l+x+u+1,((r-(y+1))-(l+x+u+1)))<<endl;\n      cout<<s.substr(l+x+1,((r-(u+y+1))-(l+x+1)))<<endl;\n      cout<<z<<endl;\n      cout<<(x+1+z+1+y)<<\" \"<<((r-l)-u)<<endl;\n    }\n    cout<<((x+1+z+1+y>=(r-l)-u)?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Long __int128_t\n#define int long long\n#define REP(i, n) for (int i = 0; i < (n); i++)\n\nLong modpow(Long a, Long n, Long mod) {\n    if (n == 0) return 1;\n    if (n % 2 == 0) {\n        Long t = modpow(a, n / 2, mod);\n        return t * t % mod;\n    }\n    return a * modpow(a, n - 1, mod) % mod;\n}\n\nLong modinv(Long a, Long mod) { return modpow(a, mod - 2, mod); }\n\nmap<Long, Long> memo[101010];\n\n// a^0 + a^1 + ... + a^{n-1}\nLong powsum(Long a, Long n, Long mod) {\n    if (memo[n].count(a)) return memo[n][a];\n    if (n == 0) return 0;\n    if (n % 2 == 0) {\n        Long t = powsum(a, n / 2, mod);\n        return memo[n][a] = (1 + modpow(a, n / 2, mod)) * t % mod;\n    }\n    return memo[n][a] = (modpow(a, n - 1, mod) + powsum(a, n - 1, mod)) % mod;\n}\n\ntemplate <Long mod, Long p = 257>\nstruct RollingHash {\n    int n;\n    vector<Long> table;\n    vector<Long> pows;\n    RollingHash(const string &s) : n(s.size()), table(n + 1), pows(n + 1) {\n        table[0] = 1;\n        pows[0] = 1;\n        for (int i = 0; i < n; i++) {\n            table[i + 1] = (table[i] * p + s[i]) % mod;\n            pows[i + 1] = pows[i] * p % mod;\n        }\n    }\n\n    // [l, r)\n    Long hash_substr(int l, int r) {\n        Long ret = (table[r] - table[l] * pows[r - l]) % mod;\n        if (ret < 0) ret += mod;\n        return ret;\n    }\n\n    // [sl, sr)が[tl, tr) + [tl2, tr2)を繰り返したものになっているか\n    bool is_periodic(int sl, int sr, int tl, int tr, int tl2 = 0, int tr2 = 0) {\n        int slen = sr - sl, tlen = tr - tl, tlen2 = tr2 - tl2;\n        int k = slen / (tlen + tlen2);\n        Long target = (hash_substr(tl, tr) * pows[tlen2] % mod + hash_substr(tl2, tr2)) *\n                      powsum(pows[tlen + tlen2], k, mod) % mod;\n        int need = slen % (tlen + tlen2);\n        target = target * pows[need] % mod;\n        if (need <= tlen) {\n            target += hash_substr(tl, tl + need);\n        } else {\n            need -= tlen;\n            Long add = hash_substr(tl, tr);\n            add = add * pows[need] % mod;\n            add += hash_substr(tl2, tl2 + need);\n            target += add;\n        }\n        target %= mod;\n        return target == hash_substr(sl, sr);\n    }\n};\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    string s;\n    cin >> s;\n\n    RollingHash<4611686018427387903> rh(s);\n\n    auto hoge = [&](int l, int r, int t) {\n        int len = r - l;\n        int L = 0, R = len;\n        while (L < R - 1) {\n            int M = (L + R) / 2;\n            if (rh.is_periodic(l, l + M, l, l + t)) {\n                L = M;\n            } else {\n                R = M;\n            }\n        }\n        int amari = (L + 1) % t;\n        return rh.is_periodic(l + L + 1, r, l + amari, l + t, l, l + amari);\n    };\n\n    int q;\n    cin >> q;\n    while (q--) {\n        int l, r, t;\n        cin >> l >> r >> t;\n        l--;\n        if (rh.is_periodic(l, r, l, l + t)) {\n            cout << \"Yes\" << '\\n';\n            continue;\n        }\n\n        if (hoge(l, r, t)) {\n            cout << \"Yes\" << '\\n';\n            continue;\n        }\n\n        if (r - l < t * 2) {\n            cout << \"No\" << '\\n';\n            continue;\n        }\n\n        if (!rh.is_periodic(l + t, r, l + t, l + t + t)) {\n            cout << \"No\" << '\\n';\n            continue;\n        }\n\n        if (hoge(l, l + 2 * t, t)) {\n            cout << \"Yes\" << '\\n';\n            continue;\n        }\n\n        cout << \"No\" << '\\n';\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t//\tassert(rsame);\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n\null B=5575777;\null mem[MAX_N];\n\null pow(int x){\n  assert(0<=x && x<MAX_N);\n\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n\nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n\null get(int l,int r){\n  if(l==r)return 0;\n\n  return p[r]-p[l]*pow(r-l);\n}\n\null get(int l,int r,int x,char ch){\n  if(l==r)return 0;\n\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n\nbool eq(int a,int b,int l,int r){\n  return ( get(a,b) == get(l,r) );\n}\n\nbool eq(int a,int b,int l,int r, int x,char ch){\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n\nbool calc(int a,int b,int l,int r){\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n\nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  if(len%t==0){\n    return calc(l,r-t,l+t,r);\n  }\n  int as=len%t;\n\n  //  calc(l+as,r-t,l+as+t,r);\n\n  if ( calc(l+as,r-t ,l+as+t,r) && (eq(l,l+as,r-as,r) ||eq(l,l+as,r-as-t,r-t) ) )return true;\n  if ( eq(l+as,r-t ,l+as+t,r) && ( calc(l,l+as,r-as,r) || calc(l,l+as,r-as-t,r-t) ) )return true;\n\n  if ( calc(l,r-as-t ,l+t,r-as) && (eq(l,l+as,r-as,r) ||eq(l+t,l+t+as,r-as,r) ) )return true;\n  if ( eq(l,r-as-t ,l+t,r-as) && ( calc(l,l+as,r-as,r) || calc(l+t,l+t+as,r-as,r) ) )return true;\n  return false;\n}\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n  for(int i=0;i<n;i++){\n    s[i]+=(i%1999);\n  }\n\n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n    l--;\n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e9\n#define MAX_V 505\nusing namespace std;\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{\n  int to;\n  vector<int> cap;\n  int rev;\n};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,vector<int> &cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,vector<int>((int)cap.size(),0),(int)G[from].size()-1});  \n}\n\nbool check(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]!=0) return A[i]>0;\n  return false;\n}\n\nbool check2(vector<int> &A){\n  for(int i=0;i<A.size();i++)\n    if(A[i]==INF) return false;\n  return true;\n}\n\nvoid Minus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]-=v[i];\n}\n\nvoid Plus(vector<int> &res, vector<int> &v){\n  for(int i=0;i<res.size();i++) res[i]+=v[i];\n}\n\nvector<int> Min(vector<int> &A, vector<int> &B){\n  for(int i=0;i<A.size();i++){\n    if(A[i]<B[i]) return A;\n    if(A[i]>B[i]) return B;\n  }\n  return A;\n}\n\n//?¢?????????????DFS??§??¢???\nvector<int> dfs(int v,int t,vector<int> f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && check(e.cap) ){\n      vector<int> d = dfs(e.to ,t , Min(f,e.cap));\n      if(check(d)&&check2(d)){\n\tMinus(e.cap, d);\n\tPlus(G[e.to][e.rev].cap, d);\n\treturn d;\n      }\n    }\n  }\n  return vector<int>((int)f.size(),0);\n}\n\nbool isall0(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]!=0) return false;\n  return true;\n}\n\nbool isallnotINF(vector<int> &v){\n  for(int i=0;i<v.size();i++)\n    if(v[i]>=INF) return false;\n  return true;\n}\n\nint V=55;\n\n//s??????t???????????§???????±???????\nvector<int> max_flow(int s,int t){\n  vector<int> flow = vector<int>(V,0);\n  for(;;){\n    memset(used,0,sizeof(used));\n    vector<int> f = dfs(s, t, vector<int>(V,INF));\n    if(isall0(f)) return flow;\n    if(isallnotINF(f)) Plus(flow, f);\n  }\n}\n\nvector<int> tov(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  \n  int num1, num2, p=0;\n  \n  if('0'<=s[p]&&s[p]<='9'){\n    num1=0;\n    while('0'<=s[p]&&s[p]<='9') num1=num1*10+s[p++]-'0';\n  }else num1=1;\n  \n  if(p==s.size()){\n    num2=0;\n  }else{\n    if(p+1==s.size()) num2=1;\n    else{\n      p+=2;\n      num2=0;\n      while('0'<=s[p]&&s[p]<='9') num2=num2*10+s[p++]-'0';\n    }\n  }\n  \n  res[num2]=num1;\n  \n  return res;\n}\n\nvector<int> tocap(string s){\n  \n  vector<int> res = vector<int>(V,0);\n  s+='+';\n  \n  string t;\n  \n  for(int i=0;i<s.size();i++){\n    if(s[i]=='+'){\n      vector<int> r=tov(t);\n      Plus(res,r);\n      t=\"\";\n    }else t+=s[i];\n  }\n  \n  reverse(res.begin(), res.end());\n  \n  return res;\n}\n\nstring itos(int num){\n\n  string res;\n  \n  while(num){\n    res=(char)(num%10+'0')+res;\n    num/=10;\n  }\n  \n  return res;\n}\n\nvoid output(vector<int> ans){\n  \n  reverse(ans.begin(), ans.end());\n  \n  for(int i=0;i<ans.size();i++)\n    if(ans[i]<0) ans[i]=0;\n  \n  string s;\n  int flag=0;\n  \n  for(int i=ans.size()-1;i>=0;i--){\n    if(ans[i]==0) continue;\n    if(flag) s+=\"+\";\n    flag=1;\n    if(i==0||(i!=0&&ans[i]!=1)) s+=itos(ans[i]);\n    if(i==1) s+=\"x\";\n    else if(i) s+=\"x^\", s+=itos(i);\n  }\n  if(s==\"\") s=\"0\";\n  cout<<s<<endl;\n}\n\nsigned main(){\n    \n  int n, m;\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    int a, b;\n    string s;\n    \n    for(int i=0;i<m;i++){\n      cin>>a>>b>>s;\n      vector<int> cap=tocap(s);\n      add_edge(a-1,b-1,cap);\n      add_edge(b-1,a-1,cap);\n    }\n\n    output(max_flow(0,n-1));\n    \n    for(int i=0;i<MAX_V;i++) G[i].clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(rsame){\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint unsigned long long \n#define B 1000000007\n\nusing namespace std;\n\nint Q;\nstring s;\nllint beki[100005];\nllint hash[100005];\n\nllint getsub(llint l, llint r)\n{\n\treturn hash[r] - hash[l-1] * beki[r-(l-1)];\n}\n\nint main(void)\n{\n\tcin >> s;\n\tint n = s.size();\n\ts = \"#\" + s;\n\t\n\tbeki[0] = 1;\n\tfor(int i = 1; i <= n; i++) beki[i] = beki[i-1] * B;\n\tfor(int i = 1; i <= n; i++) hash[i] = hash[i-1] * B + s[i];\n\t\n\tcin >> Q;\n\tfor(int q = 0; q < Q; q++){\n\t\tint l, r, t;\n\t\tcin >> l >> r >> t;\n\t\t\n\t\tint L = r - l + 1;\n\t\tif(t == L){\n\t\t\tcout << \"Yes\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint ub = L-t+1, lb = 0, mid;\n\t\twhile(ub - lb > 1){\n\t\t\tmid = (ub + lb) / 2;\n\t\t\tif(getsub(l, l+mid-1) == getsub(l+t, l+t+mid-1)) lb = mid;\n\t\t\telse ub = mid;\n\t\t}\n\t\tif(lb == L-t){\n\t\t\tcout << \"Yes\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint x = l+lb, y = l+lb+t;\n\t\tllint h = (getsub(l, x-1) * B + s[y]) * beki[(r-t)-x] + getsub(x+1, r-t);\n\t\tif(h == getsub(l+t, r)){\n\t\t\tcout << \"Yes\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\th = (getsub(l, y-1) * B + s[x]) * beki[(r-t)-y] + getsub(y+1, r-t);\n\t\tllint h2 = (getsub(l+t, y-1) * B + s[x]) * beki[r-y] + getsub(y+1, r);\n\t\tif(h == h2){\n\t\t\tcout << \"Yes\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << \"No\" << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP, rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size());\n    LCP[0] = 0;\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i] + 1] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (LCP[k]);\n  }\n\n  size_t size() const\n  {\n    return (LCP.size());\n  }\n};\n\n\nconst int INF = 1 << 30;\n\nstruct SegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n\n\nint main()\n{\n  string S;\n  int Q;\n\n  cin >> S;\n  cin >> Q;\n\n  SuffixArray sa;\n  LongestCommonPrefixArray lcp;\n  SegmentTree tree(S.size());\n\n  sa.Build_SA(S);\n  lcp.Build_LCP(sa);\n  for(int i = 0; i < S.size(); i++) tree.set(i, lcp[i]);\n  tree.build();\n\n  auto getLCP = [&](int a, int b)\n  {\n    if(a > S.size() || b > S.size()) return (INF);\n    a = lcp.rank[a], b = lcp.rank[b];\n    if(a > b) swap(a, b);\n    return (tree.rmq(a + 1, b + 1));\n  };\n\n  while(Q--) {\n    int l, r, t;\n    cin >> l >> r >> t;\n\n    int l1 = --l, r1 = r - t;\n    int l2 = l1 + t, r2 = r;\n    int length = r1 - l1;\n\n    int lcp1 = getLCP(l1, l2);\n\n    // (>_<)\n    if(lcp1 >= length || r - l == t) {\n      cout << \"Yes\" << endl;\n      continue;\n    }\n\n    int lcp2 = getLCP(l1 + lcp1 + 1, l2 + lcp1 + 1);\n\n    if(lcp1 + 1 + lcp2 >= length) {\n      if(l1 + lcp1 < l2 || l2 + lcp1 >= r1) {\n        cout << \"Yes\" << endl;\n      } else {\n        cout << \"No\" << endl;\n      }\n      continue;\n    }\n\n    if(l1 + lcp1 + 1 + lcp2 < l2) {\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    if(lcp2 + 1 == t && S[l1 + lcp1 + lcp2 + 1 - lcp2 - 1] == S[l1 + lcp1 + lcp2 + 1 + 1 + lcp2]) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10005349, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l,r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r+1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r+1 - index - 1].second);\n\t}\n\tvoid change_st(const int index, const ll from, const ll to)const {\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const pair<int, int>a, const pair<int, int>b) {\n\tint al = a.first, ar = a.second;\n\tint bl = b.first, br = b.second;\n\tint lans = -1;\n\tint rans = ar-al;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans+1, ar) == rh.hash(bl + rans+1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind,st[changeind],changeto,l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool,int> issame(int al, int bl,int len) {\n\tif (bl > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(bl <= R);\n\t\tint checklen = min(len, R - bl);\n\t\tbool same=  getha(al,al+checklen) == getha(bl,bl+ checklen);\n\t\tif (same)return make_pair(1, -1);\n\t\telse {\n\n\t\t\tint acheck = check(make_pair(al,al+checklen), (make_pair(bl,bl+checklen)));\n\t\t\treturn make_pair(false,acheck);\n\t\t}\n\t}\n}\nint main() { \n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize*2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L, L + nt / 2,nt/2).first;\n\t\t\t\t\t\tbool rsame;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > R) {\n\t\t\t\t\t\t\t\trsame = true;\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trsame = getha(l3, r3) == getha(l4, r4);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nconst int MAX = 500000, MS = 2;\nconst long long mod[] = {999999937LL, 1000000007LL}, base = 9973;\nstruct rolling_hash {\n    int n;\n    vector<long long> hs[MS], pw[MS];\n    rolling_hash(){}\n    rolling_hash(const string &s) {\n        n = s.size();\n        for (int i = 0; i < MS; i++) {\n            hs[i].assign(n+1,0);\n            pw[i].assign(n+1,0);\n            hs[i][0] = 0;\n            pw[i][0] = 1;\n            for (int j = 0; j < n; j++) {\n                pw[i][j+1] = pw[i][j]*base%mod[i];\n                hs[i][j+1] = (hs[i][j]*base+s[j])%mod[i];\n            }\n        }\n    }\n\n    long long hash(int l, int r, int i) { return ((hs[i][r]-hs[i][l]*pw[i][r-l])%mod[i]+mod[i])%mod[i]; }\n\n    bool match(int l1, int r1, int l2, int r2) {\n        bool ret = 1;\n        for (int i = 0; i < MS; i++) ret &= hash(l1,r1,i)==hash(l2,r2,i);\n        return ret;\n    }\n\n    bool match(int l, int r, long long h[]) {\n        bool ret = 1;\n        for (int i = 0; i < MS; i++) ret &= hash(l,r,i)==h[i];\n        return ret;\n    }\n};\n\n\nint main(){\n    string s;\n    cin >> s;\n    int q;\n    cin >> q;\n    int cnt =0;\n    rolling_hash rh(s);\n    for(int i=0;i<q;i++){\n        int l,r,t;\n        cin >> l >> r >> t;\n        l--;r--;\n        int l1,r1,l2,r2;\n        l1 = l;\n        l2 = l+t;\n        r1 = r-t;\n        r2 = r;\n        cnt++;\n        if(rh.match(l1,r1,l2,r2)||(l+t==r+1)){\n            cout << \"Yes\" << endl;\n        }else{\n            int ok = -1;\n            int ng = r1-l1;\n            while(ng-ok!=1){\n                int mid = (ng+ok)/2;\n                if(rh.match(l1,l1+mid,l2,l2+mid)){\n                    ok = mid;\n                }else{\n                    ng = mid;\n                }\n            }\n            bool flag = 0;\n            if(l2>=l1+ng){\n                bool fflag = 1;\n                for(int i=0;i<2;i++){\n                    ll x = rh.hash(l1,r1+1,i);\n                    ll y = rh.hash(l2,r2+1,i);\n                    x = (x+(rh.pw[i][r1-l1-ng+1]*(mod[i]+s[l2+ng-1]-s[l1+ng-1])%mod[i]))%mod[i];\n                    \n                    if(x!=y)fflag = 0;\n                }\n                if(fflag)flag = 1;\n            }else{\n                bool fflag = 1;\n                for(int i=0;i<2;i++){\n                    ll x = rh.hash(l1,r1+1,i);\n                    ll y = rh.hash(l2,r2+1,i);\n                    \n                    x = (x+(rh.pw[i][r1-l1-ng+1]*(mod[i]+s[l2+ng-1]-s[l1+ng-1])%mod[i]))%mod[i];\n                    y = (y+(rh.pw[i][r2-l1-ng+1]*(mod[i]+s[l2+ng-1]-s[l1+ng-1])%mod[i]))%mod[i];\n                    \n                    if(x!=y)fflag = 0;\n                }\n\n                if(fflag)flag = 1;\n            }   \n            if(l2+ng<=r1){\n                bool fflag = 1;\n                for(int i=0;i<2;i++){\n                    ll x = rh.hash(l1,r1+1,i);\n                    ll y = rh.hash(l2,r2+1,i);\n                    x = (x+(rh.pw[i][r1-l2-ng+1]*(mod[i]+s[l1+ng-1]-s[l2+ng-1])%mod[i]))%mod[i];\n                    y = (y+(rh.pw[i][r2-l2-ng+1]*(mod[i]+s[l1+ng-1]-s[l2+ng-1])%mod[i]))%mod[i];\n                    if(x!=y)fflag = 0;\n                }\n\n                if(fflag)flag = 1;\n            }else{\n                bool fflag = 1;\n                for(int i=0;i<2;i++){\n                    ll x = rh.hash(l1,r1+1,i);\n                    ll y = rh.hash(l2,r2+1,i);\n                    y = (y+(rh.pw[i][r2-l2-ng+1]*(mod[i]+s[l1+ng-1]-s[l2+ng-1])%mod[i]))%mod[i];\n                    if(x!=y)fflag = 0;    \n                }\n\n                if(fflag)flag = 1;\n            } \n            if(flag){\n                cout << \"Yes\" << endl;\n            }else{\n                cout << \"No\" << endl;\n            }  \n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll po(const ll p, const ll n, const ll mod)\n{\n    if (n == 0) { return 1; }\n    if (n % 2 == 1) {\n        return po(p, n - 1, mod) * p % mod;\n    } else {\n        const ll pp = po(p, n / 2, mod);\n        return pp * pp % mod;\n    }\n}\nconstexpr ll inv(const ll p, const ll mod) { return po(p, mod - 2, mod); }\nconstexpr ll BASE1 = 186398169LL;\nconstexpr ll MOD1 = 1000000007LL;\nconstexpr ll INV1 = inv(BASE1, MOD1);\nconstexpr ll BASE2 = 238173201LL;\nconstexpr ll MOD2 = 1000000009LL;\nconstexpr ll INV2 = inv(BASE2, MOD2);\nconstexpr int MAX = 100000;\nP power[MAX], inverse[MAX], h[MAX];\nmap<P, int> phash;\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string S;\n    cin >> S;\n    for (ll i = 0, p1 = 1, p2 = 1, i1 = 1, i2 = 1, h1 = 0, h2 = 0; i < S.size(); i++, (p1 *= BASE1) %= MOD1, (i1 *= INV1) %= MOD1, (p2 *= BASE2) %= MOD2, (i2 *= INV2) %= MOD2) {\n        (h1 += (S[i] - 'a') * p1 % MOD1) %= MOD1, (h2 += (S[i] - 'a') * p2 % MOD2) %= MOD2;\n        power[i] = {p1, p2}, inverse[i] = {i1, i2}, h[i] = {h1, h2};\n        for (int j = 1; j < 26; j++) { phash[{p1 * j % MOD1, p2 * j % MOD2}] = i; }\n    };\n    auto add = [](const P& p1, const P& p2) -> P { return {(p1.first + p2.first) % MOD1, (p1.second + p2.second) % MOD2}; };\n    auto sub = [](const P& p1, const P& p2) -> P { return {(p1.first + MOD1 - p2.first) % MOD1, (p1.second + MOD2 - p2.second) % MOD2}; };\n    auto mul = [](const P& p1, const P& p2) -> P { return {(p1.first * p2.first) % MOD1, (p1.second * p2.second) % MOD2}; };\n    auto getHash = [&](const int s, const int l) -> P { return l == 0 ? P{0, 0} : s == 0 ? h[s + l - 1] : mul(sub(h[s + l - 1], h[s - 1]), inverse[s]); };\n    auto getPoly = [&](const int t, const int rep) -> P { return {(po(power[t].first, rep, MOD1) + MOD1 - 1) * inv(power[t].first + MOD1 - 1, MOD1) % MOD1, (po(power[t].second, rep, MOD2) + MOD2 - 1) * inv(power[t].second + MOD2 - 1, MOD2) % MOD2}; };\n    auto judge = [&](const P& diff, const int L) -> bool { return diff == P{0, 0} or (phash.find(diff) != phash.end() and phash[diff] < L) or (phash.find({(MOD1 - diff.first) % MOD1, (MOD2 - diff.second) % MOD2}) != phash.end() and phash[{-diff.first, -diff.second}] < L); };\n    assert(phash.size() == 25 * S.size());\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; q++) {\n        int l, r, t;\n        (cin >> l >> r >> t), l--;\n        const int L = r - l, rep = L / t, rest = L % t;\n        const P Hash = getHash(l, L);\n        if (rep == 1) {\n            const P mask1 = add(getHash(l, t), mul(power[t * rep], getHash(l + t * rep, rest)));\n            const P diff = sub(mask1, Hash);\n            cout << (judge(diff, L) ? \"Yes\" : \"No\") << endl;\n        } else {\n            const P poly = getPoly(t, rep);\n            const P m1 = getHash(l, t);\n            const P mask1 = add(mul(poly, m1), mul(power[t * rep], getHash(l + t * rep, rest)));\n            const P diff1 = sub(mask1, Hash);\n            const P m2 = getHash(l + t, t);\n            const P mask2 = add(mul(poly, m2), mul(power[t * rep], getHash(l + t * rep, rest)));\n            const P diff2 = sub(mask2, Hash);\n            cout << (judge(diff1, L) or judge(diff2, L) ? \"Yes\" : \"No\") << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define SIZE 100005\n#define NUM1 1000000007\n#define NUM2 99999883\n\nstruct Info{\n\tull hash_1,hash_2;\n};\n\nint T_length;\nchar T[SIZE];\null HASH[SIZE][2],POW[SIZE][2];\n\nbool IS_SAME(Info left,Info right){\n\tif(left.hash_1 == right.hash_1 && left.hash_2 == right.hash_2)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nInfo calcHash(int left,int right){\n\n\tInfo ret;\n\n\tint length = right-left+1;\n\n\t//indexのずれに注意:T[right]までのハッシュ値はHASH[right+1]に記録されている\n\tret.hash_1 = HASH[right+1][0]-HASH[left][0]*POW[length][0];\n\tret.hash_2 = HASH[right+1][1]-HASH[left][1]*POW[length][1];\n\n\treturn ret;\n}\n\n//AとBの一致長さを返す\nint calc_match_len(int start_A,int start_B,int length){\n\n\tint left = 0,right = length-1,mid = (left+right)/2;\n\tint match_len = 0;\n\tInfo tmp_A,tmp_B;\n\n\twhile(left <= right){\n\n\t\ttmp_A = calcHash(start_A,start_A+mid);\n\t\ttmp_B = calcHash(start_B,start_B+mid);\n\n\t\tif(IS_SAME(tmp_A,tmp_B)){\n\t\t\tmatch_len = mid+1;\n\t\t\tleft = mid+1;\n\t\t}else{\n\t\t\tright = mid-1;\n\t\t}\n\t\tmid = (left+right)/2;\n\t}\n\n\treturn match_len;\n}\n\nInfo replace(Info X,int length,int loc,char pre,char next){\n\n\tX.hash_1 -= pre*POW[length-(loc+1)][0];\n\tX.hash_1 += next*POW[length-(loc+1)][0];\n\n\tX.hash_2 -= pre*POW[length-(loc+1)][1];\n\tX.hash_2 += next*POW[length-(loc+1)][1];\n\n\treturn X;\n}\n\n\nint main(){\n\n\tscanf(\"%s\",T);\n\tfor(T_length = 0; T[T_length] != '\\0'; T_length++);\n\n\t//2通りのハッシュ値を計算する\n\tHASH[0][0] = 0;\n\tHASH[0][1] = 0;\n\tPOW[0][0] = 1;\n\tPOW[0][1] = 1;\n\n\t//Tのハッシュ値を求める\n\tfor(int i = 1; i <= T_length; i++){\n\t\tHASH[i][0] = T[i-1] + HASH[i-1][0]*NUM1;\n\t\tHASH[i][1] = T[i-1] + HASH[i-1][1]*NUM2;\n\n\t\tPOW[i][0] = POW[i-1][0]*NUM1;\n\t\tPOW[i][1] = POW[i-1][1]*NUM2;\n\t}\n\n\tint num_query;\n\tscanf(\"%d\",&num_query);\n\n\tint left,right,cycle,length,match_len;\n\tInfo A,B,replace_A,replace_B;\n\n\tInfo debug;\n\n\tfor(int loop = 0; loop < num_query; loop++){\n\n\t\tscanf(\"%d %d %d\",&left,&right,&cycle);\n\t\tleft--;\n\t\tright--;\n\n\t\tlength = right-left+1;\n\n\t\tif(cycle == length){\n\t\t\tprintf(\"Yes\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tA = calcHash(left,(left+length-1)-cycle);\n\t\tB = calcHash(left+cycle,right);\n\n\t\tif(IS_SAME(A,B)){\n\t\t\tprintf(\"Yes\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tlength = right-(left+cycle)+1; //★★長さを比較長に変更する★★\n\n\t\tmatch_len = calc_match_len(left,left+cycle,length);\n\n\t\tdebug = calcHash(left,left+match_len-1);\n\n\t\tif(left+cycle+match_len <= left+length-1){ //★★不一致文字が、共通文字の場合\n\n\t\t\t//共通不一致文字をAの方に変える\n\t\t\treplace_A = replace(A,length,cycle+match_len,T[left+cycle+match_len],T[left+match_len]);\n\t\t\treplace_B = replace(B,length,match_len,T[left+cycle+match_len],T[left+match_len]);\n\n\t\t\tif(IS_SAME(replace_A,replace_B)){\n\t\t\t\tprintf(\"Yes\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treplace_A = replace(A,length,match_len,T[left+match_len],T[left+cycle+match_len]);\n\n\t\t\tif(IS_SAME(replace_A,B)){\n\t\t\t\tprintf(\"Yes\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"No\\n\");\n\t\t\t}\n\n\t\t}else{\n\n\t\t\t//不一致だった箇所を変更\n\t\t\treplace_A = replace(A,length,match_len,T[left+match_len],T[left+cycle+match_len]);\n\t\t\treplace_B = replace(B,length,match_len,T[left+cycle+match_len],T[left+match_len]);\n\n\t\t\tif(IS_SAME(replace_A,B) == true || IS_SAME(A,replace_B) == true){\n\t\t\t\tprintf(\"Yes\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"No\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tassert(!lsame||rsame);\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n#define MAX_N 100005\n  \null B=5575777;\null mem[MAX_N];\n  \null pow(int x){\n  if(x==0)return 1;\n  if(mem[x]>0)return mem[x];\n  if(x&1)return mem[x]=pow(x-1)*B;\n  mem[x]=pow(x/2);\n  mem[x]*=mem[x];\n  return mem[x];\n}\n  \nint n,q,l,r,t;\nchar s[MAX_N];\null p[MAX_N];\n  \null get(int l,int r){\n  return p[r]-p[l]*pow(r-l);\n}\n  \null get(int l,int r,int x,char ch){\n  ull res=p[r]-p[l]*pow(r-l);\n  if(l<=x&&x<r){\n    int dist=r-x-1;\n    res-=pow(dist)*s[x];\n    res+=pow(dist)*ch;\n  }\n  return res;\n}\n  \nbool eq(int a,int b,int l,int r){\n  return ( get(a,b) == get(l,r) );\n}\n  \nbool eq(int a,int b,int l,int r, int x,char ch){\n  return ( get(a,b,x,ch) == get(l,r,x,ch) );\n}\n  \nbool calc(int a,int b,int l,int r){\n  if(b-a!=r-l)return false;\n  int L=0,R=b-a+1,M;\n  while(R-L>1){\n    M=(L+R)/2;\n    if( eq(a,a+M,l,l+M) ){\n      L=M;\n    }else{\n      R=M;\n    }\n  }\n  if(L==b-a)return true;\n  return ( eq(a,b,l,r, l+L, s[a+L]) || eq(a,b,l,r, a+L, s[l+L] )  );\n}\n  \n  \nbool solve(){\n  int len=r-l;\n  if(t==len)return true;\n  if(t*2>=len){\n    return calc(l,l+(len-t),r-(len-t),r);\n  }\n  int as=len%t;\n  if( calc(l,r-as-t,l+t,r) )return true;  \n  return false;\n}\n  \nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n  \n  p[0]=0;\n  for(int i=1;i<=n;i++){\n    p[i]=p[i-1]*B+s[i-1];\n  }\n  \n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d %d\",&l,&r,&t);\n  \n    l--;\n  \n    if(solve())printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(rsame){\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll po(const ll p, const ll n, const ll mod)\n{\n    if (n == 0) { return 1; }\n    if (n % 2 == 1) {\n        return po(p, n - 1, mod) * p % mod;\n    } else {\n        const ll pp = po(p, n / 2, mod);\n        return pp * pp % mod;\n    }\n}\nconstexpr ll inv(const ll p, const ll mod) { return po(p, mod - 2, mod); }\nconstexpr ll BASE1 = 186398169LL;\nconstexpr ll MOD1 = 1000000007LL;\nconstexpr ll INV1 = inv(BASE1, MOD1);\nconstexpr ll BASE2 = 238173201LL;\nconstexpr ll MOD2 = 1000000009LL;\nconstexpr ll INV2 = inv(BASE2, MOD2);\nconstexpr int MAX = 100000;\nP power[2 * MAX], inverse[MAX], h[MAX], inverse2[MAX];\nmap<P, int> phash;\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string S;\n    cin >> S;\n    for (ll i = 0, p1 = 1, p2 = 1; i < 2 * MAX; i++, (p1 *= BASE1) %= MOD1, (p2 *= BASE2) %= MOD2) { power[i] = {p1, p2}; }\n    for (ll i = 0, i1 = 1, i2 = 1, h1 = 0, h2 = 0; i < S.size(); i++, (i1 *= INV1) %= MOD1, (i2 *= INV2) %= MOD2) {\n        (h1 += (S[i] - 'a') * power[i].first % MOD1) %= MOD1, (h2 += (S[i] - 'a') * power[i].second % MOD2) %= MOD2, h[i] = {h1, h2};\n        for (int j = 1; j < 26; j++) { phash[{power[i].first * j % MOD1, power[i].second * j % MOD2}] = i; }\n        inverse[i] = {i1, i2}, inverse2[i] = {inv((power[i].first + MOD1 - 1) % MOD1, MOD1), inv((power[i].second + MOD2 - 1) % MOD2, MOD2)};\n    };\n    auto add = [](const P& p1, const P& p2) -> P { return {(p1.first + p2.first) % MOD1, (p1.second + p2.second) % MOD2}; };\n    auto sub = [](const P& p1, const P& p2) -> P { return {(p1.first + MOD1 - p2.first) % MOD1, (p1.second + MOD2 - p2.second) % MOD2}; };\n    auto mul = [](const P& p1, const P& p2) -> P { return {(p1.first * p2.first) % MOD1, (p1.second * p2.second) % MOD2}; };\n    auto getHash = [&](const int s, const int l) -> P { return l == 0 ? P{0, 0} : s == 0 ? h[s + l - 1] : mul(sub(h[s + l - 1], h[s - 1]), inverse[s]); };\n    auto getPoly = [&](const int t, const int rep) -> P { return mul(sub(power[t * rep], {1, 1}), inverse2[t]); };\n    auto judge = [&](const P& diff, const int L) -> bool { return diff == P{0, 0} or (phash.find(diff) != phash.end() and phash[diff] < L) or (phash.find(sub({0, 0}, diff)) != phash.end() and phash[sub({0, 0}, diff)] < L); };\n    assert(phash.size() == 25 * S.size());\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; q++) {\n        int l, r, t;\n        (cin >> l >> r >> t), l--;\n        const int L = r - l, rep = L / t, rest = L % t;\n        const P Hash = getHash(l, L);\n        const P Tail = getHash(l + t * rep, rest);\n        if (rep == 1) {\n            const P mask1 = add(getHash(l, t), mul(power[t * rep], Tail));\n            const P diff = sub(mask1, Hash);\n            cout << (judge(diff, L) ? \"Yes\\n\" : \"No\\n\");\n        } else {\n            const P poly = getPoly(t, rep);\n            const P mask1 = add(mul(poly, getHash(l, t)), mul(power[t * rep], Tail));\n            const P diff1 = sub(mask1, Hash);\n            const P mask2 = add(mul(poly, getHash(l + t, t)), mul(power[t * rep], Tail));\n            const P diff2 = sub(mask2, Hash);\n            cout << (judge(diff1, L) or judge(diff2, L) ? \"Yes\\n\" : \"No\\n\");\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(rsame){\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tassert(false);\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\ntemplate<class type>\nclass string_hash {\nprotected:\n\tstd::vector<type> pw;\n\tstd::vector<type> prefix;\n\tstd::string s;\npublic:\n\tstatic const type base = type(311);\n\tstring_hash() : s(), pw(type(1)), prefix(type(0)) {};\n\tstring_hash(std::string s_) : s(s_) {\n\t\tpw.resize(s.length() + 1);\n\t\tprefix.resize(s.length() + 1);\n\t\tpw[0] = type(1);\n\t\tprefix[0] = type(0);\n\t\tfor (size_t i = 0; i < s.length(); ++i) {\n\t\t\tpw[i + 1] = pw[i] * base;\n\t\t\tprefix[i + 1] = prefix[i] * base + type(s[i]);\n\t\t}\n\t};\n\ttype get() { return s; }\n\ttype get_hash(size_t l, size_t r) {\n\t\treturn prefix[r] - pw[r - l] * prefix[l];\n\t}\n};\ntemplate<class hash_type>\nclass string_diff01 : public string_hash<hash_type> {\npublic:\n\tstring_diff01() : string_hash<hash_type>() {};\n\tstring_diff01(std::string s_) : string_hash<hash_type>(s_) {};\n\tbool diff0(size_t la, size_t lb, size_t d) {\n\t\t// Judges that s[la, la + d) and s[lb, lb + d) are the same\n\t\treturn string_hash<hash_type>::get_hash(la, la + d) == string_hash<hash_type>::get_hash(lb, lb + d);\n\t}\n\tbool diff1(size_t la, size_t lb, size_t d) {\n\t\t// Judges that s[la, la + d) and s[lb, lb + d) differs at most single character\n\t\tsize_t pl = 0, pr = d + 1;\n\t\twhile (pr - pl > 1) {\n\t\t\tsize_t pm = (pl + pr) >> 1;\n\t\t\tif (string_hash<hash_type>::get_hash(la, la + pm) == string_hash<hash_type>::get_hash(lb, lb + pm)) {\n\t\t\t\tpl = pm;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpr = pm;\n\t\t\t}\n\t\t}\n\t\tif (pl == d) return true;\n\t\treturn string_hash<hash_type>::get_hash(la + pr, la + d) == string_hash<hash_type>::get_hash(lb + pr, lb + d);\n\t}\n};\nusing namespace std;\nint main() {\n\tusing hash_type = unsigned long long;\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tstring S; int Q;\n\tcin >> S >> Q;\n\tstring_diff01<hash_type> H(S);\n\tfunction<bool(int, int, int)> is_cyclic = [&](int L, int R, int T) {\n\t\t// Supposing that (R - L) is divisible by T\n\t\tint num_cycle = (R - L) / T;\n\t\twhile (num_cycle > 1) {\n\t\t\tif (num_cycle & 1) {\n\t\t\t\t--num_cycle;\n\t\t\t\tif (!H.diff0(L, L + num_cycle * T, T)) return false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnum_cycle >>= 1;\n\t\t\t\tif (!H.diff0(L, L + num_cycle * T, num_cycle * T)) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\tfunction<bool(int, int, int)> solve = [&](int L, int R, int T) {\n\t\tint num_cycle = (R - L) / T;\n\t\tint remains = (R - L) % T;\n\t\tif (num_cycle == 0) return true;\n\t\tif (num_cycle == 1) return H.diff1(L, L + T, remains);\n\t\tif (num_cycle == 2) {\n\t\t\tif (!H.diff1(L, L + T, T)) return false;\n\t\t\tif (H.diff0(L, L + T, T)) return H.diff1(L, L + 2 * T, remains);\n\t\t\tif (H.diff0(L, L + T, remains)) return H.diff0(L, L + 2 * T, remains);\n\t\t\treturn H.diff0(L, L + 2 * T, remains) || H.diff0(L + T, L + 2 * T, remains);\n\t\t}\n\t\tconst vector<int> divs = { -1, -1, -1, 3, 4, 5, 3, 3, 4 };\n\t\tint div = (num_cycle >= 9 ? 3 : divs[num_cycle]), largeT = (num_cycle / div) * T;\n\t\tvector<hash_type> h(div);\n\t\tfor (int i = 0; i < div; ++i) {\n\t\t\th[i] = H.get_hash(L + i * largeT, L + (i + 1) * largeT);\n\t\t}\n\t\tvector<hash_type> h_sorted = h;\n\t\tsort(h_sorted.begin(), h_sorted.end());\n\t\tint sep = -1, sepcnt = 0;\n\t\tfor (int i = 1; i < div; ++i) {\n\t\t\tif (h_sorted[i] != h_sorted[i - 1]) {\n\t\t\t\tsep = i;\n\t\t\t\t++sepcnt;\n\t\t\t}\n\t\t}\n\t\tif (sepcnt >= 2 || (1 < sep && sep < div - 1)) return false;\n\t\thash_type truth = (sep != 1 ? h_sorted[0] : h_sorted[1]);\n\t\tint truth_pos = -1, wrong_pos = -1;\n\t\tfor (int i = div - 1; i >= 0; --i) {\n\t\t\tif (h[i] == truth) truth_pos = i;\n\t\t\telse wrong_pos = i;\n\t\t}\n\t\tif (!is_cyclic(L + truth_pos * largeT, L + (truth_pos + 1) * largeT, T)) return false;\n\t\tif (sep == -1) return H.diff1(L, L + div * largeT, R - L - div * largeT);\n\t\tif (!H.diff1(L + truth_pos * largeT, L + wrong_pos * largeT, largeT)) return false;\n\t\treturn H.diff0(L + truth_pos * largeT, L + div * largeT, R - L - div * largeT);\n\t};\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint L, R, T;\n\t\tcin >> L >> R >> T; --L;\n\t\tbool ans = solve(L, R, T);\n\t\tcout << (ans ? \"Yes\\n\" : \"No\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tassert(!lsame||rsame);\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\t//assert(issame(L, L + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll po(const ll p, const ll n, const ll mod)\n{\n    if (n == 0) { return 1; }\n    if (n % 2 == 1) {\n        return po(p, n - 1, mod) * p % mod;\n    } else {\n        const ll pp = po(p, n / 2, mod);\n        return pp * pp % mod;\n    }\n}\nconstexpr ll inv(const ll p, const ll mod) { return po(p, mod - 2, mod); }\nconstexpr ll BASE1 = 186398169LL;\nconstexpr ll MOD1 = 1000000007LL;\nconstexpr ll INV1 = inv(BASE1, MOD1);\nconstexpr ll BASE2 = 238173201LL;\nconstexpr ll MOD2 = 1000000009LL;\nconstexpr ll INV2 = inv(BASE2, MOD2);\nconstexpr int MAX = 100000;\nP power[2 * MAX], inverse[MAX], h[MAX], inverse2[MAX];\nmap<P, int> phash;\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string S;\n    cin >> S;\n    for (ll i = 0, p1 = 1, p2 = 1; i < 2 * MAX; i++, (p1 *= BASE1) %= MOD1, (p2 *= BASE2) %= MOD2) { power[i] = {p1, p2}; }\n    for (ll i = 0, i1 = 1, i2 = 1, h1 = 0, h2 = 0; i < S.size(); i++, (i1 *= INV1) %= MOD1, (i2 *= INV2) %= MOD2) {\n        (h1 += (S[i] - 'a') * power[i].first % MOD1) %= MOD1, (h2 += (S[i] - 'a') * power[i].second % MOD2) %= MOD2, h[i] = {h1, h2};\n        for (int j = 1; j < 26; j++) { phash[{power[i].first * j % MOD1, power[i].second * j % MOD2}] = i; }\n        inverse[i] = {i1, i2}, inverse2[i] = {inv((power[i].first + MOD1 - 1) % MOD1, MOD1), inv((power[i].second + MOD2 - 1) % MOD2, MOD2)};\n    };\n    auto add = [](const P& p1, const P& p2) -> P { return {(p1.first + p2.first) % MOD1, (p1.second + p2.second) % MOD2}; };\n    auto sub = [](const P& p1, const P& p2) -> P { return {(p1.first + MOD1 - p2.first) % MOD1, (p1.second + MOD2 - p2.second) % MOD2}; };\n    auto mul = [](const P& p1, const P& p2) -> P { return {(p1.first * p2.first) % MOD1, (p1.second * p2.second) % MOD2}; };\n    auto getHash = [&](const int s, const int l) -> P { return l == 0 ? P{0, 0} : s == 0 ? h[s + l - 1] : mul(sub(h[s + l - 1], h[s - 1]), inverse[s]); };\n    auto getPoly = [&](const int t, const int rep) -> P { return mul(sub(power[t * rep], {1, 1}), inverse2[t]); };\n    auto judge = [&](const P& diff, const int L) -> bool { return diff == P{0, 0} or (phash.find(diff) != phash.end() and phash[diff] < L) or (phash.find({(MOD1 - diff.first) % MOD1, (MOD2 - diff.second) % MOD2}) != phash.end() and phash[{-diff.first, -diff.second}] < L); };\n    assert(phash.size() == 25 * S.size());\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; q++) {\n        int l, r, t;\n        (cin >> l >> r >> t), l--;\n        const int L = r - l, rep = L / t, rest = L % t;\n        const P Hash = getHash(l, L);\n        if (rep == 1) {\n            const P mask1 = add(getHash(l, t), mul(power[t * rep], getHash(l + t * rep, rest)));\n            const P diff = sub(mask1, Hash);\n            cout << (judge(diff, L) ? \"Yes\\n\" : \"No\\n\");\n        } else {\n            const P poly = getPoly(t, rep);\n            const P m1 = getHash(l, t);\n            const P mask1 = add(mul(poly, m1), mul(power[t * rep], getHash(l + t * rep, rest)));\n            const P diff1 = sub(mask1, Hash);\n            const P m2 = getHash(l + t, t);\n            const P mask2 = add(mul(poly, m2), mul(power[t * rep], getHash(l + t * rep, rest)));\n            const P diff2 = sub(mask2, Hash);\n            cout << (judge(diff1, L) or judge(diff2, L) ? \"Yes\\n\" : \"No\\n\");\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconst ll mod = 1e9 + 7;\nconst ll b1 = 9973, b2 = 100000007;\n\nll Pow(ll a, ll b) {\n\tll res = 1; a %= mod;\n\twhile (b) {\n\t\tif (b & 1) {\n\t\t\tres = (res * a) % mod;\n\t\t}\n\t\ta = (a * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nclass RollingHash {\n\tint N;\n\tstring s;\n\tvector<ll> r1, r2, h1, h2, rh1, rh2;\npublic:\n\tRollingHash(const string& s_)\n\t\t: N((int)s_.size()), s(s_), r1(N + 1), r2(N + 1), h1(N + 1), h2(N + 1), rh1(N + 1), rh2(N + 1) {\n\t\tr1[0] = r2[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) r1[i] = r1[i - 1] * b1 % mod;\n\t\tfor (int i = 1; i <= N; i++) r2[i] = r2[i - 1] * b2 % mod;\n\n\t\th1[0] = h2[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) h1[i] = (h1[i - 1] * b1 + s[i - 1]) % mod;\n\t\tfor (int i = 1; i <= N; i++) h2[i] = (h2[i - 1] * b2 + s[i - 1]) % mod;\n\t}\n\tP get(int l, int r) {\n\t\treturn P((h1[r + 1] - h1[l] * r1[r - l + 1] % mod + mod) % mod, (h2[r + 1] - h2[l] * r2[r - l + 1] % mod + mod) % mod);\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint Q;\n\tstring S;\n\tcin >> S >> Q;\n\tint N = S.size();\n\tRollingHash rh(S);\n\tvector<P> dis;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = -25; j <= 25; j++) {\n\t\t\tdis.push_back(P(Pow(b1, i) * (mod + j) % mod, Pow(b2, i) * (mod + j) % mod));\n\t\t}\n\t}\n\tsort(dis.begin(), dis.end());\n\tfor (int i = 0, l, r, t; i < Q; i++) {\n\t\tcin >> l >> r >> t; l--; r--;\n\t\tauto lrh = rh.get(l, r - t), rrh = rh.get(l + t, r);\n\t\tll d1 = (lrh.first - rrh.first + mod) % mod, d2 = (lrh.second - rrh.second + mod) % mod;\n\t\tif (r - l + 1 > t * 2) {\n\t\t\tif (binary_search(dis.begin(), dis.end(), P(d1, d2))) {\n\t\t\t\tputs(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint w = r - l + 1 , fl = (r - l + 1) / t * t;\n\t\t\t\tif (w == fl && rh.get(l, l + t - 1) != rh.get(r - t + 1, r)) {\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (w != fl && (rh.get(l, l + w - fl - 1) != rh.get(r - (w - fl - 1), r) || rh.get(l + w - fl, l + t - 1) != rh.get(r - t + 1, r - (w - fl)))) {\n\t\t\t\t\tputs(\"No\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tll lb = t - 1, ub = r - l + 1 - t;\n\t\t\t\twhile (lb + 1 < ub) {\n\t\t\t\t\tll c = (lb + ub) / 2;\n\t\t\t\t\tlrh = rh.get(l, l + c - 1), rrh = rh.get(l + t, l + t + c - 1);\n\t\t\t\t\td1 = (lrh.first - rrh.first + mod) % mod, d2 = (lrh.second - rrh.second + mod) % mod;\n\t\t\t\t\tif (binary_search(dis.begin(), dis.end(), P(d1, d2))) {\n\t\t\t\t\t\tlb = c;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tub = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tll tmp = lb;\n\t\t\t\tlb = t - 1, ub = r - l + 1 - t;\n\t\t\t\twhile (lb + 1 < ub) {\n\t\t\t\t\tll c = (lb + ub) / 2;\n\t\t\t\t\tlrh = rh.get(r - t - c + 1, r - t), rrh = rh.get(r - c + 1, r);\n\t\t\t\t\td1 = (lrh.first - rrh.first + mod) % mod, d2 = (lrh.second - rrh.second + mod) % mod;\n\t\t\t\t\tif (binary_search(dis.begin(), dis.end(), P(d1, d2))) {\n\t\t\t\t\t\tlb = c;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tub = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tputs(tmp + lb == r - l || lb == r - l + 1 - t ? \"Yes\" : \"No\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tputs(binary_search(dis.begin(), dis.end(), P(d1, d2)) ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tassert(rsame);\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP, rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size());\n    LCP[0] = 0;\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i] + 1] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (LCP[k]);\n  }\n\n  size_t size() const\n  {\n    return (LCP.size());\n  }\n};\n\n\nconst int INF = 1 << 30;\n\nstruct SegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n\n\nint main()\n{\n  string S;\n  int Q;\n\n  cin >> S;\n  cin >> Q;\n\n  SuffixArray sa;\n  LongestCommonPrefixArray lcp;\n  SegmentTree tree(S.size());\n\n  sa.Build_SA(S);\n  lcp.Build_LCP(sa);\n  for(int i = 0; i < S.size(); i++) tree.set(i, lcp[i]);\n  tree.build();\n\n  auto getLCP = [&](int a, int b)\n  {\n    if(a > S.size() || b > S.size()) return (INF);\n    a = lcp.rank[a], b = lcp.rank[b];\n    if(a > b) swap(a, b);\n    return (tree.rmq(a + 1, b + 1));\n  };\n\n  while(Q--) {\n    int l, r, t;\n    cin >> l >> r >> t;\n\n    int l1 = --l, r1 = r - t;\n    int l2 = l1 + t, r2 = r;\n    int length = r1 - l1;\n\n    int lcp1 = getLCP(l1, l2);\n\n    /*\n    cout << S.substr(l1, r1 - l1) << endl;\n    cout << string(t, ' ') + S.substr(l2, r2 - l2) << endl;\n    */\n\n    // (>_<)\n    if(lcp1 >= length) {\n      cout << \"Yes\" << endl;\n      continue;\n    }\n\n    int lcp2 = getLCP(l1 + lcp1 + 1, l2 + lcp1 + 1);\n\n    if(lcp1 + 1 + lcp2 >= length) {\n      if(l1 + lcp1 < l2 || l2 + lcp1 >= r1) {\n        cout << \"Yes\" << endl;\n      } else {\n        cout << \"No\" << endl;\n      }\n      continue;\n    }\n\n    if(l1 + lcp1 + 1 + lcp2 < l2 || l1 + lcp1 + 1 >= l2) {\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    if(lcp2 + 1 == t && S[l1 + lcp1] == S[l2 + lcp1 + t]) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l,r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r+1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r+1 - index - 1].second);\n\t}\n\tvoid change_st(const int index, const ll from, const ll to)const {\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const pair<int, int>a, const pair<int, int>b) {\n\tint al = a.first, ar = a.second;\n\tint bl = b.first, br = b.second;\n\tint lans = -1;\n\tint rans = ar-al;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans+1, ar) == rh.hash(bl + rans+1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind,st[changeind],changeto,l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool,int> issame(pair<int,int>a, pair<int,int>b) {\n\tif (b.first > R) {\n\t\treturn true;\n\t}\n\telse {\n\t\tassert(b.first <= R);\n\t\tint len = min(a.second - a.first, R - b.first);\n\t\tbool same=  getha(a.first,a.first+len) == getha(b.first,b.first+len);\n\t\tif (same)return make_pair(1, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a, b);\n\t\t\treturn make_pair(false,acheck);\n\t\t}\n\t}\n}\nint main() { \n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize*2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto aa = issame(make_pair(L, L + nt-1), make_pair(L + nt, L + nt * 2 - 1));\n\t\t\tif (aa.first)continue;\n\t\t\telse {\n\t\t\t\tint p(aa.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = getha(l1, l1 + nt / 2 - 1) == getha(l1 + nt / 2, l1+nt-1);\n\t\t\t\t\t\tbool rsame;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (l4 > R) {\n\t\t\t\t\t\t\t\trsame = true;\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trsame = getha(l3, r3) == getha(l4, r4);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = l2 + p;\n\t\t\t\t\t\t\t\tchangeto = st[l1 + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tchangeind = l1 + p;\n\t\t\t\t\t\t\t\tchangeto = st[l2 + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame&&!rsame) {\n\t\t\t\t\t\t\t\tchangeind = l2 + p;\n\t\t\t\t\t\t\t\tchangeto = st[l1 + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!lsame&&rsame) {\n\t\t\t\t\t\t\t\tchangeind = l1 + p;\n\t\t\t\t\t\t\t\tchangeto = st[l2 + p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\tvector<ha>hash_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\n\tha get_changed_hash(const int index, const ll from, const ll to, const int l, const int r)const {\n\t\tconst ha p(hash(l, r));\n\t\tif (l > index || r < index)return p;\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[r + 1 - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[r + 1 - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nRollingHash rh;\nint check(const int a, const int b,int len) {\n\tint al = a, ar = a+ len;\n\tint bl = b, br = b+len;\n\tint lans = -1;\n\tint rans =len;\n\twhile (lans + 1 != rans) {\n\t\tint midans = (lans + rans) / 2;\n\t\tif (rh.hash(al, al + midans) == rh.hash(bl, bl + midans)) {\n\t\t\tlans = midans;\n\t\t}\n\t\telse {\n\t\t\trans = midans;\n\t\t}\n\t}\n\tif (rh.hash(al + rans + 1, ar) == rh.hash(bl + rans + 1, br))return rans;\n\telse return -1;\n}\nstring st;\nint changeind = -1;\nchar changeto = 0;\nha getha(const int l, const int r) {\n\tif (changeind != -1) {\n\t\treturn rh.get_changed_hash(changeind, st[changeind], changeto, l, r);\n\t}\n\telse {\n\t\tha h = rh.hash(l, r);\n\t\treturn h;\n\t}\n}\nint L, R, T;\npair<bool, int> issame(int a, int b, int alen) {\n\tif (b > R) {\n\t\treturn make_pair(true, -1);\n\t}\n\telse {\n\t\tassert(b <= R);\n\t\tint len = min(alen, R - b);\n\t\tbool same = getha(a, a + len) == getha(b, b + len);\n\t\tif (same)return make_pair(true, -1);\n\t\telse {\n\n\t\t\tint acheck = check(a,b,len);\n\t\t\treturn make_pair(false, acheck);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> st;\n\trh.init(st);\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tchangeind = -1;\n\t\tchangeto = -1; cin >> L >> R >> T;\n\t\tL--; R--;\n\t\tint asize = R - L + 1;\n\t\tint nt = T;\n\t\twhile (asize * 2 >= nt) {\n\t\t\tnt *= 2;\n\t\t}\n\t\tbool ok = true;\n\t\twhile (nt != T) {\n\t\t\tnt /= 2;\n\t\t\tif (nt >= asize)continue;\n\t\t\tauto ap = issame(L, L + nt, nt-1);\n\t\t\tif (ap.first)continue;\n\t\t\telse {\n\t\t\t\tint p(ap.second);\n\t\t\t\tif (p == -1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changeind != -1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (nt == T) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool lsame = issame(L,L+nt/2,nt/2-1).first;\n\t\t\t\t\t\tbool rsame= issame( L + nt,L+nt+nt/2, nt / 2 - 1).first;\n\t\t\t\t\t\tbool rflag = false;\n\t\t\t\t\t\tif(L+2*nt>R){\n\t\t\t\t\t\t\tconst int l3 = L + nt;\n\t\t\t\t\t\t\tint r3 = L + nt + nt / 2 - 1;\n\t\t\t\t\t\t\tconst int l4 = L + nt + nt / 2;\n\t\t\t\t\t\t\tint r4 = L + nt + nt - 1;\n\t\t\t\t\t\t\tif (L + nt + nt / 2 > R) {\n\t\t\t\t\t\t\t\trflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (r4 > R) {\n\t\t\t\t\t\t\t\t\tr4 = R;\n\t\t\t\t\t\t\t\t\tassert(l4 <= R);\n\t\t\t\t\t\t\t\t\tr3 = l3 + (r4 - l4);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (r4 < L+nt+p)assert(false);\n\t\t\t\t\t\t\t\tif (r3 < L + nt + p&&L + nt + p < l4)rflag = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rflag) {\n\t\t\t\t\t\t\tif (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(rsame){\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (lsame&&rsame)assert(false);\n\t\t\t\t\t\t\telse if (lsame) {\n\t\t\t\t\t\t\t\tchangeind = L + nt + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (rsame) {\n\t\t\t\t\t\t\t\tchangeind = L + p;\n\t\t\t\t\t\t\t\tchangeto = st[L + nt + p];\n\t\t\t\t\t\t\t\tassert(issame(L + nt, L + nt + nt / 2, nt / 2 - 1).first);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\n\n/**\n * AIZU ONLINE JUDGE\n * 2711 Nearly Cyclic String\n *    2018/02/16\n */\npublic class Main {\n\n\tboolean main() throws IOException {\n\n\t    String S = systemin.readLine();\n\t\tint[] ir = readIntArray();\n\t\tint Q = ir[0];\n\n\t\tfor(int q = 0; q < Q; q++) {\n\n        ir = readIntArray();\n        int l = ir[0];\n        int r = ir[1];\n        int t = ir[2];\n        log.printf(\"%s %d %d %d\\n\", S, l, r, t);\n\n        int dcnt = 0;\n        loop:for(int i = 0; i < t; i++) {\n            int[] c = new int[2];\n            int[] cnt = new int[2];\n            int ac = 0;\n            for(int j = 0;; j++) {\n                int k = j * t + i + l;\n                if (k > r)\n                    break;\n                int ch = S.charAt(k - 1);\n                log.printf(\"i=%d j = %d index = %d '%c'\\n\", i, j, k, ch);\n                for(int p = 0;; p++) {\n                    if (p >= 2) {\n                        dcnt = 99;\n                        break loop;\n                    }\n                    if (p >= ac) {\n                        c[p] = ch;\n                        cnt[p] = 1;\n                        ac++;\n                        break;\n                    }\n                    if (c[p] == ch) {\n                        cnt[p]++;\n                        break;\n                    }\n                }\n            }\n            if (ac == 2) {\n                if (cnt[0] == 1 || cnt[1] == 1) {\n                    dcnt++;\n                }\n                else {\n                    dcnt = 99;\n                    break loop;\n                }\n            }\n        }\n        log.printf(\"dcnt = %d\\n\", dcnt);\n        if (dcnt <= 1)\n            result.printf(\"yes\\n\");\n        else\n            result.printf(\"no\\n\");\n\t\t}\n        //return true; // 正常終了 次へ\n\t\treturn false;\n\t}\n\n\tstatic long time0;\n\n    PrintStream log;\n    PrintStream result;\n    BufferedReader systemin;\n\n    static Main instance = new Main();\n\n    Main() {\n        systemin = new BufferedReader(new InputStreamReader(System.in));\n        result = System.out;\n        log = new PrintStream(new OutputStream() { public void write(int b) {} } );\n    }\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tint N = Integer.MAX_VALUE;\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tboolean b = instance.main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\n\n        instance.systemin.close();\n\t}\n\n\t// 標準入力より1行分の区切り文字区切りでの整数値を読む\n\t// EOFの場合はnullを返す\n\tprivate int[] readIntArray() throws IOException {\n\n\t\tString s = null;\n\t\tfor(;;) {\n\t\t\ts = systemin.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\ts = s.trim();\n\t\t\tif (s.length() != 0) // 突然空行を読むことがある。読み飛ばすとうまくいくらしい\n\t\t\t\tbreak;\n\t\t}\n\n\t\tString[] sp = s.split(\"[ ,]\"); // 区切り文字はスペースかカンマ\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\n\n/**\n * AIZU ONLINE JUDGE\n * 2711 Nearly Cyclic String\n *    2018/02/16\n */\npublic class Main {\n\n\tboolean main() throws IOException {\n\n\t    String S = systemin.readLine();\n\t\tint[] ir = readIntArray();\n\t\tint Q = ir[0];\n\n\t\tfor(int q = 0; q < Q; q++) {\n\n            ir = readIntArray();\n            int l = ir[0];\n            int r = ir[1];\n            int t = ir[2];\n            if (r - l + 1 -1 <= t) {\n                result.printf(\"Yes\\n\");\n            }\n            else {\n            //log.printf(\"%s %d %d %d\\n\", S, l, r, t);\n\n            int dcnt = 0; // 変更が必要な文字数 1ならYes\n            loop:for(int i = 0; i < t; i++) {\n                int cnt2 = 0; // 2文字以上の文字の数\n                \n                // 初回\n                int k = i + l;\n                int ch = S.charAt(k - 1);\n                int ac = 1; // 登録した文字の種類の数\n                int ch0 = ch;\n                int cnt0 = 1;\n                int ch1 = 0;\n                int cnt1 = 0;\n\n                for(int j = 1;; j++) {\n                    k = j * t + i + l;\n                    if (k > r)\n                        break;\n                    ch = S.charAt(k - 1);\n                    //log.printf(\"i=%d j = %d index = %d '%c'\\n\", i, j, k, ch);\n                    if (/*ac > 0 &&*/ ch0 == ch) {\n                        if (++cnt0 == 2) {\n                            if (++cnt2 >= 2) {\n                                dcnt = 99;\n                                break loop;\n                            }\n                        }\n                    }\n                    else if (/*ac > 1 &&*/ ch1 == ch) {\n                        if (++cnt1 == 2) {\n                            if (++cnt2 >= 2) {\n                                dcnt = 99;\n                                break loop;\n                            }\n                        }\n                    }\n                    else if (ac == 2) {\n                        dcnt = 99;\n                        break loop;\n                    }\n                    else { // ac == 1\n                        if (dcnt >= 1) {\n                            dcnt = 99;\n                            break loop;\n                        }\n                        ac = 2;\n                        ch1 = ch;\n                        cnt1 = 1;\n                    }\n                }\n                if (ac == 2) {\n                    if (++dcnt >= 2)\n                        break loop;\n                }\n            } // loop\n            //log.printf(\"dcnt = %d\\n\", dcnt);\n            if (dcnt <= 1)\n                result.printf(\"Yes\\n\");\n            else\n                result.printf(\"No\\n\");\n            }\n\t\t}\n        //return true; // 正常終了 次へ\n\t\treturn false;\n\t}\n\n\tstatic long time0;\n\n    PrintStream log;\n    PrintStream result;\n    BufferedReader systemin;\n\n    static Main instance = new Main();\n\n    Main() {\n        systemin = new BufferedReader(new InputStreamReader(System.in));\n        result = System.out;\n        log = new PrintStream(new OutputStream() { public void write(int b) {} } );\n    }\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tint N = Integer.MAX_VALUE;\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tboolean b = instance.main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\n\n        instance.systemin.close();\n\t}\n\n\t// 標準入力より1行分の区切り文字区切りでの整数値を読む\n\t// EOFの場合はnullを返す\n\tprivate int[] readIntArray() throws IOException {\n\n\t\tString s = null;\n\t\tfor(;;) {\n\t\t\ts = systemin.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\ts = s.trim();\n\t\t\tif (s.length() != 0) // 突然空行を読むことがある。読み飛ばすとうまくいくらしい\n\t\t\t\tbreak;\n\t\t}\n\n\t\tString[] sp = s.split(\"[ ,]\"); // 区切り文字はスペースかカンマ\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\n\n/**\n * AIZU ONLINE JUDGE\n * 2711 Nearly Cyclic String\n *    2018/02/16\n */\npublic class Main {\n\n    long[] hash;\n    long[] base;\n    int K = 111111;\n\n    // lからrのハッシュを求める\n    long getHash(int l, int r) {\n//        log.printf(\"getHash %d %d %d %d\\n\", hash.length, r + 1, l, r - l + 1);\n        return hash[r + 1] - hash[l] * base[r - l + 1];\n    }\n\n    // lからとl+tからsize文字比較して最初の不一致文字を返す\n    int comp(int l, int t, int size) {\n        if (getHash(l, l + size - 1) == getHash(l+t, l+t + size - 1)) {\n//            log.printf(\"comp(%d %d %d) = -1\\n\", l, t, size, -1);\n            return -1;\n        }\n\n        int s1 = l;\n        int s2 = l + size - 1;\n        while(s1 <= s2) {\n            int m = (s1 + s2) / 2;\n//            log.printf(\"s1 s2 m = %d %d %d  \", s1, s2, m);\n            if (getHash(l, m) == getHash(l+t, m+t)) {\n//                log.printf(\"一致\\n\");\n                s1 = m + 1;\n            }\n            else {\n//                log.printf(\"不一致\\n\");\n                s2 = m-1;\n            }\n        }\n//        log.printf(\"comp(%d %d %d) = %d\\n\", l, t, size, s1);\n        return s1;\n    }\n\n    boolean main() throws IOException {\n\n        String S = systemin.readLine();\n        int[] ir = readIntArray();\n\n        if (S.length() < 200)\n            log.printf(\"%s\\n\", S);\n    \n        hash = new long[S.length() + 1];\n        base = new long[S.length() + 1];\n\n        hash[0] = 0;\n        base[0] = 1;\n        for(int i = 0; i < S.length(); i++) {\n            hash[i + 1] = hash[i] * K + S.charAt(i);\n            base[i + 1] = base[i] * K;\n        }\n\n        int Q = ir[0];\n        for(int q = 0; q < Q; q++) {\n\n            ir = readIntArray();\n            int l = ir[0] - 1;\n            int r = ir[1] - 1;\n            int t = ir[2];\n            log.printf(\"-----\\nS.len = %d l, r, t = %d, %d, %d\\n\", S.length(), l, r, t);\n            int size = r - l + 1 - t;\n            int c1 = comp(l, t, size);\n            int res = 1;\n            if (c1 >= 0) {\n                log.printf(\"c1 %d '%s' '%s'\\n\", c1, S.charAt(c1), S.charAt(c1 + t));\n                l = c1 + 1;\n                size = r - l + 1 - t;\n                int c2 = comp(l, t, size);\n                if (c2 >= 0) {\n                    log.printf(\"c2 %d '%s' '%s'\\n\", c2, S.charAt(c2), S.charAt(c2 + t));\n                    if (c2 != c1 + t) {\n                        res = 0; // だめ\n                    }\n                    else if (c2 + t * 2 < S.length() && S.charAt(c1) != S.charAt(c2 + t * 2)) {\n                        log.printf(\"dame\\n\");\n                        res = 0; // だめ\n                    }\n                    else {\n                        l = c2 + 1;\n                        size = r - l + 1 - t;\n                        int c3 = comp(l, t, size);\n                        if (c3 >= 0) {\n                            res = 0; // NG\n                        }\n                    }\n                }\n            }\n\n            if (res > 0)\n                result.printf(\"Yes\\n\");\n            else\n                result.printf(\"No\\n\");\n        }\n\n        //return true; // 正常終了 次へ\n        return false;\n    }\n\n\tboolean main2() throws IOException {\n\n\t    String S = systemin.readLine();\n\t\tint[] ir = readIntArray();\n\t\tint Q = ir[0];\n\n\t\tfor(int q = 0; q < Q; q++) {\n\n            ir = readIntArray();\n            int l = ir[0];\n            int r = ir[1];\n            int t = ir[2];\n            if (r - l + 1 -1 <= t) {\n                result.printf(\"Yes\\n\");\n            }\n            else {\n            //log.printf(\"%s %d %d %d\\n\", S, l, r, t);\n\n            int dcnt = 0; // 変更が必要な文字数 1ならYes\n            loop:for(int i = 0; i < t; i++) {\n                int cnt2 = 0; // 2文字以上の文字の数\n\n                // 初回\n                int k = i + l;\n                int ch = S.charAt(k - 1);\n                int ac = 1; // 登録した文字の種類の数\n                int ch0 = ch;\n                int cnt0 = 1;\n                int ch1 = 0;\n                int cnt1 = 0;\n\n                for(int j = 1;; j++) {\n                    k = j * t + i + l;\n                    if (k > r)\n                        break;\n                    ch = S.charAt(k - 1);\n                    //log.printf(\"i=%d j = %d index = %d '%c'\\n\", i, j, k, ch);\n                    if (ch == ch0) {\n                        if (++cnt0 == 2) {\n                            if (++cnt2 >= 2) {\n                                dcnt = 99;\n                                break loop;\n                            }\n                        }\n                    }\n                    else if (ch == ch1) {\n                        if (++cnt1 == 2) {\n                            if (++cnt2 >= 2) {\n                                dcnt = 99;\n                                break loop;\n                            }\n                        }\n                    }\n                    else if (ac == 2) {\n                        dcnt = 99;\n                        break loop;\n                    }\n                    else { // ac == 1\n                        if (dcnt >= 1) {\n                            dcnt = 99;\n                            break loop;\n                        }\n                        ac = 2;\n                        ch1 = ch;\n                        cnt1 = 1;\n                    }\n                }\n                if (ac == 2) {\n                    ++dcnt;\n//                    if (dcnt >= 2)\n//                        break loop;\n                }\n            } // loop\n            //log.printf(\"dcnt = %d\\n\", dcnt);\n            if (dcnt <= 1)\n                result.printf(\"Yes\\n\");\n            else\n                result.printf(\"No\\n\");\n            }\n\t\t}\n        //return true; // 正常終了 次へ\n\t\treturn false;\n\t}\n\n\tstatic long time0;\n\n    PrintStream log;\n    PrintStream result;\n    BufferedReader systemin;\n\n    static Main instance = new Main();\n\n    Main() {\n        systemin = new BufferedReader(new InputStreamReader(System.in));\n        result = System.out;\n        log = new PrintStream(new OutputStream() { public void write(int b) {} } );\n    }\n\n\tpublic static void main(String[] args) throws IOException {\n\n//\t    instance.main0();\n//\t    if (true)\n//\t        System.exit(0);\n\n\t\tint N = Integer.MAX_VALUE;\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tboolean b = instance.main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\n\n        instance.systemin.close();\n\t}\n\n\t// 標準入力より1行分の区切り文字区切りでの整数値を読む\n\t// EOFの場合はnullを返す\n\tprivate int[] readIntArray() throws IOException {\n\n\t\tString s = null;\n\t\tfor(;;) {\n\t\t\ts = systemin.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\ts = s.trim();\n\t\t\tif (s.length() != 0) // 突然空行を読むことがある。読み飛ばすとうまくいくらしい\n\t\t\t\tbreak;\n\t\t}\n\n\t\tString[] sp = s.split(\"[ ,]\"); // 区切り文字はスペースかカンマ\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\n\n/**\n * AIZU ONLINE JUDGE\n * 2711 Nearly Cyclic String\n *    2018/02/16\n */\npublic class Main {\n\n\tboolean main() throws IOException {\n\n\t    String S = systemin.readLine();\n\t\tint[] ir = readIntArray();\n\t\tint Q = ir[0];\n\n\t\tint[] c = new int[2];\n        int[] cnt = new int[2];\n\n\t\tfor(int q = 0; q < Q; q++) {\n\n            ir = readIntArray();\n            int l = ir[0];\n            int r = ir[1];\n            int t = ir[2];\n            if (r - l + 1 -1 <= t) {\n                result.printf(\"Yes\\n\");\n            }\n            else {\n            //log.printf(\"%s %d %d %d\\n\", S, l, r, t);\n    \n            int dcnt = 0; // 変更が必要な文字数 1ならYes\n            loop:for(int i = 0; i < t; i++) {\n                int ac = 0; // 文字の種類の数\n                int cnt2 = 0; // 2文字以上の文字の数\n                for(int j = 0;; j++) {\n                    int k = j * t + i + l;\n                    if (k > r)\n                        break;\n                    int ch = S.charAt(k - 1);\n                    //log.printf(\"i=%d j = %d index = %d '%c'\\n\", i, j, k, ch);\n                    for(int p = 0;; p++) {\n                        if (p >= 2) {\n                            dcnt = 99;\n                            break loop;\n                        }\n                        if (p >= ac) { // 登録\n                            c[p] = ch;\n                            cnt[p] = 1;\n                            ac++;\n                            break;\n                        }\n                        if (c[p] == ch) {\n                            if (++cnt[p] == 2)\n                                if (++cnt2 >= 2) {\n                                    dcnt = 99;\n                                    break loop;\n                                }\n                            break;\n                        }\n                    }\n                }\n                if (ac == 2) {\n                    dcnt++;\n                    if (dcnt >= 2)\n                        break loop;\n                }\n            }\n            //log.printf(\"dcnt = %d\\n\", dcnt);\n            if (dcnt <= 1)\n                result.printf(\"Yes\\n\");\n            else\n                result.printf(\"No\\n\");\n            }\n\t\t}\n        //return true; // 正常終了 次へ\n\t\treturn false;\n\t}\n\n\tstatic long time0;\n\n    PrintStream log;\n    PrintStream result;\n    BufferedReader systemin;\n\n    static Main instance = new Main();\n\n    Main() {\n        systemin = new BufferedReader(new InputStreamReader(System.in));\n        result = System.out;\n        log = new PrintStream(new OutputStream() { public void write(int b) {} } );\n    }\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tint N = Integer.MAX_VALUE;\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tboolean b = instance.main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\n\n        instance.systemin.close();\n\t}\n\n\t// 標準入力より1行分の区切り文字区切りでの整数値を読む\n\t// EOFの場合はnullを返す\n\tprivate int[] readIntArray() throws IOException {\n\n\t\tString s = null;\n\t\tfor(;;) {\n\t\t\ts = systemin.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\ts = s.trim();\n\t\t\tif (s.length() != 0) // 突然空行を読むことがある。読み飛ばすとうまくいくらしい\n\t\t\t\tbreak;\n\t\t}\n\n\t\tString[] sp = s.split(\"[ ,]\"); // 区切り文字はスペースかカンマ\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\n\n/**\n * AIZU ONLINE JUDGE\n * 2711 Nearly Cyclic String\n *    2018/02/16\n */\npublic class Main {\n\n    long[] hash;\n    long[] base;\n    int K = 29;\n\n    // lからrのハッシュを求める\n    long getHash(int l, int r) {\n        return hash[r + 1] - hash[l] * base[r - l + 1];\n    }\n\n    // lからとl+tからsize文字比較して最初の不一致文字を返す\n    int comp(int l, int t, int size) {\n        if (getHash(l, l + size - 1) == getHash(l+t, l+t + size - 1)) {\n            return -1;\n        }\n\n        int s1 = l;\n        int s2 = l + size - 1;\n        while(s1 <= s2) {\n            int m = (s1 + s2) / 2;\n            if (getHash(l, m) == getHash(l+t, m+t)) {\n                s1 = m + 1;\n            }\n            else {\n                s2 = m-1;\n            }\n        }\n        return s1;\n    }\n\n    boolean main() throws IOException {\n\n        String S = systemin.readLine();\n        int[] ir = readIntArray();\n\n        hash = new long[S.length() + 1];\n        base = new long[S.length() + 1];\n\n        hash[0] = 0;\n        base[0] = 1;\n        for(int i = 0; i < S.length(); i++) {\n            hash[i + 1] = hash[i] * K + S.charAt(i);\n            base[i + 1] = base[i] * K;\n        }\n\n        int Q = ir[0];\n        for(int q = 0; q < Q; q++) {\n            ir = readIntArray();\n            int l = ir[0] - 1;\n            int r = ir[1] - 1;\n            int t = ir[2];\n\n            //log.printf(\"-----\\nS.len = %d l, r, t = %d, %d, %d\\n\", S.length(), l, r, t);\n            int size = r - l + 1 - t;\n            int c1 = comp(l, t, size);\n            int res = 1;\n            if (c1 >= 0) {\n                //log.printf(\"c1 %d '%s' '%s'\\n\", c1, S.charAt(c1), S.charAt(c1 + t));\n                l = c1 + 1;\n                size = r - l + 1 - t;\n                int c2 = comp(l, t, size);\n                if (c2 >= 0) {\n                    //log.printf(\"c2 %d '%s' '%s'\\n\", c2, S.charAt(c2), S.charAt(c2 + t));\n                    if (c2 != c1 + t) {\n                        res = 0; // だめ\n                    }\n                    else if (c2 + t <= r && S.charAt(c1) != S.charAt(c2 + t)) {\n                        //log.printf(\"dame\\n\");\n                        res = 0; // だめ\n                    }\n                    else {\n                        l = c2 + 1;\n                        size = r - l + 1 - t;\n                        int c3 = comp(l, t, size);\n                        if (c3 >= 0) {\n                            res = 0; // NG\n                        }\n                    }\n                }\n            }\n\n            if (res > 0)\n                result.printf(\"Yes\\n\");\n            else\n                result.printf(\"No\\n\");\n        }\n\n        //return true; // 正常終了 次へ\n        return false;\n    }\n\n\tstatic long time0;\n\n    PrintStream log;\n    PrintStream result;\n    BufferedReader systemin;\n\n    static Main instance = new Main();\n\n    Main() {\n        systemin = new BufferedReader(new InputStreamReader(System.in));\n        result = System.out;\n        log = new PrintStream(new OutputStream() { public void write(int b) {} } );\n    }\n\n\tpublic static void main(String[] args) throws IOException {\n\n//\t    instance.main0();\n//\t    if (true)\n//\t        System.exit(0);\n\n\t\tint N = Integer.MAX_VALUE;\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tboolean b = instance.main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\n\n        instance.systemin.close();\n\t}\n\n\t// 標準入力より1行分の区切り文字区切りでの整数値を読む\n\t// EOFの場合はnullを返す\n\tprivate int[] readIntArray() throws IOException {\n\n\t\tString s = null;\n\t\tfor(;;) {\n\t\t\ts = systemin.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\ts = s.trim();\n\t\t\tif (s.length() != 0) // 突然空行を読むことがある。読み飛ばすとうまくいくらしい\n\t\t\t\tbreak;\n\t\t}\n\n\t\tString[] sp = s.split(\"[ ,]\"); // 区切り文字はスペースかカンマ\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\n\n/**\n * AIZU ONLINE JUDGE\n * 2711 Nearly Cyclic String\n *    2018/02/16\n */\npublic class Main {\n\n\tboolean main() throws IOException {\n\n\t    String S = systemin.readLine();\n\t\tint[] ir = readIntArray();\n\t\tint Q = ir[0];\n\n\t\tfor(int q = 0; q < Q; q++) {\n\n            ir = readIntArray();\n            int l = ir[0];\n            int r = ir[1];\n            int t = ir[2];\n            //log.printf(\"%s %d %d %d\\n\", S, l, r, t);\n    \n            int dcnt = 0; // 変更が必要な文字数 1ならYes\n            int[] c = new int[2];\n            int[] cnt = new int[2];\n            loop:for(int i = 0; i < t; i++) {\n                int ac = 0; // 文字の種類の数\n                int cnt2 = 0; // 2文字以上の文字の数\n                for(int j = 0;; j++) {\n                    int k = j * t + i + l;\n                    if (k > r)\n                        break;\n                    int ch = S.charAt(k - 1);\n                    //log.printf(\"i=%d j = %d index = %d '%c'\\n\", i, j, k, ch);\n                    for(int p = 0;; p++) {\n                        if (p >= 2) {\n                            dcnt = 99;\n                            break loop;\n                        }\n                        if (p >= ac) { // 登録\n                            c[p] = ch;\n                            cnt[p] = 1;\n                            ac++;\n                            break;\n                        }\n                        if (c[p] == ch) {\n                            if (++cnt[p] == 2)\n                                if (++cnt2 >= 2) {\n                                    dcnt = 99;\n                                    break loop;\n                                }\n                            break;\n                        }\n                    }\n                }\n                if (ac == 2) {\n                    dcnt++;\n                    if (dcnt >= 2)\n                        break loop;\n                }\n            }\n            //log.printf(\"dcnt = %d\\n\", dcnt);\n            if (dcnt <= 1)\n                result.printf(\"Yes\\n\");\n            else\n                result.printf(\"No\\n\");\n\t\t}\n        //return true; // 正常終了 次へ\n\t\treturn false;\n\t}\n\n\tstatic long time0;\n\n    PrintStream log;\n    PrintStream result;\n    BufferedReader systemin;\n\n    static Main instance = new Main();\n\n    Main() {\n        systemin = new BufferedReader(new InputStreamReader(System.in));\n        result = System.out;\n        log = new PrintStream(new OutputStream() { public void write(int b) {} } );\n    }\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tint N = Integer.MAX_VALUE;\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tboolean b = instance.main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\n\n        instance.systemin.close();\n\t}\n\n\t// 標準入力より1行分の区切り文字区切りでの整数値を読む\n\t// EOFの場合はnullを返す\n\tprivate int[] readIntArray() throws IOException {\n\n\t\tString s = null;\n\t\tfor(;;) {\n\t\t\ts = systemin.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\ts = s.trim();\n\t\t\tif (s.length() != 0) // 突然空行を読むことがある。読み飛ばすとうまくいくらしい\n\t\t\t\tbreak;\n\t\t}\n\n\t\tString[] sp = s.split(\"[ ,]\"); // 区切り文字はスペースかカンマ\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\n\n/**\n * AIZU ONLINE JUDGE\n * 2711 Nearly Cyclic String\n *    2018/02/16\n */\npublic class Main {\n\n    long[] hash;\n    long[] base;\n    int K = 29; //1777771; //29;\n\n    // lからrのハッシュを求める\n    long getHash(int l, int r) {\n//        log.printf(\"getHash %d %d %d %d\\n\", hash.length, r + 1, l, r - l + 1);\n        return hash[r + 1] - hash[l] * base[r - l + 1];\n    }\n\n    // lからとl+tからsize文字比較して最初の不一致文字を返す\n    int comp(int l, int t, int size) {\n        if (getHash(l, l + size - 1) == getHash(l+t, l+t + size - 1)) {\n//            log.printf(\"comp(%d %d %d) = -1\\n\", l, t, size, -1);\n            return -1;\n        }\n\n        int s1 = l;\n        int s2 = l + size - 1;\n        while(s1 <= s2) {\n            int m = (s1 + s2) / 2;\n//            log.printf(\"s1 s2 m = %d %d %d  \", s1, s2, m);\n            if (getHash(l, m) == getHash(l+t, m+t)) {\n//                log.printf(\"一致\\n\");\n                s1 = m + 1;\n            }\n            else {\n//                log.printf(\"不一致\\n\");\n                s2 = m-1;\n            }\n        }\n//        log.printf(\"comp(%d %d %d) = %d\\n\", l, t, size, s1);\n        return s1;\n    }\n\n    boolean main() throws IOException {\n\n        String S = systemin.readLine();\n        int[] ir = readIntArray();\n\n        if (S.length() < 200)\n            log.printf(\"%s\\n\", S);\n    \n        hash = new long[S.length() + 1];\n        base = new long[S.length() + 1];\n\n        hash[0] = 0;\n        base[0] = 1;\n        for(int i = 0; i < S.length(); i++) {\n            hash[i + 1] = hash[i] * K + S.charAt(i);\n            base[i + 1] = base[i] * K;\n        }\n\n        int Q = ir[0];\n        for(int q = 0; q < Q; q++) {\n//          #unmatch line:63973\n//          [計算] No\n//          [見本] Yes\n//          #unmatch数=1\n                \n\n            ir = readIntArray();\n            int l = ir[0] - 1;\n            int r = ir[1] - 1;\n            int t = ir[2];\n            \n//            if (q != 63972) {\n//                continue;\n////                result.printf(\"Yes\\n\");\n////                continue;\n//            }\n            log.printf(\"-----\\nS.len = %d l, r, t = %d, %d, %d\\n\", S.length(), l, r, t);\n//log.printf(\"[%s]\\n\", S.substring(23032, 23037));\n            \n            int size = r - l + 1 - t;\n            int c1 = comp(l, t, size);\n            int res = 1;\n            if (c1 >= 0) {\n                log.printf(\"c1 %d '%s' '%s'\\n\", c1, S.charAt(c1), S.charAt(c1 + t));\n                l = c1 + 1;\n                size = r - l + 1 - t;\n                int c2 = comp(l, t, size);\n                if (c2 >= 0) {\n                    log.printf(\"c2 %d '%s' '%s'\\n\", c2, S.charAt(c2), S.charAt(c2 + t));\n                    if (c2 != c1 + t) {\n                        res = 0; // だめ\n                    }\n                    else if (c2 + t <= r && S.charAt(c1) != S.charAt(c2 + t)) {\n                        log.printf(\"dame\\n\");\n                        res = 0; // だめ\n                    }\n                    else {\n                        l = c2 + 1;\n                        size = r - l + 1 - t;\n                        int c3 = comp(l, t, size);\n                        if (c3 >= 0) {\n                            res = 0; // NG\n                        }\n                    }\n                }\n            }\n\n            if (res > 0)\n                result.printf(\"Yes\\n\");\n            else\n                result.printf(\"No\\n\");\n        }\n\n        //return true; // 正常終了 次へ\n        return false;\n    }\n\n\tboolean main2() throws IOException {\n\n\t    String S = systemin.readLine();\n\t\tint[] ir = readIntArray();\n\t\tint Q = ir[0];\n\n\t\tfor(int q = 0; q < Q; q++) {\n            ir = readIntArray();\n            int l = ir[0];\n            int r = ir[1];\n            int t = ir[2];\n            if (r - l + 1 -1 <= t) {\n                result.printf(\"Yes\\n\");\n            }\n            else {\n            //log.printf(\"%s %d %d %d\\n\", S, l, r, t);\n\n            int dcnt = 0; // 変更が必要な文字数 1ならYes\n            loop:for(int i = 0; i < t; i++) {\n                int cnt2 = 0; // 2文字以上の文字の数\n\n                // 初回\n                int k = i + l;\n                int ch = S.charAt(k - 1);\n                int ac = 1; // 登録した文字の種類の数\n                int ch0 = ch;\n                int cnt0 = 1;\n                int ch1 = 0;\n                int cnt1 = 0;\n\n                for(int j = 1;; j++) {\n                    k = j * t + i + l;\n                    if (k > r)\n                        break;\n                    ch = S.charAt(k - 1);\n                    //log.printf(\"i=%d j = %d index = %d '%c'\\n\", i, j, k, ch);\n                    if (ch == ch0) {\n                        if (++cnt0 == 2) {\n                            if (++cnt2 >= 2) {\n                                dcnt = 99;\n                                break loop;\n                            }\n                        }\n                    }\n                    else if (ch == ch1) {\n                        if (++cnt1 == 2) {\n                            if (++cnt2 >= 2) {\n                                dcnt = 99;\n                                break loop;\n                            }\n                        }\n                    }\n                    else if (ac == 2) {\n                        dcnt = 99;\n                        break loop;\n                    }\n                    else { // ac == 1\n                        if (dcnt >= 1) {\n                            dcnt = 99;\n                            break loop;\n                        }\n                        ac = 2;\n                        ch1 = ch;\n                        cnt1 = 1;\n                    }\n                }\n                if (ac == 2) {\n                    ++dcnt;\n//                    if (dcnt >= 2)\n//                        break loop;\n                }\n            } // loop\n            //log.printf(\"dcnt = %d\\n\", dcnt);\n            if (dcnt <= 1)\n                result.printf(\"Yes\\n\");\n            else\n                result.printf(\"No\\n\");\n            }\n\t\t}\n        //return true; // 正常終了 次へ\n\t\treturn false;\n\t}\n\n\tstatic long time0;\n\n    PrintStream log;\n    PrintStream result;\n    BufferedReader systemin;\n\n    static Main instance = new Main();\n\n    Main() {\n        systemin = new BufferedReader(new InputStreamReader(System.in));\n        result = System.out;\n        log = new PrintStream(new OutputStream() { public void write(int b) {} } );\n    }\n\n\tpublic static void main(String[] args) throws IOException {\n\n//\t    instance.main0();\n//\t    if (true)\n//\t        System.exit(0);\n\n\t\tint N = Integer.MAX_VALUE;\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tboolean b = instance.main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\n\n        instance.systemin.close();\n\t}\n\n\t// 標準入力より1行分の区切り文字区切りでの整数値を読む\n\t// EOFの場合はnullを返す\n\tprivate int[] readIntArray() throws IOException {\n\n\t\tString s = null;\n\t\tfor(;;) {\n\t\t\ts = systemin.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\ts = s.trim();\n\t\t\tif (s.length() != 0) // 突然空行を読むことがある。読み飛ばすとうまくいくらしい\n\t\t\t\tbreak;\n\t\t}\n\n\t\tString[] sp = s.split(\"[ ,]\"); // 区切り文字はスペースかカンマ\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\n\n/**\n * AIZU ONLINE JUDGE\n * 2711 Nearly Cyclic String\n *    2018/02/16\n */\npublic class Main {\n\n    long[] hash;\n    long[] base;\n    int K = 111111;\n\n    // lからrのハッシュを求める\n    long getHash(int l, int r) {\n//        log.printf(\"getHash %d %d %d %d\\n\", hash.length, r + 1, l, r - l + 1);\n        return hash[r + 1] - hash[l] * base[r - l + 1];\n    }\n\n    // lからとl+tからsize文字比較して最初の不一致文字を返す\n    int comp(int l, int t, int size) {\n        if (getHash(l, l + size - 1) == getHash(l+t, l+t + size - 1)) {\n//            log.printf(\"comp(%d %d %d) = -1\\n\", l, t, size, -1);\n            return -1;\n        }\n\n        int s1 = l;\n        int s2 = l + size - 1;\n        while(s1 <= s2) {\n            int m = (s1 + s2) / 2;\n//            log.printf(\"s1 s2 m = %d %d %d  \", s1, s2, m);\n            if (getHash(l, m) == getHash(l+t, m+t)) {\n//                log.printf(\"一致\\n\");\n                s1 = m + 1;\n            }\n            else {\n//                log.printf(\"不一致\\n\");\n                s2 = m-1;\n            }\n        }\n//        log.printf(\"comp(%d %d %d) = %d\\n\", l, t, size, s1);\n        return s1;\n    }\n\n    boolean main() throws IOException {\n\n        String S = systemin.readLine();\n        int[] ir = readIntArray();\n\n        if (S.length() < 200)\n            log.printf(\"%s\\n\", S);\n    \n        hash = new long[S.length() + 1];\n        base = new long[S.length() + 1];\n\n        hash[0] = 0;\n        base[0] = 1;\n        for(int i = 0; i < S.length(); i++) {\n            hash[i + 1] = hash[i] * K + S.charAt(i);\n            base[i + 1] = base[i] * K;\n        }\n\n        int Q = ir[0];\n        for(int q = 0; q < Q; q++) {\n\n            ir = readIntArray();\n            int l = ir[0] - 1;\n            int r = ir[1] - 1;\n            int t = ir[2];\n            log.printf(\"-----\\nS.len = %d l, r, t = %d, %d, %d\\n\", S.length(), l, r, t);\n            int size = r - l + 1 - t;\n            int c1 = comp(l, t, size);\n            int res = 1;\n            if (c1 >= 0) {\n                log.printf(\"c1 %d '%s' '%s'\\n\", c1, S.charAt(c1), S.charAt(c1 + t));\n                l = c1 + 1;\n                size = r - l + 1 - t;\n                int c2 = comp(l, t, size);\n                if (c2 >= 0) {\n                    log.printf(\"c2 %d '%s' '%s'\\n\", c2, S.charAt(c2), S.charAt(c2 + t));\n                    if (c2 != c1 + t) {\n                        res = 0; // だめ\n                    }\n                    else if (S.charAt(c1) != S.charAt(c2 + t * 2)) {\n                        log.printf(\"dame\\n\");\n                        res = 0; // だめ\n                    }\n                    else {\n                        l = c2 + 1;\n                        size = r - l + 1 - t;\n                        int c3 = comp(l, t, size);\n                        if (c3 >= 0) {\n                            res = 0; // NG\n                        }\n                    }\n                }\n            }\n\n            if (res > 0)\n                result.printf(\"Yes\\n\");\n            else\n                result.printf(\"No\\n\");\n        }\n\n        //return true; // 正常終了 次へ\n        return false;\n    }\n\n\tboolean main2() throws IOException {\n\n\t    String S = systemin.readLine();\n\t\tint[] ir = readIntArray();\n\t\tint Q = ir[0];\n\n\t\tfor(int q = 0; q < Q; q++) {\n\n            ir = readIntArray();\n            int l = ir[0];\n            int r = ir[1];\n            int t = ir[2];\n            if (r - l + 1 -1 <= t) {\n                result.printf(\"Yes\\n\");\n            }\n            else {\n            //log.printf(\"%s %d %d %d\\n\", S, l, r, t);\n\n            int dcnt = 0; // 変更が必要な文字数 1ならYes\n            loop:for(int i = 0; i < t; i++) {\n                int cnt2 = 0; // 2文字以上の文字の数\n\n                // 初回\n                int k = i + l;\n                int ch = S.charAt(k - 1);\n                int ac = 1; // 登録した文字の種類の数\n                int ch0 = ch;\n                int cnt0 = 1;\n                int ch1 = 0;\n                int cnt1 = 0;\n\n                for(int j = 1;; j++) {\n                    k = j * t + i + l;\n                    if (k > r)\n                        break;\n                    ch = S.charAt(k - 1);\n                    //log.printf(\"i=%d j = %d index = %d '%c'\\n\", i, j, k, ch);\n                    if (ch == ch0) {\n                        if (++cnt0 == 2) {\n                            if (++cnt2 >= 2) {\n                                dcnt = 99;\n                                break loop;\n                            }\n                        }\n                    }\n                    else if (ch == ch1) {\n                        if (++cnt1 == 2) {\n                            if (++cnt2 >= 2) {\n                                dcnt = 99;\n                                break loop;\n                            }\n                        }\n                    }\n                    else if (ac == 2) {\n                        dcnt = 99;\n                        break loop;\n                    }\n                    else { // ac == 1\n                        if (dcnt >= 1) {\n                            dcnt = 99;\n                            break loop;\n                        }\n                        ac = 2;\n                        ch1 = ch;\n                        cnt1 = 1;\n                    }\n                }\n                if (ac == 2) {\n                    ++dcnt;\n//                    if (dcnt >= 2)\n//                        break loop;\n                }\n            } // loop\n            //log.printf(\"dcnt = %d\\n\", dcnt);\n            if (dcnt <= 1)\n                result.printf(\"Yes\\n\");\n            else\n                result.printf(\"No\\n\");\n            }\n\t\t}\n        //return true; // 正常終了 次へ\n\t\treturn false;\n\t}\n\n\tstatic long time0;\n\n    PrintStream log;\n    PrintStream result;\n    BufferedReader systemin;\n\n    static Main instance = new Main();\n\n    Main() {\n        systemin = new BufferedReader(new InputStreamReader(System.in));\n        result = System.out;\n        log = new PrintStream(new OutputStream() { public void write(int b) {} } );\n    }\n\n\tpublic static void main(String[] args) throws IOException {\n\n//\t    instance.main0();\n//\t    if (true)\n//\t        System.exit(0);\n\n\t\tint N = Integer.MAX_VALUE;\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tboolean b = instance.main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\n\n        instance.systemin.close();\n\t}\n\n\t// 標準入力より1行分の区切り文字区切りでの整数値を読む\n\t// EOFの場合はnullを返す\n\tprivate int[] readIntArray() throws IOException {\n\n\t\tString s = null;\n\t\tfor(;;) {\n\t\t\ts = systemin.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\ts = s.trim();\n\t\t\tif (s.length() != 0) // 突然空行を読むことがある。読み飛ばすとうまくいくらしい\n\t\t\t\tbreak;\n\t\t}\n\n\t\tString[] sp = s.split(\"[ ,]\"); // 区切り文字はスペースかカンマ\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\n\n/**\n * AIZU ONLINE JUDGE\n * 2711 Nearly Cyclic String\n *    2018/02/16\n */\npublic class Main {\n\n\tboolean main() throws IOException {\n\n\t    String S = systemin.readLine();\n\t\tint[] ir = readIntArray();\n\t\tint Q = ir[0];\n\n\t\tfor(int q = 0; q < Q; q++) {\n\n        ir = readIntArray();\n        int l = ir[0];\n        int r = ir[1];\n        int t = ir[2];\n        //log.printf(\"%s %d %d %d\\n\", S, l, r, t);\n\n        int dcnt = 0;\n        loop:for(int i = 0; i < t; i++) {\n            int[] c = new int[2];\n            int[] cnt = new int[2];\n            int ac = 0;\n            for(int j = 0;; j++) {\n                int k = j * t + i + l;\n                if (k > r)\n                    break;\n                int ch = S.charAt(k - 1);\n                //log.printf(\"i=%d j = %d index = %d '%c'\\n\", i, j, k, ch);\n                for(int p = 0;; p++) {\n                    if (p >= 2) {\n                        dcnt = 99;\n                        break loop;\n                    }\n                    if (p >= ac) {\n                        c[p] = ch;\n                        cnt[p] = 1;\n                        ac++;\n                        break;\n                    }\n                    if (c[p] == ch) {\n                        cnt[p]++;\n                        break;\n                    }\n                }\n            }\n            if (ac == 2) {\n                if (cnt[0] == 1 || cnt[1] == 1) {\n                    dcnt++;\n                    if (dcnt >= 2)\n                        break loop;\n                }\n                else {\n                    dcnt = 99;\n                    break loop;\n                }\n            }\n        }\n        //log.printf(\"dcnt = %d\\n\", dcnt);\n        if (dcnt <= 1)\n            result.printf(\"Yes\\n\");\n        else\n            result.printf(\"No\\n\");\n\t\t}\n        //return true; // 正常終了 次へ\n\t\treturn false;\n\t}\n\n\tstatic long time0;\n\n    PrintStream log;\n    PrintStream result;\n    BufferedReader systemin;\n\n    static Main instance = new Main();\n\n    Main() {\n        systemin = new BufferedReader(new InputStreamReader(System.in));\n        result = System.out;\n        log = new PrintStream(new OutputStream() { public void write(int b) {} } );\n    }\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tint N = Integer.MAX_VALUE;\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tboolean b = instance.main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\n\n        instance.systemin.close();\n\t}\n\n\t// 標準入力より1行分の区切り文字区切りでの整数値を読む\n\t// EOFの場合はnullを返す\n\tprivate int[] readIntArray() throws IOException {\n\n\t\tString s = null;\n\t\tfor(;;) {\n\t\t\ts = systemin.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\ts = s.trim();\n\t\t\tif (s.length() != 0) // 突然空行を読むことがある。読み飛ばすとうまくいくらしい\n\t\t\t\tbreak;\n\t\t}\n\n\t\tString[] sp = s.split(\"[ ,]\"); // 区切り文字はスペースかカンマ\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\n\n/**\n * AIZU ONLINE JUDGE\n * 2711 Nearly Cyclic String\n *    2018/02/16\n */\npublic class Main {\n\n    long[] hash;\n    long[] base;\n    int K = 29; //1777771; //29;\n\n    // lからrのハッシュを求める\n    long getHash(int l, int r) {\n//        log.printf(\"getHash %d %d %d %d\\n\", hash.length, r + 1, l, r - l + 1);\n        return hash[r + 1] - hash[l] * base[r - l + 1];\n    }\n\n    // lからとl+tからsize文字比較して最初の不一致文字を返す\n    int comp(int l, int t, int size) {\n        if (getHash(l, l + size - 1) == getHash(l+t, l+t + size - 1)) {\n//            log.printf(\"comp(%d %d %d) = -1\\n\", l, t, size, -1);\n            return -1;\n        }\n\n        int s1 = l;\n        int s2 = l + size - 1;\n        while(s1 <= s2) {\n            int m = (s1 + s2) / 2;\n//            log.printf(\"s1 s2 m = %d %d %d  \", s1, s2, m);\n            if (getHash(l, m) == getHash(l+t, m+t)) {\n//                log.printf(\"一致\\n\");\n                s1 = m + 1;\n            }\n            else {\n//                log.printf(\"不一致\\n\");\n                s2 = m-1;\n            }\n        }\n//        log.printf(\"comp(%d %d %d) = %d\\n\", l, t, size, s1);\n        return s1;\n    }\n\n    boolean main() throws IOException {\n\n        String S = systemin.readLine();\n        int[] ir = readIntArray();\n\n        if (S.length() < 200)\n            log.printf(\"%s\\n\", S);\n    \n        hash = new long[S.length() + 1];\n        base = new long[S.length() + 1];\n\n        hash[0] = 0;\n        base[0] = 1;\n        for(int i = 0; i < S.length(); i++) {\n            hash[i + 1] = hash[i] * K + S.charAt(i);\n            base[i + 1] = base[i] * K;\n        }\n\n        int Q = ir[0];\n        for(int q = 0; q < Q; q++) {\n//          #unmatch line:63973\n//          [計算] No\n//          [見本] Yes\n//          #unmatch数=1\n                \n\n            ir = readIntArray();\n            int l = ir[0] - 1;\n            int r = ir[1] - 1;\n            int t = ir[2];\n            \n//            if (q != 63972) {\n//                continue;\n////                result.printf(\"Yes\\n\");\n////                continue;\n//            }\n            log.printf(\"-----\\nS.len = %d l, r, t = %d, %d, %d\\n\", S.length(), l, r, t);\n//log.printf(\"[%s]\\n\", S.substring(23032, 23037));\n            \n            int size = r - l + 1 - t;\n            int c1 = comp(l, t, size);\n            int res = 1;\n            if (c1 >= 0) {\n                log.printf(\"c1 %d '%s' '%s'\\n\", c1, S.charAt(c1), S.charAt(c1 + t));\n                l = c1 + 1;\n                size = r - l + 1 - t;\n                int c2 = comp(l, t, size);\n                if (c2 >= 0) {\n                    log.printf(\"c2 %d '%s' '%s'\\n\", c2, S.charAt(c2), S.charAt(c2 + t));\n                    if (c2 != c1 + t) {\n                        res = 0; // だめ\n                    }\n                    else if (c2 + t * 2 < l && S.charAt(c1) != S.charAt(c2 + t * 2)) {\n                        log.printf(\"dame\\n\");\n                        res = 0; // だめ\n                    }\n                    else {\n                        l = c2 + 1;\n                        size = r - l + 1 - t;\n                        int c3 = comp(l, t, size);\n                        if (c3 >= 0) {\n                            res = 0; // NG\n                        }\n                    }\n                }\n            }\n\n            if (res > 0)\n                result.printf(\"Yes\\n\");\n            else\n                result.printf(\"No\\n\");\n        }\n\n        //return true; // 正常終了 次へ\n        return false;\n    }\n\n\tboolean main2() throws IOException {\n\n\t    String S = systemin.readLine();\n\t\tint[] ir = readIntArray();\n\t\tint Q = ir[0];\n\n\t\tfor(int q = 0; q < Q; q++) {\n            ir = readIntArray();\n            int l = ir[0];\n            int r = ir[1];\n            int t = ir[2];\n            if (r - l + 1 -1 <= t) {\n                result.printf(\"Yes\\n\");\n            }\n            else {\n            //log.printf(\"%s %d %d %d\\n\", S, l, r, t);\n\n            int dcnt = 0; // 変更が必要な文字数 1ならYes\n            loop:for(int i = 0; i < t; i++) {\n                int cnt2 = 0; // 2文字以上の文字の数\n\n                // 初回\n                int k = i + l;\n                int ch = S.charAt(k - 1);\n                int ac = 1; // 登録した文字の種類の数\n                int ch0 = ch;\n                int cnt0 = 1;\n                int ch1 = 0;\n                int cnt1 = 0;\n\n                for(int j = 1;; j++) {\n                    k = j * t + i + l;\n                    if (k > r)\n                        break;\n                    ch = S.charAt(k - 1);\n                    //log.printf(\"i=%d j = %d index = %d '%c'\\n\", i, j, k, ch);\n                    if (ch == ch0) {\n                        if (++cnt0 == 2) {\n                            if (++cnt2 >= 2) {\n                                dcnt = 99;\n                                break loop;\n                            }\n                        }\n                    }\n                    else if (ch == ch1) {\n                        if (++cnt1 == 2) {\n                            if (++cnt2 >= 2) {\n                                dcnt = 99;\n                                break loop;\n                            }\n                        }\n                    }\n                    else if (ac == 2) {\n                        dcnt = 99;\n                        break loop;\n                    }\n                    else { // ac == 1\n                        if (dcnt >= 1) {\n                            dcnt = 99;\n                            break loop;\n                        }\n                        ac = 2;\n                        ch1 = ch;\n                        cnt1 = 1;\n                    }\n                }\n                if (ac == 2) {\n                    ++dcnt;\n//                    if (dcnt >= 2)\n//                        break loop;\n                }\n            } // loop\n            //log.printf(\"dcnt = %d\\n\", dcnt);\n            if (dcnt <= 1)\n                result.printf(\"Yes\\n\");\n            else\n                result.printf(\"No\\n\");\n            }\n\t\t}\n        //return true; // 正常終了 次へ\n\t\treturn false;\n\t}\n\n\tstatic long time0;\n\n    PrintStream log;\n    PrintStream result;\n    BufferedReader systemin;\n\n    static Main instance = new Main();\n\n    Main() {\n        systemin = new BufferedReader(new InputStreamReader(System.in));\n        result = System.out;\n        log = new PrintStream(new OutputStream() { public void write(int b) {} } );\n    }\n\n\tpublic static void main(String[] args) throws IOException {\n\n//\t    instance.main0();\n//\t    if (true)\n//\t        System.exit(0);\n\n\t\tint N = Integer.MAX_VALUE;\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tboolean b = instance.main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\n\n        instance.systemin.close();\n\t}\n\n\t// 標準入力より1行分の区切り文字区切りでの整数値を読む\n\t// EOFの場合はnullを返す\n\tprivate int[] readIntArray() throws IOException {\n\n\t\tString s = null;\n\t\tfor(;;) {\n\t\t\ts = systemin.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\ts = s.trim();\n\t\t\tif (s.length() != 0) // 突然空行を読むことがある。読み飛ばすとうまくいくらしい\n\t\t\t\tbreak;\n\t\t}\n\n\t\tString[] sp = s.split(\"[ ,]\"); // 区切り文字はスペースかカンマ\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\n\n/**\n * AIZU ONLINE JUDGE\n * 2711 Nearly Cyclic String\n *    2018/02/16\n */\npublic class Main {\n\n\tboolean main() throws IOException {\n\n\t    String S = systemin.readLine();\n\t\tint[] ir = readIntArray();\n\t\tint Q = ir[0];\n\n\t\tfor(int q = 0; q < Q; q++) {\n\n        ir = readIntArray();\n        int l = ir[0];\n        int r = ir[1];\n        int t = ir[2];\n        log.printf(\"%s %d %d %d\\n\", S, l, r, t);\n\n        int dcnt = 0;\n        loop:for(int i = 0; i < t; i++) {\n            int[] c = new int[2];\n            int[] cnt = new int[2];\n            int ac = 0;\n            for(int j = 0;; j++) {\n                int k = j * t + i + l;\n                if (k > r)\n                    break;\n                int ch = S.charAt(k - 1);\n                log.printf(\"i=%d j = %d index = %d '%c'\\n\", i, j, k, ch);\n                for(int p = 0;; p++) {\n                    if (p >= 2) {\n                        dcnt = 99;\n                        break loop;\n                    }\n                    if (p >= ac) {\n                        c[p] = ch;\n                        cnt[p] = 1;\n                        ac++;\n                        break;\n                    }\n                    if (c[p] == ch) {\n                        cnt[p]++;\n                        break;\n                    }\n                }\n            }\n            if (ac == 2) {\n                if (cnt[0] == 1 || cnt[1] == 1) {\n                    dcnt++;\n                }\n                else {\n                    dcnt = 99;\n                    break loop;\n                }\n            }\n        }\n        log.printf(\"dcnt = %d\\n\", dcnt);\n        if (dcnt <= 1)\n            result.printf(\"Yes\\n\");\n        else\n            result.printf(\"No\\n\");\n\t\t}\n        //return true; // 正常終了 次へ\n\t\treturn false;\n\t}\n\n\tstatic long time0;\n\n    PrintStream log;\n    PrintStream result;\n    BufferedReader systemin;\n\n    static Main instance = new Main();\n\n    Main() {\n        systemin = new BufferedReader(new InputStreamReader(System.in));\n        result = System.out;\n        log = new PrintStream(new OutputStream() { public void write(int b) {} } );\n    }\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tint N = Integer.MAX_VALUE;\n\t\t//int N = readIntArray()[0];\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tboolean b = instance.main();\n\t\t\tif (!b)\n\t\t\t\tbreak;\n\t\t}\n\n        instance.systemin.close();\n\t}\n\n\t// 標準入力より1行分の区切り文字区切りでの整数値を読む\n\t// EOFの場合はnullを返す\n\tprivate int[] readIntArray() throws IOException {\n\n\t\tString s = null;\n\t\tfor(;;) {\n\t\t\ts = systemin.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\ts = s.trim();\n\t\t\tif (s.length() != 0) // 突然空行を読むことがある。読み飛ばすとうまくいくらしい\n\t\t\t\tbreak;\n\t\t}\n\n\t\tString[] sp = s.split(\"[ ,]\"); // 区切り文字はスペースかカンマ\n\t\tint[] a = new int[sp.length];\n\t\tfor(int i = 0; i < sp.length; i++) {\n\t\t\ta[i] = Integer.parseInt(sp[i]);\n\t\t}\n\t\treturn a;\n\t}\n\n}\n\n\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.functional;\nimport std.range;\nimport std.ascii;\nimport std.array;\nimport std.container;\nimport std.conv;\nimport std.numeric;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nlong extgcd(long a, long b, ref long x, ref long y) {\n    long g = a; x = 1; y = 0;\n    if (b != 0) {\n        g = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    }\n    return g;\n}\nlong inverse(long mod, long v) {\n    long x, y;\n    if (extgcd(v, mod, x, y) == 1) return (x + mod) % mod;\n    return 0;\n}\n\nconst long P = 10000481L;\nconst long[] mods = [999999937L, 1000000123L, 1000000207L];\nlong[][] pow;\nstatic this() {\n    const int N = cast(int)1e5 + 5;\n    pow = new long[][](mods.length, N + 1);\n    foreach (k, mod; mods) {\n        pow[k][0] = 1L;\n        foreach (n; 0 .. N) {\n            pow[k][n + 1] = pow[k][n] * P % mod;\n        }\n    }\n}\n\nclass RollingHash {\n    long[] H;\n    long mod;\n    long P;\n    int mod_index;\n    this(long P, long mod, int mod_index, in string s) { \n        this.mod = mod;\n        this.mod_index = mod_index;\n        this.P = P;\n        auto N = s.length;\n        this.H = new long[N + 1]; // H[k]: s[0]*P^(n-1) + s[1]*P^(n-2) + ... + s[n-1]*P^0\n        foreach (int i, c; s) {\n            H[i + 1] = (H[i] * P + cast(int)(c)) % mod;\n        }\n    }\n    long hash(int l, int r) { // [l, r)\n        return (H[r] - H[l] * pow[mod_index][r - l] % mod + mod) % mod;\n    }\n}\n\nvoid main() {\n    auto s = readln.chomp;\n    int N = s.size;\n    int Q = readln.chomp.to!int;\n\n    auto P_exp = new bool[long][mods.length];\n    foreach (k, mod; mods) {\n        long p = 1;\n        P_exp[k][p] = true;\n        foreach (n; 0 .. N + 2) {\n            p = (p * P) % mod;\n            P_exp[k][p] = true;\n        }\n    }\n\n    auto hashers = iota(0, mods.length, 1).map!((k) => new RollingHash(P, mods[k], k, s)).array;\n\n    foreach (_; 0 .. Q) {\n        //log(_);\n        int l, r, t; \n        scanf(\"%d %d %d\\n\", &l, &r, &t);\n        l--;\n\n        auto k = (r - l) / t;\n        auto m = r - l - t * k;\n        //log([l, r, t, k, m]);\n\n        auto ans = new bool[hashers.length];\n        foreach (j, ref hasher; hashers) {\n            auto mod = hasher.mod;\n            assert(mod == mods[j]);\n            long org = hasher.hash(l, r);\n            auto inv = delegate long(long x) { return inverse(mod, x); };\n\n            long cycle_hash(int z) {\n                long a = hasher.hash(l + t * z, l + t * z + t);\n                return (a * (pow[j][t * k] - 1L) % mod * inv(pow[j][t] - 1L) % mod * pow[j][m] % mod \n                        + hasher.hash(l + t*z, l + t*z + m)) % mod;\n            }\n\n            foreach (z; [0, 1]) {\n                if (l + t * z + t > r) continue;\n                auto diff = (org - cycle_hash(z) + mod) % mod;\n                if (diff == 0) { ans[j] = true; }\n                foreach (q; -26 .. 26 + 1) {\n                    long y = q < 0 ? q + mod : q;\n                    if (inv(y) * diff % mod in P_exp[j]) {\n                        ans[j] = true;\n                    }\n                }\n            }\n        }\n        writeln(ans.all ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.functional;\nimport std.range;\nimport std.ascii;\nimport std.array;\nimport std.container;\nimport std.conv;\nimport std.numeric;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nlong extgcd(long a, long b, ref long x, ref long y) {\n    long g = a; x = 1; y = 0;\n    if (b != 0) {\n        g = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    }\n    return g;\n}\nlong inverse(long mod, long v) {\n    long x, y;\n    if (extgcd(v, mod, x, y) == 1) return (x + mod) % mod;\n    return 0;\n}\n\nconst long P = 10000481L;\nconst long[] mods = [999999937L, 1000000123L, 1000000207L];\nlong[][] pow;\nstatic this() {\n    const int N = cast(int)1e5 + 5;\n    pow = new long[][](mods.length, N + 1);\n    foreach (k, mod; mods) {\n        pow[k][0] = 1L;\n        foreach (n; 0 .. N) {\n            pow[k][n + 1] = pow[k][n] * P % mod;\n        }\n    }\n}\n\nclass RollingHash {\n    long[] H;\n    long mod;\n    long P;\n    int mod_index;\n    this(long P, long mod, int mod_index, in string s) { \n        this.mod = mod;\n        this.mod_index = mod_index;\n        this.P = P;\n        auto N = s.length;\n        this.H = new long[N + 1]; // H[k]: s[0]*P^(n-1) + s[1]*P^(n-2) + ... + s[n-1]*P^0\n        foreach (int i, c; s) {\n            H[i + 1] = (H[i] * P + cast(int)(c)) % mod;\n        }\n    }\n    long hash(int l, int r) { // [l, r)\n        return (H[r] - H[l] * pow[mod_index][r - l] % mod + mod) % mod;\n    }\n}\n\nvoid main() {\n    auto s = readln.chomp;\n    int N = s.size;\n    int Q = readln.chomp.to!int;\n\n    auto P_exp = new bool[long][mods.length];\n    foreach (k, mod; mods) {\n        long p = 1;\n        P_exp[k][p] = true;\n        foreach (n; 0 .. N + 2) {\n            p = (p * P) % mod;\n            P_exp[k][p] = true;\n        }\n    }\n\n    auto hashers = iota(0, mods.length, 1).map!((k) => new RollingHash(P, mods[k], cast(int)k, s)).array;\n\n    auto inv_cache = new long[][](mods.length, 70);\n    foreach (k, mod; mods) {\n        foreach (q; -25 .. 25 + 1) {\n            long y = q < 0 ? q + mod : q;\n            inv_cache[k][q + 30] = inverse(mod, y);\n        }\n    }\n\n    foreach (_; 0 .. Q) {\n        //log(_);\n        int l, r, t; \n        scanf(\"%d %d %d\\n\", &l, &r, &t);\n        l--;\n\n        auto k = (r - l) / t;\n        auto m = r - l - t * k;\n        //log([l, r, t, k, m]);\n\n        auto ans = new bool[hashers.length];\n        foreach (j, ref hasher; hashers) {\n            auto mod = hasher.mod;\n            long org = hasher.hash(l, r);\n            auto inv = delegate long(long x) { return inverse(mod, x); };\n\n            long cycle_hash(int z) {\n                long a = hasher.hash(l + t * z, l + t * z + t);\n                return (a * (pow[j][t * k] - 1L) % mod * inv(pow[j][t] - 1L) % mod * pow[j][m] % mod \n                        + hasher.hash(l + t*z, l + t*z + m)) % mod;\n            }\n\n            foreach (z; [0, 1]) {\n                if (l + t * z + t > r) continue;\n                auto diff = (org - cycle_hash(z) + mod) % mod;\n                if (diff == 0) { ans[j] = true;  goto next;}\n                foreach (q; -25 .. 25 + 1) {\n                    if (inv_cache[j][q + 30] * diff % mod in P_exp[j]) {\n                        ans[j] = true;\n                        goto next;\n                    }\n                }\n            }\n            if (! ans[j]) break;\n            next:;\n        }\n        writeln(ans.all ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.functional;\nimport std.range;\nimport std.ascii;\nimport std.array;\nimport std.container;\nimport std.conv;\nimport std.numeric;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nlong extgcd(long a, long b, ref long x, ref long y) {\n    long g = a; x = 1; y = 0;\n    if (b != 0) {\n        g = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    }\n    return g;\n}\nlong inverse(long mod, long v) {\n    long x, y;\n    if (extgcd(v, mod, x, y) == 1) return (x + mod) % mod;\n    return 0;\n}\n\nconst long P = 10000481L;\nconst long[] mods = [999999937L, 1000000123L, 1000000207L];\nlong[][] pow;\nstatic this() {\n    const int N = cast(int)1e5 + 5;\n    pow = new long[][](mods.length, N + 1);\n    foreach (k, mod; mods) {\n        pow[k][0] = 1L;\n        foreach (n; 0 .. N) {\n            pow[k][n + 1] = pow[k][n] * P % mod;\n        }\n    }\n}\n\nclass RollingHash {\n    long[] H;\n    long mod;\n    long P;\n    int mod_index;\n    this(long P, long mod, int mod_index, in string s) { \n        this.mod = mod;\n        this.mod_index = mod_index;\n        this.P = P;\n        auto N = s.length;\n        this.H = new long[N + 1]; // H[k]: s[0]*P^(n-1) + s[1]*P^(n-2) + ... + s[n-1]*P^0\n        foreach (int i, c; s) {\n            H[i + 1] = (H[i] * P + cast(int)(c)) % mod;\n        }\n    }\n    long hash(int l, int r) { // [l, r)\n        return (H[r] - H[l] * pow[mod_index][r - l] % mod + mod) % mod;\n    }\n}\n\nvoid main() {\n    auto s = readln.chomp;\n    int N = s.size;\n    int Q = readln.chomp.to!int;\n\n    auto P_exp = new bool[long][mods.length];\n    foreach (k, mod; mods) {\n        long p = 1;\n        P_exp[k][p] = true;\n        foreach (n; 0 .. N + 2) {\n            p = (p * P) % mod;\n            P_exp[k][p] = true;\n        }\n    }\n\n    auto hashers = iota(0, mods.length, 1).map!((k) => new RollingHash(P, mods[k], cast(int)k, s)).array;\n\n    auto inv_cache = new long[][](mods.length, 70);\n    foreach (k, mod; mods) {\n        foreach (q; -26 .. 26 + 1) {\n            long y = q < 0 ? q + mod : q;\n            inv_cache[k][q + 30] = inverse(mod, y);\n        }\n    }\n\n    foreach (_; 0 .. Q) {\n        //log(_);\n        int l, r, t; \n        scanf(\"%d %d %d\\n\", &l, &r, &t);\n        l--;\n\n        auto k = (r - l) / t;\n        auto m = r - l - t * k;\n        //log([l, r, t, k, m]);\n\n        auto ans = new bool[hashers.length];\n        foreach (j, ref hasher; hashers) {\n            auto mod = hasher.mod;\n            assert(mod == mods[j]);\n            long org = hasher.hash(l, r);\n            auto inv = delegate long(long x) { return inverse(mod, x); };\n\n            long cycle_hash(int z) {\n                long a = hasher.hash(l + t * z, l + t * z + t);\n                return (a * (pow[j][t * k] - 1L) % mod * inv(pow[j][t] - 1L) % mod * pow[j][m] % mod \n                        + hasher.hash(l + t*z, l + t*z + m)) % mod;\n            }\n\n            foreach (z; [0, 1]) {\n                if (l + t * z + t > r) continue;\n                auto diff = (org - cycle_hash(z) + mod) % mod;\n                if (diff == 0) { ans[j] = true; }\n                foreach (q; -26 .. 26 + 1) {\n                    if (inv_cache[j][q + 30] * diff % mod in P_exp[j]) {\n                        ans[j] = true;\n                    }\n                }\n            }\n        }\n        writeln(ans.all ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.range;\nimport std.ascii;\nimport std.array;\nimport std.container;\nimport std.conv;\nimport std.numeric;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nlong modPow(long mod, long x, long n) {\n    x %= mod;\n    if (n == 0) return 1;\n    if (n % 2 == 0) return modPow(mod, x * x % mod, n / 2);\n    return x * modPow(mod, x % mod, n - 1) % mod;\n}\n\nlong extgcd(long a, long b, ref long x, ref long y) {\n    long g = a; x = 1; y = 0;\n    if (b != 0) {\n        g = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    }\n    return g;\n}\nlong inverse(long mod, long v) {\n    long x, y;\n    if (extgcd(v, mod, x, y) == 1) return (x + mod) % mod;\n    return 0;\n}\n\nclass RollingHash {\n    long[] H;\n    long mod;\n    long P;\n    this(long P, long mod, in string s) { \n        this.mod = mod;\n        this.P = P;\n        auto N = s.length;\n        this.H = new long[N + 1]; // H[k]: s[0]*P^(n-1) + s[1]*P^(n-2) + ... + s[n-1]*P^0\n        foreach (int i, c; s) {\n            H[i + 1] = (H[i] * P + cast(int)(c)) % mod;\n        }\n    }\n    long hash(int l, int r) { // [l, r)\n        return (H[r] - H[l] * modPow(mod, P, r - l) % mod + mod) % mod;\n    }\n}\n\nconst long P = 10000481L;\nconst long[] mods = [1000000123L, 1000000207L, 1000000363L];\nvoid main() {\n    auto s = readln.chomp;\n    int N = s.size;\n    int Q = readln.chomp.to!int;\n\n    auto P_exp = new bool[long][mods.length];\n    foreach (k, mod; mods) {\n        long p = 1;\n        P_exp[k][p] = true;\n        foreach (n; 0 .. N + 2) {\n            p = (p * P) % mod;\n            P_exp[k][p] = true;\n        }\n    }\n\n    auto hashers = iota(0, mods.length, 1).map!((k) => new RollingHash(P, mods[k], s)).array;\n\n    foreach (_; 0 .. Q) {\n        int l, r, t; \n        scanf(\"%d %d %d\\n\", &l, &r, &t);\n        l--;\n\n        auto k = (r - l) / t;\n        auto m = r - l - t * k;\n        //log([l, r, t, k, m]);\n        \n        auto ans = new bool[hashers.length];\n        foreach (j, ref hasher; hashers) {\n            auto mod = hasher.mod;\n            assert(mod == mods[j]);\n            long org = hasher.hash(l, r);\n            auto pow = delegate long(long x, long n) { return modPow(mod, x, n); };\n            auto inv = delegate long(long x) { return inverse(mod, x); };\n            auto Pt = pow(P, t);\n\n            long cycle_hash(int z) {\n                long a = hasher.hash(l + t * z, l + t * z + t);\n                return (a * ( (pow(Pt, k) - 1 + mod) % mod ) % mod * inv( (pow(P, t) - 1 + mod) % mod ) % mod * pow(P, m) % mod \n                        + hasher.hash(l + t*z, l + t*z + m)) % mod;\n            }\n\n            foreach (z; [0, 1]) {\n                if (l + t * z + t > r) continue;\n                auto diff = (org - cycle_hash(z) + mod) % mod;\n                if (diff == 0) { ans[j] = true; }\n                foreach (q; -26 .. 26 + 1) {\n                    long y = q < 0 ? q + mod : q;\n                    if (inv(y) * diff % mod in P_exp[j]) {\n                        ans[j] = true;\n                    }\n                }\n            }\n        }\n        writeln(ans.all ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.meta;\nimport std.range;\nimport std.ascii;\nimport std.array;\nimport std.container;\nimport std.conv;\nimport std.numeric;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nlong modPow(long mod, long x, long n) {\n    x %= mod;\n    if (n == 0) return 1;\n    if (n % 2 == 0) return modPow(mod, x * x % mod, n / 2);\n    return x * modPow(mod, x % mod, n - 1) % mod;\n}\n\nlong extgcd(long a, long b, ref long x, ref long y) {\n    long g = a; x = 1; y = 0;\n    if (b != 0) {\n        g = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    }\n    return g;\n}\nlong inverse(long mod, long v) {\n    long x, y;\n    if (extgcd(v, mod, x, y) == 1) return (x + mod) % mod;\n    return 0;\n}\n\nclass RollingHash {\n    long[] H;\n    long mod;\n    long P;\n    this(long P, long mod, in string s) { \n        this.mod = mod;\n        this.P = P;\n        auto N = s.length;\n        this.H = new long[N + 1]; // H[k]: s[0]*P^(n-1) + s[1]*P^(n-2) + ... + s[n-1]*P^0\n        foreach (int i, c; s) {\n            H[i + 1] = (H[i] * P + cast(int)(c)) % mod;\n        }\n    }\n    long hash(int l, int r) { // [l, r)\n        return (H[r] - H[l] * modPow(mod, P, r - l) % mod + mod) % mod;\n    }\n}\n\nconst long P = 10000481L;\nconst long[] mods = [1000000123L, 1000000207L, 1000000363L];\nvoid main() {\n    auto s = readln.chomp;\n    int N = s.size;\n    int Q = readln.chomp.to!int;\n\n    auto P_exp = new bool[long][mods.length];\n    foreach (k, mod; mods) {\n        long p = 1;\n        P_exp[k][p] = true;\n        foreach (n; 0 .. N + 2) {\n            p = (p * P) % mod;\n            P_exp[k][p] = true;\n        }\n    }\n\n    auto hashers = iota(0, mods.length, 1).map!((k) => new RollingHash(P, mods[k], s)).array;\n\n    foreach (_; 0 .. Q) {\n        int l, r, t; \n        scanf(\"%d %d %d\\n\", &l, &r, &t);\n        l--;\n\n        auto k = (r - l) / t;\n        auto m = r - l - t * k;\n        //log([l, r, t, k, m]);\n        \n        auto ans = new bool[hashers.length];\n        foreach (j, ref hasher; hashers) {\n            auto mod = hasher.mod;\n            assert(mod == mods[j]);\n            long org = hasher.hash(l, r);\n            alias pow = delegate(x, n) => modPow(mod, x, n);\n            alias inv = delegate(x) => inverse(mod, x);\n            auto Pt = pow(P, t);\n\n            long cycle_hash(int z) {\n                long a = hasher.hash(l + t * z, l + t * z + t);\n                return (a * ( (pow(Pt, k) - 1 + mod) % mod ) % mod * inv( (pow(P, t) - 1 + mod) % mod ) % mod * pow(P, m) % mod \n                        + hasher.hash(l + t*z, l + t*z + m)) % mod;\n            }\n\n            foreach (z; [0, 1]) {\n                if (l + t * z + t > r) continue;\n                auto diff = (org - cycle_hash(z) + mod) % mod;\n                if (diff == 0) { ans[j] = true; }\n                foreach (q; -26 .. 26 + 1) {\n                    long y = q < 0 ? q + mod : q;\n                    if (inv(y) * diff % mod in P_exp[j]) {\n                        ans[j] = true;\n                    }\n                }\n            }\n        }\n        writeln(ans.all ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.functional;\nimport std.range;\nimport std.ascii;\nimport std.array;\nimport std.container;\nimport std.conv;\nimport std.numeric;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nlong extgcd(long a, long b, ref long x, ref long y) {\n    long g = a; x = 1; y = 0;\n    if (b != 0) {\n        g = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    }\n    return g;\n}\nlong inverse(long mod, long v) {\n    long x, y;\n    if (extgcd(v, mod, x, y) == 1) return (x + mod) % mod;\n    return 0;\n}\n\nconst long P = 10000481L;\nconst long[] mods = [999999937L, 1000000123L, 1000000207L];\nlong[][] pow;\nstatic this() {\n    const int N = cast(int)1e5 + 5;\n    pow = new long[][](mods.length, N + 1);\n    foreach (k, mod; mods) {\n        pow[k][0] = 1L;\n        foreach (n; 0 .. N) {\n            pow[k][n + 1] = pow[k][n] * P % mod;\n        }\n    }\n}\n\nclass RollingHash {\n    long[] H;\n    long mod;\n    long P;\n    int mod_index;\n    this(long P, long mod, int mod_index, in string s) { \n        this.mod = mod;\n        this.mod_index = mod_index;\n        this.P = P;\n        auto N = s.length;\n        this.H = new long[N + 1]; // H[k]: s[0]*P^(n-1) + s[1]*P^(n-2) + ... + s[n-1]*P^0\n        foreach (int i, c; s) {\n            H[i + 1] = (H[i] * P + cast(int)(c)) % mod;\n        }\n    }\n    long hash(int l, int r) { // [l, r)\n        return (H[r] - H[l] * pow[mod_index][r - l] % mod + mod) % mod;\n    }\n}\n\nvoid main() {\n    auto s = readln.chomp;\n    int N = s.size;\n    int Q = readln.chomp.to!int;\n\n    auto P_exp = new bool[long][mods.length];\n    foreach (k, mod; mods) {\n        long p = 1;\n        P_exp[k][p] = true;\n        foreach (n; 0 .. N + 2) {\n            p = (p * P) % mod;\n            P_exp[k][p] = true;\n        }\n    }\n\n    auto hashers = iota(0, mods.length, 1).map!((k) => new RollingHash(P, mods[k], cast(int)k, s)).array;\n\n    foreach (_; 0 .. Q) {\n        //log(_);\n        int l, r, t; \n        scanf(\"%d %d %d\\n\", &l, &r, &t);\n        l--;\n\n        auto k = (r - l) / t;\n        auto m = r - l - t * k;\n        //log([l, r, t, k, m]);\n\n        auto ans = new bool[hashers.length];\n        foreach (j, ref hasher; hashers) {\n            auto mod = hasher.mod;\n            assert(mod == mods[j]);\n            long org = hasher.hash(l, r);\n            auto inv = delegate long(long x) { return inverse(mod, x); };\n\n            long cycle_hash(int z) {\n                long a = hasher.hash(l + t * z, l + t * z + t);\n                return (a * (pow[j][t * k] - 1L) % mod * inv(pow[j][t] - 1L) % mod * pow[j][m] % mod \n                        + hasher.hash(l + t*z, l + t*z + m)) % mod;\n            }\n\n            foreach (z; [0, 1]) {\n                if (l + t * z + t > r) continue;\n                auto diff = (org - cycle_hash(z) + mod) % mod;\n                if (diff == 0) { ans[j] = true; }\n                foreach (q; -26 .. 26 + 1) {\n                    long y = q < 0 ? q + mod : q;\n                    if (inv(y) * diff % mod in P_exp[j]) {\n                        ans[j] = true;\n                    }\n                }\n            }\n        }\n        writeln(ans.all ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.range;\nimport std.ascii;\nimport std.array;\nimport std.container;\nimport std.conv;\nimport std.numeric;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nlong modPow(long mod)(long x, long n) {\n    if (n == 0) return 1;\n    if (n % 2 == 0) return modPow!mod(x * x % mod, n / 2);\n    return x * modPow!mod(x % mod, n - 1) % mod;\n}\n\nlong extgcd(long a, long b, ref long x, ref long y) {\n    long g = a; x = 1; y = 0;\n    if (b != 0) {\n        g = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    }\n    return g;\n}\nlong inverse(long mod)(long v) {\n    long x, y;\n    if (extgcd(v, mod, x, y) == 1) return (x + mod) % mod;\n    return 0;\n}\n\nclass RollingHash(long[] Ps, long mod) {\n    string s;\n    long[][] H;\n    this(in string s) { \n        this.s = s; \n        auto N = s.length;\n        this.H = new long[][](Ps.length, N + 1); // H[k]: s[0]*Ps[k]^(n-1) + s[1]*Ps[k]^(n-2) + ... + s[n-1]*Ps[k]^0\n        foreach (k, P; Ps) {\n            foreach (int i, c; s) {\n                H[k][i + 1] = (H[k][i] * P + cast(int)(c)) % mod;\n            }\n        }\n    }\n    long[] hash(int l, int r) { // [l, r)\n        auto hs = iota(0, Ps.length, 1).map!(delegate(k) {\n                      return (H[k][r] - H[k][l] * modPow!mod(Ps[k], r - l) % mod + mod) % mod;\n                  });\n        return hs.array;\n    }\n}\n\nconst long P = 991;\nconst long mod = cast(long)1e9+7;\nalias inv = inverse!mod;\nalias pow = modPow!mod;\nvoid main() {\n    auto s = readln.chomp;\n    int N = s.size;\n    int Q = readln.chomp.to!int;\n\n    bool[long] P_exp;\n    long p = 1;\n    P_exp[p] = true;\n    foreach (n; 0 .. N + 1) {\n        p = (p * P) % mod;\n        P_exp[p] = true;\n    }\n\n    auto hasher = new RollingHash!([P], mod)(s);\n    foreach (_; 0 .. Q) {\n        int l, r, t; \n        scanf(\"%d %d %d\\n\", &l, &r, &t);\n        l--;\n\n        long org = hasher.hash(l, r)[0];\n\n        auto k = (r - l) / t;\n        auto m = r - l - t * k;\n\n        long cycle_hash(long a) {\n            return (a * (P.pow(t).pow(k) - 1) % mod * inv(P.pow(t) - 1) % mod * P.pow(m) % mod + hasher.hash(l, l + m)[0]) % mod;\n        }\n\n        auto as = [\n            hasher.hash(l, l + t)[0]\n        ];\n        if (l + 2 * t <= r) {\n            as ~= hasher.hash(l + t, l + 2*t)[0];\n        }\n\n        bool ans = false;\n        foreach (a; as) {\n            auto diff = (org - cycle_hash(a) + mod) % mod;\n            //log([a, diff]);\n            if (diff == 0) ans = true;\n            foreach (q; -26 .. 26 + 1) {\n                long y = q < 0 ? q + mod : q;\n                if (y.inv * diff % mod in P_exp) {\n                    ans = true;\n                }\n            }\n        }\n        writeln(ans ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.functional;\nimport std.range;\nimport std.ascii;\nimport std.array;\nimport std.container;\nimport std.conv;\nimport std.numeric;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nlong extgcd(long a, long b, ref long x, ref long y) {\n    long g = a; x = 1; y = 0;\n    if (b != 0) {\n        g = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    }\n    return g;\n}\nlong inverse(long mod, long v) {\n    long x, y;\n    if (extgcd(v, mod, x, y) == 1) return (x + mod) % mod;\n    return 0;\n}\n\nconst long P = 10000481L;\nconst long[] mods = [1000000123L, 1000000207L, 1000001137L];\nlong[][] pow;\nstatic this() {\n    const int N = cast(int)1e5 + 5;\n    pow = new long[][](mods.length, N + 1);\n    foreach (k, mod; mods) {\n        pow[k][0] = 1L;\n        foreach (n; 0 .. N) {\n            pow[k][n + 1] = pow[k][n] * P % mod;\n        }\n    }\n}\n\nclass RollingHash {\n    long[] H;\n    long mod;\n    long P;\n    int mod_index;\n    this(long P, long mod, int mod_index, in string s) { \n        this.mod = mod;\n        this.mod_index = mod_index;\n        this.P = P;\n        auto N = s.length;\n        this.H = new long[N + 1]; // H[k]: s[0]*P^(n-1) + s[1]*P^(n-2) + ... + s[n-1]*P^0\n        foreach (int i, c; s) {\n            H[i + 1] = (H[i] * P + cast(int)(c)) % mod;\n        }\n    }\n    long hash(int l, int r) { // [l, r)\n        return (H[r] - H[l] * pow[mod_index][r - l] % mod + mod) % mod;\n    }\n}\n\nvoid main() {\n    auto s = readln.chomp;\n    int N = s.size;\n    int Q = readln.chomp.to!int;\n\n    auto P_exp = new bool[long][mods.length];\n    foreach (k, mod; mods) {\n        long p = 1;\n        P_exp[k][p] = true;\n        foreach (n; 0 .. N + 2) {\n            p = (p * P) % mod;\n            P_exp[k][p] = true;\n        }\n    }\n\n    auto hashers = iota(0, mods.length, 1).map!((k) => new RollingHash(P, mods[k], cast(int)k, s)).array;\n\n    auto inv_cache = new long[][](mods.length, 70);\n    foreach (k, mod; mods) {\n        foreach (q; -25 .. 25 + 1) {\n            long y = q < 0 ? q + mod : q;\n            inv_cache[k][q + 30] = inverse(mod, y);\n        }\n    }\n\n    foreach (_; 0 .. Q) {\n        //log(_);\n        int l, r, t; \n        scanf(\"%d %d %d\\n\", &l, &r, &t);\n        l--;\n\n        auto k = (r - l) / t;\n        auto m = r - l - t * k;\n        //log([l, r, t, k, m]);\n\n        auto ans = new bool[hashers.length];\n        foreach (j, ref hasher; hashers) {\n            auto mod = hasher.mod;\n            long org = hasher.hash(l, r);\n            auto inv = delegate long(long x) { return inverse(mod, x); };\n\n            long cycle_hash(int z) {\n                long a = hasher.hash(l + t * z, l + t * z + t);\n                return (a * (pow[j][t * k] - 1L) % mod * inv(pow[j][t] - 1L) % mod * pow[j][m] % mod \n                        + hasher.hash(l + t*z, l + t*z + m)) % mod;\n            }\n\n            foreach (z; [0, 1]) {\n                if (l + t * z + t > r) continue;\n                auto diff = (org - cycle_hash(z) + mod) % mod;\n                if (diff == 0) { ans[j] = true;  goto next;}\n                foreach (q; -25 .. 25 + 1) {\n                    if (inv_cache[j][q + 30] * diff % mod in P_exp[j]) {\n                        ans[j] = true;\n                        goto next;\n                    }\n                }\n            }\n            if (! ans[j]) break;\n            next:;\n        }\n        writeln(ans.all ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.functional;\nimport std.range;\nimport std.ascii;\nimport std.array;\nimport std.container;\nimport std.conv;\nimport std.numeric;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nlong extgcd(long a, long b, ref long x, ref long y) {\n    long g = a; x = 1; y = 0;\n    if (b != 0) {\n        g = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    }\n    return g;\n}\nlong inverse(long mod, long v) {\n    long x, y;\n    if (extgcd(v, mod, x, y) == 1) return (x + mod) % mod;\n    return 0;\n}\n\nconst long P = 10000481L;\nconst long[] mods = [999999937L, 1000000123L, 1000000207L];\nlong[][] pow;\nstatic this() {\n    const int N = cast(int)1e5 + 5;\n    pow = new long[][](mods.length, N + 1);\n    foreach (k, mod; mods) {\n        pow[k][0] = 1L;\n        foreach (n; 0 .. N) {\n            pow[k][n + 1] = pow[k][n] * P % mod;\n        }\n    }\n}\n\nclass RollingHash {\n    long[] H;\n    long mod;\n    long P;\n    int mod_index;\n    this(long P, long mod, int mod_index, in string s) { \n        this.mod = mod;\n        this.mod_index = mod_index;\n        this.P = P;\n        auto N = s.length;\n        this.H = new long[N + 1]; // H[k]: s[0]*P^(n-1) + s[1]*P^(n-2) + ... + s[n-1]*P^0\n        foreach (int i, c; s) {\n            H[i + 1] = (H[i] * P + cast(int)(c)) % mod;\n        }\n    }\n    long hash(int l, int r) { // [l, r)\n        return (H[r] - H[l] * pow[mod_index][r - l] % mod + mod) % mod;\n    }\n}\n\nvoid main() {\n    auto s = readln.chomp;\n    int N = s.size;\n    int Q = readln.chomp.to!int;\n\n    auto P_exp = new bool[long][mods.length];\n    foreach (k, mod; mods) {\n        long p = 1;\n        P_exp[k][p] = true;\n        foreach (n; 0 .. N + 2) {\n            p = (p * P) % mod;\n            P_exp[k][p] = true;\n        }\n    }\n\n    auto hashers = iota(0, mods.length, 1).map!((k) => new RollingHash(P, mods[k], cast(int)k, s)).array;\n\n    auto inv_cache = new long[][](mods.length, 70);\n    foreach (k, mod; mods) {\n        foreach (q; -26 .. 26 + 1) {\n            long y = q < 0 ? q + mod : q;\n            inv_cache[k][q + 30] = inverse(mod, y);\n        }\n    }\n\n    foreach (_; 0 .. Q) {\n        //log(_);\n        int l, r, t; \n        scanf(\"%d %d %d\\n\", &l, &r, &t);\n        l--;\n\n        auto k = (r - l) / t;\n        auto m = r - l - t * k;\n        //log([l, r, t, k, m]);\n\n        auto ans = new bool[hashers.length];\n        foreach (j, ref hasher; hashers) {\n            auto mod = hasher.mod;\n            long org = hasher.hash(l, r);\n            auto inv = delegate long(long x) { return inverse(mod, x); };\n\n            long cycle_hash(int z) {\n                long a = hasher.hash(l + t * z, l + t * z + t);\n                return (a * (pow[j][t * k] - 1L) % mod * inv(pow[j][t] - 1L) % mod * pow[j][m] % mod \n                        + hasher.hash(l + t*z, l + t*z + m)) % mod;\n            }\n\n            foreach (z; [0, 1]) {\n                if (l + t * z + t > r) continue;\n                auto diff = (org - cycle_hash(z) + mod) % mod;\n                if (diff == 0) { ans[j] = true;  goto next;}\n                foreach (q; -26 .. 26 + 1) {\n                    if (inv_cache[j][q + 30] * diff % mod in P_exp[j]) {\n                        ans[j] = true;\n                        goto next;\n                    }\n                }\n            }\n            next:;\n        }\n        writeln(ans.all ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.meta;\nimport std.range;\nimport std.ascii;\nimport std.array;\nimport std.container;\nimport std.conv;\nimport std.numeric;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nlong modPow(long mod, long x, long n) {\n    x %= mod;\n    if (n == 0) return 1;\n    if (n % 2 == 0) return modPow(mod, x * x % mod, n / 2);\n    return x * modPow(mod, x % mod, n - 1) % mod;\n}\n\nlong extgcd(long a, long b, ref long x, ref long y) {\n    long g = a; x = 1; y = 0;\n    if (b != 0) {\n        g = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    }\n    return g;\n}\nlong inverse(long mod, long v) {\n    long x, y;\n    if (extgcd(v, mod, x, y) == 1) return (x + mod) % mod;\n    return 0;\n}\n\nclass RollingHash {\n    long[] H;\n    long mod;\n    long P;\n    this(long P, long mod, in string s) { \n        this.mod = mod;\n        this.P = P;\n        auto N = s.length;\n        this.H = new long[N + 1]; // H[k]: s[0]*P^(n-1) + s[1]*P^(n-2) + ... + s[n-1]*P^0\n        foreach (int i, c; s) {\n            H[i + 1] = (H[i] * P + cast(int)(c)) % mod;\n        }\n    }\n    long hash(int l, int r) { // [l, r)\n        return (H[r] - H[l] * modPow(mod, P, r - l) % mod + mod) % mod;\n    }\n}\n\nconst long P = 10000481L;\nconst long[] mods = [1000000123L, 1000000207L, 1000000363L];\nvoid main() {\n    auto s = readln.chomp;\n    int N = s.size;\n    int Q = readln.chomp.to!int;\n\n    auto P_exp = new bool[long][mods.length];\n    foreach (k, mod; mods) {\n        long p = 1;\n        P_exp[k][p] = true;\n        foreach (n; 0 .. N + 2) {\n            p = (p * P) % mod;\n            P_exp[k][p] = true;\n        }\n    }\n\n    auto hashers = iota(0, mods.length, 1).map!((k) => new RollingHash(P, mods[k], s)).array;\n\n    foreach (_; 0 .. Q) {\n        int l, r, t; \n        scanf(\"%d %d %d\\n\", &l, &r, &t);\n        l--;\n\n        auto k = (r - l) / t;\n        auto m = r - l - t * k;\n        //log([l, r, t, k, m]);\n        \n        auto ans = new bool[hashers.length];\n        foreach (j, ref hasher; hashers) {\n            auto mod = hasher.mod;\n            assert(mod == mods[j]);\n            long org = hasher.hash(l, r);\n            auto pow = delegate long(long x, long n) { return modPow(mod, x, n); };\n            auto inv = delegate long(long x) { return inverse(mod, x); };\n            auto Pt = pow(P, t);\n\n            long cycle_hash(int z) {\n                long a = hasher.hash(l + t * z, l + t * z + t);\n                return (a * ( (pow(Pt, k) - 1 + mod) % mod ) % mod * inv( (pow(P, t) - 1 + mod) % mod ) % mod * pow(P, m) % mod \n                        + hasher.hash(l + t*z, l + t*z + m)) % mod;\n            }\n\n            foreach (z; [0, 1]) {\n                if (l + t * z + t > r) continue;\n                auto diff = (org - cycle_hash(z) + mod) % mod;\n                if (diff == 0) { ans[j] = true; }\n                foreach (q; -26 .. 26 + 1) {\n                    long y = q < 0 ? q + mod : q;\n                    if (inv(y) * diff % mod in P_exp[j]) {\n                        ans[j] = true;\n                    }\n                }\n            }\n        }\n        writeln(ans.all ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    base = 37; MOD = 10**9 + 9\n    S = readline().strip()\n    L = len(S)\n    H = [0]*(L+1)\n    pw = [1]*(L+1)\n    ca = ord('a')\n    v = 0\n    for i in range(L):\n        H[i+1] = v = (v * base + (ord(S[i]) - ca)) % MOD\n    v = 1\n    for i in range(1, L+1):\n        pw[i] = v = v * base % MOD\n    Q = int(readline())\n    for i in range(Q):\n        l, r, t = map(int, readline().split()); l -= 1\n        m = r-l\n        if ((H[r]-H[r-t]) - (H[l+t]-H[l]) * pw[m-t]) % MOD == 0:\n            write(\"Yes\\n\")\n            continue\n        left = 0; right = m-t+1\n        base = H[l] - H[l+t]\n        while left+1 < right:\n            mid = (left + right) >> 1\n            if ((H[l+mid]-H[l+t+mid]) - base * pw[mid]) % MOD == 0:\n                left = mid\n            else:\n                right = mid\n        l1 = left\n        left = 0; right = m-t-l1+1\n        base = (H[r-t]-H[r]) % MOD\n        while left+1 < right:\n            mid = (left + right) >> 1\n            if (H[r-t-mid]-H[r-mid]) * pw[mid] % MOD == base:\n                left = mid\n            else:\n                right = mid\n        l2 = left\n        if l1+l2+1 == m-t:\n            if l1 <= t or l2 <= t:\n                write(\"Yes\\n\")\n            else:\n                write(\"No\\n\")\n        else:\n            if ((H[l+m-t-l2-1]-H[l+m-l2-1]) - (H[l+l1+1]-H[l+t+l1+1]) * pw[m-t-l2-l1-2]) % MOD != 0:\n                write(\"No\\n\")\n            else:\n                p1 = l1; p2 = m-t-l2-1\n                if p2 - p1 == t and S[l+p2-t] == S[l+p2+t]:\n                    write(\"Yes\\n\")\n                else:\n                    write(\"No\\n\")\nsolve()\n"
  }
]