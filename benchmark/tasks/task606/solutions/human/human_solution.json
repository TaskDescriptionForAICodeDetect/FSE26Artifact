[
  {
    "language": "Scala",
    "code": "import scala.collection.mutable.ArrayBuffer\nimport scala.io.StdIn._\n\nobject Main extends App {\n  val Array(_n, _k, l, r) = readLine.trim.split(' ').map(_.toLong)\n  val n = _n.toInt\n  val k = _k.toInt\n  val coin = readLine.trim.split(' ').map(_.toLong)\n  val prev = Array.fill(k + 1){ArrayBuffer[Long]()}\n  for (p ← 0 until (1 << (n / 2))) {\n    var sum = 0L\n    var count = 0\n    for (i ← 0 until n / 2) {\n      if ((p & (1 << i)) != 0) {\n        sum += coin(i)\n        count += 1\n      }\n    }\n    if (count < prev.length) prev(count).append(sum)\n  }\n  val post = Array.fill(k + 1){ArrayBuffer[Long]()}\n  for (p ← 0 until (1 << (n - n / 2))) {\n    var sum = 0L\n    var count = 0\n    for (i ← 0 until (n - n / 2)) {\n      if ((p & (1 << i)) != 0){\n        sum += coin(i + n / 2)\n        count += 1\n      }\n    }\n    if (count < post.length) post(count).append(sum)\n  }\n  prev.indices.foreach(i ⇒ prev(i) = prev(i).sorted)\n  post.indices.foreach(i ⇒ post(i) = post(i).sorted)\n  var sum = 0L\n  for (i ← 0 to k) {\n    for (p ← prev(i)) {\n      sum += upperBound(post(k - i), r - p) - lowerBound(post(k - i), l - p)\n    }\n  }\n  println(sum)\n  def lowerBound(array: ArrayBuffer[Long], target: Long): Int = {\n    var left = 0\n    var right = array.length\n    while (left < right) {\n      val mid = (left + right) / 2\n      if (array(mid) < target) left = mid + 1\n      else right = mid\n    }\n    right\n  }\n  def upperBound(array: ArrayBuffer[Long], target: Long): Int = {\n    var left = 0\n    var right = array.length\n    while (left < right) {\n      val mid = (left + right) / 2\n      if (array(mid) <= target) left = mid + 1\n      else right = mid\n    }\n    right\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<bits/stdc++.h> \nusing namespace std;\nusing ll=long long;\nusing P=pair<ll,ll>;\ntemplate<class T> using V=vector<T>; \n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\nconst ll inf=(1e18);\n//const ll mod=998244353;\nconst ll mod=1000000007;\nll GCD(ll a,ll b) {return b ? GCD(b,a%b):a;}\nll LCM(ll c,ll d){return c/GCD(c,d)*d;}\nstruct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\nll n,k,l,r;\nV<ll> a;\nV<ll> top[41],back[41];\nvoid make1(int now,ll cnt,ll val){\n    if(now==(n+1)/2){\n        if(cnt<=k)top[cnt].emplace_back(val);\n        return ;\n    }\n    make1(now+1,cnt+1,val+a[now]);\n    make1(now+1,cnt,val);\n}\nvoid make2(int now,ll cnt,ll val){\n    if(now==n){\n        if(cnt<=k)back[cnt].emplace_back(val);\n        return ;\n    }\n    make2(now+1,cnt+1,val+a[now]);\n    make2(now+1,cnt,val);\n}\nint main(){\n    cin>>n>>k>>l>>r;\n    a.resize(n);\n    for(int i=0;i<n;i++)cin>>a[i];\n    make1(0,0,0);\n    make2((n+1)/2,0,0);\n    for(int i=0;i<=k;i++){\n        sort(all(back[i]));\n    }\n    ll ans=0;\n    for(int i=0;i<=k;i++){\n        for(ll v:top[i]){\n            ans+=upper_bound(all(back[k-i]),r-v)-lower_bound(all(back[k-i]),l-v);\n        }\n    }\n    cout<<ans<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\n#define int long long\n#define dotimes(i, n) for (int i = 0, i##max__ = (n); i < i##max__; i++)\n#define whole(x, f, ...) ([&](decltype((x)) c__) { return (f)(begin(c__), end(c__), ## __VA_ARGS__); })(x)\n\nint rint() {\n  int x;\n  scanf(\"%lld\", &x);\n  return x;\n}\n\nvoid wint(int x) {\n  printf(\"%lld\\n\", x);\n}\n\ntemplate<typename T> int size(T const& c) { return static_cast<int>(c.size()); }\ntemplate <typename T> bool maxs(T& a, T const& b) { return a < b ? a = b, true : false; }\ntemplate <typename T> bool mins(T& a, T const& b) { return a > b ? a = b, true : false; }\ninline int lg(int x) { return 63 - __builtin_clzll(static_cast<unsigned int>(x)); }\n\nsigned main() {\n  const int N = rint();\n  const int K = rint();\n  const int L = rint();\n  const int R = rint();\n  const int ss[2] = {(N+1)/2, N/2};\n  vector<pair<int, int>> cs[2];\n  vector<int> as[2];\n  dotimes(i, 2) dotimes(j, ss[i])\n    as[i].emplace_back(rint());\n  dotimes(i, 2) {\n    dotimes(b, 1 << ss[i]) {\n      int c = __builtin_popcount(b);\n      if (c > K)\n        continue;\n      int s = 0;\n      dotimes(j, ss[i])\n        if (b & (1 << j))\n          s += as[i][j];\n      if (s <= R)\n        cs[i].emplace_back(c, s);\n    }\n    whole(cs[i], sort);\n  }\n  int r = 0;\n  for (auto it = whole(cs[0], lower_bound, make_pair(K - ss[1], 0LL)); it != cs[0].end(); ++it) {\n    auto p = *it;\n    int c = K - p.first;\n    r += whole(cs[1], upper_bound, make_pair(c, R - p.second)) - whole(cs[1], lower_bound, make_pair(c, L - p.second));\n  }\n  wint(r);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int int64_t\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\n#define maxup(ans, x) (ans = (ans < x ? x : ans))\n#define minup(ans, x) (ans = (ans > x ? x : ans))\n\n#define breakif(cond) if(cond) break; else\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nvoid comb(int idx, int rem, int sum, V& data, V& v) {\n\tif (rem == 0) {\n\t\tv.push_back(sum);\n\t\treturn;\n\t}\n\tif (idx == data.size()) return;\n\tcomb(idx + 1, rem, sum, data, v);\n\tcomb(idx + 1, rem - 1, sum + data[idx], data, v);\n}\n\nsigned main() {\n\tint n, k, l, r; cin >> n >> k >> l >> r;\n\tV as(n); input(as);\n\tV x; x.insert(x.begin(), as.begin(), as.begin() + as.size() / 2);\n\tV y; y.insert(y.begin(), as.begin() + as.size() / 2, as.end());\n\tint ans = 0;\n\trep(p, 0, k + 1) {\n\t\tint q = k - p;\n\t\tV ps, qs;\n\t\tcomb(0, p, 0, x, ps);\n\t\tcomb(0, q, 0, y, qs);\n\t\tsort(all(ps));\n\t\tsort(all(qs));\n\t\tif (p == 0) ps.push_back(0);\n\t\tif (q == 0) qs.push_back(0);\n\t\tfor (int s : ps) {\n\t\t\tint t1 = upper_bound(all(qs), r - s) - qs.begin();\n\t\t\tint t2 = lower_bound(all(qs), r - s) - qs.begin();\n\t\t\tans += upper_bound(all(qs), r - s) - lower_bound(all(qs), l - s);\n\t\t}\n\t}\n\tcout << ans << endl;\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const T& a = T()) { v.assign(n, a); }\ntemplate<class T, class... Args> void assign(V<T>& v, int n, const Args&... args) { v.resize(n); for (auto&& e : v) assign(e, args...); }\n\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, k; cin >> n >> k;\n  lint l, r; cin >> l >> r, ++r;\n  V<lint> a(n); for (int i = 0; i < n; ++i) cin >> a[i];\n  int n0 = n >> 1, n1 = n - n0;\n  V<lint> s0(1 << n0);\n  for (int bit = 0; bit < 1 << n0; ++bit) for (int i = 0; i < n0; ++i) if (bit & 1 << i) s0[bit] += a[i];\n  V< pair<int, lint> > s1(1 << n1);\n  for (int bit = 0; bit < 1 << n1; ++bit) {\n    s1[bit].first = __builtin_popcount(bit);\n    for (int i = 0; i < n1; ++i) if (bit & 1 << i) s1[bit].second += a[i + n0];\n  }\n  sort(begin(s1), end(s1));\n  lint res = 0;\n  for (int bit = 0; bit < 1 << n0; ++bit) {\n    int m = __builtin_popcount(bit);\n    res += distance(lower_bound(begin(s1), end(s1), make_pair(k - m, l - s0[bit])), lower_bound(begin(s1), end(s1), make_pair(k - m, r - s0[bit])));\n  }\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep0(N) for (int COUNTER = 0; COUNTER < (int)(N); COUNTER++)\n#define rep(i, N) for (int i = 0; i < (int)(N); i++)\n#define rep1(i, N) for (int i = 0; i < (int)(N); i++)\n#define rep2(i, START, GOAL) for (int i = (int)(START); i < (int)(GOAL); i++)\n#define rep3(i, START, GOAL) for (int i = (int)(START); i > (int)(GOAL); i--)\n#define all(CONTAINER) CONTAINER.begin(), CONTAINER.end()\n#define rall(CONTAINER) CONTAINER.rbegin(), CONTAINER.rend()\n#define from1(CONTAINER) CONTAINER.begin() + 1, CONTAINER.end()\n#define rfrom1(CONTAINER) CONTAINER.rbegin(), CONTAINER.rend() - 1\n#define pout(X) cout << X << \" \"\n#define print(X) cout << X << \"\\n\"\n#define output(X) cout << X << \"\\n\"\n#define dbe(X) cerr << X << \" \"\n#define dbel(X) cerr << X << \"\\n\"\n#define dberr(X) cerr << X << \" \"\n#define dberrl(X) cerr << X << \"\\n\"\n#define db(X) cerr << #X << \":\" << (X) << \" \"\n#define dbl(X) cerr << #X << \":\" << (X) << \"\\n\"\n#define db2(X, Y) cerr << #X << \":\" << (X) << \", \" << #Y << \":\" << (Y) << \" \"\n#define db2l(X, Y) cerr << #X << \":\" << (X) << \", \" << #Y << \":\" << (Y) << \"\\n\"\n#define dbl2(X, Y) cerr << #X << \":\" << (X) << \"\\n\" << #Y << \":\" << (Y) << \"\\n\"\n#define db3(X, Y, Z) cerr << #X << \":\" << (X) << \", \" << #Y << \":\" << (Y) << \" \" << #Z << \":\" << (Z) << \" \"\n#define db3l(X, Y, Z) cerr << #X << \":\" << (X) << \", \" << #Y << \":\" << (Y) << \", \" << #Z << \":\" << (Z) << \"\\n\"\n#define dbl3(X, Y, Z) cerr << #X << \":\" << (X) << \"\\n\" << #Y << \":\" << (Y) << \"\\n\" << #Z << \":\" << (Z) << \"\\n\"\n#define dbp(PAIR) cerr << #PAIR << \":(\" << PAIR.first << \", \" << PAIR.second << \") \"\n#define dbpl(PAIR) cerr << #PAIR << \":(\" << PAIR.first << \", \" << PAIR.second << \")\\n\"\n#define dbt3(TUPLE3) cerr << #TUPLE3 << \":(\" << get<0>(TUPLE3) << \", \" << get<1>(TUPLE3) << \", \" << get<2>(TUPLE3) << \") \"\n#define dbt3l(TUPLE3) cerr << #TUPLE3 << \":(\" << get<0>(TUPLE3) << \", \" << get<1>(TUPLE3) << \", \" << get<2>(TUPLE3) << \")\\n\"\n#define dbt4(TUPLE4) cerr << #TUPLE4 << \":(\" << get<0>(TUPLE4) << \", \" << get<1>(TUPLE4) << \", \" << get<2>(TUPLE4) << \", \" << get<3>(TUPLE4) << \") \"\n#define dbt4l(TUPLE4) cerr << #TUPLE4 << \":(\" << get<0>(TUPLE4) << \", \" << get<1>(TUPLE4) << \", \" << get<2>(TUPLE4) << \", \" << get<3>(TUPLE4) << \")\\n\"\n#define dbv(VEC) cerr << #VEC << \":{ \"; for (auto ELEM : VEC) cerr << ELEM << \", \"; cerr << \"}\\n\"\n#define dbvp(VP) cerr << #VP << \":{ \"; for (auto PAIR : VP) cerr << \"(\" << PAIR.first << \", \" << PAIR.second << \"), \"; cerr << \"}\\n\"\n#define dbvv(VV) cerr << #VV << \":{\\n\"; for (auto VEC : VV) { cerr << \"{ \"; for (auto ELEM : VEC) cerr << ELEM << \", \"; cerr << \"},\\n\"; } cerr << \"}\\n\"\n#define dbvvp(VVP) cerr << #VVP <<\":{\\n\"; for (auto VP : VVP) { cerr << \"{ \"; for (auto PAIR : VP) { cerr << \"(\" << PAIR.first << \", \" << PAIR.second << \"), \"; } cerr << \"},\\n\"; } cerr << \"}\\n\";\n#define dbs(SET) cerr << #SET << \"{ \"; for (auto ELEM : SET) cerr << ELEM << \", \"; cerr << \"}\\n\";\n#define dbsp(SP) cerr << #SP << \"{ \"; for (auto PAIR : SP) cerr << \"(\" << PAIR.first << \", \" << PAIR.second << \"), \"; \"}\\n\";\n#define dbm(MAP) cerr << #MAP << \":{ \"; for (auto PAIR : MAP) cerr << \"(\" << PAIR.first << \", \" << PAIR.second << \"), \"; cerr << \"}\\n\"\n#define YN(f) cout << (f ? \"YES\" : \"NO\") << \"\\n\"\n#define Yn(f) cout << (f ? \"Yes\" : \"No\") << \"\\n\"\n#define yn(f) cout << (f ? \"yes\" : \"no\") << \"\\n\"\nusing ll = long long;\nusing pii = pair<int, int>;using pll = pair<ll, ll>;using pdd = pair<double, double>;\nusing ti3 = tuple<int, int, int>;using tl3 = tuple<ll, ll, ll>;using td3 = tuple<double, double, double>;\nusing ti4 = tuple<int, int, int, int>;using tl4 = tuple<ll, ll, ll, ll>;using td4 = tuple<double, double, double, double>;\nusing vi = vector<int>;using vl = vector<ll>;using vd = vector<double>;using vs = vector<string>;using vb = vector<bool>;\nusing vvi = vector<vi>;using vvl = vector<vl>;using vvd = vector<vd>;using vvb = vector<vb>;\nusing vpii = vector<pii>;using vpll = vector<pll>;using vpdd = vector<pdd>;\nusing mii = map<int, int>;using mll = map<ll, ll>;\nusing si = set<int>;using sl = set<ll>;using ss = set<string>;\nusing spii = set<pii>;using spll = set<pll>;using spdd = set<pdd>;\n// db\n\nint next_combination(int bitint) {\n\tint x = bitint & -bitint; // bitの最下位の1 (Least Significant Bit)\n\tint y = bitint + x; // bit + LSB\n\treturn (((bitint & ~y) / x) >> 1) | y; //\n}\n\nint main() {\n\tint N, K; cin >> N >> K;\n\tll L, R; cin >> L >> R;\n\tint nb = (N + 1) / 2, nc = N / 2;\n\tvl b(nb); rep(i, nb) cin >> b[i];\n\tvl c(nc); rep(i, nc) cin >> c[i];\n\t// dbv(b); dbv(c);\n\tll ans = 0;\n\trep(t, K + 1) {\n\t\t// db2l(t, K-t);\t\t\n\t\tif (nb < t) break;\n\t\telse if (nc < K - t) continue;\n\t\tvl Ub, Uc;\n\t\tif (t > 0) {\n\t\t\tfor (int bit = (1 << t) - 1; bit < (1 << nb); bit = next_combination(bit)) {\n\t\t\t\tll res = 0;\n\t\t\t\trep(i, nb) if (bit & (1 << i)) res += b[i];\n\t\t\t\tUb.push_back(res);\n\t\t\t}\t\t\t\n\t\t}\n\t\tif (K - t > 0) {\n\t\t\tfor (int bit = (1 << (K - t)) - 1; bit < (1 << nc); bit = next_combination(bit)) {\t\t\t\t\n\t\t\t\tll res = 0;\n\t\t\t\trep(i, nc) if (bit & (1 << i)) res += c[i];\n\t\t\t\tUc.push_back(res);\n\t\t\t}\n\t\t}\n\t\tsort(all(Ub)); sort(all(Uc));\n\t\t// dbv(Ub); dbv(Uc);\n\t\tif (t == 0) ans += upper_bound(all(Uc), R) - lower_bound(all(Uc), L);\n\t\telse if (K - t == 0) ans += upper_bound(all(Ub), R) - lower_bound(all(Ub), L);\n\t\telse {\n\t\t\tll temp = 0;\n\t\t\trep(i, Ub.size()) { // 2^t\n\t\t\t\tif (Ub[i] >= R) break;\n\t\t\t\ttemp += upper_bound(all(Uc), R - Ub[i]) - lower_bound(all(Uc), L - Ub[i]);\n\t\t\t}\t\t\t\n\t\t\tans += temp;\n\t\t\t// db2l(temp, ans);\n\t\t}\t\t\n\t}\n\tprint(ans);\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll N, K, L, R;\nll a[40];\n\nauto enumerate(int sidx, int size) {\n  vector<pair<ll, ll>> ret;\n  for(int i=0; i<1<<size; i++) {\n    int cnt = 0; ll sum = 0;\n    for(int j=0; j<size; j++)\n      if(i >> j & 1) cnt++, sum += a[sidx + j];\n    ret.emplace_back(cnt, sum);\n  }\n  return move(ret);\n}\n\nll solve() {\n  auto v0 = enumerate(0, N / 2);\n  auto v1 = enumerate(N / 2, (N + 1) / 2);\n  sort(v0.begin(), v0.end());\n  ll ret = 0;\n  for(int i=0; i<(int)v1.size(); i++)\n    ret +=  upper_bound(v0.begin(), v0.end(), make_pair(K - v1[i].first, R - v1[i].second))\n          - lower_bound(v0.begin(), v0.end(), make_pair(K - v1[i].first, L - v1[i].second));\n  return ret;\n}\n\nint main() {\n  cin >> N >> K >> L >> R;\n  for(int i=0; i<N; i++) cin >> a[i];\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n \nint main(){\n    //input\n    int N, K;\n    ll L, R;\n    cin >> N >> K >> L >> R;\n    ll a[N];\n    for (int i=0;i<N;i++){\n        cin >> a[i];\n    }\n \n    int hn = N/2;\n    vector< vector<ll> > sumList1(hn+1);\n    vector< vector<ll> > sumList2(N-hn+1);\n \n    for (int i=0;i<(1<<hn);i++){\n        ll sum = 0;\n        int weight = 0;\n        for (int j=0;j<hn;j++){\n            if ((i>>j)&1){\n                sum += a[j];\n                weight++;\n            }\n        }\n        sumList1[weight].push_back(sum);\n    }\n \n    for (int i=0;i<(1<<(N-hn));i++){\n        ll sum = 0;\n        int weight = 0;\n        for (int j=0;j<(N-hn);j++){\n            if ((i>>j)&1){\n                sum += a[hn+j];\n                weight++;\n            }\n        }\n        sumList2[weight].push_back(sum);\n    }\n \n    for (int i=0;i<hn;i++){\n        sort(sumList1[i].begin(), sumList1[i].end());\n    }\n/*\n    cout << endl;\n    for (int i=0;i<sumList1.size();i++){\n        for (int j=0;j<sumList1[i].size();j++){\n            cout << sumList1[i][j] << \" \";\n        }\n        cout << endl;\n    }\n \n    cout << endl;\n    for (int i=0;i<sumList2.size();i++){\n        for (int j=0;j<sumList2[i].size();j++){\n            cout << sumList2[i][j] << \" \";\n        }\n        cout << endl;\n    }\n \n    cout << endl;\n*/\n    ll result = 0;\n    for (int i=max(0, K-hn);i<min(K,N-hn)+1;i++){\n        for (int j=0;j<sumList2[i].size();j++){\n            vector<ll>::iterator it1 = lower_bound(sumList1[K-i].begin(), sumList1[K-i].end(), L-sumList2[i][j]);\n            vector<ll>::iterator it2 = upper_bound(sumList1[K-i].begin(), sumList1[K-i].end(), R-sumList2[i][j]);\n            ll dist = (ll)distance(it1, it2);\n            result += dist;\n        }\n    }\n \n    cout << result << endl;\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\nint in(){int a;scanf(\"%d\",&a);return a;}\nll lin(){ll a;scanf(\"%lld\",&a);return a;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nvi sum[40 / 2 + 1];\n\nint main()\n{\n    ll N = in(), K = in(), L = in(), R = in();\n\n    vector<ll> A(N);\n\n    rep(i, N) {\n        A[i] = lin();\n    }\n\n    int sz1 = N / 2;\n    rep(bit, 1 << sz1) {\n        int cnt = 0;\n        ll s = 0;\n\n        rep(i, sz1) {\n            if (bit >> i & 1) {\n                cnt++;\n                s += A[i];\n            }\n        }\n\n        sum[cnt].PB(s);\n    }\n\n    rep(i, sz1 + 1) sort(all(sum[i]));\n\n    ll ans = 0;\n\n    int sz2 = N - N / 2;\n    rep(bit, 1 << sz2) {\n        int cnt = 0;\n        ll s = 0;\n\n        rep(i, sz2) {\n            if (bit >> i & 1) {\n                cnt++;\n                s += A[i + sz1];\n            }\n        }\n\n        if (K - cnt < 0 || K - cnt > sz1) continue;\n\n        int pos1 = upper_bound(all(sum[K - cnt]), R - s) - begin(sum[K - cnt]) - 1;\n        int pos2 = lower_bound(all(sum[K - cnt]), L - s) - begin(sum[K - cnt]);\n\n        if (pos2 == sum[K - cnt].size()) continue;\n\n        ans += max(pos1 - pos2 + 1, 0);\n    }\n\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n    int n, k;\n    ll l, r;\n    cin >> n >> k >> l >> r;\n\n    int a[n];\n    for(int i = 0; i < n; i++)  cin >> a[i];\n\n    int left = n/2;\n    int right = n - left;\n\n    vector<ll> va[left+1], vb[right+1];\n\n    for(int i = 0; i < 1<<left; i++){\n        ll sum = 0;\n        int popcnt = 0;\n        for(int j = 0; j < left; j++){\n            if(i>>j & 1)    sum += a[j], popcnt++;\n        }\n        va[popcnt].push_back(sum);\n    }\n\n    for(int i = 0; i < 1<<right; i++){\n        ll sum = 0;\n        int popcnt = 0;\n        for(int j = 0; j < right; j++){\n            if(i>>j & 1)    sum += a[left+j], popcnt++;\n        }\n        vb[popcnt].push_back(sum);\n    }\n\n    for(int i = 0; i <= left; i++)   sort(va[i].begin(), va[i].end());\n    for(int i = 0; i <= right; i++)  sort(vb[i].begin(), vb[i].end());\n\n    ll ans = 0;\n    for(int i = 0; i <= left; i++){\n        if(i + right < k)   continue;\n        if(i > k)   break;\n\n        for(int j = 0; j < va[i].size(); j++){\n            ll tmp = va[i][j];\n            ans += max(0ll, (ll)(upper_bound(vb[k-i].begin(), vb[k-i].end(), r-tmp) - \n                            lower_bound(vb[k-i].begin(), vb[k-i].end(), l-tmp)));\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<list>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\n#define mp make_pair\n#define rep(i, n) for(int i=0;i<n;++i)\n#define rrep(i, n) for(int i=n;i>=0;--i)\nconst int inf=1e9+7;\nconst ll mod=1e9+7;\nconst ll mod1=998244353;\nconst ll big=1e18;\nconst double PI=2*asin(1);\n\nint main() {\n  ll N, K, L, R;\n  cin>>N>>K>>L>>R;\n  vector<ll> arr1, arr2;\n  ll tmp;\n  for(int i=0;i<N;++i) {\n    cin>>tmp;\n    if(i<N/2) arr1.push_back(tmp);\n    else arr2.push_back(tmp);\n  }\n  vector<vector<ll> > arr11(K+1), arr22(K+1);\n  int num;\n  for(int bit=0;bit<(1<<arr1.size());++bit) {\n    tmp = 0;\n    num = 0;\n    for(int i=0;i<arr1.size();++i) {\n      if((bit&(1<<i))!=0) {\n        tmp += arr1[i];\n        num++;\n      }\n    }\n    if(num>K) continue;\n    arr11[num].push_back(tmp);\n  }\n  for(int bit=0;bit<(1<<arr2.size());++bit) {\n    tmp = 0;\n    num = 0;\n    for(int i=0;i<arr2.size();++i) {\n      if((bit&(1<<i))!=0) {\n        tmp += arr2[i];\n        num++;\n      }\n    }\n    if(num>K) continue;\n    arr22[num].push_back(tmp);\n  }\n  for(int i=0;i<=K;++i) {\n    sort(arr11[i].begin(), arr11[i].end());\n    sort(arr22[i].begin(), arr22[i].end());\n  }\n  ll ans = 0;\n  ll index1, index2;\n  for(int i=0;i<=K;++i) {\n    for(int j=0;j<arr11[i].size();++j) {\n      index1 = lower_bound(arr22[K-i].begin(), arr22[K-i].end(), L-arr11[i][j]) - arr22[K-i].begin();\n      index2 = upper_bound(arr22[K-i].begin(), arr22[K-i].end(), R-arr11[i][j]) - arr22[K-i].begin();\n      ans += index2 - index1;\n    }\n  }\n  cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\n\nint main(){\n    ll n,k,l,r;\n    cin>>n>>k>>l>>r;\n    ll m=n/2;\n    vector<ll> a,b;\n    for(int i=0;i<m;i++){\n        ll b;\n        cin>>b;\n        a.push_back(b);\n    }\n    for(ll i=m;i<n;i++){\n        ll a;\n        cin>>a;\n        b.push_back(a);\n    }\n    vector<vector<ll>> A,B;\n    ll key=1; key<<=m; key--;\n    A.resize(m+1);\n    for(;k>=0;k--){\n        ll sum=0;\n        ll count=0;\n        for(int i=0;i<m;i++){\n            if(key>>i&1){sum+=a[i]; count++;}\n        }\n        A[count].push_back(sum);\n    }\n    ll R=n-m;\n    key=1; key<<=R; key--;\n    B.resize(R+1);\n    for(;k>=0;k--){\n        ll sum=0;\n        ll count=0;\n        for(int i=0;i<R;i++){\n            if(key>>i&1){sum+=b[i]; count++;}\n        }\n        B[count].push_back(sum);\n    }\n    ll ans=0;\n    for(int i=0;i<=m;i++){\n        sort(A[i].begin(),A[i].end());\n        for(int t=0;t<=R;t++){\n            if(i+t!=k){continue;}\n            sort(B[t].begin(),B[t].end());\n            for(int k=0;k<A[i].size();k++){\n                ll n=A[i][k];\n                auto L=lower_bound(B[i].begin(),B[i].end(),l-n);\n                auto R=upper_bound(B[i].begin(),B[i].end(),r-n);\n                ans+=R-L;\n            }\n        }\n    }\n    cout<<ans<<endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// ref. https://ferin-tech.hatenablog.com/entry/2017/03/29/155630\n\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <unordered_map>\n#include <vector>\n#include <string.h>\n#include <set>\n\nusing namespace std;\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> void printvec(const vector<T>& v) {\n  for (auto x : v) { cout << x << \" \"; }\n  cout << endl;\n}\ntemplate<class T> void printtree(const vector< vector<T> >& tree) {\n  for (long long i = 0; i < tree.size(); ++i) {\n    cout << i + 1 << \": \"; printvec(tree[i]);\n  }\n}\ntemplate<class T, class U> void printmap(const map<T, U>& mp) {\n  for (auto x : mp) { cout << x.first << \"=>\" << x.second << endl; }\n}\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define all(s) s.begin(), s.end()\n#define sz(x) (ll)(x).size()\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> triple;\ntypedef double D;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n\nconst ll INF = 1e9;\nconst ll MOD = 1000000007;  // 1e9 + 7\n\n// BIT (Fenwick Tree) with 0-indexed query\n// https://youtu.be/lyHk98daDJo?t=7960\ntemplate<typename T>\nstruct BIT {\n  int n;\n  vector<T> d;\n  BIT(int n=0) : n(n), d(n+1) {}\n  void add(int i, T x=1) {\n    i++; // 0-indexed to 1-indexed\n    for (; i <= n; i += i&-i) {\n      d[i] += x;\n    }\n  }\n  // The sum of [0, i]\n  T sum(int i) {\n    i++; // 0-indexed to 1-indexed\n    T x = 0;\n    for (; i; i -= i&-i) {\n      x += d[i];\n    }\n    return x;\n  }\n  // The sum of [l, r)\n  T sum(int l, int r) {\n    return sum(r-1) - sum(l-1);\n  }\n};\n\nint main(int argc, char** argv) {\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ios_base::sync_with_stdio(false);\n  //cout << setprecision(10) << fixed;\n\n  ll n, k, l, r;\n  cin >> n >> k >> l >> r;\n  vector<ll> a(n);\n  rep(i,n) {\n    cin >> a[i];\n  }\n\n  ll n2 = n/2;\n  ll remain = n-n2;\n  vector<vector<vector<ll>>> dp(2);\n  dp[0].resize(n2+1); // prev\n  dp[1].resize(remain+1); // latter\n\n  rep(k,2) {\n    ll m = dp[k].size()-1;\n\n    rep(i,1ll<<m) {\n      ll v = 0; // sum of value\n      ll cnt = 0; // count\n      rep(j,m) {\n        if (i&(1ll<<j)) {\n          v += a[j];\n          ++cnt;\n        }\n      }\n      dp[k][cnt].push_back(v);\n    }\n    reverse(all(a));\n  }\n  rep(i,n2) {\n    sort(all(dp[0][i]));\n  }\n\n  vector<vector<ll>>& dp1 = dp[0];\n  vector<vector<ll>>& dp2 = dp[1];\n  // printtree(dp1);\n  // printtree(dp2);\n\n  ll ans = 0;\n  // Try all i in latter\n  rep(i, k+1) { // loop in [0,k]\n    if (i+n2 < k) { continue; } // too small\n    if (i > remain) { continue; } // too large\n    // Here, consider i and k-i.\n    for (ll v : dp2[i]) {\n      // Here, l <= lv+rv <= r\n      // <=> l-rv <= lv <= r-rv\n      ll rdx = upper_bound(all(dp1[k-i]), r-v) - dp1[k-i].begin();\n      ll ldx = lower_bound(all(dp1[k-i]), l-v) - dp1[k-i].begin();\n      // result is count of [lit, rit)\n      ans += rdx-ldx;\n    }\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <string>\n#include <utility>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <climits>\n#include <set>\n#include <cmath>\n#include <numeric>\n#include <iomanip>\n\nusing namespace std;\nlong long a[40];\nvector <long long> coin_num_to_value[21];\nint main(void){\n  int N;\n  int K;\n  long long L;\n  long long R;\n\n  cin >> N >> K >> L >> R;\n  for(int i = 0; i < N; i++){\n    cin >> a[i];\n  }\n\n  int first_half = N / 2;\n  int second_half = N - first_half;\n\n  for(int bitset = 0; bitset < (1 << second_half); bitset++){\n    long long cur_value = 0;\n    int cur_coin_num = 0;\n    for(int i = 0; i < second_half; i++){\n      if(((bitset >> i) & 1) == 1){\n        cur_coin_num ++;\n        cur_value += a[first_half + i];\n      }\n    }\n    coin_num_to_value[cur_coin_num].push_back(cur_value);\n  }\n\n  for(int i = 0; i <= second_half; i++){\n    sort(coin_num_to_value[i].begin(), coin_num_to_value[i].end());\n  }\n\n  long long ans = 0;\n  for(int bitset = 0; bitset < (1 << first_half); bitset++){\n    long long cur_value = 0;\n    int cur_coin_num = 0;\n    for(int i = 0; i < first_half; i++){\n      if(((bitset >> i) & 1) == 1){\n        cur_coin_num ++;\n        cur_value += a[i];\n      }\n    }\n    if(cur_coin_num > K || cur_coin_num + second_half < K){\n      continue;\n    }\n    int coin_num_target = K - cur_coin_num;\n    long long lb = L - cur_value;\n    long long ub = R - cur_value;\n    auto it_l = lower_bound(coin_num_to_value[coin_num_target].begin(), coin_num_to_value[coin_num_target].end(), lb);\n    auto it_r = lower_bound(coin_num_to_value[coin_num_target].begin(), coin_num_to_value[coin_num_target].end(), ub + 1);\n    ans += (it_r - it_l);\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <deque>\n#include <numeric>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n#include <chrono>\n#include <random>\n#include <limits>\n#include <iterator>\n#include <functional>\n#include <sstream>\n#include <complex>\nusing namespace std;\n\nusing ll = long long;\nusing ull = uint64_t;\nusing P = pair<int, int>;\nconstexpr double EPS = 1e-9;\nconstexpr int INF = 1001001001;\nconstexpr int mod = 1000000007;\n// constexpr int mod = 998244353;\n\ntemplate<class T>\ninline bool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, K;\n    ll L, R;\n    cin >> N >> K >> L >> R;\n    vector<ll> a(N);\n    for(int i = 0; i < N; ++i)  cin >> a[i];\n    int M = N / 2;\n    vector<pair<int, ll>> table;\n    for(int bit = 0; bit < (1 << M); ++bit){\n        ll S = 0;\n        for(int i = 0; i < M; ++i){\n            if(bit >> i & 1)    S += a[i];\n        }\n        table.emplace_back(__builtin_popcount(bit), S);\n    }\n    sort(table.begin(), table.end());\n    ll ans = 0;\n    for(int bit = 0; bit < (1 << (N - M)); ++bit){\n        int c = __builtin_popcount(bit);\n        ll S = 0;\n        for(int i = 0; i < N - M; ++i){\n            if(bit >> i & 1)    S += a[M + i];\n        }\n        ans += upper_bound(table.begin(), table.end(), make_pair(K - c, R - S)) - lower_bound(table.begin(), table.end(), make_pair(K - c, L - S));\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n    int n, k;\n    ll l, r;\n    cin >> n >> k >> l >> r;\n\n    int a[n];\n    for(int i = 0; i < n; i++)  cin >> a[i];\n\n    int left = n/2;\n    int right = n - left;\n\n    vector<ll> va[left+1], vb[right+1];\n\n    for(int i = 0; i < 1<<left; i++){\n        ll sum = 0;\n        int popcnt = 0;\n        for(int j = 0; j < left; j++){\n            if(i>>j & 1)    sum += a[j], popcnt++;\n        }\n        va[popcnt].push_back(sum);\n    }\n\n    for(int i = 0; i < 1<<right; i++){\n        ll sum = 0;\n        int popcnt = 0;\n        for(int j = 0; j < right; j++){\n            if(i>>j & 1)    sum += a[left+j], popcnt++;\n        }\n        vb[popcnt].push_back(sum);\n    }\n\n    for(int i = 0; i <= left; i++)   sort(va[i].begin(), va[i].end());\n    for(int i = 0; i <= right; i++)  sort(vb[i].begin(), vb[i].end());\n\n    ll ans = 0;\n    for(int i = 0; i <= left; i++){\n        if(i + right < k)   continue;\n        if(i > k)   break;\n\n        for(int j = 0; j < va[i].size(); j++){\n            ll tmp = va[i][j];\n            ans += max(0ll, (upper_bound(vb[k-i].begin(), vb[k-i].end(), r-tmp) - \n                            lower_bound(vb[k-i].begin(), vb[k-i].end(), l-tmp)));\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n \nusing namespace std;\n \n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n \nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n \ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\nint in(){int a;scanf(\"%d\",&a);return a;}\nll lin(){ll a;scanf(\"%lld\",&a);return a;}\n \nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n \nvi sum[40 / 2 + 1];\n \nint main()\n{\n    ll N = lin(), K = lin(), L = lin(), R = lin();\n \n    vector<ll> A(N);\n \n    rep(i, N) {\n        A[i] = lin();\n    }\n \n    int sz1 = N / 2;\n    rep(bit, 1 << sz1) {\n        int cnt = 0;\n        ll s = 0;\n \n        rep(i, sz1) {\n            if (bit >> i & 1) {\n                cnt++;\n                s += A[i];\n            }\n        }\n \n        sum[cnt].PB(s);\n    }\n \n    rep(i, sz1 + 1) sort(all(sum[i]));\n \n    ll ans = 0;\n \n    int sz2 = N - N / 2;\n    rep(bit, 1 << sz2) {\n        int cnt = 0;\n        ll s = 0;\n \n        rep(i, sz2) {\n            if (bit >> i & 1) {\n                cnt++;\n                s += A[i + sz1];\n            }\n        }\n \n        if (K - cnt < 0 || K - cnt > sz1) continue;\n \n        int pos1 = upper_bound(all(sum[K - cnt]), R - s) - begin(sum[K - cnt]) - 1;\n        int pos2 = lower_bound(all(sum[K - cnt]), L - s) - begin(sum[K - cnt]);\n \n        if (pos2 == sum[K - cnt].size()) continue;\n \n        ans += max(pos1 - pos2 + 1, 0);\n    }\n \n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nlong long n, k, l, r, a[40], pos;\nvector<long long>p[30], q[30];\nint main() {\n\tcin >> n >> k >> l >> r; pos = n / 2;\n\tfor (int i = 0; i < n; i++)cin >> a[i];\n\tfor (int i = 0; i < (1 << pos); i++) {\n\t\tlong long R = 0; for (int j = 0; j < pos; j++) { if ((i / (1 << j)) % 2 == 1) { R += a[j]; } }\n\t\tp[__popcnt(i)].push_back(R);\n\t}\n\tfor (int i = 0; i < (1 << (n - pos)); i++) {\n\t\tlong long R = 0; for (int j = 0; j < n - pos; j++) { if ((i / (1 << j)) % 2 == 1) { R += a[j + pos]; } }\n\t\tq[__popcnt(i)].push_back(R);\n\t}\n\tfor (int i = 0; i < 30; i++)sort(p[i].begin(), p[i].end());\n\tfor (int i = 0; i < 30; i++)sort(q[i].begin(), q[i].end());\n\tlong long cnts = 0;\n\tfor (int i = 0; i <= pos; i++) {\n\t\tint V = k - i; if (V < 0)continue;\n\t\tfor (int j = 0; j < p[i].size(); j++) {\n\t\t\tint pos1 = lower_bound(q[V].begin(), q[V].end(), l - p[i][j]) - q[V].begin();\n\t\t\tint pos2 = lower_bound(q[V].begin(), q[V].end(), r + 1 - p[i][j]) - q[V].begin();\n\t\t\tcnts += pos2 - pos1;\n\t\t}\n\t}\n\tcout << cnts << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) FOR(i,0,n)\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\n#define PB push_back\n#define LB lower_bound\n#define UB upper_bound\n#define PQ priority_queue\n#define UM unordered_map\n#define ALL(a) (a).begin(),(a).end()\ntypedef vector<ll> vi;\ntypedef vector<vector<ll>> vvi;\nconst ll INF = (1ll << 60);\ntypedef pair<ll,ll> pii;\n\nll bitCount(ll a){\n  ll cnt=0;\n  while(a) {cnt+=(a%2); a/=2;}\n  return cnt;\n}\n\nint main(){\n  ll N,K,L,R; cin>>N>>K>>L>>R;\n  vi a(N); REP(i,N) cin>>a[i];\n  ll ans=0;\n  FOR(k,0,K+1) {\n    vi x,y;\n    REP(i,(1ll<<(N/2))) {\n      if(bitCount(i)!=k) continue;\n      ll sum=0;\n      REP(j,(N/2)) if((1ll<<j)&i) sum+=a[j];\n      x.PB(sum);\n    }\n    REP(i,(1ll<<(N-N/2))) {\n      if(bitCount(i)!=K-k) continue;\n      ll sum=0;\n      REP(j,(N-N/2)) if((1ll<<j)&i) sum+=a[N/2+j];\n      y.PB(sum);\n    }\n    sort(ALL(y));\n    for(ll i:x){\n      ans+=distance(LB(ALL(y),L-i),UB(ALL(y),R-i));\n    }\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include <prettyprint.hpp>\n#define debug(...)  cerr << \"[\" << #__VA_ARGS__ << \"]: \", d_err(__VA_ARGS__);\n#else\n#define debug(...) 83;\n#endif\n\nvoid d_err() {\n    cerr << endl;\n}\n\ntemplate <typename H, typename... T>\nvoid d_err(H h, T... t) {\n    cerr << h << \" \";\n    d_err(t...);\n}\n\ntemplate <typename T>\nvoid print(T x) {\n    cout << x << \"\\n\";\n}\n\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define REVFOR(i, m, n) for (int i = (n - 1); i >= (m); --i)\n#define REP(i, n) FOR(i, 0, n)\n#define REVREP(i, n) REVFOR(i, 0, n)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define bcnt __builtin_popcountll\n\ntypedef long long ll;\ntypedef uint64_t ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int,int> Pin;\n\nll INF = 1e16;\nint inf = 1e9;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    int n, k; ll L, R;\n    cin >> n >> k >> L >> R;\n    vll a(n);\n    REP(i, n) cin >> a[i];\n\n    map<int, vll> v1, v2;\n\n    int half = n / 2;\n    REP(i, 1 << half) {\n        ll s = 0;\n        int cnt = 0;\n        REP(j, half) {\n            if (i >> j & 1) {\n                s += a[j];\n                cnt++;\n            }\n        }\n        v1[cnt].pb(s);\n    }\n\n    int remain = n - half;\n    REP(i, 1 << remain) {\n        ll s = 0;\n        int cnt = 0;\n        REP(j, remain) {\n            if (i >> j & 1) {\n                s += a[half + j];\n                cnt++;\n            }\n        }\n        v2[cnt].pb(s);\n    }\n\n    for (auto &e: v1) sort(ALL(e.se));\n    for (auto &e: v2) sort(ALL(e.se));\n\n    ll ans = 0;\n    for(auto &e1: v1) {\n        int k1 = e1.fi; auto& vv1 = e1.se;\n        int k2 = k - k1;\n\n        if (k2 < 0) continue;\n\n        auto& vv2 = v2[k2];\n\n        for(auto &e: vv1) {\n            auto l = lower_bound(ALL(vv2), L - e);\n            auto r = lower_bound(ALL(vv2), R - e + 1);\n            ans += r - l;\n        }\n    }\n\n    print(ans);\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAX 40\n\nint N, K;\nlong long L, R;\nlong long a[MAX];\n\nlong long ans;\nvoid dfs( int k, long long bit, long long sum )\n{\n\tif( k >= K ) {\n\t\tif( L <= sum && sum <= R ) {\n\t\t\tans++;\n\t\t}\n\t\treturn;\n\t}\n\tfor( int j = 0; j < N; j++ ) {\n\t\tif( bit & (1LL << j) ) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs( k + 1, bit | (1LL << j), sum + a[j] );\n\t}\n}\n\nint main()\n{\n\tcin >> N >> K >> L >> R;\n\tfor( int i = 0; i < N; i++ ) {\n\t\tcin >> a[i];\n\t}\n\n\tdfs( 0, 0, 0 );\n\twhile( K > 1 ) {\n\t\tans /= K;\n\t\tK--;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    //input\n    int N, K, L, R;\n    cin >> N >> K >> L >> R;\n    int a[N];\n    for (int i=0;i<N;i++){\n        cin >> a[i];\n    }\n\n    int hn = N/2;\n    vector< vector<ll> > sumList1(hn+1);\n    vector< vector<ll> > sumList2(N-hn+1);\n\n    for (int i=0;i<(1<<hn);i++){\n        ll sum = 0;\n        int weight = 0;\n        for (int j=0;j<hn;j++){\n            if ((i>>j)&1){\n                sum += a[j];\n                weight++;\n            }\n        }\n        sumList1[weight].push_back(sum);\n    }\n\n    for (int i=0;i<(1<<(N-hn));i++){\n        ll sum = 0;\n        int weight = 0;\n        for (int j=0;j<(N-hn);j++){\n            if ((i>>j)&1){\n                sum += a[hn+j];\n                weight++;\n            }\n        }\n        sumList2[weight].push_back(sum);\n    }\n\n    for (int i=0;i<hn;i++){\n        sort(sumList1[i].begin(), sumList1[i].end());\n    }\n/*\n    cout << endl;\n    for (int i=0;i<sumList1.size();i++){\n        for (int j=0;j<sumList1[i].size();j++){\n            cout << sumList1[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    cout << endl;\n    for (int i=0;i<sumList2.size();i++){\n        for (int j=0;j<sumList2[i].size();j++){\n            cout << sumList2[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    cout << endl;\n*/\n    ll result = 0;\n    for (int i=max(0, K-hn);i<min(K,N-hn)+1;i++){\n        for (int j=0;j<sumList2[i].size();j++){\n            vector<ll>::iterator it1 = lower_bound(sumList1[K-i].begin(), sumList1[K-i].end(), L-sumList2[i][j]);\n            vector<ll>::iterator it2 = upper_bound(sumList1[K-i].begin(), sumList1[K-i].end(), R-sumList2[i][j]);\n            ll dist = (ll)distance(it1, it2);\n            result += dist;\n        }\n    }\n\n    cout << result << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Node {\n    ll sum;\n    int bits;\n    \n    Node(ll sum = 0, int bits = 0) : sum(sum), bits(bits) {\n    }\n    \n    bool operator<(const Node& other) const {\n        return bits < other.bits || (bits == other.bits && sum < other.sum);\n    }   \n};\n\nvoid process(vector<ll>& a, int start, int end, vector<Node>& result) {\n    int size = end - start + 1;\n    int bound = (1 << size) - 1;\n    for (int i = 0; i <= bound; i++) {\n        ll sum = 0;\n        int bits = 0;\n        for (int k = 0; k < size; k++) {\n            if ((i & (1 << k)) > 0) {\n                sum += a[start + k];\n                bits++;\n            }\n        } \n        result.push_back(Node(sum, bits));\n    }\n}\n\nint main() {\n    int n, k; \n    ll l, r;\n    cin >> n >> k >> l >> r;\n    vector<ll> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    \n    vector<Node> result1, result2;\n    int m = (n - 1)/2;\n    process(a, 0, m, result1);\n    process(a, m + 1, n - 1, result2);\n    \n    sort(result2.begin(), result2.end());\n    \n//    for (Node& node : result1) {\n//        cout << node.bits << \" \" << node.sum << endl;\n//    }\n//    \n//    cout << \"second\" << endl;\n//    for (Node& node : result2) {\n//        cout << node.bits << \" \" << node.sum << endl;\n//    }\n    \n    ll count = 0;\n    for (Node& node : result1) {\n        if (node.bits <= k) {\n            count += upper_bound(result2.begin(), result2.end(), Node(r - node.sum, k - node.bits)) -\n                    lower_bound(result2.begin(), result2.end(), Node(l - node.sum, k - node.bits));\n        }\n    }\n    cout << count << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define INF 99999999\n#define FER 0.0000000001\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\nstruct Edge\n{\n\tint s, t, w;\n\tEdge(int s,int t,int w):s(s),t(t),w(w){}\n\tEdge() :Edge(-1, -1, -1) {}\n\tbool operator<(const Edge& e)const\n\t{\n\t\treturn w != e.w ? w < e.w : (s != e.s ? s < e.s : t < e.t);\n\t}\n};\n\n\nstruct P\n{\n\tdouble x, y;\n\tP(double x, double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn (x*x + y*y);\n\t}\n\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};\n\nstruct Rectangle\n{\n\tint h;\n\tint p;\n\tRectangle(int h,int p):h(h),p(p){}\n};\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tll N, K, L, R;\n\tcin >> N >> K >> L >> R;\n\n\tvector<ll> a(N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> a[i];\n\t}\n\n\tvector<vector<ll>> va(N + 1), vb(N + 1);\n\tva[0].push_back(0);\n\tvb[0].push_back(0);\n\n\tfor (int i = 0; i < (N / 2); i++)\n\t{\n\t\tfor (int k = K - 1; k >= 0; k--)\n\t\t{\n\t\t\tfor (int j = 0; j != va[k].size(); j++)\n\t\t\t{\n\t\t\t\tva[k + 1].push_back(va[k][j] + a[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = (N / 2); i < N; i++)\n\t{\n\t\tfor (int k = K - 1; k >= 0; k--)\n\t\t{\n\t\t\tfor (int j = 0; j != vb[k].size(); j++)\n\t\t\t{\n\t\t\t\tvb[k + 1].push_back(vb[k][j] + a[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (int k = 0; k <= K; k++)\n\t{\n\t\tsort(va[k].begin(), va[k].end());\n\t\tsort(vb[K - k].begin(), vb[K - k].end());\n\t\tfor (int j = 0; j != va[k].size(); j++)\n\t\t{\n\t\t\tans += (upper_bound(vb[K - k].begin(), vb[K - k].end(), R - va[k][j]) - lower_bound(vb[K - k].begin(), vb[K - k].end(), L - va[k][j]));\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define INF 1000000000\n#define mod 1000000007\nusing ll=long long;\nconst ll LINF = 1001002003004005006ll;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\nvector<ll> l,r;\n\n\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    ll n,k,lw,hi;cin>>n>>k>>lw>>hi;\n    rep(i,n){\n        ll t;cin>>t;\n        if(i%2==0)  l.push_back(t);\n        else        r.push_back(t);\n    }\n\n    //r\n    vector<vector<ll>> v(n+1);\n    for(int bit=0;bit<(1<<r.size());bit++){\n        int mai=__builtin_popcount(bit);\n        ll en=0;\n        rep(i,r.size()){\n            if((bit>>i)&1) en+=r[i];\n        }\n        v[mai].push_back(en);\n    }\n\n    rep(i,n) sort(ALL(v[i]));\n\n\n    ll ans=0;\n    //l\n    for(int bit=0;bit<(1<<l.size());bit++){\n        int mai=__builtin_popcount(bit);\n        int need=k-mai;\n        if(need<0) continue;\n        ll en=0;\n        rep(i,l.size()){\n            if((bit>>i)&1) en+=l[i];\n        }\n        ans+=lower_bound(ALL(v[need]),hi-en+1)-lower_bound(ALL(v[need]),lw-en);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n    int n, k;\n    ll l, r;\n    cin >> n >> k >> l >> r;\n\n    int a[n];\n    for(int i = 0; i < n; i++)  cin >> a[i];\n\n    int left = n/2;\n    int right = n - left;\n\n    vector<ll> va[left+1], vb[right+1];\n\n    for(int i = 0; i < 1<<left; i++){\n        ll sum = 0;\n        int popcnt = 0;\n        for(int j = 0; j < left; j++){\n            if(i>>j & 1)    sum += a[j], popcnt++;\n        }\n        va[popcnt].push_back(sum);\n    }\n\n    for(int i = 0; i < 1<<right; i++){\n        ll sum = 0;\n        int popcnt = 0;\n        for(int j = 0; j < right; j++){\n            if(i>>j & 1)    sum += a[left+j], popcnt++;\n        }\n        vb[popcnt].push_back(sum);\n    }\n\n    for(int i = 0; i <= left; i++)   sort(va[i].begin(), va[i].end());\n    for(int i = 0; i <= right; i++)  sort(vb[i].begin(), vb[i].end());\n\n    ll ans = 0;\n    for(int i = 0; i <= left; i++){\n        if(i + right < k)   continue;\n        if(i > k)   break;\n\n        for(int j = 0; j < va[i].size(); j++){\n            ll tmp = va[i][j];\n            ans += max(0, (int)(upper_bound(vb[k-i].begin(), vb[k-i].end(), r-tmp) - \n                            lower_bound(vb[k-i].begin(), vb[k-i].end(), l-tmp)));\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\n/*\n http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_4_B&lang=jp\n \n ??????????????????????????? II\n N ?????????????????????????????????????????????????????????????????????ai ?????§??????E ??????, ????????????K ?????????????????????????????¨?????£?????????, ?????????????¨????L ?????\\??? R ?????\\?????????????????¨?????£???????????????????????????????????????????????????????????????????????§????????????? ?????????, ????????????????????????????????\\??????????????¨????????????\n \n Constraints\n 1 ??? K ??? N ??? 40\n 1 ??? ai ??? 1016\n 1 ??? L ??? R ??? 1016\n ??\\?????????????????´??°??§???????????????\n \n Output\n ?????????????????°??? 1 ???????????????????????????\n */\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll N,K,L,R; cin >> N >> K >> L >> R;\n    vector<ll> a(N);\n    for(int i = 0; i < N;i++) cin >> a[i];\n    \n    \n    /*\n     bit?????¨???????????§N/2?????¨????????´????????¨???????????????\n     ??????????????????N - N/2??????????????? L - X <= (Y) <= R - X?????¨???????????????\n     O(N^20) + O(N^20*logM)\n     */\n    vector<vector<ll>> half_Sum(N/2 + 1);\n    ll n1 = N/2;\n    for(int i = 0; i < (1<<n1);i++){\n        ll sum = 0;\n        ll cnt = 0;\n        for(int j = 0; j < n1;j++){\n            if((i >> j)&1){\n                cnt++;\n                sum += a[j];\n            }\n        }\n        half_Sum[cnt].emplace_back(sum);\n    }\n    ll ans = 0;\n    ll n2 = N - n1;\n    for(int i = 0; i < (1<<n2);i++){\n        ll sum = 0;\n        ll cnt = 0;\n        for(int j = 0; j < n2;j++){\n            if((i>>j)&1){\n                cnt++;\n                sum += a[n1 + j];\n            }\n        }\n        \n        if(!(K - cnt >= 0)|| n1 + cnt < K)continue;\n        \n        ll it1 = upper_bound(half_Sum[K-cnt].begin(), half_Sum[K-cnt].end(), R - sum) - half_Sum[K-cnt].begin();\n        ll it2 = lower_bound(half_Sum[K-cnt].begin(), half_Sum[K-cnt].end(), L - sum) - half_Sum[K-cnt].begin();\n        \n        if(it1 - it2 <= 0) continue;\n        ans += it1 - it2;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define LOOP(i) while(i--)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto pitr=c.begin();pitr!=c.end();++pitr){cout<<*pitr;if(next(pitr,1)!=c.end())cout<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\tint N=in(),K=in();\n\tll L=in<ll>(),R=in<ll>();\n\tauto A=vecin<ll>(N);\n\n\tll H=N/2;\n\tll PH=1LL<<H;\n\tvector<pair<ll,ll>> S(PH);\n\tREP(i,PH){\n\t\tll v=i;\n\t\tll sum=0,num=0,index=0;\n\t\twhile(v){\n\t\t\tif(v&1){\n\t\t\t\tnum++;\n\t\t\t\tsum += A[index];\n\t\t\t}\n\t\t\tv>>=1LL;\n\t\t\tindex++;\n\t\t}\n\t\tS[i]=make_pair(num,sum);\n\t}\n\tsort(ALL(S),[](pair<ll,ll>& l,pair<ll,ll>& r){return l.first==r.first?l.second<r.second:l.first<r.first;});\n\n\tll ans=0;\n\tll F=1LL<<(N-H);\n\tREP(i,F){\n\t\tll v=i;\n\t\tll num=0,sum=0,index=0;\n\t\twhile(v){\n\t\t\tif(v&1){\n\t\t\t\tnum++;\n\t\t\t\tsum += A[H+index];\n\t\t\t}\n\t\t\tv>>=1LL;\n\t\t\tindex++;\n\t\t}\n\t\tauto res = equal_range(ALL(S),make_pair(K-num,1LL<<60),PAIRCOMP(first,<));\n\t\tif(res.first!=S.end()){\n\t\t\tauto left = lower_bound(res.first,res.second,make_pair(K-num,L-sum),[](const pair<ll,ll>& l,const pair<ll,ll>& r){return l.first==r.first?l.second<r.second:l.first<r.first;});\n\t\t\tauto right = upper_bound(res.first,res.second,make_pair(K-num,R-sum),[](const pair<ll,ll>& l,const pair<ll,ll>& r){return l.first==r.first?l.second<r.second:l.first<r.first;});\n\t\t\tans += distance(left,right);\n\t\t}\n\t}\n\tout(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1LL << 62;\nconstexpr ll MOD = 1000000007LL;\n\nint N, K, L, R, a[50];\n\nsigned main() {\n    cin >> N >> K >> L >> R;\n    rep(i,0,N) cin >> a[i];\n\n    vector<int> va[K+1], vb[K+1];\n    int A = N / 2, B = N - A;\n    rep(bit,0,1<<A) {\n        int C = __builtin_popcount(bit);\n        if(C > K) continue;\n        int val = 0;\n        rep(i,0,A) if(bit >> i & 1) val += a[i];\n        va[C].push_back(val);\n    }\n\n    rep(bit,0,1<<B) {\n        int C = __builtin_popcount(bit);\n        if(C > K) continue;\n        int val = 0;\n        rep(i,0,B) if(bit >> i & 1) val += a[A+i];\n        vb[C].push_back(val);\n    }\n\n    repq(i,0,K) {\n        va[i].push_back(INF), vb[i].push_back(INF);\n        sort(va[i].begin(), va[i].end());\n        sort(vb[i].begin(), vb[i].end());\n    }\n\n    int ans = 0;\n    repq(i,0,K) {\n        rep(j,0,va[i].size()) {\n            int val = va[i][j];\n            int lb = lower_bound(vb[K-i].begin(), vb[K-i].end(), L-val) - vb[K-i].begin();\n            int ub = upper_bound(vb[K-i].begin(), vb[K-i].end(), R-val) - vb[K-i].begin();\n            // printf(\"i = %lld, A val = %lld, ub = %lld, lb = %lld\\n\", i, va[i][j], ub, lb);\n            ans += (ub - lb);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nll N,K,L,R;\nll a[40];\n \nvector< P > x,y;\n \nvoid pt(int si,int ti,vector< P > &x){\n  int num=ti-si;\n  for(int S=0;S<(1<<num);S++){\n    ll sum=0,cnt=0;\n    for(int j=0;j<num;j++)\n      if(S>>j&1)\n        sum+=a[si+j],cnt++;\n    x.push_back(P(cnt,sum));\n  }\n}\n \nint main(){\n  cin>>N>>K>>L>>R;\n  for(int i=0;i<N;i++)cin>>a[i];\n  pt(0,N/2,x);\n  pt(N/2,N,y);\n \n  sort(y.begin(),y.end());\n   \n  ll ans=0;\n  for(int i=0;i<(int)x.size();i++){\n    vector< P > :: iterator itl,itr;\n    itl=lower_bound(y.begin(),y.end(),P(K-x[i].first,L-x[i].second));\n    itr=upper_bound(y.begin(),y.end(),P(K-x[i].first,R-x[i].second));\n    ans+=(itr-itl);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n);i++)\n#define sz(x) int(x.size())\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint main(){ \n  int n, K;\n  ll L, R;\n  cin >> n >> K >> L >> R;\n  vector<ll> a(n);\n  rep(i,n) cin >> a[i];\n  int l = n/ 2;\n  int r = n - l;\n\n  vector<vector<ll>> left(41), right(41);\n\n  for (int bit = 0; bit < (1 << l); bit++) {\n    ll sum = 0;\n    for (int i = 0; i < l; i++) if (bit & (1 << i)) sum += a[i];\n    left[__builtin_popcount(bit)].emplace_back(sum); \n  }\n\n  for (int bit = 0; bit < (1 << r); bit++) {\n    ll sum = 0;\n    for (int i = 0; i < r; i++) if (bit & (1 << i)) sum += a[l + i];\n    right[__builtin_popcount(bit)].emplace_back(sum); \n  }\n\n  for (int i = 0; i <= l; i++) sort(left[i].begin(), left[i].end());\n  for (int i = 0; i <= r; i++) sort(right[i].begin(), right[i].end());\n\n  ll res = 0;\n\n  for (int d = 0; d <= l; d++) {\n    int x = K - d;\n    if (x > r) continue;\n    if (x < 0) break;\n    ll add = 0;\n    for (auto e : left[d]) add += upper_bound(right[x].begin(), right[x].end(), R - e) - lower_bound(right[x].begin(), right[x].end(), L - e);\n    res += add;\n  }\n  cout << res << endl;\n  return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n//------------------------------- Libraries --------------------------------//\n\n//------------------------------- Type Names -------------------------------//\n\nusing i64 = int_fast64_t;\n\nusing seika = string;\n//akari : 1D, yukari : 2D, maki : 3D vector\ntemplate <class kizuna>\nusing akari = vector<kizuna>;\ntemplate <class yuzuki>\nusing yukari = akari<akari<yuzuki>>;\ntemplate <class tsurumaki>\nusing maki = akari<yukari<tsurumaki>>;\n//akane : ascending order, aoi : decending order\ntemplate <class kotonoha>\nusing akane = priority_queue<kotonoha, akari<kotonoha>, greater<kotonoha>>;\ntemplate <class kotonoha>\nusing aoi = priority_queue<kotonoha>;\n\n//------------------------------- Dubug Functions ---------------------------//\ninline void print()\n{\n    cout << endl;\n}\ntemplate <typename First, typename... Rest>\nvoid print(const First &first, const Rest &... rest)\n{\n    cout << first << ' ';\n    print(rest...);\n}\n//------------------------------- Solver ------------------------------------//\n\nvoid solve()\n{\n    i64 n, k, l, r;\n    cin >> n >> k >> l >> r;\n    akari<i64> as(n), vs[n + 1];\n    for (int i = 0; i < n; i++)\n    {\n        cin >> as[i];\n    }\n    int ofs = n / 2, res = n - ofs;\n    for (int s = 0; s < 1 << ofs; s++)\n    {\n        i64 val = 0;\n        for (int i = 0; i < ofs; i++)\n        {\n            if (s >> i & 1)\n            {\n                val += as[i];\n            }\n        }\n        vs[__builtin_popcount(s)].push_back(val);\n    }\n    for (int i = 0; i <= n; i++)\n    {\n        sort(vs[i].begin(), vs[i].end());\n    }\n    i64 ans = 0;\n    for (int s = 0; s < 1 << res; s++)\n    {\n        i64 val = 0;\n        for (int i = 0; i < res; i++)\n        {\n            if (s >> i & 1)\n            {\n                val += as[ofs + i];\n            }\n        }\n        int i = __builtin_popcount(s);\n        if (i > k)\n            continue;\n        ans += distance(lower_bound(vs[k - i].begin(), vs[k - i].end(), l - val), upper_bound(vs[k - i].begin(), vs[k - i].end(), r - val));\n    }\n    cout << ans << endl;\n}\n\nint main()\n{\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\nint in(){int a;scanf(\"%d\",&a);return a;}\nll lin(){ll a;scanf(\"%lld\",&a);return a;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nvector<ll> sum[40 / 2 + 1];\n\nint main()\n{\n    ll N = in(), K = in(), L = in(), R = in();\n\n    vector<ll> A(N);\n\n    rep(i, N) {\n        A[i] = lin();\n    }\n\n    int sz1 = N / 2;\n    rep(bit, 1 << sz1) {\n        int cnt = 0;\n        ll s = 0;\n\n        rep(i, sz1) {\n            if (bit >> i & 1) {\n                cnt++;\n                s += A[i];\n            }\n        }\n\n        sum[cnt].PB(s);\n    }\n\n    rep(i, sz1 + 1) sort(all(sum[i]));\n\n    ll ans = 0;\n\n    int sz2 = N - N / 2;\n    rep(bit, 1 << sz2) {\n        int cnt = 0;\n        ll s = 0;\n\n        rep(i, sz2) {\n            if (bit >> i & 1) {\n                cnt++;\n                s += A[i + sz1];\n            }\n        }\n\n        if (K - cnt < 0 || K - cnt > sz1) continue;\n\n        int pos1 = upper_bound(all(sum[K - cnt]), R - s) - begin(sum[K - cnt]) - 1;\n        int pos2 = lower_bound(all(sum[K - cnt]), L - s) - begin(sum[K - cnt]);\n\n        if (pos2 == sum[K - cnt].size()) continue;\n\n        ans += max(pos1 - pos2 + 1, 0);\n    }\n\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf INT_MAX\n#define INF LLONG_MAX\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n#define int ll\n#define vi vector<int>\n#define IP pair<int,P>\n#define PI pair<P,int>\n#define PP pair<P,P>\n#define Yes(f){cout<<(f?\"Yes\":\"No\")<<endl;}\n#define YES(f){cout<<(f?\"YES\":\"NO\")<<endl;}\nint Madd(int x,int y) {return (x+y)%M;}\nint Msub(int x,int y) {return (x-y+M)%M;}\nint Mmul(int x,int y) {return (x*y)%M;}\n\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout<<fixed<<setprecision(20);\n\n  int n,k,l,r;\n  cin>>n>>k>>l>>r;\n  vi a(n);\n  rep(i,n){\n    cin>>a[i];\n  }\n\n  vector<vi> v1(n/2+1);\n  vector<vi> v2(n/2+n%2+1);\n\n  rep(bit,1<<(n/2)){\n    int cnt=0;\n    int s=0;\n    rep(i,n/2){\n      if(bit&(1<<i)){\n        cnt++;\n        s+=a[i];\n      }\n    }\n    v1[cnt].PB(s);\n  }\n\n  rep(bit,1<<(n/2+n%2)){\n    int cnt=0;\n    int s=0;\n    rep(i,n/2+n%2){\n      if(bit&(1<<i)){\n        cnt++;\n        s+=a[i+n/2];\n      }\n    }\n    v2[cnt].PB(s);\n  }\n\n  rep(i,n/2+1){\n    sort(all(v1[i]));\n  }\n  rep(i,n/2+n%2+1){\n    sort(all(v2[i]));\n  }\n\n  int ans=0;\n  rep(i,n/2+1){\n    int j=k-i;\n    if(j>=v2.size()) continue;\n    for(int c:v1[i]){\n      //cout<<c<<' '<<j<<endl;\n      ans+=upper_bound(all(v2[j]),r-c)-lower_bound(all(v2[j]),l-c);\n    }\n  }\n\n  cout<<ans<<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N,K,L,R; cin >> N >> K >> L >> R;\n  vector<int> a(N);\n  for(int i = 0; i < N; i++){\n    cin >> a[i];\n  }\n\n  vector<pair<int,int>> v;\n  int n = N/2;\n  for(int i = 0; i < 1 << n; i++){\n    pair<int,int> res = {0,0}; //{cnt,sum}\n    for(int j = 0; j < n; j++){\n      if((i >> j) & 1){\n        res.first++;\n        res.second += a[j];\n      }\n    }\n    v.push_back(res);\n  }\n  sort(v.begin(),v.end());\n\n  int ans = 0;\n  for(int i = 0; i < 1 << (N-n); i++){\n    int cnt = 0,sum = 0;\n    for(int j = 0; j < (N-n); j++){\n      if((i >> j) & 1){\n        cnt++;\n        sum += a[n+j];\n      }\n    }\n    auto left = lower_bound(v.begin(),v.end(),make_pair(K-cnt,L-sum));\n    auto right = upper_bound(v.begin(),v.end(),make_pair(K-cnt,R-sum));\n    ans += right - left;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\nint main(){\n\t\n\tlong long int N, K, L, R, a[100];\n\tcin >> N >> K >> L >> R;\n\t\n\tint n1 = N / 2;\n\tint n2 = N - n1;\n\t\n\tfor(int i = 0; i < n1; i++){\n\t\tcin >> a[i];\n\t}\n\t\n\tvector<long long int> v[N];\n\t\n\tfor(int i = 0; i < (1 << n1); i++){\n\t\tint cnt = 0;\n\t\tlong long int S = 0;\n\t\tfor(int j = 0; j < n1; j++){\n\t\t\tif(i & (1 << j)){\n\t\t\t\tcnt++;\n\t\t\t\tS += a[j];\n\t\t\t}\n\t\t}\n\t\tv[cnt].push_back(S);\n\t}\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tsort(v[i].begin(), v[i].end());\n\t}\n\t\n\tfor(int i = 0; i < n2; i++){\n\t\tcin >> a[i];\n\t}\n\t\n\tlong long int ans = 0;\n\t\n\tfor(int i = 0; i < (1 << n2); i++){\n\t\tint cnt = 0;\n\t\tlong long int S = 0;\n\t\tfor(int j = 0; j < n2; j++){\n\t\t\tif(i & (1 << j)){\n\t\t\t\tcnt++;\n\t\t\t\tS += a[j];\n\t\t\t}\n\t\t}\n\t\tif(K < cnt){\n\t\t\tcontinue;\n\t\t}\n\t\tans += upper_bound(v[K - cnt].begin(), v[K - cnt].end(), R - S) - \n\t\t\tlower_bound(v[K - cnt].begin(), v[K - cnt].end(), L - S);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n  \nll N,K,L,R;\nll a[40];\n  \nvector< P > x,y;\n  \nvoid pt(int si,int ti,vector< P > &x){\n  int num=ti-si;\n  for(int S=0;S<(1<<num);S++){\n    ll sum=0,cnt=0;\n    for(int j=0;j<num;j++)\n      if(S>>j&1)\n        sum+=a[si+j],cnt++;\n    x.push_back(P(cnt,sum));\n  }\n}\n  \nint main(){\n  cin>>N>>K>>L>>R;\n  for(int i=0;i<N;i++)cin>>a[i];\n  pt(0,N/2,x);\n  pt(N/2,N,y);\n  \n  sort(y.begin(),y.end());\n    \n  ll ans=0;\n  for(int i=0;i<(int)x.size();i++){\n    vector< P > :: iterator itl,itr;\n    itl=lower_bound(y.begin(),y.end(),P(K-x[i].first,L-x[i].second));\n    itr=upper_bound(y.begin(),y.end(),P(K-x[i].first,R-x[i].second));\n    ans+=(itr-itl);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    //input\n    int N, K;\n    ll L, R;\n    cin >> N >> K >> L >> R;\n    ll a[N];\n    for (int i=0;i<N;i++){\n        cin >> a[i];\n    }\n\n    int hn = N/2;\n    vector< vector<ll> > sumList1(hn+1);\n    vector< vector<ll> > sumList2(N-hn+1);\n\n    for (int i=0;i<(1<<hn);i++){\n        ll sum = 0;\n        int weight = 0;\n        for (int j=0;j<hn;j++){\n            if ((i>>j)&1){\n                sum += a[j];\n                weight++;\n            }\n        }\n        sumList1[weight].push_back(sum);\n    }\n\n    for (int i=0;i<(1<<(N-hn));i++){\n        ll sum = 0;\n        int weight = 0;\n        for (int j=0;j<(N-hn);j++){\n            if ((i>>j)&1){\n                sum += a[hn+j];\n                weight++;\n            }\n        }\n        sumList2[weight].push_back(sum);\n    }\n\n    for (int i=0;i<hn;i++){\n        sort(sumList1[i].begin(), sumList1[i].end());\n    }\n/*\n    cout << endl;\n    for (int i=0;i<sumList1.size();i++){\n        for (int j=0;j<sumList1[i].size();j++){\n            cout << sumList1[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    cout << endl;\n    for (int i=0;i<sumList2.size();i++){\n        for (int j=0;j<sumList2[i].size();j++){\n            cout << sumList2[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    cout << endl;\n*/\n    ll result = 0;\n    for (int i=max(0, K-hn);i<min(K,N-hn)+1;i++){\n        for (int j=0;j<sumList2[i].size();j++){\n            vector<ll>::iterator it1 = lower_bound(sumList1[K-i].begin(), sumList1[K-i].end(), L-sumList2[i][j]);\n            vector<ll>::iterator it2 = upper_bound(sumList1[K-i].begin(), sumList1[K-i].end(), R-sumList2[i][j]);\n            ll dist = (ll)distance(it1, it2);\n            result += dist;\n        }\n    }\n\n    cout << result << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, ll> pil;\n\nint main(void) {\n  int k, n;\n  ll L, R;\n  cin >> n >> k >> L >> R;\n\n  vector<ll> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n\n  int n2 = n / 2, num;\n  ll sum;\n  vector<pil> v;\n  for (int i = 0; i < (1 << n2); i++) {\n    num = 0, sum = 0;\n    for (int j = 0; j < n2; j++) {\n      if (!(i >> j & 1)) continue;\n      num++;\n      sum += a[j];\n    }\n    v.push_back(pil(num, sum));\n  }\n  sort(v.begin(), v.end());\n\n  ll ans = 0;\n  for (int i = 0; i < (1 << (n - n2)); i++) {\n    num = 0, sum = 0;\n    for (int j = 0; j < n - n2; j++) {\n      if (!(i >> j & 1)) continue;\n      num++;\n      sum += a[j + n2];\n    }\n    ans += upper_bound(v.begin(), v.end(), pil(k - num, R - sum)) - lower_bound(v.begin(), v.end(), pil(k - num, L - sum));\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll N, K, L, R;\nll a[40];\n\nauto enumerate(int sidx, int size) {\n  vector<pair<ll, ll>> ret;\n  for(int i=0; i<1<<size; i++) {\n    if(__builtin_popcount(i) > K) continue;\n    int cnt = 0; ll sum = 0;\n    for(int j=0; j<size; j++)\n      if(i >> j & 1) cnt++, sum += a[sidx + j];\n    ret.emplace_back(cnt, sum);\n  }\n  return ret;\n}\n\nll solve() {\n  auto v0 = enumerate(0, N / 2);\n  auto v1 = enumerate(N / 2, (N + 1) / 2);\n  sort(v0.begin(), v0.end());\n  ll ret = 0;\n  for(int i=0; i<(int)v1.size(); i++)\n    ret +=  upper_bound(v0.begin(), v0.end(), make_pair(K - v1[i].first, R - v1[i].second))\n          - lower_bound(v0.begin(), v0.end(), make_pair(K - v1[i].first, L - v1[i].second));\n  return ret;\n}\n\nint main() {\n  cin >> N >> K >> L >> R;\n  for(int i=0; i<N; i++) cin >> a[i];\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define FOR(i, m, n) for(int i=(m); i<(n); ++i)\n#define rrep(i, n) for(int i=(n)-1; i>=0; --i)\n#define rfor(i, m, n) for(int i=(m); i>=(n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\t\tusing LL = long long;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<LL>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<double>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<LL, LL>;\tusing VPL = vector<PLL>;\ntemplate<class T>using pq = priority_queue<T>;\ntemplate<class T>using pqs = priority_queue<T, vector<T>, greater<T>>;\nconst int inf = (int)1e9;\nconst LL inf_ll = (LL)1e18, MOD = 1000000007;\nconst double PI = acos(-1.0), EPS = 1e-12;\n\ntemplate<class T>inline void Sort(T& a)noexcept { sort(all(a)); }\ntemplate<class T>inline void RSort(T& a)noexcept { sort(rall(a)); }\ntemplate<class T>inline void Reverse(T& a)noexcept { reverse(all(a)); }\ntemplate<class T>inline void Unique(T& a)noexcept { a.erase(unique(all(a)), a.end()); }\ntemplate<class T>inline T Sorted(T a)noexcept { Sort(a); return a; }\ntemplate<class T>inline T RSorted(T a)noexcept { RSort(a); return a; }\ntemplate<class T>inline T Reversed(T a)noexcept { Reverse(a); return a; }\ntemplate<class T>inline T Uniqued(T a)noexcept { Unique(a); return a; }\ntemplate<class T>inline auto Max(const T& a)noexcept { return *max_element(all(a)); }\ntemplate<class T>inline auto Min(const T& a)noexcept { return *min_element(all(a)); }\ntemplate<class T>inline int MaxPos(const T& a)noexcept { return max_element(all(a)) - a.begin(); }\ntemplate<class T>inline int MinPos(const T& a)noexcept { return min_element(all(a)) - a.begin(); }\ntemplate<class T, class U>inline int Count(const T& a, const  U& v)noexcept { return count(all(a), v); }\ntemplate<class T, class U>inline int Find(const T& a, const U& v)noexcept { auto pos = find(all(a), v); return pos == a.end() ? -1 : pos - a.begin(); }\ntemplate<class T, class U>inline U Sum(const T& a, const U& v)noexcept { return accumulate(all(a), v); }\ntemplate<class T, class U>inline int Lower(const T& a, const U& v)noexcept { return lower_bound(all(a), v) - a.begin(); }\ntemplate<class T, class U>inline int Upper(const T& a, const U& v)noexcept { return upper_bound(all(a), v) - a.begin(); }\ntemplate<class T, class P>inline void RemoveIf(T& a, P f)noexcept { a.erase(remove_if(all(a), f), a.end()); }\ntemplate<class T>inline T Age(T n, T m)noexcept { return (n + m - 1) / m; }\ntemplate<class T>inline T Age2(T n, T m)noexcept { return Age(n, m) * m; }\ntemplate<class T>inline T Tri(T n)noexcept { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\ntemplate<class T = long long>inline T BIT(int b)noexcept { return T{ 1 } << b; }\ntemplate<class T>inline T Gcd(T n, T m)noexcept { return m ? Gcd(m, n % m) : n; }\ntemplate<class T>inline T Lcm(T n, T m)noexcept { return n / Gcd(n, m) * m; }\ntemplate<class T>inline T Pow(T a, T n)noexcept { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; }return r; }\ntemplate<class T>inline T Powmod(T a, T n, T m = MOD)noexcept { T r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r; }\ntemplate<class T>inline bool chmax(T& a, const T& b)noexcept { if (a < b) { a = b; return true; } return false; }\ntemplate<class T>inline bool chmin(T& a, const T& b)noexcept { if (a > b) { a = b; return true; } return false; }\ninline string operator*(string s, int n)noexcept { string ret; rep(i, n)ret += s; return ret; }\n\n// --- input --- //\n#if defined(_MSC_VER) || defined(ONLINE_JUDGE)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\ninline int gc()noexcept { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v)noexcept { cin >> v; }\ninline void InputF(char& v)noexcept { while (isspace(v = gc())); }\ninline void InputF(string& v)noexcept {\n\tchar c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v)noexcept {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v)noexcept {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v)noexcept {\n\tfor (auto& e : v)InputF(e);\n}\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>()noexcept {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>()noexcept {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T()noexcept { T v; InputF(v); return v; }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n)noexcept { return InputV(n); }\n\tInputV operator[](pair<int, int> n)noexcept { return InputV(n); }\n\ttemplate<class T, size_t W>array<vector<T>, W> get(int H) {\n\t\tarray<vector<T>, W> ret;\n\t\trep(i, H)rep(j, W) { T x = *this; ret[j].push_back(x); }\n\t\treturn ret;\n\t}\n}in;\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc }; bool isPrint = true;\n\tvoid p(double v) { printf(\"%.20f\", v); } void p(long double v) { printf(\"%.20Lf\", v); }\n\tvoid p(int v) { printf(\"%d\", v); }\tvoid p(LL v) { printf(\"%lld\", v); }\n\tvoid p(char v) { putchar(v); }\t\tvoid p(bool v) { printf(\"%s\", v ? B.t : B.f); }\n\ttemplate<class T>void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); printf(\"%s\", D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.l); p(v[i]); } }\n\tvoid p(const BoolStr& v) { B = v; isPrint = false; } void p(const DivStr& v) { D = v; isPrint = false; }\npublic:\n\tvoid operator()() { printf(\"%s\", D.l); }\n\ttemplate<class H>void operator()(H&& h) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.l); isPrint = true; B = Yes; D = spc;\n\t}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.d); isPrint = true; operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) {\n\t\toperator()(forward<T>(t)...); std::exit(EXIT_SUCCESS);\n\t}\n}out;\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) (void(0))\n#endif\n\n// ---------------------------------------------------------------- //\n\nint main() {\n\tint n = in, k = in;\n\tLL l = in, r = in;\n\tVL a = in[n];\n\n\tint n1 = n / 2, n2 = n - n1;\n\tVVL s1(n1 + 1), s2(n2 + 1);\n\trep(bit, BIT(n1)) {\n\t\tLL sum = 0; int cnt = 0;\n\t\trep(i, n1)if (bit & BIT(i)) {\n\t\t\tsum += a[i]; cnt++;\n\t\t}\n\t\ts1[cnt].pb(sum);\n\t}\n\trep(bit, BIT(n2)) {\n\t\tLL sum = 0; int cnt = 0;\n\t\trep(i, n2)if (bit & BIT(i)) {\n\t\t\tsum += a[n1 + i]; cnt++;\n\t\t}\n\t\ts2[cnt].pb(sum);\n\t}\n\trep(i, n1 + 1)Sort(s1[i]);\n\trep(i, n2 + 1)Sort(s2[i]);\n\n\tLL ans = 0;\n\trep(c1, n1 + 1) {\n\t\tint c2 = k - c1;\n\t\tif (0 > c2 || c2 > n2)continue;\n\t\tfor (auto A : s1[c1]) {\n\t\t\tLL L = l - A, R = r - A;\n\t\t\tans += Upper(s2[c2], R) - Lower(s2[c2], L);\n\t\t}\n\t}\n\tout(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 40\nusing namespace std;\n\nvector<int> A[11];\nint coin[N];\n\nint calc(int bit,int arr[],int n){\n  int res = 0;\n  for(int i=0;i<n;i++) if(bit>>i&1) res += arr[i];\n  return res;\n}\n\nsigned main(){\n\n  int n,K,L,R;\n  cin>>n>>K>>L>>R;\n  for(int i=0;i<n;i++) cin>>coin[i];\n  \n  int a = n/2;\n  int b = n-a;\n  for(int i=0;i<(1<<a);i++){\n    int cnt = __builtin_popcount(i);\n    A[cnt].push_back(calc(i,coin,a));\n  }\n\n  for(int i=0;i<=10;i++)sort(A[i].begin(),A[i].end());\n  \n  int ans = 0;\n  for(int i=0;i<(1<<b);i++){\n    int cnt = __builtin_popcount(i);\n    int br = calc(i,coin+a,b);\n    if(cnt>K) continue;\n    int l = lower_bound(A[K-cnt].begin(),A[K-cnt].end(),L-br) - A[K-cnt].begin();\n    int r = upper_bound(A[K-cnt].begin(),A[K-cnt].end(),R-br) - A[K-cnt].begin();\n    ans += r-l;\n  }\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(ll i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 510000;\nll dy[8] = {0,1,0,-1,1,-1,1,-1};\nll dx[8] = {1,0,-1,0,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){cout << a << \" \" << b << \"\\n\";}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << a << \" \" << b << \" \" << c << \"\\n\";\n}\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\n\nint main(){\n    ll n,k,l,r; cin >> n >> k >> l >> r;\n    vl a(n); rep(i,n) cin >> a[i];\n    vpl fr,ba;\n    rep(bit,1<<(n/2)){\n        ll s = 0;\n        ll cnt = 0;\n        rep(i,n) if(bit>>i & 1) s += a[i], cnt++;\n        fr.emplace_back(cnt,s);\n    }\n    rep(bit,1<<(n-n/2)){\n        ll s = 0;\n        ll cnt = 0;\n        rep(i,n-n/2) if(bit>>i & 1) s += a[i+n/2], cnt++;\n        ba.emplace_back(cnt,s);\n    }\n    sort(all(fr)); sort(all(ba));\n    ll ans = 0;\n    for(auto v : fr){\n        if(v.first > k) break;\n        ans += upper_bound(all(ba),P(k-v.first,r-v.second)) - lower_bound(all(ba),P(k-v.first,l-v.second));\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define STOPIT\n#include <bits/stdc++.h>\n#define loop(n) for (lint ngtkana_is_a_genius = 0; ngtkana_is_a_genius < lint(n); ngtkana_is_a_genius++)\n#define rep(i, begin, end) for (lint i = lint(begin); (i) < lint(end); i++)\n#define all(v) v.begin(), v.end()\n#define rand(l, r) std::uniform_int_distribution<>(l, r)(mt)\nusing lint = long long;\nauto mt = std::mt19937_64(std::random_device{}());\nauto cmn = [](auto& a, auto b){ if (a > b) {a = b; return true;} return false; };\nauto cmx = [](auto& a, auto b){ if (a < b) {a = b; return true;} return false; };\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }\n#ifndef STOPIT\n#define debug(...)\\\n  do {\\\n    std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n    debug_impl(__VA_ARGS__);\\\n    std::cerr << std::noboolalpha;\\\n  } while (false)\n#else\n#define debug(...) {}\n#endif\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr>\nstd::istream& operator>> (std::istream& is, Container& v)\n  { for (auto & x : v) { is >> x; } return is; }\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n os << \"{\";\n  for (auto it = v.begin(); it != v.end(); it++)\n    {os << (it != v.begin() ? \",\" : \"\") << *it;}\n  return os << \"}\";\n}\n\n/*\n半分全列挙です。\n前半と後半で、あり得る組み合わせをそれぞれ vector で列挙し、ソートです。\n前半を全探索します。前半が x なら 後半hは [L-x,R-x] なので、二分探索で数えます。\n*/\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n, k; std::cin >> n >> k;\n  lint L, R; std::cin >> L >> R;\n  std::vector<lint> a(n); std::cin>>a;\n  debug(k,L,R,a);\n\n  auto make = [&] (auto&& a) {\n    int n = a.size();\n    int N = 1<<n;\n    lint sum = 0;\n    int count = 0;\n    std::vector<int> now(n,0);\n    std::vector<std::vector<lint>> ans(n+1);\n    ans.at(0) = {0};\n    rep(bs,1,N) {\n      int i = __builtin_ctz(bs);\n      int & b = now.at(i);\n      b ^= 1;\n      sum += (b ? +1 : -1) * a.at(i);\n      count += b ? +1 : -1;\n      ans.at(count).push_back(sum);\n    }\n    for (auto& v : ans) {\n      std::sort(all(v));\n    }\n    return ans;\n  };\n  int l = n / 2;\n  auto former = make(std::vector<lint>(a.begin(),a.begin()+l));\n  auto latter = make(std::vector<lint>(a.begin()+l,a.end()));\n  for (auto& v : former) {\n    std::reverse(all(v));\n  }\n  debug(former,latter);\n\n  lint ans = 0;\n  rep(k0,0,k+1) {\n    int k1 = k - k0;\n    if (l < k0 || n-l < k1) continue;\n    auto& v0 = former.at(k0);\n    auto& v1 = latter.at(k1);\n    for (lint x0 : v0) {\n      lint l = L - x0;\n      lint r = R - x0;\n      auto lb = std::lower_bound(all(v1),l);\n      auto ub = std::upper_bound(all(v1),r);\n      lint now = ub - lb;\n      debug(now);\n      ans += now;\n    }\n    debug(v0,v1);\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int int64_t\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\n#define maxup(ans, x) (ans = (ans < x ? x : ans))\n#define minup(ans, x) (ans = (ans > x ? x : ans))\n\n#define breakif(cond) if(cond) break; else\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nvoid comb(int idx, int rem, int sum, V& data, V& v) {\n\tif (rem == 0) {\n\t\tv.push_back(sum);\n\t\treturn;\n\t}\n\tif (idx == data.size()) return;\n\tcomb(idx + 1, rem, sum, data, v);\n\tcomb(idx + 1, rem - 1, sum + data[idx], data, v);\n}\n\nsigned main() {\n\tint n, k, l, r; cin >> n >> k >> l >> r;\n\tV as(n); input(as);\n\tV x; x.insert(x.begin(), as.begin(), as.begin() + as.size() / 2);\n\tV y; y.insert(y.begin(), as.begin() + as.size() / 2, as.end());\n\tint ans = 0;\n\trep(p, 0, k + 1) {\n\t\tint q = k - p;\n\t\tV ps, qs;\n\t\tcomb(0, p, 0, x, ps);\n\t\tcomb(0, q, 0, y, qs);\n\t\tsort(all(ps));\n\t\tsort(all(qs));\n\t\tif (ps.size() == 0) ps.push_back(0);\n\t\tif (qs.size() == 0) qs.push_back(0);\n\t\tfor (int s : ps) ans += upper_bound(all(qs), r - s) - lower_bound(all(qs), l - s);\n\t}\n\tcout << ans << endl;\n\tsystem(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,k,l,r;\n  cin>>n>>k>>l>>r;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n\n  Int h=20;\n  if(n<=h){\n    Int ans=0;\n    for(Int b=0;b<(1<<n);b++){\n      Int c=0,s=0;\n      for(Int i=0;i<n;i++)\n\tif((b>>i)&1) c++,s+=a[i];\n      if(c==k&&l<=s&&s<=r) ans++;\n    }\n    cout<<ans<<endl;\n    return 0;\n  }\n\n  vector<vector<Int> > v(h+1);\n  for(Int b=0;b<(1<<h);b++){\n    Int c=0,s=0;\n    for(Int i=0;i<n;i++)\n      if((b>>i)&1) c++,s+=a[i];\n    v[c].emplace_back(s);\n  }\n  for(Int i=0;i<=h;i++) sort(v[i].begin(),v[i].end());\n  //cout<<\"OK\"<<endl;\n  \n  Int ans=0;\n  for(Int b=0;b<(1<<(n-h));b++){\n    Int c=0,s=0;\n    for(Int i=0;i<(n-h);i++)\n      if((b>>i)&1) c++,s+=a[h+i];\n    if(c>k||k-c>h) continue;\n    //cout<<c<<\" \"<<s<<\":\"<<k<<endl;\n    auto latte=upper_bound(v[k-c].begin(),v[k-c].end(),r-s);\n    auto malta=lower_bound(v[k-c].begin(),v[k-c].end(),l-s);\n    ans+=latte-malta;\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 25\n\nint main() {\n    int n, k;\n    ll l, r;\n    cin >> n >> k >> l >> r;\n    ll a[n];\n    rep(i,n)cin >> a[i];\n    sort(a,a+n);\n    vector<ll> v[k+1];\n    rep(i,1<<(n/2)){\n        int cnt = __builtin_popcount(i);\n        if(cnt > k) continue;\n        bitset<MAX_N> f(i);\n        ll tmp = 0;\n        rep(j,n/2){\n            if(f[j]) tmp += a[j];\n        }\n        v[cnt].push_back(tmp);\n    }\n    \n    rep(i,k+1)sort(v[i].begin(), v[i].end());\n\n    int m = n - n/2;\n    rep(i,m) a[i] = a[i+n/2];\n\n    ll ans = 0;\n\n    rep(i,1<<m){\n        int cnt = __builtin_popcount(i);\n        if(cnt > k) continue;\n        bitset<MAX_N> f(i);\n        ll tmp = 0;\n        rep(j,m){\n            if(f[j]) tmp += a[j];\n        }\n        ans += upper_bound(v[k-cnt].begin(), v[k-cnt].end(), r-tmp) - lower_bound(v[k-cnt].begin(), v[k-cnt].end(), l-tmp);\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n \n \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<int, int> Pi;\ntypedef vector<ll> Vec;\ntypedef vector<int> Vi;\ntypedef vector<string> Vs;\ntypedef vector<P> VP;\ntypedef vector<vector<ll>> VV;\ntypedef vector<vector<int>> VVi;\n\n#define REP(i, a, b) for(ll i=(a); i<(b); i++)\n#define PER(i, a, b) for(ll i=(a); i>=(b); i--)\n#define rep(i, n) REP(i, 0, n)\n#define per(i, n) PER(i, n, 0)\nconst ll INF=1e18+18;\nconst ll MAX=100005;\nconst ll MOD=1000000007;\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\") << endl;\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\") << endl;\n#define ALL(v) v.begin(), v.end()\n#define rALL(v) v.rbegin(), v.rend()\n#define pb(x) push_back(x)\n#define mp(a, b) make_pair(a,b)\n#define Each(a,b) for(auto &a :b)\n#define REPM(i, mp) for (auto i = mp.begin(); i != mp.end(); ++i)\n#define dbg(x_) cerr << #x_ << \":\" << x_ << endl;\n#define dbgmap(mp) cerr << #mp << \":\"<<endl; for (auto i = mp.begin(); i != mp.end(); ++i) { cerr << i->first <<\":\"<<i->second << endl;}\n#define dbgarr(n,m,arr) rep(i,n){rep(j,m){cerr<<arr[i][j]<<\" \";}cerr<<endl;}\n#define dbgdp(n,arr) rep(i,n){cerr<<arr[i]<<\" \";}cerr<<endl;\n#define dbgmint(n,arr) rep(i,n){cerr<<arr[i].x<<\" \";}cerr<<endl;\n#define out(a) cout<<a<<endl\n#define out2(a,b) cout<<a<<\" \"<<b<<endl\n#define vout(v) rep(i,v.size()){cout<<v[i]<<\" \";}cout<<endl\n#define Uniq(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define fi first\n#define se second\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &s, const pair<T1, T2> &p) { return s<<\"(\"<<p.first<<\", \"<<p.second<<\")\"; }\n\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,v.size())i>>v[j];return i;}\n\n// vector\ntemplate<typename T>\nostream &operator<<(ostream &s, const vector<T> &v) {\n    int len=v.size();\n    for(int i=0; i<len; ++i) {\n        s<<v[i];\n        if(i<len-1) s<<\"\t\";\n    }\n    return s;\n}\n\n// 2 dimentional vector\ntemplate<typename T>\nostream &operator<<(ostream &s, const vector<vector<T> > &vv) {\n    int len=vv.size();\n    for(int i=0; i<len; ++i) {\n        s<<vv[i]<<endl;\n    }\n    return s;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout<<std::setprecision(10);\n\n    ll n,k,l,r;\n    cin>>n>>k>>l>>r;\n    Vec a(n);\n    cin>>a;\n    Vec b;\n    Vec c;\n    rep(i,n){\n        if(i<n/2){\n            b.pb(a[i]);\n        }else{\n            c.pb(a[i]);\n        }\n    }\n    ll ans=0;\n\n    rep(j,k+1){\n        Vec x;\n        Vec y;\n        rep(bit,(1LL<<(b.size()))){\n            ll tot = 0;\n            if(__builtin_popcount(bit)!=j)continue;\n            rep(i,b.size()){\n                if(bit & (1LL<<i)){\n                    tot += b[i];\n                }\n            }\n            x.pb(tot);\n        }\n        rep(bit,(1LL<<(c.size()))){\n            ll tot = 0;\n            if(__builtin_popcount(bit)!=k-j)continue;\n            rep(i,c.size()){\n                if(bit & (1LL<<i)){\n                    tot += c[i];\n                }\n            }\n            y.pb(tot);\n        }\n        sort(ALL(x));\n        sort(ALL(y));\n\n        rep(i,x.size()){\n            ll pl = upper_bound(ALL(y),r-x[i])-y.begin();\n            ll mn = lower_bound(ALL(y),l-x[i])-y.begin();\n            ans += pl-mn;\n        }\n    }\n\n    cout<<ans<<endl;\n    return  0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\n#define rep(i, x, y) for (i64 i = i64(x), i##_max_for_repmacro = i64(y); i < i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\ntemplate <i64 p>\nclass fp {\n    public:\n    i64 x;\n    fp() : x(0) {}\n    fp(i64 x_) : x((x_ % p + p) % p) {}\n    fp operator+() const { return fp(x); }\n    fp operator-() const { return fp(-x); }\n    fp& operator+=(const fp& y) {\n        x += y.x;\n        if (x >= p) x -= p;\n        return *this;\n    }\n    fp& operator-=(const fp& y) { return *this += -y; }\n    fp& operator*=(const fp& y) {\n        x = x * y.x % p;\n        return *this;\n    }\n    fp& operator/=(const fp& y) { return *this *= fp(inverse(y.x)); }\n    fp operator+(const fp& y) const { return fp(x) += y; }\n    fp operator-(const fp& y) const { return fp(x) -= y; }\n    fp operator*(const fp& y) const { return fp(x) *= y; }\n    fp operator/(const fp& y) const { return fp(x) /= y; }\n    bool operator==(const fp& y) const { return x == y.x; }\n    bool operator!=(const fp& y) const { return !(*this == y); }\n    i64 extgcd(i64 a, i64 b, i64& x, i64& y) {\n        i64 d = a;\n        if (b != 0) {\n            d = extgcd(b, a % b, y, x);\n            y -= (a / b) * x;\n        } else {\n            x = 1;\n            y = 0;\n        }\n        return d;\n    }\n    i64 inverse(i64 a) {\n        i64 x, y;\n        extgcd(a, p, x, y);\n        return (x % p + p) % p;\n    }\n};\n\ntemplate <i64 p>\ni64 abs(const fp<p>& x) { return x.x; }\n\ntemplate <i64 p>\nistream& operator>>(istream& is, fp<p>& x) {\n    is >> x.x;\n    return is;\n}\n\ntemplate <i64 p>\nostream& operator<<(ostream& os, const fp<p>& x) {\n    os << x.x;\n    return os;\n}\n\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    os << \"[\";\n    for (const auto& v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename A, typename T, size_t size>\nvoid fill(A (&ary)[size], const T& val) {\n    fill((T*)ary, (T*)(ary + size), val);\n}\n\n// x未満の要素の個数を返す\ntemplate <typename T>\ni64 count_less(const vector<T>& v, T x) {\n    return lower_bound(begin(v), end(v), x) - begin(v);\n}\n\n// x以下の要素の個数を返す\ntemplate <typename T>\ni64 count_less_or_equal(const vector<T>& v, T x) {\n    return upper_bound(begin(v), end(v), x) - begin(v);\n}\n\n// xより大きい要素の個数を返す\ntemplate <typename T>\ni64 count_greater(const vector<T>& v, T x) {\n    return end(v) - upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素の個数を返す\ntemplate <typename T>\ni64 count_greater_or_equal(const vector<T>& v, T x) {\n    return end(v) - lower_bound(begin(v), end(v), x);\n}\n\n// x未満の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less(const vector<T>& v, T x) {\n    return *(lower_bound(begin(v), end(v), x) - 1);\n}\n\n// x以下の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less_or_equal(const vector<T>& v, T x) {\n    return *(upper_bound(begin(v), end(v), x) - 1);\n}\n\n// xより大きい要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater(const vector<T>& v, T x) {\n    return *upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater_or_equal(const vector<T>& v, T x) {\n    return *lower_bound(begin(v), end(v), x);\n}\n\nconstexpr int inf = 1.01e9;\nconstexpr i64 inf64 = 4.01e18;\nconstexpr long double eps = 1e-9;\n\n// 実数値のn分探索のループ回数の上限(2分探索なら50でも十分かもしれない)\nconstexpr i64 max_loop = 100;\n\nvoid solve() {\n    //constexpr i64 mod = 1'000'000'007;\n    i64 N,K,L,R;\n    cin >> N >> K >> L >> R;\n    vector<i64> a(N);\n    rep(i,0,N) cin >> a[i];\n\n    // [0, N/2)\n    const i64 first_half_size= N / 2;\n    vector<vector<i64>> first_half(first_half_size + 1);\n    rep(b,0,1l << first_half_size){\n        i64 cnt=0,sum=0;\n        rep(i, 0, first_half_size){\n            if((b>>i)&1){\n                ++cnt;\n                sum+=a[i];\n            }\n        }\n        first_half[cnt].emplace_back(sum);\n    }\n\n    for(auto& v:first_half) sort(begin(v),end(v));\n\n    i64 ans=0;\n\n    // [N/2, N)\n    const i64 second_half_size=N-N/2;\n    const i64 offset=first_half_size;\n    rep(b,0,1l<<second_half_size){\n        i64 cnt=0,sum=0;\n        rep(i,0,second_half_size){\n            if((b>>i)&1){\n                ++cnt;\n                sum+=a[i+offset];\n            }\n        }\n\n        if(cnt>K or K-cnt>first_half_size) continue;\n\n        ans+=count_less_or_equal(first_half[K-cnt],R-sum);\n        ans-=count_less(first_half[K-cnt],L-sum);\n    }\n\n    cout << ans << endl;\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nlong long a[44],L,R;\nint k,n;\nvector<long long>P[22];\nmain()\n{\n\tcin>>n>>k>>L>>R;\n\tint N=(n+1)/2;\n\tfor(int i=0;i<n;i++)cin>>a[i];\n\tfor(int i=0;i<1<<N;i++)\n\t{\n\t\tlong long sum=0;\n\t\tfor(int j=0;j<N;j++)if(i&(1<<j))sum+=a[j];\n\t\tP[__builtin_popcount(i)].push_back(sum);\n\t}\n\tfor(int i=0;i<=N;i++)sort(P[i].begin(),P[i].end());\n\tlong long cnt=0;\n\tfor(int i=0;i<1<<(n-N);i++)\n\t{\n\t\tlong long sum=0;\n\t\tint K=k-__builtin_popcount(i);\n\t\tif(K<0||K>N)continue;\n\t\tfor(int j=0;j<n-N;j++)if(i&(1<<j))sum+=a[N+j];\n\t\tcnt+=distance(lower_bound(P[K].begin(),P[K].end(),L-sum),\n\t\tupper_bound(P[K].begin(),P[K].end(),R-sum));\n\t}\n\tcout<<cnt<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\n/*\n http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_4_B&lang=jp\n \n ??????????????????????????? II\n N ?????????????????????????????????????????????????????????????????????ai ?????§??????E ??????, ????????????K ?????????????????????????????¨?????£?????????, ?????????????¨????L ?????\\??? R ?????\\?????????????????¨?????£???????????????????????????????????????????????????????????????????????§????????????? ?????????, ????????????????????????????????\\??????????????¨????????????\n \n Constraints\n 1 ??? K ??? N ??? 40\n 1 ??? ai ??? 1016\n 1 ??? L ??? R ??? 1016\n ??\\?????????????????´??°??§???????????????\n \n Output\n ?????????????????°??? 1 ???????????????????????????\n */\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll N,K,L,R; cin >> N >> K >> L >> R;\n    vector<ll> a(N);\n    for(int i = 0; i < N;i++) cin >> a[i];\n    \n    \n    /*\n     bit?????¨???????????§N/2?????¨????????´????????¨???????????????\n     ??????????????????N - N/2??????????????? L - X <= (Y) <= R - X?????¨???????????????\n     O(N^20) + O(N^20*logM)\n     */\n    vector<vector<ll>> half_Sum(N/2 + 1);\n    ll n1 = N/2;\n    for(int i = 0; i < (1<<n1);i++){\n        ll sum = 0;\n        ll cnt = 0;\n        for(int j = 0; j < n1;j++){\n            if((i >> j)&1){\n                cnt++;\n                sum += a[j];\n            }\n        }\n        half_Sum[cnt].emplace_back(sum);\n    }\n    ll ans = 0;\n    ll n2 = N - n1;\n    for(int i = 0; i < (1<<n2);i++){\n        ll sum = 0;\n        ll cnt = 0;\n        for(int j = 0; j < n2;j++){\n            if((i>>j)&1){\n                cnt++;\n                sum += a[n1 + j];\n            }\n        }\n        \n        if(!(K - cnt >= 0)|| n1 + cnt < K)continue;\n        \n        ll it1 = upper_bound(half_Sum[K-cnt].begin(), half_Sum[K-cnt].end(), R - sum) - half_Sum[K-cnt].begin();\n        ll it2 = lower_bound(half_Sum[K-cnt].begin(), half_Sum[K-cnt].end(), L - sum) - half_Sum[K-cnt].begin();\n        \n        if(it1 - it2 <= 0) continue;\n        ans += it1 - it2;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (upper_bound(ALL(c),x)-lower_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *min_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\nsigned main()\n{\n   int N ,K, L, R; cin >> N >> K >> L >> R;\n   V<int> a(N); REP(i, N) cin >> a[i];\n\n   V<V<int>> b(K+1);\n   REP(s, 1<<N/2) {\n      int total = 0, num = 0;\n      REP(i, N) if (s >> i & 1) {\n         total += a[i]; num++;\n      }\n      b[num].push_back(total);\n   }\n   REP(i, K+1) SORT(b[i]);\n\n   int ans = 0;\n   REP(s, 1<<N-N/2) {\n      int total = 0, num = 0;\n      REP(i, N) if (s >> i & 1) {\n         total += a[i + N/2]; num++;\n      }\n      if (K < num) continue;\n      ans += (UB(b[K-num], R+1-total) - LB(b[K-num], L-total));\n   }\n   cout << ans << endl;\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define M_PI       3.14159265358979323846   // pi\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> VI;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\n\n#define rep(a,n) for(ll a = 0;a < n;a++)\n#define repi(a,b,n) for(ll a = b;a < n;a++)\n\nstatic const ll INF = 1e15;\n\nconst ll mod = 1000000007;\n\nint main(void)\n{\n\tll n, k, l, r;\n\tcin >> n >> k >> l >> r;\n\tvector<ll> left(n / 2);\n\tvector<ll> right(n - n / 2);\n\trep(i, n / 2) cin >> left[i];\n\trep(i, n - n / 2) cin >> right[i];\n\n\tvector<vector<ll>> ls(left.size() + 1);\n\trep(i, 1LL << left.size()) {\n\t\tll sum = 0;\n\t\tll p = 0;\n\t\trep(j, left.size()) {\n\t\t\tif (i & (1LL << j)) {\n\t\t\t\tsum += left[j];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tls[p].push_back(sum);\n\t}\n\tvector<vector<ll>> rs(right.size() + 1);\n\trep(i, 1LL << right.size()) {\n\t\tll sum = 0;\n\t\tll p = 0;\n\t\trep(j, right.size()) {\n\t\t\tif (i & (1LL << j)) {\n\t\t\t\tsum += right[j];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\trs[p].push_back(sum);\n\t}\n\tfor (auto& p : ls) sort(p.begin(), p.end());\n\tfor (auto& p : rs) sort(p.begin(), p.end());\n\n\tll sum = 0;\n\tfor (int i = 0; i < ls.size(); i++) {\n\t\tfor (int j = 0; j < ls[i].size(); j++) {\n\t\t\tint c = k - i;\n\t\t\tif (c >= 0 && c < rs.size()) {\n\t\t\t\tll cost = ls[i][j];\n\t\t\t\tauto p1 = upper_bound(rs[c].begin(), rs[c].end(), r - cost);\n\t\t\t\tauto p2 = lower_bound(rs[c].begin(), rs[c].end(), l - cost);\n\t\t\t\tsum += p1 - p2;\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"/mnt/c/Users/leafc/dev/compro/lib/template.hpp\"\n\n\n#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define FOR(i, m, n) for (int i = m; i < n; i++)\n#define ALL(v) (v).begin(), (v).end()\n#define coutd(n) cout << fixed << setprecision(n)\n#define ll long long int\n#define vl vector<ll>\n#define vi vector<int>\n#define MM << \" \" <<\n\nusing namespace std;\n\ntemplate <class T> void say(bool val, T yes = \"Yes\", T no = \"No\") { cout << (val ? yes : no) << endl; }\n\ntemplate <class T> void chmin(T &a, T b) {\n  if (a > b)\n    a = b;\n}\n\ntemplate <class T> void chmax(T &a, T b) {\n  if (a < b)\n    a = b;\n}\n\n\n#line 2 \"tmp.cpp\"\n\n// [s,t)の要素で出来うる値を全部作る\nvoid build(int s, int t, vl &a, vector<vl> &v) {\n  int len = t - s;\n  REP(i, (1 << len)) {\n    ll tmp = 0;\n    int cnt = __builtin_popcount(i);\n    FOR(j, s, t) {\n      if ((i >> (j - s)) % 2 == 1)\n        tmp += a[j];\n    }\n    v[cnt].push_back(tmp);\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, k;\n  cin >> n >> k;\n  ll l, r;\n  cin >> l >> r;\n  vl a(n);\n  REP(i, n) { cin >> a[i]; }\n\n  vector<vl> u(n / 2 + 5), v(n / 2 + 5);\n\n  build(0, n / 2, a, v);\n  build(n / 2, n, a, u);\n  for (auto &el : v) {\n    sort(ALL(el));\n  }\n  for (auto &el : u) {\n    sort(ALL(el));\n  }\n\n  ll ans = 0;\n  int size = v.size();\n  REP(i, size) {\n    for (const auto el : v[i]) {\n      if (k - i < 0 || (int)u.size() <= k - i)\n        continue;\n      ans += upper_bound(ALL(u[k - i]), r - el) - lower_bound(ALL(u[k - i]), l - el);\n    }\n  }\n\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <limits>\n\nusing ll = long long;\n\nconst ll INF = std::numeric_limits<ll>::max();\n\nint main() {\n    int N, K;\n    ll L, R;\n    std::cin >> N >> K >> L >> R;\n\n    int M = N / 2;\n    std::vector<ll> a(M);\n    for (auto& e : a) std::cin >> e;\n\n    std::vector<std::map<ll, ll>> cnt(M + 1);\n    for (int k = 0; k <= M; ++k) {\n        cnt[k][-INF] = cnt[k][INF] = 0;\n    }\n\n    for (int b = 0; b < (1 << M); ++b) {\n        int k = __builtin_popcount(b);\n        ll sum = 0;\n        for (int i = 0; i < M; ++i) {\n            if ((b >> i) & 1) sum += a[i];\n        }\n        if (!cnt[k].count(sum)) cnt[k][sum] = 0;\n        ++cnt[k][sum];\n    }\n\n    // 累積和に変換\n    for (int k = 0; k <= M; ++k) {\n        ll psum = 0;\n        for (auto& p : cnt[k]) {\n            psum += p.second;\n            p.second = psum;\n        }\n    }\n\n    M = N - N / 2;\n    a.resize(M);\n    for (auto& e : a) std::cin >> e;\n\n    ll ans = 0;\n    for (int b = 0; b < (1 << M); ++b) {\n        int k = __builtin_popcount(b);\n        if (K - k < 0 || N / 2 < K - k) continue;\n\n        ll sum = 0;\n        for (int i = 0; i < M; ++i) {\n            if ((b >> i) & 1) sum += a[i];\n        }\n        auto l = --cnt[K - k].lower_bound(L - sum);\n        auto r = --cnt[K - k].upper_bound(R - sum);\n        ans += r->second - l->second;\n    }\n\n    std::cout << ans << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) for(int i=0;i < (n);i++)\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SCANF(i) int i;scanf(\"%d\",&i)\nusing namespace std;\nusing P = pair<int,int>;\nconst long long INF = 1LL << 60;\nconst int IINF=100000000;\nconst int MOD = (int)1e9 + 7;\ntypedef long long ll;\n//約数列挙\nvector<long long> divisor(long long n) {\n    vector<long long> ret;\n    for (long long i = 1; i * i <= n; i++) {\n        if (n % i == 0) {\n            ret.push_back(i);\n            if (i * i != n) ret.push_back(n / i);\n        }\n    }\n    //sort(ret.begin(), ret.end()); // 昇順に並べる\n    return ret;\n}\nvector<int> dx={1,0,-1,0};vector<int> dy={0,-1,0,1};\n\nsigned main () {\n    ll n,k,l,r;cin >> n >> k >> l >> r;\n    vector<ll> list(n);\n    REP(i,n)cin >> list[i];\n    ll ind = n/2;\n    vector<vector<ll>> firsthalf(ind+1,vector<ll>());\n    vector<vector<ll>> secondhalf(n-ind+1,vector<ll>());\n    for(ll i=0;i<(1<<ind);i++){\n        ll cnt=0;ll value=0;\n        for(ll j=0;j<ind;j++){\n            if(i >> j & 1)value+=list[j],cnt++;\n        }\n        firsthalf[cnt].push_back(value);\n    }\n    for(ll i=0;i<(1<<n-ind);i++){\n        ll cnt=0;ll value=0;\n        for(ll j=0;j<n-ind;j++){\n            if(i >> j & 1)value+=list[ind+j],cnt++;\n        }\n        secondhalf[cnt].push_back(value);\n    }\n    REP(i,ind)sort(ALL(firsthalf[i]));\n    ll ans=0;\n    for(ll i=max(k-ind,(ll)0);i<min(k,n-ind)+1;i++){\n        vector<ll> target = secondhalf[i];\n        for(int j = 0;j<target.size();j++){\n            ll res = (ll)(upper_bound(ALL(firsthalf[k-i]),r-target[j]) - lower_bound(ALL(firsthalf[k-i]),l-target[j]));\n            ans += res;\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  ll i, j, k, n, ans = 0, l, r;\n  scanf(\"%lld%lld%lld%lld\", &n, &k, &l, &r);\n  ll a[n];\n  for(j = 0; j < n; ++j) scanf(\"%lld\", &a[j]);\n  vector < pair<ll, ll>> v1, v2;\n  for(i = 0; i < 1 << n / 2; ++i) {\n    ll now = 0, nown = 0;\n    for(j = 0; j < n / 2; ++j) if(1 << j & i) {\n      nown++, now += a[j];\n    }\n    pair<ll, ll> p = make_pair(nown, now);\n    v1.push_back(p);\n  }\n  for(i = 0; i < 1 << (n + 1) / 2; ++i) {\n    ll now = 0, nown = 0;\n    for(j = 0; j < (n + 1) / 2; ++j) if(1 << j & i) {\n      nown++, now += a[n / 2 + j];\n    }\n    pair<ll, ll> p = make_pair(nown, now);\n    v2.push_back(p);\n  }\n  sort(v1.begin(), v1.end());\n  sort(v2.begin(), v2.end());\n  vector < pair<ll, ll>>::iterator it;\n  for(it = v1.begin(); it != v1.end(); ++it) {\n    pair<ll, ll> p1 = make_pair(k - (*it).first, l - (*it).second);\n    pair<ll, ll> p2 = make_pair(k - (*it).first, r - (*it).second);\n    ans += upper_bound(v2.begin(), v2.end(), p2) - lower_bound(v2.begin(), v2.end(), p1);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAX 40\n\n\nint N, K;\nlong long L, R;\nlong long a[MAX];\n\n\n\nint main()\n{\n\tcin >> N >> K >> L >> R;\n\tfor( int i = 0; i < N; i++ ) {\n\t\tcin >> a[i];\n\t}\n\n\tvector< long long > v[K+1];\n\tint n1 = N / 2;\n\tint n2 = N - n1;\n\tfor( int i = 0; i < (1 << n1); i++ ) {\n\t\tlong long sum = 0;\n\t\tint cnt = 0;\n\t\tfor( int j = 0; j < n1; j++ ) {\n\t\t\tif( i & (1 << j) ) {\n\t\t\t\tcnt++;\n\t\t\t\tsum += a[j];\n\t\t\t}\n\t\t}\n\t\tif( cnt > K ) {\n\t\t\tcontinue;\n\t\t}\n\t\tv[cnt].push_back( sum );\n\t}\n\tfor( int i = 0; i < K + 1; i++ ) {\n\t\tsort( v[i].begin(), v[i].end() );\n\t}\n\tlong long ans = 0;\n\tfor( int i = 0; i < (1 << n2); i++ ) {\n\t\tlong long sum = 0;\n\t\tint cnt = 0;\n\t\tfor( int j = 0, k = n1; j < n2; j++, k++ ) {\n\t\t\tif( i & (1 << j) ) {\n\t\t\t\tcnt++;\n\t\t\t\tsum += a[k];\n\t\t\t}\n\t\t}\n\t\tif( cnt > K ) {\n\t\t\tcontinue;\n\t\t}\n\t\tauto r = upper_bound( v[K - cnt].begin(), v[K - cnt].end(), R - sum );\n\t\tauto l = lower_bound( v[K - cnt].begin(), v[K - cnt].end(), L - sum );\n\t\tans += r - l;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=100001,INF=1<<30;\n\nint main(){\n\n    int N,K;\n    ll L,R;cin>>N>>K>>L>>R;\n    vector<ll> A(N);\n    for(int i=0;i<N;i++){\n        cin>>A[i];\n    }\n    \n    vector<ll> S[2*N];\n    for(int bit=0;bit<(1<<N/2);bit++){\n        int cnt=0;\n        ll sum=0;\n        for(int i=0;i<N/2;i++){\n            if(bit&(1<<i)){\n                cnt++;\n                sum+=A[i];\n            }\n        }\n        S[cnt].push_back(sum);\n        //cout<<cnt<<\" \"<<sum<<endl;\n    }\n    \n    for(int i=0;i<N;i++){\n        sort(all(S[i]));\n    }\n    \n    ll ans=0;\n    \n    for(int bit=0;bit<(1<<(N-N/2));bit++){\n        int cnt=0;\n        ll sum=0;\n        for(int i=0;i<N-N/2;i++){\n            if(bit&(1<<i)){\n                cnt++;\n                sum+=A[i+N/2];\n            }\n        }\n        if(K<cnt) continue;\n        if(S[K-cnt].size()==0) continue;\n        //cout<<S[K-cnt].size()<<endl;\n        auto left=lower_bound(all(S[K-cnt]),L-sum),right=upper_bound(all(S[K-cnt]),R-sum);\n        ans+=distance(left,right);\n    }\n    \n    cout<<ans<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll N, K, L, R;\nll a[40];\n\nauto enumerate(int sidx, int size) {\n  vector<pair<ll, ll>> ret;\n  for(int i=0; i<1<<size; i++) {\n    int cnt = 0; ll sum = 0;\n    for(int j=0; j<size; j++)\n      if(i >> j & 1) cnt++, sum += a[sidx + j];\n    if(cnt <= K) ret.emplace_back(cnt, sum);\n  }\n  return ret;\n}\n\nll solve() {\n  auto v0 = enumerate(0, N / 2);\n  auto v1 = enumerate(N / 2, (N + 1) / 2);\n  sort(v0.begin(), v0.end());\n  ll ret = 0;\n  for(int i=0; i<(int)v1.size(); i++)\n    ret +=  upper_bound(v0.begin(), v0.end(), make_pair(K - v1[i].first, R - v1[i].second))\n          - lower_bound(v0.begin(), v0.end(), make_pair(K - v1[i].first, L - v1[i].second));\n  return ret;\n}\n\nint main() {\n  cin >> N >> K >> L >> R;\n  for(int i=0; i<N; i++) cin >> a[i];\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll N, K, L, R;\nll a[40];\n\ndecltype(auto) enumerate(int sidx, int size) {\n  vector<pair<ll, ll>> ret;\n  for(int i=0; i<1<<size; i++) {\n    int cnt = 0; ll sum = 0;\n    for(int j=0; j<size; j++)\n      if(i >> j & 1) cnt++, sum += a[sidx + j];\n    ret.emplace_back(cnt, sum);\n  }\n  return ret;\n}\n\nll solve() {\n  auto v0 = enumerate(0, N / 2);\n  auto v1 = enumerate(N / 2, (N + 1) / 2);\n  sort(v0.begin(), v0.end());\n  ll ret = 0;\n  for(int i=0; i<(int)v1.size(); i++)\n    ret +=  upper_bound(v0.begin(), v0.end(), make_pair(K - v1[i].first, R - v1[i].second))\n          - lower_bound(v0.begin(), v0.end(), make_pair(K - v1[i].first, L - v1[i].second));\n  return ret;\n}\n\nint main() {\n  cin >> N >> K >> L >> R;\n  for(int i=0; i<N; i++) cin >> a[i];\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst ll MOD = 1000000007;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e5 + 5);\nconst double EPS = 1e-10;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nll N, K, L, R, a[45];\n\nvoid build(ll bg, ll en, vector<P> &v){\n    ll m = en - bg;\n    for(int i=0; i<(1<<m); i++){\n        ll k=0, sum=0;\n        for(int j=0; j<m; j++){\n            if((i>>j)&1){\n                sum += a[j+bg];\n                k++;\n            }\n        }\n        if(k>K)continue;\n        if(sum>R)continue;\n        v.push_back(P(k,sum));\n    }\n}\n\nint main() {\n    ll cnt = 0;\n    vector<P> s1, s2;\n    cin >> N >> K >> L >> R;\n    REP(i,N) cin >> a[i];\n\n    build(0, N/2, s1);\n    build(N/2, N, s2);\n\n    SORT(s2);\n    for(auto p1 : s1){\n        ll k1 = p1.first, a1 = p1.second;\n        cnt += upper_bound(ALL(s2),P(K-k1,R-a1))-lower_bound(ALL(s2),P(K-k1,L-a1));\n    }\n\n    cout << cnt << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#if __has_include(<boost/multiprecision/cpp_int.hpp>)\n\t#include <boost/multiprecision/cpp_int.hpp>\n\t#include <boost/multiprecision/cpp_dec_float.hpp>\n\tusing bll = boost::multiprecision::cpp_int;\n\tusing bdouble = boost::multiprecision::cpp_dec_float_100;\n\tusing namespace boost::multiprecision;\n#endif\n#if __has_include(<boost/stacktrace.hpp>)\n\t#define BOOST_STACKTRACE_USE_ADDR2LINE\n\t#define BOOST_STACKTRACE_ADDR2LINE_LOCATION /usr/local/opt/binutils/bin/addr2line\n\t#define _GNU_SOURCE 1\n\t#include <boost/stacktrace.hpp>\n#endif\n#ifdef LOCAL_TEST\n\tnamespace std {\n\t\ttemplate<typename T> class dvector : public std::vector<T> {\n\t\tpublic:\n\t\t\tdvector() : std::vector<T>() {}\n\t\t\texplicit dvector(size_t n, const T& value = T()) : std::vector<T>(n, value) {}\n\t\t\tdvector(const std::vector<T>& v) : std::vector<T>(v) {}\n\t\t\tdvector(const std::initializer_list<T> il) : std::vector<T>(il) {}\n\t\t\tdvector(const std::string::iterator first, const std::string::iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const typename std::vector<T>::iterator first, const typename std::vector<T>::iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const typename std::vector<T>::reverse_iterator first, const typename std::vector<T>::reverse_iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const typename std::vector<T>::const_iterator first, const typename std::vector<T>::const_iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const typename std::vector<T>::const_reverse_iterator first, const typename std::vector<T>::const_reverse_iterator last) : std::vector<T>(first, last) {}\n\t\t\tT& operator[](size_t n) {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n); }\n\t\t\t}\n\t\t\tconst T& operator[](size_t n) const {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n); }\n\t\t\t}\n\t\t};\n\t}\n\tclass dbool {\n\tprivate:\n\t\tbool boolvalue;\n\tpublic:\n\t\tdbool() : boolvalue(false) {}\n\t\tdbool(bool b) : boolvalue(b) {}\n\t\toperator bool&() { return boolvalue; }\n\t\toperator const bool&() const { return boolvalue; }\n\t};\n\t#define vector dvector\n\t#define bool dbool\n#endif\n#ifdef LOCAL_DEV\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::vector<T>& v) {\n\t\tfor (size_t i = 0; i < v.size(); ++i){ s << v[i]; if (i < v.size() - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::vector<std::vector<T>>& vv) {\n\t\ts << \"\\\\\\n\"; for (size_t i = 0; i < vv.size(); ++i){ s << vv[i] << \"\\n\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::deque<T>& v) {\n\t\tfor (size_t i = 0; i < v.size(); ++i){ s << v[i]; if (i < v.size() - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::set<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::multiset<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate <typename T, size_t N> std::ostream& operator<<(std::ostream& s, const std::array<T, N>& a) {\n\t\ts << \"{ \"; for (size_t i = 0; i < N; ++i){ s << a[i] << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::map<T1, T2>& m) {\n\t\ts << \"{\\n\"; for (auto itr = m.begin(); itr != m.end(); ++itr){ s << \"\\t\" << (*itr).first << \" : \" << (*itr).second << \"\\n\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::pair<T1, T2>& p) {\n\t\treturn s << \"(\" << p.first << \", \" << p.second << \")\"; }\n\tclass SIGFPE_exception : std::exception {};\n\tclass SIGSEGV_exception : std::exception {};\n\tvoid catch_SIGFPE([[maybe_unused]] int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGFPE_exception(); }\n\tvoid catch_SIGSEGV([[maybe_unused]] int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGSEGV_exception(); }\n\tsigned convertedmain();\n\tsigned main() { signal(SIGFPE, catch_SIGFPE); signal(SIGSEGV, catch_SIGSEGV); return convertedmain(); }\n\t#define main() convertedmain()\n\tvoid debug_impl() { std::cerr << '\\n'; }\n\ttemplate<typename Head, typename... Tail> void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head << (sizeof...(tail) ? \",\" : \"\"); debug_impl(tail...); }\n\t#define debug(...) do { std::cerr << \"(\" << #__VA_ARGS__ << \") =\"; debug_impl(__VA_ARGS__); } while (false)\n#else\n\t#define debug(...) do {} while (false)\n#endif\n//#define int long long\nusing ll = long long;\n//constexpr int INF = (ll)1e9 + 7;//INT_MAX=(1<<31)-1=2147483647\nconstexpr ll INF = (ll)1e18;//(1LL<<63)-1=9223372036854775807\nconstexpr ll MOD = 998244353;//(ll)1e9 + 7;\nconstexpr double EPS = 1e-9;\nconstexpr ll dx[4] = {1, 0, -1, 0};\nconstexpr ll dy[4] = {0, 1, 0, -1};\nconstexpr ll dx8[8] = {1, 0, -1, 0, 1, 1, -1, -1};\nconstexpr ll dy8[8] = {0, 1, 0, -1, 1, -1, 1, -1};\n#define rep(i, n)   for(ll i=0, i##_length=(n); i< i##_length; ++i)\n#define repeq(i, n) for(ll i=1, i##_length=(n); i<=i##_length; ++i)\n#define rrep(i, n)   for(ll i=(n)-1; i>=0; --i)\n#define rrepeq(i, n) for(ll i=(n)  ; i>=1; --i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\nvoid p() { std::cout << '\\n'; }\ntemplate<typename Head, typename... Tail> void p(Head head, Tail... tail) { std::cout << head << (sizeof...(tail) ? \" \" : \"\"); p(tail...); }\ntemplate<typename T> inline void pv(std::vector<T>& v) { for(ll i=0, N=v.size(); i<N; i++) std::cout << v[i] << \" \\n\"[i==N-1]; }\ntemplate<typename T> inline bool chmax(T& a, T b) { return a < b && (a = b, true); }\ntemplate<typename T> inline bool chmin(T& a, T b) { return a > b && (a = b, true); }\ntemplate<typename T> inline void uniq(std::vector<T>& v) { v.erase(std::unique(v.begin(), v.end()), v.end()); }\n\n/*-----8<-----template-----8<-----*/\n\n/*-----8<-----library-----8<-----*/\n\nvoid solve() {\n\tll N,K,L,R;\n\tcin>>N>>K>>L>>R;\n\tvector<ll> a(N);\n\trep(i,N)cin>>a[i];\n\n\tll size0=N/2,size1=N-N/2;\n\tvector<pair<ll,ll>> x;\n\t//bit==0のときの処理をループ前のここで行う\n\tx.push_back({0,0});\n\tll t=0;\n\tfor (ll i = 1; i < (1LL << size0); i++){\n\t\tll bit = i ^ (i >> 1LL);\n\t\tll bitpos = __builtin_ctzll(i);\n\t\tif (((1 << bitpos) & bit) != 0){\n\t\t\t//bit[bitpos] が 0 -> 1 へ変化\n\t\t\tt+=a[bitpos];\n\t\t} else {\n\t\t\t//bit[bitpos] が 1 -> 0 へ変化\n\t\t\tt-=a[bitpos];\n\t\t}\n\t\tx.push_back({t, __builtin_popcount(bit)});\n\t}\n\t\n\tvector<vector<ll>> y(size1+1);\n\t//bit==0のときの処理をループ前のここで行う\n\ty[0].push_back(0);\n\tt=0;\n\tfor (ll i = 1; i < (1LL << size1); i++){\n\t\tll bit = i ^ (i >> 1LL);\n\t\tll bitpos = __builtin_ctzll(i);\n\t\tif (((1 << bitpos) & bit) != 0){\n\t\t\t//bit[bitpos] が 0 -> 1 へ変化\n\t\t\tt+=a[size0+bitpos];\n\t\t} else {\n\t\t\t//bit[bitpos] が 1 -> 0 へ変化\n\t\t\tt-=a[size0+bitpos];\n\t\t}\n\t\ty[__builtin_popcount(bit)].push_back(t);\n\t}\n\tsort(all(x));\n\trep(i,y.size())sort(all(y[i]));\n\tdebug(x);\n\tdebug(y);\n\tll ans=0;\n\trep(i,x.size()){\n\t\tll l=L-x[i].first;\n\t\tll r=R-x[i].first;\n\t\tll nokori=K-x[i].second;\n\t\tif(nokori>size1 || nokori<0)continue;\n\t\tll t=upper_bound(all(y[nokori]),r)-lower_bound(all(y[nokori]),l);\n\t\tans+=t;\n\t}\n\tp(ans);\n}\n\nsigned main() {\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\nvector<ll> v[21];\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  INT(n); INT(k); LL(L); LL(R);\n  vector<ll> a(n);\n  cin >> a;\n  rep(i, bit(n/2)){\n    ll s = 0;\n    rep(j, n/2){\n      if((i>>j)&1)s += a[j];\n    }\n    v[__builtin_popcount(i)].pb(s);\n  }\n  rep(i, n / 2)sort(all(v[i]));\n  ll res = 0;\n  rep(i, bit(n-n/2)){\n    ll s = 0;\n    rep(j, n-n/2){\n      if((i>>j)&1){\n        s += a[n/2+j];\n      }\n    }\n    int rem = k - __builtin_popcount(i);\n    if(rem < 0)continue;\n    res += upper_bound(all(v[rem]), R-s) - lower_bound(all(v[rem]), L-s);\n  }\n  cout << res << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e9 + 7;\nconst ll INF = 1e15;\nconst ld eps = 1e-9;\nconst db PI = atan(1) * 4;\n\ntemplate<typename T, typename S>inline bool upmin(T&a, const S&b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T, typename S>inline bool upmax(T&a, const S&b) { return a < b ? a = b, 1 : 0; }\n\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a%b); }\nll pow(ll a, ll b) {\n\tif (b == 0) {\n\t\treturn 1;\n\t}\n\tif (b == 1) {\n\t\treturn a;\n\t}\n\tll ans = pow(a, b / 2);\n\tans *= ans;\n\tans *= b % 2 == 1 ? a : 1;\n\treturn ans;\n}\n\nnamespace SOLVE {\n\tvoid add(VLL &A, vector<VLL> &countsA, ll index, ll count, ll coinscounted) {\n\t\tcount += index < 0 ? 0 : A[index];\n\t\tcoinscounted++;\n\t\tcountsA[coinscounted].push_back(count);\n\t\t\n\t\tll n = sz(A);\n\t\tREP(i, index + 1, n) {\n\t\t\tadd(A, countsA, i, count, coinscounted);\n\t\t}\n\t}\n\n\tll lowerBound(VLL &A, ll l, ll r, ll number) { // first index that is larger or equal to number\n\t\t// A is sorted\n\t\tll m = (l + r) / 2;\n\t\tif (l == r) {\n\t\t\tif (A[l] >= number) {\n\t\t\t\treturn l;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tif (A[m] < number) {\n\t\t\treturn lowerBound(A, m + 1, r, number);\n\t\t}\n\t\telse {\n\t\t\treturn lowerBound(A, l, m, number);\n\t\t}\n\t}\n\n\tll upperBound(VLL &A, ll l, ll r, ll number) { // last index that is smaller than number\n\t\t// A is sorted\n\t\tll m = (l + r) / 2 + 1;\n\t\tif (l == r) {\n\t\t\tif (A[l] <= number) {\n\t\t\t\treturn l;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tif (A[m] <= number) {\n\t\t\treturn upperBound(A, m, r, number);\n\t\t}\n\t\telse {\n\t\t\treturn upperBound(A, l, m - 1, number);\n\t\t}\n\t}\n\n\n\tvoid main() {\n\t\tll N, K, L, R, temp;\n\t\tVLL A, B;\n\t\tvector<VLL> countsA, countsB;\n\t\tcin >> N >> K >> L >> R;\n\n\t\tREP(i, 0, N / 2) {\n\t\t\tcin >> temp;\n\t\t\tA.push_back(temp);\n\t\t}\n\t\tREP(i, N / 2, N) {\n\t\t\tcin >> temp;\n\t\t\tB.push_back(temp);\n\t\t}\n\t\tcountsA.resize(sz(A) + 1);\n\t\tcountsB.resize(sz(B) + 1);\n\t\tadd(A, countsA, -1, 0, -1);\n\t\tadd(B, countsB, -1, 0, -1);\n\n\t\tll ans = 0;\n\t\tREP(fromA, 0, sz(countsA)) { // coins from A\n\t\t\tll fromB = K - fromA; // coins from B\n\t\t\tif (fromB >= sz(countsB) || fromB < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsort(countsB[fromB].begin(), countsB[fromB].end()); // sort B\n\t\t\t\n\t\t\tfor (ll numberA : countsA[fromA]) { // for every number in A\n\t\t\t\t// cout << numberA << endl;\n\n\t\t\t\tll Bright = R - numberA;\n\t\t\t\tll Bleft = L - numberA;\n\t\t\t\tll lb = lowerBound(countsB[fromB], 0, sz(countsB[fromB]) - 1, Bleft);\n\t\t\t\tll ub = upperBound(countsB[fromB], 0, sz(countsB[fromB]) - 1, Bright);\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\tfor (auto a : countsB[fromB]) {\n\t\t\t\t\tcout << a << ' ';\n\t\t\t\t} cout << endl;\n\t\t\t\tcout << Bleft << ' ' << Bright << endl;\n\t\t\t\tcout << lb << ' ' << ub << endl;\n\t\t\t\t*/\n\n\t\t\t\tif (lb == -1 || ub == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans += (ub - lb + 1);\n\t\t\t\t// cout << ans << endl;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tint t;\n\t//    in(t);\n\tt = 1;\n\twhile (t--) {\n\t\tSOLVE::main();\n\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\nint main() {\n    size_t N, K;\n    long long L, R;\n    scanf(\"%zu %zu %lld %lld\", &N, &K, &L, &R);\n\n    vector<long long> a(N);\n    for (size_t i=0; i<N; ++i)\n        scanf(\"%lld\", &a[i]);\n\n    vector<pair<size_t, long long>> former(1<<(N/2));\n    for (size_t i=0; i<former.size(); ++i)\n        for (size_t j=0; (1u<<j)<=i; ++j)\n            if (1<<j & i) {\n                ++former[i].first;\n                former[i].second += a[j];\n            }\n\n    vector<pair<size_t, long long>> latter(1<<(N-N/2));\n    for (size_t i=0; i<latter.size(); ++i)\n        for (size_t j=0; (1u<<j)<=i; ++j)\n            if (1<<j & i) {\n                ++latter[i].first;\n                latter[i].second += a[N/2+j];\n            }\n\n    sort(latter.begin(), latter.end());\n\n    size_t total=0;\n    for (pair<size_t, long long> v: former) {\n        vector<pair<size_t, long long>>::iterator lb=lower_bound(\n            latter.begin(), latter.end(), make_pair(K-v.first, L-v.second)\n        );\n\n        vector<pair<size_t, long long>>::iterator ub=upper_bound(\n            latter.begin(), latter.end(), make_pair(K-v.first, R-v.second)\n        );\n\n        total += ub-lb;\n    }\n\n    printf(\"%zd\\n\", total);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N,K,L,R; cin>>N>>K>>L>>R;\n    vector<int> a(N);\n    for(int i=0;i<N;i++) cin>>a[i];\n\n    const int X=N/2,Y=(N+1)/2;\n    vector<vector<int>> sumL(X+1),sumR(Y+1);\n    for(int S=0;S<(1<<X);S++){\n        int sum=0;\n        for(int i=0;i<X;i++) if(S>>i&1){\n            sum+=a[i];\n        }\n        sumL[__builtin_popcount(S)].push_back(sum);\n    }\n    for(int S=0;S<(1<<Y);S++){\n        int sum=0;\n        for(int i=0;i<Y;i++) if(S>>i&1){\n            sum+=a[N/2+i];\n        }\n        sumR[__builtin_popcount(S)].push_back(sum);\n    }\n    for(int i=0;i<=Y;i++) sort(sumR[i].begin(),sumR[i].end());\n\n    int ans=0;\n    for(int i=0;i<=min(X,K);i++){\n        if(K-i>Y) continue;\n        for(int l:sumL[i]){\n            ans+=upper_bound(sumR[K-i].begin(),sumR[K-i].end(),R-l)-lower_bound(sumR[K-i].begin(),sumR[K-i].end(),L-l);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<pa,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                    \t\treturn x != p.x ? x<p.x: y<p.y;\n                                    \t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\nint n,V,W,K,N,L,R;\nvector<pas> ve1,ve2;\n\n//int dp[2][10001]={0};\nint a[1010] ;\n           signed main(){\n      cin>>N>>K>>L>>R;\n          int n1=N/2;\n           \tint n2=N-n1;\n           \tfor(int i=0;i<N;i++)cin>>a[i];      \t\n           \tfor(int i=0;i<(1<<n1);i++){\n           \t\tint cnt=0,v=0;\n           \t\tfor(int j=0;j<n1;j++)if(i&(1<<j)){\n           \t\tcnt++;\n           \t\t\tv+=a[j];\n           \t\t}\n           \t\t\tve1.pb({cnt,v});\n           \t}\n           \t\n           \tfor(int i=0;i<(1<<n2);i++){\n           \t\tint cnt=0,v=0;\n           \t\tfor(int j=0;j<n2;j++)if(i&(1<<j)){\n           \t\tcnt++;\n           \t\t\tv+=a[j+n1];\n           \t\t}\n           \t\t\tve2.pb({cnt,v});\n           \t}\n           \n           \tint ans=0;\n           \tsort(ve2.begin(),ve2.end());\n           \tfor(auto v:ve1){\n       //a    \t\tcout<<v.x<<\" \"<<v.y<<endl;\n           \t\t\tans+=upper_bound(ve2.begin(),ve2.end(),(pas){K-v.x,R-v.y})-lower_bound(ve2.begin(),ve2.end(),(pas){K-v.x,L-v.y});\n           \t}\n           \t\n           \tcout<<ans<<endl;\n           }\n             "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vl = vector<ll>;\ntemplate<class T> using vc = vector<T>;\ntemplate<class T> using vvc = vector<vector<T>>;\n\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define repr(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repe(i, l, r) for (ll i = (l); i < (r); i++)\n#define reper(i, l, r) for (ll i = (r)-1; i >= (l); i--)\n#define repa(i,n) for (auto& i: n)\n\ntemplate<class T> inline bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nvoid init() {cin.tie(0);ios::sync_with_stdio(false);cout << fixed << setprecision(15);}\n\n#ifdef DEBUG\ntemplate <class T, class N> void verr(const T& a, const N& n) { rep(i, n) cerr << a[i] << \" \"; cerr << \"\\n\" << flush; }\nll dbgt = 1; void err() { cerr << \"passed \" << dbgt++ << \"\\n\" << flush; }\ntemplate<class H, class... T> void err(H&& h,T&&... t){ cerr<< h << (sizeof...(t)?\" \":\"\\n\") << flush; if(sizeof...(t)>0) err(forward<T>(t)...); }\n#endif\n\nconst ll INF = 4e18;\nconst ld EPS = 1e-11;\nconst ld PI = acos(-1.0L);\nconst ll MOD = 1e9 + 7;\n// const ll MOD = 998244353;\n//--------------------------------------------------------------------------------//\n\nint main() {\n    init();\n    ll N, K, L, R;\n    cin >> N >> K >> L >> R;\n    ll n1 = N / 2, n2 = (N + 1) / 2;\n    vl a1(n1), a2(n2);\n    repa(a, a1) cin >> a;\n    repa(a, a2) cin >> a;\n\n    vvc<ll> c1(21), c2(21);\n    rep(bit, 1<<n1){\n        ll v = 0;\n        rep(i, n1) if (1 << i & bit) v += a1[i];\n        c1[__builtin_popcount(bit)].eb(v);\n    }\n    rep(bit, 1<<n2){\n        ll v = 0;\n        rep(i, n2) if (1 << i & bit) v += a2[i];\n        c2[__builtin_popcount(bit)].eb(v);\n    }\n\n    rep(i, 21) sort(all(c1[i])), sort(all(c2[i]));\n\n    ll ans = 0;\n    rep(i,21){\n        if (K - i > 20) continue;\n        repa(a, c1[i]){\n            ans += upper_bound(all(c2[K - i]), R - a) - lower_bound(all(c2[K - i]), L - a);\n        }\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const T& a = T()) { v.assign(n, a); }\ntemplate<class T, class... Args> void assign(V<T>& v, int n, const Args&... args) { v.resize(n); for (auto&& e : v) assign(e, args...); }\n\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, k; cin >> n >> k;\n  lint l, r; cin >> l >> r, ++r;\n  V<lint> a(n); for (int i = 0; i < n; ++i) cin >> a[i];\n  int n0 = n >> 1, n1 = n - n0;\n  V<> s0(1 << n0);\n  for (int bit = 0; bit < 1 << n0; ++bit) for (int i = 0; i < n0; ++i) if (bit & 1 << i) s0[bit] += a[i];\n  V< pair<int, lint> > s1(1 << n1);\n  for (int bit = 0; bit < 1 << n1; ++bit) {\n    s1[bit].first = __builtin_popcount(bit);\n    for (int i = 0; i < n1; ++i) if (bit & 1 << i) s1[bit].second += a[i + n0];\n  }\n  sort(begin(s1), end(s1));\n  lint res = 0;\n  for (int bit = 0; bit < 1 << n0; ++bit) {\n    int m = __builtin_popcount(bit);\n    res += distance(lower_bound(begin(s1), end(s1), make_pair(k - m, l - s0[bit])), lower_bound(begin(s1), end(s1), make_pair(k - m, r - s0[bit])));\n  }\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    //input\n    int N, K;\n    ll L, R;\n    cin >> N >> K >> L >> R;\n    int a[N];\n    for (int i=0;i<N;i++){\n        cin >> a[i];\n    }\n\n    int hn = N/2;\n    vector< vector<ll> > sumList1(hn+1);\n    vector< vector<ll> > sumList2(N-hn+1);\n\n    for (int i=0;i<(1<<hn);i++){\n        ll sum = 0;\n        int weight = 0;\n        for (int j=0;j<hn;j++){\n            if ((i>>j)&1){\n                sum += a[j];\n                weight++;\n            }\n        }\n        sumList1[weight].push_back(sum);\n    }\n\n    for (int i=0;i<(1<<(N-hn));i++){\n        ll sum = 0;\n        int weight = 0;\n        for (int j=0;j<(N-hn);j++){\n            if ((i>>j)&1){\n                sum += a[hn+j];\n                weight++;\n            }\n        }\n        sumList2[weight].push_back(sum);\n    }\n\n    for (int i=0;i<hn;i++){\n        sort(sumList1[i].begin(), sumList1[i].end());\n    }\n/*\n    cout << endl;\n    for (int i=0;i<sumList1.size();i++){\n        for (int j=0;j<sumList1[i].size();j++){\n            cout << sumList1[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    cout << endl;\n    for (int i=0;i<sumList2.size();i++){\n        for (int j=0;j<sumList2[i].size();j++){\n            cout << sumList2[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    cout << endl;\n*/\n    ll result = 0;\n    for (int i=max(0, K-hn);i<min(K,N-hn)+1;i++){\n        for (int j=0;j<sumList2[i].size();j++){\n            vector<ll>::iterator it1 = lower_bound(sumList1[K-i].begin(), sumList1[K-i].end(), L-sumList2[i][j]);\n            vector<ll>::iterator it2 = upper_bound(sumList1[K-i].begin(), sumList1[K-i].end(), R-sumList2[i][j]);\n            ll dist = (ll)distance(it1, it2);\n            result += dist;\n        }\n    }\n\n    cout << result << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n// macro\n#define rep(i,n) for(i=0;i<n;i++)\n#define ll long long\n#define all(v) v.begin(), v.end()\n\n// code starts\nint main()\n{\n  int n,k;\n  ll l,r;\n  cin>>n>>k>>l>>r;\n  vector<ll> a(n);\n  int i,j;\n  rep(i,n)cin>>a[i];\n  int nl=n/2;\n  int nr=n-nl;\n  vector<vector<ll>> left(nl+1);\n  vector<vector<ll>> right(nr+1);\n  rep(i,1<<nl)\n  {\n    int num=0;\n    ll val=0;\n    rep(j,nl)\n    {\n      if(i&(1<<j))\n      {\n        num++;\n        val+=a[j];\n      }\n    }\n    left[num].emplace_back(val);\n  }\n  rep(i,1<<nr)\n  {\n    int num=0;\n    ll val=0;\n    rep(j,nr)\n    {\n      if(i&(1<<j))\n      {\n        num++;\n        val+=a[nl+j];\n      }\n    }\n    right[num].emplace_back(val);\n  }\n  rep(i,nl+1)sort(all(left[i]));\n  rep(i,nr+1)sort(all(right[i]));\n  ll ans=0;\n  rep(i,nl+1)\n  {\n    if(i>k||i+nr<k)continue;\n    rep(j,left[i].size())\n    {\n      int indl=lower_bound(all(right[k-i]),l-left[i][j])-right[k-i].begin();\n      int indh=upper_bound(all(right[k-i]),r-left[i][j])-right[k-i].begin();\n      ans+=(indh-indl);\n    }\n  }\n  cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define PB push_back\ntypedef long long int ll;\nconst int N=40;\nint main(){\n    int n,k,mid,tot,m,L,R,atot,from,to,cnt;\n    ll l,r,ans=0,a[N],temp;\n    vector<ll> dp[N];\n    scanf(\"%d%d%lld%lld\",&n,&k,&l,&r);\n    for(int i=0;i<n;i++)scanf(\"%lld\",&a[i]);\n    mid=n/2;\n    tot=1<<mid;\n    for(int i=0;i<tot;i++){\n        temp=0;\n        cnt=0;\n        for(int j=0;j<mid;j++)if(i&(1<<j)){\n            temp+=a[j];\n            cnt++;\n        }\n        dp[cnt].PB(temp);\n    }\n    for(int i=0;i<mid;i++)sort(dp[i].begin(),dp[i].end());\n    mid=n-mid;\n    atot=1<<mid;\n    for(int i=0;i<atot;i++){\n        temp=0;\n        cnt=0;\n        for(int j=0;j<mid;j++)if(i&(1<<j)){\n            temp+=a[n-mid+j];\n            cnt++;\n        }\n        if(cnt<=k&&!dp[k-cnt].empty()&&dp[k-cnt].back()+temp>=l&&dp[k-cnt].front()+temp<=r){\n            L=0;\n            R=(int)dp[k-cnt].size()-1;\n            while(R-L>1){\n                m=(R+L)>>1;\n                if(temp+dp[k-cnt][m]<=r)L=m;\n                else R=m;\n            }\n            if(temp+dp[k-cnt][R]<=r)to=R;\n            else to=L;\n            L=0;\n            R=(int)dp[k-cnt].size()-1;\n            while(R-L>1){\n                m=(R+L)>>1;\n                if(temp+dp[k-cnt][m]>=l)R=m;\n                else L=m;\n            }\n            if(temp+dp[k-cnt][L]>=l)from=L;\n            else from=R;\n            if(to-from>=0)ans+=to-from+1;\n        }\n    }\n    printf(\"%lld\\n\",ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n#define SIZE 45\n\n\nint N,K;\nll MIN,MAX;\nll POW[SIZE];\nll coin[SIZE];\nvector<ll> A[SIZE],B[SIZE];\n\n\nint main(){\n\n\tPOW[0] = 1;\n\tfor(int i = 1; i < SIZE; i++){\n\n\t\tPOW[i] = POW[i-1]*2;\n\t}\n\n\tscanf(\"%d %d %lld %lld\",&N,&K,&MIN,&MAX);\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%lld\",&coin[i]);\n\t}\n\n\tif(N == 1){\n\n\t\tll ans = 0;\n\t\tfor(int i = 0; i < N; i++){\n\n\t\t\tif(coin[i] >= MIN && coin[i] <= MAX){\n\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\",ans);\n\t\treturn 0;\n\t}\n\n\tvector<ll> LEFT,RIGHT;\n\tfor(int i = 0; i < N/2; i++){\n\n\t\tLEFT.push_back(coin[i]);\n\t}\n\tfor(int i = N/2; i < N; i++){\n\n\t\tRIGHT.push_back(coin[i]);\n\t}\n\n\tfor(int state = 0; state < POW[LEFT.size()]; state++){\n\n\t\tint num = 0;\n\t\tll sum = 0;\n\n\t\tfor(int loop = 0; loop < LEFT.size(); loop++){\n\t\t\tif(state & POW[loop]){\n\n\t\t\t\tnum++;\n\t\t\t\tsum += LEFT[loop];\n\t\t\t}\n\t\t}\n\t\tA[num].push_back(sum);\n\t}\n\n\tfor(int i = 0; i < LEFT.size(); i++){\n\n\t\tsort(A[i].begin(),A[i].end());\n\t}\n\n\tfor(int state = 0; state < POW[RIGHT.size()]; state++){\n\n\t\tint num = 0;\n\t\tll sum = 0;\n\n\t\tfor(int loop = 0; loop < RIGHT.size(); loop++){\n\t\t\tif(state & POW[loop]){\n\n\t\t\t\tnum++;\n\t\t\t\tsum += RIGHT[loop];\n\t\t\t}\n\t\t}\n\t\tB[num].push_back(sum);\n\t}\n\n\tfor(int i = 0; i < RIGHT.size(); i++){\n\n\t\tsort(B[i].begin(),B[i].end());\n\t}\n\n\tint limit = min(K,(int)LEFT.size());\n\n\tll ans = 0;\n\tint L,R,left,right,mid;\n\n\tfor(int a = 0; a <= limit; a++){\n\n\t\tint b = K-a;\n\t\tif(B[b].size() == 0)continue;\n\n\t\tfor(int i = 0; i < A[a].size(); i++){\n\n\t\t\tL = B[b].size();\n\t\t\tleft = 0,right = B[b].size()-1,mid = (left+right)/2;\n\t\t\twhile(left <= right){\n\n\t\t\t\tif(A[a][i]+B[b][mid] >= MIN){\n\n\t\t\t\t\tL = mid;\n\t\t\t\t\tright = mid-1;\n\t\t\t\t}else{\n\n\t\t\t\t\tleft = mid+1;\n\t\t\t\t}\n\t\t\t\tmid = (left+right)/2;\n\t\t\t}\n\n\t\t\tif(L == B[b].size())continue;\n\n\t\t\tR = -1;\n\t\t\tleft = 0,right = B[b].size()-1,mid = (left+right)/2;\n\t\t\twhile(left <= right){\n\n\t\t\t\tif(A[a][i]+B[b][mid] <= MAX){\n\n\t\t\t\t\tR = mid;\n\t\t\t\t\tleft = mid+1;\n\t\t\t\t}else{\n\n\t\t\t\t\tright = mid-1;\n\t\t\t\t}\n\t\t\t\tmid = (left+right)/2;\n\t\t\t}\n\t\t\tans += max(0,R-L+1);\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n#define SIZE 45\n\n\nint N,K;\nll MIN,MAX;\nll POW[SIZE];\nll coin[SIZE];\nvector<ll> A[SIZE],B[SIZE];\n\n\nint main(){\n\n\tPOW[0] = 1;\n\tfor(int i = 1; i < SIZE; i++){\n\n\t\tPOW[i] = POW[i-1]*2;\n\t}\n\n\tscanf(\"%d %d %lld %lld\",&N,&K,&MIN,&MAX);\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%lld\",&coin[i]);\n\t}\n\n\tif(N == 1){\n\n\t\tll ans = 0;\n\t\tfor(int i = 0; i < N; i++){\n\n\t\t\tif(coin[i] >= MIN && coin[i] <= MAX){\n\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\",ans);\n\t\treturn 0;\n\t}\n\n\tvector<ll> LEFT,RIGHT;\n\tfor(int i = 0; i < N/2; i++){\n\n\t\tLEFT.push_back(coin[i]);\n\t}\n\tfor(int i = N/2; i < N; i++){\n\n\t\tRIGHT.push_back(coin[i]);\n\t}\n\n\tfor(int state = 0; state < POW[LEFT.size()]; state++){\n\n\t\tint num = 0;\n\t\tll sum = 0;\n\n\t\tfor(int loop = 0; loop < LEFT.size(); loop++){\n\t\t\tif(state & POW[loop]){\n\n\t\t\t\tnum++;\n\t\t\t\tsum += LEFT[loop];\n\t\t\t}\n\t\t}\n\t\tA[num].push_back(sum);\n\t}\n\n\tfor(int i = 0; i < LEFT.size(); i++){\n\n\t\tsort(A[i].begin(),A[i].end());\n\t}\n\n\tfor(int state = 0; state < POW[RIGHT.size()]; state++){\n\n\t\tint num = 0;\n\t\tll sum = 0;\n\n\t\tfor(int loop = 0; loop < RIGHT.size(); loop++){\n\t\t\tif(state & POW[loop]){\n\n\t\t\t\tnum++;\n\t\t\t\tsum += RIGHT[loop];\n\t\t\t}\n\t\t}\n\t\tB[num].push_back(sum);\n\t}\n\n\tfor(int i = 0; i < RIGHT.size(); i++){\n\n\t\tsort(B[i].begin(),B[i].end());\n\t}\n\n\tint limit = min(K,(int)LEFT.size());\n\n\tll ans = 0;\n\tint L,R,left,right,mid;\n\n\tfor(int a = 0; a <= limit; a++){\n\n\t\tint b = K-a;\n\t\tif(B[b].size() == 0)continue;\n\n\t\tfor(int i = 0; i < A[a].size(); i++){\n\n\t\t\tL = B[b].size();\n\t\t\tleft = 0,right = B[b].size()-1,mid = (left+right)/2;\n\t\t\twhile(left <= right){\n\n\t\t\t\tif(A[a][i]+B[b][mid] >= MIN){\n\n\t\t\t\t\tL = mid;\n\t\t\t\t\tright = mid-1;\n\t\t\t\t}else{\n\n\t\t\t\t\tleft = mid+1;\n\t\t\t\t}\n\t\t\t\tmid = (left+right)/2;\n\t\t\t}\n\n\t\t\tif(L == B[b].size())continue;\n\n\t\t\tR = -1;\n\t\t\tleft = 0,right = B[b].size()-1,mid = (left+right)/2;\n\t\t\twhile(left <= right){\n\n\t\t\t\tif(A[a][i]+B[b][mid] <= MAX){\n\n\t\t\t\t\tR = mid;\n\t\t\t\t\tleft = mid+1;\n\t\t\t\t}else{\n\n\t\t\t\t\tright = mid-1;\n\t\t\t\t}\n\t\t\t\tmid = (left+right)/2;\n\t\t\t}\n\t\t\tans += max(0,R-L+1);\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  ll i, j, k, n, ans = 0, l, r;\n  scanf(\"%lld%lld%lld%lld\", &n, &k, &l, &r);\n  ll a[n];\n  for(j = 0; j < n; ++j) scanf(\"%lld\", &a[j]);\n  vector < pair<ll, ll> > v1, v2;\n  for(i = 0; i < 1 << n / 2; ++i) {\n    ll now = 0, nown = 0;\n    for(j = 0; j < n / 2; ++j) if(1 << j & i) {\n      nown++, now += a[j];\n    }\n    pair<ll, ll> p = make_pair(nown, now);\n    v1.push_back(p);\n  }\n  for(i = 0; i < 1 << (n + 1) / 2; ++i) {\n    ll now = 0, nown = 0;\n    for(j = 0; j < (n + 1) / 2; ++j) if(1 << j & i) {\n      nown++, now += a[n / 2 + j];\n    }\n    pair<ll, ll> p = make_pair(nown, now);\n    v2.push_back(p);\n  }\n  sort(v1.begin(), v1.end());\n  sort(v2.begin(), v2.end());\n  vector < pair<ll, ll> >::iterator it;\n  for(it = v1.begin(); it != v1.end(); ++it) {\n    pair<ll, ll> p1 = make_pair(k - (*it).first, l - (*it).second);\n    pair<ll, ll> p2 = make_pair(k - (*it).first, r - (*it).second);\n    ans += upper_bound(v2.begin(), v2.end(), p2) - lower_bound(v2.begin(), v2.end(), p1);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline vll Mask2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\ninline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\ninline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(5) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(4);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tfriend mll operator / (ll a, const mll &b) { return mll(a)/b; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 1000000007LL;// 998244353LL;//1000000007LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\n\n\n\nvoid solve()\n{\n\tll N, K, L, R; cin>>N>>K>>L>>R;\n\tvll a = cinv(N);\n\n\tif (N==1){\n\t\tll ans=0;\n\t\tif (L<=a[0] && a[0]<=R) ans++;\n\t\tcout << ans << '\\n';\n\t\treturn;\n\t}\n\tll N1 = N/2+1;\n\tll N2 = N-N1;\n\n\tvvll buf(K+1);\n\tREP(m, 1LL<<N2){\n\t\tvll idxs = Mask2Idx(m);\n\t\tif ((ll)idxs.size() > K) continue;\n\t\tll sum=0;\n\t\tEACH(idx, idxs) sum += a[N1+idx];\n\t\tbuf[idxs.size()].push_back(sum);\n\t}\n\tREP(k, K+1){\n\t\tsort(buf[k].begin(), buf[k].end());\n\t}\n\n\tll ans = 0;\n\tREP(m, 1LL<<N1){\n\t\tvll idxs = Mask2Idx(m);\n\t\tll sz = (ll)idxs.size();\n\t\tif (sz > K) continue;\n\t\tll sum=0;\n\t\tEACH(idx, idxs) sum += a[idx];\n\t\tans += UnderNumOf(buf[K-sz], R-sum) - UnderNumOf(buf[K-sz], L-sum-1);\n\t}\n\tcout << ans << '\\n';\n}\n\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nlong long n, k, l, r, a[40], pos;\nvector<long long>p[30], q[30];\nint main() {\n\tcin >> n >> k >> l >> r; pos = n / 2;\n\tfor (int i = 0; i < n; i++)cin >> a[i];\n\tfor (int i = 0; i < (1 << pos); i++) {\n\t\tlong long R = 0; for (int j = 0; j < pos; j++) { if ((i / (1 << j)) % 2 == 1) { R += a[j]; } }\n\t\tp[builtin_popcount(i)].push_back(R);\n\t}\n\tfor (int i = 0; i < (1 << (n - pos)); i++) {\n\t\tlong long R = 0; for (int j = 0; j < n - pos; j++) { if ((i / (1 << j)) % 2 == 1) { R += a[j + pos]; } }\n\t\tq[builtin_popcount(i)].push_back(R);\n\t}\n\tfor (int i = 0; i < 30; i++)sort(p[i].begin(), p[i].end());\n\tfor (int i = 0; i < 30; i++)sort(q[i].begin(), q[i].end());\n\tlong long cnts = 0;\n\tfor (int i = 0; i <= pos; i++) {\n\t\tint V = k - i; if (V < 0)continue;\n\t\tfor (int j = 0; j < p[i].size(); j++) {\n\t\t\tint pos1 = lower_bound(q[V].begin(), q[V].end(), l - p[i][j]) - q[V].begin();\n\t\t\tint pos2 = lower_bound(q[V].begin(), q[V].end(), r + 1 - p[i][j]) - q[V].begin();\n\t\t\tcnts += pos2 - pos1;\n\t\t}\n\t}\n\tcout << cnts << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <array>\n#include <cmath>\n#include <memory>\nusing namespace std;\n#define DEB(variable) cout << #variable << '=' << variable << endl\n\n#define FOR(LoopVariable,numberOFbegin,numberOFend) for (long long int LoopVariable = (numberOFbegin); (LoopVariable) < (numberOFend); (LoopVariable)++)\n#define DEFOR(LoopVariable,numberOFbegin,numberOFend) for (long long int LoopVariable = (numberOFbegin)-1; (LoopVariable) >= (numberOFend); (LoopVariable)--)\n#define REP(LoopVariable,numberOFend) for(long long int LoopVariable = 0;(LoopVariable)<(numberOFend);LoopVariable++)\n\nusing llint = long long int;\n\nconstexpr long long int linf = numeric_limits<long long int>::max()-5;\nconstexpr long long int inf= numeric_limits<int>::max()-5;\nconstexpr long long int mod = 1000000007;\n\nint main(){\n\n    llint n, k, l, r;\n    cin >> n >> k >> l >> r;\n    vector<llint> v(n);\n    REP(i,n){\n        cin >> v[i];\n    }\n\n    vector<vector<llint>> grid1(1+(n/2), vector<llint>()), grid2(1+(n+1)/2, vector<llint>());\n    for (llint bit = 0; bit < (1<<(n / 2));bit++){\n        llint tmp = 0;\n        REP(j,n/2){\n            if(bit&(1<<j)){\n                tmp += v[j];\n            }\n        }\n        grid1[__builtin_popcountll(bit)].push_back(tmp);\n    }\n    for (llint bit = 0; bit < (1<<((n+1) / 2));bit++){\n        llint tmp = 0;\n        REP(j,(n+1)/2){\n            if(bit&(1<<j)){\n                tmp += v[(n/2)+j];\n            }\n        }\n        grid2[__builtin_popcountll(bit)].push_back(tmp);\n    }\n\n    REP(i,1+n/2){\n        sort(grid1[i].begin(), grid1[i].end());\n    }\n    REP(i,1+(n+1)/2){\n        sort(grid2[i].begin(), grid2[i].end());\n    }\n    llint result = 0;\n    REP(i,1+(n/2)){\n        if(i<=k){\n            REP(j,grid1[i].size()){\n                if(k-i>=0&&k-i<=(n+1)/2){\n                    result += distance(lower_bound(grid2[k - i].begin(), grid2[k - i].end(),l-grid1[i][j] ),\n                    upper_bound(grid2[k - i].begin(), grid2[k - i].end(),r-grid1[i][j] ));\n                }\n              //  cout << result << endl;\n            }\n        }\n    }\n    cout << result << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint N,K;\null L,R;\null a[41];\n\null bitsum(int b, int offset) {\n  ull s = 0;\n  for (int i=0; b>0; b>>=1,i+=1) {\n    if (b & 1) {\n      s += a[offset+i];\n    }\n  }\n  return s;\n}\n\null solve() {\n  int M = N/2;\n  vector<vector<ull>> h(M+1);\n  for (int i=0; i<(1<<M); ++i) {\n    int bc = __builtin_popcount(i);\n    h[bc].push_back(bitsum(i, 1));\n  }\n  for (int i=1; i<=M; ++i) {\n    sort(h[i].begin(), h[i].end());\n  }\n  ull ans = 0;\n  for (int i=0; i<(1<<(N-M)); ++i) {\n    ull s = bitsum(i, M+1);\n    int bc = __builtin_popcount(i);\n    if (K-bc > M) {\n      continue;\n    }\n    ans += upper_bound(h[K-bc].begin(), h[K-bc].end(), R-s) - lower_bound(h[K-bc].begin(), h[K-bc].end(), L-s);\n  }\n  return ans;\n}\n\nint main() {\n  cin>>N>>K>>L>>R;\n  for (int i=0; i<N; ++i) {\n    cin>>a[i+1];\n  }\n  cout<<solve()<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst int64 infll = (1LL << 61) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\n\nint main() {\n  int N, K;\n  int64 L, R;\n\n  cin >> N >> K >> L >> R;\n  vector< int64 > A(N);\n  cin >> A;\n\n  int M = N / 2;\n  vector< int64 > X[41];\n  for(int i = 0; i < 1 << M; i++) {\n    int64 add = 0;\n    for(int j = 0; j < M; j++) {\n      if((i >> j) & 1) add += A[j];\n    }\n    X[__builtin_popcount(i)].push_back(add);\n  }\n  for(int i = 0; i <= M; i++) {\n    sort(begin(X[i]), end(X[i]));\n  }\n\n  int64 ret = 0;\n\n  for(int i = 0; i < 1 << (N - M); i++) {\n    int64 add = 0;\n    for(int j = 0; j < (N - M); j++) {\n      if((i >> j) & 1) add += A[j + M];\n    }\n    int p = __builtin_popcount(i);\n    if(p > K) continue;\n    ret += upper_bound(begin(X[K - p]), end(X[K - p]), R - add) - lower_bound(begin(X[K - p]), end(X[K - p]), L - add);\n  }\n  cout << ret << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\ntemplate<class T>\nvector<T> subvector(vector<T> a, int l, int num) {\n   vector<T> ret;\n   for(int i = l; i < l + num && i < (int)a.size(); i++)ret.emplace_back(a[i]);\n   return ret;\n}\n\nvector<vector<ll>> f(vector<ll> a) {\n    int n = a.size();\n    vector<vector<ll>> res(n + 1);\n    for(int i = 0; i < (1<<n); i++) {\n        ll sum = 0;\n        int c = 0;\n        for(int j = 0; j < n; j++) if(i & (1<<j))sum += a[j], c++;\n        res[c].emplace_back(sum);\n    }\n    for(auto &i : res)sort(i.begin(), i.end());\n    return res;\n}\n\n\nint main()\n{\n    int n, k; ll l, r;\n    cin >> n >> k >> l >> r;\n    vector<ll> a(n);\n    for(int i = 0; i < n; i++)cin >> a[i];\n    int fn = n / 2, bn = n - (n / 2);\n    vector<vector<ll>> fr, bc; // fr[i] := i個の集合\n    fr = f(subvector(a, 0, fn));\n    bc = f(subvector(a, fn, bn));\n\n\n    ll sum = 0;\n    for(int i = 0; i <= fn; i++) {\n        if(k - i < 0 || (k - i) > bn)continue;\n        for(ll j : fr[i]) {\n            sum += upper_bound(bc[k - i].begin(), bc[k - i].end(), r - j) - lower_bound(bc[k - i].begin(), bc[k - i].end(), l - j);\n        }\n    }\n    cout << sum << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\ntypedef pair<ll, ll> P;\n//const double INF = 1e10;\nconst ll INF = LONG_LONG_MAX / 10;\n//const ll INF = (1ll << 31) - 1;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\nbool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\nconst int mod = 1000000007;\n\n\nvoid print_line(vector<ll> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\n\n\nint main() {\n\n    int n, k;\n    ll l, r;\n    cin >> n >> k >> l >> r;\n\n    ll a[n];\n    for (int i = 0; i < n; i++) cin >> a[i];\n\n    int left = n / 2;\n    int right = n - left;\n\n    vector<ll> va[left + 1], vb[right + 1];\n\n    for (int i = 0; i < 1 << left; i++) {\n        ll sum = 0;\n        int popcnt = 0;\n        for (int j = 0; j < left; j++) {\n            if (i >> j & 1) sum += a[j], popcnt++;\n        }\n        va[popcnt].push_back(sum);\n    }\n\n    for (int i = 0; i < 1 << right; i++) {\n        ll sum = 0;\n        int popcnt = 0;\n        for (int j = 0; j < right; j++) {\n            if (i >> j & 1) sum += a[left + j], popcnt++;\n        }\n        vb[popcnt].push_back(sum);\n    }\n\n    for (int i = 0; i <= left; i++) sort(va[i].begin(), va[i].end());\n    for (int i = 0; i <= right; i++) sort(vb[i].begin(), vb[i].end());\n\n    ll ans = 0;\n    for (int i = 0; i <= left; i++) {\n        if (i + right < k) continue;\n        if (i > k) break;\n\n        for (int j = 0; j < va[i].size(); j++) {\n            ll tmp = va[i][j];\n            ans += max(0ll, (ll) (upper_bound(vb[k - i].begin(), vb[k - i].end(), r - tmp) -\n                                  lower_bound(vb[k - i].begin(), vb[k - i].end(), l - tmp)));\n        }\n    }\n\n    cout << ans << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (upper_bound(ALL(c),x)-lower_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *min_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\nsigned main()\n{\n   int N ,K, L, R; cin >> N >> K >> L >> R;\n   V<int> a(N); REP(i, N) cin >> a[i];\n\n   V<V<int>> b(K+1);\n   REP(s, 1<<N/2) {\n      int total = 0, num = 0;\n      REP(i, N/2) if (s >> i & 1) {\n         total += a[i]; num++;\n      }\n      if (K < num) continue;\n      b[num].push_back(total);\n   }\n   REP(i, K+1) SORT(b[i]);\n\n   int ans = 0;\n   REP(s, 1<<N-N/2) {\n      int total = 0, num = 0;\n      REP(i, N-N/2) if (s >> i & 1) {\n         total += a[i + N/2]; num++;\n      }\n      if (K < num) continue;\n      ans += (UB(b[K-num], R-total) - LB(b[K-num], L-total));\n   }\n   cout << ans << endl;\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stdio.h>\n#include<cstring>\n#include<math.h>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<queue>\n#include<functional>\n#include<stack>\n#include<tuple>\n#include<cassert>\nusing namespace std;\n\n#define rep(i, n) for (long long i = 0; i < (long long)(n); ++i)\nusing P = pair<long long, long long>;\n\nint main() {\n  long long N, K, L, R;\n  long long a[40];\n  vector<long long> b[30];\n  vector<long long> c[30];\n  cin >> N >> K >> L >> R;\n  rep(i, N) {\n    cin >> a[i];\n  }\n\n  long long key = (N+1) / 2;\n  rep(bit, (1<<(key))) {\n    long long cnt = 0;\n    long long sum = 0;\n    rep(i, key) {\n      if((bit>>i) & 1) {\n        cnt += 1;\n        sum += a[i];\n      }\n    }\n    b[cnt].push_back(sum);\n  }\n\n  long long key2 = N / 2;\n  rep(bit, (1<<(key2))) {\n    long long cnt = 0;\n    long long sum = 0;\n    rep(i, key2) {\n      if((bit>>i) & 1) {\n        cnt += 1;\n        sum += a[i+key];\n      }\n    }\n    c[cnt].push_back(sum);\n  }\n\n  rep(i, key2+1) {\n    sort(c[i].begin(), c[i].end());\n  }\n\n  long long ans = 0;\n  rep(i, key+1) {\n    if(i > K) break;\n    if(K-i > key2) continue;\n    rep(j, b[i].size()) {\n      long long temp;\n      long long l = L - b[i][j];\n      long long r = R - b[i][j];\n      temp = upper_bound(c[K-i].begin(), c[K-i].end(), r) - lower_bound(c[K-i].begin(), c[K-i].end(), l);\n      ans += temp;\n      // if(i == K) cout << temp << endl;\n    }\n  }\n\n  // rep(i, key+1) {\n  //   rep(j, b[i].size()) {\n  //     cout << b[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << endl;\n\n  // rep(i, key2+1) {\n  //   rep(j, c[i].size()) {\n  //     cout << c[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << endl;\n\n  // rep(i, b[0].size()) {\n  //   cout << b[0][i] << endl;\n  // }\n  // rep(i, c[0].size()) {\n  //   cout << c[0][i] << endl;\n  // }\n\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\nusing namespace std;\nusing P = pair<int, int>;\ntypedef long long ll;\n\nint main() {\n  ll n, k;\n  ll L, R;\n  cin >> n >> k >> L >> R;\n  ll ans = 0;\n  vector<ll> a(n);\n  rep(i, n) cin >> a[i];\n  ll num1 = n / 2, num2 = n - n / 2;\n  vector<vector<ll>> a_all(num1 + 1);\n  vector<vector<ll>> b_all(num2 + 1);\n  for (ll bit = 0; bit < (1 << num1); bit++){\n    ll tmp = 0;\n    ll tmp_count = __builtin_popcount(bit);\n    rep(i,num1){\n      if(bit & (1 << i)){\n        tmp += a[i];\n      }\n    }\n    a_all[tmp_count].push_back(tmp);\n  }\n  for (ll bit = 0; bit < (1 << num2); bit++){\n    ll tmp = 0;\n    ll tmp_count = __builtin_popcount(bit);\n    rep(i,num2){\n      if(bit & (1 << i)){\n        tmp += a[num1 + i];\n      }\n    }\n    b_all[tmp_count].push_back(tmp);\n  }\n  rep(i, num2 +1){\n    sort(b_all[i].begin(), b_all[i].end());\n  }\n  for (int i = max(0ll, k - num2); i <= num1 && i <= k; i++){\n    for(auto v : a_all[i]){\n      auto low = lower_bound(b_all[k - i].begin(), b_all[k - i].end(), L - v);\n      auto upp = upper_bound(b_all[k - i].begin(), b_all[k - i].end(), R - v);\n      if(upp - low <= 0)continue;\n      ans += upp - low;\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = ll(A); I < ll(B); ++I)\n#define FORR(I,A,B) for(ll I = ll((B)-1); I >= ll(A); --I)\n#define TO(x,t,f) ((x)?(t):(f))\n#define SORT(x) (sort(x.begin(),x.end())) // 0 2 2 3 4 5 8 9\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) //xi>=v  x is sorted\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) //xi>v  x is sorted\n#define NUM(x,v) (POSU(x,v)-POSL(x,v))  //x is sorted\n#define REV(x) (reverse(x.begin(),x.end())) //reverse\nll gcd(ll a,ll b){if(a%b==0)return b;return gcd(b,a%b);}\nll lcm(ll a,ll b){ll c=gcd(a,b);return ((a/c)*(b/c)*c);}\n#define NEXTP(x) next_permutation(x.begin(),x.end())\nconst ll INF=ll(1e18)+ll(7);\nconst ll MOD=1000000007LL;\n#define out(a) cout<<fixed<<setprecision((a))\n#define YesNo(a) cout<<((a)?\"Yes\":\"No\")<<endl;\n#define YESNO(a) cout<<((a)?\"YES\":\"NO\")<<endl;\n\nint main(){\n\tll ans=0,N,K,L,R;\n\tcin >> N >> K >> L >> R;\n\tll x = N/2;\n\tll y = N-x;\n\tvector<ll> S1(x),S2(y),A[x+1],B[y+1];\n\tFOR(i,0,x) cin >> S1[i];\n\tFOR(i,0,y) cin >> S2[i];\n\n\tA[0].push_back(0);\n\tB[0].push_back(0);\n\n\tFOR(i,0,x){\n\t\tFORR(j,0,x){\n\t\t\tfor(auto a:A[j]){\n\t\t\t\tA[j+1].push_back(S1[i]+a);\n\t\t\t}\n\t\t}\n\t}\n\tFOR(i,0,y){\n\t\tFORR(j,0,y){\n\t\t\tfor(auto b:B[j]){\n\t\t\t\tB[j+1].push_back(S2[i]+b);\n\t\t\t}\n\t\t}\n\t}\n\n\tFOR(i,1,x+1)SORT(A[i]);\n\tFOR(i,1,y+1)SORT(B[i]);\n\n\tFOR(i,0,min(x,K)+1){\n\t\tif( K-i > y )continue;\n\t\tfor(auto a:A[i]){\n\t\t\tll l = POSL(B[K-i],L-a);\n\t\t\tll r = POSU(B[K-i],R-a) - 1;\n\t\t\tans += r-l+1;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint N,K;\nll L,R;\nll a[41];\n\nll bitsum(int b, int offset) {\n  ll s = 0;\n  for (int i=1; b>0; b>>=1,i+=1) {\n    if (b & 1) {\n      s += a[offset+i];\n    }\n  }\n  return s;\n}\n\nll solve() {\n  int M = N/2;\n  vector<vector<ll>> h(M+1);\n  for (int i=0; i<(1<<M); ++i) {\n    int bc = __builtin_popcount(i);\n    h[bc].push_back(bitsum(i, 0));\n  }\n  for (int i=1; i<=M; ++i) {\n    sort(h[i].begin(), h[i].end());\n  }\n  ll ans = 0;\n  for (int i=0; i<(1<<(N-M)); ++i) {\n    ll s = bitsum(i, M);\n    int bc = __builtin_popcount(i);\n    if (K<bc || K-bc>M) {\n      continue;\n    }\n    ans += upper_bound(h[K-bc].begin(), h[K-bc].end(), R-s) - lower_bound(h[K-bc].begin(), h[K-bc].end(), L-s);\n  }\n  return ans;\n}\n\nint main() {\n  cin>>N>>K>>L>>R;\n  for (int i=0; i<N; ++i) {\n    cin>>a[i+1];\n  }\n  cout<<solve()<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 問題: N枚のコインからK枚を選んで金額が[L,R]の範囲になる選び方の数を求める\n// 解法: \n\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n\n#define pb push_back\n#define mp make_pair\n\nmap<ll, ll> make_map(vector<ll>& As) {\n    map<ll, ll> ret;\n    for(auto a: As) ++ret[a];\n    return ret;\n}\n\nmap<ll, ll> make_combination(map<ll, ll>& As, map<ll, ll>& Bs) {\n    map<ll, ll> ret;\n    for(auto a: As) {\n        for(auto b: Bs) {\n            auto val = a.first + b.first;\n            auto cnt = a.second * b.second;\n            ret[val] += cnt;\n        }\n    }\n    return ret;\n}\n\nll coin_combination_2(ll N, ll K, ll L, ll R,\n                      vector<ll>& As) {\n    // 前半部の全列挙\n    const auto N2 = N / 2;\n    vector<vector<ll>> former(N2 + 1);\n    REP(i, (1 << N2)) {\n        ll sum = 0;\n        int cnt = 0;\n        REP(j, N2) {\n            if (i & (1 << j)) {\n                sum += As[j];\n                cnt++;\n            }\n        }\n        former[cnt].pb(sum);\n    }\n\n    // 後半部の全列挙\n    vector<vector<ll>> latter(N - N2 + 1);\n    REP(i, (1 << (N - N2))) {\n        ll sum = 0;\n        int cnt = 0;\n        REP(j, (N - N2)) {\n            if (i & (1 << j)) {\n                sum += As[N2 + j];\n                cnt++;\n            }\n        }\n        latter[cnt].pb(sum);\n    }\n\n    REP(n, N2 + 1) sort(ALL(former[n]));\n    REP(n, N - N2 + 1) sort(ALL(latter[n]));\n\n    ll ans = 0;\n    // 前半部でn個使う場合\n    REP(n, N2 + 1) {\n        if (n + N - N2 < K) continue;\n        if (n > K) break;\n\n        ll tmp = 0;\n        for (auto e: former[n]) {\n            if (e > R) break;\n            auto mn = max(0LL, L - e);\n            auto mx = R - e;\n\n            auto it1 = lower_bound(ALL(latter[K - n]), mn);\n            auto it2 = lower_bound(ALL(latter[K - n]), mx + 1);\n            ans += (it2 - it1);\n            tmp += (it2 - it1);\n        }\n        // cout << \"former \" << n << \", latter \" << (K - n) << \", \" << tmp << \"added\" << endl;\n    }\n    return ans;\n}\n\nint main() {\n    ll N, K, L, R;\n    cin >> N >> K >> L >> R;\n    vector<ll> As(N);\n    REP(n, N) cin >> As[n];\n    cout << coin_combination_2(N, K, L, R, As) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;i++)\n \nusing namespace std;\n \ntypedef pair<int,int>P;\ntypedef pair<int,ll>pl;\n \nconst int MAX_N = 40;\n \nll a[MAX_N];\nvector<pl> x,y;\n \nvoid solve(int s,int t,vector<pl> &x)\n{\n    int z = t-s;\n    rep(i,1<<z){\n        pl p = pl(0,0);\n        rep(j,z){\n            if(i&(1<<j)){\n                p.first++;\n                p.second += a[s+j];\n            }\n        }\n        x.push_back(p);\n    }\n}\n \nint main()\n{\n    int n,k;\n    ll l,r;\n    cin >> n >> k >> l >> r;\n    rep(i,n){\n        scanf(\"%lld\",&a[i]);\n    }\n    solve(0,n/2,x);\n    solve(n/2,n,y);\n    sort(y.begin(),y.end());\n    ll ans = 0;\n    rep(i,x.size()){\n        ans += upper_bound(y.begin(),y.end(),pl(k-x[i].first,r-x[i].second))-lower_bound(y.begin(),y.end(),pl(k-x[i].first,l-x[i].second));\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 5000000000000000000\n#define ll long long\n#define pll pair<ll, ll>\nusing namespace std;\n\nint main()\n{\n  ll N, K, L, R;\n  cin >> N >> K >> L >> R;\n  ll ans = 0;\n  ll lnum = (N + 1) / 2;\n  vector<ll> la, ra;\n  for (ll i = 0; i < N; ++i) {\n    ll a;\n    cin >> a;\n    if (i < lnum) {\n      la.push_back(a);\n    }\n    else {\n      ra.push_back(a);\n    }\n  }\n\n  vector<vector<ll>> rcoin(N / 2 + 1);\n  for (ll i = 0; i < (1 << (N / 2)); ++i) {\n    ll num = __builtin_popcountll(i);\n    ll sum = 0;\n    for (ll j = 0; j < N / 2; ++j) {\n      if (i & (1 << j)) {\n        sum += ra.at(j);\n      }\n    }\n    rcoin.at(num).push_back(sum);\n  }\n  for (ll i = 0; i < N / 2 + 1; ++i) {\n    sort(rcoin.at(i).begin(), rcoin.at(i).end());\n  }\n\n  for (ll i = 0; i < (1 << lnum); ++i) {\n    ll num = __builtin_popcountll(i);\n    if ((num + N / 2 < K) || (num > K)) {\n      continue;\n    }\n    ll sum = 0;\n    for (ll j = 0; j < lnum; ++j) {\n      if (i & (1 << j)) {\n        sum += la.at(j);\n      }\n    }\n    ll num_left = K - num;\n    ll min_need = L - sum, max_need = R - sum;\n    ll pattern = lower_bound(rcoin.at(num_left).begin(), rcoin.at(num_left).end(), max_need + 1) - lower_bound(rcoin.at(num_left).begin(), rcoin.at(num_left).end(), min_need);\n    ans += pattern;\n  }\n  cout << ans << \"\\n\";\n\n\n\n\n\n  // for (ll i = 0; i < N / 2 + 1; ++i) {\n  //   for (ll j = 0; j < rcoin.at(i).size(); ++j) {\n  //     cout << rcoin.at(i).at(j) << \" \";\n  //   }\n  //   cout << \"\\n\";\n  // }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint n, k;\n\tlong long l, r;\n\tcin >> n >> k >> l >> r;\n\tvector<long long> a(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\t\n\tint n1 = n / 2, n2 = (n - n1);\n\t\n\tint coin = 0;\n\tlong long cost = 0, ans = 0;\n\tvector<vector<long long>> dat(n + 1);\n\tdat[0].push_back(0);\n\t\n\tauto f = [&](int i, long long high, long long low) {\n\t\tauto h = upper_bound(dat[i].begin(), dat[i].end(), high);\n\t\tauto w = lower_bound(dat[i].begin(), dat[i].end(), low);\n\t\treturn (h - w);\n\t};\n\t\n\tfor (int s = 1; s < (1 << n1); s++) {\n\t\tint bit = (s ^ (s >> 1));\n\t\tint i = __builtin_ctz(s);\n\t\t\n\t\tif (bit & (1 << i)) {\n\t\t\tcost += a[i];\n\t\t\tcoin++;\n\t\t} else {\n\t\t\tcost -= a[i];\n\t\t\tcoin--;\n\t\t}\n\t\t\n\t\tif (coin == k and l <= cost and cost <= r) ans++;\n\t\tdat[coin].push_back(cost);\n\t}\n\t\n\tcost = 0; coin = 0;\n\tfor (int i = 0; i <= n; i++) {\n\t\tsort(dat[i].begin(), dat[i].end());\n\t}\n\t\n\tfor (int s = 1; s < (1 << n2); s++) {\n\t\tint bit = (s ^ (s >> 1));\n\t\tint i = __builtin_ctz(s);\n\t\t\n\t\tif (bit & (1 << i)) {\n\t\t\tcost += a[n1 + i];\n\t\t\tcoin++;\n\t\t} else {\n\t\t\tcost -= a[n1 + i];\n\t\t\tcoin--;\n\t\t}\n\t\t\n\t\tif (k >= coin) {\n\t\t\tans += f(k - coin, r - cost, l - cost);\n\t\t}\n\t}\n\t\n\tcout << ans << '\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define be(v) (v).begin(),(v).end()\n#define pb(q) push_back(q)\ntypedef long long ll;\nusing namespace std;\nconst ll mod=1000000007;\n#define doublecout(a) cout<<fixed<<setprecision(10)<<a<<endl;\n\nint main() {\n    cin.tie(0);\n    cout.tie(0);\n    ios::sync_with_stdio(false);\n    ll n,k,l,r,ans=0;\n    cin>>n>>k>>l>>r;\n    ll a[n];\n    for(int i=0;i<n;i++){\n    \tcin>>a[i];\n    }\n    ll m=n/2,maki=(1<<m);\n    vector<ll> v1[21],v2[21];\n    for(int bit=0;bit<maki;bit++){\n    \tll sum=0,num=0;\n    \tfor(int i=0;i<m;i++){\n    \t\tif(bit>>i&1){\n    \t\t\tsum+=a[i];\n    \t\t\tnum++;\n    \t\t}\n    \t}\n    \tv1[num].pb(sum);\n    }\n    ll x=n-m;maki=(1<<x);\n    for(int bit=0;bit<maki;bit++){\n    \tll sum=0,num=0;\n    \tfor(int i=0;i<x;i++){\n    \t\tif(bit>>i&1){\n    \t\t\tsum+=a[i+m];\n    \t\t\tnum++;\n    \t\t}\n    \t}\n    \tv2[num].pb(sum);\n    }\n    for(int i=0;i<=20;i++){\n    \tsort(be(v1[i]));\n    \tsort(be(v2[i]));\n    }\n    m=min(20LL,k);\n    for(int i=0;i<=m;i++){\n    \tif(k-i>20)continue;\n    \tmaki=v1[i].size();\n    \tfor(int j=0;j<maki;j++){\n    \t\tans+=(upper_bound(be(v2[k-i]),r-v1[i][j])-lower_bound(be(v2[k-i]),l-v1[i][j]));\n    \t}\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1e18;\nconst int inf = 1e9;\n#define rep(i, a, b) for (int i = a; i < b; i++)\n#define per(i, b, a) for (int i = a - 1; i >= b; i--)\nusing Graph = vector<vector<int>>;\nusing pint = pair<int, int>;\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nint dxx[8] = {1, 1, 1, 0, 0, -1, -1, -1}, dyy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nint main() {\n    int n, k;\n    ll l, r;\n    cin >> n >> k >> l >> r;\n    ll a[n];\n    rep (i, 0, n) cin >> a[i];\n\n    vector<vector<ll>> L (k + 1), R (k + 1);\n    for (int bit = 0; bit < (1 << (n / 2)); bit++) {\n        ll sum = 0;\n        if (__builtin_popcount (bit) > k) continue;\n        for (int i = 0; i < n / 2; i++) {\n            if (bit & (1 << i)) {\n                sum += a[i];\n            }\n        }\n        L[__builtin_popcount (bit)].push_back (sum);\n    }\n    rep (i, 0, k + 1) {\n        sort (L[i].begin(), L[i].end());\n        // cout << L[i].size() << \"\\n\";\n    }\n    for (int bit = 0; bit < (1 << (n - n / 2)); bit++) {\n        ll sum = 0;\n        if (__builtin_popcount (bit) > k) continue;\n        for (int i = 0; i < n - n / 2; i++) {\n            if (bit & (1 << i)) {\n                sum += a[n / 2 + i];\n            }\n        }\n        R[__builtin_popcount (bit)].push_back (sum);\n    }\n    ll ans = 0;\n    rep (i, 0, k + 1) {\n        rep (j, 0, R[i].size()) {\n            if (R[i][j] > r) continue;\n            ll sum =\n                upper_bound (L[k - i].begin(), L[k - i].end(), r - R[i][j]) -\n                lower_bound (L[k - i].begin(), L[k - i].end(), l - R[i][j]);\n            ans += sum;\n        }\n    }\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define repl(i,l,r) for(ll i=(l);i<(r);i++)\n#define per(i,n) for(ll i=n-1;i>=0;i--)\n#define perl(i,r,l) for(ll i=r-1;i>=l;i--)\n#define fi first\n#define se second\n#define pb push_back\n#define ins insert\n#define pqueue(x) priority_queue<x,vector<x>,greater<x>>\n#define all(x) (x).begin(),(x).end()\n#define CST(x) cout<<fixed<<setprecision(x)\n#define vtpl(x,y,z) vector<tuple<x,y,z>>\n#define rev(x) reverse(x);\nusing ll=long long;\nusing vl=vector<ll>;\nusing vvl=vector<vector<ll>>;\nusing pl=pair<ll,ll>;\nusing vpl=vector<pl>;\nusing vvpl=vector<vpl>;\nconst ll MOD=1000000007;\nconst ll MOD9=998244353;\nconst int inf=1e9+10;\nconst ll INF=4e18;\nconst ll dy[8]={1,0,-1,0,1,1,-1,-1};\nconst ll dx[8]={0,-1,0,1,1,-1,1,-1};\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n} \n \nint main(){\n    ll n,k,l,r;cin >> n >> k >> l >> r;\n    vl v(n);rep(i,n)cin >> v[i];\n    vvl x(k+1),y(k+1);\n    rep(bit,1<<(n/2)){\n        ll ret=0,sum=0;\n        rep(i,n/2){\n            if(bit&(1<<i)){\n                sum+=v[i],ret++;\n            }\n        }\n        if(ret>k)continue;\n        x[ret].pb(sum);\n    }\n    rev(all(v));\n    rep(bit,1<<(n-n/2)){\n        ll ret=0,sum=0;\n        rep(i,n-n/2){\n            if(bit&(1<<i)){\n                sum+=v[i],ret++;\n            }\n        }\n        if(ret>k)continue;\n        y[ret].pb(sum);\n    }\n    rep(i,k+1)sort(all(x[i]));\n    rep(i,k+1)sort(all(y[i]));\n    ll ans=0;\n    rep(i,k+1){\n        for(auto p:x[i]){\n            if(p>r)continue;\n            ans+=upper_bound(all(y[k-i]),r-p)-lower_bound(all(y[k-i]),l-p);\n        }\n    }\n    cout << ans <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <unordered_set>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <cstdint>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n\n#define rep(i, n) for(ll (i) = 0;(i) < (n);(i)++)\n#define mp(a, b) make_pair((a),(b))\n#define bs(n) ((ull)1<<(ull)n)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconstexpr ll inf = INT64_MAX / 4;\nconstexpr double pi = asin(1) * 2;\nconstexpr ll mod = 1000000007;\nconstexpr double eps = 0.000000001;\n\nint main() {\n    ull n;\n    ll k, l, r;\n    cin >> n >> k >> l >> r;\n    auto a = new ll[n];\n    rep(i, n)cin >> a[i];\n    ull s1 = bs(n / 2), s2 = bs((n + 1) / 2);\n    vector<pair<ll, ll>> u(s1), v(s2);\n    for (ull i = 0; i < s1; i++) {\n        int c = 0;\n        for (unsigned j = 0; j < n / 2; j++) {\n            if (i & (1u << j)) {\n                c++;\n                u[i].second += a[j];\n            }\n        }\n        u[i].first = c;\n    }\n    for (ull i = 0; i < s2; i++) {\n        int c = 0;\n        for (unsigned j = 0; j < (n + 1) / 2; j++) {\n            if (i & (1u << j)) {\n                c++;\n                v[i].second += a[j + n / 2];\n            }\n        }\n        v[i].first = c;\n    }\n    sort(u.begin(), u.end());\n    sort(v.begin(), v.end());\n    ll ret = 0;\n    for (auto &e:u) {\n        auto p = lower_bound(v.begin(), v.end(), mp(k - e.first, l - e.second));\n        auto q = upper_bound(v.begin(), v.end(), mp(k - e.first, r - e.second));\n        ret += q - p;\n    }\n    cout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (upper_bound(ALL(c),x)-lower_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *min_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\nsigned main()\n{\n   int N ,K, L, R; cin >> N >> K >> L >> R;\n   V<int> a(N); REP(i, N) cin >> a[i];\n\n   V<V<int>> b(K+1);\n   REP(s, 1<<N/2) {\n      int total = 0, num = 0;\n      REP(i, N) if (s >> i & 1) {\n         total += a[i]; num++;\n      }\n      b[num].push_back(total);\n   }\n   REP(i, K+1) SORT(b[i]);\n\n   int ans = 0;\n   REP(s, 1<<N-N/2) {\n      int total = 0, num = 0;\n      REP(i, N) if (s >> i & 1) {\n         total += a[i + N/2]; num++;\n      }\n      if (K < num) continue;\n      ans += UB(b[K-num], R+1-total) - LB(b[K-num], L-total);\n   }\n   cout << ans << endl;\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint popcount(ll x) {x = x&0x5555555555555555ULL+(x&0xAAAAAAAAAAAAAAAAULL>>1);x=x&0x3333333333333333ULL+(x&0xCCCCCCCCCCCCCCCCULL>>2);x=x&0x0F0F0F0F0F0F0F0FULL+(x&0xF0F0F0F0F0F0F0F0ULL>>4);return x*0x0101010101010101ULL>>56;}\n\nll N, K, L, R;\nll a[40];\n\nauto enumerate(int sidx, int size) {\n  vector<pair<ll, ll>> ret;\n  for(int i=0; i<1<<size; i++) {\n    if(popcount(i) > K) continue;\n    int cnt = 0; ll sum = 0;\n    for(int j=0; j<size; j++)\n      if(i >> j & 1) cnt++, sum += a[sidx + j];\n    ret.emplace_back(cnt, sum);\n  }\n  return ret;\n}\n\nll solve() {\n  auto v0 = enumerate(0, N / 2);\n  auto v1 = enumerate(N / 2, (N + 1) / 2);\n  sort(v0.begin(), v0.end());\n  ll ret = 0;\n  for(int i=0; i<(int)v1.size(); i++)\n    ret +=  upper_bound(v0.begin(), v0.end(), make_pair(K - v1[i].first, R - v1[i].second))\n          - lower_bound(v0.begin(), v0.end(), make_pair(K - v1[i].first, L - v1[i].second));\n  return ret;\n}\n\nint main() {\n  cin >> N >> K >> L >> R;\n  for(int i=0; i<N; i++) cin >> a[i];\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < n; i++)\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n    int N, K;\n    ll L, R;\n    cin >> N >> K >> L >> R;\n    vector<ll> a(N);\n    rep(i, N) cin >> a[i];\n    int N1 = N / 2, N2 = N - N1;\n    vector<vector<ll>> v(N1 + 1);\n    rep(i, 1 << N1) {\n        ll s = 0;\n        int k = 0;\n        rep(j, N1) {\n            if ((i >> j) & 1) {\n                s += a[j];\n                k++;\n            }\n        }\n        v[k].push_back(s);\n    }\n    rep(i, N1 + 1) {\n        sort(v[i].begin(), v[i].end());\n    }\n    ll ans = 0;\n    rep(i, 1 << N2) {\n        ll s = 0;\n        int k = K;\n        rep(j, N2) {\n            if ((i >> j) & 1) {\n                s += a[N1 + j];\n                k--;\n            }\n        }\n        if (k < 0 || k > N1) continue;\n        ll l = lower_bound(v[k].begin(), v[k].end(), L - s) - v[k].begin();\n        ll r = upper_bound(v[k].begin(), v[k].end(), R - s) - v[k].begin();\n        ans += r - l;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAX 40\n\n\nint N, K;\nlong long L, R;\nlong long a[MAX];\n\n\n\nint main()\n{\n\tcin >> N >> K >> L >> R;\n\tfor( int i = 0; i < N; i++ ) {\n\t\tcin >> a[i];\n\t}\n\n\tvector< long long > v[K+1];\n\tint n1 = N / 2;\n\tint n2 = N - n1;\n\tfor( int i = 0; i < (1 << n1); i++ ) {\n\t\tlong long sum = 0;\n\t\tint cnt = 0;\n\t\tfor( int j = 0; j < n1; j++ ) {\n\t\t\tif( i & (1 << j) ) {\n\t\t\t\tcnt++;\n\t\t\t\tsum += a[j];\n\t\t\t}\n\t\t}\n\t\tif( cnt > K ) {\n\t\t\tcontinue;\n\t\t}\n\t\tv[cnt].push_back( sum );\n\t}\n\tfor( int i = 0; i < K + 1; i++ ) {\n\t\tsort( v[i].begin(), v[i].end() );\n\t}\n\tlong long ans = 0;\n\tfor( int i = 0; i < (1 << n2); i++ ) {\n\t\tlong long sum = 0;\n\t\tint cnt = 0;\n\t\tfor( int j = 0, k = n1; j < n2; j++, k++ ) {\n\t\t\tif( i & (1 << j) ) {\n\t\t\t\tcnt++;\n\t\t\t\tsum += a[k];\n\t\t\t}\n\t\t}\n\t\tif( cnt > K ) {\n\t\t\tcontinue;\n\t\t}\n\t\tauto itr = upper_bound( v[K - cnt].begin(), v[K - cnt].end(), R - sum );\n\t\tauto itl = lower_bound( v[K - cnt].begin(), v[K - cnt].end(), L - sum );\n\t\tans += itr - itl;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main()\n{\n\tll N, K, L, R;\n\tcin >> N >> K >> L >> R;\n\tvector<ll> a(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> a[i];\n\t}\n\tll n1 = N / 2, n2 = N - N / 2;\n\tvector<vector<ll>> b(n1 + 1), c(n2 + 1);\n\tfor (int i = 0; i < (1 << n1); i++) {\n\t\tll cnt = 0, val = 0;\n\t\tfor (int j = 0; j < n1; j++) {\n\t\t\tif (i & (1 << j)) {\n\t\t\t\tcnt++;\n\t\t\t\tval += a[j];\n\t\t\t}\n\t\t}\n\t\tb[cnt].push_back(val);\n\t}\n\tfor (int i = 0; i < (1 << n2); i++) {\n\t\tll cnt = 0, val = 0;\n\t\tfor (int j = 0; j < n2; j++) {\n\t\t\tif (i & (1 << j)) {\n\t\t\t\tcnt++;\n\t\t\t\tval += a[j + n1];\n\t\t\t}\n\t\t}\n\t\tc[cnt].push_back(val);\n\t}\n\tfor (int i = 0; i <= n2; i++) {\n\t\tsort(c[i].begin(), c[i].end());\n\t}\n\tll res = 0;\n\tfor (int i = max(0ll, K - n2); i <= n1 && i <= K; i++) {\n\t\tfor (auto v : b[i]) {\n\t\t\tauto ub = upper_bound(c[K - i].begin(), c[K - i].end(), R - v);\n\t\t\tauto lb = lower_bound(c[K - i].begin(), c[K - i].end(), L - v);\n\t\t\tres += ub - lb;\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define d(x) cerr << #x \":\" << x << endl;\n#define dd(x, y) cerr << \"(\" #x \",\" #y \"):(\" << x << \",\" << y << \")\" << endl\n#define rep(i, n) for (int i = (int)(0); i < (int)(n); i++)\n#define all(v) v.begin(), v.end()\n#define dump(v)                  \\\n    cerr << #v \":[ \";            \\\n    for (auto macro_vi : v) {    \\\n        cerr << macro_vi << \" \"; \\\n    }                            \\\n    cerr << \"]\" << endl;\n#define ddump(v)                           \\\n    cerr << #v \":\" << endl;                \\\n    for (auto macro_row : v) {             \\\n        cerr << \"[\";                       \\\n        for (auto macro__vi : macro_row) { \\\n            cerr << macro__vi << \" \";      \\\n        }                                  \\\n        cerr << \"]\" << endl;               \\\n    }\nusing lint       = long long;\nconst int INF    = 1e9;\nconst lint LINF  = 1e18;\nconst double EPS = 1e-10;\n\nint main() {\n    lint N, K, L, R;\n    cin >> N >> K >> L >> R;\n    vector<lint> a(N / 2), b(N / 2 + (N % 2 == 1 ? 1 : 0));\n    rep(i, a.size()) cin >> a[i];\n    rep(i, b.size()) cin >> b[i];\n\n    vector<vector<lint>> La(N + 1, vector<lint>(0));\n    for (int bit = 0; bit < (1 << a.size()); bit++) {\n        int k    = 0;\n        lint sum = 0;\n        for (int i = 0; i < a.size(); i++) {\n            if (bit & (1 << i)) {\n                sum += a[i];\n                k++;\n            }\n        }\n        La[k].push_back(sum);\n    }\n\n    for (int i = 0; i <= N; i++)\n        sort(La[i].begin(), La[i].end());\n\n    lint ans = 0;\n    for (int bit = 0; bit < (1 << b.size()); bit++) {\n        int k    = 0;\n        lint sum = 0;\n        for (int i = 0; i < b.size(); i++) {\n            if (bit & (1 << i)) {\n                sum += b[i];\n                k++;\n            }\n        }\n        if (K < k) continue;\n        ans += upper_bound(La[K - k].begin(), La[K - k].end(), R - sum) -\n               lower_bound(La[K - k].begin(), La[K - k].end(), L - sum);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(obj) begin(obj), end(obj)\nusing namespace std;\ntemplate <class T>\nvector<T> make_vec(size_t a) {\n    return vector<T>(a);\n}\ntemplate <class T, class... Ts>\nauto make_vec(size_t a, Ts... ts) {\n    return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nconst int INF = 2100100100;\nconst int MOD = 1e9 + 7;\n\nll N, M, K, Q, W, H, R, C, L;\nstring S;\n\nint main() {\n    cin >> N >> K >> L >> R;\n    vector<ll> a(N);\n    for (int i = 0; i < N; i++) {\n        cin >> a.at(i);\n    }\n\n    vector<ll> back[41];\n    for (int bit = 0; bit < (1 << (N - N / 2)); bit++) {\n        ll sum = 0;\n        for (int i = 0; i < (N - N / 2); i++) {\n            int mask = 1 << i;\n            if (bit & mask) {\n                sum += a[N - 1 - i];\n            }\n        }\n        back[__builtin_popcount(bit)].push_back(sum);\n    }\n    for (int i = 0; i <= 20; i++) {\n        sort(back[i].begin(), back[i].end());\n    }\n\n    ll ans = 0;\n    for (int bit = 0; bit < (1 << (N / 2)); bit++) {\n        ll sum = 0;\n        for (int i = 0; i < N / 2; i++) {\n            int mask = 1 << i;\n            if (bit & mask) {\n                sum += a[i];\n            }\n        }\n        int cnt = K - __builtin_popcount(bit);\n        if (cnt >= 0) {\n            ans += upper_bound(back[cnt].begin(), back[cnt].end(), R - sum) - lower_bound(back[cnt].begin(), back[cnt].end(), L - sum);\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nlong long n, k, l, r, a[40], pos;\nvector<long long>p[30], q[30];\nint main() {\n\tcin >> n >> k >> l >> r; pos = n / 2;\n\tfor (int i = 0; i < n; i++)cin >> a[i];\n\tfor (int i = 0; i < (1 << pos); i++) {\n\t\tlong long R = 0; for (int j = 0; j < pos; j++) { if ((i / (1 << j)) % 2 == 1) { R += a[j]; } }\n\t\tp[__popcnt(i)].push_back(R);\n\t}\n\tfor (int i = 0; i < (1 << (n - pos)); i++) {\n\t\tlong long R = 0; for (int j = 0; j < n - pos; j++) { if ((i / (1 << j)) % 2 == 1) { R += a[j + pos]; } }\n\t\tq[__popcnt(i)].push_back(R);\n\t}\n\tfor (int i = 0; i < 30; i++)sort(p[i].begin(), p[i].end());\n\tfor (int i = 0; i < 30; i++)sort(q[i].begin(), q[i].end());\n\tlong long cnts = 0;\n\tfor (int i = 0; i <= pos; i++) {\n\t\tint V = k - i; if (V < 0)continue;\n\t\tfor (int j = 0; j < p[i].size(); j++) {\n\t\t\tint pos1 = lower_bound(q[V].begin(), q[V].end(), l - p[i][j]) - q[V].begin();\n\t\t\tint pos2 = lower_bound(q[V].begin(), q[V].end(), r + 1 - p[i][j]) - q[V].begin();\n\t\t\tcnts += pos2 - pos1;\n\t\t}\n\t}\n\tcout << cnts << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\ntypedef long long ll;\n\nconstexpr ll mod = 1e9 + 7;\n\ntemplate <class T> inline bool chmax(T &a, const T b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <class T> inline bool chmin(T &a, const T b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\nll n, k;\nll l, r;\nll a[50];\nvector<ll> sum[100];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    cin >> n >> k >> l >> r;\n    rep(i, n) cin >> a[i];\n\n    ll x = n / 2;\n    rep(i, 1 << x) {\n        int cnt = __builtin_popcount(i);\n        if(cnt > k) continue;\n        ll s = 0;\n        rep(j, x) if((i >> j) & 1) s += a[j];\n        sum[cnt].push_back(s);\n    }\n    rep(i, k + 1) sort(ALL(sum[i]));\n\n    ll re = 0;\n    rep(i, 1 << n - x) {\n        int cnt = __builtin_popcount(i);\n        if(cnt > k) continue;\n        ll s = 0;\n        rep(j, n - x) if((i >> j) & 1) s += a[x + j];\n\n        re += upper_bound(ALL(sum[k - cnt]), r - s) -\n              lower_bound(ALL(sum[k - cnt]), l - s);\n    }\n\n    cout << re << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n#define int ll\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nsigned main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, K, L, R;\n\tcin >> N >> K >> L >> R;\n\n\tvector<ll> a(N);\n\trep(i, 0, N)\n\t{\n\t\tcin >> a[i];\n\t}\n\n\tvector<vector<ll>> va(N + 1), vb(N + 1);\n\tva[0].pb(0);\n\tvb[0].pb(0);\n\n\trep(i,0,N/2)\n\t{\n\t\trrep(k, 0, K)\n\t\t{\n\t\t\trep(j, 0, SZ(va[k]))\n\t\t\t{\n\t\t\t\tva[k + 1].pb(va[k][j] + a[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, N / 2, N)\n\t{\n\t\trrep(k, 0, K)\n\t\t{\n\t\t\trep(j,0,SZ(vb[k]))\n\t\t\t{\n\t\t\t\tvb[k + 1].pb(vb[k][j] + a[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\trep(k, 0, K + 1)\n\t{\n\t\tsort(all(va[k]));\n\t\tsort(all(vb[K - k]));\n\t\trep(j,0,SZ(va[k]))\n\t\t{\n\t\t\tans += (upper_bound(all(vb[K - k]), R - va[k][j]) - lower_bound(all(vb[K - k]), L - va[k][j]));\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long a[50];\n\nauto f(long long st, long long en) {\n    long long w = en - st;\n    vector<pair<int, long long>> vt;\n    for (long long i = 0; i < (1 << w); ++i) {\n        long long sum = 0;\n        int cnt = __builtin_popcount(i);\n        for (long long j = 0; j < w; ++j) {\n            if ((i >> j) & 1) {\n                sum += a[st + j];\n            }\n        }\n        vt.emplace_back(make_pair(cnt, sum));\n    }\n    return vt;\n}\n\nint main() {\n    int n, k;\n    long long l, r;\n    cin >> n >> k >> l >> r;\n\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n\n    auto vt1 = f(0, n / 2);\n    auto vt2 = f(n / 2, n);\n    sort(vt2.begin(), vt2.end());\n\n    long long ans = 0;\n    for (auto x:vt1) {\n        auto it1 = lower_bound(\n                vt2.begin(), vt2.end(),\n                pair<int, long long>(k - x.first, l - x.second));\n        auto it2 = upper_bound(\n                vt2.begin(), vt2.end(),\n                pair<int, long long>(k - x.first, r - x.second));\n        ans += it2 - it1;\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long\n\nsigned main(){\n\tint N, K, L, R; cin >> N >> K >> L >> R;\n\tvector<int> a(N);\n\tint k2 = N/2;\n\tfor(int i = 0; i < k2; i++) cin >> a[i];\n\tvector<int > p[N];\n\tfor(int i = 0; i < (1 << k2); i++){\n\t\tint counter = 0, s = 0;\n\t\tfor(int j = 0;j < k2; j++){\n\t\t\tif(i & (1 << j)) counter++, s += a[j];\n\t\t}\n\t\tp[counter].push_back(s);\n\t}\n\tfor(int i = 0; i < N; i++) sort(p[i].begin(), p[i].end());\n\t\n\tint ans = 0;\n\tk2 = N - k2;\n\tfor(int i = 0; i < k2; i++) cin >> a[i];\n\tfor(int i = 0; i < (1 << k2); i++){\n\t\tint s = 0, counter = 0;\n\t\tfor(int j = 0; j < k2; j++){\n\t\t\tif(i & (1 << j)) counter++, s += a[j];\n\t\t}\n\t\tif(K < counter) continue;\n\t\tans += upper_bound(p[K - counter].begin(), p[K - counter].end(), R - s) - lower_bound(p[K - counter].begin(), p[K - counter].end(), L - s);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by Edward on 4/25/2020.\n//\n\n#include <bits/stdc++.h>\n#include <iostream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nnamespace coincombo2{\n    int N, K;\n    ll L, R;\n    ll a[40];\n    vector< vector<ll> > left;\n    vector< vector<ll> > right;\n\n    void put(){\n        for(int i = 0; i < (1 << N/2); i++){\n            int cnt = 0;\n            ll sum = 0;\n            for(int j = 0; j < N/2; j++){\n                if(i & (1 << j)){\n                    cnt++;\n                    sum+=a[j];\n                }\n            }\n            left[cnt].push_back(sum);\n        }\n        for(int i = 0; i < (1 << (N - N/2)); i++){\n            int cnt = 0;\n            ll sum = 0;\n            for(int j = 0; j < N - N/2; j++){\n                if(i & (1 << j)){\n                    cnt++;\n                    sum+=a[N/2 + j];\n                }\n            }\n            right[cnt].push_back(sum);\n        }\n    }\n\n    int main(){\n        cin >> N >> K;\n        cin >> L >> R;\n        for(int i = 0; i < N; i++){\n            cin >> a[i];\n        }\n        for(int i = 0; i < N/2 + 1; i++){\n            vector <ll> v;\n            left.push_back(v);\n        }\n        for(int i = N/2; i < N + 1; i++){\n            vector <ll> v;\n            right.push_back(v);\n        }\n        put();\n        for(int i = 0; i < N/2; i++){\n            sort(left[i].begin(), left[i].end());\n        }\n        for(int i = 0; i < N - N/2; i++){\n            sort(right[i].begin(), right[i].end());\n        }\n        ll count = 0;\n        for(int i = max(0, K - (N - N/2)); i <= min(K, N/2); i++){\n            for(ll x: left[i]){\n                ll v = lower_bound(right[K-i].begin(), right[K-i].end(), R+1-x) - lower_bound(right[K-i].begin(), right[K-i].end(), L-x);\n                count += v;\n                //cout << x << \" in left gets \" << v << \" in right.\" << endl;\n            }\n        }\n        cout << count << endl;\n        return 0;\n    }\n}\n\nint main(){\n    coincombo2::main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (upper_bound(ALL(c),x)-lower_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *min_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\nsigned main()\n{\n   int N ,K, L, R; cin >> N >> K >> L >> R;\n   V<int> a(N); REP(i, N) cin >> a[i];\n\n   V<V<int>> b(K+1);\n   REP(s, 1<<N/2) {\n      int total = 0, num = 0;\n      REP(i, N) if (s >> i & 1) {\n         total += a[i]; num++;\n      }\n      b[num].push_back(total);\n   }\n   REP(i, K+1) SORT(b[i]);\n\n   int ans = 0;\n   REP(s, 1<<N-N/2) {\n      int total = 0, num = 0;\n      REP(i, N) if (s >> i & 1) {\n         total += a[i + N/2]; num++;\n      }\n      if (K < num) continue;\n      ans += (UB(b[K-num], R+1-total) - LB(b[K-num], L-total));\n   }\n   cout << ans << endl;\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(i = 0;i < n;++i)\n#define all(v) v.begin(), v.end()\nusing ll = long long;\n\nint main()\n{\n    ll i,j;\n    ll n,k,l,r;\n    cin >> n >> k >> l >> r;\n    vector<ll> a(n);\n    for(i = 0;i < n;++i){\n        cin >> a.at(i);\n    }\n    ll n1 = n/2;\n    ll n2 = n - n1;\n    ll bit;\n    vector<pair<ll,ll>> p1;\n    for(bit = 0;bit < (1 << n1);++bit){\n        ll tmp = 0;\n        ll num = 0;\n        for(i = 0;i < n1;++i){\n            if(bit & (1ll << i)){\n                tmp += a.at(i);\n                ++num;\n            }\n        }\n        if(tmp <= r) p1.emplace_back(num,tmp);\n    }\n    sort(all(p1));\n\n    vector<pair<ll,ll>> p2;\n    for(bit = 0;bit < (1 << n2);++bit){\n        ll tmp = 0;\n        ll num = 0;\n        for(i = 0;i < n2;++i){\n            if(bit & (1ll << i)){\n                tmp += a.at(i + n1);\n                ++num;\n            }\n        }\n        if(tmp <= r) p2.emplace_back(num, tmp);\n    }\n    sort(all(p2));\n    ll ans = 0;\n    for(i = 0;i < p1.size();++i){\n        ll num = p1.at(i).first;\n        ll tmp = p1.at(i).second;\n        auto x = lower_bound(all(p2), make_pair(k - num, l - tmp));\n        auto y = upper_bound(all(p2), make_pair(k - num, r - tmp));\n        ll t = y-x;\n        ans += t;\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<int, ll>;\n\nvoid calc(ll l, ll r, vector<ll> const& a, vector<P>& v) {\n    int size = r - l;\n    for(int i=0; i<1<<size; ++i) {\n        ll sum = 0;\n        int cnt = 0;\n        for(int j=0; j<size; ++j) {\n            if(i >> j & 1) {\n                cnt++;\n                sum += a[j+l];\n            }\n        }\n        v.push_back(P{cnt, sum});\n    }\n    sort(v.begin(), v.end());\n}\n\nint main() {\n    ll N, K, L, R;\n    cin >> N >> K >> L >> R;\n    vector<ll> a(N);\n    for(int i=0; i<N; ++i) {\n        cin >> a[i];\n    }\n    vector<P> v1, v2;\n    calc(0, N/2, a, v1);\n    calc(N/2, N, a, v2);\n    ll res = 0;\n    for(int i=0; i<v1.size(); ++i) {\n        ll l = lower_bound(v2.begin(), v2.end(), P{K-v1[i].first, L-v1[i].second}) - v2.begin(),\n           r = upper_bound(v2.begin(), v2.end(), P{K-v1[i].first, R-v1[i].second}) - v2.begin();\n        res += r - l;\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define EPS (1e-7)\n#define INF (1e9)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) x.begin(),x.end()\nconst double PI = acos(-1);\nconst ll MOD = 1000000007;\n// const ll MOD = 998244353;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n \ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n///////////////////////////////////////////////////////////////\n \nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N,K; cin >> N >> K;\n    ll L,R; cin >> L >> R;\n    vector<ll> a(N);\n    rep(i,N) cin >> a[i];\n\n    int M = N/2;\n    vector<vector<ll>> left(M+1),right(N-M+1);\n    for (int tmp = 0; tmp < (1 << M); tmp++) {\n        bitset<20> s(tmp);\n        ll num = 0;\n        rep(i,M) {\n            if (s.test(i)) num += a[i];  \n        }\n\n        left[s.count()].emplace_back(num);\n    }\n    for (int tmp = 0; tmp < (1 << (N-M)); tmp++) {\n        bitset<20> s(tmp);\n        ll num = 0;\n        rep(i,(N-M)) {\n            if (s.test(i)) num += a[M+i];  \n        }\n        right[s.count()].emplace_back(num);\n    }\n\n    rep(i,M+1) sort(all(left[i]));\n    rep(i,N-M+1) sort(all(right[i]));\n\n    ll cnt = 0;\n    rep(i,min(M+1,K+1)) {\n        if (K - i > N - M) continue;\n        if (right[K-i].empty()) continue;\n        for (auto num : left[i]) {\n            cnt += (upper_bound(all(right[K-i]),R-num) - lower_bound(all(right[K-i]),L-num));\n        }\n    }\n\n    cout << cnt << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint N, K, L, R, a[50];\n\nsigned main() {\n    cin >> N >> K >> L >> R;\n    rep(i,0,N) cin >> a[i];\n\n    vector<int> va[K+1], vb[K+1];\n    int A = N / 2, B = N - A;\n    rep(bit,0,1<<A) {\n        int C = __builtin_popcount(bit);\n        if(C > K) continue;\n        int val = 0;\n        rep(i,0,A) if(bit >> i & 1) val += a[i];\n        va[C].push_back(val);\n    }\n\n    rep(bit,0,1<<B) {\n        int C = __builtin_popcount(bit);\n        if(C > K) continue;\n        int val = 0;\n        rep(i,0,B) if(bit >> i & 1) val += a[A+i];\n        vb[C].push_back(val);\n    }\n\n    repq(i,0,K) {\n        va[i].push_back(INF), vb[i].push_back(INF);\n        sort(va[i].begin(), va[i].end());\n        sort(vb[i].begin(), vb[i].end());\n    }\n\n    int ans = 0;\n    repq(i,0,K) {\n        rep(j,0,va[i].size()) {\n            int val = va[i][j];\n            int lb = lower_bound(vb[K-i].begin(), vb[K-i].end(), L-val) - vb[K-i].begin();\n            int ub = upper_bound(vb[K-i].begin(), vb[K-i].end(), R-val) - vb[K-i].begin();\n            // printf(\"i = %lld, A val = %lld, ub = %lld, lb = %lld\\n\", i, va[i][j], ub, lb);\n            ans += (ub - lb);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n    int n, k;\n    ll l, r;\n    cin >> n >> k >> l >> r;\n\n    int a[n];\n    for(int i = 0; i < n; i++)  cin >> a[i];\n\n    int left = n/2;\n    int right = n - left;\n\n    vector<ll> va[left+1], vb[right+1];\n\n    for(int i = 0; i < 1<<left; i++){\n        ll sum = 0;\n        int popcnt = 0;\n        for(int j = 0; j < left; j++){\n            if(i>>j & 1)    sum += a[j], popcnt++;\n        }\n        va[popcnt].push_back(sum);\n    }\n\n    for(int i = 0; i < 1<<right; i++){\n        ll sum = 0;\n        int popcnt = 0;\n        for(int j = 0; j < right; j++){\n            if(i>>j & 1)    sum += a[left+j], popcnt++;\n        }\n        vb[popcnt].push_back(sum);\n    }\n\n    for(int i = 0; i <= left; i++)   sort(va[i].begin(), va[i].end());\n    for(int i = 0; i <= right; i++)  sort(vb[i].begin(), vb[i].end());\n\n    ll ans = 0;\n    for(int i = 0; i <= left; i++){\n        if(i + right < k)   continue;\n        if(i > k)   break;\n\n        for(int j = 0; j < va[i].size(); j++){\n            ll tmp = va[i][j];\n            ans += max(0, (upper_bound(vb[k-i].begin(), vb[k-i].end(), r-tmp) - \n                            lower_bound(vb[k-i].begin(), vb[k-i].end(), l-tmp)));\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 問題: N枚のコインからK枚を選んで金額が[L,R]の範囲になる選び方の数を求める\n// 解法: \n\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n\n#define pb push_back\n#define mp make_pair\n\nmap<ll, ll> make_map(vector<ll>& As) {\n    map<ll, ll> ret;\n    for(auto a: As) ++ret[a];\n    return ret;\n}\n\nmap<ll, ll> make_combination(map<ll, ll>& As, map<ll, ll>& Bs) {\n    map<ll, ll> ret;\n    for(auto a: As) {\n        for(auto b: Bs) {\n            auto val = a.first + b.first;\n            auto cnt = a.second * b.second;\n            ret[val] += cnt;\n        }\n    }\n    return ret;\n}\n\nll coin_combination_2(ll N, ll K, ll L, ll R,\n                      vector<ll>& As) {\n    // 前半部の全列挙\n    const auto N2 = N / 2;\n    vector<vector<ll>> former(N2 + 1);\n    REP(i, (1 << N2)) {\n        ll sum = 0;\n        int cnt = 0;\n        REP(j, N2) {\n            if (i & (1 << j)) {\n                sum += As[j];\n                cnt++;\n            }\n        }\n        former[cnt].pb(sum);\n    }\n\n    // 後半部の全列挙\n    vector<vector<ll>> latter(N - N2 + 1);\n    REP(i, (1 << (N - N2))) {\n        ll sum = 0;\n        int cnt = 0;\n        REP(j, (N - N2)) {\n            if (i & (1 << j)) {\n                sum += As[N2 + j];\n                cnt++;\n            }\n        }\n        latter[cnt].pb(sum);\n    }\n\n    REP(n, N2) sort(ALL(former[n]));\n    REP(n, N - N2) sort(ALL(latter[n]));\n\n\n    int ans = 0;\n    // 前半部でn個使う場合\n    REP(n, N2 + 1) {\n        // 後半部で足りない場合はスキップ\n        if (n + N - N2 < K) continue;\n\n        for (auto e: former[n]) {\n            auto mn = max(0LL, L - e);\n            auto mx = max(0LL, R - e);\n            if (mx == 0) break;\n            //cout << \"mn, mx = \" << mn << \",\" << mx << endl;\n\n            auto it1 = lower_bound(ALL(latter[K - n]), mn);\n            auto it2 = lower_bound(ALL(latter[K - n]), mx + 1);\n            ans += (it2 - it1);\n        }\n    }\n    return ans;\n}\n\nint main() {\n    ll N, K, L, R;\n    cin >> N >> K >> L >> R;\n    vector<ll> As(N);\n    REP(n, N) cin >> As[n];\n    cout << coin_combination_2(N, K, L, R, As) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\nint in(){int a;scanf(\"%d\",&a);return a;}\nll lin(){ll a;scanf(\"%lld\",&a);return a;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nvector<ll> sum[40 / 2 + 1];\n\nint main()\n{\n    ll N = in(), K = in(), L = in(), R = in();\n\n    vector<ll> A(N);\n\n    rep(i, N) {\n        A[i] = lin();\n    }\n\n    int sz1 = N / 2;\n    rep(bit, 1 << sz1) {\n        int cnt = 0;\n        ll s = 0;\n\n        rep(i, sz1) {\n            if (bit >> i & 1) {\n                cnt++;\n                s += A[i];\n            }\n        }\n\n        sum[cnt].PB(s);\n    }\n\n    rep(i, sz1 + 1) sort(all(sum[i]));\n\n    ll ans = 0;\n\n    int sz2 = N - N / 2;\n    rep(bit, 1 << sz2) {\n        int cnt = 0;\n        ll s = 0;\n\n        rep(i, sz2) {\n            if (bit >> i & 1) {\n                cnt++;\n                s += A[i + sz1];\n            }\n        }\n\n        if (K - cnt < 0 || K - cnt > sz1) continue;\n\n        int pos1 = upper_bound(all(sum[K - cnt]), R - s) - begin(sum[K - cnt]) - 1;\n        int pos2 = lower_bound(all(sum[K - cnt]), L - s) - begin(sum[K - cnt]);\n\n        if (pos1 < pos2) continue;\n\n        ans += max(pos1 - pos2 + 1, 0);\n    }\n\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <string>\n#include <math.h>\n#include <limits.h>\n#include <stack>\n#include <complex>\n#include <stdlib.h>\n#include <stdio.h>\n#include <functional>\n#include <cfloat>\n#include <math.h>\n#include <numeric>\n#include <string.h>\n#include <sys/time.h>\n#include <random>\n\n\n#define fs first\n#define sc second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nvector<ll> formerVector[20];\n\n\nint main(){\n    int n, k;\n    ll L, R;\n    cin >> n >> k >> L >> R;\n    ll a[40];\n    for(int i = 0; i < n; i++){\n        cin >> a[i];\n    }\n\n    for(int i = 0; i < (1 << n/2); i++){\n        ll tmp = 0;\n        int num = 0;\n        for(int j = 0; j < n/2; j++){\n            if((i >> j) % 2 == 1){\n                tmp += a[j];\n                num++;\n            }\n        }\n        formerVector[num].push_back(tmp);\n    }\n    for(int i = 0; i < n/2; i++){\n        sort(formerVector[i].begin(), formerVector[i].end());\n    }\n\n    ll res = 0;\n    for(int i = 0; i < (1 << (n-n/2)); i++){\n        ll tmp = 0;\n        int num = 0;\n        for(int j = 0; j < n-n/2; j++){\n            if((i >> j) % 2 == 1){\n                tmp += a[n/2 + j];\n                num++;\n            }\n        }\n        if(num > k){\n            continue;\n        }\n        res += upper_bound(formerVector[k-num].begin(), formerVector[k-num].end(), R-tmp) - lower_bound(formerVector[k-num].begin(), formerVector[k-num].end(), L-tmp);\n    }\n\n\n    cout << res << endl;\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define ll long long\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N, K, L, R; cin >> N >> K >> L >> R;\n\tll ans = 0;\n\tvector<ll> a(N + 1);\n\tvector<vector<ll>> sum(N / 2 + 1);\n\tfor (int i = 0; i < N; i++) cin >> a[i];\n\tint n1 = N / 2;\n\tfor (int i = 0; i < 1 << n1;i++) {\n\t\tint cnt = 0;\n\t\tll a_sum = 0;\n\t\tfor (int j = 0; j < n1; j++) {\n\t\t\tif (i >> j & 1) {\n\t\t\t\tcnt++; a_sum += a[j];\n\t\t\t}\n\t\t}\n\t\tsum[cnt].emplace_back(a_sum);\n\t}\n\tfor (int i = 0; i < n1;i++) sort(sum[i].begin(), sum[i].end());\n\n\tint n2 = N - n1;\n\tfor (int i = 0; i < 1 << n2;i++) {\n\t\tint cnt = 0;\n\t\tll a_sum = 0;\n\t\tfor (int j = 0; j < n2;j++) {\n\t\t\tif (i >> j & 1) {\n\t\t\t\tcnt++;\ta_sum += a[n1 + j];\n\t\t\t}\n\t\t}\n\n\t\tif ( !(K - cnt >= 0) || n1 + cnt < K) continue;\n\n\t\tint it1 = upper_bound(sum[K - cnt].begin(), sum[K - cnt].end(), R - a_sum) - begin(sum[K - cnt]);\n\t\tint it2 = lower_bound(sum[K - cnt].begin(), sum[K - cnt].end(), L - a_sum) - begin(sum[K - cnt]);\n\n\t\tif (it1 - it2 <= 0) continue;\n\t\tans += it1 - it2;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**Function Template**/\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> pint;\nconst int MAX = 510000;\nconst int MOD = 1000000007;\n#define rep(i, n) for(ll i = ll(0); i < ll(n); i++)\n#define Rep(i, n) for(ll i = ll(1); i < ll(n); i++)\n#define ALL(a)  (a).begin(),(a).end()\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define PI 3.14159265358979323846\n#define ifYN(x) cout<<(x?\"Yes\":\"No\")<<\"\\n\" \nll fac[MAX], finv[MAX], inv[MAX];\n\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nbool palindrome(string s){\n  bool flag=true;\n  rep(i,(ll)s.size()) if(s[i]!=s[s.size()-1-i]) flag=false;\n  return flag;\n}\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (ll i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n\n}\nll Len(ll n) {\n  ll s=0;\n  while(n!=0) s++, n/=10;\n  return s;\n}\n\n\nll Sint(ll n) {\n  ll ans=0;\n  while(n!=0) ans+=n%10,n/=10;\n  return ans;\n}\n\nll Svec(vector<ll> v){\n  ll n=0;\n  rep(i,(ll)v.size()) n+=v[i];\n  return n;\n}\n\n\nll GCD(ll a,ll b) {\n  return b ? GCD(b,a%b) : a;\n}\n\n\nll LCM(ll a,ll b){\n  return a/GCD(a,b)*b;\n}\n\n\nll Factorial(ll n){\n  ll m=1;\n  while(n>=1) m*=n,n--;\n  return m;\n}\n\nvoid runlength(string s,vector<pair<char,ll>> &p){\n  ll x=1;\n  if(s.size()==1){\n    p.push_back(pair<char,ll>(s[0],1));\n  }\n  rep(i,(ll)s.size()-1){\n    if(s[i]==s[i+1]){\n      x++;\n      if(i==(ll)s.size()-2){\n        p.push_back(pair<char,ll>(s[i],x));\n      }\n    }else{\n      p.push_back(pair<char,ll>(s[i],x));\n      x=1;\n      if(i==(ll)s.size()-2){\n        p.push_back(pair<char,ll>(s[s.size()-1],x));\n      }\n    }\n  }\n}\n\nll COM(ll n,ll k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nll modpow(ll a, ll n, ll mod) {\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nstring Toupper(string s){\n  string ans=\"\";\n  rep(i,s.size()){\n    if('a'<=s[i] && s[i]<='z') ans+=(char)s[i]-32;\n    else ans+=s[i];\n  }\n  return ans;\n}\nstring Tolower(string s){\n  string ans=\"\";\n  rep(i,s.size()){\n    if('A'<=s[i] && s[i]<='Z') ans+=(char)s[i]+32;\n    else ans+=s[i];\n  }\n  return ans;\n}\n\nvoid dis(vector<ll> v){ rep(i,v.size()) cout<<v[i]<<endl; }\n\nvoid dis2(vector<vector<ll>> v){\n  rep(i,v.size()){\n    rep(j,v[0].size()) cout<<v[i][j]<<' ';\n    cout<<endl;\n  }\n}\n\nconst int MAX_N=100010;\nvector<bool> sieve_of_eratosthenes(){\n  vector<bool> isPrime(MAX_N+1,true);\n  /* isPrime[1]=false; */\n  for(int i=2;i<=MAX_N;i++){\n    if(isPrime[i]){\n      for(int j=2*i;j<=MAX_N;j+=i){\n        isPrime[j]=false;\n      }\n    }\n  }\n  return isPrime;\n}\n\nvector<pint> prime_factorize(ll n){\n  vector<pint> ans;\n  for(ll p=2;p<=sqrt(n);p++){\n    if(n%p!=0) continue;\n    ll cnt=0;\n    while(n%p==0){\n      n/=p;\n      cnt++;\n    }\n    ans.push_back(make_pair(p,cnt));\n  }\n  if(n!=1) ans.push_back(make_pair(n,1));\n  return ans;\n}\n\n/*bool cmp(pint a, pint b) { return a.second < b.second; }*/\n\n/*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/\nint main() {\n  IOS;\n  ll n,k,l,r;cin>>n>>k>>l>>r;\n  vector<ll> v(n);\n  rep(i,n) cin>>v[i];\n  ll n1=n/2,n2=n-n1;\n  vector<ll> g[k+1];\n  rep(bit,(1<<n1)){\n    ll sum=0;\n    ll cnt=0;\n    rep(i,n1) if(bit&(1<<i)){\n      cnt++;\n      sum+=v[i];\n    }\n    if(cnt>k) continue;\n    g[cnt].push_back(sum);\n  }\n  rep(i,k+1) sort(ALL(g[i]));\n  ll ans=0;\n  rep(bit,(1<<n2)){\n    ll sum=0;\n    ll cnt=0;\n    rep(i,n2) if(bit&(1<<i)){\n      cnt++;\n      sum+=v[i+n1];\n    }\n    if(cnt>k) continue;\n    ans+=(upper_bound(ALL(g[k-cnt]),r-sum)-g[k-cnt].begin())-(lower_bound(ALL(g[k-cnt]),l-sum)-g[k-cnt].begin());\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = (A); I < (B); ++I)\n#define FORR(I,A,B) for(ll I = (B-1); I >= (A); --I)\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) //ai>=v  x is sorted\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) //ai>v  x is sorted\n#define NUM(x,v) (POSU(x,v)-POSL(x,v))  //x is sorted\nconst ll INF=1e18+7;\nconst ll MOD=1e9+7;\n\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tll N,K,L,R;\n\tcin >> N >> K >> L >> R;\n\tvector<ll> a(N);\n\tFOR(i,0,N)cin >> a[i];\n\tmultiset<P> se;\n\tse.insert({0,0});\n\tFOR(i,0,N){\n\t\tmultiset<P> t;\n\t\tfor(P x : se){\n\t\t\tt.insert(x);\n\t\t\tt.insert({x.first+a[i],x.second+1});\n\t\t}\n\t\tse = t;\n\t}\n\tll ans = 0;\n\tfor(P x : se){\n\t\tif(x.second==K && (L<=x.first && x.first<=R))ans++;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll (i)=0;(i)<(ll)(n);(i)++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\ntypedef long long ll;\ntypedef vector<ll> vl;\n\nll n, n1, n2, k, l, r, a[40], res;\nvl p[44];\n\nint main() {\n\tscanf(\"%lld %lld %lld %lld\",&n,&k,&l,&r);\n\trep(i,n) scanf(\"%lld\",&a[i]);\n\tn1 = n/2, n2 = n-n1;\n\trep(i,1<<n1) {\n\t\tll c = 0, s = 0;\n\t\trep(j,n1) if (i>>j&1) c++, s += a[j];\n\t\tp[c].pb(s);\n\t}\n\trep(i,k+1) sort(all(p[i]));\n\trep(i,1<<n2) {\n\t\tll c = 0, s = 0;\n\t\trep(j,n2) if (i>>j&1) c++, s += a[n1+j];\n\t\tif (c<=k) res += upper_bound(all(p[k-c]), r-s) - lower_bound(all(p[k-c]), l-s);\n\t}\n\tprintf(\"%lld\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint N,K;\nll L,R;\nll a[41];\n\nll bitsum(int b, int offset) {\n  ll s = 0;\n  for (int i=1; b>0; b>>=1,i+=1) {\n    if (b & 1) {\n      s += a[offset+i];\n    }\n  }\n  return s;\n}\n\nll solve() {\n  int M = N/2;\n  vector<vector<ll>> h(M+1);\n  for (int i=0; i<(1<<M); ++i) {\n    int bc = __builtin_popcount(i);\n    h[bc].push_back(bitsum(i, 0));\n  }\n  for (int i=1; i<=M; ++i) {\n    sort(h[i].begin(), h[i].end());\n  }\n  ll ans = 0;\n  for (int i=0; i<(1<<(N-M)); ++i) {\n    ll s = bitsum(i, M);\n    int bc = __builtin_popcount(i);\n    if (bc>K) {\n      continue;\n    }\n    ans += upper_bound(h[K-bc].begin(), h[K-bc].end(), R-s) - lower_bound(h[K-bc].begin(), h[K-bc].end(), L-s);\n  }\n  return ans;\n}\n\nint main() {\n  cin>>N>>K>>L>>R;\n  for (int i=0; i<N; ++i) {\n    cin>>a[i+1];\n  }\n  cout<<solve()<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\nint in(){int a;scanf(\"%d\",&a);return a;}\nll lin(){ll a;scanf(\"%lld\",&a);return a;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nvector<ll> sum[40 / 2 + 1];\n\nint main()\n{\n    ll N = lin(), K = lin(), L = lin(), R = lin();\n\n    vector<ll> A(N);\n\n    rep(i, N) {\n        A[i] = lin();\n    }\n\n    int sz1 = N / 2;\n    rep(bit, 1 << sz1) {\n        int cnt = 0;\n        ll s = 0;\n\n        rep(i, sz1) {\n            if (bit >> i & 1) {\n                cnt++;\n                s += A[i];\n            }\n        }\n\n        sum[cnt].PB(s);\n    }\n\n    rep(i, sz1 + 1) sort(all(sum[i]));\n\n    ll ans = 0;\n\n    int sz2 = N - N / 2;\n    rep(bit, 1 << sz2) {\n        int cnt = 0;\n        ll s = 0;\n\n        rep(i, sz2) {\n            if (bit >> i & 1) {\n                cnt++;\n                s += A[i + sz1];\n            }\n        }\n\n        if (K - cnt < 0 || K - cnt > sz1) continue;\n\n        int pos1 = upper_bound(all(sum[K - cnt]), R - s) - begin(sum[K - cnt]) - 1;\n        int pos2 = lower_bound(all(sum[K - cnt]), L - s) - begin(sum[K - cnt]);\n\n        if (sum[K - cnt][pos1] < sum[K - cnt][pos2]) continue;\n\n        ans += max(pos1 - pos2 + 1, 0);\n    }\n\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int int64_t\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\n#define maxup(ans, x) (ans = (ans < x ? x : ans))\n#define minup(ans, x) (ans = (ans > x ? x : ans))\n\n#define breakif(cond) if(cond) break; else\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nvoid comb(int idx, int rem, int sum, V& data, V& v) {\n\tif (rem == 0) {\n\t\tv.push_back(sum);\n\t\treturn;\n\t}\n\tif (idx == data.size()) return;\n\tcomb(idx + 1, rem, sum, data, v);\n\tcomb(idx + 1, rem - 1, sum + data[idx], data, v);\n}\n\nsigned main() {\n\tint n, k, l, r; cin >> n >> k >> l >> r;\n\tV as(n); input(as);\n\tV x; x.insert(x.begin(), as.begin(), as.begin() + as.size() / 2);\n\tV y; y.insert(y.begin(), as.begin() + as.size() / 2, as.end());\n\tint ans = 0;\n\trep(p, 0, k + 1) {\n\t\tint q = k - p;\n\t\tV ps, qs;\n\t\tcomb(0, p, 0, x, ps);\n\t\tcomb(0, q, 0, y, qs);\n\t\tsort(all(ps));\n\t\tsort(all(qs));\n\t\tif (ps.size() == 0) ps.push_back(0);\n\t\tif (qs.size() == 0) qs.push_back(0);\n\t\tfor (int s : ps) ans += upper_bound(all(qs), r - s) - lower_bound(all(qs), l - s);\n\t}\n\tcout << ans << endl;\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\n\nint main(){\n\tint N, K; ll L, R;\n\tcin >> N >> K >> L >> R;\n\tint n1 = N / 2, n2 = N - n1;\n\tvector<ll> a1(n1), a2(n2);\n\tfor(int i = 0; i < n1; i++) cin >> a1[i];\n\tfor(int i = 0; i < n2; i++) cin >> a2[i];\n\tvector<vector<ll> > b1(n1 + 1, vector<ll>());\n\tfor(int i = 0; i < (1 << n1); i++){\n\t\tint cnt = 0;\n\t\tll sum = 0;\n\t\tfor(int j = 0; j < n1; j++){\n\t\t\tif(i & (1 << j)){\n\t\t\t\tcnt++;\n\t\t\t\tsum += a1[j];\n\t\t\t}\n\t\t}\n\t\tb1[cnt].push_back(sum);\n\t}\n\tfor(int i = 0; i <= n1; i++) sort(b1[i].begin(), b1[i].end());\n\tll res = 0;\n\tfor(int i = 0; i < (1 << n2); i++){\n\t\tint cnt = 0;\n\t\tll sum = 0;\n\t\tfor(int j = 0; j < n2; j++){\n\t\t\tif(i & (1 << j)){\n\t\t\t\tcnt++;\n\t\t\t\tsum += a2[j];\n\t\t\t}\n\t\t}\n\t\tif(K - cnt < 0 || K - cnt > n1) continue;\n\t\tres += upper_bound(b1[K - cnt].begin(), b1[K - cnt].end(), R - sum) - lower_bound(b1[K - cnt].begin(), b1[K - cnt].end(), L - sum);\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nlong long n, k, l, r, a[40], pos;\nvector<long long>p[30], q[30];\nint main() {\n\tcin >> n >> k >> l >> r; pos = n / 2;\n\tfor (int i = 0; i < n; i++)cin >> a[i];\n\tfor (int i = 0; i < (1 << pos); i++) {\n\t\tlong long R = 0; for (int j = 0; j < pos; j++) { if ((i / (1 << j)) % 2 == 1) { R += a[j]; } }\n\t\tp[__builtin_popcount(i)].push_back(R);\n\t}\n\tfor (int i = 0; i < (1 << (n - pos)); i++) {\n\t\tlong long R = 0; for (int j = 0; j < n - pos; j++) { if ((i / (1 << j)) % 2 == 1) { R += a[j + pos]; } }\n\t\tq[__builtin_popcount(i)].push_back(R);\n\t}\n\tfor (int i = 0; i < 30; i++)sort(p[i].begin(), p[i].end());\n\tfor (int i = 0; i < 30; i++)sort(q[i].begin(), q[i].end());\n\tlong long cnts = 0;\n\tfor (int i = 0; i <= pos; i++) {\n\t\tint V = k - i; if (V < 0)continue;\n\t\tfor (int j = 0; j < p[i].size(); j++) {\n\t\t\tint pos1 = lower_bound(q[V].begin(), q[V].end(), l - p[i][j]) - q[V].begin();\n\t\t\tint pos2 = lower_bound(q[V].begin(), q[V].end(), r + 1 - p[i][j]) - q[V].begin();\n\t\t\tcnts += pos2 - pos1;\n\t\t}\n\t}\n\tcout << cnts << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\nsigned main(){\n    ios::sync_with_stdio(false);\n\tcin.tie(0);\n    cout << fixed << setprecision(20);\n\n    ll n,k,l,r;\n    cin>>n>>k>>l>>r;\n    ll a[n];\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n    }\n    vector<vector<ll>> v(55),v2(55);\n\n    for (long long bit = 0; bit < (1LL<<n/2); ++bit){\n        ll sum=0;\n        int cnt=0;\n        for(int i=0;i<n/2;i++){\n            if((bit>>i&1LL)) sum+=a[i],cnt++;\n        }\n        v[cnt].push_back(sum);\n        \n    }\n    for(ll bit = 0; bit< (1LL<<(n-n/2));++bit){\n        ll sum=0;\n        int cnt=0;\n        for(int i=0;i<n-n/2;i++){\n            if((bit>>i&1LL)) sum+=a[n/2+i],cnt++;\n        }\n        v2[cnt].push_back(sum);\n    }\n    for(int i=0;i<22;i++){\n        sort(v2[i].begin(),v2[i].end());\n    }\n    ll ans = 0;\n    for(int i=0;i<=k;i++){\n        for(auto j:v[i]){\n            ans += (ll)(upper_bound(v2[k-i].begin(),v2[k-i].end(),r-j) - lower_bound(v2[k-i].begin(),v2[k-i].end(),l-j));\n        }\n    }\n\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (upper_bound(ALL(c),x)-lower_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *min_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\nsigned main()\n{\n   int N ,K, L, R; cin >> N >> K >> L >> R;\n   V<int> a(N); REP(i, N) cin >> a[i];\n\n   V<V<int>> b(K+1);\n   REP(s, 1<<N/2) {\n      int total = 0, num = 0;\n      REP(i, N) if (s >> i & 1) {\n         total += a[i]; num++;\n      }\n      b[num].push_back(total);\n   }\n   REP(i, K+1) SORT(b[i]);\n\n   int ans = 0;\n   REP(s, 1<<N-N/2) {\n      int total = 0, num = 0;\n      REP(i, N) if (s >> i & 1) {\n         total += a[i + N/2]; num++;\n      }\n      ans += UB(b[K-num], R+1-total) - LB(b[K-num], L-total);\n   }\n   cout << ans << endl;\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int int64_t\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\n#define maxup(ans, x) (ans = (ans < x ? x : ans))\n#define minup(ans, x) (ans = (ans > x ? x : ans))\n\n#define breakif(cond) if(cond) break; else\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nvoid comb(int idx, int rem, int sum, V& data, V& v) {\n\tif (rem == 0) {\n\t\tv.push_back(sum);\n\t\treturn;\n\t}\n\tif (idx == data.size()) return;\n\tcomb(idx + 1, rem, sum, data, v);\n\tcomb(idx + 1, rem - 1, sum + data[idx], data, v);\n}\n\nsigned main() {\n\tint n, k, l, r; cin >> n >> k >> l >> r;\n\tV as(n); input(as);\n\tV x; x.insert(x.begin(), as.begin(), as.begin() + as.size() / 2);\n\tV y; y.insert(y.begin(), as.begin() + as.size() / 2, as.end());\n\tint ans = 0;\n\trep(p, 0, k + 1) {\n\t\tint q = k - p;\n\t\tV ps, qs;\n\t\tcomb(0, p, 0, x, ps);\n\t\tcomb(0, q, 0, y, qs);\n\t\tsort(all(ps));\n\t\tsort(all(qs));\n\t\tfor (int s : ps) {\n\t\t\tint t1 = upper_bound(all(qs), r - s) - qs.begin();\n\t\t\tint t2 = lower_bound(all(qs), r - s) - qs.begin();\n\t\t\tans += upper_bound(all(qs), r - s) - lower_bound(all(qs), l - s);\n\t\t}\n\t}\n\tcout << ans << endl;\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long int\n#define vec vector<ll>\n#define mat vector<vec>\n\nusing namespace std;\n\nconst ll mod=1000000007;\nconst ll inf=LONG_LONG_MAX;\nll dx4[4]={1,0,-1,0};\nll dy4[4]={0,-1,0,1};\nll dx8[8]={1,0,-1,1,-1,1,0,-1};\nll dy8[8]={1,1,1,0,0,-1,-1,-1};\n\nint main(){\n\n  ll n,k,l,r;\n  cin >> n >> k >> l >>r;\n\n  ll a[n];\n  for(ll i=0;i<n;i++)cin >> a[i];\n  vector<vector<ll>> v1(21),v2(21);\n\n  if(n<=20){\n    ll s=0;\n    for(ll i=0;i<(1<<n);i++){\n      if(__builtin_popcount(i)!=k)continue;\n      ll c=0;\n      for(ll j=0;j<n;j++)if(i & (1<<j))c+=a[j];\n      if(c>=l && c<=r)s++;\n    }\n    cout << s << endl;\n  }\n  else{\n    for(ll i=0;i<(1<<20);i++){\n      ll p=__builtin_popcount(i);\n      ll c=0;\n      for(ll j=0;j<20;j++)if(i & (1<<j))c+=a[j];\n      v1[p].push_back(c);\n    }\n    //cout << 5 << endl;\n    for(ll i=0;i<(1<<(n-20));i++){\n      ll p=__builtin_popcount(i);\n      ll c=0;\n      for(ll j=0;j<n-20;j++)if(i & (1<<j))c+=a[j+20];\n      v2[p].push_back(c);\n      //cout << i << endl;\n    }\n    //cout << 5 << endl;\n    for(ll i=0;i<21;i++)sort(v2[i].begin(),v2[i].end());\n    ll s=0;\n    //cout << 5 << endl;\n    for(ll i=0;i<21;i++){\n      if(i>k)continue;\n      if(k-i>20)continue;\n      for(ll j=0;j<v1[i].size();j++){\n        ll b=upper_bound(v2[k-i].begin(),v2[k-i].end(),r-v1[i][j])-lower_bound(v2[k-i].begin(),v2[k-i].end(),l-v1[i][j]);\n        if(b>=1)s+=b;\n      }\n    }\n    cout << s << endl;\n  }\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = (A); I < (B); ++I)\n#define FORR(I,A,B) for(ll I = (B-1); I >= (A); --I)\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) //ai>=v  x is sorted\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) //ai>v  x is sorted\n#define NUM(x,v) (POSU(x,v)-POSL(x,v))  //x is sorted\nconst ll INF=1e18+7;\nconst ll MOD=1e9+7;\n\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tll N,K,L,R;\n\tcin >> N >> K >> L >> R;\n\tll Na = N/2;\n\tll Nb = N - Na;\n\tvector<ll> a(Na),b(Nb);\n\tFOR(i,0,Na)cin >> a[i];\n\tFOR(i,0,Nb)cin >> b[i];\n\tvector<ll> A[Na+1],B[Nb+1];\n\tA[0].push_back(0);\n\tB[0].push_back(0);\n\n\tFOR(i,0,Na){\n\t\tFORR(j,1,i+2){\n\t\t\tfor(ll x:A[j-1])A[j].push_back(a[i]+x);\n\t\t}\n\t}\n\tFOR(i,0,Nb){\n\t\tFORR(j,1,i+2){\n\t\t\tfor(ll x:B[j-1])B[j].push_back(b[i]+x);\n\t\t}\n\t}\n\tFOR(i,1,Na+1)sort(A[i].begin(),A[i].end());\n\tFOR(i,1,Nb+1)sort(B[i].begin(),B[i].end());\n\tll ans = 0;\n\tFOR(i,0,Na+1){\n\t\tfor(ll x:A[i]){\n\t\t\tll num;\n\t\t\tif(K>=i&&(K-i<=Nb))num = POSU(B[K-i],R-x)-POSL(B[K-i],L-x);\n\t\t\telse num = 0;\n\t\t\tans += num;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\nint in(){int a;scanf(\"%d\",&a);return a;}\nll lin(){ll a;scanf(\"%lld\",&a);return a;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nvector<ll> sum[40 / 2 + 1];\n\nint main()\n{\n    ll N = lin(), K = lin(), L = lin(), R = lin();\n\n    vector<ll> A(N);\n\n    rep(i, N) {\n        A[i] = lin();\n    }\n\n    int sz1 = N / 2;\n    rep(bit, 1 << sz1) {\n        int cnt = 0;\n        ll s = 0;\n\n        rep(i, sz1) {\n            if (bit >> i & 1) {\n                cnt++;\n                s += A[i];\n            }\n        }\n\n        sum[cnt].PB(s);\n    }\n\n    rep(i, sz1 + 1) sort(all(sum[i]));\n\n    ll ans = 0;\n\n    int sz2 = N - N / 2;\n    rep(bit, 1 << sz2) {\n        int cnt = 0;\n        ll s = 0;\n\n        rep(i, sz2) {\n            if (bit >> i & 1) {\n                cnt++;\n                s += A[i + sz1];\n            }\n        }\n\n        if (K - cnt < 0 || K - cnt > sz1) continue;\n\n        int pos1 = upper_bound(all(sum[K - cnt]), R - s) - begin(sum[K - cnt]) - 1;\n        int pos2 = lower_bound(all(sum[K - cnt]), L - s) - begin(sum[K - cnt]);\n\n        if (pos1 < pos2) continue;\n\n        ans += max(pos1 - pos2 + 1, 0);\n    }\n\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\nusing ll = long long;\n\nint main(){\n  ll n, k, l, r;\n  cin >> n >> k >> l >> r;\n  ll a[n];\n  rep(i,n) cin >> a[i];\n  vector<vector<ll>> val(k+1);\n  rep(i,(1<<(n/2))) {\n    ll cnt = 0;\n    ll price = 0;\n    rep(j,n/2) {\n      if(i & (1<<j)) {\n        cnt++;\n        price += a[j];\n      }\n    }\n    if(cnt <= k) val[cnt].push_back(price);\n  }\n  rep(i,k+1) sort(val[i].begin(),val[i].end());\n  ll ans = 0;\n  rep(i,(1<<(n-n/2))) {\n    ll cnt = 0;\n    ll price = 0;\n    rep(j,n-n/2) {\n      if(i & (1<<j)) {\n        cnt++;\n        price += a[n/2+j];\n      }\n    }\n    if(cnt <= k) ans += upper_bound(val[k-cnt].begin(),val[k-cnt].end(),r-price) - lower_bound(val[k-cnt].begin(),val[k-cnt].end(),l-price);\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\n\nint main(){\n    ll n,k,l,r;\n    cin>>n>>k>>l>>r;\n    ll m=n/2;\n    vector<ll> a,b;\n    for(int i=0;i<m;i++){\n        ll b;\n        cin>>b;\n        a.push_back(b);\n    }\n    for(ll i=m;i<n;i++){\n        ll a;\n        cin>>a;\n        b.push_back(a);\n    }\n    vector<vector<ll>> A,B;\n    ll key=1; key<<=m; key--;\n    A.resize(m+1);\n    for(;key>=0;key--){\n        ll sum=0;\n        ll count=0;\n        for(int i=0;i<m;i++){\n            if(key>>i&1){sum+=a[i]; count++;}\n        }\n        A[count].push_back(sum);\n    }\n    ll R=n-m;\n    key=1; key<<=R; key--;\n    B.resize(R+1);\n    for(;key>=0;key--){\n        ll sum=0;\n        ll count=0;\n        for(int i=0;i<R;i++){\n            if(key>>i&1){sum+=b[i]; count++;}\n        }\n        B[count].push_back(sum);\n    }\n    ll ans=0;\n    for(int i=0;i<=m;i++){\n        sort(A[i].begin(),A[i].end());\n        for(int t=0;t<=R;t++){\n            if(i+t!=k){continue;}\n            sort(B[t].begin(),B[t].end());\n            for(int k=0;k<A[i].size();k++){\n                ll n=A[i][k];\n                auto L=lower_bound(B[t].begin(),B[t].end(),l-n);\n                auto R=upper_bound(B[t].begin(),B[t].end(),r-n);\n                ans+=R-L;\n            }\n        }\n    }\n    cout<<ans<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAX 40\n\n\nint N, K;\nlong long L, R;\nlong long a[MAX];\n\n\n\nint main()\n{\n\tcin >> N >> K >> L >> R;\n\tfor( int i = 0; i < N; i++ ) {\n\t\tcin >> a[i];\n\t}\n\n\tvector< long long > v[K+1];\n\tint n1 = N / 2;\n\tint n2 = N - n1;\n\tfor( int i = 0; i < (1 << n1); i++ ) {\n\t\tlong long sum = 0;\n\t\tint cnt = 0;\n\t\tfor( int j = 0; j < n1; j++ ) {\n\t\t\tif( i & (1 << j) ) {\n\t\t\t\tcnt++;\n\t\t\t\tsum += a[j];\n\t\t\t}\n\t\t}\n\t\tif( cnt > K ) {\n\t\t\tcontinue;\n\t\t}\n\t\tv[cnt].push_back( sum );\n\t}\n\tfor( int i = 0; i < K + 1; i++ ) {\n\t\tsort( v[i].begin(), v[i].end() );\n\t}\n\tlong long ans = 0;\n\tfor( int i = 0; i < (1 << n2); i++ ) {\n\t\tlong long sum = 0;\n\t\tint cnt = 0;\n\t\tfor( int j = 0, k = n1; j < n2; j++, k++ ) {\n\t\t\tif( i & (1 << j) ) {\n\t\t\t\tcnt++;\n\t\t\t\tsum += a[k];\n\t\t\t}\n\t\t}\n\t\tif( cnt > K ) {\n\t\t\tcontinue;\n\t\t}\n\t\tvector<long long>::iterator r = upper_bound( v[K - cnt].begin(), v[K - cnt].end(), R - sum );\n\t\tvector<long long>::iterator l = lower_bound( v[K - cnt].begin(), v[K - cnt].end(), L - sum );\n\t\tans += r - l;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,k,l,r;\n  cin>>n>>k>>l>>r;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n\n  Int h=20;\n  if(n<=h){\n    Int ans=0;\n    for(Int b=0;b<(1<<n);b++){\n      Int c=0,s=0;\n      for(Int i=0;i<n;i++)\n\tif((b>>i)&1) c++,s+=a[i];\n      if(c==k&&l<=s&&s<=r) ans++;\n    }\n    cout<<ans<<endl;\n    return 0;\n  }\n\n  vector<vector<Int> > v(h+1);\n  for(Int b=0;b<(1<<h);b++){\n    Int c=0,s=0;\n    for(Int i=0;i<n;i++)\n      if((b>>i)&1) c++,s+=a[i];\n    v[c].emplace_back(s);\n  }\n  for(Int i=0;i<=h;i++) sort(v[i].begin(),v[i].end());\n  \n  Int ans=0;\n  for(Int b=0;b<(1<<(n-h));b++){\n    Int c=0,s=0;\n    for(Int i=0;i<(n-h);i++)\n      if((b>>i)&1) c++,s+=a[h+i];\n    if(c>k) continue;\n    ans+=upper_bound(v[k-c].begin(),v[k-c].end(),r-s)-lower_bound(v[k-c].begin(),v[k-c].end(),l-s);\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\nsigned main(void) {\n  ll n, k, l, r, a[45];\n  cin >> n >> k >> l >> r;\n  REP(i, n) cin >> a[i];\n  ll n2 = n / 2;\n  //ps1[i] = i個選択したときのコインの合計価格の集合\n  VVL ps1(n2 + 1), ps2(n - n2 + 1);\n\n  //前半分を全列挙\n  REP(i, 1 << n2) {\n    ll vl = 0, cnt = 0;\n    REP(j, n2) if (i >> j & 1) {vl += a[j]; ++cnt;}\n    ps1[cnt].push_back(vl);\n  }\n  //後半分を全列挙\n  REP(i, 1 << (n - n2)) {\n    ll vl = 0, cnt = 0;\n    REP(j, n - n2) if (i >> j & 1) {vl += a[n2 + j]; ++cnt;}\n    ps2[cnt].push_back(vl);\n  }\n  //前半分をソート\n  REP(i, n2) sort(ALL(ps1[i]));\n\n  ll ret = 0;\n  FOR(i, max((ll)0, k - n2), min(k, n - n2) + 1) {\n    REP(j, ps2[i].size()) {\n      //二分探索で個数を求める\n      ret += (ll)(upper_bound(ALL(ps1[k - i]), r - ps2[i][j]) -\n                  lower_bound(ALL(ps1[k - i]), l - ps2[i][j]));\n    }\n  }\n  cout << ret << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\nll inf =  1e9;\n\n\nint main(){\n    ll n,k,l,r;\n    cin>>n>>k>>l>>r;\n    vector<ll> a(n),b,c;\n    for(ll i=0;i<n;i++)cin>>a[i];\n    for(ll i=0;i<n/2;i++) b.push_back(a[i]);\n    for(ll i=n/2;i<n;i++) c.push_back(a[i]);\n\n    ll bn = n/2,cn = n-n/2;\n    vector<mp> bb,cc;//i個の数字でできる数\n    for(ll i=0;i< (1<<bn);i++){\n\tll cnt = 0;\n\tll sum = 0;\n\tfor(ll j=0;j<bn;j++){\n\t    if( (i>>j)&1 ){\n\t\tcnt++;\n\t\tsum += b[j];\n\t    }\n\t}\n\tbb.push_back( mp(cnt, sum ) );\n    }\n    for(ll i=0;i< (1<<cn);i++){\n\tll cnt = 0;\n\tll sum = 0;\n\tfor(ll j=0;j<cn;j++){\n\t    if( (i>>j)&1 ){\n\t\tcnt++;\n\t\tsum += c[j];\n\t    }\n\t}\n\tcc.push_back( mp(cnt, sum) );\n    }\n    sort( bb.begin(), bb.end() );\n    sort( cc.begin(), cc.end() );\n    ll res = 0;\n    for(auto it:bb){\n\tll bi = it.first;\n\tll bs = it.second;\n\tauto s = lower_bound(cc.begin(),cc.end(), mp(k-bi,l-bs) );\n\tauto t = upper_bound(cc.begin(),cc.end(), mp(k-bi,r-bs) );\n\tres += (t-s);\n    }\n    cout<<res<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nsigned main(){\n    // cout << fixed << setprecision(10) << flush;\n\n    int n, k, l, r;\n    cin >> n >> k >> l >> r;\n    vector<int> a(n);\n    for(int i=0; i<n; i++){\n        cin >> a[i];\n    }\n\n    // 2^{n/2} について詰める\n    vector<vector<int>> cs(n/2+1, vector<int>());\n    for(int i=0; i<(1<<(n/2)); i++){\n        int s = 0;\n        for(int j=0; j<n/2; j++){\n            if(i & (1<<j)){\n                s += a[j];\n            }\n        }\n        cs[__builtin_popcount(i)].push_back(s);\n    }\n    for(int i=0; i<n/2+1; i++){\n        sort(cs[i].begin(), cs[i].end());\n    }\n\n    // 2^(n-n/2) について探す\n    int cnt = 0;\n    for(int i=0; i<(1<<(n-n/2)); i++){\n        int s = 0;\n        for(int j=n/2; j<n; j++){\n            if(i & (1<<(j-n/2))){\n                s += a[j];\n            }\n        }\n        int pc = k - __builtin_popcount(i);\n        if(pc >= 0 && pc <= n/2){\n            auto itru = upper_bound(cs[pc].begin(), cs[pc].end(), r-s);\n            auto itrl = lower_bound(cs[pc].begin(), cs[pc].end(), l-s);\n            cnt += itru - itrl;\n        }\n    }\n\n    cout << cnt << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\n/*\n http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_4_B&lang=jp\n \n ??????????????????????????? II\n N ?????????????????????????????????????????????????????????????????????ai ?????§??????E ??????, ????????????K ?????????????????????????????¨?????£?????????, ?????????????¨????L ?????\\??? R ?????\\?????????????????¨?????£???????????????????????????????????????????????????????????????????????§????????????? ?????????, ????????????????????????????????\\??????????????¨????????????\n \n Constraints\n 1 ??? K ??? N ??? 40\n 1 ??? ai ??? 1016\n 1 ??? L ??? R ??? 1016\n ??\\?????????????????´??°??§???????????????\n \n Output\n ?????????????????°??? 1 ???????????????????????????\n */\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll N,K,L,R; cin >> N >> K >> L >> R;\n    vector<ll> a(N);\n    for(int i = 0; i < N;i++) cin >> a[i];\n    \n    \n    /*\n     bit?????¨???????????§N/2?????¨????????´????????¨???????????????\n     ??????????????????N - N/2??????????????? L - X <= (Y) <= R - X?????¨???????????????\n     O(N^20) + O(N^20*logM)\n     */\n    vector<vector<ll>> half_Sum(N/2 + 1);\n    ll n1 = N/2;\n    for(int i = 0; i < (1<<n1);i++){\n        ll Sum = 0;\n        ll cnt = 0;\n        for(int j = 0; j < n1;j++){\n            if((i >> j)&1){\n                cnt++;\n                Sum += a[j];\n            }\n        }\n        half_Sum[cnt].emplace_back(Sum);\n    }\n    for(int i = 0; i < n1;i++) sort(half_Sum[i].begin(),half_Sum[i].end());\n    ll ans = 0;\n    ll n2 = N - n1;\n    for(int i = 0; i < (1<<n2);i++){\n        ll Sum = 0;\n        ll cnt = 0;\n        for(int j = 0; j < n2;j++){\n            if((i>>j)&1){\n                cnt++;\n                Sum += a[n1 + j];\n            }\n        }\n        \n        if(!(K - cnt >= 0)|| n1 + cnt < K)continue;\n        \n        ll it1 = upper_bound(half_Sum[K - cnt].begin(), half_Sum[K-cnt].end(), R-Sum) - half_Sum[K-cnt].begin();\n        ll it2 = lower_bound(half_Sum[K-cnt].begin(), half_Sum[K-cnt].end(), L-Sum) - half_Sum [K-cnt].begin();\n        \n        if(it1 - it2 <= 0) continue;\n        ans += it1 - it2;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vc = vector<char>;\nusing vvc = vector<vc>;\nusing pll = pair<ll, ll>;\nusing stkll = vector<pll>;\nconst ll INF = 1LL << 60;\nconst ll MOD = 1e9 + 7;\n#define rep(i, n) for (ll i = 0; i < (n); i++)\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#ifndef ONLINE_JUDGE\n    #define debug(x) cerr << #x << \": \" << x << endl;\n#else\n    #define debug(x)\n#endif\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    ll n, k, l, r;\n    cin >> n >> k >> l >> r;\n    vll a(n);\n    rep(i, n) cin >> a[i];\n\n    vvll v1(30), v2(30);\n    v1[0].push_back(0);\n    v2[0].push_back(0);\n    for(ll bit = 1; bit < 1<<(n/2); bit++) {\n        ll tmp = 0;\n        ll cnt = __builtin_popcountll(bit);\n        rep(i, n/2) {\n            if(bit>>i&1) tmp += a[i];\n        }\n        v1[cnt].push_back(tmp);\n    }\n    for(auto& v : v1) sort(v.begin(), v.end());\n\n    for(ll bit = 1; bit < 1<<(n-n/2); bit++) {\n        ll tmp = 0;\n        ll cnt = __builtin_popcountll(bit);\n        rep(i, n - n/2) {\n            if(bit>>i&1) tmp += a[n/2 + i];\n        }\n        v2[cnt].push_back(tmp);\n    }\n    for(auto& v : v2) sort(v.begin(), v.end());\n\n    ll ans = 0;\n    rep(i, n/2+1) {\n        if(i > k) continue;\n        for(auto x : v1[i]) {\n            if(r < x) continue;\n            if(k-i > n - n/2) continue;\n            ans += upper_bound(v2[k-i].begin(), v2[k-i].end(), r-x)\n                   - lower_bound(v2[k-i].begin(), v2[k-i].end(), l-x);\n        }\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 40\nusing namespace std;\n\nvector<int> A[11];\nint coin[N];\n\nint calc(int bit,int arr[],int n){\n  int res = 0;\n  for(int i=0;i<n;i++) if(bit>>i&1) res += arr[i];\n  return res;\n}\n\nsigned main(){\n\n  int n,K,L,R;\n  cin>>n>>K>>L>>R;\n  for(int i=0;i<n;i++) cin>>coin[i];\n  \n  int a = n/2;\n  int b = n-a;\n  for(int i=0;i<(1<<a);i++){\n    int cnt = __builtin_popcount(i);\n    A[cnt].push_back(calc(i,coin,a));\n  }\n\n  int ans = 0;\n  for(int i=0;i<(1<<b);i++){\n    int cnt = __builtin_popcount(i);\n    int br = calc(i,coin+a,b);\n    if(cnt>K) continue;\n    for(int ar:A[K-cnt])if(L<=ar+br&&ar+br<=R) ans++;\n  }\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<iomanip>\n#include<sstream>\n#include<map>\n#include<set>\n#include<cmath>\nusing namespace std;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T& val) {\n\tstd::fill((T*)array, (T*)(array + N), val);\n}\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define req(i,n) for(int i = 1;i <=n;i++)\n#define rrep(i,n) for(int i = n -1;i >= 0;i--)\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long int ull;\nconst ll INF = 1LL << 60;\nconst int inf = 1 << 25;\nint main(void) {\n\tint N; ll K, L, R; cin >> N >> K >> L >> R;\n\tvector<ll> a(N);\n\trep(i, N) cin >> a[i];\n\tint M = N / 2; vector<vector<ll>> x(41);\n\trep(i, 1 << M) {\n\t\tint cnt = 0; ll add = 0;\n\t\trep(j, M) {\n\t\t\tif ((i >> j) & 1) cnt++,add += a[j];\n\t\t}x[cnt].push_back(add);\n\t}\n\trep(i, M + 1) {\n\t\tsort(ALL(x[i]));\n\t}ll ans = 0;\n\trep(i, 1 << (N - M)) {\n\t\tll add = 0; int cnt = 0;\n\t\trep(j, (N - M)) {\n\t\t\tif ((i >> j) & 1) cnt++, add += a[j + M];\n\t\t}\n\t\tif (cnt > K) continue;\n\t\tans += upper_bound(ALL(x[K - cnt]), R - add) - lower_bound(ALL(x[K - cnt]), L - add);\n\t}cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (upper_bound(ALL(c),x)-lower_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *min_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\nsigned main()\n{\n   int N ,K, L, R; cin >> N >> K >> L >> R;\n   V<int> a(N); REP(i, N) cin >> a[i];\n\n   V<V<int>> b(K+1);\n   REP(s, 1<<N/2) {\n      int total = 0, num = 0;\n      REP(i, N) if (s >> i & 1) {\n         total += a[i]; num++;\n      }\n      b[num].push_back(total);\n   }\n   REP(i, K+1) SORT(b[i]);\n\n   int ans = 0;\n   REP(s, 1<<N-N/2) {\n      int total = 0, num = 0;\n      REP(i, N) if (s >> i & 1) {\n         total += a[i + N/2]; num++;\n      }\n      if (K < num) continue;\n      ans += (UB(b[K-num], R+1-total) - LB(b[K-num], L-total));\n   }\n   cout << ans << endl;\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,N) for(int i=0;i<int(N);++i)\n#define rep1(i,N) for(int i=1;i<int(N);++i)\n#define all(a) (a).begin(),(a).end()\n#define print(v) { cerr<<#v<<\": [ \"; for(auto _ : v) cerr<<_<<\", \"; cerr<<\"]\"<<endl; }\n#define printpair(v) { cerr<<#v<<\": [ \"; for(auto _ : v) cerr<<\"{\"<<_.first<<\",\"<<_.second<<\"}\"<<\", \"; cerr<<\"]\"<<endl; }\n#define dump(x) cerr<<#x<<\": \"<<x<<endl;\n#define bit(k) (1LL<<(k))\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, ll> l_l;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 >& p) {\n  os << \"{\" <<p.first << \", \" << p.second << \"}\";\n  return os;\n}\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nconst int INF = (ll)1e9;\nconst ll INFLL = (ll)1e17+1;\nconst ll MOD = (ll)1e9+7;\nconst double PI = acos(-1.0);\n/*\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst string dir = \"DRUL\";\n*/\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    int N, K;\n    ll L,R;\n    cin >> N >> K;\n    cin >> L >> R;\n    vector<ll> a(N);\n    rep(i, N)cin >> a[i];\n    sort(all(a));\n    int l = N/2;\n    int r = N - N/2;\n    vector<pair<ll,ll>> v[2];\n    map<pair<ll,ll>,ll> mp;\n    for(int i = 0; i < bit(l);i++){\n        ll sum = 0;\n        ll cnt = __builtin_popcount(i);\n        for(int j = 0; j < l; j++){\n            if(i&bit(j))sum += a[j];\n        }\n        v[0].emplace_back(cnt, sum);\n    }\n    for(int i = 0; i < bit(r); i++){\n        ll sum = 0;\n        ll cnt = __builtin_popcount(i);\n        for(int j = 0; j < r; j++){\n            if(i&bit(j))sum += a[l+j];\n        }\n        v[1].emplace_back(cnt, sum);\n        // mp[{sum,cnt}]++;\n    }\n    int sz = v[0].size();\n    sort(all(v[1]));\n    ll ans = 0;\n    rep(i,sz){\n        ll sum = v[0][i].second;\n        ll cnt = v[0][i].first;\n        ll add = upper_bound(all(v[1]), make_pair(K-cnt,R-sum))\n                -lower_bound(all(v[1]), make_pair(K-cnt,L-sum));\n        ans += add;\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\npair<ll, ll> ps[1<<20];\nsigned main(void)\n{\n  int n, k;\n  ll l, r, a[45];\n  cin >> n >> k >> l >> r;\n  REP(i, n) cin >> a[i];\n\n  int n2 = n/2;\n  REP(i, 1<<n2) {\n    ll vl = 0, cnt = 0;\n    REP(j, n2) {\n      if(i >> j & 1) {\n        vl += a[j];\n        ++cnt;\n      }\n    }\n    if(cnt <= k) ps[i] = MP(cnt, vl);\n  }\n  sort(ps, ps+(1<<n2));\n  ll ret = 0;\n  REP(i, 1<<(n-n2)) {\n    ll vl = 0, cnt = 0;\n    REP(j, n-n2) {\n      if(i >> j & 1) {\n        vl += a[n2+j];\n        ++cnt;\n      }\n    }\n    auto itr1 = lower_bound(ps, ps+(1<<n2), MP((ll)k-cnt, (ll)0)),\n         itr2 = upper_bound(ps, ps+(1<<n2), MP((ll)k-cnt, (ll)LLINF));\n    ret += upper_bound(itr1, itr2, MP(k-cnt, r-vl)) - lower_bound(itr1, itr2, MP(k-cnt, l-vl));\n  }\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define ONLINE_JUDGE\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pl;\ntypedef vector<pl> vp;\nconst ll INF=1001001001;\nconst ll LINF=1001001001001001001;\nconst ll D4[]={0,1,0,-1,0};\nconst ll D8[]={0,1,1,0,-1,-1,1,-1,0};\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep2(i,n) for(ll i=0;i<(n);++i)\n#define _rep3(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,_rep3,_rep2)(__VA_ARGS__)\n#define _repe2(i,n) for(ll i=0;i<=(n);++i)\n#define _repe3(i,a,b) for(ll i=(a);i<=(b);++i)\n#define repe(...) _overload3(__VA_ARGS__,_repe3,_repe2)(__VA_ARGS__)\n#define _rrep2(i,n) for(ll i=(n)-1;i>=0;i--)\n#define _rrep3(i,a,b) for(ll i=(b)-1;i>=(a);i--)\n#define rrep(...) _overload3(__VA_ARGS__,_rrep3,_rrep2)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\ntemplate<class T>\nbool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>\nbool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\n\nvoid solve();\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    solve();\n}\n\nvoid solve(){\n    ll n,k,l,r;cin>>n>>k>>l>>r;\n    vl a(n);rep(i,n)cin>>a[i];\n\n    ll h=n/2;\n    vvl c(h+1);\n    rep(i,1<<h){\n        ll sum=0;\n        rep(j,h){\n            if(i>>j&1)sum+=a[j];\n        }\n        c[__builtin_popcount(i)].push_back(sum);\n    }\n    repe(i,h)sort(all(c[i]));\n\n    ll ans=0;\n    ll h2=n-h;\n    rep(i,1<<h2){\n        ll cnt=__builtin_popcount(i);\n        if(cnt>k||cnt+h<k)continue;\n        ll sum=0;\n        rep(j,h2){\n            if(i>>j&1)sum+=a[h+j];\n        }\n        ans+=upper_bound(all(c[k-cnt]),r-sum)-lower_bound(all(c[k-cnt]),l-sum);\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 問題: N枚のコインからK枚を選んで金額が[L,R]の範囲になる選び方の数を求める\n// 解法: \n\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n\n#define pb push_back\n#define mp make_pair\n\nmap<ll, ll> make_map(vector<ll>& As) {\n    map<ll, ll> ret;\n    for(auto a: As) ++ret[a];\n    return ret;\n}\n\nmap<ll, ll> make_combination(map<ll, ll>& As, map<ll, ll>& Bs) {\n    map<ll, ll> ret;\n    for(auto a: As) {\n        for(auto b: Bs) {\n            auto val = a.first + b.first;\n            auto cnt = a.second * b.second;\n            ret[val] += cnt;\n        }\n    }\n    return ret;\n}\n\nll coin_combination_2(ll N, ll K, ll L, ll R,\n                      vector<ll>& As) {\n    // 前半部の全列挙\n    const auto N2 = N / 2;\n    vector<vector<ll>> former(N2 + 1);\n    REP(i, (1 << N2)) {\n        ll sum = 0;\n        int cnt = 0;\n        REP(j, N2) {\n            if (i & (1 << j)) {\n                sum += As[j];\n                cnt++;\n            }\n        }\n        former[cnt].pb(sum);\n    }\n\n    // 後半部の全列挙\n    vector<vector<ll>> latter(N - N2 + 1);\n    REP(i, (1 << (N - N2))) {\n        ll sum = 0;\n        int cnt = 0;\n        REP(j, (N - N2)) {\n            if (i & (1 << j)) {\n                sum += As[N2 + j];\n                cnt++;\n            }\n        }\n        latter[cnt].pb(sum);\n    }\n\n    REP(n, N2) sort(ALL(former[n]));\n    REP(n, N - N2) sort(ALL(latter[n]));\n\n\n    int ans = 0;\n    // 前半部でn個使う場合\n    REP(n, N2 + 1) {\n        if (n + N - N2 < K) continue;\n        if (n > K) break;\n\n        for (auto e: former[n]) {\n            auto mn = max(0LL, L - e);\n            auto mx = max(0LL, R - e);\n            if (mx == 0) break;\n            //cout << \"mn, mx = \" << mn << \",\" << mx << endl;\n\n            auto it1 = lower_bound(ALL(latter[K - n]), mn);\n            auto it2 = lower_bound(ALL(latter[K - n]), mx + 1);\n            ans += (it2 - it1);\n        }\n    }\n    return ans;\n}\n\nint main() {\n    ll N, K, L, R;\n    cin >> N >> K >> L >> R;\n    vector<ll> As(N);\n    REP(n, N) cin >> As[n];\n    cout << coin_combination_2(N, K, L, R, As) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n#define int ll\n\npair<ll, ll> ps[1<<20];\nsigned main(void)\n{\n  int n, k;\n  ll l, r, a[45];\n  cin >> n >> k >> l >> r;\n  REP(i, n) cin >> a[i];\n\n  int n2 = n/2;\n  REP(i, 1<<n2) {\n    ll vl = 0, cnt = 0;\n    REP(j, n2) {\n      if(i >> j & 1) {\n        vl += a[j];\n        ++cnt;\n      }\n    }\n    if(cnt <= k) ps[i] = MP(cnt, vl);\n  }\n  sort(ps, ps+(1<<n2));\n  ll ret = 0;\n  REP(i, 1<<(n-n2)) {\n    ll vl = 0, cnt = 0;\n    REP(j, n-n2) {\n      if(i >> j & 1) {\n        vl += a[n2+j];\n        ++cnt;\n      }\n    }\n    auto itr1 = lower_bound(ps, ps+(1<<n2), MP((ll)k-cnt, (ll)0)),\n         itr2 = upper_bound(ps, ps+(1<<n2), MP((ll)k-cnt, (ll)LLINF));\n    ret += upper_bound(itr1, itr2, MP(k-cnt, r-vl)) - lower_bound(itr1, itr2, MP(k-cnt, l-vl));\n  }\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std; typedef long long ll;const ll INF = 1e18; const ll MOD = 1e9+7;\ntypedef pair<int,int> P; const int xx[4]={1,-1,0,0}, yy[4]={0,0,1,-1}; struct tp{ll x1,y1,x2,y2;};\n\nint main(){\n  ll n,k,l,r; cin>>n>>k>>l>>r; ll m1=n/2, m2=n-n/2, an=0;\n  ll a[n]; for(int i=0;i<n;i++) cin>>a[i];\n  for(ll u=0,v=k;u<=k;u++,v--) {\n    vector<ll> g1, g2;\n    for(int i=0;i<(1<<m1);i++) {\n      ll nm=0;\n      for(int j=0;j<m1;j++) {if (i & (1<<j)) nm++;}\n      if (nm != u) continue;\n      ll sm=0;\n      for(int j=0;j<m1;j++) {if (i & (1<<j)) sm += a[j];}\n      g1.push_back(sm);\n    }\n    for(int i=0;i<(1<<m2);i++) {\n      ll nm=0;\n      for(int j=0;j<m2;j++) {if (i & (1<<j)) nm++;}\n      if (nm != v) continue;\n      ll sm=0;\n      for(int j=0;j<m2;j++) {if (i & (1<<j)) sm += a[m1+j];}\n      g2.push_back(sm);\n    }\n    //for(ll x:g1) cout<<x<<\" \"; cout<<endl;\n    //for(ll x:g2) cout<<x<<\" \"; cout<<endl;\n\n    sort(g1.begin(), g1.end());\n    for(ll x:g2) {\n      auto it1=lower_bound(g1.begin(), g1.end(), l-x);\n      auto it2=upper_bound(g1.begin(), g1.end(), r-x);\n      an += it2-it1;\n    }\n    //cout<<an<<endl;\n  }\n  cout<<an<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll N, K, L, R;\nll a[40];\n\ndecltype(auto) enumerate(int sidx, int size) {\n  vector<pair<ll, ll>> ret;\n  for(int i=0; i<1<<size; i++) {\n    int cnt = 0; ll sum = 0;\n    for(int j=0; j<size; j++)\n      if(i >> j & 1) cnt++, sum += a[sidx + j];\n    ret.emplace_back(cnt, sum);\n  }\n  return ret;\n}\n\nll solve() {\n  decltype(auto) v0 = enumerate(0, N / 2);\n  decltype(auto) v1 = enumerate(N / 2, (N + 1) / 2);\n  sort(v0.begin(), v0.end());\n  ll ret = 0;\n  for(int i=0; i<(int)v1.size(); i++)\n    ret +=  upper_bound(v0.begin(), v0.end(), make_pair(K - v1[i].first, R - v1[i].second))\n          - lower_bound(v0.begin(), v0.end(), make_pair(K - v1[i].first, L - v1[i].second));\n  return ret;\n}\n\nint main() {\n  cin >> N >> K >> L >> R;\n  for(int i=0; i<N; i++) cin >> a[i];\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < int(n); i++)\n#define rrep(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define reps(i, n) for (int i = 1; i <= int(n); i++)\n#define rreps(i, n) for (int i = int(n); i >= 1; i--)\n#define repc(i, n) for (int i = 0; i <= int(n); i++)\n#define rrepc(i, n) for (int i = int(n); i >= 0; i--)\n#define repi(i, a, b) for (int i = int(a); i < int(b); i++)\n#define repic(i, a, b) for (int i = int(a); i <= int(b); i++)\n#define each(x, y) for (auto &x : y)\n#define all(a) (a).begin(), (a).end()\n#define bit32(x) (1 << (x))\n#define bit64(x) (1ll << (x))\n#define sz(v) ((int) v.size())\n\nusing namespace std;\n\nusing i64 = long long;\nusing f80 = long double;\nusing vi32 = vector<int>;\nusing vi64 = vector<i64>;\nusing vf80 = vector<f80>;\nusing vstr = vector<string>;\n\ninline void yes() { cout << \"Yes\" << endl; exit(0); }\ninline void no() { cout << \"No\" << endl; exit(0); }\ninline i64 gcd(i64 a, i64 b) { if (min(a, b) == 0) return max(a, b); if (a % b == 0) return b; return gcd(b, a % b); }\ninline i64 lcm(i64 a, i64 b) { if (min(a, b) == 0) return max(a, b); return a / gcd(a, b) * b; }\ntemplate <typename T> class pqasc : public priority_queue<T, vector<T>, greater<T>> {};\ntemplate <typename T> class pqdesc : public priority_queue<T, vector<T>, less<T>> {};\ntemplate <typename T> inline void amax(T &x, T y) { x = max(x, y); }\ntemplate <typename T> inline void amin(T &x, T y) { x = min(x, y); }\ntemplate <typename T> inline T exp(T x, i64 n, T e = 1) { T r = e; while (n > 0) { if (n & 1) r *= x; x *= x; n >>= 1; } return r; }\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v) { each(x, v) is >> x; return is; }\ntemplate <typename T> ostream& operator<<(ostream &os, vector<T> &v) { rep(i, v.size()) { if (i) os << ' '; os << v[i]; } return os; }\nvoid solve(); int main() { ios::sync_with_stdio(0); cin.tie(0); cout << fixed << setprecision(16); solve(); return 0; }\n\nvoid solve() {\n  int N, K;\n  i64 L, R;\n  cin >> N >> K >> L >> R;\n  vi64 a(N);\n  cin >> a;\n  vector<vi64> sums(K + 1);\n  int M = min(20, N);\n  rep(i, bit32(M)) {\n    int cnt = 0;\n    i64 sum = 0;\n    rep(j, M) {\n      if (bit32(j) & i) {\n        cnt++;\n        sum += a[j];\n      }\n    }\n    if (cnt > K) continue;\n    sums[cnt].emplace_back(sum);\n  }\n  repc(i, K) sort(all(sums[i]));\n  int O = N - M;\n  i64 ans = 0;\n  rep(i, bit32(O)) {\n    int cnt = 0;\n    i64 sum = 0;\n    rep(j, O) {\n      if (bit32(j) & i) {\n        cnt++;\n        sum += a[M + j];\n      }\n    }\n    cnt = K - cnt;\n    if (cnt < 0) continue;\n    int l = lower_bound(all(sums[cnt]), L - sum) - sums[cnt].begin();\n    int r = upper_bound(all(sums[cnt]), R - sum) - sums[cnt].begin();\n    ans += r - l;\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint N,K;\n\tlong long L,R;\n\tscanf(\"%d%d%lld%lld\",&N,&K,&L,&R);\n\tint n=N/2;\n\tvector<long long>v(N);\n\tfor(int i=0;i<N;i++)scanf(\"%lld\",&v[i]);\n\tmultiset<pair<int,long long>>se1;\n\tvector<pair<int,long long>>se2;\n\tfor(int i=0;i<1<<n;i++){\n\t\tint m=0;\n\t\tlong long V=0;\n\t\tfor(int j=0;j<n;j++)if(i&(1<<j))m++,V+=v[j];\n\t\tse1.emplace(m,V);\n\t}\n\tfor(int i=0;i<1<<(N-n);i++){\n\t\tint m=0;\n\t\tlong long V=0;\n\t\tfor(int j=0;j<(N-n);j++)if(i&(1<<j))m++,V+=v[j+n];\n\t\tse2.emplace_back(m,V);\n\t}\n\tsort(se2.begin(),se2.end());\n\tlong long r=0;\n\tfor(auto &e1:se1){\n\t\t//?????°=K-e1.first\n\t\t//????¨?=L-e1.second??\\???R-e1.second??\\???\n\t\tauto it1=lower_bound(se2.begin(),se2.end(),make_pair(K-e1.first,L-e1.second));\n\t\tauto it2=upper_bound(se2.begin(),se2.end(),make_pair(K-e1.first,R-e1.second));\n\t\tr+=distance(it1,it2);\n\t}\n\tprintf(\"%lld\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i=0; i<(n); i++)\n\nUL N,K;\nLL L,R;\nLL A[40]={};\nLL X[21][1048576]; UL Xp[21]={};\nLL Z[21][1048576]; UL Zp[21]={};\n\nint main() {\n scanf(\"%u%u\",&N,&K);\n scanf(\"%lld%lld\",&L,&R);\n rep(i,N) scanf(\"%lld\",&A[i]);\n X[0][0]=Z[0][0]=0;\n Xp[0]=Zp[0]=1;\n rep(n,20){\n  if(!A[n]) continue;\n  for(UL k=n; k!=~0u; k--){\n   rep(i,Xp[k]){\n    X[k+1][Xp[k+1]]=X[k][i]+A[n];\n    Xp[k+1]++;\n   }\n  }\n }\n rep(n,20){\n  if(!A[n+20]) continue;\n  for(UL k=n; k!=~0u; k--){\n   rep(i,Zp[k]){\n    Z[k+1][Zp[k+1]]=Z[k][i]+A[n+20];\n    Zp[k+1]++;\n   }\n  }\n }\n rep(i,20) sort(X[i],X[i]+Xp[i]);\n rep(i,20) sort(Z[i],Z[i]+Zp[i]);\n \n ULL ans=0;\n \n rep(x,21) rep(z,21) {\n  if(x+z!=K) continue;\n  if(Xp[x]==0) continue;\n  if(Zp[z]==0) continue;\n  ULL tmp=0;\n  UL Rq=Zp[z];\n  UL Lq=Zp[z];\n  rep(p,Xp[x]) {\n   while(Lq) if(X[x][p]+Z[z][Lq-1]>=L) Lq--; else break;\n   while(Rq) if(X[x][p]+Z[z][Rq-1]>R) Rq--; else break;\n   ans+=Rq-Lq;\n  }\n }\n printf(\"%llu\\n\",ans);\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Node {\n    ll sum;\n    int bits;\n    \n    Node(ll sum = 0, int bits = 0) : sum(sum), bits(bits) {\n    }\n    \n    bool operator<(const Node& other) const {\n        return bits < other.bits || (bits == other.bits && sum < other.sum);\n    }   \n};\n\nvoid process(vector<ll>& a, int start, int end, vector<Node>& result) {\n    int size = end - start + 1;\n    int bound = (1 << size) - 1;\n    for (int i = 0; i <= bound; i++) {\n        ll sum = 0;\n        int bits = 0;\n        for (int k = 0; k < size; k++) {\n            if ((i & (1 << k)) > 0) {\n                sum += a[start + k];\n                bits++;\n            }\n        } \n        result.push_back(Node(sum, bits));\n    }\n}\n\nint main() {\n    int n, k, l, r;\n    cin >> n >> k >> l >> r;\n    vector<ll> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    \n    vector<Node> result1, result2;\n    int m = (n - 1)/2;\n    process(a, 0, m, result1);\n    process(a, m + 1, n - 1, result2);\n    \n    sort(result2.begin(), result2.end());\n    \n//    for (Node& node : result1) {\n//        cout << node.bits << \" \" << node.sum << endl;\n//    }\n//    \n//    cout << \"second\" << endl;\n//    for (Node& node : result2) {\n//        cout << node.bits << \" \" << node.sum << endl;\n//    }\n    \n    ll count = 0;\n    for (Node& node : result1) {\n        if (node.bits <= k) {\n            count += upper_bound(result2.begin(), result2.end(), Node(r - node.sum, k - node.bits)) -\n                    lower_bound(result2.begin(), result2.end(), Node(l - node.sum, k - node.bits));\n        }\n    }\n    cout << count << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = (A); I < (B); ++I)\n#define FORR(I,A,B) for(ll I = (B-1); I >= (A); --I)\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) //ai>=v  x is sorted\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) //ai>v  x is sorted\n#define NUM(x,v) (POSU(x,v)-POSL(x,v))  //x is sorted\nconst ll INF=1e18+7;\nconst ll MOD=1e9+7;\n\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tll N,K,L,R;\n\tcin >> N >> K >> L >> R;\n\tll Na = N/2;\n\tll Nb = N - Na;\n\tvector<ll> a(Na),b(Nb);\n\tFOR(i,0,Na)cin >> a[i];\n\tFOR(i,0,Nb)cin >> b[i];\n\tvector<ll> A[Na+1],B[Nb+1];\n\tA[0].push_back(0);\n\tB[0].push_back(0);\n\n\tFOR(i,0,Na){\n\t\tFORR(j,1,i+2){\n\t\t\tfor(ll x:A[j-1])A[j].push_back(a[i]+x);\n\t\t}\n\t}\n\tFOR(i,0,Nb){\n\t\tFORR(j,1,i+2){\n\t\t\tfor(ll x:B[j-1])B[j].push_back(b[i]+x);\n\t\t}\n\t}\n\tFOR(i,1,Na+1)sort(A[i].begin(),A[i].end());\n\tFOR(i,1,Nb+1)sort(B[i].begin(),B[i].end());\n\tll ans = 0;\n\tFOR(i,0,Na+1){\n\t\tfor(ll x:A[i]){\n\t\t\tll num;\n\t\t\tif(K>=i&&(K-i<=Nb))num = POSU(B[K-i],R-x)-POSL(B[K-i],L-x);\n\t\t\telse num = 0;\n\t\t\tans += num;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint n,k;\nll l,r;\nll a[44];\nvector<ll> b[41];// 选i个硬币有哪些不同结果 \nvector<ll> c[41];\nvoid dfs1(int i,ll v,int cnt){\n\tif(i==n/2){b[cnt].push_back(v);return;}\n\tdfs1(i+1,v+a[i],cnt+1);\n\tdfs1(i+1,v,cnt);\n}\nvoid dfs2(int i,ll v,int cnt){\n\tif(i==n){c[cnt].push_back(v);return;}\n\tdfs2(i+1,v+a[i],cnt+1);\n\tdfs2(i+1,v,cnt);\n}\nvoid solve(){\n\tif(n==1){cout<<(k==1&&a[0]>=l&&a[0]<=r)<<\"\\n\";return;}\n\tdfs1(0,0,0);\n\tdfs2(n/2,0,0);\n\tll res=0;\n\tfor(int i=0;i<=40;i++)sort(b[i].begin(),b[i].end()),sort(c[i].begin(),c[i].end());\n\tfor(int i=0;i<=k;i++){\n\t\tint j=k-i;\n\t\tfor(int t=0;t<b[i].size();t++){\n\t\t\tll v=b[i][t];\n\t\t\tres+=upper_bound(c[j].begin(),c[j].end(),r-v)-lower_bound(c[j].begin(),c[j].end(),l-v);\n\t\t}\n\t}cout<<res<<\"\\n\";\n}\nint main(){\n\tcin>>n>>k>>l>>r;\n\tfor(int i=0;i<n;i++)cin>>a[i];\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct state { int cnt; long long sum; };\nint N, K; long long L, R, a[50];\nint main() {\n\tcin >> N >> K >> L >> R;\n\tfor (int i = 0; i < N; i++) cin >> a[i];\n\tint sep1 = N / 2, sep2 = N - sep1;\n\tvector<state> sl(1 << sep1), sr(1 << sep2);\n\tfor (int i = 0; i < sep1; i++) {\n\t\tint bl = (1 << i), br = (bl << 1);\n\t\tfor (int j = bl; j < br; j++) {\n\t\t\tstate v = sl[j - bl];\n\t\t\tsl[j] = state{ v.cnt + 1, v.sum + a[i] };\n\t\t}\n\t}\n\tfor (int i = 0; i < sep2; i++) {\n\t\tint bl = (1 << i), br = (bl << 1);\n\t\tfor (int j = bl; j < br; j++) {\n\t\t\tstate v = sr[j - bl];\n\t\t\tsr[j] = state{ v.cnt + 1, v.sum + a[i + sep1] };\n\t\t}\n\t}\n\tvector<vector<long long> > tl(sep1 + 1), tr(sep2 + 1);\n\tfor (int i = 0; i < 1 << sep1; i++) tl[sl[i].cnt].push_back(sl[i].sum);\n\tfor (int i = 0; i < 1 << sep2; i++) tr[sr[i].cnt].push_back(sr[i].sum);\n\tfor (int i = 0; i <= sep1; i++) sort(tl[i].begin(), tl[i].end());\n\tfor (int i = 0; i <= sep2; i++) sort(tr[i].begin(), tr[i].end());\n\tlong long ret = 0;\n\tfor (int i = 0; i <= sep1; i++) {\n\t\tfor (int j = 0; j <= sep2; j++) {\n\t\t\tif (i + j != K) continue;\n\t\t\tfor (long long x : tl[i]) {\n\t\t\t\tint pl = lower_bound(tr[j].begin(), tr[j].end(), L - x) - tr[j].begin();\n\t\t\t\tint pr = lower_bound(tr[j].begin(), tr[j].end(), R - x + 1) - tr[j].begin();\n\t\t\t\tret += pr - pl;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n#define REP(i, n) for(ll i = 0; i < n; i++)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOR(i, m, n) for(ll i = m; i < n; i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define INF 1e9\n#define LINF 1e18\n\nvector<ll> a;\nvector<pair<int,ll>> X,Y;\nvoid make_array(int L, int R, vector<pair<int,ll>> &t){\n    int w = R-L;\n    REP(i,(1<<w)){\n        ll sum=0;\n        int cnt=0;\n        REP(j,w){\n            if(i&(1<<j)){\n                sum += a[L+j];\n                cnt++;\n            }\n        }\n        t.push_back({cnt,sum});\n    }\n}\n\nint main() {\n    ll n,k,l,r; cin >> n >> k >> l >> r;\n    a.assign(n,0); REP(i,n) cin >> a[i];\n    \n    make_array(0,n/2,X);\n    make_array(n/2,n,Y);\n    \n    sort(ALL(X));\n    sort(ALL(Y));\n        \n    ll ans = 0;\n\n    REP(i,X.size()){\n        int itr_R = upper_bound(ALL(Y), pair<int,ll>(k-X[i].first, r-X[i].second)) - Y.begin();\n        int itr_L = lower_bound(ALL(Y), pair<int,ll>(k-X[i].first, l-X[i].second)) - Y.begin();\n        ans += itr_R - itr_L;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define mkp(x,y) (make_pair(x,y))\ntypedef long long ll;\ntypedef pair<ll,ll> pil;\n\nint main()\n{\n    ll N,K,L,R;\n\n    while(cin>>N>>K>>L>>R)\n    {\n        vector<ll> a(N);\n        for(int i=0;i<N;i++)\n        {\n            cin>>a[i];\n        }\n        vector<pil> ps;\n        for(int i=0;i<(1<<N/2);i++)\n        {\n            int tmp=i;\n            int now=0;\n            int cnt=0;\n            ll res=0;\n            while(tmp)\n            {\n                if(tmp&1)\n                {\n                    cnt++;\n                    res+=a[now];\n                }\n                tmp>>=1;\n                now++;\n            }\n            ps.emplace_back(cnt,res);\n        }\n        sort(ps.begin(),ps.end());\n        ll ans=0;\n        for(int i=0;i<(1<<(N-N/2));i++)\n        {\n            int tmp=i;\n            int now=0;\n            int cnt=0;\n            ll res=0;\n            while(tmp)\n            {\n                if(tmp&1)\n                {\n                    cnt++;\n                    res+=a[now+N/2];\n                }\n                tmp>>=1;\n                now++;\n            }\n            ans+=upper_bound(ps.begin(),ps.end(),mkp(K-cnt,R-res))-lower_bound(ps.begin(),ps.end(),mkp(K-cnt,L-res));\n        }\n        cout<<ans<<endl;\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll N, K, L, R;\nll a[40];\n\ndecltype(auto) enumerate(int sidx, int size) {\n  vector<pair<ll, ll>> ret;\n  for(int i=0; i<1<<size; i++) {\n    int cnt = 0; ll sum = 0;\n    for(int j=0; j<size; j++)\n      if(i >> j & 1) cnt++, sum += a[sidx + j];\n    ret.emplace_back(cnt, sum);\n  }\n  return ret;\n}\n\nll solve() {\n  decltype(auto) v0 = enumerate(0, N / 2);\n  decltype(auto) v1 = enumerate(N / 2, (N + 1) / 2);\n  sort(v0.begin(), v0.end());\n  ll ret = 0;\n  for(int i=0; i<(int)v1.size(); i++)\n    ret +=  upper_bound(v0.begin(), v0.end(), make_pair(K - v1[i].first, R - v1[i].second))\n          - lower_bound(v0.begin(), v0.end(), make_pair(K - v1[i].first, L - v1[i].second));\n  return ret;\n}\n\nint main() {\n  cin >> N >> K >> L >> R;\n  for(int i=0; i<N; i++) cin >> a[i];\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\nint in(){int a;scanf(\"%d\",&a);return a;}\nll lin(){ll a;scanf(\"%lld\",&a);return a;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nvector<ll> sum[40 / 2 + 1];\n\nint main()\n{\n    ll N = in(), K = in(), L = in(), R = in();\n\n    vector<ll> A(N);\n\n    rep(i, N) {\n        A[i] = lin();\n    }\n\n    int sz1 = N / 2;\n    rep(bit, 1 << sz1) {\n        int cnt = 0;\n        ll s = 0;\n\n        rep(i, sz1) {\n            if (bit >> i & 1) {\n                cnt++;\n                s += A[i];\n            }\n        }\n\n        sum[cnt].PB(s);\n    }\n\n    rep(i, sz1 + 1) sort(all(sum[i]));\n\n    ll ans = 0;\n\n    int sz2 = N - N / 2;\n    rep(bit, 1 << sz2) {\n        int cnt = 0;\n        ll s = 0;\n\n        rep(i, sz2) {\n            if (bit >> i & 1) {\n                cnt++;\n                s += A[i + sz1];\n            }\n        }\n\n        if (K - cnt < 0 || K - cnt > sz1) continue;\n\n        int pos1 = upper_bound(all(sum[K - cnt]), R - s) - begin(sum[K - cnt]) - 1;\n        int pos2 = lower_bound(all(sum[K - cnt]), L - s) - begin(sum[K - cnt]);\n\n        if (sum[K - cnt][pos1] < sum[K - cnt][pos2]) continue;\n\n        ans += max(pos1 - pos2 + 1, 0);\n    }\n\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint N,K;\nll a[50];\nll L,R;\n\nvector<pair<int,ll> >x,y;\n\nvoid func(int l,int r ,vector<pair<int,ll> >&t){\n    int w=r-l;\n    for(int i=0;i<(1<<w);i++){\n        ll sum=0;\n        int cnt=0;\n        for(int j=0;j<w;j++){\n            if((i>>j)&1){\n                sum+=a[l+j];\n                cnt++;\n            }\n        }\n        t.push_back(make_pair(cnt,sum));\n    }\n}\n\nint main(){\n    cin>>N>>K>>L>>R;\n    for(int i=0;i<N;i++)\n        cin>>a[i];\n    func(0,N/2,x);\n    func(N/2,N,y);\n    sort(y.begin(),y.end());\n    ll ans=0;\n    for(int i=0;i<x.size();i++){\n        vector<pair<int,ll> >::iterator it1,it2;\n        it1=lower_bound(y.begin(),y.end(),pair<int,ll>(K-x[i].first,L-x[i].second));\n        it2=upper_bound(y.begin(),y.end(),pair<int,ll>(K-x[i].first,R-x[i].second));\n        ans+=(it2-it1);\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> lpair;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e18;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\n#define rREP(i,m,n) for(ll i = (m); i >= (n); i--)\n#define ALL(c) (c).begin(), (c).end()\n#define print(x) cout << (x) << endl;\n#define printa(x,n) for(ll i = 0; i < n; i++){ cout << (x[i]) << \" \";} cout<<endl;\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,k;\n    cin >> n >> k;\n    ll l, r, ary[n];\n    cin >> l >> r;\n    rep(i,n) cin >> ary[i];\n\n    int m = n/2;\n    vector<ll> zenhan[m+1];\n    vector<ll> kohan[n-m+1];\n    rep(bit, (1<<m))\n    {\n        ll tmpn=0;\n        int cnt = 0;\n        rep(i,m)\n        {\n            if((bit>>i) & 1)\n            {\n                // cout << \"here\" << endl;\n                tmpn += ary[i];\n                cnt++;\n                // cout << tmpn << \" \" << cnt << endl;\n            }\n        }\n        zenhan[cnt].push_back(tmpn);\n    }\n    // for (auto itr=zenhan[1].begin();itr!=zenhan[1].end();++itr)\n    // {\n    //     cout << *itr << endl;\n    // }\n\n    rep(bit, (1<<(n-m)))\n    {\n        ll tmpn = 0;\n        int cnt = 0;\n        rep(i,n-m)\n        {\n            if ((bit>>i)&1)\n            {\n                cnt++;\n                tmpn += ary[m+i];\n            }\n        }\n        kohan[cnt].push_back(tmpn);\n    }\n\n\n    ll ans = 0;\n    rep(i,m+1)\n    {\n        if (0<=k-i && k-i<=n-m)\n        {\n            sort(zenhan[i].begin(), zenhan[i].end());\n            sort(kohan[k-i].begin(), kohan[k-i].end());\n            for(vector<ll>::iterator itr=zenhan[i].begin(); itr!=zenhan[i].end();itr++)\n            {\n                ll d = upper_bound(kohan[k-i].begin(), kohan[k-i].end(), r-(*itr)) - lower_bound(kohan[k-i].begin(), kohan[k-i].end(), l-(*itr));\n                ans += d;\n            }\n            // cout << i << \" \" << *itr << \" \" << d << endl;\n            // cout <<  upper_bound(kohan[k-i].begin(), kohan[k-i].end(), r-(*itr)) - kohan[k-i].begin() << endl;\n            // cout <<  lower_bound(kohan[k-i].begin(), kohan[k-i].end(), l-(*itr)) - kohan[k-i].begin() << endl;\n        }\n    }\n    cout  << ans << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<int,ll>pl;\n\nconst int MAX_N = 40;\n\nll a[MAX_N];\nvector<pl> x,y;\n\nvoid solve(int s,int t,vector<pl> &x)\n{\n\tint z = t-s;\n\trep(i,1<<z){\n\t\tpl p = pl(0,0);\n\t\trep(j,z){\n\t\t\tif(i&(1<<j)){\n\t\t\t\tp.first++;\n\t\t\t\tp.second += a[s+j];\n\t\t\t}\n\t\t}\n\t\tx.push_back(p);\n\t}\n}\n\nint main()\n{\n\tint n,k;\n\tll l,r;\n\tcin >> n >> k >> l >> r;\n\trep(i,n){\n\t\tscanf(\"%lld\",&a[i]);\n\t}\n\tsolve(0,n/2,x);\n\tsolve(n/2,n,y);\n\tsort(y.begin(),y.end());\n\tll ans = 0;\n\trep(i,x.size()){\n\t\tans += upper_bound(y.begin(),y.end(),pl(k-x[i].first,r-x[i].second))-lower_bound(y.begin(),y.end(),pl(k-x[i].first,l-x[i].second));\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <set>\nusing namespace std;\n\nint main(){\n\tint N,K;\n\tlong long L,R;\n\tscanf(\"%d%d%lld%lld\",&N,&K,&L,&R);\n\tint n=N/2;\n\tvector<long long>v(N);\n\tfor(int i=0;i<N;i++)scanf(\"%lld\",&v[i]);\n\tmultiset<pair<int,long long>>se1,se2;\n\tfor(int i=0;i<1<<n;i++){\n\t\tint m=0;\n\t\tlong long V=0;\n\t\tfor(int j=0;j<n;j++)if(i&(1<<j))m++,V+=v[j];\n\t\tse1.emplace(m,V);\n\t}\n\tfor(int i=0;i<1<<(N-n);i++){\n\t\tint m=0;\n\t\tlong long V=0;\n\t\tfor(int j=0;j<(N-n);j++)if(i&(1<<j))m++,V+=v[j+n];\n\t\tse2.emplace(m,V);\n\t}\n\tlong long r=0;\n\tfor(auto &e1:se1){\n\t\t//?????°=K-e1.first\n\t\t//????¨?=L-e1.second??\\???R-e1.second??\\???\n\t\tauto it1=se2.lower_bound({K-e1.first,L-e1.second});\n\t\tauto it2=se2.upper_bound({K-e1.first,R-e1.second});\n\t\tr+=distance(it1,it2);\n\t}\n\tprintf(\"%lld\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "//tempaa\n//#pragma GCC optimize (\"-O3\")\n#ifdef _DEBUG\n#include<cassert>\n#include \"bits_stdc++.h\"\n#else\n#include <bits/stdc++.h>\n#endif\n\n#define r_ return\n#define v_ vector\n#define t_T template<class T>\n\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n//衝突対策\n#define ws ___ws\n#define over4(o1, o2, o3, o4, name, ...) name\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define vec v_\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\nusing vi = v_<ll>;\nusing vb = v_<bool>;\nusing vs = v_<string>;\nusing vd = v_<double>;\nusing vc = v_<char>;\nusing vp = v_<P>;\n\n//#define V v_\n#define vvt0(t) v_<v_<t>>\n#define vvt1(t, a) v_<v_<t>>a\n#define vvt2(t, a, b) v_<v_<t>>a(b)\n#define vvt3(t, a, b, c) v_<v_<t>> a(b,v_<t>(c))\n#define vvt4(t, a, b, c, d) v_<v_<t>> a(b,v_<t>(c,d))\n\n#define vvi(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n\n\n#define v3i(a, b, c, d) v_<v_<vi>> a(b, v_<vi>(c, vi(d)))\n#define v3d(a, b, c, d) v_<v_<vd>> a(b, v_<vd>(c, vd(d)))\n#define v3m(a, b, c, d) v_<v_<vm>> a(b, v_<vm>(c, vm(d)))\n\n\n#define PQ priority_queue<ll, v_<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<int, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, _4, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define repadd(i, m, n, ad) for(int i = m,_lim=n; i < _lim ; i+= ad)\n#define rep(...) _overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rerdec(i, m, n, dec) for(int i = m,_lim=n; i >= _lim ; i-=dec)\n#define rer(...) _overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\n\nt_T T MAX() { r_ numeric_limits<T>::max(); }\nt_T T MIN() { r_ numeric_limits<T>::min(); }\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nt_T T INF() { r_ MAX<T>() / 2; }\ntemplate<> signed INF() { r_ inf; }\ntemplate<> ll INF() { r_ linf; }\ntemplate<> double INF() { r_ (double) linf * linf; }\n\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define sz(a) ((int)(a).size())\n#define rs resize\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n/*@formatter:off*/\ninline void sort(string &a) { sort(all(a)); }\nt_T inline void sort(v_<T> &a) { sort(all(a)); };\nt_T inline void rsort(v_<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class U> inline void sortp(v_<U> &a, v_<U> &b) {    vp c;    int n = sz(a);    assert(n == sz(b));    rep(i, n)c.eb(a[i], b[i]);    sort(c);    rep(i, n) {        a[i] = c[i].first;        b[i] = c[i].second;;    }};//F = T<T>\n//例えばr_ p.fi + p.se;\ntemplate<class U> inline void rsortp(v_<U> &a, v_<U> &b) {    vp c;    int n = sz(a);    assert(n == sz(b));    rep(i, n)c.eb(a[i], b[i]);    rsort(c);    rep(i, n) {        a[i] = c[i].first;        b[i] = c[i].second;    }};\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T vall) {xx = vall;}\ntemplate<typename V, typename T>\nvoid fill(v_<V> &vecc, const T vall) {for (auto &&vx: vecc) fill(vx, vall);}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T _in() {T x;cin >> x;r_ (x);}\n#define _overloadin(_1, _2, _3, _4, name, ...) name\n#define in0() _in()\n#define in1(a) cin>>a\n#define in2(a, b) cin>>a>>b\n#define in3(a, b, c) cin>>a>>b>>c\n#define in4(a, b, c, d) cin>>a>>b>>c>>d\n#define in(...) _overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)\n\n#define _overloaddin(_1, _2, _3, _4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>>b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) _overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define _overloaddind(_1, _2, _3, _4, name, ...) name\n#define din1d(a) int a;cin>>a;a--\n#define din2d(a, b) int a,b;cin>>a>>b;a--,b--\n#define din3d(a, b, c) int a,b,c;cin>>a>>b>>c;a--,b--,c--\n#define din4d(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d;;a--,b--,c--,d--\n#define dind(...) _overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\ntemplate<typename W, typename H> void resize(W &vec_, const H head) { vec_.resize(head); }\ntemplate<typename W, typename H, typename ... T> void resize(W &vec_, const H &head, const T ... tail) {vec_.resize(head);for (auto &v: vec_)resize(v, tail...);}\n\n\nstring sin() { r_ _in<string>(); }\nll lin() { r_ _in<ll>(); }\nt_T void na(v_<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i];}\n#define dna(a, n) vi a; na(a, n);/*nを複数使うと n==in()の時バグる事に注意*/\n#define dnad(a, n) vi a; nad(a, n);\nt_T void nad(v_<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T, class U> void na2(v_<T> &a, v_<U> &b, ll n) {a.resize(n);b.resize(n);rep(i, n)cin >> a[i] >> b[i];}\n#define dna2(a, b, n) vi a,b; na2(a,b,n);\ntemplate<class T, class U, class W> void na3(v_<T> &a, v_<U> &b, v_<W> &c, ll n) {a.resize(n);b.resize(n);c.resize(n);rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n#define dnt(S, h, w) vvi(S,h,w);nt(S,h,w);\n#define dntc(S, h, w) vvc(S,h,w);nt(S,h,w);\n#define dnts(S, h, w) vvs(S,h,w);nt(S,h,w);\n\n//デバッグ\n#define sp << \" \" <<\nt_T string out_m2(v_<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), 20ll);    if (sz(a) == 0)r_ ss.str();    rep(i, W) {        ss << a[i];        if (typeid(a[i]) == typeid(P)) { ss << endl; } else { ss << \" \"; }    }    r_ ss.str();}\nt_T string out_m2(v_<v_<T> > &a, vi H, vi W, int key = -1) {    stringstream ss;    ss << endl;    vi lens(sz(W));    fora(h, H) {        rep(wi, sz(W)) {            int v = a[h][W[wi]];            str s = tos(v);            if (abs(v) == inf || abs(v) == INF<T>())s = \"e\";            lens[wi] = max(lens[wi], sz(s) + 1);            lens[wi] = max(lens[wi], sz(tos(W[wi])) + 1);        }    }    if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";    int wi = 0;    fora(w, W) {        ss << std::right << std::setw(lens[wi]) << w;        wi++;    }    ss << \"\" << endl;    rep(i, sz(W))rep(_, lens[i]) ss << \"_\";    rep(i, 3)ss << \"_\";    ss << \"\" << endl;    fora(h, H) {        ss << std::right << std::setw(2) << h << \"|\";        int wi = 0;        fora(w, W) {            str s = tos(a[h][w]);            if (abs(a[h][w]) == inf || abs(a[h][w]) == INF<T>())s = \"e\";            ss << std::right << std::setw(lens[wi]) << s;            wi++;        }        ss << \"\" << endl;    }    r_ ss.str();}\nt_T string out_m2(v_<v_<T> > &a, ll H = inf, ll W = inf, int key = -1) {    H = (H != inf) ? H : min({H, sz(a), 12ll});    W = min({W, sz(a[0]), 12ll});    vi hs, ws;    rep(h, H) { hs.push_back(h); }    rep(w, W) { ws.push_back(w); }    r_ out_m2(a, hs, ws, key);}\nt_T string out_m2(v_<v_<v_<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {    stringstream ss;    if (H == inf)H = 12;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m2(a[i], W, U, i);    }    r_ ss.str();}\nstring out_m2(int a) {    stringstream ss;    ss << a;    r_ ss.str();}\nt_T string out_m2(T &a) {    stringstream ss;    ss << a;    r_ ss.str();}\n\n#define debugName(VariableName) # VariableName\n\n#define _deb1(x) cerr <<  debugName(x)<<\" = \"<<out_m2(x) << endl\n#define _deb2(x, y) cerr <<  debugName(x)<<\" = \"<<out_m2(x)<<\", \"<< debugName(y)<<\" = \"<<out_m2(y)<< endl\n#define _deb3(x, y, z) cerr <<  debugName(x)<<\" = \"<<out_m2(x)  << \", \" <<  debugName(y)<<\" = \"<<out_m2(y) <<\", \" debugName(z)<<\" = \"<<out_m2(z) <<endl\n#define _deb4(x, y, z, a) cerr <<  debugName(x)<<\" = \"<<out_m2(x) <<\", \" <<   debugName(y)<<\" = \"<<out_m2(y) <<\", \" <<  debugName(z)<<\" = \"<<out_m2(z) <<\", \" <<  debugName(a)<<\" = \"<<out_m2(a)<<endl\n#define _deb5(x, y, z, a, b) cerr <<  debugName(x)<<\" = \"<<out_m2(x) <<\", \" <<   debugName(y)<<\" = \"<<out_m2(y) <<\", \" <<  debugName(z)<<\" = \"<<out_m2(z) <<\", \" <<  debugName(a)<<\" = \"<<out_m2(a)<<\", \" <<  debugName(b)<<\" = \"<<out_m2(b)<<endl\n\n\n#define _overloadebug(_1, _2, _3, _4, _5, name, ...) name\n#define debug(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#ifdef _DEBUG\n#define deb(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#else\n#define deb(...) ;\n#endif\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n\nll gcd(ll a, ll b) { r_ b ? gcd(b, a % b) : a; }\nll gcd(vi b) {ll res = b[0];for (auto &&v :b)res = gcd(v, res);r_ res;}\nll lcm(ll a, ll b) { r_ a / gcd(a, b) * b; }\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    r_ res;}\nt_T v_<T> rev(v_<T> &a) {    auto b = a;    reverse(all(b));    r_ b;}\nstr rev(str &a) {str s = a;reverse(all(s));r_ s;}\nll ceil(ll a, ll b) {if (b == 0) {cerr<<\"ceil\"<<endl;exit(1);r_ -1;} else r_ (a + b - 1) / b;}\nll sqrt(ll a) {    if (a < 0) {        cerr<<\"sqrt\"<<endl;        exit(1);    }    ll res = (ll) std::sqrt(a);    while (res * res < a)res++;    r_ res;}\ndouble log(double e, double x) { r_ log(x) / log(e); }\nll sig(ll t) { r_ (1 + t) * t / 2; }\nll sig(ll s, ll t) { r_ (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {    vi res;    double lim = std::sqrt(v);    rep(i, 1, lim+1){        if (v % i == 0) {            res.pb(i);            if (i != v / i)res.pb(v / i);        }    }    r_ res;}\nvb isPrime;\nvi primes;\n\nvoid setPrime() {    int len = 4010101;    isPrime.resize(4010101);    fill(isPrime, true);    isPrime[0] = isPrime[1] = false;    for (int i = 2; i <= sqrt(len) + 5; ++i) {        if (!isPrime[i])continue;        for (int j = 2; i * j < len; ++j) {            isPrime[i * j] = false;        }    }    rep(i, len)if (isPrime[i])primes.pb(i);}\n\nvi factorization(int v) {    int tv = v;    vi res;    if (isPrime.size() == 0)setPrime();    for (auto &&p :primes) {        if (v % p == 0)res.push_back(p);        while (v % p == 0) {            v /= p;        }        if (v == 1 || p * p > tv)break;    }    if (v > 1)res.pb(v);    r_ res;}\ninline bool inside(int h, int w, int H, int W) { r_ h >= 0 && w >= 0 && h < H && w < W; }\ninline bool inside(int v, int l, int r) { r_ l <= v && v < r; }\n\n\nt_T v_<T> ruiv(v_<T> &a) {    v_<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    r_ ret;}\n//imoは0-indexed\n//ruiは1-indexed\nt_T v_<T> imo(v_<T> &v) {    v_<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    r_ ret;}\n\n#define ins inside\nll u0(ll a) { r_ a < 0 ? 0 : a; }\nt_T v_<T> u(const v_<T> &a) {\n    v_<T> ret = a;fora(v, ret)v = u0(v);r_ ret;}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\n\nvoid yn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n}\nvoid Yn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\nvoid YN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\nvoid fyn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    exit(0);\n}\nvoid fYn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    exit(0);\n}\nvoid fYN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    exit(0);\n}\nvoid Possible(bool a) {\n    if (a)cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    exit(0);\n}\nvoid POSSIBLE(bool a) {\n    if (a)cout << \"POSSIBLE\" << endl;\n    else cout << \"IMPOSSIBLE\" << endl;\n    exit(0);\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    r_ a;\n}\ntemplate<class T, class U> v_<T> &operator+=(v_<T> &a, U v) {\n    a.pb(v);\n    r_ a;\n}\nt_T T sum(v_<T> &v, int s = 0, int t = inf) {    T ret = 0;    rep(i, s, min(sz(v), t))ret += v[i];    r_ ret;}\nvoid mod(int &a, int m) { a = (a % m + m) % m; }\ntemplate<class F> inline int mgr(int ok, int ng, F f) {\n#define _mgrbody int mid = (ok + ng) / 2; if (f(mid))ok = mid; else ng = mid;\n    if (ok < ng)while (ng - ok > 1) { _mgrbody } else while (ok - ng > 1) { _mgrbody }\n    r_ ok;\n}\n\ntemplate<class F> inline int mgr(int ok, int ng, int second, F f) {\n#define _mgrbody2 int mid = (ok + ng) / 2; if (f(mid, second))ok = mid; else ng = mid;\n    if (ok < ng) while (ng - ok > 1) { _mgrbody2 } else while (ok - ng > 1) { _mgrbody2 }\n    r_ ok;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, v_<T> &m) {    for (auto &&v:m) os << v << \" \";    r_ os;}\nconstexpr bool bget(ll m, int keta) { r_ (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {m /= (ll) pow(sinsuu, keta);r_ m % sinsuu;}\nll bit(int n) { r_ (1LL << (n)); }\nll bit(int n, int sinsuu) { r_ (ll) pow(sinsuu, n); }\nint mask(int n) { r_ (1ll << n) - 1; }\n#define bcou __builtin_popcountll\ntemplate<class T, class U> inline bool chma(T &a, const U &b) {if (a < b) {a = b;r_ true;}r_ false;}\ntemplate<class U> inline bool chma(const U &b) { r_ chma(ma, b); }\ntemplate<class T, class U> inline bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        r_ true;    }    r_ false;}\ntemplate<class U> inline bool chmi(const U &b) { r_ chmi(mi, b); }\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\nint max(vi &a) {    int res = a[0];    fora(v, a) {        res = max(res, v);    }    r_ res;}\nint min(vi &a) {    int res = a[0];    fora(v, a) {        res = min(res, v);    }    r_ res;}\ntemplate<typename T> class fixed_point        : T {public:    explicit constexpr fixed_point(T &&t) noexcept: T(std::forward<T>(t)) {}    template<typename... Args> constexpr decltype(auto) operator()(Args &&... args) const { r_ T::operator()(*this, std::forward<Args>(args)...); }};template<typename T> static inline constexpr decltype(auto) fix(T &&t) noexcept { r_ fixed_point<T>{std::forward<T>(t)}; }\nconstexpr ll h4[] = {1, -1, 0, 0};\nconstexpr ll w4[] = {0, 0, -1, 1};\nconstexpr ll h8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll w8[] = {1, 0, -1, 0, 1, -1, 1, -1};\nint mei_inc(int h, int w, int H, int W, int i) {while (++i < 4) { if (inside(h + h4[i], w + w4[i], H, W))r_ i; }r_ i;}\n#define mei(nh, nw, h, w) for (int i = mei_inc(h, w, H, W, -1), nh = i<4? h + h4[i] : 0, nw = i<4? w + w4[i] : 0; i < 4; i=mei_inc(h,w,H,W,i), nh = h+h4[i], nw = w+w4[i])\nint mei_inc8(int h, int w, int H, int W, int i) {    while (++i < 8) {        if (inside(h + h8[i], w + w8[i], H, W))r_ i;    }    r_ i;}\n#define mei8(nh, nw, h, w) for (int i = mei_inc8(h, w, H, W, -1), nh = i<8? h + h8[i] : 0, nw = i<8? w + w8[i] : 0; i < 8; i=mei_inc8(h,w,H,W,i), nh = h+h8[i], nw = w+w8[i])\nint mei_incv(int h, int w, int H, int W, int i, vp &p) {    while (++i < sz(p)) { if (inside(h + p[i].fi, w + p[i].se, H, W))r_ i; }    r_ i;}\n#define meiv(nh, nw, h, w, p) for (int i = mei_incv(h, w, H, W, -1, p), nh = i<sz(p)? h + p[i].fi : 0, nw = i<sz(p)? w + p[i].se : 0; i < sz(p); i=mei_incv(h,w,H,W,i,p), nh = h+p[i].fi, nw = w+p[i].se)\nvi compress(vi &A) {    vi B = A;    sort(B);    unique(B);    vi inds(sz(B));    rep(i, sz(A)) {        int ind = lower_bound(all(B), A[i]) - B.begin();        inds[ind] = A[i];        A[i] = ind;    }    return inds;}\nvi compress(vi &A, umapi& map){    vi i_v = compress(A);    rep(i, sz(i_v)){        map[i_v[i]] = i;    }    return i_v;}\n\nt_T void out2(T head) {    cout << head;}\ntemplate<class T, class... U> void out2(T head, U ... tail) {    cout << head << \" \";      out2(tail...);}\ntemplate<class T, class... U> void out(T head, U ... tail) {    cout << head << \" \";        out2(tail...);    cout << \"\" << endl;}\nt_T void out(T head) {    cout << head << endl; }\nt_T void out(const vector<T>& A) {    rep(i, sz(A)-1){        cout<<A[i]<<\" \";    }    cout<<A[sz(A)-1]<< endl;}\nvoid out() { cout << \"\" << endl; }\n\n\n/*@formatter:on*/\nint N, M, H, W;\nvi A, B, C;\n\n//44\nvoid solve() {\n    int K, L, R;\n    in(N, K, L, R);\n    int ln = N / 2, rn = N - ln;\n    na(A, ln);\n    na(B, rn);\n    auto set = [&](vi &A) {\n        vvi(cou, K + 1);\n        int N = sz(A);\n        rep(mas, bit(N)) {\n            if (bcou(mas) > K)con;\n            int su = 0;\n            rep(i, N) {\n                if (bget(mas, i)) {\n                    su += A[i];\n                    if (su > R) goto end;\n                }\n            }\n            cou[bcou(mas)] += su;\n            end:;\n        }\n        fora(c, cou) {\n            sort(c);\n        }\n        return cou;\n    };\n    auto acou = set(A);\n    auto bcou = set(B);\n    int cou = 0;\n    rep(ak, K + 1) {\n        int bk = K - ak;\n        fora(av, acou[ak]){\n            int bvl = L - av;\n            int bvr = R+1 - av;\n            int bil = lower_bound(all(bcou[bk]), bvl) - bcou[bk].begin();\n            int bir = lower_bound(all(bcou[bk]), bvr) - bcou[bk].begin();\n            cou += u0(bir - bil);\n        }\n    }\n    out(cou);\n}\n\n\nsigned main() {\n    solve();\n    r_ 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nll mod=1e9+7;\n\nint main() {\n  ll n,k,fl,fr;\n  cin >> n >> k >> fl >> fr;\n  vector<ll> a(n);\n  for(ll i=0;i<n;i++) {\n    cin >> a[i];\n  }\n  ll n1=n/2;\n  ll n2=n-n1;\n  vector<vector<ll>> a1(n1+1),a2(n2+1);\n  for(ll i=0;i<(1<<n1);i++) {\n    bitset<20> bit(i);\n    ll res=0;\n    for(ll j=0;j<n1;j++) {\n      if(bit.test(j)) {\n        res+=a[j];\n      }\n    }\n    a1[bit.count()].push_back(res);\n  }\n  for(ll i=0;i<(1<<n2);i++) {\n    bitset<20> bit(i);\n    ll res=0;\n    for(ll j=0;j<n2;j++) {\n      if(bit.test(j)) {\n        res+=a[n1+j];\n      }\n    }\n    a2[bit.count()].push_back(res);\n  }\n  for(ll i=0;i<=n1;i++) {\n    sort(a1[i].begin(),a1[i].end());\n  }\n  for(ll i=0;i<=n2;i++) {\n    sort(a2[i].begin(),a2[i].end());\n  }\n  ll ans=0;\n  for(ll i=0;i<=min(k,n1);i++) {\n    if(k-i>n2) continue;\n    for(ll j=0;j<a1[i].size();j++) {\n      ll l=-1,r=a2[k-i].size();\n      ll temp=(l+r)/2;\n      while(l+1<r) {\n        if(a1[i][j]+a2[k-i][temp]<fl) {\n          l=temp;\n        }\n        else {\n          r=temp;\n        }\n        temp=(l+r)/2;\n      }\n      ll res=r;\n      l=-1;\n      r=a2[k-i].size();\n      temp=(l+r)/2;\n      while(l+1<r) {\n        if(a1[i][j]+a2[k-i][temp]>fr) {\n          r=temp;\n        }\n        else {\n          l=temp;\n        }\n        temp=(l+r)/2;\n      }\n      res=l-res+1;\n      if(res>0) {\n        ans+=res;\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n    int n, k;\n    ll l, r;\n    cin >> n >> k >> l >> r;\n\n    ll a[n];\n    for(int i = 0; i < n; i++)  cin >> a[i];\n\n    int left = n/2;\n    int right = n - left;\n\n    vector<ll> va[left+1], vb[right+1];\n\n    for(int i = 0; i < 1<<left; i++){\n        ll sum = 0;\n        int popcnt = 0;\n        for(int j = 0; j < left; j++){\n            if(i>>j & 1)    sum += a[j], popcnt++;\n        }\n        va[popcnt].push_back(sum);\n    }\n\n    for(int i = 0; i < 1<<right; i++){\n        ll sum = 0;\n        int popcnt = 0;\n        for(int j = 0; j < right; j++){\n            if(i>>j & 1)    sum += a[left+j], popcnt++;\n        }\n        vb[popcnt].push_back(sum);\n    }\n\n    for(int i = 0; i <= left; i++)   sort(va[i].begin(), va[i].end());\n    for(int i = 0; i <= right; i++)  sort(vb[i].begin(), vb[i].end());\n\n    ll ans = 0;\n    for(int i = 0; i <= left; i++){\n        if(i + right < k)   continue;\n        if(i > k)   break;\n\n        for(int j = 0; j < va[i].size(); j++){\n            ll tmp = va[i][j];\n            ans += max(0ll, (ll)(upper_bound(vb[k-i].begin(), vb[k-i].end(), r-tmp) - \n                            lower_bound(vb[k-i].begin(), vb[k-i].end(), l-tmp)));\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (upper_bound(ALL(c),x)-lower_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *min_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\nsigned main()\n{\n   int N ,K, L, R; cin >> N >> K >> L >> R;\n   V<int> a(N); REP(i, N) cin >> a[i];\n\n   V<V<int>> b(K+1);\n   REP(s, 1<<N/2) {\n      int total = 0, num = 0;\n      REP(i, N/2) if (s >> i & 1) {\n         total += a[i]; num++;\n      }\n      if (num > K) continue;\n      b[num].push_back(total);\n   }\n   REP(i, K+1) SORT(b[i]);\n\n   int ans = 0;\n   REP(s, 1<<N-N/2) {\n      int total = 0, num = 0;\n      REP(i, N-N/2) if (s >> i & 1) {\n         total += a[i + N/2]; num++;\n      }\n      if (K < num) continue;\n      ans += (UB(b[K-num], R+1-total) - LB(b[K-num], L-total));\n   }\n   cout << ans << endl;\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, K, L, R; cin >> N >> K >> L >> R;\n\tvector<int> a(N); rep(i, 0, N) { cin >> a[i]; }\n\tvector<int> A[41], B[41];\n\tA[0].emplace_back(0);\n\tB[0].emplace_back(0);\n\trep(i, 0, N / 2) {\n\t\trrep(k, 0, K) {\n\t\t\trep(j, 0, A[k].size()) {\n\t\t\t\tA[k + 1].emplace_back(A[k][j] + a[i]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, N / 2, N) {\n\t\trrep(k, 0, K) {\n\t\t\trep(j, 0, B[k].size()) {\n\t\t\t\tB[k + 1].emplace_back(B[k][j] + a[i]);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(k, 0, K + 1) {\n\t\tsort(all(A[k]));\n\t\tsort(all(B[K - k]));\n\t\trep(i, 0, A[k].size()) {\n\t\t\tans += upper_bound(all(B[K - k]), R - A[k][i]) - lower_bound(all(B[K - k]), L - A[k][i]);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL << 30)\n#define LLINF (1LL << 60)\n#define PI 3.14159265359\n#define EPS 1e-12\n#define int ll\n\nsigned main(void) {\n  ll n, k, l, r, a[45];\n  cin >> n >> k >> l >> r;\n  REP(i, n) cin >> a[i];\n  ll n2 = n / 2;\n  VVL ps1(n2 + 1), ps2(n - n2 + 1);\n\n  REP(i, 1 << n2) {\n    ll vl = 0, cnt = 0;\n    REP(j, n2) if (i >> j & 1) {vl += a[j]; ++cnt;}\n    ps1[cnt].push_back(vl);\n  }\n  REP(i, 1 << (n - n2)) {\n    ll vl = 0, cnt = 0;\n    REP(j, n - n2) if (i >> j & 1) {vl += a[n2 + j]; ++cnt;}\n    ps2[cnt].push_back(vl);\n  }\n  REP(i, n2) sort(ALL(ps1[i]));\n  \n  ll ret = 0;\n  FOR(i, max((ll)0, k - n2), min(k, n - n2) + 1) {\n    REP(j, ps2[i].size()) {\n      ret += (ll)(upper_bound(ALL(ps1[k - i]), r - ps2[i][j]) -\n                  lower_bound(ALL(ps1[k - i]), l - ps2[i][j]));\n    }\n  }\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nlong long n, k, l, r, a[40], pos;\nvector<long long>p[30], q[30];\nint main() {\n\tcin >> n >> k >> l >> r; pos = n / 2;\n\tfor (int i = 0; i < n; i++)cin >> a[i];\n\tfor (int i = 0; i < (1 << pos); i++) {\n\t\tlong long R = 0; for (int j = 0; j < pos; j++) { if ((i / (1 << j)) % 2 == 1) { R += a[j]; } }\n\t\tp[__popcnt(i)].push_back(R);\n\t}\n\tfor (int i = 0; i < (1 << (n - pos)); i++) {\n\t\tlong long R = 0; for (int j = 0; j < n - pos; j++) { if ((i / (1 << j)) % 2 == 1) { R += a[j + pos]; } }\n\t\tq[builtin_popcnt(i)].push_back(R);\n\t}\n\tfor (int i = 0; i < 30; i++)sort(p[i].begin(), p[i].end());\n\tfor (int i = 0; i < 30; i++)sort(q[i].begin(), q[i].end());\n\tlong long cnts = 0;\n\tfor (int i = 0; i <= pos; i++) {\n\t\tint V = k - i; if (V < 0)continue;\n\t\tfor (int j = 0; j < p[i].size(); j++) {\n\t\t\tint pos1 = lower_bound(q[V].begin(), q[V].end(), l - p[i][j]) - q[V].begin();\n\t\t\tint pos2 = lower_bound(q[V].begin(), q[V].end(), r + 1 - p[i][j]) - q[V].begin();\n\t\t\tcnts += pos2 - pos1;\n\t\t}\n\t}\n\tcout << cnts << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <cstring> //memset(dp,0,sizeof(dp))\n#include <functional>\n#include <cctype>\n#include <locale>\n#define ll long long\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define fi first\n#define se second\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\ntypedef pair<int,int> P;\ntypedef pair<long long,long long> Pll;\n#define fout(num) cout << fixed << setprecision(20) << (num) << endl\n//s[i]=tolower(s[i]); islower(s[i]); cout << tolower(s[i])はバグ\n//vector<vector<ll>> dp(n,vector<ll>(n))\n//exist x map o setconst ll MOD = 1e9+7;return fac[n]*(finv[k]*finv[n-k] % MOD) % MOD;\n\nsigned main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int n,k; cin >> n >> k;\n    ll l,r; cin >> l >> r;\n    vector<ll> a(n);\n    rep(i,n) cin >> a[i];\n    int mid=n/2;\n    vector<ll> beg[n+1];\n    vector<ll> ed[n+1];\n    rep(i,1ull<<mid){\n        ll res=0;\n        rep(j,mid){\n            if(i&(1<<j))res+=a[j];\n        }\n        int num=__builtin_popcount(i);\n        beg[num].pb(res);\n    }\n    rep(i,1ull<<(n-mid)){\n        ll res=0;\n        rep(j,(n-mid)){\n            if(i&(1<<j))res+=a[j+mid];\n        }\n        int num=__builtin_popcount(i);\n        ed[num].pb(res);\n    }\n    rep(i,n+1) sort(ALL(beg[i]));\n    rep(i,n+1) sort(ALL(ed[i]));\n    ll ans=0;\n    rep(i,n+1){\n        if(i>k) continue;\n        for(ll u:beg[i]){\n            //use ed[k-i]\n            int p=(int)(lower_bound(ALL(ed[k-i]),l-u)-ed[k-i].begin());\n            int q=(int)(upper_bound(ALL(ed[k-i]),r-u)-ed[k-i].begin());\n            ans+=(q-p);\n        }\n    }\n    cout << ans <<  endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 問題: N枚のコインからK枚を選んで金額が[L,R]の範囲になる選び方の数を求める\n// 解法: \n\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n\n#define pb push_back\n#define mp make_pair\n\nmap<ll, ll> make_map(vector<ll>& As) {\n    map<ll, ll> ret;\n    for(auto a: As) ++ret[a];\n    return ret;\n}\n\nmap<ll, ll> make_combination(map<ll, ll>& As, map<ll, ll>& Bs) {\n    map<ll, ll> ret;\n    for(auto a: As) {\n        for(auto b: Bs) {\n            auto val = a.first + b.first;\n            auto cnt = a.second * b.second;\n            ret[val] += cnt;\n        }\n    }\n    return ret;\n}\n\nll coin_combination_2(ll N, ll K, ll L, ll R,\n                      vector<ll>& As) {\n    // 前半部の全列挙\n    const auto N2 = N / 2;\n    vector<vector<ll>> former(N2 + 1);\n    REP(i, (1 << N2)) {\n        ll sum = 0;\n        int cnt = 0;\n        REP(j, N2) {\n            if (i & (1 << j)) {\n                sum += As[j];\n                cnt++;\n            }\n        }\n        former[cnt].pb(sum);\n    }\n\n    // 後半部の全列挙\n    vector<vector<ll>> latter(N - N2 + 1);\n    REP(i, (1 << (N - N2))) {\n        ll sum = 0;\n        int cnt = 0;\n        REP(j, (N - N2)) {\n            if (i & (1 << j)) {\n                sum += As[N2 + j];\n                cnt++;\n            }\n        }\n        latter[cnt].pb(sum);\n    }\n\n    REP(n, N2) sort(ALL(former[n]));\n    REP(n, N - N2) sort(ALL(latter[n]));\n\n\n    ll ans = 0;\n    // 前半部でn個使う場合\n    REP(n, N2 + 1) {\n        if (n + N - N2 < K) continue;\n        if (n > K) break;\n\n        for (auto e: former[n]) {\n            auto mn = max(0LL, L - e);\n            auto mx = max(0LL, R - e);\n            if (mx == 0) break;\n            //cout << \"mn, mx = \" << mn << \",\" << mx << endl;\n\n            auto it1 = lower_bound(ALL(latter[K - n]), mn);\n            auto it2 = lower_bound(ALL(latter[K - n]), mx + 1);\n            ans += (it2 - it1);\n        }\n    }\n    return ans;\n}\n\nint main() {\n    ll N, K, L, R;\n    cin >> N >> K >> L >> R;\n    vector<ll> As(N);\n    REP(n, N) cin >> As[n];\n    cout << coin_combination_2(N, K, L, R, As) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 40\nusing namespace std;\n\nvector<int> A[21];\nint coin[N];\n\nint calc(int bit,int arr[],int n){\n  int res = 0;\n  for(int i=0;i<n;i++) if(bit>>i&1) res += arr[i];\n  return res;\n}\n\nsigned main(){\n\n  int n,K,L,R;\n  cin>>n>>K>>L>>R;\n  for(int i=0;i<n;i++) cin>>coin[i];\n  \n  int a = n/2;\n  int b = n-a;\n  for(int i=0;i<(1<<a);i++){\n    int cnt = __builtin_popcount(i);\n    A[cnt].push_back(calc(i,coin,a));\n  }\n\n  for(int i=0;i<=20;i++)sort(A[i].begin(),A[i].end());\n  \n  int ans = 0;\n  for(int i=0;i<(1<<b);i++){\n    int cnt = __builtin_popcount(i);\n    int br = calc(i,coin+a,b);\n    if(cnt>K) continue;\n    int l = lower_bound(A[K-cnt].begin(),A[K-cnt].end(),L-br) - A[K-cnt].begin();\n    int r = upper_bound(A[K-cnt].begin(),A[K-cnt].end(),R-br) - A[K-cnt].begin();\n    assert(l<=r);\n    ans += r-l;\n  }\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <complex>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define Lower_bound(v, x) \\\n  distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) \\\n  distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\nusing T = tuple<ll, ll, ll>;\nusing vll = vector<ll>;\nusing vP = vector<P>;\nusing vT = vector<T>;\nusing vvll = vector<vector<ll>>;\nusing vvP = vector<vector<P>>;\nusing dqll = deque<ll>;\n\nll dx[9] = {-1, 1, 0, 0, -1, -1, 1, 1, 0};\nll dy[9] = {0, 0, -1, 1, -1, 1, -1, 1, 0};\n\nconst ll INF = 1LL << 50;\n\nstatic const long long mod = 1000000007;\n\nint main() {\n  ll n, k, l, r;\n  cin >> n >> k >> l >> r;\n\n  ll na = n / 2;\n  ll nb = n - na;\n  vll sa(na), sb(nb);\n\n  rep(i, na) cin >> sa[i];\n  rep(i, nb) cin >> sb[i];\n\n  ll ans = 0;\n  vvll lsta(na+1, vll()), lstb(nb+1, vll());\n  rep(s, 1LL << na) {\n    ll cur = 0;\n    rep(ii, na) if ((s >> ii & 1) == 1) cur += sa[ii];\n    lsta[__builtin_popcount(s)].push_back(cur);\n  }\n  rep(s, 1LL << nb) {\n    ll cur = 0;\n    rep(ii, nb) if ((s >> ii & 1) == 1) cur += sb[ii];\n    lstb[__builtin_popcount(s)].push_back(cur);\n  }\n  rep(i, nb) Sort(lstb[i]);\n  for (ll i = 0; i <= k; i++) {\n    ll j = k - i;\n    if (i > na || j > nb) continue;\n    for (ll x : lsta[i]) {\n      ll ir = Upper_bound(lstb[j], r - x);\n      ll il = Lower_bound(lstb[j], l - x);\n      ans += ir - il;\n    } // i\n  } // i\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (upper_bound(ALL(c),x)-lower_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *min_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\nsigned main()\n{\n   int N ,K, L, R; cin >> N >> K >> L >> R;\n   V<int> a(N); REP(i, N) cin >> a[i];\n\n   V<V<int>> b(K+1);\n   REP(s, 1<<N/2) {\n      int total = 0, num = 0;\n      REP(i, N/2) if (s >> i & 1) {\n         total += a[i]; num++;\n      }\n      if (num > K) continue;\n      b[num].push_back(total);\n   }\n   REP(i, K+1) SORT(b[i]);\n\n   int ans = 0;\n   REP(s, 1<<N-N/2) {\n      int total = 0, num = 0;\n      REP(i, N-N/2) if (s >> i & 1) {\n         total += a[i + N/2]; num++;\n      }\n      if (K < num) continue;\n      ans += (UB(b[K-num], R+1-total) - LB(b[K-num], L-total));\n   }\n   cout << ans << endl;\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <list>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <tuple>\n#include <deque>\n#include <complex>\n\nusing namespace std;\n\n/*\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n*/\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef pair<long long, long long> pll;\ntypedef vector<pll> vpll;\n\ntypedef long double ld;\ntypedef vector<ld> vld;\n\ntypedef vector<bool> vb;\n\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define reps(i, n) for (ll i = 1; i <= (n); i++)\n#define rrep(i, n) for (ll i = (n) - 1; i >= 0; i--)\n#define rreps(i, n) for (ll i = (n); i >= 1; i--)\n#define all(v) (v).begin(), (v).end()\n\ntemplate <class T> void chmin(T& a, T b) { a = min(a, b);}\ntemplate <class T> void chmax(T& a, T b) { a = max(a, b);}\n\nconstexpr int INF = 1 << 30;\nconstexpr ll INFL = 1LL << 60;\nconstexpr ll MOD = 1000000007;\nconstexpr ld EPS = 1e-12;\nld PI = acos(-1.0);\n\nvoid get_enum(vll& a, vpll& va) {\n    for(ll i = 0; i < (1ll << a.size()); i++) {\n        ll sa = 0;\n        for(ll j = 0; j < a.size(); j++) {\n            if(!(i & (1ll << j))) continue;\n            sa += a[j];\n        }\n        va.push_back(make_pair(__builtin_popcountl(i), sa));\n    }\n    return;\n}\n\nvoid solve() {\n    ll n, k, l, r;\n    cin >> n >> k >> l >> r;\n    vll a, b;\n    for(ll i = 0; i < n; i++) {\n        ll t; cin >> t;\n        if(i < n / 2) a.push_back(t);\n        else b.push_back(t);\n    }\n    vpll va, vb;\n    get_enum(a, va);\n    get_enum(b, vb);\n    sort(va.begin(), va.end());\n    ll ans = 0;\n    for(auto p : vb) {\n        ll kb = p.first, sb = p.second;\n        ll il = lower_bound(va.begin(), va.end(), make_pair(k - kb, l - sb)) - va.begin();\n        ll ir = upper_bound(va.begin(), va.end(), make_pair(k - kb, r - sb)) - va.begin();\n        ans += ir - il;\n    }\n    cout << ans << endl;\n    return;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll n,k,l,r,a,m,A[41],B[41],L,cnt,R,ans;\nvector<ll> v[41],u[41];\nll ch(ll n){\n    ll cnt=0;\n    for(int i=0;i<20;i++){\n        if(((n>>i)&1)==1)cnt++;\n    }\n    return cnt;\n}\nint main(void){\n    cin>>n>>k>>l>>r;\n    m=n;\n    n/=2;\n    m-=n;\n    //cout<<n<<\" \"<<m<<endl;\n    for(int i=0;i<m;i++){\n        cin>>A[i];\n    }\n    for(int i=0;i<n;i++){\n        cin>>B[i];\n    }\n    for(int i=0;i<(1<<m);i++){\n        L=ch(i);\n        cnt=0;\n        for(int j=0;j<m;j++){\n            if(((i>>j)&1)==1){\n                cnt+=A[j];\n            }\n        }\n        if(cnt<=r)v[L].push_back(cnt);\n    }\n    for(int i=0;i<(1<<n);i++){\n        L=ch(i);\n        cnt=0;\n        for(int j=0;j<n;j++){\n            if(((i>>j)&1)==1){\n                cnt+=B[j];\n            }\n        }\n        if(cnt<=r)u[L].push_back(cnt);\n    }\n    for(int i=0;i<21;i++){\n        if(v[i].size())sort(v[i].begin(),v[i].end());\n        if(u[i].size())sort(u[i].begin(),u[i].end());\n    }\n    for(int i=0;i<=k;i++){\n        for(ll x:v[i]){\n            L=lower_bound(u[k-i].begin(),u[k-i].end(),l-x)-u[k-i].begin();\n            R=upper_bound(u[k-i].begin(),u[k-i].end(),r-x)-u[k-i].begin();\n            //cout<<L<<\" \"<<R<<endl;\n            ans+=max(0LL,R-L);\n        }\n    }\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ DPL_4_B Coin Combination Problem II\n// 2018.5.10 bal4u\n \n#include <stdio.h>\n \n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\n \nint in()\n{\n    int n = 0, c = gc();\n    do n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n    return n;\n}\n\nlong long inLL()\n{\n    long long n = 0, c = gc();\n    do n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n    return n;\n}\n\n#define MAX  ((1<<20)+5)\ntypedef struct { long long s; char n; } QUE;\nQUE que[MAX]; int top, end;\n\nlong long a[42];\nint w;\n\nlong long sum[42][MAX]; int hi[42];\n\nint main()\n{\n\tint N, K, m, i, j, k, n, n1, stop, ans;\n\tlong long L, R, v, t;\n\n\tN = in(), K = in(), L = inLL(), R = inLL();\n\tans = 0;\n\n\tif (K == 1) {\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tt = inLL();\n\t\t\tif (t >= L && t <= R) ans++;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t\treturn 0;\n\t}\n\n\tw = 0; for (i = 0; i < N; i++) {\n\t\tt = inLL();\n\t\tif (t + K-1 <= R) a[w++] = t;\n\t}\n\n\tm = w/2;\n\tque[0].s = 0, que[0].n = 0, top = 0, end = 1;\n\tfor (i = 0; i < m; i++) {\n\t\ttop = 0, stop = end;\n\t\twhile (top != stop) {\n\t\t\tv = que[top].s, n = que[top++].n, n1 = n+1;\n\t\t\tt = v + a[i];\n\n\t\t\tif (n1 == K) {\n\t\t\t\tif (t >= L && t <= R) ans++;\n\t\t\t} else if (n1 < K) {\n\t\t\t\tif (t < R) {\n\t\t\t\t\tque[end].s = t, que[end++].n = n1;\n\t\t\t\t\tsum[n1][hi[n1]++] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tque[0].s = 0, que[0].n = 0, top = 0, end = 1;\n\tfor (i = m; i < w; i++) {\n\t\ttop = 0, stop = end;\n\t\twhile (top != stop) {\n\t\t\tv = que[top].s, n = que[top++].n, n1 = n+1;\n\t\t\tt = v + a[i];\n\n\t\t\tif (n1 == K) {\n\t\t\t\tif (t >= L && t <= R) ans++;\n\t\t\t} else if (n1 < K) {\n\t\t\t\tif (t < R) {\n\t\t\t\t\tque[end].s = t, que[end++].n = n1;\n\n\t\t\t\t\tk = K-n1;\n\t\t\t\t\tif (k >= 0) {\n\t\t\t\t\t\tfor (j = 0; j < hi[k]; j++) {\n\t\t\t\t\t\t\tlong long s = t + sum[k][j];\n\t\t\t\t\t\t\tif (s >= L && s <= R) ans++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ DPL_4_B Coin Combination Problem II\n// 2018.5.10 bal4u\n \n#include <stdio.h>\n#include <stdlib.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\n \nint in()\n{\n    int n = 0, c = gc();\n    do n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n    return n;\n}\n\nlong long inLL()\n{\n    long long n = 0, c = gc();\n    do n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n    return n;\n}\n\n#define MAX  ((1<<20)+5)\n\nlong long a[42]; int w;\nlong long s1[42][MAX]; int w1[42];\nlong long s2[42][MAX]; int w2[42];\n\nint binarysearch_upper(long long *a, long long x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l+r) >> 1;\n\t\tif (a[m] == x) return m+1;\n\t\tif (a[m] < x) l = m + 1; else r = m;\n    }\n\treturn l;\n}\n\nint binarysearch_lower(long long *a, long long x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l+r) >> 1;\n        if (a[m] < x) l = m + 1; else r = m;\n    }\n\treturn l;\n}\n\nint cmp(long long *a, long long *b)\n{\n\tif (*a < *b) return -1;\n\treturn (*a != *b);\n}\n\nlong long combi(int n, int k)\n{\n\tlong long ans;\n\n\tif (s1[n][k]) return s1[n][k];\n\tif ((k << 1) > n) k = n-k;\n\tif (k == 0) ans = 1;\n\telse if (k == 1) ans = n;\n\telse ans = combi(n-1, k) + combi(n-1, k-1);\n\treturn s1[n][k] = ans;\n}\n\nint main()\n{\n\tint N, K, i, j, k, m1, m2, n, lim;\n\tlong long L, R, x, y, ans;\n\n\tN = in(), K = in(), L = inLL(), R = inLL();\n\n\tw = 0;\n\ty = inLL(); if (y + K-1 <= R) a[w++] = y;\n\tfor (i = 1; i < N; i++) {\n\t\tx = inLL();\n\t\tif (x != y) y = 0;\n\t\tif (x + K-1 <= R) a[w++] = x;\n\t}\n\n\t// identical a[i]\n\tif (x == y) {\n\t\tif (w >= K && (y = x*K) >= L && y <= R) printf(\"%lld\\n\", combi(w, K));\n\t\telse puts(\"0\");\n\t\treturn 0;\n\t}\n\n\tm1 = w/2, lim = 1 << m1;\n\tfor (i = 0; i < lim; i++) {\n\t\tx = 0, n = 0;\n\t\tfor (j = 0; ; j++) {\n\t\t\tif (j == m1) { s1[n][w1[n]++] = x; break; }\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tx += a[j];\n\t\t\t\tif (++n > K) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tm2 = w - m1;\n\tlim = 1 << m2;\n\t\tfor (i = 0; i < lim; i++) {\n\t\tx = 0, n = 0;\n\t\tfor (j = 0; ; j++) {\n\t\t\tif (j == m2) { s2[n][w2[n]++] = x; break; }\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tx += a[j+m1];\n\t\t\t\tif (++n > K) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i <= K; i++) qsort(s2[i], w2[i], sizeof(long long), cmp);\n\n\tans = 0;\n\tfor (i = 0; i <= K; i++) {\n\t\tk = K-i;\n\t\tfor (j = 0; j < w1[i]; j++) {\n\t\t\tx = L-s1[i][j], y = R-s1[i][j];\n\t\t\tif (y < 0) continue;\n\t\t\tans += (long long)binarysearch_upper(s2[k], y, w2[k]);\n\t\t\tif (x > 0) ans -= (long long)binarysearch_lower(s2[k], x, w2[k]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ DPL_4_B Coin Combination Problem II\n// 2018.5.10 bal4u\n \n#include <stdio.h>\n#include <stdlib.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\n \nint in()\n{\n    int n = 0, c = gc();\n    do n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n    return n;\n}\n\nlong long inLL()\n{\n    long long n = 0, c = gc();\n    do n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n    return n;\n}\n\n#define MAX  ((1<<20)+5)\n\nlong long a[42]; int w;\nlong long s1[42][MAX]; int w1[42];\nlong long s2[42][MAX]; int w2[42];\n\nint binarysearch_upper(long long *a, long long x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l+r) >> 1;\n\t\tif (a[m] == x) return m+1;\n\t\tif (a[m] < x) l = m + 1; else r = m;\n    }\n\treturn l;\n}\n\nint binarysearch_lower(long long *a, long long x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l+r) >> 1;\n        if (a[m] < x) l = m + 1; else r = m;\n    }\n\treturn l;\n}\n\nint cmp(long long *a, long long *b)\n{\n\tif (*a < *b) return -1;\n\treturn (*a != *b);\n}\n\nlong long combi(int n, int k)\n{\n\tlong long ans;\n\n\tif (s1[n][k]) return s1[n][k];\n\tif ((k << 1) > n) k = n-k;\n\tif (k == 0) ans = 1;\n\telse if (k == 1) ans = n;\n\telse ans = combi(n-1, k) + combi(n-1, k-1);\n\treturn s1[n][k] = ans;\n}\n\nint main()\n{\n\tint N, K, i, j, k, m1, m2, n, lim;\n\tlong long L, R, x, y, ans;\n\n\tN = in(), K = in(), L = inLL(), R = inLL();\n\n\tw = 0;\n\tx = y = inLL(); if (y + K-1 <= R) a[w++] = y;\n\tfor (i = 1; i < N; i++) {\n\t\tx = inLL();\n\t\tif (x != y) y = 0;\n\t\tif (x + K-1 <= R) a[w++] = x;\n\t}\n\n\t// identical a[i]\n\tif (x == y) {\n\t\tif (w >= K && (y = x*K) >= L && y <= R) printf(\"%lld\\n\", combi(w, K));\n\t\telse puts(\"0\");\n\t\treturn 0;\n\t}\n\n\tm1 = w-20;\n\tif (m1 < 1) m1 = 1;\n\tlim = 1 << m1;\n\tfor (i = 0; i < lim; i++) {\n\t\tx = 0, n = 0;\n\t\tfor (j = 0; ; j++) {\n\t\t\tif (j == m1) { s1[n][w1[n]++] = x; break; }\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tx += a[j];\n\t\t\t\tif (++n > K) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tm2 = w - m1;\n\tlim = 1 << m2;\n\t\tfor (i = 0; i < lim; i++) {\n\t\tx = 0, n = 0;\n\t\tfor (j = 0; ; j++) {\n\t\t\tif (j == m2) { s2[n][w2[n]++] = x; break; }\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tx += a[j+m1];\n\t\t\t\tif (++n > K) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i <= K; i++) qsort(s2[i], w2[i], sizeof(long long), cmp);\n\n\tans = 0;\n\tfor (i = 0; i <= K; i++) {\n\t\tk = K-i;\n\t\tfor (j = 0; j < w1[i]; j++) {\n\t\t\ty = R-s1[i][j];\n\t\t\tif (y >= 0) {\n\t\t\t\tans += (long long)binarysearch_upper(s2[k], y, w2[k]);\n\t\t\t\tx = L-s1[i][j];\n\t\t\t\tif (x > 0) ans -= (long long)binarysearch_lower(s2[k], x, w2[k]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ DPL_4_B Coin Combination Problem II\n// 2018.5.10 bal4u\n \n#include <stdio.h>\n#include <stdlib.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\n \nint in()\n{\n    int n = 0, c = gc();\n    do n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n    return n;\n}\n\nlong long inLL()\n{\n    long long n = 0, c = gc();\n    do n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n    return n;\n}\n\n#define INF  0x70707070707070LL\n#define MAX  ((1<<20)+5)\n\nlong long a[42]; int w;\nlong long s1[42][MAX]; int w1[42];\nlong long s2[42][MAX]; int w2[42];\n\nint binarysearch_upper(long long *a, long long x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l+r) >> 1;\n\t\tif (a[m] == x) return m+1;\n\t\tif (a[m] < x) l = m + 1; else r = m;\n    }\n\treturn l;\n}\n\nint binarysearch_lower(long long *a, long long x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l+r) >> 1;\n        if (a[m] < x) l = m + 1; else r = m;\n    }\n\treturn l;\n}\n\nint cmp(long long *a, long long *b)\n{\n\tif (*a < *b) return -1;\n\treturn (*a != *b);\n}\n\nint main()\n{\n\tint N, K, i, j, k, m1, m2, n, lim;\n\tlong long L, R, x, y, ans;\n\n\tN = in(), K = in(), L = inLL(), R = inLL();\n\n\tw = 0; for (i = 0; i < N; i++) {\n\t\tx = inLL();\n\t\tif (x + K-1 <= R) a[w++] = x;\n\t}\n\n\tm1 = w/2, lim = 1 << m1;\n\tfor (i = 0; i < lim; i++) {\n\t\tx = 0, n = 0;\n\t\tfor (j = 0; ; j++) {\n\t\t\tif (j == m1) { s1[n][w1[n]++] = x; break; }\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tx += a[j];\n\t\t\t\tif (++n > K) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tm2 = w - m1;\n\tlim = 1 << m2;\n\t\tfor (i = 0; i < lim; i++) {\n\t\tx = 0, n = 0;\n\t\tfor (j = 0; ; j++) {\n\t\t\tif (j == m2) { s2[n][w2[n]++] = x; break; }\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tx += a[j+m1];\n\t\t\t\tif (++n > K) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i <= K; i++) qsort(s2[i], w2[i], sizeof(long long), cmp);\n\n\tans = 0;\n\tfor (i = 0; i <= K; i++) {\n\t\tk = K-i;\n\t\tfor (j = 0; j < w1[i]; j++) {\n\t\t\tx = L-s1[i][j], y = R-s1[i][j];\n\t\t\tif (y < 0) continue;\n\t\t\tans += (long long)binarysearch_upper(s2[k], y, w2[k]);\n\t\t\tif (x > 0) ans -= (long long)binarysearch_lower(s2[k], x, w2[k]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ DPL_4_B Coin Combination Problem II\n// 2018.5.10 bal4u\n \n#include <stdio.h>\n#include <stdlib.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\n \nint in()\n{\n    int n = 0, c = gc();\n    do n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n    return n;\n}\n\nlong long inLL()\n{\n    long long n = 0, c = gc();\n    do n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n    return n;\n}\n\n#define MAX  ((1<<20)+5)\n\nlong long a[42]; int w;\nlong long s1[42][MAX]; int w1[42];\nlong long s2[42][MAX]; int w2[42];\n\nint binarysearch_upper(long long *a, long long x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l+r) >> 1;\n\t\tif (a[m] <= x) l = m + 1; else r = m;\n    }\n\treturn l;\n}\n\nint binarysearch_lower(long long *a, long long x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l+r) >> 1;\n        if (a[m] < x) l = m + 1; else r = m;\n    }\n\treturn l;\n}\n\nint cmp(long long *a, long long *b)\n{\n\tif (*a > *b) return -1;\n\treturn (*a != *b);\n}\n\nint main()\n{\n\tint N, K, i, j, m1, m2, n, lim;\n\tlong long L, R, t, ans;\n\n\tN = in(), K = in(), L = inLL(), R = inLL();\n\n\tw = 0; for (i = 0; i < N; i++) {\n\t\tt = inLL();\n\t\tif (t + K-1 <= R) a[w++] = t;\n\t}\n\n\tm1 = w/2, lim = 1 << m1;\n\tfor (i = 0; i < lim; i++) {\n\t\tt = 0, n = 0;\n\t\tfor (j = 0; j < m1; j++) if ((i >> j) & 1) {\n\t\t\tt += a[j], n++;\n\t\t}\n\t\ts1[n][w1[n]++] = t;\n\t}\n\n\tm2 = w - m1;\n\tlim = 1 << m2;\n\t\tfor (i = 0; i < lim; i++) {\n\t\tt = 0, n = 0;\n\t\tfor (j = 0; j < m2; j++) if ((i >> j) & 1) {\n\t\t\tt += a[j+m1], n++;\n\t\t}\n\t\ts2[n][w2[n]++] = t;\n\t}\n\n\tans = 0;\n\ti = K - m1; if (i < 0) i = 0;\n\tlim = w - m1; if (lim > K) lim = K;\n\twhile (i <= lim) {\n\t\tfor (j = 0; j < w2[i]; j++) {\n\t\t\tlong long x1 = R-s2[i][j], x2 = L-s2[i][j];\n\t\t\tif (x1 >= 0 && x2 >= 0) {\n\t\t\t\tans += (long long)binarysearch_upper(s1[K-i], x1, w1[K-i]) -\n\t\t\t\t\t              binarysearch_lower(s1[K-i], x2, w1[K-i]);\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ DPL_4_B Coin Combination Problem II\n// 2018.5.10 bal4u\n \n#include <stdio.h>\n#include <stdlib.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\n \nint in()\n{\n    int n = 0, c = gc();\n    do n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n    return n;\n}\n\nlong long inLL()\n{\n    long long n = 0, c = gc();\n    do n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n    return n;\n}\n\n#define MAX  ((1<<20)+5)\n\nlong long a[42]; int w;\nlong long s1[42][MAX]; int w1[42];\nlong long s2[42][MAX]; int w2[42];\n\nint binarysearch_upper(long long *a, long long x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l+r) >> 1;\n\t\tif (a[m] == x) return m+1;\n\t\tif (a[m] < x) l = m + 1; else r = m;\n    }\n\treturn l;\n}\n\nint binarysearch_lower(long long *a, long long x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l+r) >> 1;\n        if (a[m] < x) l = m + 1; else r = m;\n    }\n\treturn l;\n}\n\nint cmp(long long *a, long long *b)\n{\n\tif (*a < *b) return -1;\n\treturn (*a != *b);\n}\n\nlong long combi(int n, int k)\n{\n\tlong long ans;\n\n\tif (s1[n][k]) return s1[n][k];\n\tif ((k << 1) > n) k = n-k;\n\tif (k == 0) ans = 1;\n\telse if (k == 1) ans = n;\n\telse ans = combi(n-1, k) + combi(n-1, k-1);\n\treturn s1[n][k] = ans;\n}\n\nint main()\n{\n\tint N, K, i, j, k, m1, m2, n, lim;\n\tlong long L, R, x, y, ans;\n\n\tN = in(), K = in(), L = inLL(), R = inLL();\n\n\tw = 0;\n\tx = y = inLL(); if (y + K-1 <= R) a[w++] = y;\n\tfor (i = 1; i < N; i++) {\n\t\tx = inLL();\n\t\tif (x != y) y = 0;\n\t\tif (x + K-1 <= R) a[w++] = x;\n\t}\n\n\t// identical a[i]\n\tif (x == y) {\n\t\tif (w >= K && (y = x*K) >= L && y <= R) printf(\"%lld\\n\", combi(w, K));\n\t\telse puts(\"0\");\n\t\treturn 0;\n\t}\n\n\tm1 = w / 2, lim = 1 << m1;\n\tfor (i = 0; i < lim; i++) {\n\t\tx = 0, n = 0;\n\t\tfor (j = 0; ; j++) {\n\t\t\tif (j == m1) { s2[n][w2[n]++] = x; break; }\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tx += a[j];\n\t\t\t\tif (++n > K) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tm2 = w - m1;\n\tlim = 1 << m2;\n\t\tfor (i = 0; i < lim; i++) {\n\t\tx = 0, n = 0;\n\t\tfor (j = 0; ; j++) {\n\t\t\tif (j == m2) { s1[n][w1[n]++] = x; break; }\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tx += a[j+m1];\n\t\t\t\tif (++n > K) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i <= K; i++) qsort(s2[i], w2[i], sizeof(long long), cmp);\n\n\tans = 0;\n\tfor (i = 0; i <= K; i++) {\n\t\tk = K-i;\n\t\tfor (j = 0; j < w1[i]; j++) {\n\t\t\ty = R-s1[i][j];\n\t\t\tif (y >= 0) {\n\t\t\t\tans += (long long)binarysearch_upper(s2[k], y, w2[k]);\n\t\t\t\tx = L-s1[i][j];\n\t\t\t\tif (x > 0) ans -= (long long)binarysearch_lower(s2[k], x, w2[k]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define MAX 200000\nlong long int a[40], sum1[41][MAX], sum2[41][MAX], w1[41], w2[41];\nint w;\nint Input(void);\nlong long int Inputll(void);\nlong long int Combi(int w, int k);\nint Compare(const void *a, const void *b);\nlong long int Binary_search(long long int *sum, long long int x, long long int r);\nint main(void)\n{\n  int n, k, m1, m2;\n  long long int i, j, l, r, x, y, limit;\n  n = Input(), k = Input(), l = Inputll(), r = Inputll();\n  y = Inputll();\n  if (y + k - 1 <= r) a[w++] = y;\n  for (i = 1; i < n; i++) {\n    x = Inputll();\n    if (x != y) y = 0;\n    if (x + k - 1 <= r) a[w++] = x;\n  }\n  if (x == y) {\n    if (w >= k && (y = x * k) >= l && y <= r) printf(\"%lld\\n\", Combi(w, k));\n    else printf(\"0\\n\");\n    return 0;\n  }\n  m1 = w / 2, limit = 1 << m1;\n  for (i = 0; i < limit; i++) {\n    x = 0, n = 0, j = 0;\n    while (1) {\n      if (j == m1) {\n        sum1[n][w1[n]++] = x;\n        break;\n      }\n      if ((i >> j) & 1) {\n        x += a[j];\n        if (++n > k) break;\n      }\n      j++;\n    }\n  }\n  m2 = w - m1, limit = 1 << m2;\n  for (i = 0; i < limit; i++) {\n    x = 0, n = 0, j = 0;\n    while (1) {\n      if (j == m2) {\n        sum2[n][w2[n]++] = x;\n        break;\n      }\n      if ((i >> j) & 1) {\n        x += a[j+m1];\n        if (++n > k) break;\n      }\n      j++;\n    }\n  }\n  for (i = 0; i <= k; i++) qsort(sum2[i], w2[i], sizeof(long long int), Compare);\n  limit = 0;\n  for (i = 0; i <= k; i++) {\n    int kk = k - i;\n    for (j = 0; j < w1[i]; j++) {\n      x = l - sum1[i][j], y = r - sum1[i][j];\n      if (y < 0) continue;\n      limit += Binary_search(sum2[kk], y + 1, w2[kk]);\n      if (x > 0) limit -= Binary_search(sum2[kk], x, w2[kk]);\n    }\n  }\n  printf(\"%lld\\n\", limit);\n  return 0;\n}\nint Input(void)\n{\n  int n = 0, c;\n  while ((c = getchar_unlocked()) >= '0' && c <= '9') n = 10 * n + c - '0';\n  return n;\n}\nlong long int Inputll(void)\n{\n  long long int n = 0;\n  int c;\n  while ((c = getchar_unlocked()) >= '0' && c <= '9') n = 10 * n + c - '0';\n  return n;\n}\nlong long int Combi(int w, int k)\n{\n  if (sum1[w][k]) return sum1[w][k];\n  if (k == 0 || k == w) return 1;\n  else if (k == 1) return w;\n  else {\n    if (k * 2 > w) k = w - k;\n    return sum1[w][k] = Combi(w - 1, k) + Combi(w - 1, k - 1);\n  }\n}\nint Compare(const void *a, const void *b)\n{\n  long long int *ta = (long long int*)a, *tb = (long long int*)b;\n  if (*ta > *tb) return 1;\n  else if (*ta < *tb) return -1;\n  return 0;\n}\nlong long int Binary_search(long long int *sum, long long int x, long long int r)\n{\n  int m, l = 0;\n  while (l < r) {\n    m = (l + r) / 2;\n    if (sum[m] < x) l = m + 1;\n    else r = m;\n  }\n  return l;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ DPL_4_B Coin Combination Problem II\n// 2018.5.11 bal4u\n \n#include <stdio.h>\n#include <stdlib.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\n \nint in()\n{\n    int n = 0, c = gc();\n    do n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n    return n;\n}\n\nlong long inLL()\n{\n    long long n = 0, c = gc();\n    do n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n    return n;\n}\n\n#define MAX  ((1<<20)+5)\n\nlong long a[42]; int w;\nlong long s1[42][MAX]; int w1[42];\nlong long s2[42][MAX]; int w2[42];\n\nint binarysearch_upper(long long *a, long long x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l+r) >> 1;\n\t\tif (a[m] <= x) l = m + 1; else r = m;\n    }\n\treturn l;\n}\n\nint binarysearch_lower(long long *a, long long x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l+r) >> 1;\n        if (a[m] < x) l = m + 1; else r = m;\n    }\n\treturn l;\n}\n\nint cmp(long long *a, long long *b)\n{\n\tif (*a < *b) return -1;\n\treturn (*a != *b);\n}\n\nlong long combi(int n, int k)\n{\n\tlong long ans;\n\n\tif (s1[n][k]) return s1[n][k];\n\tif ((k << 1) > n) k = n-k;\n\tif (k == 0) ans = 1;\n\telse if (k == 1) ans = n;\n\telse ans = combi(n-1, k) + combi(n-1, k-1);\n\treturn s1[n][k] = ans;\n}\n\nint main()\n{\n\tint N, K, i, j, k, m1, m2, n, lim;\n\tlong long L, R, x, y, ans;\n\n\tN = in(), K = in(), L = inLL(), R = inLL();\n\n\tw = 0;\n\tx = y = inLL(); if (y + K-1 <= R) a[w++] = y;\n\tfor (i = 1; i < N; i++) {\n\t\tx = inLL();\n\t\tif (x != y) y = 0;\n\t\tif (x + K-1 <= R) a[w++] = x;\n\t}\n\n\t// identical a[i]\n\tif (x == y) {\n\t\tif (w >= K && (y = x*K) >= L && y <= R) printf(\"%lld\\n\", combi(w, K));\n\t\telse puts(\"0\");\n\t\treturn 0;\n\t}\n\n\tm1 = w / 2, lim = 1 << m1;\n\tfor (i = 0; i < lim; i++) {\n\t\tx = 0, n = 0;\n\t\tfor (j = 0; ; j++) {\n\t\t\tif (j == m1) { s1[n][w1[n]++] = x; break; }\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tx += a[j];\n\t\t\t\tif (++n > K) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tm2 = w - m1, lim = 1 << m2;\n\t\tfor (i = 0; i < lim; i++) {\n\t\tx = 0, n = 0;\n\t\tfor (j = 0; ; j++) {\n\t\t\tif (j == m2) { s2[n][w2[n]++] = x; break; }\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tx += a[j+m1];\n\t\t\t\tif (++n > K) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i <= K; i++) qsort(s2[i], w2[i], sizeof(long long), cmp);\n\n\tans = 0;\n\tfor (i = 0; i <= K; i++) {\n\t\tk = K-i;\n\t\tfor (j = 0; j < w1[i]; j++) {\n\t\t\ty = R-s1[i][j];\n\t\t\tif (y >= 0) {\n\t\t\t\tans += n = (long long)binarysearch_upper(s2[k], y, w2[k]);\n\t\t\t\tx = L-s1[i][j];\n\t\t\t\tif (x > 0) ans -= (long long)binarysearch_lower(s2[k], x, n);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ DPL_4_B Coin Combination Problem II\n// 2018.5.11 bal4u\n \n#include <stdio.h>\n#include <stdlib.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\n \nint in()\n{\n    int n = 0, c = gc();\n    do n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n    return n;\n}\n\nlong long inLL()\n{\n    long long n = 0, c = gc();\n    do n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n    return n;\n}\n\n#define MAX  ((1<<20)+5)\n\nlong long a[42]; int w;\nlong long s1[42][MAX]; int w1[42];\nlong long s2[42][MAX]; int w2[42];\n\nint binarysearch_upper(long long *a, long long x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l+r) >> 1;\n\t\tif (a[m] <= x) l = m + 1; else r = m;\n    }\n\treturn l;\n}\n\nint binarysearch_lower(long long *a, long long x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l+r) >> 1;\n        if (a[m] < x) l = m + 1; else r = m;\n    }\n\treturn l;\n}\n\nint cmp(long long *a, long long *b)\n{\n\tif (*a < *b) return -1;\n\treturn (*a != *b);\n}\n\nlong long combi(int n, int k)\n{\n\tlong long ans;\n\n\tif (s1[n][k]) return s1[n][k];\n\tif ((k << 1) > n) k = n-k;\n\tif (k == 0) ans = 1;\n\telse if (k == 1) ans = n;\n\telse ans = combi(n-1, k) + combi(n-1, k-1);\n\treturn s1[n][k] = ans;\n}\n\nint main()\n{\n\tint N, K, i, j, k, m1, m2, n, lim;\n\tlong long L, R, x, y, ans;\n\n\tN = in(), K = in(), L = inLL(), R = inLL();\n\n\tw = 0;\n\tx = y = inLL(); if (y + K-1 <= R) a[w++] = y;\n\tfor (i = 1; i < N; i++) {\n\t\tx = inLL();\n\t\tif (x != y) y = 0;\n\t\tif (x + K-1 <= R) a[w++] = x;\n\t}\n\n\t// identical a[i]\n\tif (x == y) {\n\t\tif (w >= K && (y = x*K) >= L && y <= R) printf(\"%lld\\n\", combi(w, K));\n\t\telse puts(\"0\");\n\t\treturn 0;\n\t}\n\n\tm1 = w / 2, lim = 1 << m1;\n\tfor (i = 0; i < lim; i++) {\n\t\tx = 0, n = 0;\n\t\tfor (j = 0; ; j++) {\n\t\t\tif (j == m1) { s1[n][w1[n]++] = x; break; }\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tx += a[j];\n\t\t\t\tif (++n > K) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tm2 = w - m1, lim = 1 << m2;\n\t\tfor (i = 0; i < lim; i++) {\n\t\tx = 0, n = 0;\n\t\tfor (j = 0; ; j++) {\n\t\t\tif (j == m2) { s2[n][w2[n]++] = x; break; }\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tx += a[j+m1];\n\t\t\t\tif (++n > K) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i <= K; i++) qsort(s2[i], w2[i], sizeof(long long), cmp);\n\n\tans = 0;\n\tfor (i = 0; i <= K; i++) {\n\t\tk = K-i;\n\t\tfor (j = 0; j < w1[i]; j++) {\n\t\t\ty = R-s1[i][j];\n\t\t\tif (y >= 0) {\n\t\t\t\tans += n = binarysearch_upper(s2[k], y, w2[k]);\n\t\t\t\tx = L-s1[i][j];\n\t\t\t\tif (x > 0) ans -= binarysearch_lower(s2[k], x, n);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\nvoid loop (i64 *a, i32 n, i32 k, i64 *res, i32 *len) {\n  static i64 val = 0;\n  if (k == 0) {\n    res[(*len)++] = val;\n    return;\n  }\n  if (n < k) return;\n  val += a[0];\n  loop (a + 1, n - 1, k - 1, res, len);\n  val -= a[0];\n  loop (a + 1, n - 1, k, res, len);\n  return;\n}\n\nint cmp (const void *a, const void *b) {\n  i64 d = *(i64 *)a - *(i64 *)b;\n  return d == 0 ? 0 : d < 0 ? -1 : 1;\n}\n\ni64 calc (i64 *a, i32 alen, i64 *b, i32 blen, i64 lim) {\n  i64 res = 0;\n  i32 j = 0;\n  for (i32 i = alen - 1; i >= 0; --i) {\n    while (j < blen && a[i] + b[j] <= lim) j++;\n    res += j;\n  }\n  return res;\n}\n\nvoid run (void) {\n  i32 n, k;\n  i64 l, r;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi64 \"%\" SCNi64, &n, &k, &l, &r);\n  i64 *a = (i64 *) calloc (n, sizeof (i64));\n  for (i32 i = 0; i < n; ++i) {\n    scanf (\"%\" SCNi64,a + i);\n  }\n  i64 ans = 0;\n  i32 m = n / 2;\n  i64 *front = (i64 *) calloc (184756, sizeof (i64));\n  i64 *back = (i64 *) calloc (184756, sizeof (i64));\n  for (i32 i = 0; i <= k; ++i) {\n    i32 front_len = 0;\n    loop (a, m, i, front, &front_len);\n    i32 back_len = 0;\n    loop (a + m, n - m, k - i, back, &back_len);\n    qsort (front, front_len, sizeof (i64), cmp);\n    qsort (back, back_len, sizeof (i64), cmp);\n    ans += calc (front, front_len, back, back_len, r);\n    ans -= calc (front, front_len, back, back_len, l - 1);\n  }\n  printf (\"%\" PRIi64 \"\\n\", ans);\n}\n\nint main (void) {\n  run ();\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define ll long long\n#define bit(n,m)((n>>m)&1)\n\nll dp[1<<20];\nint cnt[1<<20];\nint idx[1<<20];\n\nint c(const void*p,const void*q){\n\tif(cnt[*(int*)p]<cnt[*(int*)q])return -1;\n\tif(cnt[*(int*)p]>cnt[*(int*)q])return  1;\n\tif(dp[*(int*)p]<dp[*(int*)q])return -1;\n\treturn 1;\n}\n\nint bs(int c,ll x,int num){\n\t//dp[l]<x<=dp[r]\n\tint l=0,r=num;\n\tif(c<cnt[idx[0]]||c==cnt[idx[0]]&&x<=dp[idx[0]])return 0;\n\twhile(r-l>1){\n\t\tint m=(l+r)/2;\n\t\tif(c<cnt[idx[m]]||c==cnt[idx[m]]&&x<=dp[idx[m]])r=m;\n\t\telse l=m;\n\t}\n\treturn r;\n}\n\n\nll a[40];\nint main(){\n\tint n,k;\n\tll l,r;\n\tscanf(\"%d%d%lld%lld\",&n,&k,&l,&r);\n\tfor(int i=0;i<n;i++)scanf(\"%lld\",a+i);\n\tint N=n-n/2;\n\tn/=2;\n\tfor(int i=0;i<1<<n;i++){\n\t\tfor(int k=0;k<n;k++)if(bit(i,k)){\n\t\t\tdp[i]+=a[k];\n\t\t\tcnt[i]++;\n\t\t}\n\t\tidx[i]=i;\n\t}\n\tqsort(idx,1<<n,sizeof(int),c);\n\tll ans=0;\n\tfor(int i=0;i<1<<N;i++){\n\t\tll s=0;\n\t\tint temp=0;\n\t\tfor(int k=0;k<N;k++)if(bit(i,k)){\n\t\t\ts+=a[n+k];\n\t\t\ttemp++;\n\t\t}\n\t\tans+=bs(k-temp,r+1-s,1<<n)-bs(k-temp,l-s,1<<n);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\n\t\npublic class Main {\n    static class Graph0n {\n        private ArrayList<Node0n> dt = new ArrayList<>();\n        Graph0n(int sz){for(int i=0; i<sz; i++){Node0n node1 = new Node0n();dt.add(node1);}}\n        public void add(int vn, int val){   dt.get(vn).add(val);                    }\n        public void add2(int vn, int val){  dt.get(vn).add(val);dt.get(val).add(vn);}\n        public int get(int vn, int index){      return dt.get(vn).get(index);       }\n        public ArrayList<Integer> get(int vn){  return dt.get(vn).getAll();         }\n        public int sizeOf(int vn){              return dt.get(vn).size();           }\n        public void clear(){    for(int i=0; i<dt.size(); i++){ dt.get(i).clear();  }   }\n        public void clear(int i){    dt.get(i).clear();  }\n        public static Graph0n make_tree(int vn, FastScanner sc){\n        \tGraph0n tree = new Graph0n(vn);\n        \tfor(int i=1; i<vn; i++){\n        \t    int s1 = sc.nexI()-1;\n        \t    int g1 = sc.nexI()-1;\n        \t    tree.add2(s1,g1);\n        \t}\n        \treturn tree;\n        }\n    }\n    static class Node0n {   //重みなし無向・有向グラフの頂点\n        private ArrayList<Integer> next_vs = new ArrayList<>();\n        public void add(int val){               next_vs.add(val);       }\n        public int get(int ad){                 return next_vs.get(ad); }\n        public ArrayList<Integer> getAll(){     return next_vs;         }\n        public int size(){                      return next_vs.size();  }\n        public void clear(){                    next_vs.clear();        }\n    }\n\n    static class Edge {\n        int from=-1, v2=-1;     long weight;\n        public Edge(int vn, long w){\n            this.v2 = vn;\n            this.weight = w;\n        }\n        public Edge(int cm, int vn, long w){\n            this.from = cm;\n            this.v2 = vn;\n            this.weight = w;\n        }\n    }\n    static class Edge2 {\n        int v2;     long cost1,cost2;\n        public Edge2(int vn, long w1, long w2){\n            this.v2 = vn;\n            this.cost1 = w1;\n            this.cost2 = w2;\n        }\n    }\n\n    static class Comparator_Edge implements Comparator<Edge>{       //今は小さいのが前に出てくる\n        public int compare(Edge a, Edge b){\n            if(a.weight>b.weight) return 1;\n            else if(a.weight<b.weight) return -1;\n            else return a.v2-b.v2;\n        }\n    }\n    \n    static class Vector {\n        int x,y;\n        public Vector(int sx, int sy){\n            this.x=sx;\n            this.y=sy;\n        }\n    }\n    \n    \n    //私が好きなアルゴリズム::累積和・UF木\n    //PriorityQueueは拡張for文で出すとsortされてない順番で出てくるよ\n    //longのbit演算は1L<<posに注意\n    //long long\n    //JOIはMLEが厳しい  shortというものがあるよ。\n\tpublic static void main(String[] args) throws Exception {\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t/*\n\t\tint nt = sc.nexI();\n\t\tint nroad = sc.nexI();\n\t\tint nfes = sc.nexI();\n\t\tint nq = sc.nexI();\n\t\t\n\t\tList<List<Edge>> graph = new ArrayList<>();\n\t\tfor(int i=0; i<nt; i++){\n\t\t    List<Edge> emp = new ArrayList<>();\n\t\t    graph.add(emp);\n\t\t}\n\t\tfor(int i=0; i<nroad; i++){\n\t\t    int s1 = sc.nexI()-1;\n\t\t    int g1 = sc.nexI()-1;\n\t\t    int ln1 = sc.nexI();\n\t\t    graph.get(s1).add(new Edge(g1, ln1));\n\t\t    graph.get(g1).add(new Edge(s1, ln1));\n\t\t}\n\t\t\n\t\tlong[] d8fes = new long[nt];\n\t\tfill(d8fes, INFL);\n\t\t\n\t\tQueue<Edge> dijk = new PriorityQueue<>(new Comparator_Edge());\n\t\tfor(int i=0; i<nfes; i++){\n\t\t    int s1 = sc.nexI()-1;\n\t\t    dijk.add(new Edge(s1, 0L));\n\t\t}\n\t\twhile(dijk.size()>0){\n\t\t    Edge dw = dijk.poll();\n\t\t    if(d8fes[dw.v2]>dw.weight){\n\t\t        d8fes[dw.v2] = dw.weight;\n    \t\t    for(Edge e: graph.get(dw.v2)){\n    \t\t        long d8dw = dw.weight + e.weight;\n    \t\t        if(d8fes[e.v2]>d8dw) dijk.add(new Edge(e.v2, d8dw));\n    \t\t    }\n\t\t    }\n\t\t}\n\t\tprtspas(d8fes);*/\n\t\t\n\t\tint n = sc.nexI();\n\t\tint k = sc.nexI();\n\t\tlong ll = sc.nexL();\n\t\tlong rr = sc.nexL();\n\t\tlong[] as = new long[n];\n\t\tsc.al(as);\n\t\t\n\t\tint n1 = n/2;\n\t\tint n2 = n-n1;\n\t\t\n\t\tArrayList<ArrayList<Long>> e1ch = new ArrayList<>();\n\t\tArrayList<ArrayList<Long>> e2ch = new ArrayList<>();\n\t\t\n\t\tfor(int i=0; i<=n1; i++){\n\t\t    e1ch.add(new ArrayList<>());\n\t\t}\n\t\tfor(int i=0; i<=n2; i++){\n\t\t    e2ch.add(new ArrayList<>());\n\t\t}\n\t\t\n\t\tfor(int bit = 0; bit<flag(n1); bit++){\n\t\t    int nflaged = 0;\n\t\t    long sum_ofB = 0L;\n\t\t    for(int i=0; i<n1; i++){\n\t\t        if(isFlaged(bit, i)){\n\t\t            nflaged++;\n\t\t            sum_ofB += as[i];\n\t\t        }\n\t\t    }\n\t\t    e1ch.get(nflaged).add(sum_ofB);\n\t\t}\n\t\tfor(int bit = 0; bit<flag(n2); bit++){\n\t\t    int nflaged = 0;\n\t\t    long sum_ofB = 0L;\n\t\t    for(int i=0; i<n2; i++){\n\t\t        if(isFlaged(bit, i)){\n\t\t            nflaged++;\n\t\t            sum_ofB += as[i+n1];\n\t\t        }\n\t\t    }\n\t\t    e2ch.get(nflaged).add(sum_ofB);\n\t\t}\n\t\t\n\t\tfor(int i=0; i<=n1; i++){\n\t\t    Collections.sort(e1ch.get(i));\n\t\t}\n\t\tfor(int i=0; i<=n2; i++){\n\t\t    Collections.sort(e2ch.get(i));\n\t\t}\n\t\t\n\t\tlong ans =0L;\n\t\tfor(int i=0; i<=n1; i++){\n\t\t    int nrest = k-i;\n\t\t    if(nrest<0) continue;\n\t\t    if(nrest>n2) continue;\n\t\t    for(int j=0; j<e1ch.get(i).size(); j++){\n\t\t        int lad = biSearchMaxAL(e2ch.get(nrest), ll- e1ch.get(i).get(j)-1);\n\t\t        int rad = biSearchMaxAL(e2ch.get(nrest), rr- e1ch.get(i).get(j));\n\t\t        ans += (long)(rad-lad);\n\t\t    }\n\t\t}\n\t\tout.println(ans);\n\t    out.flush();\n\t}\n\t\n\tprivate static int INF = (int)1e8;\n\tprivate static long INFL = (long)1e17;\n\tprivate static long e97 = (long)1e9 + 7;\n\t\n\tprivate static void assertion(boolean b) { if(!b) throw new AssertionError(); }\n\n\tprivate static int abs(int a){  return (a>=0) ? a: -a;  }\n\tprivate static long abs(long a){    return (a>=0) ? a: -a;  }\n\tprivate static double abs(double a){    return (a>=0) ? a: -a;  }\n\t\n\tprivate static int min(int a, int b){   return (a>b) ? b : a;   }\n\tprivate static long min(long a, long b){    return (a>b) ? b : a;   }\n\tprivate static double min(double a, double b){    return (a>b) ? b : a;   }\n\t\n\tprivate static int max(int a, int b){   return (a>b) ? a : b;   }\n\tprivate static long max(long a, long b){    return (a>b) ? a : b;   }\n\tprivate static double max(double a, double b){    return (a>b) ? a : b;   }\n\t\n\tprivate static int minN(int... ins){\n\t\tint min = ins[0];\n\t\tfor(int i=1; i<ins.length; i++){    if(ins[i] < min) min = ins[i];  }\n\t\treturn min;\n\t}\n\tprivate static int maxN(int... ins){\n\t\tint max = ins[0];\n\t\tfor(int i=1; i<ins.length; i++){    if(ins[i] > max) max = ins[i];  }\n\t\treturn max;\n\t}\n\tprivate static long minN(long... ins){\n\t\tlong min = ins[0];\n\t\tfor(int i=1; i<ins.length; i++){    if(ins[i] < min) min = ins[i];  }\n\t\treturn min;\n\t}\n\tprivate static long maxN(long... ins){\n\t\tlong max = ins[0];\n\t\tfor(int i=1; i<ins.length; i++){    if(ins[i] > max) max = ins[i];  }\n\t\treturn max;\n\t}\n\t\n\tprivate static int minExAd(int[] dt, int ad){\n\t    int min=INF;\n\t\tfor(int i=0; i<dt.length; i++){ if((i != ad) && (dt[i] < min)) min = dt[i]; }\n\t\treturn min;\n\t}\n\tprivate static long minExAd(long[] dt, int ad){\n\t    long min=INFL;\n\t\tfor(int i=0; i<dt.length; i++){ if((i != ad) && (dt[i] < min)) min = dt[i]; }\n\t\treturn min;\n\t}\n\tprivate static int minExVal(int[] dt, int ex_val){\n\t    int min=INF;\n\t\tfor(int i=0; i<dt.length; i++){ if((dt[i] != ex_val) && (dt[i] < min)) min = dt[i]; }\n\t\treturn min;\n\t}\n\tprivate static long minExVal(long[] dt, long ex_val){\n\t    long min=INFL;\n\t\tfor(int i=0; i<dt.length; i++){ if((dt[i] != ex_val) && (dt[i] < min)) min = dt[i]; }\n\t\treturn min;\n\t}\n\tprivate static int maxExAd(int[] dt, int ad){\n\t    int max=-INF;\n\t\tfor(int i=0; i<dt.length; i++){ if((i != ad) && (dt[i] > max)) max = dt[i]; }\n\t\treturn max;\n\t}\n\tprivate static long maxExAd(long[] dt, int ad){\n\t    long max=-INFL;\n\t\tfor(int i=0; i<dt.length; i++){ if((i != ad) && (dt[i] > max)) max = dt[i]; }\n\t\treturn max;\n\t}\n\tprivate static int maxExVal(int[] dt, int ex_val){\n\t    int max=-INF;\n\t\tfor(int i=0; i<dt.length; i++){ if((dt[i] != ex_val) && (dt[i] > max)) max = dt[i]; }\n\t\treturn max;\n\t}\n\tprivate static long maxExVal(long[] dt, long ex_val){\n\t    long max=-INFL;\n\t\tfor(int i=0; i<dt.length; i++){ if((dt[i] != ex_val) && (dt[i] > max)) max = dt[i]; }\n\t\treturn max;\n\t}\n\n    private static int sumA(int[] dt){\n        int sum =0;\n        for(int e: dt){ sum += e; }\n\t\treturn sum;\n    }\n    private static long sumA(long[] dt){\n        long sum =0;\n        for(long e: dt){ sum += e; }\n\t\treturn sum;\n    }\n    private static int sumA(List<Integer> dt){\n        int sum =0;\n        for(long e: dt){ sum += e; }\n\t\treturn sum;\n    }\n\t\n\tprivate static boolean same3(long a, long b, long c){\n    \tif(a!=b) return false;\n    \tif(b!=c) return false;\n    \tif(c!=a) return false;\n    \treturn true;\n\t}\n\tprivate static boolean dif3(long a, long b, long c){\n    \tif(a==b) return false;\n    \tif(b==c) return false;\n    \tif(c==a) return false;\n    \treturn true;\n\t}\n\tprivate static boolean triangle_inequality(int a, int b, int c){\n\t    if((a+b)<c) return false;\n\t    if((b+c)<a) return false;\n\t    if((c+a)<b) return false;\n\t    return true;\n\t}\n\t\n\tprivate static double hypod(double a, double b){\n\t    return Math.sqrt(a*a+b*b);\n\t}\n\t\n\tprivate static long factorial(int n) {\n\t\tlong ans=1;\n\t\tfor(long i=n; i>0; i--){ ans*=i; }\n\t\treturn ans;\n\t}\n\t\n\tprivate static long facP(int n, long p) {\n\t\tlong ans=1;\n\t\tfor(long i=n; i>0; i--){\n\t\t    ans*=i;\n\t\t    ans %= p;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tprivate static long lcm(long m, long n){\n\t    long ans = m/gcd(m,n);\n\t    ans *= n;\n\t    return ans;\n\t}\n\t\n\tprivate static long gcd(long m, long n) {\n\t\tif(m < n) return gcd(n, m);\n\t\tif(n == 0) return m;\n\t\treturn gcd(n, m % n);\n\t}\n\t\n\tprivate static boolean is_prime(long a){\n\t    if(a==1) return false;\n\t    for(long i=2L; i<=Math.sqrt(a); i++){  if(a%i == 0) return false;  }\n\t    return true;\n\t}\n\t\n    private static long modinv(long a, long p) {    //a|p, >1に注意\n        long b = p, u = 1L, v = 0L;\n        while (b>0) {\n            long t = a / b;\n            long pe = a%b;\n            a=b;    b=pe;\n            pe= u-t*v;\n            u=v;    v=pe;\n        }\n        u %= p; \n        if (u < 0) u += p;\n        return u;\n    }\n    \n\tprivate static int pow(int n, int k){\n\t    int ans=1;\n\t    for(int i=0; i<k; i++) ans *= n;\n\t    return ans;\n\t}\n\tprivate static long pow(long n, int k){\n\t    long ans=1;\n\t    for(int i=0; i<k; i++) ans *= n;\n\t    return ans;\n\t}\n\t\n\tprivate static int pow2(int in){            return in*in;   }\n\tprivate static long pow2(long in){          return in*in;   }\n\tprivate static double pow2(double in){      return in*in;   }\n\t\n\tprivate static int getDigit2(long num){\n\t\tlong cf = 1;    int d=0;\n\t\twhile(num >= cf){   d++;    cf = (1L<<d);  }\n\t\t\n\t\treturn d; //numはd桁の数で、2^dより小さい\n\t}\n\t\n\tprivate static int getDigit10(long num){\n\t\tlong cf = 1;    int d=0;\n\t\twhile(num >= cf){   d++;    cf*=10;     }\n\t\treturn d; //numはd桁の数で、10^dより小さい\n\t}\n\t\n\tprivate static boolean isINF(int in){\n    \tif(((long)in*20)>INF) return true;\n    \telse return false;\n\t}\n\tprivate static boolean isINFL(long in){\n    \tif((in*10000)>INFL) return true;\n    \telse return false;\n\t}\n\t\n\tprivate static long pow10E97(long ob, long soeji, long p){\n\t    if(ob==0) return 0;\n\t    if(soeji==0) return 1;\n\t\tif(soeji==2) return (ob*ob)%p;\n\t\t\n\t\tint d = getDigit2(soeji);\n\t\tlong[] ob_pow_2pow = new long[d];\n\t\t\n\t\tob_pow_2pow[0] = ob;\n\t\tfor(int i=1; i<d; i++){ ob_pow_2pow[i] = (ob_pow_2pow[i-1]*ob_pow_2pow[i-1])%p;   }\n\t\t\n\t\tlong ans=1;\n\t\tfor(int i=d-1; i>=0; i--){\n\t\t\tif(soeji >= (long)(1<<i)){\n\t\t\t\tsoeji -= (long)(1<<i);\n\t\t\t\tans = (ans*ob_pow_2pow[i])%p;\n\t\t\t}\n \t\t}\n\t\treturn ans%p;\n\t}\n\tprivate static long nC2(long n){\n\t\treturn ((n*(n-1))/2L);\n\t}\n\tprivate static int divceil(int numerator, int denominator){\n\t    return (numerator+denominator-1)/denominator;\n\t}\n\tprivate static long divceil(long numerator, long denominator){\n\t    return (numerator+denominator-1L)/denominator;\n\t}\n\t\n\tprivate static int iflag(int pos){               return (1<<pos);        }\n\tprivate static long flag(long pos){               return (1L<<pos);        }\n\tprivate static boolean isFlaged(int bit, int pos){\n    \tif((bit&(1<<pos)) > 0) return true;\n    \telse return false;\n\t}\n\tprivate static boolean isFlaged(long bit, int pos){\n    \tif((bit&(1L<<pos)) > 0) return true;\n    \telse return false;\n\t}\n\tprivate static int deflag(int bit, int pos){    return bit&~(1<<pos);   }\n\tprivate static int countFlaged(int bit){\n\t    int ans=0; \n\t    for(int i=0; i<getDigit2(bit); i++){\n\t        if((bit&(1<<i)) > 0) ans++;\n\t    }\n\t    return ans;\n\t}\n\tprivate static int countFlaged(long bit){\n\t    int ans=0; \n\t    for(long i=0; i<getDigit2(bit); i++){\n\t        if((bit&(1L<<i)) > 0) ans++;\n\t    }\n\t    return ans;\n\t}\n\t\n\tprivate static void show2(int bit){\n    \tfor(int i=0; i<getDigit2(bit); i++){\n        \tif(isFlaged(bit,i)) System.out.print(\"O\");\n        \telse System.out.print(\".\");\n    \t}\n    \tSystem.out.println();\n\t}\n\t\n\tpublic static int biSearch(int[] dt, int target){\n\t\tint left=0, right=dt.length-1;\n\t\tint mid=-1;\n\t\twhile(left<=right){\n\t\t\tmid = (right+left)/2;\n\t\t\tif(dt[mid] == target) return mid;\n\t\t\tif(dt[mid] < target) left=mid+1;\n\t\t\telse right=mid-1;\n\t\t}\n\t\treturn -1;\n\t}\n\tpublic static int biSearchMax(long[] dt, long target){\n\t\tint left=-1, right=dt.length;\n\t\tint mid=-1;\n\t\t\n\t\twhile((right-left)>1){\n\t\t\tmid = left + (right-left)/2;\n\t\t\tif(dt[mid] <= target) left=mid;\n\t\t\telse right=mid;\n\t\t}\n\t\treturn left;//target以下の最大のaddress\n\t}\n\tpublic static int biSearchMaxAL(ArrayList<Long> dt, long target){\n\t\tint left=-1, right=dt.size();\n\t\tint mid=-1;\n\t\t\n\t\twhile((right-left)>1){\n\t\t\tmid = left + (right-left)/2;\n\t\t\tif(dt.get(mid) <= target) left=mid;\n\t\t\telse right=mid;\n\t\t}\n\t\treturn left;//target以下の最大のaddress\n\t}\n\t\n    private static int[] Xdir4 = {1,0,0,-1};\n    private static int[] Ydir4 = {0,1,-1,0};\n\t    \n\tprivate\tstatic int[] Xdir8 = {1,1,1,0,0,-1,-1,-1};\n\tprivate\tstatic int[] Ydir8 = {1,0,-1,1,-1,1,0,-1};\n\t\n\tprivate static boolean is_in_area(int y, int x, int h, int w){\n\t    if(y<0) return false;\n\t    if(x<0) return false;\n\t    if(y>=h) return false;\n\t    if(x>=w) return false;\n\t    return true;\n\t}\n\t\n\t\n\tstatic void show2(boolean[][] dt, int lit_x, int lit_y){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tfor(int j=0; j<dt.length; j++){\n\t\t    for(int i=0; i<dt[j].length; i++){\n\t\t\t\tif((i==lit_y) && (j==lit_x)) out.print(\"X\");\n\t\t\t\telse if(dt[j][i]) out.print(\"O\");\n\t\t\t\telse out.print(\".\");\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t\tout.flush();\n\t}\n\tstatic void show2(int[][] dt, String cmnt){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tfor(int i=0; i<dt.length; i++){\n\t\t\tfor(int j=0; j<dt[i].length; j++){\n\t\t\t\tout.print(dt[i][j]+\",\");\n\t\t\t}\n\t\t\tout.println(\"<-\"+cmnt+\":\"+i);\n\t\t}\n\t\tout.flush();\n\t}\n\tstatic void show2(long[][] dt, String cmnt){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tfor(int i=0; i<dt.length; i++){\n\t\t\tfor(int j=0; j<dt[i].length; j++){\n\t\t\t\tout.print(dt[i][j]+\",\");\n\t\t\t}\n\t\t\tout.println(\"<-\"+cmnt+\":\"+i);\n\t\t}\n\t\tout.flush();\n\t}\n\tstatic void show2(ArrayDeque<Long> dt){\t\t//上手くいかなかった時用\n\t\tlong a=0;\n\t\twhile(dt.size()>0){\n\t\t\ta=dt.removeFirst();\n\t\t\tSystem.out.print(a);\n\t\t}\n\t\tSystem.out.println(\"\\n\");\n\t}\n\tstatic void show2(List dt){\t\t//上手くいかなかった時用\n\t   \tfor(int i=0; i<dt.size(); i++){\n\t\t\tSystem.out.print(dt.get(i)+\",\");\n\t\t}\n\t\tSystem.out.println(\"\\n\");\n\t}\n\t\n\t\n\tprivate static void prtlnas(int[] as){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t    for(int i=0; i<as.length; i++){\n\t        out.println(as[i]);\n\t    }\n\t    out.flush();\n\t}\n\tprivate static void prtlnas(long[] as){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t    for(int i=0; i<as.length; i++){\n\t        out.println(as[i]);\n\t    }\n\t    out.flush();\n\t}\n\tprivate static void prtspas(int[] as){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tout.print(as[0]);\n\t    for(int i=1; i<as.length; i++){\n\t        out.print(\" \"+as[i]);\n\t    }\n\t    out.println();\n\t    out.flush();\n\t}\n\tprivate static void prtspas(long[] as){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tout.print(as[0]);\n\t    for(int i=1; i<as.length; i++){\n\t        out.print(\" \"+as[i]);\n\t    }\n\t    out.println();\n\t    out.flush();\n\t}\n\tprivate static void prtspas(List as){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tout.print(as.get(0));\n\t    for(int i=1; i<as.size(); i++){\n\t        out.print(\" \"+as.get(i));\n\t    }\n\t    out.println();\n\t    out.flush();\n\t}\n\t\n\t\n    private static void fill(boolean[] ob, boolean res){    for(int i=0; i<ob.length; i++){ ob[i] = res;    }}\n    private static void fill(int[] ob, int res){            for(int i=0; i<ob.length; i++){ ob[i] = res;    }}\n\tprivate static void fill(long[] ob, long res){          for(int i=0; i<ob.length; i++){ ob[i] = res;    }}\n\tprivate static void fill(char[] ob, char res){          for(int i=0; i<ob.length; i++){ ob[i] = res;    }}\n\tprivate static void fill(double[] ob, double res){      for(int i=0; i<ob.length; i++){ ob[i] = res;    }}\n\tprivate static void fill(boolean[][] ob,boolean res){for(int i=0;i<ob.length; i++){ for(int j=0; j<ob[0].length; j++){  ob[i][j] = res; }}}\n\tprivate static void fill(int[][] ob, int res){      for(int i=0; i<ob.length; i++){ for(int j=0; j<ob[0].length; j++){  ob[i][j] = res; }}}\n\tprivate static void fill(long[][] ob, long res){    for(int i=0; i<ob.length; i++){ for(int j=0; j<ob[0].length; j++){  ob[i][j] = res; }}}\n\tprivate static void fill(char[][] ob, char res){    for(int i=0; i<ob.length; i++){ for(int j=0; j<ob[0].length; j++){  ob[i][j] = res; }}}\n\tprivate static void fill(double[][] ob, double res){for(int i=0; i<ob.length; i++){ for(int j=0; j<ob[0].length; j++){  ob[i][j] = res; }}}\n\tprivate static void fill(int[][][] ob,int res){for(int i=0;i<ob.length;i++){for(int j=0;j<ob[0].length;j++){for(int k=0;k<ob[0][0].length;k++){ob[i][j][k]=res;}}}}\n\tprivate static void fill(long[][][] ob,long res){for(int i=0;i<ob.length;i++){for(int j=0;j<ob[0].length;j++){for(int k=0;k<ob[0][0].length;k++){ob[i][j][k]=res;}}}}\n\t\n    static class FastScanner {\n    \tprivate final InputStream in = System.in;\n    \tprivate final byte[] buffer = new byte[1024];\n    \tprivate int ptr = 0;\n    \tprivate int buflen = 0;\n    \tprivate boolean hasNextByte() {\n    \t\tif (ptr < buflen) {\n    \t\t\treturn true;\n    \t\t}else{\n    \t\t\tptr = 0;\n    \t\t\ttry {\n    \t\t\t\tbuflen = in.read(buffer);\n    \t\t\t} catch (IOException e) {\n    \t\t\t\te.printStackTrace();\n    \t\t\t}\n    \t\t\tif (buflen <= 0) {\n    \t\t\t\treturn false;\n    \t\t\t}\n    \t\t}\n    \t\treturn true;\n    \t}\n    \t\n    \tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    \tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    \tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    \tpublic String next() {\n    \t\tif (!hasNext()) throw new NoSuchElementException();\n    \t\tStringBuilder sb = new StringBuilder();\n    \t\tint b = readByte();\n    \t\twhile(isPrintableChar(b)) {\n    \t\t\tsb.appendCodePoint(b);\n    \t\t\tb = readByte();\n    \t\t}\n    \t\treturn sb.toString();\n    \t}\n    \tpublic long nexL() {\n    \t\tif (!hasNext()) throw new NoSuchElementException();\n    \t\tlong n = 0;\n    \t\tboolean minus = false;\n    \t\tint b = readByte();\n    \t\tif (b == '-') {\n    \t\t\tminus = true;\n    \t\t\tb = readByte();\n    \t\t}\n    \t\tif (b < '0' || '9' < b) {\n    \t\t\tthrow new NumberFormatException();\n    \t\t}\n    \t\twhile(true){\n    \t\t\tif ('0' <= b && b <= '9') {\n    \t\t\t\tn *= 10;\n    \t\t\t\tn += b - '0';\n    \t\t\t}else if(b == -1 || !isPrintableChar(b) || b == ':'){\n    \t\t\t\treturn minus ? -n : n;\n    \t\t\t}else{\n    \t\t\t\tthrow new NumberFormatException();\n    \t\t\t}\n    \t\t\tb = readByte();\n    \t\t}\n    \t}\n    \tpublic int nexI() {\n    \t\tlong nl = nexL();\n    \t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n    \t\treturn (int) nl;\n    \t}\n    \tpublic double nexD() { return Double.parseDouble(next());}\n    \t\n    \tpublic void al(long[] array){\n    \t   \tfor(int i=0; i<array.length; i++){\n    \t   \t    array[i] = nexL();\n    \t   \t}\n    \t   \treturn;\n    \t}\n    \tpublic void ai(int[] array){\n    \t   \tfor(int i=0; i<array.length; i++){\n    \t   \t    array[i] = nexI();\n    \t   \t}\n    \t   \treturn;\n    \t}\n    \tpublic void ai2(int[] as, int[] bs){\n    \t   \tfor(int i=0; i<as.length; i++){\n    \t   \t    as[i] = nexI();\n    \t   \t    bs[i] = nexI();\n    \t   \t}\n    \t   \treturn;\n    \t}\n    \tpublic void al2(long[] as, long[] bs){\n    \t   \tfor(int i=0; i<as.length; i++){\n    \t   \t    as[i] = nexL();\n    \t   \t    bs[i] = nexL();\n    \t   \t}\n    \t   \treturn;\n    \t}\n    \tpublic void ai3(int[] as, int[] bs, int[] cs){\n    \t   \tfor(int i=0; i<as.length; i++){\n    \t   \t    as[i] = nexI();\n    \t   \t    bs[i] = nexI();\n    \t   \t    cs[i] = nexI();\n    \t   \t}\n    \t   \treturn;\n    \t}\n    \tpublic void ad2i(int[][] as){\n    \t    for(int i=0; i<as.length; i++){\n    \t        for(int j=0; j<as[0].length; j++){\n    \t            as[i][j] = nexI();\n    \t        }\n    \t    }\n    \t    return;\n    \t}\n    \tpublic void ain(int[]... as){\n    \t    for(int i=0; i<as[0].length; i++){\n    \t        for(int j=0; j<as.length; j++){\n    \t            as[j][i] = nexI();\n    \t        }\n    \t    }\n    \t}\n    \tpublic void aln(long[]... as){\n    \t    for(int i=0; i<as[0].length; i++){\n    \t        for(int j=0; j<as.length; j++){\n    \t            as[j][i] = nexL();\n    \t        }\n    \t    }\n    \t}\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.math.BigInteger;\n \npublic class Main implements Runnable {\n\t\n\tstatic int mod = 1000000007;\n\t\n    public static void main(String[] args) {\n    \tnew Thread(null, new Main(), \"\", 1024 * 1024 * 1024).start();\n    }\n    \n    public void run() {\n        FastScanner sc = new FastScanner();\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        long L = sc.nextLong();\n        long R = sc.nextLong();\n        long[] a = sc.nextlongArray(n);\n\n        System.out.println(coinCombination(a,k,L,R));\n    }\n    \n\t//L円以上R円以下になる丁度k枚のコインの選び方の個数\n\tstatic long coinCombination(long[] a, int k, long L, long R){\n        int N = a.length;\n        class SumList extends ArrayList<Long>{\n\t\t\tprivate static final long serialVersionUID = 1L;\n        }\n        \n        //半分全列挙\n        //S:0 - (N/2)-1\n        //T:N/2 - N-1\n        int Tnum = N-(N/2);\n        SumList[] TL = new SumList[Math.min(Tnum,k)+1];\n        for(int i=0;i<TL.length;i++){\n        \tTL[i] = new SumList();\n        }\n        int Tstt = N/2;\n        for(int S = (1<<Tnum) -1;S>=0;S--){\n            long sum = 0;\n            int num = 0;\n            for(int i=0;i<Tnum;i++){\n                if(((S>>i)&1) == 1){\n                    sum += a[Tstt+i];\n                    num++;\n                }\n            }\n            if(sum<=R && num <= k){\n                TL[num].add(sum);\n            }\n        }\n\n        for(SumList l:TL){\n        \tCollections.sort(l);\n        }\n        \n        long ans = 0;\n        for(int S = (1<<(N/2)) -1;S>=0;S--){\n            long sum = 0;\n            int num = 0;\n            for(int i=0;i<N/2;i++){\n                if(((S>>i)&1) == 1){\n                    sum += a[i];\n                    num++;\n                }\n            }\n\n            if(sum<=R && 0 <= k-num && k-num < TL.length && !TL[k-num].isEmpty()){\t//[k-num]に入るべき要素が全て>Rで空のことがある\n            \tint min = lowerBound(TL[k-num],L-sum);\n            \tint max = upperBound(TL[k-num],R-sum);\n            \tans += max - min;\n            }\n        }\n        \n        return ans;\n\t}\n\t\n\tstatic int upperBound(ArrayList<Long> a, long key){\n\t\tint idx = Collections.binarySearch(a, key, (x,y)->x.compareTo(y)>0?1:-1);\n\t\t\n\t\tif(idx<0){\n\t\t\tidx = ~idx;\n\t\t}\n\t\t\n\t\treturn idx;\n\t}\n\tstatic int lowerBound(ArrayList<Long> a, long key){\n\t\tint idx = Collections.binarySearch(a, key, (x,y)->x.compareTo(y)>=0?1:-1);\n\t\t\n\t\tif(idx<0){\n\t\t\tidx = ~idx;\n\t\t}\n\t\t\n\t\treturn idx;\n\t}\n\t\n}\n\n\n\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic int[] nextintArray(int n){\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic long[] nextlongArray(int n){\n\t\tlong[] a = new long[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic Integer[] nextIntegerArray(int n){\n\t\tInteger[] a = new Integer[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\nimport java.util.Comparator;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author silviase\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CCP solver = new CCP();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CCP {\n        @SuppressWarnings(\"unchecked\")\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            long l = in.nextLong();\n            long r = in.nextLong();\n\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = in.nextLong();\n\n            int flen = n / 2;\n            int slen = n - n / 2;\n\n            ArrayList<Long>[] fir = new ArrayList[flen + 1];\n            ArrayList<Long>[] sec = new ArrayList[slen + 1];\n            for (int i = 0; i < fir.length; i++) fir[i] = new ArrayList<>();\n            for (int i = 0; i < sec.length; i++) sec[i] = new ArrayList<>();\n            for (int i = 0; i < 1 << flen; i++) {\n                int cnt = 0;\n                long sum = 0;\n                for (int j = 0; j < flen; j++) {\n                    if ((i & (1 << j)) != 0) {\n                        cnt++;\n                        sum += a[j];\n                    }\n                }\n                fir[cnt].add(sum);\n            }\n            for (int i = 0; i < 1 << slen; i++) {\n                int cnt = 0;\n                long sum = 0;\n                for (int j = 0; j < slen; j++) {\n                    if ((i & (1 << j)) != 0) {\n                        cnt++;\n                        sum += a[j + flen];\n                    }\n                }\n                sec[cnt].add(sum);\n            }\n            for (int i = 0; i < flen; i++) fir[i].sort(Comparator.naturalOrder());\n            for (int i = 0; i < slen; i++) sec[i].sort(Comparator.naturalOrder());\n            // ここまでで選び方の列挙ができた\n\n            // それぞれについて二分探索をかける\n            long sum = 0;\n            for (int i = 0; i < fir.length; i++) {\n                try {\n                    for (int j = 0; j < fir[i].size(); j++) {\n                        long key = fir[i].get(j);\n                        sum += -binarySearch(sec[k - i], l - 1 - key) + binarySearch(sec[k - i], r - key);\n                    }\n                } catch (ArrayIndexOutOfBoundsException ignored) {\n                }\n            }\n            out.println(sum);\n        }\n\n        int binarySearch(ArrayList<Long> list, long key) {\n            int ng = -1;\n            int ok = list.size();\n            while (Math.abs(ok - ng) > 1) {\n                int mid = (ok + ng) / 2;\n                if (key < list.get(mid)) {\n                    ok = mid;\n                } else {\n                    ng = mid;\n                }\n            }\n            return ok;\n        }\n\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace DPL4_B\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int N, K;\n            long L, R;\n            var t = scan;\n            N = (int)t[0]; K = (int)t[1]; L = t[2]; R = t[3];\n            var a = scan;\n\n            var n = N / 2;\n            var G = new List<long>[n + 1];\n            for (int i = 0; i <= n; i++)\n            {\n                G[i] = new List<long>();\n            }\n\n            for (int i = 0; i < 1 << n; i++)\n            {\n                int k = 0; long p = 0;\n                for (int j = 0; j < n; j++)\n                {\n                    if ((i >> j & 1) == 1)\n                    {\n                        k++;\n                        p += a[j];\n                    }\n                }\n                G[k].Add(p);\n            }\n            var H = new long[n + 1][];\n\n            for (int i = 0; i <= n; i++)\n            {\n                H[i] = G[i].ToArray();\n                Array.Sort(H[i]);\n            }\n\n            long ans = 0;\n            for (int i = 0; i < 1 << (N - n); i++)\n            {\n                int k = 0; long p = 0;\n                for (int j = 0; j < N - n; j++)\n                {\n                    if ((i >> j & 1) == 1)\n                    {\n                        k++;\n                        p += a[n + j];\n                    }\n                }\n                if (k <= K && K - k <= n)\n                {\n                    ans += UpperBound(H[K - k], R - p) - LowerBound(H[K - k], L - p);\n                }\n\n            }\n\n            Console.WriteLine(ans);\n        }\n\n        static int LowerBound(long[] arr, long val)\n        {\n            int low = 0, high = arr.Length;\n            int mid;\n\n            while (low < high)\n            {\n                mid = ((high - low) >> 1) + low;\n                if (arr[mid] < val) low = mid + 1;\n                else high = mid;\n            }\n            return low;\n        }\n\n\n        static int UpperBound(long[] arr, long val)\n        {\n            int low = 0, high = arr.Length;\n            int mid;\n\n            while (low < high)\n            {\n                mid = ((high - low) >> 1) + low;\n                if (arr[mid] <= val) low = mid + 1;\n                else high = mid;\n            }\n            return low;\n        }\n\n        static long[] scan { get { return Array.ConvertAll(Console.ReadLine().Split(), long.Parse); } }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace DPL4_B\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int N, K;\n            long L, R;\n            var t = scan;\n            N = (int)t[0]; K = (int)t[1]; L = t[2]; R = t[3];\n            var a = scan;\n\n            var n = N / 2;\n            var G = new List<long>[n + 1];\n            for (int i = 0; i <= n; i++)\n            {\n                G[i] = new List<long>();\n            }\n\n            for (int i = 0; i < 1 << n; i++)\n            {\n                int k = 0; long p = 0;\n                for (int j = 0; j < n; j++)\n                {\n                    if ((i >> j & 1) == 1)\n                    {\n                        k++;\n                        p += a[j];\n                    }\n                }\n                G[k].Add(p);\n            }\n            var H = new long[n + 1][];\n\n            for (int i = 0; i <= n; i++)\n            {\n                H[i] = G[i].ToArray();\n                Array.Sort(H[i]);\n            }\n\n            long ans = 0;\n            for (int i = 0; i < 1 << (N - n); i++)\n            {\n                int k = 0; long p = 0;\n                for (int j = 0; j < N - n; j++)\n                {\n                    if ((i >> j & 1) == 1)\n                    {\n                        k++;\n                        p += a[n + j];\n                    }\n                }\n                if (k <= K && K - k <= n)\n                {\n                    ans += UpperBound(H[K - k], R - p) - LowerBound(H[K - k], L - p);\n                }\n\n            }\n\n            Console.WriteLine(ans);\n        }\n\n        static int LowerBound(long[] arr, long val)\n        {\n            int low = 0, high = arr.Length;\n            int mid;\n\n            while (low < high)\n            {\n                mid = ((high - low) >> 1) + low;\n                if (arr[mid] < val) low = mid + 1;\n                else high = mid;\n            }\n            return low;\n        }\n\n\n        static int UpperBound(long[] arr, long val)\n        {\n            int low = 0, high = arr.Length;\n            int mid;\n\n            while (low < high)\n            {\n                mid = ((high - low) >> 1) + low;\n                if (arr[mid] <= val) low = mid + 1;\n                else high = mid;\n            }\n            return low;\n        }\n\n        static long[] scan { get { return Array.ConvertAll(Console.ReadLine().Split(), long.Parse); } }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        string[] str = Console.ReadLine().Split(' ');\n        int N = int.Parse(str[0]);\n        int K = int.Parse(str[1]);\n        long L = long.Parse(str[2]);\n        long R = long.Parse(str[3]);\n        long[] A = new long[N/2];\n        str = Console.ReadLine().Split(' ');\n        for(int i=0;i<N/2;i++){\n            A[i] = long.Parse(str[i]);\n        }\n        long[] B = new long[N-N/2];\n        for(int i=0;i<N-N/2;i++){\n            B[i] = long.Parse(str[i+N/2]);\n        }\n        List<long>[] AL = new List<long>[N/2+1];\n        for(int i=0;i<N/2+1;i++){\n            AL[i] = new List<long>();\n        }\n        List<long>[] BL = new List<long>[N-N/2+1];\n        for(int i=0;i<N-N/2+1;i++){\n            BL[i] = new List<long>();\n        }\n        for(int i=0;i<1<<(N/2);i++){\n            long V = 0;\n            int c = 0;\n            for(int j=0;j<N/2;j++){\n                if((i & (1 << j)) != 0){\n                    c++;\n                    V += A[j];\n                }\n            }\n            AL[c].Add(V);\n        }\n        for(int i=0;i<1<<(N-N/2);i++){\n            long V = 0;\n            int c = 0;\n            for(int j=0;j<N-N/2;j++){\n                if((i & (1 << j)) != 0){\n                    c++;\n                    V += B[j];\n                }\n            }\n            BL[c].Add(V);\n        }\n        long[][] AA = new long[N/2+1][];\n        for(int i=0;i<N/2+1;i++){\n            AA[i] = AL[i].ToArray();\n            Array.Sort(AA[i]);\n        }\n        long[][] BA = new long[N-N/2+1][];\n        for(int i=0;i<N-N/2+1;i++){\n            BA[i] = BL[i].ToArray();\n            Array.Sort(BA[i]);\n        }\n        long count = 0;\n        for(int l=Math.Max(0,K-BL.Length+1);K-l>=Math.Max(0,K-AL.Length+1);l++){\n            int lp = 0;\n            int rp = 0;\n            int q = BA[K-l].Length-1;\n            for(;q>=0;q--){\n                while(lp < AA[l].Length && AA[l][lp] + BA[K-l][q] < L){\n                    lp++;\n                }\n                while(rp < AA[l].Length && AA[l][rp] + BA[K-l][q] <= R){\n                    rp++;\n                }\n                count += rp - lp;\n            }\n        }\n        sb.Append(count+\"\\n\");\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AOJ_DPL_4_B\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var NKTR = ReadLong();\n            long N = NKTR[0];\n            int K = (int)NKTR[1];\n            long L = NKTR[2];\n            long R = NKTR[3];\n\n            long[] A = ReadLong();\n\n            long[] A1 = A.Take((int)N / 2).ToArray();   //前半\n            long[] A2 = A.Skip((int)N / 2).ToArray();   //後半\n\n            //前半の合計と枚数\n            List<long>[] sumA1 = new List<long>[A1.Length + 1].Select(x=>new List<long>()).ToArray();\n            foreach (var c in BitSearch(A1.Length))\n            {\n                long sum = 0;\n                foreach (var i in c)\n                {\n                    sum += A1[i];\n                }\n                sumA1[c.Length].Add(sum);\n            }\n\n            //後半の合計と枚数\n            List<long>[] sumA2 = new List<long>[A2.Length + 1].Select(x=>new List<long>()).ToArray();\n            foreach (var c in BitSearch(A2.Length))\n            {\n                long sum = 0;\n                foreach (var i in c)\n                {\n                    sum += A2[i];\n                }\n                sumA2[c.Length].Add(sum);\n            }\n\n            //後半のソート\n            long[][] sortedA2 = new long[A2.Length + 1][];\n            for (int i = 0; i < A2.Length + 1; i++)\n            {\n                sortedA2[i] = sumA2[i].OrderBy(x => x).ToArray();\n            }\n\n            //列挙 O(K*NlogN)\n            long ans = 0;\n            for (int k = 0; k <= K; k++)\n            {\n                int k1 = k;\n                int k2 = K - k;\n\n                if (k1 >= sumA1.Length) continue;\n                if (k2 >= sumA2.Length) continue;\n\n                foreach (var c1 in sumA1[k1])\n                {\n                    long r1 = L - c1;\n                    long r2 = R - c1;\n\n                    ans += UpperBound(sortedA2[k2], r2) - LowerBound(sortedA2[k2], r1);\n                }\n            }\n\n            Console.WriteLine(ans);\n            Console.ReadKey();\n        }\n\n        static int[] ReadInt()\n        {\n            int[] ret = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            return ret;\n        }\n        static long[] ReadLong()\n        {\n            long[] ret = Console.ReadLine().Split().Select(long.Parse).ToArray();\n            return ret;\n        }\n\n        /// <summary>\n        /// ビット全探索　メソッドバージョン\n        /// </summary>\n        /// <param name=\"n\"></param>\n        /// <returns>含むindexが返ってくる</returns>\n        public static int[][] BitSearch(int n)\n        {\n            int[][] ret = new int[1 << n][];\n            for (int bit = 0; bit < (1 << n); ++bit)\n            {\n                List<int> S = new List<int>();\n                for (int i = 0; i < n; i++)\n                {\n                    if ((bit & (1 << i)) != 0)\n                    {\n                        S.Add(i);\n                    }\n                }\n\n                ret[bit] = S.ToArray();\n            }\n            return ret;\n        }\n\n        /// <summary>\n        /// 二分探索 vを超える最低\n        /// </summary>\n        /// <typeparam name=\"T\"></typeparam>\n        /// <param name=\"a\"></param>\n        /// <param name=\"v\"></param>\n        /// <returns></returns>\n        public static int LowerBound<T>(T[] a, T v)\n        {\n            return LowerBound(a, v, Comparer<T>.Default);\n        }\n\n        public static int LowerBound<T>(T[] a, T v, Comparer<T> cmp)\n        {\n            var l = 0;\n            var r = a.Length - 1;\n            while (l <= r)\n            {\n                var mid = l + (r - l) / 2;\n                var res = cmp.Compare(a[mid], v);\n                if (res == -1) l = mid + 1;\n                else r = mid - 1;\n            }\n            return l;\n        }\n\n        /// <summary>\n        /// 二分探索 vを超えない最高\n        /// </summary>\n        /// <typeparam name=\"T\"></typeparam>\n        /// <param name=\"a\"></param>\n        /// <param name=\"v\"></param>\n        /// <returns></returns>\n        public static int UpperBound<T>(T[] a, T v)\n        {\n            return UpperBound(a, v, Comparer<T>.Default);\n        }\n\n        public static int UpperBound<T>(T[] a, T v, Comparer<T> cmp)\n        {\n            var l = 0;\n            var r = a.Length - 1;\n            while (l <= r)\n            {\n                var mid = l + (r - l) / 2;\n                var res = cmp.Compare(a[mid], v);\n                if (res <= 0) l = mid + 1;\n                else r = mid - 1;\n            }\n            return l;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        string[] str = Console.ReadLine().Split(' ');\n        int N = int.Parse(str[0]);\n        int K = int.Parse(str[1]);\n        long L = long.Parse(str[2]);\n        long R = long.Parse(str[3]);\n        long[] A = new long[N/2];\n        str = Console.ReadLine().Split(' ');\n        for(int i=0;i<N/2;i++){\n            A[i] = long.Parse(str[i]);\n        }\n        long[] B = new long[N-N/2];\n        for(int i=0;i<N-N/2;i++){\n            B[i] = long.Parse(str[i+N/2]);\n        }\n        List<long>[] AL = new List<long>[N/2+1];\n        for(int i=0;i<N/2+1;i++){\n            AL[i] = new List<long>();\n        }\n        List<long>[] BL = new List<long>[N-N/2+1];\n        for(int i=0;i<N-N/2+1;i++){\n            BL[i] = new List<long>();\n        }\n        for(int i=0;i<1<<(N/2);i++){\n            long V = 0;\n            int c = 0;\n            for(int j=0;j<N/2;j++){\n                if((i & (1 << j)) != 0){\n                    c++;\n                    V += A[j];\n                }\n            }\n            AL[c].Add(V);\n        }\n        for(int i=0;i<1<<(N-N/2);i++){\n            long V = 0;\n            int c = 0;\n            for(int j=0;j<N-N/2;j++){\n                if((i & (1 << j)) != 0){\n                    c++;\n                    V += B[j];\n                }\n            }\n            BL[c].Add(V);\n        }\n        long[][] AA = new long[N/2+1][];\n        for(int i=0;i<N/2+1;i++){\n            AA[i] = AL[i].ToArray();\n            Array.Sort(AA[i]);\n        }\n        long[][] BA = new long[N-N/2+1][];\n        for(int i=0;i<N-N/2+1;i++){\n            BA[i] = BL[i].ToArray();\n            Array.Sort(BA[i]);\n        }\n        long count = 0;\n        for(int l=Math.Max(0,K-BL.Length+1);K-l>=Math.Max(0,K-AL.Length+1);l++){\n            int lp = 0;\n            int rp = 0;\n            int q = BA[K-l].Length-1;\n            for(;q>=0;q--){\n                while(lp < AA[l].Length && AA[l][lp] + BA[K-l][q] < L){\n                    lp++;\n                }\n                while(rp < AA[l].Length && AA[l][rp] + BA[K-l][q] < R){\n                    rp++;\n                }\n                count += rp - lp;\n            }\n        }\n        sb.Append(count+\"\\n\");\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "n, k, l, r = gets.split.map(&:to_i)\na = gets.split.map(&:to_i)\nsum = a.inject(:+)\nif k > n / 2\n  k = n - k\n  l, r = sum - r, sum - l\nend\nb = a[0..n/2]\nc = a[n/2+1..-1]\n\nhb = (0..b.size).map { Hash.new(0) }\nhb[0][0] = 1\nsubset_sum = Array.new(2**b.size, 0)\none_count = Array.new(2**b.size, 0)\n(1..2**b.size-1).each do |x|\n  i = Math.log2((x ^ (x - 1)) + 1).to_i - 1\n  y = x & (x - 1)\n  subset_sum[x] = subset_sum[y] + b[i]\n  one_count[x] = one_count[y] + 1\n  hb[one_count[x]][subset_sum[x]] += 1\nend\n\nhc = (0..c.size).map { Hash.new(0) }\nhc[0][0] = 1\nsubset_sum = Array.new(2**c.size, 0)\none_count = Array.new(2**c.size, 0)\n(1..2**c.size-1).each do |x|\n  i = Math.log2((x ^ (x - 1)) + 1).to_i - 1\n  y = x & (x - 1)\n  subset_sum[x] = subset_sum[y] + c[i]\n  one_count[x] = one_count[y] + 1\n  hc[one_count[x]][subset_sum[x]] += 1\nend\n\nanswer = 0\n(0..k).each do |m|\n  next if !hb[m] || !hc[k - m]\n  keys1 = hb[m].keys.sort\n  keys2 = hc[k - m].keys.sort\n  count_accum = [0]\n  keys2.each {|x| count_accum << count_accum[-1] + hc[k - m][x] }\n\n  keys1.each do |x|\n    break if x > r\n    i = (0..keys2.size-1).bsearch {|i| l <= x + keys2[i] } || keys2.size\n    j = ((0..keys2.size-1).bsearch {|j| r <  x + keys2[j] } || keys2.size) - 1\n    answer += hb[m][x] * (count_accum[j + 1] - count_accum[i])\n  end\nend\np answer\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc configure(scanner *bufio.Scanner) {\n\tscanner.Split(bufio.ScanWords)\n\tscanner.Buffer(make([]byte, 1000005), 1000005)\n}\nfunc getNextString(scanner *bufio.Scanner) string {\n\tscanned := scanner.Scan()\n\tif !scanned {\n\t\tpanic(\"scan failed\")\n\t}\n\treturn scanner.Text()\n}\nfunc getNextInt(scanner *bufio.Scanner) int {\n\ti, _ := strconv.Atoi(getNextString(scanner))\n\treturn i\n}\nfunc getNextInt64(scanner *bufio.Scanner) int64 {\n\ti, _ := strconv.ParseInt(getNextString(scanner), 10, 64)\n\treturn i\n}\nfunc getNextFloat64(scanner *bufio.Scanner) float64 {\n\ti, _ := strconv.ParseFloat(getNextString(scanner), 64)\n\treturn i\n}\nfunc main() {\n\tfp := os.Stdin\n\twfp := os.Stdout\n\textra := 0\n\tif os.Getenv(\"I\") == \"IronMan\" {\n\t\tfp, _ = os.Open(os.Getenv(\"END_GAME\"))\n\t\textra = 100\n\t}\n\tscanner := bufio.NewScanner(fp)\n\tconfigure(scanner)\n\twriter := bufio.NewWriter(wfp)\n\tdefer func() {\n\t\tr := recover()\n\t\tif r != nil {\n\t\t\tfmt.Fprintln(writer, r)\n\t\t}\n\t\twriter.Flush()\n\t}()\n\tsolve(scanner, writer)\n\tfor i := 0; i < extra; i++ {\n\t\tfmt.Fprintln(writer, \"-----------------------------------\")\n\t\tsolve(scanner, writer)\n\t}\n}\nfunc solve(scanner *bufio.Scanner, writer *bufio.Writer) {\n\tn := getNextInt(scanner)\n\tk := getNextInt(scanner)\n\tl := getNextInt64(scanner)\n\tr := getNextInt64(scanner)\n\taa := make([]int64, n)\n\tfor i := 0; i < n; i++ {\n\t\taa[i] = getNextInt64(scanner)\n\t}\n\tdp1 := halfdp(n>>1, aa[:n>>1])\n\tdp2 := halfdp(n-n>>1, aa[n>>1:])\n\tkk1 := make([][]int64, n+1)\n\tkk2 := make([][]int64, n+1)\n\tfor i := 0; i < len(dp1); i++ {\n\t\tkk1[dp1[i].k] = append(kk1[dp1[i].k], dp1[i].a)\n\t}\n\tfor i := 0; i < len(dp2); i++ {\n\t\tkk2[dp2[i].k] = append(kk2[dp2[i].k], dp2[i].a)\n\t}\n\tvar ans int64\n\tfor i := 0; i < k+1; i++ {\n\t\tans += countless(r+1, kk1[i], kk2[k-i]) - countless(l, kk1[i], kk2[k-i])\n\t}\n\tfmt.Fprintln(writer, ans)\n}\n\ntype pair struct {\n\tk int\n\ta int64\n}\n\nfunc halfdp(n int, aa []int64) []pair {\n\tbb := make([]pair, 1)\n\tfor i := 0; i < n; i++ {\n\t\tbb = merge(aa[i], bb)\n\t}\n\treturn bb\n}\n\nfunc merge(a int64, aa []pair) []pair {\n\tn := len(aa)\n\tbb := make([]pair, n)\n\tfor i := 0; i < n; i++ {\n\t\tbb[i].k = aa[i].k + 1\n\t\tbb[i].a = aa[i].a + a\n\t}\n\tcc := make([]pair, n<<1)\n\tj := 0\n\tk := 0\n\tfor i := 0; i < n<<1; i++ {\n\t\tif isfirst(j, k, aa, bb) {\n\t\t\tcc[i].k = aa[j].k\n\t\t\tcc[i].a = aa[j].a\n\t\t\tj++\n\t\t\tcontinue\n\t\t}\n\t\tcc[i].k = bb[k].k\n\t\tcc[i].a = bb[k].a\n\t\tk++\n\t}\n\treturn cc\n}\n\nfunc isfirst(a, b int, aa, bb []pair) bool {\n\tif a >= len(aa) {\n\t\treturn false\n\t}\n\tif b >= len(bb) {\n\t\treturn true\n\t}\n\treturn aa[a].a <= bb[b].a\n}\n\nfunc countless(n int64, kk1, kk2 []int64) int64 {\n\tvar ans int64\n\tr := len(kk2) - 1\n\tfor l := 0; l < len(kk1); l++ {\n\t\tfor r >= 0 && kk1[l]+kk2[r] >= n {\n\t\t\tr--\n\t\t}\n\t\tans += int64(r + 1)\n\t}\n\treturn ans\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.algorithm, std.conv, std.array, std.string, std.math, std.typecons, std.numeric;\n\nvoid main()\n{\n    auto nklr = readln.split.to!(long[]);\n    auto N = nklr[0];\n    auto K = nklr[1];\n    auto L = nklr[2];\n    auto R = nklr[3];\n    auto as = readln.split.to!(long[]);\n\n    if (N == 1) {\n        writeln(L <= as[0] && as[0] <= R ? 1 : 0);\n        return;\n    }\n\n    long[][] bs, cs;\n    bs.length = 21;\n    cs.length = 21;\n    void make(size_t i, size_t j, long c, long s, long[][] xs) {\n        if (i == j) return;\n        make(i+1, j, c, s, xs);\n        xs[c+1] ~= s + as[i];\n        make(i+1, j, c+1, s + as[i], xs);\n    }\n    make(0, as.length/2, 0, 0, bs);\n    foreach (ref b; bs) sort(b);\n    make(as.length/2, as.length, 0, 0, cs);\n    foreach (ref c; cs) sort(c);\n\n    long res;\n    foreach (i, bb; bs) {\n        if (K-i.to!int < 0 || K-i.to!int > 20) continue;\n        auto cc = cs[K-i.to!int];\n        if (cc.empty) continue;\n        foreach (b; bb) {\n            if (cc[0] + b > R) continue;\n            if (cc[$-1] + b < L) continue;\n            int s, t;\n            if (cc[0] + b >= L) {\n                s = 0;\n            } else {\n                int l, r = cc.length.to!int;\n                while (l+1 < r) {\n                    auto m = (l+r)/2;\n                    if (cc[m] + b >= L) {\n                        r = m;\n                    } else {\n                        l = m;\n                    }\n                }\n                s = r;\n            }\n            int l, r = cc.length.to!int;\n            while (l+1 < r) {\n                auto m = (l+r)/2;\n                if (cc[m] + b > R) {\n                    r = m;\n                } else {\n                    l = m;\n                }\n            }\n            t = r;\n            res += t-s;\n        }\n    }\n    if (bs.length > K) foreach (b; bs[K]) if (L <= b && b <= R) ++res;\n    if (cs.length > K) foreach (c; cs[K]) if (L <= c && c <= R) ++res;\n    writeln(res);\n}\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left, bisect_right\nfrom itertools import combinations\n\n\nif __name__ == \"__main__\":\n    N, K, L, R = map(lambda x: int(x), input().split())\n    coins = list(map(lambda x: int(x), input().split()))\n\n    N_half = N // 2\n    c1 = [list(map(sum, combinations(coins[:N_half], i))) for i in range(0, N_half + 1)]\n    c2 = [list(map(sum, combinations(coins[N_half:], i)))\n          for i in range(0, N - N_half + 1)]\n    for i in range(0, N - N_half + 1):\n        c2[i].sort()\n\n    ans = 0\n    for i in range(0, K + 1):\n        if K - i < 0 or K - i > N - N_half or i > N_half:\n            continue\n        for a in c1[i]:\n            low = bisect_left(c2[K - i], L - a)  # type: ignore\n            high = bisect_right(c2[K - i], R - a)  # type: ignore\n            ans += high - low\n\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef bisect(ls, value):\n    l, r = -1, len(ls)\n    while r-l>1:\n        mid = (l+r)//2\n        if ls[mid] <= value:\n            l = mid\n        else:\n            r = mid\n    return r\n\n\ndef main():\n    n, K, L, R = map(int, sys.stdin.readline().split())\n    a = tuple(map(int, sys.stdin.readline().split()))\n    m = n // 2\n    ls = [[] for _ in range(m + 1)]\n    for i in range(1 << m):\n        cnt = 0\n        val = 0\n        for j in range(m):\n            if i >> j & 1:\n                cnt += 1\n                val += a[j]\n        ls[cnt].append(val)\n    for i in range(m + 1):\n        ls[i].sort()\n    ans = 0\n    for i in range(1 << n - m):\n        cnt = 0\n        val = 0\n        for j in range(n - m):\n            if i >> j & 1:\n                cnt += 1\n                val += a[m + j]\n        if K - m <= cnt <= K:\n            ans += bisect(ls[K - cnt], R - val) - bisect(ls[K - cnt], L - val - 1)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from itertools import combinations as C\nN, K, L, R= map(int, input().split())\na = list(map(int, input().split()))\nv = [i for i in range(N)]\nans = 0\nfor ii in list(C(v, K)):\n    tmp = 0\n    flag = True\n    for i in ii:\n        tmp += a[i]\n        if tmp > R:\n            flag = False\n            break\n    if flag and tmp >= L:\n        ans += 1\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\nimport bisect\nimport math\n\n\ndef combinations_count(n, r):\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef main():\n    n, K, L, R = map(int, sys.stdin.readline().split())\n    a = tuple(map(int, sys.stdin.readline().split()))\n    m = n//2\n    ls = [[0 for _ in range(combinations_count(m, i))] for i in range(m+1)]\n    index = [0]*(m+1)\n    for i in range(1 << m):\n        cnt = 0\n        val = 0\n        for j in range(m):\n            if i >> j & 1:\n                cnt += 1\n                val += a[j]\n        ls[cnt][index[cnt]] = val\n        index[cnt] += 1\n    for i in range(m+1):\n        ls[i].sort()\n    ans = 0\n    for i in range(1 << n-m):\n        cnt = 0\n        val = 0\n        for j in range(n-m):\n            if i >> j & 1:\n                cnt += 1\n                val += a[m+j]\n        if K-m <= cnt <= K:\n            ans += bisect.bisect_right(ls[K-cnt], R-val) - bisect.bisect_right(ls[K-cnt], L-val-1)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport bisect\n\n\ndef main():\n    n, K, L, R = map(int, sys.stdin.readline().split())\n    a = tuple(map(int, sys.stdin.readline().split()))\n    m = n//2\n    ls = [[] for _ in range(m+1)]\n    for i in range(1 << m):\n        cnt = 0\n        val = 0\n        for j in range(m):\n            if i >> j & 1:\n                cnt += 1\n                val += a[j]\n        bisect.insort_left(ls[cnt], val)\n    for i in range(m):\n        ls[i].sort()\n    ans = 0\n    for i in range(1 << n-m):\n        cnt = 0\n        val = 0\n        for j in range(n-m):\n            if i >> j & 1:\n                cnt += 1\n                val += a[m+j]\n        if K-m <= cnt <= K:\n            ans += bisect.bisect_right(ls[K-cnt], R-val) - bisect.bisect_right(ls[K-cnt], L-val-1)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "# 半分全列挙\nfrom bisect import bisect, bisect_left\nN, K, L, R = map(int, input().split())\n*A, = map(int, input().split())\n\n\ndef enum(A):\n    n = len(A)\n    ret = [[] for _ in [0]*(N+1)]\n    for i in range(1 << n):\n        sun = 0\n        cnt = 0\n        for j, a in enumerate(A):\n            if i >> j & 1:\n                sun += a\n                cnt += 1\n        ret[cnt].append(sun)\n\n    return [sorted(r) for r in ret]\n\n\nS1 = enum(A[:N//2])\nS2 = enum(A[N//2:])\n\nans = 0\nfor k, _S1 in enumerate(S1):\n    if k == K:\n        l = bisect_left(_S1, L)\n        r = bisect(_S1, R)\n        ans += r-l\n        continue\n    if K-k < 0:\n        break\n\n    _S2 = S2[K-k]\n    for a in _S1:\n        l = bisect_left(_S2, L-a)\n        r = bisect(_S2, R-a)\n        ans += r-l\n\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "#!python3\n\nfrom bisect import bisect_left\nfrom collections import defaultdict\nfrom itertools import accumulate\n\niim = lambda: map(int, input().rstrip().split())\n\ndef resolve():\n    N, K, L, R = iim()\n    A = list(iim())\n\n    n2 = N // 2\n\n    def calc(a, b):\n        d0 = [[] for i in range(K)]\n        for i in range(a, b):\n            x = A[i]\n            for k in range(K-1, 0, -1):\n                d1 = d0[k-1]\n                d2 = d0[k]\n                for v1 in d1:\n                    v1 += x\n                    if v1 > R: continue\n                    d2.append(v1)\n            d0[0].append(x)\n        return d0\n\n    da = calc(0, n2)\n    db = calc(n2, N)\n\n    for i in range(K-1):\n        #da[i].sort(reverse=True)\n        db[i].sort()\n\n    ans = 0\n    for k in range(1, K):\n        j = K-k-1\n        d1 = da[k-1]\n        d2 = db[j]\n\n        pos1 = 0\n        for k1 in d1:\n            #pos1 = bisect_left(d2, L-k1, pos1)\n            pos1 = bisect_left(d2, L-k1)\n            pos2 = bisect_left(d2, R+1-k1, pos1)\n            #print(k, k1, num1, pos1, pos2)\n\n            ans += pos2 - pos1\n\n    for dx in [da[-1], db[-1]]:\n        for val in dx:\n            if L <= val <= R:\n                ans += 1\n    print(ans)\n\nif __name__ == \"__main__\":\n    resolve()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport bisect\n\n\ndef main():\n    n, K, L, R = map(int, sys.stdin.readline().split())\n    a = tuple(map(int, sys.stdin.readline().split()))\n    m = n//2\n    ls = [[] for _ in range(m+1)]\n    for i in range(1 << m):\n        cnt = 0\n        val = 0\n        for j in range(m):\n            if i >> j & 1:\n                cnt += 1\n                val += a[j]\n        bisect.insort_left(ls[cnt], val)\n    ans = 0\n    for i in range(1 << n-m):\n        cnt = 0\n        val = 0\n        for j in range(n-m):\n            if i >> j & 1:\n                cnt += 1\n                val += a[m+j]\n        if K-m <= cnt <= K:\n            ans += bisect.bisect_right(ls[K-cnt], R-val) - bisect.bisect_right(ls[K-cnt], L-val-1)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "import bisect \nfrom itertools import combinations\n\ncoins = []\nline = input()\nn, k, l, r = list(map(int, line.split()))\nline = input()\ncoins = list(map(int, line.split()))\n\ndef solve():\n    n2 = n // 2\n    c1 = [ list(map(sum, combinations(coins[:n2], z))) for z in range(0, n2 + 1) ]\n    c2 = [ list(map(sum, combinations(coins[n2:], z))) for z in range(0, n - n2 + 1) ]\n    for i in range(0, n - n2 + 1):\n        c2[i].sort()\n    ans = 0\n    for i in range(0, k + 1):\n        if k - i < 0 or k - i > n - n2 or i > n2:\n            continue\n        for a in c1[i]:\n            low = bisect.bisect_left(c2[k - i], l - a)\n            high = bisect.bisect_right(c2[k - i], r - a)\n            ans += high - low\n    return ans\n\nprint(solve())\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport bisect\n\n\ndef main():\n    n, K, L, R = map(int, sys.stdin.readline().split())\n    a = tuple(map(int, sys.stdin.readline().split()))\n    m = n//2+1\n    ls = [[] for _ in range(m+1)]\n    for i in range(1 << m):\n        cnt = 0\n        val = 0\n        for j in range(m):\n            if i >> j & 1:\n                cnt += 1\n                val += a[j]\n        ls[cnt].append(val)\n    for i in range(m+1):\n        ls[i].sort()\n    ans = 0\n    for i in range(1 << n-m):\n        cnt = 0\n        val = 0\n        for j in range(n-m):\n            if i >> j & 1:\n                cnt += 1\n                val += a[m+j]\n        if K-m <= cnt <= K:\n            ans += bisect.bisect_right(ls[K-cnt], R-val) - bisect.bisect_right(ls[K-cnt], L-val-1)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport bisect\n\n\ndef main():\n    n, K, L, R = map(int, sys.stdin.readline().split())\n    a = tuple(map(int, sys.stdin.readline().split()))\n    m = (n-1)//2\n    ls = [[] for _ in range(m+1)]\n    for i in range(1 << m):\n        cnt = 0\n        val = 0\n        for j in range(m):\n            if i >> j & 1:\n                cnt += 1\n                val += a[j]\n        ls[cnt].append(val)\n    for i in range(m+1):\n        ls[i].sort()\n    ans = 0\n    for i in range(1 << n-m):\n        cnt = 0\n        val = 0\n        for j in range(n-m):\n            if i >> j & 1:\n                cnt += 1\n                val += a[m+j]\n        if K-m <= cnt <= K:\n            ans += bisect.bisect_right(ls[K-cnt], R-val) - bisect.bisect_right(ls[K-cnt], L-val-1)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    n,k,l,r = LI()\n    a = LI()\n    n1 = n>>1\n    n2 = n-n1\n    s1 = [[] for i in range(n1+1)]\n    s2 = [[] for i in range(n2+1)]\n    for b in range(1<<n1):\n        s = 0\n        j = 0\n        for i in range(n1):\n            if not b&(1<<i):\n                continue\n            s += a[i]\n            j += 1\n        s1[j].append(s)\n\n    for b in range(1<<n2):\n        s = 0\n        j = 0\n        for i in range(n2):\n            if not b&(1<<i):\n                continue\n            s += a[i+n1]\n            j += 1\n        s2[j].append(s)\n    for i in range(n2+1):\n        s2[i].sort()\n    ans = 0\n    for i in range(n1+1):\n        if i > k:\n            break\n        j = k-i\n        if j > n2:\n            continue\n        for s in s1[i]:\n            a,b = bisect.bisect_left(s2[j],l-s),bisect.bisect_right(s2[j],r-s)\n            ans += b-a\n    print(ans)\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    solve()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n# import re\nimport math\nimport collections\n# import decimal\nimport bisect\nimport itertools\nimport fractions\n# import functools\nimport copy\n# import heapq\nimport decimal\n# import statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10000001)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: map(int, sys.stdin.readline().split())\nna = lambda: list(map(int, sys.stdin.readline().split()))\n\n\n# ===CODE===\n\ndef largestRectangInHistgram(heights):\n    stack = [-1]\n    maxArea = 0\n\n    for i in range(len(heights)):\n        # we are saving indexes in stack that is why we comparing last element in stack\n        # with current height to check if last element in stack not bigger then\n        # current element\n        while stack[-1] != -1 and heights[stack[-1]] > heights[i]:\n            lastElementIndex = stack.pop()\n            maxArea = max(maxArea, heights[lastElementIndex] * (i - stack[-1] - 1))\n        stack.append(i)\n\n    # we went through all elements of heights array\n    # let's check if we have something left in stack\n    while stack[-1] != -1:\n        lastElementIndex = stack.pop()\n        maxArea = max(maxArea, heights[lastElementIndex] * (len(heights) - stack[-1] - 1))\n\n    return maxArea\n\n\ndef main():\n    n, k, l, r = ns()\n    a = na()\n\n    pair1 = a[:n // 2]\n    pair2 = a[n // 2:]\n    ans = 0\n\n    res1 = [[0, 0]]\n    res2 = [[0, 0]]\n\n    for p1 in pair1:\n        tmp = [[cnt + 1, r + p1] for cnt, r in res1]\n        res1 += tmp\n\n    for p2 in pair2:\n        tmp = [[cnt + 1, r + p2] for cnt, r in res2]\n        res2 += tmp\n\n    res2dic = {}\n    for cnt, p2 in res2:\n        if cnt not in res2dic.keys():\n            res2dic[cnt] = [p2]\n        else:\n            res2dic[cnt].append(p2)\n    for key in res2dic.keys():\n        res2dic[key].sort()\n\n    for cnt, r1 in res1:\n        tmpk = k - cnt\n        if tmpk < 0 or tmpk not in res2dic.keys():\n            continue\n\n        lnum = l - r1\n        rnum = r - r1\n        lidx = bisect.bisect_left(res2dic[tmpk], lnum)\n        ridx = bisect.bisect_right(res2dic[tmpk], rnum)\n        ans += ridx - lidx\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from itertools import combinations\nfrom collections import Counter\nN, K, L, R, *A = map(int, open(0).read().split())\ndef make(A, K):\n    return [Counter(map(sum, combinations(A, l))) for l in range(0, K+1)]\n\nP = make(A[:N//2], K)\nQ = make(A[N//2:], K)\n\nans = 0\nfor i in range(K+1):\n    p = P[i]; q = Q[K-i]\n    sq = sorted(q)\n    l = r = len(q)\n    s = 0\n    for k, v in sorted(p.items()):\n        while r and k+sq[r-1] > R:\n            r -= 1\n            s -= q[sq[r]]\n        while l and k+sq[l-1] >= L:\n            l -= 1\n            s += q[sq[l]]\n        ans += v * s\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\n\ndef makeItems(lst, size):\n    length = len(lst)\n    ret = [[] for _ in range(size + 2)]\n    ret[0] = [0]\n    for a in lst:\n        for b in range(size, -1, -1):\n            add = [a + c for c in ret[b]]\n            ret[b + 1].extend(add)\n    return ret\n\n\ndef main():\n    n, k, l, r = map(int, input().split())\n    aList = list(map(int, input().split()))\n    aLeft = aList[:n // 2]\n    aRight = aList[n // 2:]\n    leftItems = makeItems(aLeft, k)\n    rightItems = makeItems(aRight, k)\n    \n    for lst in rightItems:\n        lst.sort()\n    \n    ans = 0\n    for i, lst in enumerate(leftItems):\n        if i > k:continue\n        for item in lst:\n            minLimit = l - item\n            maxLimit = r - item\n            left = bl(rightItems[k - i], minLimit)\n            right = br(rightItems[k - i], maxLimit)\n            ans += right - left\n    \n    print(ans)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport bisect\n\n\ndef main():\n    n, K, L, R = map(int, sys.stdin.readline().split())\n    a = tuple(map(int, sys.stdin.readline().split()))\n    m = n//2\n    ls = [[] for _ in range(m+1)]\n    for i in range(1 << m):\n        ls[bin(i).count(\"1\")].append(sum([a[j] for j in range(m) if i >> j & 1]))\n    for i in range(m+1):\n        ls[i].sort()\n    ans = 0\n    for i in range(1 << n-m):\n        cnt = bin(i).count(\"1\")\n        val = sum([a[m+j] for j in range(n-m) if i >> j & 1])\n        if K-m <= cnt <= K:\n            ans += bisect.bisect_right(ls[K-cnt], R-val) - bisect.bisect_right(ls[K-cnt], L-val-1)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    N, K, L, R = LI()\n    a = LI()\n\n    N_half_A = N // 2\n    A_sum = [[] for _ in range(N_half_A + 1)]\n    for i in range(2 ** N_half_A):\n        sum = 0\n        num = 0\n        for j in range(N_half_A):\n            if (i >> j) & 1:\n                sum += a[j]\n                num += 1\n        A_sum[num].append(sum)\n\n    N_half_B = N - N_half_A\n    B_sum = [[] for _ in range(N_half_B + 1)]\n    for i in range(2 ** N_half_B):\n        sum = 0\n        num = 0\n        for j in range(N_half_B):\n            if (i >> j) & 1:\n                sum += a[N_half_A + j]\n                num += 1\n        B_sum[num].append(sum)\n    for i in B_sum:\n        i.sort()\n\n    ans = 0\n    for i in range(N_half_A + 1):\n        if 0 <= K - i <= N_half_B:\n            for j in A_sum[i]:\n                idx_l = bisect.bisect_left(B_sum[K-i], L - j)\n                idx_r = bisect.bisect_right(B_sum[K-i], R - j)\n                ans += idx_r - idx_l\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    resolve()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport bisect\n\n\ndef main():\n    n, K, L, R = map(int, sys.stdin.readline().split())\n    a = tuple(map(int, sys.stdin.readline().split()))\n    m = n//2\n    ls = [[] for _ in range(m+1)]\n    for i in range(1 << m):\n        cnt = 0\n        val = 0\n        for j in range(m):\n            if i >> j & 1:\n                cnt += 1\n                val += a[j]\n        ls[cnt].append(val)\n    for i in range(m+1):\n        ls[i].sort()\n    ans = 0\n    for i in range(1 << n-m):\n        cnt = 0\n        val = 0\n        for j in range(n-m):\n            if i >> j & 1:\n                cnt += 1\n                val += a[m+j]\n        if K-m <= cnt <= K:\n            ans += bisect.bisect_right(ls[K-cnt], R-val) - bisect.bisect_right(ls[K-cnt], L-val-1)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport bisect\n\n\ndef main():\n    n, K, L, R = map(int, sys.stdin.readline().split())\n    a = tuple(map(int, sys.stdin.readline().split()))\n    m = (n+1)//2\n    ls = [[] for _ in range(m+1)]\n    for i in range(1 << m):\n        cnt = 0\n        val = 0\n        for j in range(m):\n            if i >> j & 1:\n                cnt += 1\n                val += a[j]\n        ls[cnt].append(val)\n    for i in range(m+1):\n        ls[i].sort()\n    ans = 0\n    for i in range(1 << n-m):\n        cnt = 0\n        val = 0\n        for j in range(n-m):\n            if i >> j & 1:\n                cnt += 1\n                val += a[m+j]\n        if K-m <= cnt <= K:\n            ans += bisect.bisect_right(ls[K-cnt], R-val) - bisect.bisect_right(ls[K-cnt], L-val-1)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\n#[doc = \" Equivalent to std::lowerbound and std::upperbound in c++\"]\npub trait BinarySearch<T> {\n    fn lower_bound(&self, x: &T) -> usize;\n    fn upper_bound(&self, x: &T) -> usize;\n}\nimpl<T: Ord> BinarySearch<T> for [T] {\n    fn lower_bound(&self, x: &T) -> usize {\n        let mut low = 0;\n        let mut high = self.len();\n        while low != high {\n            let mid = (low + high) / 2;\n            match self[mid].cmp(x) {\n                Ordering::Less => {\n                    low = mid + 1;\n                }\n                Ordering::Equal | Ordering::Greater => {\n                    high = mid;\n                }\n            }\n        }\n        low\n    }\n    fn upper_bound(&self, x: &T) -> usize {\n        let mut low = 0;\n        let mut high = self.len();\n        while low != high {\n            let mid = (low + high) / 2;\n            match self[mid].cmp(x) {\n                Ordering::Less | Ordering::Equal => {\n                    low = mid + 1;\n                }\n                Ordering::Greater => {\n                    high = mid;\n                }\n            }\n        }\n        low\n    }\n}\n// [(n, value)]\nfn mk_h(xs: &[i64]) -> Vec<(usize, i64)> {\n    let mut res = vec![];\n    let n = xs.len();\n    for comb in 0..(1<<n) {\n        let mut count = 0;\n        let mut v = 0;\n        for i in 0..n {\n            if comb & (1<<i) > 0 {\n                count += 1;\n                v += xs[i];\n            }\n        }\n        res.push((count, v));\n    }\n    res.sort();\n    res\n}\nfn solve() {\n    input! {\n        N: usize, K: usize, L: i64, R: i64,\n        A: [i64; N],\n    }\n    let a1 = &A[0..N/2];\n    let a2 = &A[N/2..];\n    let h1 = mk_h(a1);\n    let h2 = mk_h(a2);\n\n    // dbg!(&h1);\n    // dbg!(&h2);\n    \n    let mut res = 0;\n    for x in h1 {\n        if x.0 > K || x.1 > R { continue; }\n        if x.0 == K {\n            if L <= x.1 && x.1 <= R {\n                res += 1;\n            }\n        } else { // < K\n            let more = K - x.0;\n            let lb = h2.lower_bound(&(more, L-x.1));\n            let ub = h2.upper_bound(&(more, R-x.1));\n            // dbg!((lb,ub));\n            res += ub-lb;\n        }\n    }\n    println!(\"{}\", res);\n}\n"
  }
]