[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nbool latte[100000][7];\nbool malta[200000][7];\n\nint main()\n{\n  long long N, M, Q, A[100000];\n  cin >> N >> M >> Q;\n  for(int i = 0; i < Q; i++) cin >> A[i];\n\n\n  UnionFind tree1(100000 * 7), tree2(200000 * 7);\n  long long sz = M / 7;\n  for(int i = 0; i < Q; i++) {\n    long long col = A[i] / 7, row = A[i] % 7;\n    long long col2 = A[i] / 7 + sz, row2 = A[i] % 7;\n    latte[col][row] = true;\n    malta[col][row] = true;\n    malta[col2][row2] = true;\n  }\n\n  for(int i = 0; i < sz; i++) {\n    for(int j = 0; j < 7; j++) {\n      if(j + 1 < 7 && !latte[i][j] && !latte[i][j + 1]) {\n        tree1.unite(i * 7 + j, i * 7 + j + 1);\n      }\n      if(i + 1 < sz && !latte[i][j] && !latte[i + 1][j]) {\n        tree1.unite(i * 7 + j, i * 7 + j + 7);\n      }\n    }\n  }\n\n\n  for(int i = 0; i < 2 * sz; i++) {\n    for(int j = 0; j < 7; j++) {\n      if(j + 1 < 7 && !malta[i][j] && !malta[i][j + 1]) {\n        tree2.unite(i * 7 + j, i * 7 + j + 1);\n      }\n      if(i + 1 < sz && !malta[i][j] && !malta[i + 1][j]) {\n        tree2.unite(i * 7 + j, i * 7 + j + 7);\n      }\n    }\n  }\n\n\n  int ret1 = 0, ret2 = 0;\n  for(int i = 0; i < sz; i++) {\n    for(int j = 0; j < 7; j++) {\n      if(tree1.find(i * 7 + j) == i * 7 + j && !latte[i][j]) ret1++;\n    }\n  }\n  for(int i = 0; i < 2 * sz; i++) {\n    for(int j = 0; j < 7; j++) {\n      if(tree2.find(i * 7 + j) == i * 7 + j && !malta[i][j]) ret2++;\n    }\n  }\n  long long add = ret2 - ret1;\n  cout << ret1 + (1LL * add * 7 * N / M - add) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N, m;\nbool MAP[100001][8];\nbool MOD[100010];\nint32_t a[100010];\n\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) {\n\tarr = v;\n}\ntemplate<typename T, typename ARR>\nvoid fill_all(ARR& arr, const T& v) {\n\tfor (auto& i : arr) { fill_all(i, v); }\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t Q;\n\tin >> N >> m >> Q;\n\tfor (int32_t i = 0; i < Q; ++i)\n\t{\n\t\tin >> a[i];\n\t\tMOD[a[i]] = true;\n\t}\n\n\tif (N <= 100000)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < N; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tout << count << endl;\n\t}\n\telse if ((m % 7) == 0)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < (m/7); ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tint32_t count1 = count;\n\n\t\tfill_all(MAP, false);\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tcount = 0;\n\t\tfor (int32_t y = 0; y < (m / 7)*2; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tout << (count - count1)*((7*N)/m)+count1 << endl;\n\t}\n\n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int dh[] = {1, -1, 0, 0};\nconst int dw[] = {0, 0, 1, -1};\n\nint g;\n\nvoid dfs(int h, int w, vector<vector<bool> >& b) {\n\tstack<P> s;\n\ts.push(P(h, w));\n\twhile (!s.empty()) {\n\t\tint ch, cw;\n\t\ttie(ch, cw) = s.top();\n\t\ts.pop();\n\t\tif (b[ch][cw]) continue;\n\t\tb[ch][cw] = true;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nh = ch + dh[i], nw = cw + dw[i];\n\t\t\tif (nh < 0 || nh >= g || nw < 0 || nw >= 7) continue;\n\t\t\tif (b[nh][nw]) continue;\n\t\t\ts.push(P(nh, nw));\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n;\n\tint m, q;\n\tcin >> n >> m >> q;\n\tvector<bool> memo(m, false);\n\tfor (int i = 0; i < q; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tmemo[a] = true;\n\t}\n\n\tg = m / __gcd(m, 7);\n\n\tvector< vector<bool> > b(g, vector<bool>(7, false));\n\tfor (int i = 0; i < g; i++) {\n\t\tfor (int j = 0; j < 7; j++) {\n\t\t\tint x = 7 * i + j;\n\t\t\tb[i][j] = memo[x % m];\n\t\t}\n\t}\n\t\n\tint cnt1 = 0;\n\tfor (int i = 0; i < g; i++) {\n\t\tfor (int j = 0; j < 7; j++) {\n\t\t\tif (!b[i][j]) {\n\t\t\t\tdfs(i, j, b);\n\t\t\t\tcnt1++;\n\t\t\t}\n\t\t}\n\t}\n\n\tg *= 2;\n\tb.resize(g, vector<bool>(7, false));\n\tfor (int i = 0; i < g; i++) {\n\t\tfor (int j = 0; j < 7; j++) {\n\t\t\tint x = 7 * i + j;\n\t\t\tb[i][j] = memo[x % m];\n\t\t}\n\t}\n\t\n\tint cnt2 = 0;\n\tfor (int i = 0; i < g; i++) {\n\t\tfor (int j = 0; j < 7; j++) {\n\t\t\tif (!b[i][j]) {\n\t\t\t\tdfs(i, j, b);\n\t\t\t\tcnt2++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (m % 7 == 0) {\n\t\tcout << (cnt2 - cnt1) * (7 * n / m) + (cnt1 * 2 - cnt2) << endl;\n\t} else {\n\t\tcout << (cnt2 - cnt1) * (n / m) + (cnt1 * 2 - cnt2) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n\nusing namespace std;\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n\nconst int white=-1;\nconst int black=100000000;\n\n\nvi gx, gy;\n\n\nvoid push(int x, int y)\n{\n\tgx.push_back(x);\n\tgy.push_back(y);\n}\n\n\nint pop(int& x, int& y)\n{\n\tif(gx.size()<=0) return 0;\n\tx=gx.back();\n\ty=gy.back();\n\tgx.pop_back();\n\tgy.pop_back();\n\treturn 1;\n}\n\n\nvoid eng_fill(vvi& c, int x, int y, int g)\n{\n\tint vx[]={ 1, 0,-1, 0};\n\tint vy[]={ 0,-1, 0, 1};\n\tint nx, ny;\n\tint w, h;\n\n\tw=7;\n\th=c.size();\n\tpush(x, y);\n\tc[y][x]=g;\n\twhile(pop(x, y))\n\t{\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tnx=x+vx[i];\n\t\t\tny=y+vy[i];\n\t\t\tif(nx<0 || w<=nx || ny<0 || h<=ny) continue;\n\t\t\tif(c[ny][nx]!=white) continue;\n\t\t\tc[ny][nx]=g;\n\t\t\tpush(nx, ny);\n\t\t}\n\t}\n}\n\n\n\nint engroup(vvi& c)\n{\n\tint w, h, x, y;\n\tint g=0;\n\n\tw=7;\n\th=c.size();\n\tfor(y=0;y<h;y++)\n\t{\n\t\tfor(x=0;x<w;x++)\n\t\t{\n\t\t\tif(c[y][x]!=white) continue;\n\t\t\teng_fill(c, x, y, g);\n\t\t\tg++;\n\t\t}\n\t}\n\treturn g;\n}\n\n\nint gcd(int a, int b)\n{\n\tint c;\n\twhile((c=a%b))\n\t{\n\t\ta=b;\n\t\tb=c;\n\t}\n\treturn b;\n}\n\n\nint lcm(int a, int b)\n{\n\treturn a/gcd(a, b)*b;\n}\n\n\nint main(void)\n{\n\tint n, m, q, g, h, uh, gc;\n\tvvi c, f;\n\n\twhile(scanf(\"%d%d%d\", &n, &m, &q)==3)\n\t{\n\t\tuh=lcm(m, 7)/7;\n\t\th=n/uh;\n\t\tc.clear();\n\t\tc.resize(uh);\n\t\tfor(auto& ce: c) ce.resize(7, white);\n\n\t\tfor(int i=0;i<q;i++)\n\t\t{\n\t\t\tint a;\n\t\t\tscanf(\"%d\", &a);\n\t\t\tfor(int j=a;j<uh*7;j+=m)\n\t\t\t{\n\t\t\t\tc[j/7][j%7]=black;\n\t\t\t}\n\t\t}\n\t\tg=engroup(c);\n\n\t\tf.clear();\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tint u=c[0][i];\n\t\t\tint l=c[uh-1][i];\n\t\t\tint j;\n\t\t\tif(u==black || l==black) continue;\n\t\t\tif(u>l) swap(u, l);\n\t\t\tvi ft={u,l};\n\t\t\tfor(j=f.size()-1;j>=0;j--)\n\t\t\t{\n\t\t\t\tif(ft==f[j]) break;\n\t\t\t}\n\t\t\tif(j<0)\n\t\t\t{\n\t\t\t\tf.push_back(ft);\n\t\t\t}\n\t\t}\n\t\tgc=f.size();\n/*\nfor(auto ce:c)\n{\n\tfor(int x:ce)\n\t{\n\t\tif(x==black) printf(\" X \");\n\t\telse printf(\"%2d \", x);\n\t}\n\tprintf(\"\\n\");\n}\nprintf(\"g=%d h=%d gc=%d\\n\", g, h, gc);\n*/\n\t\tint result=g*h-gc*(h-1);\n\t\tprintf(\"%d\\n\", result);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,m,q,ans;\nint ai[1100][1100];\nbool pd[1100];\n\nvoid dfs(int x,int y)\n{\n\tif (x<0||y<0||x>n-1||y>6||ai[x][y]) return;\n\tai[x][y]=1;\n\tdfs(x,y+1);\n\tdfs(x+1,y);\n\tdfs(x,y-1);\n\tdfs(x-1,y);\n}\nint main()\n{\n\tcin>>n>>m>>q;\n\tfor(int i=1,j;i<=q;i++) cin>>j,pd[j]=true;\n\tfor(int i=0;i<7*n;i++)\n\t\tai[i/7][i%7]=pd[!i%m&&i?m:i%m];\n\t\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<7;j++)\n\t\t\tif (!ai[i][j]) dfs(i,j),ans++;\n\tcout<<ans<<endl;\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 2333333\nll n;\nint m,q,a[SZ];\nbool cov[SZ];\nint ff[SZ];\nint gf(int x) {return (ff[x]==-1)?x:ff[x]=gf(ff[x]);}\nvoid uni(int a,int b)\n{int ga=gf(a),gb=gf(b);if(ga^gb)ff[ga]=gb;}\nint main()\n{\n\tscanf(\"%lld%d%d\",&n,&m,&q);\n\tfor(int i=1;i<=q;i++)\n\tscanf(\"%d\",a+i),cov[a[i]]=1;\n\t#define TJ(r,ans)\\\n\tmemset(ff,-1,sizeof(ff));\\\n\tfor(int i=0;i<r;i++)\\\n\t{\\\n\t\tif(cov[i%m])continue;\\\n\t\tif(i+7<r&&!cov[(i+7)%m]) uni(i,i+7);\\\n\t\tif(i%7!=6&&i+1<r&&!cov[(i+1)%m]) uni(i,i+1);\\\n\t}\\\n\tfor(int i=0;i<r;i++)\\\n\t\tif(!cov[i%m]) ans+=gf(i)==i;\n\tint ans1=0; TJ(m*7,ans1)\n\tint ans2=0; TJ(m*14,ans2)\n\tll rd=7*n/m,zg=rd/7,bf=rd%7,ans=0;\n\tif(zg) ans=ans1+(ans2-ans1)*(zg-1);\n\tint ans3=0; TJ(m*bf,ans3)\n\tint ans4=0; TJ(m*bf+m*7,ans4)\n\tint ans5=0; TJ(m*bf+m*7,ans5)\n\tif(zg) ans+=ans5-ans4; else ans+=ans3;\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nint n;\n\nvoid dfs(int y,int x,vector< vector<bool> > &used,const vector< vector<int> > &v){\n    int dy[]={1,0,-1,0};\n    int dx[]={0,1,0,-1};\n\n    rep(i,4){\n        int ddx = x+dx[i];\n        int ddy = y+dy[i];\n        if(ddx<0 || ddy<0 || ddx>=7 || ddy>=n)continue;\n        if(v[ddy][ddx]==0 && used[ddy][ddx]==false){\n            used[ddy][ddx]=true;\n            dfs(ddy,ddx,used,v);\n        }\n    }\n}\n\nint main(){\n    int m,q;\n    cin>>n>>m>>q;\n    assert(n<=100000);\n    vector<int> a(q);\n    rep(i,q)cin>>a[i];\n    \n    vector< vector<int> > v(n,vector<int>(7,0));\n    \n    for(int i=0;;i++){\n        if(i*m>=7*n)break;\n        rep(j,q){\n            int num = i*m+a[j];\n            v[num/7][num%7]=1;\n        }\n    }\n    int c=0;\n    vector< vector<bool> > used(n,vector<bool>(7,false));\n    rep(i,n){\n        rep(j,7){\n            if(v[i][j]!=1 && used[i][j]==false){\n                used[i][j]=true;\n                dfs(i,j,used,v);\n                c++;\n            }\n        }\n    }\n    cout<<c<<endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define maxn 2000010\nint a[maxn];\nbool col[maxn][7], vis[maxn][7];\ntypedef long long ll;\nstruct que {\n\tint x, y;\n} qu[maxn];\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\nint up[maxn], dw[maxn], Fa[maxn], fcol[maxn][7];\nint Find(int x) {return Fa[x] == x ? x : Fa[x] = Find(Fa[x]);}\nint main()\n{\n\tll n;\n\tint m, q; scanf(\"%lld%d%d\", &n, &m, &q);\n\tfor (int i = 1; i <= q; ++i) scanf(\"%d\", &a[i]);\n\tif (m % 7)\n\t{\n\t\tint nq = q;\n\t\tfor (int i = 1; i <= q; ++i)\n\t\t\tfor (int j = 1; j < 7; ++j)\n\t\t\t\ta[++nq] = a[i] + j * m;\n\t\tm *= 7; q = nq;\n\t}\n\tint mm = m / 7, cnt = 0;\n\n\tfor (int i = 1; i <= q; ++i)\n\t{\n\t\tcol[a[i] / 7][a[i] % 7] = 1;\n//\t\tprintf(\"%d %d\\n\", a[i] / 7, a[i] % 7);\n\t}\n\n\tfor (int i = 0; i < mm; ++i)\n\t\tfor (int j = 0; j < 7; ++j)\n\t\t\tif (!vis[i][j] && !col[i][j])\n\t\t\t{\n\t\t\t\tfcol[i][j] = ++cnt;\n\t\t\t\tint head = 0, tail = 1; qu[1] = (que) {i, j}; vis[i][j] = 1;\n\t\t\t\twhile (head < tail)\n\t\t\t\t{\n\t\t\t\t\tque now = qu[++head];\n\t\t\t\t\tfor (int k = 0, nx, ny; k < 4; ++k)\n\t\t\t\t\t{\n\t\t\t\t\t\tnx = now.x + dx[k]; ny = now.y + dy[k];\n\t\t\t\t\t\tif (nx >= 0 && nx < mm && ny >= 0 && ny < 7 && !vis[nx][ny] && !col[nx][ny])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tqu[++tail] = (que) {nx, ny};\n\t\t\t\t\t\t\tfcol[nx][ny] = cnt;\n\t\t\t\t\t\t\tvis[nx][ny] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\tprintf(\"%d\\n\", cnt);\n\tint cnt2 = 0;\n\tfor (int i = 0; i < 7; ++i) up[i] = fcol[0][i];\n\tfor (int i = 0; i < 7; ++i) !col[mm - 1][i] ? dw[i] = fcol[mm - 1][i] + cnt : 0;\n\tfor (int i = 1; i <= cnt * 2; ++i) Fa[i] = i;\n\n//\tfor (int i = 0; i < 7; ++i) printf(\"%d %d\\n\", up[i], dw[i]);\n\tfor (int i = 0; i < 7; ++i)\n\t{\n//\t\tprintf(\"%d %d\\n\", up[i], dw[i]);\n\t\tif (up[i] && dw[i] && Find(up[i]) != Find(dw[i]))\n\t\t{\n\t\t\tFa[Find(up[i])] = Find(dw[i]);\n\t\t\t++cnt2;\n\t\t}\n\t}\n//\tprintf(\"%d\\n\", cnt2);\n//\twhile (n % mm) ;\n\tll ans = 1ll * cnt * (n / mm) - 1ll * (n / mm - 1) * cnt2;\n\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n/*\n1000000000000 28 20\n3 4 5 6 7 8 10 11 12 13 17 18 19 20 22 23 24 25 26 27\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define I(i,j) (i*7+j)\n\nll n,m,q,a[100050];\nbool g[1000000];\nbool used[1000000];\n\nbool dfs1(ll n,ll i,ll j) {\n    ll ret = i >= n / 2;\n    REP(k,4) {\n        ll y = i + dy[k],x = j + dx[k];\n        if(0 <= y && y < n && 0 <= x && x < 7 && !used[I(y,x)] && !g[I(y,x)]) {\n            used[I(y,x)] = true;\n            ret |= dfs1(n,y,x);\n        }\n    }\n    return ret;\n}\n\nint main(){\n    cin >> n >> m >> q;\n\n    REP(i,q)\n        cin >> a[i];\n\n    ll l = 1;\n\n    while(m * l % 7 != 0)l++;\n\n    ll n2 = m * l / 7;\n\n    if(n == n2) {\n        REP(i,q) {\n            ll p = a[i];\n\n            while(p < n * 7){\n                g[p] = true;\n                p += m;\n            }\n        }\n\n        ll c = 0;\n        REP(i,n) {\n            REP(j,7) {\n                if(!used[I(i,j)] && !g[I(i,j)]) {\n                    c++;\n                    used[I(i,j)] = true;\n                    dfs1(n,i,j);\n                }\n            }\n        }\n        cout << c << endl;\n        return 0;\n    }\n\n    REP(i,q) {\n        ll p = a[i];\n\n        while(p < n2 * 7 * 2){\n            g[p] = true;\n            p += m;\n        }\n    }\n\n    ll c1 = 0,c2 = 0;\n\n    REP(i,n2) {\n        REP(j,7) {\n            if(!used[I(i,j)] && !g[I(i,j)]) {\n                c1++;\n                used[I(i,j)] = true;\n                if(dfs1(n2*2,i,j))c2++;\n            }\n        }\n    }\n\n    cout << n / n2 * c1 - (n / n2 - 1) * c2 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define  inc(i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define  dec(i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define UB upper_bound\n#define LB lower_bound\n#define PQ priority_queue\n\n#define  ALL(v)  v.begin(),  v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define  FOR(it, v) for(auto it =  v.begin(); it !=  v.end(); ++it)\n#define RFOR(it, v) for(auto it = v.rbegin(); it != v.rend(); ++it)\n\ntemplate<typename T> bool   setmin(T & a, T b) { if(b <  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool   setmax(T & a, T b) { if(b >  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmineq(T & a, T b) { if(b <= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmaxeq(T & a, T b) { if(b >= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, m, q, a[100000];\nint b[1000000][7];\n\nvoid dfs(int pi, int pj) {\n\tint di[] = { 1, 0, -1,  0 };\n\tint dj[] = { 0, 1,  0, -1 };\n\t\n\tinc(k, 4) {\n\t\tint i = pi + di[k];\n\t\tint j = pj + dj[k];\n\t\tif(inID(i, 0, n) && inID(j, 0, 7) && b[i][j] == 0) {\n\t\t\tb[i][j] = 1;\n\t\t\tdfs(i, j);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> m >> q;\n\tinc(i, q) { cin >> a[i]; }\n\t\n\tif(n > 1000000) { return -1; }\n\t\n\tinc(i, q) {\n\t\tint x = a[i];\n\t\tinc(j, 7 * n) {\n\t\t\tb[x / 7][x % 7] = 1;\n\t\t\t\n\t\t\tx += m;\n\t\t\tif(j >= 7 * n) { break; }\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tinc(i, n) {\n\tinc(j, 7) {\n\t\tif(b[i][j] == 0) {\n\t\t\tb[i][j] = 1;\n\t\t\tans++;\n\t\t\tdfs(i, j);\n\t\t}\n\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\n#include<ext/pb_ds/priority_queue.hpp>\nusing namespace std;\n\nconst int maxn = 7E5 + 7;\n\nint n,m,q,N,Ans;\nbool vis[maxn];\n\nqueue <int> Q;\nvector <int> v[maxn];\n\nvoid BFS(int s)\n{\n\tQ.push(s);\n\twhile (!Q.empty())\n\t{\n\t\tint k = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < v[k].size(); i++)\n\t\t{\n\t\t\tint to = v[k][i];\n\t\t\tif (vis[to]) continue;\n\t\t\tvis[to] = 1; Q.push(to);\n\t\t}\n\t}\n}\n\nint main()\n{\n\t#ifdef DMC\n\t\tfreopen(\"DMC.txt\",\"r\",stdin);\n\t#endif\n\t\n\tcin >> n >> m >> q; N = 7 * n;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (i - 7 > 0) v[i].push_back(i - 7);\n\t\tif (i + 7 < N) v[i].push_back(i + 7);\n\t\tif (i % 7 > 0) v[i].push_back(i - 1);\n\t\tif (i % 7 < 6) v[i].push_back(i + 1);\n\t}\n\twhile (q--)\n\t{\n\t\tint x; scanf(\"%d\",&x);\n\t\tfor (int i = x; i < N; i += m) vis[i] = 1;\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (vis[i]) continue;\n\t\t++Ans; vis[i] = 1; BFS(i);\n\t}\n\tcout << Ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#define repi(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n#define all(a) (a).begin(), (a).end()\n\nconstexpr int MAX_Q = 100000;\n\nusing ll = long long;\n\nconst ll dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };\n\nll n, m, q;\nstd::set<ll> a;\nbool fld[2000000][7];\n\nvoid dfs( ll v, ll h )\n{\n  ll i = v/7, j = v%7;\n\n  fld[i][j] = true;\n\n  rep( d, 4 )\n  {\n    ll ni = i+dy[d], nj = j+dx[d];\n\n    if( ni >= 0 && ni < h && nj >= 0 && nj < 7 && !fld[ni][nj] )\n      dfs( ni*7+nj, h );\n  }\n\n  return;\n}\n\nint main()\n{\n  scanf( \"%lld%lld%lld\", &n, &m, &q );\n  rep( i, q )\n  {\n    ll x;\n    scanf( \"%lld\", &x );\n\n    a.insert( x );\n  }\n\n  ll k = m%7==0 ? 1 : 7;\n\n  rep( i, k*m )\n    fld[i/7][i%7] = a.find( i%m )!=a.end();\n\n  ll cnt = 0;\n  rep( i, k*m ) if( !fld[i/7][i%7] )\n    dfs( i, k*m/7 ), ++cnt;\n\n  rep( i, 2*k*m )\n    fld[i/7][i%7] = a.find( i%m )!=a.end();\n\n  ll cnt2 = 0;\n  rep( i, 2*k*m ) if( !fld[i/7][i%7] )\n    dfs( i, 2*k*m/7 ), ++cnt2;\n  \n  ll a, b;\n  \n  // cnt (7a)*1+b\n  // cnt2 (7ia)*2+b\n  a = cnt2-cnt, b = cnt-a;\n\n  printf( \"%lld\\n\", a*7*n/m/k+b );\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "z#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define put(x) cout << x;\n#define putsp(x) cout << x << ' ';\n#define putln(x) cout << x << endl;\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\ntypedef long long ll;\ntypedef pair<ll, ll> llP;\ntypedef pair<int, int> intP;\ntypedef complex<double> comp;\ntypedef vector <int> vec;\ntypedef vector <ll> vecll;\ntypedef vector <double> vecd;\ntypedef vector <vec> mat;\ntypedef vector <vecll> matll;\ntypedef vector <vecd> matd;\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nconst int MAX = 100010;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = 1<<29;\nconst ll INFL = 1e18;\nconst ll MOD = 1000000007;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint dx8[8]={1,0,-1,1,-1,1,0,-1};\nint dy8[8]={1,1,1,0,0,-1,-1,-1};\n\n//********************************template END****************************************//\n\nll N, M, Q;\n\nvoid dfs(int x, int y, mat& m)\n{\n\tm[y][x] = 1;\n\trep(4, d)\n\t{\n\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\tif (0 <= ny && ny < (int)m.size() && 0 <= nx && nx < 7)\n\t\t{\n\t\t\tif (m[ny][nx] == 0)\n\t\t\t{\n\t\t\t\tdfs(nx, ny, m);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(void){\n\n\tcin >> N >> M >> Q;\n\n\tvec qs(Q);\n\n\trep(Q, i)\n\t{\n\t\tcin >> qs[i];\n\t}\n\n\tif (M % 7)\n\t{\n\t\t//0 -> white, 1 -> black\n\t\tmat maze(M, vec (7, 0)), dmaze(M*2, vec(7, 0));\n\n\t\trep(Q, i) rep(7, j)\n\t\t{\n\t\t\tint x = qs[i] + M*j;\n\t\t\tint h = x / 7, w = x % 7;\n\t\t\tdmaze[h][w] = maze[h][w] = 1;\n\t\t\tx += 7*M;\n\t\t\th = x / 7, w = x % 7;\n\t\t\tdmaze[h][w] = 1;\n\t\t}\n\n\t\tint a = 0, b = 0, k = N/M;\n\n\t\trep(M, i) rep(7, j)\n\t\t{\n\t\t\tif (maze[i][j] == 0)\n\t\t\t{\n\t\t\t\ta++;\n\t\t\t\tdfs(j, i, maze);\n\t\t\t}\n\t\t}\n\n\t\trep(2*M, i) rep(7, j)\n\t\t{\n\t\t\tif (dmaze[i][j] == 0)\n\t\t\t{\n\t\t\t\tb++;\n\t\t\t\tdfs(j, i, dmaze);\n\t\t\t}\n\t\t}\n\n\t\t//cout << a << ' ' << b << ' ' << k << endl;\n\n\t\tint ans = a + (b-a) * (k-1);\n\n\t\tcout << ans << endl;\n\t\treturn;\n\t}\n\n\t//0 -> white, 1 -> black\n\tmat maze(M/7, vec (7, 0)), dmaze(M/7*2, vec(7, 0));\n\n\trep(Q, i)\n\t{\n\t\tint x = qs[i];\n\t\tint h = x / 7, w = x % 7;\n\t\tdmaze[h][w] = maze[h][w] = 1;\n\t\tx += M;\n\t\th = x / 7, w = x % 7;\n\t\tdmaze[h][w] = 1;\n\t}\n\n\tint a = 0, b = 0, k = N*7/M;\n\n\trep(M/7, i) rep(7, j)\n\t{\n\t\tif (maze[i][j] == 0)\n\t\t{\n\t\t\ta++;\n\t\t\tdfs(j, i, maze);\n\t\t}\n\t}\n\n\trep(2*M/7, i) rep(7, j)\n\t{\n\t\tif (dmaze[i][j] == 0)\n\t\t{\n\t\t\tb++;\n\t\t\tdfs(j, i, dmaze);\n\t\t}\n\t}\n\n\t//cout << a << ' ' << b << ' ' << k << endl;\n\n\tint ans = a + (b-a) * (k-1);\n\n\tcout << ans << endl;\n\n\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define put(x) cout << x;\n#define putsp(x) cout << x << ' ';\n#define putln(x) cout << x << endl;\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\ntypedef long long ll;\ntypedef pair<ll, ll> llP;\ntypedef pair<int, int> intP;\ntypedef complex<double> comp;\ntypedef vector <int> vec;\ntypedef vector <ll> vecll;\ntypedef vector <double> vecd;\ntypedef vector <vec> mat;\ntypedef vector <vecll> matll;\ntypedef vector <vecd> matd;\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nconst int MAX = 100010;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = 1<<29;\nconst ll INFL = 1e18;\nconst ll MOD = 1000000007;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint dx8[8]={1,0,-1,1,-1,1,0,-1};\nint dy8[8]={1,1,1,0,0,-1,-1,-1};\n\n//********************************template END****************************************//\n\nvoid dfs(int x, int y, mat& m)\n{\n\tm[y][x] = 1;\n\trep(4, d)\n\t{\n\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\tif (0 <= ny && ny < (int)m.size() && 0 <= nx && nx < 7)\n\t\t{\n\t\t\tif (m[ny][nx] == 0)\n\t\t\t{\n\t\t\t\tdfs(nx, ny, m);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(void){\n\n\tll N, M, Q;\n\tcin >> N >> M >> Q;\n\n\tvec qs(Q);\n\n\trep(Q, i)\n\t{\n\t\tcin >> qs[i];\n\t}\n\n\tif (M % 7)\n\t{\n\t\t//0 -> white, 1 -> black\n\t\tmat maze(M, vec (7, 0)), dmaze(M*2, vec(7, 0));\n\n\t\trep(Q, i) rep(7, j)\n\t\t{\n\t\t\tint x = qs[i] + M*j;\n\t\t\tint h = x / 7, w = x % 7;\n\t\t\tdmaze[h][w] = maze[h][w] = 1;\n\t\t\tx += 7*M;\n\t\t\th = x / 7, w = x % 7;\n\t\t\tdmaze[h][w] = 1;\n\t\t}\n\n\t\tll a = 0, b = 0, k = N/M;\n\n\t\trep(M, i) rep(7, j)\n\t\t{\n\t\t\tif (maze[i][j] == 0)\n\t\t\t{\n\t\t\t\ta++;\n\t\t\t\tdfs(j, i, maze);\n\t\t\t}\n\t\t}\n\n\t\trep(2*M, i) rep(7, j)\n\t\t{\n\t\t\tif (dmaze[i][j] == 0)\n\t\t\t{\n\t\t\t\tb++;\n\t\t\t\tdfs(j, i, dmaze);\n\t\t\t}\n\t\t}\n\n\t\t//cout << a << ' ' << b << ' ' << k << endl;\n\n\t\tint ans = a + (b-a) * (k-1);\n\n\t\tcout << ans << endl;\n\t\treturn;\n\t}\n\n\t//0 -> white, 1 -> black\n\tmat maze(M/7, vec (7, 0)), dmaze(M/7*2, vec(7, 0));\n\n\trep(Q, i)\n\t{\n\t\tint x = qs[i];\n\t\tint h = x / 7, w = x % 7;\n\t\tdmaze[h][w] = maze[h][w] = 1;\n\t\tx += M;\n\t\th = x / 7, w = x % 7;\n\t\tdmaze[h][w] = 1;\n\t}\n\n\tll a = 0, b = 0, k = N*7/M;\n\n\trep(M/7, i) rep(7, j)\n\t{\n\t\tif (maze[i][j] == 0)\n\t\t{\n\t\t\ta++;\n\t\t\tdfs(j, i, maze);\n\t\t}\n\t}\n\n\trep(2*M/7, i) rep(7, j)\n\t{\n\t\tif (dmaze[i][j] == 0)\n\t\t{\n\t\t\tb++;\n\t\t\tdfs(j, i, dmaze);\n\t\t}\n\t}\n\n\t//cout << a << ' ' << b << ' ' << k << endl;\n\n\tll ans = a + (b-a) * (k-1);\n\n\tcout << ans << endl;\n\n\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n// #define DEBUG\n#ifdef DEBUG\n#define dump(...) cerr<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<make_tuple(__VA_ARGS__)<<\"\\n\";\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '{'; for(int i = 0; i < (int) v.size(); i++) o << v[i] << (i != (int)v.size()-1 ? \", \" : \"\"); o << \"}\";  return o; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\n#else\n#define dump(...)\n#endif\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  ll n, m, q; cin >> n >> m >> q;\n  ll h = (m + 6) / 7; // one shared block\n  ll period = h * 7; // height of period\n  ll full = n / period;\n  ll rest = n - full * period;\n  vector< vector<int> > f(period, vector<int>(7) );\n  auto used = f;\n  auto used2 = f;\n  auto used3 = f;\n\n  while(q--) {\n    ll a; cin >> a;\n    a %= m;\n    for(; a < period * 7; a += m) {\n      ll y = a / 7, x = a % 7;\n      f[y][x] = 1;\n    }\n  }\n  dump(f);\n\n  ll block = 0;\n  for(ll y = 0; y < period; y++)\n    for(ll x = 0; x < 7; x++) {\n      if(f[y][x]) continue;\n      if(used[y][x]) continue;\n      used[y][x] = 1;\n      queue<pair<ll, ll>> q;\n      q.emplace(y, x);\n      block++;\n      while(q.size()) {\n        ll yy = q.front().first, xx = q.front().second;\n        q.pop();\n        for(int d = 0; d < 4; d++) {\n          ll ny = yy + dy[d];\n          ll nx = xx + dx[d];\n          if(ny < 0 || period <= ny || nx < 0 || 7 <= nx) continue;\n          if(f[ny][nx]) continue;\n          if(used[ny][nx]) continue;\n          used[ny][nx] = 1;\n          q.emplace(ny, nx);\n        }\n      }\n    }\n\n  ll black = 0;\n  {\n    ll y = period - 1;\n    for(ll x = 0; x < 7; x++) {\n      if(f[y][x]) continue;\n      if(used2[y][x]) continue;\n      if(f[0][x]) continue;\n      used2[y][x] = 1;\n      queue<pair<ll, ll>> q;\n      q.emplace(y, x);\n      black++;\n      while(q.size()) {\n        ll yy = q.front().first, xx = q.front().second;\n        q.pop();\n        for(int d = 0; d < 4; d++) {\n          ll ny = yy + dy[d];\n          ll nx = xx + dx[d];\n          if(ny < 0 || period <= ny || nx < 0 || 7 <= nx) continue;\n          if(f[ny][nx]) continue;\n          if(used2[ny][nx]) continue;\n          used2[ny][nx] = 1;\n          q.emplace(ny, nx);\n        }\n      }\n    }\n  }\n\n  ll last = 0;\n  for(ll y = 0; y < rest; y++)\n    for(ll x = 0; x < 7; x++) {\n      if(f[y][x]) continue;\n      if(used3[y][x]) continue;\n      used3[y][x] = 1;\n      queue<pair<ll, ll>> q;\n      q.emplace(y, x);\n      last++;\n      while(q.size()) {\n        ll yy = q.front().first, xx = q.front().second;\n        q.pop();\n        for(int d = 0; d < 4; d++) {\n          ll ny = yy + dy[d];\n          ll nx = xx + dx[d];\n          if(ny < 0 || rest <= ny || nx < 0 || 7 <= nx) continue;\n          if(f[ny][nx]) continue;\n          if(used3[ny][nx]) continue;\n          used3[ny][nx] = 1;\n          q.emplace(ny, nx);\n        }\n      }\n    }\n  dump(full);\n  dump(block, black, last);\n\n  ll ans = 0;\n  ans += full * (block - black);\n  if(rest) {\n    ans += last;\n  } else {\n    ans += black;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n \nauto& in = std::cin;\nauto& out = std::cout;\n \nint64_t N,m;\nbool MAP[100001][8];\nbool MOD[100010];\nint32_t a[100010];\n \nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t Q;\n\tin >> N>>m>>Q;\n\tfor (int32_t i = 0; i < Q; ++i)\n\t{\n\t\tin >> a[i];\n\t\tMOD[a[i]] = true;\n\t}\n \n\tif (N <= 100000)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < N; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tout << count << endl;\n\t}\n\telse if (m % 7==0)\n\t{\n\t\tif (Q >= 7)\n\t\t{\n\t\t\tif (Q == m) {\n\t\t\t\tout << 0 << endl;\n\t\t\t}\n\t\t\telse if (a[0] == 0) {\n\t\t\t\tout << N / (m / 7) + (((N % (m / 7)) > 1) ? 1 : 0) << endl;\n\t\t\t}\n\t\t\telse if (a[Q - 1] + 1 == m) {\n\t\t\t\tout << N / (m / 7) + (((N % (m / 7)) > 0) ? 1 : 0) << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout << N / (m / 7) + 1 << endl;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tout << 1 << endl;\n\t\t}\n\t}\n \n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a <= x && x < b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\nstd::ostream& operator<<(std::ostream& os, const PAIR& r) {\n\tos << \"(\" << r.first << \", \" << r.second << \")\";\n\treturn os;\n}\n\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nint dy4[] = { -1, 0, 1, 0 };\nint dx4[] = { 0, 1, 0, -1 };\n\ninline int calc(std::vector<std::vector<bool>>& a) {\n\tint cnt = 0;\n\tint n = a.size();\n\tREP(i, n) {\n\t\tREP(j, 7) {\n\t\t\tif (a[i][j]) continue;\n\t\t\t++cnt;\n\t\t\tstd::queue<PAIR> que;\n\t\t\tque.push(PAIR(i, j));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tPAIR now = que.front(); que.pop();\n\t\t\t\ta[now.first][now.second] = true;\n\t\t\t\tREP(d, 4) {\n\t\t\t\t\tint dy = now.first + dy4[d];\n\t\t\t\t\tint dx = now.second + dx4[d];\n\t\t\t\t\tif (!IN(0, dy, a.size()) || !IN(0, dx, 7)) continue;\n\t\t\t\t\tif (a[dy][dx]) continue;\n\t\t\t\t\tque.push(PAIR(dy, dx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, m, q);\n\tVEC(int, a, q);\n\tstd::vector<bool> bb(m, false);\n\tREP(i, q) {\n\t\tbb[a[i]] = true;\n\t}\n\tif (n <= 200000) {\n\t\tstd::vector<std::vector<bool>> b(n, std::vector<bool>(7, false));\n\t\tREP(i, n) REP(j, 7) {\n\t\t\tif (bb[((7 * (i - 1) + j - 7) % m + m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tOUT(calc(b))BR;\n\t\treturn 0;\n\t}\n\n\tstd::vector<int> t(2);\n\tREP(_, 2) {\n\t\tstd::vector<std::vector<bool>> b(m / 7 * (_ + 1), std::vector<bool>(7, false));\n\t\tREP(i, m / 7 * (_ + 1)) REP(j, 7) {\n\t\t\tif (bb[(7 * (i - 1) + j - 7 + 8 * m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tt[_] = calc(b);\n\t}\n\tint x = 7 * n / m;\n\tint d = t[1] - t[0];\n\tOUT(t[0] + (x - 1)*d)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Implement (union by size) + (path compression)\n// Reference:\n// Zvi Galil and Giuseppe F. Italiano,\n// Data structures and algorithms for disjoint set union problems\nstruct dsu {\n  public:\n    dsu() : _n(0) {}\n    dsu(int n) : _n(n), parent_or_size(n, -1) {}\n\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                           [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n\n  private:\n    int _n;\n    // root node: -1 * component size\n    // otherwise: parent\n    std::vector<int> parent_or_size;\n};\n\n}  // namespace atcoder\n\nusing namespace atcoder;\nusing namespace std;\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define Inf 1000000000000000000\n\nlong long get(int h,int m,vector<int> x){\n\tvector<string> S(h,string(7,'0'));\n\trep(i,7*h){\n\t\tif(binary_search(x.begin(),x.end(),i%m)){\n\t\t\tS[i/7][i%7]='1';\n\t\t}\n\t}\n\tdsu D(h*7);\n\t\n\trep(i,h){\n\t\trep(j,7){\n\t\t\tif(i!=h-1){\n\t\t\t\tif(S[i][j]=='0'&&S[i+1][j]=='0'){\n\t\t\t\t\tD.merge(i*7+j,(i+1)*7+j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j!=6){\n\t\t\t\tif(S[i][j]=='0'&&S[i][j+1]=='0'){\n\t\t\t\t\tD.merge(i*7+j,i*7+j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long ret = 0LL;\n\trep(i,h){\n\t\trep(j,7){\n\t\t\tif(S[i][j]=='1')continue;\n\t\t\tif(D.leader(i*7+j)==i*7+j)ret++;\n\t\t}\n\t}\n\treturn ret;\n\t\n}\n\nint main(){\n\t\n\tlong long n,m,q;\n\tcin>>n>>m>>q;\n\tvector<int> a(q);\n\trep(i,q)cin>>a[i];\n\t\n\tlong long ans = 0LL;\n\tif(n<=m){\n\t\tans = get(n,m,a);\n\t}\n\telse{\n\t\tans = get(m,m,a);\n\t\tn -= m;\n\t\tans += n/m * (get(2*m,m,a)-get(m,m,a));\n\t\tn %= m;\n\t\tans += get(m+n,m,a) - get(m,m,a);\n\t}\n\tcout<<ans<<endl;\n\t\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nbool t[7][100010],vis[7][100010];\nint n,m,q,a;\n\nvoid DFS(int x,int y,int lim){\n\tvis[x][y]=true;\n\tint dx[]={-1,0,0,1},dy[]={0,1,-1,0};\n\tfor(int i=0;i<4;i++){\n\t\tint a=x+dx[i],b=y+dy[i];\n\t\tif(a>=0&&b>=0&&a<7&&b<lim){\n\t\t\tif(!vis[a][b])DFS(a,b,lim);\n\t\t}\n\t}\n}\nint Sol(int lim){\n\tint ret=0;\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<lim;j++){\n\t\t\tvis[i][j]=t[i][j];\n\t\t\t//cout<<t[i][j]<<\" \";\n\t\t}\n\t\t//cout<<endl;\n\t}\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<lim;j++){\n\t\t\tif(!vis[i][j]){\n\t\t\t\tret++;\n\t\t\t\tDFS(i,j,lim);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tcin>>n>>m>>q;\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tt[i][j]=0;\n\t\t}\n\t}\n\twhile(q--){\n\t\tcin>>a;\n\t\tfor(int i=a;i<7*m;i+=m){\n\t\t\tt[i%7][i/7]=1;\n\t\t}\n\t}\n\n\tint k=Sol(m),ans=0;\n\twhile(n>=m){\n\t\tans+=k;\n\t\tn-=m;\n\t}\n\tif(n)ans+=Sol(n);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N, m;\nbool MAP[100001][8];\nbool MOD[100010];\nint32_t a[100010];\n\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) {\n\tarr = v;\n}\ntemplate<typename T, typename ARR>\nvoid fill_all(ARR& arr, const T& v) {\n\tfor (auto& i : arr) { fill_all(i, v); }\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t Q;\n\tin >> N >> m >> Q;\n\tfor (int32_t i = 0; i < Q; ++i)\n\t{\n\t\tin >> a[i];\n\t\tMOD[a[i]] = true;\n\t}\n\n\tif (N <= 100000)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < N; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tout << count << endl;\n\t}\n\telse if (m % 7 == 0)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < (m/7); ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tint32_t count1 = count;\n\n\t\tfill_all(MAP, false);\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tcount = 0;\n\t\tfor (int32_t y = 0; y < (m / 7)*2; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tout << (count - count1)*((7*N)/m)+count1 << endl;\n\t}\n\n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <cstdio>\n#include <cstdint>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cmath>\n#include <climits>\n#include <bitset>\n\n// macros\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a); i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\n\n// solve\nbool white[800001];\nbool used[800001];\nint b[800001];\nint re;\n\nint dx[4] = {-7, -1, 1, 7};\nint count_a;\n\nvoid dfs(int x){\n  used[x] = true;\n  b[x] = count_a;\n  rep(i, 4){\n    int nx = x + dx[i];\n    if(nx >= 0 && nx < re){\n      if(!used[nx] && white[nx]){\n        dfs(nx);\n      }\n    }\n  }\n}\n\nint main(int argc, char const* argv[])\n{\n  ll n;\n  int m, q;\n  cin >> n >> m >> q;\n  vector<int> a(q);\n  rep(i, q){\n    cin >> a[i];\n  }\n  re = (m % 7 == 0) ? m: 7 * m;\n  fill(white, white + re, true);\n  rep(i, q){\n    rep(j, 7){\n      white[a[i] + j * m] = false;\n    }\n  }\n  count_a = 0;\n  rep(i, re){\n    if(!used[i] && white[i]){\n      dfs(i);\n      count_a++;\n    }\n  }\n  set<int> st;\n  rep(i, 7){\n    if(white[i] && white[re-7+i] && (i==0||!white[i-1]))st.insert(b[re-7+i]);\n  }\n  int count_b = int(st.size());\n  cout << (ll)(count_a - count_b) * ((7 * n) / re) + (ll)count_b << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n \nauto& in = std::cin;\nauto& out = std::cout;\n \nint32_t N, m;\nbool MAP[300001][8];\nbool MOD[200010];\nint32_t a[200010];\n \ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) {\n\tarr = v;\n}\ntemplate<typename T, typename ARR>\nvoid fill_all(ARR& arr, const T& v) {\n\tfor (auto& i : arr) { fill_all(i, v); }\n}\n \nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t Q;\n\tin >> N >> m >> Q;\n\tfor (int32_t i = 0; i < Q; ++i)\n\t{\n\t\tin >> a[i];\n\t\tMOD[a[i]] = true;\n\t}\n \n\tif (N <= 100000)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < N; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tout << count << endl;\n\t}\n\telse if ((m % 7) == 0)\n\t{return 0;\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < (m/7); ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n \n\t\tint32_t count1 = count;\n \n\t\tfill_all(MAP, false);\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tcount = 0;\n\t\tfor (int32_t y = 0; y < (m / 7)*2; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n \n\t\tout << (count - count1)*((7*N)/m)+count1 << endl;\n\t}\n \n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n#include <atcoder/dsu>\nusing namespace atcoder;\nusing namespace std;\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define Inf 1000000000000000000\n\nlong long get(int h,int m,vector<int> x){\n\tvector<string> S(h,string(7,'0'));\n\trep(i,7*h){\n\t\tif(binary_search(x.begin(),x.end(),i%m)){\n\t\t\tS[i/7][i%7]='1';\n\t\t}\n\t}\n\tdsu D(h*7);\n\t\n\trep(i,h){\n\t\trep(j,7){\n\t\t\tif(i!=h-1){\n\t\t\t\tif(S[i][j]=='0'&&S[i+1][j]=='0'){\n\t\t\t\t\tD.merge(i*7+j,(i+1)*7+j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j!=6){\n\t\t\t\tif(S[i][j]=='0'&&S[i][j+1]=='0'){\n\t\t\t\t\tD.merge(i*7+j,i*7+j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long ret = 0LL;\n\trep(i,h){\n\t\trep(j,7){\n\t\t\tif(S[i][j]=='1')continue;\n\t\t\tif(D.leader(i*7+j)==i*7+j)ret++;\n\t\t}\n\t}\n\treturn ret;\n\t\n}\n\nint main(){\n\t\n\tlong long n,m,q;\n\tcin>>n>>m>>q;\n\tvector<int> a(q);\n\trep(i,q)cin>>a[i];\n\t\n\tlong long ans = 0LL;\n\tif(n<=m){\n\t\tans = get(n,m,a);\n\t}\n\telse{\n\t\tans = get(m,m,a);\n\t\tn -= m;\n\t\tans += n/m * (get(2*m,m,a)-get(m,m,a));\n\t\tn %= m;\n\t\tans += get(m+n,m,a) - get(m,m,a);\n\t}\n\tcout<<ans<<endl;\n\t\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\n\nconst int M_N=400001;\n\nstruct UnionFind{\n    int par[M_N];\n    int rank[M_N];\n\n    void init(int n){\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            rank[i]=0;\n        }\n    }\n\n    int find(int x){\n        if(par[x]==x){\n            return x;\n        }\n        else{\n            return par[x]=find(par[x]);\n        }\n    }\n\n    void unite(int x,int y){\n        x=find(x);\n        y=find(y);\n        if(x==y) return;\n        if(rank[x]<rank[y]){\n            par[x]=y;\n        }\n        else{\n            par[y]=x;\n            if(rank[x]==rank[y]) rank[x]++;\n        }\n    }\n\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n};\n\n\nint main(){\n    LL n,m,q;cin >> n >> m >> q;\n    vector<int> a(q);\n    for (int i = 0; i < q; i++) {\n        cin >> a[i];\n    }\n    LL t = 7 * n / m;\n    vector<vector<int>> v(m, vector<int> (7,0));\n    vector<vector<int>> vv(2 * m, vector<int> (7,0));\n    vector<vector<int>> va(m/7, vector<int> (7,0));\n    vector<vector<int>> vb(2*m/7, vector<int> (7,0));\n    for (int i = 0; i < q; i++) {\n        int y = a[i] / 7, x = a[i] % 7;\n        if(m % 7 == 0){\n            va[y][x] = 1;\n            vb[y][x] = 1;\n            vb[m / 7 + y][x] = 1;\n        }\n        else{\n            for (int j = 0; j < 7; j++) {\n                y = (a[i] + m * j) / 7, x = (a[i] + m * j) % 7;\n                v[y][x] = 1;\n                vv[y][x] = 1;\n                vv[y+m][x] = 1;\n            }\n        }\n    }\n    auto f = [](vector<vector<int>> &a){\n        int h = a.size(), w = a[0].size();\n        UnionFind uf;\n        uf.init(h*w);\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if(j+1<w && a[i][j] == a[i][j+1]) uf.unite(i*7+j,i*7+j+1);\n                if(i+1<h && a[i][j] == a[i+1][j]) uf.unite(i*7+j,(i+1)*7+j);\n            }\n        }\n        int ret = 0;\n        for (int i = 0; i < h*w; i++) {\n            if(uf.find(i) == i && a[i/7][i%7] == 0) ret++;\n        }\n        return ret;\n    };\n    if(m%7==0){\n        if(t == 1){\n            cout << f(va) << endl;\n        }\n        else if(t == 2){\n            cout << f(vb) << endl;\n        }\n        else{\n            cout << f(va) + (t - 1) * (f(vb) - f(va)) << endl;\n        }\n    }\n    else{\n        t = n / m;\n        if(t == 1){\n            cout << f(v) << endl;\n        }\n        else if(t == 2){\n            cout << f(vv) << endl;\n        }\n        else{\n            cout << f(v) + (t - 1) * (f(vv) - f(v)) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN=100010;\n\nint n,m,q,ans;\nint ai[MAXN][8];\nbool pd[MAXN];\n\nvoid dfs(int x,int y)\n{\n\tif (x<0||y<0||x>n-1||y>6||ai[x][y]) return;\n\tai[x][y]=1;\n\tdfs(x,y+1);\n\tdfs(x+1,y);\n\tdfs(x,y-1);\n\tdfs(x-1,y);\n}\nint main()\n{\n\tcin>>n>>m>>q;\n\tfor(int i=1,j;i<=q;i++) cin>>j,pd[j]=true;\n\tfor(int i=0;i<7*n;i++)\n\t\tai[i/7][i%7]=pd[!i%m&&i?m:i%m];\n\t\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<7;j++)\n\t\t\tif (!ai[i][j]) dfs(i,j),ans++;\n\tcout<<ans<<endl;\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PAUSE system(\"pause\")\n#define LLI long long int\n#define LD long double\n#define PB push_back\n#define PF push_front\n#define MP make_pair\n#define FORi(i, a, b) for(int i = a; i < b ; ++i)\n#define FORd(i, a, b) for(int i = a; i > b ; --i)\n\nusing namespace std;\n\nbool walk(int k, int n, vector<bool>& vsd, vector<bool>& stop){\n\tint m = stop.size();\n\tint sz = vsd.size();\n\tif (stop[k%m]){\n\t\treturn 0;\n\t}\n\tif (k>=sz){\n\t\treturn 1;\n\t}\n\t// cout << \"On \" << k << endl;\n\tvector<int> next = {k-7, k-1, k+1, k+7};\n\tbool foreign = 0;\n\tFORi(i,0,4){\n\t\t// cout << \"try \" << next[i] << endl;\n\t\tif (next[i] >= 0 && next[i]<n && (abs(next[i]-k)>1 || next[i]/7==k/7) && !stop[next[i]%m] && !vsd[next[i]]){\n\t\t\t// cout << \"Visiting \" << next[i] << endl;\n\t\t\tvsd[next[i]] = 1;\n\t\t\tforeign |= walk(next[i], n, vsd, stop);\n\t\t}\n\t}\n\treturn foreign;\n}\n\nint main() {\n\tLLI n;\n\tint m,q;\n\tcin >> n >> m >> q;\n\tvector<int> r(q);\n\tvector<bool> stop(m, 0);\n\tFORi(i,0,q){\n\t\tcin >> r[i];\n\t\tstop[r[i]] = 1;\n\t}\n\tint k = 1;\n\twhile(m*k%7){\n\t\tk++;\n\t}\n\tint sz = m*k;\n\tint current = 0, general = 0;\n\tvector<bool> vsd(sz,0);\n\tFORi(i,0,sz){\n\t\tif (!stop[i] && !vsd[i]){\n\t\t\tvsd[i] = 1;\n\t\t\tcurrent++;\n\t\t\tgeneral += walk(i, 7*n, vsd, stop);\n\t\t}\n\t}\n\tLLI cnt = 7 * n / sz;\n\t\n\t// cout << current << ' ' << general << ' ' << cnt << endl;\t\n\t// TODO: handle remainder n%sz\n\tLLI ans = (current-general)*(cnt-1) + current;\n\tcout << ans << endl;\n\tstop.clear();\n\tvsd.clear();\n\tr.clear();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint64_t N;\nint32_t m;\nbool MAP[200001][8];\nbool MOD[700010];\n\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) {\n\tarr = v;\n}\ntemplate<typename T, typename ARR>\nvoid fill_all(ARR& arr, const T& v) {\n\tfor (auto& i : arr) { fill_all(i, v); }\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t Q;\n\tin >> N >> m >> Q;\n\tauto m_l = m;\n\tif ((m_l % 7) != 0) {\n\t\tm_l *= 7;\n\t}\n\tfor (int32_t i = 0; i < Q; ++i)\n\t{\n\t\tint32_t a;\n\t\tin >> a;\n\t\tdo{\n\t\t\tMOD[a] = true;\n\t\t\ta += m;\n\t\t}while (a < m_l);\n\t}\n\tm = m_l;\n\n\tfor (int32_t y = 0; y < (m / 7); ++y) {\n\t\tMAP[y][7] = true;\n\t}\n\tfor (int32_t x = 0; x < 8; ++x) {\n\t\tMAP[(m / 7)][x] = true;\n\t}\n\tint32_t count = 0;\n\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\tfor (int32_t y = 0; y < (m/7); ++y)\n\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t{\n\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\tMAP[y][x] = true;\n\t\t\t}\n\t\t\tif (!MAP[y][x])\n\t\t\t{\n\t\t\t\t++count;\n\t\t\t\tstack.emplace(y, x);\n\t\t\t\tMAP[y][x] = true;\n\t\t\t\twhile (!stack.empty())\n\t\t\t\t{\n\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tint32_t count1 = count;\n\n\tfill_all(MAP, false);\n\tfor (int32_t y = 0; y < (m / 7) * 2; ++y) {\n\t\tMAP[y][7] = true;\n\t}\n\tfor (int32_t x = 0; x < 8; ++x) {\n\t\tMAP[(m / 7) * 2][x] = true;\n\t}\n\tcount = 0;\n\tfor (int32_t y = 0; y < (m / 7)*2; ++y)\n\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t{\n\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\tMAP[y][x] = true;\n\t\t\t}\n\t\t\tif (!MAP[y][x])\n\t\t\t{\n\t\t\t\t++count;\n\t\t\t\tstack.emplace(y, x);\n\t\t\t\tMAP[y][x] = true;\n\t\t\t\twhile (!stack.empty())\n\t\t\t\t{\n\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tout << (count - count1)*((7*N)/m - 1)+count1 << endl;\n\t\n\n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <functional>\n#include <chrono>\n#include <time.h>\nusing namespace std;\n\nint main()\n{\n\tlong long n, m, q; cin >> n >> m >> q;\n\tvector<int>a(q);\n\tfor (int i = 0; i < q; i++)cin >> a[i];\n\n\tint ans = 0;\n\tint b = -1;\n\tfor (int i = 0; i < a.size(); i++) {\n\t\tif (a[i] - b != 1) {\n\t\t\tans++;\n\t\t\tb = a[i];\n\t\t}\n\t}\n\tif (7 - b != 1)ans++;\n\n\tcout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// Union-Find 木 (Verified: AtCoder Typical Contest 001 B)\nstruct UnionFind {\nprivate:\n    const int n;\n    int __size;\n    vector<int> uf;\npublic:\n    // 初期化 UnionFind uni(n) のように宣言すれば良い\n    UnionFind(int _n) : n(_n), __size(_n), uf(_n, -1) {}\n    // find (木の根を求める)\n    int find(int x) {return (uf[x] < 0) ? x : uf[x] = find(uf[x]);}\n    // x と y が同じ集合に属するかどうか\n    bool same(int x, int y) {return find(x) == find(y);}\n    // x が属する集合の要素数\n    int size(int x) {return -uf[find(x)];}\n    // 集合はいくつあるか\n    int size()      {return __size;}\n    // x と y の属する集合を併合\n    void unite(int x, int y) {\n        x = find(x); y = find(y);\n        if(x == y) return;\n        __size--;\n        if(uf[y] < uf[x]) swap(x, y);\n        uf[x] += uf[y]; uf[y] = x;\n    }\n};\n\nconst int W = 7;\nint board[100010][W];\nsigned main() {\n    int N, M, Q; cin >> N >> M >> Q;\n\n    for(int i=0; i<Q; i++) {\n        int A; cin >> A;\n        for(int k=A; k<M*W; k+=M) {\n            int r = k / W, c = k % W;\n            board[r][c] = 1;\n        }\n    }\n\n    int ans = 0;\n    UnionFind uf(M*W);\n    for(int i=0; i<M; i++) {\n        for(int j=0; j<W; j++) {\n            for(int k=0; k<4; k++) {\n                int ni = i + dx[k], nj = j + dy[k];\n                if(ni < 0 or ni >= M or nj < 0 or nj >= W) continue;\n                if(board[i][j] == board[ni][nj]) {\n                    int u = i  * W + j ;\n                    int v = ni * W + nj;\n                    uf.unite(u, v);\n                }\n            }\n        }\n    }\n\n    set<int> white;\n    for(int i=0; i<M; i++) {\n        if(N == i) ans += white.size();\n        for(int j=0; j<W; j++) {\n            if(board[i][j] == 0) white.insert(uf.find(i * W + j));\n        }\n    }\n    if(N >= M) ans += white.size();\n    fprintf(stderr, \"temp ans = %lld\\n\", ans);\n\n    int add = 0;\n    UnionFind uf2((M+1)*W);\n    for(int i=0; i<M; i++) {\n        for(int j=0; j<W; j++) {\n            for(int k=0; k<4; k++) {\n                int ni = i + dx[k], nj = j + dy[k];\n                int mi = ni, mj = nj;\n                if(ni < 0) ni = M - 1, mi = M;\n                if(ni >= M or nj < 0 or nj >= W) continue;\n                if(board[i][j] == board[ni][nj]) {\n                    int u = i  * W + j;\n                    int v = mi * W + mj;\n                    uf2.unite(u, v);\n                }\n            }\n        }\n    }\n    add += uf2.size();\n\n    set<int> white2, ng;\n    for(int j=0; j<W; j++) {\n        ng.insert(uf2.find(M*W + j));\n        white2.insert(uf2.find(M*W + j));\n    }\n\n    int mod = N % M;\n    for(int i=0; i<M; i++) {\n        if(i == mod and N >= M) ans += white2.size() - ng.size();\n        for(int j=0; j<W; j++) {\n            if(board[i][j] == 0) white2.insert(uf2.find(i * W + j));\n        }\n    }\n    \n    add += white2.size();\n    add -= ng.size();\n\n    ans += add * max(0LL, (N / M - 1));\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n \nauto& in = std::cin;\nauto& out = std::cout;\n \nint32_t N, m;\nbool MAP[100001][8];\nbool MOD[100010];\nint32_t a[100010];\n \ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) {\n\tarr = v;\n}\ntemplate<typename T, typename ARR>\nvoid fill_all(ARR& arr, const T& v) {\n\tfor (auto& i : arr) { fill_all(i, v); }\n}\n \nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t Q;\n\tin >> N >> m >> Q;\n\tfor (int32_t i = 0; i < Q; ++i)\n\t{\n\t\tin >> a[i];\n\t\tMOD[a[i]] = true;\n\t}\n \n\tif (N <= 100000)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < N; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tout << count << endl;\n\t}\n\telse if ((m % 7) == 0)\n\t{\n\t\tfor (int32_t y = 0; y < (m / 7); ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[(m / 7)][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < (m/7); ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tint32_t count1 = count;\n \n\t\tfill_all(MAP, false);\n\t\tfor (int32_t y = 0; y < (m / 7) * 2; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[(m / 7) * 2][x] = true;\n\t\t}\n\t\tcount = 0;\n return 0;\n\t\tfor (int32_t y = 0; y < (m / 7)*2; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n \n\t\tout << (count - count1)*((7*N)/m)+count1 << endl;\n\t}\n \n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint n, m, q, a, area[700000] = {}, ans = 0;\nbool x[700000] = {};\nqueue<int> Q;\nint now = 0;\n\nint main(){\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < q; i++){\n\t\tcin >> a;\n\n\t\tint num = 0;\n\t\twhile (num + a < 7 * n){\n\t\t\tx[num + a] = true;\n\t\t\tnum += m;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 7 * n; i++){\n\t\tif (!x[i] && area[i] == 0){\n\t\t\tans++;\n\t\t\tarea[i] = ans;\n\n\t\t\tQ.push(i);\n\t\t\twhile (!Q.empty()){\n\t\t\t\tnow = Q.front();\n\t\t\t\tQ.pop();\n\n\t\t\t\tif (now % 7 != 0 && !x[now - 1] && area[now - 1] == 0){\n\t\t\t\t\tQ.push(now - 1);\n\t\t\t\t\tarea[now - 1] = ans;\n\t\t\t\t}\n\t\t\t\tif (now % 7 != 6 && !x[now + 1] && area[now + 1] == 0){\n\t\t\t\t\tQ.push(now + 1);\n\t\t\t\t\tarea[now + 1] = ans;\n\t\t\t\t}\n\t\t\t\tif (now > 6 && !x[now - 7] && area[now - 7] == 0){\n\t\t\t\t\tQ.push(now - 7);\n\t\t\t\t\tarea[now - 7] = ans;\n\t\t\t\t}\n\t\t\t\tif (now < 7 * (n - 1) && !x[now + 7] && area[now + 7] == 0){\n\t\t\t\t\tQ.push(now + 7);\n\t\t\t\t\tarea[now + 7] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 666666\nint n,m,q,a[SZ];\nbool cov[SZ];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tfor(int i=1;i<=q;i++)\n\tscanf(\"%d\",a+i),cov[a[i]]=1;\n\tif(m==1)\n\t{\n\t\tif(q) puts(\"0\");\n\t\telse puts(\"1\");\n\t\treturn 0;\n\t}\n\tif(m==7)\n\t{\n\t\tprintf(\"%d\\n\",7-q);\n\t\treturn 0;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<map>\n#include<string>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n//#define scanf scanf_s\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\nconst llint mod=1000000007;\n\n\nint main(void){\n\tllint N,M,q,i,j,a,ansa,ansb,ok=0,ans;\n\tqueue<llint> que;\n\tvector<llint> nuru;\n\tset<llint> siro;\n\tscanf(\"%lld %lld %lld\",&N,&M,&q);\n\tfor(i=0;i<q;i++){\n\t\tscanf(\"%lld\",&a);\n\t\tnuru.pub(a);\n\t}\n\tsort(nuru.begin(),nuru.end());\n\tif(M%7!=0){ M*=7;ok=1; }\n\tfor(i=0;i<M;i++){\n\t\tfor(j=0;j<1+ok*6;j++){\n\t\t\tif(!binary_search(nuru.begin(),nuru.end(),i)){ siro.insert(i+j*M); }\n\t\t}\n\t}\n\tansa=0;\n\twhile(siro.size()!=0){\n\t\tque.push(*siro.begin());\n\t\twhile(!que.empty()){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tif(a-7>=0&&siro.find(a-7)!=siro.end()){ que.push(a-7); }\n\t\t\tif(a+7<M&&siro.find(a+7)!=siro.end()){ que.push(a+7); }\n\t\t\tif(a%7!=0&&siro.find(a-1)!=siro.end()){ que.push(a-1); }\n\t\t\tif(a%7!=6&&siro.find(a+1)!=siro.end()){ que.push(a+1); }\n\t\t\tsiro.erase(a);\n\t\t}\n\t\tansa++;\n\t}\n\n\tfor(i=0;i<M;i++){\n\t\tfor(j=0;j<1+ok*6;j++){\n\t\t\tif(!binary_search(nuru.begin(),nuru.end(),i)){ siro.insert(i+j*M/7); }\n\t\t}\n\t\tfor(j=0;j<1+ok*6;j++){\n\t\t\tif(!binary_search(nuru.begin(),nuru.end(),i)){ siro.insert(i+j*M/7+M); }\n\t\t}\n\t}\n\tansb=0;\n\twhile(siro.size()!=0){\n\t\tque.push(*siro.begin());\n\t\twhile(!que.empty()){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tif(a-7>=0&&siro.find(a-7)!=siro.end()){ que.push(a-7); }\n\t\t\tif(a+7<2*M&&siro.find(a+7)!=siro.end()){ que.push(a+7); }\n\t\t\tif(a%7!=0&&siro.find(a-1)!=siro.end()){ que.push(a-1); }\n\t\t\tif(a%7!=6&&siro.find(a+1)!=siro.end()){ que.push(a+1); }\n\t\t\tsiro.erase(a);\n\t\t}\n\t\tansb++;\n\t}\n\tans=(ansb-ansa)*N*7/M+(2*ansa-ansb);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define maxn 700010\nint a[maxn];\nbool col[100010][7], vis[100010][7];\ntypedef long long ll;\nstruct que {\n\tint x, y;\n} qu[maxn];\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\nint up[7], dw[7], Fa[14];\nint Find(int x) {return Fa[x] == x ? x : Fa[x] = Find(Fa[x]);}\nint main()\n{\n\tll n;\n\tint m, q; scanf(\"%lld%d%d\", &n, &m, &q);\n\tfor (int i = 1; i <= q; ++i) scanf(\"%d\", &a[i]);\n\tif (m % 7)\n\t{\n\t\tint nq = q;\n\t\tfor (int i = 1; i <= q; ++i)\n\t\t\tfor (int j = 1; j < 7; ++j)\n\t\t\t\ta[++nq] = a[i] + j * m;\n\t\tm *= 7;\n\t}\n\tint mm = m / 7, cnt = 0;\n\tfor (int i = 1; i <= q; ++i) col[a[i] / 7][a[i] % 7] = 1;\n\n\tfor (int i = 0; i < mm; ++i)\n\t\tfor (int j = 0; j < 7; ++j)\n\t\t\tif (!vis[i][j] && !col[i][j])\n\t\t\t{\n\t\t\t\t++cnt;\n\t\t\t\tint head = 0, tail = 1; qu[1] = (que) {i, j}; vis[i][j] = 1;\n\t\t\t\twhile (head < tail)\n\t\t\t\t{\n\t\t\t\t\tque now = qu[++head];\n\t\t\t\t\tfor (int k = 0, nx, ny; k < 4; ++k)\n\t\t\t\t\t{\n\t\t\t\t\t\tnx = now.x + dx[k]; ny = now.y + dy[k];\n\t\t\t\t\t\tif (nx >= 0 && nx < mm && ny >= 0 && ny < 7 && !vis[nx][ny] && !col[nx][ny])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tqu[++tail] = (que) {nx, ny};\n\t\t\t\t\t\t\tvis[nx][ny] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\tprintf(\"%d\\n\", cnt);\n\tint pcnt = 0, cnt2 = 0;\n\tfor (int i = 0; i < 7; ++i) !col[0][i] ? i == 0 || col[0][i - 1] ? up[i] = ++pcnt : up[i] = pcnt : 0;\n\tfor (int i = 0; i < 7; ++i) !col[mm - 1][i] ? i == 0 || col[mm - 1][i - 1] ? dw[i] = ++pcnt : dw[i] = pcnt : 0;\n\tfor (int i = 1; i <= pcnt; ++i) Fa[i] = i;\n\n//\tfor (int i = 0; i < 7; ++i) printf(\"%d %d\\n\", up[i], dw[i]);\n\tfor (int i = 0; i < 7; ++i)\n\t\tif (up[i] && dw[i] && Find(up[i]) != Find(dw[i]))\n\t\t{\n\t\t\tFa[Find(up[i])] = Find(dw[i]);\n\t\t\t++cnt2;\n\t\t}\n//\tprintf(\"%d\\n\", cnt2);\n\tprintf(\"%lld\\n\", cnt * (n / mm) - 1ll * (n / mm - 1) * cnt2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#define repi(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n#define all(a) (a).begin(), (a).end()\n\nconstexpr int MAX_Q = 100000;\n\nconst int dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };\n\nint n, m, q;\nstd::set<int> a;\nbool fld[1400000][7];\n\nvoid dfs( int v, int h )\n{\n  int i = v/7, j = v%7;\n\n  fld[i][j] = true;\n\n  rep( d, 4 )\n  {\n    int ni = i+dy[d], nj = j+dx[d];\n\n    if( ni >= 0 && ni < h && nj >= 0 && nj < 7 && !fld[ni][nj] )\n      dfs( ni*7+nj, h );\n  }\n\n  return;\n}\n\nint main()\n{\n  scanf( \"%d%d%d\", &n, &m, &q );\n  rep( i, q )\n  {\n    int x;\n    scanf( \"%d\", &x );\n\n    a.insert( x );\n  }\n\n  int k = m%7==0 ? 1 : 7;\n\n  rep( i, k*m )\n    fld[i/7][i%7] = a.find( i%m )!=a.end();\n\n  int cnt = 0;\n  rep( i, k*m ) if( !fld[i/7][i%7] )\n    dfs( i, k*m/7 ), ++cnt;\n\n  rep( i, 2*k*m )\n    fld[i/7][i%7] = a.find( i%m )!=a.end();\n\n  int cnt2 = 0;\n  rep( i, 2*k*m ) if( !fld[i/7][i%7] )\n    dfs( i, 2*k*m/7 ), ++cnt2;\n  \n  int a, b;\n  if( m % 7 == 0 )\n    a = cnt2-cnt, b = cnt-a;\n  else\n    a = (cnt2-cnt)/7, b = cnt-7*a;\n\n  printf( \"%d\\n\", a*7*n/m+b );\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nlong n;int m,q,a[1<<17];\nbool f[7][1<<17];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid bfs(int x,int y,long _n)\n{\n\tqueue<pair<int,int> >P;\n\tf[x][y]=true;\n\tP.push(make_pair(x,y));\n\twhile(!P.empty())\n\t{\n\t\tpair<int,int>p=P.front();P.pop();\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint tx=p.first+dx[r],ty=p.second+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=7||ty>=_n||f[tx][ty])continue;\n\t\t\tf[tx][ty]=true;\n\t\t\tP.push(make_pair(tx,ty));\n\t\t}\n\t}\n}\nmain()\n{\n\tcin>>n>>m>>q;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tif(n<=100000)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong ans=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t\tbfs(i,j,n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\telse if(m%7==0)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,m/7*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,m/7*3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=count2-count1;\n\t\tlong syokou=count1-kousa*2;\n\t\tcout<<syokou+kousa*(n/(m/7))<<endl;\n\t}\n\telse\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<2*m;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<2*m;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,2*m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=count2-count1;\n\t\tlong syokou=count1-kousa;\n\t\tcout<<syokou+kousa/m*n<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\nlong long n, m, q, a[200000];\nbool is_black[200000][7];\nbool visited_1[200000][7];\nbool visited_2[200000][7];\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\n\nvoid visit_1(int r, int c){\n    visited_1[r][c] = true;\n    for(int i = 0; i < 4; i++){\n        int r_ = r + dx[i];\n        int c_ = c + dy[i];\n        if(r_ >= 0 && r_ < m/7 && c_ >= 0 && c_ < 7 && (!is_black[r_][c_]) && (!visited_1[r_][c_])){\n            visit_1(r_, c_);\n        }\n    }\n}\n\nvoid visit_2(int r, int c){\n    visited_2[r][c] = true;\n    for(int i = 0; i < 4; i++){\n        int r_ = r + dx[i];\n        int c_ = c + dy[i];\n        if(r_ >= 0 && r_ < 2*m/7 && c_ >= 0 && c_ < 7 && (!is_black[r_][c_]) && (!visited_2[r_][c_])){\n            visit_2(r_, c_);\n        }\n    }\n}\n\nint main(){\n    cin >> n >> m >> q;\n    if(m % 7 == 0){\n    for(int i = 0; i < q; i++){\n        cin >> a[i];\n        is_black[a[i] / 7][a[i] % 7] = true;\n        is_black[(a[i]+m)/7][a[i]%7] = true;\n    }\n    }else{\n        m *= 7;\n        for(int i = 0; i < q; i++){\n            cin >> a[i];\n            for(int j = 0; j < 7; j++){\n                is_black[(a[i] + j*m/7)/7][(a[i]+j*m/7)%7] = true;\n                is_black[(a[i] + j*m/7 + m)/7][(a[i]+j*m/7)%7] = true;\n            }\n        }\n    }\n    long long cnt_1 = 0;\n    for(int i = 0; i < m/7; i++){\n        for(int j = 0; j < 7; j++){\n            if(!visited_1[i][j] && !is_black[i][j]){\n                visit_1(i, j);\n                cnt_1++;\n            }\n        }\n    }\n\n    long long cnt_2 = 0;\n    for(int i = 0; i < 2*m/7; i++){\n        for(int j = 0; j < 7; j++){\n            if(!visited_2[i][j] && !is_black[i][j]){\n                visit_2(i, j);\n                cnt_2++;\n            }\n        }\n    }\n\n    cout << (cnt_2 - cnt_1) * (7 * n / m) + (2*cnt_1 - cnt_2) << endl;\n    //cout << cnt_1 << endl;\n    //cout << cnt_2 << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long int N, M, Q, a[114514], g[114514], c[114514];\n\nvoid unite(int n, int m);\nvoid unite2(int n, int m);\n\nlong long int connected(){\n    long long int ret = 0;\n    unordered_set<long long int> s{-1}, t{-1}, r;\n    //for(int i = 0; i < M; ++i){\n    //    cout << g[i] << (((i + 1) % 7) ? \" \" : \"\\r\\n\");\n    //}\n    for(int i = 0; i < M; ++i){\n        if(!t.count(g[i])){\n            t.insert(g[i]);\n            unite(i, g[i]);\n        }\n    }\n    //for(int i = 0; i < M; ++i){\n    //    cout << g[i] << (((i + 1) % 7) ? \" \" : \"\\n\");\n    //}\n    for(int i = 0; i < M; ++i){\n        if(!s.count(c[i])){\n            s.insert(c[i]);\n            unite2(i, c[i]);\n        }\n    }\n    s.erase(-1);\n    t.erase(-1);\n    ret = s.size() + t.size() * (7 * N / M - 1);\n    for(int i = 0; i < 7; ++i){\n        if(g[i] != -1 && g[i] == g[i + M - 7]){\n            r.insert(g[i]);\n        }\n    }\n    ret -= r.size() * (7 * N / M - 1);\n    return ret;\n}\n\nvoid unite(int n, int m){\n    if(n < 0 || n >= M || g[n] == -1 || (g[n] == m && n != m)){\n        return ;\n    }\n    g[n] = m;\n    if(n % 7)unite(n - 1, m);\n    if(++n % 7)unite(n, m);\n    if(--n < M - 7)unite(n + 7, m);\n    if(n > 6)unite(n - 7, m);\n}\n\nvoid unite2(int n, int m){\n    if(n < 0 || n >= M || c[n] == -1 || (c[n] == m && n != m)){\n        return ;\n    }\n    c[n] = m;\n    if(n % 7)unite2(n - 1, m);\n    if(++n % 7)unite2(n, m);\n    if(M != 7){\n        unite2((--n + 7) % M, m);\n        unite2((n - 7 + M) % M, m);\n    }\n}\n\nvoid unite3(int n, int m){\n    if(n < 0 || n >= N || g[n] == -1 || (g[n] == m && n != m)){\n        return ;\n    }\n    g[n] = m;\n    if(n % 7)unite(n - 1, m);\n    if(++n % 7)unite(n, m);\n    if(--n < M - 7)unite(n + 7, m);\n    if(n > 6)unite(n - 7, m);\n}\n\nint connected2(){\n    unordered_set<long long int> s{-1};\n    for(int i = 0; i < M; ++i){\n        if(!s.count(g[i])){\n            s.insert(g[i]);\n            unite3(i, g[i]);\n        }\n    }\n    s.erase(-1);\n    return s.size();\n}\n\nint main(){\n    scanf(\"%lld%lld%lld\", &N, &M, &Q);\n    if(M % 7 == 0){\n        for(int i = 0; i < M; ++i)g[i] = c[i] = i;\n        for(int i = 0; i < Q; ++i){\n            scanf(\"%lld\", a + i);\n            g[a[i]] = -1;\n            c[a[i]] = -1;\n        }\n        cout << connected() << endl;\n    }else if(N <= 100000){\n        for(int i = 0; i < N * 7; ++i)g[i] = c[i] = i;\n        for(int i = 0; i < Q; ++i){\n            scanf(\"%lld\", a + i);\n            for(int j = a[i]; j < N * 7; j += M)g[j] = c[j] = -1;\n        }\n        cout << connected2() << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz) : data(sz, -1) {}\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n};\n\n\ntypedef long long int64;\n\n\nint64 N, M, Q, A[100000];\n\nint64 component(int height)\n{\n  int sz = height * 7;\n  UnionFind tree(sz);\n  vector< bool > used(sz, 0);\n\n  for(int i = 0; i < Q; i++) {\n    int64 idx = A[i];\n    while(idx < sz) {\n      used[idx] = true;\n      idx += M;\n    }\n  }\n\n  for(int i = 0; i < height; i++) {\n    for(int j = 0; j < 7; j++) {\n      int idx = i * 7 + j;\n      if(used[idx]) continue;\n      if(j + 1 < 7 && !used[idx + 1]) tree.unite(idx, idx + 1);\n      if(i + 1 < height && !used[idx + 7]) tree.unite(idx, idx + 7);\n    }\n  }\n  int64 ret = 0;\n  for(int i = 0; i < sz; i++) {\n    if(!used[i]) ret += tree.find(i) == i;\n  }\n  return (ret);\n}\n\nint main()\n{\n  cin >> N >> M >> Q;\n  for(int i = 0; i < Q; i++) {\n    cin >> A[i];\n  }\n\n  int MM = M;\n  if(MM % 7) MM *= 7;\n  auto latte = component(MM / 7);\n  auto malta = component(MM * 2 / 7) - latte;\n\n\n  cout << latte + malta * (N * 7 / MM - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<map>\n#include<string>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n//#define scanf scanf_s\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\nconst llint mod=1000000007;\n\n\nint main(void){\n\tllint N,M,q,i,j,a,ansa,ansb,ok=0,ans;\n\tqueue<llint> que;\n\tvector<llint> nuru;\n\tset<llint> siro;\n\tscanf(\"%lld %lld %lld\",&N,&M,&q);\n\tfor(i=0;i<q;i++){\n\t\tscanf(\"%lld\",&a);\n\t\tnuru.pub(a);\n\t}\n\t\n\tif(M%7!=0){ \n\t\tfor(i=0;i<q;i++){\n\t\t\tfor(j=1;j<7;j++){\n\t\t\t\tnuru.pub(nuru[i]+M*j);\n\t\t\t}\n\t\t}\n\t\tM*=7;ok=1;\n\t}\n\tsort(nuru.begin(),nuru.end());\n\tfor(i=0;i<M;i++){\n\t\tif(!binary_search(nuru.begin(),nuru.end(),i)){ siro.insert(i); }\n\t}\n\tansa=0;\n\twhile(siro.size()!=0){\n\t\tque.push(*siro.begin());\n\t\twhile(!que.empty()){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tif(a-7>=0&&siro.find(a-7)!=siro.end()){ que.push(a-7); }\n\t\t\tif(a+7<M&&siro.find(a+7)!=siro.end()){ que.push(a+7); }\n\t\t\tif(a%7!=0&&siro.find(a-1)!=siro.end()){ que.push(a-1); }\n\t\t\tif(a%7!=6&&siro.find(a+1)!=siro.end()){ que.push(a+1); }\n\t\t\tsiro.erase(a);\n\t\t}\n\t\tansa++;\n\t}\n\n\tfor(i=0;i<M;i++){\n\t\t\tif(!binary_search(nuru.begin(),nuru.end(),i)){ siro.insert(i); }\n\t\t\n\t\t\tif(!binary_search(nuru.begin(),nuru.end(),i)){ siro.insert(i+M); }\n\t}\n\tansb=0;\n\twhile(siro.size()!=0){\n\t\tque.push(*siro.begin());\n\t\twhile(!que.empty()){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tif(a-7>=0&&siro.find(a-7)!=siro.end()){ que.push(a-7); }\n\t\t\tif(a+7<2*M&&siro.find(a+7)!=siro.end()){ que.push(a+7); }\n\t\t\tif(a%7!=0&&siro.find(a-1)!=siro.end()){ que.push(a-1); }\n\t\t\tif(a%7!=6&&siro.find(a+1)!=siro.end()){ que.push(a+1); }\n\t\t\tsiro.erase(a);\n\t\t}\n\t\tansb++;\n\t}\n\tans=(ansb-ansa)*N*7/M+(2*ansa-ansb);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// Union-Find 木 (Verified: AtCoder Typical Contest 001 B)\nstruct UnionFind {\nprivate:\n    const int n;\n    int __size;\n    vector<int> uf;\npublic:\n    // 初期化 UnionFind uni(n) のように宣言すれば良い\n    UnionFind(int _n) : n(_n), __size(_n), uf(_n, -1) {}\n    // find (木の根を求める)\n    int find(int x) {return (uf[x] < 0) ? x : uf[x] = find(uf[x]);}\n    // x と y が同じ集合に属するかどうか\n    bool same(int x, int y) {return find(x) == find(y);}\n    // x が属する集合の要素数\n    int size(int x) {return -uf[find(x)];}\n    // 集合はいくつあるか\n    int size()      {return __size;}\n    // x と y の属する集合を併合\n    void unite(int x, int y) {\n        x = find(x); y = find(y);\n        if(x == y) return;\n        __size--;\n        if(uf[y] < uf[x]) swap(x, y);\n        uf[x] += uf[y]; uf[y] = x;\n    }\n};\n\nconst int W = 7;\nint board[100010][W];\nsigned main() {\n    int N, M, Q; cin >> N >> M >> Q;\n\n    for(int i=0; i<Q; i++) {\n        int A; cin >> A;\n        for(int k=A; k<M*W; k+=M) {\n            int r = k / W, c = k % W;\n            board[r][c] = 1;\n        }\n    }\n\n    int ans = 0;\n    UnionFind uf(M*W);\n    for(int i=0; i<M; i++) {\n        for(int j=0; j<W; j++) {\n            for(int k=0; k<4; k++) {\n                int ni = i + dx[k], nj = j + dy[k];\n                if(ni < 0 or ni >= M or nj < 0 or nj >= W) continue;\n                if(board[i][j] == board[ni][nj]) {\n                    int u = i  * W + j ;\n                    int v = ni * W + nj;\n                    uf.unite(u, v);\n                }\n            }\n        }\n    }\n\n    set<int> white;\n    for(int i=0; i<M; i++) {\n        if(N == i) ans += white.size();\n        for(int j=0; j<W; j++) {\n            if(board[i][j] == 0) white.insert(uf.find(i * W + j));\n        }\n    }\n    if(N >= M) ans += white.size();\n    fprintf(stderr, \"temp ans = %lld\\n\", ans);\n\n    int add = 0;\n    UnionFind uf2((M+1)*W);\n    for(int i=0; i<M; i++) {\n        for(int j=0; j<W; j++) {\n            for(int k=0; k<4; k++) {\n                int ni = i + dx[k], nj = j + dy[k];\n                int mi = ni, mj = nj;\n                if(ni < 0) ni = M - 1, mi = M;\n                if(ni >= M or nj < 0 or nj >= W) continue;\n                if(board[i][j] == board[ni][nj]) {\n                    int u = i  * W + j;\n                    int v = mi * W + mj;\n                    uf2.unite(u, v);\n                }\n            }\n        }\n    }\n\n    set<int> white2, ng;\n    for(int j=0; j<W; j++) {\n        ng.insert(uf2.find(M*W + j));\n        white2.insert(uf2.find(M*W + j));\n    }\n\n    int mod = N % M;\n    for(int i=0; i<M; i++) {\n        if(i == mod and N >= M) ans += white2.size() - ng.size();\n        for(int j=0; j<W; j++) {\n            if(board[i][j] == 0) white2.insert(uf2.find(i * W + j));\n        }\n    }\n    \n    add += white2.size();\n    add -= ng.size();\n    fprintf(stderr, \"add = %lld\\n\", add);\n\n    ans += add * max(0LL, (N / M - 1));\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <sstream>\n# include <cstdio>\n# include <cstdlib>\n# include <algorithm>\n# include <string>\n# include <cstring>\n# include <cmath>\n# include <stack>\n# include <queue>\n# include <vector>\n# include <list>\n# include <map>\n# include <set>\n# include <deque>\n# include <iterator>\n# include <functional>\n# include <bitset>\n# include <climits>\n# include <ctime>\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define odd(x) ((x)%2)\ntypedef long long ll;\ntypedef long double ld;\nconst ll oo=2*1000*1000*1000;\nconst int _cnt=1000*1000;\nconst int _p=1000*1000*1000+7;\nint o(int x) { return x%_p; }\nint gcd(int a,int b) { return (b)?gcd(b,a%b):a; }\nint lcm(int a,int b) { return a/gcd(a,b)*b; }\nusing namespace std;\n\nvoid file_put(){\n\tfreopen(\"filename.in\",\"r\",stdin);\n\tfreopen(\"filename.out\",\"w\",stdout);\n}\n\nint n,m,q,a[15],x,ans=0;\n\nint main(){\n\t//file_put();\n\t\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tfor (int i=1; i<=n; i++) {\n\t\tscanf(\"%d\",&x);\n\t\tx%=m;\n\t\ta[x]=1;\n\t}\n\ta[7]=1;\n\tfor (int i=1; i<=7; i++) ans+=(a[i]>0 && a[i-1]==0);\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nbool t[7][200020],vis[7][200020];\nlong long n,m,q,a;\n\nvoid DFS(int x,int y,int lim){\n\tvis[x][y]=true;\n\tint dx[]={-1,0,0,1},dy[]={0,1,-1,0};\n\tfor(int i=0;i<4;i++){\n\t\tint a=x+dx[i],b=y+dy[i];\n\t\tif(a>=0&&b>=0&&a<7&&b<lim){\n\t\t\tif(!vis[a][b])DFS(a,b,lim);\n\t\t}\n\t}\n}\nint Sol(int lim){\n\tint ret=0;\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<lim;j++){\n\t\t\tvis[i][j]=t[i][j];\n\t\t\t//cout<<t[i][j]<<\" \";\n\t\t}\n\t\t//cout<<endl;\n\t}\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<lim;j++){\n\t\t\tif(!vis[i][j]){\n\t\t\t\tret++;\n\t\t\t\tDFS(i,j,lim);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tcin>>n>>m>>q;\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tt[i][j]=0;\n\t\t}\n\t}\n\twhile(q--){\n\t\tcin>>a;\n\t\tfor(int i=a;i<14*m;i+=m){\n\t\t\tt[i%7][i/7]=1;\n\t\t}\n\t}\n\n\tlong long k=Sol(m),w=Sol(m*2),ans;\n\tint g=n/m;\n\tif(g<=1)ans=Sol(n);\n\telse ans=(g-1)*(w-k)+Sol(n);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nint a[100000];\nbool used[100000];\nbool used_root[700000];\n\nint main(){\n    long n, m, q;\n    cin >> n >> m >> q;\n    for(int i = 0; i < q; i++) {\n        cin >> a[i];\n        used[a[i]] = true;\n    }\n    int M;\n    if(m%7 != 0) M =  min(7*m, 7*n);\n    else  M =  min(m, 7*n);\n    UnionFind uf(M);\n    for(int i = 0; i < M; i++){\n        if(used[i%m]) continue;\n        if(i%7 != 6){\n            if(!used[(i+1)%m]) uf.unionSet(i, i+1);\n        }\n        if(i+7 < M){\n            if(!used[(i+7)%m]) uf.unionSet(i, i+7);\n        }\n    }\n    long cnt = 0;\n    for(int i = 0; i < M; i++){\n        if(!used[i%m]){\n            int r = uf.root(i);\n            //cout << r << endl;\n            if(!used_root[r]){\n                cnt++;\n                used_root[r] = true;\n            }\n        }\n    }\n    //cout << M << endl;\n    //cout << cnt << endl;\n    long cnt_ = cnt;\n    for(int i = M-7; i < M; i++){\n        if(!used[(i)%m]) {\n            //cout << i << endl;\n            if(!used[i+7-M] && !uf.findSet(i, i+7-M)){\n                uf.unionSet(i, i+7-M);\n                cnt_--;\n            }\n        }\n    }\n    //cout << cnt_ << endl;\n    long s = (7*n)/M;\n    long ans = cnt+cnt_*(s-1);\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\n#include <string>\n#include <vector>\n#include <algorithm>\n\n#include <cassert>\n\nusing namespace std;\n\n#define SZ(a) int((a).size())\n#define REP(i,n) for(int i=0,_n=(n);i<_n;++i)\n#define FOR(i,a,b) for(int i=(a),_b=(b);i<=_b;++i)\n\ntypedef long long llong;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\n#define MAXM 100004\nllong N, nblocks;\nint K;\nVI A;\n\nint MM;\nchar B[7][MAXM];\n\nint ncomps;\nint C[7][MAXM];\nvoid flood_fill(int r, int c) {\n   if (r < 0 || r >= MM || c < 0 || c >= 7) return;\n   if (B[c][r] == '#') return;\n   if (C[c][r]) return;\n   C[c][r] = ncomps;\n\n   flood_fill(r-1, c);\n   flood_fill(r, c-1);\n   flood_fill(r, c+1);\n   flood_fill(r+1, c);\n}\n\nint dfs(const VVI& adj, VI& vis, int u) {\n   int res = 1;\n   vis[u] = 1;\n   for (int v : adj[u]) {\n      if (!vis[v])\n         res += dfs(adj, vis, v);\n   }\n   return res;\n}\n\nllong solve() {\n   MM = (K % 7) ? K : K/7;\n\n   //cerr << \"MM: \" << MM << endl;\n\n   for (int rem : A) {\n      for (; rem < 7*MM; rem += K) {\n         int r = rem / 7;\n         int c = rem % 7;\n         B[c][r] = '#';\n      }\n   }\n\n   /*\n   REP(r, MM) {\n      REP(c, 7)\n         cerr << B[c][r];\n      cerr << endl;\n   }\n   */\n\n   REP(r, MM) {\n      REP(c, 7) {\n         if (B[c][r] != '#' && C[c][r] == 0) {\n            ++ncomps;\n            flood_fill(r, c);\n         }\n      }\n   }\n\n   /*\n   REP(r, MM) {\n      REP(c, 7)\n         cerr << C[c][r] << ' ';\n      cerr << endl;\n   }\n   */\n   \n   VVI adj(ncomps);\n   REP(c, 7) {\n      int u = C[c][0] - 1, v = C[c][MM-1] - 1;\n      if (u >= 0 && v >= 0) {\n         adj[u].push_back(v);\n         if (u != v)\n            adj[v].push_back(u);\n      }\n   }\n\n   llong nblocks = N / MM;\n   //cerr << \"Number of blocks = \" << nblocks << endl;\n   llong res = 0;\n   VI vis(ncomps);\n   REP(u, ncomps) {\n      if (vis[u]) continue;\n      if (adj[u].empty())\n         res += nblocks;\n      else {\n         bool self = find(adj[u].begin(), adj[u].end(), u) != adj[u].end();\n         int cnt = dfs(adj, vis, u);\n         if (self)\n            ++res;\n         else {\n            FOR(len, 1, cnt-1) {\n               if (nblocks >= len)\n                  res += 2;\n            }\n            res += max(nblocks - cnt + 1, 0LL);\n         }\n      }\n   }\n\n   return res;\n}\n\n\nint main(int argc, char* argv[]) {\n   ios_base::sync_with_stdio(false); \n   cin.tie(NULL);\n\n   int Q;\n   cin >> N >> K >> Q;\n   memset(B, '.', sizeof(B));\n\n   A = VI(Q);\n   REP(j, Q)\n      cin >> A[j];\n\n   llong res = solve();\n   cout << res << endl;\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll N,M,Q;\nint A[101010];\nint col[1500000];\n\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank,cnt;\n\tUF() {par=rank=vector<int>(um,0); cnt=vector<int>(um,1); for(int i=0;i<um;i++) par[i]=i;}\n\tvoid reinit() {int i; FOR(i,um) rank[i]=0,cnt[i]=1,par[i]=i;}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint count(int x) { return cnt[operator[](x)];}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tcnt[y]=cnt[x]=cnt[x]+cnt[y];\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\n\nUF<1407070> uf1,uf2,uftail;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>Q;\n\tFOR(i,Q) {\n\t\tcin>>A[i];\n\t\tfor(j=A[i];j<14*M;j+=M) col[j]=1;\n\t}\n\t\n\tll pat=N / (7*M);\n\tN %= 7*M;\n\t\n\t\n\tif(pat==0) {\n\t\tFOR(i,7*N) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uftail(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<7*N) && col[i+7]==0) uftail(i,i+7);\n\t\t}\n\t\tint ret=0;\n\t\tFOR(i,7*N) if(col[i]==0 && uftail[i]==i) ret++;\n\t}\n\telse {\n\t\tFOR(i,7*M) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uf1(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<7*M) && col[i+7]==0) uf1(i,i+7);\n\t\t}\n\t\tFOR(i,14*M) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uf2(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<14*M) && col[i+7]==0) uf2(i,i+7);\n\t\t}\n\t\tint num[3]={};\n\t\tFOR(i,7*M) if(col[i]==0 && uf1[i]==i) num[0]++;\n\t\tFOR(i,14*M) if(col[i]==0 && uf2[i]==i) num[1]++;\n\t\t\n\t\tif(N==0) {\n\t\t\tcout<<num[1]+(pat-1)*(num[2]-num[1])<<endl;\n\t\t}\n\t\telse {\n\t\t\tFOR(i,7*(N+M)) {\n\t\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uftail(i,i+1);\n\t\t\t\tif(col[i]==0 && (i+7<7*(N+M)) && col[i+7]==0) uftail(i,i+7);\n\t\t\t}\n\t\t\tint ret=0;\n\t\t\tFOR(i,7*(N+M)) if(col[i]==0 && uftail[i]==i) ret++;\n\t\t\tcout<<ret+(pat-1)*(num[2]-num[1])<<endl;\n\t\t}\n\t}\n\t\n}\n\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef pair<ll,P> T;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define LLINF 1000000000000000ll\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nll n;\nint m,q;\nint a[100100];\nint c[100100];\nint main(){\n\tscanf(\"%lld %d %d\",&n,&m,&q);\n\tfor(int i=0;i<q;i++){\n\t\tint tmp;\n\t\tscanf(\"%d\",&tmp);\n\t\ta[tmp]=1;\n\t}\n\tint k=0;\n\tmemset(c,-1,sizeof(c));\n\tint M = m;\n\tif(m%7!=0)M*=7;\n\tll l = 7*n/M;\n\tll A = 0ll,B = 0ll;\n\tfor(int i=0;i<2*M;i++){\n\t\tif(a[i%m]){\n\t\t\tcontinue;\n\t\t}else{\n\t\t\tif(i-7>=0&&c[i-7]!=-1)c[i]=c[i-7];\n\t\t\telse if(i%7!=0&&c[i-1]!=-1)c[i]=c[i-1];\n\t\t\telse{\n\t\t\t\tc[i]=k++;\n\t\t\t}\n\t\t}\n\t\tif(i==M-1)A=k;\n\t\tif(i==2*M-1)B=k;\n\t}\n\tcout << A+(B-A)*(l-1ll) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define RREP(i, x, n) for(int i = x; i >= n; i--)\n#define rrep(i, n) RREP(i,n,0)\n#define pb push_back\n#pragma GCC optimize (\"-O3\")\n\nusing namespace std;\n\n// #define DEBUG_IS_VALID\n\n#ifdef DEBUG_IS_VALID\n#define DEB 1 \n#else\n#define DEB 0\n#endif\n#define DUMPOUT cout\n#define dump(...) if(DEB) DUMPOUT<<\"  \"<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl<<\"    \"; if(DEB) dump_func(__VA_ARGS__)\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, pair<T1,T2> p){cout << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate<typename T>ostream& operator << (ostream& os, vector<T>& vec) { os << \"{\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"}\"; return os; }\ntemplate<typename T>ostream& operator << (ostream& os, set<T>& st){for(auto itr = st.begin(); itr != st.end(); itr++) cout << *itr << (next(itr)!=st.end() ? \", \" : \"\"); cout << \"}\"; return os;}\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, map<T1,T2> mp){cout << \"{\"; for(auto itr = mp.begin(); itr != mp.end(); itr++) cout << \"(\" << (itr->first) << \", \" << (itr->second) << \")\" << (next(itr)!=mp.end() ? \",\" : \"\"); cout << \"}\"; return os; }\n\nvoid dump_func(){DUMPOUT << endl;}\ntemplate <class Head, class... Tail>void dump_func(Head&& head, Tail&&... tail){ DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...);}\ntemplate<class T> inline bool chmax(T& a,T const& b){if(a>=b) return false; a=b; return true;}\ntemplate<class T> inline bool chmin(T& a,T const& b){if(a<=b) return false; a=b; return true;}\n\nusing ll = long long;\nusing P = pair<int,int>;\nusing Pl = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\n\nconst int mod=1e9+7,INF=1<<29;\nconst double EPS=1e-12,PI=3.1415926535897932384626;\nconst ll lmod = 1e9+7,LINF=1LL<<59; \n\nstruct UnionFindTree{\n  vector<int> par,rank,size;\n  UnionFindTree(int N){\n    par = rank = vector<int>(N,0);\n    size = vector<int>(N,1);\n    for(int i = 0; i < N; i++) par[i] = i;\n  }\n  int find(int x){\n    if(par[x] == x) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x,int y){\n    x = find(x);\n    y = find(y);\n    if(x == y)  return ;\n    if(rank[x] < rank[y]){\n      par[x] = y;\n    }else{\n      par[y] = x;\n      if(rank[x] == rank[y]) ++rank[x];\n    }\n    size[x] = size[y] = size[x] + size[y];\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll N,M,Q; cin >> N >> M >> Q ;\n  ll sp_sz;\n  if(M%7==0) sp_sz = M;\n  else sp_sz = 7 * M;\n  vector<bool> is_black(sp_sz,false);\n  rep(i,Q){\n    int a; cin >> a ;\n    for(int x = a; x < sp_sz ; x += M){\n      is_black[x] = true;\n    }\n  }\n  UnionFindTree uft(2*sp_sz);\n  vi dx = {-1,0,1,0};\n  vi dy = {0,-1,0,1};\n  rep(i,sp_sz){\n    if(is_black[i]) continue;\n    rep(j,4){\n      int x = i + dx[j]*7 + dy[j];\n      if(x<0 || x>=sp_sz) continue;\n      if(is_black[x]) continue;\n      uft.unite(i,x);\n      uft.unite(i+M,x+M);\n    }\n  }\n  ll sz1,sz2;\n  rep(i,sp_sz){\n    if(is_black[i]) continue;\n    if(uft.par[i]==i) sz1++;\n  }\n  REP(i,sp_sz-7,sp_sz){\n    if(is_black[i]||is_black[(i+7)%sp_sz]) continue;\n    uft.unite(i,i+7);\n  }\n  rep(i,2*sp_sz){\n    if(is_black[i%sp_sz]) continue;\n    if(uft.par[i]==i) sz2++; \n  }\n  dump(is_black);\n  dump(sz1,sz2);\n  ll diff = sz1 * 2 - sz2;\n  ll temp = 7*N/sp_sz;\n  cout << sz1 * temp - diff * (temp-1) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n// #define DEBUG\n#ifdef DEBUG\n#define dump(...) cerr<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<make_tuple(__VA_ARGS__)<<\"\\n\";\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '{'; for(int i = 0; i < (int) v.size(); i++) o << v[i] << (i != (int)v.size()-1 ? \", \" : \"\"); o << \"}\";  return o; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\n#else\n#define dump(...)\n#endif\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  ll n, m, q; cin >> n >> m >> q;\n  ll h = (m + 6) / 7; // one shared block\n  ll period = h * 7 - (7 - m % 7) % 7; // height of period\n  if(period % 7 == 0) period /= 7;\n  ll full = n / period;\n  ll rest = n - full * period;\n  vector< vector<int> > f(period, vector<int>(7) );\n  auto used = f;\n  auto used2 = f;\n  auto used3 = f;\n\n  while(q--) {\n    ll a; cin >> a;\n    for(; a < period * 7; a += m) {\n      ll y = a / 7, x = a % 7;\n      f[y][x] = 1;\n    }\n  }\n  dump(f);\n\n  ll block = 0;\n  for(ll y = 0; y < period; y++)\n    for(ll x = 0; x < 7; x++) {\n      if(f[y][x]) continue;\n      if(used[y][x]) continue;\n      used[y][x] = 1;\n      queue<pair<ll, ll>> q;\n      q.emplace(y, x);\n      block++;\n      while(q.size()) {\n        ll yy = q.front().first, xx = q.front().second;\n        q.pop();\n        for(int d = 0; d < 4; d++) {\n          ll ny = yy + dy[d];\n          ll nx = xx + dx[d];\n          if(ny < 0 || period <= ny || nx < 0 || 7 <= nx) continue;\n          if(f[ny][nx]) continue;\n          if(used[ny][nx]) continue;\n          used[ny][nx] = 1;\n          q.emplace(ny, nx);\n        }\n      }\n    }\n\n  ll black = 0;\n  {\n    ll y = period - 1;\n    for(ll x = 0; x < 7; x++) {\n      if(f[y][x]) continue;\n      if(used2[y][x]) continue;\n      if(f[0][x]) continue;\n      used2[y][x] = 1;\n      queue<pair<ll, ll>> q;\n      q.emplace(y, x);\n      black++;\n      while(q.size()) {\n        ll yy = q.front().first, xx = q.front().second;\n        q.pop();\n        for(int d = 0; d < 4; d++) {\n          ll ny = yy + dy[d];\n          ll nx = xx + dx[d];\n          if(ny < 0 || period <= ny || nx < 0 || 7 <= nx) continue;\n          if(f[ny][nx]) continue;\n          if(used2[ny][nx]) continue;\n          used2[ny][nx] = 1;\n          q.emplace(ny, nx);\n        }\n      }\n    }\n  }\n\n  ll last = 0;\n  for(ll y = 0; y < rest; y++)\n    for(ll x = 0; x < 7; x++) {\n      if(f[y][x]) continue;\n      if(used3[y][x]) continue;\n      used3[y][x] = 1;\n      queue<pair<ll, ll>> q;\n      q.emplace(y, x);\n      last++;\n      while(q.size()) {\n        ll yy = q.front().first, xx = q.front().second;\n        q.pop();\n        for(int d = 0; d < 4; d++) {\n          ll ny = yy + dy[d];\n          ll nx = xx + dx[d];\n          if(ny < 0 || rest <= ny || nx < 0 || 7 <= nx) continue;\n          if(f[ny][nx]) continue;\n          if(used3[ny][nx]) continue;\n          used3[ny][nx] = 1;\n          q.emplace(ny, nx);\n        }\n      }\n    }\n  dump(full);\n  dump(block, black, last);\n\n  ll ans = 0;\n  ans += full * (block - black);\n  if(rest) {\n    ans += last;\n  } else {\n    ans += black;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll N,M,Q;\nint A[101010];\nint col[1500000];\n\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank,cnt;\n\tUF() {par=rank=vector<int>(um,0); cnt=vector<int>(um,1); for(int i=0;i<um;i++) par[i]=i;}\n\tvoid reinit() {int i; FOR(i,um) rank[i]=0,cnt[i]=1,par[i]=i;}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint count(int x) { return cnt[operator[](x)];}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tcnt[y]=cnt[x]=cnt[x]+cnt[y];\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\n\nUF<1407070> uf1,uf2,uftail;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>Q;\n\tFOR(i,Q) {\n\t\tcin>>A[i];\n\t\tfor(j=A[i];j<14*M;j+=M) col[j]=1;\n\t}\n\t\n\tll pat;\n\tint num[3]={};\n\tif(M%7==0) {\n\t\tFOR(i,M) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uf1(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<M) && col[i+7]==0) uf1(i,i+7);\n\t\t}\n\t\tFOR(i,2*M) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uf2(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<2*M) && col[i+7]==0) uf2(i,i+7);\n\t\t}\n\t\tFOR(i,M) if(col[i]==0 && uf1[i]==i) num[0]++;\n\t\tFOR(i,2*M) if(col[i]==0 && uf2[i]==i) num[1]++;\n\t\tpat=7*N/M;\n\t}\n\telse {\n\t\tFOR(i,7*M) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uf1(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<7*M) && col[i+7]==0) uf1(i,i+7);\n\t\t}\n\t\tFOR(i,14*M) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uf2(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<14*M) && col[i+7]==0) uf2(i,i+7);\n\t\t}\n\t\tint num[3]={};\n\t\tFOR(i,7*M) if(col[i]==0 && uf1[i]==i) num[0]++;\n\t\tFOR(i,14*M) if(col[i]==0 && uf2[i]==i) num[1]++;\n\t\tpat=N/M;\n\t}\n\tcout<<num[0]+(pat-1)*(num[1]-num[0])<<endl;\n\t\n}\n\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/***********************************************\n#\n#      Filename: c.cpp\n#\n#        Author: Comsyl - ylsong15@fudan.edu.cn\n#   Description: ---\n#        Create: 2017-05-19 23:53:20\n***********************************************/\n#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll n;\nint m, q;\nbool vis[100000 + 10];\nbool bao[100000 + 10][7];\nbool used[100000 + 10][7];\n\nvoid paint(int base) {\n    for (int i = 0; i < m; ++ i) {\n        if (vis[i]) {\n            int r = i / 7;\n            int c = i % 7;\n            bao[r + base][c] = true;\n        }\n    }\n}\n\nint dir[4][2] = {{-1,0}, {0,1}, {1,0}, {0,-1}};\nvoid dfs(int x, int y, int rmax) {\n    used[x][y] = true;\n    for (int i = 0; i < 4; ++ i) {\n        int nx = x + dir[i][0];\n        int ny = y + dir[i][1];\n        if (nx>=0 && nx<rmax && ny>=0 && ny<7 && !used[nx][ny] && !bao[nx][ny]) {\n            dfs(nx, ny, rmax);\n        }\n    }\n}\n\nint main()\n{\n    cin >> n >> m >> q;\n    int r;\n    for (int i = 0; i < q; ++ i) {\n        cin >> r;\n        vis[r] = true;\n    }\n\n    paint(0);\n    int count1 = 0;\n    for (int i = 0; i < m/7; ++ i) {\n        for (int j = 0; j < 7; ++ j) {\n            if (!bao[i][j] && !used[i][j]) {\n                dfs(i, j, m/7);\n                ++ count1;\n            }\n        }\n    }\n\n    paint(m/7);\n    int count2 = 0;\n    memset(used, false, sizeof(used));\n    for (int i = 0; i < 2*m/7; ++ i) {\n        for (int j = 0; j < 7; ++ j) {\n            if (!bao[i][j] && !used[i][j]) {\n                dfs(i, j, 2*m/7);\n                ++ count2;\n            }\n        }\n    }\n\n    cout << count1 * 1L + (count2 - count1) * 1L * (n / (m/7) - 1L) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M >> K;\n\tvector<int>box(M);\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> L;\n\t\tbox[L] = 1;\n\t}\n\tvector<vector<int>>v(M * 2, vector<int>(7));\n\tfor (int i = 0; i < M * 2; i++) {\n\t\tfor (int j = 0; j < 7; j++) {\n\t\t\tv[i][j] = box[(i * 7 + j) % M];\n\t\t}\n\t}\n\tint dir[] = { 1,0,-1,0,1 };\n\tlong long int a = 0, b = 0;\n\tqueue<pair<int, int>>Q;\n\tfor (int i = 0; i < M; i++) {\n\t\tfor (int j = 0; j < 7; j++) {\n\t\t\tif (v[i][j])continue;\n\t\t\ta++;\n\t\t\tQ.push({ i,j });\n\t\t\tv[i][j] = MOD;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint y = Q.front().first;\n\t\t\t\tint x = Q.front().second;\n\t\t\t\tQ.pop();\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint ny = y + dir[k];\n\t\t\t\t\tint nx = x + dir[k + 1];\n\t\t\t\t\tif (ny < 0 || nx < 0 || ny >= M || nx >= 7)continue;\n\t\t\t\t\tif (v[ny][nx])continue;\n\t\t\t\t\tv[ny][nx] = MOD;\n\t\t\t\t\tQ.push({ ny,nx });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto &i : v) {\n\t\tfor (auto &j : i)j %= MOD;\n\t}\n\tM <<= 1;\n\tfor (int i = 0; i < M; i++) {\n\t\tfor (int j = 0; j < 7; j++) {\n\t\t\tif (v[i][j])continue;\n\t\t\tb++;\n\t\t\tQ.push({ i,j });\n\t\t\tv[i][j] = MOD;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint y = Q.front().first;\n\t\t\t\tint x = Q.front().second;\n\t\t\t\tQ.pop();\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint ny = y + dir[k];\n\t\t\t\t\tint nx = x + dir[k + 1];\n\t\t\t\t\tif (ny < 0 || nx < 0 || ny >= M  || nx >= 7)continue;\n\t\t\t\t\tif (v[ny][nx])continue;\n\t\t\t\t\tv[ny][nx] = MOD;\n\t\t\t\t\tQ.push({ ny,nx });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tb -= a;\n\ta += ((N * 2 / M) - 1)*b;\n\tcout << a << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG_ \n#include \"../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\nint main(void) {\n    ll n, m, q;\n    cin >> n >> m >> q;\n    vector<ll> a(q);\n    REP(i, q) cin >> a[i];\n\n    ll period = 7 * m / __gcd(7LL, m);\n    vector<int> col(period);\n    REP(i, q) {\n        for(ll j = a[i]; j<period; j+=m) {\n            col[j] = 1;\n        }\n    }\n\n    dump(period);\n    dump(col);\n\n    vector<bool> used(period);\n    function<void(ll)> dfs = [&](ll v) {\n        used[v] = true;\n        for(auto to: {v-1, v+1, v-7, v+7}) {\n            if(to == v-1 && v%7==0) continue;\n            if(to == v+1 && v%7==6) continue;\n            if(0<=to && to<used.size() && !used[to] && col[to%period]==0) {\n                dfs(to);\n            }\n        }\n    };\n    ll num1 = 0;\n    REP(i, period) {\n        if(used[i] || col[i]==1) continue;\n        num1++;\n        dfs(i);\n    }\n    ll num2 = 0;\n    used.assign(period*2, false);\n    REP(i, period*2) {\n        if(used[i] || col[i%period]==1) continue;\n        num2++;\n        dfs(i);\n    }\n\n    dump(num1, num2, 7 * n / period);\n\n    cout << num1 * 7 * n / period - (7 * n / period - 1) * (num1*2 - num2) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint64_t N;\nint32_t m;\nbool MAP[200001][8];\nbool MOD[700010];\n\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) {\n\tarr = v;\n}\ntemplate<typename T, typename ARR>\nvoid fill_all(ARR& arr, const T& v) {\n\tfor (auto& i : arr) { fill_all(i, v); }\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t Q;\n\tin >> N >> m >> Q;\n\tauto m_l = m;\n\tif ((m_l % 7) != 0) {\n\t\tm_l *= 7;\n\t}\n\tfor (int32_t i = 0; i < Q; ++i)\n\t{\n\t\tint32_t a;\n\t\tin >> a;\nif(!(a < m_l)){throw 0;}\n\t\tdo{\n\t\t\tMOD[a] = true;\n\t\t\ta += m;\n\t\t}while (a < m_l);\n\t}\n\tm = m_l;\n\n\tif (N <= 100000)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < N; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tout << count << endl;\n\t}\n\telse\n\t{\n\t\tfor (int32_t y = 0; y < (m / 7); ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[(m / 7)][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < (m/7); ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tint32_t count1 = count;\n\n\t\tfill_all(MAP, false);\n\t\tfor (int32_t y = 0; y < (m / 7) * 2; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[(m / 7) * 2][x] = true;\n\t\t}\n\t\tcount = 0;\n\t\tfor (int32_t y = 0; y < (m / 7)*2; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tout << (count - count1)*((7*N)/m)+count1 << endl;\n\t}\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=100003,INF=1<<30;\nvector<vector<int>> state(MAX,vector<int>(7,0));\n\nvector<int> dx={-1,0,0,1},dy={0,-1,1,0};\n\nvoid DFS(int u,int v,int goal,int when){\n    stack<pair<int,int>> ST;\n    ST.push(make_pair(u,v));\n    state[u][v]=when;\n    \n    while(!ST.empty()){\n        int a=ST.top().first,b=ST.top().second;\n        ST.pop();\n        for(int i=0;i<4;i++){\n            int c=a+dx[i],d=b+dy[i];\n            if(c<0||c>=goal||d<0||d>=7) continue;\n            if(state[c][d]==0){\n                ST.push(make_pair(c,d));\n                state[c][d]=when;\n            }\n        }\n    }\n}\n\nint main(){\n    \n    ll N;\n    int M,Q;cin>>N>>M>>Q;\n    vector<int> A(Q);\n    for(int i=0;i<Q;i++){\n        cin>>A[i];\n    }\n    if(M%7==0){\n        for(int i=0;i<Q;i++){\n            int a=A[i]/7,b=A[i]%7;\n            state[a][b]=-1;\n        }\n        int now=0;\n        for(int i=0;i<M/7;i++){\n            for(int j=0;j<7;j++){\n                if(state[i][j]==0){\n                    now++;\n                    DFS(i,j,M/7,now);\n                }\n            }\n        }\n        set<pair<int,int>> se;\n        for(int j=0;j<7;j++){\n            if(state[0][j]>=0&&state[M/7-1][j]>=0) se.insert(make_pair(state[0][j],state[M/7-1][j]));\n        }\n        \n        cout<<7*N/M*now-(7*N/M-1)*se.size()<<endl;\n    }else{\n        for(int i=0;i<Q;i++){\n            for(int j=0;j<7;j++){\n                int a=(A[i]+M*j)/7,b=(A[i]+M*j)%7;\n                state[a][b]=-1;\n            }\n        }\n        int now=0;\n        for(int i=0;i<M;i++){\n            for(int j=0;j<7;j++){\n                if(state[i][j]==0){\n                    now++;\n                    DFS(i,j,M,now);\n                }\n            }\n        }\n        set<pair<int,int>> se;\n        for(int j=0;j<7;j++){\n            if(state[0][j]>=0&&state[M-1][j]>=0) se.insert(make_pair(state[0][j],state[M-1][j]));\n        }\n        \n        cout<<N/M*now-(N/M-1)*se.size()<<endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  for(int i=0;i<(n);++i)\n#define REPr(i,n) for(int i=(n)-1;i>=0; --i)\n#define FORq(i, m, n) for(int i = (m);i <= (n);++i)\n#define rFORq(i, m , n) for(int i = (n);i >=(m);--i)\n#define SCD(n) scanf(\"%d\",&n)\n#define SCD2(m,n) scanf(\"%d%d\",&m,&n)\n#define SCD3(m,n,k) scanf(\"%d%d%d\",&m,&n,&k)\n#define SCLLD(n) scanf(\"%lld\",&n)\n#define SCLLD2(m,n) scanf(\"%lld%lld\",&m,&n)\n#define SCLLD3(m,n,k) scanf(\"%lld%lld%lld\",&m,&n,&k)\n#define PB push_back\n#define MP make_pair\n#define ARSCD(A,N) REP(i,N){SCD(A[i]);}\n#define ARSCD1(A,N) FORq(i,1,N){SCD(A[i]);}\n#define VSCD(v,N) REP(i,N){int x; SCD(x); v.PB(x);}\n#define VSCLLD(v,N) REP(i,N){long long x; SCLLD(x); v.PB(x);}\n#define PRINTD(n) printf(\"%d\\n\",n)\n#define PRINTLLD(n) printf(\"%lld\\n\",n)\n#define DEBUG printf(\"%s\\n\",\"debug\")\n#define fst first\n#define snd second\n#define SIN(x,S) (S.count(x) != 0)\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector < VI > VVI;\ntypedef vector<long long> VL;\ntypedef long long ll;\ntypedef long long integer;\n////////////////////////////////////////////////////////////////////\nconst ll p = 1000000007;\nll dx[4] = {-7,-1,1,7};\n\nint main(){\n    ll N,M,Q; SCLLD3(N,M,Q);\n    static ll a[100002] = {};\n    static bool grid[200002] = {}; // partial\n    static bool visited[200002] = {};\n    //static bool visited[100002] = {};\n    ARSCD(a,Q);\n\n    REP(q,Q){\n        ll ai = a[q];\n        ll k = 0;\n        while(k*M + ai < 2*M){\n            grid[k*M+ai] = true;\n            k++;\n        }\n    }\n\n/*     FORq(i,0,2*M-1){\n        if (i % 7 == 0) printf(\"\\n\");\n        if (grid[i]) printf(\"%d\",1);\n        else printf(\"%d\",0);\n    }\n    printf(\"\\n\"); */\n\n    ll count1 = 0;\n    ll count2 = 0;\n    queue<ll> que;\n\n    // #1\n    FORq(i,0,M-1){\n        if (grid[i]) continue;\n        if (visited[i]) continue;\n        que.push(i);\n        //printf(\"start = %d\\n\",i);\n        while(!que.empty()){\n            ll now = que.front(); que.pop();\n            visited[now] = true;\n            \n            REP(k,4){\n                ll next = now + dx[k];\n                if ((now % 7 == 0) and (k == 1)) continue;\n                if (next < 0) continue;\n                if (next >= M) continue;\n                if ((now % 7 == 6) and (k == 2)) continue;\n                if (grid[next]) continue;\n                if (visited[next]) continue;\n                //printf(\"next -> %lld\\n\",next);\n                que.push(next);\n            }\n        }\n        //printf(\"count+\\n\");\n        count1++;\n    }\n\n    //printf(\"count1 = %lld\\n\",count1);\n    fill(visited,visited+200002,false);\n\n    // #2\n    FORq(i,0,2*M-1){\n        if (grid[i]) continue;\n        if (visited[i]) continue;\n        que.push(i);\n        //printf(\"start = %d\\n\",i);\n        while(!que.empty()){\n            ll now = que.front(); que.pop();\n            visited[now] = true;\n            \n            REP(k,4){\n                ll next = now + dx[k];\n                if ((now % 7 == 0) and (k == 1)) continue;\n                if (next < 0) continue;\n                if (next >= 2*M) continue;\n                if ((now % 7 == 6) and (k == 2)) continue;\n                if (grid[next]) continue;\n                if (visited[next]) continue;\n                //printf(\"next -> %lld\\n\",next);\n                que.push(next);\n            }\n        }\n        //printf(\"count+\\n\");\n        count2++;\n    }\n    \n    //printf(\"count2 = %lld\\n\",count2);\n\n    ll A,B;\n    A = count2 - count1;\n    B = count1 - A;\n    ll c = 7*N / M;\n    PRINTLLD(A*c + B);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\n#define REP(i,a,b) for(ll i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\nll gcd(ll a, ll b) {\n    if (b > a) swap(a, b);\n    while (b) {\n        ll t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nll lcm(ll a, ll b) {\n    return a / gcd(a, b) * b;\n}\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\n\nll n, m, q;\nll h;\nint used[101010][7] = {};\nint cal[101010][7] = {};\nint used2[2][7] = {};\nint cal2[2][7] = {};\n\nvoid dfs(int y, int x) {\n    used[y][x] = 1;\n    rep(i,4) {\n        if (y + dy[i] >= 0 && y + dy[i] < h && x + dx[i] >= 0 && x + dx[i] < 7 && !used[y + dy[i]][x + dx[i]] && !cal[y + dy[i]][x + dx[i]]) {\n            dfs(y + dy[i], x + dx[i]);\n        }\n    }\n}\n\nvoid dfs2(int y, int x) {\n    used2[y][x] = 1;\n    rep(i,4) {\n        if (y + dy[i] >= 0 && y + dy[i] < 2 && x + dx[i] >= 0 && x + dx[i] < 7 && !used2[y + dy[i]][x + dx[i]] && !cal2[y + dy[i]][x + dx[i]]) {\n            dfs2(y + dy[i], x + dx[i]);\n        }\n    }\n}\n\nvoid solve() {\n    cin >> n >> m >> q;\n    h = lcm(7, m) / 7;\n    rep(i,q) {\n        ll a;\n        cin >> a;\n        for (int j = a; j < 7 * h; j += m) {\n            if (cal[j/7][j%7]) break;\n            cal[j/7][j%7] = 1;\n        }\n    }\n    ll cnt = 0;\n    rep(i,h) {\n        rep(j,7) {\n            if (!used[i][j] && !cal[i][j]) {\n                dfs(i, j);\n                cnt++;\n            }\n        }\n    }\n    rep(i,7) cal2[0][i] = cal[h-1][i];\n    rep(i,7) cal2[1][i] = cal[0][i];\n    ll cnt2 = 0;\n    rep(i,2) {\n        rep(j,7) {\n            if (!used2[i][j] && !cal2[i][j]) {\n                dfs2(i, j);\n                cnt2++;\n            }\n        }\n    }\n    ll cnt3 = 0;\n    if (!cal2[0][0]) cnt3++;\n    REP(i,1,7) if (cal2[0][i-1] && !cal2[0][i]) cnt3++;\n    if (!cal2[1][0]) cnt3++;\n    REP(i,1,7) if (cal2[1][i-1] && !cal2[1][i]) cnt3++;\n    cnt2 = cnt3 - cnt2;\n    cout << (n / h) * cnt - (n / h - 1) * cnt2 << endl;\n}\n\nint main() {\n    cin.tie(0);\n   \tios::sync_with_stdio(false);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt gcd(Int x, Int y) {\n    if (x < y) swap(x, y);\n    if (y == 0) return x;\n    return gcd(y, x % y);\n}\nInt lcm(Int x, Int y) {\n    return x / gcd(x, y) * y;\n}\nInt solve(Int N, Int M, const vector<int> A) {\n    vector<char> B(N);\n    for (int a : A) {\n        for (int k = a; k < N; k += M) {\n            B[k] = 1;\n        }\n    }\n    auto dfs = [&](auto&& dfs, int n) {\n        if (B[n] == 1) return;\n        B[n] = 1;\n        if (0 <= n - 7) dfs(dfs, n - 7);\n        if ((n % 7) != 0) dfs(dfs, n - 1);\n        if ((n % 7) != 6) dfs(dfs, n + 1);\n        if (n + 7 < N) dfs(dfs, n + 7);\n    };\n    Int ans = 0;\n    for (int i = 0; i < N; i++) {\n        if (B[i] == 0) {\n            ans++;\n            dfs(dfs, i);\n        }\n    }\n    return ans;\n}\nint main() {\n    cin.tie(nullptr); ios::sync_with_stdio(false);\n    Int N, M, Q; cin >> N >> M >> Q;\n    vector<int> A(Q); for (auto &a : A) cin >> a;\n    Int x = lcm(M, lcm(7 * N / M, 7));\n    Int k = 7 * N / x;\n    if (k == 1) {\n        Int cnt1 = solve(x, M, A);\n        cout << cnt1 << endl;\n    } else {\n        Int cnt2 = solve(2*x, M, A);\n        Int cnt3 = solve(3*x, M, A);\n        cout << cnt2 + (cnt3 - cnt2) * (k - 2) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 666666\nint n,m,q,a[SZ];\nbool cov[SZ];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tfor(int i=1;i<=q;i++)\n\tscanf(\"%d\",a+i),cov[a[i]]=1;\n\tif(m==1)\n\t{\n\t\tif(q) puts(\"0\");\n\t\telse puts(\"1\");\n\t\treturn 0;\n\t}\n\tif(m==7)\n\t{\n\t\tint cc=0; \n\t\tfor(int i=0;i<7;i++)\n\t\t\tif((!cov[i]&&cov[i+1])||(i==6)) ++cc;\n\t\tprintf(\"%d\\n\",cc);\n\t\treturn 0;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n\ntypedef long long ll;\nll N; int M, Q; int A[101010];\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { -1, 0, 1, 0 };\n//-----------------------------------------------------------------------------------\nint B[1010101][7];\nint simulate(int loop) {\n    rep(i, 0, M * loop + 10) {\n        int y = i / 7;\n        int x = i % 7;\n        B[y][x] = -1;\n    }\n\n    rep(i, 0, M * loop) {\n        int y = i / 7;\n        int x = i % 7;\n        if(!A[i % M]) B[y][x] = 0;\n    }\n\n    int cnt = 0;\n    rep(i, 0, M * loop) {\n        int y = i / 7;\n        int x = i % 7;\n        if (B[y][x] == 0) {\n            cnt++;\n            queue<int> que;\n            que.push(i);\n            while (!que.empty()) {\n                int ii = que.front(); que.pop();\n                int y = ii / 7;\n                int x = ii % 7;\n                B[y][x] = cnt;\n                rep(j, 0, 4) {\n                    int yy = y + dy[j];\n                    int xx = x + dx[j];\n                    if (yy < 0) continue;\n                    if (xx < 0 || 7 <= xx) continue;\n                    if (B[yy][xx] == 0) {\n                        que.push(yy * 7 + xx);\n                    }\n                }\n            }\n        }\n    }\n\n    return cnt;\n}\n//-----------------------------------------------------------------------------------\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> M >> Q;\n    rep(i, 0, Q) {\n        int a; cin >> a; A[a] = 1;\n    }\n\n    int loop = 1;\n    if (M % 7) loop = 7;\n    ll num = simulate(loop);\n    \n    ll k = N * 7 / (1LL * M * loop);\n    if (k == 1) {\n        cout << num << endl;\n        return 0;\n    }\n\n    ll num2 = simulate(loop * 2);\n    if (k == 2) {\n        cout << num2 << endl;\n        return 0;\n    }\n\n    ll ans = num + (k - 1) * (num2 - num);\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef pair<ll,P> T;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define LLINF 1000000000000000ll\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nll n;\nint m,q;\nint a[100100];\nint c[1400100];\nvoid dfs(int x,int M){\n\tc[x]=0;\n\tif(x%7!=0){\n\t\tif(a[(x-1)%m]==0&&c[x-1]==-1)dfs(x-1,M);\n\t}\n\tif(x%7!=6){\n\t\tif(a[(x+1)%m]==0&&c[x+1]==-1)dfs(x+1,M);\n\t}\n\tif(x-7>=0){\n\t\tif(a[(x-7)%m]==0&&c[x-7]==-1)dfs(x-7,M);\n\t}\n\tif(x+7<M){\n\t\tif(a[(x+7)%m]==0&&c[x+7]==-1)dfs(x+7,M);\n\t}\n}\nll cnt(int M){\n\tll res=0ll;\n\tfor(int i=0;i<M;i++)c[i]=-1;\n\tfor(int i=0;i<M;i++){\n\t\tif(a[i%m])continue;\n\t\tif(c[i]==-1){\n\t\t\tdfs(i,M);\n\t\t\tres++;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%lld %d %d\",&n,&m,&q);\n\tfor(int i=0;i<q;i++){\n\t\tint tmp;\n\t\tscanf(\"%d\",&tmp);\n\t\ta[tmp]=1;\n\t}\n\tint M = m;\n\tif(m%7!=0)M*=7;\n\tll l = 7ll*n/M;\n\tll A = cnt(M);\n\tll B = cnt(2*M);\n\tcout << A+(B-A)*(l-1ll) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nbool t[7][200020],vis[7][200020];\nlong long n,m,q,a;\n\nvoid DFS(int x,int y,int lim){\n\tvis[x][y]=true;\n\tint dx[]={-1,0,0,1},dy[]={0,1,-1,0};\n\tfor(int i=0;i<4;i++){\n\t\tint a=x+dx[i],b=y+dy[i];\n\t\tif(a>=0&&b>=0&&a<7&&b<lim){\n\t\t\tif(!vis[a][b])DFS(a,b,lim);\n\t\t}\n\t}\n}\nint Sol(int lim){\n\tint ret=0;\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<lim;j++){\n\t\t\tvis[i][j]=t[i][j];\n\t\t\t//cout<<t[i][j]<<\" \";\n\t\t}\n\t\t//cout<<endl;\n\t}\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<lim;j++){\n\t\t\tif(!vis[i][j]){\n\t\t\t\tret++;\n\t\t\t\tDFS(i,j,lim);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tcin>>n>>m>>q;\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tt[i][j]=0;\n\t\t}\n\t}\n\twhile(q--){\n\t\tcin>>a;\n\t\tfor(int i=a;i<14*m;i+=m){\n\t\t\tt[i%7][i/7]=1;\n\t\t}\n\t}\n\n\tlong long k=Sol(m),w=Sol(m*2),ans;\n\tint g=n/m;\n\tif(g<=1)ans=Sol(n);\n\telse ans=Sol((n%m)+m)+k+(g-2)*(w-k);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  ll n,m,k;\n  cin >> n >> m >> k;\n  ll a[k];\n  rep(i,k) R a[i];\n  if(n<=100000) {\n    int b[100000][7];\n    mem(b);\n    rep(i,k) {\n      int x=a[i];\n      while(x<n*7) {\n        b[x/7][x%7]=1;\n        x+=m;\n      }\n    }\n    int ans=0;\n    rep(i,n) {\n      rep(j,7) {\n        if(b[i][j]) continue;\n        ans++;\n        b[i][j]=1;\n        queue<P> que;\n        que.push(P(i,j));\n        while(!que.empty()) {\n          P p=que.front();que.pop();\n          rep(l,4) {\n            int x=p.F+dx[l],y=p.S+dy[l];\n            if(!check(n,7,x,y)||b[x][y]) continue;\n            b[x][y]=1;\n            que.push(P(x,y));\n          }\n        }\n      }\n    }\n    pr(ans);\n  } else {\n    if(!a[0]) {\n      if(k<7) pr(1);\n      else if(k==m) pr(0);\n      else pr(n/m);\n    } else {\n      if(k<7) pr(1);\n      else if(k==m) pr(0);\n      else if(m-7>k) pr(n/m+1);\n      else pr(n/m*2);\n    }\n  }\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nbool t[7][200020],vis[7][200020];\nlong long n,m,q,a;\n\nvoid DFS(int x,int y,int lim){\n\tvis[x][y]=true;\n\tint dx[]={-1,0,0,1},dy[]={0,1,-1,0};\n\tfor(int i=0;i<4;i++){\n\t\tint a=x+dx[i],b=y+dy[i];\n\t\tif(a>=0&&b>=0&&a<7&&b<lim){\n\t\t\tif(!vis[a][b])DFS(a,b,lim);\n\t\t}\n\t}\n}\nint Sol(int lim){\n\tint ret=0;\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<lim;j++){\n\t\t\tvis[i][j]=t[i][j];\n\t\t\t//cout<<t[i][j]<<\" \";\n\t\t}\n\t\t//cout<<endl;\n\t}\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<lim;j++){\n\t\t\tif(!vis[i][j]){\n\t\t\t\tret++;\n\t\t\t\tDFS(i,j,lim);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tcin>>n>>m>>q;\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tt[i][j]=0;\n\t\t}\n\t}\n\twhile(q--){\n\t\tcin>>a;\n\t\tfor(int i=a;i<14*m;i+=m){\n\t\t\tt[i%7][i/7]=1;\n\t\t}\n\t}\n\n\tlong long k=Sol(m),w=Sol(m*2),ans=k;\n\tans+=(n/m-1)*(w-k);\n\tn%=m;\n\tif(n)ans+=Sol(n);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nlong long int n;\nint m;\nint q;\n\n#define MAX 1000002\nint room[MAX][7];\nint id[MAX][7];\n\nbool flag[MAX];\n\nstruct UF{\n\tvector<int> belong;\n\tvector<int> size;\n\tvoid resize(int n){\n\t\tbelong.assign(n + 1, -1);\n\t\tsize.assign(n + 1, 1);\n\t}\n\tinline int root(int b){\n\t\tif (belong[b] == -1){\n\t\t\treturn b;\n\t\t}\n\t\tbelong[b] = root(belong[b]);\n\t\treturn belong[b];\n\t}\n\tvoid merge(int a, int b){\n\t\ta = root(a);\n\t\tb = root(b);\n\t\tif (a == b)return;\n\t\tbelong[a] = b;\n\t\tsize[b] += size[a];\n\t}\n};\nUF uf;\nint dx[] = { 0, 0, 1, -1 };\nint dy[] = { 1, -1, 0, 0 };\n\nvector<int> v;\n\nvoid solve(int N){\n\tlong long int sum = 0;\n\tif (n <= v.size()){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tsum += v[i];\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\t\treturn;\n\t}\n\tlong long int W = 0;\n\tfor (int i = 1; i < v.size(); i++){\n\t\tW += v[i];\n\t}\n\tn--;\n\tW *= (n / N);\n\tn %= N;\n\tfor (int i = 1; i <= n; i++){\n\t\tW += v[i];\n\t}\n\tW += v[0];\n\tprintf(\"%lld\\n\", W);\n}\nint main(){\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < q; i++){\n\t\tint a;\n\t\tscanf(\"%d\", &a);\n\t\tflag[a] = true;\n\t}\n\tint num = -1;\n\tint nnn = -1;\n\tint N;\n\tfor (int i = 0; i < MAX; i++){\n\t\tfor (int j = 0; j < 7; j++){\n\t\t\tnum++;\n\t\t\tnnn++;\n\t\t\tid[i][j] = nnn;\n\t\t\tnum %= m;\n\t\t\tif (i && (j == 0 && num == 0)){\n\t\t\t\tN = i;\n\t\t\t\tfor (int j = 0; j < 7; j++){\n\t\t\t\t\troom[i][j] = room[0][j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (flag[num]){\n\t\t\t\troom[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tif (0){\n\t\n\t}\n\telse{\n\t\tuf.resize(7 * N);\n\t\tfor (int i = 0; i <= N; i++){\n\t\t\tint inc = 0;\n\t\t\tfor (int j = 0; j < 7; j++){\n\t\t\t\tif (room[i][j] == true)continue;\n\t\t\t\tbool ok = false;\n\t\t\t\tfor (int k = 0; k < 4; k++){\n\t\t\t\t\tint ii = i + dx[k];\n\t\t\t\t\tif (ii > i)continue;\n\t\t\t\t\tint jj = j + dy[k];\n\t\t\t\t\tif (jj > j)continue;\n\t\t\t\t\tif (ii >= 0 && jj >= 0 && ii <= N&&jj < 7){\n\t\t\t\t\t\tif (room[i][j] == false && room[ii][jj] == false){\n\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t\tuf.merge(id[i][j], id[ii][jj]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok == false){\n\t\t\t\t\tinc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tv.push_back(inc);\n\t\t}\n\t\tsolve(N);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n;;;;;;;;;;;;::;,.,xOOOOOOOkdoc;,,;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,,'''',,,,,,,,,'',,:cloo:'.\n;;;;;;;;;;:ccccc,'lOOOOOOOOOOOxoc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,,''''''''''',;cloxkOOOOl..\n;;;;;;;;;:cccccc:,;xOOOOOOOOOOOOOxoc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,''''''';:loxkOOOOOOOOk:..\n;;;;;;;;;:cccccc::,ck0OOOOO0OO00OOOOxl:;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,'',;codkO0OOOOOOOOOOOo'..\n;;;;;;;;:cccccc:::;,ck0OOOOOOOOOOOOO0Okoc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:cloxOOOOOOOOOOOOOOOO0x;..'\n;;;;;;;:ccccccc::;;,,:xOOOOO0OOOOOOOOOOOkdc;,;;;;;;;::::ccccccccc:::::cldkOOOOOOOOOOOOOOOOOOO0k:..''\n;;;;;;;:cccccc::;;,,,';dO0OOOOO0OOOOOOOOOOkdodddxxxxkkkOOOOOOOOOOkkkxkkO0OOOOOOOOOOOOOOOOOOO0kc'''''\n;;;;;;;::::::::;;,,,''',cxOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOxc,,,,''\n;;;;;,;;;;;;;;;,,,,'''''',lkOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOko:;;;;,,,\n;;;;,,,,,,,,,,,,''''''''''.,lkOOkxkOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkoc:c:::;;,,\n;;;;'''''''''''''''''''''''..;lodkO0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkxk0Okxocccccc:::;,,\n;;;,'............'''''''''''..;xOOOOOOOOOOOO0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkxdol::::cccc:::;;,,\n;;,'..............''''''''''';dOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOko;;::::::::;;;;,,\n;;'................'''''','',dOOOO0OOOxdoccxOO0OOOOOOOOOOOOOOOOOOOOxdoclxOOOOOOOOOOOo;;;;;;;;;;;;,,'\n;,'................'''''',,,lOOOOOOOOoo00c.;xOOOOOOOOOOOOOOOOOOOOOll0O:.:k0OOOOOOOOOOo,,;;;;;;,,,,''\n,'..................''',,,,ckOOO0OO0Ol,::,.,d0OOOOOOOOOOOOOOOOOOOOc,::,.;x0OOOOOOOOOOkc',,,,,,,,,,''\n,'..................''',,';dOOOOOOOO0kc,,,;oOOO0OO0OO0OOOOOOOOOOOOkc,,,:dOOOOOOOOOOOOOd,',,'''''''''\n'...................''',,,lOOOOOOOOOOOOkxxkOOOOOOOOxdddkOOOOOOOOOOOOkxxOOOOOOOOOOOOOO0kc''''''''''''\n'...................''',,;xOOOkkkOOOOOOOOOOOOOOOOOxo:;:dOOOOOOOOOOOOOOOOOOOOkkkkOOOOOOOd;'''''''''''\n'.................'''',,,ckxollllldkOOOOOOOOOOOOOO0OkkOOOOOOOOOOOOOOOOOOOkdlllllodkOOOOOc'',''''''''\n''''...........'''',,,,,;odccccccccokOOOOOOOOOOOOOOO0OOOOOOOOO0OOOOOOOOOxlcccccccclk0OOOd;,,,,,,,,''\n'''''''',''',,,,,,,;;;;;;ddcccccccclxOOOOOOOOOOOOkxdddddooddkOOOOOOOOOOOdccccccccclx0OOOOl,;;;;,,,,'\n',,,,,,;;;;;;;;;;;:::::;:xOdolclllokOOOOOOOOOOOOxllodddxdddllkOOOOOOOOOOkocccccccldOOOOOOd:;:;;;;;,,\n,,,;;;;:::::::::::::::cc;lOOOkkkkOOOOOOOOOOOOOOOdlodxxdxddxdcdOOOOOOOOOOOOkxdoddxkOOOOOOOOl:::::;;,,\n,,;;::::cccccccccccccccc::dOOOOOOOOOOOOOOOOOOOO0kolldxxxxxxoldOOOOOOOOOOOOOOOOOOOOOOOOOOOOd::c::;;,,\n,,;;:::cccccccccccccccccc:cxOOOOOOOOOOOOOOOOOOOOOOkxoooooooodOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkc:c:::;,,\n,,;;::::cccccccccccccccc:c:cxOOOOOOOOOOOOOOOOOOOOOOOOOkkkkkOO0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOo;:::;;,,\n,;;;;::::ccccccccccccccc:::;ck0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOx::::;;,,\n*/\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,tune=native\")\n//#pragma GCC optimize (\"unroll-loops\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double old;\n\nconst int N = 700100;\n\nint mp[N], kek[N * 2];\nint cur;\nint len;\n\nvoid dfs(int q[], int v, int sz = len) {\n    q[v] = cur;\n    if (v % 7 && q[v - 1] == 0) {\n        dfs(q, v - 1, sz);\n    }\n    if (v % 7 != 6 && q[v + 1] == 0) {\n        dfs(q, v + 1, sz);\n    }\n    if (v / 7 && q[v - 7] == 0) {\n        dfs(q, v - 7, sz);\n    }\n    if (v + 7 < sz && q[v + 7] == 0) {\n        dfs(q, v + 7, sz);\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cout << fixed << setprecision(20);\n    ll n;\n    int m, q;\n    cin >> n >> m >> q;\n    if (m == q) {\n        cout << 0;\n        return 0;\n    }\n    len = m;\n    if (len % 7) {\n        len *= 7;\n    }\n    while (q--) {\n        int a;\n        cin >> a;\n        for (int i = a; i < len; i += m) {\n            kek[i + len] = kek[i] = mp[i] = -1;\n        }\n    }\n    for (int i = 0; i < len; ++i) {\n        if (mp[i] == 0) {\n            ++cur;\n            dfs(mp, i);\n        }\n    }\n    int st = cur;\n    cur = 0;\n    for (int i = 0; i < len * 2; ++i) {\n        if (kek[i] == 0) {\n            ++cur;\n            dfs(kek, i, len * 2);\n        }\n    }\n    ll ans = st + (cur - st) * (n * 7 / len - 1);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nint par[700002];\nint rk[700002];\n\nvoid init(int n){\n\tfor(int i=0; i<n; i++){\n\t\tpar[i]=i;\n\t}\n}\n \nint find(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x]=find(par[x]);\n\t}\n}\n \nvoid unite(int x, int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x==y) return;\n\tif(rk[x]<rk[y]){\n\t\tpar[x]=y;\n\t}else{\n\t\tpar[y]=x;\n\t\tif(rk[x]==rk[y]) rk[x]++;\n\t}\n}\n \nbool same(int x, int y){\n\treturn find(x)==find(y);\n}\n\nll n; int m, q;\nint p1[7], p2[7];\nbool b[700001];\nll conn(int p1a[7], int p2a[7], int p1b[7], int p2b[7], int p1c[7], int p2c[7]){\n    init(28);\n    for(int i=0; i<14; i++){\n        if((i<7 && !b[i]) || (i>=7 && !b[m-7+i-7])) continue;\n        for(int j=i+1; j<14; j++){\n            if((j<7 && !b[j]) || (j>=7 && !b[m-7+j-7])) continue;\n            int x, y;\n            if(i<7) x=p1a[i];\n            else x=p2a[i-7];\n            if(j<7) y=p1a[j];\n            else y=p2a[j-7];\n            if(x==y) unite(i, j);\n            if(i<7) x=p1b[i];\n            else x=p2b[i-7];\n            if(j<7) y=p1b[j];\n            else y=p2b[j-7];\n            if(x==y) unite(i+14, j+14);\n        }\n    }\n    for(int i=0; i<7; i++){\n        if(b[i] && b[m-7+i]) unite(i+7, i+14);\n    }\n    set<int> st;\n    for(int i=0; i<28; i++){\n        if((i<7 && !b[i]) || (7<=i && i<14 && !b[m-7+i-7]) || (14<=i && i<21 && !b[i-14]) || (i>=21 && !b[m-7+i-21])) continue;\n        st.insert(find(i));\n    }\n    for(int i=0; i<7; i++){\n        p1c[i]=find(i);\n        st.erase(p1c[i]);\n    }\n    for(int i=0; i<7; i++){\n        p2c[i]=find(i+21);\n        st.erase(p2c[i]);\n    }\n    return st.size();\n}\nll ct;\nll pow(ll k){\n    int p1p[7], p2p[7], p1a[7], p2a[7];\n    for(int i=0; i<7; i++) p1p[i]=p1[i], p2p[i]=p2[i];\n    bool mada=1;\n    ll ans=0;\n    while(k){\n        if(k&1){\n            if(mada){\n                for(int i=0; i<7; i++) p1a[i]=p1p[i], p2a[i]=p2p[i];\n              ans+=ct;\n                mada=0;\n            }else{\n                int p1c[7], p2c[7];\n                ans+=conn(p1p, p2p, p1a, p2a, p1c, p2c);\n                ans+=ct;\n                for(int i=0; i<7; i++) p1a[i]=p1c[i], p2a[i]=p2c[i];\n            }\n        }\n        int p1c[7], p2c[7];\n        ct=2*ct+conn(p1p, p2p, p1p, p2p, p1c, p2c);\n        for(int i=0; i<7; i++) p1p[i]=p1c[i], p2p[i]=p2c[i];\n        k>>=1;\n    }\n    set<int> st;\n    for(int i=0; i<7; i++){\n        if(b[i]) st.insert(p1a[i]);\n        if(b[m-7+i]) st.insert(p2a[i]);\n    }\n    ans+=(ll)st.size();\n    return ans;\n}\nint main()\n{\n    cin>>n>>m>>q;\n    int a[100001];\n    for(int i=0; i<q; i++){\n        cin>>a[i];\n    }\n    if(m%7!=0){\n        m*=7;\n        fill(b, b+m, 1);\n        for(int i=0; i<q; i++){\n            for(int j=0; j<7; j++){\n                b[a[i]+m/7*j]=0;\n            }\n        }\n    }else{\n        fill(b, b+m, 1);\n        for(int i=0; i<q; i++) b[a[i]]=0;\n    }\n    init(m);\n    for(int i=0; i<m; i++){\n        if(!b[i]) continue;\n        if(i%7!=0 && b[i-1]) unite(i-1, i);\n        if(i>=7 && b[i-7]) unite(i-7, i);\n    }\n    set<int> st;\n    for(int i=0; i<m; i++){\n        if(!b[i]) continue;\n        st.insert(find(i));\n    }\n    for(int i=0; i<7; i++){\n        p1[i]=find(i);\n        st.erase(p1[i]);\n    }\n    for(int i=0; i<7; i++){\n        p2[i]=find(m-7+i);\n        st.erase(p2[i]);\n    }\n    ct=st.size();\n    cout<<pow(7*n/(ll)m)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 666666\nint n,m,q,a[SZ];\nbool cov[SZ];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tfor(int i=1;i<=q;i++)\n\tscanf(\"%d\",a+i),cov[a[i]]=1;\n\tif(m==1)\n\t{\n\t\tif(q) puts(\"0\");\n\t\telse puts(\"1\");\n\t\treturn 0;\n\t}\n\tif(m==7)\n\t{\n\t\tint cc=0; \n\t\tfor(int i=0;i<7;i++)\n\t\t\tif((cov[i]&&!cov[i+1])||(i==6)) ++cc;\n\t\tprintf(\"%d\\n\",cc);\n\t\treturn 0;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a <= x && x < b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\nstd::ostream& operator<<(std::ostream& os, const PAIR& r) {\n\tos << \"(\" << r.first << \", \" << r.second << \")\";\n\treturn os;\n}\n\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nint dy4[] = {0, 1, 0 };\nint dx4[] = {1, 0, -1 };\n\ninline int calc(std::vector<std::vector<bool>>& a) {\n\tint cnt = 0;\n\tint n = a.size();\n\tREP(i, n) {\n\t\tREP(j, 7) {\n\t\t\tif (a[i][j]) continue;\n\t\t\t++cnt;\n\t\t\tstd::queue<PAIR> que;\n\t\t\tque.push(PAIR(i, j));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tPAIR now = que.front(); que.pop();\n\t\t\t\ta[now.first][now.second] = true;\n\t\t\t\tREP(d, 3) {\n\t\t\t\t\tint dy = now.first + dy4[d];\n\t\t\t\t\tint dx = now.second + dx4[d];\n\t\t\t\t\tif (!IN(0, dy, n) || !IN(0, dx, 7)) continue;\n\t\t\t\t\tif (a[dy][dx]) continue;\n\t\t\t\t\tque.push(PAIR(dy, dx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, m, q);\n\tVEC(int, a, q);\n\tstd::vector<bool> bb(m, false);\n\tREP(i, q) {\n\t\tbb[a[i]] = true;\n\t}\n\tif (n <= 1000000) {\n\t\tstd::vector<std::vector<bool>> b(n, std::vector<bool>(7, false));\n\t\tREP(i, n) REP(j, 7) {\n\t\t\tif (bb[((7 * (i - 1) + j - 7) % m + m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tOUT(calc(b))BR;\n\t\treturn 0;\n\t}\n\n\tstd::vector<int> t(2);\n\tREP(_, 2) {\n\t\tstd::vector<std::vector<bool>> b(m / 7 * (_ + 1), std::vector<bool>(7, false));\n\t\tREP(i, m / 7 * (_ + 1)) REP(j, 7) {\n\t\t\tif (bb[(7 * (i - 1) + j - 7 + 8 * m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tt[_] = calc(b);\n\t}\n\tint x = 7 * n / m;\n\tint d = t[1] - t[0];\n\tOUT(t[0] + (x - 1)*d)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define RREP(i, x, n) for(int i = x; i >= n; i--)\n#define rrep(i, n) RREP(i,n,0)\n#define pb push_back\n#pragma GCC optimize (\"-O3\")\n\nusing namespace std;\n\n// #define DEBUG_IS_VALID\n\n#ifdef DEBUG_IS_VALID\n#define DEB 1 \n#else\n#define DEB 0\n#endif\n#define DUMPOUT cout\n#define dump(...) if(DEB) DUMPOUT<<\"  \"<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl<<\"    \"; if(DEB) dump_func(__VA_ARGS__)\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, pair<T1,T2> p){cout << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate<typename T>ostream& operator << (ostream& os, vector<T>& vec) { os << \"{\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"}\"; return os; }\ntemplate<typename T>ostream& operator << (ostream& os, set<T>& st){for(auto itr = st.begin(); itr != st.end(); itr++) cout << *itr << (next(itr)!=st.end() ? \", \" : \"\"); cout << \"}\"; return os;}\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, map<T1,T2> mp){cout << \"{\"; for(auto itr = mp.begin(); itr != mp.end(); itr++) cout << \"(\" << (itr->first) << \", \" << (itr->second) << \")\" << (next(itr)!=mp.end() ? \",\" : \"\"); cout << \"}\"; return os; }\n\nvoid dump_func(){DUMPOUT << endl;}\ntemplate <class Head, class... Tail>void dump_func(Head&& head, Tail&&... tail){ DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...);}\ntemplate<class T> inline bool chmax(T& a,T const& b){if(a>=b) return false; a=b; return true;}\ntemplate<class T> inline bool chmin(T& a,T const& b){if(a<=b) return false; a=b; return true;}\n\nusing ll = long long;\nusing P = pair<int,int>;\nusing Pl = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\n\nconst int mod=1e9+7,INF=1<<29;\nconst double EPS=1e-12,PI=3.1415926535897932384626;\nconst ll lmod = 1e9+7,LINF=1LL<<59; \n\nstruct UnionFindTree{\n  vector<int> par,rank,size;\n  UnionFindTree(int N){\n    par = rank = vector<int>(N,0);\n    size = vector<int>(N,1);\n    for(int i = 0; i < N; i++) par[i] = i;\n  }\n  int find(int x){\n    if(par[x] == x) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x,int y){\n    x = find(x);\n    y = find(y);\n    if(x == y)  return ;\n    if(rank[x] < rank[y]){\n      par[x] = y;\n    }else{\n      par[y] = x;\n      if(rank[x] == rank[y]) ++rank[x];\n    }\n    size[x] = size[y] = size[x] + size[y];\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll N,M,Q; cin >> N >> M >> Q ;\n  ll sp_sz;\n  if(M%7==0) sp_sz = M;\n  else sp_sz = 7 * M;\n  vector<bool> is_black(sp_sz,false);\n  rep(i,Q){\n    int a; cin >> a ;\n    for(int x = a; x < sp_sz ; x += M){\n      is_black[x] = true;\n    }\n  }\n  UnionFindTree uft(sp_sz*2);\n  vi dx = {-1,0,1,0};\n  vi dy = {0,-1,0,1};\n  rep(i,sp_sz){\n    if(is_black[i]) continue;\n    rep(j,4){\n      int x = i + dx[j]*7 + dy[j];\n      if(x<0 || x>=sp_sz) continue;\n      if(is_black[x]) continue;\n      uft.unite(i,x);\n      uft.unite(i+sp_sz,x+sp_sz);\n    }\n  }\n  ll sz1,sz2;\n  sz1 = sz2 = 0;\n  rep(i,sp_sz){\n    if(is_black[i]) continue;\n    if(uft.par[i]==i) sz1++;\n  }\n  dump(sz1);\n  REP(i,sp_sz-7,sp_sz){\n    if(is_black[i]||is_black[(i+7)%sp_sz]) continue;\n    uft.unite(i,i+7);\n  }\n  rep(i,2*sp_sz){\n    if(is_black[i%sp_sz]) continue;\n    if(uft.par[i]==i) sz2++; \n  }\n  dump(is_black);\n  dump(sz1,sz2);\n  ll diff = sz1 * 2 - sz2;\n  ll temp = 7*N/sp_sz;\n  cout << sz1 * temp - diff * (temp-1) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M >> K;\n\tif (M % 7) {\n\t\tvector<int>box(M);\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tcin >> L;\n\t\t\tbox[L] = 1;\n\t\t}\n\t\tvector<vector<int>>v(M * 2, vector<int>(7));\n\t\tfor (int i = 0; i < M * 2; i++) {\n\t\t\tfor (int j = 0; j < 7; j++) {\n\t\t\t\tv[i][j] = box[(i * 7 + j) % M];\n\t\t\t}\n\t\t}\n\t\tint dir[] = { 1,0,-1,0,1 };\n\t\tlong long int a = 0, b = 0;\n\t\tqueue<pair<int, int>>Q;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tfor (int j = 0; j < 7; j++) {\n\t\t\t\tif (v[i][j])continue;\n\t\t\t\ta++;\n\t\t\t\tQ.push({ i,j });\n\t\t\t\tv[i][j] = MOD;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint y = Q.front().first;\n\t\t\t\t\tint x = Q.front().second;\n\t\t\t\t\tQ.pop();\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tint ny = y + dir[k];\n\t\t\t\t\t\tint nx = x + dir[k + 1];\n\t\t\t\t\t\tif (ny < 0 || nx < 0 || ny >= M || nx >= 7)continue;\n\t\t\t\t\t\tif (v[ny][nx])continue;\n\t\t\t\t\t\tv[ny][nx] = MOD;\n\t\t\t\t\t\tQ.push({ ny,nx });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto &i : v) {\n\t\t\tfor (auto &j : i)j %= MOD;\n\t\t}\n\t\tM <<= 1;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tfor (int j = 0; j < 7; j++) {\n\t\t\t\tif (v[i][j])continue;\n\t\t\t\tb++;\n\t\t\t\tQ.push({ i,j });\n\t\t\t\tv[i][j] = MOD;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint y = Q.front().first;\n\t\t\t\t\tint x = Q.front().second;\n\t\t\t\t\tQ.pop();\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tint ny = y + dir[k];\n\t\t\t\t\t\tint nx = x + dir[k + 1];\n\t\t\t\t\t\tif (ny < 0 || nx < 0 || ny >= M || nx >= 7)continue;\n\t\t\t\t\t\tif (v[ny][nx])continue;\n\t\t\t\t\t\tv[ny][nx] = MOD;\n\t\t\t\t\t\tQ.push({ ny,nx });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tb -= a;\n\t\ta += ((N * 2 / M) - 1)*b;\n\t\tcout << a << endl;\n\t}\n\telse {\n\t\tvector<int>box(M);\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tcin >> L;\n\t\t\tbox[L] = 1;\n\t\t}\n\t\tvector<vector<int>>v(M * 2 / 7, vector<int>(7));\n\t\tfor (int i = 0; i < M * 2 / 7; i++) {\n\t\t\tfor (int j = 0; j < 7; j++) {\n\t\t\t\tv[i][j] = box[(i * 7 + j) % M];\n\t\t\t}\n\t\t}\n\t\tint dir[] = { 1,0,-1,0,1 };\n\t\tlong long int a = 0, b = 0;\n\t\tqueue<pair<int, int>>Q;\n\t\tfor (int i = 0; i < M / 7; i++) {\n\t\t\tfor (int j = 0; j < 7; j++) {\n\t\t\t\tif (v[i][j])continue;\n\t\t\t\ta++;\n\t\t\t\tQ.push({ i,j });\n\t\t\t\tv[i][j] = MOD;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint y = Q.front().first;\n\t\t\t\t\tint x = Q.front().second;\n\t\t\t\t\tQ.pop();\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tint ny = y + dir[k];\n\t\t\t\t\t\tint nx = x + dir[k + 1];\n\t\t\t\t\t\tif (ny < 0 || nx < 0 || ny >= M / 7 || nx >= 7)continue;\n\t\t\t\t\t\tif (v[ny][nx])continue;\n\t\t\t\t\t\tv[ny][nx] = MOD;\n\t\t\t\t\t\tQ.push({ ny,nx });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto &i : v) {\n\t\t\tfor (auto &j : i)j %= MOD;\n\t\t}\n\t\tM <<= 1;\n\t\tfor (int i = 0; i < M / 7; i++) {\n\t\t\tfor (int j = 0; j < 7; j++) {\n\t\t\t\tif (v[i][j])continue;\n\t\t\t\tb++;\n\t\t\t\tQ.push({ i,j });\n\t\t\t\tv[i][j] = MOD;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint y = Q.front().first;\n\t\t\t\t\tint x = Q.front().second;\n\t\t\t\t\tQ.pop();\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tint ny = y + dir[k];\n\t\t\t\t\t\tint nx = x + dir[k + 1];\n\t\t\t\t\t\tif (ny < 0 || nx < 0 || ny >= M / 7 || nx >= 7)continue;\n\t\t\t\t\t\tif (v[ny][nx])continue;\n\t\t\t\t\t\tv[ny][nx] = MOD;\n\t\t\t\t\t\tQ.push({ ny,nx });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tb -= a;\n\t\ta += ((N * 14 / M) - 1)*b;\n\t\tcout << a << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\n#define REP(i,a,b) for(ll i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\nll gcd(ll a, ll b) {\n    if (b > a) swap(a, b);\n    while (b) {\n        ll t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nll lcm(ll a, ll b) {\n    return a / gcd(a, b) * b;\n}\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\n\nll n, m, q;\nll h;\nint used[101010][7] = {};\nint cal[101010][7] = {};\nint used2[2][7] = {};\nint cal2[2][7] = {};\n\nvoid dfs(int y, int x) {\n    used[y][x] = 1;\n    rep(i,4) {\n        if (y + dy[i] >= 0 && y + dy[i] < h && x + dx[i] >= 0 && x + dx[i] < 7 && !used[y + dy[i]][x + dx[i]] && !cal[y + dy[i]][x + dx[i]]) {\n            dfs(y + dy[i], x + dx[i]);\n        }\n    }\n}\n\nvoid dfs2(int y, int x) {\n    used2[y][x] = 1;\n    rep(i,4) {\n        if (y + dy[i] >= 0 && y + dy[i] < 2 && x + dx[i] >= 0 && x + dx[i] < 7 && !used2[y + dy[i]][x + dx[i]] && !cal2[y + dy[i]][x + dx[i]]) {\n            dfs2(y + dy[i], x + dx[i]);\n        }\n    }\n}\n\nvoid solve() {\n    cin >> n >> m >> q;\n    h = lcm(7, m) / 7;\n    rep(i,q) {\n        ll a;\n        cin >> a;\n        for (ll j = a; j < 7 * h; j += m) {\n            if (cal[j/7][j%7]) break;\n            cal[j/7][j%7] = 1;\n        }\n    }\n    ll cnt = 0;\n    rep(i,h) {\n        rep(j,7) {\n            if (!used[i][j] && !cal[i][j]) {\n                dfs(i, j);\n                cnt++;\n            }\n        }\n    }\n    rep(i,7) cal2[0][i] = cal[h-1][i];\n    rep(i,7) cal2[1][i] = cal[0][i];\n    ll cnt2 = 0;\n    rep(i,2) {\n        rep(j,7) {\n            if (!used2[i][j] && !cal2[i][j]) {\n                dfs2(i, j);\n                cnt2++;\n            }\n        }\n    }\n    ll cnt3 = 0;\n    if (!cal2[0][0]) cnt3++;\n    REP(i,1,7) if (cal2[0][i-1] && !cal2[0][i]) cnt3++;\n    if (!cal2[1][0]) cnt3++;\n    REP(i,1,7) if (cal2[1][i-1] && !cal2[1][i]) cnt3++;\n    cnt2 = cnt3 - cnt2;\n    cout << (n / h) * cnt - (n / h - 1) * cnt2 << endl;\n}\n\nint main() {\n    cin.tie(0);\n   \tios::sync_with_stdio(false);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nint a[100000];\nbool used[100000];\nbool used_root[700000];\n\nint main(){\n    long n, m, q;\n    cin >> n >> m >> q;\n    for(int i = 0; i < q; i++) {\n        cin >> a[i];\n        used[a[i]] = true;\n    }\n    int M;\n    if(m%7 != 0) M =  min(7*m, 7*n);\n    else  M =  min(m, 7*n);\n    UnionFind uf(M);\n    for(int i = 0; i < M; i++){\n        if(used[i%m]) continue;\n        if(i%7 != 6){\n            if(!used[(i+1)%m]) uf.unionSet(i, i+1);\n        }\n        if(i+7 < M){\n            if(!used[(i+7)%m]) uf.unionSet(i, i+7);\n        }\n    }\n    long cnt = 0;\n    for(int i = 0; i < M; i++){\n        if(!used[i%m]){\n            int r = uf.root(i);\n            //cout << r << endl;\n            if(!used_root[r]){\n                cnt++;\n                used_root[r] = true;\n            }\n        }\n    }\n    //cout << M << endl;\n    //cout << cnt << endl;\n    long cnt_ = cnt;\n    for(int i = M-7; i < M; i++){\n        if(!used[(i+7)%m]) {\n            if(uf.findSet(i, i+7-M)) cnt_--;\n            uf.unionSet(i, i+7-M);\n        }\n    }\n    //cout << cnt_ << endl;\n    long s = (7*n)/M;\n    long ans = cnt+cnt_*(s-1);\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int M = 7e5 + 5;\nlong long n;\nint m , q;\nint mark[M];\nint inp;\nstruct data{\n\tint top[7];\n\tint bot[7];\n\tlong long ans;\n\tvoid compress(){\n\t\tmap < int , int > mp;\n\t\tmp.clear();\n\t\tfor(int i = 0 ; i < 7 ; ++i){\n\t\t\tif(top[i] != -1){\n\t\t\t\tmp[top[i]];\n\t\t\t}\n\t\t\tif(bot[i] != -1){\n\t\t\t\tmp[bot[i]];\n\t\t\t}\n\t\t}\n\t\tint val = 0;\n\t\tfor(auto &it : mp){\n\t\t\tit.second = val++;\n\t\t}\n\t\tfor(int i = 0 ; i < 7 ; ++i){\n\t\t\tif(top[i] != -1){\n\t\t\t\ttop[i] = mp[top[i]];\n\t\t\t}\n\t\t\tif(bot[i] != -1){\n\t\t\t\tbot[i] = mp[bot[i]];\n\t\t\t}\n\t\t}\n\t}\n};\nint parent[M];\nint find(int node){\n\tif(parent[node] == node){\n\t\treturn node;\n\t}\n\treturn parent[node] = find(parent[node]);\n}\nbool join(int a , int b){\n\tif(find(a) == find(b)){\n\t\treturn 0;\n\t}\n\tparent[find(a)] = find(b);\n\treturn 1;\n}\ndata getbase(){\n\tfor(int i = 0 ; i < m ; ++i){\n\t\tparent[i] = i;\n\t}\n\tint ans = m - q;\n\tfor(int i = 0 ; i < m ; ++i){\n\t\tif(!mark[i]){\n\t\t\tif(i + 1 < m && !mark[i + 1]){\n\t\t\t\tans -= join(i , i + 1);\n\t\t\t}\n\t\t\tif(i + 7 < m && !mark[i + 7]){\n\t\t\t\tans -= join(i , i + 7);\n\t\t\t}\n\t\t}\n\t}\n\tdata res;\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(mark[i]){\n\t\t\tres.top[i] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.top[i] = find(i);\n\t\t}\n\t}\n\tfor(int i = m - 7 ; i < m ; ++i){\n\t\tif(mark[i]){\n\t\t\tres.bot[i - m + 7] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.bot[i - m + 7] = find(i);\n\t\t}\n\t}\n\tres.ans = ans;\n\tres.compress();\n\treturn res;\n}\ndata base;\ndata combine(data lft , data rgt){\n\tfor(int i = 0 ; i < 30 ; ++i){\n\t\tparent[i] = i;\n\t}\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(rgt.top[i] != -1){\n\t\t\trgt.top[i] += 14;\n\t\t}\n\t\tif(rgt.bot[i] != -1){\n\t\t\trgt.bot[i] += 14;\n\t\t}\n\t}\n\tdata res;\n\tres.ans = lft.ans + rgt.ans;\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(lft.bot[i] != -1 && rgt.top[i] != -1){\n\t\t\tres.ans -= join(lft.bot[i] , rgt.top[i]);\n\t\t}\n\t}\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(lft.top[i] == -1){\n\t\t\tres.top[i] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.top[i] = find(lft.top[i]);\n\t\t}\n\t\tif(rgt.bot[i] == -1){\n\t\t\tres.bot[i] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.bot[i] = find(rgt.bot[i]);\n\t\t}\n\t}\n\tres.compress();\n\treturn res;\n}\ndata solve(long long n){\n\tif(n == 1){\n\t\treturn base;\n\t}\n\tif(n & 1){\n\t\treturn combine(solve(n - 1) , base);\n\t}\n\tdata tmp = solve(n >> 1);\n\treturn combine(tmp , tmp);\n}\nint main(){\n\tscanf(\"%lld %d %d\" , &n , &m , &q);\n\tfor(int i = 1 ; i <= q ; ++i){\n\t\tscanf(\"%d\" , &inp);\n\t\tmark[inp] = 1;\n\t}\n\t//if(m % 7){\n\t\tfor(int i = m ; i < n * 7 ; ++i){\n\t\t\tmark[i] = mark[i - m];\n\t\t}\n\t\tm = n * 7;\n\t\tq = n * 7;\n\t//}\n\tbase = getbase();\n\tprintf(\"%lld\\n\" , solve(7 * n / m).ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define val(p1,p2) p1>=0 && p1<m/7 && p2>=0 && p2<7 && !col[p1][p2] && vis[p1][p2]==-1\n#define val2(p1,p2) p1>=0 && p1<(n%m)/7 && p2>=0 && p2<7 && !col[p1][p2] && vis2[p1][p2]==-1\nusing namespace std;\n\nint main() {\n\tlong long n, m, q;\n\tscanf(\"%lld %lld %lld\", &n, &m, &q);\n\tn*=7;\n\tbitset<7> col[m/7];\n\tint vis[m/7][7], vis2[(n%m)/7][7];\n\tmemset(vis,-1,sizeof(vis));\n\tmemset(vis2,-1,sizeof(vis2));\n\tfor (int i=0; i<m; i++) col[i].reset();\n\tfor (int i=0; i<q; i++) {\n\t\tint aq; scanf(\"%d\", &aq);\n\t\tcol[aq/7][aq%7]=true;\n\t}\n\tint seg=0;\n\tqueue<pair<int, int> > qu;\n\tint xi[4]={1,0,-1,0}, yi[4]={0,1,0,-1};\n\tfor (int i=0; i<m/7; i++) {\n\t\tfor (int j=0; j<7; j++) {\n\t\t\tif (!col[i][j] && vis[i][j]==-1) {\n\t\t\t\tqu.push({i,j});\n\t\t\t\tvis[i][j]=seg;\n\t\t\t\twhile (!qu.empty()) {\n\t\t\t\t\tint x=qu.front().first, y=qu.front().second;\n\t\t\t\t\tqu.pop();\n\t\t\t\t\tfor (int k=0; k<4; k++) {\n\t\t\t\t\t\tint xx=x+xi[k], yy=y+yi[k];\n\t\t\t\t\t\tif (val(xx,yy)) {\n\t\t\t\t\t\t\tvis[xx][yy]=seg;\n\t\t\t\t\t\t\tqu.push({xx,yy});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tseg++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint con=0;\n\tunordered_set<int> segs;\n\tfor (int i=0; i<7; i++) {\n\t\tif (vis[0][i]!=-1 && segs.find(vis[0][i])==segs.end()) {\n\t\t\t//printf(\"%d %d %d\\n\", i, vis[0][i], vis[m/7-1][i]);\n\t\t\tif (vis[m/7-1][i]!=-1) {\n\t\t\t\tcon++;\n\t\t\t\tsegs.insert(vis[0][i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong long tot=(seg-con)*(n/m-1)+seg;\n\t//printf(\"%lld\\n\", tot);\n\t\n\tint seg2=0;\n\tfor (int i=0; i<(n%m)/7; i++) {\n\t\tfor (int j=0; j<7; j++) {\n\t\t\tif (!col[i][j] && vis2[i][j]==-1) {\n\t\t\t\tqu.push({i,j});\n\t\t\t\tvis2[i][j]=seg2;\n\t\t\t\twhile (!qu.empty()) {\n\t\t\t\t\tint x=qu.front().first, y=qu.front().second;\n\t\t\t\t\tqu.pop();\n\t\t\t\t\tfor (int k=0; k<4; k++) {\n\t\t\t\t\t\tint xx=x+xi[k], yy=y+yi[k];\n\t\t\t\t\t\tif (val2(xx,yy)) {\n\t\t\t\t\t\t\tvis2[xx][yy]=seg2;\n\t\t\t\t\t\t\tqu.push({xx,yy});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tseg2++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (n%m!=0) {\n\tint con2=0;\n\tunordered_set<int> segs2;\n\tfor (int i=0; i<7; i++) {\n\t\tif (vis2[0][i]!=-1 && segs2.find(vis2[0][i])==segs2.end()) {\n\t\t\tif (vis[m/7-1][i]!=-1) {\n\t\t\t\t//printf(\"%d %d\\n\", vis2[0][i], vis[m/7-1][i]);\n\t\t\t\tcon2++;\n\t\t\t\tsegs2.insert(vis[0][i]);\n\t\t\t}\n\t\t}\n\t}\n\ttot+=seg2-con2;\n}\n\tprintf(\"%lld\\n\", tot);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define  inc(i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define  dec(i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define UB upper_bound\n#define LB lower_bound\n#define PQ priority_queue\n\n#define  ALL(v)  v.begin(),  v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define  FOR(it, v) for(auto it =  v.begin(); it !=  v.end(); ++it)\n#define RFOR(it, v) for(auto it = v.rbegin(); it != v.rend(); ++it)\n\ntemplate<typename T> bool   setmin(T & a, T b) { if(b <  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool   setmax(T & a, T b) { if(b >  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmineq(T & a, T b) { if(b <= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmaxeq(T & a, T b) { if(b >= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, m, q, a[100000];\nint b[100000][7];\n\nvoid dfs(int pi, int pj) {\n\tint di[] = { 1, 0, -1,  0 };\n\tint dj[] = { 0, 1,  0, -1 };\n\t\n\tinc(k, 4) {\n\t\tint i = pi + di[k];\n\t\tint j = pj + dj[k];\n\t\tif(inID(i, 0, n) && inID(j, 0, 7) && b[i][j] == 0) {\n\t\t\tb[i][j] = 1;\n\t\t\tdfs(i, j);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> m >> q;\n\tinc(i, q) { cin >> a[i]; }\n\t\n\tif(n > 100000) { return 0; }\n\t\n\tinc(i, q) {\n\t\tint x = a[i];\n\t\tinc(j, 7 * n) {\n\t\t\tb[x / 7][x % 7] = 1;\n\t\t\t\n\t\t\tx += m;\n\t\t\tif(j >= 7 * n) { break; }\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tinc(i, n) {\n\tinc(j, 7) {\n\t\tif(b[i][j] == 0) {\n\t\t\tb[i][j] = 1;\n\t\t\tans++;\n\t\t\tdfs(i, j);\n\t\t}\n\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a <= x && x < b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\nstd::ostream& operator<<(std::ostream& os, const PAIR& r) {\n\tos << \"(\" << r.first << \", \" << r.second << \")\";\n\treturn os;\n}\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nint dy4[] = { -1, 0, 1, 0 };\nint dx4[] = { 0, 1, 0, -1 };\n\nint calc(std::vector<std::vector<bool>> a) {\n\tint cnt = 0;\n\n\tREP(i, a.size()) {\n\t\tREP(j, 7) {\n\t\t\tif (a[i][j]) continue;\n\t\t\t++cnt;\n\t\t\tstd::queue<PAIR> que;\n\t\t\tque.push(PAIR(i, j));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tPAIR now = que.front(); que.pop();\n\t\t\t\ta[now.first][now.second] = true;\n\t\t\t\tREP(d, 4) {\n\t\t\t\t\tint dy = now.first + dy4[d];\n\t\t\t\t\tint dx = now.second + dx4[d];\n\t\t\t\t\tif (!IN(0, dy, a.size()) || !IN(0, dx, 7)) continue;\n\t\t\t\t\tif (a[dy][dx]) continue;\n\t\t\t\t\tque.push(PAIR(dy, dx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, m, q);\n\tVEC(int, a, q);\n\tstd::vector<bool> bb(m, false);\n\tREP(i, q) {\n\t\tbb[a[i]] = true;\n\t}\n\tif (n <= 100000) {\n\t\tstd::vector<std::vector<bool>> b(n, std::vector<bool>(7, false));\n\t\tREP(i, n) REP(j, 7) {\n\t\t\tif (bb[(7 * i + j - 7 + 8 * m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tOUT(calc(b))BR;\n\t\treturn 0;\n\t}\n\n\tstd::vector<int> t(2);\n\tREP(_, 2) {\n\t\tstd::vector<std::vector<bool>> b(m / 7 * (_ + 1), std::vector<bool>(7, false));\n\t\tREP(i, m / 7 * (_ + 1)) REP(j, 7) {\n\t\t\tif (bb[(7 * i + j - 7 + 8*m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tt[_] = calc(b);\n\t}\n\tint x = 7 * n / m;\n\tint d = t[1] - t[0];\n\tOUT(t[0] + (x - 1)*d)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n\nusing namespace std;\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n\nconst int white=-1;\nconst int black=100000000;\n\n\nvi gx, gy;\n\n\nvoid push(int x, int y)\n{\n\tgx.push_back(x);\n\tgy.push_back(y);\n}\n\n\nint pop(int& x, int& y)\n{\n\tif(gx.size()<=0) return 0;\n\tx=gx.back();\n\ty=gy.back();\n\tgx.pop_back();\n\tgy.pop_back();\n\treturn 1;\n}\n\n\nvoid eng_fill(vvi& c, int x, int y, int g)\n{\n\tint vx[]={ 1, 0,-1, 0};\n\tint vy[]={ 0,-1, 0, 1};\n\tint nx, ny;\n\tint w, h;\n\n\tw=7;\n\th=c.size();\n\tpush(x, y);\n\tc[y][x]=g;\n\twhile(pop(x, y))\n\t{\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tnx=x+vx[i];\n\t\t\tny=y+vy[i];\n\t\t\tif(nx<0 || w<=nx || ny<0 || h<=ny) continue;\n\t\t\tif(c[ny][nx]!=white) continue;\n\t\t\tc[ny][nx]=g;\n\t\t\tpush(nx, ny);\n\t\t}\n\t}\n}\n\n\n\nint engroup(vvi& c)\n{\n\tint w, h, x, y;\n\tint g=0;\n\n\tw=7;\n\th=c.size();\n\tfor(y=0;y<h;y++)\n\t{\n\t\tfor(x=0;x<w;x++)\n\t\t{\n\t\t\tif(c[y][x]!=white) continue;\n\t\t\teng_fill(c, x, y, g);\n\t\t\tg++;\n\t\t}\n\t}\n\treturn g;\n}\n\n\nint main(void)\n{\n\tint n, m, q, g, h, uh, gc;\n\tvvi c, f;\n\tvi a;\n\n\twhile(scanf(\"%d%d%d\", &n, &m, &q)==3)\n\t{\n\t\tuh=m/7;\n\t\th=n/uh;\n\t\tc.clear();\n\t\tc.resize(uh);\n\t\tfor(auto& ce: c) ce.resize(7, white);\n\n\t\ta.resize(q);\n\t\tfor(int i=0;i<q;i++)\n\t\t{\n\t\t\tint a;\n\t\t\tscanf(\"%d\", &a);\n\t\t\tc[a/7][a%7]=black;\n\t\t}\n\t\tg=engroup(c);\n\n\t\tgc=0;\n\t\tf.clear();\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tint u=c[0][i];\n\t\t\tint l=c[uh-1][i];\n\t\t\tint j;\n\t\t\tif(u==black || l==black) continue;\n\t\t\tif(u>l) swap(u, l);\n\t\t\tvi ft={u,l};\n\t\t\tfor(j=f.size()-1;j>=0;j--)\n\t\t\t{\n\t\t\t\tif(ft==f[j]) break;\n\t\t\t}\n\t\t\tif(j<0)\n\t\t\t{\n\t\t\t\tf.push_back(ft);\n\t\t\t}\n\t\t}\n\t\tgc=f.size();\n\n//\t\tprintf(\"g=%d h=%d gc=%d\\n\", g, h, gc);\n\t\tint result=g*h-gc*(h-1);\n\t\tprintf(\"%d\\n\", result);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nbool cal[7][10000];\nint n,m,q;\n\nvoid block(int i,int j);\nint main(){\n\tint qt;\n\tint ans;\n\tint i,j,k;\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\t\n\tfor(k=0;k<q;k++){\n\t\tscanf(\"%d\",&qt);\n\t\tfor(i=qt;i<n*7;i+=m){\n\t\t\tcal[i%7][i/7] = true;\n\t\t}\n\t}\n\t\n\tans = 0;\n\tfor(i=0;i<7*n;i++){\n\t\tif(!cal[i%7][i/7]){\n\t\t\tans++;\n\t\t\tblock(i%7,i/7);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\t\nvoid block(int i,int j){\n\tif(cal[i][j]) return;\n\tcal[i][j] = true;\n\tif(i!=6){\n\t\tblock(i+1,j);\n\t}\n\tif(j!=n-1){\n\t\tblock(i,j+1);\n\t}\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll n,m;\nint q;\nll a[1000001];\nll cnt[7];\nint fie[100001][7];\nint dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint bfs(int y,int x){\n\tqueue<P> que;\n\tque.push(P(y,x));\n\twhile(que.size()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=p.second+dx[i],ny=p.first+dy[i];\n\t\t\tif(nx>=0 && nx<7 && ny>=0){\n\t\t\t\tif(fie[ny][nx]==0){\n\t\t\t\t\tfie[ny][nx]=1;\n\t\t\t\t\tque.push(P(ny,nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%lld%lld%d\",&n,&m,&q);\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%lld\",&a[i]);\n\t}\n\tint len=m/7;\n\tint cnt=0;\n\tmemset(fie,-1,sizeof(fie));\n\tfor(int i=0;i<len;i++){\n\t\tfor(int j=0;j<7;j++){\n\t\t\tfie[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tfie[a[i]/7][a[i]%7]=1;\n\t}\n\tfor(int i=0;i<len;i++){\n\t\tfor(int j=0;j<7;j++){\n\t\t\tif(fie[i][j]==0){\n\t\t\t\tcnt++;\n\t\t\t\tbfs(i,j);\n\t\t\t}\n\t\t}\n\t}\n\tmemset(fie,-1,sizeof(fie));\n\tfor(int i=0;i<len*2;i++){\n\t\tfor(int j=0;j<7;j++){\n\t\t\tfie[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tfie[a[i]/7][a[i]%7]=1;\n\t\tfie[a[i]/7+len][a[i]%7]=1;\n\t}\n\tint cnt2=0;\n\tfor(int i=0;i<len*2;i++){\n\t\tfor(int j=0;j<7;j++){\n\t\t\tif(fie[i][j]==0){\n\t\t\t\tcnt2++;\n\t\t\t\tbfs(i,j);\n\t\t\t}\n\t\t}\n\t}\n\tll ad=(ll)7LL*n/m;\n\tprintf(\"%lld\\n\",(ll)cnt+(cnt2-cnt)*(ad-1LL));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  for(int i=0;i<(n);++i)\n#define REPr(i,n) for(int i=(n)-1;i>=0; --i)\n#define FORq(i, m, n) for(int i = (m);i <= (n);++i)\n#define rFORq(i, m , n) for(int i = (n);i >=(m);--i)\n#define SCD(n) scanf(\"%d\",&n)\n#define SCD2(m,n) scanf(\"%d%d\",&m,&n)\n#define SCD3(m,n,k) scanf(\"%d%d%d\",&m,&n,&k)\n#define SCLLD(n) scanf(\"%lld\",&n)\n#define SCLLD2(m,n) scanf(\"%lld%lld\",&m,&n)\n#define SCLLD3(m,n,k) scanf(\"%lld%lld%lld\",&m,&n,&k)\n#define PB push_back\n#define MP make_pair\n#define ARSCD(A,N) REP(i,N){SCD(A[i]);}\n#define ARSCD1(A,N) FORq(i,1,N){SCD(A[i]);}\n#define VSCD(v,N) REP(i,N){int x; SCD(x); v.PB(x);}\n#define VSCLLD(v,N) REP(i,N){long long x; SCLLD(x); v.PB(x);}\n#define PRINTD(n) printf(\"%d\\n\",n)\n#define PRINTLLD(n) printf(\"%lld\\n\",n)\n#define DEBUG printf(\"%s\\n\",\"debug\")\n#define fst first\n#define snd second\n#define SIN(x,S) (S.count(x) != 0)\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector < VI > VVI;\ntypedef vector<long long> VL;\ntypedef long long ll;\ntypedef long long integer;\n////////////////////////////////////////////////////////////////////\nconst ll p = 1000000007;\nll dx[4] = {-7,-1,1,7};\n\nint main(){\n    ll N,M,Q; SCLLD3(N,M,Q);\n    //static ll a[100002] = {};\n    static bool grid[100002] = {}; // partial\n    static bool visited[100002] = {};\n    static bool visited2[200002] = {};\n    //static bool visited[100002] = {};\n    //ARSCD(a,Q);\n\n    REP(q,Q){\n        ll ai;\n        SCLLD(ai);\n        ll k = 0;\n        while(k*M + ai < M){\n            grid[k*M+ai] = true;\n            k++;\n        }\n    }\n\n/*     FORq(i,0,2*M-1){\n        if (i % 7 == 0) printf(\"\\n\");\n        if (grid[i]) printf(\"%d\",1);\n        else printf(\"%d\",0);\n    }\n    printf(\"\\n\"); */\n\n    ll count1 = 0;\n    ll count2 = 0;\n    queue<ll> que;\n\n    // #1\n    FORq(i,0,M-1){\n        if (grid[i]) continue;\n        if (visited[i]) continue;\n        que.push(i);\n        //printf(\"start = %d\\n\",i);\n        while(!que.empty()){\n            ll now = que.front(); que.pop();\n            visited[now] = true;\n            \n            REP(k,4){\n                ll next = now + dx[k];\n                if ((now % 7 == 0) and (k == 1)) continue;\n                if (next < 0) continue;\n                if (next >= M) continue;\n                if ((now % 7 == 6) and (k == 2)) continue;\n                if (grid[next]) continue;\n                if (visited[next]) continue;\n                //printf(\"next -> %lld\\n\",next);\n                que.push(next);\n            }\n        }\n        //printf(\"count+\\n\");\n        count1++;\n    }\n\n    //printf(\"count1 = %lld\\n\",count1);\n\n    // #2\n    FORq(i,0,2*M-1){\n        if (grid[i % M]) continue;\n        if (visited2[i]) continue;\n        que.push(i);\n        //printf(\"start = %d\\n\",i);\n        while(!que.empty()){\n            ll now = que.front(); que.pop();\n            visited2[now] = true;\n            \n            REP(k,4){\n                ll next = now + dx[k];\n                if ((now % 7 == 0) and (k == 1)) continue;\n                if (next < 0) continue;\n                if (next >= 2*M) continue;\n                if ((now % 7 == 6) and (k == 2)) continue;\n                if (grid[next % M]) continue;\n                if (visited2[next]) continue;\n                //printf(\"next -> %lld\\n\",next);\n                que.push(next);\n            }\n        }\n        //printf(\"count+\\n\");\n        count2++;\n    }\n    \n    //printf(\"count2 = %lld\\n\",count2);\n\n    ll A,B;\n    A = count2 - count1;\n    B = count1 - A;\n    ll c = 7*N / M;\n    PRINTLLD(A*c + B);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  for(int i=0;i<(n);++i)\n#define REPr(i,n) for(int i=(n)-1;i>=0; --i)\n#define FORq(i, m, n) for(int i = (m);i <= (n);++i)\n#define rFORq(i, m , n) for(int i = (n);i >=(m);--i)\n#define SCD(n) scanf(\"%d\",&n)\n#define SCD2(m,n) scanf(\"%d%d\",&m,&n)\n#define SCD3(m,n,k) scanf(\"%d%d%d\",&m,&n,&k)\n#define SCLLD(n) scanf(\"%lld\",&n)\n#define SCLLD2(m,n) scanf(\"%lld%lld\",&m,&n)\n#define SCLLD3(m,n,k) scanf(\"%lld%lld%lld\",&m,&n,&k)\n#define PB push_back\n#define MP make_pair\n#define ARSCD(A,N) REP(i,N){SCD(A[i]);}\n#define ARSCD1(A,N) FORq(i,1,N){SCD(A[i]);}\n#define VSCD(v,N) REP(i,N){int x; SCD(x); v.PB(x);}\n#define VSCLLD(v,N) REP(i,N){long long x; SCLLD(x); v.PB(x);}\n#define PRINTD(n) printf(\"%d\\n\",n)\n#define PRINTLLD(n) printf(\"%lld\\n\",n)\n#define DEBUG printf(\"%s\\n\",\"debug\")\n#define fst first\n#define snd second\n#define SIN(x,S) (S.count(x) != 0)\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector < VI > VVI;\ntypedef vector<long long> VL;\ntypedef long long ll;\ntypedef long long integer;\n////////////////////////////////////////////////////////////////////\nconst ll p = 1000000007;\nll dx[4] = {-7,-1,1,7};\nll N,M,Q;\nstatic ll a[100002] = {};\nstatic bool grid[200003] = {};\nstatic bool visited[100002] = {};\nstatic bool visited2[200002] = {};\n\nvoid dfs1(ll pos){\n    if (visited[pos]) return;\n    visited[pos] = true;\n\n    REP(k,4){\n        ll next = pos + dx[k];\n        if (next >= M) continue;\n        if (next < 0) continue;\n        if ((k==1) and (pos % 7 == 0)) continue;\n        if ((k==2) and (pos % 7 == 6)) continue;\n        if (grid[next]) continue;\n        if (visited[next]) continue;\n        dfs1(next);\n    }\n\n    return;\n}\n\nvoid dfs2(ll pos){\n    if (visited2[pos]) return;\n    visited2[pos] = true;\n\n    REP(k,4){\n        ll next = pos + dx[k];\n        if (next >= 2*M) continue;\n        if (next < 0) continue;\n        if ((k==1) and (pos % 7 == 0)) continue;\n        if ((k==2) and (pos % 7 == 6)) continue;\n        if (grid[next]) continue;\n        if (visited2[next]) continue;\n        dfs2(next);\n    }\n\n    return;\n}\n\n\n\nint main(){\n    SCLLD3(N,M,Q);\n    ARSCD(a,Q);\n\n    REP(q,Q){\n        ll ai = a[q];\n        ll k = 0;\n        while(k*M + ai <= 2*M){\n            grid[k*M+ai] = true;\n            k++;\n        }\n    }\n\n/*     FORq(i,0,2*M-1){\n        if (i % 7 == 0) printf(\"\\n\");\n        if (grid[i]) printf(\"%d\",1);\n        else printf(\"%d\",0);\n    }\n    printf(\"\\n\"); */\n\n    ll count1 = 0;\n    ll count2 = 0;\n\n    FORq(i,0,M-1){\n        if ((grid[i] == false) and (visited[i] == false)){\n            dfs1(i);\n            count1++;\n        }\n    }\n    //printf(\"count1 = %lld\\n\",count1);\n\n    FORq(i,0,2*M-1){\n        if ((grid[i] == false) and (visited2[i] == false)){\n            dfs2(i);\n            count2++;\n        }\n    }\n\n    //printf(\"count2 = %lld\\n\",count2);\n    ll A,B;\n    A = count2 - count1;\n    B = count1 - A;\n    ll c = 7*N / M;\n    PRINTLLD(A*c + B);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\n#define ALL(x) x.begin(),x.end()\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nstruct UnionFind{\n\tvector<int> par,rank;\n\tUnionFind(int n) :par(n + 1),rank(n + 1,1){\n\t\tfor(int i = 1;i <= n;i++) par [i] = i;\n\t}\n\tint find(int x){\n\t\treturn par [x] == x ? x : par [x] = find(par [x]);\n\t}\n\tbool connect(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return false;\n\t\tif(rank [x] < rank [y]) swap(x,y);\n\t\trank [x] += rank [x] == rank [y];\n\t\tpar [y] = x;\n\t\treturn true;\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nll N,M,Q;\nset<int> st;\n\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&N,&M,&Q);\n\tFOR(i,0,Q){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tst.insert(x);\n\t}\n\tint repeat;\n\tif(M % 7 == 0){\n\t\trepeat = M / 7;\n\t}\n\telse{\n\t\trepeat = M;\n\t}\n\n\tUnionFind uf(repeat * 7 * 2);\n\tvector<string> S(repeat,string(7,'x')),T(repeat,string(7,'x'));\n\tFOR(i,0,repeat) FOR(j,0,7) if(st.count((i * 7 + j) % M) == 0){\n\t\tS [i] [j] = 'o';\n\t\tT [i] [j] = 'o';\n\t\tif(i && S [i - 1] [j] == 'o'){\n\t\t\tuf.connect((i - 1) * 7 + j,i * 7 + j);\n\t\t\tuf.connect((i - 1) * 7 + j + (repeat * 7),i * 7 + j + (repeat * 7));\n\t\t}\n\t\tif(j && S [i] [j - 1] == 'o'){\n\t\t\tuf.connect(i * 7 + (j - 1),i * 7 + j);\n\t\t\tuf.connect(i * 7 + (j - 1) + (repeat * 7),i * 7 + j + (repeat * 7));\n\t\t}\n\t}\n\n\tll ans = 0;\n\tFOR(i,0,repeat) FOR(j,0,7) if(S [i] [j] == 'o' && uf.find((i * 7 + j)) == i * 7 + j){\n\t\tans += N / repeat;\n\t}\n\tFOR(i,0,7) if(S.front() [i] == 'o' && S.back() [i] == 'o'){\n\t\tif(uf.connect((repeat - 1) * 7 + i,i + (repeat * 7))){\n\t\t\tans -= N / repeat - 1;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<map>\n#include<string>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n//#define scanf scanf_s\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\nconst llint mod=1000000007;\n\n\nint main(void){\n\tllint N,ans;\n\tint M,q,i,j,a,ansa,ansb,ok=0;\n\tqueue<int> que;\n\tvector<int> nuru;\n\tvector<int> nuran;\n\tset<int> siro;\n\tscanf(\"%lld %d %d\",&N,&M,&q);\n\tfor(i=0;i<q;i++){\n\t\tscanf(\"%d\",&a);\n\t\tnuru.pub(a);\n\t}\n\t\n\tif(M%7!=0){ \n\t\tfor(i=0;i<q;i++){\n\t\t\tfor(j=1;j<7;j++){\n\t\t\t\tnuru.pub(nuru[i]+M*j);\n\t\t\t}\n\t\t}\n\t\tM*=7;ok=1;\n\t}\n\tsort(nuru.begin(),nuru.end());\n\tj=0;\n\tfor(i=0;i<M;i++){\n\t\tif(j!=nuru.size()&&nuru[j]<i){j++;}\n\t\tif(j==nuru.size()||nuru[j]>i){nuran.pub(i);}\n\t}\n\t\n\tfor(i=0;i<nuran.size();i++){\n\t\tsiro.insert(nuran[i]);\n\t}\n\tansa=0;\n\twhile(siro.size()!=0){\n\t\tque.push(*siro.begin());\n\t\twhile(!que.empty()){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tif(siro.find(a)==siro.end()){continue;}\n\t\t\tif(a-7>=0&&siro.find(a-7)!=siro.end()){ que.push(a-7); }\n\t\t\tif(a+7<M&&siro.find(a+7)!=siro.end()){ que.push(a+7); }\n\t\t\tif(a%7!=0&&siro.find(a-1)!=siro.end()){ que.push(a-1); }\n\t\t\tif(a%7!=6&&siro.find(a+1)!=siro.end()){ que.push(a+1); }\n\t\t\tsiro.erase(a);\n\t\t}\n\t\tansa++;\n\t}\n\n\tfor(i=0;i<nuran.size();i++){\n\t\tsiro.insert(nuran[i]);siro.insert(nuran[i]+M);\n\t}\n\tansb=0;\n\twhile(siro.size()!=0){\n\t\tque.push(*siro.begin());\n\t\twhile(!que.empty()){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tif(siro.find(a)==siro.end()){continue;}\n\t\t\tif(a-7>=0&&siro.find(a-7)!=siro.end()){ que.push(a-7); }\n\t\t\tif(a+7<2*M&&siro.find(a+7)!=siro.end()){ que.push(a+7); }\n\t\t\tif(a%7!=0&&siro.find(a-1)!=siro.end()){ que.push(a-1); }\n\t\t\tif(a%7!=6&&siro.find(a+1)!=siro.end()){ que.push(a+1); }\n\t\t\tsiro.erase(a);\n\t\t}\n\t\tansb++;\n\t}\n\tans=(ansb-ansa)*N*7/M+(2*ansa-ansb);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef pair<ll,P> T;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define LLINF 1000000000000000ll\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nll n;\nint m,q;\nint a[100100];\nint c[1400100];\nint main(){\n\tscanf(\"%lld %d %d\",&n,&m,&q);\n\tfor(int i=0;i<q;i++){\n\t\tint tmp;\n\t\tscanf(\"%d\",&tmp);\n\t\ta[tmp]=1;\n\t}\n\tint k=0;\n\tmemset(c,-1,sizeof(c));\n\tint M = m;\n\tif(m%7!=0)M*=7;\n\tll l = 7*n/M;\n\tll A = 0ll,B = 0ll;\n\tfor(int i=0;i<2*M;i++){\n\t\tif(a[i%m]){\n\t\t\tcontinue;\n\t\t}else{\n\t\t\tif(i-7>=0&&c[i-7]!=-1)c[i]=c[i-7];\n\t\t\telse if(i%7!=0&&c[i-1]!=-1)c[i]=c[i-1];\n\t\t\telse{\n\t\t\t\tc[i]=k++;\n\t\t\t}\n\t\t}\n\t\tif(i==M-1)A=k;\n\t\tif(i==2*M-1)B=k;\n\t}\n\tcout << A+(B-A)*(l-1ll) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define maxn 700010\nint a[maxn];\nbool col[maxn][7], vis[maxn][7];\ntypedef long long ll;\nstruct que {\n\tint x, y;\n} qu[maxn * 7];\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\nint up[7], dw[7], Fa[14];\nint Find(int x) {return Fa[x] == x ? x : Fa[x] = Find(Fa[x]);}\nint main()\n{\n\tll n;\n\tint m, q; scanf(\"%lld%d%d\", &n, &m, &q);\n\tfor (int i = 1; i <= q; ++i) scanf(\"%d\", &a[i]);\n\tif (m % 7)\n\t{\n\t\tint nq = q;\n\t\tfor (int i = 1; i <= q; ++i)\n\t\t\tfor (int j = 1; j < 7; ++j)\n\t\t\t\ta[++nq] = a[i] + j * m;\n\t\tm *= 7; q = nq;\n\t}\n\tint mm = m / 7, cnt = 0;\n\tfor (int i = 1; i <= q; ++i) col[a[i] / 7][a[i] % 7] = 1;\n\n\tfor (int i = 0; i < mm; ++i)\n\t\tfor (int j = 0; j < 7; ++j)\n\t\t\tif (!vis[i][j] && !col[i][j])\n\t\t\t{\n\t\t\t\t++cnt;\n\t\t\t\tint head = 0, tail = 1; qu[1] = (que) {i, j}; vis[i][j] = 1;\n\t\t\t\twhile (head < tail)\n\t\t\t\t{\n\t\t\t\t\tque now = qu[++head];\n\t\t\t\t\tfor (int k = 0, nx, ny; k < 4; ++k)\n\t\t\t\t\t{\n\t\t\t\t\t\tnx = now.x + dx[k]; ny = now.y + dy[k];\n\t\t\t\t\t\tif (nx >= 0 && nx < mm && ny >= 0 && ny < 7 && !vis[nx][ny] && !col[nx][ny])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tqu[++tail] = (que) {nx, ny};\n\t\t\t\t\t\t\tvis[nx][ny] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\tprintf(\"%d\\n\", cnt);\n\tint pcnt = 0, cnt2 = 0;\n\tfor (int i = 0; i < 7; ++i) !col[0][i] ? i == 0 || col[0][i - 1] ? up[i] = ++pcnt : up[i] = pcnt : 0;\n\tfor (int i = 0; i < 7; ++i) !col[mm - 1][i] ? i == 0 || col[mm - 1][i - 1] ? dw[i] = ++pcnt : dw[i] = pcnt : 0;\n\tfor (int i = 1; i <= pcnt; ++i) Fa[i] = i;\n\n//\tfor (int i = 0; i < 7; ++i) printf(\"%d %d\\n\", up[i], dw[i]);\n\tfor (int i = 0; i < 7; ++i)\n\t\tif (up[i] && dw[i] && Find(up[i]) != Find(dw[i]))\n\t\t{\n\t\t\tFa[Find(up[i])] = Find(dw[i]);\n\t\t\t++cnt2;\n\t\t}\n//\tprintf(\"%d\\n\", cnt2);\n\tprintf(\"%lld\\n\", 1ll * cnt * (n / mm) - 1ll * (n / mm - 1) * cnt2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 2333333\nll n;\nint m,q,a[SZ];\nbool cov[SZ];\nint ff[SZ];\nint gf(int x) {return (ff[x]==-1)?x:ff[x]=gf(ff[x]);}\nvoid uni(int a,int b)\n{int ga=gf(a),gb=gf(b);if(ga^gb)ff[ga]=gb;}\nint main()\n{\n\tscanf(\"%lld%d%d\",&n,&m,&q);\n\tfor(int i=1;i<=q;i++)\n\tscanf(\"%d\",a+i),cov[a[i]]=1;\n\t#define TJ(r,ans)\\\n\tmemset(ff,-1,sizeof(ff));\\\n\tfor(int i=0;i<r;i++)\\\n\t{\\\n\t\tif(cov[i%m])continue;\\\n\t\tif(i+7<r&&!cov[(i+7)%m]) uni(i,i+7);\\\n\t\tif(i%7!=6&&i+1<r&&!cov[(i+1)%m]) uni(i,i+1);\\\n\t}\\\n\tfor(int i=0;i<r;i++)\\\n\t\tif(!cov[i%m]) ans+=gf(i)==i;\n\tint ans1=0; TJ(m*7,ans1)\n\tint ans2=0; TJ(m*14,ans2)\n\tll rd=7*n/m,zg=rd/7,bf=rd%7,ans=0;\n\tif(zg) ans=ans1+ans2*(zg-1);\n\tint ans3=0; TJ(m*bf,ans3)\n\tint ans4=0; TJ(m*bf+m*7,ans4)\n\tif(zg) ans+=ans4-ans3; else ans+=ans3;\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n#include<iostream>\n#include<unordered_set>\n\nusing namespace std;\n\n#define dprint(Exp,...) if(Exp){fprintf(stderr, __VA_ARGS__);}\n#define printe(...) fprintf(stderr, __VA_ARGS__);\n#define PrtExp(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp)\n#define PrtExpN(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp) <<\"\\n\"\n\n#define SINT(n) scanf(\"%d\",&n)\n#define SINT2(n,m) scanf(\"%d %d\",&n,&m)\n#define SINT3(n,m,o) scanf(\"%d %d %d\",&n,&m,&o)\n#define SINT4(n,m,o,p) scanf(\"%d %d %d %d\",&n,&m,&o,&p)\n#define SINT5(n,m,o,p,q) scanf(\"%d %d %d %d %d\",&n,&m,&o,&p,&q)\n#define SLL(n) scanf(\"%lld\",&n)\n#define SLL2(n,m) scanf(\"%lld %lld\",&n,&m)\n#define SLL3(n,m,o) scanf(\"%lld %lld %lld\",&n,&m,&o)\n#define SST(s) scanf(\"%s\",s)\n#define SCH(c) scanf(\"%c\",&c)\n\n#define GC() getchar()\n\n#define PINT(n) printf(\"%d\",(int)(n))\n#define PINT2(n,m) printf(\"%d %d\",(int)(n),(int)(m))\n#define PINT3(n,m,l) printf(\"%d %d %d\",(int)(n),(int)(m),(int)(l))\n#define PLL(n) printf(\"%lld\",(long long)(n))\n#define PST(s) printf(\"%s\",(s))\n#define PCH(s) printf(\"%c\",(s))\n\n#define PINTN(n) printf(\"%d\\n\",(int)(n))\n#define PINT2N(n,m) printf(\"%d %d\\n\",(int)(n),(int)(m))\n#define PINT3N(n,m,l) printf(\"%d %d %d\\n\",(int)(n),(int)(m),(int)(l))\n#define PLLN(n) printf(\"%lld\\n\",(long long)(n))\n#define PSTN(s) printf(\"%s\\n\",(s))\n#define PCHN(s) printf(\"%c\\n\",(s))\n\n#define PSP() printf(\" \")\n#define PN() printf(\"\\n\")\n\n#define PC(c) putchar(c)\n#define CSP (' ')\n#define SN (\"\\n\")\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define reP(i,a) for(int i=0;i<=a;i++)\n#define Rep(i,a) for(int i=a-1;i>=0;i--)\n#define ReP(i,a) for(int i=a;i>=0;i--)\n\n#define rEp(i,a) for(i=0;i<a;i++)\n#define rEP(i,a) for(i=0;i<=a;i++)\n#define REp(i,a) for(i=a-1;i>=0;i--)\n#define REP(i,a) for(i=a;i>=0;i--)\n\n#define repft(i,a,b) for(int i=a;i<b;i++)\n#define repfT(i,a,b) for(int i=a;i<=b;i++)\n#define Repft(i,a,b) for(int i=a-1;i>=b;i--)\n#define RepfT(i,a,b) for(int i=a;i>=b;i--)\n\n#define foreach(a,it) for(auto it = a.begin(); it != a.end(); ++it)\n\n#define FILL(a,v) fill(begin(a),end(a), v)\n#define FILL0(a) memset(a,0,sizeof(a))\n#define FILL1(a) memset(a,-1,sizeof(a))\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll>   Pll;\n\n\nconst int INF = 0x2aaaaaaa; // 715,827,882\nconst ll INFLL = 0x1f1f1f1f1f1f1f1fLL;//2,242,545,357,980,376,863\n\ntemplate <class A, class B> inline ostream& operator<<(ostream& st, const pair<A, B>& P) { return st << \"(\" << P.first << \",\" << P.second << \")\"; };\ntemplate <class A, class B> inline pair<A, B> operator+(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first + Q.first, P.second + Q.second); };\ntemplate <class A, class B> inline pair<A, B> operator-(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first - Q.first, P.second - Q.second); };\n\n#define fs  first\n#define sc  second\n\n\nll n, m, q, g;\nbool a[800005] = {};\nbool b[1600005][9];\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nvoid dfs(int y, int x) {\n\tb[y][x] = false;\n\trep(i, 4) {\n\t\tint Y = y + dy[i];\n\t\tint X = x + dx[i];\n\t\tif (b[Y][X]) dfs(Y, X);\n\t}\n}\n\nint solve(int M) {\n\t/*\n\trep(i, M+2){\n\t\trep(j, 9) {\n\t\t\tcout << b[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n\t*/\n\tqueue<Pi> Q;\n\tint ret = 0;\n\trep(i, M) rep(j, 7) {\n\t\tif (b[i + 1][j + 1]) {\n\t\t\tret++;\n\t\t\tQ.push({ i + 1, j + 1 });\n\t\t\tb[i+1][j+1] = false;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tPi p = Q.front(); Q.pop();\n\t\t\t\trep(i, 4) {\n\t\t\t\t\tint Y = p.fs + dy[i];\n\t\t\t\t\tint X = p.sc + dx[i];\n\t\t\t\t\tif (b[Y][X]) {\n\t\t\t\t\t\tQ.push({ Y, X });\n\t\t\t\t\t\tb[Y][X] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nll gcd(ll a, ll b) {\n\treturn b == 0 ? a : gcd(b, a%b);\n}\n\nint main() {\n\tcin >> n >> m >> q;\n\tg = m / gcd(m, 7);\n\t// PrtExpN(g);\n\n\trep(i, q) {\n\t\tint x;\n\t\tcin >> x;\n\t\trep(j, 8) a[j*m + x] = true;\n\t}\n\tFILL0(b);\n\trep(i, 7 * g) {\n\t\tint x = i % 7 + 1;\n\t\tint y = i / 7 + 1;\n\t\tb[y][x] = !a[i%m];\n\t}\n\tll r1 = solve(g);\n\n\tFILL0(b);\n\trep(i, 14 * g) {\n\t\tint x = i % 7 + 1;\n\t\tint y = i / 7 + 1;\n\t\tb[y][x] = !a[i%m];\n\t}\n\n\tll r2 = solve(g*2);\n\n\tll z = n / g;\n\tll ret = (z - 1)*r2 - (z - 2)*r1;\n\n\t// cout << r1 << \" \" << r2 << \" \" << ret << endl;\n\tcout << ret << endl;\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a <= x && x < b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\nstd::ostream& operator<<(std::ostream& os, const PAIR& r) {\n\tos << \"(\" << r.first << \", \" << r.second << \")\";\n\treturn os;\n}\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nint dy4[] = { -1, 0, 1, 0 };\nint dx4[] = { 0, 1, 0, -1 };\n\nint calc(std::vector<std::vector<bool>> a) {\n\tint cnt = 0;\n\n\tREP(i, a.size()) {\n\t\tREP(j, 7) {\n\t\t\tif (a[i][j]) continue;\n\t\t\t++cnt;\n\t\t\tstd::queue<PAIR> que;\n\t\t\tque.push(PAIR(i, j));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tPAIR now = que.front(); que.pop();\n\t\t\t\ta[now.first][now.second] = true;\n\t\t\t\tREP(d, 4) {\n\t\t\t\t\tint dy = now.first + dy4[d];\n\t\t\t\t\tint dx = now.second + dx4[d];\n\t\t\t\t\tif (!IN(0, dy, a.size()) || !IN(0, dx, 7)) continue;\n\t\t\t\t\tif (a[dy][dx]) continue;\n\t\t\t\t\tque.push(PAIR(dy, dx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, m, q);\n\tVEC(int, a, q);\n\tstd::vector<bool> bb(m, false);\n\tREP(i, q) {\n\t\tbb[a[i] - 1] = true;\n\t}\n\tstd::vector<int> t(2);\n\tREP(_, 2) {\n\t\tstd::vector<std::vector<bool>> b(m / 7 * (_ + 1), std::vector<bool>(7, false));\n\t\tREP(i, m / 7 * (_ + 1)) REP(j, 7) {\n\t\t\tif (bb[(7 * i + j - 8 + 8*m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tt[_] = calc(b);\n\t}\n\tint x = 7 * n / m;\n\tint d = t[1] - t[0];\n\tOUT(t[0] + (x - 1)*d)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long int n2;\nint m,q,ct,n;\nint f[111111][7];\nbool g[111111];\nvoid dfs(int x,int y){\n\tif(x<0 || x>=n || y<0 || y>=7 || f[x][y]!=-2)return;\n\tf[x][y] = ct;\n\tdfs(x-1,y);\n\tdfs(x,y-1);\n\tdfs(x+1,y);\n\tdfs(x,y+1);\n}\n\nset<int> S;\nset<pair<int,int> > E;\nint ace[99];\nint ancestor(int x){return x-ace[x]?ace[x]=ancestor(ace[x]):x;}\nint calc(){\n\tmap<int,int> Map;\n\tint z = 0;\n\tfor(set<int>::iterator it = S.begin(); it!=S.end(); it++){\n\t\tMap[*it] = z++;\n\t}\n\tfor(int i=0; i<z; i++)\n\t\tace[i] = i;\n\tfor(set<pair<int,int> >::iterator it = E.begin(); it!=E.end(); it++){\n\t\tace[ancestor(Map[it->first])]=ancestor(Map[it->second]);\n\t}\n\tint res = 0;\n\tfor(int i=0; i<z; i++){\n\t\tif(ancestor(i) == i)\n\t\t\tres++;\n\t}\n\treturn z - res;\n}\n\nint main(){\n\tcin>>n2>>m>>q;\n\tif(m%7==0)\n\t\tn=m/7;\n\telse\n\t\tn=m;\n\n\tfor(int i=0; i<q; i++){\n\t\tint x;\n\t\tcin>>x;\n\t\tg[x] = true;\n\t}\n\tmemset(f,-1,sizeof(f));\n\tfor(int i=0; i<n; i++)\n\t\tfor(int j=0; j<7; j++)\n\t\t\tif(!g[(i*7+j)%m])\n\t\t\t\tf[i][j] = -2;\n\tfor(int i=0; i<n; i++)\n\tfor(int j=0; j<7; j++)\n\tif(f[i][j] == -2){\n\t\tdfs(i,j);\n\t\tct++;\n\t}\n\tfor(int j=0; j<7; j++){\n\t\tint x = f[0][j], y=f[n-1][j];\n\t\tif(x!=-1)S.insert(x);\n\t\tif(y!=-1)S.insert(y+ct);\n\t\tif(x!=-1 && y!=-1){\n\t\t\tE.insert(make_pair(x,y+ct));\n\t\t}\n\t}\n\tint dec = calc();\n\tcout << (n2 / n) * ct - (n2/n-1)*dec << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(long long i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstruct edge{int to,cap,rev;};//ikisaki youryou gyakuhen\n\nint n,m,q;\nll gcd(ll a,ll b){\n\treturn (b==0?a:gcd(b,a%b));\n}\nll lcm(ll a,ll b){\n\treturn a/gcd(a,b)*b;\n}\nvvi dp;\nint a,b,c,t;\nvoid dfs(int a,int b){\n\tdp[a][b]=2;\n\trep(i,4){\n\t\tint x=a+dx[i];\n\t\tint y=b+dy[i];\n\t\tif(x<0||x>=t)c=1;\n\t\tif(x<0||x>=t||y<0||y>=7)continue;\n\t\tif(dp[x][y])continue;\n\t\tdfs(x,y);\n\t}\n}\nsigned main(){\n\tcin>>n>>m>>q;\n\tt=lcm(7,m);\n\tif(n-t)t*=2;\n\tt/=7;\n\tdp=vvi(t,vi(7));\n\trep(i,q){\n\t\tint a;\n\t\tcin>>a;\n\t\trep(j,t)rep(k,7)if((j*7+k)%m==a)\n\t\t\tdp[j][k]=1;\n\t}\n\trep(i,t)rep(j,7)if(dp[i][j]==0){\n\t\tc=0;\n\t\tdfs(i,j);\n\t\tif(c)b++;\n\t\telse a++;\n\t}\n\t\n\t\n\tif(t*7==n){\n\t\tcout<<a+b<<endl;\n\t}else{\n\t\tt/=2;\n\t\tcout<<a+b*(n/t-1)<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a <= x && x < b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\nstd::ostream& operator<<(std::ostream& os, const PAIR& r) {\n\tos << \"(\" << r.first << \", \" << r.second << \")\";\n\treturn os;\n}\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nint dy4[] = { -1, 0, 1, 0 };\nint dx4[] = { 0, 1, 0, -1 };\n\nint calc(std::vector<std::vector<bool>> a) {\n\tint cnt = 0;\n\n\tREP(i, a.size()) {\n\t\tREP(j, 7) {\n\t\t\tif (a[i][j]) continue;\n\t\t\t++cnt;\n\t\t\tstd::queue<PAIR> que;\n\t\t\tque.push(PAIR(i, j));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tPAIR now = que.front(); que.pop();\n\t\t\t\ta[now.first][now.second] = true;\n\t\t\t\tREP(d, 4) {\n\t\t\t\t\tint dy = now.first + dy4[d];\n\t\t\t\t\tint dx = now.second + dx4[d];\n\t\t\t\t\tif (!IN(0, dy, a.size()) || !IN(0, dx, 7)) continue;\n\t\t\t\t\tif (a[dy][dx]) continue;\n\t\t\t\t\tque.push(PAIR(dy, dx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, m, q);\n\tVEC(int, a, q);\n\tstd::vector<bool> bb(m, false);\n\tassert(m % 7 == 0);\n\tREP(i, q) {\n\t\tbb[a[i] - 1] = true;\n\t}\n\tstd::vector<int> t(2);\n\tREP(_, 2) {\n\t\tstd::vector<std::vector<bool>> b(m / 7 * (_ + 1), std::vector<bool>(7, false));\n\t\tREP(i, m / 7 * (_ + 1)) REP(j, 7) {\n\t\t\tif (bb[(7 * i + j - 8 + 8*m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tt[_] = calc(b);\n\t}\n\tint x = 7 * n / m;\n\tint d = t[1] - t[0];\n\tOUT(t[0] + (x - 1)*d)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/***********************************************\n#\n#      Filename: c.cpp\n#\n#        Author: Comsyl - ylsong15@fudan.edu.cn\n#   Description: ---\n#        Create: 2017-05-19 23:53:20\n***********************************************/\n#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll n;\nint m, q;\nbool vis[100000 + 10];\nbool bao[1000000 + 10][7];\nbool used[1000000 + 10][7];\n\nvoid paint(int base, int mm) {\n    for (int i = 0; i < mm; ++ i) {\n        if (vis[i % m]) {\n            int r = i / 7;\n            int c = i % 7;\n            bao[r + base][c] = true;\n        }\n    }\n}\n\nint dir[4][2] = {{-1,0}, {0,1}, {1,0}, {0,-1}};\nvoid dfs(int x, int y, int rmax) {\n    used[x][y] = true;\n    for (int i = 0; i < 4; ++ i) {\n        int nx = x + dir[i][0];\n        int ny = y + dir[i][1];\n        if (nx>=0 && nx<rmax && ny>=0 && ny<7 && !used[nx][ny] && !bao[nx][ny]) {\n            dfs(nx, ny, rmax);\n        }\n    }\n}\n\nint main()\n{\n    cin >> n >> m >> q;\n    int r;\n    for (int i = 0; i < q; ++ i) {\n        cin >> r;\n        vis[r] = true;\n    }\n\n    int mm = m;\n    if (m % 7) mm *= 7;\n\n    paint(0, mm);\n    int count1 = 0;\n    for (int i = 0; i < mm/7; ++ i) {\n        for (int j = 0; j < 7; ++ j) {\n            if (!bao[i][j] && !used[i][j]) {\n                dfs(i, j, mm/7);\n                ++ count1;\n            }\n        }\n    }\n\n    paint(mm/7, mm);\n    int count2 = 0;\n    memset(used, false, sizeof(used));\n    for (int i = 0; i < 2*mm/7; ++ i) {\n        for (int j = 0; j < 7; ++ j) {\n            if (!bao[i][j] && !used[i][j]) {\n                dfs(i, j, 2*mm/7);\n                ++ count2;\n            }\n        }\n    }\n\n    cout << count1 * 1L + (count2 - count1) * 1L * (n / (mm/7) - 1L) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a <= x && x < b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\nstd::ostream& operator<<(std::ostream& os, const PAIR& r) {\n\tos << \"(\" << r.first << \", \" << r.second << \")\";\n\treturn os;\n}\n\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nint dy4[] = {0, 1, 0 };\nint dx4[] = {1, 0, -1 };\n\ninline int calc(std::vector<std::vector<bool>>& a) {\n\tint cnt = 0;\n\tint n = a.size();\n\tREP(i, n) {\n\t\tREP(j, 7) {\n\t\t\tif (a[i][j]) continue;\n\t\t\t++cnt;\n\t\t\tstd::queue<PAIR> que;\n\t\t\tque.push(PAIR(i, j));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tPAIR now = que.front(); que.pop();\n\t\t\t\ta[now.first][now.second] = true;\n\t\t\t\tREP(d, 3) {\n\t\t\t\t\tint dy = now.first + dy4[d];\n\t\t\t\t\tint dx = now.second + dx4[d];\n\t\t\t\t\tif (!IN(0, dy, n) || !IN(0, dx, 7)) continue;\n\t\t\t\t\tif (a[dy][dx]) continue;\n\t\t\t\t\tque.push(PAIR(dy, dx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, m, q);\n\tVEC(int, a, q);\n\tstd::vector<bool> bb(m, false);\n\tREP(i, q) {\n\t\tbb[a[i]] = true;\n\t}\n\tif (n <= 200000) {\n\t\tstd::vector<std::vector<bool>> b(n, std::vector<bool>(7, false));\n\t\tREP(i, n) REP(j, 7) {\n\t\t\tif (bb[((7 * (i - 1) + j - 7) % m + m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tOUT(calc(b))BR;\n\t\treturn 0;\n\t}\n\n\tstd::vector<int> t(2);\n\tREP(_, 2) {\n\t\tstd::vector<std::vector<bool>> b(m / 7 * (_ + 1), std::vector<bool>(7, false));\n\t\tREP(i, m / 7 * (_ + 1)) REP(j, 7) {\n\t\t\tif (bb[(7 * (i - 1) + j - 7 + 8 * m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tt[_] = calc(b);\n\t}\n\tint x = 7 * n / m;\n\tint d = t[1] - t[0];\n\tOUT(t[0] + (x - 1)*d)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll N,M,Q;\nint A[101010];\nint col[1500000];\n\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank,cnt;\n\tUF() {par=rank=vector<int>(um,0); cnt=vector<int>(um,1); for(int i=0;i<um;i++) par[i]=i;}\n\tvoid reinit() {int i; FOR(i,um) rank[i]=0,cnt[i]=1,par[i]=i;}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint count(int x) { return cnt[operator[](x)];}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tcnt[y]=cnt[x]=cnt[x]+cnt[y];\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\n\nUF<1407070> uf1,uf2,uftail;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>Q;\n\tFOR(i,Q) {\n\t\tcin>>A[i];\n\t\tfor(j=A[i];j<14*M;j+=M) col[j]=1;\n\t}\n\t\n\tll pat;\n\tint num[3]={};\n\tif(M%7==0) M/=7;\n\t/*\n\t\tFOR(i,M) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uf1(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<M) && col[i+7]==0) uf1(i,i+7);\n\t\t}\n\t\tFOR(i,2*M) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uf2(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<2*M) && col[i+7]==0) uf2(i,i+7);\n\t\t}\n\t\tFOR(i,M) if(col[i]==0 && uf1[i]==i) num[0]++;\n\t\tFOR(i,2*M) if(col[i]==0 && uf2[i]==i) num[1]++;\n\t\tpat=7*N/M;\n\t}\n\telse {\n\t*/\n\t\tFOR(i,7*M) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uf1(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<7*M) && col[i+7]==0) uf1(i,i+7);\n\t\t}\n\t\tFOR(i,14*M) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uf2(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<14*M) && col[i+7]==0) uf2(i,i+7);\n\t\t}\n\t\tFOR(i,7*M) if(col[i]==0 && uf1[i]==i) num[0]++;\n\t\tFOR(i,14*M) if(col[i]==0 && uf2[i]==i) num[1]++;\n\t\tpat=N/M;\n\t//}\n\tcout<<num[0]+(pat-1)*(num[1]-num[0])<<endl;\n\t\n}\n\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  for(int i=0;i<(n);++i)\n#define REPr(i,n) for(int i=(n)-1;i>=0; --i)\n#define FORq(i, m, n) for(int i = (m);i <= (n);++i)\n#define rFORq(i, m , n) for(int i = (n);i >=(m);--i)\n#define SCD(n) scanf(\"%d\",&n)\n#define SCD2(m,n) scanf(\"%d%d\",&m,&n)\n#define SCD3(m,n,k) scanf(\"%d%d%d\",&m,&n,&k)\n#define SCLLD(n) scanf(\"%lld\",&n)\n#define SCLLD2(m,n) scanf(\"%lld%lld\",&m,&n)\n#define SCLLD3(m,n,k) scanf(\"%lld%lld%lld\",&m,&n,&k)\n#define PB push_back\n#define MP make_pair\n#define ARSCD(A,N) REP(i,N){SCD(A[i]);}\n#define ARSCD1(A,N) FORq(i,1,N){SCD(A[i]);}\n#define VSCD(v,N) REP(i,N){int x; SCD(x); v.PB(x);}\n#define VSCLLD(v,N) REP(i,N){long long x; SCLLD(x); v.PB(x);}\n#define PRINTD(n) printf(\"%d\\n\",n)\n#define PRINTLLD(n) printf(\"%lld\\n\",n)\n#define DEBUG printf(\"%s\\n\",\"debug\")\n#define fst first\n#define snd second\n#define SIN(x,S) (S.count(x) != 0)\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector < VI > VVI;\ntypedef vector<long long> VL;\ntypedef long long ll;\ntypedef long long integer;\n////////////////////////////////////////////////////////////////////\nconst ll p = 1000000007;\nll dx[4] = {-7,-1,1,7};\nll N,M,Q;\nstatic ll a[100002] = {};\nstatic bool grid[700003] = {};\nstatic bool visited[1500003] = {};\nstatic bool visited2[1500003] = {};\n\nvoid dfs0(ll pos){\n    if (visited[pos]) return;\n    visited[pos] = true;\n\n    REP(k,4){\n        ll next = pos + dx[k];\n        if (next >= 7*N) continue;\n        if (next < 0) continue;\n        if ((k==1) and (pos % 7 == 0)) continue;\n        if ((k==2) and (pos % 7 == 6)) continue;\n        if (grid[next]) continue;\n        if (visited[next]) continue;\n        dfs0(next);\n    }\n\n    return;\n}\n\nvoid dfs1(ll pos){\n    if (visited[pos]) return;\n    visited[pos] = true;\n\n    REP(k,4){\n        ll next = pos + dx[k];\n        if (next >= M) continue;\n        if (next < 0) continue;\n        if ((k==1) and (pos % 7 == 0)) continue;\n        if ((k==2) and (pos % 7 == 6)) continue;\n        if (grid[next]) continue;\n        if (visited[next]) continue;\n        dfs1(next);\n    }\n\n    return;\n}\n\nvoid dfs2(ll pos){\n    if (visited2[pos]) return;\n    visited2[pos] = true;\n\n    REP(k,4){\n        ll next = pos + dx[k];\n        if (next >= 2*M) continue;\n        if (next < 0) continue;\n        if ((k==1) and (pos % 7 == 0)) continue;\n        if ((k==2) and (pos % 7 == 6)) continue;\n        if (grid[next]) continue;\n        if (visited2[next]) continue;\n        dfs2(next);\n    }\n\n    return;\n}\n\nvoid dfs3(ll pos){\n    if (visited[pos]) return;\n    visited[pos] = true;\n\n    REP(k,4){\n        ll next = pos + dx[k];\n        if (next >= 7*M) continue;\n        if (next < 0) continue;\n        if ((k==1) and (pos % 7 == 0)) continue;\n        if ((k==2) and (pos % 7 == 6)) continue;\n        if (grid[next]) continue;\n        if (visited[next]) continue;\n        dfs3(next);\n    }\n\n    return;\n}\nvoid dfs4(ll pos){\n    if (visited2[pos]) return;\n    visited2[pos] = true;\n\n    REP(k,4){\n        ll next = pos + dx[k];\n        if (next >= 14*M) continue;\n        if (next < 0) continue;\n        if ((k==1) and (pos % 7 == 0)) continue;\n        if ((k==2) and (pos % 7 == 6)) continue;\n        if (grid[next % M]) continue;\n        if (visited2[next]) continue;\n        dfs4(next);\n    }\n\n    return;\n}\n\nvoid solve1(){\n    ll count = 0;\n    FORq(i,0,7*N-1){\n        if ((grid[i] == false) and (visited[i] == false)){\n            dfs0(i);\n            count++;\n        }\n    }\n\n    PRINTLLD(count);\n    return;\n}\n\n\nvoid solve23(){\n    ll count1 = 0;\n    ll count2 = 0;\n\n    FORq(i,0,M-1){\n        if ((grid[i] == false) and (visited[i] == false)){\n            dfs1(i);\n            count1++;\n        }\n    }\n    //printf(\"count1 = %lld\\n\",count1);\n\n    FORq(i,0,2*M-1){\n        if ((grid[i] == false) and (visited2[i] == false)){\n            dfs2(i);\n            count2++;\n        }\n    }\n\n    //printf(\"count2 = %lld\\n\",count2);\n    ll A,B;\n    A = count2 - count1;\n    B = count1 - A;\n    ll c = 7*N / M;\n    PRINTLLD(A*c + B);\n    return;\n}\n\nvoid solve4(){\n    ll count1 = 0;\n    ll count2 = 0;\n    FORq(i,0,7*M-1){\n        if ((grid[i] == false) and (visited[i] == false)){\n            dfs3(i);\n            count1++;\n        }\n    }\n    //printf(\"count1 = %lld\\n\",count1);\n\n    FORq(i,0,14*M-1){\n        if ((grid[i % M] == false) and (visited2[i] == false)){\n            dfs4(i);\n            count2++;\n        }\n    }\n\n    ll A,B; A = count2 - count1;\n    B = count1 - A;\n    ll x = N/M;\n    PRINTLLD(A*x + B);\n}\n\n\nint main(){\n    SCLLD3(N,M,Q);\n    ARSCD(a,Q);\n\n    REP(q,Q){\n        ll ai = a[q];\n        ll k = 0;\n        while(k*M + ai <= 700000 + 2 ){\n            grid[k*M+ai] = true;\n            k++;\n        }\n    }\n\n    if (N <= 100000){ // #1\n        solve1();\n    } else if (M % 7 == 0){\n        solve23();\n    } else {\n        solve4();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a <= x && x < b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\nstd::ostream& operator<<(std::ostream& os, const PAIR& r) {\n\tos << \"(\" << r.first << \", \" << r.second << \")\";\n\treturn os;\n}\n\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nint dy4[] = {0, 1, 0 };\nint dx4[] = {1, 0, -1 };\n\ninline int calc(std::vector<std::vector<bool>>& a) {\n\tint cnt = 0;\n\tint n = a.size();\n\tREP(i, n) {\n\t\tREP(j, 7) {\n\t\t\tif (a[i][j]) continue;\n\t\t\t++cnt;\n\t\t\tstd::queue<PAIR> que;\n\t\t\tque.push(PAIR(i, j));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tPAIR now = que.front(); que.pop();\n\t\t\t\ta[now.first][now.second] = true;\n\t\t\t\tREP(d, 3) {\n\t\t\t\t\tint dy = now.first + dy4[d];\n\t\t\t\t\tint dx = now.second + dx4[d];\n\t\t\t\t\tif (!IN(0, dy, n) || !IN(0, dx, 7)) continue;\n\t\t\t\t\tif (a[dy][dx]) continue;\n\t\t\t\t\tque.push(PAIR(dy, dx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, m, q);\n\tVEC(int, a, q);\n\tstd::vector<bool> bb(m, false);\n\tREP(i, q) {\n\t\tbb[a[i]] = true;\n\t}\n\t\tstd::vector<std::vector<bool>> b(n, std::vector<bool>(7, false));\n\t\tREP(i, n) REP(j, 7) {\n\t\t\tif (bb[((7 * (i - 1) + j - 7) % m + m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tOUT(calc(b))BR;\n\t\treturn 0;\n\n\tstd::vector<int> t(2);\n\tREP(_, 2) {\n\t\tstd::vector<std::vector<bool>> b(m / 7 * (_ + 1), std::vector<bool>(7, false));\n\t\tREP(i, m / 7 * (_ + 1)) REP(j, 7) {\n\t\t\tif (bb[(7 * (i - 1) + j - 7 + 8 * m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tt[_] = calc(b);\n\t}\n\tint x = 7 * n / m;\n\tint d = t[1] - t[0];\n\tOUT(t[0] + (x - 1)*d)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nlong n;int m,q,a[1<<17];\nbool f[7][1<<17];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid bfs(int x,int y,long _n)\n{\n\tqueue<pair<int,int> >P;\n\tf[x][y]=true;\n\tP.push(make_pair(x,y));\n\twhile(!P.empty())\n\t{\n\t\tpair<int,int>p=P.front();P.pop();\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint tx=p.first+dx[r],ty=p.second+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=7||ty>=_n||f[tx][ty])continue;\n\t\t\tf[tx][ty]=true;\n\t\t\tP.push(make_pair(tx,ty));\n\t\t}\n\t}\n}\nmain()\n{\n\tcin>>n>>m>>q;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tif(n<=100000)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong ans=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t\tbfs(i,j,n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\telse if(m%7==0)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,m/7*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,m/7*3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=count2-count1;\n\t\tlong syokou=count1-kousa*2;\n\t\tcout<<syokou+kousa*(n/(m/7))<<endl;\n\t}\n\telse\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<2*m;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<2*m;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,2*m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=(count2-count1)/7;s\n\t\tlong syokou=count1-kousa*7;\n\t\tcout<<syokou+kousa*n<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nconst int INF = 1e9,MOD = 1e9+7,ohara = 1e6;\nconst ll LINF = 1e18;\nusing namespace std;\n\n#define rep(i,n) for(ll (i)=0;(i)<(int)(n);(i)++)\n#define rrep(i,a,b) for(ll i=(a);i<(b);i++)\n#define rrrep(i,a,b) for(ll i=(a);i>=(b);i--)\n#define all(v) (v).begin(), (v).end()\n#define pb(q) push_back(q)\n#define Size(n) (n).size()\n#define Cout(x) cout<<(x)<<endl\n\nll n,cnt=0,ans=0,a[ohara],b,c,d,cmp,cmpp,m,h,w,x,y,sum=0,pos,q,grid[ohara][10];\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\n//int dy[]={-1,0,1,-1,1,-1,0,1};\n//int dx[]={-1,-1,-1,0,0,1,1,1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"),s;\nbool fl,mem[ohara][10];\nstruct edge{int to,cost;};\n\n//-------------------------↓↓↓↓↓↓------------------------\n\nvoid dfs1(ll i,ll j){\n    mem[i][j]=true;\n    rep(k,4){\n        int nx=j+dx[k],ny=i+dy[k];\n        if(nx>=0&&nx<7&&ny>=0&&ny<n&&!mem[ny][nx]&&!grid[ny][nx]){\n            dfs1(ny,nx);\n        }\n    }\n}\n\nll solve1(){\n    ll ret=0;\n    map<ll,ll> out;\n    rep(i,q)out[a[i]]=1;\n    rep(i,n){\n        rep(j,7){\n            pos=7*i+j;\n            if(out[pos%m]==1){\n                grid[i][j]=1;\n            }\n        }\n    }\n    rep(i,n){\n        rep(j,7){\n            if(!mem[i][j]&&!grid[i][j]){\n                ret++;\n                dfs1(i,j);\n                //cout<<i<<\" \"<<j<<\"\\n\";\n            }\n        }\n    }\n    return ret;\n}\n\nint main(void){\n       cin.tie(0);\n    ios::sync_with_stdio(false);\n      \n    cin>>n>>m>>q;\n    rep(i,q)cin>>a[i];\n    if(n<=100000)ans=solve1();\n    Cout(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <sstream>\n# include <cstdio>\n# include <cstdlib>\n# include <algorithm>\n# include <string>\n# include <cstring>\n# include <cmath>\n# include <stack>\n# include <queue>\n# include <vector>\n# include <list>\n# include <map>\n# include <set>\n# include <deque>\n# include <iterator>\n# include <functional>\n# include <bitset>\n# include <climits>\n# include <ctime>\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define odd(x) ((x)%2)\ntypedef long long ll;\ntypedef long double ld;\nconst ll oo=2*1000*1000*1000;\nconst int _cnt=1000*1000;\nconst int _p=1000*1000*1000+7;\nint o(int x) { return x%_p; }\nint gcd(int a,int b) { return (b)?gcd(b,a%b):a; }\nint lcm(int a,int b) { return a/gcd(a,b)*b; }\nusing namespace std;\n\nvoid file_put(){\n\tfreopen(\"filename.in\",\"r\",stdin);\n\tfreopen(\"filename.out\",\"w\",stdout);\n}\n\nint n,m,q,a[15],x,ans=0;\n\nint main(){\n\t//file_put();\n\t\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tm=7;\n\tfor (int i=1; i<=q; i++) {\n\t\tscanf(\"%d\",&x);\n\t\tx%=m;\n\t\ta[x]=1;\n\t}\n\ta[7]=1;\n\tfor (int i=1; i<=7; i++) ans+=(a[i]>0 && a[i-1]==0);\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nlong n;int m,q,a[1<<17];\nbool f[7][1<<17];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid bfs(int x,int y,long _n)\n{\n\tqueue<pair<int,int> >P;\n\tf[x][y]=true;\n\tP.push(make_pair(x,y));\n\twhile(!P.empty())\n\t{\n\t\tpair<int,int>p=P.front();P.pop();\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint tx=p.first+dx[r],ty=p.second+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=7||ty>=_n||f[tx][ty])continue;\n\t\t\tf[tx][ty]=true;\n\t\t\tP.push(make_pair(tx,ty));\n\t\t}\n\t}\n}\nmain()\n{\n\tcin>>n>>m>>q;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tif(n<=100000)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong ans=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t\tbfs(i,j,n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\telse if(m%7==0)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,m/7*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,m/7*3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=count2-count1;\n\t\tlong syokou=count1-kousa*2;\n\t\tcout<<syokou+kousa*(n/(m/7))<<endl;\n\t}\n\telse\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<7*m;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<7*m;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,7*m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<14*m;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<14*m;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,14*m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=(count2-count1)/7;\n\t\tlong syokou=count1-kousa*7;\n\t\tcout<<syokou+kousa*(7*n)/m<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a <= x && x < b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\nstd::ostream& operator<<(std::ostream& os, const PAIR& r) {\n\tos << \"(\" << r.first << \", \" << r.second << \")\";\n\treturn os;\n}\n\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nint dy4[] = {0, 1, 0 };\nint dx4[] = {1, 0, -1 };\n\ninline int calc(std::vector<std::vector<bool>>& a) {\n\tint cnt = 0;\n\tint n = a.size();\n\tREP(i, n) {\n\t\tREP(j, 7) {\n\t\t\tif (a[i][j]) continue;\n\t\t\t++cnt;\n\t\t\tstd::queue<PAIR> que;\n\t\t\tque.push(PAIR(i, j));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tPAIR now = que.front(); que.pop();\n\t\t\t\ta[now.first][now.second] = true;\n\t\t\t\tREP(d, 3) {\n\t\t\t\t\tint dy = now.first + dy4[d];\n\t\t\t\t\tint dx = now.second + dx4[d];\n\t\t\t\t\tif (!IN(0, dy, a.size()) || !IN(0, dx, 7)) continue;\n\t\t\t\t\tif (a[dy][dx]) continue;\n\t\t\t\t\tque.push(PAIR(dy, dx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, m, q);\n\tVEC(int, a, q);\n\tstd::vector<bool> bb(m, false);\n\tREP(i, q) {\n\t\tbb[a[i]] = true;\n\t}\n\tif (n <= 200000) {\n\t\tstd::vector<std::vector<bool>> b(n, std::vector<bool>(7, false));\n\t\tREP(i, n) REP(j, 7) {\n\t\t\tif (bb[((7 * (i - 1) + j - 7) % m + m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tOUT(calc(b))BR;\n\t\treturn 0;\n\t}\n\n\tstd::vector<int> t(2);\n\tREP(_, 2) {\n\t\tstd::vector<std::vector<bool>> b(m / 7 * (_ + 1), std::vector<bool>(7, false));\n\t\tREP(i, m / 7 * (_ + 1)) REP(j, 7) {\n\t\t\tif (bb[(7 * (i - 1) + j - 7 + 8 * m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tt[_] = calc(b);\n\t}\n\tint x = 7 * n / m;\n\tint d = t[1] - t[0];\n\tOUT(t[0] + (x - 1)*d)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint d[]={1,-1,7,-7};\n\nint N,M,Q;\nbool f[700000*2];\n\nint a[111111];\n\nint calc(int m){\n    memset(f,0,sizeof(f));\n    for(int i=0;i<Q;i++){\n        for(int j=a[i];j<m;j+=M)f[j]=true;\n    }\n\n    UnionFindTree uf(m);\n\n    rep(i,m){\n        rep(j,4){\n            if(i%7==0&&d[j]==-1)continue;\n            if(i%7==6&&d[j]==1)continue;\n            int nx=i+d[j];\n            if(nx<0||nx>=m)continue;\n            if(f[i]||f[nx])continue;\n            uf.unite(i,nx);\n        }\n    }\n    int res=0;\n    rep(i,m)if(!f[i]&&uf.find(i)==i)res++;\n    return res;\n}\n\nsigned main(){\n    cin>>N>>M>>Q;\n    rep(i,Q){\n        cin>>a[i];\n    }\n\n    int x=calc(M);\n    int y=calc(2*M);\n    cout<<x+(y-x)*(N*7/M-1)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n// #define DEBUG\n#ifdef DEBUG\n#define dump(...) cerr<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<make_tuple(__VA_ARGS__)<<\"\\n\";\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '{'; for(int i = 0; i < (int) v.size(); i++) o << v[i] << (i != (int)v.size()-1 ? \", \" : \"\"); o << \"}\";  return o; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\n#else\n#define dump(...)\n#endif\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  ll n, m, q; cin >> n >> m >> q;\n  ll h = (m + 6) / 7; // one shared block\n  ll period = h * 7 - (7 - m % 7) % 7; // height of period\n  ll full = n / period;\n  ll rest = n - full * period;\n  vector< vector<int> > f(period, vector<int>(7) );\n  auto used = f;\n  auto used2 = f;\n  auto used3 = f;\n\n  while(q--) {\n    ll a; cin >> a;\n    for(; a < period * 7; a += m) {\n      ll y = a / 7, x = a % 7;\n      f[y][x] = 1;\n    }\n  }\n  dump(f);\n\n  ll block = 0;\n  for(ll y = 0; y < period; y++)\n    for(ll x = 0; x < 7; x++) {\n      if(f[y][x]) continue;\n      if(used[y][x]) continue;\n      used[y][x] = 1;\n      queue<pair<ll, ll>> q;\n      q.emplace(y, x);\n      block++;\n      while(q.size()) {\n        ll yy = q.front().first, xx = q.front().second;\n        q.pop();\n        for(int d = 0; d < 4; d++) {\n          ll ny = yy + dy[d];\n          ll nx = xx + dx[d];\n          if(ny < 0 || period <= ny || nx < 0 || 7 <= nx) continue;\n          if(f[ny][nx]) continue;\n          if(used[ny][nx]) continue;\n          used[ny][nx] = 1;\n          q.emplace(ny, nx);\n        }\n      }\n    }\n\n  ll black = 0;\n  {\n    ll y = period - 1;\n    for(ll x = 0; x < 7; x++) {\n      if(f[y][x]) continue;\n      if(used2[y][x]) continue;\n      if(f[0][x]) continue;\n      used2[y][x] = 1;\n      queue<pair<ll, ll>> q;\n      q.emplace(y, x);\n      black++;\n      while(q.size()) {\n        ll yy = q.front().first, xx = q.front().second;\n        q.pop();\n        for(int d = 0; d < 4; d++) {\n          ll ny = yy + dy[d];\n          ll nx = xx + dx[d];\n          if(ny < 0 || period <= ny || nx < 0 || 7 <= nx) continue;\n          if(f[ny][nx]) continue;\n          if(used2[ny][nx]) continue;\n          used2[ny][nx] = 1;\n          q.emplace(ny, nx);\n        }\n      }\n    }\n  }\n\n  ll last = 0;\n  for(ll y = 0; y < rest; y++)\n    for(ll x = 0; x < 7; x++) {\n      if(f[y][x]) continue;\n      if(used3[y][x]) continue;\n      used3[y][x] = 1;\n      queue<pair<ll, ll>> q;\n      q.emplace(y, x);\n      last++;\n      while(q.size()) {\n        ll yy = q.front().first, xx = q.front().second;\n        q.pop();\n        for(int d = 0; d < 4; d++) {\n          ll ny = yy + dy[d];\n          ll nx = xx + dx[d];\n          if(ny < 0 || rest <= ny || nx < 0 || 7 <= nx) continue;\n          if(f[ny][nx]) continue;\n          if(used3[ny][nx]) continue;\n          used3[ny][nx] = 1;\n          q.emplace(ny, nx);\n        }\n      }\n    }\n  dump(full);\n  dump(block, black, last);\n\n  ll ans = 0;\n  ans += full * (block - black);\n  if(rest) {\n    ans += last;\n  } else {\n    ans += black;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace {\n    using ull = unsigned long long;\n    using ll = long long;\n    #define endl \"\\n\"\n\n    #define REP(i, n) for (ll i = 0; i < n; i++)\n    #define REPR(i, n) for (ll i = n; i >= 0; i--)\n    #define FOR(i, m, n) for (ll i = m; i < n; i++)\n    #define even(x) (x) % 2 == 0\n    #define odd(x) (x) % 2 != 0\n    #define all(x) x.begin(), x.end()\n    #define rall(x) x.rbegin(), x.rend()\n    #define pcnt __builtin_popcount\n    #define buli(x) __builtin_popcountll(x)\n    #define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n    #define inp(t, x) t x;cin>>x;\n    #define ithBit(n, i) ((n)>>(i) & 1)\n    #define INIT() cin.tie(0);ios::sync_with_stdio(0);cout<<fixed<<setprecision(20)\n\n    // these functions return the position of result of Binary Search.\n    #define LB(s, t, x) (int)(lower_bound(s, t, x) - s)\n    #define UB(s, t, x) (int)(upper_bound(s, t, x) - s)\n\n    #define M_PI 3.14159265358979323846\n    ll qp(ll a, ll b, int mo)\n    {\n        ll ans = 1;\n        do\n        {\n            if (b & 1)\n                ans = 1ll * ans * a % mo;\n            a = 1ll * a * a % mo;\n        } while (b >>= 1);\n        return ans;\n    }\n    ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\n    ll lcm(ll a, ll b)\n    {\n        ll temp = gcd(a, b);\n        return temp ? (a / temp * b) : 0;\n    }\n    int mDays[] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n    int dx8[] = {1, -1, 0, 0, 1, 1, -1, -1}, dy8[] = {0, 0, -1, 1, -1, 1, -1, 1};\n\n    template <typename F>\n    class\n    #if defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n        [[nodiscard]]\n    #elif defined(__GNUC__) && __GNUC_PREREQ(3, 4)\n        __attribute__((warn_unused_result))\n    #endif // defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n        FixPoint : F {\n            public :\n                explicit constexpr FixPoint(F &&f) noexcept : F(std::forward<F>(f)) {}\n\n            template <typename... Args>\n            constexpr decltype(auto)\n            operator()(Args &&... args) const {\n                return F::operator()(*this, std::forward<Args>(args)...);\n    } // namespace\n    }\n    ; // class FixPoint\n    template <typename F>\n    static inline constexpr decltype(auto)\n    makeFixPoint(F &&f) noexcept\n    {\n        return FixPoint<F>{std::forward<F>(f)};\n    }\n\n    template <typename T>\n    vector<T> make_v(size_t a) { return vector<T>(a); }\n    template <typename T, typename... Ts>\n    auto make_v(size_t a, size_t b, Ts... ts) { return vector<decltype(make_v<T>(b, ts...))>(a, make_v<T>(b, ts...)); }\n    template <typename T, typename V>\n    typename enable_if<is_class<T>::value == 0>::type\n    fill_v(T &t, const V &v) { t = v; }\n    template <typename T, typename V>\n    typename enable_if<is_class<T>::value != 0>::type\n    fill_v(T &t, const V &v) { for (auto &e : t) fill_v(e, v); }\n\n    template <class T>\n    bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\n    template <class T>\n    bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n\n    inline bool rangeCheck2D(int nx, int ny, int Width, int Height) { return nx >= 0 and nx < Width and ny >= 0 and ny < Height; }\n    \n    ll i_query(ll x)\n    {\n        cout << \"> \" << x << endl;\n        fflush(stdout);\n        ll ret;\n        cin >> ret;\n        return ret;\n    }\n    ll i_query_2(ll i)\n    {\n        cout << \"? \" << i << endl;\n        fflush(stdout);\n        ll ret;\n        cin >> ret;\n        return ret;\n    }\n    void i_answer(ll ans, ll d)\n    {\n        cout << \"! \" << ans << \" \" << d << endl;\n        fflush(stdout);\n    }\n} // namespace\n\nnamespace {\n    #define DUMPOUT cerr \n    #ifndef DEBUG_\n    #define dump(...)\n    #else\n    #define dump(...) DUMPOUT<<\"  \"; \\\n    DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl; \\\n    DUMPOUT<<\"    \"; \\\n    dump_func(__VA_ARGS__)\n    #endif \n    void dump_func() { DUMPOUT << endl; }\n    template <class Head, class... Tail>\n    void dump_func(Head&& head, Tail&&... tail)\n    {\n        DUMPOUT << head;\n        if (sizeof...(Tail) == 0) {\n            DUMPOUT << \" \";\n        }\n        else {\n            DUMPOUT << \", \";\n        }\n        dump_func(std::move(tail)...);\n    }\n    template <class T>\n    ostream &operator<<(ostream &os, const vector<T> &v)\n    {\n        for (auto i = begin(v); i != end(v); ++i)\n            os << *i << (i == end(v) - 1 ? \"\" : \" \");\n        return os;\n    }\n    template <class T>\n    void out2Dvector(vector<T> v) {\n        for (const auto& vv : v)\n            cout << vv << endl;\n    }\n    template <class T>\n    istream &operator>>(istream &is, vector<T> &v)\n    {\n        for (auto i = begin(v); i != end(v); ++i)\n            is >> *i;\n        return is;\n    }\n    template<typename T, typename U>\n    ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n        os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n        return os;\n    }\n    template<typename T, typename U>\n    ostream& operator << (ostream& os, map<T, U>& map_var) {\n        os << \"{\";\n        for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n            os << \"(\" << itr->first << \", \" << itr->second << \")\";\n            itr++;\n            if(itr != map_var.end()) os << \", \";\n            itr--;\n        }\n        os << \"}\";\n        return os;\n    }\n    template<typename T>\n    ostream& operator << (ostream& os, set<T>& set_var) {\n        os << \"{\";\n        for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n            os << *itr;\n            ++itr;\n            if(itr != set_var.end()) os << \", \";\n            itr--;\n        }\n        os << \"}\";\n        return os;\n    }\n}\n\n/*\n    lambda expression\n    auto f = [](int arg1, double arg2) { return ret; };\n    lambda recursion\n    auto result = makeFixPoint([&](auto rec, int pos, int v) -> int {\n        rec(pos, v);\n    })(0, 1);\n    auto func = makeFixPoint([]() -> int {});\n    int ret = func();\n\n    tuple binding\n    auto [x, y] = make_tuple(0, 0);\n    for pair\n    auto [a, b] = pair<int, int>({v1, v2});\n\n    bitset<N> bs(ini_val); // N must be constant\n    bs.reset(); // reset all\n*/\n\n\nint main(void)\n{\n    INIT(); // comment out for Interective Program\n\n    inp(ll, N); inp(ll, M); inp(ll, Q);\n    vector<ll> a(Q); cin >> a;\n\n    ll h = lcm(7, M) / 7 * 2;\n    auto f = make_v<char>(h, 7);\n    fill_v(f, 0);\n\n    REP(q, Q) {\n        REP(i, h) {\n            REP(j, 7) {\n                ll idx = 7 * i + j;\n                if (idx % M == a[q])\n                    f[i][j] = 1;\n            }\n        }\n    }\n\n    auto func = [&](int h) {\n        ll cnt = 0;\n        auto visited = make_v<char>(h, 7);\n        fill_v(visited, 0);\n        REP(i, h) {\n            REP(j, 7) {\n                if (visited[i][j]) continue;\n                if (f[i][j] == 1) continue;\n                cnt++;\n                queue<pair<int, int>> q;\n                q.push({i, j});\n                while (q.size()) {\n                    int y = q.front().first, x = q.front().second; q.pop();\n                    visited[y][x] = 1;\n                    REP(k, 4) {\n                        int ny = y + dy[k], nx = x + dx[k];\n                        if (not rangeCheck2D(nx, ny, 7, h)) continue;\n                        if (visited[ny][nx]) continue;\n                        if (f[ny][nx] == 1) continue;\n                        q.push({ny, nx});\n                    }\n                }\n            }\n        }\n        return cnt;\n    };\n\n    ll aa = func(h / 2);\n    ll d = func(h) - aa;\n    ll k = N / (lcm(7, M) / 7);\n    cout << aa + d * (k - 1) << endl;\n\n    return 0;\n}\n//*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\n\nconst int M_N=400001;\n\nstruct UnionFind{\n    int par[M_N];\n    int rank[M_N];\n\n    void init(int n){\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            rank[i]=0;\n        }\n    }\n\n    int find(int x){\n        if(par[x]==x){\n            return x;\n        }\n        else{\n            return par[x]=find(par[x]);\n        }\n    }\n\n    void unite(int x,int y){\n        x=find(x);\n        y=find(y);\n        if(x==y) return;\n        if(rank[x]<rank[y]){\n            par[x]=y;\n        }\n        else{\n            par[y]=x;\n            if(rank[x]==rank[y]) rank[x]++;\n        }\n    }\n\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n};\n\n\nint main(){\n    LL n,m,q;cin >> n >> m >> q;\n    vector<int> a(q);\n    for (int i = 0; i < q; i++) {\n        cin >> a[i];\n    }\n    LL t = 7 * n / m;\n    vector<vector<int>> v(m, vector<int> (7,0));\n    vector<vector<int>> vv(2 * m, vector<int> (7,0));\n    vector<vector<int>> va(m/7, vector<int> (7,0));\n    vector<vector<int>> vb(2*m/7, vector<int> (7,0));\n    for (int i = 0; i < q; i++) {\n        int y = a[i] / 7, x = a[i] % 7;\n        if(m % 7 == 0){\n            va[y][x] = 1;\n            vb[y][x] = 1;\n            vb[m / 7 + y][x] = 1;\n        }\n        else{\n            for (int j = 0; j < 7; j++) {\n                y = (a[i] * j) / 7, x = (a[i] * j) % 7;\n                v[y][x] = 1;\n                vv[y][x] = 1;\n                vv[y+m][x] = 1;\n            }\n        }\n    }\n    auto f = [](vector<vector<int>> &a){\n        int h = a.size(), w = a[0].size();\n        UnionFind uf;\n        uf.init(h*w);\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if(j+1<w && a[i][j] == a[i][j+1]) uf.unite(i*7+j,i*7+j+1);\n                if(i+1<h && a[i][j] == a[i+1][j]) uf.unite(i*7+j,(i+1)*7+j);\n            }\n        }\n        int ret = 0;\n        for (int i = 0; i < h*w; i++) {\n            if(uf.find(i) == i && a[i/7][i%7] == 0) ret++;\n        }\n        return ret;\n    };\n    if(m%7==0){\n        if(t == 1){\n            cout << f(va) << endl;\n        }\n        else if(t == 2){\n            cout << f(vb) << endl;\n        }\n        else{\n            cout << f(va) + (t - 1) * (f(vb) - f(va)) << endl;\n        }\n    }\n    else{\n        t = n / (7 * m);\n        if(t == 1){\n            cout << f(v) << endl;\n        }\n        else if(t == 2){\n            cout << f(vv) << endl;\n        }\n        else{\n            cout << f(v) + (t - 1) * (f(vv) - f(v)) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\n\nconst int M_N=400001;\n\nstruct UnionFind{\n    int par[M_N];\n    int rank[M_N];\n\n    void init(int n){\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            rank[i]=0;\n        }\n    }\n\n    int find(int x){\n        if(par[x]==x){\n            return x;\n        }\n        else{\n            return par[x]=find(par[x]);\n        }\n    }\n\n    void unite(int x,int y){\n        x=find(x);\n        y=find(y);\n        if(x==y) return;\n        if(rank[x]<rank[y]){\n            par[x]=y;\n        }\n        else{\n            par[y]=x;\n            if(rank[x]==rank[y]) rank[x]++;\n        }\n    }\n\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n};\n\n\nint main(){\n    LL n,m,q;cin >> n >> m >> q;\n    vector<int> a(q);\n    for (int i = 0; i < q; i++) {\n        cin >> a[i];\n    }\n    LL t = 7 * n / m;\n    vector<vector<int>> v(m, vector<int> (7,0));\n    vector<vector<int>> vv(2 * m, vector<int> (7,0));\n    vector<vector<int>> va(m/7, vector<int> (7,0));\n    vector<vector<int>> vb(2*m/7, vector<int> (7,0));\n    for (int i = 0; i < q; i++) {\n        int y = a[i] / 7, x = a[i] % 7;\n        va[y][x] = 1;\n        vb[y][x] = 1;\n        vb[m / 7 + y][x] = 1;\n        for (int j = 0; j < 7; j++) {\n            y = (a[i] * j) / 7, x = (a[i] * j) % 7;\n            v[y][x] = 1;\n            vv[y][x] = 1;\n            vv[y+m][x] = 1;\n        }\n    }\n    auto f = [](vector<vector<int>> &a){\n        int h = a.size(), w = a[0].size();\n        UnionFind uf;\n        uf.init(h*w);\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if(j+1<w && a[i][j] == a[i][j+1]) uf.unite(i*7+j,i*7+j+1);\n                if(i+1<h && a[i][j] == a[i+1][j]) uf.unite(i*7+j,(i+1)*7+j);\n            }\n        }\n        int ret = 0;\n        for (int i = 0; i < h*w; i++) {\n            if(uf.find(i) == i && a[i/7][i%7] == 0) ret++;\n        }\n        return ret;\n    };\n    if(m%7==0){\n        if(t == 1){\n            cout << f(va) << endl;\n        }\n        else if(t == 2){\n            cout << f(vb) << endl;\n        }\n        else{\n            cout << f(va) + (t - 1) * (f(vb) - f(va)) << endl;\n        }\n    }\n    else{\n        t = n / (7 * m);\n        if(t == 1){\n            cout << f(v) << endl;\n        }\n        else if(t == 2){\n            cout << f(vv) << endl;\n        }\n        else{\n            cout << f(v) + (t - 1) * (f(vv) - f(v)) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define put(x) cout << x;\n#define putsp(x) cout << x << ' ';\n#define putln(x) cout << x << endl;\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\ntypedef long long ll;\ntypedef pair<ll, ll> llP;\ntypedef pair<int, int> intP;\ntypedef complex<double> comp;\ntypedef vector <int> vec;\ntypedef vector <ll> vecll;\ntypedef vector <double> vecd;\ntypedef vector <vec> mat;\ntypedef vector <vecll> matll;\ntypedef vector <vecd> matd;\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nconst int MAX = 100010;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = 1<<29;\nconst ll INFL = 1e18;\nconst ll MOD = 1000000007;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint dx8[8]={1,0,-1,1,-1,1,0,-1};\nint dy8[8]={1,1,1,0,0,-1,-1,-1};\n\n//********************************template END****************************************//\n\nvoid dfs(int x, int y, mat& m)\n{\n\tm[y][x] = 1;\n\trep(4, d)\n\t{\n\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\tif (0 <= ny && ny < (int)m.size() && 0 <= nx && nx < 7)\n\t\t{\n\t\t\tif (m[ny][nx] == 0)\n\t\t\t{\n\t\t\t\tdfs(nx, ny, m);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(void){\n\n\tll N, M, Q;\n\tcin >> N >> M >> Q;\n\n\tvec qs(Q);\n\n\trep(Q, i)\n\t{\n\t\tcin >> qs[i];\n\t}\n\n\tif (M % 7)\n\t{\n\t\t//0 -> white, 1 -> black\n\t\tmat maze(M, vec (7, 0)), dmaze(M*2, vec(7, 0));\n\n\t\trep(Q, i) rep(7, j)\n\t\t{\n\t\t\tint x = qs[i] + M*j;\n\t\t\tint h = x / 7, w = x % 7;\n\t\t\tdmaze[h][w] = maze[h][w] = 1;\n\t\t\tx += 7*M;\n\t\t\th = x / 7, w = x % 7;\n\t\t\tdmaze[h][w] = 1;\n\t\t}\n\n\t\tll a = 0, b = 0, k = N/M;\n\n\t\trep(M, i) rep(7, j)\n\t\t{\n\t\t\tif (maze[i][j] == 0)\n\t\t\t{\n\t\t\t\ta++;\n\t\t\t\tdfs(j, i, maze);\n\t\t\t}\n\t\t}\n\n\t\trep(2*M, i) rep(7, j)\n\t\t{\n\t\t\tif (dmaze[i][j] == 0)\n\t\t\t{\n\t\t\t\tb++;\n\t\t\t\tdfs(j, i, dmaze);\n\t\t\t}\n\t\t}\n\n\t\t//cout << a << ' ' << b << ' ' << k << endl;\n\n\t\tll ans = a + (b-a) * (k-1);\n\n\t\tcout << ans << endl;\n\t\treturn;\n\t}\n\n\t//0 -> white, 1 -> black\n\tmat maze(M/7, vec (7, 0)), dmaze(M/7*2, vec(7, 0));\n\n\trep(Q, i)\n\t{\n\t\tint x = qs[i];\n\t\tint h = x / 7, w = x % 7;\n\t\tdmaze[h][w] = maze[h][w] = 1;\n\t\tx += M;\n\t\th = x / 7, w = x % 7;\n\t\tdmaze[h][w] = 1;\n\t}\n\n\tll a = 0, b = 0, k = N*7/M;\n\n\trep(M/7, i) rep(7, j)\n\t{\n\t\tif (maze[i][j] == 0)\n\t\t{\n\t\t\ta++;\n\t\t\tdfs(j, i, maze);\n\t\t}\n\t}\n\n\trep(2*M/7, i) rep(7, j)\n\t{\n\t\tif (dmaze[i][j] == 0)\n\t\t{\n\t\t\tb++;\n\t\t\tdfs(j, i, dmaze);\n\t\t}\n\t}\n\n\t//cout << a << ' ' << b << ' ' << k << endl;\n\n\tll ans = a + (b-a) * (k-1);\n\n\tcout << ans << endl;\n\n\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a <= x && x < b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\nstd::ostream& operator<<(std::ostream& os, const PAIR& r) {\n\tos << \"(\" << r.first << \", \" << r.second << \")\";\n\treturn os;\n}\n\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nint dy4[] = { -1, 0, 1, 0 };\nint dx4[] = { 0, 1, 0, -1 };\n\nint calc(std::vector<std::vector<bool>>& a) {\n\tint cnt = 0;\n\n\tREP(i, a.size()) {\n\t\tREP(j, 7) {\n\t\t\tif (a[i][j]) continue;\n\t\t\t++cnt;\n\t\t\tstd::queue<PAIR> que;\n\t\t\tque.push(PAIR(i, j));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tPAIR now = que.front(); que.pop();\n\t\t\t\ta[now.first][now.second] = true;\n\t\t\t\tREP(d, 4) {\n\t\t\t\t\tint dy = now.first + dy4[d];\n\t\t\t\t\tint dx = now.second + dx4[d];\n\t\t\t\t\tif (!IN(0, dy, a.size()) || !IN(0, dx, 7)) continue;\n\t\t\t\t\tif (a[dy][dx]) continue;\n\t\t\t\t\tque.push(PAIR(dy, dx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, m, q);\n\tVEC(int, a, q);\n\tstd::vector<bool> bb(m, false);\n\tREP(i, q) {\n\t\tbb[a[i]] = true;\n\t}\n\tif (n <= 100000) {\n\t\tstd::vector<std::vector<bool>> b(n, std::vector<bool>(7, false));\n\t\tREP(i, n) REP(j, 7) {\n\t\t\tif (bb[((7 * i + j - 7) % m + m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tOUT(calc(b))BR;\n\t\treturn 0;\n\t}\n\n\tstd::vector<int> t(2);\n\tREP(_, 2) {\n\t\tstd::vector<std::vector<bool>> b(m / 7 * (_ + 1), std::vector<bool>(7, false));\n\t\tREP(i, m / 7 * (_ + 1)) REP(j, 7) {\n\t\t\tif (bb[(7 * i + j - 7 + 8 * m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tt[_] = calc(b);\n\t}\n\tint x = 7 * n / m;\n\tint d = t[1] - t[0];\n\tOUT(t[0] + (x - 1)*d)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N,m;\nbool MAP[100001][8];\nbool MOD[100010];\nint a[100010];\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t Q;\n\tin >> N>>m>>Q;\n\tfor (int32_t i = 0; i < Q; ++i)\n\t{\n\t\tin >> a[i];\n\t\tMOD[a[i]] = true;\n\t}\n\n\tif (N <= 100000)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < N; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tout << count << endl;\n\t}\n\telse if (m % 7==0)\n\t{\n\t\treturn 0;\n\t\tif (Q >= 7)\n\t\t{\n\t\t\tif (Q == m) {\n\t\t\t\tout << 0 << endl;\n\t\t\t}\n\t\t\telse if (a[0] == 0) {\n\t\t\t\tout << N / (m / 7) + (N % (m / 7) > 1 ? 1 : 0) << endl;\n\t\t\t}\n\t\t\telse if (a[Q - 1] + 1 == m) {\n\t\t\t\tout << N / (m / 7) + (N % (m / 7) > 0 ? 1 : 0) << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout << N / (m / 7) + 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tout << 1 << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll n,m;\nint q;\nll a[1000001];\nll cnt[7];\nint fie[700001][7];\nint dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint bfs(int y,int x){\n\tqueue<P> que;\n\tque.push(P(y,x));\n\twhile(que.size()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=p.second+dx[i],ny=p.first+dy[i];\n\t\t\tif(nx>=0 && nx<7 && ny>=0){\n\t\t\t\tif(fie[ny][nx]==0){\n\t\t\t\t\tfie[ny][nx]=1;\n\t\t\t\t\tque.push(P(ny,nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%lld%lld%d\",&n,&m,&q);\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%lld\",&a[i]);\n\t}\n\tll lm=m;\n\tint cc=1;\n\twhile(lm%7LL!=0){\n\t\tlm+=m;\n\t\tcc++;\n\t}\n\tll len=lm/7;\n\tll cnt=0;\n\tmemset(fie,-1,sizeof(fie));\n\tfor(int i=0;i<len;i++){\n\t\tfor(int j=0;j<7;j++){\n\t\t\tfie[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tfor(int j=0;j<cc;j++){\n\t\t\tfie[(a[i]+m*j)/7LL][(a[i]+m*j)%7LL]=1;\n\t\t}\n\t}\n\tfor(int i=0;i<len;i++){\n\t\tfor(int j=0;j<7;j++){\n\t\t\tif(fie[i][j]==0){\n\t\t\t\tcnt++;\n\t\t\t\tbfs(i,j);\n\t\t\t}\n\t\t}\n\t}\n\tmemset(fie,-1,sizeof(fie));\n\tfor(int i=0;i<len*2;i++){\n\t\tfor(int j=0;j<7;j++){\n\t\t\tfie[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tfor(int j=0;j<cc*2;j++){\n\t\t\tfie[(a[i]+m*j)/7][(a[i]+m*j)%7]=1;\n\t\t}\n\t}\n\tll cnt2=0;\n\tfor(int i=0;i<len*2;i++){\n\t\tfor(int j=0;j<7;j++){\n\t\t\tif(fie[i][j]==0){\n\t\t\t\tcnt2++;\n\t\t\t\tbfs(i,j);\n\t\t\t}\n\t\t}\n\t}\n\tll ad=(ll)7LL*n/lm;\n\t//printf(\"%lld %lld %lld %lld\\n\",cnt,cnt2,ad,lm);\n\tprintf(\"%lld\\n\",(ll)cnt+(cnt2-cnt)*(ad-1LL));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cassert>\n#define int long long\nusing namespace std;\n\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = {0, 1, 0, -1};\n\nint n, m, q;\nint a[100000];\n\nint solve1() {\n\tstatic bool used[100000][7] = {false};\n\tint i, j;\n\t\n\tfor (i = 0; i < q; i++) {\n\t\tfor (j = a[i]; j < 7 * n; j += m) {\n\t\t\tint r = j / 7;\t//0-indexed\n\t\t\tint c = j % 7;\t//0-indexed\n\t\t\tused[r][c] = true;\n\t\t}\n\t}\n\t\n\tint cnt = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < 7; j++) {\n\t\t\tif (used[i][j]) continue;\n\t\t\t\n\t\t\tcnt++;\n\t\t\t\n\t\t\ttypedef pair<int, int> P;\n\t\t\tqueue<P> que;\n\t\t\tque.push(P(i, j));\n\t\t\tused[i][j] = true;\n\t\t\twhile(!que.empty()) {\n\t\t\t\tP now = que.front(); que.pop();\n\t\t\t\tfor (int dir = 0; dir < 4; dir++) {\n\t\t\t\t\tint ny = now.first + dy[dir];\n\t\t\t\t\tint nx = now.second + dx[dir];\n\t\t\t\t\tif (!(0 <= ny && ny < n && 0 <= nx && nx < 7)) continue;\n\t\t\t\t\tif (used[ny][nx]) continue;\n\t\t\t\t\tque.push(P(ny, nx));\n\t\t\t\t\tused[ny][nx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint solve2() {\n\tif (m == 7) {\n\t\tbool used[8] = {false};\n\t\tfor (int i = 0; i < q; i++) used[a[i]] = true;\n\t\tused[7] = true;\n\t\t\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 7; i++) {\n\t\t\tif (!used[i] && used[i + 1]) {\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\telse {\n\t\tstatic bool exist[100000] = {false};\n\t\tfor (int i = 0; i < q; i++) exist[a[i]] = true;\n\t\tfor (int i = 0; i <= m - 7; i++) {\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 7; j++) {\n\t\t\t\tif (!exist[i + j]) break;\n\t\t\t}\n\t\t\tif (j == 7) return n;\n\t\t}\n\t\tif (7 * n == q) return 0;\n\t\treturn 1;\n\t}\n\tassert(0);\n\treturn -1;\n}\n\nsigned main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < q; i++) cin >> a[i];\n\t\n\tint res;\n\tif (n <= 100000) { res = solve1(); }\n\telse if (m % 7 == 0) { res = solve2(); }\n\telse { res = 0; }\n\t\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N, m;\nbool MAP[100001][8];\nbool MOD[100010];\nint32_t a[100010];\n\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) {\n\tarr = v;\n}\ntemplate<typename T, typename ARR>\nvoid fill_all(ARR& arr, const T& v) {\n\tfor (auto& i : arr) { fill_all(i, v); }\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t Q;\n\tin >> N >> m >> Q;\n\tfor (int32_t i = 0; i < Q; ++i)\n\t{\n\t\tin >> a[i];\n\t\tMOD[a[i]] = true;\n\t}\n\n\tif (N <= 100000)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < N; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tout << count << endl;\n\t}\n\telse if ((m % 7) == 0)\n\t{\n\t\tfor (int32_t y = 0; y < (m / 7); ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[(m / 7)][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < (m/7); ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tint32_t count1 = count;\n\n\t\tfill_all(MAP, false);\n\t\tfor (int32_t y = 0; y < (m / 7) * 2; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[(m / 7) * 2][x] = true;\n\t\t}\n\t\tcount = 0;\n\t\tfor (int32_t y = 0; y < (m / 7)*2; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tout << (count - count1)*((7*N)/m)+count1 << endl;\n\t}\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define I(i,j) (i*7+j)\n\nll n,m,q,a[100050];\nbool g[3000000];\nbool used[3000000];\n\nbool dfs1(ll n,ll i,ll j) {\n    ll ret = i >= n / 2;\n    REP(k,4) {\n        ll y = i + dy[k],x = j + dx[k];\n        if(0 <= y && y < n && 0 <= x && x < 7 && !used[I(y,x)] && !g[I(y,x)]) {\n            used[I(y,x)] = true;\n            ret |= dfs1(n,y,x);\n        }\n    }\n    return ret;\n}\n\nint main(){\n    cin >> n >> m >> q;\n\n    REP(i,q)\n        cin >> a[i];\n\n    ll l = 1;\n\n    while(m * l % 7 != 0)l++;\n\n    ll n2 = m * l / 7;\n\n    REP(i,q) {\n        ll p = a[i];\n\n        while(p < n2 * 7){\n            g[p] = true;\n            p += m;\n        }\n    }\n\n    ll c = 0;\n    REP(i,n2) {\n        REP(j,7) {\n            if(!used[I(i,j)] && !g[I(i,j)]) {\n                c++;\n                used[I(i,j)] = true;\n                dfs1(n2,i,j);\n            }\n        }\n    }\n    if(n == n2) {\n        cout << c << endl;\n        return 0;\n    }\n\n    REP(i,n2*7*2)\n        g[i] = used[i] = false;\n\n    REP(i,q) {\n        ll p = a[i];\n\n        while(p < n2 * 7 * 2){\n            g[p] = true;\n            p += m;\n        }\n    }\n\n    ll c1 = 0,c2 = 0;\n\n    REP(i,n2) {\n        REP(j,7) {\n            if(!used[I(i,j)] && !g[I(i,j)]) {\n                c1++;\n                used[I(i,j)] = true;\n                if(dfs1(n2*2,i,j))c2++;\n            }\n        }\n    }\n\n    cout << n / n2 * c1 - (n / n2 - 1) * c2 + (c - c1) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nlong long N;\nint M, Q;\nbool X[100000][7];\nint A[100001];\nint U[700000], Rk[700000];\nbool F[700000];\nint QC;\n\nint find(int x) {\n  if (U[x] == x) return x;\n  return U[x] = find(U[x]);\n}\n\nvoid unite(int x, int y) {\n  x = find(x), y = find(y);\n  if (x == y) return;\n  if (Rk[x] < Rk[y]) swap(x, y);\n  if (U[y] == y) QC--;\n  U[y] = x;\n  Rk[x] += Rk[y];\n  Rk[y] = 0;\n  if (F[y]) F[x] = true;\n  F[y] = false;\n}\n\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> M >> Q;\n  for (int i=0; i<7*M; i++) U[i] = i, Rk[i] = 1;\n  rep(i, Q) {\n    int a;\n    cin >> a;\n    rep(k, 7) {\n      int x = a + k*M;\n      X[x/7][x%7] = true;\n    }\n  }\n  if (N == 0) {\n    cout << 0 << \"\\n\";\n    return 0;\n  }\n  /*\n  rep(i, M) {\n    rep(j, 7)cout<<X[i][j];\n    cout<<\"\\n\";\n  }\n  */\n  rep(x, M) {\n    for (int i=1; i<7; i++) {\n      if (!X[x][i] && !X[x][i-1]) {\n        unite(7*x+i, 7*x+i-1);\n      }\n    }\n  }\n\n  if (N<M) {\n    rep(x, N) {\n      if (x > 0) {\n        rep(i, 7) {\n          if (!X[x][i] && !X[(x+M-1)%M][i]) {\n            unite(7*x+i, 7*((x+M-1)%M)+i);\n          }\n        }\n      }\n    }\n    int c = 0;\n    rep(x, N) {\n      rep(i, 7) {\n        if (X[x][i]) continue;\n        if (U[7*x+i] == 7*x+i) c++;\n      }\n    }\n    cout << c << \"\\n\";\n    return 0;\n  }\n  rep(x, M) {\n    rep(i, 7) {\n      if (!X[x][i]) QC++;\n    }\n    if (x>0)\n    rep(i, 7) {\n      if (!X[x][i] && !X[(x+M-1)%M][i]) {\n        unite(7*x+i, 7*((x+M-1)%M)+i);\n      }\n    }\n  }\n  long long sum = QC;\n  rep(i, 7) {\n    if (!X[0][i] && !X[M-1][i]) {\n      unite(7*0+i, 7*(M-1)+i);\n      F[find(i)] = true;\n    }\n  }\n  int c = 0;\n  rep(x, M) {\n    rep(i, 7) {\n      if (X[x][i]) continue;\n      if (U[7*x+i] == 7*x+i && !F[7*x+i]) c++;\n    }\n  }\n  sum += 1LL * c * (N/M);\n\n  for (int i=0; i<7*M; i++) U[i] = i, Rk[i] = 1, F[i] = false;\n  rep(x, M) {\n    for (int i=1; i<7; i++) {\n      if (!X[x][i] && !X[x][i-1]) {\n        unite(7*x+i, 7*x+i-1);\n      }\n    }\n  }\n  rep(i, 7) {\n    if (!X[0][i] && !X[M-1][i]) {\n      unite(7*0+i, 7*(M-1)+i);\n      F[find(i)] = true;\n    }\n  }\n  rep(x, N%M) {\n    rep(i, 7) {\n      if (!X[x][i]) QC++;\n    }\n    if (x>0)\n    rep(i, 7) {\n      if (!X[x][i] && !X[(x+M-1)%M][i]) {\n        unite(7*x+i, 7*((x+M-1)%M)+i);\n      }\n    }\n  }\n  c = 0;\n  rep(x, N%M) {\n    rep(i, 7) {\n      if (X[x][i]) continue;\n      if (U[7*x+i] == 7*x+i && !F[7*x+i]) c++;\n    }\n  }\n  sum += c;\n  cout<<sum<<\"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  for(int i=0;i<(n);++i)\n#define REPr(i,n) for(int i=(n)-1;i>=0; --i)\n#define FORq(i, m, n) for(int i = (m);i <= (n);++i)\n#define rFORq(i, m , n) for(int i = (n);i >=(m);--i)\n#define SCD(n) scanf(\"%d\",&n)\n#define SCD2(m,n) scanf(\"%d%d\",&m,&n)\n#define SCD3(m,n,k) scanf(\"%d%d%d\",&m,&n,&k)\n#define SCLLD(n) scanf(\"%lld\",&n)\n#define SCLLD2(m,n) scanf(\"%lld%lld\",&m,&n)\n#define SCLLD3(m,n,k) scanf(\"%lld%lld%lld\",&m,&n,&k)\n#define PB push_back\n#define MP make_pair\n#define ARSCD(A,N) REP(i,N){SCD(A[i]);}\n#define ARSCD1(A,N) FORq(i,1,N){SCD(A[i]);}\n#define VSCD(v,N) REP(i,N){int x; SCD(x); v.PB(x);}\n#define VSCLLD(v,N) REP(i,N){long long x; SCLLD(x); v.PB(x);}\n#define PRINTD(n) printf(\"%d\\n\",n)\n#define PRINTLLD(n) printf(\"%lld\\n\",n)\n#define DEBUG printf(\"%s\\n\",\"debug\")\n#define fst first\n#define snd second\n#define SIN(x,S) (S.count(x) != 0)\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector < VI > VVI;\ntypedef vector<long long> VL;\ntypedef long long ll;\ntypedef long long integer;\n////////////////////////////////////////////////////////////////////\nconst ll p = 1000000007;\nll dx[4] = {-7,-1,1,7};\n\nint main(){\n    ll N,M,Q; SCLLD3(N,M,Q);\n    static ll a[100002] = {};\n    static bool grid[700002] = {}; // partial\n    //static bool visited[100002] = {};\n    ARSCD(a,Q);\n\n    REP(q,Q){\n        ll ai = a[q];\n        ll k = 0;\n        while(k*M + ai <= 7 * N - 1){\n            grid[k*M+ai] = true;\n            k++;\n        }\n    }\n\n/*     FORq(i,0,7*N-1){\n        if (i % 7 == 0) printf(\"\\n\");\n        if (grid[i]) printf(\"%d\",1);\n        else printf(\"%d\",0);\n    }\n    printf(\"\\n\"); */\n\n    ll count = 0;\n    queue<ll> que;\n\n    FORq(i,0,7*N-1){\n        if (grid[i]) continue;\n        que.push(i);\n        //printf(\"start = %d\\n\",i);\n        while(!que.empty()){\n            ll now = que.front(); que.pop();\n            grid[now] = true;\n            \n            REP(k,4){\n                ll next = now + dx[k];\n                if ((now % 7 == 0) and (k == 1)) continue;\n                if (next < 0) continue;\n                if (next >= 7 * N) continue;\n                if ((now % 7 == 6) and (k == 2)) continue;\n                if (grid[next]) continue;\n                //printf(\"next -> %lld\\n\",next);\n                que.push(next);\n            }\n        }\n        //printf(\"count+\\n\");\n        count++;\n    }\n\n    PRINTLLD(count);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n;;;;;;;;;;;;::;,.,xOOOOOOOkdoc;,,;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,,'''',,,,,,,,,'',,:cloo:'.\n;;;;;;;;;;:ccccc,'lOOOOOOOOOOOxoc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,,''''''''''',;cloxkOOOOl..\n;;;;;;;;;:cccccc:,;xOOOOOOOOOOOOOxoc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,''''''';:loxkOOOOOOOOk:..\n;;;;;;;;;:cccccc::,ck0OOOOO0OO00OOOOxl:;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,'',;codkO0OOOOOOOOOOOo'..\n;;;;;;;;:cccccc:::;,ck0OOOOOOOOOOOOO0Okoc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:cloxOOOOOOOOOOOOOOOO0x;..'\n;;;;;;;:ccccccc::;;,,:xOOOOO0OOOOOOOOOOOkdc;,;;;;;;;::::ccccccccc:::::cldkOOOOOOOOOOOOOOOOOOO0k:..''\n;;;;;;;:cccccc::;;,,,';dO0OOOOO0OOOOOOOOOOkdodddxxxxkkkOOOOOOOOOOkkkxkkO0OOOOOOOOOOOOOOOOOOO0kc'''''\n;;;;;;;::::::::;;,,,''',cxOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOxc,,,,''\n;;;;;,;;;;;;;;;,,,,'''''',lkOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOko:;;;;,,,\n;;;;,,,,,,,,,,,,''''''''''.,lkOOkxkOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkoc:c:::;;,,\n;;;;'''''''''''''''''''''''..;lodkO0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkxk0Okxocccccc:::;,,\n;;;,'............'''''''''''..;xOOOOOOOOOOOO0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkxdol::::cccc:::;;,,\n;;,'..............''''''''''';dOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOko;;::::::::;;;;,,\n;;'................'''''','',dOOOO0OOOxdoccxOO0OOOOOOOOOOOOOOOOOOOOxdoclxOOOOOOOOOOOo;;;;;;;;;;;;,,'\n;,'................'''''',,,lOOOOOOOOoo00c.;xOOOOOOOOOOOOOOOOOOOOOll0O:.:k0OOOOOOOOOOo,,;;;;;;,,,,''\n,'..................''',,,,ckOOO0OO0Ol,::,.,d0OOOOOOOOOOOOOOOOOOOOc,::,.;x0OOOOOOOOOOkc',,,,,,,,,,''\n,'..................''',,';dOOOOOOOO0kc,,,;oOOO0OO0OO0OOOOOOOOOOOOkc,,,:dOOOOOOOOOOOOOd,',,'''''''''\n'...................''',,,lOOOOOOOOOOOOkxxkOOOOOOOOxdddkOOOOOOOOOOOOkxxOOOOOOOOOOOOOO0kc''''''''''''\n'...................''',,;xOOOkkkOOOOOOOOOOOOOOOOOxo:;:dOOOOOOOOOOOOOOOOOOOOkkkkOOOOOOOd;'''''''''''\n'.................'''',,,ckxollllldkOOOOOOOOOOOOOO0OkkOOOOOOOOOOOOOOOOOOOkdlllllodkOOOOOc'',''''''''\n''''...........'''',,,,,;odccccccccokOOOOOOOOOOOOOOO0OOOOOOOOO0OOOOOOOOOxlcccccccclk0OOOd;,,,,,,,,''\n'''''''',''',,,,,,,;;;;;;ddcccccccclxOOOOOOOOOOOOkxdddddooddkOOOOOOOOOOOdccccccccclx0OOOOl,;;;;,,,,'\n',,,,,,;;;;;;;;;;;:::::;:xOdolclllokOOOOOOOOOOOOxllodddxdddllkOOOOOOOOOOkocccccccldOOOOOOd:;:;;;;;,,\n,,,;;;;:::::::::::::::cc;lOOOkkkkOOOOOOOOOOOOOOOdlodxxdxddxdcdOOOOOOOOOOOOkxdoddxkOOOOOOOOl:::::;;,,\n,,;;::::cccccccccccccccc::dOOOOOOOOOOOOOOOOOOOO0kolldxxxxxxoldOOOOOOOOOOOOOOOOOOOOOOOOOOOOd::c::;;,,\n,,;;:::cccccccccccccccccc:cxOOOOOOOOOOOOOOOOOOOOOOkxoooooooodOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkc:c:::;,,\n,,;;::::cccccccccccccccc:c:cxOOOOOOOOOOOOOOOOOOOOOOOOOkkkkkOO0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOo;:::;;,,\n,;;;;::::ccccccccccccccc:::;ck0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOx::::;;,,\n*/\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,tune=native\")\n//#pragma GCC optimize (\"unroll-loops\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double old;\n\nconst int N = 700100;\n\nint mp[N];\nint cur;\nint len;\nint bot[N], top[N];\n\nvoid dfs(int v) {\n    mp[v] = cur;\n    bot[cur] = min(bot[cur], v / 7);\n    top[cur] = max(top[cur], v / 7);\n    if (v % 7 && mp[v - 1] == 0) {\n        dfs(v - 1);\n    }\n    if (v % 7 != 6 && mp[v + 1] == 0) {\n        dfs(v + 1);\n    }\n    if (v / 7 && mp[v - 7] == 0) {\n        dfs(v - 7);\n    }\n    if (v + 7 < len && mp[v + 7] == 0) {\n        dfs(v + 7);\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cout << fixed << setprecision(20);\n    ll n;\n    int m, q;\n    cin >> n >> m >> q;\n    if (m == q) {\n        cout << 0;\n        return 0;\n    }\n    len = m;\n    if (len % 7) {\n        len *= 7;\n    }\n    while (q--) {\n        int a;\n        cin >> a;\n        for (int i = a; i < len; i += m) {\n            mp[i] = -1;\n        }\n    }\n    for (int i = 0; i < len; ++i) {\n        if (mp[i] == 0) {\n            ++cur;\n            bot[cur] = len;\n            dfs(i);\n        }\n    }\n    int kek = 0;\n    for (int i = 1; i <= cur; ++i) {\n        if (bot[i] == 0 && top[i] == len / 7 - 1) {\n            ++kek;\n        }\n    }\n    ll ans = (cur - kek) * (n * 7 / len) + kek;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint d[]={1,-1,7,-7};\n\nint N,M,Q;\nbool f[700000*2];\n\nint a[111111];\n\nint calc(int m){\n    memset(f,0,sizeof(f));\n    for(int i=0;i<Q;i++){\n        for(int j=a[i];j<m;j+=M)f[j]=true;\n    }\n\n    UnionFindTree uf(m);\n\n    rep(i,m){\n        rep(j,4){\n            if(i%7==0&&d[j]==-1)continue;\n            if(i%7==6&&d[j]==1)continue;\n            int nx=i+d[j];\n            if(nx<0||nx>=m)continue;\n            if(f[i]||f[nx])continue;\n            uf.unite(i,nx);\n        }\n    }\n    int res=0;\n    rep(i,m)if(!f[i]&&uf.find(i)==i)res++;\n    return res;\n}\n\nsigned main(){\n    cin>>N>>M>>Q;\n    int MM=M;\n    if(M%7)MM*=7;\n    rep(i,Q){\n        cin>>a[i];\n    }\n\n    int x=calc(MM);\n    int y=calc(2*MM);\n    cout<<x+(y-x)*(N*7/MM-1)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a <= x && x < b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\nstd::ostream& operator<<(std::ostream& os, const PAIR& r) {\n\tos << \"(\" << r.first << \", \" << r.second << \")\";\n\treturn os;\n}\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nint dy4[] = { -1, 0, 1, 0 };\nint dx4[] = { 0, 1, 0, -1 };\n\nint calc(std::vector<std::vector<bool>> a) {\n\tint cnt = 0;\n\n\tREP(i, a.size()) {\n\t\tREP(j, 7) {\n\t\t\tif (a[i][j]) continue;\n\t\t\t++cnt;\n\t\t\tstd::queue<PAIR> que;\n\t\t\tque.push(PAIR(i, j));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tPAIR now = que.front(); que.pop();\n\t\t\t\ta[now.first][now.second] = true;\n\t\t\t\tREP(d, 4) {\n\t\t\t\t\tint dy = now.first + dy4[d];\n\t\t\t\t\tint dx = now.second + dx4[d];\n\t\t\t\t\tif (!IN(0, dy, a.size()) || !IN(0, dx, 7)) continue;\n\t\t\t\t\tif (a[dy][dx]) continue;\n\t\t\t\t\tque.push(PAIR(dy, dx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, m, q);\n\tVEC(int, a, q);\n\tassert(m % 7 == 0);\n\tstd::vector<int> t(2);\n\tREP(_, 2) {\n\t\tstd::vector<std::vector<bool>> b(m / 7 * (_ + 1), std::vector<bool>(7, false));\n\t\tREP(i, m / 7 * (_ + 1)) REP(j, 7) {\n\t\t\tif (std::find(ALL(a), (7 * (i + 1) + j - 7) % m) != a.end()) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tt[_] = calc(b);\n\t}\n\tint x = 7 * n / m;\n\tint d = t[1] - t[0];\n\tOUT(t[0] + (x - 1)*d)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\n#define FOR(k,m,n) for(ll (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<< #str << \" \" str<<endl\n\nconstexpr int INF = (1 << 30);\nconstexpr ll INFL = (1ll << 60);\nconstexpr ll MOD = 1000000007;// 10^9+7\n\nvector<ll> scale(vector<ll> a, ll& m) {\n\tvector<ll> res;\n\tfor (auto num : a) REP(i, 7) {\n\t\tres.push_back(i*m + num);\n\t}\n\tsort(res.begin(), res.end());\n\tm *= 7;\n\treturn res;\n}\n\nbool isin(ll h, ll w, ll line) {\n\treturn 0 <= h && h < line && 0 <= w && w < 7;\n}\n\nvoid paint(vector<vector<bool>>& use, pair<ll, ll> p) {\n\tll dh[] = { 0,1,0,-1 };\n\tll dw[] = { 1,0,-1,0 };\n\tqueue<pair<ll, ll>> que;\n\tque.push(p);\n\twhile (!que.empty()) {\n\t\tauto now = que.front(); que.pop();\n\t\tREP(dir, 4) {\n\t\t\tll h = now.first + dh[dir];\n\t\t\tll w = now.second + dw[dir];\n\t\t\tif (isin(h, w, use.size()) && !use[h][w]) {\n\t\t\t\tuse[h][w] = true;\n\t\t\t\tque.push({ h,w });\n\t\t\t}\n\t\t}\n\t}\n}\n\nll count(vector<ll> a, ll line, ll loop) {\n\tll cnt = 0;\n\tvector<vector<bool>> use(line, vector<bool>(7, false));\n\tfor (auto num : a)use[num / 7][num % 7] = true;\n\tREP(i, loop - 1)REP(j, line)use.push_back(use[j]);\n\n\tREP(h, line*loop)REP(w, 7)if (!use[h][w]) {\n\t\tpaint(use, { h,w });\n\t\tcnt++;\n\t}\n\treturn cnt;\n\n}\n\npair<ll, ll> find_func(ll p1, ll p2, ll p3) {\n\tFOR(a, -100, 100)FOR(b, -100, 100) {\n\t\tif (a + b == p1 &&\n\t\t\ta * 2 + b == p2 &&\n\t\t\ta * 3 + b == p3) {\n\t\t\treturn { a,b };\n\t\t}\n\t}\n}\n\nint main()\n{\n\tll n, m, q;\n\tcin >> n >> m >> q;\n\tvector<ll> a(q);\n\tREP(i, q)cin >> a[i];\n\tif (m % 7 != 0)a = scale(a, m);\n\n\tll line = m / 7;\n\tll pos1 = count(a, line, 1);\n\tll pos2 = count(a, line, 2);\n\tll pos3 = count(a, line, 3);\n\tauto func = find_func(pos1, pos2, pos3);\n\tcout << func.first*(n / line) + func.second << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N,m;\nbool MAP[100001][8];\nbool MOD[100010];\nint32_t a[100010];\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t Q;\n\tin >> N>>m>>Q;\n\tfor (int32_t i = 0; i < Q; ++i)\n\t{\n\t\tin >> a[i];\n\t\tMOD[a[i]] = true;\n\t}\n\n\tif (N <= 100000)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < N; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tout << count << endl;\n\t}\n\telse if (m % 7==0)\n\t{\n\t\tif (Q >= 7)\n\t\t{\n\t\t\tif (Q == m) {\n\t\t\t\tout << 0 << endl;\n\t\t\t}\n\t\t\telse if (a[0] == 0) {\n\t\t\t\tout << N / (m / 7) + (((N % (m / 7)) > 1) ? 1 : 0) << endl;\n\t\t\t}\n\t\t\telse if (a[Q - 1] + 1 == m) {\n\t\t\t\tout << N / (m / 7) + (((N % (m / 7)) > 0) ? 1 : 0) << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout << N / (m / 7) + 1 << endl;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tout << 1 << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\n\n#if 0\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N,Q;\nstd::vector<int32_t> parent[100000];\nstd::vector<int32_t> child[100000];\nint32_t V[100000];\nvoid add(int32_t i, int32_t d, int32_t v)\n{\n\tV[i] += v;\n\tif (d > 0) {\n\t\tfor (auto& c : child[i]) {\n\t\t\tadd(c, d - 1, v);\n\t\t}\n\t}\n}\nint64_t sum(int32_t i, int32_t d)\n{\n\tint64_t res = V[i];\n\tif (d > 0) {\n\t\tfor (auto& c : child[i]) {\n\t\t\tres += sum(c, d - 1);\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\n\tin >> N>>Q;\n\tif ((int64_t)(N*Q)>1000000000) {\n\t\treturn 0;\n\t}\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tint p, v;\n\t\tin >> p >> V[i];\n\t\tif (p != -1) { parent[i].push_back(p); child[p].push_back(i); }\n\t}\n\tfor (int32_t loop = 0; loop < Q; ++loop)\n\t{\n\t\tint type;\n\t\tin >> type;\n\t\tif (type == 1) {\n\t\t\tint p, d, v;\n\t\t\tin >> p >> d >> v;\n\t\t\tadd(p, d, v);\n\t\t}\n\t\telse if (type == 2) {\n\t\t\tint p, d;\n\t\t\tin >> p >> d;\n#ifdef _DEBUG\n\t\t\tout << \"OUTPUT:\";\n#endif\n\t\t\tout << sum(p, d) << endl;\n\t\t}\n\t\telse if (type == 3) {\n\t\t\tint p;\n\t\t\tin >> p >> V[N];\n\t\t\tif (p != -1) { parent[N].push_back(p); child[p].push_back(N); }\n\t\t\t++N;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\n\n#if 0\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t ask(const std::string& s) {\n#ifdef _DEBUG\n#endif\n\tint32_t t;\n\tout << \"? \" << s << std::endl;\n\tin >> t;\n\treturn t;\n}\n\nconstexpr int32_t N = 200;//頂点数\nstd::vector<int32_t> graph[N];//木\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t t; in >> t;\n\tstd::string s(N,'0');\n\tint32_t count = 0;\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\ts[i] = '1';\n\t\tfor (int32_t j = i+1; j < N; ++j)\n\t\t{\n\t\t\ts[j] = '1';\n\n\t\t\tt = ask(s);\n\t\t\tif (t == 1) {\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\t++count;\n\t\t\t\tif (count >= N-1) {\n\t\t\t\t\tgoto res_out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts[j] = '0';\n\t\t}\n\t\ts[i] = '0';\n\t}\nres_out:\n\tout << '!';\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tfor (auto& j : graph[i]) {\n\t\t\tout << \" (\" << i << ',' << j << ')';\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n#if 0\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N;\n\nconstexpr int32_t MAX_N = 300000;//頂点数\nconstexpr int32_t MAX_LOGN = 30;//log2頂点数\nstd::unordered_map<int32_t, double> graph[MAX_N];//木\ndouble get(int32_t v, int32_t p) {\n\tauto& memo = graph[v][p];\n\tif (memo >= 0 && p != -1) {\n\t\treturn memo;\n\t}\n\tint32_t count = 0;\n\tdouble sum = 0;\n\tfor (auto& c : graph[v]) {\n\t\tif (c.first != p && c.first != -1) {\n\t\t\t++count;\n\t\t\tsum += get(c.first, v) + 1;\n\t\t}\n\t}\n\tif (count == 0) {\n\t\treturn memo = 0;\n\t}\n\treturn memo = sum / count;\n}\nbool CASE_HACK_MODE = true;\nint32_t center1 = -1;\nint32_t center2 = -1;\nvoid input_tree()\n{\n\tin >> N;\n\tfor (int32_t i = 0; i < N - 1; ++i)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tgraph[a][b] = -1;\n\t\tgraph[b][a] = -1;\n\t\tif (center1 == -1) { center1 = a; center2 = b; }\n\t\telse {\n\t\t\tif (a == center1 || a == center2) {\n\t\t\t\tcenter1 = a;\n\t\t\t}\n\t\t\telse if (b == center1 || b == center2) {\n\t\t\t\tcenter1 = b;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tCASE_HACK_MODE = false;\n\t\t\t}\n\n\t\t\tcenter2 = -1;\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tout << std::fixed << std::setprecision(9);\n\tinput_tree();\n\tif (!CASE_HACK_MODE)\n\t{\n\t\tfor (int32_t i = 0; i < N; ++i)\n\t\t{\n\t\t\tout << get(i, -1) << endl;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tout << ((i == center1) ? 1.0 : 2.0) << endl;\n\t}\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 666666\nint n,m,q,a[SZ];\nbool cov[SZ];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tfor(int i=1;i<=q;i++)\n\tscanf(\"%d\",a+i),cov[a[i]]=1;\n\tif(m==1)\n\t{\n\t\tif(q) puts(\"0\");\n\t\telse puts(\"1\");\n\t\treturn 0;\n\t}\n\tif(m==7)\n\t{\n\t\tint cc=0; \n\t\tfor(int i=0;i<7;i++)\n\t\t\tif((!cov[i]&&cov[i+1])||(i==6&&!cov[i])) ++cc;\n\t\tprintf(\"%d\\n\",cc);\n\t\treturn 0;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a <= x && x < b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\nstd::ostream& operator<<(std::ostream& os, const PAIR& r) {\n\tos << \"(\" << r.first << \", \" << r.second << \")\";\n\treturn os;\n}\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nint dy4[] = { -1, 0, 1, 0 };\nint dx4[] = { 0, 1, 0, -1 };\n\nint calc(std::vector<std::vector<bool>> a) {\n\tint cnt = 0;\n\n\tREP(i, a.size()) {\n\t\tREP(j, 7) {\n\t\t\tif (a[i][j]) continue;\n\t\t\t++cnt;\n\t\t\tstd::queue<PAIR> que;\n\t\t\tque.push(PAIR(i, j));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tPAIR now = que.front(); que.pop();\n\t\t\t\ta[now.first][now.second] = true;\n\t\t\t\tREP(d, 4) {\n\t\t\t\t\tint dy = now.first + dy4[d];\n\t\t\t\t\tint dx = now.second + dx4[d];\n\t\t\t\t\tif (!IN(0, dy, a.size()) || !IN(0, dx, 7)) continue;\n\t\t\t\t\tif (a[dy][dx]) continue;\n\t\t\t\t\tque.push(PAIR(dy, dx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, m, q);\n\tVEC(int, a, q);\n\tstd::vector<bool> bb(m, false);\n\tREP(i, q) {\n\t\tbb[a[i]] = true;\n\t}\n\tstd::vector<int> t(2);\n\tREP(_, 2) {\n\t\tstd::vector<std::vector<bool>> b(m / 7 * (_ + 1), std::vector<bool>(7, false));\n\t\tREP(i, m / 7 * (_ + 1)) REP(j, 7) {\n\t\t\tif (bb[(7 * i + j - 7 + 8*m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tt[_] = calc(b);\n\t}\n\tint x = 7 * n / m;\n\tint d = t[1] - t[0];\n\tOUT(t[0] + (x - 1)*d)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define put(x) cout << x;\n#define putsp(x) cout << x << ' ';\n#define putln(x) cout << x << endl;\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\ntypedef long long ll;\ntypedef pair<ll, ll> llP;\ntypedef pair<int, int> intP;\ntypedef complex<double> comp;\ntypedef vector <int> vec;\ntypedef vector <ll> vecll;\ntypedef vector <double> vecd;\ntypedef vector <vec> mat;\ntypedef vector <vecll> matll;\ntypedef vector <vecd> matd;\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nconst int MAX = 100010;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = 1<<29;\nconst ll INFL = 1e18;\nconst ll MOD = 1000000007;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint dx8[8]={1,0,-1,1,-1,1,0,-1};\nint dy8[8]={1,1,1,0,0,-1,-1,-1};\n\n//********************************template END****************************************//\n\nll N, M, Q;\n\nvoid dfs(int x, int y, mat& m)\n{\n\tm[y][x] = 1;\n\trep(4, d)\n\t{\n\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\tif (0 <= ny && ny < (int)m.size() && 0 <= nx && nx < 7)\n\t\t{\n\t\t\tif (m[ny][nx] == 0)\n\t\t\t{\n\t\t\t\tdfs(nx, ny, m);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(void){\n\n\tcin >> N >> M >> Q;\n\n\tvec qs(Q);\n\n\trep(Q, i)\n\t{\n\t\tcin >> qs[i];\n\t}\n\n\tif (M % 7)\n\t{\n\t\t//0 -> white, 1 -> black\n\t\tmat maze(M, vec (7, 0)), dmaze(M*2, vec(7, 0));\n\n\t\trep(Q, i) rep(7, j)\n\t\t{\n\t\t\tint x = qs[i] + M*j;\n\t\t\tint h = x / 7, w = x % 7;\n\t\t\tdmaze[h][w] = maze[h][w] = 1;\n\t\t\tx += 7*M;\n\t\t\th = x / 7, w = x % 7;\n\t\t\tdmaze[h][w] = 1;\n\t\t}\n\n\t\tint a = 0, b = 0, k = N/M;\n\n\t\trep(M, i) rep(7, j)\n\t\t{\n\t\t\tif (maze[i][j] == 0)\n\t\t\t{\n\t\t\t\ta++;\n\t\t\t\tdfs(j, i, maze);\n\t\t\t}\n\t\t}\n\n\t\trep(2*M, i) rep(7, j)\n\t\t{\n\t\t\tif (dmaze[i][j] == 0)\n\t\t\t{\n\t\t\t\tb++;\n\t\t\t\tdfs(j, i, dmaze);\n\t\t\t}\n\t\t}\n\n\t\t//cout << a << ' ' << b << ' ' << k << endl;\n\n\t\tint ans = a + (b-a) * (k-1);\n\n\t\tcout << ans << endl;\n\t\treturn;\n\t}\n\n\t//0 -> white, 1 -> black\n\tmat maze(M/7, vec (7, 0)), dmaze(M/7*2, vec(7, 0));\n\n\trep(Q, i)\n\t{\n\t\tint x = qs[i];\n\t\tint h = x / 7, w = x % 7;\n\t\tdmaze[h][w] = maze[h][w] = 1;\n\t\tx += M;\n\t\th = x / 7, w = x % 7;\n\t\tdmaze[h][w] = 1;\n\t}\n\n\tint a = 0, b = 0, k = N*7/M;\n\n\trep(M/7, i) rep(7, j)\n\t{\n\t\tif (maze[i][j] == 0)\n\t\t{\n\t\t\ta++;\n\t\t\tdfs(j, i, maze);\n\t\t}\n\t}\n\n\trep(2*M/7, i) rep(7, j)\n\t{\n\t\tif (dmaze[i][j] == 0)\n\t\t{\n\t\t\tb++;\n\t\t\tdfs(j, i, dmaze);\n\t\t}\n\t}\n\n\t//cout << a << ' ' << b << ' ' << k << endl;\n\n\tint ans = a + (b-a) * (k-1);\n\n\tcout << ans << endl;\n\n\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<map>\n#include<string>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n//#define scanf scanf_s\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\nconst llint mod=1000000007;\n\n\nint main(void){\n\tllint N,ans;\n\tint M,q,i,j,a,ansa,ansb,ok=0;\n\tqueue<int> que;\n\tvector<int> nuru;\n\tvector<int> siro;//0=siro 1=kuro\n\tint hkazu;\n\tscanf(\"%lld %d %d\",&N,&M,&q);\n\tfor(i=0;i<q;i++){\n\t\tscanf(\"%d\",&a);\n\t\tnuru.pub(a);\n\t}\n\t\n\tif(M%7!=0){ \n\t\tfor(i=0;i<q;i++){\n\t\t\tfor(j=1;j<7;j++){\n\t\t\t\tnuru.pub(nuru[i]+M*j);\n\t\t\t}\n\t\t}\n\t\tM*=7;ok=1;\n\t}\n\tsiro.resize(M);\n\tfor(i=0;i<nuru.size();i++){\n\t\tsiro[nuru[i]]=1;\n\t}\n\thkazu=M-nuru.size();\n\tansa=0;\n\tfor(i=0;i<M;i++){\n\t\tif(siro[i]==1){ continue; }\n\t\tque.push(i);\n\t\twhile(!que.empty()){\n\t\t\thkazu--;\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tif(siro[a]==1){continue;}\n\t\t\tsiro[a]=1;\n\t\t\tif(a-7>=0&&siro[a-7]==0){ que.push(a-7); }\n\t\t\tif(a+7<M&&siro[a+7]==0){ que.push(a+7); }\n\t\t\tif(a%7!=0&&siro[a-1]==0){ que.push(a-1); }\n\t\t\tif(a%7!=6&&siro[a+1]==0){ que.push(a+1); }\n\n\t\t}\n\t\tansa++;\n\t}\n\tsiro.clear();\n\tsiro.resize(M*2);\n\tfor(i=0;i<nuru.size();i++){\n\t\tsiro[nuru[i]]=1;siro[nuru[i]+M]=1;\n\t}\n\thkazu=M*2-nuru.size();\n\tansb=0;\n\tfor(i=0;i<M*2;i++){\n\t\tif(siro[i]==1){continue;}\n\t\tque.push(i);\n\t\twhile(!que.empty()){\n\t\t\thkazu--;\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tif(siro[a]==1){ continue; }\n\t\t\tsiro[a]=1;\n\t\t\tif(a-7>=0&&siro[a-7]==0){ que.push(a-7); }\n\t\t\tif(a+7<M*2&&siro[a+7]==0){ que.push(a+7); }\n\t\t\tif(a%7!=0&&siro[a-1]==0){ que.push(a-1); }\n\t\t\tif(a%7!=6&&siro[a+1]==0){ que.push(a+1); }\n\t\t}\n\t\tansb++;\n\t}\n\tans=(ansb-ansa)*N*7/M+(2*ansa-ansb);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define val(p1,p2) p1>=0 && p1<m/7 && p2>=0 && p2<7 && !col[p1][p2] && vis[p1][p2]==-1\n#define val2(p1,p2) p1>=0 && p1<(n%m)/7 && p2>=0 && p2<7 && !col[p1][p2] && vis2[p1][p2]==-1\nusing namespace std;\n\nint main() {\n\tlong long n, m, q;\n\tscanf(\"%lld %lld %lld\", &n, &m, &q);\n\tn*=7;\n\tbitset<7> col[m/7];\n\tint vis[m/7][7], vis2[(n%m)/7][7];\n\tmemset(vis,-1,sizeof(vis));\n\tmemset(vis2,-1,sizeof(vis2));\n\tfor (int i=0; i<m; i++) col[i].reset();\n\tfor (int i=0; i<q; i++) {\n\t\tint aq; scanf(\"%d\", &aq);\n\t\tcol[aq/7][aq%7]=true;\n\t}\n\tint seg=0;\n\tqueue<pair<int, int> > qu;\n\tint xi[4]={1,0,-1,0}, yi[4]={0,1,0,-1};\n\tfor (int i=0; i<m/7; i++) {\n\t\tfor (int j=0; j<7; j++) {\n\t\t\tif (!col[i][j] && vis[i][j]==-1) {\n\t\t\t\tqu.push({i,j});\n\t\t\t\tvis[i][j]=seg;\n\t\t\t\twhile (!qu.empty()) {\n\t\t\t\t\tint x=qu.front().first, y=qu.front().second;\n\t\t\t\t\tqu.pop();\n\t\t\t\t\tfor (int k=0; k<4; k++) {\n\t\t\t\t\t\tint xx=x+xi[k], yy=y+yi[k];\n\t\t\t\t\t\tif (val(xx,yy)) {\n\t\t\t\t\t\t\tvis[xx][yy]=seg;\n\t\t\t\t\t\t\tqu.push({xx,yy});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tseg++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint con=0;\n\tunordered_set<int> segs;\n\tfor (int i=0; i<7; i++) {\n\t\tif (vis[0][i]!=-1 && segs.find(vis[0][i])==segs.end()) {\n\t\t\t//printf(\"%d %d %d\\n\", i, vis[0][i], vis[m/7-1][i]);\n\t\t\tif (vis[m/7-1][i]!=-1) {\n\t\t\t\tcon++;\n\t\t\t\tsegs.insert(vis[0][i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong long tot=(seg-con)*(n/m-1)+seg;\n\t//printf(\"%lld\\n\", tot);\n\t\n\tint seg2=0;\n\tfor (int i=0; i<(n%m)/7; i++) {\n\t\tfor (int j=0; j<7; j++) {\n\t\t\tif (!col[i][j] && vis2[i][j]==-1) {\n\t\t\t\tqu.push({i,j});\n\t\t\t\tvis2[i][j]=seg2;\n\t\t\t\twhile (!qu.empty()) {\n\t\t\t\t\tint x=qu.front().first, y=qu.front().second;\n\t\t\t\t\tqu.pop();\n\t\t\t\t\tfor (int k=0; k<4; k++) {\n\t\t\t\t\t\tint xx=x+xi[k], yy=y+yi[k];\n\t\t\t\t\t\tif (val2(xx,yy)) {\n\t\t\t\t\t\t\tvis2[xx][yy]=seg2;\n\t\t\t\t\t\t\tqu.push({xx,yy});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tseg2++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (n%m!=0) {\n\t\tint con2=0;\n\t\tunordered_set<int> segs2;\n\t\tfor (int i=0; i<7; i++) {\n\t\t\tif (vis2[0][i]!=-1 && segs2.find(vis2[0][i])==segs2.end()) {\n\t\t\t\tif (vis[m/7-1][i]!=-1) {\n\t\t\t\t\t//printf(\"%d %d\\n\", vis2[0][i], vis[m/7-1][i]);\n\t\t\t\t\tcon2++;\n\t\t\t\t\tsegs2.insert(vis2[0][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttot+=seg2-con2;\n\t}\n\tprintf(\"%lld\\n\", tot);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define DEBUG\n#ifdef DEBUG\n#define dump(...) cerr<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<make_tuple(__VA_ARGS__)<<\"\\n\";\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '{'; for(int i = 0; i < (int) v.size(); i++) o << v[i] << (i != (int)v.size()-1 ? \", \" : \"\"); o << \"}\";  return o; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\n#else\n#define dump(...)\n#endif\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  ll n, m, q; cin >> n >> m >> q;\n  ll h = (m + 6) / 7; // one shared block\n  ll period = h * 7; // height of period\n  ll full = n / period;\n  ll rest = n - full * period;\n  vector< vector<int> > f(period, vector<int>(7) );\n  auto used = f;\n  auto used2 = f;\n  auto used3 = f;\n\n  while(q--) {\n    ll a; cin >> a;\n    for(; a < period * 7; a += m) {\n      ll y = a / 7, x = a % 7;\n      f[y][x] = 1;\n    }\n  }\n  dump(f);\n\n  ll block = 0;\n  for(ll y = 0; y < period; y++)\n    for(ll x = 0; x < 7; x++) {\n      if(f[y][x]) continue;\n      if(used[y][x]) continue;\n      used[y][x] = 1;\n      queue<pair<ll, ll>> q;\n      q.emplace(y, x);\n      block++;\n      while(q.size()) {\n        ll yy = q.front().first, xx = q.front().second;\n        q.pop();\n        for(int d = 0; d < 4; d++) {\n          ll ny = yy + dy[d];\n          ll nx = xx + dx[d];\n          if(ny < 0 || period <= ny || nx < 0 || 7 <= nx) continue;\n          if(f[ny][nx]) continue;\n          if(used[ny][nx]) continue;\n          used[ny][nx] = 1;\n          q.emplace(ny, nx);\n        }\n      }\n    }\n\n  ll black = 0;\n  {\n    ll y = period - 1;\n    for(ll x = 0; x < 7; x++) {\n      if(f[y][x]) continue;\n      if(used2[y][x]) continue;\n      if(f[0][x]) continue;\n      used2[y][x] = 1;\n      queue<pair<ll, ll>> q;\n      q.emplace(y, x);\n      black++;\n      while(q.size()) {\n        ll yy = q.front().first, xx = q.front().second;\n        q.pop();\n        for(int d = 0; d < 4; d++) {\n          ll ny = yy + dy[d];\n          ll nx = xx + dx[d];\n          if(ny < 0 || period <= ny || nx < 0 || 7 <= nx) continue;\n          if(f[ny][nx]) continue;\n          if(used2[ny][nx]) continue;\n          used2[ny][nx] = 1;\n          q.emplace(ny, nx);\n        }\n      }\n    }\n  }\n\n  ll last = 0;\n  for(ll y = 0; y < rest; y++)\n    for(ll x = 0; x < 7; x++) {\n      if(f[y][x]) continue;\n      if(used3[y][x]) continue;\n      used3[y][x] = 1;\n      queue<pair<ll, ll>> q;\n      q.emplace(y, x);\n      last++;\n      while(q.size()) {\n        ll yy = q.front().first, xx = q.front().second;\n        q.pop();\n        for(int d = 0; d < 4; d++) {\n          ll ny = yy + dy[d];\n          ll nx = xx + dx[d];\n          if(ny < 0 || rest <= ny || nx < 0 || 7 <= nx) continue;\n          if(f[ny][nx]) continue;\n          if(used3[ny][nx]) continue;\n          used3[ny][nx] = 1;\n          q.emplace(ny, nx);\n        }\n      }\n    }\n  dump(full);\n  dump(block, black, last);\n\n  ll ans = 0;\n  ans += full * (block - black);\n  if(last) {\n    ans += last;\n  } else {\n    ans += black;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long N;\nint M, X, rows;\nvector<int> V;\nint dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\nbool b[200005][7], avail[100005], vis[200005][7];\n\nbool cv(int x, int y) {\n\tif (x < 0 || x >= rows) return false;\n\tif (y < 0 || y >= 7) return false;\n\tif (!b[x][y]) return false;\n\tif (vis[x][y]) return false;\n\treturn true;\n}\n\nvoid dfs(int x, int y) {\n\tvis[x][y] = 1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint newx = x + dir[i][0], newy = y + dir[i][1];\n\t\tif (cv(newx, newy)) dfs(newx, newy);\n\t}\n}\n\nint cc(long long x, long long y) { // count CCs from row x to y\n\tmemset(b, 0, sizeof(b));\n\tmemset(vis, 0, sizeof(vis));\n\tfor (long long r = x; r <= y; r++) {\n\t\tfor (int c = 0; c < 7; c++) {\n\t\t\tlong long idx = r * 7 + c;\n\t\t\tb[r-x][c] = avail[idx % M];\n\t\t}\n\t}\n\tint ans = 0;\n\trows = y - x + 1;\n\tfor (int r = 0; r < y - x + 1; r++) {\n\t\tfor (int c = 0; c < 7; c++) {\n\t\t\tif (b[r][c] && !vis[r][c]) {\n\t\t\t\tdfs(r, c);\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%lld%d%d\", &N, &M, &X);\n\tfor (int i = 0; i < M; i++) avail[i] = 1;\n\tfor (int i = 0; i < X; i++) {\n\t\tint a;\n\t\tscanf(\"%d\", &a);\n\t\tV.push_back(a);\n\t\tavail[a] = 0;\n\t}\n\tif (N <= 2 * M) {\n\t\tprintf(\"%d\\n\", cc(0, N - 1));\n\t\treturn 0;\n\t}\n\tint one = cc(0, M - 1);\n\tint two = cc(0, 2 * M - 1);\n\tint subtract = one * 2 - two;\n\tint rows = N / M;\n\tprintf(\"%lld\\n\", (long long)one * (rows - 1) - (long long)subtract * (rows - 1) + cc((long long)(rows - 1) * M, N - 1));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define val(p1,p2) p1>=0 && p1<m/7 && p2>=0 && p2<7 && !col[p1][p2] && vis[p1][p2]==-1\n#define val2(p1,p2) p1>=0 && p1<(n%m)/7 && p2>=0 && p2<7 && !col[p1][p2] && vis2[p1][p2]==-1\nusing namespace std;\n\nint main() {\n\tlong long n, m, q;\n\tscanf(\"%lld %lld %lld\", &n, &m, &q);\n\tn*=7;\n\tbitset<7> col[m/7];\n\tint vis[m/7][7];\n\tmemset(vis,-1,sizeof(vis));\n\tfor (int i=0; i<m; i++) col[i].reset();\n\tfor (int i=0; i<q; i++) {\n\t\tint aq; scanf(\"%d\", &aq);\n\t\tcol[aq/7][aq%7]=true;\n\t}\n\tint seg=0;\n\tqueue<pair<int, int> > qu;\n\tint xi[4]={1,0,-1,0}, yi[4]={0,1,0,-1};\n\tfor (int i=0; i<m/7; i++) {\n\t\tfor (int j=0; j<7; j++) {\n\t\t\tif (!col[i][j] && vis[i][j]==-1) {\n\t\t\t\tqu.push({i,j});\n\t\t\t\tvis[i][j]=seg;\n\t\t\t\twhile (!qu.empty()) {\n\t\t\t\t\tint x=qu.front().first, y=qu.front().second;\n\t\t\t\t\tqu.pop();\n\t\t\t\t\tfor (int k=0; k<4; k++) {\n\t\t\t\t\t\tint xx=x+xi[k], yy=y+yi[k];\n\t\t\t\t\t\tif (val(xx,yy)) {\n\t\t\t\t\t\t\tvis[xx][yy]=seg;\n\t\t\t\t\t\t\tqu.push({xx,yy});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tseg++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint con=0;\n\tunordered_set<int> segs;\n\tfor (int i=0; i<7; i++) {\n\t\tif (vis[0][i]!=-1 && segs.find(vis[0][i])==segs.end()) {\n\t\t\t//printf(\"%d %d %d\\n\", i, vis[0][i], vis[m/7-1][i]);\n\t\t\tif (vis[m/7-1][i]!=-1) {\n\t\t\t\tcon++;\n\t\t\t\tsegs.insert(vis[0][i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong long tot=(seg-con)*(n/m-1)+seg;\n\t//printf(\"%lld\\n\", tot);\n\t\n\tif (n%m!=0) {\n\t\tint vis2[(n%m)/7][7];\n\t\tmemset(vis2,-1,sizeof(vis2));\n\t\t\n\t\tint seg2=0;\n\tfor (int i=0; i<(n%m)/7; i++) {\n\t\tfor (int j=0; j<7; j++) {\n\t\t\tif (!col[i][j] && vis2[i][j]==-1) {\n\t\t\t\tqu.push({i,j});\n\t\t\t\tvis2[i][j]=seg2;\n\t\t\t\twhile (!qu.empty()) {\n\t\t\t\t\tint x=qu.front().first, y=qu.front().second;\n\t\t\t\t\tqu.pop();\n\t\t\t\t\tfor (int k=0; k<4; k++) {\n\t\t\t\t\t\tint xx=x+xi[k], yy=y+yi[k];\n\t\t\t\t\t\tif (val2(xx,yy)) {\n\t\t\t\t\t\t\tvis2[xx][yy]=seg2;\n\t\t\t\t\t\t\tqu.push({xx,yy});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tseg2++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\tint con2=0;\n\t\tunordered_set<int> segs2;\n\t\tfor (int i=0; i<7; i++) {\n\t\t\tif (vis2[0][i]!=-1 && segs2.find(vis2[0][i])==segs2.end()) {\n\t\t\t\tif (vis[m/7-1][i]!=-1) {\n\t\t\t\t\t//printf(\"%d %d\\n\", vis2[0][i], vis[m/7-1][i]);\n\t\t\t\t\tcon2++;\n\t\t\t\t\tsegs2.insert(vis2[0][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttot+=seg2-con2;\n\t}\n\tprintf(\"%lld\\n\", tot);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int UF_MAX = 700010;\n\nclass UF{\n\tint x[UF_MAX];\n\tint co;\n\t\npublic:\n\t\n\tUF(){\n\t\tfill(x,x+UF_MAX,-1);\n\t\tco = 0;\n\t}\n\t\n\tint boss(int a){\n\t\tint s = a;\n\t\twhile(x[s] > -1) s = x[s];\n\t\tif(s != a) x[a] = s;\n\t\treturn s;\n\t}\n\t\n\tvoid uni(int a , int b){\n\t\tint s = boss(a);\n\t\tint t = boss(b);\n\t\tif(s != t){\n\t\t\t++co;\n\t\t\tif(x[s] < x[t]){\n\t\t\t\tx[s] += x[t];\n\t\t\t\tx[t] = s;\n\t\t\t} else {\n\t\t\t\tx[t] += x[s];\n\t\t\t\tx[s] = t;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool find(int a , int b){\n\t\treturn boss(a) == boss(b);\n\t}\n\t\n\tint count(){\n\t\treturn co;\n\t}\n\t\n\tint member(int a){\n\t\treturn -x[boss(a)];\n\t}\n} uf , uf2;\n\nLL n;\nint q,m;\nbool b[700010];\nint a[700010];\n\nint main(){\n\tscanf(\"%lld%d%d\" , &n , &m , &q);\n\trepp(i,0,q){\n\t\tscanf(\"%d\" , a + i);\n\t\tb[a[i]] = 1;\n\t}\n\tif(m % 7 != 0){\n\t\trepp(k,1,7){\n\t\t\trepp(i,0,q){\n\t\t\t\tb[a[i]+k*m] = 1;\n\t\t\t}\n\t\t}\n\t\tq *= 7;\n\t\tm *= 7;\n\t}\n\tint z = 0;\n\trepp(i,0,m){\n\t\tif(i > 7 && !b[i-7] && !b[i]) uf.uni(i-7,i);\n\t\tif(i % 7 != 0 && !b[i-1] && !b[i]) uf.uni(i-1,i);\n\t}\n\tint p = m - uf.count() - q;\n\trepp(i,0,7){\n\t\trepp(j,i+1,7){\n\t\t\tif(uf.find(i,j)) uf2.uni(i,j);\n\t\t\tif(uf.find(m-7+i,m-7+j)) uf2.uni(7+i,7+j);\n\t\t}\n\t}\n\tint r = uf2.count();\n\trepp(i,0,7){\n\t\tif(!b[i] && !b[m-7+i]) uf2.uni(i,7+i);\n\t}\n\tr = uf2.count() - r;\n\tprintf(\"%lld\\n\" , (LL)p * (n*7/m) - (LL)r * (n*7/m-1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nlong n;int m,q,a[1<<17];\nbool f[7][1<<18];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid bfs(int x,int y,long _n)\n{\n\tqueue<pair<int,int> >P;\n\tf[x][y]=true;\n\tP.push(make_pair(x,y));\n\twhile(!P.empty())\n\t{\n\t\tpair<int,int>p=P.front();P.pop();\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint tx=p.first+dx[r],ty=p.second+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=7||ty>=_n||f[tx][ty])continue;\n\t\t\tf[tx][ty]=true;\n\t\t\tP.push(make_pair(tx,ty));\n\t\t}\n\t}\n}\nmain()\n{\n\tcin>>n>>m>>q;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tif(n<=100000)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong ans=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t\tbfs(i,j,n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\telse if(m%7==0)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,m/7*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,m/7*3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=count2-count1;\n\t\tlong syokou=count1-kousa*2;\n\t\tcout<<syokou+kousa*(n/(m/7))<<endl;\n\t}\n\telse\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<2*m;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<2*m;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,2*m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n-n/m*m+m;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count3=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n-n/m*m+m;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount3++;\n\t\t\t\t\tbfs(i,j,n-n/m*m+m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=count2-count1;\n\t\tlong syokou=count1-kousa;\n\t\tlong amari=count3-syokou-kousa;\n\t\tcout<<syokou+kousa*n/m+amari<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\n#include<algorithm>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include <clocale>\n#include<cmath>\n#include<sstream>\n#include<set>\n#include<stack>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int MX=1e6+10;\ntypedef long long ll;\ntypedef pair<int ,int> p;\nint co[MX][8],vis[MX][8],n;\nint dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nvector<p>vc[10];\nbool ok(int x,int y){\n\treturn !vis[x][y]&&!co[x][y]&&x<=n&&x>=1&&y<=7&&y>=1;\n}\nvoid dfs(int x,int y){\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tint tx=x+dir[i][0];\n\t\tint ty=y+dir[i][1];\n\t\tif(ok(tx,ty)){\n\t\t\tvis[tx][ty]=1;\n\t\t\tdfs(tx,ty);\n\t\t}\n\t}\n}\nint main(){\n\tint m,q,nu;\n\tcin>>n>>m>>q;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=7;j++){\n\t\t\tnu=(i*7+j-8)%m;\n\t\t\tvc[nu].push_back(p(i,j));\n\t\t}\n\t\twhile(q--){\n\t\t\tcin>>nu;\n\t\t\tfor(int i=0;i<vc[nu].size();i++)\n\t\t\t\tco[vc[nu][i].first][vc[nu][i].second]=1;\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=7;j++)\n\t\t\t\tif(!co[i][j]&&!vis[i][j]){\n\t\t\t\t\tvis[i][j]=1;\n\t\t        dfs(i,j);\n\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",ans);\n   // system(\"pause\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\n\nconst int M_N=400001;\n\nstruct UnionFind{\n    int par[M_N];\n    int rank[M_N];\n\n    void init(int n){\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            rank[i]=0;\n        }\n    }\n\n    int find(int x){\n        if(par[x]==x){\n            return x;\n        }\n        else{\n            return par[x]=find(par[x]);\n        }\n    }\n\n    void unite(int x,int y){\n        x=find(x);\n        y=find(y);\n        if(x==y) return;\n        if(rank[x]<rank[y]){\n            par[x]=y;\n        }\n        else{\n            par[y]=x;\n            if(rank[x]==rank[y]) rank[x]++;\n        }\n    }\n\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n};\n\n\nint main(){\n    LL n,m,q;cin >> n >> m >> q;\n    vector<int> a(q);\n    for (int i = 0; i < q; i++) {\n        cin >> a[i];\n    }\n    LL t = 7 * n / m;\n    vector<vector<int>> v(m / 7, vector<int> (7,0));\n    vector<vector<int>> vv(2 * m / 7, vector<int> (7,0));\n    for (int i = 0; i < q; i++) {\n        int y = a[i] / 7, x = a[i] % 7;\n        v[y][x] = 1;\n        vv[y][x] = 1;\n        vv[m / 7 + y][x] = 1;\n    }\n    auto f = [](vector<vector<int>> &a){\n        int h = a.size(), w = a[0].size();\n        UnionFind uf;\n        uf.init(h*w);\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if(j+1<w && a[i][j] == a[i][j+1]) uf.unite(i*7+j,i*7+j+1);\n                if(i+1<h && a[i][j] == a[i+1][j]) uf.unite(i*7+j,(i+1)*7+j);\n            }\n        }\n        int ret = 0;\n        for (int i = 0; i < h*w; i++) {\n            if(uf.find(i) == i && a[i/7][i%7] == 0) ret++;\n        }\n        return ret;\n    };\n    if(t == 1){\n        cout << f(v) << endl;\n    }\n    else if(t == 2){\n        cout << f(vv) << endl;\n    }\n    else{\n        cout << f(v) + (t - 1) * (f(vv) - f(v)) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace {\n    using ull = unsigned long long;\n    using ll = long long;\n    #define endl \"\\n\"\n\n    #define REP(i, n) for (ll i = 0; i < n; i++)\n    #define REPR(i, n) for (ll i = n; i >= 0; i--)\n    #define FOR(i, m, n) for (ll i = m; i < n; i++)\n    #define even(x) (x) % 2 == 0\n    #define odd(x) (x) % 2 != 0\n    #define all(x) x.begin(), x.end()\n    #define rall(x) x.rbegin(), x.rend()\n    #define pcnt __builtin_popcount\n    #define buli(x) __builtin_popcountll(x)\n    #define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n    #define inp(t, x) t x;cin>>x;\n    #define ithBit(n, i) ((n)>>(i) & 1)\n    #define INIT() cin.tie(0);ios::sync_with_stdio(0);cout<<fixed<<setprecision(20)\n\n    // these functions return the position of result of Binary Search.\n    #define LB(s, t, x) (int)(lower_bound(s, t, x) - s)\n    #define UB(s, t, x) (int)(upper_bound(s, t, x) - s)\n\n    #define M_PI 3.14159265358979323846\n    ll qp(ll a, ll b, int mo)\n    {\n        ll ans = 1;\n        do\n        {\n            if (b & 1)\n                ans = 1ll * ans * a % mo;\n            a = 1ll * a * a % mo;\n        } while (b >>= 1);\n        return ans;\n    }\n    ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\n    ll lcm(ll a, ll b)\n    {\n        ll temp = gcd(a, b);\n        return temp ? (a / temp * b) : 0;\n    }\n    int mDays[] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n    int dx8[] = {1, -1, 0, 0, 1, 1, -1, -1}, dy8[] = {0, 0, -1, 1, -1, 1, -1, 1};\n\n    template <typename F>\n    class\n    #if defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n        [[nodiscard]]\n    #elif defined(__GNUC__) && __GNUC_PREREQ(3, 4)\n        __attribute__((warn_unused_result))\n    #endif // defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n        FixPoint : F {\n            public :\n                explicit constexpr FixPoint(F &&f) noexcept : F(std::forward<F>(f)) {}\n\n            template <typename... Args>\n            constexpr decltype(auto)\n            operator()(Args &&... args) const {\n                return F::operator()(*this, std::forward<Args>(args)...);\n    } // namespace\n    }\n    ; // class FixPoint\n    template <typename F>\n    static inline constexpr decltype(auto)\n    makeFixPoint(F &&f) noexcept\n    {\n        return FixPoint<F>{std::forward<F>(f)};\n    }\n\n    template <typename T>\n    vector<T> make_v(size_t a) { return vector<T>(a); }\n    template <typename T, typename... Ts>\n    auto make_v(size_t a, size_t b, Ts... ts) { return vector<decltype(make_v<T>(b, ts...))>(a, make_v<T>(b, ts...)); }\n    template <typename T, typename V>\n    typename enable_if<is_class<T>::value == 0>::type\n    fill_v(T &t, const V &v) { t = v; }\n    template <typename T, typename V>\n    typename enable_if<is_class<T>::value != 0>::type\n    fill_v(T &t, const V &v) { for (auto &e : t) fill_v(e, v); }\n\n    template <class T>\n    bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\n    template <class T>\n    bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n\n    inline bool rangeCheck2D(int nx, int ny, int Width, int Height) { return nx >= 0 and nx < Width and ny >= 0 and ny < Height; }\n    \n    ll i_query(ll x)\n    {\n        cout << \"> \" << x << endl;\n        fflush(stdout);\n        ll ret;\n        cin >> ret;\n        return ret;\n    }\n    ll i_query_2(ll i)\n    {\n        cout << \"? \" << i << endl;\n        fflush(stdout);\n        ll ret;\n        cin >> ret;\n        return ret;\n    }\n    void i_answer(ll ans, ll d)\n    {\n        cout << \"! \" << ans << \" \" << d << endl;\n        fflush(stdout);\n    }\n} // namespace\n\nnamespace {\n    #define DUMPOUT cerr \n    #ifndef DEBUG_\n    #define dump(...)\n    #else\n    #define dump(...) DUMPOUT<<\"  \"; \\\n    DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl; \\\n    DUMPOUT<<\"    \"; \\\n    dump_func(__VA_ARGS__)\n    #endif \n    void dump_func() { DUMPOUT << endl; }\n    template <class Head, class... Tail>\n    void dump_func(Head&& head, Tail&&... tail)\n    {\n        DUMPOUT << head;\n        if (sizeof...(Tail) == 0) {\n            DUMPOUT << \" \";\n        }\n        else {\n            DUMPOUT << \", \";\n        }\n        dump_func(std::move(tail)...);\n    }\n    template <class T>\n    ostream &operator<<(ostream &os, const vector<T> &v)\n    {\n        for (auto i = begin(v); i != end(v); ++i)\n            os << *i << (i == end(v) - 1 ? \"\" : \" \");\n        return os;\n    }\n    template <class T>\n    void out2Dvector(vector<T> v) {\n        for (const auto& vv : v)\n            cout << vv << endl;\n    }\n    template <class T>\n    istream &operator>>(istream &is, vector<T> &v)\n    {\n        for (auto i = begin(v); i != end(v); ++i)\n            is >> *i;\n        return is;\n    }\n    template<typename T, typename U>\n    ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n        os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n        return os;\n    }\n    template<typename T, typename U>\n    ostream& operator << (ostream& os, map<T, U>& map_var) {\n        os << \"{\";\n        for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n            os << \"(\" << itr->first << \", \" << itr->second << \")\";\n            itr++;\n            if(itr != map_var.end()) os << \", \";\n            itr--;\n        }\n        os << \"}\";\n        return os;\n    }\n    template<typename T>\n    ostream& operator << (ostream& os, set<T>& set_var) {\n        os << \"{\";\n        for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n            os << *itr;\n            ++itr;\n            if(itr != set_var.end()) os << \", \";\n            itr--;\n        }\n        os << \"}\";\n        return os;\n    }\n}\n\n/*\n    lambda expression\n    auto f = [](int arg1, double arg2) { return ret; };\n    lambda recursion\n    auto result = makeFixPoint([&](auto rec, int pos, int v) -> int {\n        rec(pos, v);\n    })(0, 1);\n    auto func = makeFixPoint([]() -> int {});\n    int ret = func();\n\n    tuple binding\n    auto [x, y] = make_tuple(0, 0);\n    for pair\n    auto [a, b] = pair<int, int>({v1, v2});\n\n    bitset<N> bs(ini_val); // N must be constant\n    bs.reset(); // reset all\n*/\n\n\nint main(void)\n{\n    INIT(); // comment out for Interective Program\n\n    inp(ll, N); inp(ll, M); inp(ll, Q);\n    vector<ll> a(Q); cin >> a;\n\n    ll h = lcm(7, M) / 7 * 2;\n    auto f = make_v<char>(h, 7);\n    fill_v(f, 0);\n    auto visited = make_v<char>(h, 7);\n\n    REP(q, Q) {\n        ll p = a[q];\n        while (p < h * 7) {\n            f[p / 7][p % 7] = 1;\n            p += M;\n        }\n    }\n\n    auto func = [&](int h) {\n        fill_v(visited, 0);\n        ll cnt = 0;\n        REP(i, h) {\n            REP(j, 7) {\n                if (visited[i][j]) continue;\n                if (f[i][j] == 1) continue;\n                cnt++;\n                queue<pair<int, int>> q;\n                q.push({i, j});\n                while (q.size()) {\n                    int y = q.front().first, x = q.front().second; q.pop();\n                    visited[y][x] = 1;\n                    REP(k, 4) {\n                        int ny = y + dy[k], nx = x + dx[k];\n                        if (not rangeCheck2D(nx, ny, 7, h)) continue;\n                        if (visited[ny][nx]) continue;\n                        if (f[ny][nx] == 1) continue;\n                        q.push({ny, nx});\n                    }\n                }\n            }\n        }\n        return cnt;\n    };\n\n    ll aa = func(h / 2);\n    ll d = func(h) - aa;\n    ll k = N / (lcm(7, M) / 7);\n    cout << aa + d * (k - 1) << endl;\n\n    return 0;\n}\n//*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nlong n;int m,q,a[1<<17];\nbool f[7][1<<17];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid bfs(int x,int y,long _n)\n{\n\tqueue<pair<int,int> >P;\n\tf[x][y]=true;\n\tP.push(make_pair(x,y));\n\twhile(!P.empty())\n\t{\n\t\tpair<int,int>p=P.front();P.pop();\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint tx=p.first+dx[r],ty=p.second+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=7||ty>=_n||f[tx][ty])continue;\n\t\t\tf[tx][ty]=true;\n\t\t\tP.push(make_pair(tx,ty));\n\t\t}\n\t}\n}\nmain()\n{\n\tcin>>n>>m>>q;\n\tif(n<=100000)\n\t{\n\t\tfor(int i=0;i<q;i++)\n\t\t{\n\t\t\tcin>>a[i];\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong ans=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t\tbfs(i,j,n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\telse if(m%7==0)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+1)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,m/7*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,m/7*3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=count2-count1;\n\t\tlong syokou=count1-kousa*2;\n\t\tcout<<syokou+kousa*(n/(m/7))<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 666666\nll n;\nint m,q,a[SZ];\nbool cov[SZ];\nint ff[SZ];\nint gf(int x) {return (ff[x]==-1)?x:ff[x]=gf(ff[x]);}\nvoid uni(int a,int b)\n{int ga=gf(a),gb=gf(b);if(ga^gb)ff[ga]=gb;}\nint main()\n{\n\tmemset(ff,-1,sizeof(ff));\n\tscanf(\"%lld%d%d\",&n,&m,&q);\n\tfor(int i=1;i<=q;i++)\n\tscanf(\"%d\",a+i),cov[a[i]]=1;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif(cov[i])continue;\n\t\tif(i+7<m&&!cov[i+7]) uni(i,i+7);\n\t\tif(i%7!=6&&i+1<m&&!cov[i+1]) uni(i,i+1);\n\t}\n\tint ans1=0;\n\tfor(int i=0;i<m;i++)\n\t\tif(!cov[i]) ans1+=gf(i)==i;\n\tmemset(ff,-1,sizeof(ff));\n\tfor(int i=0;i<m+m;i++)\n\t{\n\t\tif(cov[i%m])continue;\n\t\tif(i+7<m&&!cov[(i+7)%m]) uni(i,i+7);\n\t\tif(i%7!=6&&i+1<m&&!cov[(i+1)%m]) uni(i,i+1);\n\t}\n\tint ans2=0;\n\tfor(int i=0;i<m+m;i++)\n\t\tif(!cov[i]) ans2+=gf(i)==i;\n\tll tm=7*n/m;\n\tll ans=(tm-1)*(ans2-ans1)+ans1;\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<map>\n#include<string>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n//#define scanf scanf_s\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\nconst llint mod=1000000007;\n\n\nint main(void){\n\tllint N,ans;\n\tint M,q,i,j,a,ansa,ansb,ok=0;\n\tqueue<int> que;\n\tvector<int> nuru;\n\tvector<int> nuran;\n\tset<int> siro;\n\tscanf(\"%lld %d %d\",&N,&M,&q);\n\tfor(i=0;i<q;i++){\n\t\tscanf(\"%d\",&a);\n\t\tnuru.pub(a);\n\t}\n\tsort(nuru.begin(),nuru.end());\n\tif(M%7!=0){ \n\t\tfor(i=0;i<q;i++){\n\t\t\tfor(j=1;j<7;j++){\n\t\t\t\tnuru.pub(nuru[i]+M*j);\n\t\t\t}\n\t\t}\n\t\tM*=7;ok=1;\n\t}j=0;\n\tfor(i=0;i<M;i++){\n\t\tif(j!=nuru.size()&&nuru[j]<i){j++;}\n\t\tif(j==nuru.size()||nuru[j]>i){nuran.pub(i);}\n\t}\n\t\n\tfor(i=0;i<nuran.size();i++){\n\t\tsiro.insert(nuran[i]);\n\t}\n\tansa=0;\n\twhile(siro.size()!=0){\n\t\tque.push(*siro.begin());\n\t\twhile(!que.empty()){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tif(siro.find(a)==siro.end()){continue;}\n\t\t\tif(a-7>=0&&siro.find(a-7)!=siro.end()){ que.push(a-7); }\n\t\t\tif(a+7<M&&siro.find(a+7)!=siro.end()){ que.push(a+7); }\n\t\t\tif(a%7!=0&&siro.find(a-1)!=siro.end()){ que.push(a-1); }\n\t\t\tif(a%7!=6&&siro.find(a+1)!=siro.end()){ que.push(a+1); }\n\t\t\tsiro.erase(a);\n\t\t}\n\t\tansa++;\n\t}\n\n\tfor(i=0;i<nuran.size();i++){\n\t\tsiro.insert(nuran[i]);siro.insert(nuran[i]+M);\n\t}\n\tansb=0;\n\twhile(siro.size()!=0){\n\t\tque.push(*siro.begin());\n\t\twhile(!que.empty()){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tif(siro.find(a)==siro.end()){continue;}\n\t\t\tif(a-7>=0&&siro.find(a-7)!=siro.end()){ que.push(a-7); }\n\t\t\tif(a+7<2*M&&siro.find(a+7)!=siro.end()){ que.push(a+7); }\n\t\t\tif(a%7!=0&&siro.find(a-1)!=siro.end()){ que.push(a-1); }\n\t\t\tif(a%7!=6&&siro.find(a+1)!=siro.end()){ que.push(a+1); }\n\t\t\tsiro.erase(a);\n\t\t}\n\t\tansb++;\n\t}\n\tans=(ansb-ansa)*N*7/M+(2*ansa-ansb);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <sstream>\n# include <cstdio>\n# include <cstdlib>\n# include <algorithm>\n# include <string>\n# include <cstring>\n# include <cmath>\n# include <stack>\n# include <queue>\n# include <vector>\n# include <list>\n# include <map>\n# include <set>\n# include <deque>\n# include <iterator>\n# include <functional>\n# include <bitset>\n# include <climits>\n# include <ctime>\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define odd(x) ((x)%2)\ntypedef long long ll;\ntypedef long double ld;\nconst ll oo=2*1000*1000*1000;\nconst int _cnt=1000*1000;\nconst int _p=1000*1000*1000+7;\nint o(int x) { return x%_p; }\nint gcd(int a,int b) { return (b)?gcd(b,a%b):a; }\nint lcm(int a,int b) { return a/gcd(a,b)*b; }\nusing namespace std;\n\nvoid file_put(){\n\tfreopen(\"filename.in\",\"r\",stdin);\n\tfreopen(\"filename.out\",\"w\",stdout);\n}\n\nint n,m,q,a[15],x,ans=0;\n\nint main(){\n\t//file_put();\n\t\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tm=7;\n\tfor (int i=1; i<=n; i++) {\n\t\tscanf(\"%d\",&x);\n\t\tx%=m;\n\t\ta[x]=1;\n\t}\n\ta[7]=1;\n\tfor (int i=1; i<=7; i++) ans+=(a[i]>0 && a[i-1]==0);\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace {\n    using ull = unsigned long long;\n    using ll = long long;\n    #define endl \"\\n\"\n\n    #define REP(i, n) for (ll i = 0; i < n; i++)\n    #define REPR(i, n) for (ll i = n; i >= 0; i--)\n    #define FOR(i, m, n) for (ll i = m; i < n; i++)\n    #define even(x) (x) % 2 == 0\n    #define odd(x) (x) % 2 != 0\n    #define all(x) x.begin(), x.end()\n    #define rall(x) x.rbegin(), x.rend()\n    #define pcnt __builtin_popcount\n    #define buli(x) __builtin_popcountll(x)\n    #define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n    #define inp(t, x) t x;cin>>x;\n    #define ithBit(n, i) ((n)>>(i) & 1)\n    #define INIT() cin.tie(0);ios::sync_with_stdio(0);cout<<fixed<<setprecision(20)\n\n    // these functions return the position of result of Binary Search.\n    #define LB(s, t, x) (int)(lower_bound(s, t, x) - s)\n    #define UB(s, t, x) (int)(upper_bound(s, t, x) - s)\n\n    #define M_PI 3.14159265358979323846\n    ll qp(ll a, ll b, int mo)\n    {\n        ll ans = 1;\n        do\n        {\n            if (b & 1)\n                ans = 1ll * ans * a % mo;\n            a = 1ll * a * a % mo;\n        } while (b >>= 1);\n        return ans;\n    }\n    ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\n    ll lcm(ll a, ll b)\n    {\n        ll temp = gcd(a, b);\n        return temp ? (a / temp * b) : 0;\n    }\n    int mDays[] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n    int dx8[] = {1, -1, 0, 0, 1, 1, -1, -1}, dy8[] = {0, 0, -1, 1, -1, 1, -1, 1};\n\n    template <typename F>\n    class\n    #if defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n        [[nodiscard]]\n    #elif defined(__GNUC__) && __GNUC_PREREQ(3, 4)\n        __attribute__((warn_unused_result))\n    #endif // defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n        FixPoint : F {\n            public :\n                explicit constexpr FixPoint(F &&f) noexcept : F(std::forward<F>(f)) {}\n\n            template <typename... Args>\n            constexpr decltype(auto)\n            operator()(Args &&... args) const {\n                return F::operator()(*this, std::forward<Args>(args)...);\n    } // namespace\n    }\n    ; // class FixPoint\n    template <typename F>\n    static inline constexpr decltype(auto)\n    makeFixPoint(F &&f) noexcept\n    {\n        return FixPoint<F>{std::forward<F>(f)};\n    }\n\n    template <typename T>\n    vector<T> make_v(size_t a) { return vector<T>(a); }\n    template <typename T, typename... Ts>\n    auto make_v(size_t a, size_t b, Ts... ts) { return vector<decltype(make_v<T>(b, ts...))>(a, make_v<T>(b, ts...)); }\n    template <typename T, typename V>\n    typename enable_if<is_class<T>::value == 0>::type\n    fill_v(T &t, const V &v) { t = v; }\n    template <typename T, typename V>\n    typename enable_if<is_class<T>::value != 0>::type\n    fill_v(T &t, const V &v) { for (auto &e : t) fill_v(e, v); }\n\n    template <class T>\n    bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\n    template <class T>\n    bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n\n    inline bool rangeCheck2D(int nx, int ny, int Width, int Height) { return nx >= 0 and nx < Width and ny >= 0 and ny < Height; }\n    \n    ll i_query(ll x)\n    {\n        cout << \"> \" << x << endl;\n        fflush(stdout);\n        ll ret;\n        cin >> ret;\n        return ret;\n    }\n    ll i_query_2(ll i)\n    {\n        cout << \"? \" << i << endl;\n        fflush(stdout);\n        ll ret;\n        cin >> ret;\n        return ret;\n    }\n    void i_answer(ll ans, ll d)\n    {\n        cout << \"! \" << ans << \" \" << d << endl;\n        fflush(stdout);\n    }\n} // namespace\n\nnamespace {\n    #define DUMPOUT cerr \n    #ifndef DEBUG_\n    #define dump(...)\n    #else\n    #define dump(...) DUMPOUT<<\"  \"; \\\n    DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl; \\\n    DUMPOUT<<\"    \"; \\\n    dump_func(__VA_ARGS__)\n    #endif \n    void dump_func() { DUMPOUT << endl; }\n    template <class Head, class... Tail>\n    void dump_func(Head&& head, Tail&&... tail)\n    {\n        DUMPOUT << head;\n        if (sizeof...(Tail) == 0) {\n            DUMPOUT << \" \";\n        }\n        else {\n            DUMPOUT << \", \";\n        }\n        dump_func(std::move(tail)...);\n    }\n    template <class T>\n    ostream &operator<<(ostream &os, const vector<T> &v)\n    {\n        for (auto i = begin(v); i != end(v); ++i)\n            os << *i << (i == end(v) - 1 ? \"\" : \" \");\n        return os;\n    }\n    template <class T>\n    void out2Dvector(vector<T> v) {\n        for (const auto& vv : v)\n            cout << vv << endl;\n    }\n    template <class T>\n    istream &operator>>(istream &is, vector<T> &v)\n    {\n        for (auto i = begin(v); i != end(v); ++i)\n            is >> *i;\n        return is;\n    }\n    template<typename T, typename U>\n    ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n        os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n        return os;\n    }\n    template<typename T, typename U>\n    ostream& operator << (ostream& os, map<T, U>& map_var) {\n        os << \"{\";\n        for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n            os << \"(\" << itr->first << \", \" << itr->second << \")\";\n            itr++;\n            if(itr != map_var.end()) os << \", \";\n            itr--;\n        }\n        os << \"}\";\n        return os;\n    }\n    template<typename T>\n    ostream& operator << (ostream& os, set<T>& set_var) {\n        os << \"{\";\n        for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n            os << *itr;\n            ++itr;\n            if(itr != set_var.end()) os << \", \";\n            itr--;\n        }\n        os << \"}\";\n        return os;\n    }\n}\n\n/*\n    lambda expression\n    auto f = [](int arg1, double arg2) { return ret; };\n    lambda recursion\n    auto result = makeFixPoint([&](auto rec, int pos, int v) -> int {\n        rec(pos, v);\n    })(0, 1);\n    auto func = makeFixPoint([]() -> int {});\n    int ret = func();\n\n    tuple binding\n    auto [x, y] = make_tuple(0, 0);\n    for pair\n    auto [a, b] = pair<int, int>({v1, v2});\n\n    bitset<N> bs(ini_val); // N must be constant\n    bs.reset(); // reset all\n*/\n\n\nint main(void)\n{\n    INIT(); // comment out for Interective Program\n\n    inp(ll, N); inp(ll, M); inp(ll, Q);\n    vector<ll> a(Q); cin >> a;\n\n    ll h = lcm(7, M) / 7 * 2;\n    auto f = make_v<char>(h, 7);\n    fill_v(f, 0);\n    auto visited = make_v<char>(h, 7);\n\n    REP(q, Q) {\n        ll p = a[q];\n        while (p < h * 7) {\n            f[p / 7][p % 7] = 1;\n            p += M;\n        }\n    }\n\n    auto dfs = makeFixPoint([&](auto dfs, int cy, int cx, int mh) -> void {\n        visited[cy][cx] = 1;\n        REP(k, 4) {\n            int ny = cy + dy[k], nx = cx + dx[k];\n            if (not rangeCheck2D(nx, ny, 7, mh)) continue;\n            if (visited[ny][nx]) continue;\n            if (f[ny][nx] == 1) continue;\n            dfs(ny, nx, mh);\n        }\n    });\n\n    auto func = [&](int mh) {\n        fill_v(visited, 0);\n        ll cnt = 0;\n        REP(i, mh) {\n            REP(j, 7) {\n                if (visited[i][j]) continue;\n                if (f[i][j] == 1) continue;\n                cnt++;\n                dfs(i, j, mh);\n            }\n        }\n        return cnt;\n    };\n\n    ll aa = func(h / 2);\n    ll d = func(h) - aa;\n    ll k = N / (lcm(7, M) / 7);\n    cout << aa + d * (k - 1) << endl;\n\n    return 0;\n}\n//*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define  inc(i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define  dec(i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define UB upper_bound\n#define LB lower_bound\n#define PQ priority_queue\n\n#define  ALL(v)  v.begin(),  v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define  FOR(it, v) for(auto it =  v.begin(); it !=  v.end(); ++it)\n#define RFOR(it, v) for(auto it = v.rbegin(); it != v.rend(); ++it)\n\ntemplate<typename T> bool   setmin(T & a, T b) { if(b <  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool   setmax(T & a, T b) { if(b >  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmineq(T & a, T b) { if(b <= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmaxeq(T & a, T b) { if(b >= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, m, q, a[100000];\nint b[1000000][7];\n\nvoid dfs(int pi, int pj) {\n\tint di[] = { 1, 0, -1,  0 };\n\tint dj[] = { 0, 1,  0, -1 };\n\t\n\tinc(k, 4) {\n\t\tint i = pi + di[k];\n\t\tint j = pj + dj[k];\n\t\tif(inID(i, 0, n) && inID(j, 0, 7) && b[i][j] == 0) {\n\t\t\tb[i][j] = 1;\n\t\t\tdfs(i, j);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> m >> q;\n\tinc(i, q) { cin >> a[i]; }\n\t\n\t// if(n > 1000000) { return -1; }\n\t\n\tinc(i, q) {\n\t\tint x = a[i];\n\t\tinc(j, 7 * n) {\n\t\t\tb[x / 7][x % 7] = 1;\n\t\t\t\n\t\t\tx += m;\n\t\t\tif(j >= 7 * n) { break; }\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tinc(i, n) {\n\tinc(j, 7) {\n\t\tif(b[i][j] == 0) {\n\t\t\tb[i][j] = 1;\n\t\t\tans++;\n\t\t\tdfs(i, j);\n\t\t}\n\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\t\nusing namespace std;\nll N;\nint M,Q;\nconst int MAX_M=1e5;\nbool a[MAX_M];\nbool flg[MAX_M*14];\nvoid bfs(int s,int n){\n\tqueue<int> que;\n\tque.push(s);\n\tflg[s]=true;\n\twhile(!que.empty()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tREP(dir,4){\n\t\t\tint v2=-1;\n\t\t\tswitch(dir){\n\t\t\t\tcase 0:\n\t\t\t\tif(v%7>0){\n\t\t\t\t\tv2=v-1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\tif(v%7<6 && v+1<n){\n\t\t\t\t\tv2=v+1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tif(v>=7){\n\t\t\t\t\tv2=v-7;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\tif(v+7<n){\n\t\t\t\t\tv2=v+7;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(v!=-1 && !flg[v2] && !a[v2%M]){\n\t\t\t\tflg[v2]=true;\n\t\t\t\tque.push(v2);\n\t\t\t}\n\t\t}\n\t}\n}\nll cntcon(int n){\n\tll ret=0;\n\tmemset(flg,false,sizeof(flg));\n//\tcout<<\"cntcon \"<<n<<endl;\n\tREP(i,n){\n//\t\tcout<<i<<\" \";\n\t\tif(!flg[i] && !a[i%M]){\n\t\t\tret++;\n\t\t\tbfs(i,n);\n\t\t}\n\t}\n//\tcout<<endl;\n\treturn ret;\n}\n\nint main(){\n\tcin>>N>>M>>Q;\n\tREP(i,Q){\n\t\tint ta;\n\t\tcin>>ta;\n\t\ta[ta]=true;\n\t}\n\tif(N<M){\n\t\tcout<<cntcon(7*N)<<endl;\n\t}else{\n\t\tll k=N/M;\n\t\tll c1=cntcon(7*M),c2=cntcon(14*M);\n\t\tcout<<c1+(k-1)*(c2-c1)+cntcon((int)(7*N-7*k*M+7*M))-c1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define maxn 700010\nint a[maxn];\nbool col[maxn][7], vis[maxn][7];\ntypedef long long ll;\nstruct que {\n\tint x, y;\n} qu[maxn * 7];\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\nint up[7], dw[7], Fa[14];\nint Find(int x) {return Fa[x] == x ? x : Fa[x] = Find(Fa[x]);}\nint main()\n{\n\tll n;\n\tint m, q; scanf(\"%lld%d%d\", &n, &m, &q);\n\tfor (int i = 1; i <= q; ++i) scanf(\"%d\", &a[i]);\n\tif (m % 7)\n\t{\n\t\tint nq = q;\n\t\tfor (int i = 1; i <= q; ++i)\n\t\t\tfor (int j = 1; j < 7; ++j)\n\t\t\t\ta[++nq] = a[i] + j * m;\n\t\tm *= 7; q = nq;\n\t}\n\tint mm = m / 7, cnt = 0;\n\tfor (int i = 1; i <= q; ++i) col[a[i] / 7][a[i] % 7] = 1;\n\n\tfor (int i = 0; i < mm; ++i)\n\t\tfor (int j = 0; j < 7; ++j)\n\t\t\tif (!vis[i][j] && !col[i][j])\n\t\t\t{\n\t\t\t\t++cnt;\n\t\t\t\tint head = 0, tail = 1; qu[1] = (que) {i, j}; vis[i][j] = 1;\n\t\t\t\twhile (head < tail)\n\t\t\t\t{\n\t\t\t\t\tque now = qu[++head];\n\t\t\t\t\tfor (int k = 0, nx, ny; k < 4; ++k)\n\t\t\t\t\t{\n\t\t\t\t\t\tnx = now.x + dx[k]; ny = now.y + dy[k];\n\t\t\t\t\t\tif (nx >= 0 && nx < mm && ny >= 0 && ny < 7 && !vis[nx][ny] && !col[nx][ny])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tqu[++tail] = (que) {nx, ny};\n\t\t\t\t\t\t\tvis[nx][ny] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\tprintf(\"%d\\n\", cnt);\n\tint pcnt = 0, cnt2 = 0;\n\tfor (int i = 0; i < 7; ++i) !col[0][i] ? i == 0 || col[0][i - 1] ? up[i] = ++pcnt : up[i] = pcnt : 0;\n\tfor (int i = 0; i < 7; ++i) !col[mm - 1][i] ? i == 0 || col[mm - 1][i - 1] ? dw[i] = ++pcnt : dw[i] = pcnt : 0;\n\tfor (int i = 1; i <= pcnt; ++i) Fa[i] = i;\n\n//\tfor (int i = 0; i < 7; ++i) printf(\"%d %d\\n\", up[i], dw[i]);\n\tfor (int i = 0; i < 7; ++i)\n\t\tif (up[i] && dw[i] && Find(up[i]) != Find(dw[i]))\n\t\t{\n\t\t\tFa[Find(up[i])] = Find(dw[i]);\n\t\t\t++cnt2;\n\t\t}\n//\tprintf(\"%d\\n\", cnt2);\n\twhile (n % mm) ;\n\tprintf(\"%lld\\n\", 1ll * cnt * (n / mm) - 1ll * (n / mm - 1) * cnt2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define  inc(i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define  dec(i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define UB upper_bound\n#define LB lower_bound\n#define PQ priority_queue\n\n#define  ALL(v)  v.begin(),  v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define  FOR(it, v) for(auto it =  v.begin(); it !=  v.end(); ++it)\n#define RFOR(it, v) for(auto it = v.rbegin(); it != v.rend(); ++it)\n\ntemplate<typename T> bool   setmin(T & a, T b) { if(b <  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool   setmax(T & a, T b) { if(b >  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmineq(T & a, T b) { if(b <= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmaxeq(T & a, T b) { if(b >= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, m, q, a[100000];\nint b[100000][7];\n\nvoid dfs(int pi, int pj) {\n\tint di[] = { 1, 0, -1,  0 };\n\tint dj[] = { 0, 1,  0, -1 };\n\t\n\tinc(k, 4) {\n\t\tint i = pi + di[k];\n\t\tint j = pj + dj[k];\n\t\tif(inID(i, 0, n) && inID(j, 0, 7) && b[i][j] == 0) {\n\t\t\tb[i][j] = 1;\n\t\t\tdfs(i, j);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> m >> q;\n\tinc(i, q) { cin >> a[i]; }\n\t\n\tif(n > 100000) { return 1; }\n\t\n\tinc(i, q) {\n\t\tint x = a[i];\n\t\tinc(j, 7 * n) {\n\t\t\tb[x / 7][x % 7] = 1;\n\t\t\t\n\t\t\tx += m;\n\t\t\tif(x >= 7 * n) { break; }\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tinc(i, n) {\n\tinc(j, 7) {\n\t\tif(b[i][j] == 0) {\n\t\t\tb[i][j] = 1;\n\t\t\tans++;\n\t\t\tdfs(i, j);\n\t\t}\n\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int M = 1e5 + 5;\nlong long n;\nint m , q;\nint mark[M];\nint inp;\nstruct data{\n\tint top[7];\n\tint bot[7];\n\tlong long ans;\n\tvoid compress(){\n\t\tmap < int , int > mp;\n\t\tmp.clear();\n\t\tfor(int i = 0 ; i < 7 ; ++i){\n\t\t\tif(top[i] != -1){\n\t\t\t\tmp[top[i]];\n\t\t\t}\n\t\t\tif(bot[i] != -1){\n\t\t\t\tmp[bot[i]];\n\t\t\t}\n\t\t}\n\t\tint val = 0;\n\t\tfor(auto &it : mp){\n\t\t\tit.second = val++;\n\t\t}\n\t\tfor(int i = 0 ; i < 7 ; ++i){\n\t\t\tif(top[i] != -1){\n\t\t\t\ttop[i] = mp[top[i]];\n\t\t\t}\n\t\t\tif(bot[i] != -1){\n\t\t\t\tbot[i] = mp[bot[i]];\n\t\t\t}\n\t\t}\n\t}\n};\nint parent[M];\nint find(int node){\n\tif(parent[node] == node){\n\t\treturn node;\n\t}\n\treturn parent[node] = find(parent[node]);\n}\nbool join(int a , int b){\n\tif(find(a) == find(b)){\n\t\treturn 0;\n\t}\n\tparent[find(a)] = find(b);\n\treturn 1;\n}\ndata getbase(){\n\tfor(int i = 0 ; i < m ; ++i){\n\t\tparent[i] = i;\n\t}\n\tint ans = m - q;\n\tfor(int i = 0 ; i < m ; ++i){\n\t\tif(!mark[i]){\n\t\t\tif(i + 1 < m && !mark[i + 1]){\n\t\t\t\tans -= join(i , i + 1);\n\t\t\t}\n\t\t\tif(i + 7 < m && !mark[i + 7]){\n\t\t\t\tans -= join(i , i + 7);\n\t\t\t}\n\t\t}\n\t}\n\tdata res;\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(mark[i]){\n\t\t\tres.top[i] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.top[i] = find(i);\n\t\t}\n\t}\n\tfor(int i = m - 7 ; i < m ; ++i){\n\t\tif(mark[i]){\n\t\t\tres.bot[i - m + 7] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.bot[i - m + 7] = find(i);\n\t\t}\n\t}\n\tres.ans = ans;\n\tres.compress();\n\treturn res;\n}\ndata base;\ndata combine(data lft , data rgt){\n\tfor(int i = 0 ; i < 30 ; ++i){\n\t\tparent[i] = i;\n\t}\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(rgt.top[i] != -1){\n\t\t\trgt.top[i] += 14;\n\t\t}\n\t\tif(rgt.bot[i] != -1){\n\t\t\trgt.bot[i] += 14;\n\t\t}\n\t}\n\tdata res;\n\tres.ans = lft.ans + rgt.ans;\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(lft.bot[i] != -1 && rgt.top[i] != -1){\n\t\t\tres.ans -= join(lft.bot[i] , rgt.top[i]);\n\t\t}\n\t}\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(lft.top[i] == -1){\n\t\t\tres.top[i] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.top[i] = find(lft.top[i]);\n\t\t}\n\t\tif(rgt.bot[i] == -1){\n\t\t\tres.bot[i] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.bot[i] = find(rgt.bot[i]);\n\t\t}\n\t}\n\tres.compress();\n\treturn res;\n}\ndata solve(long long n){\n\tif(n == 1){\n\t\treturn base;\n\t}\n\tif(n & 1){\n\t\treturn combine(solve(n - 1) , base);\n\t}\n\tdata tmp = solve(n >> 1);\n\treturn combine(tmp , tmp);\n}\nint main(){\n\tscanf(\"%lld %d %d\" , &n , &m , &q);\n\tfor(int i = 1 ; i <= q ; ++i){\n\t\tscanf(\"%d\" , &inp);\n\t\tmark[inp] = 1;\n\t}\n\tbase = getbase();\n\tprintf(\"%lld\\n\" , solve(7 * n / m).ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nbool latte[100000][7];\nbool malta[200000][7];\n\nint main()\n{\n  int N, M, Q, A[100000];\n  cin >> N >> M >> Q;\n  for(int i = 0; i < Q; i++) cin >> A[i];\n\n\n  UnionFind tree1(100000 * 7), tree2(200000 * 7);\n  int sz = M / 7;\n  for(int i = 0; i < Q; i++) {\n    int col = A[i] / 7, row = A[i] % 7;\n    int col2 = A[i] / 7 + sz, row2 = A[i] % 7;\n    latte[col][row] = true;\n    malta[col][row] = true;\n    malta[col2][row2] = true;\n  }\n\n  for(int i = 0; i < sz; i++) {\n    for(int j = 0; j < 7; j++) {\n      if(j + 1 < 7 && !latte[i][j] && !latte[i][j + 1]) {\n        tree1.unite(i * 7 + j, i * 7 + j + 1);\n      }\n      if(i + 1 < sz && !latte[i][j] && !latte[i + 1][j]) {\n        tree1.unite(i * 7 + j, i * 7 + j + 7);\n      }\n    }\n  }\n\n\n  for(int i = 0; i < 2 * sz; i++) {\n    for(int j = 0; j < 7; j++) {\n      if(j + 1 < 7 && !malta[i][j] && !malta[i][j + 1]) {\n        tree2.unite(i * 7 + j, i * 7 + j + 1);\n      }\n      if(i + 1 < sz && !malta[i][j] && !malta[i + 1][j]) {\n        tree2.unite(i * 7 + j, i * 7 + j + 7);\n      }\n    }\n  }\n\n\n  int ret1 = 0, ret2 = 0;\n  for(int i = 0; i < sz; i++) {\n    for(int j = 0; j < 7; j++) {\n      if(tree1.find(i * 7 + j) == i * 7 + j && !latte[i][j]) ret1++;\n    }\n  }\n  for(int i = 0; i < 2 * sz; i++) {\n    for(int j = 0; j < 7; j++) {\n      if(tree2.find(i * 7 + j) == i * 7 + j && !malta[i][j]) ret2++;\n    }\n  }\n\n  int add = ret2 - ret1;\n\n  cout << ret1 + (1LL * add * 7 * N / M - add) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long int N, M, Q, a[114514], g[114514], c[114514];\n\nvoid unite(int n, int m);\nvoid unite2(int n, int m);\n\nint connected(){\n    long long int ret = 0;\n    unordered_set<long long int> s{-1}, t{-1}, r;\n    //for(int i = 0; i < M; ++i){\n    //    cout << g[i] << (((i + 1) % 7) ? \" \" : \"\\r\\n\");\n    //}\n    for(int i = 0; i < M; ++i){\n        if(!t.count(g[i])){\n            t.insert(g[i]);\n            unite(i, g[i]);\n        }\n    }\n    //for(int i = 0; i < M; ++i){\n    //    cout << g[i] << (((i + 1) % 7) ? \" \" : \"\\n\");\n    //}\n    for(int i = 0; i < M; ++i){\n        if(!s.count(c[i])){\n            s.insert(c[i]);\n            unite2(i, c[i]);\n        }\n    }\n    s.erase(-1);\n    t.erase(-1);\n    ret = s.size() + t.size() * (7 * N / M - 1);\n    for(int i = 0; i < 7; ++i){\n        if(g[i] != -1 && g[i] == g[i + M - 7]){\n            r.insert(g[i]);\n        }\n    }\n    ret -= r.size() * (7 * N / M - 1);\n    return ret;\n}\n\nvoid unite(int n, int m){\n    if(n < 0 || n >= M || g[n] == -1 || (g[n] == m && n != m)){\n        return ;\n    }\n    g[n] = m;\n    if(n % 7)unite(n - 1, m);\n    if(++n % 7)unite(n, m);\n    if(n < M - 7)unite(--n + 7, m);\n    if(n > 6)unite(n - 7, m);\n}\n\nvoid unite2(int n, int m){\n    if(n < 0 || n >= M || c[n] == -1 || (c[n] == m && n != m)){\n        return ;\n    }\n    c[n] = m;\n    if(n % 7)unite2(n - 1, m);\n    if(++n % 7)unite2(n, m);\n    unite2((--n + 7) % M, m);\n    unite2((n - 7 + M) % M, m);\n}\n\nint main(){\n    scanf(\"%lld%lld%lld\", &N, &M, &Q);\n    if(M % 7 == 0){\n        for(int i = 0; i < M; ++i)g[i] = c[i] = i;\n        for(int i = 0; i < Q; ++i){\n            scanf(\"%lld\", a + i);\n            g[a[i]] = -1;\n            c[a[i]] = -1;\n        }\n        cout << connected() << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<map>\n#include<string>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n//#define scanf scanf_s\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\nconst llint mod=1000000007;\n\n\nint main(void){\n\tllint N,ans;\n\tint M,q,i,j,a,ansa,ansb,ok=0;\n\tqueue<int> que;\n\tvector<int> nuru;\n\tset<int> siro;\n\tscanf(\"%lld %d %d\",&N,&M,&q);\n\tfor(i=0;i<q;i++){\n\t\tscanf(\"%d\",&a);\n\t\tnuru.pub(a);\n\t}\n\t\n\tif(M%7!=0){ \n\t\tfor(i=0;i<q;i++){\n\t\t\tfor(j=1;j<7;j++){\n\t\t\t\tnuru.pub(nuru[i]+M*j);\n\t\t\t}\n\t\t}\n\t\tM*=7;ok=1;\n\t}\n\tsort(nuru.begin(),nuru.end());\n\tfor(i=0;i<M;i++){\n\t\tif(!binary_search(nuru.begin(),nuru.end(),i)){ siro.insert(i); }\n\t}\n\tansa=0;\n\twhile(siro.size()!=0){\n\t\tque.push(*siro.begin());\n\t\twhile(!que.empty()){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tif(siro.find(a)==siro.end()){continue;}\n\t\t\tif(a-7>=0&&siro.find(a-7)!=siro.end()){ que.push(a-7); }\n\t\t\tif(a+7<M&&siro.find(a+7)!=siro.end()){ que.push(a+7); }\n\t\t\tif(a%7!=0&&siro.find(a-1)!=siro.end()){ que.push(a-1); }\n\t\t\tif(a%7!=6&&siro.find(a+1)!=siro.end()){ que.push(a+1); }\n\t\t\tsiro.erase(a);\n\t\t}\n\t\tansa++;\n\t}\n\n\tfor(i=0;i<M;i++){\n\t\t\tif(!binary_search(nuru.begin(),nuru.end(),i)){ siro.insert(i); }\n\t\t\n\t\t\tif(!binary_search(nuru.begin(),nuru.end(),i)){ siro.insert(i+M); }\n\t}\n\tansb=0;\n\twhile(siro.size()!=0){\n\t\tque.push(*siro.begin());\n\t\twhile(!que.empty()){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tif(siro.find(a)==siro.end()){continue;}\n\t\t\tif(a-7>=0&&siro.find(a-7)!=siro.end()){ que.push(a-7); }\n\t\t\tif(a+7<2*M&&siro.find(a+7)!=siro.end()){ que.push(a+7); }\n\t\t\tif(a%7!=0&&siro.find(a-1)!=siro.end()){ que.push(a-1); }\n\t\t\tif(a%7!=6&&siro.find(a+1)!=siro.end()){ que.push(a+1); }\n\t\t\tsiro.erase(a);\n\t\t}\n\t\tansb++;\n\t}\n\tans=(ansb-ansa)*N*7/M+(2*ansa-ansb);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m,q;\n  cin>>n>>m>>q;\n  vector<Int> a(q);\n  for(Int i=0;i<q;i++) cin>>a[i];\n  vector<Int> d(m,0);\n  for(Int i=0;i<q;i++) d[a[i]]=1;\n\n  Int w=7,h=(m%7?m:m/7);\n  Int dy[]={0,0,1,-1};\n  Int dx[]={1,-1,0,0};\n  auto in=[&](Int y,Int x){return 0<=y&&y<h&&0<=x&&x<w;};\n\n  auto dp=make_v<Int>(h,w);\n  fill_v(dp,-1);\n\n  auto idx=[&](Int y,Int x){return (y*w+x)%m;};\n  \n  auto bfs=\n    [&](Int y,Int x,Int p){\n      using P = pair<Int, Int>;\n      queue<P> q;\n      dp[y][x]=p;\n      q.emplace(y,x);\n      while(!q.empty()){\n\ttie(y,x)=q.front();q.pop();\n\tfor(Int k=0;k<4;k++){\n\t  Int ny=y+dy[k],nx=x+dx[k];\n\t  if(!in(ny,nx)||d[idx(ny,nx)]||~dp[ny][nx]) continue;\n\t  dp[ny][nx]=p;\n\t  q.emplace(ny,nx);\n\t}\n      }\n    };\n\n  Int cnt=0;\n  for(Int i=0;i<h;i++)\n    for(Int j=0;j<w;j++)\n      if(!d[idx(i,j)]&&!~dp[i][j])\n\tbfs(i,j,cnt++);\n  \n  Int ans=cnt;\n  Int num=n/h-1;\n  UnionFind uf(cnt*2);\n  for(Int j=0;j<w;j++)\n    if(~dp[0][j]&&~dp[h-1][j])\n      uf.unite(dp[0][j],cnt+dp[h-1][j]);\n  \n  Int dif=-cnt;\n  for(Int i=0;i<cnt*2;i++)\n    if(uf.find(i)==i) dif++;\n  \n  ans+=dif*num;\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define  inc(i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define  dec(i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define UB upper_bound\n#define LB lower_bound\n#define PQ priority_queue\n\n#define  ALL(v)  v.begin(),  v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define  FOR(it, v) for(auto it =  v.begin(); it !=  v.end(); ++it)\n#define RFOR(it, v) for(auto it = v.rbegin(); it != v.rend(); ++it)\n\ntemplate<typename T> bool   setmin(T & a, T b) { if(b <  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool   setmax(T & a, T b) { if(b >  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmineq(T & a, T b) { if(b <= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmaxeq(T & a, T b) { if(b >= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, m, q, a[100000];\nint b[100000][7];\n\nvoid dfs(int pi, int pj) {\n\tint di[] = { 1, 0, -1,  0 };\n\tint dj[] = { 0, 1,  0, -1 };\n\t\n\tinc(k, 4) {\n\t\tint i = pi + di[k];\n\t\tint j = pj + dj[k];\n\t\tif(inID(i, 0, n) && inID(j, 0, 7) && b[i][j] == 0) {\n\t\t\tb[i][j] = 1;\n\t\t\tdfs(i, j);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> m >> q;\n\tinc(i, q) { cin >> a[i]; }\n\t\n\tif(n > 100000) { return -1; }\n\t\n\tinc(i, q) {\n\t\tint x = a[i];\n\t\tinc(j, 7 * n) {\n\t\t\tb[x / 7][x % 7] = 1;\n\t\t\t\n\t\t\tx += m;\n\t\t\tif(j >= 7 * n) { break; }\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tinc(i, n) {\n\tinc(j, 7) {\n\t\tif(b[i][j] == 0) {\n\t\t\tb[i][j] = 1;\n\t\t\tans++;\n\t\t\tdfs(i, j);\n\t\t}\n\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  for(int i=0;i<(n);++i)\n#define REPr(i,n) for(int i=(n)-1;i>=0; --i)\n#define FORq(i, m, n) for(int i = (m);i <= (n);++i)\n#define rFORq(i, m , n) for(int i = (n);i >=(m);--i)\n#define SCD(n) scanf(\"%d\",&n)\n#define SCD2(m,n) scanf(\"%d%d\",&m,&n)\n#define SCD3(m,n,k) scanf(\"%d%d%d\",&m,&n,&k)\n#define SCLLD(n) scanf(\"%lld\",&n)\n#define SCLLD2(m,n) scanf(\"%lld%lld\",&m,&n)\n#define SCLLD3(m,n,k) scanf(\"%lld%lld%lld\",&m,&n,&k)\n#define PB push_back\n#define MP make_pair\n#define ARSCD(A,N) REP(i,N){SCD(A[i]);}\n#define ARSCD1(A,N) FORq(i,1,N){SCD(A[i]);}\n#define VSCD(v,N) REP(i,N){int x; SCD(x); v.PB(x);}\n#define VSCLLD(v,N) REP(i,N){long long x; SCLLD(x); v.PB(x);}\n#define PRINTD(n) printf(\"%d\\n\",n)\n#define PRINTLLD(n) printf(\"%lld\\n\",n)\n#define DEBUG printf(\"%s\\n\",\"debug\")\n#define fst first\n#define snd second\n#define SIN(x,S) (S.count(x) != 0)\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector < VI > VVI;\ntypedef vector<long long> VL;\ntypedef long long ll;\ntypedef long long integer;\n////////////////////////////////////////////////////////////////////\nconst ll p = 1000000007;\nll dx[4] = {-7,-1,1,7};\n\nint main(){\n    ll N,M,Q; SCLLD3(N,M,Q);\n    static ll a[100002] = {};\n    static bool grid[100002] = {}; // partial\n    //static bool visited[100002] = {};\n    ARSCD(a,Q);\n\n    REP(q,Q){\n        ll ai = a[q];\n        ll k = 0;\n        while(k*M + ai <= 7 * N - 1){\n            grid[k*M+ai] = true;\n            k++;\n        }\n    }\n\n/*     FORq(i,0,7*N-1){\n        if (i % 7 == 0) printf(\"\\n\");\n        if (grid[i]) printf(\"%d\",1);\n        else printf(\"%d\",0);\n    }\n    printf(\"\\n\"); */\n\n    ll count = 0;\n    queue<ll> que;\n\n    FORq(i,0,7*N-1){\n        if (grid[i]) continue;\n        que.push(i);\n        //printf(\"start = %d\\n\",i);\n        while(!que.empty()){\n            ll now = que.front(); que.pop();\n            grid[now] = true;\n            \n            REP(k,4){\n                ll next = now + dx[k];\n                if ((now % 7 == 0) and (k == 1)) continue;\n                if (next < 0) continue;\n                if (next >= 7 * N) continue;\n                if ((now % 7 == 6) and (k == 2)) continue;\n                if (grid[next]) continue;\n                //printf(\"next -> %lld\\n\",next);\n                que.push(next);\n            }\n        }\n        //printf(\"count+\\n\");\n        count++;\n    }\n\n    PRINTLLD(count);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define put(x) cout << x;\n#define putsp(x) cout << x << ' ';\n#define putln(x) cout << x << endl;\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\ntypedef long long ll;\ntypedef pair<ll, ll> llP;\ntypedef pair<int, int> intP;\ntypedef complex<double> comp;\ntypedef vector <int> vec;\ntypedef vector <ll> vecll;\ntypedef vector <double> vecd;\ntypedef vector <vec> mat;\ntypedef vector <vecll> matll;\ntypedef vector <vecd> matd;\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nconst int MAX = 100010;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = 1<<29;\nconst ll INFL = 1e18;\nconst ll MOD = 1000000007;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint dx8[8]={1,0,-1,1,-1,1,0,-1};\nint dy8[8]={1,1,1,0,0,-1,-1,-1};\n\n//********************************template END****************************************//\n\nll N, M, Q;\n\nvoid dfs(int x, int y, mat& m)\n{\n\tm[y][x] = 1;\n\trep(4, d)\n\t{\n\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\tif (0 <= ny && ny < (int)m.size() && 0 <= nx && nx < 7)\n\t\t{\n\t\t\tif (m[ny][nx] == 0)\n\t\t\t{\n\t\t\t\tdfs(nx, ny, m);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(void){\n\n\tcin >> N >> M >> Q;\n\n\tvec qs(Q);\n\n\trep(Q, i)\n\t{\n\t\tcin >> qs[i];\n\t}\n\n\tif (M % 7)\n\t{\n\t\t//0 -> white, 1 -> black\n\t\tmat maze(M, vec (7, 0)), dmaze(M*2, vec(7, 0));\n\n\t\trep(Q, i) rep(7, j)\n\t\t{\n\t\t\tint x = qs[i] + M*j;\n\t\t\tint h = x / 7, w = x % 7;\n\t\t\tdmaze[h][w] = maze[h][w] = 1;\n\t\t\tx += 7*M;\n\t\t\th = x / 7, w = x % 7;\n\t\t\tdmaze[h][w] = 1;\n\t\t}\n\n\t\tint a = 0, b = 0, k = N/M;\n\n\t\trep(M, i) rep(7, j)\n\t\t{\n\t\t\tif (maze[i][j] == 0)\n\t\t\t{\n\t\t\t\ta++;\n\t\t\t\tdfs(j, i, maze);\n\t\t\t}\n\t\t}\n\n\t\trep(2*M, i) rep(7, j)\n\t\t{\n\t\t\tif (dmaze[i][j] == 0)\n\t\t\t{\n\t\t\t\tb++;\n\t\t\t\tdfs(j, i, dmaze);\n\t\t\t}\n\t\t}\n\n\t\t//cout << a << ' ' << b << ' ' << k << endl;\n\n\t\tint ans = a + b * (k-1);\n\n\t\tcout << ans << endl;\n\t\treturn;\n\t}\n\n\t//0 -> white, 1 -> black\n\tmat maze(M/7, vec (7, 0)), dmaze(M/7*2, vec(7, 0));\n\n\trep(Q, i)\n\t{\n\t\tint x = qs[i];\n\t\tint h = x / 7, w = x % 7;\n\t\tdmaze[h][w] = maze[h][w] = 1;\n\t\tx += M;\n\t\th = x / 7, w = x % 7;\n\t\tdmaze[h][w] = 1;\n\t}\n\n\tint a = 0, b = 0, k = N*7/M;\n\n\trep(M/7, i) rep(7, j)\n\t{\n\t\tif (maze[i][j] == 0)\n\t\t{\n\t\t\ta++;\n\t\t\tdfs(j, i, maze);\n\t\t}\n\t}\n\n\trep(2*M/7, i) rep(7, j)\n\t{\n\t\tif (dmaze[i][j] == 0)\n\t\t{\n\t\t\tb++;\n\t\t\tdfs(j, i, dmaze);\n\t\t}\n\t}\n\n\t//cout << a << ' ' << b << ' ' << k << endl;\n\n\tint ans = a + (b-a) * (k-1);\n\n\tcout << ans << endl;\n\n\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nclass UnionFind {\n    int cnt;\n    vector<int> par, rank, size;\npublic:\n    UnionFind() {}\n    UnionFind(int _n) :cnt(_n), par(_n), rank(_n), size(_n, 1) {\n        for (int i = 0; i<_n; ++i) par[i] = i;\n    }\n    int find(int k) {\n        return (k == par[k]) ? k : (par[k] = find(par[k]));\n    }\n    int operator[](int k) {\n        return find(k);\n    }\n    int getSize(int k) {\n        return size[find(k)];\n    }\n    void unite(int x, int y) {\n        x = find(x); y = find(y);\n        if (x == y) return;\n        --cnt;\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n            size[y] += size[x];\n        } else {\n            par[y] = x;\n            size[x] += size[y];\n            if (rank[y] == rank[x]) ++rank[x];\n        }\n    }\n    int count() {\n        return cnt;\n    }\n};\n\nbool A[100000 * 7][7];\nint f(int h, int m, vi &col) {\n    MEM(A, 0);\n    UnionFind uf(7 * h);\n    int cur = 0, black = 0;\n    rep(y, h)rep(x, 7) {\n        if (!col[cur%m]) {\n            A[y][x] = 1;\n            if (y > 0 && A[y - 1][x])uf.unite(cur, cur - 7);\n            if (x > 0 && A[y][x - 1])uf.unite(cur, cur - 1);\n        } else {\n            black++;\n        }\n        cur++;\n    }\n    return uf.count() - black;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n;\n    int m, q;\n    cin >> n >> m >> q;\n    vi col(m);\n    rep(i, q) {\n        int a;\n        cin >> a;\n        col[a] = 1;\n    }\n\n    int H = m;\n    if (H % 7 == 0)H /= 7;\n    int b = f(H, m, col), a = f(H * 2, m, col) - b;\n    cout << a*((n - H) / H) + b << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define I(i,j) (i*7+j)\n\nll n,m,q,a[100050];\nbool g[3000000];\nbool used[3000000];\n\nvoid dfs1(ll n,ll i,ll j) {\n    REP(k,4) {\n        ll y = i + dy[k],x = j + dx[k];\n        if(0 <= y && y < n && 0 <= x && x < 7 && !used[I(y,x)] && !g[I(y,x)]) {\n            used[I(y,x)] = true;\n            dfs1(n,y,x);\n        }\n    }\n}\n\nint main(){\n    cin >> n >> m >> q;\n\n    REP(i,q)\n        cin >> a[i];\n\n    ll l = 1;\n\n    while(m * l % 7 != 0)l++;\n\n    ll n2 = m * l / 7;\n\n    REP(i,q) {\n        ll p = a[i];\n\n        while(p < n2 * 7){\n            g[p] = true;\n            p += m;\n        }\n    }\n\n    ll c = 0;\n    REP(i,n2) {\n        REP(j,7) {\n            if(!used[I(i,j)] && !g[I(i,j)]) {\n                c++;\n                used[I(i,j)] = true;\n                dfs1(n2,i,j);\n            }\n        }\n    }\n    if(n == n2) {\n        cout << c << endl;\n        return 0;\n    }\n\n    REP(i,n2*7*2)\n        g[i] = used[i] = false;\n\n    REP(i,q) {\n        ll p = a[i];\n\n        while(p < n2 * 7 * 2){\n            g[p] = true;\n            p += m;\n        }\n    }\n\n    ll c2 = 0;\n\n    REP(i,n2*2) {\n        REP(j,7) {\n            if(!used[I(i,j)] && !g[I(i,j)]) {\n                c2++;\n                used[I(i,j)] = true;\n                dfs1(n2*2,i,j);\n            }\n        }\n    }\n\n\tll b = 2 * c - c2;\n\tll a = c - b;\n\n\tcout << a * n / n2 + b << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cassert>\n#define int long long\nusing namespace std;\n\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = {0, 1, 0, -1};\n\nint n, m, q;\nint a[100000];\n\nint solve1() {\n\tstatic bool used[100000][7] = {false};\n\tint i, j;\n\t\n\tfor (i = 0; i < q; i++) {\n\t\tfor (j = a[i]; j < 7 * n; j += m) {\n\t\t\tint r = j / 7;\t//0-indexed\n\t\t\tint c = j % 7;\t//0-indexed\n\t\t\tused[r][c] = true;\n\t\t}\n\t}\n\t\n\tint cnt = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < 7; j++) {\n\t\t\tif (used[i][j]) continue;\n\t\t\t\n\t\t\tcnt++;\n\t\t\t\n\t\t\ttypedef pair<int, int> P;\n\t\t\tqueue<P> que;\n\t\t\tque.push(P(i, j));\n\t\t\tused[i][j] = true;\n\t\t\twhile(!que.empty()) {\n\t\t\t\tP now = que.front(); que.pop();\n\t\t\t\tfor (int dir = 0; dir < 4; dir++) {\n\t\t\t\t\tint ny = now.first + dy[dir];\n\t\t\t\t\tint nx = now.second + dx[dir];\n\t\t\t\t\tif (!(0 <= ny && ny < n && 0 <= nx && nx < n)) continue;\n\t\t\t\t\tif (used[ny][nx]) continue;\n\t\t\t\t\tque.push(P(ny, nx));\n\t\t\t\t\tused[ny][nx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint solve2() {\n\tif (m == 7) {\n\t\tbool used[8] = {false};\n\t\tfor (int i = 0; i < q; i++) used[a[i]] = true;\n\t\tused[7] = true;\n\t\t\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 7; i++) {\n\t\t\tif (!used[i] && used[i + 1]) {\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\telse {\n\t\tstatic bool exist[100000] = {false};\n\t\tfor (int i = 0; i < q; i++) exist[a[i]] = true;\n\t\tfor (int i = 0; i <= m - 7; i++) {\n\t\t\tint j;\n\t\t\tfor (j = 0; j < 7; j++) {\n\t\t\t\tif (!exist[i + j]) break;\n\t\t\t}\n\t\t\tif (j == 7) return n;\n\t\t}\n\t\tif (7 * n == q) return 0;\n\t\treturn 1;\n\t}\n\tassert(0);\n\treturn -1;\n}\n\nsigned main() {\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < q; i++) cin >> a[i];\n\t\n\tint res;\n\tif (n <= 100000) { res = solve1(); }\n\telse if (m % 7 == 0) { res = solve2(); }\n\telse { res = 0; }\n\t\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <cstdio>\n#include <cstdint>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cmath>\n#include <climits>\n#include <bitset>\n\n// macros\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a); i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\n\n// solve\nbool white[800001];\nbool used[800001];\nint b[800001];\nint re;\n\nint dx[4] = {-7, -1, 1, 7};\nint count_a;\n\nvoid dfs(int x){\n  used[x] = true;\n  b[x] = count_a;\n  rep(i, 4){\n    int nx = x + dx[i];\n    if(x % 7 == 0 && nx % 7 == 6)continue;\n    if(x % 7 == 6 && nx % 7 == 0)continue;\n    if(nx >= 0 && nx < re){\n      if(!used[nx] && white[nx]){\n        dfs(nx);\n      }\n    }\n  }\n}\n\nint main(int argc, char const* argv[])\n{\n  ll n;\n  int m, q;\n  cin >> n >> m >> q;\n  vector<int> a(q);\n  rep(i, q){\n    cin >> a[i];\n  }\n  re = (m % 7 == 0) ? m: 7 * m;\n  fill(white, white + re, true);\n  rep(i, q){\n    rep(j, 7){\n      white[a[i] + j * m] = false;\n    }\n  }\n  count_a = 0;\n  rep(i, re){\n    if(!used[i] && white[i]){\n      count_a++;\n      dfs(i);\n    }\n  }\n  set<int> st;\n  rep(i, 7){\n    if(white[i] && white[re-7+i])st.insert(b[re-7+i]);\n  }\n  int count_b = int(st.size());\n  cout << (ll)(count_a - count_b) * ((7 * n) / re) + (ll)count_b << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\nll n,m,q;\nbitset<100000> ok;\n\ntemplate<int SZ> struct DSU {\n    int par[SZ], sz[SZ];\n\n    DSU() {\n        F0R(i,SZ) par[i] = i, sz[i] = 1;\n    }\n\n    int get(int x) { // path compression\n    \tif (par[x] != x) par[x] = get(par[x]);\n    \treturn par[x];\n    }\n\n    bool unite(int x, int y) { // union-by-rank\n    \tx = get(x), y = get(y);\n    \tif (x == y) return 0;\n    \tif (sz[x] < sz[y]) swap(x,y);\n    \tsz[x] += sz[y], par[y] = x;\n    \treturn 1;\n    }\n};\n\nDSU<700000> D;\nll tot = 0;\nint rows;\n\nvoid tri(int a, int b) {\n\tif (ok[a%m] && ok[b%m]) tot -= D.unite(a,b);\n}\n\nint get(int x) {\n\tif (!ok[x%m]) return -1;\n\treturn D.get(x);\n}\n\npair<int,vi> unite(vi b, vi A, vi B) {\n\tmap<int,int> m;\n\ttrav(t,b) if (t != -1) t += MOD;\n\ttrav(t,b) m[t] = 0;\n\ttrav(t,A) m[t] = 0;\n\ttrav(t,B) m[t] = 0;\n\tm.erase(-1);\n\tint co = 0;\n\ttrav(t,m) t.s = co++;\n\ttrav(t,b) if (t != -1) t = m[t];\n\ttrav(t,A) if (t != -1) t = m[t];\n\ttrav(t,B) if (t != -1) t = m[t];\n\t// ps(b,A,B);\n\tDSU<21> Z = DSU<21>();\n\t\n\tint ret = 0;\n\tF0R(i,7) if (b[i] != -1 && A[i] != -1) ret += Z.unite(b[i],A[i]);\n\tF0R(i,7) if (B[i] != -1) B[i] = Z.get(B[i]);\n\treturn {ret,B};\n}\n\nvoid fin(vi a, vi b) {\n\t// ps(\"HUH\",a,b);\n\tint lst = MOD;\n\tvi B = b;\n\tF0R(i,n/rows-1) {\n\t\tpair<int,vi> t = unite(B,a,b);\n\t\tif (t.f == lst) {\n\t\t\ttot -= (n/rows-1-i)*t.f;\n\t\t\tbreak;\n\t\t} else {\n\t\t\ttot -= t.f;\n\t\t}\n\t\tlst = t.f; B = t.s;\n\t}\n}\n\nint main() {\n    setIO(); re(n,m,q);\n    F0R(i,m) ok[i] = 1;\n    F0R(i,q) {\n    \tint x; re(x);\n    \tok[x] = 0;\n    }\n    tot = m-q;\n    rows = m; if (m%7 == 0) rows /= 7;\n    // ps(tot,rows);\n    F0R(i,rows) F0R(j,6) tri(7*i+j,7*i+j+1);\n    F0R(i,rows-1) F0R(j,7) tri(7*i+j,7*(i+1)+j);\n    // ps(\"??\",tot);\n    tot *= n/rows;\n    vi a,b;\n    F0R(j,7) {\n    \ta.pb(get(j));\n    \tb.pb(get(7*(rows-1)+j));\n    }\n    fin(a,b);\n    ps(tot);\n    // you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nbool latte[100000][7];\nbool malta[200000][7];\n\nint main()\n{\n  long long N, M, Q, A[100000];\n  cin >> N >> M >> Q;\n  for(int i = 0; i < Q; i++) cin >> A[i];\n\n\n  UnionFind tree1(100000 * 7);\n  long long sz = M / 7;\n  for(int i = 0; i < Q; i++) {\n    long long col = A[i] / 7, row = A[i] % 7;\n    while(col < N) {\n      latte[col][row] = true;\n      col += sz;\n    }\n  }\n\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < 7; j++) {\n      if(j + 1 < 7 && !latte[i][j] && !latte[i][j + 1]) {\n        tree1.unite(i * 7 + j, i * 7 + j + 1);\n      }\n      if(i + 1 < N && !latte[i][j] && !latte[i + 1][j]) {\n        tree1.unite(i * 7 + j, i * 7 + j + 7);\n      }\n    }\n  }\n\n  int ret1 = 0;\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < 7; j++) {\n      if(tree1.find(i * 7 + j) == i * 7 + j && !latte[i][j]) {\n        ret1++;\n      }\n    }\n  }\n  cout << ret1 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n \nauto& in = std::cin;\nauto& out = std::cout;\n \nint32_t N, m;\nbool MAP[100001][8];\nbool MOD[100010];\nint32_t a[100010];\n \ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) {\n\tarr = v;\n}\ntemplate<typename T, typename ARR>\nvoid fill_all(ARR& arr, const T& v) {\n\tfor (auto& i : arr) { fill_all(i, v); }\n}\n \nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t Q;\n\tin >> N >> m >> Q;\n\tfor (int32_t i = 0; i < Q; ++i)\n\t{\n\t\tin >> a[i];\n\t\tMOD[a[i]] = true;\n\t}\n \n\tif (N <= 100000)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < N; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tout << count << endl;\n\t}\n\telse if ((m % 7) == 0)\n\t{\n\t\tfor (int32_t y = 0; y < (m / 7); ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[(m / 7)][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < (m/7); ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tint32_t count1 = count;\n \n\t\tfill_all(MAP, false);\n\t\tfor (int32_t y = 0; y < (m / 7) * 2; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[(m / 7) * 2][x] = true;\n\t\t}\n\t\tcount = 0;\n\t\tfor (int32_t y = 0; y < (m / 7)*2; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n return 0;\n\t\tout << (count - count1)*((7*N)/m)+count1 << endl;\n\t}\n \n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\n#include \"string\"\n#include \"vector\"\n#include \"cmath\"\n#include \"bitset\"\n#include \"queue\"\n#include \"functional\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"set\"\n#include \"stack\"\n#include \"tuple\"\n\n#define rep(n) for (int i = 0; i < n; ++i)\n#define REP(n,i) for (int i = 0; i < n; ++i)\n#define mod 1000000007\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define nyan \"(=^･ω･^=)\"\n#define mkp make_pair\n#define mkt make_tuple\n#define P pair<ll, ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\n\nll n, m, q, a[100000], cnt = 0, cnt2 = 0, h;\nbool b[7][200000];\n\nint dfs(int x, int y) {\n\tb[x][y] = false;\n\tif (x != 0 && b[x - 1][y])\n\t\tdfs(x - 1, y);\n\tif (x != 6 && b[x + 1][y])\n\t\tdfs(x + 1, y);\n\tif (y != 0 && b[x][y - 1])\n\t\tdfs(x, y - 1);\n\tif (y != h - 1 && b[x][y + 1])\n\t\tdfs(x, y + 1);\n\treturn 0;\n}\n\nint main() {\n\tcin >> n >> m >> q;\n\trep(q)\n\t\tcin >> a[i];\n\tif (m % 7) {\n\t\trep(7)\n\t\t\tREP(200000, j)\n\t\t\t\tb[i][j] = true;\n\t\trep(q) {\n\t\t\tREP(7, j) {\n\t\t\t\tb[(a[i] + m*j) % 7][(a[i] + m*j) / 7] =false;\n\t\t\t}\n\t\t}\n\t\th = m;\n\t\trep(m * 7) {\n\t\t\tif (b[i % 7][i / 7]) {\n\t\t\t\t++cnt;\n\t\t\t\tdfs(i % 7, i / 7);\n\t\t\t}\n\t\t}\n\t\trep(7)\n\t\t\tREP(200000, j)\n\t\t\t\tb[i][j] = true;\n\t\trep(q) {\n\t\t\tREP(14, j) {\n\t\t\t\tb[(a[i] + m*j) % 7][(a[i] + m*j) / 7] = false;\n\t\t\t}\n\t\t}\n\t\th = m * 2;\n\t\trep(m * 14) {\n\t\t\tif (b[i % 7][i / 7]) {\n\t\t\t\t++cnt2;\n\t\t\t\tdfs(i % 7, i / 7);\n\t\t\t}\n\t\t}\n\t\tcout << cnt + (cnt2 - cnt)*(n / m - 1) << endl;\n\t\treturn 0;\n\t}\n\telse {\n\t\trep(7)\n\t\t\tREP(200000, j)\n\t\t\t\tb[i][j] = true;\n\t\trep(q) {\n\t\t\tb[a[i] % 7][a[i] / 7] = false;\n\t\t}\n\t\th = m / 7;\n\t\trep(m) {\n\t\t\tif (b[i % 7][i / 7]) {\n\t\t\t\t++cnt;\n\t\t\t\tdfs(i % 7, i / 7);\n\t\t\t}\n\t\t}\n\t\trep(7)\n\t\t\tREP(200000, j)\n\t\t\t\tb[i][j] = true;\n\t\trep(q) {\n\t\t\tREP(2, j) {\n\t\t\t\tb[(a[i] + m*j) % 7][(a[i] + m*j) / 7] = false;\n\t\t\t}\n\t\t}\n\t\th = m * 2 / 7;\n\t\trep(m * 2) {\n\t\t\tif (b[i % 7][i / 7]) {\n\t\t\t\t++cnt2;\n\t\t\t\tdfs(i % 7, i / 7);\n\t\t\t}\n\t\t}\n\t\tcout << cnt + (cnt2 - cnt)*(n * 7 / m - 1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\nll n,m,q;\nbitset<100000> ok;\n\ntemplate<int SZ> struct DSU {\n    int par[SZ], sz[SZ];\n\n    DSU() {\n        F0R(i,SZ) par[i] = i, sz[i] = 1;\n    }\n\n    int get(int x) { // path compression\n    \tif (par[x] != x) par[x] = get(par[x]);\n    \treturn par[x];\n    }\n\n    bool unite(int x, int y) { // union-by-rank\n    \tx = get(x), y = get(y);\n    \tif (x == y) return 0;\n    \tif (sz[x] < sz[y]) swap(x,y);\n    \tsz[x] += sz[y], par[y] = x;\n    \treturn 1;\n    }\n};\n\nDSU<700000> D;\nll tot = 0;\nint rows;\n\nvoid tri(int a, int b) {\n\tif (ok[a%m] && ok[b%m]) tot -= D.unite(a,b);\n}\n\nint get(int x) {\n\tif (!ok[x%m]) return -1;\n\treturn D.get(x);\n}\n\npair<int,vi> unite(vi b, vi A, vi B) {\n\tmap<int,int> m;\n\ttrav(t,b) if (t != -1) t += MOD;\n\ttrav(t,b) m[t] = 0;\n\ttrav(t,A) m[t] = 0;\n\ttrav(t,B) m[t] = 0;\n\tm.erase(-1);\n\tint co = 0;\n\ttrav(t,m) t.s = co++;\n\ttrav(t,b) if (t != -1) t = m[t];\n\ttrav(t,A) if (t != -1) t = m[t];\n\ttrav(t,B) if (t != -1) t = m[t];\n\t// ps(b,A,B);\n\tDSU<21> Z = DSU<21>();\n\t\n\tint ret = 0;\n\tF0R(i,7) if (b[i] != -1 && A[i] != -1) ret += Z.unite(b[i],A[i]);\n\tF0R(i,7) if (B[i] != -1) B[i] = Z.get(B[i]);\n\treturn {ret,B};\n}\n\nvi compress(vi v) {\n\tmap<int,int> m;\n\ttrav(t,v) {\n\t\tif (!m.count(t)) {\n\t\t\tint co = sz(m);\n\t\t\tm[t] = co;\n\t\t}\n\t\tt = m[t];\n\t}\n\treturn v;\n}\n\nvoid fin(vi a, vi b) {\n\t// ps(\"HUH\",a,b);\n\tint lst = MOD;\n\tvi B = b;\n\tF0R(i,n/rows-1) {\n\t\tpair<int,vi> t = unite(B,a,b);\n\t\tif (compress(B) == compress(t.s)) {\n\t\t\t// ps(\"HUH\",B,compress(B));\n\t\t\ttot -= (n/rows-1-i)*t.f;\n\t\t\tbreak;\n\t\t} else {\n\t\t\ttot -= t.f;\n\t\t}\n\t\tlst = t.f; B = t.s;\n\t}\n}\n\nint main() {\n    setIO(); re(n,m,q);\n    F0R(i,m) ok[i] = 1;\n    F0R(i,q) {\n    \tint x; re(x);\n    \tok[x] = 0;\n    }\n    tot = m-q;\n    rows = m; \n    if (m%7 == 0) rows /= 7;\n    else tot *= 7;\n    // ps(tot,rows);\n    F0R(i,rows) F0R(j,6) tri(7*i+j,7*i+j+1);\n    F0R(i,rows-1) F0R(j,7) tri(7*i+j,7*(i+1)+j);\n    // ps(\"??\",tot);\n    tot *= n/rows;\n    vi a,b;\n    F0R(j,7) {\n    \ta.pb(get(j));\n    \tb.pb(get(7*(rows-1)+j));\n    }\n    fin(a,b);\n    ps(tot);\n    // you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll N,M,Q;\nint A[101010];\nint col[1500000];\n\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank,cnt;\n\tUF() {par=rank=vector<int>(um,0); cnt=vector<int>(um,1); for(int i=0;i<um;i++) par[i]=i;}\n\tvoid reinit() {int i; FOR(i,um) rank[i]=0,cnt[i]=1,par[i]=i;}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint count(int x) { return cnt[operator[](x)];}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tcnt[y]=cnt[x]=cnt[x]+cnt[y];\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\n\nUF<1407070> uf1,uf2,uftail;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>Q;\n\tFOR(i,Q) {\n\t\tcin>>A[i];\n\t\tfor(j=A[i];j<14*M;j+=M) col[j]=1;\n\t}\n\t\n\tll pat;\n\tint num[3]={};\n\tif(M%7==0) {\n\t\tFOR(i,M) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uf1(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<M) && col[i+7]==0) uf1(i,i+7);\n\t\t}\n\t\tFOR(i,2*M) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uf2(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<2*M) && col[i+7]==0) uf2(i,i+7);\n\t\t}\n\t\tFOR(i,M) if(col[i]==0 && uf1[i]==i) num[0]++;\n\t\tFOR(i,2*M) if(col[i]==0 && uf2[i]==i) num[1]++;\n\t\tpat=7*N/M;\n\t}\n\telse {\n\t\tFOR(i,7*M) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uf1(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<7*M) && col[i+7]==0) uf1(i,i+7);\n\t\t}\n\t\tFOR(i,14*M) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uf2(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<14*M) && col[i+7]==0) uf2(i,i+7);\n\t\t}\n\t\tFOR(i,7*M) if(col[i]==0 && uf1[i]==i) num[0]++;\n\t\tFOR(i,14*M) if(col[i]==0 && uf2[i]==i) num[1]++;\n\t\tpat=N/M;\n\t}\n\tcout<<num[0]+(pat-1)*(num[1]-num[0])<<endl;\n\t\n}\n\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint64_t N;\nint32_t m;\nbool MAP[200001][8];\nbool MOD[700010];\n\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) {\n\tarr = v;\n}\ntemplate<typename T, typename ARR>\nvoid fill_all(ARR& arr, const T& v) {\n\tfor (auto& i : arr) { fill_all(i, v); }\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t Q;\n\tin >> N >> m >> Q;\n\tauto m_l = m;\n\tif ((m_l % 7) != 0) {\n\t\tm_l *= 7;\n\t}\n\tfor (int32_t i = 0; i < Q; ++i)\n\t{\n\t\tint32_t a;\n\t\tin >> a;\n\t\tdo{\n\t\t\tMOD[a] = true;\n\t\t\ta += m;\n\t\t}while (a < m_l);\n\t}\n\tm = m_l;\n\n\tif (N <= 100000)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < N; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tout << count << endl;\n\t}\n\telse\n\t{\n\t\tfor (int32_t y = 0; y < (m / 7); ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[(m / 7)][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < (m/7); ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tint32_t count1 = count;\n\n\t\tfill_all(MAP, false);\n\t\tfor (int32_t y = 0; y < (m / 7) * 2; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[(m / 7) * 2][x] = true;\n\t\t}\n\t\tcount = 0;\n\t\tfor (int32_t y = 0; y < (m / 7)*2; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tout << (count - count1)*((7*N)/m)+count1 << endl;\n\t}\n\n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint n, m, q, a, area[700000] = {}, ans = 0;\nbool x[700000] = {};\nqueue<int> Q;\nint now = 0;\n\nint main(){\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < q; i++){\n\t\tcin >> a;\n\n\t\tfor (int j = 0; j < 7 * n; j++){\n\t\t\tif (j%m == a){\n\t\t\t\tx[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 7 * n; i++){\n\t\tif (!x[i] && area[i] == 0){\n\t\t\tans++;\n\t\t\tarea[i] = ans;\n\n\t\t\tQ.push(i);\n\t\t\twhile (!Q.empty()){\n\t\t\t\tnow = Q.front();\n\t\t\t\tQ.pop();\n\n\t\t\t\tif (now % 7 != 0 && !x[now - 1] && area[now - 1] == 0){\n\t\t\t\t\tQ.push(now - 1);\n\t\t\t\t\tarea[now - 1] = ans;\n\t\t\t\t}\n\t\t\t\tif (now % 7 != 6 && !x[now + 1] && area[now + 1] == 0){\n\t\t\t\t\tQ.push(now + 1);\n\t\t\t\t\tarea[now + 1] = ans;\n\t\t\t\t}\n\t\t\t\tif (now > 6 && !x[now - 7] && area[now - 7] == 0){\n\t\t\t\t\tQ.push(now - 7);\n\t\t\t\t\tarea[now - 7] = ans;\n\t\t\t\t}\n\t\t\t\tif (now < 7 * (n - 1) && !x[now + 7] && area[now + 7] == 0){\n\t\t\t\t\tQ.push(now + 7);\n\t\t\t\t\tarea[now + 7] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <cstdio>\n#include <cstdint>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cmath>\n#include <climits>\n#include <bitset>\n\n// macros\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a); i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\n\n// solve\nbool white[800001];\nbool used[800001];\nint b[800001];\nint re;\n\nint dx[4] = {-7, -1, 1, 7};\nint count_a;\n\nvoid dfs(int x){\n  used[x] = true;\n  b[x] = count_a;\n  rep(i, 4){\n    int nx = x + dx[i];\n    if(nx >= 0 && nx < re){\n      if(!used[nx] && white[nx]){\n        dfs(nx);\n      }\n    }\n  }\n}\n\nint main(int argc, char const* argv[])\n{\n  ll n;\n  int m, q;\n  cin >> n >> m >> q;\n  vector<int> a(q);\n  rep(i, q){\n    cin >> a[i];\n  }\n  re = (m % 7 == 0) ? m: 7 * m;\n  fill(white, white + re, true);\n  rep(i, q){\n    rep(j, 7){\n      white[a[i] + j * m] = false;\n    }\n  }\n  count_a = 0;\n  rep(i, re){\n    if(!used[i] && white[i]){\n      dfs(i);\n      count_a++;\n    }\n  }\n  set<int> st;\n  rep(i, 7){\n    if(white[i] && white[re - 7 + i])st.insert(b[re-7+i]);\n  }\n  int count_b = int(st.size());\n  cout << (ll)(count_a - count_b) * (7 * n / re) + count_b << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nint par[700002];\nint rk[700002];\n\nvoid init(int n){\n\tfor(int i=0; i<n; i++){\n\t\tpar[i]=i;\n\t}\n}\n \nint find(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x]=find(par[x]);\n\t}\n}\n \nvoid unite(int x, int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x==y) return;\n\tif(rk[x]<rk[y]){\n\t\tpar[x]=y;\n\t}else{\n\t\tpar[y]=x;\n\t\tif(rk[x]==rk[y]) rk[x]++;\n\t}\n}\n \nbool same(int x, int y){\n\treturn find(x)==find(y);\n}\n\nll n; int m, q;\nint p1[7], p2[7];\nbool b[700001];\nll conn(int p1a[7], int p2a[7], int p1b[7], int p2b[7], int p1c[7], int p2c[7]){\n    init(28);\n    for(int i=0; i<14; i++){\n        if((i<7 && !b[i]) || (i>=7 && !b[m-7+i-7])) continue;\n        for(int j=i+1; j<14; j++){\n            if((j<7 && !b[j]) || (j>=7 && !b[m-7+j-7])) continue;\n            int x, y;\n            if(i<7) x=p1a[i];\n            else x=p2a[i-7];\n            if(j<7) y=p1a[j];\n            else y=p2a[j-7];\n            if(x==y) unite(i, j);\n            if(i<7) x=p1b[i];\n            else x=p2b[i-7];\n            if(j<7) y=p1b[j];\n            else y=p2b[j-7];\n            if(x==y) unite(i+14, j+14);\n        }\n    }\n    for(int i=0; i<7; i++){\n        if(b[i] && b[m-7+i]) unite(i+7, i+14);\n    }\n    set<int> st;\n    for(int i=0; i<28; i++){\n        if((i<7 && !b[i]) || (7<=i && i<14 && !b[m-7+i-7]) || (14<=i && i<21 && !b[i-14]) || (i>=21 && !b[m-7+i-21])) continue;\n        st.insert(find(i));\n    }\n    for(int i=0; i<7; i++){\n        p1c[i]=find(i);\n        st.erase(p1c[i]);\n    }\n    for(int i=0; i<7; i++){\n        p2c[i]=find(i+21);\n        st.erase(p2c[i]);\n    }\n    return st.size();\n}\nll ct;\nll solve(ll k){\n    int p1p[7], p2p[7], p1a[7], p2a[7];\n    for(int i=0; i<7; i++) p1p[i]=p1[i], p2p[i]=p2[i];\n    bool mada=1;\n    ll ans=0;\n    while(k){\n        if(k&1){\n            if(mada){\n                for(int i=0; i<7; i++) p1a[i]=p1p[i], p2a[i]=p2p[i];\n                mada=0;\n            }else{\n                int p1c[7], p2c[7];\n                ans+=conn(p1p, p2p, p1a, p2a, p1c, p2c);\n                ans+=ct;\n                for(int i=0; i<7; i++) p1a[i]=p1c[i], p2a[i]=p2c[i];\n            }\n        }\n        int p1c[7], p2c[7];\n        ct=2*ct+conn(p1p, p2p, p1p, p2p, p1c, p2c);\n        for(int i=0; i<7; i++) p1p[i]=p1c[i], p2p[i]=p2c[i];\n        k>>=1;\n    }\n    set<int> st;\n    for(int i=0; i<7; i++){\n        if(b[i]) st.insert(p1a[i]);\n        if(b[m-7+i]) st.insert(p2a[i]);\n    }\n    ans+=(ll)st.size();\n    return ans;\n}\nint main()\n{\n    cin>>n>>m>>q;\n    int a[100001];\n    for(int i=0; i<q; i++){\n        cin>>a[i];\n    }\n    if(m%7!=0){\n        m*=7;\n        fill(b, b+m, 1);\n        for(int i=0; i<q; i++){\n            for(int j=0; j<7; j++){\n                b[a[i]+m/7*j]=0;\n            }\n        }\n    }else{\n        fill(b, b+m, 1);\n        for(int i=0; i<q; i++) b[a[i]]=0;\n    }\n    init(m);\n    for(int i=0; i<m; i++){\n        if(!b[i]) continue;\n        if(i%7!=0 && b[i-1]) unite(i-1, i);\n        if(i>=7 && b[i-7]) unite(i-7, i);\n    }\n    set<int> st;\n    for(int i=0; i<m; i++){\n        if(!b[i]) continue;\n        st.insert(find(i));\n    }\n    for(int i=0; i<7; i++){\n        p1[i]=find(i);\n        st.erase(p1[i]);\n    }\n    for(int i=0; i<7; i++){\n        p2[i]=find(m-7+i);\n        st.erase(p2[i]);\n    }\n    ct=st.size();\n    cout<<solve(7*n/(ll)m)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define RREP(i, x, n) for(int i = x; i >= n; i--)\n#define rrep(i, n) RREP(i,n,0)\n#define pb push_back\n#pragma GCC optimize (\"-O3\")\n\nusing namespace std;\n\n// #define DEBUG_IS_VALID\n\n#ifdef DEBUG_IS_VALID\n#define DEB 1 \n#else\n#define DEB 0\n#endif\n#define DUMPOUT cout\n#define dump(...) if(DEB) DUMPOUT<<\"  \"<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl<<\"    \"; if(DEB) dump_func(__VA_ARGS__)\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, pair<T1,T2> p){cout << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate<typename T>ostream& operator << (ostream& os, vector<T>& vec) { os << \"{\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"}\"; return os; }\ntemplate<typename T>ostream& operator << (ostream& os, set<T>& st){for(auto itr = st.begin(); itr != st.end(); itr++) cout << *itr << (next(itr)!=st.end() ? \", \" : \"\"); cout << \"}\"; return os;}\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, map<T1,T2> mp){cout << \"{\"; for(auto itr = mp.begin(); itr != mp.end(); itr++) cout << \"(\" << (itr->first) << \", \" << (itr->second) << \")\" << (next(itr)!=mp.end() ? \",\" : \"\"); cout << \"}\"; return os; }\n\nvoid dump_func(){DUMPOUT << endl;}\ntemplate <class Head, class... Tail>void dump_func(Head&& head, Tail&&... tail){ DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...);}\ntemplate<class T> inline bool chmax(T& a,T const& b){if(a>=b) return false; a=b; return true;}\ntemplate<class T> inline bool chmin(T& a,T const& b){if(a<=b) return false; a=b; return true;}\n\nusing ll = long long;\nusing P = pair<int,int>;\nusing Pl = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\n\nconst int mod=1e9+7,INF=1<<29;\nconst double EPS=1e-12,PI=3.1415926535897932384626;\nconst ll lmod = 1e9+7,LINF=1LL<<59; \n\nstruct UnionFindTree{\n  vector<int> par,rank,size;\n  UnionFindTree(int N){\n    par = rank = vector<int>(N,0);\n    size = vector<int>(N,1);\n    for(int i = 0; i < N; i++) par[i] = i;\n  }\n  int find(int x){\n    if(par[x] == x) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x,int y){\n    x = find(x);\n    y = find(y);\n    if(x == y)  return ;\n    if(rank[x] < rank[y]){\n      par[x] = y;\n    }else{\n      par[y] = x;\n      if(rank[x] == rank[y]) ++rank[x];\n    }\n    size[x] = size[y] = size[x] + size[y];\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll N,M,Q; cin >> N >> M >> Q ;\n  ll sp_sz;\n  if(M%7==0) sp_sz = M;\n  else sp_sz = 7 * M;\n  vector<bool> is_black(sp_sz,false);\n  rep(i,Q){\n    int a; cin >> a ;\n    for(int x = a; x < sp_sz ; x += M){\n      is_black[x] = true;\n    }\n  }\n  UnionFindTree uft(sp_sz*2);\n  vi dx = {-1,0,1,0};\n  vi dy = {0,-1,0,1};\n  rep(i,sp_sz){\n    if(is_black[i]) continue;\n    rep(j,4){\n      int x = i + dx[j]*7 + dy[j];\n      if(x<0 || x>=sp_sz) continue;\n      if(i/7 != x/7) continue;\n      if(is_black[x]) continue;\n      uft.unite(i,x);\n      uft.unite(i+sp_sz,x+sp_sz);\n    }\n  }\n  ll sz1,sz2;\n  sz1 = sz2 = 0;\n  rep(i,sp_sz){\n    if(is_black[i]) continue;\n    if(uft.par[i]==i) sz1++;\n  }\n  REP(i,sp_sz-7,sp_sz){\n    if(is_black[i]||is_black[(i+7)%sp_sz]) continue;\n    uft.unite(i,i+7);\n  }\n  rep(i,2*sp_sz){\n    if(is_black[i%sp_sz]) continue;\n    if(uft.par[i]==i) sz2++; \n  }\n  dump(is_black);\n  dump(sz1,sz2);\n  ll diff = sz1 * 2 - sz2;\n  ll temp = 7LL*N/sp_sz;\n  cout << sz1 * temp - diff * (temp-1) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 666666\nll n;\nint m,q,a[SZ];\nbool cov[SZ];\nint ff[SZ];\nint gf(int x) {return (ff[x]==-1)?x:ff[x]=gf(ff[x]);}\nvoid uni(int a,int b)\n{int ga=gf(a),gb=gf(b);if(ga^gb)ff[ga]=gb;}\nint main()\n{\n\tmemset(ff,-1,sizeof(ff));\n\tscanf(\"%lld%d%d\",&n,&m,&q);\n\tfor(int i=1;i<=q;i++)\n\tscanf(\"%d\",a+i),cov[a[i]]=1;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif(cov[i])continue;\n\t\tif(i+7<m&&!cov[i+7]) uni(i,i+7);\n\t\tif(i%7!=6&&i+1<m&&!cov[i+1]) uni(i,i+1);\n\t}\n\tint ans1=0;\n\tfor(int i=0;i<m;i++)\n\t\tif(!cov[i]) ans1+=gf(i)==i;\n\tmemset(ff,-1,sizeof(ff));\n\tfor(int i=0;i<m+m;i++)\n\t{\n\t\tif(cov[i%m])continue;\n\t\tif(i+7<m+m&&!cov[(i+7)%m]) uni(i,i+7);\n\t\tif(i%7!=6&&i+1<m+m&&!cov[(i+1)%m]) uni(i,i+1);\n\t}\n\tint ans2=0;\n\tfor(int i=0;i<m+m;i++)\n\t\tif(!cov[i]) ans2+=gf(i)==i;\n\tll tm=7*n/m;\n\tll ans=(tm-1)*(ans2-ans1)+ans1;\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\nll n;\nint m,q;\nint a[125252];\n\nint mp[125252][7];\nint dat[125252*7];\nvoid init(){\n  REP(i,125252*7)dat[i]=-1;\n}\nint root(int x){\n  return dat[x]<0?x:dat[x]=root(dat[x]);\n}\nvoid unite(int a,int b){\n  a=root(a);\n  b=root(b);\n  if(a!=b){\n    if(dat[a]>dat[b])swap(a,b);\n    dat[a]+=dat[b];\n    dat[b]=a;\n  }\n}\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint main(){\n  scanf(\"%lld%d%d\",&n,&m,&q);\n  REP(i,q)scanf(\"%d\",a+i);\n  ll u = (m%7==0) ? (m/7) : m;\n  ll k = n / u;\n  // solve u,m,q\n  REP(i,q){\n    int v = a[i];\n    while(v < 7*u){\n      mp[v/7][v%7] = 1;\n      v += m;\n    }\n  }\n  init();\n  REP(i,u)REP(j,7){\n    if(mp[i][j])continue;\n    int id = i*7 + j;\n    REP(d,4){\n      int ni = i+dy[d];\n      int nj = j+dx[d];\n      if(ni<0 || nj<0 || ni>=u || nj>=7)continue;\n      if(mp[ni][nj])continue;\n      unite(id,ni*7+nj);\n    }\n  }\n  ll subans = 0;\n  REP(i,u)REP(j,7)if(!mp[i][j] && root(7*i+j)==7*i+j)subans++;\n  // merge\n  set<pii> S;\n  REP(i,7){\n    if(mp[0][i] || mp[u-1][i])continue;\n    int ida = root(i);\n    int idb = root(7*(u-1) + i);\n    pii P = pii(ida,idb);\n    S.insert(P);\n  }\n  ll yo = S.size();\n  ll ans = subans * k - yo * (k-1);\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nbool latte[20000][7];\n\nint main()\n{\n  int N, M, Q, A[200000];\n\n  scanf(\"%d %d %d\", &N, &M, &Q);\n  for(int i = 0; i < Q; i++) scanf(\"%d\", &A[i]);\n\n  UnionFind tree1(20000 * 7);\n  long long sz = M / 7;\n  for(int i = 0; i < Q; i++) {\n    long long col = A[i] / 7, row = A[i] % 7;\n    while(col < N) {\n      latte[col][row] = true;\n      col += sz;\n    }\n  }\n\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < 7; j++) {\n      if(j + 1 < 7 && !latte[i][j] && !latte[i][j + 1]) {\n        tree1.unite(i * 7 + j, i * 7 + j + 1);\n      }\n      if(i + 1 < N && !latte[i][j] && !latte[i + 1][j]) {\n        tree1.unite(i * 7 + j, i * 7 + j + 7);\n      }\n    }\n  }\n\n  int ret1 = 0;\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < 7; j++) {\n      if(tree1.find(i * 7 + j) == i * 7 + j && !latte[i][j]) {\n        ret1++;\n      }\n    }\n  }\n\n  cout << ret1 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n// #define DEBUG\n#ifdef DEBUG\n#define dump(...) cerr<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<make_tuple(__VA_ARGS__)<<\"\\n\";\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '{'; for(int i = 0; i < (int) v.size(); i++) o << v[i] << (i != (int)v.size()-1 ? \", \" : \"\"); o << \"}\";  return o; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\n#else\n#define dump(...)\n#endif\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  ll n, m, q; cin >> n >> m >> q;\n  ll h = (m + 6) / 7; // one shared block\n  ll period = h * 7; // height of period\n  ll full = n / period;\n  ll rest = n - full * period;\n  vector< vector<int> > f(period, vector<int>(7) );\n  auto used = f;\n  auto used2 = f;\n  auto used3 = f;\n\n  while(q--) {\n    ll a; cin >> a;\n    for(; a < period * 7; a += m) {\n      ll y = a / 7, x = a % 7;\n      f[y][x] = 1;\n    }\n  }\n  dump(f);\n\n  ll block = 0;\n  for(ll y = 0; y < period; y++)\n    for(ll x = 0; x < 7; x++) {\n      if(f[y][x]) continue;\n      if(used[y][x]) continue;\n      used[y][x] = 1;\n      queue<pair<ll, ll>> q;\n      q.emplace(y, x);\n      block++;\n      while(q.size()) {\n        ll yy = q.front().first, xx = q.front().second;\n        q.pop();\n        for(int d = 0; d < 4; d++) {\n          ll ny = yy + dy[d];\n          ll nx = xx + dx[d];\n          if(ny < 0 || period <= ny || nx < 0 || 7 <= nx) continue;\n          if(f[ny][nx]) continue;\n          if(used[ny][nx]) continue;\n          used[ny][nx] = 1;\n          q.emplace(ny, nx);\n        }\n      }\n    }\n\n  ll black = 0;\n  {\n    ll y = 0;\n    for(ll x = 0; x < 7; x++) {\n      if(f[y][x]) continue;\n      if(used2[y][x]) continue;\n      if(f[period - 1][x]) continue;\n      used2[y][x] = 1;\n      queue<pair<ll, ll>> q;\n      q.emplace(y, x);\n      black++;\n      while(q.size()) {\n        ll yy = q.front().first, xx = q.front().second;\n        q.pop();\n        for(int d = 0; d < 4; d++) {\n          ll ny = yy + dy[d];\n          ll nx = xx + dx[d];\n          if(ny < 0 || period <= ny || nx < 0 || 7 <= nx) continue;\n          if(f[ny][nx]) continue;\n          if(used2[ny][nx]) continue;\n          used2[ny][nx] = 1;\n          q.emplace(ny, nx);\n        }\n      }\n    }\n  }\n\n  ll last = 0;\n  for(ll y = 0; y < rest; y++)\n    for(ll x = 0; x < 7; x++) {\n      if(f[y][x]) continue;\n      if(used3[y][x]) continue;\n      used3[y][x] = 1;\n      queue<pair<ll, ll>> q;\n      q.emplace(y, x);\n      last++;\n      while(q.size()) {\n        ll yy = q.front().first, xx = q.front().second;\n        q.pop();\n        for(int d = 0; d < 4; d++) {\n          ll ny = yy + dy[d];\n          ll nx = xx + dx[d];\n          if(ny < 0 || rest <= ny || nx < 0 || 7 <= nx) continue;\n          if(f[ny][nx]) continue;\n          if(used3[ny][nx]) continue;\n          used3[ny][nx] = 1;\n          q.emplace(ny, nx);\n        }\n      }\n    }\n  dump(full);\n  dump(block, black, last);\n\n  ll ans = 0;\n  if(full > 0) {\n    ans += 1 * block;\n    ans += (full - 1) * (block - black);\n  }\n  ans += last;\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nlong n;int m,q,a[1<<17];\nbool f[7][1<<17];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid bfs(int x,int y)\n{\n\tqueue<pair<int,int> >P;\n\tf[x][y]=true;\n\tP.push(make_pair(x,y));\n\twhile(!P.empty())\n\t{\n\t\tpair<int,int>p=P.front();P.pop();\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint tx=p.first+dx[r],ty=p.second+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=7||ty>=n||f[tx][ty])continue;\n\t\t\tf[tx][ty]=true;\n\t\t\tP.push(make_pair(tx,ty));\n\t\t}\n\t}\n}\nmain()\n{\n\tcin>>n>>m>>q;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tfor(int i=0;i<7;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tint b=(j*7+i)%m;\n\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t}\n\t}\n\tlong ans=0;\n\tfor(int i=0;i<7;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(!f[i][j])\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t\tbfs(i,j);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N,m;\nbool MAP[100001][8];\nbool MOD[100000];\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t Q;\n\tin >> N>>m>>Q;\n\tfor (int32_t i = 0; i < Q; ++i)\n\t{\n\t\tint a;\n\t\tin >> a;\n\t\tMOD[a] = true;\n\t}\n\tfor (int32_t y = 0; y < N; ++y) {\n\t\tMAP[y][7] = true;\n\t}\n\tfor (int32_t x = 0; x < 8; ++x) {\n\t\tMAP[N][x] = true;\n\t}\n\tint32_t count = 0;\n\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\tfor (int32_t y = 0; y < N; ++y)\n\t\tfor (int32_t x = 0; x < 7; ++x)\n\t{\n\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\tMAP[y][x] = true;\n\t\t}\n\t\tif (!MAP[y][x])\n\t\t{\n\t\t\t++count;\n\t\t\tstack.emplace(y, x);\n\t\t\tMAP[y][x] = true;\n\t\t\twhile (!stack.empty())\n\t\t\t{\n\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\tauto x = pos.second;\n\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t{\n\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tstack.emplace(ny,nx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tout << count << endl;\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long int n2;\nint m,q,ct,n;\nint f[111111][7];\nbool g[111111];\nvoid dfs(int x,int y){\n\tif(x<0 || x>=n || y<0 || y>=m || f[x][y]!=-2)return;\n\tf[x][y] = ct;\n\tdfs(x-1,y);\n\tdfs(x,y-1);\n\tdfs(x+1,y);\n\tdfs(x,y+1);\n}\n\nset<int> S;\nset<pair<int,int> > E;\nint ace[99];\nint ancestor(int x){return x-ace[x]?ace[x]=ancestor(ace[x]):x;}\nint calc(){\n\tmap<int,int> Map;\n\tint z = 0;\n\tfor(set<int>::iterator it = S.begin(); it!=S.end(); it++){\n\t\tMap[*it] = z++;\n\t}\n\tfor(int i=0; i<z; i++)\n\t\tace[i] = i;\n\tfor(set<pair<int,int> >::iterator it = E.begin(); it!=E.end(); it++){\n\t\tace[ancestor(Map[it->first])]=ancestor(Map[it->second]);\n\t}\n\tint res = 0;\n\tfor(int i=0; i<z; i++){\n\t\tif(ancestor(i) == i)\n\t\t\tres++;\n\t}\n\treturn z - res;\n}\n\nint main(){\n\tcin>>n2>>m>>q;\n\tif(m%7==0)\n\t\tn=m/7;\n\telse\n\t\tn=m;\n\n\tfor(int i=0; i<q; i++){\n\t\tint x;\n\t\tcin>>x;\n\t\tg[x] = true;\n\t}\n\tmemset(f,-1,sizeof(f));\n\tfor(int i=0; i<n; i++)\n\t\tfor(int j=0; j<7; j++)\n\t\t\tif(!g[(i*7+j)%m])\n\t\t\t\tf[i][j] = -2;\n\tfor(int i=0; i<n; i++)\n\tfor(int j=0; j<7; j++)\n\tif(f[i][j] == -2){\n\t\tdfs(i,j);\n\t\tct++;\n\t}\n\tfor(int j=0; j<7; j++){\n\t\tint x = f[0][j], y=f[n-1][j];\n\t\tif(x!=-1)S.insert(x);\n\t\tif(y!=-1)S.insert(y+ct);\n\t\tif(x!=-1 && y!=-1){\n\t\t\tE.insert(make_pair(x,y+ct));\n\t\t}\n\t}\n\tint dec = calc();\n\tcout << (n2 / n) * ct - (n2/n-1)*dec << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define in std::cin\n#define out std::cout\n#define rep(i,N) for(LL i=0;i<N;++i)\ntypedef long long int LL;\n\nLL gcd(LL a, LL b)\n{\n\tif (a < b) std::swap(a, b);\n\tLL r = a % b;\n\twhile (r != 0)\n\t{\n\t\ta = b;\n\t\tb = r;\n\t\tr = a % b;\n\t}\n\treturn b;\n}\n\nLL lcm(LL a, LL b)\n{\n\treturn a / gcd(a, b) * b;\n}\n\nstd::vector<std::vector<bool>>field;\nstd::vector<std::vector<bool>>vis;\nLL dx[] = { -1,0,0,1 }, dy[] = { 0,-1,1,0 };\nvoid dfs(LL x, LL y)\n{\n\tif (vis[x][y]) return;\n\tvis[x][y] = true;\n\trep(k, 4)\n\t{\n\t\tLL kx = x + dx[k], ky = y + dy[k];\n\t\tif (0 <= kx && kx < field.size() && 0 <= ky && ky < field[0].size())\n\t\t{\n\t\t\tif (!field[kx][ky] && !vis[kx][ky]) dfs(kx, ky);\n\t\t}\n\t}\n}\n\nLL linking_num()\n{\n\tvis.clear();\n\tvis.resize(field.size());\n\trep(i, vis.size()) vis[i].resize(field[i].size(), false);\n\n\tLL res = 0;\n\trep(i, field.size())\n\t{\n\t\trep(j, field[i].size())\n\t\t{\n\t\t\tif (!field[i][j] && !vis[i][j])\n\t\t\t{\n\t\t\t\tdfs(i, j);\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nLL n, m, q;\n\nint main()\n{\n\tin >> n >> m >> q;\n\tstd::vector<LL>a(q);\n\trep(i, q) in >> a[i];\n\n\tLL height = lcm(m, 7);\n\tfield.resize(height / 7);\n\trep(i, field.size()) field[i].resize(7, false);\n\trep(x, field.size())\n\t{\n\t\trep(y, field[x].size())\n\t\t{\n\t\t\tLL num = (x * 7 + y) % m;\n\t\t\tauto it = std::lower_bound(a.begin(), a.end(), num);\n\t\t\tif (it != a.end())\n\t\t\t{\n\t\t\t\tif (*it == num) field[x][y] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tLL first_num = linking_num();\n\trep(i, height / 7) field.push_back(field[i]);\n\tLL diff_num = linking_num() - first_num;\n\n\tout << first_num + diff_num * (n / (height / 7) - 1) << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nlong n;int m,q,a[1<<17];\nbool f[7][1<<17];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid bfs(int x,int y,long _n)\n{\n\tqueue<pair<int,int> >P;\n\tf[x][y]=true;\n\tP.push(make_pair(x,y));\n\twhile(!P.empty())\n\t{\n\t\tpair<int,int>p=P.front();P.pop();\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint tx=p.first+dx[r],ty=p.second+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=7||ty>=_n||f[tx][ty])continue;\n\t\t\tf[tx][ty]=true;\n\t\t\tP.push(make_pair(tx,ty));\n\t\t}\n\t}\n}\nmain()\n{\n\tcin>>n>>m>>q;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tif(m%7==0)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,m/7*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,m/7*3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=count2-count1;\n\t\tlong syokou=count1-kousa*2;\n\t\tcout<<syokou+kousa*(n/(m/7))<<endl;\n\t}\n\telse if(n<=100000)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong ans=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t\tbfs(i,j,n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 2333333\nll n;\nint m,q,a[SZ];\nbool cov[SZ];\nint ff[SZ];\nint gf(int x) {return (ff[x]==-1)?x:ff[x]=gf(ff[x]);}\nvoid uni(int a,int b)\n{int ga=gf(a),gb=gf(b);if(ga^gb)ff[ga]=gb;}\nint main()\n{\n\tscanf(\"%lld%d%d\",&n,&m,&q);\n\tfor(int i=1;i<=q;i++)\n\tscanf(\"%d\",a+i),cov[a[i]]=1;\n\tmemset(ff,-1,sizeof(ff));\n\tfor(int i=0;i<m*7;i++)\n\t{\n\t\tif(cov[i%m])continue;\n\t\tif(i+7<m*7&&!cov[(i+7)%m]) uni(i,i+7);\n\t\tif(i%7!=6&&i+1<m*7&&!cov[(i+1)%m]) uni(i,i+1);\n\t}\n\tint ans1=0;\n\tfor(int i=0;i<m*7;i++)\n\t\tif(!cov[i%m]) ans1+=gf(i)==i;\n\tll rd=7*n/m,zg=rd/7,bf=rd%7;\n\tll ans=zg*ans1;\n\tmemset(ff,-1,sizeof(ff));\n\tfor(int i=0;i<m*bf;i++)\n\t{\n\t\tif(cov[i%m])continue;\n\t\tif(i+7<m*bf&&!cov[(i+7)%m]) uni(i,i+7);\n\t\tif(i%7!=6&&i+1<m*bf&&!cov[(i+1)%m]) uni(i,i+1);\n\t}\n\tfor(int i=0;i<m*bf;i++)\n\t\tif(!cov[i%m]) ans+=gf(i)==i;\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\n#define REP(i,a,b) for(ll i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\nll gcd(ll a, ll b) {\n    if (b > a) swap(a, b);\n    while (b) {\n        ll t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nll lcm(ll a, ll b) {\n    return a / gcd(a, b) * b;\n}\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\n\nll n, m, q;\nll h;\nint used[101010][7] = {};\nint cal[101010][7] = {};\nint used2[2][7] = {};\nint cal2[2][7] = {};\n\nvoid dfs(int y, int x) {\n    used[y][x] = 1;\n    rep(i,4) {\n        if (y + dy[i] >= 0 && y + dy[i] < h && x + dx[i] >= 0 && x + dx[i] < 7 && !used[y + dy[i]][x + dx[i]] && !cal[y + dy[i]][x + dx[i]]) {\n            dfs(y + dy[i], x + dx[i]);\n        }\n    }\n}\n\nvoid dfs2(int y, int x) {\n    used2[y][x] = 1;\n    rep(i,4) {\n        if (y + dy[i] >= 0 && y + dy[i] < 2 && x + dx[i] >= 0 && x + dx[i] < 7 && !used2[y + dy[i]][x + dx[i]] && !cal2[y + dy[i]][x + dx[i]]) {\n            dfs2(y + dy[i], x + dx[i]);\n        }\n    }\n}\n\nvoid solve() {\n    cin >> n >> m >> q;\n    h = lcm(7, m) / 7;\n    rep(i,q) {\n        ll a;\n        cin >> a;\n        for (ll j = a; j < 7 * h; j += m) {\n            if (cal[j/7][j%7]) break;\n            cal[j/7][j%7] = 1;\n        }\n    }\n    ll cnt = 0;\n    rep(i,h) {\n        rep(j,7) {\n            if (!used[i][j] && !cal[i][j]) {\n                dfs(i, j);\n                cnt++;\n            }\n        }\n    }\n    rep(i,7) cal2[0][i] = cal[h-1][i];\n    rep(i,7) cal2[1][i] = cal[0][i];\n    ll cnt2 = 0;\n    rep(i,2) {\n        rep(j,7) {\n            if (!used2[i][j] && !cal2[i][j]) {\n                dfs2(i, j);\n                cnt2++;\n            }\n        }\n    }\n    ll cnt3 = 0;\n    if (!cal2[0][0]) cnt3++;\n    REP(i,1,7) if (cal2[0][i-1] && !cal2[0][i]) cnt3++;\n    if (!cal2[1][0]) cnt3++;\n    REP(i,1,7) if (cal2[1][i-1] && !cal2[1][i]) cnt3++;\n    cnt2 = cnt3 - cnt2;\n    ll ans = (n / h) * cnt - (n / h - 1) * cnt2;\n    cout << ans << endl;\n}\n\nint main() {\n    cin.tie(0);\n   \tios::sync_with_stdio(false);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <array>\n#include <stdio.h>\n#include <string.h>\nusing namespace std;\n\nvoid dfs(vector<int>& b, int n7, int j, int c) {\n    if (b[j] != 0) return;\n    b[j] = c;\n    if (j % 7 != 6) dfs(b, n7, j + 1, c);\n    if (j % 7 != 0) dfs(b, n7, j - 1, c);\n    if (j < n7 - 7) dfs(b, n7, j + 7, c);\n    if (j >= 7) dfs(b, n7, j - 7, c);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, m, q;\n    cin >> n >> m >> q;\n    if (n > 100000) throw;\n    int n7 = n * 7;\n    vector<int> b(n7);\n    for (int i = 0; i < q; i++) {\n        int a;\n        cin >> a;\n        if (a >= n7 || b[a] < 0) continue;\n        for (int j = a; j < n7; j += m) {\n            b[j] = -1;\n        }\n    }\n\n    int c = 0;\n    for (int j = 0; j < n7; j++) {\n        if (b[j] != 0) continue;\n        c++;\n        dfs(b, n7, j, c);\n    }\n\n    cout << c << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nconst int MAX = 100000;\nbool black[7 * MAX];\n\nclass UnionFind {\nprivate:\n    const int n;\n    vector<int> uni;\npublic:\n    UnionFind(int _n) : n(_n), uni(_n, -1) {}\n    int root(int x) {\n        if (uni[x] < 0) return x;\n        return uni[x] = root(uni[x]);\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    bool unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (uni[x] > uni[y]) swap(x, y);\n        uni[x] += uni[y];\n        uni[y] = x;\n        return true;\n    }\n    int getSize(int x) {\n        return -uni[root(x)];\n    }\n    int getNumOfWhiteGroup() {\n        int ret = 0;\n        rep(i, n) {\n            if (!black[i] && uni[i] < 0) ret++;\n        }\n        return ret;\n    }\n    void print() {\n        for (auto x : uni) cout << x << \" \";\n        cout << endl;\n    }\n};\n\n// N, E, S, W\nconst int dx[4] = {-1, 0,  1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\nint H, W;\n\nbool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m, q;\n    cin >> n >> m >> q;\n    rep(i, q) {\n        int a;\n        cin >> a;\n        black[a] = true;\n        if (m % 7 != 0) {\n            rep(j, 7) {\n                black[m * j + a] = true;\n            }\n        }\n    }\n\n    if (m % 7 != 0) m *= 7;\n    H = m / 7; W = 7;\n\n    UnionFind uf(m);\n    rep(i, m) {\n        if (black[i]) continue;\n        int x = i / 7, y = i % 7;\n        rep(k, 4) {\n            int nx = x + dx[k], ny = y + dy[k], ni = 7 * nx + ny;\n            if (!inside(nx, ny)) continue;\n            if (!black[ni]) {\n                uf.unite(i, ni);\n            }\n        }\n    }\n\n    int n1 = uf.getNumOfWhiteGroup();\n    int n2 = 0;\n    {\n        set<int> st;\n        int x = H - 1;\n        rep(y, 7) {\n            if (!black[7 * x + y] && !black[y]) {\n                st.insert(uf.root(7 * x + y));\n            }\n        }\n        n2 = st.size();\n    }\n\n    cout << n1 + (n1 - n2) * (7 * n / m - 1) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a <= x && x < b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\nstd::ostream& operator<<(std::ostream& os, const PAIR& r) {\n\tos << \"(\" << r.first << \", \" << r.second << \")\";\n\treturn os;\n}\n\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nint dy4[] = { -1, 0, 1, 0 };\nint dx4[] = { 0, 1, 0, -1 };\n\nint calc(std::vector<std::vector<bool>>& a) {\n\tint cnt = 0;\n\n\tREP(i, a.size()) {\n\t\tREP(j, 7) {\n\t\t\tif (a[i][j]) continue;\n\t\t\t++cnt;\n\t\t\tstd::queue<PAIR> que;\n\t\t\tque.push(PAIR(i, j));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tPAIR now = que.front(); que.pop();\n\t\t\t\ta[now.first][now.second] = true;\n\t\t\t\tREP(d, 4) {\n\t\t\t\t\tint dy = now.first + dy4[d];\n\t\t\t\t\tint dx = now.second + dx4[d];\n\t\t\t\t\tif (!IN(0, dy, a.size()) || !IN(0, dx, 7)) continue;\n\t\t\t\t\tif (a[dy][dx]) continue;\n\t\t\t\t\tque.push(PAIR(dy, dx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, m, q);\n\tVEC(int, a, q);\n\tstd::vector<bool> bb(m, false);\n\tREP(i, q) {\n\t\tbb[a[i]] = true;\n\t}\n\tif (n <= 100000) {\n\t\tstd::vector<std::vector<bool>> b(n, std::vector<bool>(7, false));\n\t\tREP(i, n) REP(j, 7) {\n\t\t\tif (bb[(7 * i + j - 7 + 8 * m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tOUT(calc(b))BR;\n\t\treturn 0;\n\t}\n\n\tstd::vector<int> t(2);\n\tREP(_, 2) {\n\t\tstd::vector<std::vector<bool>> b(m / 7 * (_ + 1), std::vector<bool>(7, false));\n\t\tREP(i, m / 7 * (_ + 1)) REP(j, 7) {\n\t\t\tif (bb[(7 * i + j - 7 + 8*m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tt[_] = calc(b);\n\t}\n\tint x = 7 * n / m;\n\tint d = t[1] - t[0];\n\tOUT(t[0] + (x - 1)*d)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\n\nconst int M_N=400001;\n\nstruct UnionFind{\n    int par[M_N];\n    int rank[M_N];\n\n    void init(int n){\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            rank[i]=0;\n        }\n    }\n\n    int find(int x){\n        if(par[x]==x){\n            return x;\n        }\n        else{\n            return par[x]=find(par[x]);\n        }\n    }\n\n    void unite(int x,int y){\n        x=find(x);\n        y=find(y);\n        if(x==y) return;\n        if(rank[x]<rank[y]){\n            par[x]=y;\n        }\n        else{\n            par[y]=x;\n            if(rank[x]==rank[y]) rank[x]++;\n        }\n    }\n\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n};\n\n\nint main(){\n    LL n,m,q;cin >> n >> m >> q;\n    vector<int> a(q);\n    for (int i = 0; i < q; i++) {\n        cin >> a[i];\n    }\n    LL t = 7 * n / m;\n    vector<vector<int>> v(m, vector<int> (7,0));\n    vector<vector<int>> vv(2 * m, vector<int> (7,0));\n    vector<vector<int>> va(m/7, vector<int> (7,0));\n    vector<vector<int>> vb(2*m/7, vector<int> (7,0));\n    for (int i = 0; i < q; i++) {\n        int y = a[i] / 7, x = a[i] % 7;\n        for (int j = 0; j < 7; j++) {\n            v[m/7*j+y][x] = 1;\n            vv[m/7*j+y][x] = 1;\n            vv[m+m/7*j+y][x] = 1;\n        }\n        va[y][x] = 1;\n        vb[y][x] = 1;\n        vb[m / 7 + y][x] = 1;\n    }\n    auto f = [](vector<vector<int>> &a){\n        int h = a.size(), w = a[0].size();\n        UnionFind uf;\n        uf.init(h*w);\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if(j+1<w && a[i][j] == a[i][j+1]) uf.unite(i*7+j,i*7+j+1);\n                if(i+1<h && a[i][j] == a[i+1][j]) uf.unite(i*7+j,(i+1)*7+j);\n            }\n        }\n        int ret = 0;\n        for (int i = 0; i < h*w; i++) {\n            if(uf.find(i) == i && a[i/7][i%7] == 0) ret++;\n        }\n        return ret;\n    };\n    if(m%7==0){\n        if(t == 1){\n            cout << f(va) << endl;\n        }\n        else if(t == 2){\n            cout << f(vb) << endl;\n        }\n        else{\n            cout << f(va) + (t - 1) * (f(vb) - f(va)) << endl;\n        }\n    }\n    else{\n        t = n / (7 * m);\n        if(t == 1){\n            cout << f(v) << endl;\n        }\n        else if(t == 2){\n            cout << f(vv) << endl;\n        }\n        else{\n            cout << f(v) + (t - 1) * (f(vv) - f(v)) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define maxn 700010\nint a[maxn];\nbool col[100010][7], vis[100010][7];\ntypedef long long ll;\nstruct que {\n\tint x, y;\n} qu[maxn];\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\nint up[7], dw[7], Fa[14];\nint Find(int x) {return Fa[x] == x ? x : Fa[x] = Find(Fa[x]);}\nint main()\n{\n\tll n;\n\tint m, q; scanf(\"%I64d%d%d\", &n, &m, &q);\n\tfor (int i = 1; i <= q; ++i) scanf(\"%d\", &a[i]);\n\tif (m % 7)\n\t{\n\t\tint nq = q;\n\t\tfor (int i = 1; i <= q; ++i)\n\t\t\tfor (int j = 1; j < 7; ++j)\n\t\t\t\ta[++nq] = a[i] + j * m;\n\t\tm *= 7;\n\t}\n\tint mm = m / 7, cnt = 0;\n\tfor (int i = 1; i <= q; ++i) col[a[i] / 7][a[i] % 7] = 1;\n\n\tfor (int i = 0; i < mm; ++i)\n\t\tfor (int j = 0; j < 7; ++j)\n\t\t\tif (!vis[i][j] && !col[i][j])\n\t\t\t{\n\t\t\t\t++cnt;\n\t\t\t\tint head = 0, tail = 1; qu[1] = (que) {i, j}; vis[i][j] = 1;\n\t\t\t\twhile (head < tail)\n\t\t\t\t{\n\t\t\t\t\tque now = qu[++head];\n\t\t\t\t\tfor (int k = 0, nx, ny; k < 4; ++k)\n\t\t\t\t\t{\n\t\t\t\t\t\tnx = now.x + dx[k]; ny = now.y + dy[k];\n\t\t\t\t\t\tif (nx >= 0 && nx < mm && ny >= 0 && ny < 7 && !vis[nx][ny] && !col[nx][ny])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tqu[++tail] = (que) {nx, ny};\n\t\t\t\t\t\t\tvis[nx][ny] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\tprintf(\"%d\\n\", cnt);\n\tint pcnt = 0, cnt2 = 0;\n\tfor (int i = 0; i < 7; ++i) !col[0][i] ? i == 0 || col[0][i - 1] ? up[i] = ++pcnt : up[i] = pcnt : 0;\n\tfor (int i = 0; i < 7; ++i) !col[mm - 1][i] ? i == 0 || col[mm - 1][i - 1] ? dw[i] = ++pcnt : dw[i] = pcnt : 0;\n\tfor (int i = 1; i <= pcnt; ++i) Fa[i] = i;\n\n//\tfor (int i = 0; i < 7; ++i) printf(\"%d %d\\n\", up[i], dw[i]);\n\tfor (int i = 0; i < 7; ++i)\n\t\tif (up[i] && dw[i] && Find(up[i]) != Find(dw[i]))\n\t\t{\n\t\t\tFa[Find(up[i])] = Find(dw[i]);\n\t\t\t++cnt2;\n\t\t}\n//\tprintf(\"%d\\n\", cnt2);\n\tprintf(\"%I64d\\n\", 1ll * cnt * (n / mm) - 1ll * (n / mm - 1) * cnt2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int dh[] = {1, -1, 0, 0};\nconst int dw[] = {0, 0, 1, -1};\n\nint g, cnt1 = 0, cnt2 = 0, cnt3 = 0;\n\nvoid dfs(int h, int w, vector<vector<bool> >& b) {\n\tstack<P> s;\n\ts.push(P(h, w));\n\tbool flag1 = false, flag2 = false;\n\twhile (!s.empty()) {\n\t\tint ch, cw;\n\t\ttie(ch, cw) = s.top();\n\t\ts.pop();\n\t\tb[ch][cw] = true;\n\t\tif (h == 0 && ch == g - 1) {\n\t\t\tif (!flag1) flag2 = true;\n\t\t\tif (w == cw) {\n\t\t\t\tflag2 = false;\n\t\t\t\tflag1 = true;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nh = ch + dh[i], nw = cw + dw[i];\n\t\t\tif (nh < 0 || nh >= g || nw < 0 || nw >= 7) continue;\n\t\t\tif (b[nh][nw]) continue;\n\t\t\ts.push(P(nh, nw));\n\t\t}\n\t}\n\tcnt3 += flag1;\n\tcnt2 += flag2;\n\tcnt1 += !(flag1 || flag2);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n;\n\tint m, q;\n\tcin >> n >> m >> q;\n\tvector<bool> memo(m, false);\n\tfor (int i = 0; i < q; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tmemo[a] = true;\n\t}\n\n\tg = m / __gcd(m, 7);\n\n\tvector< vector<bool> > b(g, vector<bool>(7, false));\n\tfor (int i = 0; i < g; i++) {\n\t\tfor (int j = 0; j < 7; j++) {\n\t\t\tint x = 7 * i + j;\n\t\t\tb[i][j] = memo[x % m];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g; i++) {\n\t\tfor (int j = 0; j < 7; j++) {\n\t\t\tif (!b[i][j]) dfs(i, j, b);\n\t\t}\n\t}\n\n\tll ans = 0;\n\tans += cnt3;\n\tans += (n / g + 1) * cnt2;\n\tans += (n / g) * cnt1;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 666666\nll n;\nint m,q,a[SZ];\nbool cov[SZ];\nint ff[SZ];\nint gf(int x) {return (ff[x]==-1)?x:ff[x]=gf(ff[x]);}\nvoid uni(int a,int b)\n{int ga=gf(a),gb=gf(b);if(ga^gb)ff[ga]=gb;}\nint main()\n{\n\tmemset(ff,-1,sizeof(ff));\n\tscanf(\"%lld%d%d\",&n,&m,&q);\n\tfor(int i=1;i<=q;i++)\n\tscanf(\"%d\",a+i),cov[a[i]]=1;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif(cov[i])continue;\n\t\tif(i+7<m&&!cov[i+7]) uni(i,i+7);\n\t\tif(i%7!=6&&i+1<m&&!cov[i+1]) uni(i,i+1);\n\t}\n\tint ans1=0;\n\tfor(int i=0;i<m;i++)\n\t\tif(!cov[i]) ans1+=gf(i)==i;\n\tmemset(ff,-1,sizeof(ff));\n\tfor(int i=0;i<m+m;i++)\n\t{\n\t\tif(cov[i%m])continue;\n\t\tif(i+7<m+m&&!cov[(i+7)%m]) uni(i,i+7);\n\t\tif(i%7!=6&&i+1<m+m&&!cov[(i+1)%m]) uni(i,i+1);\n\t}\n\tint ans2=0;\n\tfor(int i=0;i<m+m;i++)\n\t\tif(!cov[i%m]) ans2+=gf(i)==i;\n\tll tm=7*n/m;\n\tll ans=(tm-1)*(ans2-ans1)+ans1;\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint d[]={1,-1,7,-7};\n\nint N,M,Q;\nbool f[700000*2];\n\nint a[111111];\n\nint calc(int m){\n    memset(f,0,sizeof(f));\n    for(int i=0;i<Q;i++){\n        for(int j=a[i];j<m;j+=M)f[j]=true;\n    }\n\n    UnionFindTree uf(m);\n\n    rep(i,m){\n        rep(j,4){\n            if(i%7==0&&d[j]==-1)continue;\n            if(i%7==6&&d[j]==1)continue;\n            int nx=i+d[j];\n            if(nx<0||nx>=m)continue;\n            if(f[i]||f[nx])continue;\n            uf.unite(i,nx);\n        }\n    }\n    int res=0;\n    rep(i,m)if(!f[i]&&uf.find(i)==i)res++;\n    return res;\n}\n\nsigned main(){\n    cin>>N>>M>>Q;\n    if(M%7)M*=7;\n    rep(i,Q){\n        cin>>a[i];\n    }\n\n    int x=calc(M);\n    int y=calc(2*M);\n    cout<<x+(y-x)*(N*7/M-1)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nlong long N;\nint M, Q;\nbool X[100000][7];\nbool R[7];\nint A[100001];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> M >> Q;\n  rep(i, Q) {\n    int a;\n    cin >> a;\n    rep(k, 7) {\n      int x = a + k*M;\n      X[x/7][x%7] = true;\n    }\n  }\n  rep(_x, M+1) {\n    int x = (_x)%M;\n    rep(i, 7) R[i] = false;\n    if (_x > 0) {\n      rep(i, 7) {\n        if (!X[x][i] && !X[(x+M-1)%N][i]) R[i] = true;\n      }\n      for (int i=1; i<7; i++) {\n        if (X[x][i]) continue;\n        if (R[i-1]) R[i] = true;\n      }\n      for (int i=5; i>=0; i--) {\n        if (X[x][i]) continue;\n        if (R[i+1]) R[i] = true;\n      }\n    }\n    int c = 0;\n    rep(i, 7) {\n      if (X[x][i] || R[i]) continue;\n      c++;\n      for (int j=i; j<7; j++) {\n        if (X[x][j] || R[j]) break;\n        R[j] = true;\n      }\n    }\n    A[_x] = c;\n  }\n  long long sum = 0;\n  for (int i=1; i<=M; i++) sum += A[i];\n  sum *= (N/M);\n  if (N%M == 0) {\n    sum += A[0] - A[M];\n  }\n  else {\n    rep(i, N%M) {\n      sum += A[i];\n    }\n  }\n  cout<<sum<<\"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\n\n\n\nstruct UnionFind{\n    vector<int> par, rank;\n\n    void init(int n){\n        par.resize(n);\n        rank.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            rank[i]=0;\n        }\n    }\n\n    int find(int x){\n        if(par[x]==x){\n            return x;\n        }\n        else{\n            return par[x]=find(par[x]);\n        }\n    }\n\n    void unite(int x,int y){\n        x=find(x);\n        y=find(y);\n        if(x==y) return;\n        if(rank[x]<rank[y]){\n            par[x]=y;\n        }\n        else{\n            par[y]=x;\n            if(rank[x]==rank[y]) rank[x]++;\n        }\n    }\n\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n};\n\n\nint main(){\n    LL n,m,q;cin >> n >> m >> q;\n    vector<int> a(q);\n    for (int i = 0; i < q; i++) {\n        cin >> a[i];\n    }\n    LL t = 7 * n / m;\n    vector<vector<int>> v(m, vector<int> (7,0));\n    vector<vector<int>> vv(2 * m, vector<int> (7,0));\n    vector<vector<int>> va(m/7, vector<int> (7,0));\n    vector<vector<int>> vb(2*m/7, vector<int> (7,0));\n    for (int i = 0; i < q; i++) {\n        int y = a[i] / 7, x = a[i] % 7;\n        if(m % 7 == 0){\n            va[y][x] = 1;\n            vb[y][x] = 1;\n            vb[m / 7 + y][x] = 1;\n        }\n        else{\n            for (int j = 0; j < 7; j++) {\n                y = (a[i] + m * j) / 7, x = (a[i] + m * j) % 7;\n                v[y][x] = 1;\n                vv[y][x] = 1;\n                vv[y+m][x] = 1;\n            }\n        }\n    }\n    auto f = [](vector<vector<int>> &a){\n        int h = a.size(), w = a[0].size();\n        UnionFind uf;\n        uf.init(h*w);\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if(j+1<w && a[i][j] == a[i][j+1]) uf.unite(i*7+j,i*7+j+1);\n                if(i+1<h && a[i][j] == a[i+1][j]) uf.unite(i*7+j,(i+1)*7+j);\n            }\n        }\n        int ret = 0;\n        for (int i = 0; i < h*w; i++) {\n            if(uf.find(i) == i && a[i/7][i%7] == 0) ret++;\n        }\n        return ret;\n    };\n    if(m%7==0){\n        if(t == 1){\n            cout << f(va) << endl;\n        }\n        else if(t == 2){\n            cout << f(vb) << endl;\n        }\n        else{\n            cout << f(va) + (t - 1) * (f(vb) - f(va)) << endl;\n        }\n    }\n    else{\n        t = n / m;\n        if(t == 1){\n            cout << f(v) << endl;\n        }\n        else if(t == 2){\n            cout << f(vv) << endl;\n        }\n        else{\n            cout << f(v) + (t - 1) * (f(vv) - f(v)) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN=5000010;\n\nint n,m,q,ans;\nint ai[MAXN][8];\nbool pd[MAXN];\n\nvoid dfs(int x,int y)\n{\n\tif (x<0||y<0||x>n-1||y>6||ai[x][y]) return;\n\tai[x][y]=1;\n\tdfs(x,y+1);\n\tdfs(x+1,y);\n\tdfs(x,y-1);\n\tdfs(x-1,y);\n}\nint main()\n{\n\tcin>>n>>m>>q;\n\tfor(int i=1,j;i<=q;i++) cin>>j,pd[j]=true;\n\tfor(int i=0;i<7*n;i++)\n\t\tai[i/7][i%7]=pd[!i%m&&i?m:i%m];\n\t\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<7;j++)\n\t\t\tif (!ai[i][j]) dfs(i,j),ans++;\n\tcout<<ans<<endl;\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\n#define RF(x) freopen(x,\"r\",stdin)\n#define WF(x) freopen(x,\"w\",stdout)\ntypedef long long LL;\nusing namespace std;\ntypedef pair<LL,LL> PLL;\ntypedef pair<int,int> PII;\nconst LL MOD = (LL)1e9+7;\nconst int SIZE = 2e5+5;\nconst LL INF = 1LL<<60;\nconst double eps = 1e-4;\nconst double PI=3.1415926535897932;\n\nvector<int> adj[2000009];\nvector<LL> orow;//occupied rows\nunordered_set<LL> q;\nLL n,m,rowblock;\nbool vis[2000009];\n\nvoid dfs(int x){\n\tfor(int i:adj[x]){\n\t\tif(vis[i])continue;\n\t\tvis[i]=1;dfs(i);\n\t}\n}\n\nLL solve(int bc){//block count\n\tREP(i,2000009)adj[i].clear();\n\tvector<LL> orow2;\n\tREP(i,bc){\n\t\tfor(LL j:orow){\n\t\t\torow2.PB(j+rowblock*i);\n\t\t}\n\t}\n\tMS0(vis);\n\tint nn=0;\n\tREP(i,SZ(orow2)){\n\t\tLL ri=orow2[i];\n\t\tREP(j,7){\n\t\t\tif(q.find((ri*7+j)%m)!=q.end())vis[nn+j]=1;\n\t\t}\n\t\tREP(j,6){\n\t\t\tif((!vis[nn+j])&&(!vis[nn+j+1])){\n\t\t\t\tadj[nn+j].PB(nn+j+1);\n\t\t\t\tadj[nn+j+1].PB(nn+j);\n\t\t\t}\n\t\t}\n\t\tif(i){\n\t\t\tREP(j,7){\n\t\t\t\tif((!vis[nn-7+j])&&(!vis[nn+j])){\n\t\t\t\t\tadj[nn-7+j].PB(nn+j);\n\t\t\t\t\tadj[nn+j].PB(nn-7+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnn+=7;\n\t}\n\tint con=0;\n\tREP(i,nn){\n\t\tif(vis[i])continue;\n\t\tdfs(i);\n\t\tcon++;\n\t}\n\treturn con;\n}\n\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tDRI(qn);//find m value for m rows ? D:\n\trowblock=m;\n\tif(m%7==0)rowblock/=7;\n\tREP(i,qn){\n\t\tDRI(x);\n\t\tq.insert(x);\n\t\twhile(x<rowblock*7){\n\t\t\tLL ri=x/7;\n\t\t\torow.PB(ri);\n\t\t\tx+=m;\n\t\t\tif(ri+1<rowblock)orow.PB(ri+1);\n\t\t}\n\t}\n\torow.PB(0);orow.PB(rowblock-1);\n\tsort(ALL(orow));\n\torow.resize(unique(ALL(orow))-orow.begin());\n\tif(n/rowblock<=3){\n\t\tprintf(\"%lld\\n\",solve(n/rowblock));\n\t}\n\telse{\n\t\tLL v2=solve(2),v3=solve(3);\n\t\tprintf(\"%lld\\n\",(v3-v2)*(n/rowblock-2)+v2);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n \nusing namespace std;\n \ntypedef long long ll;\n \n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(c) (c).begin(), (c).end()\n#define rep(i,a,b) for(ll i=(a);i<(b);++i)\n#define per(i,a,b) for(ll i=(b-1);i>=(a);--i)\n#define clr(a, b) memset((a), (b) ,sizeof(a))\n#define ctos(c) string(1,c)\n#define print(x) cout<<#x<<\" = \"<<x<<endl;\n \n#define MOD 1000000007\n\nvector<int> uf, usz;\nint nc;\n\nvoid init(int n){\n  vector<int> uf_(n);\n  vector<int> usz_(n, 1);\n  uf = uf_;\n  usz = usz_;\n  nc = n;\n\n  for(int i = 0; i < uf.size(); i++){\n    uf[i] = i;\n  }\n}\n\nint find(int a){\n  return (uf[a] == a) ? a : uf[a] = find(uf[a]);\n}\n\nvoid union_(int a, int b){\n  a = find(a);\n  b = find(b);\n\n  if(a != b){\n    if(usz[a] >= usz[b]){\n      swap(a, b);\n    }\n    uf[a] = b;\n    usz[b] += usz[a];\n    nc--;\n  }\n}\n\nint check(int a, int b){\n  return (find(a) == find(b)) ? 1 : 0;\n}\n\nint get_size(int a){\n  return usz[find(a)];\n}\n\nll d[700100];\n\nint main(){\n\tll n,m,q;\n\tcin>>n>>m>>q;\n\tll flag7 = 0;\n\tif(m%7!=0){\n\t\tflag7 = 1;\n\t\tm *= 7;\n\t}\n\tinit(m+1);\n\tclr(d,0);\n\tvector<ll> v;\n\trep(i,0,q){\n\t\tll a;\n\t\tcin>>a;\n\t\tif(flag7==1){\n\t\t\trep(j,0,7){\n\t\t\t\td[a+(m/7)*j] = 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\td[a] = 1;\n\t\t}\n\t}\n\trep(i,0,m){\n\t\tif(d[i]==1){\n\t\t\tunion_(i,m);\n\t\t\tcontinue;\n\t\t}\n\t\tvector<ll> v1;\n\t\tif(i-7>=0)v1.pb(i-7);\n\t\tif(i%7!=0)v1.pb(i-1);\n\t\tif(i%7!=6)v1.pb(i+1);\n\t\tif(i+7<m)v1.pb(i+7);\n\t\trep(j,0,v1.sz){\n\t\t\tif(d[v1[j]]==1)continue;\n\t\t\tunion_(i,v1[j]);\n\t\t}\n\t}\n\tll ans1 = nc-1;\n\tset<ll> se1;\n\tset<pair<ll,ll> > se2; \n\trep(i,0,7){\n\t\tif(d[i]==0&&d[m-7+i]==0){\n\t\t\tll a1 = find(i);\n\t\t\tll b1 = find(m-7+i);\n\t\t\tif(a1==b1)se1.insert(a1);\n\t\t\telse{\n\t\t\t\tse2.insert(mp(max(a1,b1),min(a1,b1)));\n\t\t\t}\n\t\t}\n\t}\n\tvector<ll> v1(all(se1));\n\tvector<pair<ll,ll> > v2(all(se2));\n\tll ans2 = v1.sz;\n\tll ans3 = v2.sz;\n\tll ans4 = 0;\n\trep(i,0,v2.sz){\n\t\tint flag = 1;\n\t\trep(j,0,v1.sz){\n\t\t\tif(v1[j]==v2[i].fi||v1[j]==v2[i].se){\n\t\t\t\tflag = 0;\n\t\t\t}\n\t\t}\n\t\tif(flag == 0){\n\t\t\tans3--;\n\t\t\tans4++;\n\t\t}\n\t}\n\tll a = 7*n/m;\n\tans1 -= (ans2+ans4+ans3*2);\n\tcout << ans1*a+ans2+ans3*(a+1)+ans4 << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nclass UnionFindTree\n{\nprivate:\n    const int n;\n    int groupNum;       // グループの数\n    vector<int> parent; // 親ノード\n    vector<int> rank;   // 木の高さの上限\n    vector<int> num;    // グループの要素数\n    int find(int i){\n        if(parent[i] == i)\n            return i;\n        else\n            return parent[i] = find(parent[i]);\n    }\npublic:\n    UnionFindTree(int n) : n(n){ // コンストラクタ\n        groupNum = n;\n        parent.resize(n);\n        for(int i=0; i<n; ++i)\n            parent[i] = i;\n        rank.assign(n, 0);\n        num.assign(n, 1);\n    }\n    void unite(int a, int b){ // aとbのグループを併合\n        if((a = find(a)) != (b = find(b))){\n            if(rank[a] < rank[b]){\n                parent[a] = b;\n                num[b] += num[a];\n            }\n            else{\n                parent[b] = a;\n                if(rank[a] == rank[b])\n                    ++ rank[a];\n                num[a] += num[b];\n            }\n            -- groupNum;\n        }\n    }\n    bool same(int a, int b){ // aとbのグループが同じかを調べる\n        return find(a) == find(b);\n    }\n    int getNum(){ // グループの数を返す\n        return groupNum;\n    }\n    int getNum(int a){ // aのグループの要素数を返す\n        return num[find(a)];\n    }\n    void getGroup(vector<vector<int> >& group){ // グループ構成を返す\n        map<int, int> index;\n        group.clear();\n        for(int i=0; i<n; ++i){\n            int a = find(i);\n            if(index.find(a) == index.end()){\n                index[a] = group.size();\n                group.resize(group.size() + 1);\n            }\n            group[index[a]].push_back(i);\n        }\n    }\n};\n\nconst int dy[] = {-1, 0, 0, 1};\nconst int dx[] = {0, 1, -1, 0};\n\nint main()\n{\n    long long n;\n    int m, q;\n    cin >> n >> m >> q;\n    vector<bool> rest(m, false);\n    for(int i=0; i<q; ++i){\n        int a;\n        cin >> a;\n        rest[a] = true;\n    }\n\n    int len = m;\n    if(len % 7 != 0)\n        len *= 7;\n\n    vector<bool> black(2*len);\n    for(int i=0; i<2*len; ++i){\n        if(rest[i%m])\n            black[i] = true;\n    }\n\n    UnionFindTree uft(2*len+1);\n    int invalid = 2 * len;\n    for(int i=0; i<len; ++i){\n        int y = i / 7;\n        int x = i % 7;\n        if(black[i]){\n            uft.unite(i, invalid);\n        }\n        else{\n            for(int j=0; j<4; ++j){\n                int y2 = y + dy[j];\n                int x2 = x + dx[j];\n                if(!(0 <= y2 && y2 < len/7 && 0 <= x2 && x2 < 7))\n                    continue;\n                int k = y2 * 7 + x2;\n                if(!black[k])\n                    uft.unite(i, k);\n            }\n        }\n    }\n    int cnt1 = uft.getNum() - len - 1;\n\n    for(int i=len; i<2*len; ++i){\n        int y = i / 7;\n        int x = i % 7;\n        if(black[i]){\n            uft.unite(i, invalid);\n        }\n        else{\n            for(int j=0; j<4; ++j){\n                int y2 = y + dy[j];\n                int x2 = x + dx[j];\n                if(!(0 <= y2 && y2 < 2*len/7 && 0 <= x2 && x2 < 7))\n                    continue;\n                int k = y2 * 7 + x2;\n                if(!black[k])\n                    uft.unite(i, k);\n            }\n        }\n    }\n    int cnt2 = uft.getNum() - cnt1 - 1;\n\n    long long ans = cnt1;\n    ans += (7 * n - len) / len * cnt2;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N,m;\nbool MAP[100001][8];\nbool MOD[100010];\nint a[100010];\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t Q;\n\tin >> N>>m>>Q;\n\tfor (int32_t i = 0; i < Q; ++i)\n\t{\n\t\tin >> a[i];\n\t\tMOD[a[i]] = true;\n\t}\n\n\tif (N <= 100000)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < N; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tout << count << endl;\n\t}\n\telse if (m % 7==0)\n\t{\n\t\tif (Q >= 7)\n\t\t{\n\t\t\tif (Q == m) {\n\t\t\t\tout << 0 << endl;\n\t\t\t}\n\t\t\telse if (a[0] == 0) {\n\t\t\t\tout << N / (m / 7) + (N % (m / 7) > 1 ? 1 : 0) << endl;\n\t\t\t}\n\t\t\telse if (a[Q - 1] + 1 == m) {\n\t\t\t\tout << N / (m / 7) + (N % (m / 7) > 0 ? 1 : 0) << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout << N / (m / 7) + 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tout << 1 << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m,q;\n  cin>>n>>m>>q;\n  vector<Int> a(q);\n  for(Int i=0;i<q;i++) cin>>a[i];\n  vector<Int> d(m,0);\n  for(Int i=0;i<q;i++) d[a[i]]=1;\n\n  Int w=7,h=(m%7?m:m/7);\n  Int dy[]={0,0,1,-1};\n  Int dx[]={1,-1,0,0};\n  auto in=[&](Int y,Int x){return 0<=y&&y<h&&0<=x&&x<w;};\n\n  auto dp=make_v<Int>(h,w);\n  fill_v(dp,-1);\n\n  auto idx=[&](Int y,Int x){return y*w+x;};\n  \n  auto bfs=\n    [&](Int y,Int x,Int p){\n      using P = pair<Int, Int>;\n      queue<P> q;\n      dp[y][x]=p;\n      q.emplace(y,x);\n      while(!q.empty()){\n\ttie(y,x)=q.front();q.pop();\n\tfor(Int k=0;k<4;k++){\n\t  Int ny=y+dy[k],nx=x+dx[k];\n\t  if(!in(ny,nx)||d[idx(ny,nx)]||~dp[ny][nx]) continue;\n\t  dp[ny][nx]=p;\n\t  q.emplace(ny,nx);\n\t}\n      }\n    };\n\n  Int cnt=0;\n  for(Int i=0;i<h;i++)\n    for(Int j=0;j<w;j++)\n      if(!d[idx(i,j)]&&!~dp[i][j])\n\tbfs(i,j,cnt++);\n  \n  Int ans=cnt;\n  Int num=n/h-1;\n  UnionFind uf(cnt*2);\n  for(Int j=0;j<w;j++)\n    if(~dp[0][j]&&~dp[h-1][j])\n      uf.unite(dp[0][j],cnt+dp[h-1][j]);\n  \n  Int dif=-cnt;\n  for(Int i=0;i<cnt*2;i++)\n    if(uf.find(i)==i) dif++;\n  \n  ans+=dif*num;\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  for(int i=0;i<(n);++i)\n#define REPr(i,n) for(int i=(n)-1;i>=0; --i)\n#define FORq(i, m, n) for(int i = (m);i <= (n);++i)\n#define rFORq(i, m , n) for(int i = (n);i >=(m);--i)\n#define SCD(n) scanf(\"%d\",&n)\n#define SCD2(m,n) scanf(\"%d%d\",&m,&n)\n#define SCD3(m,n,k) scanf(\"%d%d%d\",&m,&n,&k)\n#define SCLLD(n) scanf(\"%lld\",&n)\n#define SCLLD2(m,n) scanf(\"%lld%lld\",&m,&n)\n#define SCLLD3(m,n,k) scanf(\"%lld%lld%lld\",&m,&n,&k)\n#define PB push_back\n#define MP make_pair\n#define ARSCD(A,N) REP(i,N){SCD(A[i]);}\n#define ARSCD1(A,N) FORq(i,1,N){SCD(A[i]);}\n#define VSCD(v,N) REP(i,N){int x; SCD(x); v.PB(x);}\n#define VSCLLD(v,N) REP(i,N){long long x; SCLLD(x); v.PB(x);}\n#define PRINTD(n) printf(\"%d\\n\",n)\n#define PRINTLLD(n) printf(\"%lld\\n\",n)\n#define DEBUG printf(\"%s\\n\",\"debug\")\n#define fst first\n#define snd second\n#define SIN(x,S) (S.count(x) != 0)\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector < VI > VVI;\ntypedef vector<long long> VL;\ntypedef long long ll;\ntypedef long long integer;\n////////////////////////////////////////////////////////////////////\nconst ll p = 1000000007;\nll dx[4] = {-7,-1,1,7};\nll N,M,Q;\nstatic ll a[100002] = {};\nstatic bool grid[700003] = {};\nstatic bool visited[700003] = {};\nstatic bool visited2[700003] = {};\n\nvoid dfs0(ll pos){\n    if (visited[pos]) return;\n    visited[pos] = true;\n\n    REP(k,4){\n        ll next = pos + dx[k];\n        if (next >= 7*N) continue;\n        if (next < 0) continue;\n        if ((k==1) and (pos % 7 == 0)) continue;\n        if ((k==2) and (pos % 7 == 6)) continue;\n        if (grid[next]) continue;\n        if (visited[next]) continue;\n        dfs0(next);\n    }\n\n    return;\n}\n\nvoid dfs1(ll pos){\n    if (visited[pos]) return;\n    visited[pos] = true;\n\n    REP(k,4){\n        ll next = pos + dx[k];\n        if (next >= M) continue;\n        if (next < 0) continue;\n        if ((k==1) and (pos % 7 == 0)) continue;\n        if ((k==2) and (pos % 7 == 6)) continue;\n        if (grid[next]) continue;\n        if (visited[next]) continue;\n        dfs1(next);\n    }\n\n    return;\n}\n\nvoid dfs2(ll pos){\n    if (visited2[pos]) return;\n    visited2[pos] = true;\n\n    REP(k,4){\n        ll next = pos + dx[k];\n        if (next >= 2*M) continue;\n        if (next < 0) continue;\n        if ((k==1) and (pos % 7 == 0)) continue;\n        if ((k==2) and (pos % 7 == 6)) continue;\n        if (grid[next]) continue;\n        if (visited2[next]) continue;\n        dfs2(next);\n    }\n\n    return;\n}\n\nvoid solve1(){\n    ll count = 0;\n    FORq(i,0,7*N-1){\n        if ((grid[i] == false) and (visited[i] == false)){\n            dfs0(i);\n            count++;\n        }\n    }\n\n    PRINTLLD(count);\n    return;\n}\n\n\nvoid solve23(){\n    ll count1 = 0;\n    ll count2 = 0;\n\n    FORq(i,0,M-1){\n        if ((grid[i] == false) and (visited[i] == false)){\n            dfs1(i);\n            count1++;\n        }\n    }\n    //printf(\"count1 = %lld\\n\",count1);\n\n    FORq(i,0,2*M-1){\n        if ((grid[i] == false) and (visited2[i] == false)){\n            dfs2(i);\n            count2++;\n        }\n    }\n\n    //printf(\"count2 = %lld\\n\",count2);\n    ll A,B;\n    A = count2 - count1;\n    B = count1 - A;\n    ll c = 7*N / M;\n    PRINTLLD(A*c + B);\n    return;\n}\n\nint main(){\n    SCLLD3(N,M,Q);\n    ARSCD(a,Q);\n\n    REP(q,Q){\n        ll ai = a[q];\n        ll k = 0;\n        while(k*M + ai <= 700001){\n            grid[k*M+ai] = true;\n            k++;\n        }\n    }\n\n    if (N <= 100000){ // #1\n        solve1();\n        return 0;\n    } else if (M % 7 == 0){\n        solve23();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define RREP(i, x, n) for(int i = x; i >= n; i--)\n#define rrep(i, n) RREP(i,n,0)\n#define pb push_back\n#pragma GCC optimize (\"-O3\")\n\nusing namespace std;\n\n// #define DEBUG_IS_VALID\n\n#ifdef DEBUG_IS_VALID\n#define DEB 1 \n#else\n#define DEB 0\n#endif\n#define DUMPOUT cout\n#define dump(...) if(DEB) DUMPOUT<<\"  \"<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl<<\"    \"; if(DEB) dump_func(__VA_ARGS__)\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, pair<T1,T2> p){cout << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate<typename T>ostream& operator << (ostream& os, vector<T>& vec) { os << \"{\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"}\"; return os; }\ntemplate<typename T>ostream& operator << (ostream& os, set<T>& st){for(auto itr = st.begin(); itr != st.end(); itr++) cout << *itr << (next(itr)!=st.end() ? \", \" : \"\"); cout << \"}\"; return os;}\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, map<T1,T2> mp){cout << \"{\"; for(auto itr = mp.begin(); itr != mp.end(); itr++) cout << \"(\" << (itr->first) << \", \" << (itr->second) << \")\" << (next(itr)!=mp.end() ? \",\" : \"\"); cout << \"}\"; return os; }\n\nvoid dump_func(){DUMPOUT << endl;}\ntemplate <class Head, class... Tail>void dump_func(Head&& head, Tail&&... tail){ DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...);}\ntemplate<class T> inline bool chmax(T& a,T const& b){if(a>=b) return false; a=b; return true;}\ntemplate<class T> inline bool chmin(T& a,T const& b){if(a<=b) return false; a=b; return true;}\n\nusing ll = long long;\nusing P = pair<int,int>;\nusing Pl = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\n\nconst int mod=1e9+7,INF=1<<29;\nconst double EPS=1e-12,PI=3.1415926535897932384626;\nconst ll lmod = 1e9+7,LINF=1LL<<59; \n\nstruct UnionFindTree{\n  vector<int> par,rank,size;\n  UnionFindTree(int N){\n    par = rank = vector<int>(N,0);\n    size = vector<int>(N,1);\n    for(int i = 0; i < N; i++) par[i] = i;\n  }\n  int find(int x){\n    if(par[x] == x) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x,int y){\n    x = find(x);\n    y = find(y);\n    if(x == y)  return ;\n    if(rank[x] < rank[y]){\n      par[x] = y;\n    }else{\n      par[y] = x;\n      if(rank[x] == rank[y]) ++rank[x];\n    }\n    size[x] = size[y] = size[x] + size[y];\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll N,M,Q; cin >> N >> M >> Q ;\n  ll sp_sz;\n  if(M%7==0) sp_sz = M;\n  else sp_sz = 7 * M;\n  vector<bool> is_black(sp_sz,false);\n  rep(i,Q){\n    int a; cin >> a ;\n    for(int x = a; x < sp_sz ; x += M){\n      is_black[x] = true;\n    }\n  }\n  UnionFindTree uft(sp_sz*2);\n  vi dx = {-1,0,1,0};\n  vi dy = {0,-1,0,1};\n  rep(i,sp_sz){\n    if(is_black[i]) continue;\n    rep(j,4){\n      int x = i + dx[j]*7 + dy[j];\n      if(x<0 || x>=sp_sz) continue;\n      if(is_black[x]) continue;\n      uft.unite(i,x);\n      uft.unite(i+sp_sz,x+sp_sz);\n    }\n  }\n  ll sz1,sz2;\n  sz1 = sz2 = 0;\n  rep(i,sp_sz){\n    if(is_black[i]) continue;\n    if(uft.par[i]==i) sz1++;\n  }\n  REP(i,sp_sz-7,sp_sz){\n    if(is_black[i]||is_black[(i+7)%sp_sz]) continue;\n    uft.unite(i,i+7);\n  }\n  rep(i,2*sp_sz){\n    if(is_black[i%sp_sz]) continue;\n    if(uft.par[i]==i) sz2++; \n  }\n  dump(is_black);\n  dump(sz1,sz2);\n  ll diff = sz1 * 2 - sz2;\n  ll temp = 7LL*N/sp_sz;\n  // cout << sz1 * temp - diff * (temp-1) << endl;\n  cout << sz1 + (sz1 - diff) * (temp-1) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int M = 7e5 + 5;\nlong long n;\nint m , q;\nint mark[M];\nint inp;\nstruct data{\n\tint top[7];\n\tint bot[7];\n\tlong long ans;\n\tvoid compress(){\n\t\tmap < int , int > mp;\n\t\tmp.clear();\n\t\tfor(int i = 0 ; i < 7 ; ++i){\n\t\t\tif(top[i] != -1){\n\t\t\t\tmp[top[i]];\n\t\t\t}\n\t\t\tif(bot[i] != -1){\n\t\t\t\tmp[bot[i]];\n\t\t\t}\n\t\t}\n\t\tint val = 0;\n\t\tfor(auto &it : mp){\n\t\t\tit.second = val++;\n\t\t}\n\t\tfor(int i = 0 ; i < 7 ; ++i){\n\t\t\tif(top[i] != -1){\n\t\t\t\ttop[i] = mp[top[i]];\n\t\t\t}\n\t\t\tif(bot[i] != -1){\n\t\t\t\tbot[i] = mp[bot[i]];\n\t\t\t}\n\t\t}\n\t}\n};\nint parent[M];\nint find(int node){\n\tif(parent[node] == node){\n\t\treturn node;\n\t}\n\treturn parent[node] = find(parent[node]);\n}\nbool join(int a , int b){\n\tif(find(a) == find(b)){\n\t\treturn 0;\n\t}\n\tparent[find(a)] = find(b);\n\treturn 1;\n}\ndata getbase(){\n\tfor(int i = 0 ; i < m ; ++i){\n\t\tparent[i] = i;\n\t}\n\tint ans = m - q;\n\tfor(int i = 0 ; i < m ; ++i){\n\t\tif(!mark[i]){\n\t\t\tif(i % 7 != 6 && !mark[i + 1]){\n\t\t\t\tans -= join(i , i + 1);\n\t\t\t}\n\t\t\tif(i + 7 < m && !mark[i + 7]){\n\t\t\t\tans -= join(i , i + 7);\n\t\t\t}\n\t\t}\n\t}\n\tdata res;\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(mark[i]){\n\t\t\tres.top[i] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.top[i] = find(i);\n\t\t}\n\t}\n\tfor(int i = m - 7 ; i < m ; ++i){\n\t\tif(mark[i]){\n\t\t\tres.bot[i - m + 7] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.bot[i - m + 7] = find(i);\n\t\t}\n\t}\n\tres.ans = ans;\n\tres.compress();\n\treturn res;\n}\ndata base;\ndata combine(data lft , data rgt){\n\tfor(int i = 0 ; i < 30 ; ++i){\n\t\tparent[i] = i;\n\t}\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(rgt.top[i] != -1){\n\t\t\trgt.top[i] += 14;\n\t\t}\n\t\tif(rgt.bot[i] != -1){\n\t\t\trgt.bot[i] += 14;\n\t\t}\n\t}\n\tdata res;\n\tres.ans = lft.ans + rgt.ans;\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(lft.bot[i] != -1 && rgt.top[i] != -1){\n\t\t\tres.ans -= join(lft.bot[i] , rgt.top[i]);\n\t\t}\n\t}\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(lft.top[i] == -1){\n\t\t\tres.top[i] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.top[i] = find(lft.top[i]);\n\t\t}\n\t\tif(rgt.bot[i] == -1){\n\t\t\tres.bot[i] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.bot[i] = find(rgt.bot[i]);\n\t\t}\n\t}\n\tres.compress();\n\treturn res;\n}\ndata solve(long long n){\n\tif(n == 1){\n\t\treturn base;\n\t}\n\tif(n & 1){\n\t\treturn combine(solve(n - 1) , base);\n\t}\n\tdata tmp = solve(n >> 1);\n\treturn combine(tmp , tmp);\n}\nint main(){\n\tscanf(\"%lld %d %d\" , &n , &m , &q);\n\tfor(int i = 1 ; i <= q ; ++i){\n\t\tscanf(\"%d\" , &inp);\n\t\tmark[inp] = 1;\n\t}\n\t//if(m % 7){\n\t\tfor(int i = m ; i < n * 7 ; ++i){\n\t\t\tmark[i] = mark[i - m];\n\t\t}\n\t\tq *= (n * 7) / m;\n\t\tm = n * 7;\n\t//}\n\tbase = getbase();\n\tprintf(\"%lld\\n\" , solve((7 * n) / m).ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\n#include <string>\n#include <vector>\n#include <algorithm>\n\n#include <cassert>\n\nusing namespace std;\n\n#define SZ(a) int((a).size())\n#define REP(i,n) for(int i=0,_n=(n);i<_n;++i)\n#define FOR(i,a,b) for(int i=(a),_b=(b);i<=_b;++i)\n\ntypedef long long llong;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\n#define MAXM 100004\nllong N, nblocks;\nint M;\nVI A;\n\nint MM;\nchar B[7][MAXM];\n\nint ncomps;\nint C[7][MAXM];\nvoid flood_fill(int r, int c) {\n   if (r < 0 || r >= MM || c < 0 || c >= 7) return;\n   if (B[c][r] == '#') return;\n   if (C[c][r]) return;\n   C[c][r] = ncomps;\n\n   flood_fill(r-1, c);\n   flood_fill(r, c-1);\n   flood_fill(r, c+1);\n   flood_fill(r+1, c);\n}\n\nint dfs(const VVI& adj, VI& vis, int u) {\n   int res = 1;\n   vis[u] = 1;\n   for (int v : adj[u]) {\n      if (!vis[v])\n         res += dfs(adj, vis, v);\n   }\n   return res;\n}\n\nllong solve() {\n   MM = (M % 7) ? M : M/7;\n\n   //cerr << \"MM: \" << MM << endl;\n\n   for (int rem : A) {\n      for (; rem < 7*MM; rem += M) {\n         int r = rem / 7;\n         int c = rem % 7;\n         B[c][r] = '#';\n      }\n   }\n\n   /*\n   REP(r, MM) {\n      REP(c, 7)\n         cerr << B[c][r];\n      cerr << endl;\n   }\n   */\n\n   REP(r, MM) {\n      REP(c, 7) {\n         if (B[c][r] != '#' && C[c][r] == 0) {\n            ++ncomps;\n            flood_fill(r, c);\n         }\n      }\n   }\n\n   /*\n   REP(r, MM) {\n      REP(c, 7)\n         cerr << C[c][r] << ' ';\n      cerr << endl;\n   }\n   */\n   \n   VVI adj(ncomps);\n   REP(c, 7) {\n      int u = C[c][0] - 1, v = C[c][MM-1] - 1;\n      if (u >= 0 && v >= 0) {\n         adj[u].push_back(v);\n         if (u != v)\n            adj[v].push_back(u);\n      }\n   }\n\n   llong nblocks = N / MM;\n   //cerr << \"Number of blocks = \" << nblocks << endl;\n   llong res = 0;\n   VI vis(ncomps);\n   REP(u, ncomps) {\n      if (adj[u].empty())\n         res += nblocks;\n      else if (adj[u][0] == u) {\n         assert(SZ(adj[u]) == 1);\n         ++res;\n      }\n      else if (!vis[u]) {\n         int cnt = dfs(adj, vis, u);\n         FOR(len, 1, cnt-1) {\n            if (nblocks >= len)\n               res += 2;\n         }\n         res += max(nblocks - cnt + 1, 0LL);\n      }\n   }\n\n   return res;\n}\n\n\nint main(int argc, char* argv[]) {\n   ios_base::sync_with_stdio(false); \n   cin.tie(NULL);\n\n   int Q;\n   cin >> N >> M >> Q;\n   memset(B, '.', sizeof(B));\n\n   A = VI(Q);\n   REP(j, Q)\n      cin >> A[j];\n\n   llong res = solve();\n   cout << res << endl;\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 2333333\nll n;\nint m,q,a[SZ];\nbool cov[SZ];\nint ff[SZ];\nint gf(int x) {return (ff[x]==-1)?x:ff[x]=gf(ff[x]);}\nvoid uni(int a,int b)\n{int ga=gf(a),gb=gf(b);if(ga^gb)ff[ga]=gb;}\nint main()\n{\n\tscanf(\"%lld%d%d\",&n,&m,&q);\n\tfor(int i=1;i<=q;i++)\n\tscanf(\"%d\",a+i),cov[a[i]]=1;\n\t#define TJ(r,ans)\\\n\tmemset(ff,-1,sizeof(ff));\\\n\tfor(int i=0;i<r;i++)\\\n\t{\\\n\t\tif(cov[i%m])continue;\\\n\t\tif(i+7<r&&!cov[(i+7)%m]) uni(i,i+7);\\\n\t\tif(i%7!=6&&i+1<r&&!cov[(i+1)%m]) uni(i,i+1);\\\n\t}\\\n\tfor(int i=0;i<r;i++)\\\n\t\tif(!cov[i%m]) ans+=gf(i)==i;\n\tint ans1=0; TJ(m*7,ans1)\n\tint ans2=0; TJ(m*14,ans2)\n\tll rd=7*n/m,zg=rd/7,bf=rd%7,ans=0;\n\tif(zg) ans=ans1+(ans2-ans1)*(zg-1);\n\tint ans3=0; TJ(m*bf,ans3)\n\tint ans4=0; TJ(m*bf+m*7,ans4)\n\tif(zg) ans+=ans4-ans1; else ans+=ans3;\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\nmap<long long,long long> p;\nlong long s[100010];\nlong long n,m,sum;\nvoid dfs(long long x)\n{\n    if(x+7<7*n&&x+7>=0&&p[x+7]==0)\n    {\n        p[x+7]=1;\n        dfs(x+7);\n    }\n    if(x+1<7*n&&x+1>=0&&((x+1)%7!=0)&&p[x+1]==0)\n    {\n        p[x+1]=1;\n        dfs(x+1);\n    }\n    if(x-1<7*n&&x-1>=0&&(x%7!=0)&&p[x-1]==0)\n    {\n        p[x-1]=1;\n        dfs(x-1);\n    }\n    if(x-7<7*n&&x-7>=0&&p[x-7]==0)\n    {\n        p[x-7]=1;\n        dfs(x-7);\n    }\n}\nint main()\n{\n    long long i,j,k,t;\n    while(scanf(\"%lld%lld%lld\",&n,&m,&t)!=EOF)\n    {\n    p.clear();\n    for(i=0;i<t;i++)\n    {\n        scanf(\"%lld\",&s[i]);\n        p[s[i]]=1;\n        for(j=s[i]+m;j<7*n;j=j+m)\n            p[j]=1;\n        for(j=s[i]-m;j>=0;j=j-m)\n            p[j]=1;\n    }\n    sum=0;\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<7;j++)\n        if(p[i*7+j]==0)\n        {\n            sum++;\n            dfs(i*7+j);\n        }\n    }\n    printf(\"%lld\\n\",sum);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define rep1(i,n) for(int i = 1; i < n; i++)\n#define repv(i,n) for(int i = n-1; i >= 0; i--)\n#define fi first\n#define sc second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\n\nchar BUF[3500000];\ninline void I(int&a){scanf(\"%d\",&a);}\ninline void I(int&a,int&b){scanf(\"%d%d\",&a,&b);}\ninline void I(int&a,int&b,int&c){scanf(\"%d%d%d\",&a,&b,&c);}\ninline void I(int&a,int&b,int&c,int&d){scanf(\"%d%d%d%d\",&a,&b,&c,&d);}\ninline void L(ll&a){scanf(\"%lld\",&a);}\ninline void L(ll&a,ll&b){scanf(\"%lld%lld\",&a,&b);}\ninline void L(ll&a,ll&b,ll&c){scanf(\"%lld%lld%lld\",&a,&b,&c);}\ninline void L(ll&a,ll&b,ll&c,ll&d){scanf(\"%lld%lld%lld%lld\",&a,&b,&c,&d);}\ninline void S(string&str){str.clear();scanf(\"%s\",BUF);int s=strlen(BUF);rep(i,s)str.pb(BUF[i]);}\ninline void SV(vector<int>&v){v.clear();scanf(\"%s\",BUF);int s=strlen(BUF);rep(i,s)if('a'<=BUF[i]&&BUF[i]<='z')v.pb(BUF[i]-'a');else v.pb(BUF[i]-'A');}\n\nconst auto EPS = 1e-10;\nconst auto INF = 100000000;\nconst auto MOD = 1000000007;\ntypedef pair<ll,ll> P;\n\nll n;\nint m, q;\nint a[100000];\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nbool b[7][100000], c[7][200000];\n\nll dfs1(int h){\n    ll ret = 0;\n    queue<int> que;\n    rep(i,h) rep(j,7){\n        if(!b[j][i]){\n            ret++;\n            que.push(i*7+j);\n            while(que.size() != 0){\n                int x = que.front()%7, y = que.front()/7; que.pop();\n                rep(k,4){\n                    int yy = y+dy[k], xx = x+dx[k];\n                    if(yy < 0 || xx < 0 || yy >= h || xx >= 7) continue;\n                    if(b[xx][yy]) continue;\n                    b[xx][yy] = true;\n                    que.push(yy*7+xx);\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nll dfs2(int h){\n    ll ret = 0;\n    queue<int> que;\n    rep(i,h) rep(j,7){\n        if(!c[j][i]){\n            ret++;\n            que.push(i*7+j);\n            while(que.size() != 0){\n                int x = que.front()%7, y = que.front()/7; que.pop();\n                rep(k,4){\n                    int yy = y+dy[k], xx = x+dx[k];\n                    if(yy < 0 || xx < 0 || yy >= h || xx >= 7) continue;\n                    if(c[xx][yy]) continue;\n                    c[xx][yy] = true;\n                    que.push(yy*7+xx);\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nint main(){\n    L(n); I(m,q);\n    rep(i,q) I(a[i]);\n    if(m%7 == 0){\n        rep(i,q){\n            b[a[i]%7][a[i]/7] = true;\n            c[a[i]%7][a[i]/7] = true;\n            c[a[i]%7][a[i]/7+m/7] = true;\n        }\n        ll x = dfs1(m/7);\n        ll y = dfs2(2*m/7);\n        cout << x+(y-x)*(7*n/m-1) << endl;\n    } else{\n        rep(i,q){\n            rep(j,7){\n                int tmp = a[i]+m*j;\n                b[tmp%7][tmp/7] = true;\n                c[tmp%7][tmp/7] = true;\n                c[tmp%7][tmp/7+m] = true;\n            }\n        }\n        ll x = dfs1(m);\n        ll y = dfs2(2*m);\n        cout << x+(y-x)*(n/m-1) << endl;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN=10010;\n\nint n,m,q,ans;\nint ai[MAXN][8];\nbool pd[MAXN];\n\nvoid dfs(int x,int y)\n{\n\tif (x<0||y<0||x>n-1||y>6||ai[x][y]) return;\n\tai[x][y]=1;\n\tdfs(x,y+1);\n\tdfs(x+1,y);\n\tdfs(x,y-1);\n\tdfs(x-1,y);\n}\nint main()\n{\n\tcin>>n>>m>>q;\n\tfor(int i=1,j;i<=q;i++) cin>>j,pd[j]=true;\n\tfor(int i=0;i<7*n;i++)\n\t\tai[i/7][i%7]=pd[!i%m&&i?m:i%m];\n\t\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<7;j++)\n\t\t\tif (!ai[i][j]) dfs(i,j),ans++;\n\tcout<<ans<<endl;\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<algorithm>\n#include<vector>\nbool c(const string a,const string b)\n{\n\tif(a.size()!=b.size())return false;\n\tfor(int i=0;i<a.size();i++)\n\t{\n\t\tif(a[i]!=b[i]&&a[i]!='?'&&b[i]!='?')return false;\n\t}\n\treturn true;\n}\nmain()\n{\n\tvector<string>a;int n;cin>>n;\n\tstring t;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>t;\n\t\ta.push_back(t);\n\t}\n\tcin>>t;\n\ta.push_back(t);\n\tsort(a.begin(),a.end());\n\tbool f=false;\n\tfor(int i=0;i<n+1;i++)\n\t{\n\t\tif(c(a[i],t))cout<<(f?\" \":\"\")<<i+1,f=1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define maxn 2000010\nint a[maxn];\nbool col[maxn][7], vis[maxn][7];\ntypedef long long ll;\nstruct que {\n\tint x, y;\n} qu[maxn];\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\nint up[maxn], dw[maxn], Fa[maxn], fcol[maxn][7];\nint Find(int x) {return Fa[x] == x ? x : Fa[x] = Find(Fa[x]);}\nint main()\n{\n\tll n;\n\tint m, q; scanf(\"%lld%d%d\", &n, &m, &q);\n\tfor (int i = 1; i <= q; ++i) scanf(\"%d\", &a[i]);\n\tif (m % 7)\n\t{\n\t\tint nq = q;\n\t\tfor (int i = 1; i <= q; ++i)\n\t\t\tfor (int j = 1; j < 7; ++j)\n\t\t\t\ta[++nq] = a[i] + j * m;\n\t\tm *= 7; q = nq;\n\t}\n\tint mm = m / 7, cnt = 0;\n\n\tfor (int i = 1; i <= q; ++i)\n\t{\n\t\tcol[a[i] / 7][a[i] % 7] = 1;\n//\t\tprintf(\"%d %d\\n\", a[i] / 7, a[i] % 7);\n\t}\n\n\tfor (int i = 0; i < mm; ++i)\n\t\tfor (int j = 0; j < 7; ++j)\n\t\t\tif (!vis[i][j] && !col[i][j])\n\t\t\t{\n\t\t\t\tfcol[i][j] = ++cnt;\n\t\t\t\tint head = 0, tail = 1; qu[1] = (que) {i, j}; vis[i][j] = 1;\n\t\t\t\twhile (head < tail)\n\t\t\t\t{\n\t\t\t\t\tque now = qu[++head];\n\t\t\t\t\tfor (int k = 0, nx, ny; k < 4; ++k)\n\t\t\t\t\t{\n\t\t\t\t\t\tnx = now.x + dx[k]; ny = now.y + dy[k];\n\t\t\t\t\t\tif (nx >= 0 && nx < mm && ny >= 0 && ny < 7 && !vis[nx][ny] && !col[nx][ny])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tqu[++tail] = (que) {nx, ny};\n\t\t\t\t\t\t\tvis[nx][ny] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\tprintf(\"%d\\n\", cnt);\n\tint cnt2 = 0;\n\tfor (int i = 0; i < 7; ++i) up[i] = fcol[0][i];\n\tfor (int i = 0; i < 7; ++i) dw[i] = fcol[mm - 1][i];\n\tfor (int i = 1; i <= cnt; ++i) Fa[i] = i;\n\n//\tfor (int i = 0; i < 7; ++i) printf(\"%d %d\\n\", up[i], dw[i]);\n\tfor (int i = 0; i < 7; ++i)\n\t\tif (up[i] && dw[i] && Find(up[i]) != Find(dw[i]))\n\t\t{\n\t\t\tFa[Find(up[i])] = Find(dw[i]);\n\t\t\t++cnt2;\n\t\t}\n//\tprintf(\"%d\\n\", cnt2);\n//\twhile (n % mm) ;\n\tll ans = 1ll * cnt * (n / mm) - 1ll * (n / mm - 1) * cnt2;\n\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n/*\n1000000000000 28 20\n3 4 5 6 7 8 10 11 12 13 17 18 19 20 22 23 24 25 26 27\n*/"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n \nusing namespace std;\n \n#define int long long\n//typedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD = 1000000007;\n \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint par[1400001];\nint rnk[1400001];\n\nvoid init(int n){\n\tfor(int i = 0;i < n;i++){\n\t\tpar[i] = i;\n\t\trnk[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(par[x] == x) return x;\n\telse return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\tif(rnk[x] < rnk[y]){\n\t\tpar[x] = y;\n\t}else{\n\t\tpar[y] = x;\n\t\tif(rnk[x] == rnk[y]) rnk[x]++;\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nint n,m,q;\nint a[100000];\n\nbool fnd(int x){\n\treturn upper_bound(a,a + q,x) - lower_bound(a,a + q,x);\n}\n\nsigned main(){\n\tint n1,n2;\n\tcin >> n >> m >> q;\n\tinit(m * 7);\n\tint nn,mm;\n\tif(m % 7 == 0){\n\t\tnn = n / (m / 7);\n\t\tmm = m / 7;\n\t}\n\telse{\n\t\tnn = n;\n\t\tmm = m;\n\t}\n\tfor(int i = 0;i < q;i++) cin >> a[i];\n\tfor(int i = 0;i < mm;i++){\n\t\tfor(int j = 0;j < 7;j++){\n\t\t\tif(fnd((i * 7 + j) % m)) continue;\n\t\t\tfor(int k = 0;k < 4;k++){\n\t\t\t\tint nx = i + dx[k],ny = j + dy[k];\n\t\t\t\tif(nx >= 0 && nx < m && ny >= 0 && ny < 7){\n\t\t\t\t\tif(!fnd((nx * 7 + ny) % m)) unite(i * 7 + j,nx * 7 + ny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tset<int> st;\n\tfor(int i = 0;i < mm;i++){\n\t\tfor(int j = 0;j < 7;j++){\n\t\t\tif(fnd((i * 7 + j) % m)) continue;\n\t\t\tst.insert(find(i * 7 + j));\n\t\t}\n\t}\n\tn1 = st.size();\n\tif((m % 7 && n <= m) || (m % 7 == 0 && nn == 1)){\n\t\tcout << n1 << endl;\n\t\treturn 0;\n\t}\n\tinit(m * 14);\n\tfor(int i = 0;i < 2 * mm;i++){\n\t\tfor(int j = 0;j < 7;j++){\n\t\t\tif(fnd((i * 7 + j) % m)) continue;\n\t\t\tfor(int k = 0;k < 4;k++){\n\t\t\t\tint nx = i + dx[k],ny = j + dy[k];\n\t\t\t\tif(nx >= 0 && nx < 2 * m && ny >= 0 && ny < 7){\n\t\t\t\t\tif(!fnd((nx * 7 + ny) % m)) unite(i * 7 + j,nx * 7 + ny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tst.clear();\n\tfor(int i = 0;i < 2 * mm;i++){\n\t\tfor(int j = 0;j < 7;j++){\n\t\t\tif(fnd((i * 7 + j) % m)) continue;\n\t\t\tst.insert(find(i * 7 + j));\n\t\t}\n\t}\n\tn2 = st.size();\n\tif(m % 7) cout << n1 + (n2 - n1) * (n / m - 1) << endl;\n\telse cout << n1 + (n2 - n1) * (nn - 1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M >> K;\n\tvector<int>box(M);\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> L;\n\t\tbox[L] = 1;\n\t}\n\tvector<vector<int>>v(M * 2 / 7, vector<int>(7));\n\tfor (int i = 0; i < M * 2 / 7; i++) {\n\t\tfor (int j = 0; j < 7; j++) {\n\t\t\tv[i][j] = box[(i * 7 + j) % M];\n\t\t}\n\t}\n\tint dir[] = { 1,0,-1,0,1 };\n\tlong long int a = 0, b = 0;\n\tqueue<pair<int, int>>Q;\n\tfor (int i = 0; i < M / 7; i++) {\n\t\tfor (int j = 0; j < 7; j++) {\n\t\t\tif (v[i][j])continue;\n\t\t\ta++;\n\t\t\tQ.push({ i,j });\n\t\t\tv[i][j] = MOD;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint y = Q.front().first;\n\t\t\t\tint x = Q.front().second;\n\t\t\t\tQ.pop();\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint ny = y + dir[k];\n\t\t\t\t\tint nx = x + dir[k + 1];\n\t\t\t\t\tif (ny < 0 || nx < 0 || ny >= M / 7 || nx >= 7)continue;\n\t\t\t\t\tif (v[ny][nx])continue;\n\t\t\t\t\tv[ny][nx] = MOD;\n\t\t\t\t\tQ.push({ ny,nx });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto &i : v) {\n\t\tfor (auto &j : i)j %= MOD;\n\t}\n\tM <<= 1;\n\tfor (int i = 0; i < M / 7; i++) {\n\t\tfor (int j = 0; j < 7; j++) {\n\t\t\tif (v[i][j])continue;\n\t\t\tb++;\n\t\t\tQ.push({ i,j });\n\t\t\tv[i][j] = MOD;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint y = Q.front().first;\n\t\t\t\tint x = Q.front().second;\n\t\t\t\tQ.pop();\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint ny = y + dir[k];\n\t\t\t\t\tint nx = x + dir[k + 1];\n\t\t\t\t\tif (ny < 0 || nx < 0 || ny >= M / 7 || nx >= 7)continue;\n\t\t\t\t\tif (v[ny][nx])continue;\n\t\t\t\t\tv[ny][nx] = MOD;\n\t\t\t\t\tQ.push({ ny,nx });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tb -= a;\n\ta += ((N * 14 / M) - 1)*b;\n\tcout << a << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nlong long n, m, q;\nvector<int> a;\n\nint f(int r){\n    int w = r*7, res = 0;\n    vector<bool> vsd(w, false);\n    for(int i=0;i<q;i++){\n        int v = a[i];\n        while(v < w){\n            vsd[v] = true;\n            v += m;\n        }\n    }\n    for(int i=0;i<w;i++){\n        if(vsd[i]) continue;\n        res++;\n        queue<int> q;\n        q.push(i);\n        while(!q.empty()){\n            int v = q.front();\n            q.pop();\n            if(vsd[v]) continue;\n            vsd[v] = true;\n            if(v%7 > 0 && !vsd[v-1]) q.push(v-1);\n            if(v%7 < 6 && !vsd[v+1]) q.push(v+1);\n            if(v/7 > 0 && !vsd[v-7]) q.push(v-7);\n            if(v+7 < w && !vsd[v+7]) q.push(v+7);\n        }\n    }\n    return res;\n}\n\nint main(void){\n    cin >> n >> m >> q;\n    a.assign(q, 0);\n    for(int i=0;i<q;i++) cin >> a[i];\n    long long x = m, y;\n    if(m%7 == 0) x = m / 7;\n    y = n / x;\n    long long b = f(x);\n    long long a = f(x*2) - b;\n\n    cout << b + a * (y-1) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int M = 7e5 + 5;\nlong long n;\nint m , q;\nint mark[M];\nint inp;\nstruct data{\n\tint top[7];\n\tint bot[7];\n\tlong long ans;\n\tvoid compress(){\n\t\tmap < int , int > mp;\n\t\tmp.clear();\n\t\tfor(int i = 0 ; i < 7 ; ++i){\n\t\t\tif(top[i] != -1){\n\t\t\t\tmp[top[i]];\n\t\t\t}\n\t\t\tif(bot[i] != -1){\n\t\t\t\tmp[bot[i]];\n\t\t\t}\n\t\t}\n\t\tint val = 0;\n\t\tfor(auto &it : mp){\n\t\t\tit.second = val++;\n\t\t}\n\t\tfor(int i = 0 ; i < 7 ; ++i){\n\t\t\tif(top[i] != -1){\n\t\t\t\ttop[i] = mp[top[i]];\n\t\t\t}\n\t\t\tif(bot[i] != -1){\n\t\t\t\tbot[i] = mp[bot[i]];\n\t\t\t}\n\t\t}\n\t}\n};\nint parent[M];\nint find(int node){\n\tif(parent[node] == node){\n\t\treturn node;\n\t}\n\treturn parent[node] = find(parent[node]);\n}\nbool join(int a , int b){\n\tif(find(a) == find(b)){\n\t\treturn 0;\n\t}\n\tparent[find(a)] = find(b);\n\treturn 1;\n}\ndata getbase(){\n\tfor(int i = 0 ; i < m ; ++i){\n\t\tparent[i] = i;\n\t}\n\tint ans = m - q;\n\tfor(int i = 0 ; i < m ; ++i){\n\t\tif(!mark[i]){\n\t\t\tif(i % 7 != 6 && !mark[i + 1]){\n\t\t\t\tans -= join(i , i + 1);\n\t\t\t}\n\t\t\tif(i + 7 < m && !mark[i + 7]){\n\t\t\t\tans -= join(i , i + 7);\n\t\t\t}\n\t\t}\n\t}\n\tdata res;\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(mark[i]){\n\t\t\tres.top[i] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.top[i] = find(i);\n\t\t}\n\t}\n\tfor(int i = m - 7 ; i < m ; ++i){\n\t\tif(mark[i]){\n\t\t\tres.bot[i - m + 7] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.bot[i - m + 7] = find(i);\n\t\t}\n\t}\n\tres.ans = ans;\n\tres.compress();\n\treturn res;\n}\ndata base;\ndata combine(data lft , data rgt){\n\tfor(int i = 0 ; i < 30 ; ++i){\n\t\tparent[i] = i;\n\t}\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(rgt.top[i] != -1){\n\t\t\trgt.top[i] += 14;\n\t\t}\n\t\tif(rgt.bot[i] != -1){\n\t\t\trgt.bot[i] += 14;\n\t\t}\n\t}\n\tdata res;\n\tres.ans = lft.ans + rgt.ans;\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(lft.bot[i] != -1 && rgt.top[i] != -1){\n\t\t\tres.ans -= join(lft.bot[i] , rgt.top[i]);\n\t\t}\n\t}\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(lft.top[i] == -1){\n\t\t\tres.top[i] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.top[i] = find(lft.top[i]);\n\t\t}\n\t\tif(rgt.bot[i] == -1){\n\t\t\tres.bot[i] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.bot[i] = find(rgt.bot[i]);\n\t\t}\n\t}\n\tres.compress();\n\treturn res;\n}\ndata solve(long long n){\n\tif(n == 1){\n\t\treturn base;\n\t}\n\tif(n & 1){\n\t\treturn combine(solve(n - 1) , base);\n\t}\n\tdata tmp = solve(n >> 1);\n\treturn combine(tmp , tmp);\n}\nint main(){\n\tscanf(\"%lld %d %d\" , &n , &m , &q);\n\tfor(int i = 1 ; i <= q ; ++i){\n\t\tscanf(\"%d\" , &inp);\n\t\tmark[inp] = 1;\n\t}\n\tif(m % 7){\n\t\tfor(int i = m ; i < m * 7 ; ++i){\n\t\t\tmark[i] = mark[i - m];\n\t\t}\n\t\tm *= 7;\n\t\tq *= 7;\n\t}\n\tbase = getbase();\n\tprintf(\"%lld\\n\" , solve((7 * n) / m).ans);\n}"
  },
  {
    "language": "C++",
    "code": "/***********************************************\n#\n#      Filename: c.cpp\n#\n#        Author: Comsyl - ylsong15@fudan.edu.cn\n#   Description: ---\n#        Create: 2017-05-19 23:53:20\n***********************************************/\n#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll n;\nint m, q;\nbool vis[100000 + 10];\nbool bao[100000 + 10][7];\nbool used[100000 + 10][7];\n\nvoid paint(int base, int mm) {\n    for (int i = 0; i < mm; ++ i) {\n        if (vis[i % m]) {\n            int r = i / 7;\n            int c = i % 7;\n            bao[r + base][c] = true;\n        }\n    }\n}\n\nint dir[4][2] = {{-1,0}, {0,1}, {1,0}, {0,-1}};\nvoid dfs(int x, int y, int rmax) {\n    used[x][y] = true;\n    for (int i = 0; i < 4; ++ i) {\n        int nx = x + dir[i][0];\n        int ny = y + dir[i][1];\n        if (nx>=0 && nx<rmax && ny>=0 && ny<7 && !used[nx][ny] && !bao[nx][ny]) {\n            dfs(nx, ny, rmax);\n        }\n    }\n}\n\nint main()\n{\n    cin >> n >> m >> q;\n    int r;\n    for (int i = 0; i < q; ++ i) {\n        cin >> r;\n        vis[r] = true;\n    }\n\n    int mm = m;\n    if (m % 7) mm *= 7;\n\n    paint(0, mm);\n    int count1 = 0;\n    for (int i = 0; i < mm/7; ++ i) {\n        for (int j = 0; j < 7; ++ j) {\n            if (!bao[i][j] && !used[i][j]) {\n                dfs(i, j, mm/7);\n                ++ count1;\n            }\n        }\n    }\n\n    paint(mm/7, mm);\n    int count2 = 0;\n    memset(used, false, sizeof(used));\n    for (int i = 0; i < 2*mm/7; ++ i) {\n        for (int j = 0; j < 7; ++ j) {\n            if (!bao[i][j] && !used[i][j]) {\n                dfs(i, j, 2*mm/7);\n                ++ count2;\n            }\n        }\n    }\n\n    cout << count1 * 1L + (count2 - count1) * 1L * (n / (mm/7) - 1L) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\n#include<algorithm>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include <clocale>\n#include<cmath>\n#include<sstream>\n#include<set>\n#include<stack>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int MX=1e5+10;\ntypedef long long ll;\ntypedef pair<int ,int> p;\nint map[MX][8],co[MX][8],vis[MX][8],n;\nint dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nvector<p>vc[10];\nbool ok(int x,int y){\n\treturn !vis[x][y]&&!co[x][y]&&x<=n&&x>=1&&y<=7&&y>=1;\n}\nvoid dfs(int x,int y){\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tint tx=x+dir[i][0];\n\t\tint ty=y+dir[i][1];\n\t\tif(ok(tx,ty)){\n\t\t\tvis[tx][ty]=1;\n\t\t\tdfs(tx,ty);\n\t\t}\n\t}\n}\nint main(){\n\tint m,q,nu;\n\tmemset(co,0,sizeof(co));\n\tcin>>n>>m>>q;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=7;j++){\n\t\t\tnu=(i*7+j-8)%m;\n\t\t\tvc[nu].push_back(p(i,j));\n\t\t}\n\t\twhile(q--){\n\t\t\tcin>>nu;\n\t\t\tfor(int i=0;i<vc[nu].size();i++)\n\t\t\t\tco[vc[nu][i].first][vc[nu][i].second]=1;\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=7;j++)\n\t\t\t\tif(!co[i][j]&&!vis[i][j]){\n\t\t\t\t\tvis[i][j]=1;\n\t\t        dfs(i,j);\n\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",ans);\n    //system(\"pause\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n \nauto& in = std::cin;\nauto& out = std::cout;\n \nint32_t N, m;\nbool MAP[100001][8];\nbool MOD[100010];\nint32_t a[100010];\n \ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) {\n\tarr = v;\n}\ntemplate<typename T, typename ARR>\nvoid fill_all(ARR& arr, const T& v) {\n\tfor (auto& i : arr) { fill_all(i, v); }\n}\n \nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t Q;\n\tin >> N >> m >> Q;\n\tfor (int32_t i = 0; i < Q; ++i)\n\t{\n\t\tin >> a[i];\n\t\tMOD[a[i]] = true;\n\t}\n \n\tif (N <= 100000)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < N; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tout << count << endl;\n\t}\n\telse if ((m % 7) == 0)\n\t{\n\t\tfor (int32_t y = 0; y < (m / 7); ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[(m / 7)][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < (m/7); ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n return 0;\n\t\tint32_t count1 = count;\n \n\t\tfill_all(MAP, false);\n\t\tfor (int32_t y = 0; y < (m / 7) * 2; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[(m / 7) * 2][x] = true;\n\t\t}\n\t\tcount = 0;\n\t\tfor (int32_t y = 0; y < (m / 7)*2; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n \n\t\tout << (count - count1)*((7*N)/m)+count1 << endl;\n\t}\n \n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <cstdio>\n#include <cstdint>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cmath>\n#include <climits>\n#include <bitset>\n\n// macros\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a); i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\n\n// solve\nbool white[800001];\nbool used[800001];\nint b[800001];\nint re;\n\nint dx[4] = {-7, -1, 1, 7};\nint count_a;\n\nvoid dfs(int x){\n  used[x] = true;\n  b[x] = count_a;\n  rep(i, 4){\n    int nx = x + dx[i];\n    if(x % 7 == 0 && nx % 7 == 6)continue;\n    if(x % 7 == 6 && nx % 7 == 0)continue;\n    if(nx >= 0 && nx < re){\n      if(!used[nx] && white[nx]){\n        dfs(nx);\n      }\n    }\n  }\n}\n\nint main(int argc, char const* argv[])\n{\n  ll n;\n  int m, q;\n  cin >> n >> m >> q;\n  vector<int> a(q);\n  rep(i, q){\n    cin >> a[i];\n  }\n  re = (m % 7 == 0) ? m: 7 * m;\n  fill(white, white + re, true);\n  rep(i, q){\n    rep(j, 7){\n      white[a[i] + j * m] = false;\n    }\n  }\n  count_a = 0;\n  rep(i, re){\n    if(!used[i] && white[i]){\n      count_a++;\n      dfs(i);\n    }\n  }\n  set<int> st;\n  rep(i, 7){\n    if(white[i] && white[re-7+i])st.insert(b[i]);\n  }\n  int count_b = int(st.size());\n  cout << (ll)(count_a - count_b) * ((7 * n) / re) + (ll)count_b << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nbool t[7][200020],vis[7][200020];\nlong long n,m,q,a;\n\nvoid DFS(int x,int y,int lim){\n\tvis[x][y]=true;\n\tint dx[]={-1,0,0,1},dy[]={0,1,-1,0};\n\tfor(int i=0;i<4;i++){\n\t\tint a=x+dx[i],b=y+dy[i];\n\t\tif(a>=0&&b>=0&&a<7&&b<lim){\n\t\t\tif(!vis[a][b])DFS(a,b,lim);\n\t\t}\n\t}\n}\nint Sol(int lim){\n\tint ret=0;\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<lim;j++){\n\t\t\tvis[i][j]=t[i][j];\n\t\t\t//cout<<t[i][j]<<\" \";\n\t\t}\n\t\t//cout<<endl;\n\t}\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<lim;j++){\n\t\t\tif(!vis[i][j]){\n\t\t\t\tret++;\n\t\t\t\tDFS(i,j,lim);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tcin>>n>>m>>q;\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tt[i][j]=0;\n\t\t}\n\t}\n\twhile(q--){\n\t\tcin>>a;\n\t\tfor(int i=a;i<14*m;i+=m){\n\t\t\tt[i%7][i/7]=1;\n\t\t}\n\t}\n\n\tlong long k=Sol(m),w=Sol(m*2),ans;\n\tint g=n/m-1;\n\tif(g<=0)ans=Sol(n);\n\telse ans=(g)*(w-k)+Sol(n-(g*m));\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<string>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n//#define scanf scanf_s\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\nconst llint mod=1000000007;\n\n\nint main(void){\n\tllint N,M,q,i,j,a,ansa,ansb,ok=0,ans;\n\tqueue<llint> que;\n\tvector<llint> nuru;\n\tset<llint> siro;\n\tscanf(\"%lld %lld %lld\",&N,&M,&q);\n\tfor(i=0;i<q;i++){\n\t\tscanf(\"%lld\",&a);\n\t\tnuru.pub(a);\n\t}\n\tsort(nuru.begin(),nuru.end());\n\tif(M%7!=0){ M*=7;ok=1; }\n\tfor(i=0;i<M;i++){\n\t\tfor(j=0;j<1+ok*6;j++){\n\t\t\tif(!binary_search(nuru.begin(),nuru.end(),i)){ siro.insert(i+j*M); }\n\t\t}\n\t}\n\tansa=0;\n\twhile(siro.size()!=0){\n\t\tque.push(*siro.begin());\n\t\twhile(!que.empty()){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tif(a-7>=0&&siro.find(a-7)!=siro.end()){ que.push(a-7); }\n\t\t\tif(a+7<M&&siro.find(a+7)!=siro.end()){ que.push(a+7); }\n\t\t\tif(a%7!=0&&siro.find(a-1)!=siro.end()){ que.push(a-1); }\n\t\t\tif(a%7!=6&&siro.find(a+1)!=siro.end()){ que.push(a+1); }\n\t\t\tsiro.erase(a);\n\t\t}\n\t\tansa++;\n\t}\n\n\tfor(i=0;i<M;i++){\n\t\tfor(j=0;j<1+ok*6;j++){\n\t\t\tif(!binary_search(nuru.begin(),nuru.end(),i)){ siro.insert(i+j*M/7); }\n\t\t}\n\t\tfor(j=0;j<1+ok*6;j++){\n\t\t\tif(!binary_search(nuru.begin(),nuru.end(),i)){ siro.insert(i+j*M/7+M); }\n\t\t}\n\t}\n\tansb=0;\n\twhile(siro.size()!=0){\n\t\tque.push(*siro.begin());\n\t\twhile(!que.empty()){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tif(a-7>=0&&siro.find(a-7)!=siro.end()){ que.push(a-7); }\n\t\t\tif(a+7<2*M&&siro.find(a+7)!=siro.end()){ que.push(a+7); }\n\t\t\tif(a%7!=0&&siro.find(a-1)!=siro.end()){ que.push(a-1); }\n\t\t\tif(a%7!=6&&siro.find(a+1)!=siro.end()){ que.push(a+1); }\n\t\t\tsiro.erase(a);\n\t\t}\n\t\tansb++;\n\t}\n\tans=(ansb-ansa)*N*7/M+(2*ansa-ansb);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nconst int INF = 1e9,MOD = 1e9+7,ohara = 1e6;\nconst ll LINF = 1e18;\nusing namespace std;\n\n#define rep(i,n) for(ll (i)=0;(i)<(int)(n);(i)++)\n#define rrep(i,a,b) for(ll i=(a);i<(b);i++)\n#define rrrep(i,a,b) for(ll i=(a);i>=(b);i--)\n#define all(v) (v).begin(), (v).end()\n#define pb(q) push_back(q)\n#define Size(n) (n).size()\n#define Cout(x) cout<<(x)<<endl\n\nll n,cnt=0,ans=0,a[ohara],b,c,d,cmp,cmpp,m,h,w,x,y,sum=0,pos,q,grid[ohara][10],aa;\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\n//int dy[]={-1,0,1,-1,1,-1,0,1};\n//int dx[]={-1,-1,-1,0,0,1,1,1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"),s;\nbool fl,mem[ohara][10];\nstruct edge{int to,cost;};\n\n//-------------------------↓↓↓↓↓↓------------------------\n\nvoid dfs1(ll i,ll j){\n    mem[i][j]=true;\n    rep(k,4){\n        int nx=j+dx[k],ny=i+dy[k];\n        if(nx>=0&&nx<7&&ny>=0&&ny<n&&!mem[ny][nx]&&!grid[ny][nx]){\n            dfs1(ny,nx);\n        }\n    }\n}\n\nll solve1(){\n    ll ret=0;\n    map<ll,ll> out;\n    rep(i,q)out[a[i]]=1;\n    rep(i,n){\n        rep(j,7){\n            pos=7*i+j;\n            if(out[pos%m]==1){\n                grid[i][j]=1;\n            }\n        }\n    }\n    rep(i,n){\n        rep(j,7){\n            if(!mem[i][j]&&!grid[i][j]){\n                ret++;\n                dfs1(i,j);\n            }\n        }\n    }\n    return ret;\n}\n\nvoid dfs2(ll i,ll j){\n    mem[i][j]=true;\n    rep(k,4){\n        int nx=j+dx[k],ny=i+dy[k];\n        if(nx>=0&&nx<7&&ny>=0&&ny<m/7&&!mem[ny][nx]&&!grid[ny][nx]){\n            dfs2(ny,nx);\n        }\n    }\n}\n\nvoid dfs3(ll i,ll j){\n    mem[i][j]=true;\n    rep(k,4){\n        int nx=j+dx[k],ny=i+dy[k];\n        if(nx>=0&&nx<7&&ny>=0&&ny<m/7+m/7&&!mem[ny][nx]&&!grid[ny][nx]){\n            dfs3(ny,nx);\n        }\n    }\n}\n\nll solve2(){\n    ll ret1=0,ret2=0;\n    map<ll,ll> out;\n    rep(i,q)out[a[i]]=1;\n    rep(i,m/7){\n        rep(j,7){\n            pos=7*i+j;\n            if(out[pos%m]==1){\n                grid[i][j]=1;\n            }\n        }\n    }\n    rep(i,m/7){\n        rep(j,7){\n            if(!mem[i][j]&&!grid[i][j]){\n                ret1++;\n                dfs2(i,j);\n            }\n        }\n    }\n    rep(i,m/7){\n        rep(j,7){\n            mem[i][j]=false;\n        }\n    }\n    rrep(i,m/7,m/7+m/7){\n        rep(j,7){\n            pos=7*i+j;\n            if(out[pos%m]==1){\n                grid[i][j]=1;\n            }\n        }\n    }\n    rep(i,m/7+m/7){\n        rep(j,7){\n            if(!mem[i][j]&&!grid[i][j]){\n                ret2++;\n                dfs3(i,j);\n            }\n        }\n    }\n    aa=ret2-ret1;\n    b=ret1-aa;\n    ll kaisuu;\n    kaisuu=n/(m/7);\n    return aa*kaisuu+b;\n}\n\nint main(void){\n       cin.tie(0);\n    ios::sync_with_stdio(false);\n      \n    cin>>n>>m>>q;\n    rep(i,q)cin>>a[i];\n    if(n<=100000)ans=solve1();\n    else if(m%7==0)ans=solve2();\n    Cout(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N,m;\nbool MAP[100001][8];\nbool MOD[100000];\nint a[100000];\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t Q;\n\tin >> N>>m>>Q;\n\tfor (int32_t i = 0; i < Q; ++i)\n\t{\n\t\tin >> a[i];\n\t\tMOD[a[i]] = true;\n\t}\n\n\tif (N <= 100000)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < N; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tout << count << endl;\n\t}\n\telse if (m % 7==0)\n\t{\n\t\tif (Q >= 7)\n\t\t{\n\t\t\tif (Q == m) {\n\t\t\t\tout << 0 << endl;\n\t\t\t}\n\t\t\telse if (a[0] == 0) {\n\t\t\t\tout << N / (m / 7) + (N % (m / 7) > 1 ? 1 : 0) << endl;\n\t\t\t}\n\t\t\telse if (a[Q - 1] + 1 == m) {\n\t\t\t\tout << N / (m / 7) + (N % (m / 7) > 0 ? 1 : 0) << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout << N / (m / 7) + 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tout << 1 << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\n\n#if 0\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N,Q;\nstd::vector<int32_t> parent[100000];\nstd::vector<int32_t> child[100000];\nint32_t V[100000];\nvoid add(int32_t i, int32_t d, int32_t v)\n{\n\tV[i] += v;\n\tif (d > 0) {\n\t\tfor (auto& c : child[i]) {\n\t\t\tadd(c, d - 1, v);\n\t\t}\n\t}\n}\nint64_t sum(int32_t i, int32_t d)\n{\n\tint64_t res = V[i];\n\tif (d > 0) {\n\t\tfor (auto& c : child[i]) {\n\t\t\tres += sum(c, d - 1);\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\n\tin >> N>>Q;\n\tif ((int64_t)(N*Q)>1000000000) {\n\t\treturn 0;\n\t}\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tint p, v;\n\t\tin >> p >> V[i];\n\t\tif (p != -1) { parent[i].push_back(p); child[p].push_back(i); }\n\t}\n\tfor (int32_t loop = 0; loop < Q; ++loop)\n\t{\n\t\tint type;\n\t\tin >> type;\n\t\tif (type == 1) {\n\t\t\tint p, d, v;\n\t\t\tin >> p >> d >> v;\n\t\t\tadd(p, d, v);\n\t\t}\n\t\telse if (type == 2) {\n\t\t\tint p, d;\n\t\t\tin >> p >> d;\n#ifdef _DEBUG\n\t\t\tout << \"OUTPUT:\";\n#endif\n\t\t\tout << sum(p, d) << endl;\n\t\t}\n\t\telse if (type == 3) {\n\t\t\tint p;\n\t\t\tin >> p >> V[N];\n\t\t\tif (p != -1) { parent[N].push_back(p); child[p].push_back(N); }\n\t\t\t++N;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\n\n#if 0\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t ask(const std::string& s) {\n#ifdef _DEBUG\n#endif\n\tint32_t t;\n\tout << \"? \" << s << std::endl;\n\tin >> t;\n\treturn t;\n}\n\nconstexpr int32_t N = 200;//頂点数\nstd::vector<int32_t> graph[N];//木\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t t; in >> t;\n\tstd::string s(N,'0');\n\tint32_t count = 0;\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\ts[i] = '1';\n\t\tfor (int32_t j = i+1; j < N; ++j)\n\t\t{\n\t\t\ts[j] = '1';\n\n\t\t\tt = ask(s);\n\t\t\tif (t == 1) {\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\t++count;\n\t\t\t\tif (count >= N-1) {\n\t\t\t\t\tgoto res_out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts[j] = '0';\n\t\t}\n\t\ts[i] = '0';\n\t}\nres_out:\n\tout << '!';\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tfor (auto& j : graph[i]) {\n\t\t\tout << \" (\" << i << ',' << j << ')';\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n#if 0\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N;\n\nconstexpr int32_t MAX_N = 300000;//頂点数\nconstexpr int32_t MAX_LOGN = 30;//log2頂点数\nstd::unordered_map<int32_t, double> graph[MAX_N];//木\ndouble get(int32_t v, int32_t p) {\n\tauto& memo = graph[v][p];\n\tif (memo >= 0 && p != -1) {\n\t\treturn memo;\n\t}\n\tint32_t count = 0;\n\tdouble sum = 0;\n\tfor (auto& c : graph[v]) {\n\t\tif (c.first != p && c.first != -1) {\n\t\t\t++count;\n\t\t\tsum += get(c.first, v) + 1;\n\t\t}\n\t}\n\tif (count == 0) {\n\t\treturn memo = 0;\n\t}\n\treturn memo = sum / count;\n}\nbool CASE_HACK_MODE = true;\nint32_t center1 = -1;\nint32_t center2 = -1;\nvoid input_tree()\n{\n\tin >> N;\n\tfor (int32_t i = 0; i < N - 1; ++i)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tgraph[a][b] = -1;\n\t\tgraph[b][a] = -1;\n\t\tif (center1 == -1) { center1 = a; center2 = b; }\n\t\telse {\n\t\t\tif (a == center1 || a == center2) {\n\t\t\t\tcenter1 = a;\n\t\t\t}\n\t\t\telse if (b == center1 || b == center2) {\n\t\t\t\tcenter1 = b;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tCASE_HACK_MODE = false;\n\t\t\t}\n\n\t\t\tcenter2 = -1;\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tout << std::fixed << std::setprecision(9);\n\tinput_tree();\n\tif (!CASE_HACK_MODE)\n\t{\n\t\tfor (int32_t i = 0; i < N; ++i)\n\t\t{\n\t\t\tout << get(i, -1) << endl;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tout << ((i == center1) ? 1.0 : 2.0) << endl;\n\t}\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a <= x && x < b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\nstd::ostream& operator<<(std::ostream& os, const PAIR& r) {\n\tos << \"(\" << r.first << \", \" << r.second << \")\";\n\treturn os;\n}\n\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nint dy4[] = { -1, 0, 1, 0 };\nint dx4[] = { 0, 1, 0, -1 };\n\nint calc(std::vector<std::vector<bool>>& a) {\n\tint cnt = 0;\n\n\tREP(i, a.size()) {\n\t\tREP(j, 7) {\n\t\t\tif (a[i][j]) continue;\n\t\t\t++cnt;\n\t\t\tstd::queue<PAIR> que;\n\t\t\tque.push(PAIR(i, j));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tPAIR now = que.front(); que.pop();\n\t\t\t\ta[now.first][now.second] = true;\n\t\t\t\tREP(d, 4) {\n\t\t\t\t\tint dy = now.first + dy4[d];\n\t\t\t\t\tint dx = now.second + dx4[d];\n\t\t\t\t\tif (!IN(0, dy, a.size()) || !IN(0, dx, 7)) continue;\n\t\t\t\t\tif (a[dy][dx]) continue;\n\t\t\t\t\tque.push(PAIR(dy, dx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, m, q);\n\tVEC(int, a, q);\n\tstd::vector<bool> bb(m, false);\n\tREP(i, q) {\n\t\tbb[a[i]] = true;\n\t}\n\tif (n <= 100000) {\n\t\tstd::vector<std::vector<bool>> b(n, std::vector<bool>(7, false));\n\t\tREP(i, n) REP(j, 7) {\n\t\t\tif (bb[((7 * i + j - 7) % m + m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tOUT(calc(b))BR;\n\t\treturn 0;\n\t}\n\n\tstd::vector<int> t(2);\n\tREP(_, 2) {\n\t\tstd::vector<std::vector<bool>> b(m / 7 * (_ + 1), std::vector<bool>(7, false));\n\t\tREP(i, m / 7 * (_ + 1)) REP(j, 7) {\n\t\t\tif (bb[(7 * i + j - 7 + 8 * m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tt[_] = calc(b);\n\t}\n\tint x = 7 * n / m;\n\tint d = t[1] - t[0];\n\tOUT(t[0] + (x - 1)*d)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "int main(void){\n\tllint N,M,q,i,j,a,ansa,ansb,ok=0,ans;\n\tqueue<llint> que;\n\tvector<llint> nuru;\n\tset<llint> siro;\n\tscanf(\"%lld %lld %lld\",&N,&M,&q);\n\tfor(i=0;i<q;i++){\n\t\tscanf(\"%lld\",&a);\n\t\tnuru.pub(a);\n\t}\n\tsort(nuru.begin(),nuru.end());\n\tif(M%7!=0){ M*=7;ok=1; }\n\tfor(i=0;i<M;i++){\n\t\tfor(j=0;j<1+ok*6;j++){\n\t\t\tif(!binary_search(nuru.begin(),nuru.end(),i)){ siro.insert(i+j*M/7); }\n\t\t}\n\t}\n\tansa=0;\n\twhile(siro.size()!=0){\n\t\tque.push(*siro.begin());\n\t\twhile(!que.empty()){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tif(a-7>=0&&siro.find(a-7)!=siro.end()){ que.push(a-7); }\n\t\t\tif(a+7<M&&siro.find(a+7)!=siro.end()){ que.push(a+7); }\n\t\t\tif(a%7!=0&&siro.find(a-1)!=siro.end()){ que.push(a-1); }\n\t\t\tif(a%7!=6&&siro.find(a+1)!=siro.end()){ que.push(a+1); }\n\t\t\tsiro.erase(a);\n\t\t}\n\t\tansa++;\n\t}\n\n\tfor(i=0;i<M;i++){\n\t\tfor(j=0;j<1+ok*6;j++){\n\t\t\tif(!binary_search(nuru.begin(),nuru.end(),i)){ siro.insert(i+j*M/7); }\n\t\t}\n\t\tfor(j=0;j<1+ok*6;j++){\n\t\t\tif(!binary_search(nuru.begin(),nuru.end(),i)){ siro.insert(i+j*M/7+M); }\n\t\t}\n\t}\n\tansb=0;\n\twhile(siro.size()!=0){\n\t\tque.push(*siro.begin());\n\t\twhile(!que.empty()){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tif(a-7>=0&&siro.find(a-7)!=siro.end()){ que.push(a-7); }\n\t\t\tif(a+7<2*M&&siro.find(a+7)!=siro.end()){ que.push(a+7); }\n\t\t\tif(a%7!=0&&siro.find(a-1)!=siro.end()){ que.push(a-1); }\n\t\t\tif(a%7!=6&&siro.find(a+1)!=siro.end()){ que.push(a+1); }\n\t\t\tsiro.erase(a);\n\t\t}\n\t\tansb++;\n\t}\n\tans=(ansb-ansa)*N*7/M+(2*ansa-ansb);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n#define rrep(i,x) for(int i=(int)x-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(int)x;i>=1;--i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nsigned main()\n{\n    int n,m,q;cin>>n>>m>>q;    \n\n    if (n > 100000) return 1;\n\n    static int calendar[100000][7];\n\n    rep(i, q) {\n        int a; cin >> a;\n        for (int i = a; i < 7 * n; i += m) {\n            calendar[i / 7][i % 7] = 1;\n        }\n    }\n\n    int ans = 0;\n\n    static int dy[4] = {-1,0,1,0};\n    static int dx[4] = {0,-1,0,1};\n\n    rep(i, n) {\n        rep(j, 7) {\n            if (calendar[i][j] == 0) {\n                ans += 1;\n                queue<pii> q;\n                q.push(pii(i, j));\n                calendar[i][j] = 1;\n                \n                while (q.size()) {\n                    pii p = q.front(); q.pop();\n                    rep(k, 4) {\n                        int ny = p.fst + dy[k], nx = p.scd + dx[k];\n                        if (ny < 0 || ny >= n || nx < 0 || nx >= 7) continue;\n                        if (calendar[ny][nx] == 0) {\n                            calendar[ny][nx] = 1;\n                            q.push(pii(ny, nx));\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <cstdio>\n#include <cstdint>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cmath>\n#include <climits>\n#include <bitset>\n\n// macros\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a); i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\n\n// solve\nbool white[800001];\nbool used[800001];\nint b[800001];\nint re;\n\nint dx[4] = {-7, -1, 1, 7};\nint count_a;\n\nvoid dfs(int x){\n  used[x] = true;\n  b[x] = count_a;\n  rep(i, 4){\n    int nx = x + dx[i];\n    if(nx >= 0 && nx < re){\n      if(!used[nx] && white[nx]){\n        dfs(nx);\n      }\n    }\n  }\n}\n\nint main(int argc, char const* argv[])\n{\n  ll n;\n  int m, q;\n  cin >> n >> m >> q;\n  vector<int> a(q);\n  rep(i, q){\n    cin >> a[i];\n  }\n  re = (m % 7 == 0) ? m: 7 * m;\n  fill(white, white + re, true);\n  rep(i, q){\n    rep(j, 7){\n      white[a[i] + j * m] = false;\n    }\n  }\n  count_a = 0;\n  rep(i, re){\n    if(!used[i] && white[i]){\n      count_a++;\n      dfs(i);\n    }\n  }\n  set<int> st;\n  rep(i, 7){\n    if(white[i] && white[re-7+i])st.insert(b[re-7+i]);\n  }\n  int count_b = int(st.size());\n  cout << (ll)(count_a - count_b) * ((7 * n) / re) + (ll)count_b << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n \nauto& in = std::cin;\nauto& out = std::cout;\n \nint32_t N, m;\nbool MAP[100001][8];\nbool MOD[100010];\nint32_t a[100010];\n \ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) {\n\tarr = v;\n}\ntemplate<typename T, typename ARR>\nvoid fill_all(ARR& arr, const T& v) {\n\tfor (auto& i : arr) { fill_all(i, v); }\n}\n \nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t Q;\n\tin >> N >> m >> Q;\n\tfor (int32_t i = 0; i < Q; ++i)\n\t{\n\t\tin >> a[i];\n\t\tMOD[a[i]] = true;\n\t}\n \n\tif (N <= 100000)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < N; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tout << count << endl;\n\t}\n\telse if ((m % 7) == 0)\n\t{\n\t\tfor (int32_t y = 0; y < (m / 7); ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[(m / 7)][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < (m/7); ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tint32_t count1 = count;\n \n\t\tfill_all(MAP, false);\n\t\tfor (int32_t y = 0; y < (m / 7) * 2; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[(m / 7) * 2][x] = true;\n\t\t}\n\t\tcount = 0;\n\t\tfor (int32_t y = 0; y < (m / 7)*2; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\nif(m==0){return 0;}\n\t\tout << (count - count1)*((7*N)/m)+count1 << endl;\n\t}\n \n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\n#define REP(i,a,b) for(ll i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\nll gcd(ll a, ll b) {\n    if (b > a) swap(a, b);\n    while (b) {\n        ll t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nll lcm(ll a, ll b) {\n    return a / gcd(a, b) * b;\n}\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\n\nll n, m, q;\nll h;\nint used[707070][7] = {};\nint cal[707070][7] = {};\nint used2[2][7] = {};\nint cal2[2][7] = {};\n\nvoid dfs(int y, int x) {\n    used[y][x] = 1;\n    rep(i,4) {\n        if (y + dy[i] >= 0 && y + dy[i] < h && x + dx[i] >= 0 && x + dx[i] < 7 && !used[y + dy[i]][x + dx[i]] && !cal[y + dy[i]][x + dx[i]]) {\n            dfs(y + dy[i], x + dx[i]);\n        }\n    }\n}\n\nvoid dfs2(int y, int x) {\n    used2[y][x] = 1;\n    rep(i,4) {\n        if (y + dy[i] >= 0 && y + dy[i] < 2 && x + dx[i] >= 0 && x + dx[i] < 7 && !used2[y + dy[i]][x + dx[i]] && !cal2[y + dy[i]][x + dx[i]]) {\n            dfs2(y + dy[i], x + dx[i]);\n        }\n    }\n}\n\nvoid solve() {\n    cin >> n >> m >> q;\n    h = lcm(7, m) / 7;\n    rep(i,q) {\n        ll a;\n        cin >> a;\n        for (ll j = a; j < 7 * h; j += m) {\n            cal[j/7][j%7] = 1;\n        }\n        if (a % m == 0) cal[0][0] = 1;\n    }\n    ll cnt = 0;\n    rep(i,h) {\n        rep(j,7) {\n            if (!used[i][j] && !cal[i][j]) {\n                dfs(i, j);\n                cnt++;\n            }\n        }\n    }\n    rep(i,7) cal2[0][i] = cal[h-1][i];\n    rep(i,7) cal2[1][i] = cal[0][i];\n    ll cnt2 = 0;\n    rep(i,2) {\n        rep(j,7) {\n            if (!used2[i][j] && !cal2[i][j]) {\n                dfs2(i, j);\n                cnt2++;\n            }\n        }\n    }\n    ll cnt3 = 0;\n    if (!cal2[0][0]) cnt3++;\n    REP(i,1,7) if (cal2[0][i-1] && !cal2[0][i]) cnt3++;\n    if (!cal2[1][0]) cnt3++;\n    REP(i,1,7) if (cal2[1][i-1] && !cal2[1][i]) cnt3++;\n    cnt2 = cnt3 - cnt2;\n    ll ans = (n / h) * cnt - (n / h - 1) * cnt2;\n    cout << ans << endl;\n}\n\nint main() {\n    cin.tie(0);\n   \tios::sync_with_stdio(false);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nlong n;int m,q,a[1<<17];\nbool f[7][1<<17];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid bfs(int x,int y,long _n)\n{\n\tqueue<pair<int,int> >P;\n\tf[x][y]=true;\n\tP.push(make_pair(x,y));\n\twhile(!P.empty())\n\t{\n\t\tpair<int,int>p=P.front();P.pop();\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint tx=p.first+dx[r],ty=p.second+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=7||ty>=_n||f[tx][ty])continue;\n\t\t\tf[tx][ty]=true;\n\t\t\tP.push(make_pair(tx,ty));\n\t\t}\n\t}\n}\nmain()\n{\n\tcin>>n>>m>>q;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tif(n<=100000)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong ans=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t\tbfs(i,j,n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\telse if(m%7==0)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,m/7*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,m/7*3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=count2-count1;\n\t\tlong syokou=count1-kousa*2;\n\t\tcout<<syokou+kousa*(n/(m/7))<<endl;\n\t}\n\telse\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<2*m;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<2*m;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,2*m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n-n/m*m+m;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count3=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n-n/m*m+m;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount3++;\n\t\t\t\t\tbfs(i,j,n-n/m*m+m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=count2-count1;\n\t\tlong syokou=count1-kousa;\n\t\tlong amari=count3-syokou-kousa;\n\t\tcout<<syokou+kousa*(n/m)+amari<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\n#include<algorithm>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include <clocale>\n#include<cmath>\n#include<sstream>\n#include<set>\n#include<stack>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int MX=1e7+10;\ntypedef long long ll;\ntypedef pair<int ,int> p;\nint co[MX][8],vis[MX][8],n;\nint dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nvector<p>vc[10];\nbool ok(int x,int y){\n\treturn !vis[x][y]&&!co[x][y]&&x<=n&&x>=1&&y<=7&&y>=1;\n}\nvoid dfs(int x,int y){\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tint tx=x+dir[i][0];\n\t\tint ty=y+dir[i][1];\n\t\tif(ok(tx,ty)){\n\t\t\tvis[tx][ty]=1;\n\t\t\tdfs(tx,ty);\n\t\t}\n\t}\n}\nint main(){\n\tint m,q,nu;\n\tmemset(co,0,sizeof(co));\n\tcin>>n>>m>>q;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=7;j++){\n\t\t\tnu=(i*7+j-8)%m;\n\t\t\tvc[nu].push_back(p(i,j));\n\t\t}\n\t\twhile(q--){\n\t\t\tcin>>nu;\n\t\t\tfor(int i=0;i<vc[nu].size();i++)\n\t\t\t\tco[vc[nu][i].first][vc[nu][i].second]=1;\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=7;j++)\n\t\t\t\tif(!co[i][j]&&!vis[i][j]){\n\t\t\t\t\tvis[i][j]=1;\n\t\t        dfs(i,j);\n\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",ans);\n   // system(\"pause\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n\nusing namespace std;\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n\nconst int white=-1;\nconst int black=100000000;\n\n\nvi gx, gy;\n\n\nvoid push(int x, int y)\n{\n\tgx.push_back(x);\n\tgy.push_back(y);\n}\n\n\nint pop(int& x, int& y)\n{\n\tif(gx.size()<=0) return 0;\n\tx=gx.back();\n\ty=gy.back();\n\tgx.pop_back();\n\tgy.pop_back();\n\treturn 1;\n}\n\n\nvoid eng_fill(vvi& c, int x, int y, int g)\n{\n\tint vx[]={ 1, 0,-1, 0};\n\tint vy[]={ 0,-1, 0, 1};\n\tint nx, ny;\n\tint w, h;\n\n\tw=7;\n\th=c.size();\n\tpush(x, y);\n\tc[y][x]=g;\n\twhile(pop(x, y))\n\t{\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tnx=x+vx[i];\n\t\t\tny=y+vy[i];\n\t\t\tif(nx<0 || w<=nx || ny<0 || h<=ny) continue;\n\t\t\tif(c[ny][nx]!=white) continue;\n\t\t\tc[ny][nx]=g;\n\t\t\tpush(nx, ny);\n\t\t}\n\t}\n}\n\n\n\nint engroup(vvi& c)\n{\n\tint w, h, x, y;\n\tint g=0;\n\n\tw=7;\n\th=c.size();\n\tfor(y=0;y<h;y++)\n\t{\n\t\tfor(x=0;x<w;x++)\n\t\t{\n\t\t\tif(c[y][x]!=white) continue;\n\t\t\teng_fill(c, x, y, g);\n\t\t\tg++;\n\t\t}\n\t}\n\treturn g;\n}\n\n\nint gcd(int a, int b)\n{\n\tint c;\n\twhile((c=a%b))\n\t{\n\t\ta=b;\n\t\tb=c;\n\t}\n\treturn b;\n}\n\n\nint lcm(int a, int b)\n{\n\treturn a/gcd(a, b)*b;\n}\n\n\nint main(void)\n{\n\tint n, m, q, g1, g2, h, uh;\n\tvvi c, f;\n\tvi a;\n\n\twhile(scanf(\"%d%d%d\", &n, &m, &q)==3)\n\t{\n\t\ta.resize(n);\n\t\tfor(int i=0;i<q;i++) scanf(\"%d\", &a[i]);\n\n\t\tuh=lcm(m, 7)/7;\n\t\th=n/uh;\n\n\t\tc.clear();\n\t\tc.resize(uh);\n\t\tfor(auto& ce: c) ce.resize(7, white);\n\t\tfor(int i=0;i<q;i++)\n\t\t{\n\t\t\tfor(int j=a[i];j<uh*7;j+=m)\n\t\t\t{\n\t\t\t\tc[j/7][j%7]=black;\n\t\t\t}\n\t\t}\n\t\tg1=engroup(c);\n\n\t\tc.clear();\n\t\tc.resize(uh*2);\n\t\tfor(auto& ce: c) ce.resize(7, white);\n\t\tfor(int i=0;i<q;i++)\n\t\t{\n\t\t\tfor(int j=a[i];j<uh*2*7;j+=m)\n\t\t\t{\n\t\t\t\tc[j/7][j%7]=black;\n\t\t\t}\n\t\t}\n\t\tg2=engroup(c);\n\n\t\tprintf(\"%d\\n\", g1+(g2-g1)*(h-1));\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define maxn 700010\nint a[maxn];\nbool col[maxn][7], vis[maxn][7];\ntypedef long long ll;\nstruct que {\n\tint x, y;\n} qu[maxn * 7];\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\nint up[7], dw[7], Fa[14];\nint Find(int x) {return Fa[x] == x ? x : Fa[x] = Find(Fa[x]);}\nint main()\n{\n\tll n;\n\tint m, q; scanf(\"%lld%d%d\", &n, &m, &q);\n\tfor (int i = 1; i <= q; ++i) scanf(\"%d\", &a[i]);\n\tif (m % 7)\n\t{\n\t\tint nq = q;\n\t\tfor (int i = 1; i <= q; ++i)\n\t\t\tfor (int j = 1; j < 7; ++j)\n\t\t\t\ta[++nq] = a[i] + j * m;\n\t\tm *= 7; q = nq;\n\t}\n\tint mm = m / 7, cnt = 0;\n\n\tfor (int i = 1; i <= q; ++i) col[a[i] / 7][a[i] % 7] = 1;\n\n\tfor (int i = 0; i < mm; ++i)\n\t\tfor (int j = 0; j < 7; ++j)\n\t\t\tif (!vis[i][j] && !col[i][j])\n\t\t\t{\n\t\t\t\t++cnt;\n\t\t\t\tint head = 0, tail = 1; qu[1] = (que) {i, j}; vis[i][j] = 1;\n\t\t\t\twhile (head < tail)\n\t\t\t\t{\n\t\t\t\t\tque now = qu[++head];\n\t\t\t\t\tfor (int k = 0, nx, ny; k < 4; ++k)\n\t\t\t\t\t{\n\t\t\t\t\t\tnx = now.x + dx[k]; ny = now.y + dy[k];\n\t\t\t\t\t\tif (nx >= 0 && nx < mm && ny >= 0 && ny < 7 && !vis[nx][ny] && !col[nx][ny])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tqu[++tail] = (que) {nx, ny};\n\t\t\t\t\t\t\tvis[nx][ny] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\tprintf(\"%d\\n\", cnt);\n\tint pcnt = 0, cnt2 = 0;\n\tfor (int i = 0; i < 7; ++i) !col[0][i] ? i == 0 || col[0][i - 1] ? up[i] = ++pcnt : up[i] = pcnt : 0;\n\tfor (int i = 0; i < 7; ++i) !col[mm - 1][i] ? i == 0 || col[mm - 1][i - 1] ? dw[i] = ++pcnt : dw[i] = pcnt : 0;\n\tfor (int i = 1; i <= pcnt; ++i) Fa[i] = i;\n\n//\tfor (int i = 0; i < 7; ++i) printf(\"%d %d\\n\", up[i], dw[i]);\n\tfor (int i = 0; i < 7; ++i)\n\t\tif (up[i] && dw[i] && Find(up[i]) != Find(dw[i]))\n\t\t{\n\t\t\tFa[Find(up[i])] = Find(dw[i]);\n\t\t\t++cnt2;\n\t\t}\n//\tprintf(\"%d\\n\", cnt2);\n//\twhile (n % mm) ;\n\tll ans = 1ll * cnt * (n / mm) - 1ll * (n / mm - 1) * cnt2;\n\twhile (ans < 0) ;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nlong long N;\nint M, Q;\nbool X[100000][7];\nbool R[7];\nint A[100001];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> M >> Q;\n  rep(i, Q) {\n    int a;\n    cin >> a;\n    rep(k, 7) {\n      int x = a + k*M;\n      X[x/7][x%7] = true;\n    }\n  }\n  if (N == 0) {\n    cout << 0 << \"\\n\";\n    return 0;\n  }\n  rep(_x, M+1) {\n    int x = (_x)%M;\n    rep(i, 7) R[i] = false;\n    if (_x > 0) {\n      rep(i, 7) {\n        if (!X[x][i] && !X[(x+M-1)%M][i]) R[i] = true;\n      }\n      for (int i=1; i<7; i++) {\n        if (X[x][i]) continue;\n        if (R[i-1]) R[i] = true;\n      }\n      for (int i=5; i>=0; i--) {\n        if (X[x][i]) continue;\n        if (R[i+1]) R[i] = true;\n      }\n    }\n    int c = 0;\n    rep(i, 7) {\n      if (X[x][i] || R[i]) continue;\n      c++;\n      for (int j=i; j<7; j++) {\n        if (X[x][j] || R[j]) break;\n        R[j] = true;\n      }\n    }\n    A[_x] = c;\n  }\n  long long sum = 0;\n  for (int i=1; i<=M; i++) sum += A[i];\n  sum *= (N/M);\n  if (N%M == 0) {\n    sum += A[0] - A[M];\n  }\n  else {\n    rep(i, N%M) {\n      sum += A[i];\n    }\n  }\n  cout<<sum<<\"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N,m;\nbool MAP[100001][8];\nbool MOD[100010];\nint32_t a[100010];\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t Q;\n\tin >> N>>m>>Q;\n\tfor (int32_t i = 0; i < Q; ++i)\n\t{\n\t\tin >> a[i];\n\t\tMOD[a[i]] = true;\n\t}\n\n\tif (N <= 100000)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < N; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tout << count << endl;\n\t}\n\telse if (m % 7==0)\n\t{\n\t\tif (Q >= 7)\n\t\t{\n\t\t\tif (Q == m) {\n\t\t\t\tout << 0 << endl;\n\t\t\t}\n\t\t\telse if (a[0] == 0) {\n\t\t\t\tout << N / (m / 7) + (N % (m / 7) > 1 ? 1 : 0) << endl;\n\t\t\t}\n\t\t\telse if (a[Q - 1] + 1 == m) {\n\t\t\t\tout << N / (m / 7) + (N % (m / 7) > 0 ? 1 : 0) << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout << N / (m / 7) + 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tout << 1 << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\n\n#if 0\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N,Q;\nstd::vector<int32_t> parent[100000];\nstd::vector<int32_t> child[100000];\nint32_t V[100000];\nvoid add(int32_t i, int32_t d, int32_t v)\n{\n\tV[i] += v;\n\tif (d > 0) {\n\t\tfor (auto& c : child[i]) {\n\t\t\tadd(c, d - 1, v);\n\t\t}\n\t}\n}\nint64_t sum(int32_t i, int32_t d)\n{\n\tint64_t res = V[i];\n\tif (d > 0) {\n\t\tfor (auto& c : child[i]) {\n\t\t\tres += sum(c, d - 1);\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\n\tin >> N>>Q;\n\tif ((int64_t)(N*Q)>1000000000) {\n\t\treturn 0;\n\t}\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tint p, v;\n\t\tin >> p >> V[i];\n\t\tif (p != -1) { parent[i].push_back(p); child[p].push_back(i); }\n\t}\n\tfor (int32_t loop = 0; loop < Q; ++loop)\n\t{\n\t\tint type;\n\t\tin >> type;\n\t\tif (type == 1) {\n\t\t\tint p, d, v;\n\t\t\tin >> p >> d >> v;\n\t\t\tadd(p, d, v);\n\t\t}\n\t\telse if (type == 2) {\n\t\t\tint p, d;\n\t\t\tin >> p >> d;\n#ifdef _DEBUG\n\t\t\tout << \"OUTPUT:\";\n#endif\n\t\t\tout << sum(p, d) << endl;\n\t\t}\n\t\telse if (type == 3) {\n\t\t\tint p;\n\t\t\tin >> p >> V[N];\n\t\t\tif (p != -1) { parent[N].push_back(p); child[p].push_back(N); }\n\t\t\t++N;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\n\n#if 0\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t ask(const std::string& s) {\n#ifdef _DEBUG\n#endif\n\tint32_t t;\n\tout << \"? \" << s << std::endl;\n\tin >> t;\n\treturn t;\n}\n\nconstexpr int32_t N = 200;//頂点数\nstd::vector<int32_t> graph[N];//木\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t t; in >> t;\n\tstd::string s(N,'0');\n\tint32_t count = 0;\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\ts[i] = '1';\n\t\tfor (int32_t j = i+1; j < N; ++j)\n\t\t{\n\t\t\ts[j] = '1';\n\n\t\t\tt = ask(s);\n\t\t\tif (t == 1) {\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\t++count;\n\t\t\t\tif (count >= N-1) {\n\t\t\t\t\tgoto res_out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts[j] = '0';\n\t\t}\n\t\ts[i] = '0';\n\t}\nres_out:\n\tout << '!';\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tfor (auto& j : graph[i]) {\n\t\t\tout << \" (\" << i << ',' << j << ')';\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n#if 0\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N;\n\nconstexpr int32_t MAX_N = 300000;//頂点数\nconstexpr int32_t MAX_LOGN = 30;//log2頂点数\nstd::unordered_map<int32_t, double> graph[MAX_N];//木\ndouble get(int32_t v, int32_t p) {\n\tauto& memo = graph[v][p];\n\tif (memo >= 0 && p != -1) {\n\t\treturn memo;\n\t}\n\tint32_t count = 0;\n\tdouble sum = 0;\n\tfor (auto& c : graph[v]) {\n\t\tif (c.first != p && c.first != -1) {\n\t\t\t++count;\n\t\t\tsum += get(c.first, v) + 1;\n\t\t}\n\t}\n\tif (count == 0) {\n\t\treturn memo = 0;\n\t}\n\treturn memo = sum / count;\n}\nbool CASE_HACK_MODE = true;\nint32_t center1 = -1;\nint32_t center2 = -1;\nvoid input_tree()\n{\n\tin >> N;\n\tfor (int32_t i = 0; i < N - 1; ++i)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tgraph[a][b] = -1;\n\t\tgraph[b][a] = -1;\n\t\tif (center1 == -1) { center1 = a; center2 = b; }\n\t\telse {\n\t\t\tif (a == center1 || a == center2) {\n\t\t\t\tcenter1 = a;\n\t\t\t}\n\t\t\telse if (b == center1 || b == center2) {\n\t\t\t\tcenter1 = b;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tCASE_HACK_MODE = false;\n\t\t\t}\n\n\t\t\tcenter2 = -1;\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tout << std::fixed << std::setprecision(9);\n\tinput_tree();\n\tif (!CASE_HACK_MODE)\n\t{\n\t\tfor (int32_t i = 0; i < N; ++i)\n\t\t{\n\t\t\tout << get(i, -1) << endl;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tout << ((i == center1) ? 1.0 : 2.0) << endl;\n\t}\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\n#define REP(i,a,b) for(ll i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\nll gcd(ll a, ll b) {\n    if (b > a) swap(a, b);\n    while (b) {\n        ll t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nll lcm(ll a, ll b) {\n    return a / gcd(a, b) * b;\n}\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\n\nll n, m, q;\nll h;\nint used[101010][7] = {};\nint cal[101010][7] = {};\nint used2[2][7] = {};\nint cal2[2][7] = {};\n\nvoid dfs(int y, int x) {\n    used[y][x] = 1;\n    rep(i,4) {\n        if (y + dy[i] >= 0 && y + dy[i] < h && x + dx[i] >= 0 && x + dx[i] < 7 && !used[y + dy[i]][x + dx[i]] && !cal[y + dy[i]][x + dx[i]]) {\n            dfs(y + dy[i], x + dx[i]);\n        }\n    }\n}\n\nvoid dfs2(int y, int x) {\n    used2[y][x] = 1;\n    rep(i,4) {\n        if (y + dy[i] >= 0 && y + dy[i] < 2 && x + dx[i] >= 0 && x + dx[i] < 7 && !used2[y + dy[i]][x + dx[i]] && !cal2[y + dy[i]][x + dx[i]]) {\n            dfs2(y + dy[i], x + dx[i]);\n        }\n    }\n}\n\nvoid solve() {\n    cin >> n >> m >> q;\n    h = lcm(7, m) / 7;\n    rep(i,q) {\n        ll a;\n        cin >> a;\n        for (ll j = a; j < 7 * h; j += m) {\n            if (cal[j/7][j%7]) break;\n            cal[j/7][j%7] = 1;\n        }\n    }\n    ll cnt = 0;\n    rep(i,h) {\n        rep(j,7) {\n            if (!used[i][j] && !cal[i][j]) {\n                dfs(i, j);\n                cnt++;\n            }\n        }\n    }\n    rep(i,7) cal2[0][i] = cal[h-1][i];\n    rep(i,7) cal2[1][i] = cal[0][i];\n    ll cnt2 = 0;\n    rep(i,2) {\n        rep(j,7) {\n            if (!used2[i][j] && !cal2[i][j]) {\n                dfs2(i, j);\n                cnt2++;\n            }\n        }\n    }\n    ll cnt3 = 0;\n    if (!cal2[0][0]) cnt3++;\n    REP(i,1,7) if (cal2[0][i-1] && !cal2[0][i]) cnt3++;\n    if (!cal2[1][0]) cnt3++;\n    REP(i,1,7) if (cal2[1][i-1] && !cal2[1][i]) cnt3++;\n    cnt2 = cnt3 - cnt2;\n    ll ans = (n / h) * cnt - (n / h - 1) * cnt2\n    cout << ans << endl;\n}\n\nint main() {\n    cin.tie(0);\n   \tios::sync_with_stdio(false);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nconst int INF = 1e9,MOD = 1e9+7,ohara = 1e6;\nconst ll LINF = 1e18;\nusing namespace std;\n\n#define rep(i,n) for(ll (i)=0;(i)<(int)(n);(i)++)\n#define rrep(i,a,b) for(ll i=(a);i<(b);i++)\n#define rrrep(i,a,b) for(ll i=(a);i>=(b);i--)\n#define all(v) (v).begin(), (v).end()\n#define pb(q) push_back(q)\n#define Size(n) (n).size()\n#define Cout(x) cout<<(x)<<endl\n\nll n,cnt=0,ans=0,a[ohara],b,c,d,cmp,cmpp,m,h,w,x,y,sum=0,pos,q,grid[ohara][10],aa;\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\n//int dy[]={-1,0,1,-1,1,-1,0,1};\n//int dx[]={-1,-1,-1,0,0,1,1,1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"),s;\nbool fl,mem[ohara][10];\nstruct edge{int to,cost;};\n\n//-------------------------↓↓↓↓↓↓------------------------\n\nvoid dfs1(ll i,ll j){\n    mem[i][j]=true;\n    rep(k,4){\n        int nx=j+dx[k],ny=i+dy[k];\n        if(nx>=0&&nx<7&&ny>=0&&ny<n&&!mem[ny][nx]&&!grid[ny][nx]){\n            dfs1(ny,nx);\n        }\n    }\n}\n\nll solve1(){\n    ll ret=0;\n    map<ll,ll> out;\n    rep(i,q)out[a[i]]=1;\n    rep(i,n){\n        rep(j,7){\n            pos=7*i+j;\n            if(out[pos%m]==1){\n                grid[i][j]=1;\n            }\n        }\n    }\n    rep(i,n){\n        rep(j,7){\n            if(!mem[i][j]&&!grid[i][j]){\n                ret++;\n                dfs1(i,j);\n            }\n        }\n    }\n    return ret;\n}\n\nvoid dfs2(ll i,ll j){\n    mem[i][j]=true;\n    rep(k,4){\n        int nx=j+dx[k],ny=i+dy[k];\n        if(nx>=0&&nx<7&&ny>=0&&ny<m/7&&!mem[ny][nx]&&!grid[ny][nx]){\n            dfs2(ny,nx);\n        }\n    }\n}\n\nvoid dfs3(ll i,ll j){\n    mem[i][j]=true;\n    rep(k,4){\n        int nx=j+dx[k],ny=i+dy[k];\n        if(nx>=0&&nx<7&&ny>=0&&ny<m/7+m/7&&!mem[ny][nx]&&!grid[ny][nx]){\n            dfs3(ny,nx);\n        }\n    }\n}\n\nll solve2(){\n    ll ret1=0,ret2=0;\n    map<ll,ll> out;\n    rep(i,q)out[a[i]]=1;\n    rep(i,m/7){\n        rep(j,7){\n            pos=7*i+j;\n            if(out[pos%m]==1){\n                grid[i][j]=1;\n            }\n        }\n    }\n    rep(i,m/7){\n        rep(j,7){\n            if(!mem[i][j]&&!grid[i][j]){\n                ret1++;\n                dfs2(i,j);\n            }\n        }\n    }\n    rep(i,m/7){\n        rep(j,7){\n            mem[i][j]=false;\n        }\n    }\n    rrep(i,m/7,m/7+m/7){\n        rep(j,7){\n            pos=7*i+j;\n            if(out[pos%m]==1){\n                grid[i][j]=1;\n            }\n        }\n    }\n    rep(i,m/7+m/7){\n        rep(j,7){\n            if(!mem[i][j]&&!grid[i][j]){\n                ret2++;\n                dfs3(i,j);\n            }\n        }\n    }\n    aa=ret2-ret1;\n    b=ret1-aa;\n    ll kaisuu;\n    kaisuu=n/(m/7);\n    return aa*kaisuu+b;\n}\n\nvoid dfs4(ll i,ll j){\n    mem[i][j]=true;\n    rep(k,4){\n        int nx=j+dx[k],ny=i+dy[k];\n        if(nx>=0&&nx<7&&ny>=0&&ny<m&&!mem[ny][nx]&&!grid[ny][nx]){\n            dfs4(ny,nx);\n        }\n    }\n}\n\nvoid dfs5(ll i,ll j){\n    mem[i][j]=true;\n    rep(k,4){\n        int nx=j+dx[k],ny=i+dy[k];\n        if(nx>=0&&nx<7&&ny>=0&&ny<m+m&&!mem[ny][nx]&&!grid[ny][nx]){\n            dfs5(ny,nx);\n        }\n    }\n}\n\nll solve3(){\n    ll ret1=0,ret2=0;\n    map<ll,ll> out;\n    rep(i,q)out[a[i]]=1;\n    rep(i,m){\n        rep(j,7){\n            pos=7*i+j;\n            if(out[pos%m]==1){\n                grid[i][j]=1;\n            }\n        }\n    }\n    rep(i,m){\n        rep(j,7){\n            if(!mem[i][j]&&!grid[i][j]){\n                ret1++;\n                dfs4(i,j);\n            }\n        }\n    }\n    rep(i,m){\n        rep(j,7){\n            mem[i][j]=false;\n        }\n    }\n    rrep(i,m,m+m){\n        rep(j,7){\n            pos=7*i+j;\n            if(out[pos%m]==1){\n                grid[i][j]=1;\n            }\n        }\n    }\n    rep(i,m+m){\n        rep(j,7){\n            if(!mem[i][j]&&!grid[i][j]){\n                ret2++;\n                dfs5(i,j);\n            }\n        }\n    }\n    aa=ret2-ret1;\n    b=ret1-aa;\n    ll kaisuu;\n    kaisuu=n/(m);\n    return aa*kaisuu+b;\n}\n\nint main(void){\n       cin.tie(0);\n    ios::sync_with_stdio(false);\n      \n    cin>>n>>m>>q;\n    rep(i,q)cin>>a[i];\n    if(n<=100000)ans=solve1();\n    else if(m%7==0)ans=solve2();\n    else ans=solve3();\n    Cout(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 2333333\nll n;\nint m,q,a[SZ];\nbool cov[SZ];\nint ff[SZ];\nint gf(int x) {return (ff[x]==-1)?x:ff[x]=gf(ff[x]);}\nvoid uni(int a,int b)\n{int ga=gf(a),gb=gf(b);if(ga^gb)ff[ga]=gb;}\nint main()\n{\n\tscanf(\"%lld%d%d\",&n,&m,&q);\n\tfor(int i=1;i<=q;i++)\n\tscanf(\"%d\",a+i),cov[a[i]]=1;\n\tmemset(ff,-1,sizeof(ff));\n\tfor(int i=0;i<m*7;i++)\n\t{\n\t\tif(cov[i%m])continue;\n\t\tif(i+7<m*7&&!cov[(i+7)%m]) uni(i,i+7);\n\t\tif(i%7!=6&&i+1<m*7&&!cov[(i+1)%m]) uni(i,i+1);\n\t}\n\tint ans1=0;\n\tfor(int i=0;i<m*7;i++)\n\t\tif(!cov[i%m]) ans1+=gf(i)==i;\n\tmemset(ff,-1,sizeof(ff));\n\tfor(int i=0;i<m*14;i++)\n\t{\n\t\tif(cov[i%m])continue;\n\t\tif(i+7<m*14&&!cov[(i+7)%m]) uni(i,i+7);\n\t\tif(i%7!=6&&i+1<m*14&&!cov[(i+1)%m]) uni(i,i+1);\n\t}\n\tint ans2=0;\n\tfor(int i=0;i<m*14;i++)\n\t\tif(!cov[i%m]) ans2+=gf(i)==i;\n\tll rd=7*n/m,zg=rd/7,bf=rd%7;\n\tll ans=0;\n\tif(zg) ans=ans1+ans2*(zg-1);\n\tmemset(ff,-1,sizeof(ff));\n\tfor(int i=0;i<m*bf;i++)\n\t{\n\t\tif(cov[i%m])continue;\n\t\tif(i+7<m*bf&&!cov[(i+7)%m]) uni(i,i+7);\n\t\tif(i%7!=6&&i+1<m*bf&&!cov[(i+1)%m]) uni(i,i+1);\n\t}\n\tint ans3=0;\n\tfor(int i=0;i<m*bf;i++)\n\t\tif(!cov[i%m]) ans3+=gf(i)==i;\n\tmemset(ff,-1,sizeof(ff));\n\tfor(int i=0;i<m*bf+m*7;i++)\n\t{\n\t\tif(cov[i%m])continue;\n\t\tif(i+7<m*bf+m*7&&!cov[(i+7)%m]) uni(i,i+7);\n\t\tif(i%7!=6&&i+1<m*bf+m*7&&!cov[(i+1)%m]) uni(i,i+1);\n\t}\n\tint ans4=0;\n\tfor(int i=0;i<m*bf;i++)\n\t\tif(!cov[i%m]) ans4+=gf(i)==i;\n\tif(zg) ans+=ans4-ans3; else ans+=ans3;\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nconst int INF = 1e9,MOD = 1e9+7,ohara = 1e6;\nconst ll LINF = 1e18;\nusing namespace std;\n\n#define rep(i,n) for(ll (i)=0;(i)<(int)(n);(i)++)\n#define rrep(i,a,b) for(ll i=(a);i<(b);i++)\n#define rrrep(i,a,b) for(ll i=(a);i>=(b);i--)\n#define all(v) (v).begin(), (v).end()\n#define pb(q) push_back(q)\n#define Size(n) (n).size()\n#define Cout(x) cout<<(x)<<endl\n\nll n,cnt=0,ans=0,a[ohara],b,c,d,cmp,cmpp,m,h,w,x,y,sum=0,pos,q,grid[ohara][10],aa;\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\n//int dy[]={-1,0,1,-1,1,-1,0,1};\n//int dx[]={-1,-1,-1,0,0,1,1,1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"),s;\nbool fl,mem[ohara][10];\nstruct edge{int to,cost;};\n\n//-------------------------↓↓↓↓↓↓------------------------\n\nbool ok2(){\n    bool ok=true;\n    rep(i,n-1){\n        if(a[i+1]-a[i]!=1)ok=false;\n    }\n    return ok;\n}\n\nvoid dfs1(ll i,ll j){\n    mem[i][j]=true;\n    rep(k,4){\n        int nx=j+dx[k],ny=i+dy[k];\n        if(nx>=0&&nx<7&&ny>=0&&ny<n&&!mem[ny][nx]&&!grid[ny][nx]){\n            dfs1(ny,nx);\n        }\n    }\n}\n\nll solve1(){\n    ll ret=0;\n    map<ll,ll> out;\n    rep(i,q)out[a[i]]=1;\n    rep(i,n){\n        rep(j,7){\n            pos=7*i+j;\n            if(out[pos%m]==1){\n                grid[i][j]=1;\n            }\n        }\n    }\n    rep(i,n){\n        rep(j,7){\n            if(!mem[i][j]&&!grid[i][j]){\n                ret++;\n                dfs1(i,j);\n            }\n        }\n    }\n    return ret;\n}\n\nvoid dfs2(ll i,ll j){\n    mem[i][j]=true;\n    rep(k,4){\n        int nx=j+dx[k],ny=i+dy[k];\n        if(nx>=0&&nx<7&&ny>=0&&ny<m/7&&!mem[ny][nx]&&!grid[ny][nx]){\n            dfs2(ny,nx);\n        }\n    }\n}\n\nvoid dfs3(ll i,ll j){\n    mem[i][j]=true;\n    rep(k,4){\n        int nx=j+dx[k],ny=i+dy[k];\n        if(nx>=0&&nx<7&&ny>=0&&ny<m/7+m/7&&!mem[ny][nx]&&!grid[ny][nx]){\n            dfs3(ny,nx);\n        }\n    }\n}\n\nll solve2(){\n    ll ret1=0,ret2=0;\n    map<ll,ll> out;\n    rep(i,q)out[a[i]]=1;\n    rep(i,m/7){\n        rep(j,7){\n            pos=7*i+j;\n            if(out[pos%m]==1){\n                grid[i][j]=1;\n            }\n        }\n    }\n    rep(i,m/7){\n        rep(j,7){\n            if(!mem[i][j]&&!grid[i][j]){\n                ret1++;\n                dfs2(i,j);\n            }\n        }\n    }\n    rep(i,m/7){\n        rep(j,7){\n            mem[i][j]=false;\n        }\n    }\n    rrep(i,m/7,m/7+m/7){\n        rep(j,7){\n            pos=7*i+j;\n            if(out[pos%m]==1){\n                grid[i][j]=1;\n            }\n        }\n    }\n    rep(i,m/7+m/7){\n        rep(j,7){\n            if(!mem[i][j]&&!grid[i][j]){\n                ret2++;\n                dfs3(i,j);\n            }\n        }\n    }\n    aa=ret2-ret1;\n    b=ret1-aa;\n    ll kaisuu;\n    kaisuu=n/(m/7);\n    return aa*kaisuu+b;\n}\n\nint main(void){\n       cin.tie(0);\n    ios::sync_with_stdio(false);\n      \n    cin>>n>>m>>q;\n    rep(i,q)cin>>a[i];\n    if(n<=100000||ok2())ans=solve1();\n    else if(m%7==0)ans=solve2();\n    Cout(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n;;;;;;;;;;;;::;,.,xOOOOOOOkdoc;,,;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,,'''',,,,,,,,,'',,:cloo:'.\n;;;;;;;;;;:ccccc,'lOOOOOOOOOOOxoc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,,''''''''''',;cloxkOOOOl..\n;;;;;;;;;:cccccc:,;xOOOOOOOOOOOOOxoc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,''''''';:loxkOOOOOOOOk:..\n;;;;;;;;;:cccccc::,ck0OOOOO0OO00OOOOxl:;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,'',;codkO0OOOOOOOOOOOo'..\n;;;;;;;;:cccccc:::;,ck0OOOOOOOOOOOOO0Okoc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:cloxOOOOOOOOOOOOOOOO0x;..'\n;;;;;;;:ccccccc::;;,,:xOOOOO0OOOOOOOOOOOkdc;,;;;;;;;::::ccccccccc:::::cldkOOOOOOOOOOOOOOOOOOO0k:..''\n;;;;;;;:cccccc::;;,,,';dO0OOOOO0OOOOOOOOOOkdodddxxxxkkkOOOOOOOOOOkkkxkkO0OOOOOOOOOOOOOOOOOOO0kc'''''\n;;;;;;;::::::::;;,,,''',cxOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOxc,,,,''\n;;;;;,;;;;;;;;;,,,,'''''',lkOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOko:;;;;,,,\n;;;;,,,,,,,,,,,,''''''''''.,lkOOkxkOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkoc:c:::;;,,\n;;;;'''''''''''''''''''''''..;lodkO0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkxk0Okxocccccc:::;,,\n;;;,'............'''''''''''..;xOOOOOOOOOOOO0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkxdol::::cccc:::;;,,\n;;,'..............''''''''''';dOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOko;;::::::::;;;;,,\n;;'................'''''','',dOOOO0OOOxdoccxOO0OOOOOOOOOOOOOOOOOOOOxdoclxOOOOOOOOOOOo;;;;;;;;;;;;,,'\n;,'................'''''',,,lOOOOOOOOoo00c.;xOOOOOOOOOOOOOOOOOOOOOll0O:.:k0OOOOOOOOOOo,,;;;;;;,,,,''\n,'..................''',,,,ckOOO0OO0Ol,::,.,d0OOOOOOOOOOOOOOOOOOOOc,::,.;x0OOOOOOOOOOkc',,,,,,,,,,''\n,'..................''',,';dOOOOOOOO0kc,,,;oOOO0OO0OO0OOOOOOOOOOOOkc,,,:dOOOOOOOOOOOOOd,',,'''''''''\n'...................''',,,lOOOOOOOOOOOOkxxkOOOOOOOOxdddkOOOOOOOOOOOOkxxOOOOOOOOOOOOOO0kc''''''''''''\n'...................''',,;xOOOkkkOOOOOOOOOOOOOOOOOxo:;:dOOOOOOOOOOOOOOOOOOOOkkkkOOOOOOOd;'''''''''''\n'.................'''',,,ckxollllldkOOOOOOOOOOOOOO0OkkOOOOOOOOOOOOOOOOOOOkdlllllodkOOOOOc'',''''''''\n''''...........'''',,,,,;odccccccccokOOOOOOOOOOOOOOO0OOOOOOOOO0OOOOOOOOOxlcccccccclk0OOOd;,,,,,,,,''\n'''''''',''',,,,,,,;;;;;;ddcccccccclxOOOOOOOOOOOOkxdddddooddkOOOOOOOOOOOdccccccccclx0OOOOl,;;;;,,,,'\n',,,,,,;;;;;;;;;;;:::::;:xOdolclllokOOOOOOOOOOOOxllodddxdddllkOOOOOOOOOOkocccccccldOOOOOOd:;:;;;;;,,\n,,,;;;;:::::::::::::::cc;lOOOkkkkOOOOOOOOOOOOOOOdlodxxdxddxdcdOOOOOOOOOOOOkxdoddxkOOOOOOOOl:::::;;,,\n,,;;::::cccccccccccccccc::dOOOOOOOOOOOOOOOOOOOO0kolldxxxxxxoldOOOOOOOOOOOOOOOOOOOOOOOOOOOOd::c::;;,,\n,,;;:::cccccccccccccccccc:cxOOOOOOOOOOOOOOOOOOOOOOkxoooooooodOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkc:c:::;,,\n,,;;::::cccccccccccccccc:c:cxOOOOOOOOOOOOOOOOOOOOOOOOOkkkkkOO0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOo;:::;;,,\n,;;;;::::ccccccccccccccc:::;ck0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOx::::;;,,\n*/\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,tune=native\")\n//#pragma GCC optimize (\"unroll-loops\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double old;\n\nconst int N = 700100;\n\nint mp[N];\nint cur;\nint len;\n\nvoid dfs(int v) {\n    mp[v] = cur;\n    if (v % 7 && mp[v - 1] == 0) {\n        dfs(v - 1);\n    }\n    if (v % 7 != 6 && mp[v + 1] == 0) {\n        dfs(v + 1);\n    }\n    if (v / 7 && mp[v - 7] == 0) {\n        dfs(v - 7);\n    }\n    if (v + 7 < len && mp[v + 7] == 0) {\n        dfs(v + 7);\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cout << fixed << setprecision(20);\n    ll n;\n    int m, q;\n    cin >> n >> m >> q;\n    if (m == q) {\n        cout << 0;\n        return 0;\n    }\n    len = m;\n    if (len % 7) {\n        len *= 7;\n    }\n    while (q--) {\n        int a;\n        cin >> a;\n        for (int i = a; i < len; i += m) {\n            mp[i] = -1;\n        }\n    }\n    for (int i = 0; i < len; ++i) {\n        if (mp[i] == 0) {\n            ++cur;\n            dfs(i);\n        }\n    }\n    int kek = 0;\n    vector<int> s(cur + 1);\n    for (int i = 0; i < 7; ++i) {\n        if (mp[i] != -1 && mp[i] == mp[i + len - 7]) {\n            s[mp[i]] = 1;\n        }\n    }\n    for (int i = 1; i <= cur; ++i) {\n        kek += s[i];\n    }\n    ll ans = (cur - kek) * (n * 7 / len) + kek;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n\nusing namespace std;\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing ll=long long;\n\n\nconst int white=-1;\nconst int black=100000000;\n\n\nvi gx, gy;\n\n\nvoid push(int x, int y)\n{\n\tgx.push_back(x);\n\tgy.push_back(y);\n}\n\n\nint pop(int& x, int& y)\n{\n\tif(gx.size()<=0) return 0;\n\tx=gx.back();\n\ty=gy.back();\n\tgx.pop_back();\n\tgy.pop_back();\n\treturn 1;\n}\n\n\nvoid eng_fill(vvi& c, int x, int y, int g)\n{\n\tint vx[]={ 1, 0,-1, 0};\n\tint vy[]={ 0,-1, 0, 1};\n\tint nx, ny;\n\tint w, h;\n\n\tw=7;\n\th=c.size();\n\tpush(x, y);\n\tc[y][x]=g;\n\twhile(pop(x, y))\n\t{\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tnx=x+vx[i];\n\t\t\tny=y+vy[i];\n\t\t\tif(nx<0 || w<=nx || ny<0 || h<=ny) continue;\n\t\t\tif(c[ny][nx]!=white) continue;\n\t\t\tc[ny][nx]=g;\n\t\t\tpush(nx, ny);\n\t\t}\n\t}\n}\n\n\n\nint engroup(vvi& c)\n{\n\tint w, h, x, y;\n\tint g=0;\n\n\tw=7;\n\th=c.size();\n\tfor(y=0;y<h;y++)\n\t{\n\t\tfor(x=0;x<w;x++)\n\t\t{\n\t\t\tif(c[y][x]!=white) continue;\n\t\t\teng_fill(c, x, y, g);\n\t\t\tg++;\n\t\t}\n\t}\n\treturn g;\n}\n\n\nint gcd(int a, int b)\n{\n\tint c;\n\twhile((c=a%b))\n\t{\n\t\ta=b;\n\t\tb=c;\n\t}\n\treturn b;\n}\n\n\nint lcm(int a, int b)\n{\n\treturn a/gcd(a, b)*b;\n}\n\n\nint main(void)\n{\n\tint m, q, g, uh, gc;\n\tll n, h;\n\tvvi c, f;\n\n\twhile(scanf(\"%lld%d%d\", &n, &m, &q)==3)\n\t{\n\t\tuh=lcm(m, 7)/7;\n\t\th=n/uh;\n\t\tc.clear();\n\t\tc.resize(uh);\n\t\tfor(auto& ce: c) ce.resize(7, white);\n\n\t\tfor(int i=0;i<q;i++)\n\t\t{\n\t\t\tint a;\n\t\t\tscanf(\"%d\", &a);\n\t\t\tfor(int j=a;j<uh*7;j+=m)\n\t\t\t{\n\t\t\t\tc[j/7][j%7]=black;\n\t\t\t}\n\t\t}\n\t\tg=engroup(c);\n\n\t\tf.clear();\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tint u=c[0][i];\n\t\t\tint l=c[uh-1][i];\n\t\t\tint j;\n\t\t\tif(u==black || l==black) continue;\n\t\t\tif(u>l) swap(u, l);\n\t\t\tvi ft={u,l};\n\t\t\tfor(j=f.size()-1;j>=0;j--)\n\t\t\t{\n\t\t\t\tif(ft==f[j]) break;\n\t\t\t}\n\t\t\tif(j<0)\n\t\t\t{\n\t\t\t\tf.push_back(ft);\n//\t\t\t\tprintf(\"%d %d\\n\", ft[0], ft[1]);\n\t\t\t}\n\t\t}\n\t\tgc=f.size();\n# if 0\nfor(auto ce:c)\n{\n\tfor(int x:ce)\n\t{\n\t\tif(x==black) printf(\" X \");\n\t\telse printf(\"%2d \", x);\n\t}\n\tprintf(\"\\n\");\n}\nprintf(\"g=%d h=%d gc=%d\\n\", g, h, gc);\n#endif\n\t\tint result=g*h-gc*(h-1);\n\t\tprintf(\"%d\\n\", result);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=700003,INF=1<<30;\nvector<vector<int>> state(MAX,vector<int>(7,0));\n\nvector<int> dx={-1,0,0,1},dy={0,-1,1,0};\n\nvoid DFS(int u,int v,int goal,int when){\n    stack<pair<int,int>> ST;\n    ST.push(make_pair(u,v));\n    state[u][v]=when;\n    \n    while(!ST.empty()){\n        int a=ST.top().first,b=ST.top().second;\n        ST.pop();\n        for(int i=0;i<4;i++){\n            int c=a+dx[i],d=b+dy[i];\n            if(c<0||c>=goal||d<0||d>=7) continue;\n            if(state[c][d]==0){\n                ST.push(make_pair(c,d));\n                state[c][d]=when;\n            }\n        }\n    }\n}\n\nint main(){\n    \n    ll N;\n    int M,Q;cin>>N>>M>>Q;\n    vector<int> A(Q);\n    for(int i=0;i<Q;i++){\n        cin>>A[i];\n    }\n    if(M%7==0){\n        for(int i=0;i<Q;i++){\n            int a=A[i]/7,b=A[i]%7;\n            state[a][b]=-1;\n        }\n        int now=0;\n        for(int i=0;i<M/7;i++){\n            for(int j=0;j<7;j++){\n                if(state[i][j]==0){\n                    now++;\n                    DFS(i,j,M/7,now);\n                }\n            }\n        }\n        set<pair<int,int>> se;\n        for(int j=0;j<7;j++){\n            if(state[0][j]>=0&&state[M/7-1][j]>=0) se.insert(make_pair(state[0][j],state[M/7-1][j]));\n        }\n        \n        cout<<7*N/M*now-(7*N/M-1)*se.size()<<endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nll n;\nint m, q;\nint a[100010];\nint memo[10];\nint used[10];\nint dx[] = {1, -1};\n\nint main(void){\n\tcin >> n >> m >> q;\n\trep(i, q) cin >> a[i];\n\n\trep(i, q) memo[a[i] % 7]++;\n\tbool flag = true;\n\tll ans = 0;\n\t// printf(\"k\\n\");\n\trep(i, 7){\n\t\tif(used[i]) continue;\n\t\tans++;\n\t\tqueue<int> q; q.push(i);\n\t\twhile(!q.empty()){\n\t\t\tint t = q.front(); q.pop();\n\t\t\trep(k, 2){\n\t\t\t\tif(memo[i + dx[k]] == 0 && used[i + dx[k]] == 0){\n\t\t\t\t\tq.push(i + dx[k]);\n\t\t\t\t\tused[i + dx[k]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace {\n    using ull = unsigned long long;\n    using ll = long long;\n    #define endl \"\\n\"\n\n    #define REP(i, n) for (ll i = 0; i < n; i++)\n    #define REPR(i, n) for (ll i = n; i >= 0; i--)\n    #define FOR(i, m, n) for (ll i = m; i < n; i++)\n    #define even(x) (x) % 2 == 0\n    #define odd(x) (x) % 2 != 0\n    #define all(x) x.begin(), x.end()\n    #define rall(x) x.rbegin(), x.rend()\n    #define pcnt __builtin_popcount\n    #define buli(x) __builtin_popcountll(x)\n    #define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n    #define inp(t, x) t x;cin>>x;\n    #define ithBit(n, i) ((n)>>(i) & 1)\n    #define INIT() cin.tie(0);ios::sync_with_stdio(0);cout<<fixed<<setprecision(20)\n\n    // these functions return the position of result of Binary Search.\n    #define LB(s, t, x) (int)(lower_bound(s, t, x) - s)\n    #define UB(s, t, x) (int)(upper_bound(s, t, x) - s)\n\n    #define M_PI 3.14159265358979323846\n    ll qp(ll a, ll b, int mo)\n    {\n        ll ans = 1;\n        do\n        {\n            if (b & 1)\n                ans = 1ll * ans * a % mo;\n            a = 1ll * a * a % mo;\n        } while (b >>= 1);\n        return ans;\n    }\n    ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\n    ll lcm(ll a, ll b)\n    {\n        ll temp = gcd(a, b);\n        return temp ? (a / temp * b) : 0;\n    }\n    int mDays[] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n    int dx8[] = {1, -1, 0, 0, 1, 1, -1, -1}, dy8[] = {0, 0, -1, 1, -1, 1, -1, 1};\n\n    template <typename F>\n    class\n    #if defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n        [[nodiscard]]\n    #elif defined(__GNUC__) && __GNUC_PREREQ(3, 4)\n        __attribute__((warn_unused_result))\n    #endif // defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n        FixPoint : F {\n            public :\n                explicit constexpr FixPoint(F &&f) noexcept : F(std::forward<F>(f)) {}\n\n            template <typename... Args>\n            constexpr decltype(auto)\n            operator()(Args &&... args) const {\n                return F::operator()(*this, std::forward<Args>(args)...);\n    } // namespace\n    }\n    ; // class FixPoint\n    template <typename F>\n    static inline constexpr decltype(auto)\n    makeFixPoint(F &&f) noexcept\n    {\n        return FixPoint<F>{std::forward<F>(f)};\n    }\n\n    template <typename T>\n    vector<T> make_v(size_t a) { return vector<T>(a); }\n    template <typename T, typename... Ts>\n    auto make_v(size_t a, size_t b, Ts... ts) { return vector<decltype(make_v<T>(b, ts...))>(a, make_v<T>(b, ts...)); }\n    template <typename T, typename V>\n    typename enable_if<is_class<T>::value == 0>::type\n    fill_v(T &t, const V &v) { t = v; }\n    template <typename T, typename V>\n    typename enable_if<is_class<T>::value != 0>::type\n    fill_v(T &t, const V &v) { for (auto &e : t) fill_v(e, v); }\n\n    template <class T>\n    bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\n    template <class T>\n    bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n\n    inline bool rangeCheck2D(int nx, int ny, int Width, int Height) { return nx >= 0 and nx < Width and ny >= 0 and ny < Height; }\n    \n    ll i_query(ll x)\n    {\n        cout << \"> \" << x << endl;\n        fflush(stdout);\n        ll ret;\n        cin >> ret;\n        return ret;\n    }\n    ll i_query_2(ll i)\n    {\n        cout << \"? \" << i << endl;\n        fflush(stdout);\n        ll ret;\n        cin >> ret;\n        return ret;\n    }\n    void i_answer(ll ans, ll d)\n    {\n        cout << \"! \" << ans << \" \" << d << endl;\n        fflush(stdout);\n    }\n} // namespace\n\nnamespace {\n    #define DUMPOUT cerr \n    #ifndef DEBUG_\n    #define dump(...)\n    #else\n    #define dump(...) DUMPOUT<<\"  \"; \\\n    DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl; \\\n    DUMPOUT<<\"    \"; \\\n    dump_func(__VA_ARGS__)\n    #endif \n    void dump_func() { DUMPOUT << endl; }\n    template <class Head, class... Tail>\n    void dump_func(Head&& head, Tail&&... tail)\n    {\n        DUMPOUT << head;\n        if (sizeof...(Tail) == 0) {\n            DUMPOUT << \" \";\n        }\n        else {\n            DUMPOUT << \", \";\n        }\n        dump_func(std::move(tail)...);\n    }\n    template <class T>\n    ostream &operator<<(ostream &os, const vector<T> &v)\n    {\n        for (auto i = begin(v); i != end(v); ++i)\n            os << *i << (i == end(v) - 1 ? \"\" : \" \");\n        return os;\n    }\n    template <class T>\n    void out2Dvector(vector<T> v) {\n        for (const auto& vv : v)\n            cout << vv << endl;\n    }\n    template <class T>\n    istream &operator>>(istream &is, vector<T> &v)\n    {\n        for (auto i = begin(v); i != end(v); ++i)\n            is >> *i;\n        return is;\n    }\n    template<typename T, typename U>\n    ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n        os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n        return os;\n    }\n    template<typename T, typename U>\n    ostream& operator << (ostream& os, map<T, U>& map_var) {\n        os << \"{\";\n        for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n            os << \"(\" << itr->first << \", \" << itr->second << \")\";\n            itr++;\n            if(itr != map_var.end()) os << \", \";\n            itr--;\n        }\n        os << \"}\";\n        return os;\n    }\n    template<typename T>\n    ostream& operator << (ostream& os, set<T>& set_var) {\n        os << \"{\";\n        for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n            os << *itr;\n            ++itr;\n            if(itr != set_var.end()) os << \", \";\n            itr--;\n        }\n        os << \"}\";\n        return os;\n    }\n}\n\n/*\n    lambda expression\n    auto f = [](int arg1, double arg2) { return ret; };\n    lambda recursion\n    auto result = makeFixPoint([&](auto rec, int pos, int v) -> int {\n        rec(pos, v);\n    })(0, 1);\n    auto func = makeFixPoint([]() -> int {});\n    int ret = func();\n\n    tuple binding\n    auto [x, y] = make_tuple(0, 0);\n    for pair\n    auto [a, b] = pair<int, int>({v1, v2});\n\n    bitset<N> bs(ini_val); // N must be constant\n    bs.reset(); // reset all\n*/\n\n\nint main(void)\n{\n    INIT(); // comment out for Interective Program\n\n    inp(ll, N); inp(ll, M); inp(ll, Q);\n    vector<ll> a(Q); cin >> a;\n\n    ll h = lcm(7, M) / 7 * 2;\n    auto f = make_v<char>(h, 7);\n    fill_v(f, 0);\n    auto visited = make_v<char>(h, 7);\n\n    REP(q, Q) {\n        REP(i, h) {\n            REP(j, 7) {\n                ll idx = 7 * i + j;\n                if (idx % M == a[q])\n                    f[i][j] = 1;\n            }\n        }\n    }\n\n    auto func = [&](int h) {\n        fill_v(visited, 0);\n        ll cnt = 0;\n        REP(i, h) {\n            REP(j, 7) {\n                if (visited[i][j]) continue;\n                if (f[i][j] == 1) continue;\n                cnt++;\n                queue<pair<int, int>> q;\n                q.push({i, j});\n                while (q.size()) {\n                    int y = q.front().first, x = q.front().second; q.pop();\n                    visited[y][x] = 1;\n                    REP(k, 4) {\n                        int ny = y + dy[k], nx = x + dx[k];\n                        if (not rangeCheck2D(nx, ny, 7, h)) continue;\n                        if (visited[ny][nx]) continue;\n                        if (f[ny][nx] == 1) continue;\n                        q.push({ny, nx});\n                    }\n                }\n            }\n        }\n        return cnt;\n    };\n\n    ll aa = func(h / 2);\n    ll d = func(h) - aa;\n    ll k = N / (lcm(7, M) / 7);\n    cout << aa + d * (k - 1) << endl;\n\n    return 0;\n}\n//*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nlong long int n;\nint m;\nint q;\n\n#define MAX 5000002\nint room[MAX][7];\nint id[MAX][7];\n\nbool flag[MAX];\n\nstruct UF{\n\tvector<int> belong;\n\tvector<int> size;\n\tvoid resize(int n){\n\t\tbelong.assign(n + 1, -1);\n\t\tsize.assign(n + 1, 1);\n\t}\n\tinline int root(int b){\n\t\tif (belong[b] == -1){\n\t\t\treturn b;\n\t\t}\n\t\tbelong[b] = root(belong[b]);\n\t\treturn belong[b];\n\t}\n\tvoid merge(int a, int b){\n\t\ta = root(a);\n\t\tb = root(b);\n\t\tif (a == b)return;\n\t\tbelong[a] = b;\n\t\tsize[b] += size[a];\n\t}\n};\n\nUF uf;\nint dx[] = { 0, 0, 1, -1 };\nint dy[] = { 1, -1, 0, 0 };\n\nvector<long long int> v;\n\nvoid solve(long long int N){\n\tlong long int sum = 0;\n\tif (n <= v.size()){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tsum += v[i];\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\t\treturn;\n\t}\n\tlong long int W = 0;\n\tfor (int i = 1; i < v.size(); i++){\n\t\tW += v[i];\n\t}\n\tn--;\n\tW *= (n / N);\n\tn %= N;\n\tfor (int i = 1; i <= n; i++){\n\t\tW += v[i];\n\t}\n\tW += v[0];\n\tprintf(\"%lld\\n\", W);\n}\nint main(){\n\tscanf(\"%lld\", &n);\n\tcin >>  m >> q;\n\tfor (int i = 0; i < q; i++){\n\t\tint a;\n\t\tscanf(\"%d\", &a);\n\t\tflag[a] = true;\n\t}\n\tint num = -1;\n\tint nnn = -1;\n\tint N;\n\tfor (int i = 0; i < MAX; i++){\n\t\tfor (int j = 0; j < 7; j++){\n\t\t\tnum++;\n\t\t\tnnn++;\n\t\t\tid[i][j] = nnn;\n\t\t\tnum %= m;\n\t\t\tif (i && (j == 0 && num == 0)){\n\t\t\t\tN = i;\n\t\t\t\tfor (int j = 0; j < 7; j++){\n\t\t\t\t\troom[i][j] = room[0][j];\n\t\t\t\t\tid[i][j] = nnn;\n\t\t\t\t\tnnn++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (flag[num]){\n\t\t\t\troom[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tif (0){\n\t\n\t}\n\telse{\n\t\tuf.resize(7 * N);\n\t\tfor (int i = 0; i <= N; i++){\n\t\t\tint inc = 0;\n\t\t\tfor (int j = 0; j < 7; j++){\n\t\t\t\tif (room[i][j] == true)continue;\n\t\t\t\tbool ok = false;\n\t\t\t\tfor (int k = 0; k < 4; k++){\n\t\t\t\t\tint ii = i + dx[k];\n\t\t\t\t\tif (ii > i)continue;\n\t\t\t\t\tint jj = j + dy[k];\n\t\t\t\t\tif (jj > j)continue;\n\t\t\t\t\tif (ii >= 0 && jj >= 0 && ii <= N&&jj < 7){\n\t\t\t\t\t\tif (room[i][j] == false && room[ii][jj] == false){\n\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t\tuf.merge(id[i][j], id[ii][jj]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok == false){\n\t\t\t\t\tinc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tv.push_back(inc);\n\t\t}\n\t\tsolve(N);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define I(i,j) (i*7+j)\n\nll n,m,q,a[100050];\nbool g[3000000];\nbool used[3000000];\n\nbool dfs1(ll n,ll i,ll j) {\n    ll ret = i >= n / 2;\n    REP(k,4) {\n        ll y = i + dy[k],x = j + dx[k];\n        if(0 <= y && y < n && 0 <= x && x < 7 && !used[I(y,x)] && !g[I(y,x)]) {\n            used[I(y,x)] = true;\n            ret |= dfs1(n,y,x);\n        }\n    }\n    return ret;\n}\n\nint main(){\n    cin >> n >> m >> q;\n\n    REP(i,q)\n        cin >> a[i];\n\n    ll l = 1;\n\n    while(m * l % 7 != 0)l++;\n\n    ll n2 = m * l / 7;\n\n    if(n == n2) {\n        REP(i,q) {\n            ll p = a[i];\n\n            while(p < n * 7){\n                g[p] = true;\n                p += m;\n            }\n        }\n\n        ll c = 0;\n        REP(i,n) {\n            REP(j,7) {\n                if(!used[I(i,j)] && !g[I(i,j)]) {\n                    c++;\n                    used[I(i,j)] = true;\n                    dfs1(n,i,j);\n                }\n            }\n        }\n        cout << c << endl;\n        return 0;\n    }\n\n    REP(i,q) {\n        ll p = a[i];\n\n        while(p < n2 * 7 * 2){\n            g[p] = true;\n            p += m;\n        }\n    }\n\n    ll c1 = 0,c2 = 0;\n\n    REP(i,n2) {\n        REP(j,7) {\n            if(!used[I(i,j)] && !g[I(i,j)]) {\n                c1++;\n                used[I(i,j)] = true;\n                if(dfs1(n2*2,i,j))c2++;\n            }\n        }\n    }\n\n    cout << n / n2 * c1 - (n / n2 - 1) * c2 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n}\n// ここから編集しろ\nint UF[710000];\nint FIND(int a){\n\tif(UF[a]<0)return a;return UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint gcd(int a,int b){while(a){b%=a;swap(a,b);}return b;}\nint lcm(int a,int b){return a/gcd(a,b)*b;}\nint p[110000];\nint main(){\n\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<c;i++){\n\t\tint t;scanf(\"%d\",&t);\n\t\tp[t]=1;\n\t}\n\tfor(int i=0;i<710000;i++)UF[i]=-1;\n\tint S=lcm(a,7);\n\tfor(int i=0;i<S;i++){\n\t\tif(p[i%b])continue;\n\t\tif(i%7<6&&!p[(i+1)%b])UNION(i,i+1);\n\t\tif(i+7<S&&!p[(i+7)%b])UNION(i,i+7);\n\t}\n\tint sh=0;\n\tint sz=0;\n\tfor(int i=0;i<S;i++)if(!p[i%b]&&UF[i]<0)sz++;\n\tset<pair<int,int > >s;\n\tfor(int i=0;i<7;i++){\n\t\tif(p[i%b])continue;\n\t\tif(p[(S-7+i)%b])continue;\n\t\ts.insert(make_pair(FIND(i),FIND(S-7+i)));\n\t}\n\tsh=s.size();\n\tlong long ret=sz+(long long)(sz-sh)*(a*7/S-1);\n\tprintf(\"%lld\\n\",ret);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define maxn 700010\nint a[maxn];\nbool col[100010][7], vis[100010][7];\ntypedef long long ll;\nstruct que {\n\tint x, y;\n} qu[maxn];\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\nint up[7], dw[7], Fa[14];\nint Find(int x) {return Fa[x] == x ? x : Fa[x] = Find(Fa[x]);}\nint main()\n{\n\tll n;\n\tint m, q; scanf(\"%lld%d%d\", &n, &m, &q);\n\tfor (int i = 1; i <= q; ++i) scanf(\"%d\", &a[i]);\n\tif (m % 7)\n\t{\n\t\tint nq = q;\n\t\tfor (int i = 1; i <= q; ++i)\n\t\t\tfor (int j = 1; j < 7; ++j)\n\t\t\t\ta[++nq] = a[i] + j * m;\n\t\tm *= 7; q = nq;\n\t}\n\tint mm = m / 7, cnt = 0;\n\tfor (int i = 1; i <= q; ++i) col[a[i] / 7][a[i] % 7] = 1;\n\n\tfor (int i = 0; i < mm; ++i)\n\t\tfor (int j = 0; j < 7; ++j)\n\t\t\tif (!vis[i][j] && !col[i][j])\n\t\t\t{\n\t\t\t\t++cnt;\n\t\t\t\tint head = 0, tail = 1; qu[1] = (que) {i, j}; vis[i][j] = 1;\n\t\t\t\twhile (head < tail)\n\t\t\t\t{\n\t\t\t\t\tque now = qu[++head];\n\t\t\t\t\tfor (int k = 0, nx, ny; k < 4; ++k)\n\t\t\t\t\t{\n\t\t\t\t\t\tnx = now.x + dx[k]; ny = now.y + dy[k];\n\t\t\t\t\t\tif (nx >= 0 && nx < mm && ny >= 0 && ny < 7 && !vis[nx][ny] && !col[nx][ny])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tqu[++tail] = (que) {nx, ny};\n\t\t\t\t\t\t\tvis[nx][ny] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\tprintf(\"%d\\n\", cnt);\n\tint pcnt = 0, cnt2 = 0;\n\tfor (int i = 0; i < 7; ++i) !col[0][i] ? i == 0 || col[0][i - 1] ? up[i] = ++pcnt : up[i] = pcnt : 0;\n\tfor (int i = 0; i < 7; ++i) !col[mm - 1][i] ? i == 0 || col[mm - 1][i - 1] ? dw[i] = ++pcnt : dw[i] = pcnt : 0;\n\tfor (int i = 1; i <= pcnt; ++i) Fa[i] = i;\n\n//\tfor (int i = 0; i < 7; ++i) printf(\"%d %d\\n\", up[i], dw[i]);\n\tfor (int i = 0; i < 7; ++i)\n\t\tif (up[i] && dw[i] && Find(up[i]) != Find(dw[i]))\n\t\t{\n\t\t\tFa[Find(up[i])] = Find(dw[i]);\n\t\t\t++cnt2;\n\t\t}\n//\tprintf(\"%d\\n\", cnt2);\n\tprintf(\"%lld\\n\", 1ll * cnt * (n / mm) - 1ll * (n / mm - 1) * cnt2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<n;i++)\n#define loop(i,a,n) for(i=a;i<n;i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint main(void) {\n  int i,j;\n  int n,m,q;\n  cin>>n>>m>>q;\n  vi a(q);\n  rep(i,q)cin>>a[i];\n  if(m==7){\n    vi c(7);\n    rep(i,q)c[a[i]]++;\n    int ans=0;\n    c.push_back(1);\n    rep(i,7)\n      if(c[i]==0&&c[i+1])ans++;\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt gcd(Int x, Int y) {\n    if (x < y) swap(x, y);\n    if (y == 0) return x;\n    return gcd(y, x % y);\n}\nInt lcm(Int x, Int y) {\n    return x / gcd(x, y) * y;\n}\nInt solve(Int N, Int M, const vector<int> A) {\n    vector<char> B(N);\n    for (int a : A) {\n        for (int k = a; k < N; k += M) {\n            B[k] = 1;\n        }\n    }\n    auto dfs = [&](auto&& dfs, int n) {\n        if (B[n] == 1) return;\n        B[n] = 1;\n        if (0 <= n - 7) dfs(dfs, n - 7);\n        if ((n % 7) != 0) dfs(dfs, n - 1);\n        if ((n % 7) != 6) dfs(dfs, n + 1);\n        if (n + 7 < N) dfs(dfs, n + 7);\n    };\n    Int ans = 0;\n    for (int i = 0; i < N; i++) {\n        if (B[i] == 0) {\n            ans++;\n            dfs(dfs, i);\n        }\n    }\n    return ans;\n}\nint main() {\n    cin.tie(nullptr); ios::sync_with_stdio(false);\n    Int N, M, Q; cin >> N >> M >> Q;\n    vector<int> A(Q); for (auto &a : A) cin >> a;\n    Int x = lcm(M, 7);\n    Int k = 7 * N / x;\n    if (k == 1) {\n        Int cnt1 = solve(x, M, A);\n        cout << cnt1 << endl;\n    } else {\n        Int cnt2 = solve(2*x, M, A);\n        Int cnt3 = solve(3*x, M, A);\n        cout << cnt2 + (cnt3 - cnt2) * (k - 2) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 2147483600\n\nclass UnionFind {\npublic:\n  vector<int> par, rank; // parent(negative := its root and abs-value is its size), depth\n  UnionFind(int sz) : par(sz, -1), rank(sz, 0){}\n  int find(int x){\n    if(par[x]<0) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;  // already belong to same tree\n    if(rank[x] < rank[y]){  // y becomes parent node\n      par[y] += par[x];\n      par[x] = y;\n    } else {  // x becomes parent node\n      par[x] += par[y];\n      par[y] = x;\n      if(rank[x]==rank[y]) rank[x]++;\n    }\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int size(int x){ return -par[find(x)]; }\n};\n\nlong calc(int m, vector<long> &vec, int x){\n  UnionFind uf(m*x);\n  vector<bool> c(m*x, true);\n  rep(i,x) for(auto j : vec) c[m*i+j]=false;\n\n  rep(i,m*x) if(c[i]){\n    if(i%7>0 && c[i-1]) uf.unite(i-1, i);\n    if(i>6 && c[i-7]) uf.unite(i-7, i);\n    if(i%7<6 && c[i+1]) uf.unite(i+1, i);\n    if(i+7<m*x && c[i+7]) uf.unite(i+7, i);\n  }\n\n  long ret=0;\n  rep(i,m*x) if(c[i] && uf.par[i]<0) ret++;\n  return ret;\n}\n\nint main(){\n  long n,m,q;\n  cin>>n>>m>>q;\n  vector<long> a(q);\n  rep(i,q) cin>>a[i];\n\n  if(m%7==0){\n    long r1 = calc(m, a, 1);\n    long r2 = calc(m, a ,2);\n    cout << r1 + (r2-r1)*(n/(m/7) - 1)<< endl;\n  } else {\n    long r1 = calc(m, a, 7);\n    long r2 = calc(m, a, 14);\n    cout << r1 + (r2-r1)*(n/m - 1) << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nll a[1444441];\nbool marked[1444441];\nint MX;\nbool visited[1444441];\nbool isvalid(int x)\n{\n\treturn (x>=0&&x<MX&&!marked[x]);\n}\n\nvoid dfs(int x)\n{\n\tvisited[x]=1;\n\t//cerr<<x<<' ';\n\tif(x%7!=0&&isvalid(x-1)&&!visited[x-1]) dfs(x-1);\n\tif(x%7!=6&&isvalid(x+1)&&!visited[x+1]) dfs(x+1);\n\tif(isvalid(x-7)&&!visited[x-7]) dfs(x-7);\n\tif(isvalid(x+7)&&!visited[x+7]) dfs(x+7);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll n, m, q; cin>>n>>m>>q;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tif(m%7!=0)\n\t{\n\t\tfor(int i = 1; i < 7; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < q; j++)\n\t\t\t{\n\t\t\t\ta[i*q+j] = a[j] + i*m;\n\t\t\t}\n\t\t}\n\t\tm*=7;\n\t\tq*=7;\n\t}\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tmarked[a[i]] = 1;\n\t}\n\tMX = m;\n\tll cc1 = 0;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tif(!marked[i]&&!visited[i])\n\t\t{\n\t\t\tcc1++;\n\t\t\tdfs(i);\n\t\t\t//cerr<<'\\n';\n\t\t}\n\t}\n\tif(n*7==m)\n\t{\n\t\tcout<<cc1<<'\\n';\n\t\treturn 0;\n\t}\n\tMX*=2;\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\ta[q+i] = a[i] + m;\n\t}\n\tq*=2;\n\tm*=2;\n\tmemset(visited,0,sizeof(visited));\n\tmemset(marked,0,sizeof(marked));\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tmarked[a[i]]=1;\n\t}\n\tll cc2 = 0;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tif(!marked[i]&&!visited[i])\n\t\t{\n\t\t\tcc2++;\n\t\t\t//cerr<<'\\n';\n\t\t\tdfs(i);\n\t\t}\n\t}\n\t//cerr<<\"HERE\\n\";\n\t//cerr<<cc1<<' '<<cc2<<'\\n';\n\tll diff = cc2 - cc1;\n\tcout<<cc1 + ll(n*7/(m/2) - 1)*diff<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll N,M,Q;\nint A[101010];\nint col[1500000];\n\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank,cnt;\n\tUF() {par=rank=vector<int>(um,0); cnt=vector<int>(um,1); for(int i=0;i<um;i++) par[i]=i;}\n\tvoid reinit() {int i; FOR(i,um) rank[i]=0,cnt[i]=1,par[i]=i;}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint count(int x) { return cnt[operator[](x)];}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tcnt[y]=cnt[x]=cnt[x]+cnt[y];\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\n\nUF<1407070> uf1,uf2,uftail;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>Q;\n\tFOR(i,Q) {\n\t\tcin>>A[i];\n\t\tfor(j=A[i];j<14*M;j+=M) col[j]=1;\n\t}\n\t\n\tll pat=N / M;\n\tN %= M;\n\t\n\t\n\tif(pat==0) {\n\t\tFOR(i,7*N) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uftail(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<7*N) && col[i+7]==0) uftail(i,i+7);\n\t\t}\n\t\tint ret=0;\n\t\tFOR(i,7*N) if(col[i]==0 && uftail[i]==i) ret++;\n\t\tcout<<ret<<endl;\n\t}\n\telse {\n\t\tFOR(i,7*M) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uf1(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<7*M) && col[i+7]==0) uf1(i,i+7);\n\t\t}\n\t\tFOR(i,14*M) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uf2(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<14*M) && col[i+7]==0) uf2(i,i+7);\n\t\t}\n\t\tint num[3]={};\n\t\tFOR(i,7*M) if(col[i]==0 && uf1[i]==i) num[0]++;\n\t\tFOR(i,14*M) if(col[i]==0 && uf2[i]==i) num[1]++;\n\t\t\n\t\tif(N==0) {\n\t\t\tcout<<num[1]+(pat-1)*(num[2]-num[1])<<endl;\n\t\t}\n\t\telse {\n\t\t\tFOR(i,7*(N+M)) {\n\t\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uftail(i,i+1);\n\t\t\t\tif(col[i]==0 && (i+7<7*(N+M)) && col[i+7]==0) uftail(i,i+7);\n\t\t\t}\n\t\t\tint ret=0;\n\t\t\tFOR(i,7*(N+M)) if(col[i]==0 && uftail[i]==i) ret++;\n\t\t\tcout<<ret+(pat-1)*(num[2]-num[1])<<endl;\n\t\t}\n\t}\n\t\n}\n\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nint n;\n\nvoid dfs(int y,int x,vector< vector<bool> > &used,const vector< vector<int> > &v){\n    int dy[]={1,0,-1,0};\n    int dx[]={0,1,0,-1};\n    \n    rep(i,4){\n        int ddx = x+dx[i];\n        int ddy = y+dy[i];\n        if(ddx<0 || ddy<0 || ddx>=7 || ddy>=n)continue;\n        if(v[ddy][ddx]==0 && used[ddy][ddx]==false){\n            used[ddy][ddx]=true;\n            dfs(ddy,ddx,used,v);\n        }\n    }\n}\n\nint main(){\n    int m,q;\n    cin>>n>>m>>q;\n    vector<int> a(q);\n    rep(i,q)cin>>a[i];\n    \n    if(n<=100000){\n        vector< vector<int> > v(n,vector<int>(7,0));\n        \n        for(int i=0;;i++){\n            if(i*m>=7*n)break;\n            rep(j,q){\n                int num = i*m+a[j];\n                v[num/7][num%7]=1;\n            }\n        }\n        int c=0;\n        vector< vector<bool> > used(n,vector<bool>(7,false));\n        rep(i,n){\n            rep(j,7){\n                if(v[i][j]!=1 && used[i][j]==false){\n                    used[i][j]=true;\n                    dfs(i,j,used,v);\n                    c++;\n                }\n            }\n        }\n        cout<<c<<endl;\n    }else{\n        assert(m%7==0);\n        bool zero=0,last=0;\n        if(a[0]==0)zero=1;\n        if(a[q-1]==6)last=1;\n        cout<<2-zero-last<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nconst int INF = 1e9,MOD = 1e9+7,ohara = 1e6;\nconst ll LINF = 1e18;\nusing namespace std;\n\n#define rep(i,n) for(ll (i)=0;(i)<(int)(n);(i)++)\n#define rrep(i,a,b) for(ll i=(a);i<(b);i++)\n#define rrrep(i,a,b) for(ll i=(a);i>=(b);i--)\n#define all(v) (v).begin(), (v).end()\n#define pb(q) push_back(q)\n#define Size(n) (n).size()\n#define Cout(x) cout<<(x)<<endl\n\nll n,cnt=0,ans=0,a[ohara],b,c,d,cmp,cmpp,m,h,w,x,y,sum=0,pos,q,grid[ohara][10],aa;\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\n//int dy[]={-1,0,1,-1,1,-1,0,1};\n//int dx[]={-1,-1,-1,0,0,1,1,1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"),s;\nbool fl,mem[ohara][10];\nstruct edge{int to,cost;};\n\n//-------------------------↓↓↓↓↓↓------------------------\n\nvoid dfs1(ll i,ll j){\n    mem[i][j]=true;\n    rep(k,4){\n        int nx=j+dx[k],ny=i+dy[k];\n        if(nx>=0&&nx<7&&ny>=0&&ny<n&&!mem[ny][nx]&&!grid[ny][nx]){\n            dfs1(ny,nx);\n        }\n    }\n}\n\nll solve1(){\n    ll ret=0;\n    map<ll,ll> out;\n    rep(i,q)out[a[i]]=1;\n    rep(i,n){\n        rep(j,7){\n            pos=7*i+j;\n            if(out[pos%m]==1){\n                grid[i][j]=1;\n            }\n        }\n    }\n    rep(i,n){\n        rep(j,7){\n            if(!mem[i][j]&&!grid[i][j]){\n                ret++;\n                dfs1(i,j);\n            }\n        }\n    }\n    return ret;\n}\n\nvoid dfs2(ll i,ll j){\n    mem[i][j]=true;\n    rep(k,4){\n        int nx=j+dx[k],ny=i+dy[k];\n        if(nx>=0&&nx<7&&ny>=0&&ny<m/7&&!mem[ny][nx]&&!grid[ny][nx]){\n            dfs2(ny,nx);\n        }\n    }\n}\n\nvoid dfs3(ll i,ll j){\n    mem[i][j]=true;\n    rep(k,4){\n        int nx=j+dx[k],ny=i+dy[k];\n        if(nx>=0&&nx<7&&ny>=0&&ny<m/7+m/7&&!mem[ny][nx]&&!grid[ny][nx]){\n            dfs3(ny,nx);\n        }\n    }\n}\n\nll solve2(){\n    ll ret1=0,ret2=0;\n    map<ll,ll> out;\n    rep(i,q)out[a[i]]=1;\n    rep(i,m/7){\n        rep(j,7){\n            pos=7*i+j;\n            if(out[pos%m]==1){\n                grid[i][j]=1;\n            }\n        }\n    }\n    rep(i,m/7){\n        rep(j,7){\n            if(!mem[i][j]&&!grid[i][j]){\n                ret1++;\n                dfs2(i,j);\n            }\n        }\n    }\n    rep(i,m/7){\n        rep(j,7){\n            mem[i][j]=false;\n        }\n    }\n    rrep(i,m/7,m/7+m/7){\n        rep(j,7){\n            pos=7*i+j;\n            if(out[pos%m]==1){\n                grid[i][j]=1;\n            }\n        }\n    }\n    rep(i,m/7+m/7){\n        rep(j,7){\n            if(!mem[i][j]&&!grid[i][j]){\n                ret2++;\n                dfs3(i,j);\n            }\n        }\n    }\n    aa=ret2-ret1;\n    b=ret1-aa;\n    ll kaisuu;\n    kaisuu=n/(m/7);\n    return aa*kaisuu+b;\n}\n\nint main(void){\n       cin.tie(0);\n    ios::sync_with_stdio(false);\n      \n    cin>>n>>m>>q;\n    rep(i,q)cin>>a[i];\n    if(n<=100000)ans=solve1();\n    else ans=solve2();\n    Cout(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll N,M,Q;\nint A[101010];\nint col[1500000];\n\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank,cnt;\n\tUF() {par=rank=vector<int>(um,0); cnt=vector<int>(um,1); for(int i=0;i<um;i++) par[i]=i;}\n\tvoid reinit() {int i; FOR(i,um) rank[i]=0,cnt[i]=1,par[i]=i;}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint count(int x) { return cnt[operator[](x)];}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tcnt[y]=cnt[x]=cnt[x]+cnt[y];\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\n\nUF<1407070> uf1,uf2,uftail;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>Q;\n\tFOR(i,Q) {\n\t\tcin>>A[i];\n\t\tfor(j=A[i];j<14*M;j+=M) col[j]=1;\n\t}\n\t\n\tll pat=N / (7*M);\n\tN %= 7*M;\n\t\n\t\n\tif(pat==0) {\n\t\tFOR(i,7*N) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uftail(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<7*N) && col[i+7]==0) uftail(i,i+7);\n\t\t}\n\t\tint ret=0;\n\t\tFOR(i,7*N) if(col[i]==0 && uftail[i]==i) ret++;\n\t\tcout<<ret<<endl;\n\t}\n\telse {\n\t\tFOR(i,7*M) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uf1(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<7*M) && col[i+7]==0) uf1(i,i+7);\n\t\t}\n\t\tFOR(i,14*M) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uf2(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<14*M) && col[i+7]==0) uf2(i,i+7);\n\t\t}\n\t\tint num[3]={};\n\t\tFOR(i,7*M) if(col[i]==0 && uf1[i]==i) num[0]++;\n\t\tFOR(i,14*M) if(col[i]==0 && uf2[i]==i) num[1]++;\n\t\t\n\t\tif(N==0) {\n\t\t\tcout<<num[1]+(pat-1)*(num[2]-num[1])<<endl;\n\t\t}\n\t\telse {\n\t\t\tFOR(i,7*(N+M)) {\n\t\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uftail(i,i+1);\n\t\t\t\tif(col[i]==0 && (i+7<7*(N+M)) && col[i+7]==0) uftail(i,i+7);\n\t\t\t}\n\t\t\tint ret=0;\n\t\t\tFOR(i,7*(N+M)) if(col[i]==0 && uftail[i]==i) ret++;\n\t\t\tcout<<ret+(pat-1)*(num[2]-num[1])<<endl;\n\t\t}\n\t}\n\t\n}\n\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n\nusing namespace std;\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing ll=long long;\n\n\nconst int white=-1;\nconst int black=100000000;\n\n\nvi gx, gy;\n\n\nvoid push(int x, int y)\n{\n\tgx.push_back(x);\n\tgy.push_back(y);\n}\n\n\nint pop(int& x, int& y)\n{\n\tif(gx.size()<=0) return 0;\n\tx=gx.back();\n\ty=gy.back();\n\tgx.pop_back();\n\tgy.pop_back();\n\treturn 1;\n}\n\n\nvoid eng_fill(vvi& c, int x, int y, int g)\n{\n\tint vx[]={ 1, 0,-1, 0};\n\tint vy[]={ 0,-1, 0, 1};\n\tint nx, ny;\n\tint w, h;\n\n\tw=7;\n\th=c.size();\n\tpush(x, y);\n\tc[y][x]=g;\n\twhile(pop(x, y))\n\t{\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tnx=x+vx[i];\n\t\t\tny=y+vy[i];\n\t\t\tif(nx<0 || w<=nx || ny<0 || h<=ny) continue;\n\t\t\tif(c[ny][nx]!=white) continue;\n\t\t\tc[ny][nx]=g;\n\t\t\tpush(nx, ny);\n\t\t}\n\t}\n}\n\n\n\nint engroup(vvi& c)\n{\n\tint w, h, x, y;\n\tint g=0;\n\n\tw=7;\n\th=c.size();\n\tfor(y=0;y<h;y++)\n\t{\n\t\tfor(x=0;x<w;x++)\n\t\t{\n\t\t\tif(c[y][x]!=white) continue;\n\t\t\teng_fill(c, x, y, g);\n\t\t\tg++;\n\t\t}\n\t}\n\treturn g;\n}\n\n\nint gcd(int a, int b)\n{\n\tint c;\n\twhile((c=a%b))\n\t{\n\t\ta=b;\n\t\tb=c;\n\t}\n\treturn b;\n}\n\n\nint lcm(int a, int b)\n{\n\treturn a/gcd(a, b)*b;\n}\n\n\nint main(void)\n{\n\tint m, q, g, uh, gc;\n\tll n, h;\n\tvvi c, f;\n\n\twhile(scanf(\"%lld%d%d\", &n, &m, &q)==3)\n\t{\n\t\tuh=lcm(m, 7)/7;\n\t\th=n/uh;\n\t\tc.clear();\n\t\tc.resize(uh);\n\t\tfor(auto& ce: c) ce.resize(7, white);\n\n\t\tfor(int i=0;i<q;i++)\n\t\t{\n\t\t\tint a;\n\t\t\tscanf(\"%d\", &a);\n\t\t\tfor(int j=a;j<uh*7;j+=m)\n\t\t\t{\n\t\t\t\tc[j/7][j%7]=black;\n\t\t\t}\n\t\t}\n\t\tg=engroup(c);\n\n\t\tf.clear();\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tint u=c[0][i];\n\t\t\tint l=c[uh-1][i];\n\t\t\tint j;\n\t\t\tif(u==black || l==black) continue;\n\t\t\tif(u>l) swap(u, l);\n\t\t\tvi ft={u,l};\n\t\t\tfor(j=f.size()-1;j>=0;j--)\n\t\t\t{\n\t\t\t\tif(ft==f[j]) break;\n\t\t\t}\n\t\t\tif(j<0)\n\t\t\t{\n\t\t\t\tf.push_back(ft);\n//\t\t\t\tprintf(\"%d %d\\n\", ft[0], ft[1]);\n\t\t\t}\n\t\t}\n\t\tgc=f.size();\n# if 0\nfor(auto ce:c)\n{\n\tfor(int x:ce)\n\t{\n\t\tif(x==black) printf(\" X \");\n\t\telse printf(\"%2d \", x);\n\t}\n\tprintf(\"\\n\");\n}\nprintf(\"g=%d h=%d gc=%d\\n\", g, h, gc);\n#endif\n\t\tll result=g*h-gc*(h-1);\n\t\tprintf(\"%lld\\n\", result);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace {\n    using ull = unsigned long long;\n    using ll = long long;\n    #define endl \"\\n\"\n\n    #define REP(i, n) for (ll i = 0; i < n; i++)\n    #define REPR(i, n) for (ll i = n; i >= 0; i--)\n    #define FOR(i, m, n) for (ll i = m; i < n; i++)\n    #define even(x) (x) % 2 == 0\n    #define odd(x) (x) % 2 != 0\n    #define all(x) x.begin(), x.end()\n    #define rall(x) x.rbegin(), x.rend()\n    #define pcnt __builtin_popcount\n    #define buli(x) __builtin_popcountll(x)\n    #define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n    #define inp(t, x) t x;cin>>x;\n    #define ithBit(n, i) ((n)>>(i) & 1)\n    #define INIT() cin.tie(0);ios::sync_with_stdio(0);cout<<fixed<<setprecision(20)\n\n    // these functions return the position of result of Binary Search.\n    #define LB(s, t, x) (int)(lower_bound(s, t, x) - s)\n    #define UB(s, t, x) (int)(upper_bound(s, t, x) - s)\n\n    #define M_PI 3.14159265358979323846\n    ll qp(ll a, ll b, int mo)\n    {\n        ll ans = 1;\n        do\n        {\n            if (b & 1)\n                ans = 1ll * ans * a % mo;\n            a = 1ll * a * a % mo;\n        } while (b >>= 1);\n        return ans;\n    }\n    ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\n    ll lcm(ll a, ll b)\n    {\n        ll temp = gcd(a, b);\n        return temp ? (a / temp * b) : 0;\n    }\n    int mDays[] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n    int dx8[] = {1, -1, 0, 0, 1, 1, -1, -1}, dy8[] = {0, 0, -1, 1, -1, 1, -1, 1};\n\n    template <typename F>\n    class\n    #if defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n        [[nodiscard]]\n    #elif defined(__GNUC__) && __GNUC_PREREQ(3, 4)\n        __attribute__((warn_unused_result))\n    #endif // defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n        FixPoint : F {\n            public :\n                explicit constexpr FixPoint(F &&f) noexcept : F(std::forward<F>(f)) {}\n\n            template <typename... Args>\n            constexpr decltype(auto)\n            operator()(Args &&... args) const {\n                return F::operator()(*this, std::forward<Args>(args)...);\n    } // namespace\n    }\n    ; // class FixPoint\n    template <typename F>\n    static inline constexpr decltype(auto)\n    makeFixPoint(F &&f) noexcept\n    {\n        return FixPoint<F>{std::forward<F>(f)};\n    }\n\n    template <typename T>\n    vector<T> make_v(size_t a) { return vector<T>(a); }\n    template <typename T, typename... Ts>\n    auto make_v(size_t a, size_t b, Ts... ts) { return vector<decltype(make_v<T>(b, ts...))>(a, make_v<T>(b, ts...)); }\n    template <typename T, typename V>\n    typename enable_if<is_class<T>::value == 0>::type\n    fill_v(T &t, const V &v) { t = v; }\n    template <typename T, typename V>\n    typename enable_if<is_class<T>::value != 0>::type\n    fill_v(T &t, const V &v) { for (auto &e : t) fill_v(e, v); }\n\n    template <class T>\n    bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\n    template <class T>\n    bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n\n    inline bool rangeCheck2D(int nx, int ny, int Width, int Height) { return nx >= 0 and nx < Width and ny >= 0 and ny < Height; }\n    \n    ll i_query(ll x)\n    {\n        cout << \"> \" << x << endl;\n        fflush(stdout);\n        ll ret;\n        cin >> ret;\n        return ret;\n    }\n    ll i_query_2(ll i)\n    {\n        cout << \"? \" << i << endl;\n        fflush(stdout);\n        ll ret;\n        cin >> ret;\n        return ret;\n    }\n    void i_answer(ll ans, ll d)\n    {\n        cout << \"! \" << ans << \" \" << d << endl;\n        fflush(stdout);\n    }\n} // namespace\n\nnamespace {\n    #define DUMPOUT cerr \n    #ifndef DEBUG_\n    #define dump(...)\n    #else\n    #define dump(...) DUMPOUT<<\"  \"; \\\n    DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl; \\\n    DUMPOUT<<\"    \"; \\\n    dump_func(__VA_ARGS__)\n    #endif \n    void dump_func() { DUMPOUT << endl; }\n    template <class Head, class... Tail>\n    void dump_func(Head&& head, Tail&&... tail)\n    {\n        DUMPOUT << head;\n        if (sizeof...(Tail) == 0) {\n            DUMPOUT << \" \";\n        }\n        else {\n            DUMPOUT << \", \";\n        }\n        dump_func(std::move(tail)...);\n    }\n    template <class T>\n    ostream &operator<<(ostream &os, const vector<T> &v)\n    {\n        for (auto i = begin(v); i != end(v); ++i)\n            os << *i << (i == end(v) - 1 ? \"\" : \" \");\n        return os;\n    }\n    template <class T>\n    void out2Dvector(vector<T> v) {\n        for (const auto& vv : v)\n            cout << vv << endl;\n    }\n    template <class T>\n    istream &operator>>(istream &is, vector<T> &v)\n    {\n        for (auto i = begin(v); i != end(v); ++i)\n            is >> *i;\n        return is;\n    }\n    template<typename T, typename U>\n    ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n        os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n        return os;\n    }\n    template<typename T, typename U>\n    ostream& operator << (ostream& os, map<T, U>& map_var) {\n        os << \"{\";\n        for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n            os << \"(\" << itr->first << \", \" << itr->second << \")\";\n            itr++;\n            if(itr != map_var.end()) os << \", \";\n            itr--;\n        }\n        os << \"}\";\n        return os;\n    }\n    template<typename T>\n    ostream& operator << (ostream& os, set<T>& set_var) {\n        os << \"{\";\n        for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n            os << *itr;\n            ++itr;\n            if(itr != set_var.end()) os << \", \";\n            itr--;\n        }\n        os << \"}\";\n        return os;\n    }\n}\n\n/*\n    lambda expression\n    auto f = [](int arg1, double arg2) { return ret; };\n    lambda recursion\n    auto result = makeFixPoint([&](auto rec, int pos, int v) -> int {\n        rec(pos, v);\n    })(0, 1);\n    auto func = makeFixPoint([]() -> int {});\n    int ret = func();\n\n    tuple binding\n    auto [x, y] = make_tuple(0, 0);\n    for pair\n    auto [a, b] = pair<int, int>({v1, v2});\n\n    bitset<N> bs(ini_val); // N must be constant\n    bs.reset(); // reset all\n*/\n\n\nint main(void)\n{\n    INIT(); // comment out for Interective Program\n\n    inp(ll, N); inp(ll, M); inp(ll, Q);\n    vector<ll> a(Q); cin >> a;\n\n    ll h = lcm(7, M) / 7 * 2;\n    auto f = make_v<char>(h, 7);\n    fill_v(f, 0);\n\n    REP(q, Q) {\n        REP(i, h) {\n            REP(j, 7) {\n                ll idx = 7 * i + j;\n                if (idx % M == a[q])\n                    f[i][j] = 1;\n            }\n        }\n    }\n\n    auto func = [&](int h) {\n        ll cnt = 0;\n        auto visited = make_v<char>(h, 7);\n        fill_v(visited, 0);\n        REP(i, h) {\n            REP(j, 7) {\n                if (visited[i][j]) continue;\n                if (f[i][j] == 1) continue;\n                cnt++;\n                queue<pair<int, int>> q;\n                q.push({i, j});\n                while (q.size()) {\n                    auto [y, x] = q.front(); q.pop();\n                    visited[y][x] = 1;\n                    REP(k, 4) {\n                        int ny = y + dy[k], nx = x + dx[k];\n                        if (not rangeCheck2D(nx, ny, 7, h)) continue;\n                        if (visited[ny][nx]) continue;\n                        if (f[ny][nx] == 1) continue;\n                        q.push({ny, nx});\n                    }\n                }\n            }\n        }\n        return cnt;\n    };\n\n    ll aa = func(h / 2);\n    ll d = func(h) - aa;\n    ll k = N / (lcm(7, M) / 7);\n    cout << aa + d * (k - 1) << endl;\n\n    return 0;\n}\n//*/"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define RREP(i, x, n) for(int i = x; i >= n; i--)\n#define rrep(i, n) RREP(i,n,0)\n#define pb push_back\n#pragma GCC optimize (\"-O3\")\n\nusing namespace std;\n\n// #define DEBUG_IS_VALID\n\n#ifdef DEBUG_IS_VALID\n#define DEB 1 \n#else\n#define DEB 0\n#endif\n#define DUMPOUT cout\n#define dump(...) if(DEB) DUMPOUT<<\"  \"<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl<<\"    \"; if(DEB) dump_func(__VA_ARGS__)\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, pair<T1,T2> p){cout << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate<typename T>ostream& operator << (ostream& os, vector<T>& vec) { os << \"{\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"}\"; return os; }\ntemplate<typename T>ostream& operator << (ostream& os, set<T>& st){for(auto itr = st.begin(); itr != st.end(); itr++) cout << *itr << (next(itr)!=st.end() ? \", \" : \"\"); cout << \"}\"; return os;}\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, map<T1,T2> mp){cout << \"{\"; for(auto itr = mp.begin(); itr != mp.end(); itr++) cout << \"(\" << (itr->first) << \", \" << (itr->second) << \")\" << (next(itr)!=mp.end() ? \",\" : \"\"); cout << \"}\"; return os; }\n\nvoid dump_func(){DUMPOUT << endl;}\ntemplate <class Head, class... Tail>void dump_func(Head&& head, Tail&&... tail){ DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...);}\ntemplate<class T> inline bool chmax(T& a,T const& b){if(a>=b) return false; a=b; return true;}\ntemplate<class T> inline bool chmin(T& a,T const& b){if(a<=b) return false; a=b; return true;}\n\nusing ll = long long;\nusing P = pair<int,int>;\nusing Pl = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\n\nconst int mod=1e9+7,INF=1<<29;\nconst double EPS=1e-12,PI=3.1415926535897932384626;\nconst ll lmod = 1e9+7,LINF=1LL<<59; \n\nstruct UnionFindTree{\n  vector<int> par,rank,size;\n  UnionFindTree(int N){\n    par = rank = vector<int>(N,0);\n    size = vector<int>(N,1);\n    for(int i = 0; i < N; i++) par[i] = i;\n  }\n  int find(int x){\n    if(par[x] == x) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x,int y){\n    x = find(x);\n    y = find(y);\n    if(x == y)  return ;\n    if(rank[x] < rank[y]){\n      par[x] = y;\n    }else{\n      par[y] = x;\n      if(rank[x] == rank[y]) ++rank[x];\n    }\n    size[x] = size[y] = size[x] + size[y];\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll N,M,Q; cin >> N >> M >> Q ;\n  ll sp_sz;\n  if(M%7==0) sp_sz = M;\n  else sp_sz = 7 * M;\n  vector<bool> is_black(sp_sz,false);\n  rep(i,Q){\n    int a; cin >> a ;\n    for(int x = a; x < sp_sz ; x += M){\n      is_black[x] = true;\n    }\n  }\n  UnionFindTree uft(sp_sz*2);\n  vi dx = {-1,0,1,0};\n  vi dy = {0,-1,0,1};\n  rep(i,sp_sz){\n    if(is_black[i]) continue;\n    rep(j,4){\n      int x = i + dx[j]*7 + dy[j];\n      if(x<0 || x>=sp_sz) continue;\n      if((j%2==1)&&(i/7!=x/7)) continue;\n      if(is_black[x]) continue;\n      uft.unite(i,x);\n      uft.unite(i+sp_sz,x+sp_sz);\n    }\n  }\n  ll sz1,sz2;\n  sz1 = sz2 = 0;\n  rep(i,sp_sz){\n    if(is_black[i]) continue;\n    if(uft.par[i]==i) sz1++;\n  }\n  REP(i,sp_sz-7,sp_sz){\n    if(is_black[i]||is_black[(i+7)%sp_sz]) continue;\n    uft.unite(i,i+7);\n  }\n  rep(i,2*sp_sz){\n    if(is_black[i%sp_sz]) continue;\n    if(uft.par[i]==i) sz2++; \n  }\n  dump(is_black);\n  dump(sz1,sz2);\n  ll diff = sz1 * 2 - sz2;\n  ll temp = 7LL*N/sp_sz;\n  cout << sz1 * temp - diff * (temp-1) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n \nauto& in = std::cin;\nauto& out = std::cout;\n \nint32_t N, m;\nbool MAP[100001][8];\nbool MOD[100010];\nint32_t a[100010];\n \ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) {\n\tarr = v;\n}\ntemplate<typename T, typename ARR>\nvoid fill_all(ARR& arr, const T& v) {\n\tfor (auto& i : arr) { fill_all(i, v); }\n}\n \nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t Q;\n\tin >> N >> m >> Q;\n\tfor (int32_t i = 0; i < Q; ++i)\n\t{\n\t\tin >> a[i];\n\t\tMOD[a[i]] = true;\n\t}\n \n\tif (N <= 100000)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < N; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tout << count << endl;\n\t}\n\telse if ((m % 7) == 0)\n\t{\n\t\tfor (int32_t y = 0; y < (m / 7); ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[(m / 7)][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < (m/7); ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tint32_t count1 = count;\n \n\t\tfill_all(MAP, false);\n\t\tfor (int32_t y = 0; y < (m / 7) * 2; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[(m / 7) * 2][x] = true;\n\t\t}\n\t\tcount = 0;\n\t\tfor (int32_t y = 0; y < (m / 7)*2; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\nif(m!=0){return 0;}\n\t\tout << (count - count1)*((7*N)/m)+count1 << endl;\n\t}\n \n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int dh[] = {1, -1, 0, 0};\nconst int dw[] = {0, 0, 1, -1};\n\nint g, cnt1 = 0, cnt2 = 0, cnt3 = 0;\n\nvoid dfs(int h, int w, vector<vector<bool> >& b) {\n\tstack<P> s;\n\ts.push(P(h, w));\n\tvector<bool> m1(7, false), m2(7, false), m3(7, false);\n\twhile (!s.empty()) {\n\t\tint ch, cw;\n\t\ttie(ch, cw) = s.top();\n\t\ts.pop();\n\t\tb[ch][cw] = true;\n\t\tif (ch == 0) m1[cw] = true;\n\t\tif (ch == g - 1) m2[cw] = true;\n\t\tif (ch == g) m3[cw] = true;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nh = ch + dh[i], nw = cw + dw[i];\n\t\t\tif (nh < 0 || nh > g || nw < 0 || nw >= 7) continue;\n\t\t\tif (b[nh][nw]) continue;\n\t\t\ts.push(P(nh, nw));\n\t\t}\n\t}\n\n\tbool flag1 = false, flag2 = false;\n\tfor (int i = 0; i < 7; i++) {\n\t\tif (m1[i] && m2[i]) flag1 = true;\n\t\tif (m2[i] && m3[i]) flag2 = true;\n\t}\n\tflag2 &= !flag1;\n\n\tcnt3 += flag1;\n\tcnt2 += flag2;\n\tcnt1 += !(flag1 || flag2);\n\tcnt1 -= flag2;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n;\n\tint m, q;\n\tcin >> n >> m >> q;\n\tvector<bool> memo(m, false);\n\tfor (int i = 0; i < q; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tmemo[a] = true;\n\t}\n\n\tg = m / __gcd(m, 7);\n\n\tvector< vector<bool> > b(g + 1, vector<bool>(7, false));\n\tfor (int i = 0; i <= g; i++) {\n\t\tfor (int j = 0; j < 7; j++) {\n\t\t\tint x = 7 * i + j;\n\t\t\tb[i][j] = memo[x % m];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g; i++) {\n\t\tfor (int j = 0; j < 7; j++) {\n\t\t\tif (!b[i][j]) dfs(i, j, b);\n\t\t}\n\t}\n\n\tll ans = 0;\n\tans += cnt3;\n\tans += (n / g + 1) * cnt2;\n\tans += (n / g) * cnt1;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n#define int long long\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nlong long N;\nint M, Q;\nbool X[200000][7];\nbool R[7];\nint A[200001];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> M >> Q;\n  rep(i, Q) {\n    int a;\n    cin >> a;\n    rep(k, 7) {\n      int x = a + k*M;\n      X[x/7][x%7] = true;\n    }\n  }\n  if (N == 0) {\n    cout << 0 << \"\\n\";\n    return 0;\n  }\n  rep(_x, M+1) {\n    int x = (_x)%M;\n    rep(i, 7) R[i] = false;\n    if (_x > 0) {\n      rep(i, 7) {\n        if (!X[x][i] && !X[(x+M-1)%M][i]) R[i] = true;\n      }\n      for (int i=1; i<7; i++) {\n        if (X[x][i]) continue;\n        if (R[i-1]) R[i] = true;\n      }\n      for (int i=5; i>=0; i--) {\n        if (X[x][i]) continue;\n        if (R[i+1]) R[i] = true;\n      }\n    }\n    int c = 0;\n    rep(i, 7) {\n      if (X[x][i] || R[i]) continue;\n      c++;\n      for (int j=i; j<7; j++) {\n        if (X[x][j] || R[j]) break;\n        R[j] = true;\n      }\n    }\n    A[_x] = c;\n  }\n  long long sum = 0;\n  for (int i=1; i<=M; i++) sum += A[i];\n  sum *= (N/M);\n  if (N%M == 0) {\n    sum += A[0] - A[M];\n  }\n  else {\n    rep(i, N%M) {\n      sum += A[i];\n    }\n  }\n  cout<<sum<<\"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 2333333\nll n;\nint m,q,a[SZ];\nbool cov[SZ];\nint ff[SZ];\nint gf(int x) {return (ff[x]==-1)?x:ff[x]=gf(ff[x]);}\nvoid uni(int a,int b)\n{int ga=gf(a),gb=gf(b);if(ga^gb)ff[ga]=gb;}\nint main()\n{\n\tscanf(\"%lld%d%d\",&n,&m,&q);\n\tfor(int i=1;i<=q;i++)\n\tscanf(\"%d\",a+i),cov[a[i]]=1;\n\t#define TJ(r,ans)\\\n\tmemset(ff,-1,sizeof(ff));\\\n\tfor(int i=0;i<r;i++)\\\n\t{\\\n\t\tif(cov[i%m])continue;\\\n\t\tif(i+7<r&&!cov[(i+7)%m]) uni(i,i+7);\\\n\t\tif(i%7!=6&&i+1<r&&!cov[(i+1)%m]) uni(i,i+1);\\\n\t}\\\n\tfor(int i=0;i<r;i++)\\\n\t\tif(!cov[i%m]) ans+=gf(i)==i;\n\tint ans1=0; TJ(m*7,ans1)\n\tint ans2=0; TJ(m*14,ans2)\n\tll rd=7*n/m,zg=rd/7,bf=rd%7,ans=0;\n\tif(zg) ans=ans1+(ans2-ans1)*(zg-1);\n\tint ans3=0; TJ(m*bf,ans3)\n\tint ans4=0; TJ(m*bf+m*7,ans4)\n\tint ans5=0; TJ(m*7,ans5)\n\tif(zg) ans+=ans5-ans4; else ans+=ans3;\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int dh[] = {1, -1, 0, 0};\nconst int dw[] = {0, 0, 1, -1};\n\nint g, cnt1 = 0, cnt2 = 0, cnt3 = 0;\n\nvoid dfs(int h, int w, vector<vector<bool> >& b) {\n\tstack<P> s;\n\ts.push(P(h, w));\n\tvector<bool> m1(7, false), m2(7, false), m3(7, false);\n\twhile (!s.empty()) {\n\t\tint ch, cw;\n\t\ttie(ch, cw) = s.top();\n\t\ts.pop();\n\t\tb[ch][cw] = true;\n\t\tif (ch == 0) m1[cw] = true;\n\t\tif (ch == g - 1) m2[cw] = true;\n\t\tif (ch == g) m3[cw] = true;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nh = ch + dh[i], nw = cw + dw[i];\n\t\t\tif (nh < 0 || nh > g || nw < 0 || nw >= 7) continue;\n\t\t\tif (b[nh][nw]) continue;\n\t\t\ts.push(P(nh, nw));\n\t\t}\n\t}\n\n\tbool flag1 = false, flag2 = false;\n\tfor (int i = 0; i < 7; i++) {\n\t\tif (m1[i] && m2[i]) flag1 = true;\n\t\tif (m2[i] && m3[i]) flag2 = true;\n\t}\n\tflag2 &= !flag1;\n\t\n\tcnt3 += flag1;\n\tcnt2 += flag2;\n\tcnt1 += !(flag1 || flag2);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n;\n\tint m, q;\n\tcin >> n >> m >> q;\n\tvector<bool> memo(m, false);\n\tfor (int i = 0; i < q; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tmemo[a] = true;\n\t}\n\n\tg = m / __gcd(m, 7);\n\n\tvector< vector<bool> > b(g + 1, vector<bool>(7, false));\n\tfor (int i = 0; i <= g; i++) {\n\t\tfor (int j = 0; j < 7; j++) {\n\t\t\tint x = 7 * i + j;\n\t\t\tb[i][j] = memo[x % m];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g; i++) {\n\t\tfor (int j = 0; j < 7; j++) {\n\t\t\tif (!b[i][j]) dfs(i, j, b);\n\t\t}\n\t}\n\n\tll ans = 0;\n\tans += cnt3;\n\tans += (n / g + 1) * cnt2;\n\tans += (n / g) * cnt1;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int dh[] = {1, -1, 0, 0};\nconst int dw[] = {0, 0, 1, -1};\n\nint g, cnt1 = 0, cnt2 = 0, cnt3 = 0;\n\nvoid dfs(int h, int w, vector<vector<bool> >& b) {\n\tstack<P> s;\n\ts.push(P(h, w));\n\tbool flag = false;\n\twhile (!s.empty()) {\n\t\tint ch, cw;\n\t\ttie(ch, cw) = s.top();\n\t\ts.pop();\n\t\tb[ch][cw] = true;\n\t\tif (h == 0 && ch == g - 1 && w == cw) flag = true;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nh = ch + dh[i], nw = cw + dw[i];\n\t\t\tif (nh < 0 || nh >= g || nw < 0 || nw >= 7) continue;\n\t\t\tif (b[nh][nw]) continue;\n\t\t\ts.push(P(nh, nw));\n\t\t}\n\t}\n\tcnt3 += flag;\n\tcnt1 += !flag;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n;\n\tint m, q;\n\tcin >> n >> m >> q;\n\tvector<bool> memo(m, false);\n\tfor (int i = 0; i < q; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tmemo[a] = true;\n\t}\n\n\tg = m / __gcd(m, 7);\n\n\tvector< vector<bool> > b(g, vector<bool>(7, false));\n\tfor (int i = 0; i < g; i++) {\n\t\tfor (int j = 0; j < 7; j++) {\n\t\t\tint x = 7 * i + j;\n\t\t\tb[i][j] = memo[x % m];\n\t\t}\n\t}\n\n\tfor (int j = 0; j < 7; j++) {\n\t\tif (!b[0][j] && !b[g - 1][j]) cnt2++;\n\t}\n\t\n\tfor (int i = 0; i < g; i++) {\n\t\tfor (int j = 0; j < 7; j++) {\n\t\t\tif (!b[i][j]) dfs(i, j, b);\n\t\t}\n\t}\n\n\tcnt2 -= cnt3;\n\n\tll ans = 0;\n\tans += cnt3;\n\tans += (n / g + 1) * cnt2;\n\tans += (n / g) * cnt1;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define  inc(i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define  dec(i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define UB upper_bound\n#define LB lower_bound\n#define PQ priority_queue\n\n#define  ALL(v)  v.begin(),  v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define  FOR(it, v) for(auto it =  v.begin(); it !=  v.end(); ++it)\n#define RFOR(it, v) for(auto it = v.rbegin(); it != v.rend(); ++it)\n\ntemplate<typename T> bool   setmin(T & a, T b) { if(b <  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool   setmax(T & a, T b) { if(b >  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmineq(T & a, T b) { if(b <= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmaxeq(T & a, T b) { if(b >= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, m, q, a[100000];\nint b[100000][7];\n\nvoid dfs(int pi, int pj) {\n\tint di[] = { 1, 0, -1,  0 };\n\tint dj[] = { 0, 1,  0, -1 };\n\t\n\tinc(k, 4) {\n\t\tint i = pi + di[k];\n\t\tint j = pj + dj[k];\n\t\tif(inID(i, 0, n) && inID(j, 0, 7) && b[i][j] == 0) {\n\t\t\tb[i][j] = 1;\n\t\t\tdfs(i, j);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> m >> q;\n\tinc(i, q) { cin >> a[i]; }\n\t\n\tif(n > 100000 && m % 7 == 0) {\n\t\tinc(i, q - 1) { if(a[i + 1] - a[i] != 1) { return -1; } }\n\t\t\n\t\tint ans;\n\t\tif(m == 7) {\n\t\t\tif(q == 7) { ans = 0; }\n\t\t\telse if(a[0] == 0 || a[q - 1] == 6) { ans = 1; }\n\t\t\telse { ans = 2; }\n\t\t} else {\n\t\t\tif(q < 7) { ans = 1; }\n\t\t\telse if(q == m) { ans = 0; }\n\t\t\telse if(a[0] == 0 || a[q - 1] == m - 1) { ans = 7 * n / m; }\n\t\t\telse { ans = 7 * n / m + 1; }\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tinc(i, q) {\n\t\tint x = a[i];\n\t\tinc(j, 7 * n) {\n\t\t\tb[x / 7][x % 7] = 1;\n\t\t\t\n\t\t\tx += m;\n\t\t\tif(x >= 7 * n) { break; }\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tinc(i, n) {\n\tinc(j, 7) {\n\t\tif(b[i][j] == 0) {\n\t\t\tb[i][j] = 1;\n\t\t\tans++;\n\t\t\tdfs(i, j);\n\t\t}\n\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN=1000010;\n\nint n,m,q,ans;\nint ai[MAXN][8];\nbool pd[MAXN];\n\nvoid dfs(int x,int y)\n{\n\tif (x<0||y<0||x>n-1||y>6||ai[x][y]) return;\n\tai[x][y]=1;\n\tdfs(x,y+1);\n\tdfs(x+1,y);\n\tdfs(x,y-1);\n\tdfs(x-1,y);\n}\nint main()\n{\n\tcin>>n>>m>>q;\n\tfor(int i=1,j;i<=q;i++) cin>>j,pd[j]=true;\n\tfor(int i=0;i<7*n;i++)\n\t\tai[i/7][i%7]=pd[!i%m&&i?m:i%m];\n\t\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<7;j++)\n\t\t\tif (!ai[i][j]) dfs(i,j),ans++;\n\tcout<<ans<<endl;\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXPERIOD=100000;\nconst int MAXBLOCKROWS=MAXPERIOD;\nconst int DX[]={-1,0,+1,0},DY[]={0,+1,0,-1};\ntypedef struct R { ll cnt; int top[7],bot[7]; } R;\n\nll nrows; int period,nq;\nint fullblockrows,lastblockrows;\n\nbool black[MAXBLOCKROWS][7];\nint comp[MAXBLOCKROWS][7],ncomp;\nint qx[MAXBLOCKROWS*7],qy[MAXBLOCKROWS*7],qhead,qtail;\n\nR norm(const R &a) {\n\tR ret; ret.cnt=a.cnt; map<int,int> id; int nid=0;\n\tREP(i,7) {\n\t\tif(a.top[i]!=-1&&!id.count(a.top[i])) id[a.top[i]]=nid++;\n\t\tret.top[i]=a.top[i]==-1?-1:id[a.top[i]];\n\t}\n\tREP(i,7) {\n\t\tif(a.bot[i]!=-1&&!id.count(a.bot[i])) id[a.bot[i]]=nid++;\n\t\tret.bot[i]=a.bot[i]==-1?-1:id[a.bot[i]];\n\t}\n\treturn ret;\n}\n\nR calc(int nrows) {\n\tmemset(comp,-1,sizeof(comp)); ncomp=0; qhead=qtail=0;\n\tREP(sx,nrows) REP(sy,7) if(!black[sx][sy]&&comp[sx][sy]==-1) {\n\t\tcomp[sx][sy]=ncomp++; qx[qhead]=sx,qy[qhead]=sy,++qhead;\n\t\twhile(qtail<qhead) {\n\t\t\tint x=qx[qtail],y=qy[qtail]; ++qtail;\n\t\t\tREP(k,4) {\n\t\t\t\tint nx=x+DX[k],ny=y+DY[k];\n\t\t\t\tif(nx<0||nx>=nrows||ny<0||ny>=7||black[nx][ny]||comp[nx][ny]!=-1) continue;\n\t\t\t\tcomp[nx][ny]=comp[sx][sy]; qx[qhead]=nx,qy[qhead]=ny,++qhead;\n\t\t\t}\n\t\t}\n\t}\n\tR ret; ret.cnt=0; REP(i,7) ret.top[i]=comp[0][i],ret.bot[i]=comp[nrows-1][i];\n\tREP(c,ncomp) { bool found=false; REP(i,7) if(ret.top[i]==c||ret.bot[i]==c) found=true; if(!found) ++ret.cnt; }\n\tret=norm(ret);\n\t//printf(\"calc(%d)=%lld [\",nrows,ret.cnt); REP(i,7) printf(\"%d%c\",ret.top[i],i==6?']':','); printf(\" [\"); REP(i,7) printf(\"%d%c\",ret.bot[i],i==6?']':','); printf(\"\\n\");\n\treturn ret;\n}\n\nvoid merge(map<int,int> &id,int a,int b) {\n\ta=id[a]; b=id[b]; if(a==b) return;\n\tfor(map<int,int>::iterator it=id.begin();it!=id.end();++it) if(it->second==b) it->second=a;\n}\n\nR combine(R a,R b) {\n\tR ret; ret.cnt=a.cnt+b.cnt;\n\tmap<int,int> id;\n\tREP(i,7) if(a.top[i]!=-1) id[a.top[i]]=a.top[i];\n\tREP(i,7) if(a.bot[i]!=-1) id[a.bot[i]]=a.bot[i];\n\tREP(i,7) if(b.top[i]!=-1) id[14+b.top[i]]=14+b.top[i];\n\tREP(i,7) if(b.bot[i]!=-1) id[14+b.bot[i]]=14+b.bot[i];\n\tREP(i,7) if(a.bot[i]!=-1&&b.top[i]!=-1) merge(id,a.bot[i],14+b.top[i]);\n\tREP(i,7) ret.top[i]=a.top[i]==-1?-1:id[a.top[i]];\n\tREP(i,7) ret.bot[i]=b.bot[i]==-1?-1:id[14+b.bot[i]];\n\tfor(map<int,int>::iterator it=id.begin();it!=id.end();++it) {\n\t\tif(it->first!=it->second) continue;\n\t\tint c=it->first;\n\t\tbool found=false; REP(i,7) if(ret.top[i]==c||ret.bot[i]==c) found=true; if(!found) ++ret.cnt;\n\t}\n\tret=norm(ret);\n\t//printf(\"combine=%lld [\",ret.cnt); REP(i,7) printf(\"%d%c\",ret.top[i],i==6?']':','); printf(\" [\"); REP(i,7) printf(\"%d%c\",ret.bot[i],i==6?']':','); printf(\"\\n\");\n\t//printf(\"\\ta=%lld [\",a.cnt); REP(i,7) printf(\"%d%c\",a.top[i],i==6?']':','); printf(\" [\"); REP(i,7) printf(\"%d%c\",a.bot[i],i==6?']':','); printf(\"\\n\");\n\t//printf(\"\\tb=%lld [\",b.cnt); REP(i,7) printf(\"%d%c\",b.top[i],i==6?']':','); printf(\" [\"); REP(i,7) printf(\"%d%c\",b.bot[i],i==6?']':','); printf(\"\\n\");\n\treturn ret;\n}\n\nR pw(R x,ll n) {\n\tif(n==1) return x;\n\tif(n%2==1) return combine(pw(x,n-1),x);\n\treturn pw(combine(x,x),n/2);\n}\n\nvoid run() {\n\tscanf(\"%lld%d%d\",&nrows,&period,&nq);\n\tfullblockrows=period/gcd(7,period); lastblockrows=nrows%fullblockrows;\n\tmemset(black,false,sizeof(black));\n\tREP(i,nq) { int x; scanf(\"%d\",&x); for(int j=x;j<7*fullblockrows;j+=period) black[j/7][j%7]=true; }\n\t//REP(x,fullblockrows) { REP(y,7) printf(\"%c\",black[x][y]?'X':'.'); puts(\"\"); }\n\n\tR onefull=calc(fullblockrows);\n\tll numfullblocks=nrows/fullblockrows;\n\tR allfull=pw(onefull,numfullblocks);\n\tR all=allfull;\n\tif(lastblockrows!=0) {\n\t\tR last=calc(lastblockrows);\n\t\tall=combine(all,last);\n\t}\n\tll ret=all.cnt;\n\tset<int> seen;\n\tREP(i,7) if(all.top[i]!=-1&&!seen.count(all.top[i])) seen.insert(all.top[i]),++ret;\n\tREP(i,7) if(all.bot[i]!=-1&&!seen.count(all.bot[i])) seen.insert(all.bot[i]),++ret;\n\tprintf(\"%lld\\n\",ret);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN=10010;\n\nint n,m,q,ans;\nint ai[MAXN][8];\nbool pd[MAXN];\n\nvoid dfs(int x,int y)\n{\n\tif (x<0||y<0||x>n-1||y>6||ai[x][y]) return;\n\tai[x][y]=1;\n\tdfs(x,y+1);\n\tdfs(x+1,y);\n\tdfs(x,y-1);\n\tdfs(x-1,y);\n}\nint main()\n{\n\tcin>>n>>m>>q;\n// \tfor(int i=1,j;i<=q;i++) cin>>j,pd[j]=true;\n\tfor(int i=0;i<7*n;i++)\n\t\tai[i/7][i%7]=pd[!i%m&&i?m:i%m];\n\t\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<7;j++)\n\t\t\tif (!ai[i][j]) dfs(i,j),ans++;\n\tcout<<ans<<endl;\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nll n; int m,cnt,a[4][7],b[35],fa[35]; bool bo[100005];\nstruct node{ int p[2][7]; ll sz; };\nint getfa(int x){ return (x==fa[x])?x:fa[x]=getfa(fa[x]); }\nnode mrg(node u,node v){//puts(\"?\");\n\tnode ans; ans.sz=u.sz+v.sz;\n\tint i,j,cnt=0,mx=0;\n\tfor (i=0; i<2; i++)\n\t\tfor (j=0; j<7; j++) if (u.p[i][j]){\n\t\t\ta[i][j]=u.p[i][j]; mx=max(mx,a[i][j]);\n\t\t} else a[i][j]=0;\n\tfor (i=0,cnt=mx; i<2; i++)\n\t\tfor (j=0; j<7; j++) if (v.p[i][j]){\n\t\t\ta[i+2][j]=v.p[i][j]+mx; cnt=max(cnt,a[i+2][j]);\n\t\t} else a[i+2][j]=0;\n\t//for (i=0; i<4; i++)\n\t//\tfor (j=0; j<7; j++) printf(\"%d%c\",a[i][j],(j==6)?'\\n':' ');\n\t//\t\tcout<<cnt<<endl;\n\tans.sz-=cnt;\n\tfor (i=1; i<=cnt; i++) fa[i]=i;\n\tfor (i=0; i<7; i++){\n\t\tif (a[1][i] && a[2][i]) fa[getfa(a[1][i])]=getfa(a[2][i]);\n\t}\n\tmemset(b,0,sizeof(b));\n\tfor (i=cnt=0; i<7; i++){\n\t\tif (a[0][i]){\n\t\t\tif (!b[getfa(a[0][i])]) b[getfa(a[0][i])]=++cnt;\n\t\t\tans.p[0][i]=b[getfa(a[0][i])];\n\t\t} else ans.p[0][i]=0;\n\t\tif (a[3][i]){\n\t\t\tif (!b[getfa(a[3][i])]) b[getfa(a[3][i])]=++cnt;\n\t\t\tans.p[1][i]=b[getfa(a[3][i])];\n\t\t} else ans.p[1][i]=0;\n\t}\n\tfor (i=0; i<7; i++){\n\t\tif (a[1][i] && !b[getfa(a[1][i])]){\n\t\t\tb[getfa(a[1][i])]=++cnt;\n\t\t}\n\t\tif (a[2][i] && !b[getfa(a[2][i])]){\n\t\t\tb[getfa(a[2][i])]=++cnt;\n\t\t}\n\t\t\n\t}\n\t//puts(\"!\");\n\tans.sz+=cnt;\n\t//cout<<ans.sz<<endl;\n\t//for (i=0; i<2; i++)\n\t//\tfor (j=0; j<7; j++) printf(\"%d%c\",ans.p[i][j],(j<6)?' ':'\\n');\n\treturn ans;\n}\nnode calc(ll i){\n\tint j,cnt=0; node u;\n\tfor (j=0; j<7; j++) if (bo[(i*7+j)%m]){\n\t\tif (!j || !u.p[0][j-1]) cnt++;\n\t\tu.p[0][j]=u.p[1][j]=cnt;\n\t} else u.p[0][j]=u.p[1][j]=0;\n\tu.sz=cnt; return u;\n}\nnode work(ll k){\n\tnode ans=calc(0); int i;\n\tfor (i=1; i<7*m; i++) ans=mrg(ans,calc(i));\n\tnode x=ans; k--;\n\tfor (; k; k>>=1,x=mrg(x,x)) if (k&1) ans=mrg(ans,x);\n\treturn ans;\n}\nint main(){\n\tscanf(\"%lld%d%d\",&n,&m,&cnt);\n\tif (!n){ puts(\"0\"); return 0; }\n\tint i,x;\n\tmemset(bo,1,sizeof(bo));\n\tfor (i=1; i<=cnt; i++){\n\t\tscanf(\"%d\",&x); bo[x]=0;\n\t}\n\tif (n<7*m){\n\t\tnode ans=calc(0);\n\t\tfor (i=1; i<n; i++) ans=mrg(ans,calc(i));\n\t\tprintf(\"%lld\\n\",ans.sz);\n\t\treturn 0;\n\t}\n\tnode ans=work(n/(7*m));\n\tll j;\n\tfor (j=n/(7*m)*(7*m); j<n; j++) ans=mrg(ans,calc(j));\n\tprintf(\"%lld\\n\",ans.sz);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 2333333\nll n;\nint m,q,a[SZ];\nbool cov[SZ];\nint ff[SZ];\nint gf(int x) {return (ff[x]==-1)?x:ff[x]=gf(ff[x]);}\nvoid uni(int a,int b)\n{int ga=gf(a),gb=gf(b);if(ga^gb)ff[ga]=gb;}\nint main()\n{\n\tscanf(\"%lld%d%d\",&n,&m,&q);\n\tfor(int i=1;i<=q;i++)\n\tscanf(\"%d\",a+i),cov[a[i]]=1;\n\t#define TJ(r,ans)\\\n\tmemset(ff,-1,sizeof(ff));\\\n\tfor(int i=0;i<r;i++)\\\n\t{\\\n\t\tif(cov[i%m])continue;\\\n\t\tif(i+7<r&&!cov[(i+7)%m]) uni(i,i+7);\\\n\t\tif(i%7!=6&&i+1<r&&!cov[(i+1)%m]) uni(i,i+1);\\\n\t}\\\n\tfor(int i=0;i<r;i++)\\\n\t\tif(!cov[i%m]) ans+=gf(i)==i;\n\tint ans1=0; TJ(m*7,ans1)\n\tint ans2=0; TJ(m*14,ans2)\n\tll rd=7*n/m,zg=rd/7,bf=rd%7,ans=0;\n\tif(zg) ans=ans1+(ans2-ans1)*(zg-1);\n\tint ans3=0; TJ(m*bf,ans3)\n\tint ans4=0; TJ(m*bf+m*7,ans4)\n\tif(zg) ans+=ans4-ans3; else ans+=ans3;\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nlong long N;\nint M, Q;\nbool X[100000][7];\nint A[100001];\nint U[700000], Rk[700000];\nbool F[700000];\nint QC;\n\nint find(int x) {\n  if (U[x] == x) return x;\n  return U[x] = find(U[x]);\n}\n\nvoid unite(int x, int y) {\n  x = find(x), y = find(y);\n  if (x == y) return;\n  if (Rk[x] < Rk[y]) swap(x, y);\n  if (U[y] == y) QC--;\n  U[y] = x;\n  Rk[x] += Rk[y];\n  Rk[y] = 0;\n  if (F[y]) F[x] = true;\n  F[y] = false;\n}\n\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> M >> Q;\n  for (int i=0; i<7*M; i++) U[i] = i, Rk[i] = 1;\n  rep(i, Q) {\n    int a;\n    cin >> a;\n    rep(k, 7) {\n      int x = a + k*M;\n      X[x/7][x%7] = true;\n    }\n  }\n  if (N == 0) {\n    cout << 0 << \"\\n\";\n    return 0;\n  }\n  /*\n  rep(i, M) {\n    rep(j, 7)cout<<X[i][j];\n    cout<<\"\\n\";\n  }\n  */\n  rep(x, M) {\n    for (int i=1; i<7; i++) {\n      if (!X[x][i] && !X[x][i-1]) {\n        unite(7*x+i, 7*x+i-1);\n      }\n    }\n  }\n\n  if (N<M) {\n    rep(x, N) {\n      if (x > 0) {\n        rep(i, 7) {\n          if (!X[x][i] && !X[(x+M-1)%M][i]) {\n            unite(7*x+i, 7*((x+M-1)%M)+i);\n          }\n        }\n      }\n    }\n    int c = 0;\n    rep(x, N) {\n      rep(i, 7) {\n        if (X[x][i]) continue;\n        if (U[7*x+i] == 7*x+i) c++;\n      }\n    }\n    cout << c << \"\\n\";\n    return 0;\n  }\n  rep(x, M) {\n    rep(i, 7) {\n      if (!X[x][i]) QC++;\n    }\n    if (x>0)\n    rep(i, 7) {\n      if (!X[x][i] && !X[(x+M-1)%M][i]) {\n        unite(7*x+i, 7*((x+M-1)%M)+i);\n      }\n    }\n  }\n  long long sum = QC;\n  rep(i, 7) {\n    if (!X[0][i] && !X[M-1][i]) {\n      unite(7*0+i, 7*(M-1)+i);\n      F[find(i)] = true;\n    }\n  }\n  int c = 0;\n  rep(x, M) {\n    rep(i, 7) {\n      if (X[x][i]) continue;\n      if (U[7*x+i] == 7*x+i && !F[7*x+i]) c++;\n    }\n  }\n  sum += 1LL * c * ((N/M)-1);\n\n  for (int i=0; i<7*M; i++) U[i] = i, Rk[i] = 1, F[i] = false;\n  rep(x, M) {\n    for (int i=1; i<7; i++) {\n      if (!X[x][i] && !X[x][i-1]) {\n        unite(7*x+i, 7*x+i-1);\n      }\n    }\n  }\n  rep(i, 7) {\n    if (!X[0][i] && !X[M-1][i]) {\n      unite(7*0+i, 7*(M-1)+i);\n      F[find(i)] = true;\n    }\n  }\n  rep(x, N%M) {\n    rep(i, 7) {\n      if (!X[x][i]) QC++;\n    }\n    if (x>0)\n    rep(i, 7) {\n      if (!X[x][i] && !X[(x+M-1)%M][i]) {\n        unite(7*x+i, 7*((x+M-1)%M)+i);\n      }\n    }\n  }\n  c = 0;\n  rep(x, N%M) {\n    rep(i, 7) {\n      if (X[x][i]) continue;\n      if (U[7*x+i] == 7*x+i && !F[7*x+i]) c++;\n    }\n  }\n  sum += c;\n  cout<<sum<<\"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nlong n;int m,q,a[1<<17];\nbool f[7][1<<17];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid bfs(int x,int y,long _n)\n{\n\tqueue<pair<int,int> >P;\n\tf[x][y]=true;\n\tP.push(make_pair(x,y));\n\twhile(!P.empty())\n\t{\n\t\tpair<int,int>p=P.front();P.pop();\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint tx=p.first+dx[r],ty=p.second+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=7||ty>=_n||f[tx][ty])continue;\n\t\t\tf[tx][ty]=true;\n\t\t\tP.push(make_pair(tx,ty));\n\t\t}\n\t}\n}\nmain()\n{\n\tcin>>n>>m>>q;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tif(n<=100000)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong ans=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t\tbfs(i,j,n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\telse if(m%7==0)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,m/7*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,m/7*3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=count2-count1;\n\t\tlong syokou=count1-kousa*2;\n\t\tcout<<syokou+kousa*(n/(m/7))<<endl;\n\t}\n\telse\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<2*m;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<2*m;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,2*m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=count2-count1;\n\t\tlong syokou=count1-kousa;\n\t\tcout<<syokou+kousa*n/m<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint64_t N;\nint32_t m;\nbool MAP[200001][8];\nbool MOD[200010];\n\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) {\n\tarr = v;\n}\ntemplate<typename T, typename ARR>\nvoid fill_all(ARR& arr, const T& v) {\n\tfor (auto& i : arr) { fill_all(i, v); }\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t Q;\n\tin >> N >> m >> Q;\n\tauto m_l = m;\n\tif ((m_l % 7) != 0) {\n\t\tm_l *= 7;\n\t}\n\tfor (int32_t i = 0; i < Q; ++i)\n\t{\n\t\tint32_t a;\n\t\tin >> a;\n\t\twhile (a < m_l) {\n\t\t\tMOD[a] = true;\n\t\t\ta += m;\n\t\t}\n\t}\n\tm = m_l;\n\n\tif (N <= 100000)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < N; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tout << count << endl;\n\t}\n\telse\n\t{\n\t\tfor (int32_t y = 0; y < (m / 7); ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[(m / 7)][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < (m/7); ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tint32_t count1 = count;\n\n\t\tfill_all(MAP, false);\n\t\tfor (int32_t y = 0; y < (m / 7) * 2; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[(m / 7) * 2][x] = true;\n\t\t}\n\t\tcount = 0;\n\t\tfor (int32_t y = 0; y < (m / 7)*2; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tout << (count - count1)*((7*N)/m)+count1 << endl;\n\t}\n\n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define  inc(i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define  dec(i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define UB upper_bound\n#define LB lower_bound\n#define PQ priority_queue\n\n#define  ALL(v)  v.begin(),  v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define  FOR(it, v) for(auto it =  v.begin(); it !=  v.end(); ++it)\n#define RFOR(it, v) for(auto it = v.rbegin(); it != v.rend(); ++it)\n\ntemplate<typename T> bool   setmin(T & a, T b) { if(b <  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool   setmax(T & a, T b) { if(b >  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmineq(T & a, T b) { if(b <= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmaxeq(T & a, T b) { if(b >= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, m, q, a[100000];\nint b[100000][7];\n\nvoid dfs(int pi, int pj) {\n\tint di[] = { 1, 0, -1,  0 };\n\tint dj[] = { 0, 1,  0, -1 };\n\t\n\tinc(k, 4) {\n\t\tint i = pi + di[k];\n\t\tint j = pj + dj[k];\n\t\tif(inID(i, 0, n) && inID(j, 0, 7) && b[i][j] == 0) {\n\t\t\tb[i][j] = 1;\n\t\t\tdfs(i, j);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> m >> q;\n\tinc(i, q) { cin >> a[i]; }\n\t\n\tif(n > 100000) { return -1; }\n\t\n\tinc(i, q) {\n\t\tint x = a[i];\n\t\tinc(j, n) {\n\t\t\tb[x / 7][x % 7] = 1;\n\t\t\t\n\t\t\tx += m;\n\t\t\tif(j >= n) { break; }\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tinc(i, n) {\n\tinc(j, 7) {\n\t\tif(b[i][j] == 0) {\n\t\t\tb[i][j] = 1;\n\t\t\tans++;\n\t\t\tdfs(i, j);\n\t\t}\n\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nint a[100000];\nbool used[100000];\nbool used_root[1400000];\n\nint main(){\n    long n, m, q;\n    cin >> n >> m >> q;\n    for(int i = 0; i < q; i++) {\n        cin >> a[i];\n        used[a[i]] = true;\n    }\n    int M;\n    if(m%7 != 0) M =  min(7*m, 7*n);\n    else  M =  min(m, 7*n);\n    UnionFind uf(2*M);\n    for(int i = 0; i < M; i++){\n        if(used[i%m]) continue;\n        if(i%7 != 6){\n            if(!used[(i+1)%m]) uf.unionSet(i, i+1);\n        }\n        if(i+7 < M){\n            if(!used[(i+7)%m]) uf.unionSet(i, i+7);\n        }\n    }\n    long cnt = 0;\n    for(int i = 0; i < M; i++){\n        if(!used[i%m]){\n            int r = uf.root(i);\n            //cout << r << endl;\n            if(!used_root[r]){\n                cnt++;\n                used_root[r] = true;\n            }\n        }\n    }\n    //cout << M << endl;\n    //cout << cnt << endl;\n\n    for(int i = 0; i < 2*M; i++){\n        if(used[i%m]) continue;\n        if(i%7 != 6){\n            if(!used[(i+1)%m]) uf.unionSet(i, i+1);\n        }\n        if(i+7 < 2*M){\n            //cout << i << ' ' << i+7 << endl;\n            if(!used[(i+7)%m]) uf.unionSet(i, i+7);\n        }\n    }\n\n    long cnt_ = 0;\n    for(int i = 0; i < 2*M; i++){\n        used_root[i] = false;\n    }\n    for(int i = 0; i < 2*M; i++){\n        if(!used[i%m]){\n            int r = uf.root(i);\n            //cout << r << endl;\n            if(!used_root[r]){\n                cnt_++;\n                used_root[r] = true;\n            }\n        }\n    }\n    cnt_ -= cnt;\n    //cout << cnt << endl;\n    //cout << cnt_ << endl;\n    long s = (7*n)/M;\n    //cout << s << endl;\n    long ans = cnt+cnt_*(s-1);\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint gcd(int a, int b) {\n\tif (!b)return a;\n\treturn gcd(b, a%b);\n}\nbool b[1400000][7], c[1400000][7];\nint a[100000];\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint main() {\n\tll n; int m, q; scanf(\"%lld%d%d\", &n, &m, &q);\n\tint l = m / gcd(m, 7) * 7;\n\trep(i, q) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tfor (int j = a[i]; j < 2 * l; j += m) {\n\t\t\tc[j / 7][j % 7] = 1;\n\t\t\tif (j <= l)b[j / 7][j % 7] = 1;\n\t\t}\n\t}\n\tqueue<P>que;\n\tll c1 = 0;\n\trep(i, l / 7)rep(j, 7) {\n\t\tif (b[i][j])continue;\n\t\tc1++; que.push(P(i, j));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.front(); que.pop();\n\t\t\trep(k, 4) {\n\t\t\t\tint nx = p.first + dx[k], ny = p.second + dy[k];\n\t\t\t\tif (0 <= nx&&nx < l / 7 && 0 <= ny&&ny < 7 && !b[nx][ny]) {\n\t\t\t\t\tb[nx][ny] = 1; que.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll c2 = 0;\n\trep(i, 2 * l / 7)rep(j, 7) {\n\t\tif (c[i][j])continue;\n\t\tc2++; que.push(P(i, j));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.front(); que.pop();\n\t\t\trep(k, 4) {\n\t\t\t\tint nx = p.first + dx[k], ny = p.second + dy[k];\n\t\t\t\tif (0 <= nx&&nx < 2 * l / 7 && 0 <= ny&&ny < 7 && !c[nx][ny]) {\n\t\t\t\t\tc[nx][ny] = 1; que.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", (c2 - c1)*(7*n / l - 1) + c1);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n;;;;;;;;;;;;::;,.,xOOOOOOOkdoc;,,;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,,'''',,,,,,,,,'',,:cloo:'.\n;;;;;;;;;;:ccccc,'lOOOOOOOOOOOxoc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,,''''''''''',;cloxkOOOOl..\n;;;;;;;;;:cccccc:,;xOOOOOOOOOOOOOxoc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,''''''';:loxkOOOOOOOOk:..\n;;;;;;;;;:cccccc::,ck0OOOOO0OO00OOOOxl:;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,'',;codkO0OOOOOOOOOOOo'..\n;;;;;;;;:cccccc:::;,ck0OOOOOOOOOOOOO0Okoc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:cloxOOOOOOOOOOOOOOOO0x;..'\n;;;;;;;:ccccccc::;;,,:xOOOOO0OOOOOOOOOOOkdc;,;;;;;;;::::ccccccccc:::::cldkOOOOOOOOOOOOOOOOOOO0k:..''\n;;;;;;;:cccccc::;;,,,';dO0OOOOO0OOOOOOOOOOkdodddxxxxkkkOOOOOOOOOOkkkxkkO0OOOOOOOOOOOOOOOOOOO0kc'''''\n;;;;;;;::::::::;;,,,''',cxOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOxc,,,,''\n;;;;;,;;;;;;;;;,,,,'''''',lkOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOko:;;;;,,,\n;;;;,,,,,,,,,,,,''''''''''.,lkOOkxkOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkoc:c:::;;,,\n;;;;'''''''''''''''''''''''..;lodkO0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkxk0Okxocccccc:::;,,\n;;;,'............'''''''''''..;xOOOOOOOOOOOO0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkxdol::::cccc:::;;,,\n;;,'..............''''''''''';dOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOko;;::::::::;;;;,,\n;;'................'''''','',dOOOO0OOOxdoccxOO0OOOOOOOOOOOOOOOOOOOOxdoclxOOOOOOOOOOOo;;;;;;;;;;;;,,'\n;,'................'''''',,,lOOOOOOOOoo00c.;xOOOOOOOOOOOOOOOOOOOOOll0O:.:k0OOOOOOOOOOo,,;;;;;;,,,,''\n,'..................''',,,,ckOOO0OO0Ol,::,.,d0OOOOOOOOOOOOOOOOOOOOc,::,.;x0OOOOOOOOOOkc',,,,,,,,,,''\n,'..................''',,';dOOOOOOOO0kc,,,;oOOO0OO0OO0OOOOOOOOOOOOkc,,,:dOOOOOOOOOOOOOd,',,'''''''''\n'...................''',,,lOOOOOOOOOOOOkxxkOOOOOOOOxdddkOOOOOOOOOOOOkxxOOOOOOOOOOOOOO0kc''''''''''''\n'...................''',,;xOOOkkkOOOOOOOOOOOOOOOOOxo:;:dOOOOOOOOOOOOOOOOOOOOkkkkOOOOOOOd;'''''''''''\n'.................'''',,,ckxollllldkOOOOOOOOOOOOOO0OkkOOOOOOOOOOOOOOOOOOOkdlllllodkOOOOOc'',''''''''\n''''...........'''',,,,,;odccccccccokOOOOOOOOOOOOOOO0OOOOOOOOO0OOOOOOOOOxlcccccccclk0OOOd;,,,,,,,,''\n'''''''',''',,,,,,,;;;;;;ddcccccccclxOOOOOOOOOOOOkxdddddooddkOOOOOOOOOOOdccccccccclx0OOOOl,;;;;,,,,'\n',,,,,,;;;;;;;;;;;:::::;:xOdolclllokOOOOOOOOOOOOxllodddxdddllkOOOOOOOOOOkocccccccldOOOOOOd:;:;;;;;,,\n,,,;;;;:::::::::::::::cc;lOOOkkkkOOOOOOOOOOOOOOOdlodxxdxddxdcdOOOOOOOOOOOOkxdoddxkOOOOOOOOl:::::;;,,\n,,;;::::cccccccccccccccc::dOOOOOOOOOOOOOOOOOOOO0kolldxxxxxxoldOOOOOOOOOOOOOOOOOOOOOOOOOOOOd::c::;;,,\n,,;;:::cccccccccccccccccc:cxOOOOOOOOOOOOOOOOOOOOOOkxoooooooodOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkc:c:::;,,\n,,;;::::cccccccccccccccc:c:cxOOOOOOOOOOOOOOOOOOOOOOOOOkkkkkOO0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOo;:::;;,,\n,;;;;::::ccccccccccccccc:::;ck0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOx::::;;,,\n*/\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,tune=native\")\n//#pragma GCC optimize (\"unroll-loops\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double old;\n\nconst int N = 700100;\n\nint mp[N], kek[N * 2];\nint cur;\nint len;\n\nvoid dfs(int q[], int v, int sz = len) {\n    q[v] = cur;\n    if (v % 7 && q[v - 1] == 0) {\n        dfs(q, v - 1, sz);\n    }\n    if (v % 7 != 6 && q[v + 1] == 0) {\n        dfs(q, v + 1, sz);\n    }\n    if (v / 7 && q[v - 7] == 0) {\n        dfs(q, v - 7, sz);\n    }\n    if (v + 7 < sz && q[v + 7] == 0) {\n        dfs(q, v + 7, sz);\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cout << fixed << setprecision(20);\n    ll n;\n    int m, q;\n    cin >> n >> m >> q;\n    if (m == q) {\n        cout << 0 << endl;\n        return 0;\n    }\n    len = m;\n    if (len % 7) {\n        len *= 7;\n    }\n    while (q--) {\n        int a;\n        cin >> a;\n        for (int i = a; i < len; i += m) {\n            kek[i + len] = kek[i] = mp[i] = -1;\n        }\n    }\n    for (int i = 0; i < len; ++i) {\n        if (mp[i] == 0) {\n            ++cur;\n            dfs(mp, i);\n        }\n    }\n    int st = cur;\n    cur = 0;\n    for (int i = 0; i < len * 2; ++i) {\n        if (kek[i] == 0) {\n            ++cur;\n            dfs(kek, i, len * 2);\n        }\n    }\n    ll ans = st + (cur - st) * (n * 7 / len - 1);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#define repi(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n#define all(a) (a).begin(), (a).end()\n\nconstexpr int MAX_Q = 100000;\n\nconst int dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };\n\nint n, m, q;\nstd::set<int> a;\nbool fld[2000000][7];\n\nvoid dfs( int v, int h )\n{\n  int i = v/7, j = v%7;\n\n  fld[i][j] = true;\n\n  rep( d, 4 )\n  {\n    int ni = i+dy[d], nj = j+dx[d];\n\n    if( ni >= 0 && ni < h && nj >= 0 && nj < 7 && !fld[ni][nj] )\n      dfs( ni*7+nj, h );\n  }\n\n  return;\n}\n\nint main()\n{\n  scanf( \"%d%d%d\", &n, &m, &q );\n  rep( i, q )\n  {\n    int x;\n    scanf( \"%d\", &x );\n\n    a.insert( x );\n  }\n\n  int k = m%7==0 ? 1 : 7;\n\n  rep( i, k*m )\n    fld[i/7][i%7] = a.find( i%m )!=a.end();\n\n  int cnt = 0;\n  rep( i, k*m ) if( !fld[i/7][i%7] )\n    dfs( i, k*m/7 ), ++cnt;\n\n  rep( i, 2*k*m )\n    fld[i/7][i%7] = a.find( i%m )!=a.end();\n\n  int cnt2 = 0;\n  rep( i, 2*k*m ) if( !fld[i/7][i%7] )\n    dfs( i, 2*k*m/7 ), ++cnt2;\n  \n  int a, b;\n  \n  a = cnt2-cnt, b = cnt-a;\n\n  printf( \"%d\\n\", a*7*n/m/k+b );\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nbool t[7][100010],vis[7][100010];\nlong long n,m,q,a;\n\nvoid DFS(int x,int y,int lim){\n\tvis[x][y]=true;\n\tint dx[]={-1,0,0,1},dy[]={0,1,-1,0};\n\tfor(int i=0;i<4;i++){\n\t\tint a=x+dx[i],b=y+dy[i];\n\t\tif(a>=0&&b>=0&&a<7&&b<lim){\n\t\t\tif(!vis[a][b])DFS(a,b,lim);\n\t\t}\n\t}\n}\nint Sol(int lim){\n\tint ret=0;\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<lim;j++){\n\t\t\tvis[i][j]=t[i][j];\n\t\t\t//cout<<t[i][j]<<\" \";\n\t\t}\n\t\t//cout<<endl;\n\t}\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<lim;j++){\n\t\t\tif(!vis[i][j]){\n\t\t\t\tret++;\n\t\t\t\tDFS(i,j,lim);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tcin>>n>>m>>q;\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tt[i][j]=0;\n\t\t}\n\t}\n\twhile(q--){\n\t\tcin>>a;\n\t\tfor(int i=a;i<7*m;i+=m){\n\t\t\tt[i%7][i/7]=1;\n\t\t}\n\t}\n\n\tlong long k=Sol(m),ans=0;\n\tans+=(n/m)*k;\n\tn%=m;\n\tif(n)ans+=Sol(n);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n;;;;;;;;;;;;::;,.,xOOOOOOOkdoc;,,;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,,'''',,,,,,,,,'',,:cloo:'.\n;;;;;;;;;;:ccccc,'lOOOOOOOOOOOxoc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,,''''''''''',;cloxkOOOOl..\n;;;;;;;;;:cccccc:,;xOOOOOOOOOOOOOxoc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,''''''';:loxkOOOOOOOOk:..\n;;;;;;;;;:cccccc::,ck0OOOOO0OO00OOOOxl:;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,'',;codkO0OOOOOOOOOOOo'..\n;;;;;;;;:cccccc:::;,ck0OOOOOOOOOOOOO0Okoc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:cloxOOOOOOOOOOOOOOOO0x;..'\n;;;;;;;:ccccccc::;;,,:xOOOOO0OOOOOOOOOOOkdc;,;;;;;;;::::ccccccccc:::::cldkOOOOOOOOOOOOOOOOOOO0k:..''\n;;;;;;;:cccccc::;;,,,';dO0OOOOO0OOOOOOOOOOkdodddxxxxkkkOOOOOOOOOOkkkxkkO0OOOOOOOOOOOOOOOOOOO0kc'''''\n;;;;;;;::::::::;;,,,''',cxOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOxc,,,,''\n;;;;;,;;;;;;;;;,,,,'''''',lkOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOko:;;;;,,,\n;;;;,,,,,,,,,,,,''''''''''.,lkOOkxkOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkoc:c:::;;,,\n;;;;'''''''''''''''''''''''..;lodkO0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkxk0Okxocccccc:::;,,\n;;;,'............'''''''''''..;xOOOOOOOOOOOO0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkxdol::::cccc:::;;,,\n;;,'..............''''''''''';dOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOko;;::::::::;;;;,,\n;;'................'''''','',dOOOO0OOOxdoccxOO0OOOOOOOOOOOOOOOOOOOOxdoclxOOOOOOOOOOOo;;;;;;;;;;;;,,'\n;,'................'''''',,,lOOOOOOOOoo00c.;xOOOOOOOOOOOOOOOOOOOOOll0O:.:k0OOOOOOOOOOo,,;;;;;;,,,,''\n,'..................''',,,,ckOOO0OO0Ol,::,.,d0OOOOOOOOOOOOOOOOOOOOc,::,.;x0OOOOOOOOOOkc',,,,,,,,,,''\n,'..................''',,';dOOOOOOOO0kc,,,;oOOO0OO0OO0OOOOOOOOOOOOkc,,,:dOOOOOOOOOOOOOd,',,'''''''''\n'...................''',,,lOOOOOOOOOOOOkxxkOOOOOOOOxdddkOOOOOOOOOOOOkxxOOOOOOOOOOOOOO0kc''''''''''''\n'...................''',,;xOOOkkkOOOOOOOOOOOOOOOOOxo:;:dOOOOOOOOOOOOOOOOOOOOkkkkOOOOOOOd;'''''''''''\n'.................'''',,,ckxollllldkOOOOOOOOOOOOOO0OkkOOOOOOOOOOOOOOOOOOOkdlllllodkOOOOOc'',''''''''\n''''...........'''',,,,,;odccccccccokOOOOOOOOOOOOOOO0OOOOOOOOO0OOOOOOOOOxlcccccccclk0OOOd;,,,,,,,,''\n'''''''',''',,,,,,,;;;;;;ddcccccccclxOOOOOOOOOOOOkxdddddooddkOOOOOOOOOOOdccccccccclx0OOOOl,;;;;,,,,'\n',,,,,,;;;;;;;;;;;:::::;:xOdolclllokOOOOOOOOOOOOxllodddxdddllkOOOOOOOOOOkocccccccldOOOOOOd:;:;;;;;,,\n,,,;;;;:::::::::::::::cc;lOOOkkkkOOOOOOOOOOOOOOOdlodxxdxddxdcdOOOOOOOOOOOOkxdoddxkOOOOOOOOl:::::;;,,\n,,;;::::cccccccccccccccc::dOOOOOOOOOOOOOOOOOOOO0kolldxxxxxxoldOOOOOOOOOOOOOOOOOOOOOOOOOOOOd::c::;;,,\n,,;;:::cccccccccccccccccc:cxOOOOOOOOOOOOOOOOOOOOOOkxoooooooodOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkc:c:::;,,\n,,;;::::cccccccccccccccc:c:cxOOOOOOOOOOOOOOOOOOOOOOOOOkkkkkOO0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOo;:::;;,,\n,;;;;::::ccccccccccccccc:::;ck0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOx::::;;,,\n*/\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,tune=native\")\n//#pragma GCC optimize (\"unroll-loops\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double old;\n\nconst int N = 700100;\n\nint mp[N];\nint cur;\nint len;\nint bot[N], top[N];\n\nvoid dfs(int v) {\n    mp[v] = cur;\n    bot[cur] = min(bot[cur], v / 7);\n    top[cur] = max(top[cur], v / 7);\n    if (v % 7 && mp[v - 1] == 0) {\n        dfs(v - 1);\n    }\n    if (v % 7 != 6 && mp[v + 1] == 0) {\n        dfs(v + 1);\n    }\n    if (v / 7 && mp[v - 7] == 0) {\n        dfs(v - 7);\n    }\n    if (v + 7 < len && mp[v + 7] == 0) {\n        dfs(v + 7);\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cout << fixed << setprecision(20);\n    ll n;\n    int m, q;\n    cin >> n >> m >> q;\n    if (m == q) {\n        cout << 0;\n        return 0;\n    }\n    len = m;\n    if (len % 7) {\n        len *= 7;\n    }\n    while (q--) {\n        int a;\n        cin >> a;\n        for (int i = a; i < len; i += m) {\n            mp[i] = -1;\n        }\n    }\n    for (int i = 0; i < len; ++i) {\n        if (mp[i] == 0) {\n            ++cur;\n            bot[cur] = len;\n            dfs(i);\n        }\n    }\n    int kek = 0;\n    for (int i = 1; i <= cur; ++i) {\n        if (bot[i] == 0 && top[i] == len / 7 - 1) {\n            ++kek;\n        }\n    }\n    ll ans = (cur - kek) * (n * 7 / len) + kek;\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\n#define REP(i,a,b) for(ll i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\nll gcd(ll a, ll b) {\n    if (b > a) swap(a, b);\n    while (b) {\n        ll t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nll lcm(ll a, ll b) {\n    return a / gcd(a, b) * b;\n}\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\n\nll n, m, q;\nll h;\nint used[707070][7] = {};\nint cal[707070][7] = {};\nint used2[2][7] = {};\nint cal2[2][7] = {};\n\nvoid dfs(int y, int x) {\n    used[y][x] = 1;\n    rep(i,4) {\n        if (y + dy[i] >= 0 && y + dy[i] < h && x + dx[i] >= 0 && x + dx[i] < 7 && !used[y + dy[i]][x + dx[i]] && !cal[y + dy[i]][x + dx[i]]) {\n            dfs(y + dy[i], x + dx[i]);\n        }\n    }\n}\n\nvoid dfs2(int y, int x) {\n    used2[y][x] = 1;\n    rep(i,4) {\n        if (y + dy[i] >= 0 && y + dy[i] < 2 && x + dx[i] >= 0 && x + dx[i] < 7 && !used2[y + dy[i]][x + dx[i]] && !cal2[y + dy[i]][x + dx[i]]) {\n            dfs2(y + dy[i], x + dx[i]);\n        }\n    }\n}\n\nvoid solve() {\n    cin >> n >> m >> q;\n    h = lcm(7, m) / 7;\n    rep(i,q) {\n        ll a;\n        cin >> a;\n        for (ll j = a; j < 7 * h; j += m) {\n            if (cal[j/7][j%7]) break;\n            cal[j/7][j%7] = 1;\n        }\n    }\n    ll cnt = 0;\n    rep(i,h) {\n        rep(j,7) {\n            if (!used[i][j] && !cal[i][j]) {\n                dfs(i, j);\n                cnt++;\n            }\n        }\n    }\n    rep(i,7) cal2[0][i] = cal[h-1][i];\n    rep(i,7) cal2[1][i] = cal[0][i];\n    ll cnt2 = 0;\n    rep(i,2) {\n        rep(j,7) {\n            if (!used2[i][j] && !cal2[i][j]) {\n                dfs2(i, j);\n                cnt2++;\n            }\n        }\n    }\n    ll cnt3 = 0;\n    if (!cal2[0][0]) cnt3++;\n    REP(i,1,7) if (cal2[0][i-1] && !cal2[0][i]) cnt3++;\n    if (!cal2[1][0]) cnt3++;\n    REP(i,1,7) if (cal2[1][i-1] && !cal2[1][i]) cnt3++;\n    cnt2 = cnt3 - cnt2;\n    ll ans = (n / h) * cnt - (n / h - 1) * cnt2;\n    cout << ans << endl;\n}\n\nint main() {\n    cin.tie(0);\n   \tios::sync_with_stdio(false);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n}\n// ここから編集しろ\nint UF[710000];\nint FIND(int a){\n\tif(UF[a]<0)return a;return UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint gcd(int a,int b){while(a){b%=a;swap(a,b);}return b;}\nint lcm(int a,int b){return a/gcd(a,b)*b;}\nint p[110000];\nint main(){\n\tlong long a;\n\tint b,c;scanf(\"%lld%d%d\",&a,&b,&c);\n\tfor(int i=0;i<c;i++){\n\t\tint t;scanf(\"%d\",&t);\n\t\tp[t]=1;\n\t}\n\tfor(int i=0;i<710000;i++)UF[i]=-1;\n\tint S=lcm(b,7);\n\t\n\tfor(int i=0;i<S;i++){\n\t\tif(p[i%b])continue;\n\t\tif(i%7<6&&!p[(i+1)%b])UNION(i,i+1);\n\t\tif(i+7<S&&!p[(i+7)%b])UNION(i,i+7);\n\t}\n\tint sh=0;\n\tint sz=0;\n\tfor(int i=0;i<S;i++)if(!p[i%b]&&UF[i]<0)sz++;\n\tset<pair<int,int > >s;\n\tfor(int i=0;i<7;i++){\n\t\tif(p[i%b])continue;\n\t\tif(p[(S-7+i)%b])continue;\n\t\ts.insert(make_pair(FIND(i),FIND(S-7+i)));\n\t}\n\tsh=s.size();\n\tlong long ret=sz+(long long)(sz-sh)*(a*7/S-1);\n\tprintf(\"%lld\\n\",ret);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nlong n;int m,q,a[1<<17];\nbool f[7][1<<17];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid bfs(int x,int y,long _n)\n{\n\tqueue<pair<int,int> >P;\n\tf[x][y]=true;\n\tP.push(make_pair(x,y));\n\twhile(!P.empty())\n\t{\n\t\tpair<int,int>p=P.front();P.pop();\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint tx=p.first+dx[r],ty=p.second+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=7||ty>=_n||f[tx][ty])continue;\n\t\t\tf[tx][ty]=true;\n\t\t\tP.push(make_pair(tx,ty));\n\t\t}\n\t}\n}\nmain()\n{\n\tcin>>n>>m>>q;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tif(n<=100000)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong ans=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t\tbfs(i,j,n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\telse if(m%7==0)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,m/7*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,m/7*3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=count2-count1;\n\t\tlong syokou=count1-kousa*2;\n\t\tcout<<syokou+kousa*(n/(m/7))<<endl;\n\t}\n\telse\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<2*m;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<2*m;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,2*m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n-n/m*m+m;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count3=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n-n/m*m+m;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount3++;\n\t\t\t\t\tbfs(i,j,n-n/m*m+m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=count2-count1;\n\t\tlong syokou=count1-kousa;\n\t\tlong amari=count3-syokou-kousa;\n\t\tcout<<syokou+kousa*n/m+amari<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nbool t[7][200020],vis[7][200020];\nlong long n,m,q,a;\n\nvoid DFS(int x,int y,int lim){\n\tvis[x][y]=true;\n\tint dx[]={-1,0,0,1},dy[]={0,1,-1,0};\n\tfor(int i=0;i<4;i++){\n\t\tint a=x+dx[i],b=y+dy[i];\n\t\tif(a>=0&&b>=0&&a<7&&b<lim){\n\t\t\tif(!vis[a][b])DFS(a,b,lim);\n\t\t}\n\t}\n}\nint Sol(int lim){\n\tint ret=0;\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<lim;j++){\n\t\t\tvis[i][j]=t[i][j];\n\t\t\t//cout<<t[i][j]<<\" \";\n\t\t}\n\t\t//cout<<endl;\n\t}\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<lim;j++){\n\t\t\tif(!vis[i][j]){\n\t\t\t\tret++;\n\t\t\t\tDFS(i,j,lim);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tcin>>n>>m>>q;\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tt[i][j]=0;\n\t\t}\n\t}\n\twhile(q--){\n\t\tcin>>a;\n\t\tfor(int i=a;i<14*m;i+=m){\n\t\t\tt[i%7][i/7]=1;\n\t\t}\n\t}\n\n\tlong long k=Sol(m),w=Sol(m*2),ans;\n\tint g=n/m;\n\tif(g<=1)ans=Sol(n);\n\telse ans=(n/m-1)*(w-k);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nint main() {\n\tlong long n;\n\tint m, q;\n\tcin >> n >> m >> q;\n\n\tvector<int> a(q);\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> a[i];\n\t}\n\n\tint T = 0;\n\tfor (int i = 1;; i++) {\n\t\tif (m * i % 7 == 0) {\n\t\t\tT = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint H = m * T / 7;\n\tvector<vector<bool>> check1(H, vector<bool>(7));\n\tvector<vector<bool>> check2(H * 2, vector<bool>(7));\n\tfor (int i = 0; i < q; i++) {\n\t\tfor (int j = 0; j < T; j++) {\n\t\t\tint val = a[i] + m * j;\n\t\t\tint y = val / 7;\n\t\t\tint x = val % 7;\n\t\t\tcheck1[y][x] = true;\n\t\t\tcheck2[y][x] = true;\n\t\t\tcheck2[y + H][x] = true;\n\t\t}\n\t}\n\n\tfunction<void(vector<vector<bool>> &, int, int)> dfs = [&](vector<vector<bool>> &check, int y, int x) {\n\t\tconst int dy[] = { 0, 1, 0, -1 };\n\t\tconst int dx[] = { 1, 0, -1, 0 };\n\t\tcheck[y][x] = true;\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tint yy = y + dy[k];\n\t\t\tint xx = x + dx[k];\n\t\t\tif (yy < 0 || xx < 0 || yy >= check.size() || xx >= 7) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (check[yy][xx]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdfs(check, yy, xx);\n\t\t}\n\t};\n\n\tauto count = [&](auto v) {\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < v.size(); i++) {\n\t\t\tfor (int j = 0; j < 7; j++) {\n\t\t\t\tif (!v[i][j]) {\n\t\t\t\t\tdfs(v, i, j);\n\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t};\n\n\tint one = count(check1);\n\tint two = count(check2);\n\n\tint diff = 2 * one - two;\n\tlong long ans = n / H * one - (n / H - 1) * diff;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n\ntypedef long long ll;\nll N; int M, Q; int A[101010];\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { -1, 0, 1, 0 };\n//-----------------------------------------------------------------------------------\nint B[1010101][7];\nint simulate(int loop) {\n    rep(i, 0, M * loop) {\n        int y = i / 7;\n        int x = i % 7;\n        if(!A[i % M]) B[y][x] = 0;\n        else B[y][x] = -1;\n    }\n\n    rep(i, M * loop, M * loop + 10) {\n        int y = i / 7;\n        int x = i % 7;\n        B[y][x] = -1;\n    }\n\n    int cnt = 0;\n    rep(i, 0, M * loop) {\n        int y = i / 7;\n        int x = i % 7;\n        if (B[y][x] == 0) {\n            cnt++;\n            queue<int> que;\n            que.push(i);\n            while (!que.empty()) {\n                int ii = que.front(); que.pop();\n                int y = ii / 7;\n                int x = ii % 7;\n                if (B[y][x] != 0) continue;\n                B[y][x] = cnt;\n                rep(j, 0, 4) {\n                    int yy = y + dy[j];\n                    int xx = x + dx[j];\n                    if (yy < 0) continue;\n                    if (xx < 0 || 7 <= xx) continue;\n                    if (B[yy][xx] == 0) {\n                        que.push(yy * 7 + xx);\n                    }\n                }\n            }\n        }\n    }\n\n    return cnt;\n}\n//-----------------------------------------------------------------------------------\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> M >> Q;\n    rep(i, 0, Q) {\n        int a; cin >> a; A[a] = 1;\n    }\n\n    int loop = 1;\n    if (M % 7) loop = 7;\n    ll num = simulate(loop);\n    \n    ll k = N * 7 / (1LL * M * loop);\n    if (k == 1) {\n        cout << num << endl;\n        return 0;\n    }\n\n    ll num2 = simulate(loop * 2);\n    ll ans = num + (k - 1) * (num2 - num);\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\n#define REP(i,a,b) for(ll i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\nll gcd(ll a, ll b) {\n    if (b > a) swap(a, b);\n    while (b) {\n        ll t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nll lcm(ll a, ll b) {\n    return a / gcd(a, b) * b;\n}\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\n\nll n, m, q;\nll h;\nint used[707070][7] = {};\nint cal[707070][7] = {};\nint used2[2][7] = {};\nint cal2[2][7] = {};\n\nvoid dfs(int y, int x) {\n    used[y][x] = 1;\n    rep(i,4) {\n        if (y + dy[i] >= 0 && y + dy[i] < h && x + dx[i] >= 0 && x + dx[i] < 7 && !used[y + dy[i]][x + dx[i]] && !cal[y + dy[i]][x + dx[i]]) {\n            dfs(y + dy[i], x + dx[i]);\n        }\n    }\n}\n\nvoid dfs2(int y, int x) {\n    used2[y][x] = 1;\n    rep(i,4) {\n        if (y + dy[i] >= 0 && y + dy[i] < 2 && x + dx[i] >= 0 && x + dx[i] < 7 && !used2[y + dy[i]][x + dx[i]] && !cal2[y + dy[i]][x + dx[i]]) {\n            dfs2(y + dy[i], x + dx[i]);\n        }\n    }\n}\n\nvoid solve() {\n    cin >> n >> m >> q;\n    h = lcm(7, m) / 7;\n    rep(i,q) {\n        ll a;\n        cin >> a;\n        for (ll j = a; j < 7 * h; j += m) {\n            cal[j/7][j%7] = 1;\n        }\n    }\n    ll cnt = 0;\n    rep(i,h) {\n        rep(j,7) {\n            if (!used[i][j] && !cal[i][j]) {\n                dfs(i, j);\n                cnt++;\n            }\n        }\n    }\n    rep(i,7) cal2[0][i] = cal[h-1][i];\n    rep(i,7) cal2[1][i] = cal[0][i];\n    ll cnt2 = 0;\n    rep(i,2) {\n        rep(j,7) {\n            if (!used2[i][j] && !cal2[i][j]) {\n                dfs2(i, j);\n                cnt2++;\n            }\n        }\n    }\n    ll cnt3 = 0;\n    if (!cal2[0][0]) cnt3++;\n    REP(i,1,7) if (cal2[0][i-1] && !cal2[0][i]) cnt3++;\n    if (!cal2[1][0]) cnt3++;\n    REP(i,1,7) if (cal2[1][i-1] && !cal2[1][i]) cnt3++;\n    cnt2 = cnt3 - cnt2;\n    ll ans = (n / h) * cnt - (n / h - 1) * cnt2;\n    cout << ans << endl;\n}\n\nint main() {\n    cin.tie(0);\n   \tios::sync_with_stdio(false);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nlong long int n;\nint m;\nint q;\n\n#define MAX 1000002\nint room[MAX][7];\nint id[MAX][7];\n\nbool flag[MAX];\n\nstruct UF{\n\tvector<int> belong;\n\tvector<int> size;\n\tvoid resize(int n){\n\t\tbelong.assign(n + 1, -1);\n\t\tsize.assign(n + 1, 1);\n\t}\n\tinline int root(int b){\n\t\tif (belong[b] == -1){\n\t\t\treturn b;\n\t\t}\n\t\tbelong[b] = root(belong[b]);\n\t\treturn belong[b];\n\t}\n\tvoid merge(int a, int b){\n\t\ta = root(a);\n\t\tb = root(b);\n\t\tif (a == b)return;\n\t\tif (a < b)swap(a, b);\n\t\tbelong[a] = b;\n\t\tsize[b] += size[a];\n\t}\n};\nUF uf;\nint dx[] = { 0, 0, 1, -1 };\nint dy[] = { 1, -1, 0, 0 };\n\nvector<int> v;\n\nvoid solve(int N){\n\tlong long int sum = 0;\n\tif (n <= v.size()){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tsum += v[i];\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\t\treturn;\n\t}\n\tlong long int W = 0;\n\tfor (int i = 1; i < v.size(); i++){\n\t\tW += v[i];\n\t}\n\tn--;\n\tW *= (n / N);\n\tn %= N;\n\tfor (int i = 1; i <= n; i++){\n\t\tW += v[i];\n\t}\n\tW += v[0];\n\tprintf(\"%lld\\n\", W);\n}\nint main(){\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < q; i++){\n\t\tint a;\n\t\tscanf(\"%d\", &a);\n\t\tflag[a] = true;\n\t}\n\tint num = -1;\n\tint nnn = -1;\n\tint N;\n\tbool exi = false;\n\tfor (int i = 0; i < MAX; i++){\n\t\tfor (int j = 0; j < 7; j++){\n\t\t\tnum++;\n\t\t\tnnn++;\n\t\t\tid[i][j] = nnn;\n\t\t\tnum %= m;\n\t\t\tif (i && (j == 0 && num == 0)){\n\t\t\t\tN = i;\n\t\t\t\tfor (int j = 0; j < 7; j++){\n\t\t\t\t\troom[i][j] = room[0][j];\n\t\t\t\t\tid[i][j] = nnn;\n\t\t\t\t\tnnn++;\n\t\t\t\t}\n\t\t\t\texi = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (flag[num]){\n\t\t\t\troom[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tif (exi)break;\n\t}\n\tif (0){\n\n\t}\n\telse{\n\t\tuf.resize(7 * (N+1));\n\t\tfor (int i = 0; i <= N; i++){\n\t\t\tfor (int j = 0; j < 7; j++){\n\t\t\t\tif (room[i][j] == true)continue;\n\t\t\t\tfor (int k = 0; k < 4; k++){\n\t\t\t\t\tint ii = i + dx[k];\n\t\t\t\t\tint jj = j + dy[k];\n\t\t\t\t\tif (ii >= 0 && jj >= 0 && ii <= N&&jj < 7){\n\t\t\t\t\t\tif (room[i][j] == false && room[ii][jj] == false){\n\t\t\t\t\t\t\tuf.merge(id[i][j], id[ii][jj]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= N; i++){\n\t\t\tint inc = 0;\n\t\t\tfor (int j = 0; j < 7; j++){\n\t\t\t\tif (room[i][j] == false){\n\t\t\t\t\tif (uf.root(id[i][j]) == id[i][j]){\n\t\t\t\t\t\tinc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tv.push_back(inc);\n\t\t}\n\t\tsolve(N);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nbool cal[100000][7];\nint n,m,q;\n\nvoid block(int i,int j);\nint main(){\n\tint qt;\n\tint ans;\n\tint i,j,k;\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\t\n\tfor(k=0;k<q;k++){\n\t\tscanf(\"%d\",&qt);\n\t\tfor(i=qt;i<n*7;i+=m){\n\t\t\tcal[i/7][i%7] = true;\n\t\t}\n\t}\n\t\n\tans = 0;\n\tfor(i=0;i<7*n;i++){\n\t\tif(!cal[i/7][i%7]){\n\t\t\tans++;\n\t\t\tblock(i/7,i%7);\n\t\t}\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n\t\nvoid block(int i,int j){\n\tif(cal[i][j]) return;\n\tcal[i][j] = true;\n\tif(i!=n-1){\n\t\tblock(i+1,j);\n\t}\n\tif(j!=6){\n\t\tblock(i,j+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define maxn 4900010\nint a[maxn];\nbool col[maxn][7], vis[maxn][7];\ntypedef long long ll;\nstruct que {\n\tint x, y;\n} qu[maxn];\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\nint up[70], dw[70], Fa[140];\nint Find(int x) {return Fa[x] == x ? x : Fa[x] = Find(Fa[x]);}\nint main()\n{\n\tll n;\n\tint m, q; scanf(\"%lld%d%d\", &n, &m, &q);\n\tfor (int i = 1; i <= q; ++i) scanf(\"%d\", &a[i]);\n\tif (m % 7)\n\t{\n\t\tint nq = q;\n\t\tfor (int i = 1; i <= q; ++i)\n\t\t\tfor (int j = 1; j < 7; ++j)\n\t\t\t\ta[++nq] = a[i] + j * m;\n\t\tm *= 7; q = nq;\n\t}\n\tint mm = m / 7, cnt = 0;\n\n\tfor (int i = 1; i <= q; ++i)\n\t{\n\t\tcol[a[i] / 7][a[i] % 7] = 1;\n//\t\tprintf(\"%d %d\\n\", a[i] / 7, a[i] % 7);\n\t}\n\n\tfor (int i = 0; i < mm; ++i)\n\t\tfor (int j = 0; j < 7; ++j)\n\t\t\tif (!vis[i][j] && !col[i][j])\n\t\t\t{\n\t\t\t\t++cnt;\n\t\t\t\tint head = 0, tail = 1; qu[1] = (que) {i, j}; vis[i][j] = 1;\n\t\t\t\twhile (head < tail)\n\t\t\t\t{\n\t\t\t\t\tque now = qu[++head];\n\t\t\t\t\tfor (int k = 0, nx, ny; k < 4; ++k)\n\t\t\t\t\t{\n\t\t\t\t\t\tnx = now.x + dx[k]; ny = now.y + dy[k];\n\t\t\t\t\t\tif (nx >= 0 && nx < mm && ny >= 0 && ny < 7 && !vis[nx][ny] && !col[nx][ny])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tqu[++tail] = (que) {nx, ny};\n\t\t\t\t\t\t\tvis[nx][ny] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\tprintf(\"%d\\n\", cnt);\n\tint pcnt = 0, cnt2 = 0;\n\tfor (int i = 0; i < 7; ++i) !col[0][i] ? (i == 0 || col[0][i - 1] ? up[i] = ++pcnt : up[i] = pcnt) : 0;\n\tfor (int i = 0; i < 7; ++i) !col[mm - 1][i] ? (i == 0 || col[mm - 1][i - 1] ? dw[i] = ++pcnt : dw[i] = pcnt) : 0;\n\tfor (int i = 1; i <= pcnt; ++i) Fa[i] = i;\n\n//\tfor (int i = 0; i < 7; ++i) printf(\"%d %d\\n\", up[i], dw[i]);\n\tfor (int i = 0; i < 7; ++i)\n\t\tif (up[i] && dw[i] && Find(up[i]) != Find(dw[i]))\n\t\t{\n\t\t\tFa[Find(up[i])] = Find(dw[i]);\n\t\t\t++cnt2;\n\t\t}\n//\tprintf(\"%d\\n\", cnt2);\n//\twhile (n % mm) ;\n\tll ans = 1ll * cnt * (n / mm) - 1ll * (n / mm - 1) * cnt2;\n\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n/*\n1000000000000 21 7\n0 3 6 9 12 15 18\n*/"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a <= x && x < b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\nstd::ostream& operator<<(std::ostream& os, const PAIR& r) {\n\tos << \"(\" << r.first << \", \" << r.second << \")\";\n\treturn os;\n}\n\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nint dy4[] = { -1, 0, 1, 0 };\nint dx4[] = { 0, 1, 0, -1 };\n\nint calc(std::vector<std::vector<bool>>& a) {\n\tint cnt = 0;\n\n\tREP(i, a.size()) {\n\t\tREP(j, 7) {\n\t\t\tif (a[i][j]) continue;\n\t\t\t++cnt;\n\t\t\tstd::queue<PAIR> que;\n\t\t\tque.push(PAIR(i, j));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tPAIR now = que.front(); que.pop();\n\t\t\t\ta[now.first][now.second] = true;\n\t\t\t\tREP(d, 4) {\n\t\t\t\t\tint dy = now.first + dy4[d];\n\t\t\t\t\tint dx = now.second + dx4[d];\n\t\t\t\t\tif (!IN(0, dy, a.size()) || !IN(0, dx, 7)) continue;\n\t\t\t\t\tif (a[dy][dx]) continue;\n\t\t\t\t\tque.push(PAIR(dy, dx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, m, q);\n\tVEC(int, a, q);\n\tstd::vector<bool> bb(m, false);\n\tREP(i, q) {\n\t\tbb[a[i]] = true;\n\t}\n\tif (n <= 100000) {\n\t\tstd::vector<std::vector<bool>> b(n, std::vector<bool>(7, false));\n\t\tREP(i, n) REP(j, 7) {\n\t\t\tif (bb[((7 * (i - 1) + j - 7) % m + m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tOUT(calc(b))BR;\n\t\treturn 0;\n\t}\n\n\tstd::vector<int> t(2);\n\tREP(_, 2) {\n\t\tstd::vector<std::vector<bool>> b(m / 7 * (_ + 1), std::vector<bool>(7, false));\n\t\tREP(i, m / 7 * (_ + 1)) REP(j, 7) {\n\t\t\tif (bb[(7 * (i - 1) + j - 7 + 8 * m) % m]) {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tt[_] = calc(b);\n\t}\n\tint x = 7 * n / m;\n\tint d = t[1] - t[0];\n\tOUT(t[0] + (x - 1)*d)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int>P;\n\nint a[114514];\nbool cal[10][114514];\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,-1,0,1 };\nint main() {\n\tLL n, m, q;\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < q; i++)cin >> a[i];\n\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < 7; j++)cal[j][i] = false;\n\n\tfor (int i = 0; i < q; i++) {\n\t\tfor (int j = a[i]; j < 7 * n; j += m) {\n\t\t\tint b, c;\n\t\t\tb = j / 7;\n\t\t\tc = j % 7;\n\t\t\tcal[c][b] = true;\n\t\t}\n\t}\n\n\tqueue<P>Q;\n\tint ans = 0;\n\tfor (int i = 0; i < 7; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (cal[i][j])continue;\n\t\t\tans++;\n\t\t\tQ.push(P(i, j));\n\t\t\twhile (Q.size()) {\n\t\t\t\tP a = Q.front();\n\t\t\t\tQ.pop();\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint sx = a.first + dx[k], sy = a.second + dy[k];\n\t\t\t\t\tif (0 > sx || sx >= 7 || 0 > sy || sy >= n)continue;\n\t\t\t\t\tif (cal[sx][sy])continue;\n\t\t\t\t\tcal[sx][sy] = true;\n\t\t\t\t\tQ.push(P(sx, sy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n \nauto& in = std::cin;\nauto& out = std::cout;\n \nint32_t N, m;\nbool MAP[300001][8];\nbool MOD[200010];\nint32_t a[200010];\n \ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) {\n\tarr = v;\n}\ntemplate<typename T, typename ARR>\nvoid fill_all(ARR& arr, const T& v) {\n\tfor (auto& i : arr) { fill_all(i, v); }\n}\n \nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t Q;\n\tin >> N >> m >> Q;\n\tfor (int32_t i = 0; i < Q; ++i)\n\t{\n\t\tin >> a[i];\n\t\tMOD[a[i]] = true;\n\t}\n \n\tif (N <= 100000)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < N; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tout << count << endl;\n\t}\n\telse if ((m % 7) == 0)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < (m/7); ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n \n\t\tint32_t count1 = count;\n \n\t\tfill_all(MAP, false);\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tcount = 0;\n\t\tfor (int32_t y = 0; y < (m / 7)*2; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n \n\t\tout << (count - count1)*((7*N)/m)+count1 << endl;\n\t}\n \n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n// #define DEBUG\n#ifdef DEBUG\n#define dump(...) cerr<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<make_tuple(__VA_ARGS__)<<\"\\n\";\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '{'; for(int i = 0; i < (int) v.size(); i++) o << v[i] << (i != (int)v.size()-1 ? \", \" : \"\"); o << \"}\";  return o; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\n#else\n#define dump(...)\n#endif\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\n\nll period;\nvector< vector<int> > tmp, f;\n\nll BFS(vector< vector<int> > &used, int y0, int y1, int h) {\n  ll cnt = 0;\n  for(ll y = y0; y < y1; y++) {\n    for(ll x = 0; x < 7; x++) {\n      if(f[y][x]) continue;\n      if(used[y][x]) continue;\n      // if(connect != -1 ? f[connect][x] : false) continue;\n      used[y][x] = 1;\n      queue<pair<ll, ll>> q;\n      q.emplace(y, x);\n      cnt++;\n      while(q.size()) {\n        ll yy = q.front().first, xx = q.front().second;\n        q.pop();\n        for(int d = 0; d < 4; d++) {\n          ll ny = yy + dy[d];\n          ll nx = xx + dx[d];\n          if(ny < 0 || h <= ny || nx < 0 || 7 <= nx) continue;\n          if(f[ny][nx]) continue;\n          if(used[ny][nx]) continue;\n          used[ny][nx] = 1;\n          q.emplace(ny, nx);\n        }\n      }\n    }\n  }\n  return cnt;\n}\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  ll n, m, q; cin >> n >> m >> q;\n  ll h = (m + 6) / 7; // one shared block\n  period = h * 7 - (7 - m % 7) % 7; // height of period\n  if(period % 7 == 0) period /= 7; // 一応これで最小単位の最大値になるはず\n  ll full = n / period;\n  ll rest = n - full * period;\n  tmp = vector< vector<int> >(period * 3, vector<int>(7) );\n  f = tmp;\n\n  while(q--) {\n    ll a; cin >> a;\n    for(; a < period * 7; a += m) {\n      ll y = a / 7, x = a % 7;\n      f[y][x] = 1;\n      f[y + period][x] = 1;\n      f[y + period * 2][x] = 1;\n    }\n  }\n\n  auto used = tmp;\n  ll b2 = BFS(used, 0, period, period * 3);\n  ll b4 = BFS(used, period, period * 2, period * 3);\n  auto used2 = tmp;\n  BFS(used2, 0, period, period * 2 + rest);\n  ll b3 = BFS(used2, period, period * 2 + rest, period * 2 + rest);\n  auto used3 = tmp;\n  ll b1 = BFS(used3, 0, period + rest, period + rest);\n  auto used4 = tmp;\n  ll b5 = BFS(used4, 0, rest, rest);\n\n  ll ans = 0;\n  \n  if(full == 0) {\n    ans = b5;\n  } else if(full == 1) {\n    ans = b1;\n  } else {\n    ans = b2 + b3 + (full - 2) * b4;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nlong n;int m,q,a[1<<17];\nbool f[7][1<<17];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid bfs(int x,int y,long _n)\n{\n\tqueue<pair<int,int> >P;\n\tf[x][y]=true;\n\tP.push(make_pair(x,y));\n\twhile(!P.empty())\n\t{\n\t\tpair<int,int>p=P.front();P.pop();\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint tx=p.first+dx[r],ty=p.second+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=7||ty>=_n||f[tx][ty])continue;\n\t\t\tf[tx][ty]=true;\n\t\t\tP.push(make_pair(tx,ty));\n\t\t}\n\t}\n}\nmain()\n{\n\tcin>>n>>m>>q;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tif(n<=100000)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong ans=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t\tbfs(i,j,n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\telse if(m%7==0)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,m/7*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,m/7*3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=count2-count1;\n\t\tlong syokou=count1-kousa*2;\n\t\tcout<<syokou+kousa*(n/(m/7))<<endl;\n\t}\n\telse\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<7;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<7;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,7);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<14;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<14;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,14);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=(count2-count1)/7;\n\t\tlong syokou=count1-kousa*7;\n\t\tcout<<syokou+kousa*n<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\nll n,m,q;\nbitset<100000> ok;\n\ntemplate<int SZ> struct DSU {\n    int par[SZ], sz[SZ];\n\n    DSU() {\n        F0R(i,SZ) par[i] = i, sz[i] = 1;\n    }\n\n    int get(int x) { // path compression\n    \tif (par[x] != x) par[x] = get(par[x]);\n    \treturn par[x];\n    }\n\n    bool unite(int x, int y) { // union-by-rank\n    \tx = get(x), y = get(y);\n    \tif (x == y) return 0;\n    \tif (sz[x] < sz[y]) swap(x,y);\n    \tsz[x] += sz[y], par[y] = x;\n    \treturn 1;\n    }\n};\n\nDSU<700000> D;\nll tot = 0;\nint rows;\n\nvoid tri(int a, int b) {\n\tif (ok[a%m] && ok[b%m]) tot -= D.unite(a,b);\n}\n\nint get(int x) {\n\tif (!ok[x%m]) return -1;\n\treturn D.get(x);\n}\n\npair<int,vi> unite(vi b, vi A, vi B) {\n\tmap<int,int> m;\n\ttrav(t,b) if (t != -1) t += MOD;\n\ttrav(t,b) m[t] = 0;\n\ttrav(t,A) m[t] = 0;\n\ttrav(t,B) m[t] = 0;\n\tm.erase(-1);\n\tint co = 0;\n\ttrav(t,m) t.s = co++;\n\ttrav(t,b) if (t != -1) t = m[t];\n\ttrav(t,A) if (t != -1) t = m[t];\n\ttrav(t,B) if (t != -1) t = m[t];\n\t// ps(b,A,B);\n\tDSU<21> Z = DSU<21>();\n\t\n\tint ret = 0;\n\tF0R(i,7) if (b[i] != -1 && A[i] != -1) ret += Z.unite(b[i],A[i]);\n\tF0R(i,7) if (B[i] != -1) B[i] = Z.get(B[i]);\n\treturn {ret,B};\n}\n\nvi compress(vi v) {\n\tmap<int,int> m;\n\ttrav(t,v) {\n\t\tif (!m.count(t)) {\n\t\t\tint co = sz(m);\n\t\t\tm[t] = co;\n\t\t}\n\t\tt = m[t];\n\t}\n\treturn v;\n}\n\nvoid fin(vi a, vi b) {\n\t// ps(\"HUH\",a,b);\n\tint lst = MOD;\n\tvi B = b;\n\tF0R(i,n/rows-1) {\n\t\tpair<int,vi> t = unite(B,a,b);\n\t\tif (compress(B) == compress(t.s)) {\n\t\t\t// ps(\"HUH\",B,compress(B));\n\t\t\ttot -= (n/rows-1-i)*t.f;\n\t\t\tbreak;\n\t\t} else {\n\t\t\ttot -= t.f;\n\t\t}\n\t\tlst = t.f; B = t.s;\n\t}\n}\n\nint main() {\n    setIO(); re(n,m,q);\n    F0R(i,m) ok[i] = 1;\n    F0R(i,q) {\n    \tint x; re(x);\n    \tok[x] = 0;\n    }\n    tot = m-q;\n    rows = m; if (m%7 == 0) rows /= 7;\n    // ps(tot,rows);\n    F0R(i,rows) F0R(j,6) tri(7*i+j,7*i+j+1);\n    F0R(i,rows-1) F0R(j,7) tri(7*i+j,7*(i+1)+j);\n    // ps(\"??\",tot);\n    tot *= n/rows;\n    vi a,b;\n    F0R(j,7) {\n    \ta.pb(get(j));\n    \tb.pb(get(7*(rows-1)+j));\n    }\n    fin(a,b);\n    ps(tot);\n    // you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nlong n;int m,q,a[1<<17];\nbool f[7][1<<17];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid bfs(int x,int y,long _n)\n{\n\tqueue<pair<int,int> >P;\n\tf[x][y]=true;\n\tP.push(make_pair(x,y));\n\twhile(!P.empty())\n\t{\n\t\tpair<int,int>p=P.front();P.pop();\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint tx=p.first+dx[r],ty=p.second+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=7||ty>=_n||f[tx][ty])continue;\n\t\t\tf[tx][ty]=true;\n\t\t\tP.push(make_pair(tx,ty));\n\t\t}\n\t}\n}\nmain()\n{\n\tcin>>n>>m>>q;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tif(n<=100000)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong ans=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t\tbfs(i,j,n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\telse if(m%7==0)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+1)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,m/7*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,m/7*3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=count2-count1;\n\t\tlong syokou=count1-kousa*2;\n\t\tcout<<syokou+kousa*(n/(m/7))<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define  inc(i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define  dec(i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define UB upper_bound\n#define LB lower_bound\n#define PQ priority_queue\n\n#define  ALL(v)  v.begin(),  v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define  FOR(it, v) for(auto it =  v.begin(); it !=  v.end(); ++it)\n#define RFOR(it, v) for(auto it = v.rbegin(); it != v.rend(); ++it)\n\ntemplate<typename T> bool   setmin(T & a, T b) { if(b <  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool   setmax(T & a, T b) { if(b >  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmineq(T & a, T b) { if(b <= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmaxeq(T & a, T b) { if(b >= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, m, q, a[100000];\nint b[100000][7];\n\nvoid dfs(int pi, int pj) {\n\tint di[] = { 1, 0, -1,  0 };\n\tint dj[] = { 0, 1,  0, -1 };\n\t\n\tinc(k, 4) {\n\t\tint i = pi + di[k];\n\t\tint j = pj + dj[k];\n\t\tif(inID(i, 0, n) && inID(j, 0, 7) && b[i][j] == 0) {\n\t\t\tb[i][j] = 1;\n\t\t\tdfs(i, j);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> m >> q;\n\tinc(i, q) { cin >> a[i]; }\n\t\n\tif(n > 100000) { return 0; }\n\t\n\tinc(i, q) {\n\t\tint x = a[i];\n\t\tinc(j, 7 * n) {\n\t\t\tb[x / 7][x % 7] = 1;\n\t\t\t\n\t\t\tx += m;\n\t\t\tif(j >= 7 * n) { break; }\n\t\t}\n\t}\n\t\n\treturn 0;\n\t\n\tint ans = 0;\n\tinc(i, n) {\n\tinc(j, 7) {\n\t\tif(b[i][j] == 0) {\n\t\t\tb[i][j] = 1;\n\t\t\tans++;\n\t\t\tdfs(i, j);\n\t\t}\n\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n}\n// ここから編集しろ\nint UF[710000];\nint FIND(int a){\n\tif(UF[a]<0)return a;return UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint gcd(int a,int b){while(a){b%=a;swap(a,b);}return b;}\nint lcm(int a,int b){return a/gcd(a,b)*b;}\nint p[110000];\nint main(){\n\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<c;i++){\n\t\tint t;scanf(\"%d\",&t);\n\t\tp[t]=1;\n\t}\n\tfor(int i=0;i<710000;i++)UF[i]=-1;\n\tint S=lcm(b,7);\n\t\n\tfor(int i=0;i<S;i++){\n\t\tif(p[i%b])continue;\n\t\tif(i%7<6&&!p[(i+1)%b])UNION(i,i+1);\n\t\tif(i+7<S&&!p[(i+7)%b])UNION(i,i+7);\n\t}\n\tint sh=0;\n\tint sz=0;\n\tfor(int i=0;i<S;i++)if(!p[i%b]&&UF[i]<0)sz++;\n\tset<pair<int,int > >s;\n\tfor(int i=0;i<7;i++){\n\t\tif(p[i%b])continue;\n\t\tif(p[(S-7+i)%b])continue;\n\t\ts.insert(make_pair(FIND(i),FIND(S-7+i)));\n\t}\n\tsh=s.size();\n\tlong long ret=sz+(long long)(sz-sh)*(a*7/S-1);\n\tprintf(\"%lld\\n\",ret);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll N,M,Q;\nint A[101010];\nint col[1500000];\n\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank,cnt;\n\tUF() {par=rank=vector<int>(um,0); cnt=vector<int>(um,1); for(int i=0;i<um;i++) par[i]=i;}\n\tvoid reinit() {int i; FOR(i,um) rank[i]=0,cnt[i]=1,par[i]=i;}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint count(int x) { return cnt[operator[](x)];}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tcnt[y]=cnt[x]=cnt[x]+cnt[y];\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\n\nUF<1407070> uf1,uf2,uftail;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>Q;\n\tFOR(i,Q) {\n\t\tcin>>A[i];\n\t\tfor(j=A[i];j<14*M;j+=M) col[j]=1;\n\t}\n\t\n\tll pat;\n\tint num[3]={};\n\tif(M%7==0) {\n\t\tFOR(i,M) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uf1(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<M) && col[i+7]==0) uf1(i,i+7);\n\t\t}\n\t\tFOR(i,2*M) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uf2(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<2*M) && col[i+7]==0) uf2(i,i+7);\n\t\t}\n\t\tFOR(i,M) if(col[i]==0 && uf1[i]==i) num[0]++;\n\t\tFOR(i,2*M) if(col[i]==0 && uf2[i]==i) num[1]++;\n\t\tll pat=7*N/M;\n\t}\n\telse {\n\t\tFOR(i,7*M) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uf1(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<7*M) && col[i+7]==0) uf1(i,i+7);\n\t\t}\n\t\tFOR(i,14*M) {\n\t\t\tif(col[i]==0 && (i%7<6) && col[i+1]==0) uf2(i,i+1);\n\t\t\tif(col[i]==0 && (i+7<14*M) && col[i+7]==0) uf2(i,i+7);\n\t\t}\n\t\tint num[3]={};\n\t\tFOR(i,7*M) if(col[i]==0 && uf1[i]==i) num[0]++;\n\t\tFOR(i,14*M) if(col[i]==0 && uf2[i]==i) num[1]++;\n\t\tll pat=N/M;\n\t}\n\tcout<<num[0]+(pat-1)*(num[1]-num[0])<<endl;\n\t\n}\n\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nlong n;int m,q,a[1<<17];\nbool f[7][1<<17];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid bfs(int x,int y)\n{\n\tqueue<pair<int,int> >P;\n\tf[x][y]=true;\n\tP.push(make_pair(x,y));\n\twhile(!P.empty())\n\t{\n\t\tpair<int,int>p=P.front();P.pop();\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint tx=p.first+dx[r],ty=p.second+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=7||ty>=n||f[tx][ty])continue;\n\t\t\tf[tx][ty]=true;\n\t\t\tP.push(make_pair(tx,ty));\n\t\t}\n\t}\n}\nmain()\n{\n\tcin>>n>>m>>q;\n\tif(n>100000)return 0;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tfor(int i=0;i<7;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tint b=(j*7+i)%m;\n\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t}\n\t}\n\tlong ans=0;\n\tfor(int i=0;i<7;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(!f[i][j])\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t\tbfs(i,j);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nlong n;int m,q,a[1<<17];\nbool f[7][1<<17];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid bfs(int x,int y,long _n)\n{\n\tqueue<pair<int,int> >P;\n\tf[x][y]=true;\n\tP.push(make_pair(x,y));\n\twhile(!P.empty())\n\t{\n\t\tpair<int,int>p=P.front();P.pop();\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint tx=p.first+dx[r],ty=p.second+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=7||ty>=_n||f[tx][ty])continue;\n\t\t\tf[tx][ty]=true;\n\t\t\tP.push(make_pair(tx,ty));\n\t\t}\n\t}\n}\nmain()\n{\n\tcin>>n>>m>>q;\n\tif(n<=100000)\n\t{\n\t\tfor(int i=0;i<q;i++)\n\t\t{\n\t\t\tcin>>a[i];\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong ans=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t\tbfs(i,j,n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\telse if(m%7==0)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+1)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,m/7*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,m/7*3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=count2-count1;\n\t\tlong syokou=count1-kousa*2;\n\t\tcout<<syokou+kousa*(n/(m/7))<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 2147483600\n\nclass UnionFind {\npublic:\n  vector<int> par, rank; // parent(negative := its root and abs-value is its size), depth\n  UnionFind(int sz) : par(sz, -1), rank(sz, 0){}\n  int find(int x){\n    if(par[x]<0) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;  // already belong to same tree\n    if(rank[x] < rank[y]){  // y becomes parent node\n      par[y] += par[x];\n      par[x] = y;\n    } else {  // x becomes parent node\n      par[x] += par[y];\n      par[y] = x;\n      if(rank[x]==rank[y]) rank[x]++;\n    }\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int size(int x){ return -par[find(x)]; }\n};\n\nlong calc(int m, vector<long> &vec, int x){\n  UnionFind uf(m*x);\n  vector<bool> c(m*x, true);\n  rep(i,x) for(auto j : vec) c[m*i+j]=false;\n\n  rep(i,m*x) if(c[i]){\n    if(i%7>0 && c[i-1]) uf.unite(i-1, i);\n    if(i>6 && c[i-7]) uf.unite(i-7, i);\n    if(i%7<6 && c[i+1]) uf.unite(i+1, i);\n    if(i+7<m*x && c[i+7]) uf.unite(i+7, i);\n  }\n\n  long ret=0;\n  rep(i,m*x) if(c[i] && uf.par[i]<0) ret++;\n  return ret;\n}\n\nint main(){\n  long n,m,q;\n  cin>>n>>m>>q;\n  vector<long> a(q);\n  rep(i,q) cin>>a[i];\n\n  if(m%7==0){\n    long r1 = calc(m, a, 1);\n    long r2 = calc(m, a ,2);\n    cout << r1 + (r2-r1)*(n/(m/7) - 1)<< endl;\n  } else {\n    long r1 = calc(7*m, a, 7);\n    long r2 = calc(7*m, a, 14);\n    cout << r1 + (r2-r1)*(n/m - 1) << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint par[1400010];\nint b[1400010];\nint find(int x) {\n\treturn par[x] == x ? x : (par[x] = find(par[x]));\n}\nvoid unite(int x, int y) {\n\tpar[find(x)] = find(y);\n}\nint ban[100010];\nint main() {\n\tlong long n;\n\tint m, q;\n\tscanf(\"%lld%d%d\", &n, &m, &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tban[x] = 1;\n\t}\n\tif (m == 1) {\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < 1400010; i++) {\n\t\tpar[i] = i;\n\t}\n\tint k = 0;\n\tlong long c[2] = {};\n\tc[0] = -1;\n\tfor (long long i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 7; j++) {\n\t\t\tb[k+j] = ban[(k + j) %  m];\n\t\t}\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tif (!b[k+j] && !b[k+j+1]) {\n\t\t\t\tunite(k + j, k + j + 1);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < 7; j++) {\n\t\t\tif (k && !b[k+j] && !b[k+j-7]) {\n\t\t\t\tunite(k + j, k + j - 7);\n\t\t\t}\n\t\t}\n\t\tif (i % m == m - 1) {\n\t\t\tc[i/m] = 0;\n\t\t\tfor (int j = 0; j < i * 7 + 7; j++) {\n\t\t\t\tif (!b[j] && find(j) == j) {\n\t\t\t\t\tc[i/m]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == 2 * m - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tk += 7;\n\t}\n\tlong long p = n / m, qu = n % m;\n\tlong long ans = 0;\n\tif (p == 0 || c[0] == -1) {\n\t\tfor (int j = 0; j < n * 7; j++) {\n\t\t\tif (!b[j] && find(j) == j) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tans = c[0];\n\t\tans += (c[1] - c[0]) * (p - 1);\n\t\tfor (int j = m * 7; j < (m + qu) * 7; j++) {\n\t\t\tif (!b[j] && find(j) == j) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  for(int i=0;i<(n);++i)\n#define REPr(i,n) for(int i=(n)-1;i>=0; --i)\n#define FORq(i, m, n) for(int i = (m);i <= (n);++i)\n#define rFORq(i, m , n) for(int i = (n);i >=(m);--i)\n#define SCD(n) scanf(\"%d\",&n)\n#define SCD2(m,n) scanf(\"%d%d\",&m,&n)\n#define SCD3(m,n,k) scanf(\"%d%d%d\",&m,&n,&k)\n#define SCLLD(n) scanf(\"%lld\",&n)\n#define SCLLD2(m,n) scanf(\"%lld%lld\",&m,&n)\n#define SCLLD3(m,n,k) scanf(\"%lld%lld%lld\",&m,&n,&k)\n#define PB push_back\n#define MP make_pair\n#define ARSCD(A,N) REP(i,N){SCD(A[i]);}\n#define ARSCD1(A,N) FORq(i,1,N){SCD(A[i]);}\n#define VSCD(v,N) REP(i,N){int x; SCD(x); v.PB(x);}\n#define VSCLLD(v,N) REP(i,N){long long x; SCLLD(x); v.PB(x);}\n#define PRINTD(n) printf(\"%d\\n\",n)\n#define PRINTLLD(n) printf(\"%lld\\n\",n)\n#define DEBUG printf(\"%s\\n\",\"debug\")\n#define fst first\n#define snd second\n#define SIN(x,S) (S.count(x) != 0)\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector < VI > VVI;\ntypedef vector<long long> VL;\ntypedef long long ll;\ntypedef long long integer;\n////////////////////////////////////////////////////////////////////\nconst ll p = 1000000007;\nll dx[4] = {-7,-1,1,7};\n\nint main(){\n    ll N,M,Q; SCLLD3(N,M,Q);\n    static ll a[100002] = {};\n    static bool grid[200002] = {}; // partial\n    static bool visited[100002] = {};\n    static bool visited2[200002] = {};\n    //static bool visited[100002] = {};\n    ARSCD(a,Q);\n\n    REP(q,Q){\n        ll ai = a[q];\n        ll k = 0;\n        while(k*M + ai < 2*M){\n            grid[k*M+ai] = true;\n            k++;\n        }\n    }\n\n/*     FORq(i,0,2*M-1){\n        if (i % 7 == 0) printf(\"\\n\");\n        if (grid[i]) printf(\"%d\",1);\n        else printf(\"%d\",0);\n    }\n    printf(\"\\n\"); */\n\n    ll count1 = 0;\n    ll count2 = 0;\n    queue<ll> que;\n\n    // #1\n    FORq(i,0,M-1){\n        if (grid[i]) continue;\n        if (visited[i]) continue;\n        que.push(i);\n        //printf(\"start = %d\\n\",i);\n        while(!que.empty()){\n            ll now = que.front(); que.pop();\n            visited[now] = true;\n            \n            REP(k,4){\n                ll next = now + dx[k];\n                if ((now % 7 == 0) and (k == 1)) continue;\n                if (next < 0) continue;\n                if (next >= M) continue;\n                if ((now % 7 == 6) and (k == 2)) continue;\n                if (grid[next]) continue;\n                if (visited[next]) continue;\n                //printf(\"next -> %lld\\n\",next);\n                que.push(next);\n            }\n        }\n        //printf(\"count+\\n\");\n        count1++;\n    }\n\n    //printf(\"count1 = %lld\\n\",count1);\n\n    // #2\n    FORq(i,0,2*M-1){\n        if (grid[i]) continue;\n        if (visited2[i]) continue;\n        que.push(i);\n        //printf(\"start = %d\\n\",i);\n        while(!que.empty()){\n            ll now = que.front(); que.pop();\n            visited2[now] = true;\n            \n            REP(k,4){\n                ll next = now + dx[k];\n                if ((now % 7 == 0) and (k == 1)) continue;\n                if (next < 0) continue;\n                if (next >= 2*M) continue;\n                if ((now % 7 == 6) and (k == 2)) continue;\n                if (grid[next]) continue;\n                if (visited2[next]) continue;\n                //printf(\"next -> %lld\\n\",next);\n                que.push(next);\n            }\n        }\n        //printf(\"count+\\n\");\n        count2++;\n    }\n    \n    //printf(\"count2 = %lld\\n\",count2);\n\n    ll A,B;\n    A = count2 - count1;\n    B = count1 - A;\n    ll c = 7*N / M;\n    PRINTLLD(A*c + B);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint a[100000];\nbool b[1000000][7];\nbool used[1000000][7];\nll n;\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nvoid dfs(int x, int y) {\n\tused[x][y] = 1;\n\trep(i, 4) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < n && 0 <= ny&&ny < 7&&!used[nx][ny]&&b[nx][ny]!=1) {\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\nint main() {\n\tint m, q; scanf(\"%lld%d%d\", &n, &m, &q);\n\tif (n <= 100000) {\n\t\trep(i, q) {\n\t\t\tint a; scanf(\"%d\", &a);\n\t\t\tfor (int j = a; j < 7*n; j += m)b[j / 7][j % 7] = 1;\n\t\t}\n\t\tint cnt = 0;\n\t\trep(i, n)rep(j, 7) {\n\t\t\tif (!used[i][j]&&!b[i][j]) {\n\t\t\t\tcnt++; dfs(i, j);\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nlong n;int m,q,a[1<<17];\nbool f[7][1<<18];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid bfs(int x,int y,long _n)\n{\n\tqueue<pair<int,int> >P;\n\tf[x][y]=true;\n\tP.push(make_pair(x,y));\n\twhile(!P.empty())\n\t{\n\t\tpair<int,int>p=P.front();P.pop();\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint tx=p.first+dx[r],ty=p.second+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=7||ty>=_n||f[tx][ty])continue;\n\t\t\tf[tx][ty]=true;\n\t\t\tP.push(make_pair(tx,ty));\n\t\t}\n\t}\n}\nmain()\n{\n\tcin>>n>>m>>q;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tif(n<=100000)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong ans=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t\tbfs(i,j,n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\telse if(m%7==0)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,m/7*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,m/7*3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=count2-count1;\n\t\tlong syokou=count1-kousa*2;\n\t\tcout<<syokou+kousa*(n/(m/7))<<endl;\n\t}\n\telse\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<2*m;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<2*m;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,2*m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n-n/m*m+m;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count3=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n-n/m*m+m;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount3++;\n\t\t\t\t\tbfs(i,j,n-n/m*m+m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=count2-count1;\n\t\tlong syokou=count1-kousa;\n\t\tlong amari=count3-syokou-kousa;\n\t\tcout<<syokou+kousa*(n/m)+amari<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\n#define FOR(k,m,n) for(ll (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<< #str << \" \" str<<endl\n\nconstexpr int INF = (1 << 30);\nconstexpr ll INFL = (1ll << 60);\nconstexpr ll MOD = 1000000007;// 10^9+7\n\nvector<ll> scale(vector<ll> a, ll& m) {\n\tvector<ll> res;\n\tfor (auto num : a) REP(i, 7) {\n\t\tres.push_back(i*m + num);\n\t}\n\tsort(res.begin(), res.end());\n\tm *= 7;\n\treturn res;\n}\n\nbool isin(ll h, ll w, ll line) {\n\treturn 0 <= h && h < line && 0 <= w && w < 7;\n}\n\nvoid paint(vector<vector<bool>>& use, pair<ll, ll> p) {\n\tll dh[] = { 0,1,0,-1 };\n\tll dw[] = { 1,0,-1,0 };\n\tqueue<pair<ll, ll>> que;\n\tque.push(p);\n\twhile (!que.empty()) {\n\t\tauto now = que.front(); que.pop();\n\t\tREP(dir, 4) {\n\t\t\tll h = now.first + dh[dir];\n\t\t\tll w = now.second + dw[dir];\n\t\t\tif (isin(h, w, use.size()) && !use[h][w]) {\n\t\t\t\tuse[h][w] = true;\n\t\t\t\tque.push({ h,w });\n\t\t\t}\n\t\t}\n\t}\n}\n\nll count(vector<ll> a, ll line, ll loop) {\n\tll cnt = 0;\n\tvector<vector<bool>> use(line, vector<bool>(7, false));\n\tfor (auto num : a)use[num / 7][num % 7] = true;\n\tREP(i, loop - 1)REP(j, line)use.push_back(use[j]);\n\n\tREP(h, line*loop)REP(w, 7)if (!use[h][w]) {\n\t\tpaint(use, { h,w });\n\t\tcnt++;\n\t}\n\treturn cnt;\n\n}\n\npair<ll, ll> find_func(ll p1, ll p2) {\n\tFOR(a, -100, 100)FOR(b, -100, 100) {\n\t\tif (a + b == p1 && a * 2 + b == p2) {\n\t\t\treturn { a,b };\n\t\t}\n\t}\n}\n\nint main()\n{\n\tll n, m, q;\n\tcin >> n >> m >> q;\n\tvector<ll> a(q);\n\tREP(i, q)cin >> a[i];\n\tif (m % 7 != 0)a = scale(a, m);\n\n\tll pos1 = count(a, m / 7, 1);\n\tll pos2 = count(a, m / 7, 2);\n\tauto func = find_func(pos1, pos2);\n\tcout << func.first*(n / (m / 7)) + func.second << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\n\nconst int M_N=400001;\n\nstruct UnionFind{\n    int par[M_N];\n    int rank[M_N];\n\n    void init(int n){\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            rank[i]=0;\n        }\n    }\n\n    int find(int x){\n        if(par[x]==x){\n            return x;\n        }\n        else{\n            return par[x]=find(par[x]);\n        }\n    }\n\n    void unite(int x,int y){\n        x=find(x);\n        y=find(y);\n        if(x==y) return;\n        if(rank[x]<rank[y]){\n            par[x]=y;\n        }\n        else{\n            par[y]=x;\n            if(rank[x]==rank[y]) rank[x]++;\n        }\n    }\n\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n};\n\n\nint main(){\n    int n,m,q;cin >> n >> m >> q;\n    vector<int> a(q);\n    for (int i = 0; i < q; i++) {\n        cin >> a[i];\n    }\n    int t = 7 * n / m;\n    vector<vector<int>> v(m / 7, vector<int> (7,0));\n    vector<vector<int>> vv(2 * m / 7, vector<int> (7,0));\n    for (int i = 0; i < q; i++) {\n        int y = a[i] / 7, x = a[i] % 7;\n        v[y][x] = 1;\n        vv[y][x] = 1;\n        vv[m / 7 + y][x] = 1;\n    }\n    auto f = [](vector<vector<int>> &a){\n        int h = a.size(), w = a[0].size();\n        UnionFind uf;\n        uf.init(h*w);\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if(j+1<w&&a[i][j] == a[i][j+1]) uf.unite(i*7+j,i*7+j+1);\n                if(i+1<h&&a[i][j] == a[i+1][j]) uf.unite(i*7+j,(i+1)*7+j);\n            }\n        }\n        int ret = 0;\n        for (int i = 0; i < h*w; i++) {\n            if(uf.find(i)==i && a[i/7][i%7] == 0) ret++;\n        }\n        return ret;\n    };\n    if(t == 1){\n        cout << f(v) << endl;\n    }\n    else if(t == 2){\n        cout << f(vv) << endl;\n    }\n    else{\n        cout << f(v) + (t - 1) * (f(vv) - f(v)) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  for(int i=0;i<(n);++i)\n#define REPr(i,n) for(int i=(n)-1;i>=0; --i)\n#define FORq(i, m, n) for(int i = (m);i <= (n);++i)\n#define rFORq(i, m , n) for(int i = (n);i >=(m);--i)\n#define SCD(n) scanf(\"%d\",&n)\n#define SCD2(m,n) scanf(\"%d%d\",&m,&n)\n#define SCD3(m,n,k) scanf(\"%d%d%d\",&m,&n,&k)\n#define SCLLD(n) scanf(\"%lld\",&n)\n#define SCLLD2(m,n) scanf(\"%lld%lld\",&m,&n)\n#define SCLLD3(m,n,k) scanf(\"%lld%lld%lld\",&m,&n,&k)\n#define PB push_back\n#define MP make_pair\n#define ARSCD(A,N) REP(i,N){SCD(A[i]);}\n#define ARSCD1(A,N) FORq(i,1,N){SCD(A[i]);}\n#define VSCD(v,N) REP(i,N){int x; SCD(x); v.PB(x);}\n#define VSCLLD(v,N) REP(i,N){long long x; SCLLD(x); v.PB(x);}\n#define PRINTD(n) printf(\"%d\\n\",n)\n#define PRINTLLD(n) printf(\"%lld\\n\",n)\n#define DEBUG printf(\"%s\\n\",\"debug\")\n#define fst first\n#define snd second\n#define SIN(x,S) (S.count(x) != 0)\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector < VI > VVI;\ntypedef vector<long long> VL;\ntypedef long long ll;\ntypedef long long integer;\n////////////////////////////////////////////////////////////////////\nconst ll p = 1000000007;\nll dx[4] = {-7,-1,1,7};\nll N,M,Q;\nstatic ll a[100002] = {};\nstatic bool grid[700003] = {};\nstatic bool visited[700003] = {};\nstatic bool visited2[700003] = {};\n\nvoid dfs0(ll pos){\n    if (visited[pos]) return;\n    visited[pos] = true;\n\n    REP(k,4){\n        ll next = pos + dx[k];\n        if (next >= 7*N) continue;\n        if (next < 0) continue;\n        if ((k==1) and (pos % 7 == 0)) continue;\n        if ((k==2) and (pos % 7 == 6)) continue;\n        if (grid[next]) continue;\n        if (visited[next]) continue;\n        dfs0(next);\n    }\n\n    return;\n}\n\nvoid dfs1(ll pos){\n    if (visited[pos]) return;\n    visited[pos] = true;\n\n    REP(k,4){\n        ll next = pos + dx[k];\n        if (next >= M) continue;\n        if (next < 0) continue;\n        if ((k==1) and (pos % 7 == 0)) continue;\n        if ((k==2) and (pos % 7 == 6)) continue;\n        if (grid[next]) continue;\n        if (visited[next]) continue;\n        dfs1(next);\n    }\n\n    return;\n}\n\nvoid dfs2(ll pos){\n    if (visited2[pos]) return;\n    visited2[pos] = true;\n\n    REP(k,4){\n        ll next = pos + dx[k];\n        if (next >= 2*M) continue;\n        if (next < 0) continue;\n        if ((k==1) and (pos % 7 == 0)) continue;\n        if ((k==2) and (pos % 7 == 6)) continue;\n        if (grid[next]) continue;\n        if (visited2[next]) continue;\n        dfs2(next);\n    }\n\n    return;\n}\n\n\n\nint main(){\n    SCLLD3(N,M,Q);\n    ARSCD(a,Q);\n\n    REP(q,Q){\n        ll ai = a[q];\n        ll k = 0;\n        while(k*M + ai <= 700001){\n            grid[k*M+ai] = true;\n            k++;\n        }\n    }\n\n    if (N <= 100000){ // #1\n        ll count = 0;\n        FORq(i,0,7*N-1){\n            if ((grid[i] == false) and (visited[i] == false)){\n                dfs0(i);\n                count++;\n            }\n        }\n\n        PRINTLLD(count);\n        return 0;\n    }\n\n/*     FORq(i,0,2*M-1){\n        if (i % 7 == 0) printf(\"\\n\");\n        if (grid[i]) printf(\"%d\",1);\n        else printf(\"%d\",0);\n    }\n    printf(\"\\n\"); */\n\n    ll count1 = 0;\n    ll count2 = 0;\n\n    FORq(i,0,M-1){\n        if ((grid[i] == false) and (visited[i] == false)){\n            dfs1(i);\n            count1++;\n        }\n    }\n    //printf(\"count1 = %lld\\n\",count1);\n\n    FORq(i,0,2*M-1){\n        if ((grid[i] == false) and (visited2[i] == false)){\n            dfs2(i);\n            count2++;\n        }\n    }\n\n    //printf(\"count2 = %lld\\n\",count2);\n    ll A,B;\n    A = count2 - count1;\n    B = count1 - A;\n    ll c = 7*N / M;\n    PRINTLLD(A*c + B);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define maxn 700010\nint a[maxn];\nbool col[maxn][7], vis[maxn][7];\ntypedef long long ll;\nstruct que {\n\tint x, y;\n} qu[maxn * 7];\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\nint up[7], dw[7], Fa[14];\nint Find(int x) {return Fa[x] == x ? x : Fa[x] = Find(Fa[x]);}\nint main()\n{\n\tll n;\n\tint m, q; scanf(\"%lld%d%d\", &n, &m, &q);\n\tfor (int i = 1; i <= q; ++i) scanf(\"%d\", &a[i]);\n\tif (m % 7)\n\t{\n\t\tint nq = q;\n\t\tfor (int i = 1; i <= q; ++i)\n\t\t\tfor (int j = 1; j < 7; ++j)\n\t\t\t\ta[++nq] = a[i] + j * m;\n\t\tm *= 7; q = nq;\n\t}\n\tint mm = m / 7, cnt = 0;\n\twhile (mm > n) ;\n\tfor (int i = 1; i <= q; ++i) col[a[i] / 7][a[i] % 7] = 1;\n\n\tfor (int i = 0; i < mm; ++i)\n\t\tfor (int j = 0; j < 7; ++j)\n\t\t\tif (!vis[i][j] && !col[i][j])\n\t\t\t{\n\t\t\t\t++cnt;\n\t\t\t\tint head = 0, tail = 1; qu[1] = (que) {i, j}; vis[i][j] = 1;\n\t\t\t\twhile (head < tail)\n\t\t\t\t{\n\t\t\t\t\tque now = qu[++head];\n\t\t\t\t\tfor (int k = 0, nx, ny; k < 4; ++k)\n\t\t\t\t\t{\n\t\t\t\t\t\tnx = now.x + dx[k]; ny = now.y + dy[k];\n\t\t\t\t\t\tif (nx >= 0 && nx < mm && ny >= 0 && ny < 7 && !vis[nx][ny] && !col[nx][ny])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tqu[++tail] = (que) {nx, ny};\n\t\t\t\t\t\t\tvis[nx][ny] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\tprintf(\"%d\\n\", cnt);\n\tint pcnt = 0, cnt2 = 0;\n\tfor (int i = 0; i < 7; ++i) !col[0][i] ? i == 0 || col[0][i - 1] ? up[i] = ++pcnt : up[i] = pcnt : 0;\n\tfor (int i = 0; i < 7; ++i) !col[mm - 1][i] ? i == 0 || col[mm - 1][i - 1] ? dw[i] = ++pcnt : dw[i] = pcnt : 0;\n\tfor (int i = 1; i <= pcnt; ++i) Fa[i] = i;\n\n//\tfor (int i = 0; i < 7; ++i) printf(\"%d %d\\n\", up[i], dw[i]);\n\tfor (int i = 0; i < 7; ++i)\n\t\tif (up[i] && dw[i] && Find(up[i]) != Find(dw[i]))\n\t\t{\n\t\t\tFa[Find(up[i])] = Find(dw[i]);\n\t\t\t++cnt2;\n\t\t}\n//\tprintf(\"%d\\n\", cnt2);\n//\twhile (n % mm) ;\n\tprintf(\"%lld\\n\", 1ll * cnt * (n / mm) - 1ll * (n / mm - 1) * cnt2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define  inc(i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define  dec(i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define UB upper_bound\n#define LB lower_bound\n#define PQ priority_queue\n\n#define  ALL(v)  v.begin(),  v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define  FOR(it, v) for(auto it =  v.begin(); it !=  v.end(); ++it)\n#define RFOR(it, v) for(auto it = v.rbegin(); it != v.rend(); ++it)\n\ntemplate<typename T> bool   setmin(T & a, T b) { if(b <  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool   setmax(T & a, T b) { if(b >  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmineq(T & a, T b) { if(b <= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmaxeq(T & a, T b) { if(b >= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, m, q, a[100000];\nint b[100000][7];\n\nvoid dfs(int pi, int pj) {\n\tint di[] = { 1, 0, -1,  0 };\n\tint dj[] = { 0, 1,  0, -1 };\n\t\n\tinc(k, 4) {\n\t\tint i = pi + di[k];\n\t\tint j = pj + dj[k];\n\t\tif(inID(i, 0, n) && inID(j, 0, 7) && b[i][j] == 0) {\n\t\t\tb[i][j] = 1;\n\t\t\tdfs(i, j);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> m >> q;\n\tinc(i, q) { cin >> a[i]; }\n\t\n\tif(n > 100000) { return -1; }\n\t\n\tinc(i, q) {\n\t\tint x = a[i];\n\t\tinc(j, 7 * n) {\n\t\t\tb[x / 7][x % 7] = 1;\n\t\t\t\n\t\t\tx += m;\n\t\t\tif(j >= n) { break; }\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tinc(i, n) {\n\tinc(j, 7) {\n\t\tif(b[i][j] == 0) {\n\t\t\tb[i][j] = 1;\n\t\t\tans++;\n\t\t\tdfs(i, j);\n\t\t}\n\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint64_t N;\nint32_t m;\nbool MAP[100001][8];\nbool MOD[100010];\nint32_t a[100010];\n\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) {\n\tarr = v;\n}\ntemplate<typename T, typename ARR>\nvoid fill_all(ARR& arr, const T& v) {\n\tfor (auto& i : arr) { fill_all(i, v); }\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tint32_t Q;\n\tin >> N >> m >> Q;\n\tfor (int32_t i = 0; i < Q; ++i)\n\t{\n\t\tin >> a[i];\n\t\tMOD[a[i]] = true;\n\t}\n\n\tif (N <= 100000)\n\t{\n\t\tfor (int32_t y = 0; y < N; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[N][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < N; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tout << count << endl;\n\t}\n\telse if ((m % 7) == 0)\n\t{\n\t\tfor (int32_t y = 0; y < (m / 7); ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[(m / 7)][x] = true;\n\t\t}\n\t\tint32_t count = 0;\n\t\tstd::stack<std::pair<int32_t, int32_t>> stack;\n\t\tfor (int32_t y = 0; y < (m/7); ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tint32_t count1 = count;\n\n\t\tfill_all(MAP, false);\n\t\tfor (int32_t y = 0; y < (m / 7) * 2; ++y) {\n\t\t\tMAP[y][7] = true;\n\t\t}\n\t\tfor (int32_t x = 0; x < 8; ++x) {\n\t\t\tMAP[(m / 7) * 2][x] = true;\n\t\t}\n\t\tcount = 0;\n\t\tfor (int32_t y = 0; y < (m / 7)*2; ++y)\n\t\t\tfor (int32_t x = 0; x < 7; ++x)\n\t\t\t{\n\t\t\t\tif (MOD[(7 * y + x) % m]) {\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t}\n\t\t\t\tif (!MAP[y][x])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tstack.emplace(y, x);\n\t\t\t\t\tMAP[y][x] = true;\n\t\t\t\t\twhile (!stack.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tauto pos = stack.top(); stack.pop();\n\t\t\t\t\t\tauto y = pos.first;//オーバーライド\n\t\t\t\t\t\tauto x = pos.second;\n\t\t\t\t\t\tint diff[] = { 1,0,-1,0,1 };\n\t\t\t\t\t\tfor (int32_t j = 0; j < 4; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto ny = std::max(0, y + diff[j + 1]);\n\t\t\t\t\t\t\tauto nx = std::max(0, x + diff[j]);\n\t\t\t\t\t\t\tif (!MAP[ny][nx])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (MOD[(7 * ny + nx) % m]) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tstack.emplace(ny, nx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMAP[ny][nx] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tout << (count - count1)*((7*N)/m)+count1 << endl;\n\t}\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int M = 7e5 + 5;\nlong long n;\nint m , q;\nint mark[M];\nint inp;\nstruct data{\n\tint top[7];\n\tint bot[7];\n\tlong long ans;\n\tvoid compress(){\n\t\tmap < int , int > mp;\n\t\tmp.clear();\n\t\tfor(int i = 0 ; i < 7 ; ++i){\n\t\t\tif(top[i] != -1){\n\t\t\t\tmp[top[i]];\n\t\t\t}\n\t\t\tif(bot[i] != -1){\n\t\t\t\tmp[bot[i]];\n\t\t\t}\n\t\t}\n\t\tint val = 0;\n\t\tfor(auto &it : mp){\n\t\t\tit.second = val++;\n\t\t}\n\t\tfor(int i = 0 ; i < 7 ; ++i){\n\t\t\tif(top[i] != -1){\n\t\t\t\ttop[i] = mp[top[i]];\n\t\t\t}\n\t\t\tif(bot[i] != -1){\n\t\t\t\tbot[i] = mp[bot[i]];\n\t\t\t}\n\t\t}\n\t}\n};\nint parent[M];\nint find(int node){\n\tif(parent[node] == node){\n\t\treturn node;\n\t}\n\treturn parent[node] = find(parent[node]);\n}\nbool join(int a , int b){\n\tif(find(a) == find(b)){\n\t\treturn 0;\n\t}\n\tparent[find(a)] = find(b);\n\treturn 1;\n}\ndata getbase(){\n\tfor(int i = 0 ; i < m ; ++i){\n\t\tparent[i] = i;\n\t}\n\tint ans = m - q;\n\tfor(int i = 0 ; i < m ; ++i){\n\t\tif(!mark[i]){\n\t\t\tif(i + 1 < m && !mark[i + 1]){\n\t\t\t\tans -= join(i , i + 1);\n\t\t\t}\n\t\t\tif(i + 7 < m && !mark[i + 7]){\n\t\t\t\tans -= join(i , i + 7);\n\t\t\t}\n\t\t}\n\t}\n\tdata res;\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(mark[i]){\n\t\t\tres.top[i] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.top[i] = find(i);\n\t\t}\n\t}\n\tfor(int i = m - 7 ; i < m ; ++i){\n\t\tif(mark[i]){\n\t\t\tres.bot[i - m + 7] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.bot[i - m + 7] = find(i);\n\t\t}\n\t}\n\tres.ans = ans;\n\tres.compress();\n\treturn res;\n}\ndata base;\ndata combine(data lft , data rgt){\n\tfor(int i = 0 ; i < 30 ; ++i){\n\t\tparent[i] = i;\n\t}\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(rgt.top[i] != -1){\n\t\t\trgt.top[i] += 14;\n\t\t}\n\t\tif(rgt.bot[i] != -1){\n\t\t\trgt.bot[i] += 14;\n\t\t}\n\t}\n\tdata res;\n\tres.ans = lft.ans + rgt.ans;\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(lft.bot[i] != -1 && rgt.top[i] != -1){\n\t\t\tres.ans -= join(lft.bot[i] , rgt.top[i]);\n\t\t}\n\t}\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(lft.top[i] == -1){\n\t\t\tres.top[i] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.top[i] = find(lft.top[i]);\n\t\t}\n\t\tif(rgt.bot[i] == -1){\n\t\t\tres.bot[i] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.bot[i] = find(rgt.bot[i]);\n\t\t}\n\t}\n\tres.compress();\n\treturn res;\n}\ndata solve(long long n){\n\tif(n == 1){\n\t\treturn base;\n\t}\n\tif(n & 1){\n\t\treturn combine(solve(n - 1) , base);\n\t}\n\tdata tmp = solve(n >> 1);\n\treturn combine(tmp , tmp);\n}\nint main(){\n\tscanf(\"%lld %d %d\" , &n , &m , &q);\n\tfor(int i = 1 ; i <= q ; ++i){\n\t\tscanf(\"%d\" , &inp);\n\t\tmark[inp] = 1;\n\t}\n\tif(m % 7){\n\t\tfor(int i = m ; i < 7 * m ; ++i){\n\t\t\tmark[i] = mark[i - m];\n\t\t}\n\t\tm *= 7;\n\t\tq *= 7;\n\t}\n\tbase = getbase();\n\tprintf(\"%lld\\n\" , solve(7 * n / m).ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<map>\n#include<string>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n//#define scanf scanf_s\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\nconst llint mod=1000000007;\n\n\nint main(void){\n\tllint N,M,q,i,j,a,ansa,ansb,ok=0,ans;\n\tqueue<llint> que;\n\tvector<llint> nuru;\n\tset<llint> siro;\n\tscanf(\"%lld %lld %lld\",&N,&M,&q);\n\tfor(i=0;i<q;i++){\n\t\tscanf(\"%lld\",&a);\n\t\tnuru.pub(a);\n\t}\n\t\n\tif(M%7!=0){ \n\t\tfor(i=0;i<q;i++){\n\t\t\tfor(j=1;j<7;j++){\n\t\t\t\tnuru.pub(nuru[i]+M*j);\n\t\t\t}\n\t\t}\n\t\tM*=7;ok=1;\n\t}\n\tsort(nuru.begin(),nuru.end());\n\tfor(i=0;i<M;i++){\n\t\tif(!binary_search(nuru.begin(),nuru.end(),i)){ siro.insert(i); }\n\t}\n\tansa=0;\n\twhile(siro.size()!=0){\n\t\tque.push(*siro.begin());\n\t\twhile(!que.empty()){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tif(siro.find(a)==siro.end()){continue;}\n\t\t\tif(a-7>=0&&siro.find(a-7)!=siro.end()){ que.push(a-7); }\n\t\t\tif(a+7<M&&siro.find(a+7)!=siro.end()){ que.push(a+7); }\n\t\t\tif(a%7!=0&&siro.find(a-1)!=siro.end()){ que.push(a-1); }\n\t\t\tif(a%7!=6&&siro.find(a+1)!=siro.end()){ que.push(a+1); }\n\t\t\tsiro.erase(a);\n\t\t}\n\t\tansa++;\n\t}\n\n\tfor(i=0;i<M;i++){\n\t\t\tif(!binary_search(nuru.begin(),nuru.end(),i)){ siro.insert(i); }\n\t\t\n\t\t\tif(!binary_search(nuru.begin(),nuru.end(),i)){ siro.insert(i+M); }\n\t}\n\tansb=0;\n\twhile(siro.size()!=0){\n\t\tque.push(*siro.begin());\n\t\twhile(!que.empty()){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tif(siro.find(a)==siro.end()){continue;}\n\t\t\tif(a-7>=0&&siro.find(a-7)!=siro.end()){ que.push(a-7); }\n\t\t\tif(a+7<2*M&&siro.find(a+7)!=siro.end()){ que.push(a+7); }\n\t\t\tif(a%7!=0&&siro.find(a-1)!=siro.end()){ que.push(a-1); }\n\t\t\tif(a%7!=6&&siro.find(a+1)!=siro.end()){ que.push(a+1); }\n\t\t\tsiro.erase(a);\n\t\t}\n\t\tansb++;\n\t}\n\tans=(ansb-ansa)*N*7/M+(2*ansa-ansb);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<map>\n#include<string>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n//#define scanf scanf_s\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\nconst llint mod=1000000007;\n\n\nint main(void){\n\tllint N,ans;\n\tint M,q,i,j,a,ansa,ansb,ok=0;\n\tqueue<int> que;\n\tvector<int> nuru;\n\tvector<int> nuran;\n\tset<int> siro;\n\tscanf(\"%lld %d %d\",&N,&M,&q);\n\tfor(i=0;i<q;i++){\n\t\tscanf(\"%d\",&a);\n\t\tnuru.pub(a);\n\t}\n\tsort(nuru.begin(),nuru.end());\n\tif(M%7!=0){ \n\t\tfor(i=0;i<q;i++){\n\t\t\tfor(j=1;j<7;j++){\n\t\t\t\tnuru.pub(nuru[i]+M*j);\n\t\t\t}\n\t\t}\n\t\tM*=7;ok=1;\n\t}j=0;\n\tnuru.pub(big);\n\tfor(i=0;i<M;i++){\n\t\tif(nuru[j]<i){j++;}\n\t\tif(nuru[j]>i){nuran.pub(i);}\n\t}\n\tfor(i=0;i<nuran.size();i++){\n\t\tsiro.insert(nuran[i]);\n\t}\n\tansa=0;\n\twhile(siro.size()!=0){\n\t\tque.push(*siro.begin());\n\t\twhile(!que.empty()){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tif(siro.find(a)==siro.end()){continue;}\n\t\t\tif(a-7>=0&&siro.find(a-7)!=siro.end()){ que.push(a-7); }\n\t\t\tif(a+7<M&&siro.find(a+7)!=siro.end()){ que.push(a+7); }\n\t\t\tif(a%7!=0&&siro.find(a-1)!=siro.end()){ que.push(a-1); }\n\t\t\tif(a%7!=6&&siro.find(a+1)!=siro.end()){ que.push(a+1); }\n\t\t\tsiro.erase(a);\n\t\t}\n\t\tansa++;\n\t}\n\n\tfor(i=0;i<nuran.size();i++){\n\t\tsiro.insert(nuran[i]);siro.insert(nuran[i]+M);\n\t}\n\tansb=0;\n\twhile(siro.size()!=0){\n\t\tque.push(*siro.begin());\n\t\twhile(!que.empty()){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tif(siro.find(a)==siro.end()){continue;}\n\t\t\tif(a-7>=0&&siro.find(a-7)!=siro.end()){ que.push(a-7); }\n\t\t\tif(a+7<2*M&&siro.find(a+7)!=siro.end()){ que.push(a+7); }\n\t\t\tif(a%7!=0&&siro.find(a-1)!=siro.end()){ que.push(a-1); }\n\t\t\tif(a%7!=6&&siro.find(a+1)!=siro.end()){ que.push(a+1); }\n\t\t\tsiro.erase(a);\n\t\t}\n\t\tansb++;\n\t}\n\tans=(ansb-ansa)*N*7/M+(2*ansa-ansb);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nlong long N;\nint M, Q;\nbool X[100000][7];\nbool R[7];\nint A[100001];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> M >> Q;\n  rep(i, Q) {\n    int a;\n    cin >> a;\n    rep(k, 7) {\n      int x = a + k*M;\n      X[x/7][x%7] = true;\n    }\n  }\n  rep(_x, M+1) {\n    int x = (_x)%M;\n    rep(i, 7) R[i] = false;\n    if (_x > 0) {\n      rep(i, 7) {\n        if (!X[x][i] && !X[(x+M-1)%M][i]) R[i] = true;\n      }\n      for (int i=1; i<7; i++) {\n        if (X[x][i]) continue;\n        if (R[i-1]) R[i] = true;\n      }\n      for (int i=5; i>=0; i--) {\n        if (X[x][i]) continue;\n        if (R[i+1]) R[i] = true;\n      }\n    }\n    int c = 0;\n    rep(i, 7) {\n      if (X[x][i] || R[i]) continue;\n      c++;\n      for (int j=i; j<7; j++) {\n        if (X[x][j] || R[j]) break;\n        R[j] = true;\n      }\n    }\n    A[_x] = c;\n  }\n  long long sum = 0;\n  for (int i=1; i<=M; i++) sum += A[i];\n  sum *= (N/M);\n  if (N%M == 0) {\n    sum += A[0] - A[M];\n  }\n  else {\n    rep(i, N%M) {\n      sum += A[i];\n    }\n  }\n  cout<<sum<<\"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n// #define DEBUG\n#ifdef DEBUG\n#define dump(...) cerr<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<make_tuple(__VA_ARGS__)<<\"\\n\";\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '{'; for(int i = 0; i < (int) v.size(); i++) o << v[i] << (i != (int)v.size()-1 ? \", \" : \"\"); o << \"}\";  return o; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\n#else\n#define dump(...)\n#endif\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  ll n, m, q; cin >> n >> m >> q;\n  ll h = (m + 6) / 7; // one shared block\n  ll period = h * 7; // height of period\n  ll full = n / period;\n  ll rest = n - full * period;\n  vector< vector<int> > f(period, vector<int>(7) );\n  auto used = f;\n  auto used2 = f;\n  auto used3 = f;\n\n  while(q--) {\n    ll a; cin >> a;\n    for(; a < period * 7; a += m) {\n      ll y = a / 7, x = a % 7;\n      f[y][x] = 1;\n    }\n  }\n  dump(f);\n\n  ll block = 0;\n  for(ll y = 0; y < period; y++)\n    for(ll x = 0; x < 7; x++) {\n      if(f[y][x]) continue;\n      if(used[y][x]) continue;\n      used[y][x] = 1;\n      queue<pair<ll, ll>> q;\n      q.emplace(y, x);\n      block++;\n      while(q.size()) {\n        ll yy = q.front().first, xx = q.front().second;\n        q.pop();\n        for(int d = 0; d < 4; d++) {\n          ll ny = yy + dy[d];\n          ll nx = xx + dx[d];\n          if(ny < 0 || period <= ny || nx < 0 || 7 <= nx) continue;\n          if(f[ny][nx]) continue;\n          if(used[ny][nx]) continue;\n          used[ny][nx] = 1;\n          q.emplace(ny, nx);\n        }\n      }\n    }\n\n  ll black = 0;\n  {\n    ll y = period - 1;\n    for(ll x = 0; x < 7; x++) {\n      if(f[y][x]) continue;\n      if(used2[y][x]) continue;\n      if(f[0][x]) continue;\n      used2[y][x] = 1;\n      queue<pair<ll, ll>> q;\n      q.emplace(y, x);\n      black++;\n      while(q.size()) {\n        ll yy = q.front().first, xx = q.front().second;\n        q.pop();\n        for(int d = 0; d < 4; d++) {\n          ll ny = yy + dy[d];\n          ll nx = xx + dx[d];\n          if(ny < 0 || period <= ny || nx < 0 || 7 <= nx) continue;\n          if(f[ny][nx]) continue;\n          if(used2[ny][nx]) continue;\n          used2[ny][nx] = 1;\n          q.emplace(ny, nx);\n        }\n      }\n    }\n  }\n\n  ll last = 0;\n  for(ll y = 0; y < rest; y++)\n    for(ll x = 0; x < 7; x++) {\n      if(f[y][x]) continue;\n      if(used3[y][x]) continue;\n      used3[y][x] = 1;\n      queue<pair<ll, ll>> q;\n      q.emplace(y, x);\n      last++;\n      while(q.size()) {\n        ll yy = q.front().first, xx = q.front().second;\n        q.pop();\n        for(int d = 0; d < 4; d++) {\n          ll ny = yy + dy[d];\n          ll nx = xx + dx[d];\n          if(ny < 0 || rest <= ny || nx < 0 || 7 <= nx) continue;\n          if(f[ny][nx]) continue;\n          if(used3[ny][nx]) continue;\n          used3[ny][nx] = 1;\n          q.emplace(ny, nx);\n        }\n      }\n    }\n  dump(full);\n  dump(block, black, last);\n\n  ll ans = 0;\n  ans += full * (block - black);\n  if(rest) {\n    ans += last;\n  } else {\n    ans += black;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nlong long int n;\nint m;\nint q;\n\n#define MAX 2000002\nint room[MAX][7];\nint id[MAX][7];\n\nbool flag[MAX];\n\nstruct UF{\n\tvector<int> belong;\n\tvector<int> size;\n\tvoid resize(int n){\n\t\tbelong.assign(n + 1, -1);\n\t\tsize.assign(n + 1, 1);\n\t}\n\tinline int root(int b){\n\t\tif (belong[b] == -1){\n\t\t\treturn b;\n\t\t}\n\t\tbelong[b] = root(belong[b]);\n\t\treturn belong[b];\n\t}\n\tvoid merge(int a, int b){\n\t\ta = root(a);\n\t\tb = root(b);\n\t\tif (a == b)return;\n\t\tbelong[a] = b;\n\t\tsize[b] += size[a];\n\t}\n};\n\nUF uf;\nint dx[] = { 0, 0, 1, -1 };\nint dy[] = { 1, -1, 0, 0 };\n\nvector<long long int> v;\n\nvoid solve(long long int N){\n\tlong long int sum = 0;\n\tif (n <= v.size()){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tsum += v[i];\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\t\treturn;\n\t}\n\tlong long int W = 0;\n\tfor (int i = 1; i < v.size(); i++){\n\t\tW += v[i];\n\t}\n\tn--;\n\tW *= (n / N);\n\tn %= N;\n\tfor (int i = 1; i <= n; i++){\n\t\tW += v[i];\n\t}\n\tW += v[0];\n\tprintf(\"%lld\\n\", W);\n}\nint main(){\n\tscanf(\"%lld\", &n);\n\tcin >>  m >> q;\n\tfor (int i = 0; i < q; i++){\n\t\tint a;\n\t\tscanf(\"%d\", &a);\n\t\tflag[a] = true;\n\t}\n\tint num = -1;\n\tint nnn = -1;\n\tint N;\n\tbool exi = false;\n\tfor (int i = 0; i < MAX; i++){\n\t\tfor (int j = 0; j < 7; j++){\n\t\t\tnum++;\n\t\t\tnnn++;\n\t\t\tid[i][j] = nnn;\n\t\t\tnum %= m;\n\t\t\tif (i && (j == 0 && num == 0)){\n\t\t\t\tN = i;\n\t\t\t\tfor (int j = 0; j < 7; j++){\n\t\t\t\t\troom[i][j] = room[0][j];\n\t\t\t\t\tid[i][j] = nnn;\n\t\t\t\t\tnnn++;\n\t\t\t\t}\n\t\t\t\texi = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (flag[num]){\n\t\t\t\troom[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tif (exi)break;\n\t}\n\tif (0){\n\t\n\t}\n\telse{\n\t\tuf.resize(7 * N);\n\t\tfor (int i = 0; i <= N; i++){\n\t\t\tint inc = 0;\n\t\t\tfor (int j = 0; j < 7; j++){\n\t\t\t\tif (room[i][j] == true)continue;\n\t\t\t\tbool ok = false;\n\t\t\t\tfor (int k = 0; k < 4; k++){\n\t\t\t\t\tint ii = i + dx[k];\n\t\t\t\t\tif (ii > i)continue;\n\t\t\t\t\tint jj = j + dy[k];\n\t\t\t\t\tif (jj > j)continue;\n\t\t\t\t\tif (ii >= 0 && jj >= 0 && ii <= N&&jj < 7){\n\t\t\t\t\t\tif (room[i][j] == false && room[ii][jj] == false){\n\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t\tuf.merge(id[i][j], id[ii][jj]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok == false){\n\t\t\t\t\tinc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tv.push_back(inc);\n\t\t}\n\t\tsolve(N);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <bitset>\n\nusing namespace std;\ntypedef pair<int, int> Pi;\ntypedef long long ll;\n#define pii Pi\n#define pll PL\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) ((int)(x).size())\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(), (x).end()\ntypedef tuple<int, int, int> t3;\ntypedef tuple<int, int, int, int> t4;\ntypedef pair<ll, ll> PL;\ntypedef long double ldouble;\n\nint A[100010];\nint color[1400070];\nint ca[100010];\nint p[1400070];\nint Find(int x){return p[x] == x ? x : p[x] = Find(p[x]); }\n\nvoid solve(){\n\tll n;int m, q; cin >> n >> m >>q;\n\tfor(int i=1;i<=q;i++)scanf(\"%d\", A+i), ca[A[i]] = 1;\n\tint t = (m % 7 == 0 ? m / 7 : m);\n\trep(i, 7*t)p[i] = i;\n\trep(i, t)rep(j, 7){\n\t\tint v = i * 7 + j;\n\t\tif(ca[v % m])color[v] = 1;\n\t\tif(i && color[v] == 0 && color[v-7] == 0)p[Find(v)] = Find(v-7);\n\t\tif(j && color[v] == 0 && color[v-1] == 0)p[Find(v)] = Find(v-1);\n\t}\n\tll ans = 0;\n\trep(i, 7*t)if(color[i] == 0 && p[i] == i)ans++;\n\tif(t == n){\n\t\tprintf(\"%lld\\n\", ans);\n\t\treturn;\n\t}\n\tll ans2 = 0;\n\tt = t * 2;\n\trep(i, 7*t)p[i] = i;\n\trep(i, t)rep(j, 7){\n\t\tint v = i * 7 + j;\n\t\tif(ca[v % m])color[v] = 1;\n\t\tif(i && color[v] == 0 && color[v-7] == 0)p[Find(v)] = Find(v-7);\n\t\tif(j && color[v] == 0 && color[v-1] == 0)p[Find(v)] = Find(v-1);\n\t}\n\trep(i, 7*t)if(color[i] == 0 && p[i] == i)ans2++;\n\tans2 -= ans;\n\tprintf(\"%lld\\n\", ans + ans2 * (n / (t / 2) - 1));\n}\n\nint main(){\n\tint Tc = 1; //scanf(\"%d\\n\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\t//printf(\"Case #%d: \", tc);\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int M = 7e5 + 5;\nlong long n;\nint m , q;\nint mark[M];\nint inp;\nstruct data{\n\tint top[7];\n\tint bot[7];\n\tlong long ans;\n\tvoid compress(){\n\t\tmap < int , int > mp;\n\t\tmp.clear();\n\t\tfor(int i = 0 ; i < 7 ; ++i){\n\t\t\tif(top[i] != -1){\n\t\t\t\tmp[top[i]];\n\t\t\t}\n\t\t\tif(bot[i] != -1){\n\t\t\t\tmp[bot[i]];\n\t\t\t}\n\t\t}\n\t\tint val = 0;\n\t\tfor(auto &it : mp){\n\t\t\tit.second = val++;\n\t\t}\n\t\tfor(int i = 0 ; i < 7 ; ++i){\n\t\t\tif(top[i] != -1){\n\t\t\t\ttop[i] = mp[top[i]];\n\t\t\t}\n\t\t\tif(bot[i] != -1){\n\t\t\t\tbot[i] = mp[bot[i]];\n\t\t\t}\n\t\t}\n\t}\n};\nint parent[M];\nint find(int node){\n\tif(parent[node] == node){\n\t\treturn node;\n\t}\n\treturn parent[node] = find(parent[node]);\n}\nbool join(int a , int b){\n\tif(find(a) == find(b)){\n\t\treturn 0;\n\t}\n\tparent[find(a)] = find(b);\n\treturn 1;\n}\ndata getbase(){\n\tfor(int i = 0 ; i < m ; ++i){\n\t\tparent[i] = i;\n\t}\n\tint ans = m - q;\n\tfor(int i = 0 ; i < m ; ++i){\n\t\tif(!mark[i]){\n\t\t\tif(i + 1 < m && !mark[i + 1]){\n\t\t\t\tans -= join(i , i + 1);\n\t\t\t}\n\t\t\tif(i + 7 < m && !mark[i + 7]){\n\t\t\t\tans -= join(i , i + 7);\n\t\t\t}\n\t\t}\n\t}\n\tdata res;\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(mark[i]){\n\t\t\tres.top[i] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.top[i] = find(i);\n\t\t}\n\t}\n\tfor(int i = m - 7 ; i < m ; ++i){\n\t\tif(mark[i]){\n\t\t\tres.bot[i - m + 7] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.bot[i - m + 7] = find(i);\n\t\t}\n\t}\n\tres.ans = ans;\n\tres.compress();\n\treturn res;\n}\ndata base;\ndata combine(data lft , data rgt){\n\tfor(int i = 0 ; i < 30 ; ++i){\n\t\tparent[i] = i;\n\t}\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(rgt.top[i] != -1){\n\t\t\trgt.top[i] += 14;\n\t\t}\n\t\tif(rgt.bot[i] != -1){\n\t\t\trgt.bot[i] += 14;\n\t\t}\n\t}\n\tdata res;\n\tres.ans = lft.ans + rgt.ans;\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(lft.bot[i] != -1 && rgt.top[i] != -1){\n\t\t\tres.ans -= join(lft.bot[i] , rgt.top[i]);\n\t\t}\n\t}\n\tfor(int i = 0 ; i < 7 ; ++i){\n\t\tif(lft.top[i] == -1){\n\t\t\tres.top[i] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.top[i] = find(lft.top[i]);\n\t\t}\n\t\tif(rgt.bot[i] == -1){\n\t\t\tres.bot[i] = -1;\n\t\t}\n\t\telse{\n\t\t\tres.bot[i] = find(rgt.bot[i]);\n\t\t}\n\t}\n\tres.compress();\n\treturn res;\n}\ndata solve(long long n){\n\tif(n == 1){\n\t\treturn base;\n\t}\n\tif(n & 1){\n\t\treturn combine(solve(n - 1) , base);\n\t}\n\tdata tmp = solve(n >> 1);\n\treturn combine(tmp , tmp);\n}\nint main(){\n\tscanf(\"%lld %d %d\" , &n , &m , &q);\n\tfor(int i = 1 ; i <= q ; ++i){\n\t\tscanf(\"%d\" , &inp);\n\t\tmark[inp] = 1;\n\t}\n\tif(m % 7){\n\t\tfor(int i = m ; i < n * 7 ; ++i){\n\t\t\tmark[i] = mark[i - m];\n\t\t}\n\t\tm = n * 7;\n\t\tq = n * 7;\n\t}\n\tbase = getbase();\n\tprintf(\"%lld\\n\" , solve(7 * n / m).ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <functional>\n#include <chrono>\n#include <time.h>\nusing namespace std;\n\nint main()\n{\n\tlong long n, m, q; cin >> n >> m >> q;\n\tvector<int>a(q);\n\tfor (int i = 0; i < q; i++)cin >> a[i];\n\n\tcout << 7 - a.size() << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 666666\nll n;\nint m,q,a[SZ];\nbool cov[SZ];\nint main()\n{\n\tscanf(\"%lld%d%d\",&n,&m,&q);\n\tfor(int i=1;i<=q;i++)\n\tscanf(\"%d\",a+i),cov[a[i]]=1;\n\tif(m==1)\n\t{\n\t\tif(q) puts(\"0\");\n\t\telse puts(\"1\");\n\t\treturn 0;\n\t}\n\tif(m==7)\n\t{\n\t\tint cc=0; \n\t\tfor(int i=0;i<7;i++)\n\t\t\tif((!cov[i]&&cov[i+1])||(i==6&&!cov[i])) ++cc;\n\t\tprintf(\"%d\\n\",cc);\n\t\treturn 0;\n\t}\n\tthrow \"QWQ\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n \nusing namespace std;\n \ntypedef long long ll;\n \n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(c) (c).begin(), (c).end()\n#define rep(i,a,b) for(ll i=(a);i<(b);++i)\n#define per(i,a,b) for(ll i=(b-1);i>=(a);--i)\n#define clr(a, b) memset((a), (b) ,sizeof(a))\n#define ctos(c) string(1,c)\n#define print(x) cout<<#x<<\" = \"<<x<<endl;\n \n#define MOD 1000000007\n\nvector<int> uf, usz;\nint nc;\n\nvoid init(int n){\n  vector<int> uf_(n);\n  vector<int> usz_(n, 1);\n  uf = uf_;\n  usz = usz_;\n  nc = n;\n\n  for(int i = 0; i < uf.size(); i++){\n    uf[i] = i;\n  }\n}\n\nint find(int a){\n  return (uf[a] == a) ? a : uf[a] = find(uf[a]);\n}\n\nvoid union_(int a, int b){\n  a = find(a);\n  b = find(b);\n\n  if(a != b){\n    if(usz[a] >= usz[b]){\n      swap(a, b);\n    }\n    uf[a] = b;\n    usz[b] += usz[a];\n    nc--;\n  }\n}\n\nint check(int a, int b){\n  return (find(a) == find(b)) ? 1 : 0;\n}\n\nint get_size(int a){\n  return usz[find(a)];\n}\n\nll d[100100];\n\nint main(){\n\tll n,m,q;\n\tcin>>n>>m>>q;\n\tinit(m+1);\n\tclr(d,0);\n\tvector<ll> v;\n\trep(i,0,q){\n\t\tll a;\n\t\tcin>>a;\n\t\td[a] = 1;\n\t}\n\trep(i,0,m){\n\t\tif(d[i]==1){\n\t\t\tunion_(i,m);\n\t\t\tcontinue;\n\t\t}\n\t\tvector<ll> v1;\n\t\tif(i-7>=0)v1.pb(i-7);\n\t\tif(i%7!=0)v1.pb(i-1);\n\t\tif(i%7!=6)v1.pb(i+1);\n\t\tif(i+7<m)v1.pb(i+7);\n\t\trep(j,0,v1.sz){\n\t\t\tif(d[v1[j]]==1)continue;\n\t\t\tunion_(i,v1[j]);\n\t\t}\n\t}\n\tll ans1 = nc-1;\n\tset<ll> se1;\n\tset<pair<ll,ll> > se2; \n\trep(i,0,7){\n\t\tif(d[i]==0&&d[m-7+i]==0){\n\t\t\tll a1 = find(i);\n\t\t\tll b1 = find(m-7+i);\n\t\t\tif(a1==b1)se1.insert(a1);\n\t\t\telse{\n\t\t\t\tse2.insert(mp(max(a1,b1),min(a1,b1)));\n\t\t\t}\n\t\t}\n\t}\n\tvector<ll> v1(all(se1));\n\tvector<pair<ll,ll> > v2(all(se2));\n\tll ans2 = v1.sz;\n\tll ans3 = v2.sz;\n\tll ans4 = 0;\n\trep(i,0,v2.sz){\n\t\tint flag = 1;\n\t\trep(j,0,v1.sz){\n\t\t\tif(v1[j]==v2[i].fi||v1[j]==v2[i].se){\n\t\t\t\tflag = 0;\n\t\t\t}\n\t\t}\n\t\tif(flag == 0){\n\t\t\tans3--;\n\t\t\tans4++;\n\t\t}\n\t}\n\tll a = 7*n/m;\n\tans1 -= (ans2+ans4+ans3*2);\n\tcout << ans1*a+ans2+ans3*(a+1)+ans4 << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<map>\n#include<string>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n//#define scanf scanf_s\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\nconst llint mod=1000000007;\n\n\nint main(void){\n\tllint N,M,q,i,j,a,ansa,ansb,ok=0,ans;\n\tqueue<llint> que;\n\tvector<llint> nuru;\n\tset<llint> siro;\n\tscanf(\"%lld %lld %lld\",&N,&M,&q);\n\tfor(i=0;i<q;i++){\n\t\tscanf(\"%lld\",&a);\n\t\tnuru.pub(a);\n\t}\n\tsort(nuru.begin(),nuru.end());\n\tif(M%7!=0){ M*=7;ok=1; }\n\tfor(i=0;i<M;i++){\n\t\tfor(j=0;j<1+ok*6;j++){\n\t\t\tif(!binary_search(nuru.begin(),nuru.end(),i)){ siro.insert(i+j*M/7); }\n\t\t}\n\t}\n\tansa=0;\n\twhile(siro.size()!=0){\n\t\tque.push(*siro.begin());\n\t\twhile(!que.empty()){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tif(a-7>=0&&siro.find(a-7)!=siro.end()){ que.push(a-7); }\n\t\t\tif(a+7<M&&siro.find(a+7)!=siro.end()){ que.push(a+7); }\n\t\t\tif(a%7!=0&&siro.find(a-1)!=siro.end()){ que.push(a-1); }\n\t\t\tif(a%7!=6&&siro.find(a+1)!=siro.end()){ que.push(a+1); }\n\t\t\tsiro.erase(a);\n\t\t}\n\t\tansa++;\n\t}\n\n\tfor(i=0;i<M;i++){\n\t\tfor(j=0;j<1+ok*6;j++){\n\t\t\tif(!binary_search(nuru.begin(),nuru.end(),i)){ siro.insert(i+j*M/7); }\n\t\t}\n\t\tfor(j=0;j<1+ok*6;j++){\n\t\t\tif(!binary_search(nuru.begin(),nuru.end(),i)){ siro.insert(i+j*M/7+M); }\n\t\t}\n\t}\n\tansb=0;\n\twhile(siro.size()!=0){\n\t\tque.push(*siro.begin());\n\t\twhile(!que.empty()){\n\t\t\ta=que.front();\n\t\t\tque.pop();\n\t\t\tif(a-7>=0&&siro.find(a-7)!=siro.end()){ que.push(a-7); }\n\t\t\tif(a+7<2*M&&siro.find(a+7)!=siro.end()){ que.push(a+7); }\n\t\t\tif(a%7!=0&&siro.find(a-1)!=siro.end()){ que.push(a-1); }\n\t\t\tif(a%7!=6&&siro.find(a+1)!=siro.end()){ que.push(a+1); }\n\t\t\tsiro.erase(a);\n\t\t}\n\t\tansb++;\n\t}\n\tans=(ansb-ansa)*N*7/M+(2*ansa-ansb);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nlong n;int m,q,a[1<<17];\nbool f[7][1<<17];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid bfs(int x,int y,long _n)\n{\n\tqueue<pair<int,int> >P;\n\tf[x][y]=true;\n\tP.push(make_pair(x,y));\n\twhile(!P.empty())\n\t{\n\t\tpair<int,int>p=P.front();P.pop();\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint tx=p.first+dx[r],ty=p.second+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=7||ty>=_n||f[tx][ty])continue;\n\t\t\tf[tx][ty]=true;\n\t\t\tP.push(make_pair(tx,ty));\n\t\t}\n\t}\n}\nmain()\n{\n\tcin>>n>>m>>q;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tif(n<=100000)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong ans=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t\tbfs(i,j,n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\telse if(m%7==0)\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*2;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,m/7*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m/7*3;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,m/7*3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=count2-count1;\n\t\tlong syokou=count1-kousa*2;\n\t\tcout<<syokou+kousa*(n/(m/7))<<endl;\n\t}\n\telse\n\t{\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count1=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount1++;\n\t\t\t\t\tbfs(i,j,m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<2*m;j++)\n\t\t\t{\n\t\t\t\tf[i][j]=false;\n\t\t\t\tint b=(j*7+i)%m;\n\t\t\t\tif(upper_bound(a,a+q,b)!=lower_bound(a,a+q,b))f[i][j]=true;\n\t\t\t}\n\t\t}\n\t\tlong count2=0;\n\t\tfor(int i=0;i<7;i++)\n\t\t{\n\t\t\tfor(int j=0;j<2*m;j++)\n\t\t\t{\n\t\t\t\tif(!f[i][j])\n\t\t\t\t{\n\t\t\t\t\tcount2++;\n\t\t\t\t\tbfs(i,j,2*m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong kousa=(count2-count1)/7;\n\t\tlong syokou=count1-kousa*7;\n\t\tcout<<syokou+kousa*n<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// Union-Find 木 (Verified: AtCoder Typical Contest 001 B)\nstruct UnionFind {\nprivate:\n    const int n;\n    int __size;\n    vector<int> uf;\npublic:\n    // 初期化 UnionFind uni(n) のように宣言すれば良い\n    UnionFind(int _n) : n(_n), __size(_n), uf(_n, -1) {}\n    // find (木の根を求める)\n    int find(int x) {return (uf[x] < 0) ? x : uf[x] = find(uf[x]);}\n    // x と y が同じ集合に属するかどうか\n    bool same(int x, int y) {return find(x) == find(y);}\n    // x が属する集合の要素数\n    int size(int x) {return -uf[find(x)];}\n    // 集合はいくつあるか\n    int size()      {return __size;}\n    // x と y の属する集合を併合\n    void unite(int x, int y) {\n        x = find(x); y = find(y);\n        if(x == y) return;\n        __size--;\n        if(uf[y] < uf[x]) swap(x, y);\n        uf[x] += uf[y]; uf[y] = x;\n    }\n};\n\nconst int W = 7;\nint board[100010][W];\nsigned main() {\n    int N, M, Q; cin >> N >> M >> Q;\n\n    for(int i=0; i<Q; i++) {\n        int A; cin >> A;\n        for(int k=A; k<N*W; k+=M) {\n            int r = k / W, c = k % W;\n            board[r][c] = 1;\n        }\n    }\n\n    int ans = 0;\n    UnionFind uf(N*W);\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<W; j++) {\n            for(int k=0; k<4; k++) {\n                int ni = i + dx[k], nj = j + dy[k];\n                if(ni < 0 or ni >= N or nj < 0 or nj >= W) continue;\n                if(board[i][j] == board[ni][nj]) {\n                    int u = i  * W + j ;\n                    int v = ni * W + nj;\n                    uf.unite(u, v);\n                }\n            }\n        }\n    }\n\n    set<int> white;\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<W; j++) {\n            if(board[i][j] == 0) white.insert(uf.find(i * W + j));\n        }\n    }\n    ans += white.size();\n    // fprintf(stderr, \"temp ans = %lld\\n\", ans);\n\n    int add = 0;\n    UnionFind uf2((N+1)*W);\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<W; j++) {\n            for(int k=0; k<4; k++) {\n                int ni = i + dx[k], nj = j + dy[k];\n                int mi = ni, mj = nj;\n                if(ni < 0) ni = N - 1, mi = N;\n                if(ni >= N or nj < 0 or nj >= W) continue;\n                if(board[i][j] == board[ni][nj]) {\n                    int u = i  * W + j;\n                    int v = mi * W + mj;\n                    uf2.unite(u, v);\n                }\n            }\n        }\n    }\n    add += uf2.size();\n\n    set<int> white2, ng;\n    for(int j=0; j<W; j++) {\n        ng.insert(uf2.find(N*W + j));\n        white2.insert(uf2.find(N*W + j));\n    }\n\n    int mod = N % M;\n    for(int i=0; i<N; i++) {\n        if(i == mod) ans += white2.size() - ng.size();\n        for(int j=0; j<W; j++) {\n            if(board[i][j] == 0) white2.insert(uf2.find(i * W + j));\n        }\n    }\n    \n    add += white2.size();\n    add -= ng.size();\n\n    ans += add * max(0LL, (N / M - 1));\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define MOD 1000000007\n#define INF 11234567890\n#define in std::cin\n#define out std::cout\n#define rep(i,N) for(LL i=0;i<N;++i)\ntypedef long long int LL;\n\nLL n, m, q, a[112345];\nbool field[15000][7];\nLL memo[15000][7];\nLL ans;\n\nint sx[] = { 0,1 }, sy[] = { 1,0 };\n\nLL f(LL x, LL y)\n{\n\tif (memo[x][y] != -1) { return memo[x][y] = 0; }\n\tif (field[x][y] == true) { return memo[x][y] = 0; }\n\tLL res = 0;\n\tLL cou = 0;\n\trep(i, 2)\n\t{\n\t\tif (0 <= x + sx[i] && x + sx[i] <= (a[q - 1] / 7)\n\t\t\t&& 0 <= y + sy[i] && y + sy[i] < 7)\n\t\t{\n\t\t\tif (field[x + sx[i]][y + sy[i]] == false)\n\t\t\t{\n\t\t\t\tres += f(x + sx[i], y + sy[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t++cou;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t++cou;\n\t\t}\n\t}\n\tif (cou == 2) { return memo[x][y] = 1; }\n\treturn memo[x][y] = res;\n}\nint main()\n{\n\tin >> n >> m >> q;\n\trep(i, q)\n\t{\n\t\tin >> a[i];\n\t\tif (i > 0)\n\t\t{\n\t\t\tif (a[i] - a[i - 1] != 1)\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (m % 7 != 0) { return 0; }\n\n\tmemset(field, false, sizeof(field));\n\tmemset(memo, -1, sizeof(memo));\n\trep(i, q) { field[a[i] / 7][a[i] % 7] = true; }\n\trep(x, (a[q - 1] / 7) + 1)\n\t{\n\t\trep(y, 7)\n\t\t{\n\t\t\tans += f(x, y);\n\t\t}\n\t}\n\tbool flag = false;\n\trep(x, 7)\n\t{\n\t\tif (flag == false)\n\t\t{\n\t\t\tif (field[0][x] == false && field[a[q - 1] / 7][x] == false)\n\t\t\t{\n\t\t\t\t--ans;\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (field[0][x] == true || field[a[q - 1] / 7][x] == true)\n\t\t\t{\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tout << ans*(n / (m / 7)) << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 666666\nll n;\nint m,q,a[SZ];\nbool cov[SZ];\nint ff[SZ];\nint gf(int x) {return (ff[x]==-1)?x:ff[x]=gf(ff[x]);}\nvoid uni(int a,int b)\n{int ga=gf(a),gb=gf(b);if(ga^gb)ff[ga]=gb;}\nint main()\n{\n\tmemset(ff,-1,sizeof(ff));\n\tscanf(\"%lld%d%d\",&n,&m,&q);\n\tfor(int i=1;i<=q;i++)\n\tscanf(\"%d\",a+i),cov[a[i]]=1;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif(cov[i])continue;\n\t\tif(i+7<m&&!cov[i+7]) uni(i,i+7);\n\t\tif(i%7!=6&&i+1<m&&!cov[i+1]) uni(i,i+1);\n\t}\n\tint ans=0;\n\tfor(int i=0;i<m;i++)\n\t\tif(!cov[i]) ans+=gf(i)==i;\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\nlong long n, m, q, a[200000];\nbool is_black[200000][7];\nbool visited_1[200000][7];\nbool visited_2[200000][7];\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\n\nvoid visit_1(int r, int c){\n    visited_1[r][c] = true;\n    for(int i = 0; i < 4; i++){\n        int r_ = r + dx[i];\n        int c_ = c + dy[i];\n        if(r_ >= 0 && r_ < m/7 && c_ >= 0 && c_ < 7 && (!is_black[r_][c_]) && (!visited_1[r_][c_])){\n            visit_1(r_, c_);\n        }\n    }\n}\n\nvoid visit_2(int r, int c){\n    visited_2[r][c] = true;\n    for(int i = 0; i < 4; i++){\n        int r_ = r + dx[i];\n        int c_ = c + dy[i];\n        if(r_ >= 0 && r_ < 2*m/7 && c_ >= 0 && c_ < 7 && (!is_black[r_][c_]) && (!visited_2[r_][c_])){\n            visit_2(r_, c_);\n        }\n    }\n}\n\nint main(){\n    cin >> n >> m >> q;\n    for(int i = 0; i < q; i++){\n        cin >> a[i];\n        is_black[a[i] / 7][a[i] % 7] = true;\n        is_black[(a[i]+m)/7][a[i]%7] = true;\n    }\n    long long cnt_1 = 0;\n    for(int i = 0; i < m/7; i++){\n        for(int j = 0; j < 7; j++){\n            if(!visited_1[i][j] && !is_black[i][j]){\n                visit_1(i, j);\n                cnt_1++;\n            }\n        }\n    }\n\n    long long cnt_2 = 0;\n    for(int i = 0; i < 2*m/7; i++){\n        for(int j = 0; j < 7; j++){\n            if(!visited_2[i][j] && !is_black[i][j]){\n                visit_2(i, j);\n                cnt_2++;\n            }\n        }\n    }\n\n    cout << (cnt_2 - cnt_1) * (7 * n / m) + (2*cnt_1 - cnt_2) << endl;\n    //cout << cnt_1 << endl;\n    //cout << cnt_2 << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nbool cal[7][1000000];\nint n,m,q;\n\nvoid block(int i,int j);\nint main(){\n\tint qt;\n\tint ans;\n\tint i,j,k;\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\t\n\tfor(k=0;k<q;k++){\n\t\tscanf(\"%d\",&qt);\n\t\tfor(i=qt;i<n*7;i+=m){\n\t\t\tcal[i%7][i/7] = true;\n\t\t}\n\t}\n\t\n\tans = 0;\n\tfor(i=0;i<7*n;i++){\n\t\tif(!cal[i%7][i/7]){\n\t\t\tans++;\n\t\t\tblock(i%7,i/7);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\t\nvoid block(int i,int j){\n\tif(cal[i][j]) return;\n\tcal[i][j] = true;\n\tif(i!=6){\n\t\tblock(i+1,j);\n\t}\n\tif(j!=n-1){\n\t\tblock(i,j+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n;;;;;;;;;;;;::;,.,xOOOOOOOkdoc;,,;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,,'''',,,,,,,,,'',,:cloo:'.\n;;;;;;;;;;:ccccc,'lOOOOOOOOOOOxoc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,,''''''''''',;cloxkOOOOl..\n;;;;;;;;;:cccccc:,;xOOOOOOOOOOOOOxoc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,''''''';:loxkOOOOOOOOk:..\n;;;;;;;;;:cccccc::,ck0OOOOO0OO00OOOOxl:;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,'',;codkO0OOOOOOOOOOOo'..\n;;;;;;;;:cccccc:::;,ck0OOOOOOOOOOOOO0Okoc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:cloxOOOOOOOOOOOOOOOO0x;..'\n;;;;;;;:ccccccc::;;,,:xOOOOO0OOOOOOOOOOOkdc;,;;;;;;;::::ccccccccc:::::cldkOOOOOOOOOOOOOOOOOOO0k:..''\n;;;;;;;:cccccc::;;,,,';dO0OOOOO0OOOOOOOOOOkdodddxxxxkkkOOOOOOOOOOkkkxkkO0OOOOOOOOOOOOOOOOOOO0kc'''''\n;;;;;;;::::::::;;,,,''',cxOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOxc,,,,''\n;;;;;,;;;;;;;;;,,,,'''''',lkOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOko:;;;;,,,\n;;;;,,,,,,,,,,,,''''''''''.,lkOOkxkOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkoc:c:::;;,,\n;;;;'''''''''''''''''''''''..;lodkO0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkxk0Okxocccccc:::;,,\n;;;,'............'''''''''''..;xOOOOOOOOOOOO0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkxdol::::cccc:::;;,,\n;;,'..............''''''''''';dOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOko;;::::::::;;;;,,\n;;'................'''''','',dOOOO0OOOxdoccxOO0OOOOOOOOOOOOOOOOOOOOxdoclxOOOOOOOOOOOo;;;;;;;;;;;;,,'\n;,'................'''''',,,lOOOOOOOOoo00c.;xOOOOOOOOOOOOOOOOOOOOOll0O:.:k0OOOOOOOOOOo,,;;;;;;,,,,''\n,'..................''',,,,ckOOO0OO0Ol,::,.,d0OOOOOOOOOOOOOOOOOOOOc,::,.;x0OOOOOOOOOOkc',,,,,,,,,,''\n,'..................''',,';dOOOOOOOO0kc,,,;oOOO0OO0OO0OOOOOOOOOOOOkc,,,:dOOOOOOOOOOOOOd,',,'''''''''\n'...................''',,,lOOOOOOOOOOOOkxxkOOOOOOOOxdddkOOOOOOOOOOOOkxxOOOOOOOOOOOOOO0kc''''''''''''\n'...................''',,;xOOOkkkOOOOOOOOOOOOOOOOOxo:;:dOOOOOOOOOOOOOOOOOOOOkkkkOOOOOOOd;'''''''''''\n'.................'''',,,ckxollllldkOOOOOOOOOOOOOO0OkkOOOOOOOOOOOOOOOOOOOkdlllllodkOOOOOc'',''''''''\n''''...........'''',,,,,;odccccccccokOOOOOOOOOOOOOOO0OOOOOOOOO0OOOOOOOOOxlcccccccclk0OOOd;,,,,,,,,''\n'''''''',''',,,,,,,;;;;;;ddcccccccclxOOOOOOOOOOOOkxdddddooddkOOOOOOOOOOOdccccccccclx0OOOOl,;;;;,,,,'\n',,,,,,;;;;;;;;;;;:::::;:xOdolclllokOOOOOOOOOOOOxllodddxdddllkOOOOOOOOOOkocccccccldOOOOOOd:;:;;;;;,,\n,,,;;;;:::::::::::::::cc;lOOOkkkkOOOOOOOOOOOOOOOdlodxxdxddxdcdOOOOOOOOOOOOkxdoddxkOOOOOOOOl:::::;;,,\n,,;;::::cccccccccccccccc::dOOOOOOOOOOOOOOOOOOOO0kolldxxxxxxoldOOOOOOOOOOOOOOOOOOOOOOOOOOOOd::c::;;,,\n,,;;:::cccccccccccccccccc:cxOOOOOOOOOOOOOOOOOOOOOOkxoooooooodOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkc:c:::;,,\n,,;;::::cccccccccccccccc:c:cxOOOOOOOOOOOOOOOOOOOOOOOOOkkkkkOO0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOo;:::;;,,\n,;;;;::::ccccccccccccccc:::;ck0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOx::::;;,,\n*/\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,tune=native\")\n//#pragma GCC optimize (\"unroll-loops\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double old;\n\nconst int N = 700100;\n\nint mp[N], kek[N * 2];\nint cur;\nint len;\n\nvoid dfs(int mp[], int v, int sz = len) {\n    mp[v] = cur;\n    if (v % 7 && mp[v - 1] == 0) {\n        dfs(mp, v - 1);\n    }\n    if (v % 7 != 6 && mp[v + 1] == 0) {\n        dfs(mp, v + 1);\n    }\n    if (v / 7 && mp[v - 7] == 0) {\n        dfs(mp, v - 7);\n    }\n    if (v + 7 < sz && mp[v + 7] == 0) {\n        dfs(mp, v + 7);\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cout << fixed << setprecision(20);\n    ll n;\n    int m, q;\n    cin >> n >> m >> q;\n    if (m == q) {\n        cout << 0;\n        return 0;\n    }\n    len = m;\n    if (len % 7) {\n        len *= 7;\n    }\n    while (q--) {\n        int a;\n        cin >> a;\n        for (int i = a; i < len; i += m) {\n            mp[i] = -1;\n            kek[i + len] = kek[i] = mp[i];\n        }\n    }\n    for (int i = 0; i < len; ++i) {\n        if (mp[i] == 0) {\n            ++cur;\n            dfs(mp, i);\n        }\n    }\n    int st = cur;\n    cur = 0;\n    for (int i = 0; i < len * 2; ++i) {\n        if (kek[i] == 0) {\n            ++cur;\n            dfs(kek, i, len * 2);\n        }\n    }\n    ll ans = st + (cur - st) * (n * 7 / len - 1);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nlong N;\nint M,Q;\nint A[1<<17];\nint d[4]={0,1,0,-1};\nlong f(int h)\n{\n\tvector<vector<bool> >mp(h,vector<bool>(7,true));\n\tfor(int i=0;i<Q;i++)\n\t{\n\t\tfor(int j=A[i];j<7*h;j+=M)\n\t\t{\n\t\t\tmp[j/7][j%7]=false;\n\t\t}\n\t}\n\tlong cnt=0;\n\tfor(int i=0;i<h;i++)for(int j=0;j<7;j++)if(mp[i][j])\n\t{\n\t\tqueue<pair<int,int> >P;P.push(make_pair(i,j));\n\t\tmp[i][j]=false;\n\t\tcnt++;\n\t\twhile(!P.empty())\n\t\t{\n\t\t\tint x=P.front().first,y=P.front().second;P.pop();\n\t\t\tfor(int r=0;r<4;r++)\n\t\t\t{\n\t\t\t\tint tx=x+d[r],ty=y+d[r^1];\n\t\t\t\tif(tx<0||ty<0||tx>=h||ty>=7||!mp[tx][ty])continue;\n\t\t\t\tmp[tx][ty]=false;\n\t\t\t\tP.push(make_pair(tx,ty));\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\nmain()\n{\n\tcin>>N>>M>>Q;\n\tfor(int i=0;i<Q;i++)cin>>A[i];\n\tint X=M%7?7*M:M;\n\tlong S=f(X/7);\n\tif(X/7<N)\n\t{\n\t\tlong T=f(2*X/7);\n\t\tlong a=T-S,b=S-a;\n\t\tS=N/(X/7)*a+b;\n\t}\n\tcout<<S<<endl;\n}"
  },
  {
    "language": "C",
    "code": "#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n// 内部定数\n#define D_ROW_MAX\t\t200000\t\t\t\t\t\t\t\t\t// 最大行数\n#define D_COL_CNT\t\t7\t\t\t\t\t\t\t\t\t\t// 列数\n#define D_GRP_MAX\t\tD_ROW_MAX * D_COL_CNT\t\t\t\t\t// 最大グループ数\n\n// 内部変数\nstatic FILE *szpFpI;\t\t\t\t\t\t\t\t\t\t\t// 入力\nstatic long long slRow;\t\t\t\t\t\t\t\t\t\t\t// 全行数\nstatic int siDiv;\t\t\t\t\t\t\t\t\t\t\t\t// 除数\nstatic char sc2Mass[D_ROW_MAX][D_COL_CNT];\t\t\t\t\t\t// マス\nstatic int si1GNo[D_GRP_MAX];\t\t\t\t\t\t\t\t\t// グループ番号\nstatic int siGCnt;\t\t\t\t\t\t\t\t\t\t\t\t// グループ数\n\n// 内部変数 - テスト用\n#ifdef D_TEST\n\tstatic int siRes;\n\tstatic FILE *szpFpA;\n\tstatic int siTNo;\n#endif\n\n// １行出力\nint\nfOutLine(\n\tchar *pcpLine\t\t\t\t// <I> １行\n)\n{\n\tchar lc1Buf[1024];\n\n#ifdef D_TEST\n\tlc1Buf[0] = '\\0';\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpA);\n\tif (strcmp(lc1Buf, pcpLine)) {\n\t\tsiRes = -1;\n\t}\n#else\n\tprintf(\"%s\", pcpLine);\n#endif\n\n\treturn 0;\n}\n\n// グループ番号 - 取得\nint\nfGNoGet(\n\tint piRow\t\t\t\t\t// <I> 行\n\t, int piCol\t\t\t\t\t// <I> 列\n)\n{\n\t// グループ番号\n\tint liNo = piRow * D_COL_CNT + piCol;\n\tif (liNo == si1GNo[liNo]) {\n\t\treturn liNo;\n\t}\n\n\t// グループ番号 - 取得\n\tpiRow = si1GNo[liNo] / D_COL_CNT;\n\tpiCol = si1GNo[liNo] % D_COL_CNT;\n\tsi1GNo[liNo] = fGNoGet(piRow, piCol);\n\n\treturn si1GNo[liNo];\n}\n\n// 同一グループ化\nint\nfGrpConv(\n\tint piRow1\t\t\t\t\t// <I> 行１\n\t, int piCol1\t\t\t\t// <I> 列１\n\t, int piRow2\t\t\t\t// <I> 行２\n\t, int piCol2\t\t\t\t// <I> 列２\n)\n{\n\t// 色\n\tif (sc2Mass[piRow1][piCol1] != 0) {\n\t\treturn 0;\n\t}\n\tif (sc2Mass[piRow2][piCol2] != 0) {\n\t\treturn 0;\n\t}\n\n\t// グループ番号 - 取得\n\tint liGNo1 = fGNoGet(piRow1, piCol1);\n\tint liGNo2 = fGNoGet(piRow2, piCol2);\n\tif (liGNo1 == liGNo2) {\n\t\treturn 0;\n\t}\n\n\t// 同一グループ化\n\tsi1GNo[liGNo2] = liGNo1;\n\tsiGCnt--;\n\n\treturn 0;\n}\n\n// グループ数 - 取得\nint\nfGetGCnt(\n\tint piRow\t\t\t\t\t// <I> 行数\n)\n{\n\tint i, j;\n\n\t// グループ番号 - 初期化\n\tsiGCnt = 0;\n\tfor (i = 0; i < piRow; i++) {\n\t\tfor (j = 0; j < D_COL_CNT; j++) {\n\t\t\tif (sc2Mass[i][j] == 0) {\n\t\t\t\tint liNo = i * D_COL_CNT + j;\n\t\t\t\tsi1GNo[liNo] = liNo;\n\t\t\t\tsiGCnt++;\n\t\t\t}\n\t\t}\n\t}\n\n\t// 同一グループ化 - 右方向\n\tfor (i = 0; i < piRow; i++) {\n\t\tfor (j = 0; j < D_COL_CNT - 1; j++) {\n\t\t\tfGrpConv(i, j, i, j + 1);\n\t\t}\n\t}\n\n\t// 同一グループ化 - 下方向\n\tfor (i = 0; i < piRow - 1; i++) {\n\t\tfor (j = 0; j < D_COL_CNT; j++) {\n\t\t\tfGrpConv(i, j, i + 1, j);\n\t\t}\n\t}\n\n\treturn siGCnt;\n}\n\n// 実行メイン\nint\nfMain(\n)\n{\n\tint i, j;\n\tchar lc1Buf[1024];\n\n\t// データ - 初期化\n\tmemset(sc2Mass, 0, sizeof(sc2Mass));\n\n\t// 全行数・除数・黒数 - 取得\n\tint liBCnt;\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpI);\n\tsscanf(lc1Buf, \"%lld%d%d\", &slRow, &siDiv, &liBCnt);\n\n\t// 最小単位の行数\n\tint liMRow;\n\tif (siDiv % D_COL_CNT) {\n\t\tliMRow = siDiv;\n\t}\n\telse {\n\t\tliMRow = siDiv / D_COL_CNT;\n\t}\n\n\t// 黒 - 取得\n\tfor (i = 0; i < liBCnt; i++) {\n\t\tint liNum;\n\t\tfscanf(szpFpI, \"%d\", &liNum);\n\n\t\t// マス - 黒化\n\t\tfor (j = 0; ; j++) {\n\t\t\tint liRow = liNum / D_COL_CNT;\n\t\t\tif (liRow >= liMRow) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint liCol = liNum % D_COL_CNT;\n\t\t\tsc2Mass[liRow][liCol] = 1;\n\t\t\tliNum += siDiv;\n\t\t}\n\t}\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpI);\n\n\t// グループ数 - 取得\n\tlong long llGCnt = fGetGCnt(liMRow);\n\n\t// 最小単位超\n\tif (slRow > liMRow) {\n\t\tslRow -= liMRow;\n\n\t\t// マスコピー\n\t\tmemcpy(sc2Mass[liMRow], sc2Mass[0], sizeof(char) * liMRow * D_COL_CNT);\n\n\t\t// グループ数 - 増加分\n\t\tlong long llGCnt2 = fGetGCnt(liMRow * 2);\n\t\tllGCnt2 -= llGCnt;\n\n\t\t// グループ数 - 加算\n\t\tllGCnt += slRow / (long long)liMRow * llGCnt2;\n\t}\n\n\t// 出力\n\tsprintf(lc1Buf, \"%lld\\n\", llGCnt);\n\tfOutLine(lc1Buf);\n\n\treturn 0;\n}\n\n// １回実行\nint\nfOne(\n)\n{\n\tint liRet;\n\tchar lc1Buf[1024];\n\n\t// 入力 - セット\n#ifdef D_TEST\n\tsprintf(lc1Buf, \".\\\\Test\\\\T%d.txt\", siTNo);\n\tszpFpI = fopen(lc1Buf, \"r\");\n\tsprintf(lc1Buf, \".\\\\Test\\\\A%d.txt\", siTNo);\n\tszpFpA = fopen(lc1Buf, \"r\");\n\tsiRes = 0;\n#else\n\tszpFpI = stdin;\n#endif\n\n\t// 実行メイン\n\tliRet = fMain();\n\n\t// 残データ有無\n#ifdef D_TEST\n\tlc1Buf[0] = '\\0';\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpA);\n\tif (strcmp(lc1Buf, \"\")) {\n\t\tsiRes = -1;\n\t}\n#endif\n\n\t// テストファイルクローズ\n#ifdef D_TEST\n\tfclose(szpFpI);\n\tfclose(szpFpA);\n#endif\n\n\t// テスト結果\n#ifdef D_TEST\n\tif (siRes == 0) {\n\t\tprintf(\"OK %d\\n\", siTNo);\n\t}\n\telse {\n\t\tprintf(\"NG %d\\n\", siTNo);\n\t}\n#endif\n\n\treturn 0;\n}\n\n// プログラム開始\nint\nmain()\n{\n\n#ifdef D_TEST\n\tint i;\n\tfor (i = D_TEST_SNO; i <= D_TEST_ENO; i++) {\n\t\tsiTNo = i;\n\t\tfOne();\n\t}\n#else\n\tfOne();\n#endif\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint map[7][100000];\nlong a[100000],n,dx[4]={-1,1,0,0},dy[]={0,0,-1,1};\n\n\nvoid fill(long i,long j){\n\tlong k;\n\tmap[i][j]=1;\n\tfor(k=0;k<4;k++){\n\t\tif(0<=i+dx[k] && i+dx[k]<7 && 0<=j+dy[k] && j+dy[k]<n){\n\t\t\tif(map[i+dx[k]][j+dy[k]]==0) fill(i+dx[k],j+dy[k]);\n\t\t}\n\t}\n}\n\nint main(int argc, char const *argv[]){\n\tlong m,q,i,j,c=0;\n\tscanf(\"%ld %ld %ld\",&n,&m,&q);\n\tfor(i=0;i<q;i++){\n\t\tscanf(\"%ld\",&a[i]);\n\t}\n\tfor(i=0;i<7*n/m;i++){\n\t\tfor(j=0;j<q;j++){\n\t\t\tmap[(m*i+a[j])%7][(m*i+a[j])/7]=1;\n\t\t}\n\t}\n\tfor(i=0;i<7;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(map[i][j]==0){\n\t\t\t\tc++;\n\t\t\t\tfill(i,j);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%ld\\n\",c);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n// 内部定数\n#define D_ROW_MAX\t\t500000\t\t\t\t\t\t\t\t\t// 最大行数\n#define D_COL_CNT\t\t7\t\t\t\t\t\t\t\t\t\t// 列数\n#define D_STACK_MAX\t\tD_ROW_MAX * D_COL_CNT\t\t\t\t\t// 最大スタック数\n\n// 内部構造体 - スタック情報\ntypedef struct Stack {\n\tint miRow, miCol;\t\t\t\t\t\t\t\t\t\t\t// 行・列\n} Stack;\n\n// 内部変数\nstatic FILE *szpFpI;\t\t\t\t\t\t\t\t\t\t\t// 入力\nstatic int siRow;\t\t\t\t\t\t\t\t\t\t\t\t// 行数\nstatic int siDiv;\t\t\t\t\t\t\t\t\t\t\t\t// 除数\nstatic int si2Mass[D_ROW_MAX][D_COL_CNT];\t\t\t\t\t\t// マス\nstatic int siRMax;\t\t\t\t\t\t\t\t\t\t\t\t// 最大行\nstatic int siGCnt;\t\t\t\t\t\t\t\t\t\t\t\t// グループ数\nstatic Stack sz1Stack[D_STACK_MAX];\t\t\t\t\t\t\t\t// スタック\nstatic int siSCnt;\t\t\t\t\t\t\t\t\t\t\t\t// スタック数\n\n// 内部変数 - テスト用\n#ifdef D_TEST\n\tstatic int siRes;\n\tstatic FILE *szpFpA;\n\tstatic int siTNo;\n#endif\n\n// １行出力\nint\nfOutLine(\n\tchar *pcpLine\t\t\t\t// <I> １行\n)\n{\n\tchar lc1Buf[1024];\n\n#ifdef D_TEST\n\tlc1Buf[0] = '\\0';\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpA);\n\tif (strcmp(lc1Buf, pcpLine)) {\n\t\tsiRes = -1;\n\t}\n#else\n\tprintf(\"%s\", pcpLine);\n#endif\n\n\treturn 0;\n}\n\n// スタック - 追加\nint\nfStackAdd(\n\tint piRow\t\t\t\t\t// <I> 行\n\t, int piCol\t\t\t\t\t// <I> 列\n\t, int piGNo\t\t\t\t\t// <I> グループ番号\n)\n{\n\t// 範囲チェック\n\tif (piRow < 0 || siRMax <= piRow) {\n\t\treturn -1;\n\t}\n\tif (piCol < 0 || D_COL_CNT <= piCol) {\n\t\treturn -1;\n\t}\n\n\t// グループ番号\n\tif (si2Mass[piRow][piCol] != 0) {\n\t\treturn -1;\n\t}\n\tsi2Mass[piRow][piCol] = piGNo;\n\n\t// セット\n\tsz1Stack[siSCnt].miRow = piRow;\n\tsz1Stack[siSCnt].miCol = piCol;\n\n\t// スタック数\n\tsiSCnt++;\n\n\treturn 0;\n}\n\n// グループ化\nint\nfSetGrp(\n\tint piSRow\t\t\t\t\t// <I> 開始行\n\t, int piERow\t\t\t\t// <I> 終了行\n)\n{\n\tint i, j, liRet;\n\n\tfor (i = piSRow; i <= piERow; i++) {\n\t\tfor (j = 0; j < D_COL_CNT; j++) {\n\n\t\t\t// スタック - 追加\n\t\t\tliRet = fStackAdd(i, j, siGCnt + 1);\n\t\t\tif (liRet != 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsiGCnt++;\n\n\t\t\t// 上下左右へ\n\t\t\twhile (siSCnt > 0) {\n\t\t\t\tint liRow = sz1Stack[siSCnt - 1].miRow;\n\t\t\t\tint liCol = sz1Stack[siSCnt - 1].miCol;\n\t\t\t\tsiSCnt--;\n\t\t\t\tfStackAdd(liRow + 1, liCol, siGCnt);\n\t\t\t\tfStackAdd(liRow - 1, liCol, siGCnt);\n\t\t\t\tfStackAdd(liRow, liCol + 1, siGCnt);\n\t\t\t\tfStackAdd(liRow, liCol - 1, siGCnt);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n// 実行メイン\nint\nfMain(\n)\n{\n\tint i;\n\tchar lc1Buf[1024];\n\n\t// データ - 初期化\n\tmemset(si2Mass, 0, sizeof(si2Mass));\n\tsiGCnt = 0;\n\tsiSCnt = 0;\n\n\t// 行数・除数・塗る回数 - 取得\n\tint liDCnt;\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpI);\n\tsscanf(lc1Buf, \"%d%d%d\", &siRow, &siDiv, &liDCnt);\n\n\t// 最大行\n\tif (siRow <= siDiv * 2) {\n\t\tsiRMax = siRow;\n\t}\n\telse {\n\t\tsiRMax = siDiv * 2;\n\t}\n\n\t// 塗る位置 - 取得\n\tfor (i = 0; i < liDCnt; i++) {\n\t\tint liCol;\n\t\tfscanf(szpFpI, \"%d\", &liCol);\n\n\t\t// マス - 黒化\n\t\tint liRow = 0;\n\t\twhile (1) {\n\n\t\t\t// 行移動\n\t\t\tliRow += liCol / D_COL_CNT;\n\t\t\tliCol %= D_COL_CNT;\n\t\t\tif (liRow >= siRMax) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// 塗る\n\t\t\tsi2Mass[liRow][liCol] = -1;\n\n\t\t\t// 次へ\n\t\t\tliCol += siDiv;\n\t\t}\n\t}\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpI);\n\n\t// 小規模\n\tif (siRow <= siDiv * 2) {\n\t\tfSetGrp(0, siRow - 1);\n\t\treturn siGCnt;\n\t}\n\n\t// １つでのグループ数\n\tfSetGrp(0, siDiv - 1);\n\tint liGCnt = siGCnt;\n\n\t// １つ増分のグループ数\n\tfSetGrp(siDiv, siDiv * 2 - 1);\n\tint liGCnt2 = siGCnt - liGCnt;\n\n\t// 合計\n\treturn liGCnt + (siRow / siDiv - 1) * liGCnt2;\n}\n\n// １回実行\nint\nfOne(\n)\n{\n\tint liRet;\n\tchar lc1Buf[1024];\n\n\t// 入力 - セット\n#ifdef D_TEST\n\tsprintf(lc1Buf, \".\\\\Test\\\\T%d.txt\", siTNo);\n\tszpFpI = fopen(lc1Buf, \"r\");\n\tsprintf(lc1Buf, \".\\\\Test\\\\A%d.txt\", siTNo);\n\tszpFpA = fopen(lc1Buf, \"r\");\n\tsiRes = 0;\n#else\n\tszpFpI = stdin;\n#endif\n\n\t// 実行メイン\n\tliRet = fMain();\n\n\t// 出力\n\tif (liRet == 0) {\n\t\tsprintf(lc1Buf, \"Yes\\n\");\n\t}\n\telse {\n\t\tsprintf(lc1Buf, \"No\\n\");\n\t}\n\tsprintf(lc1Buf, \"%d\\n\", liRet);\n\tfOutLine(lc1Buf);\n\n\t// 残データ有無\n#ifdef D_TEST\n\tlc1Buf[0] = '\\0';\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpA);\n\tif (strcmp(lc1Buf, \"\")) {\n\t\tsiRes = -1;\n\t}\n#endif\n\n\t// テストファイルクローズ\n#ifdef D_TEST\n\tfclose(szpFpI);\n\tfclose(szpFpA);\n#endif\n\n\t// テスト結果\n#ifdef D_TEST\n\tif (siRes == 0) {\n\t\tprintf(\"OK %d\\n\", siTNo);\n\t}\n\telse {\n\t\tprintf(\"NG %d\\n\", siTNo);\n\t}\n#endif\n\n\treturn 0;\n}\n\n// プログラム開始\nint\nmain()\n{\n\n#ifdef D_TEST\n\tint i;\n\tfor (i = D_TEST_SNO; i <= D_TEST_ENO; i++) {\n\t\tsiTNo = i;\n\t\tfOne();\n\t}\n#else\n\tfOne();\n#endif\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.stream.IntStream;\nimport java.util.Collection;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.util.stream.Collectors;\nimport java.io.InputStreamReader;\nimport java.util.stream.Stream;\nimport java.util.StringTokenizer;\nimport java.util.Queue;\nimport java.io.BufferedReader;\nimport java.util.ArrayDeque;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyScanner in = new MyScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        C solver = new C();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class C {\n        public void solve(int testNumber, MyScanner in, PrintWriter out) {\n            long n = in.Long();\n            int m = in.Int();\n            int q = in.Int();\n            int[][] cal = new int[m / 7][7];\n            int[] a = in.Int(q);\n            Set<Integer> set = IntStream.of(a).boxed().collect(Collectors.toSet());\n            for (int j = 0; j < m / 7; j++) {\n                for (int k = 0; k < 7; k++) {\n                    int i = (7 * j + k) % m;\n                    if (set.contains(i)) {\n                        cal[j][k] = 1;\n                    }\n                }\n            }\n            long cnt = 0;\n            for (int i = 0; i < m / 7; i++) {\n                for (int j = 0; j < 7; j++) {\n                    if (cal[i][j] == 0) {\n                        cnt++;\n                        Queue<int[]> que = new ArrayDeque<>();\n                        que.add(new int[]{i, j});\n                        while (!que.isEmpty()) {\n                            int[] p = que.poll();\n                            int y = p[0];\n                            int x = p[1];\n                            if (cal[y][x] != 0) continue;\n                            cal[y][x] = -1;\n                            if (0 <= y - 1) que.add(new int[]{y - 1, x});\n                            if (y + 1 < m / 7) que.add(new int[]{y + 1, x});\n                            if (0 <= x - 1) que.add(new int[]{y, x - 1});\n                            if (x + 1 < 7) que.add(new int[]{y, x + 1});\n                        }\n                    }\n                }\n            }\n            long ln = n * 7 / m;\n            int lm = m / 7;\n            int u = 0;\n            for (int j = 0; j < 7; j++) {\n                if (cal[0][j] == -1 && cal[lm - 1][j] == -1) {\n                    u++;\n                    Queue<int[]> que = new ArrayDeque<>();\n                    que.add(new int[]{0, j});\n                    que.add(new int[]{lm - 1, j});\n                    while (!que.isEmpty()) {\n                        int[] p = que.poll();\n                        int y = p[0];\n                        int x = p[1];\n                        if (cal[y][x] != -1) continue;\n                        cal[y][x] = 0;\n                        if (0 <= y - 1) que.add(new int[]{y - 1, x});\n                        if (y + 1 < m / 7) que.add(new int[]{y + 1, x});\n                        if (0 <= x - 1) que.add(new int[]{y, x - 1});\n                        if (x + 1 < 7) que.add(new int[]{y, x + 1});\n                    }\n                }\n            }\n            cnt = cnt * ln - (ln > 1 ? u : 0) - (ln > 2 ? (ln - 2) * u : 0);\n            out.println(cnt);\n        }\n\n    }\n\n    static class MyScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public MyScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int Int() {\n            return Integer.parseInt(next());\n        }\n\n        public long Long() {\n            return Long.parseLong(next());\n        }\n\n        public int[] Int(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = Int();\n            }\n            return a;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\t\n\tstatic Scanner\ts\t=new Scanner(System.in);\n\tstatic long n;\n\tstatic int m, q, a[];\n\t\n\tpublic static void main(String[] __){\n\t\tinput();\n\t\t\n\t\tint b=a[a.length-1]-a[0], k=2;\n\t\tif(b<7){\n\t\t\tSystem.out.println(1);\n\t\t\treturn;\n\t\t}else{\n\t\t\tif(a[0]==0)\n\t\t\t\tk--;\n\t\t\tif(a[a.length-1]==m-1)\n\t\t\t\tk--;\n\t\t\t\n\t\t\tSystem.out.println(7L*n/m*k);\n\t\t}\n\t}\n\t\n\tprivate static final void input(){\n\t\tn=s.nextLong();\n\t\tm=s.nextInt();\n\t\tq=s.nextInt();\n\t\ta=new int[q];\n\t\tfor(int i=0; i<q; i++)\n\t\t\ta[i]=s.nextInt();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.stream.IntStream;\nimport java.util.Collection;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.util.stream.Collectors;\nimport java.io.InputStreamReader;\nimport java.util.stream.Stream;\nimport java.util.StringTokenizer;\nimport java.util.Queue;\nimport java.io.BufferedReader;\nimport java.util.ArrayDeque;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyScanner in = new MyScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        C solver = new C();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class C {\n        long gcd(long a, long b) {\n            return b == 0 ? a : gcd(b, a % b);\n        }\n\n        long lcm(long a, long b) {\n            return a / gcd(a, b) * b;\n        }\n\n        public void solve(int testNumber, MyScanner in, PrintWriter out) {\n            long n = in.Long();\n            int m = in.Int();\n            int q = in.Int();\n            int lm = (int) lcm(m, 7);\n            int[][] cal = new int[lm][7];\n            int[] a = in.Int(q);\n            Set<Integer> set = IntStream.of(a).boxed().collect(Collectors.toSet());\n            for (int j = 0; j < lm; j++) {\n                for (int k = 0; k < 7; k++) {\n                    int i = (7 * j + k) % m;\n                    if (set.contains(i)) {\n                        cal[j][k] = 1;\n                    }\n                }\n            }\n            long[] cnt = new long[lm];\n            long sum = 0;\n            for (int i = 0; i < lm; i++) {\n                for (int j = 0; j < 7; j++) {\n                    if (cal[i][j] == 0) {\n                        cnt[i]++;\n                        Queue<int[]> que = new ArrayDeque<>();\n                        que.add(new int[]{i, j});\n                        while (!que.isEmpty()) {\n                            int[] p = que.poll();\n                            int y = p[0];\n                            int x = p[1];\n                            if (cal[y][x] != 0) continue;\n                            cal[y][x] = -1;\n                            if (0 <= y - 1) que.add(new int[]{y - 1, x});\n                            if (y + 1 < m) que.add(new int[]{y + 1, x});\n                            if (0 <= x - 1) que.add(new int[]{y, x - 1});\n                            if (x + 1 < 7) que.add(new int[]{y, x + 1});\n                        }\n                    }\n                }\n                sum += cnt[i];\n            }\n            int u = 0;\n            for (int j = 0; j < 7; j++) {\n                if (cal[0][j] == -1 && cal[lm - 1][j] == -1) {\n                    u++;\n                    Queue<int[]> que = new ArrayDeque<>();\n                    que.add(new int[]{0, j});\n                    que.add(new int[]{lm - 1, j});\n                    while (!que.isEmpty()) {\n                        int[] p = que.poll();\n                        int y = p[0];\n                        int x = p[1];\n                        if (cal[y][x] != -1) continue;\n                        cal[y][x] = 0;\n                        if (0 <= y - 1) que.add(new int[]{y - 1, x});\n                        if (y + 1 < m / 7) que.add(new int[]{y + 1, x});\n                        if (0 <= x - 1) que.add(new int[]{y, x - 1});\n                        if (x + 1 < 7) que.add(new int[]{y, x + 1});\n                    }\n                }\n            }\n            long ln = n / lm;\n            long ans = sum * ln - (ln > 1 ? u : 0) - (ln > 2 ? (ln - 2) * u : 0);\n            long l = n % lm;\n            for (int i = 0; i < l; i++) {\n                ans += cnt[i];\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class MyScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public MyScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int Int() {\n            return Integer.parseInt(next());\n        }\n\n        public long Long() {\n            return Long.parseLong(next());\n        }\n\n        public int[] Int(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = Int();\n            }\n            return a;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.stream.IntStream;\nimport java.util.Collection;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.util.stream.Collectors;\nimport java.io.InputStreamReader;\nimport java.util.stream.Stream;\nimport java.util.StringTokenizer;\nimport java.util.Queue;\nimport java.io.BufferedReader;\nimport java.util.ArrayDeque;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyScanner in = new MyScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        C solver = new C();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class C {\n        long gcd(long a, long b) {\n            return b == 0 ? a : gcd(b, a % b);\n        }\n\n        long lcm(long a, long b) {\n            return a / gcd(a, b) * b;\n        }\n\n        public void solve(int testNumber, MyScanner in, PrintWriter out) {\n            long n = in.Long();\n            int m = in.Int();\n            int q = in.Int();\n            int lm = (int) lcm(m, 7);\n            int[][] cal = new int[lm][7];\n            int[] a = in.Int(q);\n            Set<Integer> set = IntStream.of(a).boxed().collect(Collectors.toSet());\n            for (int j = 0; j < lm; j++) {\n                for (int k = 0; k < 7; k++) {\n                    int i = (7 * j + k) % m;\n                    if (set.contains(i)) {\n                        cal[j][k] = 1;\n                    }\n                }\n            }\n            long[] cnt = new long[lm];\n            long sum = 0;\n            for (int i = 0; i < lm; i++) {\n                for (int j = 0; j < 7; j++) {\n                    if (cal[i][j] == 0) {\n                        cnt[i]++;\n                        Queue<int[]> que = new ArrayDeque<>();\n                        que.add(new int[]{i, j});\n                        while (!que.isEmpty()) {\n                            int[] p = que.poll();\n                            int y = p[0];\n                            int x = p[1];\n                            if (cal[y][x] != 0) continue;\n                            cal[y][x] = -1;\n                            if (0 <= y - 1) que.add(new int[]{y - 1, x});\n                            if (y + 1 < lm) que.add(new int[]{y + 1, x});\n                            if (0 <= x - 1) que.add(new int[]{y, x - 1});\n                            if (x + 1 < 7) que.add(new int[]{y, x + 1});\n                        }\n                    }\n                }\n                sum += cnt[i];\n            }\n            int u = 0;\n            for (int j = 0; j < 7; j++) {\n                if (cal[0][j] == -1 && cal[lm - 1][j] == -1) {\n                    u++;\n                    Queue<int[]> que = new ArrayDeque<>();\n                    que.add(new int[]{0, j});\n                    que.add(new int[]{lm - 1, j});\n                    while (!que.isEmpty()) {\n                        int[] p = que.poll();\n                        int y = p[0];\n                        int x = p[1];\n                        if (cal[y][x] != -1) continue;\n                        cal[y][x] = 0;\n                        if (0 <= y - 1) que.add(new int[]{y - 1, x});\n                        if (y + 1 < lm) que.add(new int[]{y + 1, x});\n                        if (0 <= x - 1) que.add(new int[]{y, x - 1});\n                        if (x + 1 < 7) que.add(new int[]{y, x + 1});\n                    }\n                }\n            }\n            long ln = n / lm;\n            long ans = sum * ln - (ln > 1 ? u : 0) - (ln > 2 ? (ln - 2) * u : 0);\n            long l = n % lm;\n            for (int i = 0; i < l; i++) {\n                ans += cnt[i];\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class MyScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public MyScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int Int() {\n            return Integer.parseInt(next());\n        }\n\n        public long Long() {\n            return Long.parseLong(next());\n        }\n\n        public int[] Int(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = Int();\n            }\n            return a;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n  public static void main(String[] args) {\n    FastScanner sc = new FastScanner();\n    long n = sc.nextLong();\n    int m = sc.nextInt();\n    int q = sc.nextInt();\n    int[] a = sc.nextIntList(q);\n    \n    if (m % 7 != 0) {\n      int[] b = new int[q * 7];\n      for (int i = 0; i < q; i ++) {\n        for (int j = 0; j < 7; j ++) {\n          b[j * q + i] = a[i] + m * j;\n        }\n      }\n      m *= 7;\n      a = b;\n    }\n    \n    int s1 = count(a, m, false);\n    int s2 = count(a, m, true);\n    \n    long t1 = s2 - s1;\n    long t2 = s1 - t1;\n    long f = n * 7 / m;\n    \n    System.out.println(f * t1 + t2);\n    \n  }\n  \n  \n  private static int count(int[] a, int m, boolean twice) {\n    int n = m / 7 * (twice ? 2 : 1);\n    \n    int[][] map = new int[n][7];\n\n    for (int x : a) {\n      map[x / 7][x % 7] = -1;\n      if (twice) {\n        map[x / 7 + m / 7][x % 7] = -1;\n      }\n    }\n\n    int[][] dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    int count = 0;\n    Deque<int[]> queue = new ArrayDeque<>();\n    for (int sx = 0; sx < 7; sx ++) {\n      for (int sy = 0; sy < n; sy ++) {\n        if (map[sy][sx] == 0) {\n          count ++;\n          map[sy][sx] = count;\n        } else {\n          continue;\n        }\n\n        queue.add(new int[]{sy, sx});\n        while (queue.size() > 0) {\n          int[] p = queue.poll();\n          for (int[] d : dir) {\n            int y = p[0] + d[0];\n            int x = p[1] + d[1];\n            \n            if (0 <= x && x < 7 && 0 <= y && y < n && map[y][x] == 0) {\n              queue.add(new int[]{y, x});\n              map[y][x] = count;\n            }\n          }\n        }\n      }\n    }\n    return count;\n  }\n}\n\n\n\n\nclass FastScanner {\n\tpublic static String debug = null;\n\n\tprivate final InputStream in = System.in;\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate byte[] buffer = new byte[1024];\n\tprivate boolean eos = false;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tif (debug != null) {\n\t\t\t\t\tbuflen = debug.length();\n\t\t\t\t\tbuffer = debug.getBytes();\n\t\t\t\t\tdebug = \"\";\n\t\t\t\t\teos = true;\n\t\t\t\t} else {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen < 0) {\n\t\t\t\teos = true;\n\t\t\t\treturn false;\n\t\t\t} else if (buflen == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t}\n\n\tpublic boolean isEOS() {\n\t\treturn this.eos;\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic int nextInt() {\n\t\treturn (int) nextLong();\n\t}\n\n\tpublic long[] nextLongList(int n) {\n\t\treturn nextLongTable(1, n)[0];\n\t}\n\n\tpublic int[] nextIntList(int n) {\n\t\treturn nextIntTable(1, n)[0];\n\t}\n\n\tpublic long[][] nextLongTable(int n, int m) {\n\t\tlong[][] ret = new long[n][m];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tfor (int j = 0; j < m; j ++) {\n\t\t\t\tret[i][j] = nextLong();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic int[][] nextIntTable(int n, int m) {\n\t\tint[][] ret = new int[n][m];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tfor (int j = 0; j < m; j ++) {\n\t\t\t\tret[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int[] a;\n\tstatic byte[] cells;\n\n\tpublic static void main(String args[]) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint m = scan.nextInt();\n\t\tint q = scan.nextInt();\n\t\ta = new int[q];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\ta[i] = scan.nextByte();\n\t\t}\n\t\tscan.close();\n\t\tcells = new byte[n * 7];\n\t\tfor (int i = 0; i < cells.length; i++) {\n\t\t\tcells[i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint b = 0;\n\t\t\twhile (m * b + a[i] < 7 * n) {\n\t\t\t\tcells[m * b + a[i]] |= 0x0001;\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor (int i = 0; i < 7 * n; i++) {\n\t\t\tif ((cells[i] & 0x0011) == 0 && countNextTo(i) > 0) {\n\t\t\t\tcount=1;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\n\tprivate static int countNextTo(int num) {\n\t\tif ((cells[num] & 0x0001) != 0 || (cells[num] & 0x0010) != 0 || num < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tint count = 0;\n\n\t\tif (num % 7 != 6 && num < cells.length - 1) {\n\t\t\tcount += (cells[num + 1] & 0x0011) == 0 ? countNextTo(num + 1) : 0;\n\t\t}\n\t\tif (cells.length - num > 7) {\n\t\t\tcount += (cells[num + 7] & 0x0011) == 0 ? countNextTo(num + 7) : 0;\n\t\t}\n\t\tcount++;\n\t\tcells[num] |= 0x0010;\n\t\treturn count;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n  public static void main(String[] args) {\n    FastScanner sc = new FastScanner();\n    long n = sc.nextLong();\n    int m = sc.nextInt();\n    int q = sc.nextInt();\n    int[] a = sc.nextIntList(q);\n    \n    if (m % 7 != 0) {\n      int[] b = new int[q * 7];\n      for (int i = 0; i < q; i ++) {\n        for (int j = 0; j < 7; j ++) {\n          b[j * m + i] = a[i] + m * j;\n        }\n      }\n      m *= 7;\n      a = b;\n    }\n    \n    int s1 = count(a, m, false);\n    int s2 = count(a, m, true);\n    \n    long t1 = s2 - s1;\n    long t2 = s1 - t1;\n    long f = n * 7 / m;\n    \n    System.out.println(f * t1 + t2);\n    \n  }\n  \n  \n  private static int count(int[] a, int m, boolean twice) {\n    int n = m / 7 * (twice ? 2 : 1);\n    \n    int[][] map = new int[n][7];\n\n    for (int x : a) {\n      map[x / 7][x % 7] = -1;\n      if (twice) {\n        map[x / 7 + m / 7][x % 7] = -1;\n      }\n    }\n\n    int[][] dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    int count = 0;\n    Deque<int[]> queue = new ArrayDeque<>();\n    for (int sx = 0; sx < 7; sx ++) {\n      for (int sy = 0; sy < n; sy ++) {\n        if (map[sy][sx] == 0) {\n          count ++;\n          map[sy][sx] = count;\n        } else {\n          continue;\n        }\n\n        queue.add(new int[]{sy, sx});\n        while (queue.size() > 0) {\n          int[] p = queue.poll();\n          for (int[] d : dir) {\n            int y = p[0] + d[0];\n            int x = p[1] + d[1];\n            \n            if (0 <= x && x < 7 && 0 <= y && y < n && map[y][x] == 0) {\n              queue.add(new int[]{y, x});\n              map[y][x] = count;\n            }\n          }\n        }\n      }\n    }\n    return count;\n  }\n}\n\n\n\n\nclass FastScanner {\n\tpublic static String debug = null;\n\n\tprivate final InputStream in = System.in;\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate byte[] buffer = new byte[1024];\n\tprivate boolean eos = false;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tif (debug != null) {\n\t\t\t\t\tbuflen = debug.length();\n\t\t\t\t\tbuffer = debug.getBytes();\n\t\t\t\t\tdebug = \"\";\n\t\t\t\t\teos = true;\n\t\t\t\t} else {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen < 0) {\n\t\t\t\teos = true;\n\t\t\t\treturn false;\n\t\t\t} else if (buflen == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t}\n\n\tpublic boolean isEOS() {\n\t\treturn this.eos;\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic int nextInt() {\n\t\treturn (int) nextLong();\n\t}\n\n\tpublic long[] nextLongList(int n) {\n\t\treturn nextLongTable(1, n)[0];\n\t}\n\n\tpublic int[] nextIntList(int n) {\n\t\treturn nextIntTable(1, n)[0];\n\t}\n\n\tpublic long[][] nextLongTable(int n, int m) {\n\t\tlong[][] ret = new long[n][m];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tfor (int j = 0; j < m; j ++) {\n\t\t\t\tret[i][j] = nextLong();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic int[][] nextIntTable(int n, int m) {\n\t\tint[][] ret = new int[n][m];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tfor (int j = 0; j < m; j ++) {\n\t\t\t\tret[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static long N;\n    static int M, Q;\n    static int[] A;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        N = sc.nextLong();\n        M = sc.nextInt();\n        Q = sc.nextInt();\n        A = new int[Q];\n        for (int i = 0; i < Q; i++) {\n            A[i] = sc.nextInt();\n        }\n        System.out.println(solve());\n    }\n\n    static long solve() {\n        if( M % 7 != 0 ) {\n            int[] B = new int[Q * 7];\n\n            for (int i = 0; i < 7; i++) {\n                for (int j = 0; j < Q; j++) {\n                    B[i*Q + j] = A[j] + i*M;\n                }\n            }\n\n            M *= 7;\n            Q *= 7;\n            A = B;\n        }\n\n//        System.out.println(N + \" \" + M + \" \" + Q);\n//        System.out.println( Arrays.toString(A) );\n\n        int c1 = count(1);\n        int c2 = count(2);\n\n        // c1 = a + b\n        // c2 = 2a + b\n        int a = c2 - c1;\n        int b = c1 - a;\n\n        return (long)a * (N / (M/7)) + b;\n    }\n\n    static int count(int z) {\n        boolean[][] marked = new boolean[z*M/7][7];\n\n        for (int i = 0; i < z; i++) {\n            for (int j = 0; j < Q; j++) {\n                int a = A[j];\n                int week = (a + i*M) / 7;\n                int day = (a + i*M) % 7;\n                marked[week][day] = true;\n            }\n        }\n\n//        System.out.println();\n//        for (boolean[] bool : marked) {\n//            System.out.println( Arrays.toString(bool) );\n//        }\n\n        int lastWeek = z * M / 7 - 1;\n        UnionFind uf = new UnionFind( z * M );\n        for (int i = 0; i < z * M; i++) {\n            int week = i / 7;\n            int day = i % 7;\n\n            if( day != 6 ) {\n                unite(uf, marked, week, day, week, day+1);\n            }\n\n            if( week != lastWeek ) {\n                unite(uf, marked, week, day, week+1, day);\n            }\n        }\n\n        Set<Integer> uniq = new HashSet<>();\n        for (int i = 0; i < z * M; i++) {\n            int week = i / 7;\n            int day = i % 7;\n\n            if( !marked[week][day] ) {\n                uniq.add( uf.root(i) );\n            }\n        }\n        return uniq.size();\n    }\n\n    static void unite(UnionFind uf, boolean[][] marked, int w1, int d1, int w2, int d2) {\n        if( !marked[w1][d1] && !marked[w2][d2] ) {\n            uf.unite( w1 * 7 + d1, w2 * 7 + d2);\n        }\n    }\n\n    static class UnionFind {\n\n        private final int[] parent;\n        private final int[] rank;\n\n        public UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n\n        public int root(int i) {\n            if( parent[i] == i ) {\n                return i;\n            } else {\n                return parent[i] = root(parent[i]);\n            }\n        }\n\n        public void unite(int i, int j) {\n            int ri = root(i);\n            int rj = root(j);\n            if( ri == rj ) return;\n\n            if( rank[ri] < rank[rj] ) {\n                parent[ri] = rj;\n\n            } else {\n                parent[rj] = ri;\n                if( rank[ri] == rank[rj] ) {\n                    rank[ri]++;\n                }\n            }\n        }\n\n        public boolean isSame(int a, int b) {\n            return root(a) == root(b);\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint m = ni();\n\t\tint q = ni();\n\t\tint[] a = na(q);\n\t\tboolean[] map = new boolean[7*n];\n\t\tArrays.fill(map, true);\n\t\tfor(int v : a){\n\t\t\tfor(int i = v;i < 7*n;i+=m){\n\t\t\t\tmap[i] = false;\n\t\t\t}\n\t\t}\n\t\tDJSet ds = new DJSet(7*n);\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < 7;j++){\n\t\t\t\tif(j+1 < 7 && map[i*7+j] && map[i*7+j+1]){\n\t\t\t\t\tds.union(i*7+j, i*7+j+1);\n\t\t\t\t}\n\t\t\t\tif(i+1 < n && map[i*7+j] && map[(i+1)*7+j]){\n\t\t\t\t\tds.union(i*7+j, (i+1)*7+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ct = 0;\n\t\tfor(int i = 0;i < 7*n;i++){\n\t\t\tif(ds.upper[i] < 0 && map[i]){\n\t\t\t\tct++;\n\t\t\t}\n\t\t}\n\t\tout.println(ct);\n\t}\n\t\n\tpublic static class DJSet {\n\t\tpublic int[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tpublic int root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tpublic boolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tpublic boolean union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (upper[y] < upper[x]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\tupper[x] += upper[y];\n\t\t\t\tupper[y] = x;\n\t\t\t}\n\t\t\treturn x == y;\n\t\t}\n\n\t\tpublic int count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : upper)\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\treturn ct;\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int[] a;\n\tstatic byte[] cells;\n\n\tpublic static void main(String args[]) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint m = scan.nextInt();\n\t\tint q = scan.nextInt();\n\t\ta = new int[q];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\ta[i] = scan.nextByte();\n\t\t}\n\t\tscan.close();\n\t\tcells = new byte[n * 7];\n\t\tfor (int i = 0; i < cells.length; i++) {\n\t\t\tcells[i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint b = 0;\n\t\t\twhile (m * b + a[i] < 7 * n) {\n\t\t\t\tcells[m * b + a[i]] |= 0x0001;\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor (int i = 0; i < 7 * n; i++) {\n\t\t\tif ((cells[i] & 0x0011) == 0 && countNextTo(i) > 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\n\tprivate static int countNextTo(int num) {\n\t\tif ((cells[num] & 0x0001) != 0 || (cells[num] & 0x0010) != 0 || num < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tint count = 0;\n\n\t\tif (num % 7 != 6 && num < cells.length - 1) {\n\t\t\tcount += (cells[num + 1] & 0x0011) == 0 ? (countNextTo(num + 1) > 0 ? 1 : 0) : 0;\n\t\t}\n\t\tif (cells.length - num > 7) {\n\t\t\tcount += (cells[num + 7] & 0x0011) == 0 ? (countNextTo(num + 7) > 0 ? 1 : 0) : 0;\n\t\t}\n\t\tcount++;\n\t\tcells[num] |= 0x0010;\n\t\treturn count;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.stream.IntStream;\nimport java.util.Collection;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.util.stream.Collectors;\nimport java.io.InputStreamReader;\nimport java.util.stream.Stream;\nimport java.util.StringTokenizer;\nimport java.util.Queue;\nimport java.io.BufferedReader;\nimport java.util.ArrayDeque;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyScanner in = new MyScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        C solver = new C();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class C {\n        public void solve(int testNumber, MyScanner in, PrintWriter out) {\n            long n = in.Long();\n            int m = in.Int();\n            int q = in.Int();\n            int[][] cal = new int[m][7];\n            int[] a = in.Int(q);\n            Set<Integer> set = IntStream.of(a).boxed().collect(Collectors.toSet());\n            for (int j = 0; j < m; j++) {\n                for (int k = 0; k < 7; k++) {\n                    int i = (7 * j + k) % m;\n                    if (set.contains(i)) {\n                        cal[j][k] = 1;\n                    }\n                }\n            }\n            long[] cnt = new long[m];\n            long sum = 0;\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < 7; j++) {\n                    if (cal[i][j] == 0) {\n                        cnt[i]++;\n                        Queue<int[]> que = new ArrayDeque<>();\n                        que.add(new int[]{i, j});\n                        while (!que.isEmpty()) {\n                            int[] p = que.poll();\n                            int y = p[0];\n                            int x = p[1];\n                            if (cal[y][x] != 0) continue;\n                            cal[y][x] = -1;\n                            if (0 <= y - 1) que.add(new int[]{y - 1, x});\n                            if (y + 1 < m) que.add(new int[]{y + 1, x});\n                            if (0 <= x - 1) que.add(new int[]{y, x - 1});\n                            if (x + 1 < 7) que.add(new int[]{y, x + 1});\n                        }\n                    }\n                }\n                sum += cnt[i];\n            }\n            int u = 0;\n            for (int j = 0; j < 7; j++) {\n                if (cal[0][j] == -1 && cal[m - 1][j] == -1) {\n                    u++;\n                    Queue<int[]> que = new ArrayDeque<>();\n                    que.add(new int[]{0, j});\n                    que.add(new int[]{m - 1, j});\n                    while (!que.isEmpty()) {\n                        int[] p = que.poll();\n                        int y = p[0];\n                        int x = p[1];\n                        if (cal[y][x] != -1) continue;\n                        cal[y][x] = 0;\n                        if (0 <= y - 1) que.add(new int[]{y - 1, x});\n                        if (y + 1 < m / 7) que.add(new int[]{y + 1, x});\n                        if (0 <= x - 1) que.add(new int[]{y, x - 1});\n                        if (x + 1 < 7) que.add(new int[]{y, x + 1});\n                    }\n                }\n            }\n            long ln = n / m;\n            long ans = sum * ln - (ln > 1 ? u : 0) - (ln > 2 ? (ln - 2) * u : 0);\n            long l = n % m;\n            for (int i = 0; i < l; i++) {\n                ans += cnt[i];\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class MyScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public MyScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int Int() {\n            return Integer.parseInt(next());\n        }\n\n        public long Long() {\n            return Long.parseLong(next());\n        }\n\n        public int[] Int(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = Int();\n            }\n            return a;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tlong n = sc.nextLong();\n\t\tint m = sc.nextInt();\n\t\tint q = sc.nextInt();\n\n\t\tint[] a = new int[q];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\n\t\tif (n > 100_000) {\n\t\t\tthrow new AssertionError();\n\t\t}\n\n\t\tboolean[][] mz = new boolean[(int)n][7];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tfor (int j = 0; true; j++) {\n\t\t\t\tint tmp = m * j + a[i];\n\t\t\t\tif (tmp >= 7 * n) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint x = tmp % 7;\n\t\t\t\tint y = tmp / 7;\n\t\t\t\tmz[y][x] = true;\n\t\t\t}\n\t\t}\n\n\t\tpr.println(cnt(mz));\n\t}\n\n\tprivate static int cnt(boolean[][] mz) {\n\t\tint[] dx = {1, -1, 0, 0};\n\t\tint[] dy = {0, 0, 1, -1};\n\n\t\tint sizey = mz.length;\n\t\tint sizex = mz[0].length;\n\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < sizey; i++) {\n\t\t\tfor (int j = 0; j < sizex; j++) {\n\t\t\t\tif (!mz[i][j]) {\n\t\t\t\t\tret++;\n\n\t\t\t\t\tQueue<Pair> q = new ArrayDeque<>();\n\t\t\t\t\tq.add(new Pair(i, j));\n\t\t\t\t\tmz[i][j] = true;\n\t\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\t\tPair e = q.remove();\n\n\t\t\t\t\t\tfor (int k = 0, size = dx.length; k < size; k++) {\n\t\t\t\t\t\t\tint nx = e.b + dx[k];\n\t\t\t\t\t\t\tint ny = e.a + dy[k];\n\n\t\t\t\t\t\t\tif (nx < 0 || nx >= sizex || ny < 0 || ny >= sizey) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (mz[ny][nx]) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tq.add(new Pair(ny, nx));\n\t\t\t\t\t\t\tmz[ny][nx] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tprivate static class Pair implements Comparable<Pair> {\n\t\tint a;\n\t\tint b;\n\n\t\tPair(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif (a == o.a) {\n\t\t\t\tInteger.compare(b, o.b);\n\t\t\t}\n\n\t\t\treturn Integer.compare(a, o.a);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Integer.hashCode(a);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\t// [xxx, xxxx]\n\t\t\tStringBuilder stmp = new StringBuilder(32);\n\t\t\tstmp.append('[');\n\t\t\tstmp.append(a);\n\t\t\tstmp.append(',');\n\t\t\tstmp.append(' ');\n\t\t\tstmp.append(b);\n\t\t\tstmp.append(']');\n\n\t\t\treturn stmp.toString();\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t// parseInt from Integer.parseInt()\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t// parseLong from Long.parseLong()\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n\t\tpr.close();\n\t\tsc.close();\n\t}\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(PrintStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.util.Collection;\nimport java.io.IOException;\nimport java.util.Queue;\nimport java.io.BufferedReader;\nimport java.util.ArrayDeque;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyScanner in = new MyScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        C solver = new C();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class C {\n        public void solve(int testNumber, MyScanner in, PrintWriter out) {\n            int n = in.Int();\n            int m = in.Int();\n            int q = in.Int();\n            int[][] cal = new int[m / 7][7];\n            for (int i = 0; i < q; i++) {\n                int a = in.Int();\n                for (int j = 0; j < m / 7; j++) {\n                    for (int k = 0; k < 7; k++) {\n                        if ((7 * j + k) % m == a) {\n                            cal[j][k] = 1;\n                        }\n                    }\n                }\n            }\n            int cnt = 0;\n            for (int i = 0; i < m / 7; i++) {\n                for (int j = 0; j < 7; j++) {\n                    if (cal[i][j] == 0) {\n                        cnt++;\n                        Queue<int[]> que = new ArrayDeque<>();\n                        que.add(new int[]{i, j});\n                        while (!que.isEmpty()) {\n                            int[] p = que.poll();\n                            int y = p[0];\n                            int x = p[1];\n                            if (cal[y][x] != 0) continue;\n                            cal[y][x] = -1;\n                            if (0 <= y - 1) que.add(new int[]{y - 1, x});\n                            if (y + 1 < m / 7) que.add(new int[]{y + 1, x});\n                            if (0 <= x - 1) que.add(new int[]{y, x - 1});\n                            if (x + 1 < 7) que.add(new int[]{y, x + 1});\n                        }\n                    }\n                }\n            }\n            int ln = n * 7 / m;\n            int lm = m / 7;\n            int u = 0;\n            for (int j = 0; j < 7; j++) {\n                if (cal[0][j] == -1 && cal[lm - 1][j] == -1) {\n                    u++;\n                    Queue<int[]> que = new ArrayDeque<>();\n                    que.add(new int[]{0, j});\n                    que.add(new int[]{lm - 1, j});\n                    while (!que.isEmpty()) {\n                        int[] p = que.poll();\n                        int y = p[0];\n                        int x = p[1];\n                        if (cal[y][x] != -1) continue;\n                        cal[y][x] = 0;\n                        if (0 <= y - 1) que.add(new int[]{y - 1, x});\n                        if (y + 1 < m / 7) que.add(new int[]{y + 1, x});\n                        if (0 <= x - 1) que.add(new int[]{y, x - 1});\n                        if (x + 1 < 7) que.add(new int[]{y, x + 1});\n                    }\n                }\n            }\n            cnt = cnt * ln - (ln > 1 ? u : 0) - (ln > 2 ? (ln - 2) * u : 0);\n            out.println(cnt);\n        }\n\n    }\n\n    static class MyScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public MyScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int Int() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tlong n = nl();\n\t\tint m = ni();\n\t\tint q = ni();\n\t\tint[] a = na(q);\n\t\tif(m % 7 != 0){\n\t\t\ta = Arrays.copyOf(a, q*7);\n\t\t\tfor(int i = q;i < q*7;i++){\n\t\t\t\ta[i] = a[i-q] + m;\n\t\t\t}\n\t\t\tm *= 7;\n\t\t\tq *= 7;\n\t\t}\n\t\ttr(m);\n\t\tboolean[] map = new boolean[m];\n\t\tArrays.fill(map, true);\n\t\tfor(int v : a)map[v] = false;\n\t\tint c1 = count(map);\n\t\t\n\t\tmap = new boolean[2*m];\n\t\tArrays.fill(map, true);\n\t\tfor(int v : a)map[v] = map[v+m] = false;\n\t\tint c2 = count(map);\n\t\tout.println(c1 + (c2-c1) * (7*n/m-1));\n\t}\n\t\n\tstatic int count(boolean[] map){\n\t\tint m = map.length;\n\t\tDJSet ds = new DJSet(m);\n\t\tfor(int i = 0;i < m/7;i++){\n\t\t\tfor(int j = 0;j < 7;j++){\n\t\t\t\tif(j+1 < 7 && map[i*7+j] && map[i*7+j+1]){\n\t\t\t\t\tds.union(i*7+j, i*7+j+1);\n\t\t\t\t}\n\t\t\t\tif(i+1 < m/7 && map[i*7+j] && map[(i+1)*7+j]){\n\t\t\t\t\tds.union(i*7+j, (i+1)*7+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ct = 0;\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tif(ds.upper[i] < 0 && map[i]){\n\t\t\t\tct++;\n\t\t\t}\n\t\t}\n\t\treturn ct;\n\t}\n\t\n\tpublic static class DJSet {\n\t\tpublic int[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tpublic int root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tpublic boolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tpublic boolean union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (upper[y] < upper[x]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\tupper[x] += upper[y];\n\t\t\t\tupper[y] = x;\n\t\t\t}\n\t\t\treturn x == y;\n\t\t}\n\n\t\tpublic int count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : upper)\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\treturn ct;\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tlong n = nl();\n\t\tint m = ni();\n\t\tint q = ni();\n\t\tint[] a = na(q);\n\t\tif(m % 7 != 0){\n\t\t\ta = Arrays.copyOf(a, m*7);\n\t\t\tfor(int i = m;i < m*7;i++){\n\t\t\t\ta[i] = a[i-m] + m;\n\t\t\t}\n\t\t\tm *= 7;\n\t\t}\n\t\tboolean[] map = new boolean[m];\n\t\tArrays.fill(map, true);\n\t\tfor(int v : a)map[v] = false;\n\t\tint c1 = count(map);\n\t\t\n\t\tmap = new boolean[2*m];\n\t\tArrays.fill(map, true);\n\t\tfor(int v : a)map[v] = map[v+m] = false;\n\t\tint c2 = count(map);\n\t\tout.println(c1 + (c2-c1) * (7*n/m-1));\n\t}\n\t\n\tstatic int count(boolean[] map){\n\t\tint m = map.length;\n\t\tDJSet ds = new DJSet(m);\n\t\tfor(int i = 0;i < m/7;i++){\n\t\t\tfor(int j = 0;j < 7;j++){\n\t\t\t\tif(j+1 < 7 && map[i*7+j] && map[i*7+j+1]){\n\t\t\t\t\tds.union(i*7+j, i*7+j+1);\n\t\t\t\t}\n\t\t\t\tif(i+1 < m/7 && map[i*7+j] && map[(i+1)*7+j]){\n\t\t\t\t\tds.union(i*7+j, (i+1)*7+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ct = 0;\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tif(ds.upper[i] < 0 && map[i]){\n\t\t\t\tct++;\n\t\t\t}\n\t\t}\n\t\treturn ct;\n\t}\n\t\n\tpublic static class DJSet {\n\t\tpublic int[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tpublic int root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tpublic boolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tpublic boolean union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (upper[y] < upper[x]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\tupper[x] += upper[y];\n\t\t\t\tupper[y] = x;\n\t\t\t}\n\t\t\treturn x == y;\n\t\t}\n\n\t\tpublic int count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : upper)\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\treturn ct;\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\t\n\tstatic Scanner s=new Scanner(System.in);\n\t\n\t\n\tstatic int n,m,q,a[];\n\tpublic static void main(String[] __){\n\t\tinput();\n\t\t\n\t\tint b=a[a.length-1]-a[0],k=2;\n\t\tif(b<7) {\n\t\t\tSystem.out.println(1);\n\t\t\treturn;\n\t\t}else {\n\t\t\tif(a[0]==0)\n\t\t\t\tk--;\n\t\t\tif(a[a.length-1]==m-1)\n\t\t\t\tk--;\n\t\t\t\n\t\t\tSystem.out.println(7L*n/m*k);\n\t\t}\n\t}\n\t\n\t\n\t\n\tprivate static final void input(){;\n\t\tn=s.nextInt();\n\t\tm=s.nextInt();\n\t\tq=s.nextInt();\n\t\ta=new int[q];\n\t\tfor(int i=0;i<q;i++)\n\t\t\ta[i]=s.nextInt();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int[] a;\n\tstatic byte[] cells;\n\n\tpublic static void main(String args[]) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint m = scan.nextInt();\n\t\tint q = scan.nextInt();\n\t\ta = new int[q];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\ta[i] = scan.nextByte();\n\t\t}\n\t\tscan.close();\n\t\tcells = new byte[n * 7];\n\t\tfor (int i = 0; i < cells.length; i++) {\n\t\t\tcells[i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint b = 0;\n\t\t\twhile (m * b + a[i] < 7 * n) {\n\t\t\t\tcells[m * b + a[i]] |= 0x0001;\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor (int i = 0; i < 7 * n; i++) {\n\t\t\tif ((cells[i] & 0x0011) == 0 && countNextTo(i) > 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\n\tprivate static int countNextTo(int num) {\n\t\tif ((cells[num] & 0x0001) != 0 || (cells[num] & 0x0010) != 0 || num < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tint count = 0;\n\n\t\tif (num % 7 != 6 && num < cells.length - 1) {\n\t\t\tcount += (cells[num + 1] & 0x0011) == 0 ? countNextTo(num + 1) : 0;\n\t\t}\n\t\tif (cells.length - num > 7) {\n\t\t\tcount += (cells[num + 7] & 0x0011) == 0 ? countNextTo(num + 7) : 0;\n\t\t}\n\t\tcount++;\n\t\tcells[num] |= 0x0010;\n\t\treturn count;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tfinal long N = sc.nextLong();\n\t\t\tfinal int M = sc.nextInt();\n\t\t\tfinal int Q = sc.nextInt();\n\t\t\t\n\t\t\tif(M % 7 != 0){ throw new RuntimeException(); }\n\t\t\t\n\t\t\tboolean[] painted = new boolean[7];\n\t\t\tfor(int i = 0; i < Q; i++){\n\t\t\t\tpainted[sc.nextInt() % M] = true;\n\t\t\t}\n\t\t\t\n\t\t\tint blanks = 0;\n\t\t\tboolean prev_blank = false;\n\t\t\tfor(int i = 0; i < painted.length; i++){\n\t\t\t\tif(!painted[i] && !prev_blank){\n\t\t\t\t\tprev_blank = true;\n\t\t\t\t\tblanks++;\n\t\t\t\t}else if(painted[i]){\n\t\t\t\t\tprev_blank = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(blanks);\n\t\t}\n\t}\n\t\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n \n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n \n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n \n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tfinal int[] ret = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextInt();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tfinal long[] ret = new long[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextLong();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n \n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int[] a;\n\tstatic byte[] cells;\n\n\tpublic static void main(String args[]) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint m = scan.nextInt();\n\t\tint q = scan.nextInt();\n\t\ta = new int[q];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\ta[i] = scan.nextByte();\n\t\t}\n\t\tscan.close();\n\t\tcells = new byte[n * 7];\n\t\tfor (int i = 0; i < cells.length; i++) {\n\t\t\tcells[i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint b = 0;\n\t\t\twhile (m * b + a[i] < 7 * n) {\n\t\t\t\tcells[m * b + a[i]] |= 0x0001;\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor (int i = 0; i < 7 * n; i++) {\n\t\t\tif ((cells[i] & 0x0011) == 0 && countNextTo(i) > 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\n\tprivate static int countNextTo(int num) {\n\t\tif ((cells[num] & 0x0001) != 0 || (cells[num] & 0x0010) != 0||num<0) {\n\t\t\treturn 0;\n\t\t}\n\t\tint count = 0;\n//\t\tif (num % 7 != 0) {\n//\t\t\tcount += countNextTo(num - 1);\n//\t\t}\n\t\tif (num % 7 != 6 && num < cells.length - 1) {\n\t\t\tcount += countNextTo(num + 1);\n\t\t}\n//\t\tif (num > 6) {\n//\t\t\tcount += countNextTo(num - 7);\n//\t\t}\n\t\tif (cells.length - num > 7) {\n\t\t\tcount += countNextTo(num + 7);\n\t\t}\n\t\tcount++;\n\t\tcells[num] |= 0x0010;\n\t\t//System.out.println(count);\n\t\treturn count;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "package Atcoder;\n\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int[] a;\n\tstatic byte[] cells;\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint m = scan.nextInt();\n\t\tint q = scan.nextInt();\n\t\ta = new int[q];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\ta[i] = scan.nextByte();\n\t\t}\n\t\tscan.close();\n\t\tcells = new byte[n * 7];\n\t\tfor (int i = 0; i < cells.length; i++) {\n\t\t\tcells[i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint b = 0;\n\t\t\twhile (m * b + a[i] < 7 * n) {\n\t\t\t\tcells[m * b + a[i]] |= 0x0001;\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor (int i = 0; i < 7 * n; i++) {\n\t\t\tif ((cells[i] & 0x0011) == 0 && countNextTo(i) > 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\n\tprivate static int countNextTo(int num) {\n\t\tif ((cells[num] & 0x0001) != 0 || (cells[num] & 0x0010) != 0||num<0) {\n\t\t\treturn 0;\n\t\t}\n\t\tint count = 0;\n//\t\tif (num % 7 != 0) {\n//\t\t\tcount += countNextTo(num - 1);\n//\t\t}\n\t\tif (num % 7 != 6 && num < cells.length - 1) {\n\t\t\tcount += countNextTo(num + 1);\n\t\t}\n//\t\tif (num > 6) {\n//\t\t\tcount += countNextTo(num - 7);\n//\t\t}\n\t\tif (cells.length - num > 7) {\n\t\t\tcount += countNextTo(num + 7);\n\t\t}\n\t\tcount++;\n\t\tcells[num] |= 0x0010;\n\t\t//System.out.println(count);\n\t\treturn count;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static int N, M, Q;\n    static int[] A;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        N = sc.nextInt();\n        M = sc.nextInt();\n        Q = sc.nextInt();\n        A = new int[Q];\n        for (int i = 0; i < Q; i++) {\n            A[i] = sc.nextInt();\n        }\n        System.out.println(solve());\n    }\n\n    static long solve() {\n        if( M % 7 != 0 ) {\n            int[] B = new int[Q * 7];\n\n            for (int i = 0; i < 7; i++) {\n                for (int j = 0; j < Q; j++) {\n                    B[i*Q + j] = A[j] + i*M;\n                }\n            }\n\n            M *= 7;\n            Q *= 7;\n            A = B;\n        }\n\n//        System.out.println(N + \" \" + M + \" \" + Q);\n//        System.out.println( Arrays.toString(A) );\n\n        int c1 = count(1);\n        int c2 = count(2);\n\n        // c1 = a + b\n        // c2 = 2a + b\n        int a = c2 - c1;\n        int b = c1 - a;\n\n        return (long)a * (N / (M/7)) + b;\n    }\n\n    static int count(int z) {\n        boolean[][] marked = new boolean[z*M/7][7];\n\n        for (int i = 0; i < z; i++) {\n            for (int j = 0; j < Q; j++) {\n                int a = A[j];\n                int week = (a + i*M) / 7;\n                int day = (a + i*M) % 7;\n                marked[week][day] = true;\n            }\n        }\n\n//        System.out.println();\n//        for (boolean[] bool : marked) {\n//            System.out.println( Arrays.toString(bool) );\n//        }\n\n        int lastWeek = z * M / 7 - 1;\n        UnionFind uf = new UnionFind( z * M );\n        for (int i = 0; i < z * M; i++) {\n            int week = i / 7;\n            int day = i % 7;\n\n            if( day != 6 ) {\n                unite(uf, marked, week, day, week, day+1);\n            }\n\n            if( week != lastWeek ) {\n                unite(uf, marked, week, day, week+1, day);\n            }\n        }\n\n        Set<Integer> uniq = new HashSet<>();\n        for (int i = 0; i < z * M; i++) {\n            int week = i / 7;\n            int day = i % 7;\n\n            if( !marked[week][day] ) {\n                uniq.add( uf.root(i) );\n            }\n        }\n        return uniq.size();\n    }\n\n    static void unite(UnionFind uf, boolean[][] marked, int w1, int d1, int w2, int d2) {\n        if( !marked[w1][d1] && !marked[w2][d2] ) {\n            uf.unite( w1 * 7 + d1, w2 * 7 + d2);\n        }\n    }\n\n    static class UnionFind {\n\n        private final int[] parent;\n        private final int[] rank;\n\n        public UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n\n        public int root(int i) {\n            if( parent[i] == i ) {\n                return i;\n            } else {\n                return parent[i] = root(parent[i]);\n            }\n        }\n\n        public void unite(int i, int j) {\n            int ri = root(i);\n            int rj = root(j);\n            if( ri == rj ) return;\n\n            if( rank[ri] < rank[rj] ) {\n                parent[ri] = rj;\n\n            } else {\n                parent[rj] = ri;\n                if( rank[ri] == rank[rj] ) {\n                    rank[ri]++;\n                }\n            }\n        }\n\n        public boolean isSame(int a, int b) {\n            return root(a) == root(b);\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\tSol mySol =new Sol();\n\t\tmySol.Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tlong c7 = calc(7 * M);\n\t\tlong c14 = calc(14 * M);\n\t\tlong joint = c7 * 2 - c14;\n\t\tlong crest = calc((int) ((N * 7) % (M * 7)));\n\t\tlong ans = ((7 * N) / (7 * M)) * c7 + crest - ((7 * N) / (7 * M) - 1) * joint - ((N * 7) % (M * 7) != 0 ? 1 : 0) * joint;\n\t\tConsole.WriteLine(ans);\n\t}\n\t\n\tlong calc(int hw){\n\t\tif(hw == 0) return 0;\n\t\tint w = 7;\n\t\tint h = hw / w;\n\t\t\n\t\tint[][] m = new int[h][];\n\t\tfor(int i=0;i<h;i++) m[i] = new int[w];\n\t\t\n\t\tforeach(var r in A){\n\t\t\tfor(int j=r;j<hw;j+=M){\n\t\t\t\tm[j/w][j%w] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] dx = {0, 1, 0, -1};\n\t\tint[] dy = {1, 0, -1, 0};\n\t\tvar UF = new UnionFind(hw);\n\t\tfor(int i=0;i<hw;i++){\n\t\t\tint y = i / w;\n\t\t\tint x = i % w;\n\t\t\tfor(int t=0;t<4;t++){\n\t\t\t\tint ny = y + dy[t];\n\t\t\t\tint nx = x + dx[t];\n\t\t\t\tif(!InRange(ny, 0, h) || !InRange(nx, 0, w)) continue;\n\t\t\t\tif(m[ny][nx] == m[y][x]) UF.Unite(i, ny * w + nx);\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong ret = 0;\n\t\tfor(int i=0;i<hw;i++) if(UF.IsRoot(i) && m[i / w][i % w] == 0) ret++;\n\t\treturn ret;\n\t\t\n\t}\n\tbool InRange(int t, int l, int r){\n\t\treturn l <= t && t < r;\n\t}\n\t\n\tint M,Q;\n\tlong N;\n\tint[] A;\n\tpublic Sol(){\n\t\tvar d = rla();\n\t\tN = d[0]; M = (int) d[1]; Q = (int) d[2];\n\t\tA = ria();\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(char sep=' '){return Console.ReadLine().Split(sep);}\n\tstatic int[] ria(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>int.Parse(e));}\n\tstatic long[] rla(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>long.Parse(e));}\n\tstatic double[] rda(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>double.Parse(e));}\n}\nclass UnionFind{\n\t\n\tint[] parent;\n\tint[] mem;\n\tint compo;\n\tint N;\n\tpublic UnionFind(int n_){\n\t\tInitialize(n_);\n\t}\n\t\n\tpublic void Initialize(int n_){\n\t\tN=n_;\n\t\tparent=new int[N];\n\t\tmem=new int[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tparent[i]=i;\n\t\t\tmem[i]=1;\n\t\t}\n\t\tcompo=N;\n\t}\n\t\n\tpublic int Parent(int a){\n\t\tif(parent[a]==a)return a;\n\t\treturn parent[a]=Parent(parent[a]);\n\t}\n\t\n\tpublic bool IsUnited(int a,int b){\n\t\treturn Parent(a)==Parent(b);\n\t}\n\t\n\tpublic void Unite(int a,int b){\n\t\ta=Parent(a);b=Parent(b);//Parent()を呼ぶことでa以上のノードは全てparentがrootになる\n\t\tif(a==b)return;\n\t\tparent[a]=b;\n\t\tmem[b]+=mem[a];\n\t\tcompo-=1;\n\t}\n\t\n\tpublic bool IsRoot(int x){\n\t\treturn x==parent[x];\n\t}\n\tpublic int MemCnt(int x){\n\t\treturn mem[Parent(x)];\n\t}\n\t\n\tpublic void Dump(){\n\t\tfor(int i=0;i<parent.Length;i++){\n\t\t\tConsole.Write(i==0?\"{0}\":\" {0}\",parent[i]);\n\t\t}\n\t\tConsole.WriteLine(\"\");\n\t}\n\t\n\tpublic int Compo{\n\t\tget{\n\t\t\treturn compo;\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nclass Program\n{\nstatic string[] input = Console.ReadLine().Split(' ');\nstatic long n = long.Parse(input[0]);\nstatic long m = long.Parse(input[1]);\nstatic long q = long.Parse(input[2]);\nstatic long r = m;//行数\nstatic long c = 7;//列数\nstatic long[] nums = Array.ConvertAll(Console.ReadLine().Split(' '),long.Parse);\nstatic long numsCount = 0;\nstatic long[] startPosition = new long[2];//スタート座標\nstatic long[,] distances;//最短距離\nstatic Queue<long[]> que = new Queue<long[]>();//幅優先探索用のキュー\nstatic long[,] wallPositions;//壁は1\nstatic long[] VectorArrow = new long[8]{0,1,0,-1,1,0,-1,0};//上下左右に進む為のベクトル\nstatic long islandsCount = 0;//島の数\nstatic long islandsCountFirst = 0;\nstatic long islandsCountSecond = 0;\n\n\tstatic void Main()\n\t{\n\t\tif(m % 7 == 0) r /= 7;\n\n\t\tdistances = new long[2*r,c];\n\t\twallPositions = new long[2*r+4,c+2];\n  \n\t\tfor(long i = 0; i < r; i++)\n    {\n\t\t\tfor(long j = 0; j < c; j++)\n\t\t\t{\n\t\t\t\tif((7*i+j) % m == nums[numsCount])\n\t\t\t\t{\n\t\t\t\t\twallPositions[i+1,j+1] = 1;//壁の取得\n\t\t\t\t\tnumsCount++;\n\t\t\t\t\tnumsCount %= q;\n\t\t\t\t}else wallPositions[i+1,j+1] = 0;\n\t\t\t}\n    }\n\n    for(long i = 0; i < r+2; i++)//周囲を壁で埋める\n    {\n      wallPositions[i,0] = 1;\n      wallPositions[i,c+1] = 1;\n    }\n    for(long j = 0; j < c+2; j++)\n    {\n      wallPositions[0,j] = 1;\n      wallPositions[r+1,j] = 1;\n    }\n\n\t\tfor(long i = 0; i < r; i++)\n\t\t{\n\t\t\tfor(long j = 0; j < c; j++)\n\t\t\t{\n\t\t\t\tdistances[i,j] = long.MaxValue;//距離を無限と仮定\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < r; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < c; j++)\n\t\t\t{\n\t\t\t\tif(distances[i,j] == long.MaxValue && wallPositions[i+1,j+1] == 0)\n\t\t\t\t{\n\t\t\t\t\tislandsCount++;\n\t\t\t\t\tstartPosition[0] = i;\n\t\t\t\t\tstartPosition[1] = j;\n\t\t\t\t\t//Console.WriteLine(i+\" \"+j+\" \"+distances[i,j]);\n\t\t\t\t\tBFS(startPosition);//幅優先探索\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tislandsCountFirst = islandsCount;//１つ目の島\n\t\tislandsCount = 0;\n\t\tr *= 2;\n\t\tnumsCount = 0;\n\n\t\tfor(long i = 0; i < r; i++)\n    {\n\t\t\tfor(long j = 0; j < c; j++)\n\t\t\t{\n\t\t\t\tif((7*i+j) % m == nums[numsCount])\n\t\t\t\t{\n\t\t\t\t\twallPositions[i+1,j+1] = 1;//壁の取得\n\t\t\t\t\tnumsCount++;\n\t\t\t\t\tnumsCount %= q;\n\t\t\t\t}else wallPositions[i+1,j+1] = 0;\n\t\t\t}\n    }\n    for(long i = 0; i < r+2; i++)//周囲を壁で埋める\n    {\n      wallPositions[i,0] = 1;\n      wallPositions[i,c+1] = 1;\n    }\n    for(long j = 0; j < c+2; j++)\n    {\n      wallPositions[0,j] = 1;\n      wallPositions[r+1,j] = 1;\n    }\n\n\t\tfor(long i = 0; i < r; i++)\n\t\t{\n\t\t\tfor(long j = 0; j < c; j++)\n\t\t\t{\n\t\t\t\tdistances[i,j] = long.MaxValue;//距離を無限と仮定\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < r; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < c; j++)\n\t\t\t{\n\t\t\t\tif(distances[i,j] == long.MaxValue && wallPositions[i+1,j+1] == 0)\n\t\t\t\t{\n\t\t\t\t\tislandsCount++;\n\t\t\t\t\tstartPosition[0] = i;\n\t\t\t\t\tstartPosition[1] = j;\n\t\t\t\t\tBFS(startPosition);//幅優先探索\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tislandsCountSecond = islandsCount;\n\n\t\tr /= 2;\n\t\tlong a = islandsCountSecond - islandsCountFirst;\n\t\tlong b = islandsCountFirst - a;\n\t\tlong aa = n/r;\n\t\t//Console.WriteLine(islandsCountFirst + \" \" + islandsCountSecond);\n\t\tConsole.WriteLine(a*aa+b);\n    \n\t}\n\n  static void BFS(long[] startPosition)//幅優先探索。引数はスタートの座標。\n  {\n    que.Enqueue(startPosition);\n    \n    distances[startPosition[0], startPosition[1]] = 0;//スタート地点までの距離は0\n    long poppedMemoX = 0;\n    long poppedMemoY = 0;\n    while(que.Count > 0)\n    {\n      poppedMemoX = que.Peek()[0];\n      poppedMemoY = que.Peek()[1];\n      que.Dequeue();\n    \n      for(long partnerNum = 0; partnerNum < 4; partnerNum++)//上下左右に進みたい\n      {\n        long aimX = poppedMemoX+VectorArrow[2*partnerNum];\n        long aimY = poppedMemoY+VectorArrow[2*partnerNum+1];\n        if(wallPositions[aimX+1, aimY+1] == 1) continue;//壁なら無視\n        if(distances[aimX, aimY] != long.MaxValue) continue;//距離が確定済みなら無視\n        distances[aimX, aimY] = 1;//距離の加算\n        que.Enqueue(new long[2]{aimX, aimY});\n      }\n    }\n      /*\n      for(long i = 0; i < r; i++)//各点までの距離の表示\n      {\n        string answer = \"\";\n        for(long j = 0; j < c; j++)\n        {\n          if(wallPositions[i+1,j+1] == 1) answer += \"#\";\n          else answer += distances[i,j].ToString();\n        }\n        Console.WriteLine(answer);\n      }\n      */\n\n  }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n//    static Scan sc = new ScanCHK();\n    const int M = 1000000007;\n    const double eps = 1e-9;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        long n;\n        int m, q;\n        sc.Multi(out n, out m, out q);\n        var a = sc.IntArr;\n        var blk = new bool[m];\n        foreach (var item in a)\n        {\n            blk[item] = true;\n        }\n        if (m % 7 == 0)\n        {\n            var uf = new UnionFind(m);\n            for (int i = 0; i < m; i++)\n            {\n                if (!blk[i] && i % 7 < 6 && !blk[i + 1])\n                {\n                    uf.union(i, i + 1);\n                }\n                if (!blk[i] && i + 7 < m && !blk[i + 7])\n                {\n                    uf.union(i, i + 7);\n                }\n            }\n            long cnt = 0;\n            for (int i = 0; i < m; i++)\n            {\n                if (!blk[i] && uf.getpar(i) == i)\n                {\n                    ++cnt;\n                }\n            }\n            var uff = new UnionFind(m * 2);\n            for (int i = 0; i < 7; i++)\n            {\n                if (!blk[i] && !blk[m - 7 + i])\n                {\n                    uff.union(uf.getpar(i), uf.getpar(m - 7 + i) + m);\n                }\n            }\n            long dis = 0;\n            for (int i = 0; i < m * 2; i++)\n            {\n                if (uff.getpar(i) != i)\n                {\n                    ++dis;\n                }\n            }\n            DBG(n * 7 / m * cnt - (n * 7 / m - 1) * dis);\n            return;\n        }\n        else\n        {\n            var uf = new UnionFind(m * 7);\n            for (int i = 0; i < m * 7; i++)\n            {\n                if (!blk[i % m] && i % 7 < 6 && !blk[(i + 1) % m])\n                {\n                    uf.union(i, i + 1);\n                }\n                if (!blk[i % m] && i + 7 < m && !blk[(i + 7) % m])\n                {\n                    uf.union(i, i + 7);\n                }\n            }\n            long cnt = 0;\n            for (int i = 0; i < m * 7; i++)\n            {\n                if (!blk[i % m] && uf.getpar(i) == i)\n                {\n                    ++cnt;\n                }\n            }\n            var uff = new UnionFind(m * 14);\n            for (int i = 0; i < 7; i++)\n            {\n                if (!blk[i] && !blk[m - 7 + i])\n                {\n                    uff.union(uf.getpar(i), uf.getpar(m * 7 - 7 + i) + m * 7);\n                }\n            }\n            long dis = 0;\n            for (int i = 0; i < m * 14; i++)\n            {\n                if (uff.getpar(i) != i)\n                {\n                    ++dis;\n                }\n            }\n            DBG(n / m * cnt - (n / m - 1) * dis);\n            return;\n        }\n\n        sw.Flush();\n    }\n\n    static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    static T Max<T>(params T[] a) { return a.Max(); }\n    static T Min<T>(params T[] a) { return a.Min(); }\n    static void DBG(string a) { Console.WriteLine(a); }\n    static void DBG<T>(IEnumerable<T> a) { Console.WriteLine(string.Join(\" \", a)); }\n    static void DBG(params object[] a) { Console.WriteLine(string.Join(\" \", a)); }\n    static void Prt(string a) { sw.WriteLine(a); }\n    static void Prt<T>(IEnumerable<T> a) { sw.WriteLine(string.Join(\" \", a)); }\n    static void Prt(params object[] a) { sw.WriteLine(string.Join(\" \", a)); }\n}\nstatic class ex\n{\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a)\n    {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) { return Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile(); }\n    public static Func<T, T> Lambda(Unary op) { return Expression.Lambda<Func<T, T>>(op(x), x).Compile(); }\n}\n\nclass ScanCHK : Scan\n{\n    public new string Str { get { var s = Console.ReadLine(); if (s != s.Trim()) throw new Exception(); return s; } }\n}\nclass Scan\n{\n    public int Int { get { return int.Parse(Str); } }\n    public long Long { get { return long.Parse(Str); } }\n    public double Double { get { return double.Parse(Str); } }\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public int[] IntArr { get { return StrArr.Select(int.Parse).ToArray(); } }\n    public long[] LongArr { get { return StrArr.Select(long.Parse).ToArray(); } }\n    public double[] DoubleArr { get { return StrArr.Select(double.Parse).ToArray(); } }\n    public string[] StrArr { get { return Str.Split(); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                             : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                             : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                             : eq<T, char>()   ? ct<T, char>(s[0])\n                                               : ct<T, string>(s); }\n    public void Multi<T>(out T a) { a = cv<T>(Str); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\nclass mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a)\n    {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n)\n    {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n)\n    {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n)\n    {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n)\n    {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y)\n    {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static long dot(long[] x, long[] y)\n    {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A)\n    {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x)\n    {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x)\n    {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B)\n    {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y)\n    {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B)\n    {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b)\n    {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) { return pow(a, Mod - 2); }\n    public static long gcd(long a, long b)\n    {\n        while (b > 0) { var t = a % b; a = b; b = t; }\n        return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y)\n    {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n    public static long comb(int n, int r)\n    {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++)\n        {\n            int piv = denom[p - 1];\n            if (piv > 1)\n            {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n}\nclass UnionFind\n{\n    int n;\n    int[] par, num;\n    public UnionFind(int m)\n    {\n        n = m; par = new int[n]; num = new int[n];\n        for (int i = 0; i < n; ++i) { par[i] = i; num[i] = 1; }\n    }\n    int find(int x) => par[x] == x ? x : (par[x] = find(par[x]));\n    public bool isunion(int x, int y) => find(x) == find(y);\n    public int unionnum(int x) => num[find(x)];\n    public bool union(int x, int y)\n    {\n        int p = find(x), q = find(y);\n        if (p == q) return false;\n        par[q] = p; num[p] += num[q];\n        return true;\n    }\n    public int getpar(int x) => find(x);\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Linq;\nusing System.Collections;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Math;\n\nnamespace NotFounds\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var sw = new System.IO.StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            Console.SetOut(sw);\n            new Program().Solve(new MyInputStream(Console.In, ' '));\n            Console.Out.Flush();\n        }\n\n        public void Solve(MyInputStream cin)\n        {\n            var n = cin.ReadInt();\n            var m = cin.ReadInt();\n            var q = cin.ReadInt();\n            var a = cin.ReadIntArray(q);\n\n            var map = new bool[n, 7];\n            for (int k = 0; k < q; ++k)\n                for (int i = 0; i < n; ++i)\n                    for (int j = 0; j < 7; ++j)\n                        if ((7 * i + j) % m == a[k])\n                            map[i, j] = true;\n\n            var que = new Queue<Pair<int, int>>();\n            var visited = new bool[n, 7];\n            var cnt = 0;\n            var dxy = new int[] { 1, 0, -1, 0, 1 };\n            for (int i = 0; i < n; ++i)\n            {\n                for (int j = 0; j < 7; ++j)\n                {\n                    if (map[i, j] || visited[i, j]) continue;\n                    que.Enqueue(new Pair<int, int>(i, j));\n                    while (que.Any())\n                    {\n                        var now = que.Dequeue();\n                        var y = now.First;\n                        var x = now.Second;\n                        visited[y, x] = true;\n                        for (int k = 0; k < 4; ++k)\n                        {\n                            var nx = x + dxy[k];\n                            var ny = y + dxy[k + 1];\n                            if (nx < 0 || nx >= 7) continue;\n                            if (ny < 0 || ny >= n) continue;\n                            if (visited[ny, nx]) continue;\n                            if (map[ny, nx]) continue;\n                            //WriteLine($\"{x} {y}  {nx} {ny}\");\n                            que.Enqueue(new Pair<int, int>(ny, nx));\n                        }\n                    }\n                    //WriteLine($\"({i} {j}) : {visited[i, j]}\");\n                    cnt++;\n                }\n            }\n            WriteLine(cnt);\n        }\n    }\n\n    public class Pair<T1, T2> : IComparable<Pair<T1, T2>>\n        where T1 : IComparable<T1>\n        where T2 : IComparable<T2>\n    {\n        public T1 First;\n        public T2 Second;\n        public Pair() { First = default(T1); Second = default(T2); }\n        public Pair(T1 f, T2 s) { First = f; Second = s; }\n        public override string ToString() { return \"(\" + First + \", \" + Second + \")\"; }\n        public override int GetHashCode()\n        {\n            var f = First.GetHashCode();\n            var s = Second.GetHashCode();\n            return ((f << 5) + f) ^ s;\n        }\n        public override bool Equals(object obj)\n        {\n            if (ReferenceEquals(this, obj)) return true;\n            else if (obj == null) return false;\n            var tmp = obj as Pair<T1, T2>;\n            return (object)tmp != null && First.Equals(tmp.First) && Second.Equals(tmp.Second);\n        }\n        public int CompareTo(Pair<T1, T2> obj)\n        {\n            if (obj == null) return 1;\n            var ret = this.First.CompareTo(obj.First);\n            if (ret != 0) return ret;\n            else return this.Second.CompareTo(obj.Second);\n        }\n    }\n\n    public class MyInputStream\n    {\n        private readonly System.IO.TextReader _stream;\n        private char separator = ' ';\n        private Queue<string> inputStream;\n        public MyInputStream(System.IO.TextReader s, char separator = ' ')\n        {\n            this.separator = separator;\n            this._stream = s;\n            inputStream = new Queue<string>();\n        }\n        public string Read()\n        {\n            if (inputStream.Count != 0) return inputStream.Dequeue();\n            string[] tmp = _stream.ReadLine().Split(separator);\n            for (int i = 0; i < tmp.Length; ++i)\n                inputStream.Enqueue(tmp[i]);\n            return inputStream.Dequeue();\n        }\n        public string ReadLine() { return _stream.ReadLine(); }\n        public int ReadInt() { return int.Parse(Read()); }\n        public long ReadLong() { return long.Parse(Read()); }\n        public double ReadDouble() { return double.Parse(Read()); }\n        public string[] ReadStrArray(long N) { var ret = new string[N]; for (long i = 0; i < N; ++i) ret[i] = Read(); return ret;}\n        public int[] ReadIntArray(long N) { var ret = new int[N]; for (long i = 0; i < N; ++i) ret[i] = ReadInt(); return ret;}\n        public long[] ReadLongArray(long N) { var ret = new long[N]; for (long i = 0; i < N; ++i) ret[i] = ReadLong(); return ret;}\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n//    static Scan sc = new ScanCHK();\n    const int M = 1000000007;\n    const double eps = 1e-9;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        long n;\n        int m, q;\n        sc.Multi(out n, out m, out q);\n        var a = sc.IntArr;\n        var blk = new bool[m];\n        foreach (var item in a)\n        {\n            blk[item] = true;\n        }\n        if (m % 7 == 0)\n        {\n            var uf = new UnionFind(m);\n            for (int i = 0; i < m; i++)\n            {\n                if (!blk[i] && i % 7 < 6 && !blk[i + 1])\n                {\n                    uf.union(i, i + 1);\n                }\n                if (!blk[i] && i + 7 < m && !blk[i + 7])\n                {\n                    uf.union(i, i + 7);\n                }\n            }\n            long cnt = 0;\n            for (int i = 0; i < m; i++)\n            {\n                if (!blk[i] && uf.getpar(i) == i)\n                {\n                    ++cnt;\n                }\n            }\n            var uff = new UnionFind(m * 2);\n            for (int i = 0; i < 7; i++)\n            {\n                if (!blk[i] && !blk[m - 7 + i])\n                {\n                    uff.union(uf.getpar(i), uf.getpar(m - 7 + i) + m);\n                }\n            }\n            long dis = 0;\n            for (int i = 0; i < m * 2; i++)\n            {\n                if (uff.getpar(i) != i)\n                {\n                    ++dis;\n                }\n            }\n            DBG(n * 7 / m * cnt - (n * 7 / m - 1) * dis);\n            return;\n        }\n        else\n        {\n            var uf = new UnionFind(m * 7);\n            for (int i = 0; i < m * 7; i++)\n            {\n                if (!blk[i % m] && i % 7 < 6 && !blk[(i + 1) % m])\n                {\n                    uf.union(i, i + 1);\n                }\n                if (!blk[i % m] && i + 7 < m * 7 && !blk[(i + 7) % m])\n                {\n                    uf.union(i, i + 7);\n                }\n            }\n            long cnt = 0;\n            for (int i = 0; i < m * 7; i++)\n            {\n                if (!blk[i % m] && uf.getpar(i) == i)\n                {\n                    ++cnt;\n                }\n            }\n            var uff = new UnionFind(m * 14);\n            for (int i = 0; i < 7; i++)\n            {\n                if (!blk[i % m] && !blk[(m * 7 - 7 + i) % m])\n                {\n                    uff.union(uf.getpar(i), uf.getpar(m * 7 - 7 + i) + m * 7);\n                }\n            }\n            long dis = 0;\n            for (int i = 0; i < m * 14; i++)\n            {\n                if (uff.getpar(i) != i)\n                {\n                    ++dis;\n                }\n            }\n            DBG(n / m * cnt - (n / m - 1) * dis);\n            return;\n        }\n\n        sw.Flush();\n    }\n\n    static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    static T Max<T>(params T[] a) { return a.Max(); }\n    static T Min<T>(params T[] a) { return a.Min(); }\n    static void DBG(string a) { Console.WriteLine(a); }\n    static void DBG<T>(IEnumerable<T> a) { Console.WriteLine(string.Join(\" \", a)); }\n    static void DBG(params object[] a) { Console.WriteLine(string.Join(\" \", a)); }\n    static void Prt(string a) { sw.WriteLine(a); }\n    static void Prt<T>(IEnumerable<T> a) { sw.WriteLine(string.Join(\" \", a)); }\n    static void Prt(params object[] a) { sw.WriteLine(string.Join(\" \", a)); }\n}\nstatic class ex\n{\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a)\n    {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) { return Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile(); }\n    public static Func<T, T> Lambda(Unary op) { return Expression.Lambda<Func<T, T>>(op(x), x).Compile(); }\n}\n\nclass ScanCHK : Scan\n{\n    public new string Str { get { var s = Console.ReadLine(); if (s != s.Trim()) throw new Exception(); return s; } }\n}\nclass Scan\n{\n    public int Int { get { return int.Parse(Str); } }\n    public long Long { get { return long.Parse(Str); } }\n    public double Double { get { return double.Parse(Str); } }\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public int[] IntArr { get { return StrArr.Select(int.Parse).ToArray(); } }\n    public long[] LongArr { get { return StrArr.Select(long.Parse).ToArray(); } }\n    public double[] DoubleArr { get { return StrArr.Select(double.Parse).ToArray(); } }\n    public string[] StrArr { get { return Str.Split(); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                             : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                             : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                             : eq<T, char>()   ? ct<T, char>(s[0])\n                                               : ct<T, string>(s); }\n    public void Multi<T>(out T a) { a = cv<T>(Str); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\nclass mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a)\n    {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n)\n    {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n)\n    {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n)\n    {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n)\n    {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y)\n    {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static long dot(long[] x, long[] y)\n    {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A)\n    {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x)\n    {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x)\n    {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B)\n    {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y)\n    {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B)\n    {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b)\n    {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) { return pow(a, Mod - 2); }\n    public static long gcd(long a, long b)\n    {\n        while (b > 0) { var t = a % b; a = b; b = t; }\n        return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y)\n    {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n    public static long comb(int n, int r)\n    {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++)\n        {\n            int piv = denom[p - 1];\n            if (piv > 1)\n            {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n}\nclass UnionFind\n{\n    int n;\n    int[] par, num;\n    public UnionFind(int m)\n    {\n        n = m; par = new int[n]; num = new int[n];\n        for (int i = 0; i < n; ++i) { par[i] = i; num[i] = 1; }\n    }\n    int find(int x) => par[x] == x ? x : (par[x] = find(par[x]));\n    public bool isunion(int x, int y) => find(x) == find(y);\n    public int unionnum(int x) => num[find(x)];\n    public bool union(int x, int y)\n    {\n        int p = find(x), q = find(y);\n        if (p == q) return false;\n        par[q] = p; num[p] += num[q];\n        return true;\n    }\n    public int getpar(int x) => find(x);\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nclass Program\n{\nstatic string[] input = Console.ReadLine().Split(' ');\nstatic long n = long.Parse(input[0]);\nstatic long m = long.Parse(input[1]);\nstatic long q = long.Parse(input[2]);\nstatic long r = m;//行数\nstatic long c = 7;//列数\nstatic long[] nums = Array.ConvertAll(Console.ReadLine().Split(' '),long.Parse);\nstatic long numsCount = 0;\nstatic long[] startPosition = new long[2];//スタート座標\nstatic long[,] distances = new long[2*r,c];//最短距離\nstatic Queue<long[]> que = new Queue<long[]>();//幅優先探索用のキュー\nstatic long[,] wallPositions = new long[2*r+4,c+2];//壁は1\nstatic long[] VectorArrow = new long[8]{0,1,0,-1,1,0,-1,0};//上下左右に進む為のベクトル\nstatic long islandsCount = 0;//島の数\nstatic long islandsCountFirst = 0;\nstatic long islandsCountSecond = 0;\n\n\tstatic void Main()\n\t{\n\t\tif(r % 7 != 0) r *= 7;\n  \n\t\tfor(long i = 0; i < r; i++)\n    {\n\t\t\tfor(long j = 0; j < c; j++)\n\t\t\t{\n\t\t\t\tif((7*i+j) % m == nums[numsCount])\n\t\t\t\t{\n\t\t\t\t\twallPositions[i+1,j+1] = 1;//壁の取得\n\t\t\t\t\tnumsCount++;\n\t\t\t\t\tnumsCount %= q;\n\t\t\t\t}else wallPositions[i+1,j+1] = 0;\n\t\t\t}\n    }\n\n    for(long i = 0; i < r+2; i++)//周囲を壁で埋める\n    {\n      wallPositions[i,0] = 1;\n      wallPositions[i,c+1] = 1;\n    }\n    for(long j = 0; j < c+2; j++)\n    {\n      wallPositions[0,j] = 1;\n      wallPositions[r+1,j] = 1;\n    }\n\n\t\tfor(long i = 0; i < r; i++)\n\t\t{\n\t\t\tfor(long j = 0; j < c; j++)\n\t\t\t{\n\t\t\t\tdistances[i,j] = long.MaxValue;//距離を無限と仮定\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < r; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < c; j++)\n\t\t\t{\n\t\t\t\tif(distances[i,j] == long.MaxValue && wallPositions[i+1,j+1] == 0)\n\t\t\t\t{\n\t\t\t\t\tislandsCount++;\n\t\t\t\t\tstartPosition[0] = i;\n\t\t\t\t\tstartPosition[1] = j;\n\t\t\t\t\tBFS(startPosition);//幅優先探索\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tislandsCountFirst = islandsCount;//１つ目の島\n\t\tr *= 2;\n\t\tnumsCount = 0;\n\n\t\tfor(long i = 0; i < r; i++)\n    {\n\t\t\tfor(long j = 0; j < c; j++)\n\t\t\t{\n\t\t\t\tif((7*i+j) % m == nums[numsCount])\n\t\t\t\t{\n\t\t\t\t\twallPositions[i+1,j+1] = 1;//壁の取得\n\t\t\t\t\tnumsCount++;\n\t\t\t\t\tnumsCount %= q;\n\t\t\t\t}else wallPositions[i+1,j+1] = 0;\n\t\t\t}\n    }\n    for(long i = 0; i < r+2; i++)//周囲を壁で埋める\n    {\n      wallPositions[i,0] = 1;\n      wallPositions[i,c+1] = 1;\n    }\n    for(long j = 0; j < c+2; j++)\n    {\n      wallPositions[0,j] = 1;\n      wallPositions[r+1,j] = 1;\n    }\n\n\t\tfor(long i = 0; i < r; i++)\n\t\t{\n\t\t\tfor(long j = 0; j < c; j++)\n\t\t\t{\n\t\t\t\tdistances[i,j] = long.MaxValue;//距離を無限と仮定\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < r; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < c; j++)\n\t\t\t{\n\t\t\t\tif(distances[i,j] == long.MaxValue && wallPositions[i+1,j+1] == 0)\n\t\t\t\t{\n\t\t\t\t\tislandsCount++;\n\t\t\t\t\tstartPosition[0] = i;\n\t\t\t\t\tstartPosition[1] = j;\n\t\t\t\t\tBFS(startPosition);//幅優先探索\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tislandsCountSecond = islandsCount;\n\n\t\tr /= 2;\n\t\tlong a = islandsCountSecond - islandsCountFirst;\n\t\tlong b = islandsCountFirst - a;\n\t\tlong aa = n/r;\n\t\tConsole.WriteLine(a*aa+b);\n    \n\t}\n\n  static void BFS(long[] startPosition)//幅優先探索。引数はスタートの座標。\n  {\n    que.Enqueue(startPosition);\n    \n    distances[startPosition[0], startPosition[1]] = 0;//スタート地点までの距離は0\n    long poppedMemoX = 0;\n    long poppedMemoY = 0;\n    while(que.Count > 0)\n    {\n      poppedMemoX = que.Peek()[0];\n      poppedMemoY = que.Peek()[1];\n      que.Dequeue();\n    \n      for(long partnerNum = 0; partnerNum < 4; partnerNum++)//上下左右に進みたい\n      {\n        long aimX = poppedMemoX+VectorArrow[2*partnerNum];\n        long aimY = poppedMemoY+VectorArrow[2*partnerNum+1];\n        if(wallPositions[aimX+1, aimY+1] == 1) continue;//壁なら無視\n        if(distances[aimX, aimY] != long.MaxValue) continue;//距離が確定済みなら無視\n        distances[aimX, aimY] = distances[poppedMemoX, poppedMemoY] + 1;//距離の加算\n        que.Enqueue(new long[2]{aimX, aimY});\n      }\n    }\n      /*\n      for(long i = 0; i < r; i++)//各点までの距離の表示\n      {\n        string answer = \"\";\n        for(long j = 0; j < c; j++)\n        {\n          if(wallPositions[i+1,j+1] == 1) answer += \"#\";\n          else answer += distances[i,j].ToString();\n        }\n        Console.WriteLine(answer);\n      }\n      */\n\n  }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n//    static Scan sc = new ScanCHK();\n    const int M = 1000000007;\n    const double eps = 1e-9;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        long n;\n        int m, q;\n        sc.Multi(out n, out m, out q);\n        var a = sc.IntArr;\n        var blk = new bool[m];\n        foreach (var item in a)\n        {\n            blk[item] = true;\n        }\n        if (m % 7 == 0)\n        {\n            var uf = new UnionFind(m);\n            for (int i = 0; i < m; i++)\n            {\n                if (!blk[i] && i % 7 < 6 && !blk[i + 1])\n                {\n                    uf.union(i, i + 1);\n                }\n                if (!blk[i] && i + 7 < m && !blk[i + 7])\n                {\n                    uf.union(i, i + 7);\n                }\n            }\n            long cnt = 0;\n            for (int i = 0; i < m; i++)\n            {\n                if (!blk[i] && uf.getpar(i) == i)\n                {\n                    ++cnt;\n                }\n            }\n            var uff = new UnionFind(m * 2);\n            for (int i = 0; i < 7; i++)\n            {\n                if (!blk[i] && !blk[m - 7 + i])\n                {\n                    uff.union(uf.getpar(i), uf.getpar(m - 7 + i) + m);\n                }\n            }\n            long dis = 0;\n            for (int i = 0; i < m * 2; i++)\n            {\n                if (uff.getpar(i) != i)\n                {\n                    ++dis;\n                }\n            }\n            DBG(n * 7 / m * cnt - (n * 7 / m - 1) * dis);\n            return;\n        }\n        else\n        {\n            var uf = new UnionFind(m * 7);\n            for (int i = 0; i < m * 7; i++)\n            {\n                if (!blk[i % m] && i % 7 < 6 && !blk[(i + 1) % m])\n                {\n                    uf.union(i, i + 1);\n                }\n                if (!blk[i % m] && !blk[(i + 7) % m])\n                {\n                    uf.union(i, i + 7);\n                }\n            }\n            long cnt = 0;\n            for (int i = 0; i < m * 7; i++)\n            {\n                if (!blk[i % m] && uf.getpar(i) == i)\n                {\n                    ++cnt;\n                }\n            }\n            var uff = new UnionFind(m * 14);\n            for (int i = 0; i < 7; i++)\n            {\n                if (!blk[i % m] && !blk[(m * 7 - 7 + i) % m])\n                {\n                    uff.union(uf.getpar(i), uf.getpar(m * 7 - 7 + i) + m * 7);\n                }\n            }\n            long dis = 0;\n            for (int i = 0; i < m * 14; i++)\n            {\n                if (uff.getpar(i) != i)\n                {\n                    ++dis;\n                }\n            }\n            DBG(n / m * cnt - (n / m - 1) * dis);\n            return;\n        }\n\n        sw.Flush();\n    }\n\n    static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    static T Max<T>(params T[] a) { return a.Max(); }\n    static T Min<T>(params T[] a) { return a.Min(); }\n    static void DBG(string a) { Console.WriteLine(a); }\n    static void DBG<T>(IEnumerable<T> a) { Console.WriteLine(string.Join(\" \", a)); }\n    static void DBG(params object[] a) { Console.WriteLine(string.Join(\" \", a)); }\n    static void Prt(string a) { sw.WriteLine(a); }\n    static void Prt<T>(IEnumerable<T> a) { sw.WriteLine(string.Join(\" \", a)); }\n    static void Prt(params object[] a) { sw.WriteLine(string.Join(\" \", a)); }\n}\nstatic class ex\n{\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a)\n    {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) { return Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile(); }\n    public static Func<T, T> Lambda(Unary op) { return Expression.Lambda<Func<T, T>>(op(x), x).Compile(); }\n}\n\nclass ScanCHK : Scan\n{\n    public new string Str { get { var s = Console.ReadLine(); if (s != s.Trim()) throw new Exception(); return s; } }\n}\nclass Scan\n{\n    public int Int { get { return int.Parse(Str); } }\n    public long Long { get { return long.Parse(Str); } }\n    public double Double { get { return double.Parse(Str); } }\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public int[] IntArr { get { return StrArr.Select(int.Parse).ToArray(); } }\n    public long[] LongArr { get { return StrArr.Select(long.Parse).ToArray(); } }\n    public double[] DoubleArr { get { return StrArr.Select(double.Parse).ToArray(); } }\n    public string[] StrArr { get { return Str.Split(); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                             : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                             : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                             : eq<T, char>()   ? ct<T, char>(s[0])\n                                               : ct<T, string>(s); }\n    public void Multi<T>(out T a) { a = cv<T>(Str); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\nclass mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a)\n    {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n)\n    {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n)\n    {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n)\n    {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n)\n    {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y)\n    {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static long dot(long[] x, long[] y)\n    {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A)\n    {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x)\n    {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x)\n    {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B)\n    {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y)\n    {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B)\n    {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b)\n    {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) { return pow(a, Mod - 2); }\n    public static long gcd(long a, long b)\n    {\n        while (b > 0) { var t = a % b; a = b; b = t; }\n        return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y)\n    {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n    public static long comb(int n, int r)\n    {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++)\n        {\n            int piv = denom[p - 1];\n            if (piv > 1)\n            {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n}\nclass UnionFind\n{\n    int n;\n    int[] par, num;\n    public UnionFind(int m)\n    {\n        n = m; par = new int[n]; num = new int[n];\n        for (int i = 0; i < n; ++i) { par[i] = i; num[i] = 1; }\n    }\n    int find(int x) => par[x] == x ? x : (par[x] = find(par[x]));\n    public bool isunion(int x, int y) => find(x) == find(y);\n    public int unionnum(int x) => num[find(x)];\n    public bool union(int x, int y)\n    {\n        int p = find(x), q = find(y);\n        if (p == q) return false;\n        par[q] = p; num[p] += num[q];\n        return true;\n    }\n    public int getpar(int x) => find(x);\n}\n"
  },
  {
    "language": "Lisp",
    "code": "#-swank\n(unless (member :child-sbcl *features*)\n  (quit\n   :unix-status\n   (process-exit-code\n    (run-program *runtime-pathname*\n                 `(\"--control-stack-size\" \"128MB\"\n                   \"--noinform\" \"--disable-ldb\" \"--lose-on-corruption\" \"--end-runtime-options\"\n                   \"--eval\" \"(push :child-sbcl *features*)\"\n                   \"--script\" ,(namestring *load-pathname*))\n                 :output t :error t :input t))))\n(in-package :cl-user)\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(defconstant +mod+ 1000000007)\n\n(defmacro dbg (&rest forms)\n  #+swank (if (= (length forms) 1)\n              `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n              `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n;; BEGIN_INSERTED_CONTENTS\n(defpackage :cp/println-matrix\n  (:use :cl)\n  (:export #:println-matrix))\n(in-package :cp/println-matrix)\n\n(declaim (inline println-matrix))\n(defun println-matrix (array &key (separator #\\ ) (key #'identity) (writer #'write) (row-start 0) row-end (col-start 0) col-end)\n  \"Prints a 2-dimensional array.\"\n  (declare ((array * (* *)) array)\n           ((integer 0 #.most-positive-fixnum) row-start col-start))\n  (let ((row-end (or row-end (array-dimension array 0)))\n        (col-end (or col-end (array-dimension array 1))))\n    (declare ((integer 0 #.most-positive-fixnum) row-end col-end))\n    (loop for i from row-start below row-end\n          do (loop for j from col-start below col-end\n                   unless (= j col-start)\n                   do (princ separator)\n                   do (funcall writer (funcall key (aref array i j))))\n             (terpri))))\n\n;; BEGIN_USE_PACKAGE\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (use-package :cp/println-matrix :cl-user))\n(in-package :cl-user)\n\n;;;\n;;; Body\n;;;\n\n(defun test (n m &rest as)\n  (let ((matrix (make-array (list n 7) :element-type 'base-char :initial-element #\\.)))\n    (dotimes (i (* n 7))\n      (when (member (mod i m) as)\n        (setf (row-major-aref matrix i) #\\#)))\n    (println-matrix matrix :separator \"\" :writer #'write-char)))\n\n(defun solve-small (n m as)\n  (declare (uint31 n m)\n           ((simple-array uint31 (*)) as))\n  (let ((plan (make-array (list n 7) :element-type 'bit :initial-element 0))\n        (res 0))\n    (declare (uint62 res))\n    (loop for a across as\n          do (loop for i from a below (* n 7) by m\n                   do (setf (row-major-aref plan i) 1)))\n    (dotimes (i n)\n      (dotimes (j 7)\n        (when (zerop (aref plan i j))\n          (sb-int:named-let dfs ((i i) (j j))\n            (labels ((visit (y x)\n                       (when (and (<= 0 y (- n 1))\n                                  (<= 0 x 6))\n                         (dfs y x))))\n              (when (zerop (aref plan i j))\n                (setf (aref plan i j) 1)\n                (visit (- i 1) j)\n                (visit (+ i 1) j)\n                (visit i (- j 1))\n                (visit i (+ j 1)))))\n          (incf res))))\n    res))\n\n(defun main ()\n  (let* ((n (read))\n         (m (read))\n         (q (read))\n         (as (make-array q :element-type 'uint31 :initial-element 0)))\n    (dotimes (i q)\n      (setf (aref as i) (read-fixnum)))\n    (println\n     (cond\n       ((zerop (mod m 7))\n        (let* ((period (floor m 7))\n               (term1 (solve-small period m as))\n               (term2 (solve-small (* 2 period) m as))\n               (coef (- term2 term1))\n               (intercept (- term1 coef)))\n          (multiple-value-bind (quot rem) (floor n period)\n            (dbg coef intercept)\n            (+ intercept (* quot coef)\n               (- (solve-small (+ period rem) m as) term1)))))\n       ((<= n 10000)\n        (solve1 n m as))\n       (t (error \"Huh?\"))))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    #+os-windows (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)\n    #+os-unix (run-program \"xsel\" '(\"-b\" \"-o\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let* ((*standard-output* (or out (make-string-output-stream)))\n         (res (etypecase thing\n                (null\n                 (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n                   (main)))\n                (string\n                 (with-input-from-string (*standard-input* (delete #\\Return thing))\n                   (main)))\n                (symbol (5am:run! thing))\n                (pathname\n                 (with-open-file (*standard-input* thing)\n                   (main))))))\n    (if out res (get-output-stream-string *standard-output*))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (equal \"4\n\"\n          (run \"7 7 3\n1 3 5\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"10\n\"\n          (run \"10 14 8\n5 6 7 8 9 10 11 12\n\" nil))))\n"
  },
  {
    "language": "Lisp",
    "code": "#-swank\n(unless (member :child-sbcl *features*)\n  (quit\n   :unix-status\n   (process-exit-code\n    (run-program *runtime-pathname*\n                 `(\"--control-stack-size\" \"128MB\"\n                   \"--noinform\" \"--disable-ldb\" \"--lose-on-corruption\" \"--end-runtime-options\"\n                   \"--eval\" \"(push :child-sbcl *features*)\"\n                   \"--script\" ,(namestring *load-pathname*))\n                 :output t :error t :input t))))\n(in-package :cl-user)\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(defconstant +mod+ 1000000007)\n\n(defmacro dbg (&rest forms)\n  #+swank (if (= (length forms) 1)\n              `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n              `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n;; BEGIN_INSERTED_CONTENTS\n(defpackage :cp/println-matrix\n  (:use :cl)\n  (:export #:println-matrix))\n(in-package :cp/println-matrix)\n\n(declaim (inline println-matrix))\n(defun println-matrix (array &key (separator #\\ ) (key #'identity) (writer #'write) (row-start 0) row-end (col-start 0) col-end)\n  \"Prints a 2-dimensional array.\"\n  (declare ((array * (* *)) array)\n           ((integer 0 #.most-positive-fixnum) row-start col-start))\n  (let ((row-end (or row-end (array-dimension array 0)))\n        (col-end (or col-end (array-dimension array 1))))\n    (declare ((integer 0 #.most-positive-fixnum) row-end col-end))\n    (loop for i from row-start below row-end\n          do (loop for j from col-start below col-end\n                   unless (= j col-start)\n                   do (princ separator)\n                   do (funcall writer (funcall key (aref array i j))))\n             (terpri))))\n\n(defpackage :cp/read-fixnum\n  (:use :cl)\n  (:export #:read-fixnum))\n(in-package :cp/read-fixnum)\n\n(declaim (ftype (function * (values fixnum &optional)) read-fixnum))\n(defun read-fixnum (&optional (in *standard-input*))\n  \"NOTE: cannot read -2^62\"\n  (macrolet ((%read-byte ()\n               `(the (unsigned-byte 8)\n                     #+swank (char-code (read-char in nil #\\Nul))\n                     #-swank (sb-impl::ansi-stream-read-byte in nil #.(char-code #\\Nul) nil))))\n    (let* ((minus nil)\n           (result (loop (let ((byte (%read-byte)))\n                           (cond ((<= 48 byte 57)\n                                  (return (- byte 48)))\n                                 ((zerop byte) ; #\\Nul\n                                  (error \"Read EOF or #\\Nul.\"))\n                                 ((= byte #.(char-code #\\-))\n                                  (setq minus t)))))))\n      (declare ((integer 0 #.most-positive-fixnum) result))\n      (loop\n        (let* ((byte (%read-byte)))\n          (if (<= 48 byte 57)\n              (setq result (+ (- byte 48)\n                              (* 10 (the (integer 0 #.(floor most-positive-fixnum 10))\n                                         result))))\n              (return (if minus (- result) result))))))))\n\n;; BEGIN_USE_PACKAGE\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (use-package :cp/read-fixnum :cl-user))\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (use-package :cp/println-matrix :cl-user))\n(in-package :cl-user)\n\n;;;\n;;; Body\n;;;\n\n(defun test (n m &rest as)\n  (let ((matrix (make-array (list n 7) :element-type 'base-char :initial-element #\\.)))\n    (dotimes (i (* n 7))\n      (when (member (mod i m) as)\n        (setf (row-major-aref matrix i) #\\#)))\n    (println-matrix matrix :separator \"\" :writer #'write-char)))\n\n(defun solve-small (n m as)\n  (declare #.cl-user::opt\n           ((integer 0 #.(expt 10 12)) n m)\n           ((simple-array uint31 (*)) as))\n  (let ((plan (make-array (list n 7) :element-type 'bit :initial-element 0))\n        (res 0))\n    (declare (uint62 res))\n    (loop for a across as\n          do (loop for i from a below (* n 7) by m\n                   do (setf (row-major-aref plan i) 1)))\n    (dotimes (i n)\n      (dotimes (j 7)\n        (when (zerop (aref plan i j))\n          (sb-int:named-let dfs ((i i) (j j))\n            (labels ((visit (y x)\n                       (when (and (<= 0 y (- n 1))\n                                  (<= 0 x 6))\n                         (dfs y x))))\n              (when (zerop (aref plan i j))\n                (setf (aref plan i j) 1)\n                (visit (- i 1) j)\n                (visit (+ i 1) j)\n                (visit i (- j 1))\n                (visit i (+ j 1)))))\n          (incf res))))\n    res))\n\n(defun main ()\n  (let* ((n (read))\n         (m (read))\n         (q (read))\n         (as (make-array q :element-type 'uint31 :initial-element 0)))\n    (dotimes (i q)\n      (setf (aref as i) (read-fixnum)))\n    (println\n     (cond\n       ((zerop (mod m 7))\n        (let* ((period (floor m 7))\n               (term1 (solve-small period m as))\n               (term2 (solve-small (* 2 period) m as))\n               (coef (- term2 term1))\n               (intercept (- term1 coef)))\n          (multiple-value-bind (quot rem) (floor n period)\n            (dbg coef intercept)\n            (+ intercept (* quot coef)\n               (- (solve-small (+ period rem) m as) term1)))))\n       ((<= n 100000)\n        (solve-small n m as))\n       (t (error \"Huh?\"))))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    #+os-windows (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)\n    #+os-unix (run-program \"xsel\" '(\"-b\" \"-o\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let* ((*standard-output* (or out (make-string-output-stream)))\n         (res (etypecase thing\n                (null\n                 (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n                   (main)))\n                (string\n                 (with-input-from-string (*standard-input* (delete #\\Return thing))\n                   (main)))\n                (symbol (5am:run! thing))\n                (pathname\n                 (with-open-file (*standard-input* thing)\n                   (main))))))\n    (if out res (get-output-stream-string *standard-output*))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (equal \"4\n\"\n          (run \"7 7 3\n1 3 5\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"10\n\"\n          (run \"10 14 8\n5 6 7 8 9 10 11 12\n\" nil))))\n"
  },
  {
    "language": "Lisp",
    "code": "#-swank\n(unless (member :child-sbcl *features*)\n  (quit\n   :unix-status\n   (process-exit-code\n    (run-program *runtime-pathname*\n                 `(\"--control-stack-size\" \"128MB\"\n                   \"--noinform\" \"--disable-ldb\" \"--lose-on-corruption\" \"--end-runtime-options\"\n                   \"--eval\" \"(push :child-sbcl *features*)\"\n                   \"--script\" ,(namestring *load-pathname*))\n                 :output t :error t :input t))))\n(in-package :cl-user)\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(defconstant +mod+ 1000000007)\n\n(defmacro dbg (&rest forms)\n  #+swank (if (= (length forms) 1)\n              `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n              `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n;; BEGIN_INSERTED_CONTENTS\n(defpackage :cp/println-matrix\n  (:use :cl)\n  (:export #:println-matrix))\n(in-package :cp/println-matrix)\n\n(declaim (inline println-matrix))\n(defun println-matrix (array &key (separator #\\ ) (key #'identity) (writer #'write) (row-start 0) row-end (col-start 0) col-end)\n  \"Prints a 2-dimensional array.\"\n  (declare ((array * (* *)) array)\n           ((integer 0 #.most-positive-fixnum) row-start col-start))\n  (let ((row-end (or row-end (array-dimension array 0)))\n        (col-end (or col-end (array-dimension array 1))))\n    (declare ((integer 0 #.most-positive-fixnum) row-end col-end))\n    (loop for i from row-start below row-end\n          do (loop for j from col-start below col-end\n                   unless (= j col-start)\n                   do (princ separator)\n                   do (funcall writer (funcall key (aref array i j))))\n             (terpri))))\n\n(defpackage :cp/read-fixnum\n  (:use :cl)\n  (:export #:read-fixnum))\n(in-package :cp/read-fixnum)\n\n(declaim (ftype (function * (values fixnum &optional)) read-fixnum))\n(defun read-fixnum (&optional (in *standard-input*))\n  \"NOTE: cannot read -2^62\"\n  (macrolet ((%read-byte ()\n               `(the (unsigned-byte 8)\n                     #+swank (char-code (read-char in nil #\\Nul))\n                     #-swank (sb-impl::ansi-stream-read-byte in nil #.(char-code #\\Nul) nil))))\n    (let* ((minus nil)\n           (result (loop (let ((byte (%read-byte)))\n                           (cond ((<= 48 byte 57)\n                                  (return (- byte 48)))\n                                 ((zerop byte) ; #\\Nul\n                                  (error \"Read EOF or #\\Nul.\"))\n                                 ((= byte #.(char-code #\\-))\n                                  (setq minus t)))))))\n      (declare ((integer 0 #.most-positive-fixnum) result))\n      (loop\n        (let* ((byte (%read-byte)))\n          (if (<= 48 byte 57)\n              (setq result (+ (- byte 48)\n                              (* 10 (the (integer 0 #.(floor most-positive-fixnum 10))\n                                         result))))\n              (return (if minus (- result) result))))))))\n\n;; BEGIN_USE_PACKAGE\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (use-package :cp/read-fixnum :cl-user))\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (use-package :cp/println-matrix :cl-user))\n(in-package :cl-user)\n\n;;;\n;;; Body\n;;;\n\n(defun test (n m &rest as)\n  (let ((matrix (make-array (list n 7) :element-type 'base-char :initial-element #\\.)))\n    (dotimes (i (* n 7))\n      (when (member (mod i m) as)\n        (setf (row-major-aref matrix i) #\\#)))\n    (println-matrix matrix :separator \"\" :writer #'write-char)))\n\n(defun solve (n m as)\n  (declare #.cl-user::opt\n           ((integer 0 #.(expt 10 12)) n m)\n           ((simple-array uint31 (*)) as))\n  (let ((plan (make-array (list n 7) :element-type 'bit :initial-element 0))\n        (res 0))\n    (declare (uint62 res))\n    (loop for a across as\n          do (loop for i from a below (* n 7) by m\n                   do (setf (row-major-aref plan i) 1)))\n    (dotimes (i n)\n      (dotimes (j 7)\n        (when (zerop (aref plan i j))\n          (sb-int:named-let dfs ((i i) (j j))\n            (labels ((visit (y x)\n                       (when (and (<= 0 y (- n 1))\n                                  (<= 0 x 6))\n                         (dfs y x))))\n              (when (zerop (aref plan i j))\n                (setf (aref plan i j) 1)\n                (visit (- i 1) j)\n                (visit (+ i 1) j)\n                (visit i (- j 1))\n                (visit i (+ j 1)))))\n          (incf res))))\n    res))\n\n(defun main ()\n  (let* ((n (read))\n         (m (read))\n         (q (read))\n         (as (make-array q :element-type 'uint31 :initial-element 0)))\n    (dotimes (i q)\n      (setf (aref as i) (read-fixnum)))\n    (println\n     (let* ((period m)\n            (term1 (solve period m as))\n            (term2 (solve (* 2 period) m as))\n            (coef (- term2 term1))\n            (intercept (- term1 coef)))\n       (multiple-value-bind (quot rem) (floor n period)\n         (+ intercept\n            (* quot coef)\n            (- (solve (+ period rem) m as) term1)))))\n    ;; (println\n    ;;  (cond\n    ;;    ((zerop (mod m 7))\n    ;;     (let* ((period (floor m 7))\n    ;;            (term1 (solve period m as))\n    ;;            (term2 (solve (* 2 period) m as))\n    ;;            (coef (- term2 term1))\n    ;;            (intercept (- term1 coef)))\n    ;;       (multiple-value-bind (quot rem) (floor n period)\n    ;;         (+ intercept (* quot coef)\n    ;;            (- (solve (+ period rem) m as) term1)))))\n    ;;    ((<= n 100000)\n    ;;     (solve n m as))\n    ;;    (t (let* ((period m)\n    ;;              (term1 (solve period m as))\n    ;;              (term2 (solve (* 2 period) m as))\n    ;;              (coef (- term2 term1))\n    ;;              (intercept (- term1 coef)))\n    ;;         (multiple-value-bind (quot rem) (floor n period)\n    ;;           (+ intercept\n    ;;              (* quot coef)\n    ;;              (- (solve (+ period rem) m as) term1)))))))\n    ))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    #+os-windows (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)\n    #+os-unix (run-program \"xsel\" '(\"-b\" \"-o\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let* ((*standard-output* (or out (make-string-output-stream)))\n         (res (etypecase thing\n                (null\n                 (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n                   (main)))\n                (string\n                 (with-input-from-string (*standard-input* (delete #\\Return thing))\n                   (main)))\n                (symbol (5am:run! thing))\n                (pathname\n                 (with-open-file (*standard-input* thing)\n                   (main))))))\n    (if out res (get-output-stream-string *standard-output*))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (equal \"4\n\"\n          (run \"7 7 3\n1 3 5\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"10\n\"\n          (run \"10 14 8\n5 6 7 8 9 10 11 12\n\" nil))))\n"
  },
  {
    "language": "Lisp",
    "code": "#-swank\n(unless (member :child-sbcl *features*)\n  (quit\n   :unix-status\n   (process-exit-code\n    (run-program *runtime-pathname*\n                 `(\"--control-stack-size\" \"128MB\"\n                   \"--noinform\" \"--disable-ldb\" \"--lose-on-corruption\" \"--end-runtime-options\"\n                   \"--eval\" \"(push :child-sbcl *features*)\"\n                   \"--script\" ,(namestring *load-pathname*))\n                 :output t :error t :input t))))\n(in-package :cl-user)\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(defconstant +mod+ 1000000007)\n\n(defmacro dbg (&rest forms)\n  #+swank (if (= (length forms) 1)\n              `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n              `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n;; BEGIN_INSERTED_CONTENTS\n(defpackage :cp/println-matrix\n  (:use :cl)\n  (:export #:println-matrix))\n(in-package :cp/println-matrix)\n\n(declaim (inline println-matrix))\n(defun println-matrix (array &key (separator #\\ ) (key #'identity) (writer #'write) (row-start 0) row-end (col-start 0) col-end)\n  \"Prints a 2-dimensional array.\"\n  (declare ((array * (* *)) array)\n           ((integer 0 #.most-positive-fixnum) row-start col-start))\n  (let ((row-end (or row-end (array-dimension array 0)))\n        (col-end (or col-end (array-dimension array 1))))\n    (declare ((integer 0 #.most-positive-fixnum) row-end col-end))\n    (loop for i from row-start below row-end\n          do (loop for j from col-start below col-end\n                   unless (= j col-start)\n                   do (princ separator)\n                   do (funcall writer (funcall key (aref array i j))))\n             (terpri))))\n\n(defpackage :cp/read-fixnum\n  (:use :cl)\n  (:export #:read-fixnum))\n(in-package :cp/read-fixnum)\n\n(declaim (ftype (function * (values fixnum &optional)) read-fixnum))\n(defun read-fixnum (&optional (in *standard-input*))\n  \"NOTE: cannot read -2^62\"\n  (macrolet ((%read-byte ()\n               `(the (unsigned-byte 8)\n                     #+swank (char-code (read-char in nil #\\Nul))\n                     #-swank (sb-impl::ansi-stream-read-byte in nil #.(char-code #\\Nul) nil))))\n    (let* ((minus nil)\n           (result (loop (let ((byte (%read-byte)))\n                           (cond ((<= 48 byte 57)\n                                  (return (- byte 48)))\n                                 ((zerop byte) ; #\\Nul\n                                  (error \"Read EOF or #\\Nul.\"))\n                                 ((= byte #.(char-code #\\-))\n                                  (setq minus t)))))))\n      (declare ((integer 0 #.most-positive-fixnum) result))\n      (loop\n        (let* ((byte (%read-byte)))\n          (if (<= 48 byte 57)\n              (setq result (+ (- byte 48)\n                              (* 10 (the (integer 0 #.(floor most-positive-fixnum 10))\n                                         result))))\n              (return (if minus (- result) result))))))))\n\n;; BEGIN_USE_PACKAGE\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (use-package :cp/read-fixnum :cl-user))\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (use-package :cp/println-matrix :cl-user))\n(in-package :cl-user)\n\n;;;\n;;; Body\n;;;\n\n(defun test (n m &rest as)\n  (let ((matrix (make-array (list n 7) :element-type 'base-char :initial-element #\\.)))\n    (dotimes (i (* n 7))\n      (when (member (mod i m) as)\n        (setf (row-major-aref matrix i) #\\#)))\n    (println-matrix matrix :separator \"\" :writer #'write-char)))\n\n(defun solve-small (n m as)\n  (declare ((integer 0 #.(expt 10 12)) n m)\n           ((simple-array uint31 (*)) as))\n  (let ((plan (make-array (list n 7) :element-type 'bit :initial-element 0))\n        (res 0))\n    (declare (uint62 res))\n    (loop for a across as\n          do (loop for i from a below (* n 7) by m\n                   do (setf (row-major-aref plan i) 1)))\n    (dotimes (i n)\n      (dotimes (j 7)\n        (when (zerop (aref plan i j))\n          (sb-int:named-let dfs ((i i) (j j))\n            (labels ((visit (y x)\n                       (when (and (<= 0 y (- n 1))\n                                  (<= 0 x 6))\n                         (dfs y x))))\n              (when (zerop (aref plan i j))\n                (setf (aref plan i j) 1)\n                (visit (- i 1) j)\n                (visit (+ i 1) j)\n                (visit i (- j 1))\n                (visit i (+ j 1)))))\n          (incf res))))\n    res))\n\n(defun main ()\n  (let* ((n (read))\n         (m (read))\n         (q (read))\n         (as (make-array q :element-type 'uint31 :initial-element 0)))\n    (dotimes (i q)\n      (setf (aref as i) (read-fixnum)))\n    (println\n     (cond\n       ((zerop (mod m 7))\n        (let* ((period (floor m 7))\n               (term1 (solve-small period m as))\n               (term2 (solve-small (* 2 period) m as))\n               (coef (- term2 term1))\n               (intercept (- term1 coef)))\n          (multiple-value-bind (quot rem) (floor n period)\n            (dbg coef intercept)\n            (+ intercept (* quot coef)\n               (- (solve-small (+ period rem) m as) term1)))))\n       ((<= n 10000)\n        (solve-small n m as))\n       (t (error \"Huh?\"))))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    #+os-windows (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)\n    #+os-unix (run-program \"xsel\" '(\"-b\" \"-o\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let* ((*standard-output* (or out (make-string-output-stream)))\n         (res (etypecase thing\n                (null\n                 (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n                   (main)))\n                (string\n                 (with-input-from-string (*standard-input* (delete #\\Return thing))\n                   (main)))\n                (symbol (5am:run! thing))\n                (pathname\n                 (with-open-file (*standard-input* thing)\n                   (main))))))\n    (if out res (get-output-stream-string *standard-output*))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (equal \"4\n\"\n          (run \"7 7 3\n1 3 5\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"10\n\"\n          (run \"10 14 8\n5 6 7 8 9 10 11 12\n\" nil))))\n"
  },
  {
    "language": "Lisp",
    "code": "#-swank\n(unless (member :child-sbcl *features*)\n  (quit\n   :unix-status\n   (process-exit-code\n    (run-program *runtime-pathname*\n                 `(\"--control-stack-size\" \"128MB\"\n                   \"--noinform\" \"--disable-ldb\" \"--lose-on-corruption\" \"--end-runtime-options\"\n                   \"--eval\" \"(push :child-sbcl *features*)\"\n                   \"--script\" ,(namestring *load-pathname*))\n                 :output t :error t :input t))))\n(in-package :cl-user)\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(defconstant +mod+ 1000000007)\n\n(defmacro dbg (&rest forms)\n  #+swank (if (= (length forms) 1)\n              `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n              `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n;; BEGIN_INSERTED_CONTENTS\n(defpackage :cp/println-matrix\n  (:use :cl)\n  (:export #:println-matrix))\n(in-package :cp/println-matrix)\n\n(declaim (inline println-matrix))\n(defun println-matrix (array &key (separator #\\ ) (key #'identity) (writer #'write) (row-start 0) row-end (col-start 0) col-end)\n  \"Prints a 2-dimensional array.\"\n  (declare ((array * (* *)) array)\n           ((integer 0 #.most-positive-fixnum) row-start col-start))\n  (let ((row-end (or row-end (array-dimension array 0)))\n        (col-end (or col-end (array-dimension array 1))))\n    (declare ((integer 0 #.most-positive-fixnum) row-end col-end))\n    (loop for i from row-start below row-end\n          do (loop for j from col-start below col-end\n                   unless (= j col-start)\n                   do (princ separator)\n                   do (funcall writer (funcall key (aref array i j))))\n             (terpri))))\n\n(defpackage :cp/read-fixnum\n  (:use :cl)\n  (:export #:read-fixnum))\n(in-package :cp/read-fixnum)\n\n(declaim (ftype (function * (values fixnum &optional)) read-fixnum))\n(defun read-fixnum (&optional (in *standard-input*))\n  \"NOTE: cannot read -2^62\"\n  (macrolet ((%read-byte ()\n               `(the (unsigned-byte 8)\n                     #+swank (char-code (read-char in nil #\\Nul))\n                     #-swank (sb-impl::ansi-stream-read-byte in nil #.(char-code #\\Nul) nil))))\n    (let* ((minus nil)\n           (result (loop (let ((byte (%read-byte)))\n                           (cond ((<= 48 byte 57)\n                                  (return (- byte 48)))\n                                 ((zerop byte) ; #\\Nul\n                                  (error \"Read EOF or #\\Nul.\"))\n                                 ((= byte #.(char-code #\\-))\n                                  (setq minus t)))))))\n      (declare ((integer 0 #.most-positive-fixnum) result))\n      (loop\n        (let* ((byte (%read-byte)))\n          (if (<= 48 byte 57)\n              (setq result (+ (- byte 48)\n                              (* 10 (the (integer 0 #.(floor most-positive-fixnum 10))\n                                         result))))\n              (return (if minus (- result) result))))))))\n\n;; BEGIN_USE_PACKAGE\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (use-package :cp/read-fixnum :cl-user))\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (use-package :cp/println-matrix :cl-user))\n(in-package :cl-user)\n\n;;;\n;;; Body\n;;;\n\n(defun test (n m &rest as)\n  (let ((matrix (make-array (list n 7) :element-type 'base-char :initial-element #\\.)))\n    (dotimes (i (* n 7))\n      (when (member (mod i m) as)\n        (setf (row-major-aref matrix i) #\\#)))\n    (println-matrix matrix :separator \"\" :writer #'write-char)))\n\n(defun solve-small (n m as)\n  (declare (uint31 n m)\n           ((simple-array uint31 (*)) as))\n  (let ((plan (make-array (list n 7) :element-type 'bit :initial-element 0))\n        (res 0))\n    (declare (uint62 res))\n    (loop for a across as\n          do (loop for i from a below (* n 7) by m\n                   do (setf (row-major-aref plan i) 1)))\n    (dotimes (i n)\n      (dotimes (j 7)\n        (when (zerop (aref plan i j))\n          (sb-int:named-let dfs ((i i) (j j))\n            (labels ((visit (y x)\n                       (when (and (<= 0 y (- n 1))\n                                  (<= 0 x 6))\n                         (dfs y x))))\n              (when (zerop (aref plan i j))\n                (setf (aref plan i j) 1)\n                (visit (- i 1) j)\n                (visit (+ i 1) j)\n                (visit i (- j 1))\n                (visit i (+ j 1)))))\n          (incf res))))\n    res))\n\n(defun main ()\n  (let* ((n (read))\n         (m (read))\n         (q (read))\n         (as (make-array q :element-type 'uint31 :initial-element 0)))\n    (dotimes (i q)\n      (setf (aref as i) (read-fixnum)))\n    (println\n     (cond\n       ((zerop (mod m 7))\n        (let* ((period (floor m 7))\n               (term1 (solve-small period m as))\n               (term2 (solve-small (* 2 period) m as))\n               (coef (- term2 term1))\n               (intercept (- term1 coef)))\n          (multiple-value-bind (quot rem) (floor n period)\n            (dbg coef intercept)\n            (+ intercept (* quot coef)\n               (- (solve-small (+ period rem) m as) term1)))))\n       ((<= n 10000)\n        (solve-small n m as))\n       (t (error \"Huh?\"))))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    #+os-windows (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)\n    #+os-unix (run-program \"xsel\" '(\"-b\" \"-o\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let* ((*standard-output* (or out (make-string-output-stream)))\n         (res (etypecase thing\n                (null\n                 (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n                   (main)))\n                (string\n                 (with-input-from-string (*standard-input* (delete #\\Return thing))\n                   (main)))\n                (symbol (5am:run! thing))\n                (pathname\n                 (with-open-file (*standard-input* thing)\n                   (main))))))\n    (if out res (get-output-stream-string *standard-output*))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (equal \"4\n\"\n          (run \"7 7 3\n1 3 5\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"10\n\"\n          (run \"10 14 8\n5 6 7 8 9 10 11 12\n\" nil))))\n"
  },
  {
    "language": "Ruby",
    "code": "N,M,Q,*A=`dd`.split.map &:to_i;\nZ=0,-1,0,1;\n\nS=->h{v=[];A.map{|a|14.times{v[a]=1;a+=M}};(0...h).count{|k|!v[k]&&(*u=k;\nv[k]||4.times{|d|v[k]=d;\ni=7*(k/7+Z[d])+j=k%7+Z[~d];\ni<0||j<0||v[i]||i<h&&j<7&&u<<i\n}while k=u.pop;\n1)}};\n\nx=S[h=M.lcm(7)];\np~-N*7/h*(S[h*2]-x)+x"
  },
  {
    "language": "Ruby",
    "code": "class UnionFind\n    attr_reader :set_size\n    def initialize(n)\n        @par = Array.new(n)\n        n.times{ |i| @par[i] = i }\n        @rank = Array.new(n, 0)\n        @set_size = Array.new(n, 0)\n    end\n\n    def find(x)\n        if @par[x] == x\n            x\n        else\n            @par[x] = find(@par[x])\n        end\n    end\n\n    def unite(x,y)\n        x = find(x)\n        y = find(y)\n        return if x == y\n\n        if @rank[x] < @rank[y]\n            @par[x] = y\n            @set_size[y] += @set_size[x]\n        else\n            @par[y] = x\n            @set_size[x] += @set_size[y]\n            @rank[x] += 1 if @rank[x] == @rank[y]\n        end\n    end\n\n    def same?(x, y)\n        find(x) == find(y)\n    end\nend\n\nn, m, q = gets.split.map(&:to_i)\nas = gets.split.map(&:to_i)\n\nif m % 7 != 0\n    (1..6).each do |i|\n        as.concat(as[0, q].map{|a| a+i*m})\n    end\n    m *= 7\n    q *= 7\nend\n\nuf = UnionFind.new(m)\nwhite = Array.new(m, true)\nas.each{|a| white[a] = false}\nm.times do |i|\n    next unless white[i]\n    [i-1, i+1, i-7, i+7].each do |j|\n        if white[j] && j.between?(0, m-1)\n            uf.unite(i, j)\n        end\n    end\nend\n\nblocks = 7*n/m\nnum = m.times.count{|i| white[i] && uf.find(i) == i} * blocks\n\nused = {}\n7.times do |i|\n    j = m-7+i\n    if white[i] && white[j] && !(used[uf.find(i)] && used[uf.find(j)])\n        num -= blocks - 1\n        used[uf.find(i)] = true\n        used[uf.find(j)] = true\n    end\nend\nputs num"
  },
  {
    "language": "Ruby",
    "code": "eval\"N,M,Q,*A=\"+`dd`.split*?,;\nZ=0,-1,0,1;\n\nS=->h{v=[];A.map{|a|14.times{v[a]=1;a+=M}};(0...h).count{|k|!v[k]&&(*u=k;\nv[k]||4.times{|d|v[k]=d;\ni=7*(k/7+Z[d])+j=k%7+Z[~d];\ni<0||j<0||v[i]||i<h&&j<7&&u<<i\n}while k=u.pop;\n1)}};\n\nx=S[h=M.lcm(7)];\np~-N*7/h*(S[h*2]-x)+x\n"
  },
  {
    "language": "Ruby",
    "code": "class UnionFind\n    attr_reader :set_size\n    def initialize(n)\n        @par = Array.new(n)\n        n.times{ |i| @par[i] = i }\n        @rank = Array.new(n, 0)\n        @set_size = Array.new(n, 0)\n    end\n\n    def find(x)\n        if @par[x] == x\n            x\n        else\n            @par[x] = find(@par[x])\n        end\n    end\n\n    def unite(x,y)\n        x = find(x)\n        y = find(y)\n        return if x == y\n\n        if @rank[x] < @rank[y]\n            @par[x] = y\n            @set_size[y] += @set_size[x]\n        else\n            @par[y] = x\n            @set_size[x] += @set_size[y]\n            @rank[x] += 1 if @rank[x] == @rank[y]\n        end\n    end\n\n    def same?(x, y)\n        find(x) == find(y)\n    end\nend\n\nn, m, q = gets.split.map(&:to_i)\nas = gets.split.map(&:to_i)\n\nif m % 7 != 0\n    (1..6).each do |i|\n        as.concat(as[0, q].map{|a| a+i*m})\n    end\n    m *= 7\n    q *= 7\nend\n\nuf = UnionFind.new(m)\nwhite = Array.new(m, true)\nas.each{|a| white[a] = false}\nm.times do |i|\n    next unless white[i]\n    uf.unite(i, i+1) if white[i+1] && i%7<6\n    uf.unite(i, i+7) if white[i+7] && i+7<m \nend\n\nblocks = 7*n/m\nnum = m.times.count{|i| white[i] && uf.find(i) == i} * blocks\n\nused = {}\n7.times do |i|\n    j = m-7+i\n    if white[i] && white[j] && !(used[uf.find(i)] && used[uf.find(j)])\n        num -= blocks - 1\n        used[uf.find(i)] = true\n        used[uf.find(j)] = true\n    end\nend\nputs num"
  },
  {
    "language": "Ruby",
    "code": "N,M,Q,*A=`dd`.split.map &:to_i;\nZ=0,-1,0,1;\n\nS=->h{v=[];A.map{|a|14.times{v[a]=1;a+=M}};(0...h).count{|k|!v[k]&&(*u=k;q=-1;\nv[k]||4.times{|d|v[k]=d;\ni=7*(k/7+Z[d])+j=k%7+Z[~d];\ni<0||j<0||v[i]||i<h&&j<7&&u<<i\n}while k=u[q+=1];\n1)}};\n\nx=S[h=M.lcm(7)];\np~-N*7/h*(S[h*2]-x)+x"
  },
  {
    "language": "Ruby",
    "code": "eval\"N,M,Q,*A=\"+`dd`.split*?,;\nZ=0,-1,0,1;\nD=->k{V[k]||4.times{|d|V[k]=d;\ni=7*(k/7+Z[d])+j=k%7+Z[~d];\ni<0||j<0||i<H&&j<7&&D[i]\n}};\nS=->_{V=[];A.map{|a|14.times{V[a]=1;a+=M}};(0...H).count{|k|!V[k]&D[k]}};\nx=S[H=M.lcm(7)];\np~-N*7/H*(S[H*=2]-x)+x"
  },
  {
    "language": "Ruby",
    "code": "n,m,q,*a=$<.read.split.map &:to_i;\nif (m%7 < 1)\n  if(q.size==m)\n    puts 0\n\n  elsif(  q.size >6)\n    puts n\n\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "eval\"N,M,Q,*A=\"+`dd`.split*?,;\nZ=0,-1,0,1;\n\nS=->h{v=[];A.map{|a|14.times{v[a]=1;a+=M}};(0...h).count{|k|!v[k]&&(*u=k;\nv[k]||4.times{|d|v[k]=d;\ni=7*(k/7+Z[d])+j=k%7+Z[~d];\ni<0||j<0||i<h&&j<7&&u<<i\n}while k=u.pop;\n1)}};\n\nx=S[h=M.lcm(7)];\np~-N*7/h*(S[h*2]-x)+x"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n\nlong N, M;\nbool[][] used;\nbool[long] D;\nint[] dr = [0, 0, 1, -1];\nint[] dc = [1, -1, 0, 0];\n\nlong num(int i, int j) {return 7*(i+1)+(j+1)-8;}\nbool is_black(int i, int j) {return ((num(i, j) % M) in D) ? true : false;}\n\nvoid dfs(int r, int c) {\n    if (used[r][c]) return;\n    used[r][c] = true;\n\n    foreach (i; 0..4) {\n        int nr = r + dr[i];\n        int nc = c + dc[i];\n        if (nr < 0 || nr >= N || nc < 0 || nc >= 7) continue;\n        if (used[nr][nc]) continue;\n        if (is_black(nr, nc)) continue;\n        dfs(nr, nc);\n    }\n}\n\n\nvoid main() {\n    auto s = readln.split.map!(to!long);\n    N = s[0];\n    M = s[1];\n    auto Q = s[2];\n    auto A = readln.split.map!(to!long).array;\n    if (N > 100000) throw new Exception(\"hoge\");\n\n    foreach (a; A) D[a] = true;\n    used = new bool[][](N, 7);\n\n    int ans = 0;\n    foreach (i; 0..N) {\n        foreach (j; 0..7) {\n            if (!used[i][j] && !is_black(i.to!int, j)) {\n                dfs(i.to!int, j);\n                ans += 1;\n            }\n        }\n    }\n\n    ans.writeln;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n \nlong N, M;\nbool[][] used;\nbool[long] D;\nint[] dr = [0, 0, 1, -1];\nint[] dc = [1, -1, 0, 0];\n \nlong num(int i, int j) {return 7*(i+1)+(j+1)-8;}\nbool is_black(int i, int j) {return ((num(i, j) % M) in D) ? true : false;}\n \nvoid dfs(int r, int c) {\n    if (used[r][c]) return;\n    used[r][c] = true;\n \n    foreach (i; 0..4) {\n        int nr = r + dr[i];\n        int nc = c + dc[i];\n        if (nr < 0 || nr >= N || nc < 0 || nc >= 7) continue;\n        if (used[nr][nc]) continue;\n        if (is_black(nr, nc)) continue;\n        dfs(nr, nc);\n    }\n}\n \n \nvoid main() {\n    auto s = readln.split.map!(to!long);\n    N = s[0];\n    M = s[1];\n    auto Q = s[2];\n    auto A = readln.split.map!(to!long).array;\n \n    foreach (a; A) D[a] = true;\n    used = new bool[][](N, 7);\n \n    int ans = 0;\n    foreach (i; 0..N) {\n        foreach (j; 0..7) {\n            if (!used[i][j] && !is_black(i.to!int, j)) {\n                dfs(i.to!int, j);\n                ans += 1;\n            }\n        }\n    }\n \n    ans.writeln;\n}\n"
  },
  {
    "language": "Python",
    "code": "n,m,q=map(int,input().split())\na=list(map(int,input().split()))\n\ndef count_group(size):\n    cc = [False]*size\n    for i in range(q):\n        j = 0\n        while a[i]+m*j < size:\n            cc[a[i]+m*j] = True\n            j += 1\n\n    gg = [0]*size\n    ox = [-1, 0, 1, 0]\n    oy = [0, -7, 0, 7]\n    def dfs(i, g):\n        if cc[i] or gg[i] != 0: return\n        gg[i] = g\n        for t in range(4):\n            if i % 7  == 0 and ox[t] == -1: continue\n            if (i+1) % 7  == 0 and ox[t] == 1: continue\n            j = i+ox[t]+oy[t]\n            if 0 <= j < size:\n                dfs(j, g)\n\n    maxg = 0\n    for i in range(size):\n        if not cc[i] and gg[i] == 0:\n            maxg += 1\n            dfs(i, maxg)\n\n    return maxg\n\nblock = (m+7)//7*7*7\nif n <= block:\n    print(count_group(n*7))\n    exit(0)\nc1 = count_group(block)\nc2 = count_group(block*2)\nc3 = count_group(block+((n*7)%block))\nprint(c1 + ((n*7-block)//block)*(c2-c1) + (c3-c1))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\nimport numba\nfrom numba import njit, b1, i4, i8\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n@njit((i8, i8, i8[:]), cache=True)\ndef solve_naive(H, M, A):\n    visited = np.zeros(7 * H, np.bool_)\n    for a in A:\n        visited[a::M] = 1\n    st = np.empty(7 * H + 10, np.int64)\n    ncomp = 0\n    for v in range(7 * H):\n        if visited[v]:\n            continue\n        ncomp += 1\n        st[0] = v\n        p = 1\n        while p:\n            p -= 1\n            v = st[p]\n            x, y = divmod(v, 7)\n            for d in (1, -1, 7, -7):\n                w = v + d\n                if w < 0 or w >= 7 * H:\n                    continue\n                x1, y1 = divmod(w, 7)\n                if abs(x - x1) + abs(y - y1) != 1:\n                    continue\n                if visited[w]:\n                    continue\n                visited[w] = True\n                st[p] = w\n                p += 1\n    return ncomp\n\nN, M, Q = map(int, readline().split())\nA = np.array(readline().split(), np.int64)\n\nif N <= 5 * M:\n    x = solve_naive(N, M, A)\nelse:\n    q, r = divmod(N, M)\n    a, b = solve_naive(r + 3 * M, M, A), solve_naive(r + 4 * M, M, A)\n    x = a + (q - 3) * (b - a)\nprint(x)"
  },
  {
    "language": "Python",
    "code": "from queue import Queue\n\nn,m,q=map(int,input().split())\na=list(map(int,input().split()))\n\ndef count_group(size):\n    cc = [False]*size\n    for i in range(q):\n        j = 0\n        while a[i]+m*j < size:\n            cc[a[i]+m*j] = True\n            j += 1\n\n    gg = [0]*size\n    ox = [-1, 0, 1, 0]\n    oy = [0, -7, 0, 7]\n    def bfs(i, g):\n        qq = Queue()\n        qq.put(i, False)\n        while not qq.empty():\n            ii = qq.get(False)\n            gg[ii] = g\n            for t in range(4):\n                if ii % 7  == 0 and ox[t] == -1: continue\n                if (ii+1) % 7  == 0 and ox[t] == 1: continue\n                j = ii+ox[t]+oy[t]\n                if 0 <= j < size:\n                    if cc[j] or gg[j] != 0: continue\n                    qq.put(j, False)\n\n    maxg = 0\n    for i in range(size):\n        if not cc[i] and gg[i] == 0:\n            maxg += 1\n            bfs(i, maxg)\n\n    return maxg\n\nblock = (m+7)//7*7*7\nif n*7 <= block:\n    print(count_group(n*7))\n    exit(0)\nc1 = count_group(block)\nc2 = count_group(block*2)\nc3 = count_group(block+((n*7)%block))\nprint(c1 + ((n*7-block)//block)*(c2-c1) + (c3-c1))\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\n/**\n * Union-Find tree.\n * Verified by yukicoder No.94 (http://yukicoder.me/submissions/82111)\n */\nstruct UnionFind { disj: Vec<usize> }\n\nimpl UnionFind {\n    fn new(n: usize) -> Self {\n        let mut disj = vec![0; n];\n        for i in 0 .. n {\n            disj[i] = i;\n        }\n        UnionFind { disj: disj }\n    }\n    fn root(self: &mut Self, x: usize) -> usize {\n        if x != self.disj[x] {\n            let par = self.disj[x];\n            let r = self.root(par);\n            self.disj[x] = r;\n        }\n        return self.disj[x];\n    }\n    fn unite(self: &mut Self, x: usize, y: usize) {\n        let xr = self.root(x);\n        let yr = self.root(y);\n        self.disj[xr] = yr;\n    }\n    fn is_same_set(self: &mut Self, x: usize, y: usize) -> bool {\n        return self.root(x) == self.root(y);\n    }\n}\n\n\nfn backend(n: usize, m: usize, a: &[usize]) -> i64 {\n    let mut tbl = vec![false; 7 * n];\n    for &a in a.iter() {\n        for j in 0 .. 7 * n / m {\n            tbl[a + m * j] = true;\n        }\n    }\n    let mut uf = UnionFind::new(7 * n);\n    for i in 0 .. n {\n        for j in 0 .. 7 {\n            if i < n - 1 && !tbl[7 * i + j] && !tbl[7 * i + j + 7] {\n                uf.unite(7 * i + j, 7 * i + j + 7);\n            }\n            if j < 6 && !tbl[7 * i + j] && !tbl[7 * i + j + 1] {\n                uf.unite(7 * i + j, 7 * i + j + 1);\n            }\n        }\n    }\n    let mut s = HashSet::new();\n    for i in 0 .. 7 * n {\n        if !tbl[i] {\n            s.insert(uf.root(i));\n        }\n    }\n    s.len() as i64\n}\nfn solve_easy1(n: usize, m: usize, a: &[usize]) {\n    let mut tbl = vec![false; 7 * n];\n    for &a in a.iter() {\n        for j in 0 .. 7 * n / m {\n            tbl[a + m * j] = true;\n        }\n    }\n    let mut uf = UnionFind::new(7 * n);\n    for i in 0 .. n {\n        for j in 0 .. 7 {\n            if i < n - 1 && !tbl[7 * i + j] && !tbl[7 * i + j + 7] {\n                uf.unite(7 * i + j, 7 * i + j + 7);\n            }\n            if j < 6 && !tbl[7 * i + j] && !tbl[7 * i + j + 1] {\n                uf.unite(7 * i + j, 7 * i + j + 1);\n            }\n        }\n    }\n    let mut s = HashSet::new();\n    for i in 0 .. 7 * n {\n        if !tbl[i] {\n            s.insert(uf.root(i));\n        }\n    }\n    println!(\"{}\", s.len());\n}\n\nfn solve() {\n    let n: i64 = get();\n    let m: usize = get();\n    let q = get();\n    let a: Vec<usize> = (0 .. q).map(|_| get()).collect();\n    let tmp = if m % 7 == 0 { m } else { 7 * m };\n    let s1 = backend(tmp / 7, m, &a);\n    let s2 = backend(2 * tmp / 7, m, &a);\n    println!(\"{}\", s1 + (s2 - s1) * (7 * n / tmp as i64 - 1));\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\n/**\n * Union-Find tree.\n * Verified by yukicoder No.94 (http://yukicoder.me/submissions/82111)\n */\nstruct UnionFind { disj: Vec<usize> }\n\nimpl UnionFind {\n    fn new(n: usize) -> Self {\n        let mut disj = vec![0; n];\n        for i in 0 .. n {\n            disj[i] = i;\n        }\n        UnionFind { disj: disj }\n    }\n    fn root(self: &mut Self, x: usize) -> usize {\n        if x != self.disj[x] {\n            let par = self.disj[x];\n            let r = self.root(par);\n            self.disj[x] = r;\n        }\n        return self.disj[x];\n    }\n    fn unite(self: &mut Self, x: usize, y: usize) {\n        let xr = self.root(x);\n        let yr = self.root(y);\n        self.disj[xr] = yr;\n    }\n    fn is_same_set(self: &mut Self, x: usize, y: usize) -> bool {\n        return self.root(x) == self.root(y);\n    }\n}\n\n\nfn solve_easy1(n: usize, m: usize, a: &[usize]) {\n    let mut tbl = vec![false; 7 * n];\n    for &a in a.iter() {\n        for j in 0 .. 7 * n / m {\n            tbl[a + m * j] = true;\n        }\n    }\n    let mut uf = UnionFind::new(7 * n);\n    for i in 0 .. n {\n        for j in 0 .. 7 {\n            if i < n - 1 && !tbl[7 * i + j] && !tbl[7 * i + j + 7] {\n                uf.unite(7 * i + j, 7 * i + j + 7);\n            }\n            if j < 6 && !tbl[7 * i + j] && !tbl[7 * i + j + 1] {\n                uf.unite(7 * i + j, 7 * i + j + 1);\n            }\n        }\n    }\n    let mut s = HashSet::new();\n    for i in 0 .. 7 * n {\n        if !tbl[i] {\n            s.insert(uf.root(i));\n        }\n    }\n    println!(\"{}\", s.len());\n}\n\nfn solve() {\n    let n: i64 = get();\n    let m: usize = get();\n    let q = get();\n    let a: Vec<usize> = (0 .. q).map(|_| get()).collect();\n    assert!(n <= 100100);\n    let n = n as usize;\n    solve_easy1(n, m, &a);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  }
]