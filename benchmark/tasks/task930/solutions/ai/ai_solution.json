[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define ROWS 100\n#define COLS 7\n\nint grid[ROWS][COLS];\nbool visited[ROWS][COLS];\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nvoid dfs(int x, int y, int n) {\n    if (x < 0 || x >= n || y < 0 || y >= COLS || visited[x][y] || grid[x][y] == -1) \n        return;\n    \n    visited[x][y] = true;\n    \n    for (int k = 0; k < 4; k++) {\n        int nx = x + dx[k];\n        int ny = y + dy[k];\n        dfs(nx, ny, n);\n    }\n}\n\nint count_white_regions(int n) {\n    int regions = 0;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < COLS; j++) {\n            if (!visited[i][j] && grid[i][j] != -1) {\n                dfs(i, j, n);\n                regions++;\n            }\n        }\n    }\n    \n    return regions;\n}\n\nint main() {\n    int n, m, q;\n    scanf(\"%d %d %d\", &n, &m, &q);\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < COLS; j++) {\n            grid[i][j] = 7 * i + j - 8;\n            visited[i][j] = false;\n        }\n    }\n    \n    for (int op = 0; op < q; op++) {\n        int a;\n        scanf(\"%d\", &a);\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < COLS; j++) {\n                if (grid[i][j] % m == a) {\n                    grid[i][j] = -1;\n                }\n            }\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < COLS; j++) {\n            visited[i][j] = false;\n        }\n    }\n    \n    printf(\"%d\\n\", count_white_regions(n));\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:23:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint n, m, q;\nint a[100000];\nint grid[100000][7];\nint visited[100000][7];\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nint is_valid(int x, int y) {\n    return x >= 0 && x < n && y >= 0 && y < 7;\n}\n\nvoid dfs(int x, int y) {\n    visited[x][y] = 1;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (is_valid(nx, ny) && !visited[nx][ny] && grid[nx][ny] == 0) {\n            dfs(nx, ny);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &n, &m, &q);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 7; j++) {\n            grid[i][j] = 0;\n            visited[i][j] = 0;\n        }\n    }\n    for (int k = 0; k < q; k++) {\n        scanf(\"%d\", &a[k]);\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 7; j++) {\n            int num = 7 * i + j - 7;\n            for (int k = 0; k < q; k++) {\n                if (num % m == a[k]) {\n                    grid[i][j] = 1;\n                    break;\n                }\n            }\n        }\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 7; j++) {\n            if (grid[i][j] == 0 && !visited[i][j]) {\n                dfs(i, j);\n                count++;\n            }\n        }\n    }\n    printf(\"%d\\n\", count);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:23:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n    vector<vector<bool>> is_black(n, vector<bool>(7, false));\n    vector<int> a(q);\n    for (int i = 0; i < q; ++i) {\n        cin >> a[i];\n    }\n\n    for (int k = 0; k < q; ++k) {\n        int rem = a[k];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < 7; ++j) {\n                int num = 7 * i + j - 7;\n                if (num % m == rem) {\n                    is_black[i][j] = true;\n                }\n            }\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(7, false));\n    int regions = 0;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 7; ++j) {\n            if (!is_black[i][j] && !visited[i][j]) {\n                regions++;\n                queue<pair<int, int>> q;\n                q.push({i, j});\n                visited[i][j] = true;\n                while (!q.empty()) {\n                    auto current = q.front();\n                    q.pop();\n                    for (int d = 0; d < 4; ++d) {\n                        int ni = current.first + dx[d];\n                        int nj = current.second + dy[d];\n                        if (ni >= 0 && ni < n && nj >= 0 && nj < 7) {\n                            if (!is_black[ni][nj] && !visited[ni][nj]) {\n                                visited[ni][nj] = true;\n                                q.push({ni, nj});\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cout << regions << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:23:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static int n, m, q;\n    static int[] a;\n    static boolean[][] isBlack;\n    static int[][] grid;\n    static int[] dx = {-1, 1, 0, 0};\n    static int[] dy = {0, 0, -1, 1};\n\n    static void dfs(int i, int j, boolean[][] visited) {\n        visited[i][j] = true;\n        for (int d = 0; d < 4; d++) {\n            int ni = i + dx[d];\n            int nj = j + dy[d];\n            if (ni >= 0 && ni < n && nj >= 0 && nj < 7 && !isBlack[ni][nj] && !visited[ni][nj]) {\n                dfs(ni, nj, visited);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        m = sc.nextInt();\n        q = sc.nextInt();\n        a = new int[q];\n        for (int i = 0; i < q; i++) {\n            a[i] = sc.nextInt();\n        }\n\n        grid = new int[n][7];\n        isBlack = new boolean[n][7];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 7; j++) {\n                grid[i][j] = 7 * i + j - 7;\n            }\n        }\n\n        for (int k = 0; k < q; k++) {\n            int ak = a[k];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < 7; j++) {\n                    if (grid[i][j] % m == ak) {\n                        isBlack[i][j] = true;\n                    }\n                }\n            }\n        }\n\n        boolean[][] visited = new boolean[n][7];\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 7; j++) {\n                if (!isBlack[i][j] && !visited[i][j]) {\n                    dfs(i, j, visited);\n                    count++;\n                }\n            }\n        }\n        System.out.println(count);\n    }\n}",
    "timestamp": "2025-08-05 23:24:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class CalendarGrid {\n    static int[][] grid;\n    static boolean[][] visited;\n    static int n, m;\n    static int[] dx = {0, 0, 1, -1};\n    static int[] dy = {1, -1, 0, 0};\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        n = Integer.parseInt(st.nextToken());\n        m = Integer.parseInt(st.nextToken());\n        \n        grid = new int[n][7];\n        visited = new boolean[n][7];\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 7; j++) {\n                grid[i][j] = 7 * i + j - 8;\n            }\n        }\n        \n        int q = Integer.parseInt(st.nextToken());\n        \n        for (int k = 0; k < q; k++) {\n            st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < 7; j++) {\n                    if (grid[i][j] % m == a) {\n                        grid[i][j] = -1;\n                    }\n                }\n            }\n        }\n        \n        int regions = countRegions();\n        System.out.println(regions);\n    }\n    \n    static int countRegions() {\n        int regions = 0;\n        visited = new boolean[n][7];\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 7; j++) {\n                if (grid[i][j] != -1 && !visited[i][j]) {\n                    dfs(i, j);\n                    regions++;\n                }\n            }\n        }\n        \n        return regions;\n    }\n    \n    static void dfs(int x, int y) {\n        visited[x][y] = true;\n        \n        for (int k = 0; k < 4; k++) {\n            int nx = x + dx[k];\n            int ny = y + dy[k];\n            \n            if (nx >= 0 && nx < n && ny >= 0 && ny < 7 && \n                grid[nx][ny] != -1 && !visited[nx][ny]) {\n                dfs(nx, ny);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:24:32"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100;\nint grid[MAXN][7];\nbool visited[MAXN][7];\nint n, m, q;\n\nvoid dfs(int r, int c) {\n    if (r < 0 || r >= n || c < 0 || c >= 7 || visited[r][c] || grid[r][c] == 1)\n        return;\n    \n    visited[r][c] = true;\n    \n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {1, 0, -1, 0};\n    \n    for (int k = 0; k < 4; k++) {\n        int nr = r + dx[k];\n        int nc = c + dy[k];\n        dfs(nr, nc);\n    }\n}\n\nint count_white_regions() {\n    memset(visited, 0, sizeof(visited));\n    int regions = 0;\n    \n    for (int r = 0; r < n; r++) {\n        for (int c = 0; c < 7; c++) {\n            if (!visited[r][c] && grid[r][c] == 0) {\n                dfs(r, c);\n                regions++;\n            }\n        }\n    }\n    \n    return regions;\n}\n\nint main() {\n    cin >> n >> m >> q;\n    \n    for (int r = 0; r < n; r++) {\n        for (int c = 0; c < 7; c++) {\n            grid[r][c] = 0;\n        }\n    }\n    \n    for (int i = 0; i < q; i++) {\n        int a;\n        cin >> a;\n        \n        for (int r = 0; r < n; r++) {\n            for (int c = 0; c < 7; c++) {\n                int val = 7 * r + c - 8;\n                if (val % m == a) {\n                    grid[r][c] = 1;\n                }\n            }\n        }\n    }\n    \n    cout << count_white_regions() << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:24:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def dfs(grid, x, y, visited):\n    stack = [(x, y)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    n = len(grid)\n    \n    while stack:\n        cx, cy = stack.pop()\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < n and 0 <= ny < 7 and not visited[nx][ny] and grid[nx][ny] == 0:\n                visited[nx][ny] = True\n                stack.append((nx, ny))\n\ndef count_white_regions(n, q, operations):\n    grid = [[0] * 7 for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(7):\n            num = 7 * i + j - 8\n            for a_i, m in operations:\n                if num % m == a_i:\n                    grid[i][j] = 1\n                    break\n    \n    visited = [[False] * 7 for _ in range(n)]\n    regions = 0\n    \n    for i in range(n):\n        for j in range(7):\n            if grid[i][j] == 0 and not visited[i][j]:\n                visited[i][j] = True\n                dfs(grid, i, j, visited)\n                regions += 1\n                \n    return regions\n\n# Example usage\nn = 5 \nq = 2\noperations = [(0, 2), (1, 3)]\nprint(count_white_regions(n, q, operations))",
    "timestamp": "2025-08-13 15:04:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class CalendarGrid {\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt(), m = scanner.nextInt(), q = scanner.nextInt();\n        boolean[][] grid = new boolean[n][7];\n        \n        for (int i = 0; i < q; i++) {\n            int a_i = scanner.nextInt();\n            for (int r = 0; r < n; r++) {\n                for (int c = 0; c < 7; c++) {\n                    if ((7 * r + c - 8) % m == a_i) {\n                        grid[r][c] = true;\n                    }\n                }\n            }\n        }\n        \n        int connectedWhiteRegions = countWhiteRegions(grid, n, 7);\n        System.out.println(connectedWhiteRegions);\n        scanner.close();\n    }\n\n    private static int countWhiteRegions(boolean[][] grid, int n, int cols) {\n        boolean[][] visited = new boolean[n][cols];\n        int count = 0;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (!grid[i][j] && !visited[i][j]) {\n                    dfs(grid, visited, i, j, n, cols);\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }\n\n    private static void dfs(boolean[][] grid, boolean[][] visited, int row, int col, int n, int cols) {\n        if (row < 0 || col < 0 || row >= n || col >= cols || visited[row][col] || grid[row][col]) {\n            return;\n        }\n\n        visited[row][col] = true;\n        \n        dfs(grid, visited, row - 1, col, n, cols);\n        dfs(grid, visited, row + 1, col, n, cols);\n        dfs(grid, visited, row, col - 1, n, cols);\n        dfs(grid, visited, row, col + 1, n, cols);\n    }\n}",
    "timestamp": "2025-08-13 15:04:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_ROWS 100\n\nint grid[MAX_ROWS][7];\nbool visited[MAX_ROWS][7];\nint n, q;\n\nint dr[] = {-1, 1, 0, 0};\nint dc[] = {0, 0, -1, 1};\n\nbool is_valid(int r, int c) {\n    return r >= 0 && r < n && c >= 0 && c < 7;\n}\n\nvoid dfs(int r, int c, int remainder, int m) {\n    if (!is_valid(r, c) || visited[r][c]) {\n        return;\n    }\n    int cell_value = 7 * r + c - 8;\n    if (cell_value % m == remainder) {\n        return;\n    }\n    visited[r][c] = true;\n    for (int i = 0; i < 4; i++) {\n        dfs(r + dr[i], c + dc[i], remainder, m);\n    }\n}\n\nint main() {\n    int m, remainders[100], ai;\n    \n    scanf(\"%d\", &n);\n    scanf(\"%d\", &m);\n    scanf(\"%d\", &q);\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d\", &remainders[i]);\n    }\n\n    // Initialize grid and visited\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 7; j++) {\n            visited[i][j] = false;\n        }\n    }\n\n    for (int i = 0; i < q; i++) {\n        ai = remainders[i];\n        for (int r = 0; r < n; r++) {\n            for (int c = 0; c < 7; c++) {\n                int cell_value = 7 * r + c - 8;\n                if (cell_value % m == ai) {\n                    visited[r][c] = true;\n                }\n            }\n        }\n    }\n\n    int white_regions = 0;\n    \n    for (int r = 0; r < n; r++) {\n        for (int c = 0; c < 7; c++) {\n            if (!visited[r][c]) {\n                dfs(r, c, -1, m);\n                white_regions++;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", white_regions);\n    return 0;\n}",
    "timestamp": "2025-08-13 15:05:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint n, q, m;\nvector<vector<bool>> grid;\nvector<bool> row_black;\n\nconst int dir_x[] = {-1, 1, 0, 0};\nconst int dir_y[] = {0, 0, -1, 1};\n\nbool isValid(int x, int y, int n) {\n    return x >= 0 && x < n && y >= 0 && y < 7 && !grid[x][y];\n}\n\nvoid bfs(int x, int y, int n) {\n    queue<pair<int, int>> q;\n    q.push({x, y});\n    grid[x][y] = true;\n\n    while (!q.empty()) {\n        int cx = q.front().first;\n        int cy = q.front().second;\n        q.pop();\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = cx + dir_x[i];\n            int ny = cy + dir_y[i];\n\n            if (isValid(nx, ny, n)) {\n                grid[nx][ny] = true;\n                q.push({nx, ny});\n            }\n        }\n    }\n}\n\nint countWhiteRegions(int n) {\n    int count = 0;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 7; ++j) {\n            if (!grid[i][j]) {\n                count++;\n                bfs(i, j, n);\n            }\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    cin >> n >> q >> m;\n\n    grid.assign(n, vector<bool>(7, false));\n\n    for (int operation = 0; operation < q; ++operation) {\n        int a;\n        cin >> a;\n\n        for (int i = 0; i < n; ++i) {\n            if (!row_black[i] && (7 * i - 8) % m == a) {\n                row_black[i] = true;\n                for (int j = 0; j < 7; ++j) {\n                    int value = 7 * i + j - 8;\n                    if (value % m == a) {\n                        grid[i][j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    cout << countWhiteRegions(n) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:05:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_white_regions(n, m, ops):\n    grid = [[7*i + j - 8 for j in range(7)] for i in range(n)]\n    painted = [[False] * 7 for _ in range(n)]\n    \n    for op in ops:\n        a_i, m_val = op\n        for i in range(n):\n            for j in range(7):\n                if (grid[i][j] % m_val) == a_i:\n                    painted[i][j] = True\n    \n    def dfs(r, c):\n        if r < 0 or r >= n or c < 0 or c >= 7 or painted[r][c]:\n            return\n        painted[r][c] = True\n        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:\n            dfs(r+dr, c+dc)\n    \n    regions = 0\n    for i in range(n):\n        for j in range(7):\n            if not painted[i][j]:\n                dfs(i, j)\n                regions += 1\n    \n    return regions",
    "timestamp": "2025-08-13 15:05:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n    q = int(input[ptr])\n    ptr += 1\n    \n    a = []\n    for _ in range(q):\n        a_i = int(input[ptr])\n        ptr += 1\n        a.append(a_i)\n    \n    grid = [[True for _ in range(7)] for _ in range(n)]\n    # Initialize grid: True means white, False means black\n    for i in range(n):\n        for j in range(7):\n            val = 7 * i + j - 7\n            if val < 0:\n                grid[i][j] = False  # invalid cells are considered black\n    \n    # Process queries\n    for rem in a:\n        for i in range(n):\n            for j in range(7):\n                val = 7 * i + j - 7\n                if val >= 0 and val % m == rem:\n                    grid[i][j] = False\n    \n    # BFS to count connected white regions\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    visited = [[False for _ in range(7)] for _ in range(n)]\n    count = 0\n    \n    for i in range(n):\n        for j in range(7):\n            if grid[i][j] and not visited[i][j]:\n                count += 1\n                queue = deque()\n                queue.append((i, j))\n                visited[i][j] = True\n                while queue:\n                    x, y = queue.popleft()\n                    for dx, dy in directions:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < n and 0 <= ny < 7:\n                            if grid[nx][ny] and not visited[nx][ny]:\n                                visited[nx][ny] = True\n                                queue.append((nx, ny))\n    print(count)\n\nsolve()",
    "timestamp": "2025-08-13 15:05:25"
  }
]