[
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * 1386.cc: Starting a Scenic Railroad Service\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 200000;\nconst int MAX_M = 100000;\nconst int INF = 1 << 30;\n\n/* typedef */\n\n/* global variables */\n\nint as[MAX_N], bs[MAX_N];\nint csums[MAX_M + 1], asums[MAX_M + 1], bsums[MAX_M + 1];\n\n/* subroutines */\n\ninline void setmax(int &a, int b) { if (a < b) a = b; }\n\n/* main */\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n\n  int m = 0;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%d\", as + i, bs + i);\n    csums[as[i]]++, csums[bs[i]]--;\n    asums[as[i]]++;\n    bsums[bs[i]]++;\n    setmax(m, bs[i]);\n  }\n\n  for (int i = 0; i < m; i++) {\n    csums[i + 1] += csums[i];\n    asums[i + 1] += asums[i];\n    bsums[i + 1] += bsums[i];\n  }\n\n  int maxp1 = 0;\n  for (int i = 0; i < n; i++) setmax(maxp1, asums[bs[i] - 1] - bsums[as[i]]);\n\n  int maxp2 = 0;\n  for (int i = 1; i < m; i++) setmax(maxp2, csums[i]);\n\n  printf(\"%d %d\\n\", maxp1, maxp2);\n  //for (int i = 0; i <= m; i++) printf(\"%d \", csums[i]); putchar('\\n');\n  //for (int i = 0; i <= m; i++) printf(\"%d \", asums[i]); putchar('\\n');\n  //for (int i = 0; i <= m; i++) printf(\"%d \", bsums[i]); putchar('\\n');\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,b,e) for(int i=(b);i<(e);++i)\n#define RREP(i,b,e) for(int i=(b)-1;i>=e;--i)\n#define rep(i,e) for(int i=0;i<(e);++i)\n\nconstexpr int MOD = 1000000007;\nconstexpr int INF = 1LL << 30;\nconstexpr long long LLINF = 1LL << 62;\nconstexpr double EPS = 1e-9;\n\nstruct Initializer {\n  Initializer() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout << fixed << setprecision(15) << boolalpha;\n  }\n} initializer;\n\ntemplate<typename T>\nistream &operator>>(istream &is, vector<T> &vec) {\n  for (T &x : vec) is >> x;\n  return is;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n  os << \"[\";\n  for (auto it = vec.begin(); it != vec.end(); ++it) {\n    if (it != vec.begin()) os << \", \";\n    os << *it;\n  }\n  return os << \"]\";\n}\n\ntemplate<typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &pa) {\n  return os << \"(\" << pa.first << \", \" << pa.second << \")\";\n}\n\ntemplate<typename Tuple, size_t N>\nstruct TuplePrinter {\n  static void print(const Tuple &t) {\n    TuplePrinter<Tuple, N-1>::print(t);\n    cout << \", \" << get<N-1>(t);\n  }\n};\n\ntemplate<typename Tuple>\nstruct TuplePrinter<Tuple, 1> {\n  static void print(const Tuple &t) {\n    cout << get<0>(t);\n  }\n};\n\ntemplate<typename... T>\nostream &operator<<(ostream &os, const tuple<T...> &tup) {\n  os << \"(\";\n  TuplePrinter<decltype(tup), sizeof...(T)>::print(tup);\n  return os << \")\";\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os, const set<T> &se) {\n  os << \"{\";\n  for (auto it = se.begin(); it != se.end(); ++it) {\n    if (it != se.begin()) os << \", \";\n    os << *it;\n  }\n  return os << \"}\";\n}\n\ntemplate<typename T, typename U>\nostream &operator<<(ostream &os, const map<T, U> &ma) {\n  os << \"{\";\n  for (auto it = ma.begin(); it != ma.end(); ++it) {\n    if (it != ma.begin()) os << \", \";\n    os << it->first << \": \" << it->second;\n  }\n  return os << \"}\";\n}\n\ninline void print(void) { cout<<'\\n'; }\ntemplate<class T> inline void print(const T &x) { cout<<x<<'\\n'; }\ntemplate<class T, class... U> inline void print(const T &x, const U&... y) { cout<<x<<\" \"; print(y...); }\n#define dump(...) cout<<#__VA_ARGS__<<\": [L_\"<<__LINE__<<\"]\"<<'\\n'; print(__VA_ARGS__);cout<<'\\n';\n\ntemplate<class T, class U>inline bool chmax(T &a, const U &b) { if(a<b){ a=b; return 1; } return 0; }\ntemplate<class T, class U>inline bool chmin(T &a, const U &b) { if(b<a){ a=b; return 1; } return 0; }\n\nint main() {\n  int n; cin>>n;\n  vector<pair<int, int>> ab(n);\n  vector<int> as(n), bs(n);\n  vector<int> acc(100010, 0);\n\n  rep(i, n) {\n    int a, b; cin>>a>>b;\n    as[i] = a; bs[i] = b;\n    ab[i].first = a; ab[i].second = b;\n    ++acc[a]; --acc[b];\n  }\n\n  rep(i, 100010-1) acc[i+1] += acc[i];\n  int s2 = *max_element(acc.begin(), acc.end());\n\n  sort(as.begin(), as.end());\n  sort(bs.begin(), bs.end());\n  int s1 = s2;\n  rep(i, n) {\n    int a = ab[i].first, b = ab[i].second;\n    int l = lower_bound(as.begin(), as.end(), b) - as.begin();\n    int r = upper_bound(bs.begin(), bs.end(), a) - bs.begin();\n    s1 = max(s1, l-r);\n  }\n  print(s1, s2);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream&\noperator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream&\noperator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream&\noperator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\n// 1-based index!\ntemplate<typename T>\nstruct BIT {\n    vector<T> data;\n    BIT(size_t n) : data(n + 1, 0) { }\n    T sum(int i){\n        assert(0 <= i);\n        T s = 0;\n        for(; i > 0; i -= i & -i) s += data[i];\n        return s;\n    }\n    T sum(int i,int j){\n        if(i == 0) return 0;\n        assert(0 < i and i <= j);\n        return sum(j) - sum(i - 1);\n    }\n    void add(int i, T x){\n        assert(0 < i);\n        for(; i < data.size(); i += i & -i) data[i] += x;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N; cin >> N;\n    vector<int> A(N), B(N);\n    int M = 0;\n    rep(i, N) {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        A[i] = a; B[i] = b;\n        set_max(M, b + 1);\n    }\n    vector<int> imos(M);\n    vector<int> sum_s(M), sum_e(M);\n    rep(i, N) {\n        int a = A[i], b = B[i];\n        imos[a]++; imos[b]--;\n        A[i] = a; B[i] = b;\n        sum_e[b]++;\n        sum_s[a]++;\n    }\n    rep(i, M - 1) {\n        imos[i + 1] += imos[i];\n        sum_e[i + 1] += sum_e[i];\n        sum_s[M - i - 2] += sum_s[M - i - 1];\n    }\n    int ans1 = *max_element(all(imos));\n    int ans0 = 0;\n    rep(i, N) {\n        int a = A[i], b = B[i];\n        int not_intersect = sum_e[a] + sum_s[b];\n        set_max(ans0, N - not_intersect);\n    }\n    cout << ans0 << \" \" << ans1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n#define _GLIBCXX_DEBUG // for STL debug\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint imos[100010];\n\nconst int SIZE = 1 << 18;\nstruct segtree {\n    int node[2 * SIZE];\n    segtree() {\n        memset(node, 0, sizeof(node));\n    }\n    void add(int x, int val) {\n        x += SIZE - 1;\n        node[x] += val;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = node[2*x+1] + node[2*x+2];\n        }\n    }\n    int query(int a, int b, int l=0, int r=SIZE, int k=0) {\n        if(b <= l or r <= a) return 0;\n        if(a <= l and r <= b) return node[k];\n        int mid = (l + r) / 2;\n        int vl = query(a, b, l, mid, 2*k+1);\n        int vr = query(a, b, mid, r, 2*k+2);\n        return vl + vr;\n    }\n};\n\nint rp[100010], lp[100010];\n\nstruct segment {\n    int l, r;\n    segment() {}\n    segment(int a, int b) : l(a), r(b) {}\n};\n\nsegtree treeone;\nsigned main() {\n    int N; cin >> N;\n    vector<segment> segs;\n    for(int i=0; i<N; i++) {\n        int a, b; cin >> a >> b;\n        segs.push_back(segment(a, b));\n    }\n\n    // sort(segs.begin(), segs.end());\n    int ans1 = 0, ans2 = 0;\n    for(int i=0; i<N; i++) {\n        int l = segs[i].l, r = segs[i].r;\n        imos[l]++;\n        imos[r]--;\n\n        rp[r]++;\n        lp[l]++;\n    }\n\n    for(int i=0; i<100005; i++) {\n        imos[i+1] += imos[i];\n        rp[i+1] += rp[i];\n        chmax(ans2, imos[i]);\n    }\n    for(int i=100005; i>0; i--) {\n        lp[i-1] += lp[i];\n    }\n\n    for(int i=0; i<N; i++) {\n        int l = segs[i].l, r = segs[i].r;\n        int cand = rp[l] + lp[r];\n        chmax(ans1, N - cand);\n    }\n\n    cout << ans1 << \" \" << ans2 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "import java.util.Scanner;\n\n\n\npublic class Main{\n    public static final int MP = 200010; //MaxPassengers\n    public static final int MSN = 100010; //MaxStationNumber\n    public static class p{\n        int bp; //boarding point\n        int dp; //deplaning\n    }\n    public static void main(String[] args){\n        int P1 = 0, P2 = 0;\n        p[] pas = new p[MP]; //passenger\n        int[] igo = new int[MSN]; //is getting on\n        int[] agon = new int[MSN]; //already getting on\n        int[] agoff= new int[MSN]; //already getting off \n        Scanner sc = new Scanner(System.in);\n        int n = Integer.parseInt(sc.next());\n        for(int i = 0; i < n; i++){\n            pas[i] = new p(); \n            pas[i].bp = Integer.parseInt(sc.next());\n            pas[i].dp = Integer.parseInt(sc.next());\n            igo[pas[i].bp]++;\n            igo[pas[i].dp]--;\n            agon[pas[i].bp]++;\n            agoff[pas[i].dp]++;\n        }\n        for(int j = 1; j < MSN; j++){ //make Accumulation\n            igo[j] += igo[j-1];\n            agon[j] += agon[j-1];\n            agoff[j] += agoff[j-1];\n            if(P2 < igo[j]){ //Policy 2\n                P2 = igo[j];\n            }\n        }\n        for(int k = 0; k < n; k++){\n            //i番目の人が降りる一つ前までの駅までに乗ってきた人数-i番目の人が乗る駅で降りている人数\n            if(P1 < (agon[pas[k].dp - 1] - agoff[pas[k].bp])){ \n                P1 = agon[pas[k].dp - 1] - agoff[pas[k].bp];\n            }\n        }\n        System.out.println(P1 + \" \" + P2);\n        sc.close();   \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T> void chmin(T &a,T b){if(a>b) a=b;}\ntemplate<typename T> void chmax(T &a,T b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n;\n  cin>>n;\n  vector<int> a(n),b(n);\n  for(int i=0;i<n;i++) cin>>a[i]>>b[i];\n  vector<int> s(114514,0);\n  for(int i=0;i<n;i++) s[a[i]]++,s[b[i]]--;\n  partial_sum(s.begin(),s.end(),s.begin());\n  int ma=0,mi=*max_element(s.begin(),s.end());\n  vector<int> u=a,v=b;\n  sort(u.begin(),u.end());\n  sort(v.begin(),v.end());\n  for(int i=0;i<n;i++){\n    int tmp=0;\n    tmp+=upper_bound(v.begin(),v.end(),a[i])-v.begin();\n    tmp+=u.end()-lower_bound(u.begin(),u.end(),b[i]);\n    chmax(ma,n-tmp);\n  }\n  cout<<ma<<\" \"<<mi<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// I\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <string>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n#include <cassert>\n#include <cinttypes>\nconst double EPS = 1e-10;\n#define equals(a,b) (fabs((a) - (b)) < EPS)\n\nusing namespace std;\n\ntypedef int64_t ll;\ntypedef uint64_t ull;\n\ntypedef pair<ll, ll> P;\ninline P operator+(const P& p1, const P& p2) {\n  return P(p1.first + p2.first, p1.second + p2.second);\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i] >> b[i];\n  }\n\n  int ans_policy2 = 0;\n  static int imos[2000100] = { };\n  for (int i = 0; i < n; i++) {\n    imos[2 * a[i] + 1]++;\n    imos[2 * b[i]]--;\n  }\n  for (int i = 0; i < 200001; i++) {\n    imos[i + 1] += imos[i];\n    ans_policy2 = max(ans_policy2, imos[i + 1]);\n  }\n\n\n  bool flag = true;\n  for (int i = 0; i < n; i++) {\n    if (imos[2 * b[i]] > 0) {\n      flag = false;\n      break;\n    }\n  }\n\n  if (flag) {\n    cout << min(n, ans_policy2) << \" \";\n  } else {\n    cout << min(n, ans_policy2 + 1) << \" \";\n  }\n  cout << min(n, ans_policy2) << endl;\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<utility>\nusing namespace std;\nint n;\nint a[2<<17],b[2<<17];\nint sum[1<<17],L[1<<17],R[1<<17];\nmain()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i]>>b[i];\n\t\tsum[a[i]]++;\n\t\tsum[b[i]]--;\n\t\tL[b[i]]++;\n\t\tR[a[i]]++;\n\t}\n\tfor(int i=1;i<1<<17;i++)sum[i]+=sum[i-1];\n\tfor(int i=1;i<1<<17;i++)L[i]+=L[i-1];\n\tfor(int i=1<<17;--i;)R[i-1]+=R[i];\n\tint ansa=0,ansb=0;\n\tfor(int i=0;i<1<<17;i++)ansa=max(ansa,sum[i]);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tansb=max(ansb,n-L[a[i]]-R[b[i]]);\n\t}\n\tcout<<ansb<<\" \"<<ansa<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll=long long;\n#define rep(i,a,n) for(ll i=a;i<n;i++)\n#define ALL(s) s.begin(),s.end()\n#define P pair<ll,ll>\n#define vl vector<ll>\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vvl vector<vector<ll>>\n#define print(n) cout<<n<<endl\nconst int M=100111;\nconst int inf=1000000007;\nconst long long INF=1000000000000000007;\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nint ddx[8]={1,-1,0,0,1,-1,-1,1},ddy[8]={0,0,1,-1,1,-1,1,-1};\n\n\nint main(){\n\tint n,a[2*M],b[2*M];\n\tint y[2*M]={},l[2*M]={},r[2*M]={};\n\tcin>>n;\n\trep(i,0,n){\n\t\tcin>>a[i]>>b[i];\n\t\tl[a[i]]++,r[b[i]]++;\n\t\ty[a[i]]++,y[b[i]]--;\n\t}\n\trep(i,1,2*M){\n\t\tl[i]+=l[i-1];\n\t\tr[i]+=r[i-1];\n\t}\n\tint ansx=0,ansy=0;\n\trep(i,0,n){\n\t\tansx=max(ansx,l[b[i]-1]-r[a[i]]);\n\t}\n\tint sumy=0;\n\trep(i,1,2*M){\n\t\tsumy+=y[i];\n\t\tansy=max(ansy,sumy);\n\t}\n\tcout<<ansx<<\" \"<<ansy<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200000 + 100;\nconst int N = 100000;\nint n;\nint a[maxn], b[maxn];\nint cnt[maxn], up[maxn], down[maxn];\n\nint main()\n{\n    cin>>n;\n    int ans1 = 0,ans2 = 0;//保单1和保单2\n    for(int i=1;i<=n;i++)\n    {\n        cin>>a[i]>>b[i];\n        ++cnt[a[i]],--cnt[b[i]];\n        ++up[a[i]],++down[b[i]];\n    }\n    for(int i=1;i<=n;i++)\n    {\n        cnt[i] += cnt[i-1];\n        up[i] += up[i-1];\n        down[i] += down[i-1];\n        ans2 = max(ans2,cnt[i]);\n    }\n    \n    for(int i=1;i<=n;i++)\n    {\n        ans1 = max(ans1,up[b[i]-1]-down[a[i]]);//没离开前的上车人数-上车时已下车人数\n    }\n    cout<<ans1<<' '<<ans2<<'\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\n\nconst int M = 1e5;\n\nint main() {\n\tint N; cin >> N;\n\tvector<int> l(N), r(N);\n\trep(i, N) scanf(\"%d%d\", &l[i], &r[i]), l[i]--, r[i]--;\n\tvector<int> a(M + 1);\n\trep(i, N) a[l[i]]++, a[r[i]]--;\n\trep(j, M) a[j + 1] += a[j];\n\tint ma = 0;\n\trep(j, M) ma = max(ma, a[j]);\n\tvector<int> L = l, R = r;\n\tsort(L.begin(), L.end());\n\tsort(R.begin(), R.end());\n\tint ans = 0;\n\trep(i, N) {\n\t\tint x = lower_bound(L.begin(), L.end(), r[i]) - L.begin();\n\t\tx = N - x;\n\t\tint y = upper_bound(R.begin(), R.end(), l[i]) - R.begin();\n\t\tans = max(ans, N - x - y);\n\t}\n\tcout << ans << ' ' << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 100000\n\nstruct Info{\n\tvoid set(int arg_start,int arg_end){\n\t\tstart = arg_start;\n\t\tend = arg_end;\n\t}\n\tint start,end;\n};\n\nint table1_start[100002],table1_end[100002],table2[100002];\nInfo info[200000];\n\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 0; i <= 100001; i++){\n\t\ttable1_start[i] = 0;\n\t\ttable1_end[i] = 0;\n\t\ttable2[i] = 0;\n\t}\n\n\tint a,b,maximum = 0;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d\",&a,&b);\n\t\tmaximum = max(maximum,b);\n\t\tinfo[loop].set(a,b);\n\t\ttable1_start[a]++;\n\t\ttable1_end[b]++;\n\t\ttable2[a]++;\n\t\ttable2[b]--;\n\t}\n\n\tfor(int i = 1; i <= maximum; i++){\n\t\ttable1_start[i] += table1_start[i-1];\n\t\ttable1_end[i] += table1_end[i-1];\n\t}\n\n\tint max_1 = 0;\n\tint end_after_i_start_num,start_after_i_end_num;\n\n\tfor(int i = 0; i < N; i++){\n\t\tend_after_i_start_num = table1_end[maximum]-table1_end[info[i].start];\n\t\tstart_after_i_end_num = table1_start[maximum]-table1_start[info[i].end-1];\n\t\tmax_1 = max(max_1,end_after_i_start_num-start_after_i_end_num);\n\t}\n\n\tint max_2 = 0;\n\tfor(int i = 1; i <= maximum; i++){\n\t\ttable2[i] += table2[i-1];\n\t\tmax_2 = max(max_2,table2[i]);\n\t}\n\n\tprintf(\"%d %d\\n\",max_1,max_2);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\n\n\nint n;\nvector<P> v;\n\nint calc1() {\n\tvector<int> vle, vri;\n\trep(i, n) {\n\t\tvle.push_back(v[i].first);\n\t\tvri.push_back(v[i].second);\n\t}\n\tsort(vle.begin(), vle.end());\n\tsort(vri.begin(), vri.end());\n\tint ret = 0;\n\trep(i, n) {\n\t\tint cle = upper_bound(vri.begin(), vri.end(), v[i].first) - vri.begin();\n\t\tint cri = lower_bound(vle.begin(), vle.end(), v[i].second) - vle.begin();\n\t\tcri = n - cri;\n\t\t//cout << i<<\" \"<<cle << \" \" << cri << endl;\n\t\tret = max(ret, n-1 - cle - cri + 1);\n\t}\n\treturn ret;\n}\n\nint calc2() {\n\tvector<P> z;\n\trep(i, v.size()) {\n\t\tz.push_back({ v[i].first,0 });\n\t\tz.push_back({ v[i].second,1 });\n\t}\n\tsort(z.begin(), z.end());\n\tint ret = 0;\n\tint cnt = 0;\n\tint len = z.size();\n\trep(i, len) {\n\t\tif (z[i].second)cnt--;\n\t\telse cnt++;\n\t\twhile (i + 1 < len&&z[i].first == z[i + 1].first) {\n\t\t\ti++;\n\t\t\tif (z[i].second)cnt--;\n\t\t\telse cnt++;\n\t\t}\n\t\tret = max(ret, cnt);\n\t}\n\treturn ret;\n}\nvoid solve() {\n\tcin >> n;\n\tv.resize(n);\n\trep(i, n) {\n\t\tcin >> v[i].first >> v[i].second;\n\t\tv[i].first--; v[i].second--;\n\n\t}\n\tcout << calc1() << \" \" << calc2() << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <functional>\n#include <utility>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <map>\n#include <set>\n#include <climits>\ntypedef long long ll;\n#define rll register ll\n#define rint register int\n#define rdouble register double\n#define mem(a) memset(a,0,sizeof(a)\n#define maxn int(1e7)\n#define eps int(1e-6)\n#define inf 0x3f3f3f3f\nusing namespace std;\nint a[maxn+10],b[maxn+10],get[maxn+10],off[maxn+10],p[maxn+10];\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    int cnt=-1;\n    for(int i=1; i<=n; i++)\n    {\n        scanf(\"%d%d\",&a[i],&b[i]);\n        get[a[i]]++;\n        off[b[i]]++;\n\n        p[a[i]]++;\n        p[b[i]]--;\n        cnt=max(cnt,b[i]);\n    }\n    for(int i=1;i<=cnt;i++)\n    {\n        get[i]+=get[i-1];\n        off[i]+=off[i-1];\n        p[i]+=p[i-1];\n    }\n    int ans1=-1,ans2=-1;\n    for(int i=1;i<=cnt;i++)\n    {\n        ans1=max(ans1,get[b[i]-1]-off[a[i]]);\n    }\n    for(int i=1;i<=cnt;i++)\n    {\n        \n        ans2=max(ans2,p[i]);\n    }\n    printf(\"%d %d\\n\", ans1,ans2);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define REP_R(i, n) for (int i = (n) - 1; (i) >= 0; -- (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\ntemplate <class T> inline void chmax(T & a, T const & b) { a = max(a, b); }\n \ntemplate <class Monoid>\nstruct segment_tree {\n    typedef typename Monoid::underlying_type underlying_type;\n    int n;\n    vector<underlying_type> a;\n    Monoid mon;\n    segment_tree() = default;\n    segment_tree(int a_n, underlying_type initial_value = Monoid().unit(), Monoid const & a_mon = Monoid()) : mon(a_mon) {\n        n = 1; while (n < a_n) n *= 2;\n        a.resize(2 * n - 1, mon.unit());\n        fill(a.begin() + (n - 1), a.begin() + ((n - 1) + a_n), initial_value); // set initial values\n        REP_R (i, n - 1) a[i] = mon.append(a[2 * i + 1], a[2 * i + 2]); // propagate initial values\n    }\n    void point_set(int i, underlying_type z) { // 0-based\n        a[i + n - 1] = z;\n        for (i = (i + n) / 2; i > 0; i /= 2) { // 1-based\n            a[i - 1] = mon.append(a[2 * i - 1], a[2 * i]);\n        }\n    }\n    underlying_type range_concat(int l, int r) { // 0-based, [l, r)\n        underlying_type lacc = mon.unit(), racc = mon.unit();\n        for (l += n, r += n; l < r; l /= 2, r /= 2) { // 1-based loop, 2x faster than recursion\n            if (l % 2 == 1) lacc = mon.append(lacc, a[(l ++) - 1]);\n            if (r % 2 == 1) racc = mon.append(a[(-- r) - 1], racc);\n        }\n        return mon.append(lacc, racc);\n    }\n};\nstruct plus_monoid {\n    typedef int underlying_type;\n    int unit() const { return 0; }\n    int append(int a, int b) const { return a + b; }\n};\n \nint policy_1(int n, vector<int> const & a, vector<int> const & b) {\n    int b_max = *max_element(ALL(b));\n    segment_tree<plus_monoid> l(b_max + 1);  // can be a BIT\n    segment_tree<plus_monoid> r(b_max + 1);\n    REP (i, n) {\n        l.point_set(b[i], l.range_concat(b[i], b[i] + 1) + 1);\n        r.point_set(a[i], r.range_concat(a[i], a[i] + 1) + 1);\n    }\n    int result = 0;\n    REP (i, n) {\n        chmax(result, n - l.range_concat(0, a[i] + 1) - r.range_concat(b[i], b_max + 1));\n    }\n    return result;\n}\n \nint policy_2(int n, vector<int> const & a, vector<int> const & b) {\n    int b_max = *max_element(ALL(b));\n    vector<int> imos(b_max + 1);\n    REP (i, n) {\n        imos[a[i]] += 1;\n        imos[b[i]] -= 1;\n    }\n    REP (x, b_max) {\n        imos[x + 1] += imos[x];\n    }\n    return *max_element(ALL(imos));\n}\n \nint main() {\n    // input\n    int n; scanf(\"%d\", &n);\n    vector<int> a(n), b(n);\n    REP (i, n) scanf(\"%d%d\", &a[i], &b[i]);\n    // solve\n    int s1 = policy_1(n, a, b);\n    int s2 = policy_2(n, a, b);\n    // output\n    printf(\"%d %d\\n\", s1, s2);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\ntypedef pair <int, int> pii;\nbool scomp(const pii &a, const pii &b){\n    return (a.second==b.second)? a.first<b.first: a.second<b.second; \n}\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> sum(100002, 0);\n    vector<pii> fs(n);\n    for(int i=0; i<n; i++){\n        int a,b;\n        cin >> a >> b;\n        fs[i] = pii(a,b);\n        sum[a]++;\n        sum[b]--;\n    }\n    for(int i=0; i<100001; i++){\n        sum[i+1] += sum[i];\n    }\n    int ans2 = *max_element(sum.begin(), sum.end());\n\n    vector<pii> sc = fs;\n    sort(fs.begin(), fs.end());\n    sort(sc.begin(), sc.end(), scomp);\n    int ans1 = 0;\n    for(auto e: fs){\n        int sub = n;\n        sub -=  fs.end() -lower_bound(fs.begin(), fs.end(), pii(e.second, 0));\n        sub -= lower_bound(sc.begin(), sc.end(), pii(0, e.first+1), scomp) -sc.begin();\n        ans1 = max(ans1, sub);\n    }\n    cout << ans1 << \" \" << ans2 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int64)1e9\n#define REP(i, n) for(int64 i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int64 i = (a); i < (b); i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint32_t;\nusing int64 = int64_t;\nusing uint64 = uint64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\ntemplate<typename A, typename B> inline void chmin(A &a, B b) { if (a > b) a = b; }\ntemplate<typename A, typename B> inline void chmax(A &a, B b) { if (a < b) a = b; }\n\nint main(void) {\n  int64 n;\n  cin >> n;\n  vector<PLL> ival(n);\n  using T = tuple<int64, int64, int64>;\n  vector<T> ps(2*n);\n  vector<int64> imos(112345, 0);\n  REP(i, n) {\n    cin >> ival[i].fs >> ival[i].sc;\n    imos[ival[i].fs]++; imos[ival[i].sc]--;\n    ps[2*i] = T(2*ival[i].fs+1, -ival[i].sc, i+1);\n    ps[2*i+1] = T(2*ival[i].sc, -ival[i].fs, -i-1);\n  }\n  sort(all(ps));\n  int64 r2 = 0;\n  REP(i, imos.size()-1) {\n    imos[i+1] += imos[i];\n    chmax(r2, imos[i+1]);\n  }\n  multiset<PLL> st;\n  int64 cmp = 0;\n  vector<int64> r1(n+1, 0), sav(n+1, 0);\n  REP(i, ps.size()) {\n    int64 p, id, ot;\n    tie(p, ot, id) = ps[i];\n//    cout << abs(id) << \" \" << p/2 << endl;\n//    cout << \"debug \" << id << \": \";\n//    REP(j, r1.size()) cout << r1[j] << \" \";\n//    cout << endl;\n    if (p%2 == 0) {\n      p /= 2;\n      id = -id;\n      r1[id] += cmp-sav[id]-r1[id];\n      st.erase(st.find(PLL(ival[id-1].fs, id)));\n      r1[id] += st.size();\n//      cout << r1[id] << \" \" << st.size() << \" \" << cmp << \" \" << sav[id] << \" \" << st.begin()->fs << endl;\n\n      if (st.size() && st.begin()->fs <= ival[id-1].fs) r1[id] = 0;\n      cmp++;\n    } else {\n      p /= 2;\n//      cout << p << \" \" << id << \" \" << st.size() << \" insert\" << endl;\n      r1[id] += st.size();\n      sav[id] = cmp;\n      st.emplace(p, id);\n    }\n  }\n//  REP(i, r1.size()) cout << r1[i] << \" \";\n//  cout << endl;\n  cout << *max_element(all(r1))+1 << \" \" << r2 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst int MaxN = 100000;\n\nint n;\nint num[MaxN + 5];\n\nint main()\n{\n\twhile(scanf(\"%d\", &n) != EOF)\n\t{\n\t\tint Max_r = 0;\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tnum[l]++; num[r]--;\n\t\t\tMax_r = max(Max_r, r - 1);\n\t\t}\n\t\tint cnt = 0;\n\t\tnum[0] = 0;\n\t\tfor(int i = 1; i <= Max_r; i++)\n\t\t\tnum[i] = num[i] + num[i - 1];\n\t\t/*\n\t\tfor(int i = 1; i <= Max_r; i++)\n\t\t\tprintf(\"%d \", num[i]);\n\t\tprintf(\"\\n\");\n\t\t*/\n\t\tfor(int i = 1; i <= Max_r; i++)\n\t\t\tcnt = max(cnt, num[i]);\n\t\tbool flag = true;\n\t\tfor(int i = 1; i <= Max_r; i++)\n\t\t\tif(num[i] != cnt)\n\t\t\t\tflag = false;\n\t\tif(flag) printf(\"%d %d\\n\", cnt, cnt);\n\t\telse printf(\"%d %d\\n\", cnt + 1, cnt);\n\t\tmemset(num, 0, sizeof(num));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <stack>\nusing namespace std;\n#define debug(x) std::cerr << #x << \" = \" << (x) << std::endl\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst int MaxN = 1e5;\n\nint biu[MaxN + 5],l[MaxN + 5],r[MaxN + 5],piu[MaxN + 5];\n\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\n\nvoid add(int i,int x)\n{\n\twhile(i <= MaxN)\n\t{\n\t\tbiu[i] += x;\n\t\ti += lowbit(i);\n\t}\n}\n\nint que(int i)\n{\n\tint da = 0;\n\twhile(i > 0)\n\t{\n\t\tda += biu[i];\n\t\ti -= lowbit(i);\n\t}\n\treturn da;\n}\n\nint main()\n{\n\tint n,ans,pia,sum;\n\twhile(~scanf(\"%d\",&n))\n\t{\n\t\tmemset(biu,0,sizeof(biu));\n\t\tfor(int i = 1;i <= n;i++)\n\t\t{\n\t\t\tscanf(\"%d %d\",&l[i],&r[i]);\n\t\t\tadd(l[i],1);\n\t\t\tadd(r[i],-1);\n\t\t}\n\t\tans = 0;\n\t\tfor(int i = 1;i <= n;i++)\n\t\t{\n\t\t\tpia = que(r[i] - 1);\n\t\t\tans = max(ans,pia);\n\t\t}\n\t\tsum = 0;\n\t\tmemset(piu,0,sizeof(piu));\n\t\tmemset(biu,0,sizeof(biu));\n\t\tfor(int i = 1;i <= n;i++)\n\t\t{\n\t\t\tpiu[l[i]]++;\n\t\t\tbiu[r[i]]++;\n\t\t}\n\t\tfor(int i = 1;i <= MaxN;i++)\n\t\t{\n\t\t\tpiu[i] += piu[i - 1];\n\t\t\tbiu[i] += biu[i - 1];\n\t\t}\n\t\tfor(int i = 1;i <= n;i++)\n\t\t{\n\t\t\tpia = piu[r[i] - 1] - biu[l[i]];\n//\t\t\tprintf(\"%d %d %d %d\\n\",r[i],piu[r[i] - 1],l[i],biu[l[i] - 1]);\n\t\t\tsum = max(pia,sum);\n\t\t}\n\t\tprintf(\"%d %d\\n\",sum,ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint dp1[100010],dp2[100010],dp[100010];\n\nint main()\n{\n\tvector<pair<int,int> > v;\n\tint n;cin >> n;\n\tREP(i,n)\n\t{\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tdp1[a]++;dp2[b]++;\n\t\tdp[a]++;dp[b]--;\n\t\tv.PB(MP(a,b));\n\t}\n\t\n\tREP(i,100009)\n\t{\n\t\tdp[i+1] += dp[i];dp1[i+1] += dp1[i];dp2[i+1] += dp2[i];\n\t}\n\t\n\tint ans = 0;\n\tfor(int i = 0;i < n;i++)\n\t{\n\t\tans = max(ans,dp1[v[i].SE-1]-dp2[v[i].FI]);\n\t}\n\tcout << ans << ' ';\n\t\n\tans = 0;\n\tREP(i,100010)\n\t{\n\t\tans = max(ans,dp[i]);\n\t}\n\t\n\tcout << ans << endl;\t\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define WR \"txt\"\n#define N 200010\n\nvoid Open() { freopen(WR\".in\", \"r\", stdin); freopen(WR\".out\", \"w\", stdout); }\nvoid Close() { fclose(stdin); fclose(stdout); }\nusing namespace std;\nint Read()  {\n\tint val = 0, opt = 1; char ch;\n\twhile (!isdigit(ch = getchar() )) if (ch == '-') opt = -1;\n\twhile (isdigit( ch )) (val *= 10) += ch - '0', ch= getchar();\n\treturn val * opt;\n}\n\nint Up[N], Dn[N], Ans1, Ans2, Sum = 0, Max = 0;\nint n, l[N], r[N];\n\nvoid work()  {\n\tn = Read();\n\tint u, v;\n\tfor (int i = 1;i <= n; i++)  {\n\t\tu = Read(), v = Read();\n\t\tUp[u]++, Dn[v]++;\n\t\tl[i] = u, r[i] = v;\n\t}\n\tfor (int i = 1;i <= N - 10; i++)  {\n\t\tMax -= Dn[i];\n\t\tMax += Up[i];\n\t\tUp[i] += Up[i - 1];\n\t\tDn[i] += Dn[i - 1];\n\t\tAns2 = max(Ans2, Max);\n\t}\n\tfor (int i = 1;i <= n; i++) \n\t\tAns1 = max(Ans1, Up[r[i] - 1] - Dn[l[i]]);\n\tprintf(\"%d %d\\n\", Ans1, Ans2);\n}\n\nint main(void)  {\n\t//Open();\n\twork();\n\t//Close();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define REP_R(i, n) for (int i = (n) - 1; (i) >= 0; -- (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\ntemplate <class T> inline void chmax(T & a, T const & b) { a = max(a, b); }\n\ntemplate <class Monoid>\nstruct segment_tree {\n    typedef typename Monoid::underlying_type underlying_type;\n    int n;\n    vector<underlying_type> a;\n    Monoid mon;\n    segment_tree() = default;\n    segment_tree(int a_n, underlying_type initial_value = Monoid().unit(), Monoid const & a_mon = Monoid()) : mon(a_mon) {\n        n = 1; while (n < a_n) n *= 2;\n        a.resize(2 * n - 1, mon.unit());\n        fill(a.begin() + (n - 1), a.begin() + ((n - 1) + a_n), initial_value); // set initial values\n        REP_R (i, n - 1) a[i] = mon.append(a[2 * i + 1], a[2 * i + 2]); // propagate initial values\n    }\n    void point_set(int i, underlying_type z) { // 0-based\n        a[i + n - 1] = z;\n        for (i = (i + n) / 2; i > 0; i /= 2) { // 1-based\n            a[i - 1] = mon.append(a[2 * i - 1], a[2 * i]);\n        }\n    }\n    underlying_type range_concat(int l, int r) { // 0-based, [l, r)\n        underlying_type lacc = mon.unit(), racc = mon.unit();\n        for (l += n, r += n; l < r; l /= 2, r /= 2) { // 1-based loop, 2x faster than recursion\n            if (l % 2 == 1) lacc = mon.append(lacc, a[(l ++) - 1]);\n            if (r % 2 == 1) racc = mon.append(a[(-- r) - 1], racc);\n        }\n        return mon.append(lacc, racc);\n    }\n};\nstruct plus_monoid {\n    typedef int underlying_type;\n    int unit() const { return 0; }\n    int append(int a, int b) const { return a + b; }\n};\n\ntemplate <class OperatorMonoid>\nstruct dual_segment_tree {\n    typedef typename OperatorMonoid::underlying_type operator_type;\n    typedef typename OperatorMonoid::target_type underlying_type;\n    int n;\n    vector<operator_type> f;\n    vector<underlying_type> a;\n    OperatorMonoid op;\n    dual_segment_tree() = default;\n    dual_segment_tree(int a_n, underlying_type initial_value, OperatorMonoid const & a_op = OperatorMonoid()) : op(a_op) {\n        n = 1; while (n < a_n) n *= 2;\n        a.resize(n, initial_value);\n        f.resize(n-1, op.unit());\n    }\n    underlying_type point_get(int i) { // 0-based\n        underlying_type acc = a[i];\n        for (i = (i+n)/2; i > 0; i /= 2) { // 1-based\n            acc = op.apply(f[i-1], acc);\n        }\n        return acc;\n    }\n    void range_apply(int l, int r, operator_type z) { // 0-based, [l, r)\n        assert (0 <= l and l <= r and r <= n);\n        range_apply(0, 0, n, l, r, z);\n    }\n    void range_apply(int i, int il, int ir, int l, int r, operator_type z) {\n        if (l <= il and ir <= r) { // 0-based\n            if (i < f.size()) {\n                f[i] = op.append(z, f[i]);\n            } else {\n                a[i-n+1] = op.apply(z, a[i-n+1]);\n            }\n        } else if (ir <= l or r <= il) {\n            // nop\n        } else {\n            range_apply(2*i+1, il, (il+ir)/2, 0, n, f[i]);\n            range_apply(2*i+2, (il+ir)/2, ir, 0, n, f[i]);\n            f[i] = op.unit();\n            range_apply(2*i+1, il, (il+ir)/2, l, r, z);\n            range_apply(2*i+2, (il+ir)/2, ir, l, r, z);\n        }\n    }\n};\nstruct plus_operator_monoid {\n    typedef int underlying_type;\n    typedef int target_type;\n    int unit() const { return 0; }\n    int append(int a, int b) const { return a + b; }\n    int apply(int a, int b) const { return a + b; }\n};\n\nint policy_1(int n, vector<int> const & a, vector<int> const & b) {\n    int b_max = *max_element(ALL(b));\n    dual_segment_tree<plus_operator_monoid> segtree1(b_max + 1, 0);\n    segment_tree<plus_monoid> segtree2(b_max + 1);\n    int result = 0;\n    REP (i, n) {\n        chmax(result, segtree1.point_get(a[i] - 1) + segtree2.range_concat(a[i], b[i]) + 1);\n        segtree1.range_apply(a[i], b[i] - 1, 1);\n        segtree2.point_set(a[i], segtree2.range_concat(a[i], a[i] + 1) + 1);\n    }\n    return result;\n}\n\nint policy_2(int n, vector<int> const & a, vector<int> const & b) {\n    int b_max = *max_element(ALL(b));\n    vector<int> imos(b_max + 1);\n    REP (i, n) {\n        imos[a[i]] += 1;\n        imos[b[i]] -= 1;\n    }\n    REP (x, b_max) {\n        imos[x + 1] += imos[x];\n    }\n    return *max_element(ALL(imos));\n}\n\nint main() {\n    // input\n    int n; scanf(\"%d\", &n);\n    vector<int> a(n), b(n);\n    REP (i, n) {\n        scanf(\"%d%d\", &a[i], &b[i]);\n    }\n    // solve\n    int s1 = policy_1(n, a, b);\n    int s2 = policy_2(n, a, b);\n    // output\n    printf(\"%d %d\\n\", s1, s2);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\n// #define DEBUG\n\n#ifdef DEBUG\n#define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n\n\nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n\nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstruct Segment_tree {\n    using T = ll;\n\n    int n;\n    vector<T> data;\n    const T out = 0;\n\n    inline T vmerge(T l, T r) {return l + r;}\n\n    Segment_tree(int n): n(n) {data.assign(2 * n, out);}\n\n    void update(int p, T x) { // add value at position p\n        for (data[p += n] += x; p > 1; p >>= 1) data[p >> 1] = vmerge(data[p], data[p ^ 1]);\n    }\n\n    T query(int l, int r) { // sum on interval [l, r)\n        T resl = out, resr = out;\n        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) resl = vmerge(data[l++], resl);\n            if (r & 1) resr = vmerge(resr, data[--r]);\n        }\n        return vmerge(resl, resr);\n    }\n};\n\ninline int pow2fit(int x){\n    int ret = 1;\n    while(ret < x) ret *= 2;\n    return ret;\n}\n\nconst int M = (int)1e5 + 23;\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    using Elem = tuple<int, int, int>;\n    set<Elem> s;\n    Segment_tree segr(pow2fit(M)), segl(pow2fit(M));\n    vi imo(M);\n    rep(i, n){\n        int l, r; cin >> l >> r;\n        l--, r--;\n        imo[l+1]++; imo[r+1]--;\n        s .insert(Elem(r, l, i));\n        segl.update(l, 1);\n    }\n\n    int resl = 0;\n    rep(i, 1, M){\n        int& cur = imo[i];\n        cur = imo[i - 1] + cur;\n        chmax(resl, cur);\n    }\n\n    int resu = 0;\n    for(auto& e : s){\n        int l, r, idx; tie(r, l, idx) = e;\n        int cur = 0;\n        segl.update(l, -1);\n        segr.update(r - 1, 1);\n        cur += segl.query(l, r);\n        cur += segr.query(l, r);\n        chmax(resu, cur);\n    }\n\n    cout << resu << \" \" << resl << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n\nint calc2(vector<P> A){\n  const int N = (1e6) + 100;\n  vector<int> cnt(N, 0);\n  int n = A.size();\n  for(int i=0;i<n;i++){\n    int a, b; tie(a, b) = A[i];\n    cnt[a]++;\n    cnt[b]--;\n  }\n\n  for(int i=1;i<N;i++) cnt[i] += cnt[i-1];\n  int ans = 0;\n  for(int i=0;i<N;i++) Max(ans, cnt[i]);\n  return ans;\n}\n\nint calc1(vector<P> A){\n  int n = A.size();\n  vector<int> L, R;\n  for(int i=0;i<n;i++){\n    int l, r; tie(l, r) = A[i];\n    L.push_back(l);\n    R.push_back(r);\n  }\n  sort(L.begin(), L.end());\n  sort(R.begin(), R.end());\n\n  int ans = 0;\n  for(int i=0;i<n;i++){\n    int l, r; tie(l, r) = A[i];\n    int numL = n - (lower_bound(L.begin(), L.end(), r) - L.begin());\n    int numR = upper_bound(R.begin(), R.end(), l) - R.begin();\n    int num = n - (numL + numR);\n    Max(ans, num);\n  }\n  return ans;\n}\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n;\n  cin>>n;\n  vector<P> A(n);\n  cin>>A;\n  int s1 = calc1(A);\n  int s2 = calc2(A);\n  cout<<s1<<\" \"<<s2<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\nint l[200005], r[200005];\nvector<P> vec;\nvector<int> lvec, rvec;\n\nint main(void)\n{\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> l[i] >> r[i], r[i]--;\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tlvec.push_back(l[i]);\n\t\trvec.push_back(r[i]);\n\t}\n\tsort(lvec.begin(), lvec.end());\n\tsort(rvec.begin(), rvec.end());\n\t\n\tint ans = 0, tmp;\n\tfor(int i = 1; i <= n; i++){\n\t\ttmp = lower_bound(rvec.begin(), rvec.end(), l[i]) - rvec.begin();\n\t\ttmp += lvec.end() - upper_bound(lvec.begin(), lvec.end(), r[i]);\n\t\tans = max(ans, n - tmp);\n\t}\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tvec.push_back(make_pair(l[i], 1));\n\t\tvec.push_back(make_pair(r[i], 2));\n\t}\n\tsort(vec.begin(), vec.end());\n\t\n\tint ans2 = 0, cnt = 0;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tif(vec[i].second == 1) cnt++;\n\t\tif(vec[i].second == 2) cnt--;\n\t\tans2 = max(ans2, cnt);\n\t}\n\t\n\tcout << ans << \" \" << ans2 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define db double\n#define Hzy(o) freopen(o\".in\", \"r\", stdin), freopen(o\".out\", \"w\", stdout)\nusing namespace std;\nconst int INF = 1 << 30;\nconst LL inf = 1LL << 60;\nconst int N = 200010;\nint t[N];\nint sum(int x) {\n\tint res = 0 ;\n\tfor(; x < N; x += x & -x)\n\t\tres += t[x];\n\treturn res;\n}\nvoid add(int x, int d) {\n\tfor(; x; x -= x & -x)\n\t\tt[x] += d;\n}\nint a[N], n, ans1, ans2 = 1;\nvector <int> Q[N], ins[N];\nint read() {\n\tint w(0), f(0); char c = getchar();\n\twhile((c < '0' || c > '9') && c != '-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(c >= '0' && c <= '9') w = w * 10 + c - '0', c = getchar();\n\treturn f ? -w : w;\n}\nint main() {\n\tn = read();\n\tint x, y;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tx = read(), y = read();\n\t\ta[x]++, a[y]--;\n\t\tQ[y].push_back(x);\n\t\tins[x].push_back(y);\n\t}\n\tint now = 0;\n\tfor(int i = 0; i < N; ++i) {\n\t\tnow += a[i];\n\t\tans1 = max(ans1, now);\n\t}\n\tfor(int i = 0; i < N; ++i) {\n\t\tfor(int x : Q[i])\n\t\t\tans2 = max(ans2, sum(x + 1));\n\t\tfor(int x : ins[i])\n\t\t\tadd(x, 1);\n\t}\n\tprintf(\"%d %d\\n\", ans2, ans1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a ; i <= b; ++ i) \nconst int N = 2e5 + 5, M = N , mo = 1e9 + 7 ;\nconst ll inf = 1e17 ;\nusing namespace std ;\n\nstruct poi {\n    int l, r, ans ;\n} a[N], b[N] ;\nmultiset <int> S ;\nint n, bit[N] ;\n\nbool cmpl(poi a, poi b) {\n    return a.l < b.l ;\n}\n\nbool cmpr(poi a, poi b) {\n    return a.r < b.r ;\n}\n\nint solve(int c) {\n    rep(i, 0, M - 5) bit[i] = 0 ;\n    rep(i, 1, n) ++ bit[a[i].l], -- bit[a[i].r] ;\n    rep(i, 1, M - 5) bit[i] += bit[i - 1] ;\n    int res = 0 ;\n    rep(i, 0, M - 5) res = max(res, bit[i]) ;\n    return res ;\n}\n\nvoid put(int x) {\n    for ( ; x <= M - 5 ; x += x & (- x)) bit[x] ++ ;\n}\n\nint get(int x) {\n    int res = 0 ;\n    for ( ; x ; x -= x & (- x)) res += bit[x] ;\n    return res ;\n}\n\nint SOLVE() {\n    sort(a + 1, a + n + 1, cmpl) ;\n    rep(i, 1, n) a[i].ans = n ;\n    rep(i, 1, n) {\n        a[i].ans -= get(a[i].l) ;\n        put(a[i].r) ;\n    }\n    rep(i, 0, M - 5) bit[i] = 0 ;\n    sort(a + 1, a + n + 1, cmpr) ;\n    for (int i = n ; i; -- i) {\n        a[i].ans -= get(M - 5 - a[i].r) ;\n        put(M - 5 - a[i].l) ;\n    }\n    int res = 0 ;\n    rep(i, 1, n) res = max(res, a[i].ans) ;\n    return res ;\n}\n\nint main() {\n    scanf(\"%d\", &n) ;\n    rep(i, 1, n) scanf(\"%d%d\", &a[i].l, &a[i].r) ;\n    printf(\"%d %d\\n\", SOLVE(), solve(1)) ;\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//make_tuple emplace_back next_permutation push_back make_pair second first setprecision\n\n#if MYDEBUG\n#include \"lib/cp_debug.h\"\n#else\n#define DBG(...) ;\n#endif\n\nusing LL = long long;\nconstexpr LL LINF=334ll<<53;\nconstexpr int INF=15<<26;\nconstexpr LL  MOD=1E9+7;\n\n\nstruct Problem{\n    int n;\n    vector<pair<int,int>> p;\n    vector<int> csum,sum;\n    Problem(LL n):n(n),p(n),csum(n+1),sum(n){};\n\n    void solve(){\n        for(int i=0; i<n; ++i){\n            cin >> p[i].first >> p[i].second;\n        }\n        sort(p.begin(),p.end());\n        int ansmin,ansmax;\n        priority_queue<int,vector<int>,greater<int>> pq;\n        pq.push(1);\n        for(int i=0; i<n; ++i){\n            pq.push(p[i].second);\n            if(pq.top()<=p[i].first) pq.pop();\n            csum[i+1]++;\n            int pos = lower_bound(p.begin(),p.end(),make_pair(p[i].second,0))-p.begin();\n            csum[pos]--;\n            sum[i]=pos-i-1;\n        }\n        ansmin=pq.size();\n        for(int i=1; i<n; ++i){\n            csum[i]+=csum[i-1];\n        }\n        DBG(csum)\n\n        for(int i=0; i<n; ++i){\n            csum[i]+=sum[i];\n        }\n        DBG(p)\n        DBG(csum)\n        ansmax=*max_element(csum.begin(),csum.begin()+n)+1;\n        cout << ansmax << ' ' <<ansmin <<\"\\n\";\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    long long n=0;\n    cin >> n;\n    Problem p(n);\n    p.solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nll N, A[200000], B[200000];\n\nint main(void) {\n  cin >> N;\n  REP(i, 0, N) cin >> A[i] >> B[i];\n\n  vector<ll> va(N), vb(N);\n  REP(i, 0, N) va[i] = A[i];\n  REP(i, 0, N) vb[i] = B[i];\n\n  sort(va.begin(), va.end());\n  sort(vb.begin(), vb.end());\n\n  ll ans1 = 0;\n  REP(i, 0, N) {\n    ll p = upper_bound(vb.begin(), vb.end(), A[i]) - vb.begin();\n    ll q = va.end() - lower_bound(va.begin(), va.end(), B[i]);\n    ans1 = max(ans1, N - p - q);\n  }\n\n  vector<ll> imos(200001, 0);\n  REP(i, 0, N) {\n    imos[A[i]]++;\n    imos[B[i]]--;\n  }\n  REP(i, 0, 200000) imos[i + 1] += imos[i];\n  ll ans2 = 0;\n  REP(i, 0, 200000) ans2 = max(ans2, imos[i]);\n\n  cout << ans1 << \" \" << ans2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define itrep(i, a) for (auto i = (a).begin(); i != (a).end(); i++)\n#define REP(i, a, n) for (int i = (a); i <= (n); i++)\n#define all(a) (a).begin(), (a).end()\n#define mp(a, b) make_pair((a), (b))\n\nusing namespace std;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, -1, 0, 1 };\n\ntemplate<class T> void inputVector(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < v.size(); i++) cin >> v[i];\n}\n\nstruct Interval {\n    int a, b;\n    Interval() {}\n    Interval(int a, int b) {\n\tthis->a = a;\n\tthis->b = b;\n    }\n};\n\nint memo2[100010];\n\nvector<pair<int, int>> prs;\n\nsigned main() {\n    int N;\n    cin >> N;\n\n    rep(i, N) {\n\tint a, b;\n\tscanf(\"%d %d\", &a, &b);\n\tprs.push_back(mp(a, b));\n    }\n\n    sort(all(prs));\n\n    int ret2 = 0;\n    rep(i, N) {\n\tmemo2[prs[i].first]++;\n\tmemo2[prs[i].second]--;\n    }\n    REP(i, 1, 100005) {\n\tmemo2[i] += memo2[i - 1];\n\tret2 = max(ret2, memo2[i]);\n    }\n\n    int ret = 0;\n    priority_queue<int> q;\n    rep(i, N) {\n\twhile (!q.empty() && -q.top() <= prs[i].first) q.pop();\n\tint cnt = q.size();\n\n\tint low = i;\n\tint high = N;\n\tint mid = (high + low) / 2;\n\tint base = prs[i].second;\n\twhile (high - low > 1) {\n\t    if (prs[mid].first < base) {\n\t\tlow = mid;\n\t    } else {\n\t\thigh = mid;\n\t    }\n\t    mid = (high + low) / 2;\n\t}\n\n\tret = max(mid - i + cnt + 1, ret);\n\n\tq.push(-prs[i].second);\n    }\n\n    cout << ret << \" \" << ret2 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, a[200009], b[200009], imos[100009], bit[100009]; vector<int> g[100009], gs[100009];\nvoid add(int pos, int val) {\n\tfor (int i = pos + 1; i <= 100000; i += i & (-i)) bit[i] += val;\n}\nint sum(int pos) {\n\tint ret = 0;\n\tfor (int i = pos; i >= 1; i -= i & (-i)) ret += bit[i];\n\treturn ret;\n}\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i] >> b[i]; a[i]--; b[i] -= 2;\n\t\timos[a[i]]++;\n\t\timos[b[i] + 1]--;\n\t\tg[b[i]].push_back(i);\n\t\tgs[a[i]].push_back(i);\n\t}\n\tfor (int i = 0; i < 100000; i++) imos[i + 1] += imos[i];\n\tint rb = *max_element(imos, imos + 100000), ra = 0;\n\tfor (int i = 0; i <= 100000; i++) {\n\t\tfor (int j : gs[i]) add(i, 1);\n\t\tfor (int j : g[i]) add(a[j], -1), add(i, 1);\n\t\tfor (int j : g[i]) ra = max(ra, sum(i + 1) - sum(a[j]));\n\t}\n\tcout << ra << ' ' << rb << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint calc2(int n, const vi &a, const vi &b){\n\tvector<pi> v;\n\trep(i, n){\n\t\tv.emplace_back(a[i], 1);\n\t\tv.emplace_back(b[i], -1);\n\t}\n\tsort(all(v));\n\tint sum = 0, mx = 0;\n\tfor(pi p : v){\n\t\tif(p.second < 0) --sum;\n\t\telse mx = max(mx, ++sum);\n\t}\n\treturn mx;\n}\ntemplate<class T>struct SegTreeSum{\n\tT *dat;\n\tint n;\n\tSegTreeSum(int size = 1000000){\n\t\tfor(n = 1; n < size; n *= 2);\n\t\tdat = new T[2 * n - 1];\n\t\tinit();\n\t}\n\t~SegTreeSum(){ delete [] dat; }\n\t\n\tvoid init(){\n\t\trep(i, 2 * n - 1) dat[i] = 0;\n\t}\n\tvoid inc(int k){\n\t\tk += n - 1;\n\t\tdat[k]++;\n\t\t\n\t\twhile(k > 0){\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = dat[k * 2 + 1] + dat[k * 2 + 2];\n\t\t}\n\t}\n\tT query(int a, int b, int k, int l, int r){\n\t\tif(r <= a || b <= l) return 0;\n\t\tif(a <= l && r <= b) return dat[k];\n\t\t\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\n\t\treturn vl + vr;\n\t}\n\tT query(int a, int b){ return query(a, b, 0, 0, n); }\n};\nint calc1(int n, const vi &a, const vi &b){\n\tconst int MX = 100010;\n\tSegTreeSum<int> from(MX);\n\tSegTreeSum<int> to(MX);\n\tSegTreeSum<int> tmp(MX);\n\tvector<tuple<int, int, int>> v;\n\t\n\trep(i, n){\n\t\tfrom.inc(a[i]);\n\t\tto.inc(b[i]);\n\t\tv.emplace_back(b[i], -a[i], i);\n\t}\n\tsort(all(v));\n\tint ans = 0;\n\trep(i, v.size()){\n\t\tint a, b, id; tie(b, a, id) = v[i]; a *= -1;\n\t\tint cnt = 0, skip = 0;\n\t\tfor(int j = i; j < v.size(); j++){\n\t\t\tif(get<0>(v[j]) != b || get<1>(v[j]) != -a) break;\n\t\t\ttmp.inc(a);\n\t\t\tskip++;\n\t\t}\n\t\ti += skip - 1;\n\t\t\n\t\tcnt += from.query(a, b); //dbg(a, b, id); dbg(cnt);\n\t\tcnt += to.query(a + 1, b + 1); //dbg(cnt);\n\t\tcnt -= tmp.query(a, b); //dbg(cnt);\n\t\tans = max(ans, cnt);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n; cin >> n;\n\tvi a(n), b(n);\n\trep(i, n) cin >> a[i] >> b[i];\n\t\n\tint ans2 = calc2(n, a, b);\n\tint ans1 = calc1(n, a, b);\n\tcout << ans1 << \" \" << ans2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\n#define FRER() freopen(\"i.txt\", \"r\", stdin);\n\nusing namespace std;\n\nconst int maxn = 200000 + 5;\n\nint l[maxn], r[maxn], ml[maxn] = {0}, mr[maxn] = {0}, sum[maxn] = {0};\n\nint main()\n{\n\tint n, ans1 = 0, ans2 = 0;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tscanf(\"%d %d\", &l[i], &r[i]);\n\t\t++sum[l[i]];\n\t\t--sum[r[i]];\n\t\t++ml[l[i]];\n\t\t++mr[r[i]];\n\t}\n\tfor(int i = 1; i < maxn; ++i) {\n\t\tsum[i] += sum[i - 1];\n\t\tml[i] += ml[i - 1];\n\t\tmr[i] += mr[i - 1];\n\t\tans2 = max(ans2, sum[i]);\n\t}\n\tfor(int i = 0; i < n; ++i) {\n\t\tans1 = max(ans1, ml[r[i] - 1] - mr[l[i]]);\n\t}\n\tprintf(\"%d %d\\n\", ans1, ans2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<vector>\n#include<tuple>\n#define llint long long int\n#define lldo long double\n#define fir first\n#define sec second\n#define pub push_back\n#define mp make_pair\n#define mt make_tuple\nvoid maxeq(int &a,int b){if(a<b){a=b;}}\nusing namespace std;\nint main(void){\n\tint n,i,ansA=0,ansB=0;cin>>n;\n\tvector<pair<int,int>> hito(n);\n\tvector<int>nin(100001);//?????°\n\tvector<int>sta(100001);//??????????´???????\n\tfor(i=0;i<n;i++){\n\t\tcin>>hito[i].fir>>hito[i].sec;\n\t\tnin[hito[i].fir]++;\n\t\tsta[hito[i].fir]++;\n\t\tnin[hito[i].sec]--;\n\t}\n\tfor(i=1;i<=100000;i++){nin[i]+=nin[i-1];sta[i]+=sta[i-1];}\n\tfor(i=0;i<n;i++){\n\t\tmaxeq(ansB,nin[hito[i].fir]);\n\t\tmaxeq(ansA,nin[hito[i].fir]+sta[hito[i].sec-1]-sta[hito[i].fir]);\n\t}\n\tcout<<ansA<<\" \"<<ansB<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nint imos[1<<17];\nint a[1<<17],b[1<<17],ca[1<<17],cb[1<<17];\n\nint main(){\n    int n;cin >> n;\n    vector<P> p(n);\n    for (int i = 0; i < n; i++) {\n        cin >> p[i].fs >> p[i].sc;\n        p[i].fs--,p[i].sc--;\n        imos[p[i].fs]++;\n        imos[p[i].sc]--;\n        a[p[i].sc-1]++;\n        b[p[i].fs]++;\n    }\n    for (int i = 0; i <= 100000 ; i++) {\n        ca[i+1] = ca[i] + a[i];\n    }\n    for (int i = 100000; i >= 0 ; i--) {\n        cb[i] = cb[i+1] + b[i];\n    }\n    int ans1 = 0;\n    for (int i = 0; i < n; i++) {\n        int tmp = ca[p[i].fs] + cb[p[i].sc];\n        ans1 = max(ans1, n - tmp);\n    }\n    for (int i = 0; i < 100000; i++) {\n        imos[i+1] += imos[i];\n    }\n    int ans2 = 0;\n    for (int i = 0; i <= 100000; i++) {\n        ans2 = max(ans2,imos[i]);\n    }\n    cout << ans1 << \" \" << ans2 << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a ; i <= b; ++ i) \nconst int N = 2e5 + 5, M = N , mo = 1e9 + 7 ;\nconst ll inf = 1e17 ;\nusing namespace std ;\n\nstruct poi {\n    int l, r, ans ;\n} a[N], b[N] ;\nmultiset <int> S ;\nint n, bit[N] ;\n\nbool cmpl(poi a, poi b) {\n    return a.l < b.l ;\n}\n\nbool cmpr(poi a, poi b) {\n    return a.r < b.r ;\n}\n\nint solve() {\n    rep(i, 0, M - 5) bit[i] = 0 ;\n    rep(i, 1, n) ++ bit[a[i].l], -- bit[a[i].r] ;\n    rep(i, 1, M - 5) bit[i] += bit[i - 1] ;\n    int res = 0 ;\n    rep(i, 0, M - 5) res = max(res, bit[i]) ;\n    return res ;\n}\n\nvoid put(int x) {\n    for ( ; x <= M - 5 ; x += x & (- x)) bit[x] ++ ;\n}\n\nint get(int x) {\n    int res = 0 ;\n    for ( ; x ; x -= x & (- x)) res += bit[x] ;\n    return res ;\n}\n\nint l[N],r[N];\n\nint SOLVE() {\n\tfor (int i=1;i<=n;i++) {\n\t\tl[a[i].l]++; r[a[i].r]++;\n\t}\n\tfor (int i=1;i<=200000;i++) l[i]+=l[i-1],r[i]+=r[i-1];\n    int res = 0 ;\n\trep(i,1,n) res=max(res,l[a[i].r-1]-r[a[i].l]);\n    return res ;\n}\n\nint main() {\n    scanf(\"%d\", &n) ;\n    rep(i, 1, n) scanf(\"%d%d\", &a[i].l, &a[i].r) ;\n    int r=solve();\n    printf(\"%d %d\\n\", SOLVE(), r) ;\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\nusing namespace std;\n\nconst int maxn = 200000 + 10;\nstruct Node {\n    int l,r;\n    bool operator < (const Node& b) const {\n        return r == b.r && l > b.l || r < b.r;\n    }\n}P[maxn];\nvector<int> sl,sr;\nint n;\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i = 0; i < n; i++) {\n        scanf(\"%d %d\",&P[i].l,&P[i].r);\n        sl.push_back(P[i].l);\n        sr.push_back(P[i].r);\n    }\n    sort(sl.begin(),sl.end());\n    sort(sr.begin(),sr.end());\n    int mmax = 0;\n    for(int i = 0; i < n; i++) {\n        int t1 = upper_bound(sr.begin(),sr.end(),P[i].l) - sr.begin();\n        int t2 = lower_bound(sl.begin(),sl.end(),P[i].r) - sl.begin();\n        t2 = n - t2;\n        mmax = max(mmax,n - t1 - t2);\n    }\n    sort(P, P + n);\n    multiset<int> s;\n    multiset<int>::iterator it;\n    for(int i = 0; i < n; i++) {\n        if(s.empty()) {\n            s.insert(-P[i].r);\n        } else {\n            it = s.lower_bound(-P[i].l);\n            if(it == s.end()) {\n                s.insert(-P[i].r);\n            } else {\n                s.erase(it);\n                s.insert(-P[i].r);\n            }\n        }\n    }\n    cout << mmax << \" \" << s.size() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=2*1e5+100;\nint a[maxn],b[maxn],s[maxn],sum[maxn],rr[maxn],ll[maxn];\nint main()\n{\n    //freopen(\"i.txt\",\"r\",stdin);\n    int n,t,last,ans2=0,ans1=0;\n    scanf(\"%d\",&n);\n    priority_queue<int,vector<int>,greater<int> >r;\n    priority_queue<int,vector<int>,less<int> >l;\n    for(int i=0; i<n; i++)\n    {\n        scanf(\"%d %d\",&a[i],&b[i]);\n        s[a[i]]++,s[b[i]]--;\n        l.push(a[i]),r.push(b[i]);\n    }\n    t=r.top(),r.pop();\n    rr[last=t]=1;\n    while(!r.empty())\n    {\n        t=r.top(),r.pop();\n        rr[t]=rr[last]+1;\n        last=t;\n    }\n    t=l.top(),l.pop();\n    ll[last=t]=1;\n    while(!l.empty())\n    {\n        t=l.top(),l.pop();\n        ll[t]=ll[last]+1;\n        last=t;\n    }\n    for(int i=1; i<=100000; i++)\n        if(!rr[i])rr[i]=rr[i-1];\n    for(int i=100000; i>=0; i--)\n        if(!ll[i])ll[i]=ll[i+1];\n    for(int i=0; i<n; i++)\n        ans1=max(n-ll[b[i]]-rr[a[i]],ans1);\n    for(int i=1; i<=100000; i++)\n        ans2=max(s[i]=s[i-1]+s[i],ans2);\n    printf(\"%d %d\\n\",ans1,ans2);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#if __has_include(\"../library/Basic/Debug.hpp\")\n\n#include \"../library/Basic/Debug.hpp\"\n\n#else\n\n/* ----- Header Files ----- */\n// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <cstdint>\n\n\n/* ----- Type Alias ----- */\nusing Bool = bool;\nusing Int = long long int;\nusing Real = long double;\nusing Char = char;\nusing String = std::string;\ntemplate <class... Ts>\nusing Tuple = std::tuple<Ts...>;\n\ntemplate <class T>\nusing Vector = std::vector<T>;\ntemplate <class T>\nusing Matrix = Vector<Vector<T>>;\ntemplate <class T>\nusing Queue = std::queue<T>;\ntemplate <class T>\nusing Stack = std::stack<T>;\ntemplate <class T>\nusing Deque = std::deque<T>;\n\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T>\nusing Set = std::set<T>;\ntemplate <class T, class U>\nusing Map = std::map<T, U>;\n\ntemplate <class T, class... Us>\nusing Func = std::function<T(Us...)>;\n\ntemplate <class T>\nT genv(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto genv(size_t l, Ts... ts) {\n    return Vector<decltype(genv<T>(ts...))>(l, genv<T>(ts...));\n}\n\ntemplate <class Cost = Int>\nstruct Edge {\n    Int src, dst;\n    Cost cost;\n    Edge(Int src = -1, Int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = Int>\nusing Edges = Vector<Edge<Cost>>;\ntemplate <class Cost = Int>\nusing Graph = Vector<Vector<Edge<Cost>>>;\n\n#endif\n\n/* ----- Misc ----- */\nvoid fastio() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n}\n\nstruct Fout {\n    Int precision;\n    Fout(Int precision) : precision(precision) {}\n};\nstd::ostream& operator<<(std::ostream& os, const Fout& fio) {\n    os << std::fixed << std::setprecision(fio.precision);\n    return os;\n}\n\n\n/* ----- Constants ----- */\n// constexpr Int INF = std::numeric_limits<Int>::max() / 3;\n// constexpr Int MOD = 1000000007;\n// constexpr Real PI = acos(-1);\n// constexpr Real EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nconstexpr Int L = 100000;\n\nint main() {\n    Int n;\n    std::cin >> n;\n\n    Vector<Int> l(n), r(n);\n    Vector<Int> ls(L, 0), rs(L, 0), imos(L + 1, 0);\n    for (Int i = 0; i < n; ++i) {\n        std::cin >> l[i] >> r[i];\n        --l[i], --r[i];\n        ++ls[l[i]], ++rs[r[i]];\n        ++imos[l[i]], --imos[r[i]];\n    }\n\n    std::partial_sum(ls.begin(), ls.end(), ls.begin());\n    std::partial_sum(rs.begin(), rs.end(), rs.begin());\n    std::partial_sum(imos.begin(), imos.end(), imos.begin());\n\n    Int ans1 = 0;\n    for (Int i = 0; i < n; ++i) {\n        ans1 = std::max(ans1, ls[r[i] - 1] - rs[l[i]]);\n    }\n    Int ans2 = *std::max_element(imos.begin(), imos.end());\n\n    std::cout << ans1 << ' ' << ans2 << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define pb push_back\n#define LIM 210005\n\nusing namespace std;\n\nvi lft,rgt;\nint n, xx[LIM], yy[LIM];\n\n#define MAX 200105\n\nint arr[LIM];\n\nint notun()\n{\n//    int n;\n//    sf(n);\n    for(int i=0; i<n; i++)\n    {\n//        int a,b;\n\n//        sff(a,b);\n        arr[ xx[i] ]++;\n        arr[ yy[i] ]--;\n    }\n\n    int mx = INT_MIN;\n\n    for(int i=1; i<=MAX; i++)\n    {\n        arr[i] += arr[i-1];\n        mx = max(mx,arr[i]);\n    }\n\n    cout << \" \" << mx << endl;\n\n\n\n    return 0;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i=0; i<n; i++) {\n        int x,y;\n        scanf(\"%d %d\", &x,&y);\n        xx[i] = x; yy[i] = y;\n        lft.pb(x); rgt.pb(y);\n    }\n    sort(lft.begin(), lft.end());\n    sort(rgt.begin(), rgt.end());\n\n    int ans = 0;\n    for(int i=0; i<n; i++) {\n        int pise = upper_bound(rgt.begin(), rgt.end(), xx[i])-rgt.begin();\n        int samne= n-(lower_bound(lft.begin(), lft.end(), yy[i])-lft.begin());\n        ans = max( ans, n - pise - samne );\n//        cout << i << ' ' << pise << ' ' << samne << endl;\n    }\n    cout << ans ;\n\n    notun();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <string>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n#include <cassert>\n#include <cinttypes>\nconst double EPS = 1e-10;\n#define equals(a,b) (fabs((a) - (b)) < EPS)\n\nusing namespace std;\n\ntypedef int64_t ll;\ntypedef uint64_t ull;\n\ntypedef pair<ll, ll> P;\ninline P operator+(const P& p1, const P& p2) {\n  return P(p1.first + p2.first, p1.second + p2.second);\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i] >> b[i];\n  }\n\n  int ans_policy2 = 0;\n  static int imos[2000100] = { };\n  for (int i = 0; i < n; i++) {\n    imos[2 * a[i] + 1]++;\n    imos[2 * b[i]]--;\n  }\n  for (int i = 0; i < 200001; i++) {\n    imos[i + 1] += imos[i];\n    ans_policy2 = max(ans_policy2, imos[i + 1]);\n  }\n\n\n  bool flag = true;\n  for (int i = 0; i < n; i++) {\n    if (imos[2 * b[i]] > 0) {\n      flag = false;\n      break;\n    }\n  }\n\n  if (flag) {\n    cout << ans_policy2 << \" \";\n  } else {\n    cout << ans_policy2 + 1 << \" \";\n  }\n  cout << ans_policy2 << endl;\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconstexpr int INF = 1LL << 60;\n\nconstexpr int MAX_N = 200000;\nconstexpr int MAX_B = 100005;\n\ntypedef pair<int, int> pii;\n\nint n, a[MAX_N], b[MAX_N], sumB[MAX_B], sumA[MAX_B], imos[MAX_B];\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n\n        sumB[b[i]]++;\n        sumA[a[i]]++;\n\n        imos[a[i]]++;\n        imos[b[i]]--;\n    }\n\n    int ans2 = 0;\n    for (int i = 1; i < MAX_B; i++)\n    {\n        sumB[i] += sumB[i - 1];\n        sumA[MAX_B - i - 1] += sumA[MAX_B - i];\n\n        imos[i] += imos[i - 1];\n        ans2 = max(ans2, imos[i]);\n    }\n\n    int ans1 = 0;\n    for (int i = 0; i < n; i++)\n    {\n        ans1 = max(ans1, n - sumB[a[i]] - sumA[b[i]]);\n    }\n\n    cout << ans1 << \" \" << ans2 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a ; i <= b; ++ i) \nconst int N = 2e5 + 5, M = N , mo = 1e9 + 7 ;\nconst ll inf = 1e17 ;\nusing namespace std ;\n\nstruct poi {\n    int l, r, ans ;\n} a[N], b[N] ;\nmultiset <int> S ;\nint n, bit[N] ;\n\nbool cmpl(poi a, poi b) {\n    return a.l < b.l ;\n}\n\nbool cmpr(poi a, poi b) {\n    return a.r < b.r ;\n}\n\nint solve() {\n    rep(i, 0, M - 5) bit[i] = 0 ;\n    rep(i, 1, n) ++ bit[a[i].l], -- bit[a[i].r] ;\n    rep(i, 1, M - 5) bit[i] += bit[i - 1] ;\n    int res = 0 ;\n    rep(i, 0, M - 5) res = max(res, bit[i]) ;\n    return res ;\n}\n\nvoid put(int x) {\n    for ( ; x <= M - 5 ; x += x & (- x)) bit[x] ++ ;\n}\n\nint get(int x) {\n    int res = 0 ;\n    for ( ; x ; x -= x & (- x)) res += bit[x] ;\n    return res ;\n}\n\nint l[N],r[N];\n\nint SOLVE() {\n\trep(i,1,M-5) bit[i]=0;\n    sort(a + 1, a + n + 1, cmpl) ;\n    rep(i, 1, n) a[i].ans = n ;\n    rep(i, 1, n) {\n        a[i].ans -= get(a[i].l) ;\n        put(a[i].r) ;\n    }\n    rep(i, 0, M - 5) bit[i] = 0 ;\n    sort(a + 1, a + n + 1, cmpr) ;\n    for (int i = n ; i; -- i) {\n        a[i].ans -= get(M - 5 - a[i].r) ;\n        put(M - 5 - a[i].l) ;\n    }\n    int res = 0 ;\n    rep(i, 1, n) res = max(res, a[i].ans) ;\n    return res ;\n}\n\nint main() {\n    scanf(\"%d\", &n) ;\n    rep(i, 1, n) scanf(\"%d%d\", &a[i].l, &a[i].r) ;\n//    int r=SOLVE();\n    printf(\"%d %d\\n\", SOLVE(), solve()) ;\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n\nint calc2(vector<P> A){\n  const int N = (1e6) + 100;\n  vector<int> cnt(N, 0);\n  int n = A.size();\n  for(int i=0;i<n;i++){\n    int a, b; tie(a, b) = A[i];\n    cnt[a]++;\n    cnt[b]--;\n  }\n\n  for(int i=1;i<N;i++) cnt[i] += cnt[i-1];\n  int ans = 0;\n  for(int i=0;i<N;i++) Max(ans, cnt[i]);\n  return ans;\n}\n\nint calc1(vector<P> A){\n  int n = A.size();\n  vector<int> L, R;\n  for(int i=0;i<n;i++){\n    int l, r; tie(l, r) = A[i];\n    L.push_back(l);\n    R.push_back(r);\n  }\n  sort(L.begin(), L.end());\n  sort(R.begin(), R.end());\n\n  int ans = 0;\n  for(int i=0;i<n;i++){\n    int l, r; tie(l, r) = A[i];\n    int numL = n - (lower_bound(L.begin(), L.end(), r) - L.begin());\n    int numR = upper_bound(R.begin(), R.end(), l) - R.begin();\n    int num = n - (numL + numR);\n    Max(ans, num);\n  }\n  return ans;\n}\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n;\n  cin>>n;\n  vector<P> A(n);\n  cin>>A;\n  int s1 = calc1(A);\n  int s2 = calc2(A);\n  cout<<s1<<\" \"<<s2<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint memo[201000];\n\nint main()\n{\n\tint n;cin >> n;\n\tvector<pair<pair<int,int>,int> > v;\n\tREP(i,n)\n\t{\n\t\tint a,b;cin >> a >> b;\n\t\tv.PB(MP(MP(a,i),1));\n\t\tv.PB(MP(MP(b,i),0));\n\t}\n\t\n\tsort(ALL(v));\n\t\n\tll ans1 = 0,ans2 = 0,imos = 0;\n\tll inin = 0,ouou = 0;\n\t\n\tREP(i,v.size())\n\t{\n\t\tvector<pair<pair<int,int>,int> > now;\n\t\tauto tmp = v[i];\n\t\tnow.PB(tmp);\n\t\twhile(i+1 != v.size()&&tmp.FI == v[i+1].FI)\n\t\t{\n\t\t\tauto tmtm = v[i+1];\n\t\t\tnow.PB(tmtm);\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tREP(j,now.size())\n\t\t{\n\t\t\tif(now[j].SE == 1)\n\t\t\t{\n\t\t\t\tinin++;\n\t\t\t\timos++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\touou++;\n\t\t\t\timos--;\n\t\t\t}\n\t\t}\n\t\tans1 = max(ans1,imos);\n\t\t\n\t\tREP(j,now.size())\n\t\t{\n\t\t\tint num = now[j].FI.SE;\n\t\t\tif(now[j].SE == 1)\n\t\t\t{\n\t\t\t\tmemo[num] = ouou;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tll tmtm = inin - memo[num];\n\t\t\t\tans2 = max(ans2,tmtm);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans2 << \" \"\t<< ans1 << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll N=1e6+10;\nstruct sc\n{\n    ll x,y;\n}p[N];\nll vis[N],m,a[N],b[N];\nll sum[N];\nint main()\n{\n    //freopen(\"i.txt\",\"r\",stdin);\n    scanf(\"%lld\",&m);\n    for(int i=0; i<m; i++)\n    {\n        scanf(\"%lld %lld\",&p[i].x,&p[i].y);\n        vis[p[i].x]++;\n        vis[p[i].y]--;\n        a[p[i].x]++;\n        b[p[i].y]++;\n    }\n    ll ans1=0,ans2=0;\n    for(int i=1; i<=100000; i++)\n    {\n        vis[i]+=vis[i-1];\n        ans2=max(vis[i],ans2);\n        a[i]+=a[i-1];\n        b[i]+=b[i-1];\n    }\n    for(int i=0; i<m; i++)\n        ans1=max(ans1,m-a[100000]+a[p[i].y-1]-b[p[i].x]);\n    printf(\"%lld %lld\\n\",ans1,ans2);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int MAX = 1e5 + 2;\n    vector<int> a(n), b(n);\n    vector<int> imos(MAX);\n    vector<int> sum(MAX), rsum(MAX);\n    for(int i = 0; i < n; ++i) {\n        cin >> a[i] >> b[i];\n        imos[a[i]]++;\n        imos[b[i]]--;\n        sum[b[i]]++;\n        rsum[a[i]]++;\n    }\n    for(int i = 1; i < MAX; ++i) {\n        imos[i] += imos[i - 1];\n        sum[i] += sum[i - 1];\n    }\n    for(int i = MAX - 1; i >= 1; --i) {\n        rsum[i - 1] += rsum[i];\n    }\n    int ans1 = 0, ans2 = *max_element(imos.begin(), imos.end());\n    for(int i = 0; i < n; ++i) {\n        ans1 = max(ans1, n - sum[a[i]] - rsum[b[i]]);\n    }\n    cout << ans1 << ' ' << ans2 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define REP_R(i, n) for (int i = (n) - 1; (i) >= 0; -- (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\ntemplate <class T> inline void chmax(T & a, T const & b) { a = max(a, b); }\n\ntemplate <class Monoid>\nstruct segment_tree {\n    typedef typename Monoid::underlying_type underlying_type;\n    int n;\n    vector<underlying_type> a;\n    Monoid mon;\n    segment_tree() = default;\n    segment_tree(int a_n, underlying_type initial_value = Monoid().unit(), Monoid const & a_mon = Monoid()) : mon(a_mon) {\n        n = 1; while (n < a_n) n *= 2;\n        a.resize(2 * n - 1, mon.unit());\n        fill(a.begin() + (n - 1), a.begin() + ((n - 1) + a_n), initial_value); // set initial values\n        REP_R (i, n - 1) a[i] = mon.append(a[2 * i + 1], a[2 * i + 2]); // propagate initial values\n    }\n    void point_set(int i, underlying_type z) { // 0-based\n        a[i + n - 1] = z;\n        for (i = (i + n) / 2; i > 0; i /= 2) { // 1-based\n            a[i - 1] = mon.append(a[2 * i - 1], a[2 * i]);\n        }\n    }\n    underlying_type range_concat(int l, int r) { // 0-based, [l, r)\n        underlying_type lacc = mon.unit(), racc = mon.unit();\n        for (l += n, r += n; l < r; l /= 2, r /= 2) { // 1-based loop, 2x faster than recursion\n            if (l % 2 == 1) lacc = mon.append(lacc, a[(l ++) - 1]);\n            if (r % 2 == 1) racc = mon.append(a[(-- r) - 1], racc);\n        }\n        return mon.append(lacc, racc);\n    }\n};\nstruct plus_monoid {\n    typedef int underlying_type;\n    int unit() const { return 0; }\n    int append(int a, int b) const { return a + b; }\n};\n\nint policy_1(int n, vector<int> const & a, vector<int> const & b) {\n    int b_max = *max_element(ALL(b));\n    segment_tree<plus_monoid> l(b_max + 1);\n    segment_tree<plus_monoid> r(b_max + 1);\n    REP (i, n) {\n        l.point_set(b[i], l.range_concat(b[i], b[i] + 1) + 1);\n        r.point_set(a[i], r.range_concat(a[i], a[i] + 1) + 1);\n    }\n    int result = 0;\n    REP (i, n) {\n        chmax(result, n - l.range_concat(0, a[i] + 1) - r.range_concat(b[i], b_max + 1));\n    }\n    return result;\n}\n\nint policy_2(int n, vector<int> const & a, vector<int> const & b) {\n    int b_max = *max_element(ALL(b));\n    vector<int> imos(b_max + 1);\n    REP (i, n) {\n        imos[a[i]] += 1;\n        imos[b[i]] -= 1;\n    }\n    REP (x, b_max) {\n        imos[x + 1] += imos[x];\n    }\n    return *max_element(ALL(imos));\n}\n\nint main() {\n    // input\n    int n; scanf(\"%d\", &n);\n    vector<int> a(n), b(n);\n    REP (i, n) scanf(\"%d%d\", &a[i], &b[i]);\n    // solve\n    int s1 = policy_1(n, a, b);\n    int s2 = policy_2(n, a, b);\n    // output\n    printf(\"%d %d\\n\", s1, s2);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst int maxn = 1e5 + 5;\nint a[maxn];\nint numl[maxn], numr[maxn];\n\nstruct ed{\n\tint l, r;\n}eds[2 * maxn];\n\nint main()\n{\n\tint n;\n\tint rd = 0;\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++) \n\t{\n\t\tscanf(\"%d%d\", &eds[i].l ,&eds[i].r);\n\t\ta[eds[i].l]++;\n\t\ta[eds[i].r]--;\n\t\tnuml[eds[i].l]++;\n\t\tnumr[eds[i].r]++;\n\t\trd = max(rd, eds[i].r);\n\t}\n\tint ma1 = 0, num = 0, ma2 = 0;\n\tfor(int i = 1; i <= rd; i++)\n\t{\n\t\ta[i] += a[i - 1];\n\t\tma2 = max(ma2, a[i]);\n\t\tnuml[i] += numl[i - 1];\n\t\tnumr[i] += numr[i - 1];\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint ans = numl[eds[i].r - 1] - numr[eds[i].l];\n\t\tma1 = max(ma1, ans);\n\t}\n\tprintf(\"%d %d\\n\", ma1, ma2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 100000\n\nstruct Info{\n\tvoid set(int arg_start,int arg_end){\n\t\tstart = arg_start;\n\t\tend = arg_end;\n\t}\n\tint start,end;\n};\n\nint table1_start[100002],table1_end[100002],table2[100002];\nInfo info[200000];\n\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 0; i <= 100001; i++){\n\t\ttable1_start[i] = 0;\n\t\ttable1_end[i] = 0;\n\t\ttable2[i] = 0;\n\t}\n\n\tint a,b,maximum = 0;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d\",&a,&b);\n\t\tmaximum = max(maximum,b);\n\t\tinfo[loop].set(a,b);\n\t\ttable1_start[a]++;\n\t\ttable1_end[b]++;\n\t\ttable2[a]++;\n\t\ttable2[b]--;\n\t}\n\n\tfor(int i = 1; i <= maximum; i++){\n\t\ttable1_start[i] += table1_start[i-1];\n\t\ttable1_end[i] += table1_end[i-1];\n\t}\n\n\tint max_1 = 0;\n\tint end_after_i_start_num,start_after_i_end_num;\n\n\tfor(int i = 0; i < N; i++){\n\t\tend_after_i_start_num = table1_end[maximum]-table1_end[info[i].start];\n\t\tstart_after_i_end_num = table1_start[maximum]-table1_start[info[i].end-1];\n\t\tmax_1 = max(max_1,end_after_i_start_num-start_after_i_end_num);\n\t}\n\n\tint max_2 = 0;\n\tfor(int i = 1; i <= 100000; i++){\n\t\ttable2[i] += table2[i-1];\n\t\tmax_2 = max(max_2,table2[i]);\n\t}\n\n\tprintf(\"%d %d\\n\",max_1,max_2);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nint n,l,r,imos[100007],ans1,ans2,sum;\n\nvector<P>v;\nvector<int>v1,v2;\n\nint main(){\n  \n  cin>>n;\n\n  for(int i=0;i<n;i++){\n    cin>>l>>r;\n    v.push_back(P(l,r));\n    v1.push_back(l);\n    v2.push_back(r);\n    imos[l]++;\n    imos[r]--;\n  }\n\n  sort(v1.begin(),v1.end());\n  sort(v2.begin(),v2.end());\n\n  for(int i=0;i<n;i++){\n    int sum1=upper_bound(v2.begin(),v2.end(),v[i].first)-v2.begin();\n    int sum2=v1.end()-lower_bound(v1.begin(),v1.end(),v[i].second);\n    ans1=max(ans1,n-sum1-sum2);\n  }\n\n  for(int i=0;i<100007;i++){\n    sum+=imos[i];\n    ans2=max(ans2,sum);\n  }\n\n  cout<< ans1 << ' ' << ans2 <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int N, A[200000], B[200000];\n  int sum[100000] = {};\n\n  vector< int > add[100000], del[100000];\n  int ans[100000] = {};\n\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++) {\n    scanf(\"%d %d\", &A[i], &B[i]);\n    --A[i], --B[i];\n    ++sum[A[i]];\n    --sum[B[i]];\n    add[A[i]].emplace_back(i);\n    del[B[i]].emplace_back(i);\n  }\n\n  int ret = 0, cur = 0;\n  for(int i = 0; i < 100000; i++) {\n    cur += sum[i];\n    ret = max(ret, cur);\n  }\n\n  cur = 0;\n  int open = 0;\n  for(int i = 0; i < 100000; i++) {\n    for(auto &idx : del[i]) ans[idx] += open;\n    cur -= del[i].size();\n    for(auto &idx : add[i]) ans[idx] -= open - cur;\n    open += add[i].size();\n    cur += add[i].size();\n  }\n  cout << *max_element(ans, ans + N) << \" \" << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<iomanip>\n#include<vector>\n#include<map>\n#include<set>\n#define FAST ios::sync_with_stdio(false)\ntypedef long long ll;\nconst int inf = 0x3f3f3f3f;\nconst int maxn = (int)2e5 + 5;\nconst int mod = (int)1e9 + 9;\nusing namespace std;\n\nstruct biu{\n\tint x, y;\n}a[maxn];\n\nint num[maxn], l[maxn], r[maxn];\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++){\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\ta[i].x = x, a[i].y = y;\n\t\tnum[x]++, num[y]--;\n\t\tr[x+1]++, l[y]++;\n\t}\n\tint Max = 0, sum = 0;\n\tfor(int i = 1; i <= 100000; i++){\n\t\tsum += num[i];\n\t\tMax = max(Max, sum);\n\t}\n\tfor(int i = 2; i <= 100000; i++){\n\t\tl[i] += l[i-1], r[i] += r[i-1];\n\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tans = max(ans, r[a[i].y] - l[a[i].x]);\n\t}\n\tprintf(\"%d %d\\n\", ans, Max);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\n\nint main() {\n    int n;\n    cin >> n;\n    const int LIM = 100010;\n    vector<int> left(LIM), right(LIM), ims(LIM);\n    vector<P> v(n);\n    for (int i = 0; i < n; ++i) {\n        int a, b;\n        cin >> a >> b;\n        ++ims[a];\n        --ims[b];\n        ++left[a];\n        ++right[b];\n        v[i] = P(a, b);\n    }\n    int ans1 = 0, ans2 = 0;\n    for (int i = 1; i < LIM; ++i) {\n        ims[i] += ims[i - 1];\n        left[i] += left[i - 1];\n        right[i] += right[i - 1];\n        ans2 = max(ans2, ims[i]);\n    }\n    for (P& i : v) ans1 = max(ans1, left[i.second - 1] - right[i.first]);\n    cout << ans1 << \" \" << ans2 << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e5 + 6;\n\nint bit[N];\nint get(int x) {\n  int r = 0;\n  for (; x < N; x += x&-x)\n    r += bit[x];\n  return r;\n}\n\nvoid upd(int x, int d) {\n  for (; x; x -= x&-x)\n    bit[x] += d;\n}\n\nint add[N], n;\nvector<int> que[N];\nvector<int> ins[N];\n\nint main() {\n  scanf(\"%d\", &n);\n  vector<pair<int, int> > p;\n  for (int i = 0; i < n; ++i) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    add[a]++;\n    add[b]--;\n    que[b].push_back(a);\n    ins[a].push_back(b);\n  }\n  int now = 0, ans1 = 1;\n  for (int i = 0; i < N; ++i) {\n    now += add[i];\n    ans1 = max(ans1, now);\n  }\n  int ans2 = 1;\n  for (int i = 0; i < N; ++i) {\n    for (int x : que[i]) {\n      ans2 = max(ans2, get(x+1));\n    }\n    for (int x : ins[i])\n      upd(x, +1);\n  }\n  printf(\"%d %d\\n\", ans2, ans1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\n\nint bit[100010+1];\n\nint sum(int i){\n\tint s=0;\n\twhile(i>0){\n\t\ts += bit[i];\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\n\nvoid add(int i,int x){\n\twhile(i <= 100010){\n\t\tbit[i] += x;\n\t\ti += i& -i;\n\t}\n}\n\n\nint a[100010];\n\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<pair<int,int> > v(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin >> v[i].first >> v[i].second;\n\t}\n\tsort(v.begin(),v.end());\n\tfor(int i=0;i<n;i++){\n\t\ta[v[i].first]+=1;\n\t\ta[v[i].second]-=1;\n\t}\n\tvector<int>x(n),y(n);\n\tfor(int i=0;i<n;i++){\n\t\tx[i] = v[i].first;\n\t\ty[i] = v[i].second;\n\t}\n\tfor(int i=1;i<=100000;i++){\n\t\ta[i]+=a[i-1];\n\t}\n\tint p1,p2;\n\tp2 = *max_element(a,a+100000);\n\tint mx = 1;\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){\n\t\t\tint tmp;\n\t\t\ttmp = lower_bound(x.begin()+1,x.end(),y[i])-x.begin();\n\t\t\tmx = max(tmp,mx);\n\t\t}else{\n\t\t\tint tmp;\n\t\t\ttmp = lower_bound(x.begin()+i+1,x.end(),y[i])-x.begin();\n\t\t\ttmp -= i;\n\t\t\ttmp += sum(100002)-sum(x[i]);\n\t\t\tmx = max(tmp,mx);\n\t\t}\n\t\tadd(y[i],1);\n\t}\n\tcout << mx << \" \" << p2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a ; i <= b; ++ i) \nconst int N = 2e5 + 5, M = N , mo = 1e9 + 7 ;\nconst ll inf = 1e17 ;\nusing namespace std ;\n\nstruct poi {\n    int l, r, ans ;\n} a[N], b[N] ;\nmultiset <int> S ;\nint n, bit[N] ;\n\nbool cmpl(poi a, poi b) {\n    return a.l < b.l ;\n}\n\nbool cmpr(poi a, poi b) {\n    return a.r < b.r ;\n}\n\nint solve() {\n    rep(i, 0, M - 5) bit[i] = 0 ;\n    rep(i, 1, n) ++ bit[a[i].l], -- bit[a[i].r] ;\n    rep(i, 1, M - 5) bit[i] += bit[i - 1] ;\n    int res = 0 ;\n    rep(i, 0, M - 5) res = max(res, bit[i]) ;\n    return res ;\n}\n\nvoid put(int x) {\n    for ( ; x <= M - 5 ; x += x & (- x)) bit[x] ++ ;\n}\n\nint get(int x) {\n    int res = 0 ;\n    for ( ; x ; x -= x & (- x)) res += bit[x] ;\n    return res ;\n}\n\nint l[N],r[N];\n\nint SOLVE() {\n//\trep(i,1,M-5) bit[i]=0;\n    sort(a + 1, a + n + 1, cmpl) ;\n    rep(i, 1, n) a[i].ans = n ;\n    rep(i, 1, n) {\n        a[i].ans -= get(a[i].l) ;\n        put(a[i].r) ;\n    }\n    rep(i, 0, M - 5) bit[i] = 0 ;\n    sort(a + 1, a + n + 1, cmpr) ;\n    for (int i = n ; i; -- i) {\n        a[i].ans -= get(M - 5 - a[i].r) ;\n        put(M - 5 - a[i].l) ;\n    }\n    int res = 0 ;\n    rep(i, 1, n) res = max(res, a[i].ans) ;\n    return res ;\n}\n\nint main() {\n    scanf(\"%d\", &n) ;\n    rep(i, 1, n) scanf(\"%d%d\", &a[i].l, &a[i].r) ;\n//    int r=SOLVE();\n    printf(\"%d %d\\n\", SOLVE(), solve()) ;\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define itrep(i, a) for (auto i = (a).begin(); i != (a).end(); i++)\n#define REP(i, a, n) for (int i = (a); i <= (n); i++)\n#define all(a) (a).begin(), (a).end()\n#define mp(a, b) make_pair((a), (b))\n\nusing namespace std;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, -1, 0, 1 };\n\ntemplate<class T> void inputVector(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < v.size(); i++) cin >> v[i];\n}\n\nstruct Interval {\n    int a, b;\n    Interval() {}\n    Interval(int a, int b) {\n\tthis->a = a;\n\tthis->b = b;\n    }\n};\n\nint memo[100010];\nint memo2[100010];\n\nvector<pair<int, int>> prs;\n\nsigned main() {\n    int N;\n    cin >> N;\n\n    rep(i, N) {\n\tint a, b;\n\tscanf(\"%d %d\", &a, &b);\n\tprs.push_back(mp(a, b));\n    }\n\n    sort(all(prs));\n\n    int ret2 = 0;\n    rep(i, N) {\n\tmemo2[prs[i].first]++;\n\tmemo2[prs[i].second]--;\n    }\n    REP(i, 1, 100005) {\n\tmemo2[i] += memo2[i - 1];\n\tret2 = max(ret2, memo2[i]);\n    }\n\n    rep(i, N) {\n\tif (i > 0) {\n\t    if (prs[i].first < prs[i - 1].second) {\n\t\tprs[i].first = prs[i - 1].first;\n\t\tprs[i - 1].second = max(prs[i].second, prs[i - 1].second);\n\t    }\n\t}\n    }\n\n    int ret = 0;\n    rep(i, N) {\n\tmemo[prs[i].first]++;\n\tmemo[prs[i].second]--;\n    }\n    REP(i, 1, 100005) {\n\tmemo[i] += memo[i - 1];\n\tret = max(ret, memo[i]);\n    }\n\n    cout << ret << \" \" << ret2 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int SIZE=100002;\n\nclass BIT{\n    int N;\n    vector<int> dat;\n    public:\n    BIT(int N):N(N),dat(N){}\n\n    void add(int x){\n        x++;\n        while(x<=N){\n            dat[x-1]++;\n            x+=x&-x;\n        }\n    }\n    int query(int r){\n        int res=0;\n        while(r>0){\n            res+=dat[r-1];\n            r-=r&-r;\n        }\n        return res;\n    }\n};\nint main(){\n    int n;\n    cin>>n;\n    vector<int> a(n),b(n);\n    for(int i=0;i<n;i++) cin>>a[i]>>b[i];\n    auto l=a,r=b;\n\n    auto solve1=[&](){\n        vector<int> rids(n);\n        iota(rids.begin(),rids.end(),0);\n        sort(rids.begin(),rids.end(),[&](int lhs,int rhs){return r[lhs]<r[rhs];});\n\n        int iter=0;\n        vector<int> ls;\n        for(auto lv:l) ls.push_back(lv);\n        sort(ls.begin(),ls.end());\n        int res=0;\n        vector<int> rs;\n        \n        BIT bit(SIZE);\n        for(int i=0;i<SIZE;i++){\n            int ltmp=SIZE;\n            while(iter<n && r[rids[iter]]==i){\n                int id=rids[iter];\n                ltmp=min(ltmp,l[id]);\n                rs.push_back(r[id]);\n                bit.add(l[id]);\n                iter++;\n            }\n            if(ltmp!=SIZE){\n                int cntl=lower_bound(ls.begin(),ls.end(),i)-lower_bound(ls.begin(),ls.end(),ltmp);\n                int cntr=rs.end()-upper_bound(rs.begin(),rs.end(),ltmp);\n                int cntlr=bit.query(SIZE)-bit.query(ltmp);\n                int sc=cntl+cntr-cntlr;\n                res=max(res,sc);\n            }\n            \n        }\n        return res;\n    };\n\n    auto solve2=[&](){\n        vector<int> sum(SIZE);\n        for(int i=0;i<n;i++){\n            sum[a[i]]++;\n            sum[b[i]]--;\n        }\n        for(int i=0;i+1<SIZE;i++){\n            sum[i+1]+=sum[i];\n        }\n        return *max_element(sum.begin(),sum.end());\n    };\n\n    int res1=solve1();\n    int res2=solve2();\n    cout<<res1<<\" \"<<res2<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint l[200010], r[200010], lqz[200010], rqz[200010], s[200010];\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tscanf(\"%d%d\", &l[i], &r[i]);\n\t\tlqz[l[i]]++;\n\t\trqz[r[i]]++;\n\t\ts[l[i]]++;\n\t\ts[r[i]]--;\n\t}\n\tfor (int i = 1; i <= 100000; ++i)\n\t{\n\t\tlqz[i] += lqz[i - 1];\n\t\trqz[i] += rqz[i - 1];\n\t\ts[i] += s[i - 1];\n\t}\n\tint ans1(0), ans2(0);\n\tfor (int i = 0; i < n; ++i)\n\t\tans1 = max(ans1, lqz[r[i] - 1] - rqz[l[i]]);\n\tfor (int i = 1; i <= 100000; ++i)\n\t\tans2 = max(ans2, s[i]);\n\tprintf(\"%d %d\\n\", ans1, ans2);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define mem(a,b) memset(a,b,sizeof(a))\n#define FOR(i,j,k) for(int i=j;i<=k;i++)\n#define REV(i,j,k) for(int i=j;i>=k;i--)\n#define FORR(i,j,k,l) for(int i=j;i<=k;i+=l)\n#define inf         freopen(\"in.txt\", \"r\", stdin)\n#define outf        freopen(\"out.txt\", \"w\", stdout)\n#define pf          printf\n#define sf(n)       scanf(\"%d\", &n)\n#define sff(a,b)    scanf(\"%d %d\", &a, &b)\n#define sfff(a,b,c)    scanf(\"%d %d %d\", &a, &b, &c)\n#define clean(mat,n)   FOR(i,0,n) mat[i].clear()\n#define minn          (long long)-1000000000000000000\n#define maxx          (long long) 1000000000000000000\n#define mod          1000000007\n#define M_PI           3.14159265358979323846  /* pi */\n#define LL           long long\n#define NL '\\n'\n#define cnd tree[idx]\n#define lnd (idx<<1)\n#define rnd ((idx<<1)+1)\n#define PB push_back\n#define F first\n#define S second\n#define MAX 200010\n#define MP make_pair\n#define valid(nx,ny)  ((nx >= 0) && (nx < row) && (ny >= 0) && (ny < col))\ntypedef pair<int,int> pr;\n\npr ar[MAX];\nint n, cnt[MAX];\n\nint chk(int v)\n{\n    set<int> st, en;\n    set<int>::iterator it;\n\n    FOR(i,0,n-1)\n    {\n        if(!(i < v))\n        {\n            it = en.lower_bound(ar[i].F);\n            if(it != en.begin() && *it > ar[i].F) it--;\n//            int use = *it;\n//            if(it != en.begin()) cout << use << endl;\n\n            if(st.lower_bound( ar[i].S ) != st.end() );\n            else if( it != en.begin() && *it <= ar[i].F  );\n            else return 0;\n\n        }\n\n         st.insert( ar[i].F );\n         en.insert( ar[i].S );\n    }\n    return 1;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n   /// inf;\n    //outf;\n\n    cin >> n;\n    FOR(i,0,n-1) cin >> ar[i].F >> ar[i].S;\n\n    FOR(i,0,n-1)\n    {\n        cnt[ ar[i].F ]++; cnt[ ar[i].S ]--;\n    }\n\n    int c = 0, pc = 0, pt = n;\n    FOR(i,0,MAX-1)\n    {\n        c += cnt[i];\n        pc = max(c, pc);\n    }\n\n   // cout << chk( 3 ) << endl;\n\n    int st = 1, en = n, mid;\n\n    while(st <= en)\n    {\n        mid = (st + en)>>1;\n        if(chk(mid)) en = mid - 1, pt = min(pt, mid);\n        else st = mid + 1;\n    }\n\n    cout << pt << ' ' << pc << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <ostream>\n#include <fstream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <math.h>\n#include <set>\n#define maxn 200010\nusing namespace std;\nstruct node\n{\n    int l,r;\n}ss[maxn];\nint ans[maxn>>1];\nint ans2[maxn>>1];\nint sum[maxn>>1];\nint sum2[maxn>>1];\nint f[maxn>>1];\nbool cmp(node& a,node& b)\n{\n    return a.r < b.r;\n}\nint main()\n{\n    freopen(\"in.txt\",\"r\",stdin);\n    int n;\n    cin>>n;\n    int l,r;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>ss[i].l>>ss[i].r;\n        ++sum[ss[i].l];\n        --sum2[ss[i].r];\n        ++f[ss[i].l];\n        --f[ss[i].r];\n    }\n    sort(ss+1,ss+1+n,cmp);\n    int cnt = 0;\n    int maxx = 0;\n    for(int i=1;i<=ss[n].r;i++)\n    {\n        ans[i] = ans[i-1]+sum[i];\n        ans2[i] = ans2[i-1]+sum2[i];\n        cnt += f[i];\n        maxx = max(maxx,cnt);\n    }\n    int maxy = 0;\n    for(int i=1;i<=n;i++)\n    {\n        maxy = max(ans[ss[i].r-1]+ans2[ss[i].l],maxy);\n    }\n    cout<<maxy<<\" \"<<maxx<<endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define pii pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< pii >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; cin >> x;\n#define int2(x, y) Int(x); Int(y);\n#define int3(x, y, z) Int(x); int2(y, z);\n#define in(x, a, b) ((a) <= (x) && (x) < (b))\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n#define Decimal fixed << setprecision(10)\n\n//int dxy[5] = {0, 1, 0, -1, 0};\n// cmd\n\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    Int(n);\n    int m = 100001;\n    vi imos(m+1, 0), sum(m+1, 0), rsum(m+1, 0);\n    vp data(n);\n    rep(i, n) {\n        int2(a, b);\n        a--; b--;\n        data[i].fir = a; data[i].sec = b;\n        imos[a]++; imos[b]--;\n        sum[b]++; rsum[a]++;\n    }\n\n    Rep(i, imos.size()) {\n        imos[i] += imos[i-1];\n        sum[i] += sum[i-1];\n    }\n\n    for (int i = rsum.size()-1; i > 0; i--) {\n        rsum[i-1] += rsum[i];\n    }\n\n    int ans = 0;\n    rep(i, n) {\n        ans = max(ans, n - rsum[data[i].sec] - sum[data[i].fir]);\n    }\n\n    cout << ans << \" \" << *max_element(all(imos)) << endl;\n\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n  ll n;\n  cin >> n;\n  vector<ll> l(n);\n  vector<ll> r(n);\n  vector<ll> lb(n);\n  vector<ll> rb(n);\n  vector<ll> imos(100100);\n  for(int i=0;i<n;i++){\n    cin >> l[i];\n    cin >> r[i];\n    lb[i] = l[i];\n    rb[i] = r[i];\n    imos[l[i]]++;\n    imos[r[i]]--;\n  }\n  sort(l.begin(), l.end());\n  sort(r.begin(), r.end());\n  ll ans = 0;\n  for(int i=0;i<n;i++){\n    ll migi = l.end() - lower_bound(l.begin(), l.end(), rb[i]);\n    ll hidari = upper_bound(r.begin(), r.end(), lb[i]) - r.begin();\n    ans = max(ans, n - migi - hidari);\n  }\n  cout << ans << \" \";\n  ans = imos[0];\n  for(int i=1;i<imos.size();i++){\n    imos[i] += imos[i-1];\n    ans = max(ans, imos[i]);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n;\n  cin >> n;\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; i++){\n    cin >> a[i] >> b[i];\n    a[i]--;\n    b[i]--;\n  }\n  vector<int> L(100001, 0);\n  for (int i = 0; i < n; i++){\n    L[b[i]]++;\n  }\n  for (int i = 0; i < 100000; i++){\n    L[i + 1] += L[i];\n  }\n  vector<int> R(100001, 0);\n  for (int i = 0; i < n; i++){\n    R[a[i]]++;\n  }\n  for (int i = 100000; i >= 1; i--){\n    R[i - 1] += R[i];\n  }\n  int ans1 = 0;\n  for (int i = 0; i < n; i++){\n    ans1 = max(ans1, n - L[a[i]] - R[b[i]]);\n  }\n  vector<int> d(100001, 0);\n  for (int i = 0; i < n; i++){\n    d[a[i]]++;\n    d[b[i]]--;\n  }\n  for (int i = 0; i < 100000; i++){\n    d[i + 1] += d[i];\n  }\n  int ans2 = 0;\n  for (int i = 0; i < 100000; i++){\n    ans2 = max(ans2, d[i]);\n  }\n  cout << ans1 << ' ' << ans2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define MAXN 400010\nusing namespace std;\nint n;\n\nstruct mem{\n\tint l,r;\n} a[ MAXN ];\nint sum[MAXN],w[MAXN],q[MAXN];\nint main()\n{\n\n\tscanf(\"%d\",&n);\n\tint mx=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\ta[i].l=x;\n\t\ty--;\n\t\ta[i].r=y;\n\t\tsum[x]++;\n\t\tsum[y+1]--;\n\t\tmx=max(y+1,mx);\n\t\tw[x]++;\n\t\tq[y]++;\n\t}\n\tint ans1=0,ans2=0;\n\tfor(int i=1;i<=mx;i++)\n\t{\n\t\tw[i]=w[i-1]+w[i];\n\t\tq[i]=q[i-1]+q[i];\n\t\tsum[i]=sum[i-1]+sum[i];\n\t\tans2=max(ans2,sum[i]);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint xx=w[a[i].r]-q[a[i].l-1];\n\t\tans1=max(ans1,xx);\n\t}\n\tprintf(\"%d %d\\n\",ans1,ans2);\n\treturn 0;\n}\n\t\t \n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\n#define int ll\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nint imos[200000];\nint mae[200000];\nint gyaku[200000];\nvoid solve() {\n    int n;\n    cin >> n;\n    pair<int, int> ans = mp(0, 0);\n    vector<pair<int, int>> inputs;\n    REP(i, n) {\n        int a, b;\n        cin >> a >> b;\n        imos[a]++;\n        imos[b]--;\n        mae[b]++;\n        gyaku[a]++;\n        inputs.push_back(mp(a, b));\n    }\n    REP(i, 150000) {\n        imos[i + 1] += imos[i];\n        mae[i + 1] += mae[i];\n        ans.second = max(ans.second, imos[i]);\n    }\n    for (int i = 120000; i >= 0; --i) {\n        gyaku[i] += gyaku[i + 1];\n    }\n    REP(i, n) {\n        ans.first = max(ans.first, n - mae[inputs[i].first] - gyaku[inputs[i].second]);\n    }\n    cout << ans.first << \" \" << ans.second << endl;\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint a[200000];\nint b[200000];\nint imos[200002];\nint ruia[200002]; //a[i]の累積和（200000から取る）\nint ruib[200002]; //b[i]の累積和（0から取る）\nint main()\n{\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t\tcin>>a[i]>>b[i];\n\tfill(imos,imos+200002,0);\n\tfill(ruia,ruia+200002,0);\n\tfill(ruib,ruib+200002,0);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\timos[a[i]]++;\n\t\timos[b[i]]--;\n\t\truia[a[i]]++;\n\t\truib[b[i]]++;\n\t}\n\tfor(int i=1;i<200002;i++)\n\t{\n\t\timos[i]+=imos[i-1];\n\t\truib[i]+=ruib[i-1];\n\t\truia[200001-i]+=ruia[200001-i+1];\n\t}\n\tint ans1=-1;\n\tint ans2=-1;\n\tfor(int i=1;i<200001;i++)\n\t\tans2=max(ans2,imos[i]);\n\tfor(int i=0;i<n;i++)\n\t\tans1=max(ans1,n-ruia[b[i]]-ruib[a[i]]);\n\tcout<<ans1<<\" \"<<ans2<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long int\nusing namespace std;\nconst int maxn=2e5+7;\nconst int maxab=1e5+7;\nint a[maxn],b[maxn];\nint sum_a[maxab],sum_b[maxab];\nint sum[maxab];\nint main()\n{\n    int n;\n    cin>>n;\n    int maxt=0;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>a[i]>>b[i];\n        sum_a[a[i]]++;\n        sum_b[b[i]]++;\n        sum[a[i]]++;\n        sum[b[i]]--;\n        maxt=max(maxt,b[i]);\n    }\n    for(int i=1;i<=maxt;i++)\n    {\n        sum_a[i]+=sum_a[i-1];\n        sum_b[i]+=sum_b[i-1];\n        sum[i]+=sum[i-1];\n    }\n    int policy1=0,policy2=0;\n    for(int i=1;i<=n;i++)\n        policy1=max(policy1,sum_a[b[i]-1]-sum_b[a[i]]);\n//该人在车上时段，上过车的人数与下过车的人数的差值，即此时刻车上有的人数\n    for(int i=1;i<=maxt;i++)\n        policy2=max(policy2,sum[i]);\n//以最优方案，某时刻车上人数的最大值\n    cout<<policy1<<\" \"<<policy2<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint memo[201000];\n\nint main()\n{\n\tint n;cin >> n;\n\tvector<pair<pair<int,int>,int> > v;\n\tREP(i,n)\n\t{\n\t\tint a,b;cin >> a >> b;\n\t\tv.PB(MP(MP(a,i),1));\n\t\tv.PB(MP(MP(b,i),0));\n\t}\n\t\n\tsort(ALL(v));\n\t\n\tll ans1 = 0,ans2 = 0,imos = 0;\n\tll inin = 0,ouou = 0;\n\t\n\tREP(i,v.size())\n\t{\n\t\tvector<pair<pair<int,int>,int> > now;\n\t\tauto tmp = v[i];\n\t\tnow.PB(tmp);\n\t\twhile(i+1 != v.size()&&tmp.FI == v[i+1].FI)\n\t\t{\n\t\t\tauto tmtm = v[i+1];\n\t\t\tnow.PB(tmtm);\n\t\t\ti++;\n\t\t}\n\t\tint nige = 0;\n\t\tREP(j,now.size())\n\t\t{\n\t\t\tif(now[j].SE == 1)\n\t\t\t{\n\t\t\t\tnige++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\touou++;\n\t\t\t\timos--;\n\t\t\t}\n\t\t}\n\t\tans1 = max(ans1,imos);\n\t\t\n\t\tREP(j,now.size())\n\t\t{\n\t\t\tint num = now[j].FI.SE;\n\t\t\tif(now[j].SE == 1)\n\t\t\t{\n\t\t\t\tmemo[num] = ouou;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tll tmtm = inin - memo[num];\n\t\t\t\tans2 = max(ans2,tmtm);\n\t\t\t}\n\t\t}\n\t\tinin += nige;\n\t\timos += nige;\n\t}\n\t\n\tcout << ans2 << \" \"\t<< ans1 << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\nclass BIT{\npublic:\n  int n,bit[555555];\n  BIT(){fill(bit,bit+555555,0);}\n  void add(int i,int x){\n    while(i<=n){\n      bit[i]+=x;\n      i+=i&-i;\n    }\n  }\n  int sum(int i){\n    int s=0;\n    while(i>0){\n      s+=bit[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n};\nBIT b=BIT(),t=BIT();\nvoid Main() {\n  b.n=t.n=200001;\n  ll n;\n  R n;\n  P a[n];\n  rep(i,n) cin >> a[i].F >> a[i].S;\n  ll d[111111];\n  mem(d);\n  rep(i,n) {\n    d[a[i].F]++;\n    d[a[i].S]--;\n    b.add(a[i].F,1);\n    t.add(a[i].S,1);\n  }\n  rep(i,100000) d[i+1]+=d[i];\n  ll M2=0,M=0;\n  rep(i,100001) M2=max(M2,d[i]);\n  rep(i,n) {\n    ll x=b.sum(a[i].S-1);\n    ll y=t.sum(a[i].F);\n    M=max(M,x-y);\n  }\n  pr(M,M2);\n  \n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <utility>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#ifdef _DEBUG_\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n#else\n#define dump(val)\n#endif\n\nusing namespace std;\n\ntypedef long long int ll;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) {\n    return vector<T>(a, b);\n}\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\nusing P = pair<int, int>;\n\nclass BinaryIndexedTree {\npublic:\n    vector<int> data;\n    BinaryIndexedTree(int _n) {\n        int n = 1;\n        while (n < _n) {\n            n *= 2;\n        }\n        data.resize(n, 0);\n    }\n    void update(int n, int val) {\n        for (n++; n < data.size(); n += (n & -n)) {\n            data[n] += val;\n        }\n    }\n    int query(int n) {\n        int ans = 0;\n        for (n++; n > 0; n -= (n & -n)) {\n            ans += data[n];\n        }\n        return ans;\n    }\n};\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<P> d(n);\n    REP(i, 0, n) {\n        cin >> d[i].second >> d[i].first;\n    }\n    sort(d.begin(), d.end());\n    ll ans1 = 0;\n    {\n        BinaryIndexedTree BIT(100010);\n        vector<int> res(n, 0);\n        REP(i, 0, n) {\n            int st = d[i].second, ed = d[i].first;\n            res[i] = i - BIT.query(st) + 1;\n            BIT.update(ed, 1);\n            //dump(res[i]);\n        }\n        BIT = BinaryIndexedTree(100010);\n        for (int i = n - 1; i >= 0; i--) {\n            int st = d[i].second, ed = d[i].first;\n            ll tmp = BIT.query(ed - 1);\n            ans1 = max(ans1, tmp + res[i]);\n            //dump(tmp);\n            BIT.update(st, 1);\n        }\n    }\n    ll ans2 = 0;\n    {\n        vector<int> imos(100010, 0);\n        REP(i, 0, n) {\n            int a = d[i].second;\n            int b = d[i].first;\n            imos[a]++;\n            imos[b]--;\n        }\n        ans2 = imos[0];\n        REP(i, 1, 100010) {\n            imos[i] += imos[i - 1];\n            ans2 = max(ans2, (ll)imos[i]);\n        }\n    }\n    cout << ans1 << \" \" << ans2 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MaxN = 2e5;\nint n, N, c[MaxN + 5];\nint ishead[MaxN + 5], istail[MaxN + 5];\npair <int, int> a[MaxN + 5];\n\nvoid Init()\n{\n\tN = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d%d\", &a[i].first, &a[i].second);\t\t\t\n\t\tN = max(N, a[i].second);\n\t}\n\tN++;\n}\n\nint Solve_1()\n{\n\tfor (int i = 0; i <= N; i++) ishead[i] = istail[i] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tishead[a[i].first]++;\n\t\tistail[a[i].second]++;\n\t}\n\tint ret = 0, pred = 0;\n\tfor (int i = 0; i <= N; i++) {\n\t\tret = max(ret, pred);\n\t\tpred += ishead[i] - istail[i];\n\t}\n\treturn ret;\n}\n\nint Lowbit(int x) {return x & (-x);}\n\nvoid Add(int x, int t) \n{\n\tfor (int i = x; i <= N; i += Lowbit(i)) c[i] += t;\n}\n\nint Sigma(int x) \n{\n\tint ret = 0;\n\tfor (int i = x; i > 0; i -= Lowbit(i)) ret += c[i];\n\treturn ret;\n}\n\nint Solve_2()\n{\n\tfor (int i = 0; i <= N; i++) c[i] = 0;\n\tsort(a + 1, a + n + 1);\n\tint ret = 0, p = 1;\n\tfor (int i = 1; i <= n; i++) Add(a[i].first + 1, 1);\n\tfor (int i = 0; i <= N; i++) {\n\t\tint last = p;\n\t\twhile (p <= n && a[p].first == i) {\n\t\t\tret = max(ret, Sigma(a[p].second) - Sigma(a[p].first));\t\n\t\t\tp++;\n\t\t}\n\t\tint p = last;\n\t\twhile (p <= n && a[p].first <= i) {\n\t\t\tAdd(a[p].first + 1, -1);\n\t\t\tAdd(a[p].second, 1);\n\t\t\tp++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\twhile (~scanf(\"%d\", &n)) {\n\t\tInit();\n\t\tprintf(\"%d %d\\n\", Solve_2(), Solve_1());\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,s,t) for(int (i) = (s); (i)< (t); (i)++)\n#define FORR(i,s,t) for(int (i) = (s); (i) > (t); (i)--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl;\n\ntypedef long long LL;\ntypedef vector<LL> VL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\nstruct BIT {\n\tint N;\n\tint nn;\n\tvector<ll>data;\n\tBIT(int n) {\n\t\tN = n + 1;\n\t\tdata = vector<LL>(N, 0);\n\t\tnn = 1;\n\t\twhile (nn*2<=N)\n\t\t{\n\t\t\tnn *= 2;\n\t\t}\n\t}\n\tvoid add(int i, LL w) {\n\t\tfor (int x = i; x <= N;x += x&-x) {\n\t\t\tdata[x] += w;\n\t\t}\n\t}\n\tLL sum(int i) {\n\t\tLL ret = 0;\n\t\tfor (int x = i;x > 0;x -= x&-x) {\n\t\t\tret += data[x];\n\t\t}\n\t\treturn ret;\n\t}\n\tLL sum(int l, int r) {\n\t\tif (l > r)return 0;\n\t\treturn sum(r) - sum(l - 1);\n\t}\n\tvoid range_add(BIT& bity, int l, int r, LL val) {\n\t\tadd(l, -val*(l - 1));\n\t\tbity.add(l, val);\n\t\tadd(r + 1, val*r);\n\t\tbity.add(r + 1, -val);\n\t}\n\tLL range_sum(BIT& bity, int i) {\n\t\treturn sum(i) + bity.sum(i)*i;\n\t}\n\tLL range_sum(BIT& bity, int l, int r) {\n\t\treturn range_sum(bity, r) - range_sum(bity, l - 1);\n\t}\n\n};\n\n//struct seg {\n//\tint L, R;\n//\tseg() {}\n//\tseg(int l, int r) {\n//\t\tL = l;\n//\t\tR = r;\n//\t}\n//\t//bool operator <(const seg&x)const{\n//\t//\tif (R == x.R)return L < x.L;\n//\t//\telse return R < x.R;\n//\t//}\n//\tbool operator <(const seg&x)const {\n//\t\tif (L == x.L)return R < x.R;\n//\t\telse return L < x.L;\n//\t}\n//};\ntypedef pair<int, int> seg;\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\n\tint N;cin >> N;\n\tvector<pll> S(N);\n\tvector<seg> Seg(N);\n\tBIT bit(100005), bit2(100005);\n\tFOR(i, 0, N) {\n\t\tcin >> S[i].first >> S[i].second;\n\t\tSeg[i] = seg(S[i].second - 1,S[i].first);\n\t\tbit.range_add(bit2, S[i].first, S[i].second - 1, 1);\n\t}\n\tLL ans2 = 0;\n\tFOR(i, 1, 100001) {\n\t\tans2 = max(ans2, bit.range_sum(bit2, i, i));\n\t}\n\n\tsort(Seg.begin(), Seg.end());\n\tLL ans = 0;\n\tpriority_queue<int>pq;\n\tfor (int i = N - 1;i >= 0;i--) {\n\t\tint nowR = Seg[i].first;\n\t\tint nowL = Seg[i].second;\n\n\t//\tcout << nowL << \" \" << nowR << endl;\n\n\t\twhile (!pq.empty()) {\n\t\t\tint T = pq.top();\n\t\t\tif (nowR < T) {\n\t\t\t\tpq.pop();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tll Rcnt = pq.size();\n\n\t\tll Lcnt = i - (upper_bound(Seg.begin(), Seg.begin() + i, seg(nowL-1,INF)) - Seg.begin());\n\n\t\tans = max(ans, Rcnt + Lcnt + 1);\n\t\t//cout << \" ==== \" << endl;\n\t\t//debug(Rcnt);\n\t\t//debug(Lcnt);\n//\t\tdebug(ans);\n\n\t\tpq.push(nowL);\n\t}\n//\tdebug(ans);\n//\tdebug(ans2);\n\tcout << ans << \" \" << ans2 << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a ; i <= b; ++ i) \nconst int N = 2e5 + 5, M = N , mo = 1e9 + 7 ;\nconst ll inf = 1e17 ;\nusing namespace std ;\n\nstruct poi {\n    int l, r, ans ;\n} a[N], b[N] ;\nmultiset <int> S ;\nint n, bit[N] ;\n\nbool cmpl(poi a, poi b) {\n    return a.l < b.l ;\n}\n\nbool cmpr(poi a, poi b) {\n    return a.r < b.r ;\n}\n\nint solve() {\n    rep(i, 0, M - 5) bit[i] = 0 ;\n    rep(i, 1, n) ++ bit[a[i].l], -- bit[a[i].r] ;\n    rep(i, 1, M - 5) bit[i] += bit[i - 1] ;\n    int res = 0 ;\n    rep(i, 0, M - 5) res = max(res, bit[i]) ;\n    return res ;\n}\n\nvoid put(int x) {\n    for ( ; x <= M - 5 ; x += x & (- x)) bit[x] ++ ;\n}\n\nint get(int x) {\n    int res = 0 ;\n    for ( ; x ; x -= x & (- x)) res += bit[x] ;\n    return res ;\n}\n\nint l[N],r[N];\n\nint SOLVE() {\n\trep(i,1,M-5) bit[i]=0;\n    sort(a + 1, a + n + 1, cmpl) ;\n    rep(i, 1, n) a[i].ans = n ;\n    rep(i, 1, n) {\n        a[i].ans -= get(a[i].l) ;\n        put(a[i].r) ;\n    }\n    rep(i, 0, M - 5) bit[i] = 0 ;\n    sort(a + 1, a + n + 1, cmpr) ;\n    for (int i = n ; i; -- i) {\n        a[i].ans -= get(M - 5 - a[i].r) ;\n        put(M - 5 - a[i].l) ;\n    }\n    int res = 0 ;\n    rep(i, 1, n) res = max(res, a[i].ans) ;\n    return res ;\n}\n\nint main() {\n    scanf(\"%d\", &n) ;\n    rep(i, 1, n) scanf(\"%d%d\", &a[i].l, &a[i].r) ;\n    int r=SOLVE();\n    printf(\"%d %d\\n\", r, solve()) ;\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=2*1e5+100;\nint a[maxn],b[maxn],s[maxn],vl[maxn],vr[maxn];\nint main()\n{\n    int n,t,last,ans2=0,ans1=0;\n    scanf(\"%d\",&n);\n    for(int i=0; i<n; i++)\n    {\n        scanf(\"%d %d\",&a[i],&b[i]);\n        s[a[i]]++,s[b[i]]--;\n        vl[a[i]]++,vr[b[i]]++;\n    }\n    for(int i=1; i<=100000; i++)\n    {\n        ans2=max(s[i]=s[i-1]+s[i],ans2);\n        vr[i]+=vr[i-1];\n        vl[100001-i]+=vl[100002-i];\n    }\n    for(int i=0; i<n; i++)ans1=max(n-vl[b[i]]-vr[a[i]],ans1);\n    printf(\"%d %d\\n\",ans1,ans2);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <cstring>\n\nusing namespace std;\n\nconst int MAX = 1e6 + 10;\nint n, st, ed, seat[MAX];\nint trees[MAX], treee[MAX];\n\nint lowbit(int x)\n{\n\treturn x & -x;\n}\n\nvoid addtree(int pos, int val, int tree[])\n{\n\twhile(pos < MAX)\n\t{\n\t\ttree[pos] += val;\n\t\tpos += lowbit(pos);\n\t}\n}\n\nint query(int pos, int tree[])\n{\n\tint res = 0;\n\twhile(pos > 0)\n\t{\n\t\tres += tree[pos];\n\t\tpos -= lowbit(pos);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n)\n\t{\n\t\tint ans = 0;\n\t\tmemset(seat, 0, sizeof(seat));\n\t\tmemset(trees, 0, sizeof(trees));\n\t\tmemset(treee, 0, sizeof(treee));\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> st >> ed;\n\n\t\t\tint ts = query(st - 1, treee), te = i - query(ed - 1, trees);\n\t\t\t\n\t\t\tans = max(1 + i - ts - te, ans);\n\t\t\taddtree(ed - 1, 1, treee), addtree(st, 1, trees);\n\n\t\t\tseat[st] += 1, seat[ed] -= 1;\n\t\t}\n\n\t\tcout << ans;\n\n\t\tint res = 0, change = 0;\n\t\tfor(int i = 0; i < MAX; i++)\n\t\t{\n\t\t\tchange += seat[i];\n\t\t\tres = max(change, res);\n\t\t}\n\n\t\tcout << \" \" << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=32e4;\n\nint l[N],r[N];\nint vl[N],vr[N];\nint t[N];\nint main(){\n\tios::sync_with_stdio(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>l[i]>>r[i];\n\t\tvl[i]=l[i], vr[i]=r[i];\n\t\tt[l[i]]++, t[r[i]]--;\n\t}\n\tint a1=0,a2=0;\n\tfor(int i=1;i<N;i++){\n\t\tt[i]+=t[i-1];\n\t\ta2=max(a2,t[i]);\n\t}\n\tsort(vl,vl+n);\n\tsort(vr,vr+n);\n\tfor(int i=0;i<n;i++){\n\t\tint u=n-(lower_bound(vl,vl+n,r[i])-vl),\n\t\t\tv=upper_bound(vr,vr+n,l[i])-vr;\n\t\ta1=max(a1,n-u-v);\n\t}\n\tcout<<a1<<' '<<a2<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define N 200100\nusing namespace std;\n\nint cnt[N],a[N],b[N];\nint l[N],r[N];\nint n,ans1,ans2,m;\n\nint main()\n{\n\tscanf(\"%d\",&n); m=0;\n\tfor (int i=1;i<=n;i++)\n\t{ \n\t\tscanf(\"%d %d\",&l[i],&r[i]); m=max(m,r[i]);\n\t\tcnt[l[i]]++; cnt[r[i]]--;\n\t\ta[l[i]]++;   b[r[i]]++;\n\t}\n\tfor (int i=1;i<=m;i++) a[i]+=a[i-1],b[i]+=b[i-1],cnt[i]+=cnt[i-1];\n\tfor (int i=1;i<=n;i++) ans1=max(ans1,n-(n-a[r[i]-1])-b[l[i]]);\n\tfor (int i=1;i<=m;i++) ans2=max(ans2,cnt[i]);\n\tprintf(\"%d %d\\n\",ans1,ans2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\n\nint bit[100010+1];\n\nint sum(int i){\n\tint s=0;\n\twhile(i>0){\n\t\ts += bit[i];\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\n\nvoid add(int i,int x){\n\twhile(i <= 100010){\n\t\tbit[i] += x;\n\t\ti += i& -i;\n\t}\n}\n\n\nint a[100010];\n\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<pair<int,int> > v(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin >> v[i].first >> v[i].second;\n\t}\n\tsort(v.begin(),v.end());\n\tfor(int i=0;i<n;i++){\n\t\ta[v[i].first]+=1;\n\t\ta[v[i].second]-=1;\n\t}\n\tvector<int>x(n),y(n);\n\tfor(int i=0;i<n;i++){\n\t\tx[i] = v[i].first;\n\t\ty[i] = v[i].second;\n\t}\n\tfor(int i=1;i<=100000;i++){\n\t\ta[i]+=a[i-1];\n\t}\n\tint p1,p2;\n\tp2 = *max_element(a,a+100000);\n\tint mx = 1;\n\tfor(int i=0;i<n;i++){\n\t\tif(i==0){\n\t\t\tint tmp;\n\t\t\ttmp = lower_bound(x.begin()+1,x.end(),y[i]-1)-x.begin()-1;\n\t\t\ttmp++;\n\t\t\tmx = max(tmp,mx);\n\t\t}else{\n\t\t\tint tmp;\n\t\t\ttmp = lower_bound(x.begin()+i+1,x.end(),y[i]-1)-x.begin()-i-1;\n\t\t\ttmp++;\n\t\t\ttmp += sum(100002)-sum(x[i]);\n\t\t\tmx = max(tmp,mx);\n\t\t}\n\t\tadd(y[i],1);\n\t}\n\tcout << mx << \" \" << p2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define REP_R(i, n) for (int i = (n) - 1; (i) >= 0; -- (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\ntemplate <class T> inline void chmax(T & a, T const & b) { a = max(a, b); }\n\ntemplate <class Monoid>\nstruct segment_tree {\n    typedef typename Monoid::underlying_type underlying_type;\n    int n;\n    vector<underlying_type> a;\n    Monoid mon;\n    segment_tree() = default;\n    segment_tree(int a_n, underlying_type initial_value = Monoid().unit(), Monoid const & a_mon = Monoid()) : mon(a_mon) {\n        n = 1; while (n < a_n) n *= 2;\n        a.resize(2 * n - 1, mon.unit());\n        fill(a.begin() + (n - 1), a.begin() + ((n - 1) + a_n), initial_value); // set initial values\n        REP_R (i, n - 1) a[i] = mon.append(a[2 * i + 1], a[2 * i + 2]); // propagate initial values\n    }\n    void point_set(int i, underlying_type z) { // 0-based\n        a[i + n - 1] = z;\n        for (i = (i + n) / 2; i > 0; i /= 2) { // 1-based\n            a[i - 1] = mon.append(a[2 * i - 1], a[2 * i]);\n        }\n    }\n    underlying_type range_concat(int l, int r) { // 0-based, [l, r)\n        underlying_type lacc = mon.unit(), racc = mon.unit();\n        for (l += n, r += n; l < r; l /= 2, r /= 2) { // 1-based loop, 2x faster than recursion\n            if (l % 2 == 1) lacc = mon.append(lacc, a[(l ++) - 1]);\n            if (r % 2 == 1) racc = mon.append(a[(-- r) - 1], racc);\n        }\n        return mon.append(lacc, racc);\n    }\n};\nstruct plus_monoid {\n    typedef int underlying_type;\n    int unit() const { return 0; }\n    int append(int a, int b) const { return a + b; }\n};\n\nint policy_1(int n, vector<int> const & a, vector<int> const & b) {\n    int b_max = *max_element(ALL(b));\n    segment_tree<plus_monoid> l(b_max + 1);\n    segment_tree<plus_monoid> r(b_max + 1);\n    int result = 0;\n    REP (i, n) {\n        chmax(result, (i + 1) - l.range_concat(0, a[i] + 1) - r.range_concat(b[i], b_max + 1));\n        l.point_set(b[i], l.range_concat(b[i], b[i] + 1) + 1);\n        r.point_set(a[i], r.range_concat(a[i], a[i] + 1) + 1);\n    }\n    return result;\n}\n\nint policy_2(int n, vector<int> const & a, vector<int> const & b) {\n    int b_max = *max_element(ALL(b));\n    vector<int> imos(b_max + 1);\n    REP (i, n) {\n        imos[a[i]] += 1;\n        imos[b[i]] -= 1;\n    }\n    REP (x, b_max) {\n        imos[x + 1] += imos[x];\n    }\n    return *max_element(ALL(imos));\n}\n\nint main() {\n    // input\n    int n; scanf(\"%d\", &n);\n    vector<int> a(n), b(n);\n    REP (i, n) {\n        scanf(\"%d%d\", &a[i], &b[i]);\n    }\n    // solve\n    int s1 = policy_1(n, a, b);\n    int s2 = policy_2(n, a, b);\n    // output\n    printf(\"%d %d\\n\", s1, s2);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, a[200009], b[200009], imos[100009], bit[100009]; vector<int> g[100009], gs[100009];\nvoid add(int pos, int val) {\n\tfor (int i = pos + 1; i <= 100000; i += i & (-i)) bit[i] += val;\n}\nint sum(int pos) {\n\tint ret = 0;\n\tfor (int i = pos; i >= 1; i -= i & (-i)) ret += bit[i];\n\treturn ret;\n}\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i] >> b[i]; a[i]--; b[i] -= 2;\n\t\timos[a[i]]++;\n\t\timos[b[i] + 1]--;\n\t\tg[b[i]].push_back(i);\n\t\tgs[a[i]].push_back(i);\n\t}\n\tfor (int i = 0; i < 100000; i++) imos[i + 1] += imos[i];\n\tint rb = *max_element(imos, imos + 100000), ra = 0;\n\tfor (int i = 0; i <= 100000; i++) {\n\t\tfor (int j : gs[i]) add(i, 1);\n\t\tfor (int j : g[i]) add(a[j], -1), add(i, 1);\n\t\tfor (int j : g[i]) ra = max(ra, sum(i + 1) - sum(a[j]));\n\t}\n\tcout << ra << ' ' << rb << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a ; i <= b; ++ i) \nconst int N = 2e5 + 5, M = N , mo = 1e9 + 7 ;\nconst ll inf = 1e17 ;\nusing namespace std ;\n\nstruct poi {\n    int l, r, ans ;\n} a[N], b[N] ;\nmultiset <int> S ;\nint n, bit[N] ;\n\nbool cmpl(poi a, poi b) {\n    return a.l < b.l ;\n}\n\nbool cmpr(poi a, poi b) {\n    return a.r < b.r ;\n}\n\nint solve() {\n    rep(i, 0, M - 5) bit[i] = 0 ;\n    rep(i, 1, n) ++ bit[a[i].l], -- bit[a[i].r] ;\n    rep(i, 1, M - 5) bit[i] += bit[i - 1] ;\n    int res = 0 ;\n    rep(i, 0, M - 5) res = max(res, bit[i]) ;\n    return res ;\n}\n\nvoid put(int x) {\n    for ( ; x <= M - 5 ; x += x & (- x)) bit[x] ++ ;\n}\n\nint get(int x) {\n    int res = 0 ;\n    for ( ; x ; x -= x & (- x)) res += bit[x] ;\n    return res ;\n}\n\nint SOLVE() {\n    sort(a + 1, a + n + 1, cmpl) ;\n    rep(i, 1, n) a[i].ans = n ;\n    rep(i, 1, n) {\n        a[i].ans -= get(a[i].l) ;\n        put(a[i].r) ;\n    }\n    rep(i, 0, M - 5) bit[i] = 0 ;\n    sort(a + 1, a + n + 1, cmpr) ;\n    for (int i = n ; i; -- i) {\n        a[i].ans -= get(M - 5 - a[i].r) ;\n        put(M - 5 - a[i].l) ;\n    }\n    int res = 0 ;\n    rep(i, 1, n) res = max(res, a[i].ans) ;\n    return res ;\n}\n\nint main() {\n    scanf(\"%d\", &n) ;\n    rep(i, 1, n) scanf(\"%d%d\", &a[i].l, &a[i].r) ;\n    int r=solve();\n    printf(\"%d %d\\n\", SOLVE(), r) ;\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<pa,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                 \n                                        using namespace std;\n\nint par[500100],ranks[500100],kosuu[500100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\n\nint gcd(int a1,int a2){\n\tif(a1<a2) return gcd(a2,a1);\n\tif(a2==1) return 1;\n\tif(a1%a2==0) return a2;\n\treturn gcd(a2,a1%a2);\n}\n\n\nint rui2(int e,int r){\n\tif(r==0) return 1;\n\tif(r==1) return e%inf;\n\tif(r%2==1) return (e*rui2(e,r-1))%inf;\n\tint w=rui2(e,r/2)%inf;\n\treturn (w*w)%inf;\n}\n\nint n;\nint a[200030];\nint b[200030];\nint hajime[200030]={0},owari[200030]={0};\nint imos[200030]={0};\n\nint solve1(){\n\tfor(int i=0;i<n;i++)hajime[a[i]]++,owari[b[i]]++;\n\tfor(int i=1;i<=200000;i++)owari[i]+=owari[i-1];\n\tfor(int i=200000;i>=0;i--)hajime[i]+=hajime[i+1];\n\t\n\tint ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tans=max(ans,n-owari[a[i]]-hajime[b[i]]);\n\t}\n\treturn ans;\n}\nint solve2(){\n\tint ans=0;\n\tfor(int i=0;i<n;i++)imos[a[i]]++,imos[b[i]]--;\n\t\n\tfor(int i=1;i<=200000;i++){\n\t\timos[i]+=imos[i-1];\n\t\tans=max(imos[i],ans);\n\t}\n\treturn ans;\n//\tcout<<ans<<endl;\n}\n\n            signed main(){\n   cin>>n;\n            \tfor(int i=0;i<n;i++) cin>>a[i]>>b[i];\n            \t\n            \tcout<<solve1()<<\" \"<<solve2()<<endl;\n            \treturn 0;\n            }\n             "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\n#define FRER() freopen(\"i.txt\", \"r\", stdin);\n\nusing namespace std;\n\nconst int maxn = 100000 + 5;\n\nint l[maxn], r[maxn], ml[maxn] = {0}, mr[maxn] = {0}, sum[maxn] = {0};\n\nint main()\n{\n\tint n, ans1 = 0, ans2 = 0;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tscanf(\"%d %d\", &l[i], &r[i]);\n\t\t++sum[l[i]];\n\t\t--sum[r[i]];\n\t\t++ml[l[i]];\n\t\t++mr[r[i]];\n\t}\n\tfor(int i = 1; i < maxn; ++i) {\n\t\tsum[i] += sum[i - 1];\n\t\tml[i] += ml[i - 1];\n\t\tmr[i] += mr[i - 1];\n\t\tans2 = max(ans2, sum[i]);\n\t}\n\tfor(int i = 0; i < n; ++i) {\n\t\tans1 = max(ans1, ml[r[i] - 1] - mr[l[i]]);\n\t}\n\tprintf(\"%d %d\\n\", ans1, ans2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nvoid StartingAScenicRailroadService(const int board[], const int alight[], const int n) {\n\tstatic int geton[100001], getoff[100001], order[200000];\n\tint policy1 = 0, policy2 = 0;\n\tfor (int s = 1;s <= 100000;s++)geton[s] = getoff[s] = 0;\n\tfor (int i = 0;i < n;i++)++geton[board[i]], ++getoff[alight[i]];\n\tfor (int s = 1;s < 100000;s++)geton[s + 1] += geton[s], getoff[s + 1] += getoff[s];\n\tfor (int i = 0;i < n;i++)order[--geton[board[i]]] = i;\n\tfor (int k = 0;k < n;k++) {\n\t\tint a = alight[order[k]], b = board[order[k]];\n\t\tif (geton[a] - getoff[b] > policy1)policy1 = geton[a] - getoff[b];\n\t\tif (geton[b + 1] - getoff[b] > policy2)policy2 = geton[b + 1] - getoff[b];\n\t}\n\tcout << policy1 << ' ' << policy2 << endl;\n}\n\nint main() {\n\tstatic int board[200000], alight[200000];\n\tint n;\n\tcin >> n;\n\tfor (int i = 0;i < n;i++)cin >> board[i] >> alight[i];\n\tStartingAScenicRailroadService(board, alight, n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint memo[200100];\n\nint main()\n{\n\tint n;cin >> n;\n\tvector<pair<pair<int,int>,int> > v;\n\tREP(i,n)\n\t{\n\t\tint a,b;cin >> a >> b;\n\t\tv.PB(MP(MP(a,i),1));\n\t\tv.PB(MP(MP(b,i),0));\n\t}\n\t\n\tsort(ALL(v));\n\t\n\tll ans1 = 0,ans2 = 0,imos = 0;\n\tll inin = 0,ouou = 0;\n\t\n\tREP(i,v.size())\n\t{\n\t\tvector<pair<pair<int,int>,int> > now;\n\t\tauto tmp = v[i];\n\t\tnow.PB(tmp);\n\t\twhile(tmp.FI == v[i+1].FI)\n\t\t{\n\t\t\tauto tmtm = v[i+1];\n\t\t\tnow.PB(tmtm);\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tREP(j,now.size())\n\t\t{\n\t\t\tif(now[j].SE == 1)\n\t\t\t{\n\t\t\t\tinin++;\n\t\t\t\timos++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\touou++;\n\t\t\t\timos--;\n\t\t\t}\n\t\t}\n\t\tans1 = max(ans1,imos);\n\t\t\n\t\tREP(j,now.size())\n\t\t{\n\t\t\tint num = now[j].FI.SE;\n\t\t\tif(now[j].SE == 1)\n\t\t\t{\n\t\t\t\tmemo[num] = ouou;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tll tmtm = inin - memo[num];\n\t\t\t\tans2 = max(ans2,tmtm);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans2 << ' ' << ans1 << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\nint a[100005];\nint b[100005];\nint l[100005];\nint r[100005];\nint s[100005];\nint main()\n{\n\tint i, n;\n\tint x, y;\n\tscanf(\"%d\", &n);\n\tfor(i = 1 ; i <= n ;i++)\n\t{\n\t\tscanf(\"%d %d\", &x, &y);\n\t\ta[x]++;\n\t\tb[y]++;\n\t\tl[i] = x;\n\t\tr[i] = y;\n\t\ts[x]++;\n\t\ts[y]--;\n\t}\n\tfor(i = 1 ; i <= 100000 ; i++)\n\t{\n\t\ta[i] = a[i] + a[i - 1];\n\t\tb[i] = b[i] + b[i - 1];\n\t\ts[i] = s[i] + s[i - 1];\n\t}\n\tint ans1 = 0,ans2 = 0;\n\tfor(i = 1 ; i <= n ; i++)\n\t{\n\t\tans1 = max(ans1, a[r[i] - 1] - b[l[i]]);\n\t}\n\tfor(i = 1 ; i <= 100000 ;i++)\n\t{\n\t\tans2 = max(ans2, s[i]);\n\t}\n\tprintf(\"%d %d\\n\",ans1,ans2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=1<<18,INF=1<<30;\n\nstruct data{\n    int l;\n    int r;\n    int id;\n};\n\nint bit[MAX+1],N;\n\n//1-indexed\n\nint sum(int i){\n    int s=0;\n    while(i>0){\n        s+=bit[i];\n        i-=i&-i;\n    }\n    return s;\n}\n\n//sからtの和=sum(t)-sum(s-1)\n\nvoid add(int i,int x){\n    while(i<=N){\n        bit[i]+=x;\n        i+=i&-i;\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int M;cin>>M;\n    vector<data> S(M);\n    vector<int> cnt(100005),C(M),D(M);\n    for(int i=0;i<M;i++){\n        int a,b;cin>>a>>b;\n        S[i].l=a;\n        S[i].r=b;\n        S[i].id=i;\n        cnt[a]++;\n        cnt[b]--;\n    }\n    int ma2=0;\n    \n    for(int i=1;i<100005;i++){\n        cnt[i]+=cnt[i-1];\n        ma2=max(ma2,cnt[i]);\n    }\n    \n    sort(all(S),[](data a,data b){\n        return a.r<b.r;\n    });\n    \n    N=200000;\n    \n    for(int i=0;i<M;i++){\n        add(S[i].r,1);\n        C[S[i].id]=sum(S[i].l);\n    }\n    \n    memset(bit,0,sizeof(bit));\n    \n    sort(all(S),[](data a,data b){\n        return a.l>b.l;\n    });\n    \n    for(int i=0;i<M;i++){\n        add(S[i].l,1);\n        D[S[i].id]=sum(N-1)-sum(S[i].r-1);\n    }\n    \n    int ma=0;\n    \n    for(int i=0;i<M;i++){\n        ma=max(ma,M-C[i]-D[i]);\n    }\n    \n    cout<<ma<<\" \"<<ma2<<endl;\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <map>\n#include <cstring>\n#include <set>\n#include <stack>\n#include <cstdlib>\n#include <bitset>\nusing namespace std;\n\nconst int maxn = 200000 + 10;\n\nstruct Seg\n{\n\tint l, r;\n\tSeg() {}\n\tSeg(int l, int r): l(l), r(r) {}\n\tbool operator < (const Seg &t) const\n\t{\n\t\treturn r < t.r;\n\t}\n};\n\nvector<int> vl, vr;\nSeg s[maxn];\n\nint n;\n\nint main()\n{\n\t// freopen(\"in.txt\", \"r\", stdin);\n\tcin >> n;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tvl.push_back(l);\n\t\tvr.push_back(r);\n\t\ts[i] = Seg(l, r);\n\t}\n\tsort(vl.begin(), vl.end());\n\tsort(vr.begin(), vr.end());\n\tint ans1 = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint t1 = upper_bound(vr.begin(), vr.end(), s[i].l) - vr.begin();\n\t\tint t2 = lower_bound(vl.begin(), vl.end(), s[i].r) - vl.begin();\n\t\tt2 = n - t2;\n\t\tans1 = max(ans1, n - t1 - t2);\n\t}\n\tpriority_queue<int, vector<int>, greater<int> > q;\n\tsort(s, s + n);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(q.empty())\n\t\t{\n\t\t\tq.push(s[i].r);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(q.top() <= s[i].l)\n\t\t\t{\n\t\t\t\tq.pop();\n\t\t\t\tq.push(s[i].r);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tq.push(s[i].r);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans1 << \" \" << q.size() << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring> \nusing namespace std;\nint n,a[200005],b[200005],ans1,ans2,r[100005],dz,sc[100005],xc[100005];\nint main(){\n\t\n\tcin >> n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin >> a[i] >> b[i];\n\t  sc[a[i]]++;\n\t  xc[b[i]]++;\n\t  r[a[i]]++;\n\t  r[b[i]]--;\n\t  dz=max(dz,b[i]);\n\t}\n\tfor(int i=1;i<=dz;i++)\n\t{\n\t\tsc[i]+=sc[i-1];\n\t\txc[i]+=xc[i-1];\n\t } \n\t for(int i=1;i<=n;i++)\n\t ans1=max(ans1,sc[b[i]-1]-xc[a[i]]);\n\tfor(int i=1;i<=dz;i++)\n\t{r[i]+=r[i-1];\n\tans2=max(ans2,r[i]);\n\t}\n\tcout << ans1 << \" \" << ans2  <<endl;\n\t return 0;\n} \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int N, A[200000], B[200000];\n  int sum[100000] = {};\n\n  vector< int > add[100000], del[100000];\n  int ans[200000] = {};\n\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++) {\n    scanf(\"%d %d\", &A[i], &B[i]);\n    --A[i], --B[i];\n    ++sum[A[i]];\n    --sum[B[i]];\n    add[A[i]].emplace_back(i);\n    del[B[i]].emplace_back(i);\n  }\n\n  int ret = 0, cur = 0;\n  for(int i = 0; i < 100000; i++) {\n    cur += sum[i];\n    ret = max(ret, cur);\n  }\n\n  cur = 0;\n  int open = 0;\n  for(int i = 0; i < 100000; i++) {\n    for(auto &idx : del[i]) ans[idx] += open;\n    cur -= del[i].size();\n    for(auto &idx : add[i]) ans[idx] -= open - cur;\n    open += add[i].size();\n    cur += add[i].size();\n  }\n  cout << *max_element(ans, ans + N) << \" \" << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  typedef function <T(T,T)> F;\n  typedef function <T(T,E)> G;\n  int n;\n  F f;\n  G g;\n  T d1;\n  E d0;\n  vector<T> dat;\n  SegmentTree(){};\n  SegmentTree(int n_,F f,G g,T d1,\n\t      vector<T> v = vector<T>()):\n    f(f),g(g),d1(d1){\n    init(n_);\n    if(n_==(int)v.size()) build(n_,v);\n  }\n\n  void init(int n_){\n    n = 1;\n    while(n<n_) n *= 2;\n    dat.clear();\n    dat.resize(2*n-1,d1);\n  }\n  \n  void build(int n_,vector<T> v){\n    for(int i=0;i<n_;i++) dat[i+n-1] = v[i];\n    for(int i=n-2;i>=0;i--)\n      dat[i] = f(dat[i*2+1],dat[i*2+2]);\n  }\n\n  inline int query(int a,int b,int c,int d,function< int(T, int, int)> calc){\n    int vl = d1, vr = d1;\n    for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1){\n      if(l&1) vl = vl+calc(dat[(l++)-1]);\n      if(r&1) vr = calc(dat[(--r)-1])+vr;\n    }\n    return vl+vr;\n  }\n};\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  int n;\n  cin>>n;\n  vector<int> s(n),t(n);\n  for(int i=0;i<n;i++) cin>>s[i];\n  const int MAX = 114514;\n  using Vec = vector<int>;\n  vector<Vec> v(MAX);\n  for(int \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <functional>\n#include <utility>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <map>\n#include <set>\n#include <climits>\ntypedef long long ll;\n#define rll register ll\n#define rint register int\n#define rdouble register double\n#define mem(a) memset(a,0,sizeof(a)\n#define maxn int(1e7)\n#define eps int(1e-6)\n#define inf 0x3f3f3f3f\nusing namespace std;\nint a[maxn+10],b[maxn+10],get[maxn+10],off[maxn+10],p[maxn+10];\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    int cnt=-1;\n    for(int i=1; i<=n; i++)\n    {\n        scanf(\"%d%d\",&a[i],&b[i]);\n        get[a[i]]++;\n        off[b[i]]++;\n\n        p[a[i]]++;\n        p[b[i]]--;\n        cnt=max(cnt,b[i]);\n    }\n    for(int i=1;i<=cnt;i++)\n    {\n        get[i]+=get[i-1];\n        off[i]+=off[i-1];\n        p[i]+=p[i-1];\n    }\n    int ans1=-1,ans2=-1;\n    for(int i=1;i<=n;i++)\n    {\n        ans1=max(ans1,get[b[i]-1]-off[a[i]]);\n    }\n    for(int i=1;i<=cnt;i++)\n    {\n        \n        ans2=max(ans2,p[i]);\n    }\n    printf(\"%d %d\\n\", ans1,ans2);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a ; i <= b; ++ i) \nconst int N = 2e5 + 5, M = N , mo = 1e9 + 7 ;\nconst ll inf = 1e17 ;\nusing namespace std ;\n\nstruct poi {\n    int l, r, ans ;\n} a[N], b[N] ;\nmultiset <int> S ;\nint n, bit[N] ;\n\nbool cmpl(poi a, poi b) {\n    return a.l < b.l ;\n}\n\nbool cmpr(poi a, poi b) {\n    return a.r < b.r ;\n}\n\nint solve() {\n    rep(i, 0, M - 5) bit[i] = 0 ;\n    rep(i, 1, n) ++ bit[a[i].l], -- bit[a[i].r] ;\n    rep(i, 1, M - 5) bit[i] += bit[i - 1] ;\n    int res = 0 ;\n    rep(i, 0, M - 5) res = max(res, bit[i]) ;\n    return res ;\n}\n\nvoid put(int x) {\n    for ( ; x <= M - 5 ; x += x & (- x)) bit[x] ++ ;\n}\n\nint get(int x) {\n    int res = 0 ;\n    for ( ; x ; x -= x & (- x)) res += bit[x] ;\n    return res ;\n}\n\nint l[N],r[N];\n\nint SOLVE() {\n\trep(i,1,M-5) bit[i]=0;\n    sort(a + 1, a + n + 1, cmpl) ;\n    rep(i, 1, n) a[i].ans = n ;\n    rep(i, 1, n) {\n        a[i].ans -= get(a[i].l) ;\n        put(a[i].r) ;\n    }\n    rep(i, 0, M - 5) bit[i] = 0 ;\n    sort(a + 1, a + n + 1, cmpr) ;\n    for (int i = n ; i; -- i) {\n        a[i].ans -= get(M - 5 - a[i].r) ;\n        put(M - 5 - a[i].l) ;\n    }\n    int res = 0 ;\n    rep(i, 1, n) res = max(res, a[i].ans) ;\n    return res ;\n}\n\nint main() {\n    scanf(\"%d\", &n) ;\n    rep(i, 1, n) scanf(\"%d%d\", &a[i].l, &a[i].r) ;\n    int r=solve();\n    printf(\"%d %d\\n\", SOLVE(), r) ;\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint ans1,ans2,a[200001],b[200001],r[200001],MAX;\nint sc[200001];\nint xc[200001];\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tsc[a[i]]++;\n\t\txc[b[i]]++;\n\t\tr[a[i]]++;\n\t\tr[b[i]]--;\n\t\tMAX=max(MAX,b[i]);\n\t}\n\tfor(int i=1;i<=MAX;i++)\n\t{\n\t\tsc[i]+=sc[i-1];\n\t\txc[i]+=xc[i-1];\n\t}\n\tfor(int i=1;i<=n;i++)\n\tans1=max(ans1,sc[b[i]-1]-xc[a[i]]);\n\tfor(int i=1;i<=MAX;i++)\n\t{\n\t\tr[i]+=r[i-1];\n\t\tans2=max(ans2,r[i]);\n\t}\n\tprintf(\"%d %d\\n\",ans1,ans2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define REP_R(i, n) for (int i = (n) - 1; (i) >= 0; -- (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\ntemplate <class T> inline void chmax(T & a, T const & b) { a = max(a, b); }\n\ntemplate <class Monoid>\nstruct segment_tree {\n    typedef typename Monoid::underlying_type underlying_type;\n    int n;\n    vector<underlying_type> a;\n    Monoid mon;\n    segment_tree() = default;\n    segment_tree(int a_n, underlying_type initial_value = Monoid().unit(), Monoid const & a_mon = Monoid()) : mon(a_mon) {\n        n = 1; while (n < a_n) n *= 2;\n        a.resize(2 * n - 1, mon.unit());\n        fill(a.begin() + (n - 1), a.begin() + ((n - 1) + a_n), initial_value); // set initial values\n        REP_R (i, n - 1) a[i] = mon.append(a[2 * i + 1], a[2 * i + 2]); // propagate initial values\n    }\n    void point_set(int i, underlying_type z) { // 0-based\n        a[i + n - 1] = z;\n        for (i = (i + n) / 2; i > 0; i /= 2) { // 1-based\n            a[i - 1] = mon.append(a[2 * i - 1], a[2 * i]);\n        }\n    }\n    underlying_type range_concat(int l, int r) { // 0-based, [l, r)\n        underlying_type lacc = mon.unit(), racc = mon.unit();\n        for (l += n, r += n; l < r; l /= 2, r /= 2) { // 1-based loop, 2x faster than recursion\n            if (l % 2 == 1) lacc = mon.append(lacc, a[(l ++) - 1]);\n            if (r % 2 == 1) racc = mon.append(a[(-- r) - 1], racc);\n        }\n        return mon.append(lacc, racc);\n    }\n};\nstruct plus_monoid {\n    typedef int underlying_type;\n    int unit() const { return 0; }\n    int append(int a, int b) const { return a + b; }\n};\n\ntemplate <class OperatorMonoid>\nstruct dual_segment_tree {\n    typedef typename OperatorMonoid::underlying_type operator_type;\n    typedef typename OperatorMonoid::target_type underlying_type;\n    int n;\n    vector<operator_type> f;\n    vector<underlying_type> a;\n    OperatorMonoid op;\n    dual_segment_tree() = default;\n    dual_segment_tree(int a_n, underlying_type initial_value, OperatorMonoid const & a_op = OperatorMonoid()) : op(a_op) {\n        n = 1; while (n < a_n) n *= 2;\n        a.resize(n, initial_value);\n        f.resize(n-1, op.unit());\n    }\n    underlying_type point_get(int i) { // 0-based\n        underlying_type acc = a[i];\n        for (i = (i+n)/2; i > 0; i /= 2) { // 1-based\n            acc = op.apply(f[i-1], acc);\n        }\n        return acc;\n    }\n    void range_apply(int l, int r, operator_type z) { // 0-based, [l, r)\n        assert (0 <= l and l <= r and r <= n);\n        range_apply(0, 0, n, l, r, z);\n    }\n    void range_apply(int i, int il, int ir, int l, int r, operator_type z) {\n        if (l <= il and ir <= r) { // 0-based\n            if (i < f.size()) {\n                f[i] = op.append(z, f[i]);\n            } else {\n                a[i-n+1] = op.apply(z, a[i-n+1]);\n            }\n        } else if (ir <= l or r <= il) {\n            // nop\n        } else {\n            range_apply(2*i+1, il, (il+ir)/2, 0, n, f[i]);\n            range_apply(2*i+2, (il+ir)/2, ir, 0, n, f[i]);\n            f[i] = op.unit();\n            range_apply(2*i+1, il, (il+ir)/2, l, r, z);\n            range_apply(2*i+2, (il+ir)/2, ir, l, r, z);\n        }\n    }\n};\nstruct plus_operator_monoid {\n    typedef int underlying_type;\n    typedef int target_type;\n    int unit() const { return 0; }\n    int append(int a, int b) const { return a + b; }\n    int apply(int a, int b) const { return a + b; }\n};\n\nint policy_1(int n, vector<int> const & a, vector<int> const & b) {\n    int b_max = *max_element(ALL(b));\n    dual_segment_tree<plus_operator_monoid> segtree1(b_max + 1, 0);\n    segment_tree<plus_monoid> segtree2(b_max + 1);\n    int result = 0;\n    REP (i, n) {\n        chmax(result, segtree1.point_get(a[i]) + segtree2.range_concat(a[i], b[i]) + 1);\n        segtree1.range_apply(a[i] + 1, b[i], 1);\n        segtree2.point_set(a[i], segtree2.range_concat(a[i], a[i] + 1) + 1);\n    }\n    return result;\n}\n\nint policy_2(int n, vector<int> const & a, vector<int> const & b) {\n    int b_max = *max_element(ALL(b));\n    vector<int> imos(b_max + 1);\n    REP (i, n) {\n        imos[a[i]] += 1;\n        imos[b[i]] -= 1;\n    }\n    REP (x, b_max) {\n        imos[x + 1] += imos[x];\n    }\n    return *max_element(ALL(imos));\n}\n\nint main() {\n    // input\n    int n; scanf(\"%d\", &n);\n    vector<int> a(n), b(n);\n    REP (i, n) {\n        scanf(\"%d%d\", &a[i], &b[i]);\n    }\n    // solve\n    int s1 = policy_1(n, a, b);\n    int s2 = policy_2(n, a, b);\n    // output\n    printf(\"%d %d\\n\", s1, s2);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint memo[201000];\n\nint main()\n{\n\tint n;cin >> n;\n\tvector<pair<pair<int,int>,int> > v;\n\tREP(i,n)\n\t{\n\t\tint a,b;cin >> a >> b;\n\t\tv.PB(MP(MP(a,i),1));\n\t\tv.PB(MP(MP(b,i),0));\n\t}\n\t\n\tsort(ALL(v));\n\t\n\tll ans1 = 0,ans2 = 0,imos = 0;\n\tll inin = 0,ouou = 0;\n\t\n\tREP(i,v.size())\n\t{\n\t\tvector<pair<pair<int,int>,int> > now;\n\t\tauto tmp = v[i];\n\t\tnow.PB(tmp);\n\t\twhile(i+1 != v.size()&&tmp.FI == v[i+1].FI)\n\t\t{\n\t\t\tauto tmtm = v[i+1];\n\t\t\tnow.PB(tmtm);\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tREP(j,now.size())\n\t\t{\n\t\t\tif(now[j].SE == 1)\n\t\t\t{\n\t\t\t\tinin++;\n\t\t\t\timos++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\touou++;\n\t\t\t\timos--;\n\t\t\t}\n\t\t}\n\t\tans1 = max(ans1,imos);\n\t\t\n\t\tREP(j,now.size())\n\t\t{\n\t\t\tint num = now[j].FI.SE;\n\t\t\tif(now[j].SE == 1)\n\t\t\t{\n\t\t\t\tmemo[num] = ouou;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tll tmtm = inin - memo[num];\n\t\t\t\tans2 = max(ans2,tmtm);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans2 << ' ' << ans1 << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<stack>\n#include<algorithm>\n#include<cstdio>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<iomanip>\n#include<cstring>\n#include<list>\n#include<typeinfo>\n#include<vector>\n\nusing namespace std;\nconst int maxn = 2e5+10;\nint ans1,ans2,a[maxn],b[maxn],r[maxn],MAX;\nint sc[maxn];\nint xc[maxn];\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>a[i]>>b[i];\n        sc[a[i]]++;\n        xc[b[i]]++;\n        r[a[i]]++;\n        r[b[i]]--;\n        MAX = max(MAX, b[i]);\n    }\n    for(int i = 1;i<= MAX;i++)\n    {\n        sc[i]+= sc[i-1];\n        xc[i]+= xc[i-1];\n    }\n    for(int i=1; i<=n;i++)\n        ans1=max(ans1,sc[b[i]-1]-xc[a[i]]);\n    for(int i=1;i<=MAX;i++)\n    {\n        r[i]+=r[i-1];\n        ans2 = max(ans2,r[i]);\n    }\n    cout<<ans1<<' '<<ans2<<endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nint n,l,r,imos[100007],ans1,ans2,sum;\n\nvector<P>v;\nvector<int>v1,v2;\n\nint main(){\n  \n  cin>>n;\n\n  for(int i=0;i<n;i++){\n    cin>>l>>r;\n    v.push_back(P(l,r));\n    v1.push_back(l);\n    v2.push_back(r);\n    imos[l]++;\n    imos[r]--;\n  }\n\n  sort(v1.begin(),v1.end());\n  sort(v2.begin(),v2.end());\n\n  for(int i=0;i<n;i++){\n    int sum1=lower_bound(v2.begin(),v2.end(),v[i].first)-v2.begin();\n    int sum2=v1.end()-lower_bound(v1.begin(),v1.end(),v[i].second);\n    ans1=max(ans1,n-sum1-sum2);\n  }\n\n  for(int i=0;i<100007;i++){\n    sum+=imos[i];\n    ans2=max(ans2,sum);\n  }\n\n  cout<< ans1 << ' ' << ans2 <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint l[200010], r[200010], lqz[200010], rqz[200010], s[200010];\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tscanf(\"%d%d\", &l[i], &r[i]);\n\t\tlqz[l[i]]++;\n\t\trqz[r[i]]++;\n\t\ts[l[i]]++;\n\t\ts[r[i]]--;\n\t}\n\tfor (int i = 1; i <= 100000; ++i)\n\t{\n\t\tlqz[i] += lqz[i - 1];\n\t\trqz[i] += rqz[i - 1];\n\t\ts[i] += s[i - 1];\n\t}\n\tint ans1(0), ans2(0);\n\tfor (int i = 0; i < n; ++i)\n\t\tans1 = max(ans1, lqz[r[i] - 1] - rqz[l[i]]);\n\tfor (int i = 1; i <= 100000; ++i)\n\t\tans2 = max(ans2, s[i]);\n\tprintf(\"%d %d\", ans1, ans2);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define ls o << 1\n#define rs o << 1 | 1\nusing namespace std;\nconst int maxn = 2e5 + 10;\n\nstruct Tree {\n    LL sum, add, _set;\n    int l, r;\n} tree[4 * maxn];\n\nvoid build(int o, int L, int R)\n{\n    if (L == R) {\n        tree[o].sum = tree[o].add = 0;\n        tree[o]._set = -1;\n        tree[o].l = tree[o].r = L;\n        return;\n    }\n    int M = (L + R) >> 1;\n    build(ls, L, M);\n    build(rs, M + 1, R);\n\n    tree[o].sum = tree[ls].sum + tree[rs].sum;\n    tree[o].add = 0;\n    tree[o]._set = -1;\n    tree[o].l = tree[ls].l, tree[o].r = tree[rs].r;\n}\n\nvoid maintain(int o, int L, int R)\n{\n    tree[o].sum = 0;\n    if (R > L)\n        tree[o].sum = tree[ls].sum + tree[rs].sum;\n    if (tree[o]._set >= 0)\n        tree[o].sum = tree[o]._set * ((LL)R - L + 1);\n    if (tree[o].add)\n        tree[o].sum += tree[o].add * ((LL)R - L + 1);\n}\n\nvoid pushdown(int o)\n{\n    if (tree[o]._set != -1)\n        tree[ls]._set = tree[rs]._set = tree[o]._set, tree[ls].add = tree[rs].add = 0, tree[o]._set = -1;\n    if (tree[o].add)\n        tree[ls].add += tree[o].add, tree[rs].add += tree[o].add, tree[o].add = 0;\n}\n\nvoid update(int o, int L, int R, int qL, int qR, int v, int op)\n{\n    if (qL <= L && R <= qR) {\n        if (op == 0)\n            tree[o].add += v;\n        if (op == 1)\n            tree[o]._set = v, tree[o].add = 0;\n    } else {\n        pushdown(o);\n        int M = (L + R) >> 1;\n        if (qL <= M)\n            update(ls, L, M, qL, qR, v, op);\n        else\n            maintain(ls, L, M);\n        if (qR > M)\n            update(rs, M + 1, R, qL, qR, v, op);\n        else\n            maintain(rs, M + 1, R);\n    }\n    maintain(o, L, R);\n}\n\nLL query(int o, int L, int R, int qL, int qR, LL add)\n{\n    if (tree[o]._set >= 0) {\n        return (tree[o]._set + add + tree[o].add) * ((LL)min(R, qR) - max(L, qL) + 1);\n    } else if (qL <= L && R <= qR) {\n        return tree[o].sum + add * (R - L + 1);\n    }\n    int M = (L + R) >> 1;\n    LL ans = 0;\n    if (qL <= M)\n        ans += query(ls, L, M, qL, qR, add + tree[o].add);\n    if (qR > M)\n        ans += query(rs, M + 1, R, qL, qR, add + tree[o].add);\n    return ans;\n}\n\nint n, s[maxn], t[maxn];\n\nint main()\n{\n    scanf(\"%d\", &n);\n    build(1, 1, 100000);\n    LL ans1 = 0, ans2 = 0;\n    for(int i = 0; i < n; i ++) {\n        scanf(\"%d%d\", &s[i], &t[i]);\n        update(1, 1, 100000, s[i], t[i] - 1, 1, 0);\n    }\n    for(int i = 1; i <= 100000; i ++)\n        ans1 = max(ans1, query(1, 1, 100000, i, i, 0));\n    sort(s, s + n);\n    sort(t, t + n);\n    for(int i = 0; i < n; i ++) {\n        int tl = upper_bound(t, t + n, s[i]) - t - 1, tr = lower_bound(s, s + n, t[i]) - s;\n        int resL = tl + 1, resR = n - tr;\n        ans2 = max(ans2, (LL)n - resL - resR);\n    }\n    printf(\"%lld %lld\\n\", ans2, ans1);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n    int N;\n    cin >> N;\n    vector<int> A(N),B(N);\n    vector<int> L(100010),R(100010),imos(100010);\n    for(int i=0;i<N;i++){\n        cin >> A[i] >> B[i];\n        L[B[i]-1]++;\n        R[A[i]]++;\n        imos[A[i]]++; imos[B[i]]--;\n    }\n    int ans1 = 0,ans2 = 0;\n    for(int i=1;i<=100000;i++){\n        L[i] += L[i-1];\n        imos[i] += imos[i-1];\n        ans2 = max(ans2,imos[i]);\n    }\n    for(int i=100000;i>=1;i--){\n        R[i] += R[i+1];\n    }\n//    for(int i=1;i<=6;i++) cerr << L[i] << \" \" << R[i] << endl;\n    for(int i=0;i<N;i++){\n        ans1 = max(ans1,N-L[A[i]-1]-R[B[i]]);\n    }\n    cout << ans1 << \" \" << ans2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N;\nint A[222222],B[222222];\nint sum[111111],sum1[111111],sum2[111111];\n\nsigned main(){\n    cin>>N;\n    rep(i,N)cin>>A[i]>>B[i];\n    rep(i,N){\n        sum[A[i]]++;\n        sum[B[i]]--;\n\n        sum1[A[i]]++;\n        sum2[B[i]]++;\n    }\n\n    rep(i,111111-1){\n        sum[i+1]+=sum[i];\n        sum1[i+1]+=sum1[i];\n        sum2[i+1]+=sum2[i];\n    }\n\n    int ans=0;\n    rep(i,N){\n        int tmp=0;\n        tmp+=sum2[A[i]];\n        tmp+=N-sum1[B[i]-1];\n        chmax(ans,N-tmp);\n    }\n\n    cout<<ans<<\" \"<<*max_element(sum,sum+111111)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\nint n;\nint a[SIZE], b[SIZE];\n\nint solve1(){\n  int right[SIZE] = {};\n  int left[SIZE] = {};\n\n  for(int i=0;i<n;i++){\n    right[b[i]]++;\n    left[a[i]]++;\n  }\n\n  for(int i=0;i<SIZE/2;i++){\n    right[i+1] += right[i];\n    left[SIZE/2 - i] += left[SIZE/2 - i + 1];\n  }\n\n  int ans = 0;\n  \n  for(int i=0;i<n;i++){\n    ans = max(ans, n - right[a[i]] - left[b[i]]);\n  }\n\n  return ans;\n}\n\n\nint solve2(){\n  int sum[SIZE] = {};\n  int ans = 0;\n  \n  for(int i=0;i<n;i++){\n    sum[a[i]]++;\n    sum[b[i]]--;\n  }\n\n  for(int i=0;i<SIZE/2;i++){\n    sum[i+1] += sum[i];\n    ans = max(sum[i], ans);\n  }\n\n  return ans;\n}\n\n\nint main(){\n\n  scanf(\"%d\",&n);\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",a+i, b+i);\n  }\n\n  printf(\"%d %d\\n\",solve1(), solve2());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint memo[201000];\n\nint main()\n{\n\tint n;cin >> n;\n\tvector<pair<pair<int,int>,int> > v;\n\tREP(i,n)\n\t{\n\t\tint a,b;cin >> a >> b;\n\t\tv.PB(MP(MP(a,i),1));\n\t\tv.PB(MP(MP(b,i),0));\n\t}\n\t\n\tsort(ALL(v));\n\t\n\tll ans1 = 0,ans2 = 0,imos = 0;\n\tll inin = 0,ouou = 0;\n\t\n\tREP(i,v.size())\n\t{\n\t\tvector<pair<pair<int,int>,int> > now;\n\t\tauto tmp = v[i];\n\t\tnow.PB(tmp);\n\t\twhile(tmp.FI == v[i+1].FI)\n\t\t{\n\t\t\tauto tmtm = v[i+1];\n\t\t\tnow.PB(tmtm);\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tREP(j,now.size())\n\t\t{\n\t\t\tif(now[j].SE == 1)\n\t\t\t{\n\t\t\t\tinin++;\n\t\t\t\timos++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\touou++;\n\t\t\t\timos--;\n\t\t\t}\n\t\t}\n\t\tans1 = max(ans1,imos);\n\t\t\n\t\tREP(j,now.size())\n\t\t{\n\t\t\tint num = now[j].FI.SE;\n\t\t\tif(now[j].SE == 1)\n\t\t\t{\n\t\t\t\tmemo[num] = ouou;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tll tmtm = inin - memo[num];\n\t\t\t\tans2 = max(ans2,tmtm);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans2 << ' ' << ans1 << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing u32 = uint32_t;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define MAXC(c, x) (c = max(c, x))\n#define MINC(c, x) (c = min(c, x))\n\n#define REP(i,n) for(auto i = 0 * (n), i##_len = (n); i < i##_len; ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,n) for(ll i=s, i##_len=(ll)(n); i<i##_len; ++i)\n#define TEN(x) ((ll)1e##x)\nconst ll mod = TEN(9) + 7;\n\nconst ll INF = 1e9;\n\ntemplate <class T, class U = size_t>\nstruct SegTree {\n\t// !!! ????£???? t(lhs, rhs) ????????°??????????????¨???(????????????????????????????±???????????????????) !!!\n\ttypedef typename T::V V;\n\texplicit SegTree(U _n = 0, const T &t = T()) : n(1), t(t) {\n\t\twhile (n < _n) n *= 2;\n\t\tv.assign(n * 2 - 1, t.identity());\n\t\tif (n >= 2) {\n\t\t\tfor (U i = n - 2;; --i) {\n\t\t\t\tv[i] = t(v[i * 2 + 1], v[i * 2 + 2]);\n\t\t\t\tif (i == 0) break; // U????¬????????????´??°???????????§??????????????????????£?????????????\n\t\t\t}\n\t\t}\n\t}\n\tV operator[](U i) const { return v[n - 1 + i]; }\n\tvoid set(U i, const V & x) {\n\t\ti += n - 1;\n\t\tv[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tv[i] = t(v[i * 2 + 1], v[i * 2 + 2]);\n\t\t}\n\t}\n\t// [a,b)?????????????????????????????¨????????????\n\tV get(U a, U b) const { return q(a, b, 0, 0, n); }\nprivate:\n\t// t : traits ?????????????????????\n\t// v : ?????¨????????¨???????????¨???\n\t// n : ?????¨????????¨???????????°\n\tT t;\n\tvector<V> v;\n\tU n;\n\n\t// [a,b)?????????????????????????????¨????????????\n\t// k     : ?????¨??????????????\\????????????\n\t// [l,r) : k????????????????????? \n\tV q(U a, U b, U k, U l, U r) const {\n\t\tif (r <= a || b <= l) return t.identity(); // ?????????\n\t\tif (a <= l && r <= b) return v[k];         // [l,r) ??? [a,b)\n\n\t\t\t\t\t\t\t\t\t\t\t\t   //[l,r)????????¨???[a,b)???????????????\n\t\tU c = (l + r) / 2;\n\t\treturn t(\n\t\t\tq(a, b, k * 2 + 1, l, c),\n\t\t\tq(a, b, k * 2 + 2, c, r)\n\t\t);\n\t}\n};\n\ntemplate <class T>\nstruct SumTrait {\n\ttypedef T V;\n\tV identity() const { return 0; }\n\tV operator()(const V &a, const V &b) const { return a + b; }\n};\n\nint main() {\n\t#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n\t#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\tll n; cin >> n;\n\tvector<pair<ll,ll>> ab(n);\n\tREP(i, n) cin >> ab[i].first >> ab[i].second;\n\n\tll ma = 0;\n\t{\n\t\tvl imos_f(200001, 0), imos_s(200001, 0);\n\t\tREP(i, n) {\n\t\t\timos_f[ab[i].first]++;\n\t\t\timos_s[ab[i].second]++;\n\t\t}\n\t\tFOR(i, 1, 200001) {\n\t\t\timos_f[i] += imos_f[i - 1];\n\t\t\timos_s[i] += imos_s[i - 1];\n\t\t}\n\n\t\tvl v1(n), v2(n);\n\t\t{\n\t\t\tSegTree<SumTrait<ll>> st(200001), st2(200001);\n\t\t\tsort(ALL(ab));\n\t\t\tREP(i, n) {\n\t\t\t\tv1[i] = st.get(ab[i].second, 200001);\n\t\t\t\tst.set(ab[i].second, st[ab[i].second] + 1);\n\t\t\t}\n\t\t\tsort(ALL(ab), greater<>());\n\t\t\tREP(i, n) {\n\t\t\t\tv2[i] = st2.get(0, ab[i].second);\n\t\t\t\tst2.set(ab[i].second, st2[ab[i].second] + 1);\n\t\t\t}\n\t\t}\n\t\tmap<pair<ll, ll>, ll> sum;\n\t\tREP(i, n) sum[ab[i]]++;\n\n\t\tREP(i, n) {\n\t\t\tll cnt = -1;\n\t\t\tcnt += imos_f[ab[i].second - 1] - imos_f[ab[i].first];\n\t\t\tcnt += imos_s[ab[i].second - 1] - imos_s[ab[i].first];\n\t\t\tcnt += v1[i] - v2[i] + sum[ab[i]];\n\t\t\tma = max(ma, cnt);\n\t\t}\n\t}\n\n\n\tsort(ALL(ab), [](pair<ll, ll> lhs, pair<ll, ll> rhs) {\n\t\tif (lhs.second < rhs.second) return true;\n\t\tif (lhs.second > rhs.second) return false;\n\t\treturn lhs.first < rhs.first;\n\t});\n\n\n\tll cnt = 1;\n\tmap<ll, ll> bottoms; bottoms[0]++;\n\tREP(i, n) {\n\t\tauto it = bottoms.upper_bound(ab[i].first);\n\t\tif (it == bottoms.begin()) {\n\t\t\tbottoms[ab[i].second]++;\n\t\t\tcnt++;\n\t\t} else {\n\t\t\tit--;\n\t\t\tit->second--;\n\t\t\tcnt--;\n\t\t\tif (it->second == 0) {\n\t\t\t\tbottoms.erase(it);\n\t\t\t}\n\t\t\tbottoms[ab[i].second]++;\n\t\t\tcnt++;\n\t\t}\n\t}\n\tcout << ma << \" \" << cnt << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <iomanip>\n#include <climits>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\n#define SIZE 200010\n\ntypedef struct _Node\n{\n    int leftPt, rightPt;\n} Node;\n\nNode arr[SIZE];\nint leftArr[SIZE], rightArr[SIZE], rangeArr[SIZE];\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int num;\n    while (cin >> num)\n    {\n        memset(leftArr, 0, sizeof(leftArr));\n        memset(rightArr, 0, sizeof(rightArr));\n        memset(rangeArr, 0, sizeof(rangeArr));\n\n        int len = -1;\n        for (int i = 0; i < num; i++)\n        {\n            cin >> arr[i].leftPt >> arr[i].rightPt;\n\n            leftArr[arr[i].leftPt]++;\n            rightArr[arr[i].rightPt]++;\n            rangeArr[arr[i].leftPt]++;\n            rangeArr[arr[i].rightPt]--;\n\n            len = max(len, arr[i].rightPt + 1);\n        }\n\n        for (int i = 1; i < len; i++)\n        {\n            leftArr[i] += leftArr[i - 1];\n            rightArr[i] += rightArr[i - 1];\n            rangeArr[i] += rangeArr[i - 1];\n        }\n\n        int fstAns = 0;\n        for (int i = 0; i < num; i++)\n        {\n            fstAns = max(fstAns, num - rightArr[arr[i].leftPt] - (leftArr[len - 1] - leftArr[arr[i].rightPt - 1]));\n        }\n\n        int sndAns = 0;\n        for (int i = 0; i < len; i++)\n        {\n            sndAns = max(sndAns, rangeArr[i]);\n        }\n\n        cout << fstAns << \" \" << sndAns << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#include <vector>\n#include <string>\n#include <utility>\n#include <queue>\n#include <stack>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <deque>\n#include <bitset>\n\n#include <cmath>\n#include <functional>\n\n#define ALL(a) (a).begin(), (a).end()\n#define FOR(i, a, b) for(int i = int(a); i < int(b); ++i)\n#define RFOR(i, a, b) for(int i = int(b)-1; i >= int(a); --i)\n#define REP(i, n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define IN(a, x ,b) (a<_x && x < b)\ntemplate<class T> inline T CHMAX(T& a, const T b) {return a=(a<b)?b:a;}\ntemplate<class T> inline T CHMIN(T& a, const T b){return a=(a>b)?b:a;}\n\nusing ll = long long;\n\nusing std::vector;\nusing std::cout;\nusing std::endl;\nusing std::cin;\nusing std::pair;\nusing std::unordered_multimap;\nusing std::set;\nusing std::map;\n\nint main(){\n  int n;\n  cin >> n;\n  vector<int> a(n), b(n);\n  REP(i, n) cin >> a[i] >> b[i];\n\n  int sz = 0;\n  { // zaatsu\n    map<int, int> mp;\n    REP(i, n) mp[a[i]], mp[b[i]];\n    for(auto& p : mp) p.second = sz++;\n    REP(i, n) a[i] = mp[a[i]], b[i] = mp[b[i]];\n  }\n\n  vector<vector<int>> LR(sz), RL(sz);\n  REP(i, n) {\n    LR[a[i]].emplace_back(b[i]);\n    RL[b[i]].emplace_back(a[i]);\n  }\n\n  { // s1\n    int res = 0;\n    vector<int> L;\n    REP(i, n) L.emplace_back(a[i]);\n    sort(ALL(L));\n    int sum = 0;\n    REP(i, sz) {\n      for(int l : RL[i]) --sum;\n      for(int r : LR[i]) {\n        int cnt = std::lower_bound(ALL(L), r) - L.begin() - i;\n        CHMAX(res, cnt + sum);\n      }\n      ++sum;\n    }\n\n    cout << res << \" \";\n  }\n\n  { // s2\n    int res = 0;\n    int cnt = 0;\n    REP(i, sz) {\n      for(int l : RL[i]) --cnt;\n      for(int r : LR[i]) ++cnt;\n      CHMAX(res, cnt);\n    }\n    cout << res << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nint from[200000];\nint to[200000];\nint adj[200000];\n\nint Solve1() {\n  memset(adj, 0, sizeof(adj));\n  for (int i = 0; i < N; ++i) {\n    for (int j = i+1; j < N; ++j) {\n      if (from[i] < to[j] && from[j] < to[i]) {\n\t++adj[i];\n\t++adj[j];\n      }\n    }\n  }\n  return *max_element(adj, adj+N) + 1;\n}\n\nint Solve2() {\n  multiset<pair<int, int>> all;\n  for (int i = 0; i < N; ++i) {\n    all.emplace(from[i], 1);\n    all.emplace(to[i], -1);\n  }\n  int cnt = 0;\n  int ans = 0;\n  for (auto kv : all) {\n    cnt += kv.second;\n    ans = max(ans, cnt);\n  }\n  return ans;\n}\n\nint main() {\n  while (cin >> N) {\n    for (int i = 0; i < N; ++i) {\n      cin >> from[i] >> to[i];\n    }\n    cout << Solve1() << \" \" << Solve2() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\nconst int maxn = 2e5+5;\ntypedef long long ll;\nint n;\nstruct Tree{\n    int f[maxn << 2],lazy[maxn << 2];\n    void pushup(int rt){\n        f[rt] = max(f[rt << 1],f[rt << 1|1]);\n    }\n    void pushdown(int rt,int l,int r){\n        if(lazy[rt]){\n            lazy[rt << 1]+=lazy[rt];\n            lazy[rt << 1|1]+=lazy[rt];\n            int mid = (l+r)>>1;\n            f[rt << 1]+=lazy[rt];\n            f[rt << 1|1]+=lazy[rt];\n            lazy[rt]=0;\n        }\n    }\n    void build(int rt,int l,int r){\n        lazy[rt]=0;\n        f[rt]=0;\n        if(l==r){\n            return;\n        }\n        int mid = (l+r) >> 1;\n        build(rt << 1,l,mid);\n        build(rt << 1|1,mid+1,r);\n        pushup(rt);\n    }\n\n    void update(int rt,int rp,int rq,int l,int r,int val){\n        if(rp<=l && rq>=r){\n            f[rt]+=val;\n            lazy[rt]+=val;\n            return;\n        }\n        pushdown(rt,l,r);\n        int mid = (l+r) >> 1;\n        if(rp <=mid) update(rt << 1,rp,rq,l,mid,val);\n        if(rq >mid) update(rt << 1|1,rp,rq,mid+1,r,val);\n        pushup(rt);\n    }\n\n    int query(int rt,int rp,int rq,int l,int r){\n        if(rp <=l && rq>=r){\n            return f[rt];\n        }\n        pushdown(rt,l,r);\n        int mid = (l+r) >> 1;\n        int ans =0;\n        if(rp <= mid){\n            ans = max(ans,query(rt << 1,rp,rq,l,mid));\n        }\n        if(rq > mid){\n            ans = max(ans,query(rt << 1|1,rp,rq,mid+1,r));\n        }\n        return ans;\n    }\n}T[2];\n\nstruct edge{\n    int x,y;\n    bool operator <(const edge &e)const{\n        return x < e.x || ( x==e.x && y<e.y);\n    }\n}e[maxn];\nint main(){\n    //freopen(\"out.txt\",\"w\",stdout);\n   while(~scanf(\"%d\",&n)){\n       for(int i=1;i<=n;i++){\n           scanf(\"%d%d\",&e[i].x,&e[i].y);\n\n       }\n       sort(e+1,e+1+n);\n       T[0].build(1,1,n);\n       T[1].build(1,1,1e5);\n        for(int i=1;i<=n-1;i++){\n            int x = e[i].x,y= e[i].y;\n            T[1].update(1,x,y-1,1,1e5,1);\n\n            int l = i+1,r=n+1,mid;\n            while(l < r){\n                mid = (l+r) >> 1;\n                if(e[mid].x < y) l=mid+1;\n                else r = mid;\n            }\n            //cout << \"l: \" << l << endl;\n            T[0].update(1,i,i,1,n,(l-1-i+1));\n            T[0].update(1,i+1,l-1,1,n,1);\n        }\n//        for(int i=1;i<=1000;i++){\n//            cout << T[1].query(1,i,i,1,1e5) << endl;\n//        }\n        int ans1 = T[0].query(1,1,n,1,n),\n            ans2 = T[1].query(1,1,1e5,1,1e5);\n\n        printf(\"%d %d\\n\",ans1,ans2);\n   }\n   //system(\"pause\");\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint memo[201000];\n\nint main()\n{\n\tint n;cin >> n;\n\tvector<pair<pair<int,int>,int> > v;\n\tREP(i,n)\n\t{\n\t\tint a,b;cin >> a >> b;\n\t\tv.PB(MP(MP(a,i),1));\n\t\tv.PB(MP(MP(b,i),0));\n\t}\n\t\n\tsort(ALL(v));\n\t\n\tll ans1 = 0,ans2 = 0,imos = 0;\n\tll inin = 0,ouou = 0;\n\t\n\tREP(i,v.size())\n\t{\n\t\tvector<pair<pair<int,int>,int> > now;\n\t\tauto tmp = v[i];\n\t\tnow.PB(tmp);\n\t\twhile(i+1 != v.size()&&tmp.FI == v[i+1].FI)\n\t\t{\n\t\t\tauto tmtm = v[i+1];\n\t\t\tnow.PB(tmtm);\n\t\t\ti++;\n\t\t}\n\t\tint nige = 0;\n\t\tREP(j,now.size())\n\t\t{\n\t\t\tif(now[j].SE == 1)\n\t\t\t{\n\t\t\t\tnige++;\n\t\t\t\timos++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\touou++;\n\t\t\t\timos--;\n\t\t\t}\n\t\t}\n\t\tans1 = max(ans1,imos);\n\t\t\n\t\tREP(j,now.size())\n\t\t{\n\t\t\tint num = now[j].FI.SE;\n\t\t\tif(now[j].SE == 1)\n\t\t\t{\n\t\t\t\tmemo[num] = ouou;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tll tmtm = inin - memo[num];\n\t\t\t\tans2 = max(ans2,tmtm);\n\t\t\t}\n\t\t}\n\t\tinin += nige;\n\t}\n\t\n\tcout << ans2 << \" \"\t<< ans1 << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint memo[201000];\n\nint main()\n{\n\tint n;cin >> n;\n\tvector<pair<pair<int,int>,int> > v;\n\tREP(i,n)\n\t{\n\t\tint a,b;cin >> a >> b;\n\t\tv.PB(MP(MP(a,i),1));\n\t\tv.PB(MP(MP(b,i),0));\n\t}\n\t\n\tsort(ALL(v));\n\t\n\tll ans1 = 0,ans2 = 0,imos = 0;\n\tll inin = 0,ouou = 0;\n\t\n\tREP(i,v.size())\n\t{\n\t\tvector<pair<pair<int,int>,int> > now;\n\t\tauto tmp = v[i];\n\t\tnow.PB(tmp);\n\t\twhile(i+1 != v.size()&&tmp.FI == v[i+1].FI)\n\t\t{\n\t\t\tauto tmtm = v[i+1];\n\t\t\tnow.PB(tmtm);\n\t\t\ti++;\n\t\t}\n\t\tint nige = 0;\n\t\tREP(j,now.size())\n\t\t{\n\t\t\tif(now[j].SE == 1)\n\t\t\t{\n\t\t\t\tnige++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\touou++;\n\t\t\t\timos--;\n\t\t\t}\n\t\t}\n\t\tans1 = max(ans1,imos);\n\t\t\n\t\tREP(j,now.size())\n\t\t{\n\t\t\tint num = now[j].FI.SE;\n\t\t\tif(now[j].SE == 1)\n\t\t\t{\n\t\t\t\tmemo[num] = ouou;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tll tmtm = inin - memo[num];\n\t\t\t\tans2 = max(ans2,tmtm);\n\t\t\t}\n\t\t}\n\t\tinin += nige;\n\t\timos += nige;\n\t\tans1 = max(ans1,imos);\n\n\t}\n\t\n\tcout << ans2 << \" \"\t<< ans1 << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <cstring>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <utility>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long int LLI;\ntypedef pair<int,int> PII;\n\n#define _ ios_base::sync_with_stdio(0);\n#define debug\n#define x first\n#define y second\n#define MXN 200005\n\nconst int inf = 0x3f3f3f3f;\nconst int mod = 1e9+7;\nconst double eps = 1e-8; \n\nvector<PII> v;\nint cnt[MXN], res[2], n;\nint a[MXN], b[MXN];\nint after[MXN], before[MXN];\nbool used[MXN];\n\n\nint main() { _\n    while (cin >> n) {\n        memset(cnt, 0, sizeof(cnt));\n        memset(used, 0, sizeof(used));\n        memset(after, 0, sizeof(after));\n        memset(before, 0, sizeof(before));\n        for (int i = 1; i <= n; ++i) {\n            cin >> a[i] >> b[i];\n            v.push_back({a[i], i});\n            v.push_back({b[i], -i});\n            cnt[a[i]]++;\n            cnt[b[i]]--;\n        }\n        int cur = 0, tmp = n;\n        res[0] = res[1] = 0;\n        for (int i = 1; i <= 1e5; ++i) {\n            cur += cnt[i];\n            res[1] = max(res[1], cur);\n        }\n        sort(v.begin(), v.end());\n        cur = 0;\n        for (int i = 0; i < v.size(); ++i) {\n            if (v[i].y < 0) {\n                after[-v[i].y] = tmp;\n                ++cur;\n            } else {\n                before[v[i].y] = cur;\n                --tmp;\n            }\n        }\n        for (int i = 1; i <= n; ++i)\n            res[0] = max(res[0], n-after[i]-before[i]);\n        cout << res[0] << \" \" << res[1] << \"\\n\";\n        v.clear();\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n, T = 100001;\nstruct point {\n\tint b, e;\n}w[201000];\nint S1[201000], S2[201000], S[201000], R1, R2;\nint main() {\n\tint i;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d%d\", &w[i].b, &w[i].e);\n\t\tS[w[i].b]++, S[w[i].e]--;\n\t\tS1[w[i].b]++;\n\t\tS2[w[i].e]++;\n\t}\n\tfor (i = 1; i <= T; i++) {\n\t\tS[i] += S[i - 1];\n\t\tS1[i] += S1[i - 1];\n\t\tS2[i] += S2[i - 1];\n\t\tR2 = max(R2, S[i]);\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tR1 = max(R1, n - (n - S1[w[i].e - 1]) - S2[w[i].b]);\n\t}\n\tprintf(\"%d %d\\n\", R1, R2);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\n\n\n/*\n 1-index\n\n add : x に valを加算\n sum : [1,x] の総和を出力\n */\nstruct BIT {\n    ll N;\n    vector<ll> bit;\n    BIT(ll N):N(N) {\n        /* BITは[1..N]で扱う */\n        bit.resize(N + 1, 0);\n    }\n    \n    void add(int x, ll val){\n        while (x <= N) {\n            bit[x] += val;\n            x += x & -x;\n        }\n    }\n    \n    ll sum(int x){\n        if(x == 0) return 0;\n        ll ret = 0;\n        while (x) {\n            ret += bit[x];\n            x &= (x - 1);\n        }\n        return (ret);\n    }\n};\n\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    ll ans1 = 0,ans2 = 0;\n    int n; cin >> n;\n    vector<int> a(n),b(n);\n    for(int i = 0; i < n;i++) cin >> a[i] >> b[i];\n    \n    // Policy 1 ==== BEGIN ====\n    BIT l(100001),r(100001);\n    for(int i = 0; i < n;i++){\n        l.add(b[i],1);\n        r.add(a[i],1);\n    }\n    for(int i = 0; i < n;i++){\n        ans1 = max(ans1,(ll)n - l.sum(a[i]) - (r.sum(100000) - r.sum(b[i]-1)));\n    }\n    // Policy 1 ====  END  ====\n    // Policy 2 ==== BEGIN ====\n    vector<ll> imos(100001);\n    for(int i = 0; i < n;i++){\n        imos[a[i]]++; imos[b[i]]--;\n    }\n    for(int i = 1; i <= 100000;i++){\n        imos[i] += imos[i-1];\n    }\n    ans2 = *max_element(imos.begin(), imos.end());\n    // Policy 2 ====  END  ====\n\n    cout << ans1 << \" \" << ans2 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    int a[n], b[n];\n    int sum[MAX], sum_a[MAX], sum_b[MAX];\n    memset(sum, 0, sizeof(sum));\n    memset(sum_a, 0, sizeof(sum_a));\n    memset(sum_b, 0, sizeof(sum_b));\n    rep(i, n){\n        scanf(\"%d%d\", &a[i], &b[i]);\n        ++sum[a[i]]; --sum[b[i]];\n        ++sum_a[a[i]];\n        ++sum_b[b[i]];\n    }\n    partial_sum(sum, sum+MAX, sum);\n    rrep(i, MAX-1) sum_a[i] += sum_a[i+1];\n    partial_sum(sum_b, sum_b+MAX, sum_b);\n    int M = 0, m = 0;\n    rep(i, n){\n        chmax(M, n - sum_a[b[i]] - sum_b[a[i]]);\n        chmax(m, sum[a[i]]);\n    }\n    printf(\"%d %d\\n\", M, m);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\ntypedef long long LL;\n\nstruct point\n{\n\tint l,r;\n}a[200005];\nint l[200005],r[200005],ans[200005];\nint N,i,n,sum_1,sum_2;\nint main()\n{\n\tcin>>n;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i].l>>a[i].r;\n\t\tl[a[i].l]++;\n\t\tr[a[i].r]++;\n\t\tans[a[i].l]++;\n\t\tans[a[i].r]--;\n\t\tN=max(a[i].r,N);\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tl[i]+=l[i-1];\n\t\tr[i]+=r[i-1];\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tsum_1 =max(sum_1, l[a[i].r-1] -r[a[i].l]);\n\tfor(i=1;i<=N;i++)\n\t{\n\t\tans[i]+=ans[i-1];\n\t\tsum_2 = max(sum_2,ans[i]);\n\t}\n\tcout<<sum_1<<\" \"<<sum_2<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\nstruct po\n{\n\tint x;\n\tint y;\n}a[100005];\n\nint head[100005], tail[100005];\nint num[100005];\nint n;\nint main()\n{\n\tscanf(\"%d \",&n);\n\tfor(int i = 1;i <= n;i++)\n\t{\n\t\tscanf(\"%d %d\",&a[i].x ,&a[i].y);\n\t\tnum[a[i].x]++;\n\t\tnum[a[i].y]--;\n\t\thead[a[i].x + 1]++;\n\t\ttail[a[i].y]++;\n\t}\n\tint now = 0, Max = 0;\n\tfor(int i = 1;i <= 100000;i++)\n\t{\n\t\tnow += num[i];\n\t\tMax = max(now, Max);\n\t}\n\tfor(int i = 2;i <= 100000;i++)\n\t{\n\t\thead[i] += head[i-1];\n\t\ttail[i] += tail[i-1];\n\t}\n\tint m = 0;\n\tfor(int i = 1;i <= n;i++)\n\t{\n\t\tm = max(m, head[a[i].y] - tail[a[i].x]);\n\t}\n\tprintf(\"%d %d\\n\",m ,Max);\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1386 Starting a Scenic Railroad Service\n// 2018.2.6 bal4u\n\n#include <stdio.h>\n\nint a[200002], b[200002];\nint imos[200002], imos1[200002], imos2[200002];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint n, i, s1, s2, t, max;\n\n\tn = in();\n\tmax = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tint _a, _b;\n\t\ta[i] = _a = in(), b[i] = _b = in();\n\t\tif (_b > max) max = _b;\n\t\timos [_a]++, imos [_b]--;\n\t\timos1[_a]++, imos2[_b]++;\n\t}\n\n\ts1 = s2 = 0;\n    for (i = 1; i <= max; i++) {\n        imos [i] += imos [i-1];\n\t\tif (imos[i] > s2) s2 = imos[i];\n        imos1[i] += imos1[i-1];\n        imos2[i] += imos2[i-1];\n    }\n    for (i = 0; i < n; i++) {\n\t\tt = imos1[b[i]-1] - imos2[a[i]];\n\t\tif (t > s1) s1 = t;\n    }\n    printf(\"%d %d\\n\", s1, s2);\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\nclass Main {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        int n=sc.nextInt();\n        int[]a=new int[n],b=new int[n];\n        //policy-2\n        int[]p2=new int[2*n];\n        for(int i=0;i<n;++i){\n            a[i]=sc.nextInt();\n            b[i]=sc.nextInt();\n            p2[2*i]=2*a[i]+1;\n            p2[2*i+1]=2*b[i];\n        }\n        //policy-2\n        Arrays.sort(p2);\n        int ans2=0;\n        int c=0;\n        for(int i=0;i<2*n;++i){\n            if(p2[i]%2==0)\n                c--;\n            else\n                c++;\n            ans2=Math.max(ans2,c);\n        }\n        //policy-1\n        int ans1=0;\n        PlusSegmentTree segL=new PlusSegmentTree();\n        PlusSegmentTree segR=new PlusSegmentTree();\n        for(int i=0;i<n;++i){\n            int u=(int)segL.query(1,b[i]);\n            u-=(int)segR.query(1,a[i]+1);\n            ans1=Math.max(ans1,u+1);\n            segL.update(a[i],segL.query(a[i],a[i]+1)+1);\n            segR.update(b[i],segR.query(b[i],b[i]+1)+1);\n        }\n        if(ans1<ans2)throw new Error();\n        out.println(ans1+\" \"+ans2);\n        out.close();\n    }\n    // http://codeforces.com/blog/entry/7018\n    //-----------PrintWriter for faster output---------------------------------\n    public static PrintWriter out;\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine(){\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\nclass PlusSegmentTree {\n    static final int SIZE = 1 << 18;\n    long[] seg;\n    PlusSegmentTree() {\n\tthis.seg = new long[2 * SIZE];\n    }\n    void update(int x, long value) {\n\tx += SIZE - 1;\n\tthis.seg[x] = value;\n\twhile (x > 0) {\n\t    x = (x - 1) / 2;\n\t    this.seg[x] = this.seg[2 * x + 1] + this.seg[2 * x + 2];\n\t}\n    }\n    long query(int l, int r) {\n\tl += SIZE - 1;\n\tr += SIZE - 1;\n        long y = 0;\n\twhile (l < r) {\n\t    if ((l & 1) == 0) {\n\t\ty = y + this.seg[l];\n\t    }\n\t    if ((r & 1) == 0) {\n\t\ty = y + this.seg[r - 1];\n\t    }\n\t    l /= 2;\n\t    r = (r - 1) / 2;\n\t}\n\treturn y;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\nclass Main {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        int n=sc.nextInt();\n        int[]a=new int[n],b=new int[n];\n        //policy-2\n        int[]p2=new int[2*n];\n        for(int i=0;i<n;++i){\n            a[i]=sc.nextInt();\n            b[i]=sc.nextInt();\n            p2[2*i]=2*a[i]+1;\n            p2[2*i+1]=2*b[i];\n        }\n        //policy-2\n        Arrays.sort(p2);\n        int ans2=0;\n        int c=0;\n        for(int i=0;i<2*n;++i){\n            if(p2[i]%2==0)\n                c--;\n            else\n                c++;\n            ans2=Math.max(ans2,c);\n        }\n        //policy-1\n        int ans1=0;\n        PlusSegmentTree segL=new PlusSegmentTree();\n        PlusSegmentTree segR=new PlusSegmentTree();\n        for(int i=0;i<n;++i){\n            int u=(int)segL.query(0,b[i]+1);\n            u-=(int)segR.query(0,a[i]+1);\n            ans1=Math.max(ans1,u+1);\n            segL.update(a[i],segL.query(a[i],a[i]+1)+1);\n            segR.update(b[i],segR.query(b[i],b[i]+1)+1);\n        }\n        out.println(ans1+\" \"+ans2);\n        out.close();\n    }\n    // http://codeforces.com/blog/entry/7018\n    //-----------PrintWriter for faster output---------------------------------\n    public static PrintWriter out;\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine(){\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\nclass PlusSegmentTree {\n    static final int SIZE = 1 << 18;\n    long[] seg;\n    PlusSegmentTree() {\n\tthis.seg = new long[2 * SIZE];\n    }\n    void update(int x, long value) {\n\tx += SIZE - 1;\n\tthis.seg[x] = value;\n\twhile (x > 0) {\n\t    x = (x - 1) / 2;\n\t    this.seg[x] = this.seg[2 * x + 1] + this.seg[2 * x + 2];\n\t}\n    }\n    long query(int l, int r) {\n\tl += SIZE - 1;\n\tr += SIZE - 1;\n        long y = 0;\n\twhile (l < r) {\n\t    if ((l & 1) == 0) {\n\t\ty = y + this.seg[l];\n\t    }\n\t    if ((r & 1) == 0) {\n\t\ty = y + this.seg[r - 1];\n\t    }\n\t    l /= 2;\n\t    r = (r - 1) / 2;\n\t}\n\treturn y;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\nclass Main {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        int n=sc.nextInt();\n        int[]a=new int[n],b=new int[n];\n        //policy-2\n        int[]p2=new int[2*n];\n        for(int i=0;i<n;++i){\n            a[i]=sc.nextInt();\n            b[i]=sc.nextInt();\n            p2[2*i]=2*a[i]+1;\n            p2[2*i+1]=2*b[i];\n        }\n        //policy-2\n        Arrays.sort(p2);\n        int ans2=0;\n        int c=0;\n        for(int i=0;i<2*n;++i){\n            if(p2[i]%2==0)\n                c--;\n            else\n                c++;\n            ans2=Math.max(ans2,c);\n        }\n        //policy-1\n        int ans1=0;\n        PlusSegmentTree segL=new PlusSegmentTree();\n        PlusSegmentTree segR=new PlusSegmentTree();\n        for(int i=0;i<n;++i){\n            int u=(int)segL.query(0,b[i]);\n            u-=(int)segR.query(0,a[i]+1);\n            ans1=Math.max(ans1,u+1);\n            segL.update(a[i],segL.query(a[i],a[i]+1)+1);\n            segR.update(b[i],segR.query(b[i],b[i]+1)+1);\n        }\n        out.println(ans1+\" \"+ans2);\n        out.close();\n    }\n    // http://codeforces.com/blog/entry/7018\n    //-----------PrintWriter for faster output---------------------------------\n    public static PrintWriter out;\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine(){\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\nclass PlusSegmentTree {\n    static final int SIZE = 1 << 18;\n    long[] seg;\n    PlusSegmentTree() {\n\tthis.seg = new long[2 * SIZE];\n    }\n    void update(int x, long value) {\n\tx += SIZE - 1;\n\tthis.seg[x] = value;\n\twhile (x > 0) {\n\t    x = (x - 1) / 2;\n\t    this.seg[x] = this.seg[2 * x + 1] + this.seg[2 * x + 2];\n\t}\n    }\n    long query(int l, int r) {\n\tl += SIZE - 1;\n\tr += SIZE - 1;\n        long y = 0;\n\twhile (l < r) {\n\t    if ((l & 1) == 0) {\n\t\ty = y + this.seg[l];\n\t    }\n\t    if ((r & 1) == 0) {\n\t\ty = y + this.seg[r - 1];\n\t    }\n\t    l /= 2;\n\t    r = (r - 1) / 2;\n\t}\n\treturn y;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\n\npublic class I{\n    public static final int MP = 200010; //MaxPassengers\n    public static final int MSN = 100010; //MaxStationNumber\n    public static class p{\n        int bp; //boarding point\n        int dp; //deplaning\n    }\n    public static void main(String[] args){\n        int P1 = 0, P2 = 0;\n        p[] pas = new p[MP]; //passenger\n        int[] igo = new int[MSN]; //is getting on\n        int[] agon = new int[MSN]; //already getting on\n        int[] agoff= new int[MSN]; //already getting off \n        Scanner sc = new Scanner(System.in);\n        int n = Integer.parseInt(sc.next());\n        for(int i = 0; i < n; i++){\n            pas[i] = new p(); \n            pas[i].bp = Integer.parseInt(sc.next());\n            pas[i].dp = Integer.parseInt(sc.next());\n            igo[pas[i].bp]++;\n            igo[pas[i].dp]--;\n            agon[pas[i].bp]++;\n            agoff[pas[i].dp]++;\n        }\n        for(int j = 1; j < MSN; j++){ //make Accumulation\n            igo[j] += igo[j-1];\n            agon[j] += agon[j-1];\n            agoff[j] += agoff[j-1];\n            if(P2 < igo[j]){ //Policy 2\n                P2 = igo[j];\n            }\n        }\n        for(int k = 1; k < n; k++){\n            //i番目の人が降りる一つ前までの駅までに乗ってきた人数-i番目の人が乗る駅で降りている人数\n            if(P1 < (agon[pas[k].dp - 1] - agoff[pas[k].bp])){ \n                P1 = agon[pas[k].dp - 1] - agoff[pas[k].bp];\n            }\n        }\n        System.out.println(P1 + \" \" + P2);\n        sc.close();   \n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\n\npublic class Main{\n    public static final int MP = 200010; //MaxPassengers\n    public static final int MSN = 100010; //MaxStationNumber\n    public static class p{\n        int bp; //boarding point\n        int dp; //deplaning\n    }\n    public static void main(String[] args){\n        int P1 = 0, P2 = 0;\n        p[] pas = new p[MP]; //passenger\n        int[] igo = new int[MSN]; //is getting on\n        int[] agon = new int[MSN]; //already getting on\n        int[] agoff= new int[MSN]; //already getting off \n        Scanner sc = new Scanner(System.in);\n        int n = Integer.parseInt(sc.next());\n        for(int i = 0; i < n; i++){\n            pas[i] = new p(); \n            pas[i].bp = Integer.parseInt(sc.next());\n            pas[i].dp = Integer.parseInt(sc.next());\n            igo[pas[i].bp]++;\n            igo[pas[i].dp]--;\n            agon[pas[i].bp]++;\n            agoff[pas[i].dp]++;\n        }\n        for(int j = 1; j < MSN; j++){ //make Accumulation\n            igo[j] += igo[j-1];\n            agon[j] += agon[j-1];\n            agoff[j] += agoff[j-1];\n            if(P2 < igo[j]){ //Policy 2\n                P2 = igo[j];\n            }\n        }\n        for(int k = 1; k < n; k++){\n            //i番目の人が降りる一つ前までの駅までに乗ってきた人数-i番目の人が乗る駅で降りている人数\n            if(P1 < (agon[pas[k].dp - 1] - agoff[pas[k].bp])){ \n                P1 = agon[pas[k].dp - 1] - agoff[pas[k].bp];\n            }\n        }\n        System.out.println(P1 + \" \" + P2);\n        sc.close();   \n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\n\npublic class I{\n    public static final int MP = 200010; //MaxPassengers\n    public static final int MSN = 100010; //MaxStationNumber\n    public static class p{\n        int bp; //boarding point\n        int dp; //deplaning\n    }\n    public static void main(String[] args){\n        int P1 = 0, P2 = 0;\n        p[] pas = new p[MP]; //passenger\n        int[] igo = new int[MSN]; //is getting on\n        int[] agon = new int[MSN]; //already getting on\n        int[] agoff= new int[MSN]; //already getting off \n        Scanner sc = new Scanner(System.in);\n        int n = Integer.parseInt(sc.next());\n        for(int i = 0; i < n; i++){\n            pas[i] = new p(); \n            pas[i].bp = Integer.parseInt(sc.next());\n            pas[i].dp = Integer.parseInt(sc.next());\n            igo[pas[i].bp]++;\n            igo[pas[i].dp]--;\n            agon[pas[i].bp]++;\n            agoff[pas[i].dp]++;\n        }\n        for(int j = 1; j < MSN; j++){ //make Accumulation\n            igo[j] += igo[j-1];\n            agon[j] += agon[j-1];\n            agoff[j] += agoff[j-1];\n            if(P2 < igo[j]){ //Policy 2\n                P2 = igo[j];\n            }\n        }\n        for(int k = 1; k < n; k++){\n            //i番目の人が降りる一つ前までの駅までに乗ってきた人数-i番目の人が乗る駅で降りている人数\n            if(P1 < (agon[pas[k].dp - 1] - agoff[pas[k].bp])){ \n                P1 = agon[pas[k].dp - 1] - agoff[pas[k].bp];\n            }\n        }\n        System.out.println(P1 + \" \" + P2);\n        sc.close();   \n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\n\npublic class Main{\n    public static final int MP = 200010; //MaxPassengers\n    public static final int MSN = 100010; //MaxStationNumber\n    public static class p{\n        int bp; //boarding point\n        int dp; //deplaning\n    }\n    public static void main(String[] args){\n        int P1 = 0, P2 = 0;\n        p[] pas = new p[MP]; //passenger\n        int[] igo = new int[MSN]; //is getting on\n        int[] agon = new int[MSN]; //already getting on\n        int[] agoff= new int[MSN]; //already getting off \n        Scanner sc = new Scanner(System.in);\n        int n = Integer.parseInt(sc.next());\n        for(int i = 0; i < n; i++){\n            pas[i] = new p(); \n            pas[i].bp = Integer.parseInt(sc.next());\n            pas[i].dp = Integer.parseInt(sc.next());\n            igo[pas[i].bp]++;\n            igo[pas[i].dp]--;\n            agon[pas[i].bp]++;\n            agoff[pas[i].dp]++;\n        }\n        for(int j = 1; j < MSN; j++){ //make Accumulation\n            igo[j] += igo[j-1];\n            agon[j] += agon[j-1];\n            agoff[j] += agoff[j-1];\n            if(P2 < igo[j]){ //Policy 2\n                P2 = igo[j];\n            }\n        }\n        for(int k = 0; k < n; k++){\n            //i番目の人が降りる一つ前までの駅までに乗ってきた人数-i番目の人が乗る駅で降りている人数\n            if(P1 < (agon[pas[k].dp - 1] - agoff[pas[k].bp])){ \n                P1 = agon[pas[k].dp - 1] - agoff[pas[k].bp];\n            }\n        }\n        System.out.println(P1 + \" \" + P2);\n        sc.close();   \n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\nclass Main {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        int n=sc.nextInt();\n        int[]a=new int[n],b=new int[n];\n        //policy-2\n        int[]p2=new int[2*n];\n        for(int i=0;i<n;++i){\n            a[i]=sc.nextInt();\n            b[i]=sc.nextInt();\n            p2[2*i]=2*a[i]+1;\n            p2[2*i+1]=2*b[i];\n        }\n        //policy-2\n        Arrays.sort(p2);\n        int ans2=0;\n        int c=0;\n        for(int i=0;i<2*n;++i){\n            if(p2[i]%2==0)\n                c--;\n            else\n                c++;\n            ans2=Math.max(ans2,c);\n        }\n        //policy-1\n        int ans1=0;\n        PlusSegmentTree segL=new PlusSegmentTree();\n        PlusSegmentTree segR=new PlusSegmentTree();\n        for(int i=0;i<n;++i){\n            segL.update(a[i],segL.query(a[i],a[i]+1)+1);\n            segR.update(b[i],segR.query(b[i],b[i]+1)+1);\n        }\n        for(int i=0;i<n;++i){\n            int u=(int)segL.query(1,b[i]);\n            u-=(int)segR.query(1,a[i]+1);\n            ans1=Math.max(ans1,u);\n        }\n        if(ans1<ans2)throw new Error();\n        out.println(ans1+\" \"+ans2);\n        out.close();\n    }\n    // http://codeforces.com/blog/entry/7018\n    //-----------PrintWriter for faster output---------------------------------\n    public static PrintWriter out;\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine(){\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\nclass PlusSegmentTree {\n    static final int SIZE = 1 << 18;\n    long[] seg;\n    PlusSegmentTree() {\n\tthis.seg = new long[2 * SIZE];\n    }\n    void update(int x, long value) {\n\tx += SIZE - 1;\n\tthis.seg[x] = value;\n\twhile (x > 0) {\n\t    x = (x - 1) / 2;\n\t    this.seg[x] = this.seg[2 * x + 1] + this.seg[2 * x + 2];\n\t}\n    }\n    long query(int l, int r) {\n\tl += SIZE - 1;\n\tr += SIZE - 1;\n        long y = 0;\n\twhile (l < r) {\n\t    if ((l & 1) == 0) {\n\t\ty = y + this.seg[l];\n\t    }\n\t    if ((r & 1) == 0) {\n\t\ty = y + this.seg[r - 1];\n\t    }\n\t    l /= 2;\n\t    r = (r - 1) / 2;\n\t}\n\treturn y;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\nclass Main {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        int n=sc.nextInt();\n        int[]a=new int[n],b=new int[n];\n        //policy-2\n        int[]p2=new int[2*n];\n        for(int i=0;i<n;++i){\n            a[i]=sc.nextInt();\n            b[i]=sc.nextInt();\n            p2[2*i]=2*a[i]+1;\n            p2[2*i+1]=2*b[i];\n        }\n        //policy-2\n        Arrays.sort(p2);\n        int ans2=0;\n        int c=0;\n        for(int i=0;i<2*n;++i){\n            if(p2[i]%2==0)\n                c--;\n            else\n                c++;\n            ans2=Math.max(ans2,c);\n        }\n        //policy-1\n        int ans1=0;\n        PlusSegmentTree segL=new PlusSegmentTree();\n        PlusSegmentTree segR=new PlusSegmentTree();\n        for(int i=0;i<n;++i){\n            int u=(int)segL.query(0,b[i]);\n            u-=(int)segR.query(0,a[i]+1);\n            ans1=Math.max(ans1,u+1);\n            segL.update(a[i],segL.query(a[i],a[i]+1)+1);\n            segR.update(b[i],segR.query(b[i],b[i]+1)+1);\n        }\n        if(ans1<ans2)throw new Error();\n        out.println(ans1+\" \"+ans2);\n        out.close();\n    }\n    // http://codeforces.com/blog/entry/7018\n    //-----------PrintWriter for faster output---------------------------------\n    public static PrintWriter out;\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine(){\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\nclass PlusSegmentTree {\n    static final int SIZE = 1 << 18;\n    long[] seg;\n    PlusSegmentTree() {\n\tthis.seg = new long[2 * SIZE];\n    }\n    void update(int x, long value) {\n\tx += SIZE - 1;\n\tthis.seg[x] = value;\n\twhile (x > 0) {\n\t    x = (x - 1) / 2;\n\t    this.seg[x] = this.seg[2 * x + 1] + this.seg[2 * x + 2];\n\t}\n    }\n    long query(int l, int r) {\n\tl += SIZE - 1;\n\tr += SIZE - 1;\n        long y = 0;\n\twhile (l < r) {\n\t    if ((l & 1) == 0) {\n\t\ty = y + this.seg[l];\n\t    }\n\t    if ((r & 1) == 0) {\n\t\ty = y + this.seg[r - 1];\n\t    }\n\t    l /= 2;\n\t    r = (r - 1) / 2;\n\t}\n\treturn y;\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "class Treap\n  def initialize\n    @root = nil\n  end\n\n  def add(x)\n    if @root\n      @root = @root.add(x)\n    else\n      @root = Node.new(x)\n    end\n  end\n\n  def query(x)\n    if @root\n      @root.query(x)\n    else\n      0\n    end\n  end\n\n  class Node\n    def initialize(x)\n      @value = x\n      @priority = rand(0)\n      @left_child = @right_child = nil\n      @count = 1\n    end\n\n    def add(x)\n      @count += 1\n      if x <= @value\n        if @left_child\n          @left_child = @left_child.add(x)\n        else\n          @left_child = Node.new(x)\n        end\n        if @left_child.priority > @priority\n          return rotate_right\n        else\n          return self\n        end\n      else\n        if @right_child\n          @right_child = @right_child.add(x)\n        else\n          @right_child = Node.new(x)\n        end\n        if @right_child.priority > @priority\n          return rotate_left\n        else\n          return self\n        end\n      end\n    end\n\n    def rotate_right\n      v = @left_child\n      @left_child = v.right_child\n      v.right_child = self\n      update\n      v.update\n      return v\n    end\n\n    def rotate_left\n      v = @right_child\n      @right_child = v.left_child\n      v.left_child = self\n      update\n      v.update\n      return v\n    end\n\n    def update\n      @count = (@left_child ? @left_child.count : 0) + 1 + (@right_child ? @right_child.count : 0)\n    end\n\n    def query(x)\n      if x <= @value\n        if @left_child\n          return @left_child.query(x)\n        else\n          return 0\n        end\n      else\n        if @right_child\n          return (@left_child ? @left_child.count : 0) + 1 + @right_child.query(x)\n        else\n          return @count\n        end\n      end\n    end\n\n    attr_accessor :priority, :left_child, :right_child, :count, :max\n  end\nend\n\nn = gets.to_i\nplus_tree = Treap.new\nminus_tree = Treap.new\ntimeline = []\nranges = []\nn.times do\n  l, r = gets.split.map(&:to_i)\n  ranges << [l, r]\n  plus_tree.add(l)\n  minus_tree.add(r)\n  timeline << [l, +1]\n  timeline << [r, -1]\nend\n\npolicy1 = ranges.map {|l, r| plus_tree.query(r) - minus_tree.query(l + 1) }.max\n\ntimeline.sort!\npolicy2 = 0\nk = 0\nuntil timeline.empty?\n  t = timeline[0][0]\n  while !timeline.empty? && timeline[0][0] == t\n    _, diff = timeline.shift\n    k += diff\n  end\n  policy2 = k if k > policy2\nend\n\nputs \"#{policy1} #{policy2}\"\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n    n,k = LI()\n    ans = 0\n    for l in range(1,n+1):\n        for i in range(1000):\n            if i*k > l:break\n            j = l-i*k+i\n            if j%2:\n                j //= 2\n                j += 1\n                s = 1\n                for a in range(i):\n                    s *= j-a\n                    s //= a+1\n                ans += s\n    print(ans)\n    return\n\n#B\ndef B():\n    return\n\n\n#C\ndef C():\n    while 1:\n        n = I()\n        if n == 0:\n            break\n        v = [input().split() for i in range(n)]\n        d = defaultdict(int)\n        f = [[1 for j in range(n)] for i in range(n)]\n        i = 0\n        s = 0\n        while i < n:\n            v[i][1] = int(v[i][1])\n            v[i][2] = int(v[i][2])\n            if v[i][2] == 0:\n                s += v[i][1]\n                v.pop(i)\n                n -= 1\n            else:\n                d[v[i][0]] = i\n                i += 1\n\n        for i in range(n):\n            for j in v[i][3:]:\n                f[i][d[j]] = 0\n        e = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if i == j:continue\n                if f[i][j]:\n                    e[i].append(j)\n        for i in e:\n            print(i)\n        print(ans)\n    return\n\n#D\ndef D():\n    n = I()\n    s = [0 for i in range(100001)]\n    l = LIR(n)\n    l.sort(key = lambda x:x[1])\n    r = [l[i][0] for i in range(n)]\n    r.sort()\n    f = [0 for i in range(100001)]\n    for a,b in l:\n        s[a] += 1\n        s[b] -= 1\n        f[b] += 1\n    for i in range(100000):\n        s[i+1] += s[i]\n        f[i+1] += f[i]\n    ans = 0\n\n    for a,b in l:\n        ri = bisect.bisect_left(r,b)\n        ri = n-ri\n        le = f[a]\n        ans = max(ans,n-(ri+le))\n    print(ans,max(s))\n    return\n\n#E\ndef E():\n    n = I()\n    c = LI()\n    f = [[i,c[i]] for i in range(n)]\n    f.sort(key = lambda x:x[1])\n    v = [[] for i in range(n)]\n    m = I()\n    for i in range(m):\n        a,b = LI()\n        a -= 1\n        b -= 1\n        v[a].append(b)\n        v[b].append(a)\n    q = deque()\n    bfs_map = [1 for i in range(n)]\n    ans = [0 for i in range(n)]\n    for i,j in f:\n        if not bfs_map[i]:continue\n        q.append(i,-1)\n        bfs_map[i] = 0\n        ans[i] = 1\n        while q:\n            x,pre = q.popleft()\n            for y in v[x]:\n                if bfs_map[y]:\n                    if x == 0:\n                        bfs_map[y] = 0\n                        q.append(y)\n    print(sum(ans))\n    return\n\n#F\ndef F():\n    return\n\n#G\ndef G():\n    return\n\n#H\ndef H():\n    return\n\n#I\ndef I_():\n    return\n\n#J\ndef J():\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    D()\n\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nn = int(input())\nP = [list(map(int, input().split())) for i in range(n)]\n\nM = 10**5+1\n\ndef policy1(P):\n    A = [a for a, b in P]\n    B = [b for a, b in P]\n    A.sort(); B.sort()\n    ans = 1\n    for a, b in P:\n        left = bisect(B, a)\n        right = n - bisect(A, b-1)\n        ans = max(ans, n - (left + right))\n    return ans\n\ndef policy2(P):\n    D = [0]*M\n    for a, b in P:\n        D[a] += 1\n        D[b] -= 1\n    for i in range(1, M):\n        D[i] += D[i-1]\n    return max(D)\n\nprint(policy1(P), policy2(P))"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nab = [list(map(int, input().split())) for _ in range(n)]\n\npol1 = 0\npol2 = 0\n\nft = [[0] * 2 for _ in range(100000)] \n\nfor i in ab:\n    ft[i[0] - 1][0] += 1\n    ft[i[1] - 1][1] += 1\n\nftsum = [[0] * 2 for _ in range(100000)]\nftsum[0][0] = ft[0][0]\nfor i in range(1, len(ft)):\n    ftsum[i][0] = ftsum[i-1][0] + ft[i][0]\n    ftsum[i][1] = ftsum[i-1][1] + ft[i][1]\n\nfor i in range(len(ft)-1):\n    pol2 = max(pol2, ftsum[i][0] - ftsum[i][1])\n\nfor f, t in ab:\n    f = f-1\n    t = t-1\n    temp = ftsum[t-1][0]\n    if f != 0:\n        temp -= ftsum[f][1]\n    pol1 = max(pol1, temp)\n\nprint(pol1, pol2)\n    \n\n"
  }
]