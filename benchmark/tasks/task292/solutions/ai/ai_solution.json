[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int start;\n    int end;\n} Segment;\n\nint compare(const void *a, const void *b) {\n    Segment *segA = (Segment *)a;\n    Segment *segB = (Segment *)b;\n    if (segA->end != segB->end) {\n        return segA->end - segB->end;\n    }\n    return segA->start - segB->start;\n}\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint compute_policy1(Segment segments[], int N) {\n    int *count = (int *)calloc(1000002, sizeof(int));\n    int max_seats = 0;\n    \n    for (int i = 0; i < N; i++) {\n        count[segments[i].start]++;\n        count[segments[i].end]--;\n    }\n    \n    int current = 0;\n    for (int i = 1; i <= 1000000; i++) {\n        current += count[i];\n        max_seats = max(max_seats, current);\n    }\n    \n    free(count);\n    return max_seats;\n}\n\nint compute_policy2(Segment segments[], int N) {\n    qsort(segments, N, sizeof(Segment), compare);\n    int seats = 0;\n    int *last_end = (int *)malloc(N * sizeof(int));\n    \n    for (int i = 0; i < N; i++) {\n        int j;\n        for (j = 0; j < seats; j++) {\n            if (segments[i].start >= last_end[j]) {\n                last_end[j] = segments[i].end;\n                break;\n            }\n        }\n        if (j == seats) {\n            last_end[seats] = segments[i].end;\n            seats++;\n        }\n    }\n    \n    free(last_end);\n    return seats;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Segment *segments = (Segment *)malloc(N * sizeof(Segment));\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &segments[i].start, &segments[i].end);\n    }\n    \n    int policy1 = compute_policy1(segments, N);\n    int policy2 = compute_policy2(segments, N);\n    \n    printf(\"%d %d\\n\", policy1, policy2);\n    \n    free(segments);\n    return 0;\n}",
    "timestamp": "2025-08-05 20:56:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\npair<int, int> compute_seats(int N, vector<pair<int, int>>& passengers) {\n    vector<pair<int, int>> events;\n    for (auto& p : passengers) {\n        events.emplace_back(p.first, 1);\n        events.emplace_back(p.second, -1);\n    }\n    sort(events.begin(), events.end());\n    \n    int max_overlap = 0;\n    int current = 0;\n    for (auto& e : events) {\n        current += e.second;\n        max_overlap = max(max_overlap, current);\n    }\n    int policy1 = max_overlap;\n    \n    map<int, int> timeline;\n    for (auto& p : passengers) {\n        timeline[p.first]++;\n        timeline[p.second]--;\n    }\n    \n    int policy2 = 0;\n    current = 0;\n    for (auto& t : timeline) {\n        current += t.second;\n        policy2 = max(policy2, current);\n    }\n    \n    return {policy1, policy2};\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<pair<int, int>> passengers(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> passengers[i].first >> passengers[i].second;\n    }\n    auto result = compute_seats(N, passengers);\n    cout << result.first << \" \" << result.second << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 20:57:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ScenicRailroad {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[][] passengers = new int[n][2];\n        \n        for (int i = 0; i < n; i++) {\n            passengers[i][0] = scanner.nextInt();\n            passengers[i][1] = scanner.nextInt();\n        }\n        \n        int policy1 = calculatePolicy1(passengers);\n        int policy2 = calculatePolicy2(passengers);\n        \n        System.out.println(policy1 + \" \" + policy2);\n    }\n    \n    private static int calculatePolicy1(int[][] passengers) {\n        List<int[]> intervals = new ArrayList<>();\n        for (int[] p : passengers) {\n            intervals.add(new int[]{p[0], p[1]});\n        }\n        \n        intervals.sort((a, b) -> a[0] - b[0]);\n        \n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n        int seats = 0;\n        \n        for (int[] interval : intervals) {\n            int start = interval[0];\n            int end = interval[1];\n            \n            while (!minHeap.isEmpty() && minHeap.peek() <= start) {\n                minHeap.poll();\n            }\n            \n            minHeap.offer(end);\n            seats = Math.max(seats, minHeap.size());\n        }\n        \n        return seats;\n    }\n    \n    private static int calculatePolicy2(int[][] passengers) {\n        List<Integer> starts = new ArrayList<>();\n        List<Integer> ends = new ArrayList<>();\n        \n        for (int[] p : passengers) {\n            starts.add(p[0]);\n            ends.add(p[1]);\n        }\n        \n        Collections.sort(starts);\n        Collections.sort(ends);\n        \n        int i = 0, j = 0, current = 0, max = 0;\n        \n        while (i < starts.size() && j < ends.size()) {\n            if (starts.get(i) < ends.get(j)) {\n                current++;\n                i++;\n                max = Math.max(max, current);\n            } else {\n                current--;\n                j++;\n            }\n        }\n        \n        return max;\n    }\n}",
    "timestamp": "2025-08-05 20:57:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ScenicRailroad {\n    public static int[] calculateSeats(int[][] reservations) {\n        // Sort reservations by start section\n        Arrays.sort(reservations, (a, b) -> a[0] - b[0]);\n\n        // Policy 1: Assign seats dynamically\n        int seatsPolicy1 = calculateSeatsPolicy1(reservations);\n\n        // Policy 2: Assign seats after all reservations\n        int seatsPolicy2 = calculateSeatsPolicy2(reservations);\n\n        return new int[]{seatsPolicy1, seatsPolicy2};\n    }\n\n    private static int calculateSeatsPolicy1(int[][] reservations) {\n        int maxSeats = 0;\n        int[] currentSeats = new int[10001];\n\n        for (int[] reservation : reservations) {\n            int start = reservation[0];\n            int end = reservation[1];\n            int seatFound = -1;\n\n            for (int i = 0; i < maxSeats; i++) {\n                if (currentSeats[i] <= start) {\n                    seatFound = i;\n                    break;\n                }\n            }\n\n            if (seatFound == -1) {\n                seatFound = maxSeats++;\n            }\n\n            currentSeats[seatFound] = end;\n        }\n\n        return maxSeats;\n    }\n\n    private static int calculateSeatsPolicy2(int[][] reservations) {\n        int[] sections = new int[10001];\n\n        for (int[] reservation : reservations) {\n            sections[reservation[0]]++;\n            sections[reservation[1]]--;\n        }\n\n        int currentPassengers = 0;\n        int maxPassengers = 0;\n\n        for (int passengers : sections) {\n            currentPassengers += passengers;\n            maxPassengers = Math.max(maxPassengers, currentPassengers);\n        }\n\n        return maxPassengers;\n    }\n\n    public static void main(String[] args) {\n        int[][] reservations = {{1, 4}, {2, 5}, {3, 6}, {4, 7}};\n        int[] result = calculateSeats(reservations);\n        System.out.println(\"Policy 1 Seats: \" + result[0]);\n        System.out.println(\"Policy 2 Seats: \" + result[1]);\n    }\n}",
    "timestamp": "2025-08-05 20:57:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_PASSENGERS 1000\n\ntypedef struct {\n    int start;\n    int end;\n} Segment;\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint policy1_seats(Segment* segments, int n) {\n    int max_seats = 0;\n    int current_passengers = 0;\n\n    for (int i = 0; i < n; i++) {\n        current_passengers++;\n        max_seats = max(max_seats, current_passengers);\n\n        for (int j = 0; j < i; j++) {\n            if (segments[j].end <= segments[i].start) {\n                current_passengers--;\n            }\n        }\n    }\n\n    return max_seats;\n}\n\nint policy2_seats(Segment* segments, int n) {\n    int max_overlap = 0;\n\n    for (int i = 0; i < n; i++) {\n        int current_overlap = 0;\n        for (int j = 0; j < n; j++) {\n            if (segments[j].start < segments[i].end && segments[j].end > segments[i].start) {\n                current_overlap++;\n            }\n        }\n        max_overlap = max(max_overlap, current_overlap);\n    }\n\n    return max_overlap;\n}\n\nint main() {\n    int n;\n    Segment* segments = malloc(MAX_PASSENGERS * sizeof(Segment));\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &segments[i].start, &segments[i].end);\n    }\n\n    int policy1_result = policy1_seats(segments, n);\n    int policy2_result = policy2_seats(segments, n);\n\n    printf(\"%d %d\\n\", policy1_result, policy2_result);\n\n    free(segments);\n    return 0;\n}",
    "timestamp": "2025-08-05 20:58:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint calculateSeatsPolicy1(int n, vector<pair<int, int>>& passengers) {\n    vector<pair<int, int>> timeline;\n    for (auto& p : passengers) {\n        timeline.push_back({p.first, 1});\n        timeline.push_back({p.second, -1});\n    }\n    \n    sort(timeline.begin(), timeline.end());\n    \n    int currentPassengers = 0;\n    int maxPassengers = 0;\n    \n    for (auto& event : timeline) {\n        currentPassengers += event.second;\n        maxPassengers = max(maxPassengers, currentPassengers);\n    }\n    \n    return maxPassengers;\n}\n\nint calculateSeatsPolicy2(int n, vector<pair<int, int>>& passengers) {\n    vector<int> startPoints, endPoints;\n    for (auto& p : passengers) {\n        startPoints.push_back(p.first);\n        endPoints.push_back(p.second);\n    }\n    \n    sort(startPoints.begin(), startPoints.end());\n    sort(endPoints.begin(), endPoints.end());\n    \n    int seats = 0;\n    int i = 0, j = 0;\n    int currentPassengers = 0;\n    \n    while (i < n && j < n) {\n        if (startPoints[i] <= endPoints[j]) {\n            currentPassengers++;\n            seats = max(seats, currentPassengers);\n            i++;\n        } else {\n            currentPassengers--;\n            j++;\n        }\n    }\n    \n    return seats;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<pair<int, int>> passengers(n);\n    for (int i = 0; i < n; i++) {\n        cin >> passengers[i].first >> passengers[i].second;\n    }\n    \n    int policy1Seats = calculateSeatsPolicy1(n, passengers);\n    int policy2Seats = calculateSeatsPolicy2(n, passengers);\n    \n    cout << policy1Seats << \" \" << policy2Seats << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:58:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_seats_policy_1(travel_information):\n    events = []\n    for start, end in travel_information:\n        events.append((start, 'start'))\n        events.append((end, 'end'))\n    \n    events.sort()\n    max_seats = current_seats = 0\n\n    for time, event in events:\n        if event == 'start':\n            current_seats += 1\n            max_seats = max(max_seats, current_seats)\n        else:\n            current_seats -= 1\n\n    return max_seats\n\ndef min_seats_policy_2(travel_information):\n    travel_information.sort(key=lambda x: (x[0], x[1]))\n    ends = []\n\n    for start, end in travel_information:\n        i = 0\n        while i < len(ends) and ends[i] <= start:\n            i += 1\n        if i < len(ends):\n            ends[i] = end\n        else:\n            ends.append(end)\n\n    return len(ends)\n\n\ndef min_seats_required(travel_information):\n    seats_policy_1 = min_seats_policy_1(travel_information)\n    seats_policy_2 = min_seats_policy_2(travel_information)\n    return seats_policy_1, seats_policy_2\n\n# Example usage:\ntravel_information = [\n    (1, 5),\n    (2, 6),\n    (3, 7),\n    (4, 8),\n    (5, 9),\n]\nprint(min_seats_required(travel_information)) # Output: (5, 5)",
    "timestamp": "2025-08-13 04:16:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class ScenicRailroadService {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int numberOfTravelSections = scanner.nextInt();\n        int numberOfPassengers = scanner.nextInt();\n\n        int[] startStations = new int[numberOfPassengers];\n        int[] endStations = new int[numberOfPassengers];\n\n        for (int i = 0; i < numberOfPassengers; i++) {\n            startStations[i] = scanner.nextInt();\n            endStations[i] = scanner.nextInt();\n        }\n\n        System.out.println(computeSeatsForPolicy1(numberOfTravelSections, numberOfPassengers, startStations, endStations));\n        System.out.println(computeSeatsForPolicy2(numberOfTravelSections, numberOfPassengers, startStations, endStations));\n    }\n\n    private static int computeSeatsForPolicy1(int n, int m, int[] starts, int[] ends) {\n        int[] seatsAtStations = new int[n + 1];\n        for (int i = 0; i < m; i++) {\n            for (int j = starts[i]; j < ends[i]; j++) {\n                seatsAtStations[j]++;\n            }\n        }\n        int maxSeatsRequired = 0;\n        for (int seat : seatsAtStations) {\n            maxSeatsRequired = Math.max(maxSeatsRequired, seat);\n        }\n        return maxSeatsRequired;\n    }\n\n    private static int computeSeatsForPolicy2(int n, int m, int[] starts, int[] ends) {\n        int[][] events = new int[2 * m][2];\n        for (int i = 0; i < m; i++) {\n            events[2 * i] = new int[]{starts[i], 1};  // Start event\n            events[2 * i + 1] = new int[]{ends[i], -1}; // End event\n        }\n\n        Arrays.sort(events, (a, b) -> {\n            if (a[0] != b[0]) {\n                return Integer.compare(a[0], b[0]);\n            }\n            return Integer.compare(a[1], b[1]);\n        });\n\n        int maxSeatsRequired = 0;\n        int currentSeats = 0;\n        for (int[] event : events) {\n            currentSeats += event[1];\n            maxSeatsRequired = Math.max(maxSeatsRequired, currentSeats);\n        }\n        return maxSeatsRequired;\n    }\n}",
    "timestamp": "2025-08-13 04:16:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int start;\n    int end;\n} Reservation;\n\nint compare(const void *a, const void *b) {\n    Reservation *resA = (Reservation *)a;\n    Reservation *resB = (Reservation *)b;\n    int diff = resA->start - resB->start;\n    if (diff != 0)\n        return diff;\n    return resA->end - resB->end;\n}\n\nint maxSeatsPolicy1(Reservation *reservations, int n) {\n    int currentSeats = 0, maxSeats = 0;\n    for (int i = 0; i < n; i++) {\n        int usedSeats = 1;\n        for (int j = 0; j < i; j++) {\n            if (reservations[j].end > reservations[i].start) {\n                usedSeats++;\n            }\n        }\n        if (usedSeats > maxSeats)\n            maxSeats = usedSeats;\n    }\n    return maxSeats;\n}\n\nint maxSeatsPolicy2(Reservation *reservations, int n) {\n    qsort(reservations, n, sizeof(Reservation), compare);\n    \n    int *endTimes = (int *)malloc(n * sizeof(int));\n    int currentSeats = 0, maxSeats = 0;\n\n    for (int i = 0; i < n; i++) {\n        while (currentSeats > 0 && endTimes[currentSeats - 1] <= reservations[i].start) {\n            currentSeats--;\n        }\n        endTimes[currentSeats++] = reservations[i].end;\n        if (currentSeats > maxSeats)\n            maxSeats = currentSeats;\n    }\n    \n    free(endTimes);\n    return maxSeats;\n}\n\nint main() {\n    int n;\n    \n    printf(\"Enter number of passengers: \");\n    scanf(\"%d\", &n);\n    \n    Reservation *reservations = (Reservation *)malloc(n * sizeof(Reservation));\n    for (int i = 0; i < n; i++) {\n        printf(\"Enter start and end stations for passenger %d: \", i + 1);\n        scanf(\"%d %d\", &reservations[i].start, &reservations[i].end);\n    }\n\n    int seatsPolicy1 = maxSeatsPolicy1(reservations, n);\n    int seatsPolicy2 = maxSeatsPolicy2(reservations, n);\n    \n    printf(\"Seats required for Policy 1: %d\\n\", seatsPolicy1);\n    printf(\"Seats required for Policy 2: %d\\n\", seatsPolicy2);\n    \n    free(reservations);\n    return 0;\n}",
    "timestamp": "2025-08-13 04:16:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_seats_required(reservations):\n    # Policy 1: Passengers can choose any remaining seat\n    def policy_1(reservations):\n        max_seat = 0\n        for start, end in reservations:\n            max_seat = max(max_seat, end)\n        return max_seat\n\n    # Policy 2: Seats assigned after all reservations\n    def policy_2(reservations):\n        timeline = []\n        for start, end in reservations:\n            timeline.append((start, 1))\n            timeline.append((end, -1))\n        \n        timeline.sort()\n        current_passengers = 0\n        max_passengers = 0\n        \n        for _, change in timeline:\n            current_passengers += change\n            max_passengers = max(max_passengers, current_passengers)\n        \n        return max_passengers\n\n    # Return results for both policies\n    return policy_1(reservations), policy_2(reservations)\n\n# Example usage\nreservations = [(1, 3), (2, 4), (3, 5)]\nprint(min_seats_required(reservations))",
    "timestamp": "2025-08-13 04:17:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_seats(passengers):\n    if not passengers:\n        return (0, 0)\n    \n    # Policy 1: Maximum overlapping passengers at any point\n    events = []\n    for start, end in passengers:\n        events.append((start, 'start'))\n        events.append((end, 'end'))\n    \n    # Sort events: if times are same, 'end' comes before 'start'\n    events.sort(key=lambda x: (x[0], x[1] == 'start'))\n    \n    current_passengers = 0\n    max_passengers = 0\n    for time, typ in events:\n        if typ == 'start':\n            current_passengers += 1\n            max_passengers = max(max_passengers, current_passengers)\n        else:\n            current_passengers -= 1\n    policy1 = max_passengers\n    \n    # Policy 2: Number of distinct overlapping intervals\n    passengers_sorted = sorted(passengers, key=lambda x: x[0])\n    policy2 = 0\n    for i in range(len(passengers_sorted)):\n        current_start, current_end = passengers_sorted[i]\n        count = 1\n        for j in range(i):\n            prev_start, prev_end = passengers_sorted[j]\n            if current_start < prev_end and prev_start < current_end:\n                count += 1\n        policy2 = max(policy2, count)\n    \n    return (policy1, policy2)",
    "timestamp": "2025-08-13 04:17:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstruct Reservation {\n    int start;\n    int end;\n};\n\nint getSeatsForPolicy1(std::vector<Reservation>& reservations) {\n    int maxSeats = 0;\n    for (int i = 0; i < reservations.size(); ++i) {\n        int seatsAtThisStart = 0;\n        for (int j = 0; j < reservations.size(); ++j) {\n            if (reservations[j].start <= reservations[i].start && reservations[j].end > reservations[i].start) {\n                seatsAtThisStart++;\n            }\n        }\n        maxSeats = std::max(maxSeats, seatsAtThisStart);\n    }\n    return maxSeats;\n}\n\nint getSeatsForPolicy2(std::vector<Reservation>& reservations) {\n    int maxSeats = 0;\n    std::vector<int> seatsTimeline(10001, 0);\n    \n    for (const auto & reservation : reservations) {\n        for (int i = reservation.start; i < reservation.end; i++) {\n            seatsTimeline[i]++;\n            maxSeats = std::max(maxSeats, seatsTimeline[i]);\n        }\n    }\n    \n    return maxSeats;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<Reservation> reservations(n);\n    \n    for (int i = 0; i < n; ++i) {\n        std::cin >> reservations[i].start >> reservations[i].end;\n    }\n    \n    int policy1Seats = getSeatsForPolicy1(reservations);\n    int policy2Seats = getSeatsForPolicy2(reservations);\n    \n    std::cout << policy1Seats << \" \" << policy2Seats << std::endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:18:10"
  }
]