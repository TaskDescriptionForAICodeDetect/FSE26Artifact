[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\ntypedef long double D;\ntypedef complex<D> P;\n\n#define X real()\n#define Y imag()\n\nconst D eps=1e-8;\nconst D inf=1e12;\nconst D PI=acos(-1);\n\nD cross(P a,P b){ return (conj(a)*b).Y; }\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\nP projection(L l,P p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*(c/b).X;\n}\nD distanceLP(L l,P p) {\n  return abs(p-projection(l,p));\n}\nP crosspoint(L l,L m) {\n  D A=cross(l[1]-l[0],m[1]-m[0]);\n  D B=cross(l[1]-l[0],l[1]-m[0]);\n  if (abs(A)<eps&&abs(B)<eps) return m[0]; // same line\n  if (abs(A)<eps) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0]+B/A*(m[1]-m[0]);\n}\n\nP p[3],q[3],e[3],x[3];\nD r[3];\nP g;\nP cp;\n\nbool ok(){\n  r[0]=distanceLP(L(p[0],p[1]),x[0]);\n  repl(i,1,3){\n    D lb=0,ub=abs(cp-p[i]);\n    rep(hoge,80){\n      D mid=(ub+lb)/2.0;\n      x[i]=p[i]+e[i]*mid;\n      r[i]=distanceLP(L(p[i],p[(i+1)%3]),x[i]);\n      D d0i=abs(x[i]-x[0]);\n      if(d0i>r[0]+r[i])lb=mid;\n      else ub=mid;\n    }\n  }\n  D d12=abs(x[1]-x[2]);\n  return d12>r[1]+r[2];\n}\n\nint main(){\n  while(1){\n    bool done=true;\n    rep(i,3){\n      int x,y;\n      cin>>x>>y;\n      if(x!=0||y!=0)done=false;\n      p[i]=P(x,y);\n    }\n    if(done)break;\n\n    D absA=abs(p[2]-p[1]); D absB=abs(p[2]-p[0]); D absC=abs(p[1]-p[0]);\n    q[0]=(p[1]*absB+p[2]*absC)/(absB+absC);\n    q[1]=(p[0]*absA+p[2]*absC)/(absA+absC);\n    q[2]=(p[0]*absA+p[1]*absB)/(absA+absB);\n    cp=crosspoint(L(p[1],q[1]),L(p[2],q[2]));\n    rep(i,3)e[i]=(q[i]-p[i])/abs(q[i]-p[i]);\n    D lb=0,ub=abs(cp-p[0]);\n    rep(hoge,80){\n      D mid=(lb+ub)/2.0;\n      x[0]=p[0]+e[0]*mid;\n      if(ok())ub=mid;\n      else lb=mid;\n    }\n    printf(\"%.5Lf %.5Lf %.5Lf\\n\", r[0], r[1], r[2]);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\nlong double x[3], y[3], l[3], a[3], r[3];\n\t\nbool check() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (x[i] != 0) {\n\t\t\treturn true;\n\t\t}\n\t\tif (y[i] != 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nint main() {\n\tcout << fixed;\n\tcout << setprecision(6);\n\n\tint tmp;\n\tbool first = true;\n\tlong double value;\n\tlong double opp, hyp, adj;\n\tlong double dist;\n\tlong double diffx[2], diffy[2];\n\tlong double dirx, diry;\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tcin >> x[i];\n\t\tcin >> y[i];\n\t}\n\n\tint itr = 0;\n\twhile (check()) {\n\t\t//cout << itr++ << endl;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\ttmp = (i+1) % 3;\n\n\t\t\t//cout << pow(x[i] - x[tmp], 2) << \" \" << pow(y[i] - y[tmp], 2) << endl;\n\t\t\tl[i] = sqrtl(pow(x[i] - x[tmp], 2) + pow(y[i] - y[tmp], 2));\n\t\t}\n\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t/*\n\t\t\thyp = 2*l[i]*l[(i+2)%3];\n\t\t\tadj = pow(l[i], 2) + pow(l[(i+2)%3], 2) - pow(l[(i+1)%3], 2);\n\t\t\topp = sqrtl(pow(hyp,2)-pow(adj,2));\n\n\t\t\ta[i] = (hyp - adj) / opp;\n\t\t\t*/\n\n\t\t\ta[i] = pow(l[i],2) + pow(l[(i+2)%3],2) - pow(l[(i+1)%3],2);\n\t\t\ta[i] /= 2*l[i]*l[(i+2)%3];\n\t\t\ta[i] = acos(a[i]);\n\t\t\ta[i] = tan(a[i]/2);\n\t\t\t//cout << a[i] << endl;\n\t\t}\n\n\n\t\tlong double diff = max(l[0],l[2]);\n\t\tlong double diff2;\n\t\tr[0] = 0.1;\n\n\t\twhile (diff > 1e-10) {\n\t\t\tr[0] += diff;\n\t\t\t//cout << \"START: \" << r[0] << endl;\n\n\t\t\tr[1] = 0.1;\n\t\t\tdiff2 = l[0];\n\t\t\twhile (diff2 > 1e-10) {\n\t\t\t\tr[1] += diff2;\n\n\t\t\t\tif (r[0]/a[0] + 2*sqrtl(r[0]*r[1]) + r[1]/a[1] > l[0]) {\n\t\t\t\t\tr[1] -= diff2;\n\t\t\t\t\tdiff2 /= 2;\n\t\t\t\t}\n\t\t\t} \n\n\t\t\tr[2] = 0.1;\n\t\t\tdiff2 = l[2];\n\t\t\twhile (diff2 > 1e-10) {\n\t\t\t\tr[2] += diff2;\n\n\t\t\t\tif (r[0]/a[0] + 2*sqrtl(r[0]*r[2]) + r[2]/a[2] > l[2]) {\n\t\t\t\t\tr[2] -= diff2;\n\t\t\t\t\tdiff2 /= 2;\n\t\t\t\t}\n\t\t\t} \n\t\t\t\n\t\t\tvalue = r[1]/a[1] + 2*sqrtl(r[1]*r[2]) + r[2]/a[2];\n\n\t\t\tif (value < l[1]) {\n\t\t\t\tr[0] -= diff;\n\t\t\t\tdiff /= 2;\n\t\t\t} \n\t\t}\n\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t} else {\n\t\t\tcout << endl;\n\t\t}\n\n\t\tcout << r[0];\n\t\tfor (int i = 1; i < 3; i++) {\n\t\t\tcout << \" \" << r[i];\n\t\t}\n\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tcin >> x[i];\n\t\t\tcin >> y[i];\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<double,P> P2;\n\nconst double EPS = 1e-8;\nP v[3];\n\ndouble cross(P a, P b){ return imag(conj(a)*b);}\n\nP rotate(P p, double rad){\n  double x = real(p) * cos(rad) - imag(p) * sin(rad);\n  double y = real(p) * sin(rad) + imag(p) * cos(rad);\n  return P(x,y);\n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  return m.first + B / A * (m.second - m.first);\n}\n\ndouble areaV(){\n  double sum = 0.0;\n  for(int i=0;i<3;i++) sum += (real(v[i]) - real(v[(i+1)%3])) * (imag(v[i]) + imag(v[(i+1)%3]));\n  return abs(sum) / 2.0;\n}\n\nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\nP2 check2(P2 p, int pos){\n  double le = 0.1, ri = 2.0 * areaV() / (abs(v[1]-v[0]) + abs(v[2]-v[1]) + abs(v[0]-v[2]));\n  L l[2];\n  P2 res;\n  for(int i=0;i<100;i++){\n    double mid = (le + ri) / 2.0;\n\n    for(int j=pos;j<pos+2;j++){\n      P a = (v[(j+1)%3]-v[j%3]) * mid / abs(v[(j+1)%3]-v[j%3]);\n      P b = rotate(a, M_PI/2.0);\n      l[j-pos] = L(v[(j+1)%3]+b, v[j%3]+b);\n    }\n    res = P2(mid, crossPoint(l[0],l[1]));\n\n    if(equal(abs(res.second-p.second), res.first+p.first)) return res;\n    else if(abs(res.second-p.second) < res.first+p.first) ri = mid;\n    else le = mid;\n  }\n}\n\nint check(double r){\n  L l[2];\n  P2 p[3];\n  for(int i=0;i<2;i++){\n    P a = (v[i+1]-v[i]) * r / abs(v[i+1]-v[i]);\n    P b = rotate(a, M_PI/2.0);\n    l[i] = L(v[i+1]+b, v[i]+b);\n  }\n  p[0] = P2(r, crossPoint(l[0],l[1]));\n\n\n  for(int i=1;i<3;i++) p[i] = check2(p[0], i);\n\n  if(equal(abs(p[2].second-p[1].second), p[2].first+p[1].first)){\n    printf(\"%.6f %.6f %.6f\\n\",p[2].first, p[0].first, p[1].first);\n    return 1;\n  }\n  else if(abs(p[2].second-p[1].second) < p[2].first+p[1].first) return 2;\n  else return 0;\n  \n}\n\nvoid solve(){\n  double le = 0.1, ri = 2.0 * areaV() / (abs(v[1]-v[0]) + abs(v[2]-v[1]) + abs(v[0]-v[2]));\n  for(int i=0;i<100;i++){\n    double mid = (le + ri) / 2.0;\n    int res = check(mid);\n    if(res == 0) ri = mid;\n    else if(res == 2) le = mid;\n    else return;\n  }\n}\n\nint main(){\n  int x[3],y[3];\n  while(cin >> x[0] >> y[0] >> x[1] >> y[1] >> x[2] >> y[2] && (x[0]|y[0]|x[1]|y[1]|x[2]|y[2])){\n    for(int i=0;i<3;i++) v[i] = P((double)x[i], (double)y[i]);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\n//  ?§?????????????????????????\nLine getBisectorOfAngle(Point base,Point a,Point b){\n  Vector v1=(a-base),v2=(b-base);\n  double s=acos(dot(v1,v2)/(abs(v1)*abs(v2)))*360/(4*pi);\n  return Line(base,rotate(base,a,s));\n}\n\n//  ????§???¢???????§?????????????????????????\nLine getBisectorOfAngleInTriangle(Point base,Point a,Point b){\n  Line L=getBisectorOfAngle(base,a,b);\n  Point p=getCrossPointLL(Line(a,b),L);\n  return Segment(base,p);\n}\n\nPoint p1,p2,p3;\nSegment s1,s2,s3;\nLine L1,L2,L3;\nvector<double> ans;\n\nbool check(Line L,Point A,double a,double dis){\n  Vector V=(L.p2-L.p1)/abs(L.p2-L.p1);\n  Point P=L.p1+V*dis;\n  double d=getDistanceLP(s3,P);\n  if(((a+d)-abs(A-P))<eps)return true;\n  return false;\n}\n\nbool ok(double dis){\n  Vector V=(L1.p2-L1.p1)/abs(L1.p2-L1.p1);\n  Point A=L1.p1+V*dis;\n  double a,b,c,l,r,m;\n  a=getDistanceLP(s1,A);\n\n  l=0;r=abs(L2.p1-L2.p2);\n  for(int i=0;i<50;i++){\n    m=(l+r)/2.0;\n    if(check(L2,A,a,m))l=m;\n    else r=m;\n  }\n  V=(L2.p2-L2.p1)/abs(L2.p2-L2.p1);\n  Point B=L2.p1+V*m;\n  b=getDistanceLP(s3,B);\n\n  l=0;r=abs(L3.p1-L3.p2);\n  for(int i=0;i<50;i++){\n    m=(l+r)/2.0;\n    if(check(L3,A,a,m))l=m;\n    else r=m;\n  }\n  V=(L3.p2-L3.p1)/abs(L3.p2-L3.p1);\n  Point C=L3.p1+V*m;\n  c=getDistanceLP(s3,C);\n\n  if(equals(c+b,abs(C-B))){\n    ans.push_back(a);\n    ans.push_back(b);\n    ans.push_back(c);\n  }\n  if(((c+b)-abs(C-B))<-eps)return true;\n  return false;\n}\n\nint main()\n{\n  int a,b,c,d,e,f;\n  while(1){\n    cin>>a>>b>>c>>d>>e>>f;\n    if(a+b+c+d+e+f==0)break;\n    p1=Point(a,b);\n    p2=Point(c,d);\n    p3=Point(e,f);\n    s1=Segment(p1,p2);\n    s2=Segment(p1,p3);\n    s3=Segment(p2,p3);\n    L1=getBisectorOfAngleInTriangle(p1,p2,p3);\n    L2=getBisectorOfAngleInTriangle(p2,p3,p1);\n    L3=getBisectorOfAngleInTriangle(p3,p1,p2);\n    Point cp=getCrossPointLL(L1,L2);\n    L1.p2=cp;\n    L2.p2=cp;\n    L3.p2=cp;\n    ans.clear();\n\n    double l=0,r=abs(L1.p2-L1.p1);\n    for(int i=0;i<50;i++){\n      double m=(l+r)/2.0;\n      if(ok(m))r=m;\n      else l=m;\n      if(!ans.empty())break;\n    }\n\n    printf(\"%.6f %.6f %.6f\\n\",ans[0],ans[1],ans[2]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-5;\nconst double PI = acos(-1);\nconst int INF = 1<<24;\n\nbool equals(double a, double b) { return fabs(a - b) < EPS; }\n\nnamespace std {\n  bool operator < (const P &a, const P b) {\n    return ( a.real() != b.real()\n\t     ? a.real() < b.real() : a.imag() < b.imag() );\n  }\n}\n\nstruct L : public vector<P> {\n  L(P a, P b) {\n    push_back(a), push_back(b);\n  }\n};\n\nstruct C {\n  P o;\n  double r;\n  C() {}\n  C(P o, double r) : o(o), r(r) {}\n};\n\ndouble norm(P a) { return a.real()*a.real() + a.imag() * a.imag(); }\ndouble abs (P a) { return sqrt(norm(a)); }\ndouble dot  (P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\ndouble cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\n\nbool isOrthogonal(P a, P b) { return equals(dot(a, b), 0.0); }\nbool isParallel  (P a, P b) { return equals(cross(a, b), 0.0); }\n\nP project(P s1, P s2, P p) {\n  P base = s2 - s1;\n  double t = dot(p - s1, base)/norm(base);\n  return s1 + base*t;\n}\n\nP reflect(P s1, P s2, P p) { return p + (project(s1, s2, p) - p)*2.0; }\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return fabs(cross(s2 - s1, p - s1)/abs(s2 - s1));\n}\n\nP getRotateP(P p, double rad, P o = P(0, 0)) {\n  P q = p - o;\n  return o + P(q.real()*cos(rad) - q.imag()*sin(rad),\n\t   q.real()*sin(rad) + q.imag()*cos(rad));\n}\n\nnamespace CCW {\n  enum { COUNTER_CLOCKWISE = 1, CLOCKWISE = -1,\n\t ONLINE_BACK = 2, ONLINE_FRONT = -2,\n\t ONSEGMENT = 0 };\n}\nint ccw(P p0, P a, P b) {\n  a -= p0;\n  b -= p0;\n  if(cross(a, b) > EPS) return CCW::COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CCW::CLOCKWISE;\n  if(dot(a, b) < -EPS) return CCW::ONLINE_BACK;\n  if(norm(a) < norm(b)) return CCW::ONLINE_FRONT;\n  return CCW::ONSEGMENT;\n}\n\n// üªÆüªÌð·»èB\nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t   ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\n// ¼üÆ~Ìð·»èBßèlÍð_ÌB\nint isIntersect(P s1, P s2, C c) {\n  double d = getDistanceLP(s1, s2, c.o);\n  if(equals(d, c.r)) return 1;\n  else if(d < c.r) return 2;\n  else return 0;\n}\n\n// ~Æ~Ìð·»èB\n//  0 : ð·AàïÈµ\n//  1 : OÅ1_ÆÚ·é\n//  2 : 2_Åð·\n// -1 : àïµÄÚ·é\n// -2 : ®SÉàï\nint isIntersect(C a, C b) {\n  double x = a.o.real() - b.o.real();\n  double y = a.o.imag() - b.o.imag();\n  double s = a.r + b.r;\n  double d = x*x + y*y;\n  s *= s;\n  if(equals(d, s)) return 1;\n  if(d > s) return 0;\n  double r = abs(a.r - b.r);\n  r *= r;\n  if(equals(d, r)) return -1;\n  if(d > r) return 2;\n  return -2;\n}\n\n// ¼üÆ¼üÌð_B\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  // cross ÌÖW è\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\n// ¼üÆ~Ìð_B\nvector<P> getCrossP(P s1, P s2, C c) {\n  vector<P> v;\n  P p = project(s1, s2, c.o);\n  if(isIntersect(s1, s2, c) == 1) {\n    v.push_back(p);\n  } else {\n    double h = abs(p-c.o);\n    double d = sqrt(c.r*c.r - h*h);\n    P base = s2 - s1;\n    v.push_back(p + d*base/abs(base));\n    v.push_back(p - d*base/abs(base));\n  }\n  return v;\n}\n\n// xNg(1, 0)ðîÆµ½xNgÌpx(-PI <= rad <= PI)\ndouble getAngle(P a) {\n  return atan2(a.imag(), a.real());\n}\n\n// 2ÂÌxNgÌÈ·p(0 <= rad <= PI)\ndouble getAngle(P a, P b) {\n  double rad1 = getAngle(a);\n  double rad2 = getAngle(b);\n  if(rad1 < 0) rad1 += 2*PI;\n  if(rad2 < 0) rad2 += 2*PI;\n  double res = fabs(rad1 - rad2);\n  return res > PI ? 2*PI-res : res;\n  //if(cross(a, b) < 0.0) swap(a, b);\n  //return getAngle(b) - getAngle(a);\n  //return acos(dot(a, b)/abs(a)/abs(b));\n}\n\n// 2ÂÌ¼üÉÚ·é¼arÌ~\nC getC(P a1, P a2, P b1, P b2, double r) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  if(cross(a, b) < 0) swap(a, b);\n  P p = getCrossP(a1, a2, b1, b2);\n  double rad = getAngle(a, b) / 2.0;\n  double alpha = getAngle(a);\n  C res;\n  res.r = r;\n  res.o = p + (P(cos(alpha + rad), sin(alpha + rad)) * r) / sin(rad);\n  return res;\n}\n\n// wÌö®ðp¢ÄOp`Ì3ÓÌ·³©çÊÏðßé\ndouble heron(double a, double b, double c) {\n  double s = (a+b+c)/2.0;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\n// ½p`ÌÊÏ\ndouble getArea(vector<P> &G) {\n  int n = G.size();\n  double S = 0;\n  for(int i = 0; i < n; ++i) {\n    S += cross(G[i], G[(i+1)%n]);\n  }\n  return S/2.0;\n}\n\n// Op`ÌàÚ~Ì¼a\ndouble getIncircleR(P p1, P p2, P p3) {\n  double a = abs(p1 - p2);\n  double b = abs(p2 - p3);\n  double c = abs(p3 - p1);\n  return heron(a,b,c)*2.0/(a+b+c);\n}\n\nC getIncircle(P p1, P p2, P p3) {\n  return getC(p1, p2, p1, p3, getIncircleR(p1, p2, p3));\n}\n\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for(int i = 0; i < n; ch[k++] = ps[i++])\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = CCW::CLOCKWISE) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\nP p[3];\nC incircle;\n\nC calc(P a1, P a2, P b1, P b2, C c) {\n  C res;\n  double s, t;\n  double br = -1;\n  s = 0.0, t = incircle.r;\n  while(1) {\n    double r = (s+t)/2.0;\n    res = getC(a1, a2, b1, b2, r);\n    if(r == br) return res;\n    br = r;\n    int tmp = isIntersect(c, res);\n    if(tmp == 0) {\n      s = r;\n    } else if(tmp == 1) {\n      return res;\n    } else {\n      t = r;\n    }\n  }\n}\n\nvoid solve() {\n  incircle = getIncircle(p[0], p[1], p[2]);\n  double s, t;\n  double br = -1;\n  C c[3];\n  s = 0.0, t = incircle.r;\n  while(1) {\n    double r = (s+t)/2.0;\n\n    c[0] = getC(p[0], p[1], p[0], p[2], r);\n\n    if(!isIntersect(c[0], incircle)) {\n      s = r;\n      continue;\n    }\n\n    c[1] = calc(p[1], p[2], p[1], p[0], c[0]);\n    c[2] = calc(p[2], p[0], p[2], p[1], c[0]);\n\n    int tmp = isIntersect(c[1], c[2]);\n\n    if(r == br || tmp == 1) {\n      for(int i = 0; i < 3; ++i) {\n\tif(i) printf(\" \");\n\tprintf(\"%.6f\", c[i].r);\n      }\n      printf(\"\\n\");\n      return;\n    } else if(tmp == 0) {\n      t = r;\n    } else {\n      s = r;\n    }\n    br = r;\n  }\n}\n\nint main() {\n  while(1) {\n    bool allZero = true;\n    for(int i = 0; i < 3; ++i) {\n      cin >> p[i].real() >> p[i].imag();\n      if(p[i].real() != 0 || p[i].imag() != 0) allZero = false;\n    }\n    if(allZero) break;\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <iomanip>\nusing namespace std;\n\nlong double x[3], y[3], l[3], a[3], r[3];\n\t\nbool check() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (x[i] != 0) {\n\t\t\treturn true;\n\t\t}\n\t\tif (y[i] != 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nlong double quad(long double a, long double b, long double c) {\n\tlong double result;\n\tresult = pow(b,2)-4*a*c;\n\tif (result < 0) {\n\t\treturn -1;\n\t}\n\tresult = 2*b*sqrtl(result);\n\tresult = 2*pow(b,2)-4*a*c-result;\n\tresult /= 4*pow(a,2);\n\treturn result;\n}\n\nint main() {\n\tcout << fixed;\n\tcout << setprecision(6);\n\n\tint tmp;\n\tbool first = true;\n\tlong double value;\n\tlong double opp, hyp, adj;\n\tlong double dist;\n\tlong double diffx[2], diffy[2];\n\tlong double dirx, diry;\n\tlong double save;\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tcin >> x[i];\n\t\tcin >> y[i];\n\t}\n\n\tint itr = 0;\n\twhile (check()) {\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t} else {\n\t\t\tcout << endl;\n\t\t}\n\n\t\t//cout << itr++ << endl;\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\ttmp = (i+1) % 3;\n\n\t\t\t\t//cout << pow(x[i] - x[tmp], 2) << \" \" << pow(y[i] - y[tmp], 2) << endl;\n\t\t\t\tl[i] = sqrtl(pow(x[i] - x[tmp], 2) + pow(y[i] - y[tmp], 2));\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t/*\n\t\t\t\thyp = 2*l[i]*l[(i+2)%3];\n\t\t\t\tadj = pow(l[i], 2) + pow(l[(i+2)%3], 2) - pow(l[(i+1)%3], 2);\n\t\t\t\topp = sqrtl(pow(hyp,2)-pow(adj,2));\n\n\t\t\t\ta[i] = (hyp - adj) / opp;\n\t\t\t\t*/\n\n\t\t\t\ta[i] = pow(l[i],2) + pow(l[(i+2)%3],2) - pow(l[(i+1)%3],2);\n\t\t\t\ta[i] /= 2*l[i]*l[(i+2)%3];\n\t\t\t\ta[i] = acos(a[i]);\n\t\t\t\ta[i] = tan(a[i]/2);\n\t\t\t\t//cout << a[i] << endl;\n\t\t\t}\n\n\n\t\t\tlong double diff = max(l[0],l[2]);\n\t\t\tr[0] = 0.1;\n\n\t\t\twhile (diff > 1e-15) {\n\t\t\t//for (int i = 0; i < 10; i++) {\n\t\t\t\tr[0] += diff;\n\t\t\t\t//cout << \"START: \" << r[0] << endl;\n\n\n\t\t\t\tr[1] = quad(1/a[1], 2*sqrtl(r[0]), r[0]/a[0]-l[0]);\n\t\t\t\tr[2] = quad(1/a[2], 2*sqrtl(r[0]), r[0]/a[0]-l[2]);\n\n\t\t\t\tif (r[1] == -1 || r[2] == -1) {\n\t\t\t\t\tr[0] -= diff;\n\t\t\t\t\tdiff /= 2;\n\n\t\t\t\t\t//cout << \"HIT\\n\";\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//cout << r[1] << \" \" << r[2] << endl;\n\t\t\t\t\n\t\t\t\tvalue = r[1]/a[1] + 2*sqrtl(r[1]*r[2]) + r[2]/a[2];\n\t\t\t\t//cout << \"ERROR: \" << value - l[1] << endl;\n\n\t\t\t\t//cout << r[0] << \" \" << r[1] << \" \" << r[2] << endl;\n\n\t\t\t\tif (value < l[1]) {\n\t\t\t\t\tr[0] -= diff;\n\t\t\t\t\tdiff /= 2;\n\n\t\t\t\t\t//cout << \"HIT\\n\";\n\t\t\t\t} else {\n\t\t\t\t\t//cout << \"MISS\\n\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcout << r[0] << \" \";\n\t\t\tsave = x[0];\n\t\t\tx[0] = x[1];\n\t\t\tx[1] = x[2];\n\t\t\tx[2] = save;\n\n\t\t\tsave = y[0];\n\t\t\ty[0] = y[1];\n\t\t\ty[1] = y[2];\n\t\t\ty[2] = save;\n\t\t}\n\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tcin >> x[i];\n\t\t\tcin >> y[i];\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tVP p(3);\n\tfor (;;) {\n\t\trep(i, 3) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = { (double)x,(double)y };\n\t\t}\n\t\tif (p[0] == p[1])break;\n\t\tP up1 = (p[1] * abs(p[2] - p[0]) + p[2] * abs(p[1] - p[0])) / (abs(p[2] - p[0]) + abs(p[1] - p[0]));\n\t\tP dn1 = p[0];\n\t\tdouble r1,r2, r3;\n\t\trep(i, 25) {\n\t\t\tP m1 = (up1 + dn1) * 0.5l;\n\t\t\tr1 = dist_lp({ p[0],p[1] }, m1);\n\t\t\tP up2 = (p[0] * abs(p[2] - p[1]) + p[2] * abs(p[0] - p[1])) / (abs(p[2] - p[1]) + abs(p[0] - p[1]));\n\t\t\tP up3 = (p[0] * abs(p[2] - p[1]) + p[1] * abs(p[0] - p[2])) / (abs(p[2] - p[1]) + abs(p[0] - p[2]));\n\t\t\tP dn2 = p[1], dn3 = p[2];\n\t\t\trep(j, 25) {\n\t\t\t\tP m2 = (up2 + dn2)*0.5l, m3 = (up3 + dn3)*0.5l;\n\t\t\t\tr2 = dist_lp({ p[0],p[1] }, m2);\n\t\t\t\tr3 = dist_lp({ p[0],p[2] }, m3);\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[1],m2 }) && dist_lp({ p[0],p[2] }, m2) > r2 && abs(m1 - m2) > r1 + r2)dn2 = m2;\n\t\t\t\telse up2 = m2;\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[2],m3 }) && dist_lp({ p[0],p[1] }, m3) > r3 && abs(m3 - m1) > r1 + r3)dn3 = m3;\n\t\t\t\telse up3 = m3;\n\t\t\t}\n\t\t\tif (isis_ss({ p[1],up2 }, { p[2],up3 }) || abs(up2 - up3) < r2 + r3)dn1 = m1;\n\t\t\telse up1 = m1;\n\t\t}\n\t\tcout << fixed << setprecision(10) << r1 << \" \" << r2 << \" \" << r3 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<complex>\n#define eps 1e-12\n#define RE real()\n#define IM imag()\nusing namespace std;\ntypedef complex<double> Point;\nPoint I,A,B,C;\n\nint main()\n{\n    double x1,y1,x2,y2,x3,y3;\n    while(~scanf(\"%lf%lf%lf%lf%lf%lf\",&x1,&y1,&x2,&y2,&x3,&y3))\n    {\n        if(fabs(x1)<eps && fabs(y1)<eps && fabs(x2)<eps && fabs(y2)<eps && fabs(x3)<eps && fabs(y3)<eps) break;\n        A = Point(x1,y1), B = Point(x2,y2), C = Point(x3,y3);\n        double a,b,c;\n        c = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n        a = sqrt((x3-x2)*(x3-x2) + (y3-y2)*(y3-y2));\n        b = sqrt((x1-x3)*(x1-x3) + (y3-y1)*(y3-y1));\n        double p = (c+a+b)/2.0;\n        double r = sqrt(p*(p-a)*(p-b)*(p-c))/p;\n        I = Point( ((a*A.RE+b*B.RE+c*C.RE)/(a+b+c)),((a*A.IM+b*B.IM+c*C.IM)/(a+b+c)));\n        double Ia,Ib,Ic;\n        Ia = sqrt((x1-I.RE)*(x1-I.RE) + (y1-I.IM)*(y1-I.IM));\n        Ib = sqrt((x2-I.RE)*(x2-I.RE) + (y2-I.IM)*(y2-I.IM));\n        Ic = sqrt((x3-I.RE)*(x3-I.RE) + (y3-I.IM)*(y3-I.IM));\n        double  r1=(r/(2*(p-a)))*(p-r+Ia-Ib-Ic);\n        double  r2=(r/(2*(p-b)))*(p-r+Ib-Ia-Ic);\n        double  r3=(r/(2*(p-c)))*(p-r+Ic-Ib-Ia);\n        printf(\"%.6f %.6f %.6f\\n\",r1,r2,r3);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nG g;\nP F(double r,int a){\n\tdouble q=abs(arg(g[(a+1)%3]-g[a])-arg(g[(a-1+3)%3]-g[a]));\n\tif(q>PI)q=2*PI-q;\n\tq/=2;\n\tdouble w=r/tan(q);\n\tP t=g[(a+1)%3]-g[a];\n\treturn g[a]+t*w/abs(t)+P(0,1)*t*r/abs(t);\n}\nint main(){\n\tint a,b,c,d,e,f;\n\twhile(cin>>a>>b>>c>>d>>e>>f,a||b||c||d||e||f){\n\t\tg=G(3);\n\t\tg[0]=P(a,b);\n\t\tg[1]=P(c,d);\n\t\tg[2]=P(e,f);\n\t\tdouble l=0,r=100000;\n\t\tdouble out1,out2;\n\t\twhile(r-l>EPS){\n\t\t\tdouble m=(r+l)/2;\n//\t\t\tcout<<shosu(9)<<endl<<l<<\" \"<<m<<\" \"<<r<<endl;\n\t\t\tP p=F(m,0);\n\t\t\tif(intersectSS(L(g[1],g[2]),L(g[0],p))){\n\t\t\t\tr=m;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble L1=0,R=100000;\n\t\t\tP q,z;\n\t\t\twhile(R-L1>EPS){\n\t\t\t\tout1=(R+L1)/2;\n\t\t\t\tq=F(out1,1);\n\t\t\t\tif(abs(g[1]-p)<abs(g[1]-q)||distanceSP(L(g[2],g[0]),q)<distanceSP(L(g[2],g[0]),p)){\n\t\t\t\t\tR=out1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(abs(p-q)>m+out1)L1=out1;\n\t\t\t\telse R=out1;\n\t\t\t}\n\t\t\tL1=0;R=100000;\n\t\t\twhile(R-L1>EPS){\n\t\t\t\tout2=(R+L1)/2;\n\t\t\t\tz=F(out2,2);\n\t\t\t\tif(abs(g[2]-p)<abs(g[2]-z)||distanceSP(L(g[0],g[1]),z)<distanceSP(L(g[0],g[1]),p)){\n\t\t\t\t\tR=out2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(abs(p-z)>m+out2)L1=out2;\n\t\t\t\telse R=out2;\n\t\t\t}\n//\t\t\tcout<<abs(z-q)<<\" \"<<out1<<\" \"<<out2<<endl;\n\t\t\tif(abs(z-q)<out1+out2)l=m;\n\t\t\telse r=m;\n\t\t}\n\t\tcout<<shosu(9)<<l<<\" \"<<out1<<\" \"<<out2<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\nostream &operator << (ostream &os,Point &p){\n  os<<p.x<<\" \"<<p.y;\n  return os;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\nint main(){\n  Polygon p(3);\n  while(cin>>p[0]>>p[1]>>p[2],!(p[0]==p[1])){\n    \n    Vector v[3][2],e[3];\n    v[0][0]=p[1]-p[0];\n    v[0][1]=p[2]-p[0];\n    v[1][0]=p[2]-p[1];\n    v[1][1]=p[0]-p[1];\n    v[2][0]=p[0]-p[2];\n    v[2][1]=p[1]-p[2];\n    for(int i=0;i<3;i++){\n      for(int j=0;j<2;j++)\n\tv[i][j]=v[i][j]/abs(v[i][j]);\n      e[i]=v[i][0]+v[i][1];\n      e[i]=e[i]/abs(e[i]);\n      //cout<<e[i]<<endl;\n    }\n    \n    Circle c[3];\n    double l=0,r=abs(getCrossPointLL(Segment(p[1],p[2]),Segment(p[0],p[0]+e[0]))-p[0]);\n    for(int i=0;i<100;i++){\n      double m=(l+r)/2;\n      c[0].c=p[0]+e[0]*m;\n      c[0].r=getDistanceLP(Segment(p[0],p[1]),c[0].c);\n      if(getDistanceLP(Segment(p[1],p[2]),c[0].c)<=c[0].r){\n\tr=m;\n\tcontinue;\n      }\n      \n      double l1=0,r1=abs(getCrossPointLL(Segment(p[2],p[0]),Segment(p[1],p[1]+e[1]))-p[1]);\n      double l2=0,r2=abs(getCrossPointLL(Segment(p[0],p[1]),Segment(p[2],p[2]+e[2]))-p[2]);\n      for(int j=0;j<100;j++){\n\tdouble m1=(l1+r1)/2,m2=(l2+r2)/2;\n\tc[1].c=p[1]+e[1]*m1;c[1].r=getDistanceLP(Segment(p[1],p[2]),c[1].c);\n\tc[2].c=p[2]+e[2]*m2;c[2].r=getDistanceLP(Segment(p[2],p[0]),c[2].c);\n\tif(getDistanceLP(Segment(p[2],p[0]),c[1].c)<c[1].r) r1=m1;\n\telse if(abs(c[1].c-c[0].c)<=c[1].r+c[0].r) r1=m1;\n\telse l1=m1;\n        if(getDistanceLP(Segment(p[0],p[1]),c[2].c)<c[2].r) r2=m2;\n\telse if(abs(c[2].c-c[0].c)<=c[2].r+c[0].r) r2=m2;\n\telse l2=m2;\n      }\n      //cout<<abs(c[1].c-c[2].c)<<\" \"<<c[1].r+c[2].r<<endl;\n      if(abs(c[1].c-c[2].c)<=c[1].r+c[2].r) l=m;\n      else r=m;\n    }\n    printf(\"%.12f %.12f %.12f\\n\",c[0].r,c[1].r,c[2].r);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  A_-_Malfatti_Circles\n//\n//  Created by Andy on 7/5/18.\n//  Copyright © 2018 Andy. All rights reserved.\n//\n\n#include <iostream>\n#include <cmath>\n\n\ndouble Ax, Ay, Bx, By, Cx, Cy;\ndouble a, b, c, p, s, r;\ndouble Ix, Iy;\ndouble IA, IB, IC;\ndouble r1, r2, r3;\n\n\nint main(int argc, const char * argv[]) {\n\n    while (true) {\n        scanf(\"%lf %lf %lf %lf %lf %lf\", &Ax, &Ay, &Bx, &By, &Cx, &Cy);\n        if (Ax == Bx && Bx == Cx && Ax == Ay && Ay == By && By == Cy && Cy == 0) break;\n        \n        a = std::sqrt(pow(Bx - Cx, 2) + pow(By - Cy, 2));\n        b = std::sqrt(pow(Cx - Ax, 2) + pow(Cy - Ay, 2));\n        c = std::sqrt(pow(Ax - Bx, 2) + pow(Ay - By, 2));\n        p = a + b + c;\n        s = p / 2;\n        \n//        std::cout << \"B: (\" << Bx << \",\" << By << \")\\n\";\n//        std::cout << \"C: (\" << Cx << \",\" << Cy << \")\\n\";\n//        std::cout << \"BC: \" << std::sqrt(pow(Bx-Cx, 2) + pow(By-Cy, 2)) << \"\\n\";\n//        std::cout << a << \" \" << b << \" \" << c << \" \" << perimeter << \" \" << semiperimeter << \"\\n\";\n        \n        Ix = ((a * Ax) + (b * Bx) + (c * Cx)) / p;\n        Iy = ((a * Ay) + (b * By) + (c * Cy)) / p;\n\n//        std::cout << \"I: (\" << Ix << \",\" << Iy << \")\\n\";\n        \n        r = (std::sqrt(s * (s - c) * (s - a) * (s - b))) / s;\n        \n        IA = std::sqrt(pow(Ax - Ix, 2) + pow(Ay - Iy, 2));\n        IB = std::sqrt(pow(Bx - Ix, 2) + pow(By - Iy, 2));\n        IC = std::sqrt(pow(Cx - Ix, 2) + pow(Cy - Iy, 2));\n\n        r1 = (r / (2 * (s - a))) * (s - r - IB - IC + IA);\n        r2 = (r / (2 * (s - b))) * (s - r - IC - IA + IB);\n        r3 = (r / (2 * (s - c))) * (s - r - IA - IB + IC);\n\n        \n        printf(\"%.6lf %.6lf %.6lf\\n\", r1, r2, r3);\n        \n        \n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<double,P> P2;\n\nconst double EPS = 1e-8;\nP v[3];\n\ndouble cross(P a, P b){ return imag(conj(a)*b);}\n\nP rotate(P p, double rad){\n  double x = real(p) * cos(rad) - imag(p) * sin(rad);\n  double y = real(p) * sin(rad) + imag(p) * cos(rad);\n  return P(x,y);\n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  return m.first + B / A * (m.second - m.first);\n}\n\ndouble areaV(){\n  double sum = 0.0;\n  for(int i=0;i<3;i++) sum += (real(v[i]) - real(v[(i+1)%3])) * (imag(v[i]) + imag(v[(i+1)%3]));\n  return abs(sum) / 2.0;\n}\n\nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\nP2 check2(P2 p, int pos){\n  double le = 0.1, ri = 2.0 * areaV() / (abs(v[1]-v[0]) + abs(v[2]-v[1]) + abs(v[0]-v[2]));\n  L l[2];\n  P2 res;\n  for(int i=0;i<1000;i++){\n    double mid = (le + ri) / 2.0;\n\n    for(int j=pos;j<pos+2;j++){\n      P a = (v[(j+1)%3]-v[j%3]) * mid / abs(v[(j+1)%3]-v[j%3]);\n      P b = rotate(a, M_PI/2.0);\n      l[j-pos] = L(v[(j+1)%3]+b, v[j%3]+b);\n    }\n    res = P2(mid, crossPoint(l[0],l[1]));\n\n    if(equal(abs(res.second-p.second), res.first+p.first)) return res;\n    else if(abs(res.second-p.second) < res.first+p.first) ri = mid;\n    else le = mid;\n  }\n}\n\nint check(double r){\n  L l[2];\n  P2 p[3];\n  for(int i=0;i<2;i++){\n    P a = (v[i+1]-v[i]) * r / abs(v[i+1]-v[i]);\n    P b = rotate(a, M_PI/2.0);\n    l[i] = L(v[i+1]+b, v[i]+b);\n  }\n  p[0] = P2(r, crossPoint(l[0],l[1]));\n\n\n  for(int i=1;i<3;i++) p[i] = check2(p[0], i);\n\n  if(equal(abs(p[2].second-p[1].second), p[2].first+p[1].first)){\n    printf(\"%.6f %.6f %.6f\\n\",p[2].first, p[0].first, p[1].first);\n    return 1;\n  }\n  else if(abs(p[2].second-p[1].second) < p[2].first+p[1].first) return 2;\n  else return 0;\n  \n}\n\nvoid solve(){\n  double le = 0.1, ri = 2.0 * areaV() / (abs(v[1]-v[0]) + abs(v[2]-v[1]) + abs(v[0]-v[2]));\n  while(1){\n    double mid = (le + ri) / 2.0;\n    int res = check(mid);\n    if(res == 0) ri = mid;\n    else if(res == 2) le = mid;\n    else return;\n  }\n}\n\nint main(){\n  int x[3],y[3];\n  while(cin >> x[0] >> y[0] >> x[1] >> y[1] >> x[2] >> y[2] && (x[0]|y[0]|x[1]|y[1]|x[2]|y[2])){\n    for(int i=0;i<3;i++) v[i] = P((double)x[i], (double)y[i]);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tVP p(3);\n\tfor (;;) {\n\t\trep(i, 3) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = { (double)x,(double)y };\n\t\t}\n\t\tif (p[0] == p[1])break;\n\t\tP up1 = (p[1] * abs(p[2] - p[0]) + p[2] * abs(p[1] - p[0])) / (abs(p[2] - p[0]) + abs(p[1] - p[0]));\n\t\tP dn1 = p[0];\n\t\tdouble r1,r2, r3;\n\t\trep(i, 70) {\n\t\t\tP m1 = (up1 + dn1) * 0.5l;\n\t\t\tr1 = dist_lp({ p[0],p[1] }, m1);\n\t\t\tP up2 = (p[0] * abs(p[2] - p[1]) + p[2] * abs(p[0] - p[1])) / (abs(p[2] - p[1]) + abs(p[0] - p[1]));\n\t\t\tP up3 = (p[0] * abs(p[2] - p[1]) + p[1] * abs(p[0] - p[2])) / (abs(p[2] - p[1]) + abs(p[0] - p[2]));\n\t\t\tP dn2 = p[1], dn3 = p[2];\n\t\t\trep(j, 70) {\n\t\t\t\tP m2 = (up2 + dn2)*0.5l, m3 = (up3 + dn3)*0.5l;\n\t\t\t\tr2 = dist_lp({ p[0],p[1] }, m2);\n\t\t\t\tr3 = dist_lp({ p[0],p[2] }, m3);\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[1],m2 }) && dist_lp({ p[0],p[2] }, m2) > r2 && abs(m1 - m2) > r1 + r2)dn2 = m2;\n\t\t\t\telse up2 = m2;\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[2],m3 }) && dist_lp({ p[0],p[1] }, m3) > r3 && abs(m3 - m1) > r1 + r3)dn3 = m3;\n\t\t\t\telse up3 = m3;\n\t\t\t}\n\t\t\tif (isis_ss({ p[1],up2 }, { p[2],up3 }) || abs(up2 - up3) < r2 + r3)dn1 = m1;\n\t\t\telse up1 = m1;\n\t\t}\n\t\tcout << fixed << setprecision(10) << r1 << \" \" << r2 << \" \" << r3 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\nint main(){\n  Polygon p(3);\n  while(cin>>p[0]>>p[1]>>p[2],!(p[0]==p[1])){\n    \n    Vector v[3][2],e[3];\n    v[0][0]=p[1]-p[0];\n    v[0][1]=p[2]-p[0];\n    v[1][0]=p[2]-p[1];\n    v[1][1]=p[0]-p[1];\n    v[2][0]=p[0]-p[2];\n    v[2][1]=p[1]-p[2];\n    for(int i=0;i<3;i++){\n      for(int j=0;j<2;j++)\n\tv[i][j]=v[i][j]/abs(v[i][j]);\n      e[i]=v[i][0]+v[i][1];\n      e[i]=e[i]/abs(e[i]);\n    }\n    \n    Circle c,c1,c2;\n    double l=0,r=abs(getCrossPointLL(Segment(p[1],p[2]),Segment(p[0],p[0]+e[0]))-p[0]);\n    for(int i=0;i<1000;i++){\n      double m=(l+r)/2;\n      c.c=p[0]+e[0]*m;\n      c.r=getDistanceLP(Segment(p[0],p[1]),c.c);\n      if(getDistanceLP(Segment(p[1],p[2]),c.c)<c.r){\n\tr=m;\n\tcontinue;\n      }\n      \n      double l1=0,r1=abs(getCrossPointLL(Segment(p[2],p[0]),Segment(p[1],p[1]+e[1]))-p[1]);\n      double l2=0,r2=abs(getCrossPointLL(Segment(p[0],p[1]),Segment(p[2],p[2]+e[2]))-p[2]);\n      for(int j=0;j<1000;j++){\n\tdouble m1=(l1+r1)/2,m2=(l2+r2)/2;\n\tc1.c=p[1]+e[1]*m1;c1.r=getDistanceLP(Segment(p[1],p[2]),c1.c);\n\tc2.c=p[2]+e[2]*m2;c2.r=getDistanceLP(Segment(p[2],p[0]),c2.c);\n\tif(getDistanceLP(Segment(p[2],p[0]),c1.c)<c.r) r1=m1;\n\telse if(abs(c1.c-c.c)<=c1.r+c.r) r1=m1;\n\telse l1=m1;\n        if(getDistanceLP(Segment(p[0],p[1]),c2.c)<c.r) r2=m2;\n\telse if(abs(c2.c-c.c)<=c2.r+c.r) r2=m2;\n\telse l2=m2;\n      }\n      if(abs(c1.c-c2.c)<=c1.r+c2.r) l=m;\n      else r=m;\n    }\n    printf(\"%.12f %.12f %.12f\\n\",c.r,c1.r,c2.r);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> point;\npoint p[5], q[5];\nconst double eps=1.0e-8;\nnamespace std{\n    bool operator == (const point& a, const point& b) {\n        return abs(a-b)<eps;\n    }\n}\nstruct line : public vector<point> {\n    line() {}\n    line(const point& a, const point& b) { push_back(a); push_back(b); }\n};\nstruct Circle{\n    point center;\n    double radius;\n    Circle(const point& c, const double& r):center(c),radius(r) {}\n};\npoint unit(const point& v) { return v/abs(v);}\npoint ortho(const point& v) { return v*point(0,1);}\npoint spin(const point& v, const double &angle) {return v*point(cos(angle),sin(angle));}\ninline point vec(const line& l) { return l[1]-l[0];}\ninline double dot  (const point& a, const point& b) { return (a*conj(b)).real();}\ninline double cross(const point& a, const point& b) { return (conj(a)*b).imag();}\npoint crosspoint(const line& l, const line& m) {\n    double A = cross(vec(l), vec(m));\n    double B = cross(vec(l), l[1]-m[0]);\n    if(abs(A)<eps) {    /// parallel\n        return m[0];    /// sameline\n    }\n    return m[0] + B/A*vec(m);\n}\npoint O;\nint cmp(const point& a, const point& b){\n    return arg(a-O)<arg(b-O);\n}\npoint solve(const point& x, const double& R, const double& angle, const line& p){\n    double l=0, r=1, mid;\n    point ret;\n    while(l+eps<r){\n        mid=(l+r)/2.0;\n        double radius=abs(vec(p))*mid*sin(angle);\n        point X=p[0]+abs(vec(p))*mid*unit(vec(p));\n        if(abs(X-x)>R+radius) l=mid;\n        else r=mid;\n        ret=X;\n    }\n//    printf(\"mid=%f\\n\",mid);\n    return ret;\n}\nint main(){\n    point A, B, C;\n    int ax, ay, bx, by, cx, cy;\n    while(cin>>ax>>ay>>bx>>by>>cx>>cy&&(ax||ay||bx||by||cx||cy)){\n        A=point(ax,ay); B=point(bx,by); C=point(cx,cy);\n        O=(A+B+C)/(double)3.0;\n        p[0]=A; p[1]=B; p[2]=C;\n        q[0]=A; q[1]=B; q[2]=C;\n        sort(p,p+3,cmp);\n        A=p[0], B=p[1], C=p[2];\n        line AB(A,B), BA(B,A), BC(B,C), CB(C,B), CA(C,A), AC(A,C); ///sides\n        double a, b, c; ///angle\n        double sa, sb, sc; ///side lengths\n        sa=abs(B-C), sb=abs(A-C), sc=abs(A-B);\n        a=acos((sb*sb+sc*sc-sa*sa)/(2*sb*sc));\n        b=acos((sa*sa+sc*sc-sb*sb)/(2*sa*sc));\n        c=acos((sb*sb+sa*sa-sc*sc)/(2*sb*sa));\n        line AP(A,A+spin(vec(AB),a/2)), BP(B,B+spin(vec(BC),b/2)), CP(C,C+spin(vec(CA),c/2));\n        point P=crosspoint(AP,BP); ///intersection\n        AP=line(A,P); BP=line(B,P); CP=line(C,P);\n        point lap=vec(AP);\n        double l, r, mid;\n        double ansx, ansy, ansz;\n        double ans[5], ret[5];\n        l=0, r=1;\n        double vy, vz;\n        while(l+eps<r){\n            mid=(l+r)/2.0;\n            point X=A+abs(lap)*mid*unit(lap);\n            double radiusX=abs(lap)*mid*sin(a/2);\n            Circle CX=Circle(X,radiusX);\n            point Y, Z, Z2;\n            Y=solve(X,radiusX,b/2,BP);\n            Z=solve(X,radiusX,c/2,CP);\n            double radiusY=abs(B-Y)*sin(b/2);\n            Z2=solve(Y,radiusY,c/2,CP);\n            if(abs(Z2-C)<abs(Z-C)){\n                Z=Z2;\n                l=mid;\n            }\n            else{\n                r=mid;\n            }\n            double radiusZ=abs(C-Z)*sin(c/2);\n            ansx=radiusX;\n            ansy=radiusY;\n            ansz=radiusZ;\n        }\n        ans[0]=ansx, ans[1]=ansy, ans[2]=ansz;\n        for(int i=0; i<3; i++){\n            if(p[i]==q[0]){\n                ret[0]=ans[i];\n            }\n            else if(p[i]==q[1]){\n                ret[1]=ans[i];\n            }\n            else if(p[i]==q[2]){\n                ret[2]=ans[i];\n            }\n        }\n        printf(\"%f %f %f\\n\",ret[0],ret[1],ret[2]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tVP p(3);\n\tfor (;;) {\n\t\trep(i, 3) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = { (double)x,(double)y };\n\t\t}\n\t\tif (p[0] == p[1])break;\n\t\tP up1 = (p[1] * abs(p[2] - p[0]) + p[2] * abs(p[1] - p[0])) / (abs(p[2] - p[0]) + abs(p[1] - p[0]));\n\t\tP dn1 = p[0];\n\t\tdouble r1, r2, r3;\n\t\trep(i, 80) {\n\t\t\tP m1 = (up1 + dn1) * 0.5;\n\t\t\tr1 = dist_lp({ p[0],p[1] }, m1);\n\t\t\tP up2 = (p[0] * abs(p[2] - p[1]) + p[2] * abs(p[0] - p[1])) / (abs(p[2] - p[1]) + abs(p[0] - p[1]));\n\t\t\tP up3 = (p[0] * abs(p[2] - p[1]) + p[1] * abs(p[0] - p[2])) / (abs(p[2] - p[1]) + abs(p[0] - p[2]));\n\t\t\tP dn2 = p[1], dn3 = p[2];\n\t\t\trep(j, 80) {\n\t\t\t\tP m2 = (up2 + dn2)*0.5, m3 = (up3 + dn3)*0.5;\n\t\t\t\tr2 = dist_lp({ p[0],p[1] }, m2);\n\t\t\t\tr3 = dist_lp({ p[0],p[2] }, m3);\n\t\t\t\tif (abs(m1 - m2) > r1 + r2)dn2 = m2;\n\t\t\t\telse up2 = m2;\n\t\t\t\tif (dist_lp({ p[0],p[1] }, m3) > r3 && abs(m3 - m1) > r1 + r3)dn3 = m3;\n\t\t\t\telse up3 = m3;\n\t\t\t}\n\t\t\tif (abs(up2 - up3) < r2 + r3)dn1 = m1;\n\t\t\telse up1 = m1;\n\t\t}\n\t\tcout << fixed << setprecision(10) << r1 << \" \" << r2 << \" \" << r3 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\n#include <fstream>\n#include <sstream>\nclass svg {\n\tofstream f;\n\tstringstream s;\n\tdouble x1 = 1e9, y1 = 1e9, x2 = -1e9, y2 = -1e9;\npublic:\n\tsvg(string path) :f(path, ios::trunc) {\n\t}\n\t~svg(){\n\t\tf << \"<?xml version=\\\"1.0\\\" standalone=\\\"no\\\"?><svg viewBox='\"<<x1*1.1-x2*0.1<<\" \"<<y1*1.1-y2*0.1<<\" \"<<(x2-x1)*1.2<<\" \"<<(y2-y1)*1.2<<\"' xmlns = \\\"http://www.w3.org/2000/svg\\\" xmlns:xlink = \\\"http://www.w3.org/1999/xlink\\\" >\\n\";\n\t\tf << s.str();\n\t\tf << \"</svg>\";\n\t}\n\tvoid circle(C c) {\n\t\ts << fixed << \"<circle cx = \\\"\" << c.p.real() << \"\\\" cy = \\\"\" << c.p.imag() << \"\\\" r = \\\"\" << c.r << \"\\\" stroke=\\\"black\\\" stroke-width=\\\"0.01\\\" fill = \\\"none\\\"/>\\n\";\n\t\tcmin(x1, c.p.real() - c.r);\n\t\tcmin(y1, c.p.imag() - c.r);\n\t\tcmax(x2, c.p.real() + c.r);\n\t\tcmax(y2, c.p.imag() + c.r);\n\t}\n\tvoid line(L l) {\n\t\ts << fixed << \"<line x1=\\\"\" << l.a.real() << \"\\\" y1=\\\"\" << l.a.imag() << \"\\\" x2=\\\"\" << l.b.real() << \"\\\" y2=\\\"\" << l.b.imag() << \"\\\" stroke=\\\"black\\\" stroke-width=\\\"0.01\\\"/>\\n\";\n\t\tcmin(x1, l.a.real());\n\t\tcmin(y1, l.a.imag());\n\t\tcmax(x2, l.a.real());\n\t\tcmax(y2, l.a.imag());\n\t\tcmin(x1, l.b.real());\n\t\tcmin(y1, l.b.imag());\n\t\tcmax(x2, l.b.real());\n\t\tcmax(y2, l.b.imag());\n\t}\n};\nint main() {\n\tVP p(3);\n\tfor (;;) {\n\t\trep(i, 3) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = { (double)x,(double)y };\n\t\t}\n\t\tif (p[0] == p[1])break;\n\t\tP up1 = (p[1] * abs(p[2] - p[0]) + p[2] * abs(p[1] - p[0])) / (abs(p[2] - p[0]) + abs(p[1] - p[0]));\n\t\tP dn1 = p[0];\n\t\tP up2, up3;\n\t\tdouble r1, r2, r3;\n\t\trep(i, 50) {\n\t\t\tP m1 = (up1 + dn1) * 0.5;\n\t\t\tr1 = dist_lp({ p[0],p[1] }, m1);\n\t\t\tup2 = (p[0] * abs(p[2] - p[1]) + p[2] * abs(p[0] - p[1])) / (abs(p[2] - p[1]) + abs(p[0] - p[1]));\n\t\t\tup3 = (p[0] * abs(p[2] - p[1]) + p[1] * abs(p[0] - p[2])) / (abs(p[2] - p[1]) + abs(p[0] - p[2]));\n\t\t\tP dn2 = p[1], dn3 = p[2];\n\t\t\trep(j, 50) {\n\t\t\t\tP m2 = (up2 + dn2)*0.5, m3 = (up3 + dn3)*0.5;\n\t\t\t\tr2 = dist_lp({ p[0],p[1] }, m2);\n\t\t\t\tr3 = dist_lp({ p[0],p[2] }, m3);\n\t\t\t\tif (!isis_ls({ p[0],up1 }, { p[1],m2 }) && dist_lp({ p[0],p[2] }, m2) > r2 && abs(m1 - m2) > r1 + r2)dn2 = m2;\n\t\t\t\telse up2 = m2;\n\t\t\t\tif (!isis_ls({ p[0],up1 }, { p[2],m3 }) && dist_lp({ p[0],p[1] }, m3) > r3 && abs(m3 - m1) > r1 + r3)dn3 = m3;\n\t\t\t\telse up3 = m3;\n\t\t\t}\n\t\t\tif (dist_lp({ p[1],p[2] }, m1) > r1&&abs(up2 - up3) < r2 + r3)dn1 = m1;\n\t\t\telse up1 = m1;\n\t\t}\n\t\tcout << fixed << setprecision(10) << r1 << \" \" << r2 << \" \" << r3 << endl;\n\t\tsvg s(\"out.svg\");\n\t\trep(i, 3)s.line({ p[i],p[(i + 1) % 3] });\n\t\ts.circle({ up1,r1 });\n\t\ts.circle({ up2,r2 });\n\t\ts.circle({ up3,r3 });\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tVP p(3);\n\tfor (;;) {\n\t\trep(i, 3) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = { (double)x,(double)y };\n\t\t}\n\t\tif (p[0] == p[1])break;\n\t\tP up1 = (p[1] * abs(p[2] - p[0]) + p[2] * abs(p[1] - p[0])) / (abs(p[2] - p[0]) + abs(p[1] - p[0]));\n\t\tP dn1 = p[0];\n\t\tdouble r1, r2, r3;\n\t\trep(i, 80) {\n\t\t\tP m1 = (up1 + dn1) * 0.5;\n\t\t\tr1 = dist_lp({ p[0],p[1] }, m1);\n\t\t\tP up2 = (p[0] * abs(p[2] - p[1]) + p[2] * abs(p[0] - p[1])) / (abs(p[2] - p[1]) + abs(p[0] - p[1]));\n\t\t\tP up3 = (p[0] * abs(p[2] - p[1]) + p[1] * abs(p[0] - p[2])) / (abs(p[2] - p[1]) + abs(p[0] - p[2]));\n\t\t\tP dn2 = p[1], dn3 = p[2];\n\t\t\trep(j, 80) {\n\t\t\t\tP m2 = (up2 + dn2)*0.5, m3 = (up3 + dn3)*0.5;\n\t\t\t\tr2 = dist_lp({ p[0],p[1] }, m2);\n\t\t\t\tr3 = dist_lp({ p[0],p[2] }, m3);\n\t\t\t\tif (abs(m1 - m2) > r1 + r2)dn2 = m2;\n\t\t\t\telse up2 = m2;\n\t\t\t\tif (dist_lp({ p[0],p[1] }, m3) > r3 && abs(m3 - m1) > r1 + r3)dn3 = m3;\n\t\t\t\telse up3 = m3;\n\t\t\t}\n\t\t\tif (isis_ss({ p[1],up2 }, { p[2],up3 }) || abs(up2 - up3) < r2 + r3)dn1 = m1;\n\t\t\telse up1 = m1;\n\t\t}\n\t\tcout << fixed << setprecision(10) << r1 << \" \" << r2 << \" \" << r3 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\nint main(){\n  Polygon p(3);\n  while(cin>>p[0]>>p[1]>>p[2],!(p[0]==p[1])){\n    \n    Vector v[3][2],e[3];\n    v[0][0]=p[1]-p[0];\n    v[0][1]=p[2]-p[0];\n    v[1][0]=p[2]-p[1];\n    v[1][1]=p[0]-p[1];\n    v[2][0]=p[0]-p[2];\n    v[2][1]=p[1]-p[2];\n    for(int i=0;i<3;i++){\n      for(int j=0;j<2;j++)\n\tv[i][j]=v[i][j]/abs(v[i][j]);\n      e[i]=v[i][0]+v[i][1];\n      e[i]=e[i]/abs(e[i]);\n    }\n    \n    Circle c,c1,c2;\n    double l=0,r=abs(getCrossPointLL(Segment(p[1],p[2]),Segment(p[0],p[0]+e[0]))-p[0]);\n    for(int i=0;i<100;i++){\n      double m=(l+r)/2;\n      c.c=p[0]+e[0]*m;\n      c.r=getDistanceLP(Segment(p[0],p[1]),c.c);\n      if(getDistanceLP(Segment(p[1],p[2]),c.c)<c.r){\n\tr=m;\n\tcontinue;\n      }\n      \n      double l1=0,r1=abs(getCrossPointLL(Segment(p[2],p[0]),Segment(p[1],p[1]+e[1]))-p[1]);\n      double l2=0,r2=abs(getCrossPointLL(Segment(p[0],p[1]),Segment(p[2],p[2]+e[2]))-p[2]);\n      for(int j=0;j<100;j++){\n\tdouble m1=(l1+r1)/2,m2=(l2+r2)/2;\n\tc1.c=p[1]+e[1]*m1;c1.r=getDistanceLP(Segment(p[1],p[2]),c1.c);\n\tc2.c=p[2]+e[2]*m2;c2.r=getDistanceLP(Segment(p[2],p[0]),c2.c);\n\tif(getDistanceLP(Segment(p[2],p[0]),c1.c)<c.r) r1=m1;\n\telse if(abs(c1.c-c.c)<=c1.r+c.r) r1=m1;\n\telse l1=m1;\n        if(getDistanceLP(Segment(p[0],p[1]),c2.c)<c.r) r2=m2;\n\telse if(abs(c2.c-c.c)<=c2.r+c.r) r2=m2;\n\telse l2=m2;\n      }\n      if(abs(c1.c-c2.c)<=c1.r+c2.r) l=m;\n      else r=m;\n    }\n    printf(\"%.12f %.12f %.12f\\n\",c.r,c1.r,c2.r);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<algorithm>\n\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\nint main(){\n\tfor(int x1,y1,x2,y2,x3,y3;scanf(\"%d%d%d%d%d%d\",&x1,&y1,&x2,&y2,&x3,&y3),x1||y1||x2||y2||x3||y3;){\n\t\tdouble a,b,c;\n\t\ta=hypot(x2-x3,y2-y3);\n\t\tb=hypot(x3-x1,y3-y1);\n\t\tc=hypot(x1-x2,y1-y2);\n\t\tdouble A,B,C;\n\t\tA=acos((b*b+c*c-a*a)/(2.*b*c))/2;\n\t\tB=acos((c*c+a*a-b*b)/(2.*c*a))/2;\n\t\tC=acos((a*a+b*b-c*c)/(2.*a*b))/2;\n\n\t\tdouble cotA,cotB,cotC;\n\t\tcotA=cos(A)/sin(A);\n\t\tcotB=cos(B)/sin(B);\n\t\tcotC=cos(C)/sin(C);\n\n\t\tdouble s=(a+b+c)/2;\n\t\tdouble area=sqrt(s*(s-a)*(s-b)*(s-c));\n\n\t\tdouble r1,r2,r3;\n\t\tdouble r1min=0.05,r1max=2*area/(a+b+c);\n\t\trep(i,50){\n\t\t\tr1=(r1min+r1max)/2;\n\t\t\tr2=(-sqrt(r1)+sqrt(r1+cotB*(c-r1*cotA)))/cotB;\tr2=r2*r2;\n\t\t\tr3=(-sqrt(r1)+sqrt(r1+cotC*(b-r1*cotA)))/cotC;\tr3=r3*r3;\n\t\t\tif(r2*cotB+2*sqrt(r2*r3)+r3*cotC<a)\tr1max=r1;\n\t\t\telse\t\t\t\t\t\t\t\tr1min=r1;\n\t\t}\n\t\tprintf(\"%f %f %f\\n\",r1,r2,r3);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n    // üªª½sÈêÍdÈÁÄ¢È¢±ÆÉ·é\n    if(abs(cross(a2-a1,b2-b1)) < EPS){\n        return 0;\n    }\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,a)>0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n\n// @üxNgðßé\nP unitVector(P a){\n\treturn P(-a.imag(),a.real());\n}\n// PÊ@üxNgðßé\nP unitNormalVector(P a,P b){\n\tP tmp=(b-a);\n\tP e=P(-tmp.imag(),tmp.real());\n\te/=abs(e);\n\treturn e;\n}\n\nP ap,bp,cp;\nP acp,bcp,ccp;\ndouble ar,br,cr;\n\nP selDot(P ab1_a,P ab1_b,P ab2_a,P ab2_b,P ac1_a,P ac1_b,P ac2_a,P ac2_b){\n\tP inDot=P(-1,-1);\n\t// »ê¼êÌð_ðßAOp`ÌÉÜÜêéàÌðIÔ\n\tif(isInTriangle(ap,bp,cp,intersection_l(ab1_a,ab1_b,ac1_a,ac1_b)))\n\t\tinDot=intersection_l(ab1_a,ab1_b,ac1_a,ac1_b);\n\telse if(isInTriangle(ap,bp,cp,intersection_l(ab1_a,ab1_b,ac2_a,ac2_b)))\n\t\tinDot=intersection_l(ab1_a,ab1_b,ac2_a,ac2_b);\n\telse if(isInTriangle(ap,bp,cp,intersection_l(ab2_a,ab2_b,ac2_a,ac2_b)))\n\t\tinDot=intersection_l(ab2_a,ab2_b,ac2_a,ac2_b);\n\telse if(isInTriangle(ap,bp,cp,intersection_l(ab2_a,ab2_b,ac1_a,ac1_b)))\n\t\tinDot=intersection_l(ab2_a,ab2_b,ac1_a,ac1_b);\n\treturn inDot;\n}\n\n// ~bÆ~cÌÖWð`FbN\nbool checkB(double r){\n\tP ba1_a,ba1_b,ba2_a,ba2_b;\n\tP bc1_a,bc1_b,bc2_a,bc2_b;\n\n\tP e1=unitNormalVector(bp,ap);\n\tP e2=unitNormalVector(bp,cp);\n\n\tba1_a=e1*r+bp;\n\tba1_b=e1*r+ap;\n\tba2_a=-e1*r+bp;\n\tba2_b=-e1*r+ap;\n\tbc1_a=e2*r+bp;\n\tbc1_b=e2*r+cp;\n\tbc2_a=-e2*r+bp;\n\tbc2_b=-e2*r+cp;\n\tP inDot=selDot(ba1_a,ba1_b,ba2_a,ba2_b,bc1_a,bc1_b,bc2_a,bc2_b);\n\t// ðð½·ð_ª¶ÝµÈ¢\n\tif(EQ(inDot.real(),-1))return false;\n\tbcp=inDot;\n\tbr=r;\n\t// ~aªOp`ÌOÉÍÝoÄ¢½çA»Ì_Åfalse\n\tdouble d1=distance_l_p(ap,bp,bcp);\n\tdouble d2=distance_l_p(bp,cp,bcp);\n\tdouble d3=distance_l_p(cp,ap,bcp);\n\tif((!EQ(d1,br)&&d1<br)||(!EQ(d2,br)&&d2<br)||(!EQ(d3,br)&&d3<br))return false;\n\t//~aÆdÈé©`FbN\n\t// dÈéÈçfalse\n\tif(abs(acp-bcp)<br+ar)return false;\n\treturn true;\n}\nbool checkC(double r){\n\tP ca1_a,ca1_b,ca2_a,ca2_b;\n\tP cb1_a,cb1_b,cb2_a,cb2_b;\n\n\tP e1=unitNormalVector(cp,ap);\n\tP e2=unitNormalVector(cp,bp);\n\n\tca1_a=e1*r+cp;\n\tca1_b=e1*r+ap;\n\tca2_a=-e1*r+cp;\n\tca2_b=-e1*r+ap;\n\tcb1_a=e2*r+cp;\n\tcb1_b=e2*r+bp;\n\tcb2_a=-e2*r+cp;\n\tcb2_b=-e2*r+bp;\n\tP inDot=selDot(ca1_a,ca1_b,ca2_a,ca2_b,cb1_a,cb1_b,cb2_a,cb2_b);\n\t// ðð½·ð_ª¶ÝµÈ¢\n\tif(EQ(inDot.real(),-1))return false;\n\tccp=inDot;\n\tcr=r;\n\tdouble d1=distance_l_p(ap,bp,ccp);\n\tdouble d2=distance_l_p(bp,cp,ccp);\n\tdouble d3=distance_l_p(cp,ap,ccp);\n\tif((!EQ(d1,cr)&&d1<cr)||(!EQ(d2,cr)&&d2<cr)||(!EQ(d3,cr)&&d3<cr))return false;\n\t//~aÆdÈé©`FbN\n\t// dÈéÈçfalse\n\tif(abs(ccp-acp)<cr+ar)return false;\n\treturn true;\n}\n\n// _AÉß¢~ð¼arÅu¯é©`FbN\nbool check(double r){\n\tP ab1_a,ab1_b;\n\tP ab2_a,ab2_b;\n\n\tP ac1_a,ac1_b;\n\tP ac2_b,ac2_a;\n\n\tP e1=unitNormalVector(ap,bp);\n\tP e2=unitNormalVector(ap,cp);\n\n\tab1_a=e1*r+ap;\n\tab1_b=e1*r+bp;\n\tab2_a=-e1*r+ap;\n\tab2_b=-e1*r+bp;\n\tac1_a=e2*r+ap;\n\tac1_b=e2*r+cp;\n\tac2_a=-e2*r+ap;\n\tac2_b=-e2*r+cp;\n\n\tP inDot=selDot(ab1_a,ab1_b,ab2_a,ab2_b,ac1_a,ac1_b,ac2_a,ac2_b);\n\t// ðð½·ð_ª¶ÝµÈ¢\n\tif(EQ(inDot.real(),-1))\n\t\treturn false;\n\tacp=inDot;\n\tar=r;\n\t// ~aªOp`ÌOÉÍÝoÄ¢½çA»Ì_Åfalse\n\tdouble d1=distance_l_p(ap,bp,acp);\n\tdouble d2=distance_l_p(ap,cp,acp);\n\tdouble d3=distance_l_p(bp,cp,acp);\n\tif((!EQ(d1,ar)&&d1<ar)||(!EQ(d2,ar)&&d2<ar)||(!EQ(d3,ar)&&d3<ar))return false;\n\t// _BÉß¢~Ì¼aÆS_ðßé\n\tdouble ub=10000000;\n\tdouble lb=0;\n\tint loop=100;\n\twhile(loop--){\n\t\tdouble mid=(ub+lb)/2;\n\t\tif(checkB(mid))lb=mid;\n\t\telse ub=mid;\n\t}\n\tbr=ub;\n\tub=10000000;\n\tlb=0;\n\tloop=100;\n\twhile(loop--){\n\t\tdouble mid=(ub+lb)/2;\n\t\tif(checkC(mid))lb=mid;\n\t\telse ub=mid;\n\t}\n\tcr=ub;\n\t// àµbÆcÌ~ª­ÁÂ©È¢ÈçAfalse\n\tif(abs(bcp-ccp)>cr+br)return false;\n\treturn true;\n}\n\nint main(){\n\n\tint x1,x2,x3,y1,y2,y3;\n\twhile(cin>>x1>>y1>>x2>>y2>>x3>>y3&&!(x1==0&&y1==0&&x2==0&&y2==0&&x3==0&&y3==0)){\n\t\tap=P(x1,y1);\n\t\tbp=P(x2,y2);\n\t\tcp=P(x3,y3);\n\t\tdouble ub=10000000;\n\t\tdouble lb=0;\n\t\tint loop=100;\n\t\tP acp;\n\t\twhile(loop--){\n\t\t\tdouble mid=(ub+lb)/2;\n\t\t\tif(check(mid))lb=mid;\n\t\t\telse ub=mid;\n\t\t}\n\t\tprintf(\"%.10f %.10f %.10f\\n\",ar,br,cr);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int LOOP = 80;\nconst double EPS = 1e-8;\nconst double eps = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;\nnamespace std{\n\tbool operator < (const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b){\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b){\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P>{\n\tL(){}\n\tL(const P &a, const P &b){\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\n\nstruct C{\n\tP p; double r;\n\tC(){}\n\tC(const P &p, double r) : p(p), r(r){}\n};\n\nint ccw(P a, P b, P c){\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;       // counter clockwise\n\tif(cross(b, c) < 0)   return -1;       // clockwise\n\tif(dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif(norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nP crosspoint(const L &l, const L &m){\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif(abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nint intersectCC(const C &c1, const C &c2){\n\tdouble d = std::abs(c1.p - c2.p), r1 = c1.r, r2 = c2.r;\n\tif(r1 + r2 < d) return 0;                   // ??¢????????????\n\tif(std::abs(r1 + r2 - d) < eps) return -2;  // ?????\\\n\tif(std::abs(d + r1 - r2) < eps) return +1;  // c1 ??? c2 ????????§?????\\\n\tif(std::abs(d + r2 - r1) < eps) return -1;  // c2 ??? c1 ????????§?????\\\n\tif(d + r1 < r2) return +3;                  // c1 ??? c2 ??????\n\tif(d + r2 < r1) return -3;                  // c2 ??? c1 ??????\n\treturn 2;                                    // 2?????????????????????\n}\n\nP projection(const L &l, const P &p){\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\n\ndouble distanceLP(const L &l, const P &p){\n\treturn abs(p - projection(l, p));\n}\n\nstd::vector<P> crosspointCL(const C &c, const L &l){\n\tstd::vector<P> res;\n\tdouble d = distanceLP(l, c.p);      // ????????¨??´???????????¢\n\tif(d > c.r) return res;  // ??¢????????????\n\n\tif(std::abs(d - c.r) < eps){  // ?§?????????????\n\t\tres.push_back(projection(l, c.p));\n\t\treturn res;\n\t}\n\tP h = projection(l, c.p);\n\tP u = std::sqrt(c.r * c.r - d * d) * (l[1] - l[0]) / std::abs(l[1] - l[0]);\n\tres.push_back(h + u);\n\tres.push_back(h - u);\n\treturn res;\n}\n\nP p[3];\nL ls[3];\nP no[3];\n\nbool InTriangle(P p){\n\tfor(int i = 0; i < 3; i++){\n\t\tif(ccw(ls[i][0], ls[i][1], p) != 1) return false;\n\t}\n\treturn true;\n}\n\nbool InTriangle(C c){\n\tfor(int i = 0; i < 3; i++){\n\t\tauto res = crosspointCL(c, ls[i]);\n\t\tif(res.size() == 2) return false;\n\t}\n\treturn true;\n}\n\nvoid PrintC(C c){\n\tcout << \"Circle \" << c.p.real() << \" \" << c.p.imag() << \" \" << c.r << endl;\n}\n\ndouble d(double x1, double y1, double x2, double y2){\n\tx1 -= x2, y1 -= y2;\n\treturn sqrt(x1 * x1 + y1 * y1);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\twhile(true){\n\t\tdouble sum = 0;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tsum += x + y;\n\t\t\tp[i] = P(x, y);\n\t\t}\n\t\tif(abs(sum) < 1e-6) break;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tP p1 = p[i], p2 = p[(i + 1) % 3];\n\t\t\tls[i] = L(p1, p2);\n\t\t\tdouble d = abs(p1 - p2);\n\t\t\tno[i] = (p2 - p1) / d * polar(1.0, PI / 2.0);\n\t\t}\n\n\t\tdouble lb1 = 1e-6, ub1 = 1e6;\n\t\tC c1, c2, c3;\n\t\tfor(int loop1 = 0; loop1 < LOOP; loop1++){\n\t\t\tdouble mid1 = (lb1 + ub1) / 2.0;\n\t\t\tP p1;\n\t\t\t{\n\t\t\t\tL l1 = ls[0], l2 = ls[1];\n\t\t\t\tl1[0] += no[0] * mid1;\n\t\t\t\tl1[1] += no[0] * mid1;\n\t\t\t\tl2[0] += no[1] * mid1;\n\t\t\t\tl2[1] += no[1] * mid1;\n\t\t\t\tp1 = crosspoint(l1, l2);\n\t\t\t\tif(!InTriangle(p1) || !InTriangle(C(p1, mid1))){\n\t\t\t\t\tub1 = mid1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc1 = C(p1, mid1);\n\n\t\t\tdouble lb2 = 1e-6, ub2 = 1e6;\n\t\t\tP p2;\n\n\t\t\tfor(int loop2 = 0; loop2 < LOOP; loop2++){\n\t\t\t\tdouble mid2 = (lb2 + ub2) / 2.0;\n\t\t\t\t{\n\t\t\t\t\tL l1 = ls[1], l2 = ls[2];\n\t\t\t\t\tl1[0] += no[1] * mid2;\n\t\t\t\t\tl1[1] += no[1] * mid2;\n\t\t\t\t\tl2[0] += no[2] * mid2;\n\t\t\t\t\tl2[1] += no[2] * mid2;\n\t\t\t\t\tp2 = crosspoint(l1, l2);\n\t\t\t\t\tif(!InTriangle(p2) || !InTriangle(C(p2, mid2)) || intersectCC(c1, C(p2, mid2)) != 0){\n\t\t\t\t\t\tub2 = mid2;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlb2 = mid2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tc2 = C(p2, lb2);\n\n\n\t\t\tdouble dist = abs(c1.p - c2.p);\n\t\t\tif(dist > c1.r + c2.r + eps){\n\t\t\t\tlb1 = mid1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//PrintC(c1);\n\t\t\t//PrintC(c2);\n\n\t\t\t// c1??¨??\\?????????c3????±???????\n\t\t\tdouble lb3 = 1e-6, ub3 = 1e6;\n\t\t\tP p3;\n\t\t\tfor(int loop2 = 0; loop2 < LOOP; loop2++){\n\t\t\t\tdouble mid3 = (lb3 + ub3) / 2.0;\n\t\t\t\t{\n\t\t\t\t\tL l1 = ls[2], l2 = ls[0];\n\t\t\t\t\tl1[0] += no[2] * mid3;\n\t\t\t\t\tl1[1] += no[2] * mid3;\n\t\t\t\t\tl2[0] += no[0] * mid3;\n\t\t\t\t\tl2[1] += no[0] * mid3;\n\t\t\t\t\tp3 = crosspoint(l1, l2);\n\t\t\t\t\tif(!InTriangle(p3) || !InTriangle(C(p3, mid3)) || intersectCC(c1, C(p3, mid3)) != 0){\n\t\t\t\t\t\tub3 = mid3;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlb3 = mid3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tc3 = C(p3, lb3);\n\n\t\t\tdist = abs(p2 - p3);\n\t\t\tif(dist > c2.r + c3.r) ub1 = mid1;\n\t\t\telse lb1 = mid1;\n\t\t\t//PrintC(c1);\n\t\t\t//PrintC(c2);\n\t\t\t//PrintC(c3);\n\t\t}\n\n\t\tcout << fixed << setprecision(15) << c3.r << \" \" << c1.r << \" \" << c2.r << endl;\n\t\t//PrintC(c1);\n\t\t//PrintC(c2);\n\t\t//PrintC(c3);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????\\??¢????????¶ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\n\nint cordx(Point p) { return 400 + static_cast<int>(zoom * (p.real() - centerX)); }\nint cordy(Point p) { return 400 - static_cast<int>(zoom * (p.imag() - centerY)); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\nint main() {\n\twhile (1) {\n\t\tvector<Point>ps;\n\t\tint x1, y1, x2, y2, x3, y3; cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tif (!x1&&!y1&&!x2&&!y2&&!x3&&!y3)break;\n\t\tps.push_back(Point(x1, y1));\n\t\tps.push_back(Point(x2, y2));\n\t\tps.push_back(Point(x3, y3));\n\t\tPoint nai = inner_center({ Line(ps[0], ps[1]), Line(ps[1], ps[2]), Line(ps[2], ps[0]) });\n\t\tld nair = dist_lp(Line(ps[0], ps[1]), nai);\n\t\tvector<ld>rs;\n\t\tvector<ld>as;\n\t\tvector<ld>ds;\n\t\tvector<ld>lens;\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tas.push_back(abs(ps[(i + 1) % 3] - ps[(i + 2) % 3]));\n\t\t\tds.push_back(abs(ps[i] - nai));\n\t\t}\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\trs.push_back(nair / (-as[i] + as[(i + 1) % 3] + as[(i + 2) % 3])*((as[0] + as[1] + as[2]) / 2 + ds[i] - nair - ds[(i + 1) % 3] - ds[(i + 2) % 3]));\n\t\t\tcout <<setprecision(22)<<fixed<< rs[i] << endl;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cstdio>\nusing namespace std;\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\n#define EPS 0.00001\n\nPoint A, B, C;\n\nvoid getR(double alpha, double beta, double l, double r, double R, double &ans, bool &suc){\n    double a, b, c;\n    a = 1.0/((tan(beta)*tan(beta)));\n    b = 2*r/(tan(alpha)*tan(beta)) - 2*l/tan(beta) - 4*r;\n    c = l*l - 2*r*l/tan(alpha) + r*r/(tan(alpha)*tan(alpha));\n    double rr1 = (-b - sqrt(b*b-4*a*c))/(2*a);\n    double rr2 = (-b + sqrt(b*b-4*a*c))/(2*a);\n    suc = false;\n    if ( 0 <= rr1 && rr1 <= R ) { ans = rr1; suc = true;}\n    if ( 0 <= rr2 && rr2 <= R ) { ans = rr2; suc = true;}\n}\n\nvoid compute(){\n    double a = abs(B - C), b = abs(A-C), c = abs(A-B), r1, r2, r3;\n    double s = (a + b + c)/2.0;\n    double R = sqrt(s*(s-a)*(s-b)*(s-c))/s;\n    double X = acos((c*c + b*b - a*a)/(2*c*b));\n    double Y = acos((c*c + a*a - b*b)/(2*c*a));\n    double Z = acos((a*a + b*b - c*c)/(2*a*b));\n    double l = 0, r = 2*R;\n    bool suc1, suc2;\n    while(1){\n\tr1 = (l + r)/2.0;\n\tgetR(X/2, Y/2, c, r1, R, r2, suc1);\n\tgetR(X/2, Z/2, b, r1, R, r3, suc2);\n\tVector v1 = A - B;\n\tVector v2 = A - C;\n\tv1 = polar(r2/sin(Y/2), arg(v1) - Y/2) + B; \n\tv2 = polar(r3/sin(Z/2), arg(v2) + Z/2) + C; \n\tdouble d = abs(v1 - v2);\n\tif ( fabs(d - (r2+r3)) < EPS ) break;\n\tif ( d < r2+r3 || !suc1 || !suc2) l = r1;\n\telse r = r1;\n    }\n    \n    printf(\"%.5lf %.5lf %.5lf\\n\", r1, r2, r3);\n}\n\nmain(){\n    while(1){\n\tcin >> A.real() >> A.imag();\n\tcin >> B.real() >> B.imag();\n\tcin >> C.real() >> C.imag();\n\tif ( A.real() == 0 && A.imag() == 0 && \n\t     B.real() == 0 && B.imag() == 0 && \n\t     C.real() == 0 && C.imag() == 0 ) break;\n\tcompute();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef complex<double> C;\n \nconst double EPS = 1e-10;\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\nconst ll INF = 100000000;\nconst ll MOD = 1000000007;\nC p[3];\n\ndouble cross(C a, C b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nC intersection_l(C a1, C a2, C b1, C b2) {\n  C a = a2 - a1; C b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nvoid solve() {\n    double l = min(abs(p[0]-p[1]), abs(p[0]-p[2]));\n\n    double lef = 0.0, rig = l;\n    C r1, r2, r3;\n    double d1, d2, d3;\n    rep(_,100) {\n        \n        double mid = (lef + rig) / 2.0;\n        C mp1 = p[0] + (p[1] - p[0]) / abs(p[1]-p[0]) * mid;\n        C mp2 = p[0] + (p[2] - p[0]) / abs(p[2]-p[0]) * mid;\n        C mp1t = mp1 + (p[1]-p[0])*C(0,1);\n        C mp2t = mp2 + (p[2]-p[0])*C(0,1);\n        r1 = intersection_l(mp1, mp1t, mp2, mp2t);\n        d1 = abs(r1 - mp1);\n\n        double l_2 = min(abs(p[1]-p[0]), abs(p[1]-p[2]));\n        double lef_2 = 0.0, rig_2 = l_2;\n        rep(__,100) {\n            double mid_2 = (lef_2 + rig_2) / 2.0;\n            C mp1_2 = p[1] + (p[0]-p[1]) / abs(p[0]-p[1]) * mid_2;\n            C mp2_2 = p[1] + (p[2]-p[1]) / abs(p[2]-p[1]) * mid_2;\n            C mp1t_2 = mp1_2 + (p[0]-p[1])*C(0,1);\n            C mp2t_2 = mp2_2 + (p[2]-p[1])*C(0,1);\n            r2 = intersection_l(mp1_2, mp1t_2, mp2_2, mp2t_2);\n            d2 = abs(r2 - mp1_2);\n            if (abs(r1-r2) < d1+d2) {\n                rig_2 = mid_2;\n            } else {\n                lef_2 = mid_2;\n            }\n        }\n\n        l_2 = min(abs(p[2]-p[0]), abs(p[2]-p[1]));\n        lef_2 = 0.0, rig_2 = l_2;\n        rep(__,100) {\n            double mid_2 = (lef_2 + rig_2) / 2.0;\n            C mp1_2 = p[2] + (p[0]-p[2]) / abs(p[0]-p[2]) * mid_2;\n            C mp2_2 = p[2] + (p[1]-p[2]) / abs(p[1]-p[2]) * mid_2;\n            C mp1t_2 = mp1_2 + (p[0]-p[2])*C(0,1);\n            C mp2t_2 = mp2_2 + (p[1]-p[2])*C(0,1);\n            r3 = intersection_l(mp1_2, mp1t_2, mp2_2, mp2t_2);\n            d3 = abs(r3 - mp1_2);\n            if (abs(r1-r3) < d1+d3) {\n                rig_2 = mid_2;\n            } else {\n                lef_2 = mid_2;\n            }\n        }\n        if (abs(r2-r3) < d2+d3) {\n            lef = mid;\n        } else {\n            rig = mid;\n        }\n    }\n    printf(\"%.9f %.9f %.9f\\n\", d1, d2, d3);\n}\n\nint main() {\n    int _x[3], _y[3];\n    while (cin >> _x[0] >> _y[0] >> _x[1] >> _y[1] >> _x[2] >> _y[2]) {\n        bool end = true;\n        rep(i,3) {\n            if (_x[i] || _y[i]) end = false;\n        }\n        if (end) break;\n        rep(i,3)  p[i] = C(_x[i], _y[i]);\n        solve();\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <iomanip>\nusing namespace std;\n\nlong double x[3], y[3], l[3], a[3], r[3];\n\t\nbool check() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (x[i] != 0) {\n\t\t\treturn true;\n\t\t}\n\t\tif (y[i] != 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nlong double quad(long double a, long double b, long double c) {\n\tlong double result;\n\tresult = pow(b,2)-4*a*c;\n\tif (result < 0) {\n\t\treturn -1;\n\t}\n\tresult = 2*b*sqrtl(result);\n\tresult = 2*pow(b,2)-4*a*c-result;\n\tresult /= 4*pow(a,2);\n\treturn result;\n}\n\nint main() {\n\tcout << fixed;\n\tcout << setprecision(6);\n\n\tint tmp;\n\tlong double value;\n\tlong double opp, hyp, adj;\n\tlong double dist;\n\tlong double diffx[2], diffy[2];\n\tlong double dirx, diry;\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tcin >> x[i];\n\t\tcin >> y[i];\n\t}\n\n\tint itr = 0;\n\twhile (check()) {\n\t\t//cout << itr++ << endl;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\ttmp = (i+1) % 3;\n\n\t\t\t//cout << pow(x[i] - x[tmp], 2) << \" \" << pow(y[i] - y[tmp], 2) << endl;\n\t\t\tl[i] = sqrtl(pow(x[i] - x[tmp], 2) +  pow(y[i] - y[tmp], 2));\n\t\t}\n\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\n\t\t\thyp = 2*l[i]*l[(i+2)%3];\n\t\t\tadj = pow(l[i], 2) + pow(l[(i+2)%3], 2) - pow(l[(i+1)%3], 2);\n\t\t\topp = sqrtl(pow(hyp,2)-pow(adj,2));\n\n\t\t\ta[i] = (hyp - adj) / opp;\n\t\t\t\n\n\t\t\t/*\n\t\t\ta[i] = pow(l[i],2) + pow(l[(i+2)%3],2) - pow(l[(i+1)%3],2);\n\t\t\ta[i] /= 2*l[i]*l[(i+2)%3];\n\t\t\ta[i] = acos(a[i]);\n\t\t\ta[i] = tan(a[i]/2);\n\t\t\t*/\n\t\t\t//cout << a[i] << endl;\n\t\t}\n\n\n\t\tlong double diff = min(l[0],l[2]);\n\t\tr[0] = 0.1;\n\n\t\t//r[0] = 21.565935;\n\t\t//r[1] = 24.409005;\n\t\t//r[2] = 27.107493;\n\n\t\twhile (diff > 1e-10) {\n\t\t//for (int i = 0; i < 10; i++) {\n\t\t\tr[0] += diff;\n\t\t\t//cout << \"START: \" << r[0] << endl;\n\n\n\t\t\tr[1] = quad(1/a[1], 2*sqrtl(r[0]), r[0]/a[0]-l[0]);\n\t\t\tr[2] = quad(1/a[2], 2*sqrtl(r[0]), r[0]/a[0]-l[2]);\n\n\t\t\tif (r[1] == -1 || r[2] == -1) {\n\t\t\t\tr[0] -= diff;\n\t\t\t\tdiff /= 10;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//cout << r[1] << \" \" << r[2] << endl;\n\t\t\t\n\t\t\tvalue = r[1]/a[1] + 2*sqrtl(r[1]*r[2]) + r[2]/a[2];\n\t\t\t//cout << \"ERROR: \" << value - l[1] << endl;\n\n\t\t\t//cout << r[0] << \" \" << r[1] << \" \" << r[2] << endl;\n\n\t\t\tif (value < l[1]) {\n\t\t\t\tr[0] -= diff;\n\t\t\t\tdiff /= 10;\n\t\t\t} else if (value == l[1]) {\n\t\t\t\tbreak;\n\t\t\t} \n\t\t}\n\n\t\tcout << r[0];\n\t\tfor (int i = 1; i < 3; i++) {\n\t\t\tcout << \" \" << r[i];\n\t\t}\n\t\tcout << endl;\n\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tcin >> x[i];\n\t\t\tcin >> y[i];\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    Set 6 A - Mathematics - Malfatti Circles\n    \n*/\n\n#include <iostream>\n#include <cmath>\n\n/* Distance from (x1,y1) to (x2,y2) */\ndouble dist(double x1, double y1, double x2, double y2)\n{\n    // std::cout << \"(\" << x1 << \", \" << y1 << \") to (\" << x2 << \", \" << y2 << \")\\n\";\n    // printf(\"sqrt( (%d - %d)^2 + (%d - %d)^2 )\\n\", y2, y1, x2, x1);\n    double a = (y2 - y1) * (y2 - y1);\n    double b = (x2 - x1) * (x2 - x1);\n    // std::cout << \"Sa:\" << a << \" Sb:\" << b << \"\\n\";\n    return std::sqrt( a + b );\n}\n\n/* Distance from point (x,y) to line (x1,y1) to (x2,y2)*/\ndouble dist(double x0, double y0, double x1, double y1, double x2, double y2)\n{\n    // frac f;\n    // f.first = std::abs((y2-y1)*x - (x2-x1)*y + x2*y1 - y2*x1);\n    // f.second = std::sqrt((y2-y1)*(y2-y1) + (x2-x1)*(x2-x1));\n    // return f;\n    return std::abs( (y2-y1)*x0 - (x2-x1)*y0 + x2*y1 - y2*x1 ) /\n           std::sqrt( (y2-y1)*(y2-y1) + (x2-x1)*(x2-x1) );\n}\n\n/* Return the incenter of a triangle */\nstd::pair<double, double>\nincenter (int Ax, int Ay, int Bx, int By, int Cx, int Cy, double a, double b, double c)\n{\n    std::pair<double, double> ret;\n    double p = a + b + c; // perimeter\n    ret.first = (a*Ax + b*Bx + c*Cx) / p;\n    ret.second = (a*Ay + b*By+ c*Cy) / p;\n    return ret;\n}\n\ndouble inradius(double a, double b, double c) {\n    double s = (a+b+c)/2;\n    double K = std::sqrt(s * (s - a) * (s - b) * (s - c));\n    return K / s;\n}\n\nint main()\n{\n    int Ax, Ay, Bx, By, Cx, Cy;\n    \n    // std::cout << \"Test: \" << dist(0, 5, 0, 0, 3, 3) << \"\\n\";\n    \n    while(std::cin >> Ax >> Ay >> Bx >> By >> Cx >> Cy) {\n        if (Ax == 0 && \n            Ay == 0 &&\n            Bx == 0 &&\n            By == 0 &&\n            Cx == 0 &&\n            Cy == 0) {\n            break;\n        }\n        \n        double r1, r2, r3;                 // radii\n        double a, b, c;                    // length of sides of triangle\n        double s;                          // semiperimeter of triangle\n        double r;                          // inradius of triangle\n        std::pair<double, double> tCentre; // incentre of triangle\n        double d, e, f;                    // dist from incenter to vertices\n        \n        a = dist(Bx, By, Cx, Cy);\n        b = dist(Ax, Ay, Cx, Cy);\n        c = dist(Ax, Ay, Bx, By);\n        // std::cout << \"a:\" << a << \" \\nb:\" << b << \" \\nc:\" << c << \"\\n\"; \n        \n        tCentre = incenter(Ax, Ay, Bx, By, Cx, Cy, a, b, c);\n        // std::cout << \"Ix:\" << tCentre.first << \" Iy:\" << tCentre.second << \"\\n\";\n        \n        s = (a + b + c) / 2;\n        r = inradius(a,b,c);\n        // std::cout << \"s:\" << s << \" \\nr:\" << r << \"\\n\";\n        \n        d = dist(tCentre.first, tCentre.second, Ax, Ay);\n        e = dist(tCentre.first, tCentre.second, Bx, By);\n        f = dist(tCentre.first, tCentre.second, Cx, Cy);\n\n        // std::cout << \"d:\" << d << \" \\ne:\" << e << \" \\nf:\" << f << \"\\n\";\n        \n        r1 = (r * (s + d - r - e - f)) / (2 * (s - a));\n        r2 = (r * (s + e - r - d - f)) / (2 * (s - b));\n        r3 = (r * (s + f - r - d - e)) / (2 * (s - c));\n        \n        std::cout << r1 << \" \" << r2 << \" \" << r3 << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-9)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\n//  ?§?????????????????????????\nLine getBisectorOfAngle(Point base,Point a,Point b){\n  Vector v1=(a-base),v2=(b-base);\n  double s=acos(dot(v1,v2)/(abs(v1)*abs(v2)))*360/(4*pi);\n  return Line(base,rotate(base,a,s));\n  //return Line(base,rotate(base,a,180-s));\n}\n\n//  ????§???¢???????§?????????????????????????\nLine getBisectorOfAngleInTriangle(Point base,Point a,Point b){\n  Line L=getBisectorOfAngle(base,a,b);\n  Point p=getCrossPointLL(Line(a,b),L);\n  return Segment(base,p);\n}\n\nPoint p1,p2,p3;\nSegment s1,s2,s3;\nLine L1,L2,L3;\nvector<double> ans;\n\nbool check(Line L,Point A,double a,double dis){\n  Vector V=(L.p2-L.p1)/abs(L.p2-L.p1);\n  Point P=L.p1+V*dis;\n  double d=getDistanceLP(s3,P);\n  if(((a+d)-abs(A-P))<eps)return true;\n  return false;\n}\n\nbool in(Point P,double r){\n  if(getDistanceLP(s1,P)-r<-eps)return false;\n  if(getDistanceLP(s2,P)-r<-eps)return false;\n  if(getDistanceLP(s3,P)-r<-eps)return false;\n  return true;\n}\n\nbool ok(double dis){\n  Vector V=(L1.p2-L1.p1)/abs(L1.p2-L1.p1);\n  Point A=L1.p1+V*dis;\n  double a,b,c,l,r,m;\n  a=getDistanceLP(s1,A);\n\n  l=0;r=abs(L2.p1-L2.p2);\n  for(int i=0;i<100;i++){\n    m=(l+r)/2.0;\n    if(check(L2,A,a,m))l=m;\n    else r=m;\n  }\n  V=(L2.p2-L2.p1)/abs(L2.p2-L2.p1);\n  Point B=L2.p1+V*m;\n  b=getDistanceLP(s3,B);\n  if(!in(B,b))return false;\n\n  l=0;r=abs(L3.p1-L3.p2);\n  for(int i=0;i<100;i++){\n    m=(l+r)/2.0;\n    if(check(L3,A,a,m))l=m;\n    else r=m;\n  }\n  V=(L3.p2-L3.p1)/abs(L3.p2-L3.p1);\n  Point C=L3.p1+V*m;\n  c=getDistanceLP(s3,C);\n  if(!in(C,c))return false;\n\n  if(equals(c+b,abs(C-B))){\n    ans.push_back(a);\n    ans.push_back(b);\n    ans.push_back(c);\n  }\n  //printf(\"%.10f %.10f %.10f %.10f\\n\",a,b,c,abs(C-B));\n  if(((c+b)-abs(C-B))<-eps)return true;\n  return false;\n}\n\nint main()\n{\n  int a,b,c,d,e,f;\n  while(1){\n    cin>>a>>b>>c>>d>>e>>f;\n    if(a+b+c+d+e+f==0)break;\n    p1=Point(a,b);\n    p2=Point(c,d);\n    p3=Point(e,f);\n    s1=Segment(p1,p2);\n    s2=Segment(p1,p3);\n    s3=Segment(p2,p3);\n    L1=getBisectorOfAngleInTriangle(p1,p2,p3);\n    L2=getBisectorOfAngleInTriangle(p2,p3,p1);\n    L3=getBisectorOfAngleInTriangle(p3,p1,p2);\n    Point cp=getCrossPointLL(L1,L2);\n    L1.p2=cp;\n    L2.p2=cp;\n    L3.p2=cp;\n    ans.clear();\n\n    double l=0,r=abs(L1.p2-L1.p1);\n    for(int i=0;i<100;i++){\n      double m=(l+r)/2.0;\n      if(ok(m))r=m;\n      else l=m;\n      if(!ans.empty())break;\n    }\n\n    printf(\"%.6f %.6f %.6f\\n\",ans[0],ans[1],ans[2]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntypedef complex<double> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tVP p(3);\n\tfor (;;) {\n\t\trep(i, 3) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = { (double)x,(double)y };\n\t\t}\n\t\tif (p[0] == p[1])break;\n\t\tP up1 = (p[1] * abs(p[2] - p[0]) + p[2] * abs(p[1] - p[0])) / (abs(p[2] - p[0]) + abs(p[1] - p[0]));\n\t\tP dn1 = p[0];\n\t\tdouble r1,r2, r3;\n\t\trep(i, 100) {\n\t\t\tP m1 = (up1 + dn1) * 0.5l;\n\t\t\tr1 = dist_lp({ p[0],p[1] }, m1);\n\t\t\tP up2 = (p[0] * abs(p[2] - p[1]) + p[2] * abs(p[0] - p[1])) / (abs(p[2] - p[1]) + abs(p[0] - p[1]));\n\t\t\tP up3 = (p[0] * abs(p[2] - p[1]) + p[1] * abs(p[0] - p[2])) / (abs(p[2] - p[1]) + abs(p[0] - p[2]));\n\t\t\tP dn2 = p[1], dn3 = p[2];\n\t\t\trep(j, 100) {\n\t\t\t\tP m2 = (up2 + dn2)*0.5l, m3 = (up3 + dn3)*0.5l;\n\t\t\t\tr2 = dist_lp({ p[0],p[1] }, m2);\n\t\t\t\tr3 = dist_lp({ p[0],p[2] }, m3);\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[1],m2 }) && dist_lp({ p[0],p[2] }, m2) > r2 && abs(m1 - m2) > r1 + r2)dn2 = m2;\n\t\t\t\telse up2 = m2;\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[2],m3 }) && dist_lp({ p[0],p[1] }, m3) > r3 && abs(m3 - m1) > r1 + r3)dn3 = m3;\n\t\t\t\telse up3 = m3;\n\t\t\t}\n\t\t\tif (isis_ss({ p[1],up2 }, { p[2],up3 }) || abs(up2 - up3) < r2 + r3)dn1 = m1;\n\t\t\telse up1 = m1;\n\t\t}\n\t\tcout << fixed << setprecision(10) << r1 << \" \" << r2 << \" \" << r3 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tVP p(3);\n\tfor (;;) {\n\t\trep(i, 3) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = { (double)x,(double)y };\n\t\t}\n\t\tif (p[0] == p[1])break;\n\t\tP up1 = (p[1] * abs(p[2] - p[0]) + p[2] * abs(p[1] - p[0])) / (abs(p[2] - p[0]) + abs(p[1] - p[0]));\n\t\tP dn1 = p[0];\n\t\tdouble r1,r2, r3;\n\t\trep(i, 60) {\n\t\t\tP m1 = (up1 + dn1) * 0.5l;\n\t\t\tr1 = dist_lp({ p[0],p[1] }, m1);\n\t\t\tP up2 = (p[0] * abs(p[2] - p[1]) + p[2] * abs(p[0] - p[1])) / (abs(p[2] - p[1]) + abs(p[0] - p[1]));\n\t\t\tP up3 = (p[0] * abs(p[2] - p[1]) + p[1] * abs(p[0] - p[2])) / (abs(p[2] - p[1]) + abs(p[0] - p[2]));\n\t\t\tP dn2 = p[1], dn3 = p[2];\n\t\t\trep(j, 60) {\n\t\t\t\tP m2 = (up2 + dn2)*0.5l, m3 = (up3 + dn3)*0.5l;\n\t\t\t\tr2 = dist_lp({ p[0],p[1] }, m2);\n\t\t\t\tr3 = dist_lp({ p[0],p[2] }, m3);\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[1],m2 }) && dist_lp({ p[0],p[2] }, m2) > r2 && abs(m1 - m2) > r1 + r2)dn2 = m2;\n\t\t\t\telse up2 = m2;\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[2],m3 }) && dist_lp({ p[0],p[1] }, m3) > r3 && abs(m3 - m1) > r1 + r3)dn3 = m3;\n\t\t\t\telse up3 = m3;\n\t\t\t}\n\t\t\tif (isis_ss({ p[1],up2 }, { p[2],up3 }) || abs(up2 - up3) < r2 + r3)dn1 = m1;\n\t\t\telse up1 = m1;\n\t\t}\n\t\tcout << fixed << setprecision(10) << r1 << \" \" << r2 << \" \" << r3 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  A_-_Malfatti_Circles\n//\n//  Created by Andy on 7/5/18.\n//  Copyright © 2018 Andy. All rights reserved.\n//\n\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n\n\ndouble Ax, Ay, Bx, By, Cx, Cy;\ndouble a, b, c, p, s, r;\ndouble Ix, Iy;\ndouble IA, IB, IC;\ndouble r1, r2, r3;\n\n\nint main(int argc, const char * argv[]) {\n\n    while (true) {\n        scanf(\"%lf %lf %lf %lf %lf %lf\", &Ax, &Ay, &Bx, &By, &Cx, &Cy);\n        if (Ax == Bx && Bx == Cx && Ax == Ay && Ay == By && By == Cy && Cy == 0) break;\n        \n        a = std::sqrt(pow(Bx - Cx, 2) + pow(By - Cy, 2));\n        b = std::sqrt(pow(Cx - Ax, 2) + pow(Cy - Ay, 2));\n        c = std::sqrt(pow(Ax - Bx, 2) + pow(Ay - By, 2));\n        p = a + b + c;\n        s = p / 2;\n        \n//        std::cout << \"B: (\" << Bx << \",\" << By << \")\\n\";\n//        std::cout << \"C: (\" << Cx << \",\" << Cy << \")\\n\";\n//        std::cout << \"BC: \" << std::sqrt(pow(Bx-Cx, 2) + pow(By-Cy, 2)) << \"\\n\";\n//        std::cout << a << \" \" << b << \" \" << c << \" \" << perimeter << \" \" << semiperimeter << \"\\n\";\n        \n        Ix = ((a * Ax) + (b * Bx) + (c * Cx)) / p;\n        Iy = ((a * Ay) + (b * By) + (c * Cy)) / p;\n\n//        std::cout << \"I: (\" << Ix << \",\" << Iy << \")\\n\";\n        \n        r = (std::sqrt(s * (s - c) * (s - a) * (s - b))) / s;\n        \n        IA = std::sqrt(pow(Ax - Ix, 2) + pow(Ay - Iy, 2));\n        IB = std::sqrt(pow(Bx - Ix, 2) + pow(By - Iy, 2));\n        IC = std::sqrt(pow(Cx - Ix, 2) + pow(Cy - Iy, 2));\n\n        r1 = (r / (2 * (s - a))) * (s - r - IB - IC + IA);\n        r2 = (r / (2 * (s - b))) * (s - r - IC - IA + IB);\n        r3 = (r / (2 * (s - c))) * (s - r - IA - IB + IC);\n\n        \n        printf(\"%.6lf %.6lf %.6lf\\n\", r1, r2, r3);\n        \n        \n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst int nrep = 30;\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : VP{\n    L(const P& a, const P& b){ resize(2); at(0)=a; at(1)=b; }\n    L(){ resize(2); }\n};\nstruct C{\n    P p;\n    double r;\n    C(const P& p, const double& r) : p(p), r(r) {}\n    C(){}\n};\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\n\nP projection(const L& l, const P& p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n}\n\nint main(){\n\twhile(1){\n\t\tvector<int> input(6);\n\t\tbool allzero = true;\n\t\tfor(int i=0; i<6; i++){\n\t\t\tcin >> input[i];\n\t\t\tif(input[i]!=0) allzero = false;\n\t\t}\n\t\tif(allzero) break;\n\t\t\n\t\tVP v(3);\n\t\tfor(int i=0; i<3; i++){\n\t\t\tv[i] = P(input[2*i], input[2*i+1]);\n\t\t}\n\t\t\n\t\tVP bisection(3);\n\t\tfor(int i=0; i<3; i++){\n\t\t\tdouble a = abs(v[(i+1)%3] -v[i]), b = abs(v[(i+2)%3] -v[i]);\n\t\t\tbisection[i] = v[(i+1)%3] + (v[(i+2)%3]-v[(i+1)%3])* a/(a+b);\n\t\t}\n\t\t\n\t\tC c[3];\n\t\tP b = v[0], e = bisection[0];\n\t\tfor(int i=0; i<nrep; i++){\n\t\t\tP mid = 0.5*(b+e);\n\t\t\tc[0] = C(mid, distanceLP(L(v[0], v[1]), mid));\n\t\t\tif(distanceLP(L(v[1], v[2]), mid) < c[0].r +EPS){\n\t\t\t\te = mid;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=1; j<=2; j++){\n\t\t\t\tP b = v[j], e = bisection[j];\n\t\t\t\tfor(int k=0; k<nrep; k++){\n\t\t\t\t\tP mid = 0.5*(b+e);\n\t\t\t\t\tc[j] = C(mid, distanceLP(L(v[1], v[2]), mid));\n\t\t\t\t\tif(distanceLP(L(v[(j+1)%3], v[(j+2)%3]), mid) < c[j].r +EPS){\n\t\t\t\t\t\te = mid;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(abs(c[0].p -c[j].p) < c[0].r+c[j].r){\n\t\t\t\t\t\te = mid;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tb = mid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(abs(c[1].p -c[2].p) < c[1].r+c[2].r){\n\t\t\t\tb = mid;\n\t\t\t}else{\n\t\t\t\te = mid;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << fixed;\n\t\tcout << setprecision(10);\n\t\tcout << c[0].r << \" \" << c[1].r << \" \" << c[2].r << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n    // üªª½sÈêÍdÈÁÄ¢È¢±ÆÉ·é\n    if(abs(cross(a2-a1,b2-b1)) < EPS){\n        return 0;\n    }\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,a)>0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n\n// @üxNgðßé\nP unitVector(P a){\n\treturn P(-a.imag(),a.real());\n}\n// PÊ@üxNgðßé\nP unitNormalVector(P a,P b){\n\tP tmp=(b-a);\n\tP e=P(-tmp.imag(),tmp.real());\n\te/=abs(e);\n\treturn e;\n}\n\nP ap,bp,cp;\nP acp,bcp,ccp;\ndouble ar,br,cr;\n\nP selDot(P &ab1_a,P &ab1_b,P &ab2_a,P &ab2_b,P &ac1_a,P &ac1_b,P& ac2_a,P &ac2_b){\n\tP inDot=P(-1,-1);\n\t// »ê¼êÌð_ðßAOp`ÌÉÜÜêéàÌðIÔ\n\tif(isInTriangle(ap,bp,cp,intersection_l(ab1_a,ab1_b,ac1_a,ac1_b)))\n\t\tinDot=intersection_l(ab1_a,ab1_b,ac1_a,ac1_b);\n\telse if(isInTriangle(ap,bp,cp,intersection_l(ab1_a,ab1_b,ac2_a,ac2_b)))\n\t\tinDot=intersection_l(ab1_a,ab1_b,ac2_a,ac2_b);\n\telse if(isInTriangle(ap,bp,cp,intersection_l(ab2_a,ab2_b,ac2_a,ac2_b)))\n\t\tinDot=intersection_l(ab2_a,ab2_b,ac2_a,ac2_b);\n\telse if(isInTriangle(ap,bp,cp,intersection_l(ab2_a,ab2_b,ac1_a,ac1_b)))\n\t\tinDot=intersection_l(ab2_a,ab2_b,ac1_a,ac1_b);\n\treturn inDot;\n}\n\n// ~bÆ~cÌÖWð`FbN\nbool checkB(double r){\n\tP ba1_a,ba1_b,ba2_a,ba2_b;\n\tP bc1_a,bc1_b,bc2_a,bc2_b;\n\n\tP e1=unitNormalVector(bp,ap);\n\tP e2=unitNormalVector(bp,cp);\n\n\tba1_a=e1*r+bp;\n\tba1_b=e1*r+ap;\n\tba2_a=-e1*r+bp;\n\tba2_b=-e1*r+ap;\n\tbc1_a=e2*r+bp;\n\tbc1_b=e2*r+cp;\n\tbc2_a=-e2*r+bp;\n\tbc2_b=-e2*r+cp;\n\tP inDot=selDot(ba1_a,ba1_b,ba2_a,ba2_b,bc1_a,bc1_b,bc2_a,bc2_b);\n\t// ðð½·ð_ª¶ÝµÈ¢\n\tif(EQ(inDot.real(),-1))return false;\n\tbcp=inDot;\n\tbr=r;\n\t// ~aªOp`ÌOÉÍÝoÄ¢½çA»Ì_Åfalse\n\tdouble d1=distance_l_p(ap,bp,bcp);\n\tdouble d2=distance_l_p(bp,cp,bcp);\n\tdouble d3=distance_l_p(cp,ap,bcp);\n\tif((!EQ(d1,br)&&d1<br)||(!EQ(d2,br)&&d2<br)||(!EQ(d3,br)&&d3<br))return false;\n\t//~aÆdÈé©`FbN\n\t// dÈéÈçfalse\n\tif(abs(acp-bcp)<br+ar)return false;\n\treturn true;\n}\nbool checkC(double r){\n\tP ca1_a,ca1_b,ca2_a,ca2_b;\n\tP cb1_a,cb1_b,cb2_a,cb2_b;\n\n\tP e1=unitNormalVector(cp,ap);\n\tP e2=unitNormalVector(cp,bp);\n\n\tca1_a=e1*r+cp;\n\tca1_b=e1*r+ap;\n\tca2_a=-e1*r+cp;\n\tca2_b=-e1*r+ap;\n\tcb1_a=e2*r+cp;\n\tcb1_b=e2*r+bp;\n\tcb2_a=-e2*r+cp;\n\tcb2_b=-e2*r+bp;\n\tP inDot=selDot(ca1_a,ca1_b,ca2_a,ca2_b,cb1_a,cb1_b,cb2_a,cb2_b);\n\t// ðð½·ð_ª¶ÝµÈ¢\n\tif(EQ(inDot.real(),-1))return false;\n\tccp=inDot;\n\tcr=r;\n\tdouble d1=distance_l_p(ap,bp,ccp);\n\tdouble d2=distance_l_p(bp,cp,ccp);\n\tdouble d3=distance_l_p(cp,ap,ccp);\n\tif((!EQ(d1,cr)&&d1<cr)||(!EQ(d2,cr)&&d2<cr)||(!EQ(d3,cr)&&d3<cr))return false;\n\t//~aÆdÈé©`FbN\n\t// dÈéÈçfalse\n\tif(abs(ccp-acp)<cr+ar)return false;\n\treturn true;\n}\n\n// _AÉß¢~ð¼arÅu¯é©`FbN\nbool check(double r){\n\tP ab1_a,ab1_b;\n\tP ab2_a,ab2_b;\n\n\tP ac1_a,ac1_b;\n\tP ac2_b,ac2_a;\n\n\tP e1=unitNormalVector(ap,bp);\n\tP e2=unitNormalVector(ap,cp);\n\n\tab1_a=e1*r+ap;\n\tab1_b=e1*r+bp;\n\tab2_a=-e1*r+ap;\n\tab2_b=-e1*r+bp;\n\tac1_a=e2*r+ap;\n\tac1_b=e2*r+cp;\n\tac2_a=-e2*r+ap;\n\tac2_b=-e2*r+cp;\n\n\tP inDot=selDot(ab1_a,ab1_b,ab2_a,ab2_b,ac1_a,ac1_b,ac2_a,ac2_b);\n\t// ðð½·ð_ª¶ÝµÈ¢\n\tif(EQ(inDot.real(),-1))\n\t\treturn false;\n\tacp=inDot;\n\tar=r;\n\t// ~aªOp`ÌOÉÍÝoÄ¢½çA»Ì_Åfalse\n\tdouble d1=distance_l_p(ap,bp,acp);\n\tdouble d2=distance_l_p(ap,cp,acp);\n\tdouble d3=distance_l_p(bp,cp,acp);\n\tif((!EQ(d1,ar)&&d1<ar)||(!EQ(d2,ar)&&d2<ar)||(!EQ(d3,ar)&&d3<ar))return false;\n\t// _BÉß¢~Ì¼aÆS_ðßé\n\tdouble ub=10000000;\n\tdouble lb=0;\n\tint loop=100;\n\twhile(loop--){\n\t\tdouble mid=(ub+lb)/2;\n\t\tif(checkB(mid))lb=mid;\n\t\telse ub=mid;\n\t}\n\tbr=ub;\n\tub=10000000;\n\tlb=0;\n\tloop=100;\n\twhile(loop--){\n\t\tdouble mid=(ub+lb)/2;\n\t\tif(checkC(mid))lb=mid;\n\t\telse ub=mid;\n\t}\n\tcr=ub;\n\t// àµbÆcÌ~ª­ÁÂ©È¢ÈçAfalse\n\tif(abs(bcp-ccp)>cr+br)return false;\n\treturn true;\n}\n\nint main(){\n\n\tint x1,x2,x3,y1,y2,y3;\n\twhile(cin>>x1>>y1>>x2>>y2>>x3>>y3&&!(x1==0&&y1==0&&x2==0&&y2==0&&x3==0&&y3==0)){\n\t\tap=P(x1,y1);\n\t\tbp=P(x2,y2);\n\t\tcp=P(x3,y3);\n\t\tdouble ub=10000000;\n\t\tdouble lb=0;\n\t\tint loop=100;\n\t\tP acp;\n\t\twhile(loop--){\n\t\t\tdouble mid=(ub+lb)/2;\n\t\t\tif(check(mid))lb=mid;\n\t\t\telse ub=mid;\n\t\t}\n\t\tprintf(\"%.10f %.10f %.10f\\n\",ar,br,cr);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Taimur Azhar z5116684\n// Prog Chal\n// Week 6 Problem A - Malfatti Circles\n\n#include <stdlib.h>\n#include <iostream>  \n#include <cmath> \n\nusing namespace std;  \n\nstruct Point{  \n    double x,y;  \n}p1,p2,p3,ic; \n\ndouble dist(Point p1,Point p2) {  \n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));  \n}  \n\nint main() {    \n    while(cin >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y) {\n        if ((p1.x == 0) && (p1.y == 0) && (p2.x == 0) && (p2.y == 0) && (p3.x == 0) && (p3.y == 0)) break;\n        \n        // Distance of each line in the triangle\n        double a = dist(p2, p3);  \n        double b = dist(p1, p3);  \n        double c = dist(p1, p2);  \n        // Semiperimeter\n        double s = (a + b + c) / 2;  \n        // Incentre of the triangle\n        ic.x = (a * A.x + b * B.x + c * C.x) / (a + b + c);  \n        ic.y = (a * A.y + b * B.y + c * C.y) / (a + b + c);\n        // Inneradius\n        double ir = sqrt(s * (s - a) * (s - b) * (s - c)) / s; \n        // The three distances from the incentre\n        double d = dist(p1, ic);  \n        double e = dist(p2, ic);  \n        double f = dist(p3, ic);  \n        // Each radii\n        double r1 = r / (2 * (s - a)) * (s + d - r - e - f);  \n        double r2 = r / (2 * (s - b)) * (s + e - r - d - f);  \n        double r3 = r / (2 * (s - c)) * (s + f - r - d - e);  \n\n        cout << setprecision(9) << r1 << \" \" << r2 << \" \" << r3 << \" \" << endl;\n    }\n    return 0;  \n}  \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\nifstream ifs(\"input.txt\");\n#define cin ifs\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n    // üªª½sÈêÍdÈÁÄ¢È¢±ÆÉ·é\n    if(abs(cross(a2-a1,b2-b1)) < EPS){\n        return 0;\n    }\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,a)>0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n\n// @üxNgðßé\nP unitVector(P a){\n\treturn P(-a.imag(),a.real());\n}\n// PÊ@üxNgðßé\nP unitNormalVector(P a,P b){\n\tP tmp=(b-a);\n\tP e=P(-tmp.imag(),tmp.real());\n\te/=abs(e);\n\treturn e;\n}\n\nP ap,bp,cp;\nP acp,bcp,ccp;\ndouble ar,br,cr;\n\nP selDot(P &ab1_a,P &ab1_b,P &ab2_a,P &ab2_b,P &ac1_a,P &ac1_b,P& ac2_a,P &ac2_b){\n\tP inDot=P(-1,-1);\n\t// »ê¼êÌð_ðßAOp`ÌÉÜÜêéàÌðIÔ\n\tif(isInTriangle(ap,bp,cp,intersection_l(ab1_a,ab1_b,ac1_a,ac1_b)))\n\t\tinDot=intersection_l(ab1_a,ab1_b,ac1_a,ac1_b);\n\telse if(isInTriangle(ap,bp,cp,intersection_l(ab1_a,ab1_b,ac2_a,ac2_b)))\n\t\tinDot=intersection_l(ab1_a,ab1_b,ac2_a,ac2_b);\n\telse if(isInTriangle(ap,bp,cp,intersection_l(ab2_a,ab2_b,ac2_a,ac2_b)))\n\t\tinDot=intersection_l(ab2_a,ab2_b,ac2_a,ac2_b);\n\telse if(isInTriangle(ap,bp,cp,intersection_l(ab2_a,ab2_b,ac1_a,ac1_b)))\n\t\tinDot=intersection_l(ab2_a,ab2_b,ac1_a,ac1_b);\n\treturn inDot;\n}\n\n// ~bÆ~cÌÖWð`FbN\nbool checkB(double r){\n\tP ba1_a,ba1_b,ba2_a,ba2_b;\n\tP bc1_a,bc1_b,bc2_a,bc2_b;\n\n\tP e1=unitNormalVector(bp,ap);\n\tP e2=unitNormalVector(bp,cp);\n\n\tba1_a=e1*r+bp;\n\tba1_b=e1*r+ap;\n\tba2_a=-e1*r+bp;\n\tba2_b=-e1*r+ap;\n\tbc1_a=e2*r+bp;\n\tbc1_b=e2*r+cp;\n\tbc2_a=-e2*r+bp;\n\tbc2_b=-e2*r+cp;\n\tP inDot=selDot(ba1_a,ba1_b,ba2_a,ba2_b,bc1_a,bc1_b,bc2_a,bc2_b);\n\t// ðð½·ð_ª¶ÝµÈ¢\n\tif(EQ(inDot.real(),-1))return false;\n\tbcp=inDot;\n\tbr=r;\n\t// ~aªOp`ÌOÉÍÝoÄ¢½çA»Ì_Åfalse\n\tdouble d1=distance_l_p(ap,bp,bcp);\n\tdouble d2=distance_l_p(bp,cp,bcp);\n\tdouble d3=distance_l_p(cp,ap,bcp);\n\tif((!EQ(d1,br)&&d1<br)||(!EQ(d2,br)&&d2<br)||(!EQ(d3,br)&&d3<br))return false;\n\t//~aÆdÈé©`FbN\n\t// dÈéÈçfalse\n\tif(abs(acp-bcp)<br+ar)return false;\n\treturn true;\n}\nbool checkC(double r){\n\tP ca1_a,ca1_b,ca2_a,ca2_b;\n\tP cb1_a,cb1_b,cb2_a,cb2_b;\n\n\tP e1=unitNormalVector(cp,ap);\n\tP e2=unitNormalVector(cp,bp);\n\n\tca1_a=e1*r+cp;\n\tca1_b=e1*r+ap;\n\tca2_a=-e1*r+cp;\n\tca2_b=-e1*r+ap;\n\tcb1_a=e2*r+cp;\n\tcb1_b=e2*r+bp;\n\tcb2_a=-e2*r+cp;\n\tcb2_b=-e2*r+bp;\n\tP inDot=selDot(ca1_a,ca1_b,ca2_a,ca2_b,cb1_a,cb1_b,cb2_a,cb2_b);\n\t// ðð½·ð_ª¶ÝµÈ¢\n\tif(EQ(inDot.real(),-1))return false;\n\tccp=inDot;\n\tcr=r;\n\tdouble d1=distance_l_p(ap,bp,ccp);\n\tdouble d2=distance_l_p(bp,cp,ccp);\n\tdouble d3=distance_l_p(cp,ap,ccp);\n\tif((!EQ(d1,cr)&&d1<cr)||(!EQ(d2,cr)&&d2<cr)||(!EQ(d3,cr)&&d3<cr))return false;\n\t//~aÆdÈé©`FbN\n\t// dÈéÈçfalse\n\tif(abs(ccp-acp)<cr+ar)return false;\n\treturn true;\n}\n\n// _AÉß¢~ð¼arÅu¯é©`FbN\nbool check(double r){\n\tP ab1_a,ab1_b;\n\tP ab2_a,ab2_b;\n\n\tP ac1_a,ac1_b;\n\tP ac2_b,ac2_a;\n\n\tP e1=unitNormalVector(ap,bp);\n\tP e2=unitNormalVector(ap,cp);\n\n\tab1_a=e1*r+ap;\n\tab1_b=e1*r+bp;\n\tab2_a=-e1*r+ap;\n\tab2_b=-e1*r+bp;\n\tac1_a=e2*r+ap;\n\tac1_b=e2*r+cp;\n\tac2_a=-e2*r+ap;\n\tac2_b=-e2*r+cp;\n\n\tP inDot=selDot(ab1_a,ab1_b,ab2_a,ab2_b,ac1_a,ac1_b,ac2_a,ac2_b);\n\t// ðð½·ð_ª¶ÝµÈ¢\n\tif(EQ(inDot.real(),-1))\n\t\treturn false;\n\tacp=inDot;\n\tar=r;\n\t// ~aªOp`ÌOÉÍÝoÄ¢½çA»Ì_Åfalse\n\tdouble d1=distance_l_p(ap,bp,acp);\n\tdouble d2=distance_l_p(ap,cp,acp);\n\tdouble d3=distance_l_p(bp,cp,acp);\n\tif((!EQ(d1,ar)&&d1<ar)||(!EQ(d2,ar)&&d2<ar)||(!EQ(d3,ar)&&d3<ar))return false;\n\t// _BÉß¢~Ì¼aÆS_ðßé\n\tdouble ub=10000000;\n\tdouble lb=0;\n\tint loop=100;\n\twhile(loop--){\n\t\tdouble mid=(ub+lb)/2;\n\t\tif(checkB(mid))lb=mid;\n\t\telse ub=mid;\n\t}\n\tbr=ub;\n\tub=10000000;\n\tlb=0;\n\tloop=100;\n\twhile(loop--){\n\t\tdouble mid=(ub+lb)/2;\n\t\tif(checkC(mid))lb=mid;\n\t\telse ub=mid;\n\t}\n\tcr=ub;\n\t// àµbÆcÌ~ª­ÁÂ©È¢ÈçAfalse\n\tif(abs(bcp-ccp)>cr+br)return false;\n\treturn true;\n}\n\nint main(){\n\n\tint x1,x2,x3,y1,y2,y3;\n\twhile(cin>>x1>>y1>>x2>>y2>>x3>>y3&&!(x1==0&&y1==0&&x2==0&&y2==0&&x3==0&&y3==0)){\n\t\tap=P(x1,y1);\n\t\tbp=P(x2,y2);\n\t\tcp=P(x3,y3);\n\t\tdouble ub=10000000;\n\t\tdouble lb=0;\n\t\tint loop=100;\n\t\tP acp;\n\t\twhile(loop--){\n\t\t\tdouble mid=(ub+lb)/2;\n\t\t\tif(check(mid))lb=mid;\n\t\t\telse ub=mid;\n\t\t}\n\t\tprintf(\"%.10f %.10f %.10f\\n\",ar,br,cr);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<complex>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst double eps = 1e-10;\nconst double MINRAD=0.00001;\nconst double pi = acos(-1);\n\ntypedef complex<double> P;\n\nvoid output_circle(P cr1,double r1){\n  cout << \"[\" << cr1.real()<<\",\"<<cr1.imag()<<\",\"\n       << r1 << \"],\"<<endl;\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a)<eps)return abs(c-a);\n  if (dot(a-b,c-b)<eps)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_cl(P a,P b,P circle,double r){\n  bool flag1 = abs(a-circle) < r+eps;\n  bool flag2 = abs(b-circle) < r+eps;\n  if (flag1 == flag2){\n    if (!flag1){\n      if (distance_ls_p(a,b,circle) < r+eps)return true;\n    }else if (flag1){\n      return true;\n    }\n  }else {\n    return true;\n  }\n  return false;\n}\n\n//0:a include b\n//1:b include a\n//2:intersected\n//3:same\n//4:far away\n// r1 >= r2\n\nint is_intersected_circle(P a,P b,double r1,double r2){\n  double d = abs(a-b);\n  if (d<eps && abs(r1-r2)<eps)return 3;\n  if (d+r2 < r1)return 0;\n  if (d+r1 < r2)return 1;\n  if (fabs(r1+r2-d) < eps)return 5;\n  if (d > r1+r2)return 4;\n\n  return 2;\n}\n\n\nbool is_out(P *cmp,P cr1){\n  if (cross(cmp[2]-cmp[1],cr1-cmp[1])<eps||\n      cross(cmp[3]-cmp[2],cr1-cmp[2])<eps||\n      cross(cmp[1]-cmp[3],cr1-cmp[3])<eps)return true;\n  return false;\n}\n\ndouble compute_r(P cr1,double r1,\n\t\t double x2,double y2,double sintheta2,\n\t\t double mx2,double my2,\n\t\t P*cmp,int ind1,int ind2){\n  double l =0.1,r=5000;\n  double mid;\n  P cr2;\n  while(l < r){\n    mid = (l+r)/2;\n    cr2=P(x2+mid/sintheta2*mx2,y2+mid/sintheta2*my2);\n\n    if (is_out(cmp,cr2)\n\t||is_intersected_cl(cmp[ind1],cmp[ind2],cr2,mid)\n\t){\n      r=mid-MINRAD;\n      continue;\n    }\n    \n    int state;\n    if (mid > r1){\n      state=is_intersected_circle(cr2,cr1,mid,r1);\n    }else {\n      state=is_intersected_circle(cr1,cr2,r1,mid);\n    }\n    \n    /*\n    cout <<\"state \" << state << endl;\n    output_circle(cr1,r1);\n    output_circle(cr2,mid);\n    */\n\n\n    if (state == 5){\n      break;\n    }else if(state == 4){\n      l=mid+eps;\n    }else {\n      r=mid-eps;\n    }\n  }\n  //  output_circle(cr2,mid);\n  return mid;\n}\n\nvoid solve(double x1,double y1,double sintheta1,\n\t   double mx1,double my1,\n\t   double x2,double y2,double sintheta2,\n\t   double mx2,double my2,\n\t   double x3,double y3,double sintheta3,\n\t   double mx3,double my3){\n  double l=0.1,r=5000;\n  double r1,r2,r3,r13,r23;\n  P cmp[4];cmp[1]=P(x1,y1);cmp[2]=P(x2,y2);cmp[3]=P(x3,y3);\n  while(l < r){\n    //    cout << l <<\" \" << (l+r)/2 <<\" \" << r << endl;\n\n    r1=(l+r)/2;\n    P cr1(x1+r1/sintheta1*mx1,y1+r1/sintheta1*my1);\n\n    //    cout <<\"circle 1 \" << endl;output_circle(cr1,r1);\n    \n    if (is_intersected_cl(cmp[2],cmp[3],cr1,r1)||\n\tis_out(cmp,cr1)){\n      r=r1-MINRAD;\n      continue;\n    }\n\n\n    r2=compute_r(cr1,r1,x2,y2,sintheta2,mx2,my2,cmp,1,3);\n    P cr2=P(x2+r2/sintheta2*mx2,y2+r2/sintheta2*my2);\n    //    cout <<\"circle2 \"<< endl;output_circle(cr2,r2);\n    \n    r13=compute_r(cr1,r1,x3,y3,sintheta3,mx3,my3,cmp,1,2);\n\n    r23=compute_r(cr2,r2,x3,y3,sintheta3,mx3,my3,cmp,1,2);\n    \n    \n    r3=r13;\n    if (fabs(r13-r23)<MINRAD){\n      //      cout <<\"exactly\"<<endl;\n      r3=r13;\n      break;\n    }\n    if (r13 < r23){\n      r=r1-MINRAD;\n    }else if(r13 > r23){\n      l=r1+MINRAD;\n    }\n\n\n\n  }\n  //  cout <<\"answer\"<<endl;\n  printf(\"%.6lf %.6lf %.6lf\\n\",r1,r2,r3);\n}\n\n\ndouble compute_info(double x1,double y1,\n\t\t    double x2,double y2,\n\t\t    double x3,double y3,\n\t\t    double &mx1,double &my1,double &sintheta1){\n  P p1(x1,y1),p2(x2,y2),p3(x3,y3);\n  P tmp =p2-p1;\n  double theta1;\n  double theta2=arg(p2-p1);\n  double theta3=arg(p3-p1);\n  if (theta3<0&&theta2>0)theta3+=2*pi;\n  theta1=theta3-theta2;\n  theta1/=2;\n\n  mx1=tmp.real()*cos(theta1)-tmp.imag()*sin(theta1);\n  my1=tmp.real()*sin(theta1)+tmp.imag()*cos(theta1);\n\n  double abab=(abs(P(mx1,my1)));\n  mx1/=abab;\n  my1/=abab;\n  sintheta1=sin(theta1);\n}\n\n\nmain(){\n  double x1,x2,x3,y1,y2,y3;\n  while(cin>>x1>>y1>>x2>>y2>>x3>>y3){\n    if (x1==0&&x2==0&&x3==0&&\n\ty1==0&&y2==0&&y3==0)break;\n    double mx1,my1,mx2,my2,mx3,my3;\n    double sintheta1,sintheta2,sintheta3;\n    \n    \n    compute_info(x1,y1,x2,y2,x3,y3,mx1,my1,sintheta1);\n    compute_info(x2,y2,x3,y3,x1,y1,mx2,my2,sintheta2);\n    compute_info(x3,y3,x1,y1,x2,y2,mx3,my3,sintheta3);\n\n    \n    //    cout <<\"input\" << endl;cout << \"[\";cout << \"[\" << x1 <<\",\"<<y1<<\"],\";cout << \"[\" << x2 <<\",\"<<y2<<\"],\"; cout << \"[\" << x3 <<\",\"<<y3<<\"],\";cout << \"[\" << x1 <<\",\"<<y1<<\"],\";cout << \"],\"<<endl;cout <<\"input end \"<<endl;\n    \n\n\n    solve(x1,y1,sintheta1,mx1,my1,\n\t  x2,y2,sintheta2,mx2,my2,\n\t  x3,y3,sintheta3,mx3,my3);\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\nifstream ifs(\"input.txt\");\n#define cin ifs\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n    // üªª½sÈêÍdÈÁÄ¢È¢±ÆÉ·é\n    if(abs(cross(a2-a1,b2-b1)) < EPS){\n        return 0;\n    }\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,a)>0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n\n// @üxNgðßé\nP unitVector(P a){\n\treturn P(-a.imag(),a.real());\n}\n// PÊ@üxNgðßé\nP unitNormalVector(P a,P b){\n\tP tmp=(b-a);\n\tP e=P(-tmp.imag(),tmp.real());\n\te/=abs(e);\n\treturn e;\n}\n\nP ap,bp,cp;\nP acp,bcp,ccp;\ndouble ar,br,cr;\n\nP selDot(P ab1_a,P ab1_b,P ab2_a,P ab2_b,P ac1_a,P ac1_b,P ac2_a,P ac2_b){\n\tP inDot=P(-1,-1);\n\t// »ê¼êÌð_ðßAOp`ÌÉÜÜêéàÌðIÔ\n\tif(isInTriangle(ap,bp,cp,intersection_l(ab1_a,ab1_b,ac1_a,ac1_b)))\n\t\tinDot=intersection_l(ab1_a,ab1_b,ac1_a,ac1_b);\n\telse if(isInTriangle(ap,bp,cp,intersection_l(ab1_a,ab1_b,ac2_a,ac2_b)))\n\t\tinDot=intersection_l(ab1_a,ab1_b,ac2_a,ac2_b);\n\telse if(isInTriangle(ap,bp,cp,intersection_l(ab2_a,ab2_b,ac2_a,ac2_b)))\n\t\tinDot=intersection_l(ab2_a,ab2_b,ac2_a,ac2_b);\n\telse if(isInTriangle(ap,bp,cp,intersection_l(ab2_a,ab2_b,ac1_a,ac1_b)))\n\t\tinDot=intersection_l(ab2_a,ab2_b,ac1_a,ac1_b);\n\treturn inDot;\n}\n\n// ~bÆ~cÌÖWð`FbN\nbool checkB(double r){\n\tP ba1_a,ba1_b,ba2_a,ba2_b;\n\tP bc1_a,bc1_b,bc2_a,bc2_b;\n\n\tP e1=unitNormalVector(bp,ap);\n\tP e2=unitNormalVector(bp,cp);\n\n\tba1_a=e1*r+bp;\n\tba1_b=e1*r+ap;\n\tba2_a=-e1*r+bp;\n\tba2_b=-e1*r+ap;\n\tbc1_a=e2*r+bp;\n\tbc1_b=e2*r+cp;\n\tbc2_a=-e2*r+bp;\n\tbc2_b=-e2*r+cp;\n\tP inDot=selDot(ba1_a,ba1_b,ba2_a,ba2_b,bc1_a,bc1_b,bc2_a,bc2_b);\n\t// ðð½·ð_ª¶ÝµÈ¢\n\tif(EQ(inDot.real(),-1))return false;\n\tbcp=inDot;\n\tbr=r;\n\t// ~aªOp`ÌOÉÍÝoÄ¢½çA»Ì_Åfalse\n\tdouble d1=distance_l_p(ap,bp,bcp);\n\tdouble d2=distance_l_p(bp,cp,bcp);\n\tdouble d3=distance_l_p(cp,ap,bcp);\n\tif((!EQ(d1,br)&&d1<br)||(!EQ(d2,br)&&d2<br)||(!EQ(d3,br)&&d3<br))return false;\n\t//~aÆdÈé©`FbN\n\t// dÈéÈçfalse\n\tif(abs(acp-bcp)<br+ar)return false;\n\treturn true;\n}\nbool checkC(double r){\n\tP ca1_a,ca1_b,ca2_a,ca2_b;\n\tP cb1_a,cb1_b,cb2_a,cb2_b;\n\n\tP e1=unitNormalVector(cp,ap);\n\tP e2=unitNormalVector(cp,bp);\n\n\tca1_a=e1*r+cp;\n\tca1_b=e1*r+ap;\n\tca2_a=-e1*r+cp;\n\tca2_b=-e1*r+ap;\n\tcb1_a=e2*r+cp;\n\tcb1_b=e2*r+bp;\n\tcb2_a=-e2*r+cp;\n\tcb2_b=-e2*r+bp;\n\tP inDot=selDot(ca1_a,ca1_b,ca2_a,ca2_b,cb1_a,cb1_b,cb2_a,cb2_b);\n\t// ðð½·ð_ª¶ÝµÈ¢\n\tif(EQ(inDot.real(),-1))return false;\n\tccp=inDot;\n\tcr=r;\n\tdouble d1=distance_l_p(ap,bp,ccp);\n\tdouble d2=distance_l_p(bp,cp,ccp);\n\tdouble d3=distance_l_p(cp,ap,ccp);\n\tif((!EQ(d1,cr)&&d1<cr)||(!EQ(d2,cr)&&d2<cr)||(!EQ(d3,cr)&&d3<cr))return false;\n\t//~aÆdÈé©`FbN\n\t// dÈéÈçfalse\n\tif(abs(ccp-acp)<cr+ar)return false;\n\treturn true;\n}\n\n// _AÉß¢~ð¼arÅu¯é©`FbN\nbool check(double r){\n\tP ab1_a,ab1_b;\n\tP ab2_a,ab2_b;\n\n\tP ac1_a,ac1_b;\n\tP ac2_b,ac2_a;\n\n\tP e1=unitNormalVector(ap,bp);\n\tP e2=unitNormalVector(ap,cp);\n\n\tab1_a=e1*r+ap;\n\tab1_b=e1*r+bp;\n\tab2_a=-e1*r+ap;\n\tab2_b=-e1*r+bp;\n\tac1_a=e2*r+ap;\n\tac1_b=e2*r+cp;\n\tac2_a=-e2*r+ap;\n\tac2_b=-e2*r+cp;\n\n\tP inDot=selDot(ab1_a,ab1_b,ab2_a,ab2_b,ac1_a,ac1_b,ac2_a,ac2_b);\n\t// ðð½·ð_ª¶ÝµÈ¢\n\tif(EQ(inDot.real(),-1))\n\t\treturn false;\n\tacp=inDot;\n\tar=r;\n\t// ~aªOp`ÌOÉÍÝoÄ¢½çA»Ì_Åfalse\n\tdouble d1=distance_l_p(ap,bp,acp);\n\tdouble d2=distance_l_p(ap,cp,acp);\n\tdouble d3=distance_l_p(bp,cp,acp);\n\tif((!EQ(d1,ar)&&d1<ar)||(!EQ(d2,ar)&&d2<ar)||(!EQ(d3,ar)&&d3<ar))return false;\n\t// _BÉß¢~Ì¼aÆS_ðßé\n\tdouble ub=10000000;\n\tdouble lb=0;\n\tint loop=100;\n\twhile(loop--){\n\t\tdouble mid=(ub+lb)/2;\n\t\tif(checkB(mid))lb=mid;\n\t\telse ub=mid;\n\t}\n\tbr=ub;\n\tub=10000000;\n\tlb=0;\n\tloop=100;\n\twhile(loop--){\n\t\tdouble mid=(ub+lb)/2;\n\t\tif(checkC(mid))lb=mid;\n\t\telse ub=mid;\n\t}\n\tcr=ub;\n\t// àµbÆcÌ~ª­ÁÂ©È¢ÈçAfalse\n\tif(abs(bcp-ccp)>cr+br)return false;\n\treturn true;\n}\n\nint main(){\n\n\tint x1,x2,x3,y1,y2,y3;\n\twhile(cin>>x1>>y1>>x2>>y2>>x3>>y3&&!(x1==0&&y1==0&&x2==0&&y2==0&&x3==0&&y3==0)){\n\t\tap=P(x1,y1);\n\t\tbp=P(x2,y2);\n\t\tcp=P(x3,y3);\n\t\tdouble ub=10000000;\n\t\tdouble lb=0;\n\t\tint loop=100;\n\t\tP acp;\n\t\twhile(loop--){\n\t\t\tdouble mid=(ub+lb)/2;\n\t\t\tif(check(mid))lb=mid;\n\t\t\telse ub=mid;\n\t\t}\n\t\tprintf(\"%.10f %.10f %.10f\\n\",ar,br,cr);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <complex>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nld dot (P a, P b) { return real(conj(a) * b); }\nld cross (P a, P b) { return imag(conj(a) * b); }\n\nclass L{\npublic:\n  P a, b;\n  L (P aa, P bb) { a = aa; b = bb; }\n  L (ld ax, ld ay, ld bx, ld by) { a = P(ax, ay); b = P(bx, by); }\n};\n\nP incenter(VP tri) {\n  ld l[3];\n  REP(i,3) l[i] = abs(tri[(i+1)%3] - tri[(i+2)%3]);\n  ld p = l[0]+l[1]+l[2];\n  P ic;\n  REP(i,3) ic += l[i]/p*tri[i];\n  return ic;\n}\n\nP proj(L l, P p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n  return abs(p - proj(l, p));\n}\n\nint main() {\n  while(1){\n    VP tri;\n    REP(i,3){\n      ld x,y;\n      cin>>x>>y;\n      tri.emplace_back(x,y);\n    }\n    if (tri[0] == tri[1]) break;\n    P ic = incenter(tri);\n    P lb = tri[0], ub = ic;\n    ld d = 0, d1 = 0, d2 = 0;\n    while (abs(lb - ub) > eps) {\n      P mid = (lb + ub) / (ld)2.0;\n      d = dist_lp(L(tri[0], tri[1]), mid);\n      P lb1 = tri[1], ub1 = ic;\n      while (abs(lb1 - ub1) > eps) {\n        P mid1 = (lb1 + ub1) / (ld)2.0;\n        d1 = dist_lp(L(tri[0], tri[1]), mid1);\n        if (abs(mid - mid1) - d < d1) {\n          ub1 = mid1;\n        } else {\n          lb1 = mid1;\n        }\n      }\n      P lb2 = tri[2], ub2 = ic;\n      while (abs(lb2 - ub2) > eps) {\n        P mid2 = (lb2 + ub2) / (ld)2.0;\n        d2 = dist_lp(L(tri[0], tri[2]), mid2);\n        if (abs(mid - mid2) - d < d2) {\n          ub2 = mid2;\n        } else {\n          lb2 = mid2;\n        }\n      }\n      if (abs(lb2 - lb1) < d1 + d2) {\n        lb = mid;\n      } else {\n        ub = mid;\n      }\n    }\n    cout << setprecision(10) << fixed << d << ' ' << d1 << ' ' << d2 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nconst double PI=acos(-1);\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n\tPoint& operator+=(Point p){x+=p.x,y+=p.y; return *this;}\n\tPoint& operator-=(Point p){x-=p.x,y-=p.y; return *this;}\n\tPoint& operator*=(double c){x*=c,y*=c; return *this;}\n\tPoint& operator/=(double c){x/=c,y/=c; return *this;}\n};\nPoint operator+(Point a,Point b){return a+=b;}\nPoint operator-(Point a,Point b){return a-=b;}\nPoint operator*(Point a,double c){return a*=c;}\nPoint operator*(double c,Point a){return a*=c;}\nPoint operator/(Point a,double c){return a/=c;}\nbool operator==(Point a,Point b){return abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;}\nbool operator!=(Point a,Point b){return !(a==b);}\n\ndouble Abs(Point p){\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\ndouble Abs2(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\ndouble Arg(Point p){\n\treturn atan2(p.y,p.x);\n}\ndouble Dot(Point a,Point b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble Cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\nPoint Rot(Point p,double t){\n\treturn Point(cos(t)*p.x-sin(t)*p.y,sin(t)*p.x+cos(t)*p.y);\n}\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n\tLine(double x,double y,double u,double v):pos(x,y),dir(u,v){}\n};\n\nostream& operator<<(ostream& os,const Point& p){\n\treturn os<<'('<<p.x<<','<<p.y<<')';\n}\nostream& operator<<(ostream& os,const Line& l){\n\treturn os<<'('<<l.pos<<','<<l.dir<<')';\n}\n\nint main()\n{\n\tfor(Point ps[3];;){\n\t\trep(i,3) cin>>ps[i].x>>ps[i].y;\n\t\tif(count(all(ps),Point(0,0))==3) break;\n\t\t\n\t\tPoint ds[3]; // 二等分線の方向ベクトル\n\t\tdouble ts[3]; // 角度\n\t\trep(i,3){\n\t\t\tPoint d1=ps[(i+1)%3]-ps[i],d2=ps[(i+2)%3]-ps[i];\n\t\t\tts[i]=acos(Dot(d1,d2)/(Abs(d1)*Abs(d2)));\n\t\t\tds[i]=Rot(d1,ts[i]/2)/Abs(d1);\n\t\t}\n\t\tdouble s=Cross(ps[1]-ps[0],ps[2]-ps[0])/2; // 面積\n\t\tdouble h=2*s/(Abs(ps[1]-ps[0])+Abs(ps[2]-ps[1])+Abs(ps[0]-ps[2])); // 内接円の半径\n\t\t\n\t\tdouble r[3];\n\t\tdouble lo=0,hi=h;\n\t\trep(_,50){\n\t\t\tr[0]=(lo+hi)/2;\n\t\t\tPoint q[3]={ps[0]+r[0]/sin(ts[0]/2)*ds[0]};\n\t\t\t\n\t\t\trepi(i,1,3){\n\t\t\t\tdouble lo=0,hi=h;\n\t\t\t\trep(_,50){\n\t\t\t\t\tr[i]=(lo+hi)/2;\n\t\t\t\t\tq[i]=ps[i]+r[i]/sin(ts[i]/2)*ds[i];\n\t\t\t\t\tif(Abs(q[i]-q[0])<r[0]+r[i])\n\t\t\t\t\t\thi=r[i];\n\t\t\t\t\telse\n\t\t\t\t\t\tlo=r[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// q[1]とq[2]の距離が半径の和より小さかったら，r[0]を大きくする必要がある\n\t\t\tif(Abs(q[2]-q[1])<r[1]+r[2])\n\t\t\t\tlo=r[0];\n\t\t\telse\n\t\t\t\thi=r[0];\n\t\t}\n\t\tprintf(\"%f %f %f\\n\",r[0],r[1],r[2]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<double,P> P2;\n\nconst double EPS = 1e-6;\nP v[3];\n\ndouble cross(P a, P b){ return imag(conj(a)*b);}\n\nP rotate(P p, double rad){\n  double x = real(p) * cos(rad) - imag(p) * sin(rad);\n  double y = real(p) * sin(rad) + imag(p) * cos(rad);\n  return P(x,y);\n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  return m.first + B / A * (m.second - m.first);\n}\n\ndouble areaV(){\n  double sum = 0.0;\n  for(int i=0;i<3;i++) sum += (real(v[i]) - real(v[(i+1)%3])) * (imag(v[i]) + imag(v[(i+1)%3]));\n  return abs(sum) / 2.0;\n}\n\nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\nP2 check2(P2 p, int pos){\n  double le = 0.1, ri = 2.0 * areaV() / (abs(v[1]-v[0]) + abs(v[2]-v[1]) + abs(v[0]-v[2]));\n  L l[2];\n  P2 res;\n  for(int i=0;i<1000;i++){\n    double mid = (le + ri) / 2.0;\n\n    for(int j=pos;j<pos+2;j++){\n      P a = (v[(j+1)%3]-v[j%3]) * mid / abs(v[(j+1)%3]-v[j%3]);\n      P b = rotate(a, M_PI/2.0);\n      l[j-pos] = L(v[(j+1)%3]+b, v[j%3]+b);\n    }\n    res = P2(mid, crossPoint(l[0],l[1]));\n\n    if(equal(abs(res.second-p.second), res.first+p.first)) return res;\n    else if(abs(res.second-p.second) < res.first+p.first) ri = mid;\n    else le = mid;\n  }\n}\n\nint check(double r, int pos){\n  L l[2];\n  P2 p[3];\n  for(int i=0;i<2;i++){\n    P a = (v[i+1]-v[i]) * r / abs(v[i+1]-v[i]);\n    P b = rotate(a, M_PI/2.0);\n    l[i] = L(v[i+1]+b, v[i]+b);\n  }\n  p[0] = P2(r, crossPoint(l[0],l[1]));\n\n\n  for(int i=1;i<3;i++) p[i] = check2(p[0], i);\n\n  if(pos == 999 || equal(abs(p[2].second-p[1].second), p[2].first+p[1].first)){\n    printf(\"%.6f %.6f %.6f\\n\",p[2].first, p[0].first, p[1].first);\n    return 1;\n  }\n  else if(abs(p[2].second-p[1].second) < p[2].first+p[1].first) return 2;\n  else return 0;\n  \n}\n\nvoid solve(){\n  double le = 0.1, ri = 2.0 * areaV() / (abs(v[1]-v[0]) + abs(v[2]-v[1]) + abs(v[0]-v[2]));\n  for(int i=0;i<1000;i++){\n    double mid = (le + ri) / 2.0;\n    int res = check(mid,i);\n    if(res == 0) ri = mid;\n    else if(res == 2) le = mid;\n    else return;\n  }\n}\n\nint main(){\n  int x[3],y[3];\n  while(cin >> x[0] >> y[0] >> x[1] >> y[1] >> x[2] >> y[2] && (x[0]|y[0]|x[1]|y[1]|x[2]|y[2])){\n    for(int i=0;i<3;i++) v[i] = P((double)x[i], (double)y[i]);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<double,P> P2;\n\nconst double EPS = 1e-8;\nP v[3];\n\ndouble cross(P a, P b){ return imag(conj(a)*b);}\n\nP rotate(P p, double rad){\n  double x = real(p) * cos(rad) - imag(p) * sin(rad);\n  double y = real(p) * sin(rad) + imag(p) * cos(rad);\n  return P(x,y);\n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  return m.first + B / A * (m.second - m.first);\n}\n\ndouble areaV(){\n  double sum = 0.0;\n  for(int i=0;i<3;i++) sum += (real(v[i]) - real(v[(i+1)%3])) * (imag(v[i]) + imag(v[(i+1)%3]));\n  return abs(sum) / 2.0;\n}\n\nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\nP2 check2(P2 p, int pos){\n  double le = 0.1, ri = 2.0 * areaV() / (abs(v[1]-v[0]) + abs(v[2]-v[1]) + abs(v[0]-v[2]));\n  L l[2];\n  P2 res;\n  for(int i=0;i<1000;i++){\n    double mid = (le + ri) / 2.0;\n\n    for(int j=pos;j<pos+2;j++){\n      P a = (v[(j+1)%3]-v[j%3]) * mid / abs(v[(j+1)%3]-v[j%3]);\n      P b = rotate(a, M_PI/2.0);\n      l[j-pos] = L(v[(j+1)%3]+b, v[j%3]+b);\n    }\n    res = P2(mid, crossPoint(l[0],l[1]));\n\n    if(equal(abs(res.second-p.second), res.first+p.first)) return res;\n    else if(abs(res.second-p.second) < res.first+p.first) ri = mid;\n    else le = mid;\n  }\n}\n\nint check(double r){\n  L l[2];\n  P2 p[3];\n  for(int i=0;i<2;i++){\n    P a = (v[i+1]-v[i]) * r / abs(v[i+1]-v[i]);\n    P b = rotate(a, M_PI/2.0);\n    l[i] = L(v[i+1]+b, v[i]+b);\n  }\n  p[0] = P2(r, crossPoint(l[0],l[1]));\n\n\n  for(int i=1;i<3;i++) p[i] = check2(p[0], i);\n\n  if(equal(abs(p[2].second-p[1].second), p[2].first+p[1].first)){\n    printf(\"%.6f %.6f %.6f\\n\",p[2].first, p[0].first, p[1].first);\n    return 1;\n  }\n  else if(abs(p[2].second-p[1].second) < p[2].first+p[1].first) return 2;\n  else return 0;\n  \n}\n\nvoid solve(){\n  double le = 0.1, ri = 2.0 * areaV() / (abs(v[1]-v[0]) + abs(v[2]-v[1]) + abs(v[0]-v[2]));\n  while(1){\n    double mid = (le + ri) / 2.0;\n    int res = check(mid);\n    if(res == 0) ri = mid;\n    else if(res == 2) le = mid;\n    else return;\n  }\n}\n\nint main(){\n  int x[3],y[3];\n  while(cin >> x[0] >> y[0] >> x[1] >> y[1] >> x[2] >> y[2] && (x[0]|y[0]|x[1]|y[1]|x[2]|y[2])){\n    for(int i=0;i<3;i++) v[i] = P((double)x[i], (double)y[i]);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <iomanip>\nusing namespace std;\n\nlong double x[3], y[3], l[3], a[3], r[3];\n\t\nbool check() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (x[i] != 0) {\n\t\t\treturn true;\n\t\t}\n\t\tif (y[i] != 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nlong double quad(long double a, long double b, long double c) {\n\tlong double result;\n\tresult = pow(b,2)-4*a*c;\n\tif (result < 0) {\n\t\treturn -1;\n\t}\n\tresult = 2*b*sqrtl(result);\n\tresult = 2*pow(b,2)-4*a*c-result;\n\tresult /= 4*pow(a,2);\n\treturn result;\n}\n\nint main() {\n\tcout << fixed;\n\tcout << setprecision(6);\n\n\tint tmp;\n\tlong double value;\n\tlong double opp, hyp, adj;\n\tlong double dist;\n\tlong double diffx[2], diffy[2];\n\tlong double dirx, diry;\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tcin >> x[i];\n\t\tcin >> y[i];\n\t}\n\n\tint itr = 0;\n\twhile (check()) {\n\t\t//cout << itr++ << endl;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\ttmp = (i+1) % 3;\n\n\t\t\t//cout << pow(x[i] - x[tmp], 2) << \" \" << pow(y[i] - y[tmp], 2) << endl;\n\t\t\tl[i] = sqrtl(pow(x[i] - x[tmp], 2) +  pow(y[i] - y[tmp], 2));\n\t\t}\n\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t/*\n\t\t\thyp = 2*l[i]*l[(i+2)%3];\n\t\t\tadj = pow(l[i], 2) + pow(l[(i+2)%3], 2) - pow(l[(i+1)%3], 2);\n\t\t\topp = sqrtl(pow(hyp,2)-pow(adj,2));\n\n\t\t\ta[i] = (hyp - adj) / opp;\n\t\t\t*/\n\n\t\t\ta[i] = pow(l[i],2) + pow(l[(i+2)%3],2) - pow(l[(i+1)%3],2);\n\t\t\ta[i] /= 2*l[i]*l[(i+2)%3];\n\t\t\ta[i] = acos(a[i]);\n\t\t\ta[i] = tan(a[i]/2);\n\t\t\t//cout << a[i] << endl;\n\t\t}\n\n\n\t\tlong double diff = min(l[0],l[2]);\n\t\tr[0] = 0.1;\n\n\t\t//r[0] = 21.565935;\n\t\t//r[1] = 24.409005;\n\t\t//r[2] = 27.107493;\n\n\t\twhile (diff > 1e-7) {\n\t\t//for (int i = 0; i < 10; i++) {\n\t\t\tr[0] += diff;\n\t\t\t//cout << \"START: \" << r[0] << endl;\n\n\n\t\t\tr[1] = quad(1/a[1], 2*sqrtl(r[0]), r[0]/a[0]-l[0]);\n\t\t\tr[2] = quad(1/a[2], 2*sqrtl(r[0]), r[0]/a[0]-l[2]);\n\n\t\t\tif (r[1] == -1 || r[2] == -1) {\n\t\t\t\tr[0] -= diff;\n\t\t\t\tdiff /= 10;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//cout << r[1] << \" \" << r[2] << endl;\n\t\t\t\n\t\t\tvalue = r[1]/a[1] + 2*sqrtl(r[1]*r[2]) + r[2]/a[2];\n\t\t\t//cout << \"ERROR: \" << value - l[1] << endl;\n\n\t\t\t//cout << r[0] << \" \" << r[1] << \" \" << r[2] << endl;\n\n\t\t\tif (value < l[1]) {\n\t\t\t\tr[0] -= diff;\n\t\t\t\tdiff /= 10;\n\t\t\t} else if (value == l[1]) {\n\t\t\t\tbreak;\n\t\t\t} \n\t\t}\n\n\t\tcout << r[0];\n\t\tfor (int i = 1; i < 3; i++) {\n\t\t\tcout << \" \" << r[i];\n\t\t}\n\t\tcout << endl;\n\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tcin >> x[i];\n\t\t\tcin >> y[i];\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\ndouble ABS(double a){return max(a,-a);}\ndouble x[5];\ndouble y[5];\ndouble EPS=1e-9;\ndouble PI=acos(-1.0);\nint main(){\n\twhile(1){\n\t\tfor(int i=0;i<3;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tdouble gm=0;\n\t\tfor(int i=0;i<3;i++)gm+=ABS(x[i])+ABS(y[i]);\n\t\tif(gm<EPS)break;\n\t\tdouble l1=sqrt((x[0]-x[1])*(x[0]-x[1])+(y[0]-y[1])*(y[0]-y[1]));\n\t\tdouble l2=sqrt((x[0]-x[2])*(x[0]-x[2])+(y[0]-y[2])*(y[0]-y[2]));\n\t\tdouble th=atan2(y[2]-y[0],x[2]-x[0])-atan2(y[1]-y[0],x[1]-x[0]);\n\t\tif(th<-PI)th+=PI*2;\n\t\tif(th>PI)th-=PI*2;\n\t\tif(th<0){\n\t\t\tth=-th;\n\t\t}\n\t\tdouble t2=atan2(y[2]-y[1],x[2]-x[1])-atan2(y[0]-y[1],x[0]-x[1]);\n\t\tdouble t3=atan2(y[0]-y[2],x[0]-x[2])-atan2(y[1]-y[2],x[1]-x[2]);\n\t\t\n\t\tif(t2<-PI)t2+=PI*2;\n\t\tif(t2>PI)t2-=PI*2;\n\t\tif(t2<0)t2=-t2;\n\t\tif(t3<-PI)t3+=PI*2;\n\t\tif(t3>PI)t3-=PI*2;\n\t\tif(t3<0)t3=-t3;\n\t//\tprintf(\"%f %f %f \",th,t2,t3);\n\t\t//printf(\"%f %f\\n\",l1,l2);\n\t\t\n\t\tdouble L=0;\n\t\tdouble R=10000;\n\t\tdouble R2,R3;\n\t\tfor(int i=0;i<50;i++){\n\t\t\tdouble M=(L+R)/2;\n\t\t\tdouble X1=M/tan(th/2);\n\t\t\tdouble Y1=M;\n\t\t\tif(X1>l1||X1>l2){\n\t\t\t\tR=M;continue;\n\t\t\t}\n\t\t\tdouble left=0;\n\t\t\tdouble right=10000;\n\t\t\tdouble X2,Y2;\n\t\t\tfor(int j=0;j<50;j++){\n\t\t\t\tdouble md=(left+right)/2;\n\t\t\t\tX2=l1-md/tan(t2/2);\n\t\t\t\tY2=md;\n\t\t\t\tif(X2<X1){right=md;continue;}\n\t\t\t\tif((X1-X2)*(X1-X2)+(Y1-Y2)*(Y1-Y2)>(M+md)*(M+md))left=md;\n\t\t\t\telse right=md;\n\t\t\t}\n\t\t\tR2=right;\n\t\t\tdouble X3,Y3;\n\t\t\tleft=0;right=10000;\n\t\t\tfor(int j=0;j<50;j++){\n\t\t\t\tdouble md=(left+right)/2;\n\t\t\t\tX3=l2-md/tan(t3/2);\n\t\t\t\tY3=md;\n\t\t\t\tif(X3<X1){right=md;continue;}\n\t\t\t\tif((X1-X3)*(X1-X3)+(Y1-Y3)*(Y1-Y3)>(M+md)*(M+md))left=md;\n\t\t\t\telse right=md;\n\t\t\t}\n\t\t\tR3=right;\n\t\t\tdouble xf=X3*cos(th/2)+Y3*sin(th/2);\n\t\t\tdouble yf=X3*sin(th/2)-Y3*cos(th/2);\n\t\t\tX3=xf*cos(th/2)-yf*sin(th/2);\n\t\t\tY3=xf*sin(th/2)+yf*cos(th/2);\n\t\t//\tif(Y3<Y2){R=M;continue;}\n\t\t//\tprintf(\"(%f %f), (%f %f), (%f %f)\\n\",X1,Y1,X2,Y2,X3,Y3);\n\t\t\tif((X2-X3)*(X2-X3)+(Y2-Y3)*(Y2-Y3)>(R2+R3)*(R2+R3))R=M;\n\t\t\telse L=M;\n\t\t}\n\t\tprintf(\"%f %f %f\\n\",R,R2,R3);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// File Name: G.cpp\n// Author: YangYue\n// Created Time: Thu Oct 10 13:54:01 2013\n//headers \n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef pair<double,double> PDD;\ntypedef pair<LL, LL>PLL;\ntypedef pair<LL,int>PLI;\n\n#define lch(n) ((n<<1))\n#define rch(n) ((n<<1)+1)\n#define lowbit(i) (i&-i)\n#define sqr(x) ((x)*(x))\n#define fi first\n#define se second\n#define MP make_pair\n#define PB push_back\n\nconst int MaxN = 200005;\nconst double eps = 1e-8;\nconst double DINF = 1e100;\nconst int INF = 1000000006;\nconst LL LINF = 1000000000000000005ll;\n\nint dcmp(double x) { return x < -eps ? -1 : x > eps; }\nstruct Point {\n\tdouble x, y;\n\tPoint (){}\n\tPoint(double x, double y) : x(x), y(y) {}\n\tPoint operator - (const Point &b) { return Point(x - b.x, y - b.y); }\n\tPoint operator + (const Point &b) { return Point(x + b.x, y + b.y); }\n\tPoint operator * (const double &b) { return Point(x * b, y * b); }\n\tPoint operator / (const double &b) { return Point(x / b, y / b); }\n\tPoint rot90(int t) { return Point(-y, x) * t; }\n\tdouble operator * (const Point &b) { return x * b.y - y * b.x; }\n\tdouble operator % (const Point &b) { return x * b.x + y * b.y; }\n\tdouble len2() { return x * x + y * y; }\n\tdouble len() { return sqrt(x * x + y * y); }\n\tbool operator < (const Point &b) const {\n\t\tif (dcmp(x - b.x) != 0) return dcmp(x - b.x) < 0;\n\t\treturn dcmp(y - b.y) < 0;\n\t}\n\tbool operator == (const Point &b) const { return dcmp(x - b.x) == 0 && dcmp(y - b.y) == 0; }\n\tvoid init() {\n\t\tscanf(\"%lf%lf\", &x, &y); \n\t}\n} A, B, C;\ndouble sinA, sinB, sinC;\nvector<double> solve(double a, double b, double c) {\n\tdouble delta = b * b - 4 * a * c;\n\tvector<double> res;\n\tif (dcmp(a)) {\n\t\tif (delta < 0) return res;\n\t\tdouble x1 = (-b + sqrt(delta)) / (2.0*a);\n\t\tdouble x2 = (-b - sqrt(delta)) / (2.0*a);\n\t\tif (x1 > x2) swap(x1, x2);\n\t\tres.push_back(x1);\n\t\tres.push_back(x2);\n\t\treturn res;\n\t}\n\tif (!dcmp(b) && dcmp(c)) return res;\n\tres.push_back(-c / b);\n\treturn res;\n}\ndouble get(Point A, Point B, Point C, double r1, double sinC) {\n\tPoint a = (C - B);\n\tPoint b = (C - A);\n\tPoint c = (B - A);\n\ta = a / a.len();\n\tb = b / b.len();\n\tc = c / c.len();\n\tr1 /= (b+c).len();\n\tdouble l1 = (b+c).len();\n\tdouble l2 = (a+b).len();\n\tvector<double> root = solve((a+b).len2() - l2*l2*sinC*sinC, 2.0*((b*r1 + c*r1 - (C-A))%(a+b)) - 2*r1*sinA*sinC*l1*l2, (b*r1+c*r1-(C-A)).len2()-l1*l1*r1*r1*sinA*sinA);\n\tif (root.size() == 0) return -1;\n\t//printf(\"%.10f\\n\", root[0]);\n\treturn root[0] * l2;\n}\nbool ccheck(Point c1,Point c2,double r1,double r2) {\n\tif (dcmp((c1-c2).len() - (r1+r2)) == 0) return 1;\n\treturn 0;\n}\nbool check(double r1, double &ra, double &rb, double &rc) {\n\tdouble r3 = get(A, B, C, r1, sinC);\n\tif (r3 < eps) return 0;\n\tdouble r2 = get(A, C, B, r1, sinB);\n\tif (r2 < eps) return 0;\n\tPoint a = (C-B);\n\tPoint b = (C-A);\n\tPoint c = (B-A);\n\ta = a / a.len();\n\tb = b / b.len();\n\tc = c / c.len();\n\n\t//Point c1 = A + (b+c)*r1/(b+c).len();\n\tPoint c2 = B + (a-c)*r2/(a-c).len();\n\tPoint c3 = C - (a+b)*r3/(a+b).len();\n\n\tra = r1 * sinA;\n\trb = r2 * sinB;\n\trc = r3 * sinC;\n\t//\tprintf(\"%d\\n\", ccheck(c1, c2, ra, rb));\n\t//\tprintf(\"%d\\n\", ccheck(c1, c3, ra, rc));\n\tif (dcmp((c2-c3).len2() - sqr(rc+rb)) >= 0) return 1;\n\treturn 0;\n}\nint main()\n{\n\t//freopen(\"in\",\"r\",stdin);\n\n\twhile (1) {\n\t\tA.init(); B.init(); C.init();\n\t\tif (A == Point(0, 0) && B == Point(0, 0) && C == Point(0, 0)) break;\n\t\tdouble l = 0, r = min((B-A).len(), (C-A).len()); ////////===============================================!!!\n\t\tdouble ra, rb, rc;\n\n\t\tPoint a = (C-B) / (C-B).len();\n\t\tPoint b = (C-A) / (C-A).len();\n\t\tPoint c = (B-A) / (B-A).len();\n\t\tsinA = fabs((b + c) * b / (b + c).len());\n\t\tsinC = fabs((a + b) * b / (a + b).len());\n\t\tsinB = fabs((a - c) * a / (a - c).len());\n\n\t\twhile (l + eps < r) {\n\t\t\tdouble mid = (l + r) * 0.5;\n\t\t\tif (check(mid, ra, rb, rc)) r = mid; else l = mid;\n\t\t}\n\t\tcheck(r, ra, rb, rc);\n\t\tprintf(\"%.10f %.10f %.10f\\n\", ra, rb, rc);\n\t}\n\n\treturn 0;\n}\n\n// hehe ~"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\ndouble dot(P a,P b){\n  return real(b*conj(a));\n}\n\ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n\nP init(P a){\n  return a/max(0.0001,abs(a));\n}\n\nint ax,ay,bx,by,cx,cy;\n\nP A,B,C;\ndouble sinA,cosA,sinB,cosB,sinC,cosC;\n\ndouble funcC(double ra){\n  double L=0,R=10000,M;\n  for(int i=0;i<50;i++){\n    M=(L+R)/2.0;\n    if( M/sinC*cosC + ra/sinA*cosA + sqrt( 4.0*ra*M ) < abs(A-C) ) L=M;\n    else R=M;\n  }\n  return L;\n}\n\ndouble funcB(double ra){\n  double L=0,R=10000,M;\n  for(int i=0;i<50;i++){\n    M=(L+R)/2.0;\n    if( M/sinB*cosB + ra/sinA*cosA + sqrt( 4.0*ra*M ) < abs(A-B) ) L=M;\n    else R=M;\n  }\n  return L;\n}\n\nbool check(double ra){\n  double rb=funcB(ra);\n  double rc=funcC(ra);\n\n  if( rb/sinB*cosB + rc/sinC*cosC + sqrt( 4.0*rb*rc ) < abs(C-B) ){\n    return true;\n  }else{\n    return false;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>ax>>ay>>bx>>by>>cx>>cy;\n    if(ax==0&&ay==0&&bx==0&&by==0&&cx==0&&cy==0)break;\n    A=P(ax,ay),B=P(bx,by),C=P(cx,cy);\n    P AB=init(B-A),AC=init(C-A);\n    AB=(AB+AC)*0.5;\n    sinA = abs(cross(AB,AC))/abs(AB);\n    cosA = dot(AB,AC)/abs(AB);\n    \n    P BA=init(A-B),BC=init(C-B);\n    BA=(BA+BC)*0.5;\n    sinB = abs(cross(BA,BC))/abs(BA);\n    cosB = dot(BA,BC)/abs(BA);\n\n    P CA=init(A-C),CB=init(B-C);\n    CA=(CA+CB)*0.5;\n    sinC = abs(cross(CA,CB))/abs(CA);\n    cosC = dot(CA,CB)/abs(CA);\n\n    double L=0,R=10000,M;\n    for(int i=0;i<50;i++){\n      M=(L+R)/2.0;\n      if(check(M))R=M;\n      else L=M;\n    }\n\n    printf(\"%.10f %.10f %.10f\\n\",L,funcB(L),funcC(L));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\ntypedef long double D;\ntypedef complex<D> P;\n\n#define X real()\n#define Y imag()\n\nconst D eps=1e-8;\nconst D inf=1e12;\nconst D PI=acos(-1);\n\nD cross(P a,P b){ return (conj(a)*b).Y; }\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\nP projection(L l,P p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*(c/b).X;\n}\nD distanceLP(L l,P p) {\n  return abs(p-projection(l,p));\n}\nP crosspoint(L l,L m) {\n  D A=cross(l[1]-l[0],m[1]-m[0]);\n  D B=cross(l[1]-l[0],l[1]-m[0]);\n  if (abs(A)<eps&&abs(B)<eps) return m[0]; // same line\n  if (abs(A)<eps) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0]+B/A*(m[1]-m[0]);\n}\n\nP p[3],q[3],e[3],x[3];\nD r[3];\nP g;\n\nbool ok(){\n  r[0]=distanceLP(L(p[0],p[1]),x[0]);\n  P cp=crosspoint(L(p[1],q[1]),L(p[2],q[2]));\n  repl(i,1,3){\n    D lb=0,ub=abs(cp-p[i]);\n    rep(hoge,80){\n      D mid=(ub+lb)/2.0;\n      x[i]=p[i]+e[i]*mid;\n      r[i]=distanceLP(L(p[i],p[(i+1)%3]),x[i]);\n      D d0i=abs(x[i]-x[0]);\n      if(d0i>r[0]+r[i])lb=mid;\n      else ub=mid;\n    }\n  }\n  D d12=abs(x[1]-x[2]);\n  return d12>r[1]+r[2];\n}\n\nint main(){\n  while(1){\n    bool done=true;\n    rep(i,3){\n      int x,y;\n      cin>>x>>y;\n      if(x!=0||y!=0)done=false;\n      p[i]=P(x,y);\n    }\n    if(done)break;\n\n    D absA=abs(p[2]-p[1]); D absB=abs(p[2]-p[0]); D absC=abs(p[1]-p[0]);\n    q[0]=(p[1]*absB+p[2]*absC)/(absB+absC);\n    q[1]=(p[0]*absA+p[2]*absC)/(absA+absC);\n    q[2]=(p[0]*absA+p[1]*absB)/(absA+absB);\n    rep(i,3)e[i]=(q[i]-p[i])/abs(q[i]-p[i]);\n    D lb=0,ub=abs(q[0]-p[0]);\n    rep(hoge,80){\n      D mid=(lb+ub)/2.0;\n      x[0]=p[0]+e[0]*mid;\n      if(ok())ub=mid;\n      else lb=mid;\n    }\n    printf(\"%.10Lf %.10Lf %.10Lf\\n\", r[0], r[1], r[2]);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\nusing P = pair<ld, ld>;\ninline ld dist(const P& p1, const P& p2) { return hypot(p1.first - p2.first, p1.second - p2.second); }\nint main()\n{\n    while (true) {\n        P p1, p2, p3;\n        cin >> p1.first >> p1.second >> p2.first >> p2.second >> p3.first >> p3.second;\n        if (p1 == P{0, 0} and p2 == P{0, 0} and p3 == P{0, 0}) { break; }\n        const ld a = dist(p1, p2), b = dist(p2, p3), c = dist(p3, p1), s = (a + b + c) / 2;\n        const ld r = sqrt((s - a) * (s - b) * (s - c) / s);\n        const ld d = hypot(s - a, r), e = hypot(s - b, r), f = hypot(s - c, r);\n        const ld r1 = r / 2 / (s - a) * (s + d - r - e - f), r2 = r / 2 / (s - b) * (s + e - r - d - f), r3 = r / 2 / (s - c) * (s + f - r - d - e);\n        cout << fixed << setprecision(15) << r2 << \" \" << r3 << \" \" << r1 << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tVP p(3);\n\tfor (;;) {\n\t\trep(i, 3) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = { (double)x,(double)y };\n\t\t}\n\t\tif (p[0] == p[1])break;\n\t\tP up1 = (p[1] * abs(p[2] - p[0]) + p[2] * abs(p[1] - p[0])) / (abs(p[2] - p[0]) + abs(p[1] - p[0]));\n\t\tP dn1 = p[0];\n\t\tdouble r1, r2, r3;\n\t\trep(i, 80) {\n\t\t\tP m1 = (up1 + dn1) * 0.5;\n\t\t\tr1 = dist_lp({ p[0],p[1] }, m1);\n\t\t\tP up2 = (p[0] * abs(p[2] - p[1]) + p[2] * abs(p[0] - p[1])) / (abs(p[2] - p[1]) + abs(p[0] - p[1]));\n\t\t\tP up3 = (p[0] * abs(p[2] - p[1]) + p[1] * abs(p[0] - p[2])) / (abs(p[2] - p[1]) + abs(p[0] - p[2]));\n\t\t\tP dn2 = p[1], dn3 = p[2];\n\t\t\trep(j, 80) {\n\t\t\t\tP m2 = (up2 + dn2)*0.5, m3 = (up3 + dn3)*0.5;\n\t\t\t\tr2 = dist_lp({ p[0],p[1] }, m2);\n\t\t\t\tr3 = dist_lp({ p[0],p[2] }, m3);\n\t\t\t\tif (dist_lp({ p[0],p[2] }, m2) > r2 && abs(m1 - m2) > r1 + r2)dn2 = m2;\n\t\t\t\telse up2 = m2;\n\t\t\t\tif (dist_lp({ p[0],p[1] }, m3) > r3 && abs(m3 - m1) > r1 + r3)dn3 = m3;\n\t\t\t\telse up3 = m3;\n\t\t\t}\n\t\t\tif (abs(up2 - up3) < r2 + r3)dn1 = m1;\n\t\t\telse up1 = m1;\n\t\t}\n\t\tcout << fixed << setprecision(10) << r1 << \" \" << r2 << \" \" << r3 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tVP p(3);\n\tfor (;;) {\n\t\trep(i, 3) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = { (double)x,(double)y };\n\t\t}\n\t\tif (p[0] == p[1])break;\n\t\tP up1 = (p[1] * abs(p[2] - p[0]) + p[2] * abs(p[1] - p[0])) / (abs(p[2] - p[0]) + abs(p[1] - p[0]));\n\t\tP dn1 = p[0];\n\t\tdouble r1,r2, r3;\n\t\trep(i, 60) {\n\t\t\tP m1 = (up1 + dn1) * 0.5l;\n\t\t\tr1 = dist_lp({ p[0],p[1] }, m1);\n\t\t\tP up2 = (p[0] * abs(p[2] - p[1]) + p[2] * abs(p[0] - p[1])) / (abs(p[2] - p[1]) + abs(p[0] - p[1]));\n\t\t\tP up3 = (p[0] * abs(p[2] - p[1]) + p[1] * abs(p[0] - p[2])) / (abs(p[2] - p[1]) + abs(p[0] - p[2]));\n\t\t\tP dn2 = p[1], dn3 = p[2];\n\t\t\trep(j, 60) {\n\t\t\t\tP m2 = (up2 + dn2)*0.5l, m3 = (up3 + dn3)*0.5l;\n\t\t\t\tr2 = dist_lp({ p[0],p[1] }, m2);\n\t\t\t\tr3 = dist_lp({ p[0],p[2] }, m3);\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[1],m2 }) && dist_lp({ p[0],p[2] }, m2) > r2 && abs(m1 - m2) > r1 + r2)dn2 = m2;\n\t\t\t\telse up2 = m2;\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[2],m3 }) && dist_lp({ p[0],p[1] }, m3) > r3 && abs(m3 - m1) > r1 + r3)dn3 = m3;\n\t\t\t\telse up3 = m3;\n\t\t\t}\n\t\t\tif (isis_ss({ p[1],up2 }, { p[2],up3 }) || abs(up2 - up3) < r2 + r3)dn1 = m1;\n\t\t\telse up1 = m1;\n\t\t}\n\t\tcout << fixed << setprecision(10) << r1 << \" \" << r2 << \" \" << r3 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tVP p(3);\n\tfor (;;) {\n\t\trep(i, 3) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = { (double)x,(double)y };\n\t\t}\n\t\tif (p[0] == p[1])break;\n\t\tP up1 = (p[1] * abs(p[2] - p[0]) + p[2] * abs(p[1] - p[0])) / (abs(p[2] - p[0]) + abs(p[1] - p[0]));\n\t\tP dn1 = p[0];\n\t\tdouble r1,r2, r3;\n\t\trep(i, 80) {\n\t\t\tP m1 = (up1 + dn1) * 0.5;\n\t\t\tr1 = dist_lp({ p[0],p[1] }, m1);\n\t\t\tP up2 = (p[0] * abs(p[2] - p[1]) + p[2] * abs(p[0] - p[1])) / (abs(p[2] - p[1]) + abs(p[0] - p[1]));\n\t\t\tP up3 = (p[0] * abs(p[2] - p[1]) + p[1] * abs(p[0] - p[2])) / (abs(p[2] - p[1]) + abs(p[0] - p[2]));\n\t\t\tP dn2 = p[1], dn3 = p[2];\n\t\t\trep(j, 80) {\n\t\t\t\tP m2 = (up2 + dn2)*0.5, m3 = (up3 + dn3)*0.5;\n\t\t\t\tr2 = dist_lp({ p[0],p[1] }, m2);\n\t\t\t\tr3 = dist_lp({ p[0],p[2] }, m3);\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[1],m2 }) && dist_lp({ p[0],p[2] }, m2) > r2 && abs(m1 - m2) > r1 + r2)dn2 = m2;\n\t\t\t\telse up2 = m2;\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[2],m3 }) && dist_lp({ p[0],p[1] }, m3) > r3 && abs(m3 - m1) > r1 + r3)dn3 = m3;\n\t\t\t\telse up3 = m3;\n\t\t\t}\n\t\t\tif (abs(up2 - up3) < r2 + r3)dn1 = m1;\n\t\t\telse up1 = m1;\n\t\t}\n\t\tcout << fixed << setprecision(10) << r1 << \" \" << r2 << \" \" << r3 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\n#include <fstream>\n#include <sstream>\nclass svg {\n\tofstream f;\n\tstringstream s;\n\tdouble x1 = 1e9, y1 = 1e9, x2 = -1e9, y2 = -1e9;\npublic:\n\tsvg(string path) :f(path, ios::trunc) {\n\t}\n\t~svg(){\n\t\tf << \"<?xml version=\\\"1.0\\\" standalone=\\\"no\\\"?><svg viewBox='\"<<x1*1.1-x2*0.1<<\" \"<<y1*1.1-y2*0.1<<\" \"<<(x2-x1)*1.2<<\" \"<<(y2-y1)*1.2<<\"' xmlns = \\\"http://www.w3.org/2000/svg\\\" xmlns:xlink = \\\"http://www.w3.org/1999/xlink\\\" >\\n\";\n\t\tf << s.str();\n\t\tf << \"</svg>\";\n\t}\n\tvoid circle(C c) {\n\t\ts << fixed << \"<circle cx = \\\"\" << c.p.real() << \"\\\" cy = \\\"\" << c.p.imag() << \"\\\" r = \\\"\" << c.r << \"\\\" stroke=\\\"black\\\" stroke-width=\\\"0.01\\\" fill = \\\"none\\\"/>\\n\";\n\t\tcmin(x1, c.p.real() - c.r);\n\t\tcmin(y1, c.p.imag() - c.r);\n\t\tcmax(x2, c.p.real() + c.r);\n\t\tcmax(y2, c.p.imag() + c.r);\n\t}\n\tvoid line(L l) {\n\t\ts << fixed << \"<line x1=\\\"\" << l.a.real() << \"\\\" y1=\\\"\" << l.a.imag() << \"\\\" x2=\\\"\" << l.b.real() << \"\\\" y2=\\\"\" << l.b.imag() << \"\\\" stroke=\\\"black\\\" stroke-width=\\\"0.01\\\"/>\\n\";\n\t\tcmin(x1, l.a.real());\n\t\tcmin(y1, l.a.imag());\n\t\tcmax(x2, l.a.real());\n\t\tcmax(y2, l.a.imag());\n\t\tcmin(x1, l.b.real());\n\t\tcmin(y1, l.b.imag());\n\t\tcmax(x2, l.b.real());\n\t\tcmax(y2, l.b.imag());\n\t}\n};\nint main() {\n\tVP p(3);\n\tfor (;;) {\n\t\trep(i, 3) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = { (double)x,(double)y };\n\t\t}\n\t\tif (p[0] == p[1])break;\n\t\tP up1 = (p[1] * abs(p[2] - p[0]) + p[2] * abs(p[1] - p[0])) / (abs(p[2] - p[0]) + abs(p[1] - p[0]));\n\t\tP dn1 = p[0];\n\t\tP up2, up3;\n\t\tdouble r1, r2, r3;\n\t\trep(i, 30) {\n\t\t\tP m1 = (up1 + dn1) * 0.5;\n\t\t\tr1 = dist_lp({ p[0],p[1] }, m1);\n\t\t\tup2 = (p[0] * abs(p[2] - p[1]) + p[2] * abs(p[0] - p[1])) / (abs(p[2] - p[1]) + abs(p[0] - p[1]));\n\t\t\tup3 = (p[0] * abs(p[2] - p[1]) + p[1] * abs(p[0] - p[2])) / (abs(p[2] - p[1]) + abs(p[0] - p[2]));\n\t\t\tP dn2 = p[1], dn3 = p[2];\n\t\t\trep(j, 30) {\n\t\t\t\tP m2 = (up2 + dn2)*0.5, m3 = (up3 + dn3)*0.5;\n\t\t\t\tr2 = dist_lp({ p[0],p[1] }, m2);\n\t\t\t\tr3 = dist_lp({ p[0],p[2] }, m3);\n\t\t\t\tif (!isis_ls({ p[0],up1 }, { p[1],m2 }) && dist_lp({ p[0],p[2] }, m2) > r2 && abs(m1 - m2) > r1 + r2)dn2 = m2;\n\t\t\t\telse up2 = m2;\n\t\t\t\tif (!isis_ls({ p[0],up1 }, { p[2],m3 }) && dist_lp({ p[0],p[1] }, m3) > r3 && abs(m3 - m1) > r1 + r3)dn3 = m3;\n\t\t\t\telse up3 = m3;\n\t\t\t\tcout << r2 << \",\" << r3 << endl;\n\t\t\t}\n\t\t\tif (dist_lp({ p[1],p[2] }, m1) > r1&&abs(up2 - up3) < r2 + r3)dn1 = m1;\n\t\t\telse up1 = m1;\n\t\tcout << r1 << \",\" << r2 << \",\" << r3 << endl;\n\t\t}\n\t\tcout << fixed << setprecision(10) << r1 << \",\" << r2 << \",\" << r3 << endl;\n\t\tsvg s(\"out.svg\");\n\t\trep(i, 3)s.line({ p[i],p[(i + 1) % 3] });\n\t\ts.circle({ up1,r1 });\n\t\ts.circle({ up2,r2 });\n\t\ts.circle({ up3,r3 });\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint x[3], y[3];\nint main() {\n\twhile (scanf(\"%d%d%d%d%d%d\", &x[0], &y[0], &x[1], &y[1], &x[2], &y[2]), x[0] | y[0] | x[1] | y[1] | x[2] | y[2]) {\n\t\tdouble l0 = hypot(1.0 * (x[1] - x[2]), 1.0 * (y[1] - y[2]));\n\t\tdouble l1 = hypot(1.0 * (x[2] - x[0]), 1.0 * (y[2] - y[0]));\n\t\tdouble l2 = hypot(1.0 * (x[0] - x[1]), 1.0 * (y[0] - y[1]));\n\t\tdouble t0 = ((x[1] - x[0]) * (x[2] - x[0]) + (y[1] - y[0]) * (y[2] - y[0])) / (l1 * l2);\n\t\tdouble t1 = ((x[2] - x[1]) * (x[0] - x[1]) + (y[2] - y[1]) * (y[0] - y[1])) / (l2 * l0);\n\t\tdouble t2 = ((x[0] - x[2]) * (x[1] - x[2]) + (y[0] - y[2]) * (y[1] - y[2])) / (l0 * l1);\n\t\tdouble a0 = 1.0 / tan(acos(t0) / 2.0);\n\t\tdouble a1 = 1.0 / tan(acos(t1) / 2.0);\n\t\tdouble a2 = 1.0 / tan(acos(t2) / 2.0);\n\t\tdouble l = 0.0, r = sqrt(min(l0, l1) / (a2 + 1.0)), lx = 0.0, ly = 0.0;\n\t\tfor (int i = 0; i < 60; i++) {\n\t\t\tdouble m = (l + r) * 0.5;\n\t\t\tdouble dx = a0 * l1 + (1.0 - a0 * a2) * m * m;\n\t\t\tdouble dy = a1 * l0 + (1.0 - a2 * a1) * m * m;\n\t\t\tlx = (-1.0 * m + sqrt(dx)) / a0;\n\t\t\tly = (-1.0 * m + sqrt(dy)) / a1;\n\t\t\tdouble lz = a0 * lx * lx + 2.0 * lx * ly + a1 * ly * ly;\n\t\t\tif (lz < l2) r = m;\n\t\t\telse l = m;\n\t\t}\n\t\tprintf(\"%.10lf %.10lf %.10lf\\n\", lx * lx, ly * ly, l * l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\n\nconstexpr ld eps = 1e-8;\nconstexpr ld pi = std::acos(-1.0);\n\n\nnamespace geometry2d {\n\n\nusing point = std::complex<long double>;\nusing polygon = std::vector<point>;\n\n\nbool eq(long double a, long double b) {\n    return (std::abs(a-b) < eps);\n}\n\nlong double dot(point a, point b) {\n    return std::real(std::conj(a) * b);\n}\n\nlong double cross(point a, point b) {\n    return std::imag(std::conj(a) * b);\n}\n\nclass segment {\npublic:\n    segment()\n        : a(point(0, 0)),\n          b(point(0, 0))\n    {}\n    segment(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n\n    point a, b;\n};\n\nclass line {\npublic:\n    line()\n        : a(point(0, 0)), b(point(0, 0))\n    {}\n    line(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n    line(segment s)\n        : a(s.a), b(s.b)\n    {}\n\n    point a, b;\n};\n\nclass circle {\npublic:\n    circle()\n        : p(point(0, 0)), r(0)\n    {}\n    circle(point p_, long double r_)\n        : p(p_), r(r_)\n    {}\n\n    point p;\n    long double r;\n};\n\n\nint ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if(cross(b, c) > eps)           return 1;  // a -> b -> c : counterclockwise\n    if(cross(b, c) < -eps)          return -1; // a -> b -> c : clockwise\n    if(dot(b, c) < 0)               return 2;  // c -> a -> b : line\n    if(std::norm(b) < std::norm(c)) return -2; // a -> b -> c : line\n    return 0;                                  // a -> c -> b : line\n}\n\n\nbool isis_ll(line l, line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(line l, segment s) {\n    return (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(line l, point p) {\n    return (std::abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(segment s, point p) {\n    return (std::abs(s.a - p) + std::abs(s.b - p) - std::abs(s.b - s.a) < eps);\n}\n\nbool isis_ss(segment s, segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n        && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n\npoint proj(line l, point p) {\n    long double t = dot(p - l.a, l.a - l.b) / std::norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\npoint is_ll(line s, line t) {\n    point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\npoint is_ss(segment s1, segment s2) {\n    assert(isis_ss(s1, s2));\n    point sv = s1.b - s1.a, tv = s2.b - s2.a;\n    if(cross(sv, tv) == 0) {\n        if(std::abs(s1.a - s2.a) < eps || std::abs(s1.a - s2.b) < eps) {\n            return s1.a;\n        } else {\n            return s1.b;\n        }\n    } else {\n        return is_ll(line(s1), line(s2));\n    }\n}\n\nlong double dist_lp(line l, point p) {\n    return std::abs(p - proj(l, p));\n}\n\nlong double dist_ll(line l, line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nlong double dist_ls(line l, segment s) {\n    return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nlong double dist_sp(segment s, point p) {\n    point r = proj(line(s), p);\n    return isis_sp(s, r) ? std::abs(r - p) : std::min(std::abs(s.a - p), std::abs(s.b - p));\n}\n\nlong double dist_ss(segment s, segment t) {\n    if(isis_ss(s, t)) return 0;\n    long double d1 = std::min(dist_sp(s, t.a), dist_sp(s, t.b));\n    long double d2 = std::min(dist_sp(t, s.a), dist_sp(t, s.b));\n    return std::min(d1, d2);\n}\n\n\n} // namespace geometry2d\n\nusing namespace geometry2d;\n\npoint rot(point p, ld ang) {\n    ld x = real(p) * cos(ang) - imag(p) * sin(ang);\n    ld y = real(p) * sin(ang) + imag(p) * cos(ang);\n    return point(x, y);\n}\n\ncircle calc(point cp, ld r, point const& limit, line l1, line l2) {\n    point lb = l1.a, ub = limit;\n    ld rad = 0;\n    for(int i = 0; i < 60; ++i) {\n        point m = 0.5l * (lb + ub);\n        rad = dist_lp(l1, m);\n\n        if(abs(cp - m) + eps < r + rad) {\n            ub = m;\n        } else {\n            lb = m;\n        }\n    }\n    return circle(lb, rad);\n}\n\nint main() {\n    int x1, y1, x2, y2, x3, y3;\n    while(cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3) {\n        if(x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0 && x3 == 0 && y3 == 0) {\n            break;\n        }\n        point p1(x1, y1), p2(x2, y2), p3(x3, y3);\n        point vec1 = rot(p2 - p1, (arg(p3 - p1) + arg(p2 - p1)) / 2 - arg(p2 - p1));\n        point vec2 = rot(p1 - p3, (arg(p1 - p3) + arg(p2 - p3)) / 2 - arg(p1 - p3));\n        point g = is_ll(line(p1, p1 + vec1), line(p3, p3 + vec2));\n\n        point lb = p1, ub = g; \n        ld r1, r2, r3;\n        for(int i = 0; i < 60; ++i) {\n            point m = (ub + lb) * 0.5l;\n            r1 = dist_lp(line(p1, p2), m);\n\n            auto c2 = calc(m, r1, g, line(p2, p1), line(p2, p3));\n            auto c3 = calc(m, r1, g, line(p3, p1), line(p3, p2));\n            r2 = c2.r;\n            r3 = c3.r;\n            if(abs(c2.p - c3.p) + eps < c2.r + c3.r) {\n                lb = m;\n            } else {\n                ub = m;\n            }\n        }\n\n        cout << setprecision(10) << fixed;\n        cout << r1 << ' ' << r2 << ' ' << r3 << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <complex>\n#include <cmath>\n#include <vector>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Pol;\ndouble x[3],y[3],eps=1e-10;\nP p[3],m[3],ran=P(1048576,1048576);\nPol tri;\nbool eq(D a, D b) { return abs(a-b)<eps;}\ninline D cro(P a,P b){\n\treturn imag(conj(a)*b);\n}\ninline int ccw (P a, P b, P c){\n\tif(cro(b-a,c-a)>eps) return 1;\n\tif(cro(b-a,c-a)<-eps) return -1;\n\tif(eq(abs(a-c)+abs(c-b),abs(a-b))) return 0;\n\tif(eq(abs(a-b)+abs(b-c),abs(a-c))) return -2;\n\tif(eq(abs(c-a)+abs(a-b),abs(c-b))) return 2;\n}\nenum ENCONT{INP=1,ONP=0,OUTP=-1};\nint contain(Pol pol, P p){\n\tbool in=false;\n\trep(i,pol.size()){\n\t\tP a=pol[i]-p,b=pol[(i+1)%pol.size()]-p;\n\t\tif(ccw(a,b,P(0,0))==0) return ONP;\n\t\tif(imag(a)>imag(b)) swap(a,b);\n\t\tif(imag(a)<eps && eps<imag(b) && ccw(P(0,0),a,b)==1) in=!in;\n\t}\n\treturn in ? INP : OUTP;\n}\ninline D verlength(L l,P p){\n\treturn abs(cro(l.fs-l.sc,p-l.sc)/abs(l.fs-l.sc));\n}\nbool containC(Pol tri,P p,L l,D r){\n\treturn (contain(tri,p)==1)&&verlength(l,p)>r;\n}\nP decidec2(P c1,D r1){\n\tdouble ub=100000,lb=0;\n\tP c2;\n\tD r2;\n\twhile(ub-lb>eps){\n\t\tdouble mid=(ub+lb)/2;\n\t\tc2=p[1]+mid*m[1];\n\t\tr2=verlength(L(p[1],p[2]),c2);\n\t\tif(!containC(tri,c2,L(p[2],p[0]),r2)){\n\t\t\tub=mid;\n\t\t\tcontinue;\n\t\t}\n\t\tif(abs(c1-c2)>r1+r2) lb=mid;\n\t\telse ub=mid;\n\t}\n//\tcout<<ub<<\"   \"<<abs(c1-c2)<<\" \"<<r1+r2<<endl;\n//\tif(abs(abs(c1-c2)-(r1+r2))>1e-5) return ran;\n\treturn c2;\n}\nP decidec3(P c2,D r2){\n\tdouble ub=100000,lb=0;\n\tP c3;\n\twhile(ub-lb>eps){\n\t\tdouble mid=(ub+lb)/2;\n\t\tc3=p[2]+mid*m[2];\n\t\tD r3=verlength(L(p[2],p[0]),c3);\n\t\tif(!containC(tri,c3,L(p[0],p[1]),r3)){\n\t\t\tub=mid;\n\t\t\tcontinue;\n\t\t}\n\t\tif(abs(c2-c3)>r2+r3) lb=mid;\n\t\telse ub=mid;\n\t}\n\treturn c3;\n}\nint main(){\n\twhile(true){\n\t\trep(i,3) cin>>x[i]>>y[i];\n\t\trep(i,3) p[i]=P(x[i],y[i]);\n\t\tif(p[0]==p[1]) break;\n\t\ttri.clear();\n\t\trep(i,3) tri.push_back(p[i]);\n\t\trep(i,3){\n\t\t\tint cu=i,ne1=(i+1)%3,ne2=(i+2)%3;\n\t\t\tP a=p[ne1]-p[cu],b=p[ne2]-p[cu];\n\t\t\ta/=abs(a);\n\t\t\tb/=abs(b);\n\t\t\tm[i]=a+b;\n\t\t\tm[i]/=abs(m[i]);\n\t\t}\n\t\tdouble ub=100000,lb=0;\n\t\tD r1,r2,r3;\n\t\tP c1,c2,c3;\n\t\twhile(ub-lb>eps){\n\t\t\tdouble mid=(ub+lb)/2;\n\t\t\tc1=p[0]+mid*m[0];\n\t\t\tr1=verlength(L(p[0],p[1]),c1);\n\t\t\tif(!containC(tri,c1,L(p[1],p[2]),r1)){\n\t\t\t\tub=mid;\n\t\t\t\tcontinue;\n\t\t\t}\n/*\t\t\tif(r1<0.01){\n\t\t\t\tlb=mid;\n\t\t\t\tcontinue;\n\t\t\t}*/\n\t\t\tc2=decidec2(c1,r1);\n//\t\t\tcout<<\"c1 \"<<c1<<endl;\n//\t\t\tcout<<\"r1 \"<<r1<<endl;\n//\t\t\tcout<<\"c2 \"<<c2<<endl;\n\t\t\tr2=verlength(L(p[1],p[2]),c2);\n/*\t\t\tif(r2<0.01){\n\t\t\t\tub=mid;\n\t\t\t\tcontinue;\n\t\t\t}*/\n\t\t\tc3=decidec3(c2,r2);\n\t\t\tr3=verlength(L(p[2],p[0]),c3);\n/*\t\t\tif(r3<0.01){\n\t\t\t\tlb=mid;\n\t\t\t\tcontinue;\n\t\t\t}*/\n\t\t\tif(abs(c3-c1)>r3+r1) lb=mid;\n\t\t\telse ub=mid;\n//\t\t\tcout<<\"c3 \"<<c3<<endl;\n\t\t}\n//\t\tcout<<\"dist(c1,c2)= \"<<abs(c1-c2)<<endl;\n//\t\tcout<<\"dist(c2,c3)= \"<<abs(c2-c3)<<endl;\n//\t\tcout<<\"dist(c3,c1)= \"<<abs(c3-c1)<<endl;\n\t\tprintf(\"%.10f %.10f %.10f\\n\",r1,r2,r3);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <vector>\n#define EPS (1e-10)\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,double> C;\n\ndouble cross(P a, P b){ return a.X*b.Y - a.Y*b.X;}\n\nvector<double> malfatti_circle(P a, P b, P c){\n  const double A = abs(b-c), B = abs(a-c), C = abs(a-b), r = abs(cross(b-a,c-a))/(A+B+C),\n    x = (-A+B+C)/2.0/r, y = (A-B+C)/2.0/r, z = (A+B-C)/2.0/r;\n  vector<double> ret(3);\n  double r_a, r_b, r_c, small = 0.0, large = r;\n  for(int i = 0; i < 100; ++i){\n    r_a = (small+large)/2.0;\n    double s = y*y, t = x*y*r_a - C*y - 2*r_a, u = C*C - 2.0*C*x*r_a + x*x*r_a*r_a;\n    r_b = (-t - sqrt(t*t - s*u))/s;\n    s = z*z;\n    t = x*z*r_a - B*z - 2*r_a;\n    u = B*B - 2.0*B*x*r_a + x*x*r_a*r_a;\n    r_c = (-t - sqrt(t*t - s*u))/s;\n    if(2*sqrt(r_b*r_c) + y*r_b + z*r_c > A){\n      small = r_a;\n    }else{\n      large = r_a;\n    }\n  }\n  ret[0] = r_a;\n  ret[1] = r_b;\n  ret[2] = r_c;\n  return ret;\n}\n\nint main(){\n  double x_a, y_a, x_b, y_b, x_c, y_c;\n  while(cin >> x_a >> y_a >> x_b >> y_b >> x_c >> y_c, x_a||y_a||x_b||y_b||x_c||y_c){\n    P a = P(x_a,y_a), b = P(x_b,y_b), c = P(x_c,y_c);\n    vector<double> R = malfatti_circle(a,b,c);\n    for(int i = 0; i < 3; ++i){\n      printf(\"%.12f\", R[i]);\n      if(i < 3) cout << \" \";\n    }cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tVP p(3);\n\tfor (;;) {\n\t\trep(i, 3) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = { (double)x,(double)y };\n\t\t}\n\t\tif (p[0] == p[1])break;\n\t\tP up1 = (p[1] * abs(p[2] - p[0]) + p[2] * abs(p[1] - p[0])) / (abs(p[2] - p[0]) + abs(p[1] - p[0]));\n\t\tP dn1 = p[0];\n\t\tdouble r1,r2, r3;\n\t\trep(i, 80) {\n\t\t\tP m1 = (up1 + dn1) * 0.5;\n\t\t\tr1 = dist_lp({ p[0],p[1] }, m1);\n\t\t\tP up2 = (p[0] * abs(p[2] - p[1]) + p[2] * abs(p[0] - p[1])) / (abs(p[2] - p[1]) + abs(p[0] - p[1]));\n\t\t\tP up3 = (p[0] * abs(p[2] - p[1]) + p[1] * abs(p[0] - p[2])) / (abs(p[2] - p[1]) + abs(p[0] - p[2]));\n\t\t\tP dn2 = p[1], dn3 = p[2];\n\t\t\trep(j, 80) {\n\t\t\t\tP m2 = (up2 + dn2)*0.5, m3 = (up3 + dn3)*0.5;\n\t\t\t\tr2 = dist_lp({ p[0],p[1] }, m2);\n\t\t\t\tr3 = dist_lp({ p[0],p[2] }, m3);\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[1],m2 }) && dist_lp({ p[0],p[2] }, m2) > r2 && abs(m1 - m2) > r1 + r2)dn2 = m2;\n\t\t\t\telse up2 = m2;\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[2],m3 }) && dist_lp({ p[0],p[1] }, m3) > r3 && abs(m3 - m1) > r1 + r3)dn3 = m3;\n\t\t\t\telse up3 = m3;\n\t\t\t}\n\t\t\tif (isis_ss({ p[1],up2 }, { p[2],up3 }) || abs(up2 - up3) < r2 + r3)dn1 = m1;\n\t\t\telse up1 = m1;\n\t\t}\n\t\tcout << fixed << setprecision(10) << r1 << \" \" << r2 << \" \" << r3 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\ntypedef long double D;\ntypedef complex<D> P;\n\n#define X real()\n#define Y imag()\n\nconst D eps=1e-8;\nconst D inf=1e12;\nconst D PI=acos(-1);\n\nD cross(P a,P b){ return (conj(a)*b).Y; }\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\nP projection(L l,P p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*(c/b).X;\n}\nD distanceLP(L l,P p) {\n  return abs(p-projection(l,p));\n}\nP crosspoint(L l,L m) {\n  D A=cross(l[1]-l[0],m[1]-m[0]);\n  D B=cross(l[1]-l[0],l[1]-m[0]);\n  if (abs(A)<eps&&abs(B)<eps) return m[0]; // same line\n  if (abs(A)<eps) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0]+B/A*(m[1]-m[0]);\n}\n\nP p[3],q[3],e[3],x[3];\nD r[3];\nP g;\nP cp;\n\nbool ok(){\n  r[0]=distanceLP(L(p[0],p[1]),x[0]);\n  repl(i,1,3){\n    D lb=0,ub=abs(cp-p[i]);\n    rep(hoge,100){\n      D mid=(ub+lb)/2.0;\n      x[i]=p[i]+e[i]*mid;\n      r[i]=distanceLP(L(p[i],p[(i+1)%3]),x[i]);\n      D d0i=abs(x[i]-x[0]);\n      if(d0i>r[0]+r[i])lb=mid;\n      else ub=mid;\n    }\n  }\n  D d12=abs(x[1]-x[2]);\n  return d12>r[1]+r[2];\n}\n\nint main(){\n  while(1){\n    bool done=true;\n    rep(i,3){\n      int x,y;\n      cin>>x>>y;\n      if(x!=0||y!=0)done=false;\n      p[i]=P(x,y);\n    }\n    if(done)break;\n\n    D absA=abs(p[2]-p[1]); D absB=abs(p[2]-p[0]); D absC=abs(p[1]-p[0]);\n    q[0]=(p[1]*absB+p[2]*absC)/(absB+absC);\n    q[1]=(p[0]*absA+p[2]*absC)/(absA+absC);\n    q[2]=(p[0]*absA+p[1]*absB)/(absA+absB);\n    cp=crosspoint(L(p[1],q[1]),L(p[2],q[2]));\n    rep(i,3)e[i]=(q[i]-p[i])/abs(q[i]-p[i]);\n    D lb=0,ub=abs(cp-p[0]);\n    rep(hoge,100){\n      D mid=(lb+ub)/2.0;\n      x[0]=p[0]+e[0]*mid;\n      if(ok())ub=mid;\n      else lb=mid;\n    }\n    printf(\"%.5Lf %.5Lf %.5Lf\\n\", r[0], r[1], r[2]);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nld dist(pair<ld,ld> A,pair<ld,ld> B){\n\treturn sqrt((A.fr-B.fr)*(A.fr-B.fr)+(A.sc-B.sc)*(A.sc-B.sc));\n}\nld Area(pair<ld,ld> A,pair<ld,ld> B,pair<ld,ld> C){\n\treturn abs((B.fr-A.fr)*(C.sc-A.sc)-(C.fr-A.fr)*(B.sc-A.sc))/2.0;\n}\n\npair<ld,ld> f(pair<ld,ld> A,pair<ld,ld> B,pair<ld,ld> C){\n\tld d1 = dist(A,B);\n\tld d2 = dist(A,C);\n\treturn pair<ld,ld>((B.fr*d2+C.fr*d1)/(d1+d2),(B.sc*d2+C.sc*d1)/(d1+d2));\n}\npair<ld,ld> g(pair<ld,ld> A,pair<ld,ld> B,ld x,ld y){\n\tA.fr += (B.fr-A.fr)*y/x;\n\tA.sc += (B.sc-A.sc)*y/x;\n\treturn A;\n}\n\nint main(){\n\twhile(1){\n\t\tint x[3],y[3];\n\t\trep(i,3)scanf(\"%d%d\",&x[i],&y[i]);\n\t\tif(x[0] == x[1] && y[0] == y[1])break;\n\t\tpair<ld,ld> p[3];\n\t\tp[0] = pair<ld,ld>(x[0],y[0]);\n\t\tp[1] = pair<ld,ld>(x[1],y[1]);\n\t\tp[2] = pair<ld,ld>(x[2],y[2]);\n\t\tpair<ld,ld> I = f(p[1],p[0],f(p[0],p[1],p[2]));\n\t\t\n\t\tld Ir = Area(p[0],p[1],p[2])*2.0/(dist(p[0],p[1])+dist(p[1],p[2])+dist(p[2],p[0]));\n\t\t\n\t\t//cout << I.fr << \" \" << I.sc << endl;\n\t\t//cout << Ir << endl;\n\t\t\n\t\tld A[3];\n\t\t\n\t\tld l=0,r=Ir;\n\t\twhile(l+0.0000001<r){\n\t\t\tld R0 = (l+r)/2.0;\n\t\t\tpair<ld,ld> q[1] = {g(p[0],I,Ir,R0)};\n\t\t\tld R1_l=0,R1_r=Ir;\n\t\t\twhile(R1_l+0.0000001<R1_r){\n\t\t\t\tld R1 = (R1_l+R1_r)/2.0;\n\t\t\t\tif(dist(g(p[1],I,Ir,R1),q[0]) > R0+R1)R1_l = R1;\n\t\t\t\telse R1_r = R1;\n\t\t\t}\n\t\t\tld R2_l=0,R2_r=Ir;\n\t\t\twhile(R2_l+0.0000001<R2_r){\n\t\t\t\tld R2 = (R2_l+R2_r)/2.0;\n\t\t\t\tif(dist(g(p[2],I,Ir,R2),q[0]) > R0+R2)R2_l = R2;\n\t\t\t\telse R2_r = R2;\n\t\t\t}\n\t\t\t//cout << R1_l << \" \" << R2_l << endl;\n\t\t\tif(dist(g(p[1],I,Ir,R1_l),g(p[2],I,Ir,R2_l)) < R1_l+R2_l){\n\t\t\t\tl=R0;\n\t\t\t}\n\t\t\telse r=R0;\n\t\t\tA[0] = R0;\n\t\t\tA[1] = R1_l;\n\t\t\tA[2] = R2_l;\n\t\t}\n\t\tcout.precision(20);\n\t\tcout << A[0] << \" \" << A[1] << \" \" << A[2] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-7;\nconst double PI = acos(-1);\nconst int INF = 1<<24;\n\nbool equals(double a, double b) { return fabs(a - b) < EPS; }\n\nnamespace std {\n  bool operator < (const P &a, const P b) {\n    return ( a.real() != b.real()\n\t     ? a.real() < b.real() : a.imag() < b.imag() );\n  }\n}\n\nstruct L : public vector<P> {\n  L(P a, P b) {\n    push_back(a), push_back(b);\n  }\n};\n\nstruct C {\n  P o;\n  double r;\n  C() {}\n  C(P o, double r) : o(o), r(r) {}\n};\n\ndouble norm(P a) { return a.real()*a.real() + a.imag() * a.imag(); }\ndouble abs (P a) { return sqrt(norm(a)); }\ndouble dot  (P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\ndouble cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\n\nbool isOrthogonal(P a, P b) { return equals(dot(a, b), 0.0); }\nbool isParallel  (P a, P b) { return equals(cross(a, b), 0.0); }\n\nP project(P s1, P s2, P p) {\n  P base = s2 - s1;\n  double t = dot(p - s1, base)/norm(base);\n  return s1 + base*t;\n}\n\nP reflect(P s1, P s2, P p) { return p + (project(s1, s2, p) - p)*2.0; }\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return fabs(cross(s2 - s1, p - s1)/abs(s2 - s1));\n}\n\nP getRotateP(P p, double rad, P o = P(0, 0)) {\n  P q = p - o;\n  return o + P(q.real()*cos(rad) - q.imag()*sin(rad),\n\t   q.real()*sin(rad) + q.imag()*cos(rad));\n}\n\nnamespace CCW {\n  enum { COUNTER_CLOCKWISE = 1, CLOCKWISE = -1,\n\t ONLINE_BACK = 2, ONLINE_FRONT = -2,\n\t ONSEGMENT = 0 };\n}\nint ccw(P p0, P a, P b) {\n  a -= p0;\n  b -= p0;\n  if(cross(a, b) > EPS) return CCW::COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CCW::CLOCKWISE;\n  if(dot(a, b) < -EPS) return CCW::ONLINE_BACK;\n  if(norm(a) < norm(b)) return CCW::ONLINE_FRONT;\n  return CCW::ONSEGMENT;\n}\n\n// üªÆüªÌð·»èB\nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t   ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\n// ¼üÆ~Ìð·»èBßèlÍð_ÌB\nint isIntersect(P s1, P s2, C c) {\n  double d = getDistanceLP(s1, s2, c.o);\n  if(equals(d, c.r)) return 1;\n  else if(d < c.r) return 2;\n  else return 0;\n}\n\n// ~Æ~Ìð·»èB\n//  0 : ð·AàïÈµ\n//  1 : OÅ1_ÆÚ·é\n//  2 : 2_Åð·\n// -1 : àïµÄÚ·é\n// -2 : ®SÉàï\nint isIntersect(C a, C b) {\n  double x = a.o.real() - b.o.real();\n  double y = a.o.imag() - b.o.imag();\n  double s = a.r + b.r;\n  double d = x*x + y*y;\n  s *= s;\n  if(equals(d, s)) return 1;\n  if(d > s) return 0;\n  double r = abs(a.r - b.r);\n  r *= r;\n  if(equals(d, r)) return -1;\n  if(d > r) return 2;\n  return -2;\n}\n\n// ¼üÆ¼üÌð_B\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  // cross ÌÖW è\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\n// ¼üÆ~Ìð_B\nvector<P> getCrossP(P s1, P s2, C c) {\n  vector<P> v;\n  P p = project(s1, s2, c.o);\n  if(isIntersect(s1, s2, c) == 1) {\n    v.push_back(p);\n  } else {\n    double h = abs(p-c.o);\n    double d = sqrt(c.r*c.r - h*h);\n    P base = s2 - s1;\n    v.push_back(p + d*base/abs(base));\n    v.push_back(p - d*base/abs(base));\n  }\n  return v;\n}\n\n// xNg(1, 0)ðîÆµ½xNgÌpx(-PI <= rad <= PI)\ndouble getAngle(P a) {\n  return atan2(a.imag(), a.real());\n}\n\n// 2ÂÌxNgÌÈ·p(0 <= rad <= PI)\ndouble getAngle(P a, P b) {\n  double rad1 = getAngle(a);\n  double rad2 = getAngle(b);\n  if(rad1 < 0) rad1 += 2*PI;\n  if(rad2 < 0) rad2 += 2*PI;\n  double res = fabs(rad1 - rad2);\n  return res > PI ? 2*PI-res : res;\n  /*  if(cross(a, b) < 0.0) swap(a, b);\n      return getAngle(b) - getAngle(a);*/\n  //return acos(dot(a, b)/abs(a)/abs(b));\n}\n\n// 2ÂÌ¼üÉÚ·é¼arÌ~\nC getC(P a1, P a2, P b1, P b2, double r) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  if(cross(a, b) < 0) swap(a, b);\n  P p = getCrossP(a1, a2, b1, b2);\n  double rad = getAngle(a, b) / 2.0;\n  double alpha = getAngle(a);\n  C res;\n  res.r = r;\n  res.o = p + P(cos(alpha + rad), sin(alpha + rad)) * r / sin(rad);\n  return res;\n}\n\n// wÌö®ðp¢ÄOp`Ì3ÓÌ·³©çÊÏðßé\ndouble heron(double a, double b, double c) {\n  double s = (a+b+c)/2.0;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\n// ½p`ÌÊÏ\ndouble getArea(vector<P> &G) {\n  int n = G.size();\n  double S = 0;\n  for(int i = 0; i < n; ++i) {\n    S += cross(G[i], G[(i+1)%n]);\n  }\n  return S/2.0;\n}\n\n// Op`ÌàÚ~Ì¼a\ndouble getIncircleR(P p1, P p2, P p3) {\n  double a = abs(p1 - p2);\n  double b = abs(p2 - p3);\n  double c = abs(p3 - p1);\n  return heron(a,b,c)*2.0/(a+b+c);\n}\n\nC getIncircle(P p1, P p2, P p3) {\n  return getC(p1, p2, p1, p3, getIncircleR(p1, p2, p3));\n}\n\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for(int i = 0; i < n; ch[k++] = ps[i++])\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = CCW::CLOCKWISE) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\nP p[3];\nC incircle;\n\nC calc(P a1, P a2, P b1, P b2, C c) {\n  C res;\n  double s, t;\n  s = 0.0, t = incircle.r;\n  while(1) {\n    double r = (s+t)/2.0;\n    res = getC(a1, a2, b1, b2, r);\n    int tmp = isIntersect(c, res);\n    if(tmp == 0) {\n      s = r;\n    } else if(tmp == 1) {\n      return res;\n    } else {\n      t = r;\n    }\n  }\n}\n\nvoid solve() {\n  incircle = getIncircle(p[0], p[1], p[2]);\n  double s, t;\n  C c[3];\n  s = 0.0, t = incircle.r;\n  while(1) {\n    double r = (s+t)/2.0;\n    c[0] = getC(p[0], p[1], p[0], p[2], r);\n\n    if(!isIntersect(c[0], incircle)) {\n      s = r;\n      continue;\n    }\n\n    c[1] = calc(p[1], p[2], p[1], p[0], c[0]);\n    c[2] = calc(p[2], p[0], p[2], p[1], c[0]);\n\n    int tmp = isIntersect(c[1], c[2]);\n\n    if(tmp == 1) {\n      for(int i = 0; i < 3; ++i) {\n\tif(i) printf(\" \");\n\tprintf(\"%.6f\", c[i].r);\n      }\n      printf(\"\\n\");\n      return;\n    } else if(tmp == 0) {\n      t = r;\n    } else {\n      s = r;\n    }\n  }\n}\n\nint main() {\n  while(1) {\n    bool allZero = true;\n    for(int i = 0; i < 3; ++i) {\n      cin >> p[i].real() >> p[i].imag();\n      if(p[i].real() != 0 || p[i].imag() != 0) allZero = false;\n    }\n    if(allZero) break;\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#define POINT_A 1\n#define POINT_B 2\n#define POINT_C 3\n#define EPS 1.0e-6\nusing namespace std;\ntypedef long double elem;\ntypedef complex<elem> point, vec;\nbool eq(elem a, elem b){return abs(a - b)<EPS; } \nvec normv(const vec &v){return v/abs(v);}\nelem dist(const point &a, const point &b){return abs(a-b); }\nelem dot(const vec &a, const vec &b){return a.real()*b.real()+a.imag()*b.imag();}\nelem AreaOfTriangle(elem a, elem b, elem c){ elem s = (a+b+c)/2; return sqrt(s)*sqrt(s-a)*sqrt(s-b)*sqrt(s-c); }\nelem InradiusOfTriangle(elem a, elem b, elem c){ return AreaOfTriangle(a,b,c) / (a+b+c); }\nelem InradiusOfTriangleByMalfatti(elem r1, elem r2, elem r3){ return ( 2 * sqrt(r1*r2*r3) ) / ( sqrt(r1)+sqrt(r2)+sqrt(r3) - sqrt(r1+r2+r3) ); }\nelem QueryR(point A, point B, point C, elem ka, elem Ra, int query){\n\tvec v1,v2,px,X,e;\n\tpoint p;\n\t\n\tX = ka * ( normv( normv(B-A) + normv(C-A) ) ) + A;\n\tif( query == POINT_B ){ v1 = A-B; v2 = C-B; p = B;\n\t}else if(  query == POINT_C ){ v1 = A-C; v2 = B-C; p = C; }\n\tpx = X - p;\n\te = normv( normv(v1) + normv(v2) );\n\n\t//cout << \"E: \" << e << \" X: \" << X << endl;\n\n\telem sinH = sin( acos( dot(v1,v2) / (abs(v1)*abs(v2)) ) / 2 );\n\telem a = 1 - ( 1 / pow(sinH,2) );\n\telem b = Ra + dot(px,e)/sinH;\n\telem c = pow(Ra,2)-pow(abs(px),2);\n\n\telem candR1 = ( -b + sqrt( pow(b,2) - a*c ) ) / a;\n\telem candR2 = ( -b - sqrt( pow(b,2) - a*c ) ) / a;\n\n\t//cout << \"POINT \" << p << \"CAND R1: \" << candR1 << \" CAND R2: \" << candR2 << endl;\n\n\tif( candR1 * candR2 < 0 )\n\t\treturn max( candR1, candR2 );\n\telse\n\t\treturn min( candR1, candR2 );\n}\nint main(){\n\twhile(true){\n\t\tpoint A,B,C;\t\t\t\t// ¸_\n\t\telem a,b,c;\t\t\t\t\t// ÎÓÌå«³\n\t\telem sinAh, sinBh, sinCh;\t// sin(A/2)ÈÇ\n\t\telem ka,kb,kc;\n\t\telem Ra, Rb, Rc;\n\n\t\telem xa,ya,xb,yb,xc,yc;\n\t\tscanf(\"%Lf%Lf%Lf%Lf%Lf%Lf\",&xa,&ya,&xb,&yb,&xc,&yc);\n\t\tif(xa==0.0&&ya==0.0&&xb==0.0&&yb==0.0&&xc==0.0&&yc==0.0)break;\n\n\t\tA.real(xa);A.imag(ya); B.real(xb);B.imag(yb); C.real(xc);C.imag(yc);\n\t\ta = abs( B-C ); b = abs( C-A ); c = abs( B-A );\n\t\tvec v1,v2;\n\t\tv1 = B - A; v2 = C - A; sinAh=sin( acos( dot(v1,v2) / (abs(v1)*abs(v2)) ) / 2 );\n\t\tv1 = A - B; v2 = C - B; sinBh=sin( acos( dot(v1,v2) / (abs(v1)*abs(v2)) ) / 2 );\n\t\tv1 = A - C; v2 = B - C; sinCh=sin( acos( dot(v1,v2) / (abs(v1)*abs(v2)) ) / 2 );\n\n\t\t/* binary serach */\n\t\tRa = Rb = Rc = 0.0;\n\t\telem l = 0;\n\t\telem r = 2 * abs( ((c/(b+c))*(C-B) + B) - A );\n\t\twhile( r > l + EPS )\n\t\t{\n\t\t\telem m = (l+r)/2;\n\t\t\t//printf(\"L=%Lf M=%Lf R=%Lf Ra=%Lf Rb=%Lf Rc=%Lf\\n\", l,m,r,Ra,Rb,Rc);\n\t\t\tka = m;\n\t\t\tRa = sinAh * ka;\n\t\t\tRb = QueryR(A,B,C,ka,Ra,POINT_B);\n\t\t\tRc = QueryR(A,B,C,ka,Ra,POINT_C);\n\t\t\tkb = Rb / sinBh;\n\t\t\tkc = Rc / sinCh;\n\t\t\tvec BY = kb * normv( normv(A-B) + normv(C-B) );\n\t\t\tvec CZ = kc * normv( normv(A-C) + normv(B-C) );\n\t\t\telem d = dist( B + BY, C + CZ );\n\t\t\tif( eq(d-(Rb+Rc),0.0) )\n\t\t\t\tbreak;\n\t\t\telse if( d > Rb + Rc ){\n\t\t\t\tr = m;\n\t\t\t}else{\n\t\t\t\tl = m;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.5Lf %.5Lf %.5Lf\\n\", Ra, Rb, Rc);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tVP p(3);\n\tfor (;;) {\n\t\trep(i, 3) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = { (double)x,(double)y };\n\t\t}\n\t\tif (p[0] == p[1])break;\n\t\tP up1 = (p[1] * abs(p[2] - p[0]) + p[2] * abs(p[1] - p[0])) / (abs(p[2] - p[0]) + abs(p[1] - p[0]));\n\t\tP dn1 = p[0];\n\t\tdouble r1,r2, r3;\n\t\trep(i, 100) {\n\t\t\tP m1 = (up1 + dn1) * 0.5l;\n\t\t\tr1 = dist_lp({ p[0],p[1] }, m1);\n\t\t\tP up2 = (p[0] * abs(p[2] - p[1]) + p[2] * abs(p[0] - p[1])) / (abs(p[2] - p[1]) + abs(p[0] - p[1]));\n\t\t\tP up3 = (p[0] * abs(p[2] - p[1]) + p[1] * abs(p[0] - p[2])) / (abs(p[2] - p[1]) + abs(p[0] - p[2]));\n\t\t\tP dn2 = p[1], dn3 = p[2];\n\t\t\trep(j, 100) {\n\t\t\t\tP m2 = (up2 + dn2)*0.5l, m3 = (up3 + dn3)*0.5l;\n\t\t\t\tr2 = dist_lp({ p[0],p[1] }, m2);\n\t\t\t\tr3 = dist_lp({ p[0],p[2] }, m3);\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[1],m2 }) && dist_lp({ p[0],p[2] }, m2) > r2 && abs(m1 - m2) > r1 + r2)dn2 = m2;\n\t\t\t\telse up2 = m2;\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[2],m3 }) && dist_lp({ p[0],p[1] }, m3) > r3 && abs(m3 - m1) > r1 + r3)dn3 = m3;\n\t\t\t\telse up3 = m3;\n\t\t\t}\n\t\t\tif (isis_ss({ p[1],up2 }, { p[2],up3 }) || abs(up2 - up3) < r2 + r3)dn1 = m1;\n\t\t\telse up1 = m1;\n\t\t}\n\t\tcout << fixed << setprecision(10) << r1 << \" \" << r2 << \" \" << r3 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <stdio.h>\n\nusing namespace std;\n\nconst double EPS = 1e-12;\n\ntypedef complex<double> P;\nstruct L{ P p, q; L(P p, P q) : p(p), q(q) {} };\n\ndouble cross(P a, P b) { return imag(conj(a)*b); }\n\ndouble lpDist(L l, P p){\n\treturn abs(cross(l.q-l.p,p-l.p))/abs(l.q-l.p);\n}\n\nP crossPoint(L l, L m){\n\tdouble A = cross(l.q-l.p, m.q-m.p);\n\tdouble B = cross(l.q-l.p, l.q-m.p);\n\treturn m.p + B/A*(m.q-m.p);\n}\n\nint main(){\n\tint x1, y1, x2, y2, x3, y3;\n\twhile(cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3){\n\t\tif(!(x1||y1||x2||y2||x3||y3)) break;\n\t\tP p1 = P(x1,y1), p2 = P(x2,y2), p3 = P(x3,y3);\n\t\tP dirA = (p2-p1)/abs(p2-p1)+(p3-p1)/abs(p3-p1);\n\t\tP dirB = (p1-p2)/abs(p1-p2)+(p3-p2)/abs(p3-p2);\n\t\tP c = crossPoint(L(p1,p1+dirA),L(p2,p2+dirB));\n\t\tdouble rA, rB, rC;\n\t\tdouble leftA = 0.0, rightA = 1.0, leftB, rightB, leftC, rightC;\n\t\twhile(true){\n\t\t\tdouble midA = (leftA+rightA)/2;\n\t\t\tP cA = p1 + (c-p1)*midA, cB, cC;\n\t\t\trA = lpDist(L(p1,p2), cA);\n\t\t\tleftB = 0.0, rightB = 1.0, leftC = 0.0, rightC = 1.0;\n\t\t\twhile(rightB-leftB>EPS){\n\t\t\t\tdouble midB = (leftB+rightB)/2;\n\t\t\t\tcB = p2 + (c-p2)*midB;\n\t\t\t\trB = lpDist(L(p2,p3), cB);\n\t\t\t\tif(rA+rB < abs(cB-cA)) leftB  = midB;\n\t\t\t\telse                   rightB = midB;\n\t\t\t}\n\t\t\twhile(rightC-leftC>EPS){\n\t\t\t\tdouble midC = (leftC+rightC)/2;\n\t\t\t\tcC = p3 + (c-p3)*midC;\n\t\t\t\trC = lpDist(L(p3,p1), cC);\n\t\t\t\tif(rA+rC < abs(cC-cA)) leftC  = midC;\n\t\t\t\telse                   rightC = midC;\n\t\t\t}\n\t\t\tif(rB+rC > abs(cB-cC)) leftA  = midA;\n\t\t\telse                   rightA = midA;\n\t\t\tif(rightA-leftA < EPS){\n\t\t\t\tprintf(\"%.6lf %.6lf %.6lf\\n\", rA, rB, rC);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Point{\n\tvoid set(double arg_x,double arg_y){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t}\n\tdouble x,y;\n};\n\nint X1,X2,X3,Y1,Y2,Y3;\nPoint A,B,C,center;\nPoint face_A,face_B,face_C;\ndouble len_A,len_B,len_C;\ndouble half_len_sum,S;\ndouble inner_R;\ndouble dist1,dist2,dist3;\ndouble R1,R2,R3;\n\n\n//交点を求める関数\nPoint calc_Cross_Point(double x1,double x2,double x3,double x4,double y1,double y2,double y3,double y4){\n\tPoint ret;\n\tret.x = ((x2-x1)*(y3*(x4-x3)+x3*(y3-y4))-(x4-x3)*(y1*(x2-x1)+x1*(y1-y2)))/((y2-y1)*(x4-x3)-(y4-y3)*(x2-x1));\n\tif(x1 != x2){\n\t\tret.y = ((y2-y1)*ret.x+y1*(x2-x1)+x1*(y1-y2))/(x2-x1);\n\t}else{\n\t\tret.y = ((y4-y3)*ret.x+y3*(x4-x3)+x3*(y3-y4))/(x4-x3);\n\t}\n\treturn ret;\n}\n\n//インタフェース関数\nPoint calc_Cross_Point(Point a,Point b,Point c,Point d){\n\treturn calc_Cross_Point(a.x,b.x,c.x,d.x,a.y,b.y,c.y,d.y);\n}\n\ndouble calc_dist(Point a,Point b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nvoid func(){\n\n\tA.set(X1,Y1);\n\tB.set(X2,Y2);\n\tC.set(X3,Y3);\n\n\tlen_A = calc_dist(B,C);\n\tlen_B = calc_dist(C,A);\n\tlen_C = calc_dist(A,B);\n\n\t//総長の半分\n\thalf_len_sum = (len_A+len_B+len_C)/2;\n\tS = sqrt(half_len_sum*(half_len_sum-len_A)*(half_len_sum-len_B)*(half_len_sum-len_C));\n\n\t//内接円の半径\n\tinner_R = (2.0*S)/(len_A+len_B+len_C);\n\n\t //各頂点から角の二等分線を伸ばす\n\t face_A.x = (len_B*B.x+len_C*C.x)/(len_B+len_C);\n\t face_A.y = (len_B*B.y+len_C*C.y)/(len_B+len_C);\n\n\t face_B.x = (len_C*C.x+len_A*A.x)/(len_A+len_C);\n\t face_B.y = (len_C*C.y+len_A*A.y)/(len_A+len_C);\n\n\t //内心円の座標は、角の二等分線の交点\n\t center = calc_Cross_Point(A,face_A,B,face_B);\n\n\t //内心と各頂点への距離\n\t dist1 = calc_dist(center,A);\n\t dist2 = calc_dist(center,B);\n\t dist3 = calc_dist(center,C);\n\n\t //公式\n\t R1 = inner_R/(2.0*(half_len_sum-len_A))*(half_len_sum+dist1-inner_R-dist2-dist3);\n\t R2 = inner_R/(2.0*(half_len_sum-len_B))*(half_len_sum+dist2-inner_R-dist1-dist3);\n\t R3 = inner_R/(2.0*(half_len_sum-len_C))*(half_len_sum+dist3-inner_R-dist1-dist2);\n\n\t printf(\"%.10lf %.10lf %.10lf\\n\",R1,R2,R3);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d %d %d %d\",&X1,&Y1,&X2,&Y2,&X3,&Y3);\n\t\tif(X1 == 0 && Y1 == 0 && X2 == 0 && Y2 == 0 && X3 == 0 && Y3 == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\n#include <fstream>\n#include <sstream>\nclass svg {\n\tofstream f;\n\tstringstream s;\n\tdouble x1 = 1e9, y1 = 1e9, x2 = -1e9, y2 = -1e9;\npublic:\n\tsvg(string path) :f(path, ios::trunc) {\n\t}\n\t~svg(){\n\t\tf << \"<?xml version=\\\"1.0\\\" standalone=\\\"no\\\"?><svg viewBox='\"<<x1*1.1-x2*0.1<<\" \"<<y1*1.1-y2*0.1<<\" \"<<(x2-x1)*1.2<<\" \"<<(y2-y1)*1.2<<\"' xmlns = \\\"http://www.w3.org/2000/svg\\\" xmlns:xlink = \\\"http://www.w3.org/1999/xlink\\\" >\\n\";\n\t\tf << s.str();\n\t\tf << \"</svg>\";\n\t}\n\tvoid circle(C c) {\n\t\ts << fixed << \"<circle cx = \\\"\" << c.p.real() << \"\\\" cy = \\\"\" << c.p.imag() << \"\\\" r = \\\"\" << c.r << \"\\\" stroke=\\\"black\\\" stroke-width=\\\"0.01\\\" fill = \\\"none\\\"/>\\n\";\n\t\tcmin(x1, c.p.real() - c.r);\n\t\tcmin(y1, c.p.imag() - c.r);\n\t\tcmax(x2, c.p.real() + c.r);\n\t\tcmax(y2, c.p.imag() + c.r);\n\t}\n\tvoid line(L l) {\n\t\ts << fixed << \"<line x1=\\\"\" << l.a.real() << \"\\\" y1=\\\"\" << l.a.imag() << \"\\\" x2=\\\"\" << l.b.real() << \"\\\" y2=\\\"\" << l.b.imag() << \"\\\" stroke=\\\"black\\\" stroke-width=\\\"0.01\\\"/>\\n\";\n\t\tcmin(x1, l.a.real());\n\t\tcmin(y1, l.a.imag());\n\t\tcmax(x2, l.a.real());\n\t\tcmax(y2, l.a.imag());\n\t\tcmin(x1, l.b.real());\n\t\tcmin(y1, l.b.imag());\n\t\tcmax(x2, l.b.real());\n\t\tcmax(y2, l.b.imag());\n\t}\n};\nint main() {\n\tVP p(3);\n\tfor (;;) {\n\t\trep(i, 3) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = { (double)x,(double)y };\n\t\t}\n\t\tif (p[0] == p[1])break;\n\t\tP up1 = (p[1] * abs(p[2] - p[0]) + p[2] * abs(p[1] - p[0])) / (abs(p[2] - p[0]) + abs(p[1] - p[0]));\n\t\tP dn1 = p[0];\n\t\tP up2, up3;\n\t\tdouble r1, r2, r3;\n\t\trep(i, 30) {\n\t\t\tP m1 = (up1 + dn1) * 0.5;\n\t\t\tr1 = dist_lp({ p[0],p[1] }, m1);\n\t\t\tup2 = (p[0] * abs(p[2] - p[1]) + p[2] * abs(p[0] - p[1])) / (abs(p[2] - p[1]) + abs(p[0] - p[1]));\n\t\t\tup3 = (p[0] * abs(p[2] - p[1]) + p[1] * abs(p[0] - p[2])) / (abs(p[2] - p[1]) + abs(p[0] - p[2]));\n\t\t\tP dn2 = p[1], dn3 = p[2];\n\t\t\trep(j, 30) {\n\t\t\t\tP m2 = (up2 + dn2)*0.5, m3 = (up3 + dn3)*0.5;\n\t\t\t\tr2 = dist_lp({ p[0],p[1] }, m2);\n\t\t\t\tr3 = dist_lp({ p[0],p[2] }, m3);\n\t\t\t\tif (!isis_ls({ p[0],up1 }, { p[1],m2 }) && dist_lp({ p[0],p[2] }, m2) > r2 && abs(m1 - m2) > r1 + r2)dn2 = m2;\n\t\t\t\telse up2 = m2;\n\t\t\t\tif (!isis_ls({ p[0],up1 }, { p[2],m3 }) && dist_lp({ p[0],p[1] }, m3) > r3 && abs(m3 - m1) > r1 + r3)dn3 = m3;\n\t\t\t\telse up3 = m3;\n\t\t\t}\n\t\t\tif (dist_lp({ p[1],p[2] }, m1) > r1&&abs(up2 - up3) < r2 + r3)dn1 = m1;\n\t\t\telse up1 = m1;\n\t\t}\n\t\tcout << fixed << setprecision(10) << r1 << \",\" << r2 << \",\" << r3 << endl;\n\t\tsvg s(\"out.svg\");\n\t\trep(i, 3)s.line({ p[i],p[(i + 1) % 3] });\n\t\ts.circle({ up1,r1 });\n\t\ts.circle({ up2,r2 });\n\t\ts.circle({ up3,r3 });\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nbool lessP(const P &l, const P &r) {\n    if (sgn(l.real(), r.real())) return l.real() < r.real();\n    if (sgn(l.imag(), r.imag())) return l.imag() < r.imag();\n    return false;\n}\n\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nR dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\nR deg2rad(R x) {\n    return x/180*PI;\n}\n\nR rad2deg(R x) {\n    return x/PI*180;\n}\n\n//?§???????[0, 2*PI)???\nR radNorP(R x) {\n    return fmod(fmod(x, 2*PI) + 2*PI, 2*PI);\n}\n\n//?§???????[-PI, PI)???\nR radNorN(R x) {\n    x = radNorP(x);\n    if (x >= PI) x -= 2*PI;\n    return x;\n}\n\n/**\n * radian??§???x???[l, r]?????\\??£????????????????????\\??????\n * 0:OFF\n * 1:IN\n * 2:ON\n */\nbool inR(R l, R r, R x) {\n    l = radNorP(l);\n    r = radNorP(r);\n    x = radNorP(x);\n    if (!sgn(l, x) || !sgn(r, x)) return 2;\n    if (!sgn(l, r)) return 0;\n    if (sgn(l, r) == 1) {\n        if (sgn(l, x) == 1 && sgn(x, r) == 1) return 1;\n    } else {\n        if (sgn(x, r) == 1 || sgn(l, x) == 1) return 1;\n    }\n    return 0;\n}\n\n\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\nstruct C {\n    P p;\n    R r;\n    C() {}\n    C(P p, R r) : p(p), r(r) {}\n};\n\n\n//return number of cross point\nint crossCC(const C &c, const C &d, L &l) {\n    if (near(c.p, d.p) && !sgn(c.r, d.r)) {\n        l.x = l.y = c.p+P(c.r, 0);\n        return -1;\n    }\n    R di = abs(c.p - d.p);\n    if (sgn(c.r+d.r, di) == 1) return 0;\n    if (sgn(di, abs(c.r-d.r)) == 1) return 0;\n    R bth = arg(d.p - c.p);\n    R th = sacos((c.r*c.r + di*di - d.r*d.r) / (2*c.r*di));\n    l.x = c.p+polar<R>(c.r, bth+th);\n    l.y = c.p+polar<R>(c.r, bth-th);\n    if (sgn(th) == 0) return 1;\n    return 2;\n}\n\nstruct T {\n    P d[3];\n    T() {}\n    T(P x, P y, P z) {\n        d[0] = x; d[1] = y; d[2] = z;\n    }\n};\n\ntypedef vector<P> Pol;\n\nP cu(const T &t, int i) {\n    return t.d[(i%3+3)%3];\n}\n\nP cu(const Pol &p, int i) { \n    int s = p.size();\n    return p[(i%s+s)%s];\n};\n\nT t;\nR ars[3], are[3], ar[3], arb[3], dist[3];\nC c[3];\n\nbool calc() {\n    R l = 0, r = min(dist[0], dist[2]);\n    for (int i = 0; i < 100; i++) {\n        R md = (l+r)/2;\n        c[1] = C(cu(t, 1) + polar<R>(md, arb[1]), md*sin(ar[1]));\n        if (abs(c[0].p-c[1].p) > c[0].r+c[1].r) {\n            l = md;\n        } else {\n            r = md;\n        }\n    }\n    l = 0, r = min(dist[0], dist[1]);\n    for (int i = 0; i < 100; i++) {\n        R md = (l+r)/2;\n        c[2] = C(cu(t, 2) + polar<R>(md, arb[2]), md*sin(ar[2]));\n        if (abs(c[0].p-c[2].p) > c[0].r+c[2].r) {\n            l = md;\n        } else {\n            r = md;\n        }\n    }\n    return abs(c[1].p-c[2].p) < c[1].r + c[2].r;\n}\n\nbool solve() {\n    for (int i = 0; i < 3; i++) {\n        R x, y;\n        cin >> x >> y;\n        t.d[i] = P(x, y);\n    }\n    if (cu(t, 0) == cu(t, 1) && cu(t, 1) == cu(t, 2)) return false;\n    for (int i = 0; i < 3; i++) {\n        ars[i] = radNorP(arg(cu(t, i+1) - cu(t, i)));\n        are[i] = radNorP(arg(cu(t, i+2) - cu(t, i)));\n        if (ars[i] > are[i]) are[i] += 2*PI;\n        ar[i] = (are[i] - ars[i]) / 2;\n        arb[i] = (are[i] + ars[i])/2;\n        dist[i] = abs(cu(t, i+1) - cu(t, i+2));\n    }\n    R l = 0, r = min(dist[1], dist[2]) / cos(ar[0]);\n    for (int i = 0; i < 100; i++) {\n        R md = (l+r)/2;\n        c[0] = C(cu(t,0) + polar<R>(md, arb[0]), md*sin(ar[0]));\n        if (calc()) {\n            l = md;\n        } else {\n            r = md;\n        }\n    }\n    printf(\"%.20Lf %.20Lf %.20Lf\\n\", c[0].r, c[1].r, c[2].r);\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\ndouble dot(P a,P b){\n  return real(b*conj(a));\n}\n\ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n\nP init(P a){\n  return a/max(0.0001,abs(a));\n}\n\nint ax,ay,bx,by,cx,cy;\n\nP A,B,C;\ndouble sinA,cosA,sinB,cosB,sinC,cosC;\n\ndouble funcC(double ra){\n  double L=0,R=10000,M;\n  for(int i=0;i<100;i++){\n    M=(L+R)/2.0;\n    if( M/sinC*cosC + ra/sinA*cosA + sqrt( 4.0*ra*M ) < abs(A-C) ) L=M;\n    else R=M;\n  }\n  return L;\n}\n\ndouble funcB(double ra){\n  double L=0,R=10000,M;\n  for(int i=0;i<100;i++){\n    M=(L+R)/2.0;\n    if( M/sinB*cosB + ra/sinA*cosA + sqrt( 4.0*ra*M ) < abs(A-B) ) L=M;\n    else R=M;\n  }\n  return L;\n}\n\nbool check(double ra){\n  double rb=funcB(ra);\n  double rc=funcC(ra);\n\n  if( rb/sinB*cosB + rc/sinC*cosC + sqrt( 4.0*rb*rc ) < abs(C-B) ){\n    return true;\n  }else{\n    return false;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>ax>>ay>>bx>>by>>cx>>cy;\n    if(ax==0&&ay==0&&bx==0&&by==0&&cx==0&&cy==0)break;\n    A=P(ax,ay),B=P(bx,by),C=P(cx,cy);\n    P AB=init(B-A),AC=init(C-A);\n    AB=(AB+AC)*0.5;\n    sinA = abs(cross(AB,AC))/abs(AB);\n    cosA = dot(AB,AC)/abs(AB);\n    \n    P BA=init(A-B),BC=init(C-B);\n    BA=(BA+BC)*0.5;\n    sinB = abs(cross(BA,BC))/abs(BA);\n    cosB = dot(BA,BC)/abs(BA);\n\n    P CA=init(A-C),CB=init(B-C);\n    CA=(CA+CB)*0.5;\n    sinC = abs(cross(CA,CB))/abs(CA);\n    cosC = dot(CA,CB)/abs(CA);\n\n    double L=0,R=10000,M;\n    for(int i=0;i<100;i++){\n      M=(L+R)/2.0;\n      if(check(M))R=M;\n      else L=M;\n    }\n\n    printf(\"%.10f %.10f %.10f\\n\",L,funcB(L),funcC(L));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iomanip>\n\n#define REP(i,n) for(i=0; i < (n); i++)\n#define REPONE(i, n) for(i=1; i <= (n); i++)\n#define LOOP(n) for(int loopCount=1; loopCount <= (n); loopCount++)\n#define ITER(c) __typeof((c).begin())\n#define EACH(c,it) for(ITER(c) it =(c).begin(); it!=(c).end(); it++)\n#define SZ(c) ((int) (c).size())\n#define ALL(c) c.begin(), c.end()\n#define SUM(c) accumulate(ALL(c), 0)\n#define EXIST(c,v) (find(ALL(c), (v)) != (c).end())\n#define PB push_back\n#define MP make_pair\n\nusing namespace std;\nstatic const double PI = 3.141592653589793238462643383279;\ntypedef long long ll;\n\n#define P complex<T> \n#define EPS (1e-9)\n\n/*****\n * ¼üÍ¼üãÌÙÈé2_(p1, p2)Å\\·\n * ~ÍScÆ¼arÉæè(c, r)Æ\\·\n *****/\n\n//XJ[lÌðÔ·B+:1, -:-1, 0:0B\ntemplate<typename T>\nint sig(T a){\n    return a==0?0:a>0?1:-1;\n}\n\n//xNgp1, p2ÌàÏðÔ·\ntemplate<typename T>\nT iprod(P p1, P p2){\n    return (p1.real()*p2.real()) + (p1.imag()*p2.imag());\n}\n\n//xNgp1, p2ÌOÏ(XJ[l,zÀW)ðÔ·\ntemplate<typename T>\nT oprod(P p1, P p2){\n    return (p1.real()*p2.imag()) - (p1.imag()*p2.real());\n}\n\n//üª(p1, p2)Æ_qÌ£ðÔ·\ntemplate<typename T>\nT disSP(P p1, P p2, P q){\n    if(iprod( (p2-p1), (q-p1) ) < EPS) return abs(q-p1);\n    if(iprod( (p1-p2), (q-p2) ) < EPS) return abs(q-p2);\n    return disLP(p1, p2, q);\n}\n\n//¼ü(p1, p2)Æ_qÌ£ðÔ·\ntemplate<typename T>\nT disLP(P p1, P p2, P q){\n    return (T)(abs( oprod( (p2-p1), (q-p1) ) ) / abs(p2-p1));\n}\n\n//üª(p1, p2)Æüª(q1, q2)Ìð_ª¶Ý·éÆ«ÉtrueðÔ·\ntemplate<typename T>\nbool crsSS(P p1, P p2, P q1, P q2){\n    if(max(p1.real(), p2.real()) + EPS < min(q1.real(), q2.real())) return false;\n    if(max(q1.real(), q2.real()) + EPS < min(p1.real(), p2.real())) return false;\n    if(max(p1.imag(), p2.imag()) + EPS < min(q1.imag(), q2.imag())) return false;\n    if(max(q1.imag(), q2.imag()) + EPS < min(p1.imag(), p2.imag())) return false;\n   return sig(oprod(p2-p1, q1-p1)) * sig(oprod(p2-p1, q2-p1)) < EPS\n        && sig(oprod(q2-q1, p1-q1)) * sig(oprod(q2-q1, p2-q1)) < EPS;\n}\n\n//~(c1, r)Æ~(c2, r2)Ìð_ª¶Ý·éÆ«ÉtrueðÔ·B\n//Ú_ÌÆ«à½ªtrueðÔ·\ntemplate<typename T>\nbool crsCC(P c1, T r1, P c2, T r2){\n    T dis = abs(c1-c2);\n    return dis < r1 + r2 + EPS && abs(r1-r2) < dis + EPS;\n}\n\n//Op`(p1, p2, p3)ÌOSðÔ·\n/*********¢À*********/\ntemplate<typename T>\nP ccenter(P p1, P p2, P p3){\n    return p1;\n}\n//4_p1, p2, p3, p4ª¯ê¼üãÉ éÆ«trueðÔ·B\n//4_ª¯ê¼üãÉ éÆ«àtrueðÔ·çµ¢\ntemplate<typename T>\nbool onCir(P p1, P p2, P p3, P p4){\n    if(abs(oprod(p2-p1, p3-p1)) < EPS) return true;\n    P c = ccenter(p1, p2, p3);\n    return abs(norm(c-p1) - norm(c-p4)) < EPS;\n}\n\n//_q©ç¼ü(p1, p2)Éºëµ½üÌ«ðÔ·\ntemplate<typename T>\nP proj(P p1, P p2, P q){\n    return p1 + (iprod( p2-p1, q-p1 )/(norm(p2-p1))*(p2-p1));\n}\n\n//¼ü(p1,p2)Æ¼ü(q1, q2)Ìð_ðÔ·\ntemplate<typename T>\nP isLL(P p1, P p2, P q1, P q2){\n    T d = oprod( q2-q1, p2-p1 );\n    if ( abs(d) < EPS ) return NULL;\n    return p1 + (oprod(q2-q1, q1-p1)/d*(p2-p1));\n}\n\n//¼ü(p1,p2)Æ~(c,r)Ìð_ÌvectorðÔ·(p1Éß¢)\ntemplate<typename T>\nvector<P> isCL(P c, T r, P p1, P p2){\n    vector<P> ans;\n    T x = iprod(p1-c, p2-p1);\n    T y = norm(p2-p1);\n    T d  = x*x - y*(norm(p1-c) - r*r);\n    if(d < -EPS) return ans;\n    if(d < 0) d = 0;\n    P q1 = p1 - (x/y)*(p2-p1);\n    P q2 = sqrt(d)/y*(p2-p1);\n    ans.push_back(q1-q2);\n    ans.push_back(q1+q2);\n    return ans;\n}\n\n//~(c1, r1), ~(c2, r2)Ìð_ÌvectorðÔ·\ntemplate<typename T>\nvector<P> isCC(P c1, T r1, P c2, T r2){\n    vector<P> ans;\n    T x = norm(c1-c2);\n    T y = ((r1*r1 - r2*r2)/x + 1)/2;\n    T d = r1*r1/x - y*y;\n    if(d < -EPS) return ans;\n    if(d < 0) d=0;\n    P q1 = c1 + y*(c2-c1);\n    P q2 = (c2 - c1)*(polar(sqrt(d), (T)M_PI/2));\n    ans.push_back(q1-q2);\n    ans.push_back(q1+q2);\n    return ans;\n}\n\n//_p©çø¢½~(c, r)ðÊéÚüÌÚ_ÌvectorðÔ·\ntemplate<typename T>\nvector<P> tanCP(P c, T r, P p){\n    vector<P> ans;\n    T x = norm(p-c);\n    T d = x - r*r;\n    if(d < -EPS) return ans;\n    if(d < 0) d = 0;\n    P q1 = (r*r/x)*(p-c);\n    P q2 = (p-c)*(polar(-r*sqrt(d)/x, (T)M_PI/2));\n    ans.push_back(c+q1-q2);\n    ans.push_back(c+q1+q2);\n    return ans;\n}\n\n//~(c1, r1), ~(c2, r2)Ì¤ÊÚüÌvectorðÔ·\n/******2~ªÚ·éÆ«ÌªvC³*********/\ntemplate<typename T>\nvector< vector<P> > tanCC(P c1, T r1, P c2, T r2){\n    vector< vector<P> > ans;\n    vector<P> line;\n    if(abs(r1-r2) < EPS){\n        P dir = c2-c1;\n        dir = dir * polar(r1/abs(dir), (T)M_PI/2);\n        \n        line.clear(); line.push_back(c1+dir); line.push_back(c2+dir);\n        ans.push_back(line);\n        line.clear(); line.push_back(c1-dir); line.push_back(c2-dir);\n        ans.push_back(line);\n        \n    }else{\n        P p = (-r2*c1 + r1*c2)/(r1-r2);\n        vector<P> ps, qs;\n        ps = tanCP(c1, r1, p);\n        qs = tanCP(c2, r2, p);\n        for(int i=0; i<(int)ps.size() && i<(int)qs.size(); i++){\n            line.clear(); line.push_back(ps[i]);line.push_back(qs[i]);\n            ans.push_back(line);\n        }\n    }\n    P p = (r2*c1 + r1*c2)/(r1+r2);\n    vector<P> ps, qs;\n    ps = tanCP(c1, r1, p);\n    qs = tanCP(c2, r2, p);\n    /*** ps[i] == qs[i] ÌÛÉÚüðÁèÅ«éæ¤Éµ½¢ ***/\n    for(int i=0; i<(int)ps.size() && i<(int)qs.size(); i++){\n        /*** ÈºÍèÉÇÁ ***/\n        if(abs(ps[i]-qs[i]) < EPS){\n            P dir = (c2 - c1)*polar((T)1/(abs(c2-c1)), (T)M_PI/2);\n            ps[i] += dir;\n            qs[i] -= dir;\n        }\n        /*** ±±ÜÅ ***/\n        line.clear(); line.push_back(ps[i]);line.push_back(qs[i]);\n        ans.push_back(line);\n    }\n    return ans;\n}\n\n//~(c1, r1), ~(c2, r2)Ì¤ÊªÊÏ\ntemplate<typename T>\nT areaCC(P c1, T r1, P c2, T r2){\n    T d = abs(c1-c2);\n    if(r1+r2 < d+EPS) return 0;\n    if(d < abs(r1-r2) + EPS){\n        T r = min(r1, r2);\n        return r*r*M_PI;\n    }\n    T x = (d*d+r1*r1-r2*r2)/(2*d);\n    T t1 = acos(x/r1);\n    T t2 = cos((d-x)/r2);\n    return r1*r1*t1 + r2*r2*t2 - d*r1*sin(t1);\n}\n\n//Oð´_Æ·éB~(O,r1)ÆOp`(O,p1,p2)Ì¤ÊªÊÏ\ntemplate<typename T>\nT areaCT(T r, P p1, P p2){\n    T o(0, 0);\n    vector<P> qs = isCL(o, r, p1, p2);\n    if(qs.empty()) return r*r*arg(p1-p2)/2;\n    bool b1 = abs(p1) > r + EPS, b2 = abs(p2) > r + EPS;\n    if(b1 && b2){\n        if(iprod(p1-qs[0], p2-qs[0]) < EPS &&\n                iprod(p1-qs[1], p2-qs[1]) < EPS){\n            return (r*r*(arg(p1-p2)-arg(qs[0]-qs[1])) + oprod(qs[0], qs[1]))/2;\n        }else{\n            return r*r*arg(p1-p2)/2;\n        }\n    }else if(b1){\n        return (r*r*arg(p1-qs[0]) + oprod(qs[0], p2))/2;\n    }else if(b2){\n        return (r*r*arg(qs[1]-p2) + oprod(p1, qs[1]))/2;\n    }else{\n        return oprod(p1, p2) / 2;\n    }\n}\n\n\n//ÔvZÊO(n)\n//Ê½p`psÉÎµÄA_qªàÌÆ«Í1,\n//ÓãÌÆ«ÍOAOÌÍ-1ðÔ·\ntemplate<typename T>\nint contains(vector<P> ps, P q){\n    int n = ps.size();\n    int ans = -1;\n    for(int i=0; i<n; i++){\n        P a = ps[i] - q, b = ps[(i+1)%n] - q;\n        if(a.imag() > b.imag()){\n            swap(a,b);\n        }\n        if(a.imag() < EPS && b.imag() > EPS && oprod(a,b) > EPS){\n            ans = -ans;\n        }\n        if(abs(oprod(a,b)) < EPS && iprod(a,b) < EPS) return 0;\n    }\n    return ans;\n}\n\ntemplate<typename T>\nbool circleInTriangle(vector<P> ps, P c, T r){\n    return contains(ps,c)&&(disLP(ps[0],ps[1],c)>r-EPS)\n        &&(disLP(ps[1],ps[2],c)>r-EPS)&&(disLP(ps[2],ps[0],c)>r-EPS);\n}\n\n\ntypedef complex<double> point;\n#define N 200\n\nint main(){\n    point p1, p2, p3, c1, c2, c3, v1, v2, v3;\n    double l1, l2, l3, r1, r2, r3, ub1, ub2, ub3;\n    double low1, high1, mid1, low2, high2, mid2, low3, high3, mid3;\n    double x, y, d1, d2, d3;\n    int bs1, bs2, bs3;\n    vector<point> ps(3);\n    while(1){\n        scanf(\"%lf%lf\",&x,&y);\n        p1 = point(x,y);\n        scanf(\"%lf%lf\",&x,&y);\n        p2 = point(x,y);\n        scanf(\"%lf%lf\",&x,&y);\n        p3 = point(x,y);\n        if(p1==p2) break;\n        ps[0] = p1;\n        ps[1] = p2;\n        ps[2] = p3;\n        if(!contains(ps,(p1+p2+p3)/3.0))swap(ps[0],ps[1]);\n        ub1 = disLP(p2,p3,p1);\n        ub2 = disLP(p3,p1,p2);\n        ub3 = disLP(p1,p2,p3);\n        v1 = ((p3-p1)*abs(p2-p1)+(p2-p1)*abs(p3-p1))/(abs(p2-p1)+abs(p3-p1));\n        v2 = ((p1-p2)*abs(p3-p2)+(p3-p2)*abs(p1-p2))/(abs(p1-p2)+abs(p3-p2));\n        v3 = ((p2-p3)*abs(p1-p3)+(p1-p3)*abs(p2-p3))/(abs(p2-p3)+abs(p1-p3));\n        if(0){\n        printf(\"line(%f,%f,%f,%f);\\n\",0.1*p1.real()+250.0, 0.1*p1.imag()+250.0, 0.1*p2.real()+250.0, 0.1*p2.imag()+250.0);\n        printf(\"line(%f,%f,%f,%f);\\n\",0.1*p3.real()+250.0, 0.1*p3.imag()+250.0, 0.1*p2.real()+250.0, 0.1*p2.imag()+250.0);\n        printf(\"line(%f,%f,%f,%f);\\n\",0.1*p1.real()+250.0, 0.1*p1.imag()+250.0, 0.1*p3.real()+250.0, 0.1*p3.imag()+250.0);\n        }\n        low1 = 0.0; high1 = 1.0;\n        REP(bs1,N){\n            if(0){\n            printf(\"circle(%f, %f, %f);\\n\",c1.real()+250.0, c1.imag()+250.0, r1);\n            printf(\"circle(%f, %f, %f);\\n\",c2.real()+250.0, c2.imag()+250.0, r2);\n            printf(\"circle(%f, %f, %f);\\n\",c3.real()+250.0, c3.imag()+250.0, r3);\n            }\n            if(high1-low1<EPS) break;\n            mid1 = (low1 + high1)*0.5;\n            c1 = p1 + v1*mid1;\n            r1 = disLP(p1,p2,c1);\n            if(!circleInTriangle(ps,c1,r1)){\n                high1 = mid1;\n                continue;\n            }\n            if(r1<EPS){\n                low1 = mid1;\n                continue;\n            }\n            low2 = 0.0; high2 = 1.0;\n            REP(bs2,N){\n                if(high2-low2<EPS)break;\n                mid2 = (low2+high2)*0.5;\n                c2 = p2 + v2*mid2;\n                r2 = disLP(p2,p3,c2);\n                if(!circleInTriangle(ps,c2,r2)){\n                    high2 = mid2;\n                    continue;\n                }\n                d2 = abs(c1-c2) - (r1+r2);\n                if(d2 > 0){\n                    low2 = mid2;\n                    continue;\n                }\n                if(d2 < 0){\n                    high2 = mid2;\n                    continue;\n                }\n            }\n            /*\n            if(abs(d2)>EPS){\n                low1 = mid1;\n                continue;\n            }\n            */\n            low3 = 0.0; high3 = 1.0;\n            REP(bs3,N){\n                if(high3-low3<EPS) break;\n                mid3 = (low3+high3)*0.5;\n                c3 = p3 + v3*mid3;\n                r3 = disLP(p3,p1,c3);\n                if(!circleInTriangle(ps,c3,r3)){\n                    high3 = mid3;\n                    continue;\n                }\n                d3 = abs(c1-c3)-(r1 + r3);\n                if(d3 > 0){\n                    low3 = mid3;\n                    continue;\n                }\n                if(d3 < 0){\n                    high3 = mid3;\n                    continue;\n                }\n            }\n            /*\n            if(abs(d3)>EPS){\n                low1 = mid1;\n                continue;\n            }\n            */\n            d1 = abs(c2-c3) - (r2+r3);\n            //cout << d1 << endl;\n            if(abs(d1)<EPS) break;\n            if(d1 > 0){\n                high1 = mid1;\n                continue;\n            }\n            if(d1 < 0){\n                low1 = mid1;\n                continue;\n            }\n        }\n        printf(\"%.9f %.9f %.9f\\n\", r1, r2, r3);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <complex>\n\nusing namespace std;\ntypedef long long ll;\ntypedef complex<double> Point;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\ninline double sq(double x) { return x * x; }\n\nPoint p[3];\nPoint vect[3];\ndouble len[3];\ndouble l[3];\ndouble sins[3];\nPoint inner;\n\nbool inbox(Point p, Point q, Point r) {\n  if (p.real() > q.real()) {\n    double temp = p.real();\n    p = Point(q.real(), p.imag());\n    q = Point(temp, q.imag());\n  }\n  if (p.imag() > q.imag()) {\n    double temp = p.imag();\n    p = Point(p.real(), q.imag());\n    q = Point(q.real(), temp);\n  }\n  return p.real() <= r.real() && r.real() <= q.real() &&\n         p.imag() <= r.imag() && r.imag() <= q.imag();\n}\n\nPoint getPos(int index, double r) {\n  double d = r / sins[index];\n  return p[index] + vect[index] * d;\n}\n\npair<Point, double> bs(int index, Point center1, double r1) {\n  double left = 0.0;\n  double right = l[index] / 2;\n  REP(iter, 60) {\n    double mid = (left + right) / 2.0;\n    Point c = getPos(index, mid);\n    if (!inbox(p[index], inner, c) || abs(c - center1) < r1 + mid) {\n      right = mid;\n    } else {\n      left = mid;\n    }\n  }\n  return make_pair(getPos(index, left), left);\n}\n\nint main() {\n  int x1, x2, x3, y1, y2, y3;\n  while (scanf(\"%d %d %d %d %d %d\", &x1, &y1, &x2, &y2, &x3, &y3), x1|y1|x2|y2|x3|y3) {\n    p[0] = Point(x1, y1);\n    p[1] = Point(x2, y2);\n    p[2] = Point(x3, y3);\n    REP(i, 3) {\n      int prev = (i + 1) % 3;\n      int next = (i + 2) % 3;\n      len[i] = abs(p[prev] - p[next]);\n    }\n    inner = (len[0] * p[0] + len[1] * p[1] + len[2] * p[2]) / (len[0] + len[1] + len[2]);\n    REP(i, 3) {\n      vect[i] = inner - p[i];\n      l[i] = abs(vect[i]);\n      vect[i] /= abs(vect[i]);\n    }\n    REP(i, 3) {\n      int prev = (i + 1) % 3;\n      int next = (i + 2) % 3;\n      double c = (sq(l[i]) + sq(len[prev]) - sq(l[next])) / (2 * l[i] * len[prev]);\n      sins[i] = sqrt(1 - c * c);\n    }\n    double left = 0.0;\n    double right = l[0] / 2;\n    REP(iter, 60) {\n      double mid = (left + right) / 2.0;\n      Point center1 = getPos(0, mid);\n      pair<Point, double> center2 = bs(1, center1, mid);\n      pair<Point, double> center3 = bs(2, center1, mid);\n      //cout << center1 << \" \" << center2.first << \" \" << center3.first << endl;\n      //cout << mid << \" \" << center2.second << \" \" << center3.second << endl;\n      //cout << abs(center1 - center2.first) << \" \" << mid + center2.second << endl;\n      //cout << abs(center2.first - center3.first) << \" \" << center2.second + center3.second << endl;\n      //cout << abs(center3.first - center1) << \" \" << center3.second + mid << endl;\n      if (inbox(p[0], inner, center1) && abs(center2.first - center3.first) < center2.second + center3.second) {\n        left = mid;\n      } else {\n        right = mid;\n      }\n      if (iter == 59) {\n        printf(\"%.6lf %.6lf %.6lf\\n\", mid, center2.second, center3.second);\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tVP p(3);\n\tfor (;;) {\n\t\trep(i, 3) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = { (double)x,(double)y };\n\t\t}\n\t\tif (p[0] == p[1])break;\n\t\tP up1 = (p[1] * abs(p[2] - p[0]) + p[2] * abs(p[1] - p[0])) / (abs(p[2] - p[0]) + abs(p[1] - p[0]));\n\t\tP dn1 = p[0];\n\t\tdouble r1,r2, r3;\n\t\trep(i, 100) {\n\t\t\tP m1 = (up1 + dn1) * 0.5;\n\t\t\tr1 = dist_lp({ p[0],p[1] }, m1);\n\t\t\tP up2 = (p[0] * abs(p[2] - p[1]) + p[2] * abs(p[0] - p[1])) / (abs(p[2] - p[1]) + abs(p[0] - p[1]));\n\t\t\tP up3 = (p[0] * abs(p[2] - p[1]) + p[1] * abs(p[0] - p[2])) / (abs(p[2] - p[1]) + abs(p[0] - p[2]));\n\t\t\tP dn2 = p[1], dn3 = p[2];\n\t\t\trep(j, 100) {\n\t\t\t\tP m2 = (up2 + dn2)*0.5, m3 = (up3 + dn3)*0.5;\n\t\t\t\tr2 = dist_lp({ p[0],p[1] }, m2);\n\t\t\t\tr3 = dist_lp({ p[0],p[2] }, m3);\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[1],m2 }) && dist_lp({ p[0],p[2] }, m2) > r2 && abs(m1 - m2) > r1 + r2)dn2 = m2;\n\t\t\t\telse up2 = m2;\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[2],m3 }) && dist_lp({ p[0],p[1] }, m3) > r3 && abs(m3 - m1) > r1 + r3)dn3 = m3;\n\t\t\t\telse up3 = m3;\n\t\t\t}\n\t\t\tif (isis_ss({ p[1],up2 }, { p[2],up3 }) || abs(up2 - up3) < r2 + r3)dn1 = m1;\n\t\t\telse up1 = m1;\n\t\t}\n\t\tcout << fixed << setprecision(10) << r1 << \" \" << r2 << \" \" << r3 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <complex>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << \"\\n\"\n#define input(X) getline(cin,X)\nstatic const int INF = 1e+9+7;\nstatic const ll INFL = 1e+18+7;\nll n,m,l;\nint p;\nstring s,t;\nll d[200010],dp[300][300];\nchar field[200][200];\nnamespace Geometry{\n  #define equals(a,b) (fabs((a) - (b)) < EPS)\n  #define BOTTOM 0\n  #define LEFT 1\n  #define RIGHT 2\n  #define TOP 3\n  #define gprint(X) cout << fixed << setprecision(8) << (X) << endl\n  #define gprints(X,Y) cout << fixed << setprecision(8) << (X) << \" \" << (Y) << endl\n  const double EPS = 1e-10;\n  static const int COUNTER_CLOCKWISE = 1;\n  static const int CLOCKWISE = -1;\n  static const int ONLINE_BACK = 2;\n  static const int ONLINE_FRONT = -2;\n  static const int ON_SEGMENT = 0;\n  \n  class Point{\n  public:\n    double x,y;\n    Point(double x = 0,double y = 0): x(x),y(y){}\n    Point operator + (Point p){ return Point(x + p.x , y + p.y); }\n    Point operator - (Point p){ return Point(x - p.x , y - p.y); }\n    Point operator += (Point p){ return Point(x += p.x,y += p.y); }\n    Point operator -= (Point p){ return Point(x -= p.x,y -= p.y); }\n    Point operator * (double a){ return Point(a * x , a * y); }\n    Point operator / (double a){ return Point(x / a , y / a); }\n    bool operator < (const Point &p) const{ return x != p.x ? x < p.x : y < p.y; }\n    bool operator == (const Point &p) const{ return equals(x,p.x) && equals(y,p.y); }\n\n    double abs(){ return sqrt(norm()); }\n    double norm(){ return x * x + y * y; }\n    friend ostream& operator << (ostream &os,Point &p){ return os << p.x << \" \" << p.y; }\n    friend istream& operator >> (istream &is,Point &p){ return is >> p.x >> p.y; }\n  };\n\n  struct Segment{\n    Point p1,p2;\n    Segment(){};\n    Segment(Point p1,Point p2): p1(p1) , p2(p2){};\n    friend ostream& operator << (ostream &os,Segment &seg){ return os << seg.p1 << \" \" << seg.p2; }\n    friend istream& operator >> (istream &is,Segment &seg){ return is >> seg.p1 >> seg.p2; }\n  };\n\n  class Circle{\n  public:\n    Point c;\n    double r;\n    Circle(Point c = Point(),double r = 0.0): c(c),r(r){}\n    friend ostream& operator << (ostream &os,Circle &c){ return os << c.c << \" \" << c.r; }\n    friend istream& operator >> (istream &is,Circle &c){ return is >> c.c >> c.r; }\n  };\n\n  typedef Point Vector;\n  typedef Segment Line;\n  typedef vector<Point> Polygon;\n\n  double norm(Vector a){ return  a.x * a.x + a.y * a.y; }\n  double abs(Vector a){ return sqrt(norm(a)); }\n  double dot(Vector a,Vector b){ return a.x * b.x + a.y * b.y; }\n  double cross(Vector a,Vector b){ return a.x * b.y - a.y * b.x; }\n  bool Orthogonal(Vector a,Vector b){ return equals(dot(a,b),0.0); }\n  bool Orthogonal(Point a1,Point a2,Point b1,Point b2){ return Orthogonal(a1 - a2,b1 - b2); }\n  bool Orthogonal(Segment s1,Segment s2){ return equals(dot(s1.p2 - s1.p1,s2.p2 - s2.p1) , 0.0); }\n  bool Parallel(Vector a,Vector b){ return equals(cross(a,b),0.0); }\n  bool Parallel(Point a1,Point a2,Point b1,Point b2){ return Parallel(a1 - a2 , b1 - b2); }\n  bool Parallel(Segment s1,Segment s2){ return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0); }\n  bool less(const Point &a,const Point &b){ return (a.x != b.x) ? a.x < b.x : a.y < b.y; }\n  bool greater(const Point &a,const Point b){ return !less(a,b); }\n\n  Point project(Segment s,Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1 , base) / norm(base);\n    return s.p1 + base * r;\n  }\n\n  Point reflect(Segment s,Point p){\n    return p + (project(s,p) - p) * 2.0;\n  }\n\n  int ccw(Point &p0,Point p1,Point p2){\n    p1 -= p0;\n    p2 -= p0;\n    if(cross(p1,p2) > EPS)return COUNTER_CLOCKWISE;\n    if(cross(p1,p2) < -EPS)return CLOCKWISE;\n    if(dot(p1,p2) < -EPS)return ONLINE_BACK;\n    if(p1.norm() < p2.norm())return ONLINE_FRONT;\n    return ON_SEGMENT;\n  }\n\n  bool intersect(Point p1,Point p2,Point p3,Point p4){\n    return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && \n            ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n  }\n  bool intersect(Segment s1,Segment s2){ return intersect(s1.p1 , s1.p2 , s2.p1 , s2.p2); }\n\n  double getDistance(Vector a,Vector b){ return abs(a - b); }\n  double getDistance(Segment s1){ return getDistance(s1.p1,s1.p2); }\n  double getDistanceLP(Line l,Point p){ return abs(cross(l.p2 - l.p1 , p - l.p1) / abs(l.p2 - l.p1)); }\n  double getDistanceSP(Segment s,Point p){\n    if(dot(s.p2 - s.p1,p - s.p1) < 0.0) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2,p - s.p2) < 0.0) return abs(p - s.p2);\n    return getDistanceLP(s,p);\n  }\n  double getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2))return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n  }\n\n  Point getCrossPoint(Segment s1,Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base,s1.p1 - s2.p1));\n    double d2 = abs(cross(base,s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n  }\n\n  pair<Point,Point> getCrossPoints(Circle c,Line l){\n    Vector pr = project(l,c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base , pr - e * base);\n  }\n\n  double arg(Vector p){ return atan2(p.y,p.x); }\n  Vector polar(double a,double r){ return Point(cos(r) * a, sin(r) * a); }\n\n  pair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r,t + a),c1.c + polar(c1.r,t - a));\n  }\n  \n  int contains(Polygon g,Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i = 0;i < n;i++){\n      Point a = g[i] - p, b = g[(i + 1) % n] - p;\n      if(abs(cross(a,b)) < EPS && dot(a,b) < EPS)return 1;\n      if(a.y > b.y)swap(a,b);\n      if(a.y < EPS && EPS < b.y && cross(a,b) > EPS)x = !x;\n    }\n    return (x ? 2 : 0);\n  }\n\n  //=====================================================//\n  //==================== Andrew Scan ====================//\n  //=====================================================//\n \n  int Accw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS)return 1;\n    return -1;\n  }\n \n  Polygon andrewScan(Polygon s){\n    Polygon ans;\n    Polygon u,l;\n    if(s.size() < 3)return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n    for(int i = 2;i < s.size();i++){\n      for(int n = u.size();n >= 2 && Accw(u[n-2],u[n-1],s[i]) != -1;n--){\n        u.pop_back();\n      }\n      u.push_back(s[i]);\n    }\n \n    for(int i = s.size() - 3;i >= 0;i--){\n      for(int n = l.size();n >= 2 && Accw(l[n-2],l[n-1],s[i]) != -1;n--){\n        l.pop_back();\n      }\n      l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i = u.size() - 2;i >= 1;i--){\n      l.push_back(u[i]);\n    }\n    int f = 0;\n    for(int i = 1;i < l.size();i++){\n      if(l[f].y > l[i].y || (l[f].y == l[i].y && l[f].x > l[i].x)){\n        f = i;\n      }\n    }\n    for(int i = 0;i < l.size();i++){\n      ans.push_back(Point((int)l[(i + f)%l.size()].x,(int)l[(i + f)%l.size()].y));\n    }\n    return ans;\n  }\n\n  //=====================================================//\n  //======================== END ========================//\n  //=====================================================//\n\n  class EndPoint{\n  public:\n    Point p;\n    int seg,st;\n    EndPoint(){}\n    EndPoint(Point p,int seg,int st): p(p),seg(seg),st(st){}\n\n    bool operator < (const EndPoint &ep) const{\n      if(p.y == ep.p.y){\n        return st < ep.st;\n      }else{\n        return p.y < ep.p.y;\n      }\n    }\n  };\n\n  EndPoint EP[2 * 100000];\n\n  int manhattanIntersection(vector<Segment> S){\n    int n = S.size();\n    for(int i = 0,k = 0;i < n;i++){\n      if(S[i].p1.y == S[i].p2.y){\n        if(S[i].p1.x > S[i].p2.x)swap(S[i].p1,S[i].p2);\n      }else if(S[i].p1.y > S[i].p2.y){\n        swap(S[i].p1,S[i].p2);\n      }\n\n      if(S[i].p1.y == S[i].p2.y){\n        EP[k++] = EndPoint(S[i].p1,i,LEFT);\n        EP[k++] = EndPoint(S[i].p2,i,RIGHT);\n      }else{\n        EP[k++] = EndPoint(S[i].p1,i,BOTTOM);\n        EP[k++] = EndPoint(S[i].p2,i,TOP);\n      }\n    }\n\n    sort(EP,EP + (2 * n));\n\n    set<int> BT;\n    BT.insert(1000000001);\n    int cnt = 0;\n    for(int i = 0;i < 2 * n;i++){\n      if(EP[i].st == TOP){\n        BT.erase(EP[i].p.x);\n      }else if(EP[i].st == BOTTOM){\n        BT.insert(EP[i].p.x);\n      }else if(EP[i].st == LEFT){\n        set<int>::iterator b = lower_bound(BT.begin(),BT.end(),S[EP[i].seg].p1.x);\n        set<int>::iterator e = upper_bound(BT.begin(),BT.end(),S[EP[i].seg].p2.x);\n        cnt += distance(b,e);\n      }\n    }\n    return cnt;\n  }\n};\n\nusing namespace Geometry;\n\nint main(){\n  Point a,b,c;\n  while(cin >> a >> b >> c,(a.abs() + b.abs() + c.abs()) != 0){\n    // Area Size\n    double segA = getDistance(b,c);\n    double segB = getDistance(a,c);\n    double segC = getDistance(b,a);\n    double area1 = (segA + segB + segC) / 2;\n    double area2 = sqrt(area1 * (area1 - segA) * (area1 - segB) * (area1 - segC));\n    double radius = area2 / area1;\n    // cout << \"total : \" << (segA * radius / 2) + (segB * radius / 2) + (segC * radius / 2) << endl;\n    Point p = Point((segA*a.x + segB*b.x + segC*c.x)/(segA + segB + segC),(segA*a.y + segB*b.y + segC*c.y)/(segA + segB + segC));\n\n    double difA = getDistance(p,a);\n    double difB = getDistance(p,b);\n    double difC = getDistance(p,c);\n\n    // ans\n    double r1 = radius / (2 * (area1 - segA)) * (area1 + difA - radius - difB - difC);\n    double r2 = radius / (2 * (area1 - segB)) * (area1 + difB - radius - difA - difC);\n    double r3 = radius / (2 * (area1 - segC)) * (area1 + difC - radius - difB - difA);\n    cout << fixed << setprecision(6) << r1 << \" \" << r2 << \" \" << r3 << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<double,P> P2;\n\nconst double EPS = 1e-8;\nP v[3];\n\ndouble cross(P a, P b){ return imag(conj(a)*b);}\n\nbool cmp(const P2 &a, const P2 &b){ return a.first < b.first;}\n\nP rotate(P p, double rad){\n  double x = real(p) * cos(rad) - imag(p) * sin(rad);\n  double y = real(p) * sin(rad) + imag(p) * cos(rad);\n  return P(x,y);\n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  return m.first + B / A * (m.second - m.first);\n}\n\ndouble areaV(){\n  double sum = 0.0;\n  for(int i=0;i<3;i++) sum += (real(v[i]) - real(v[(i+1)%3])) * (imag(v[i]) + imag(v[(i+1)%3]));\n  return abs(sum) / 2.0;\n}\n\nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\nP2 check2(P2 p, int pos){\n  double le = 0.0, ri = 2.0 * areaV() / (abs(v[1]-v[0]) + abs(v[2]-v[1]) + abs(v[0]-v[2]));\n  L l[2];\n  P2 res;\n  for(int i=0;i<100;i++){\n    double mid = (le + ri) / 2.0;\n\n    for(int j=pos;j<pos+2;j++){\n      P a = (v[(j+1)%3]-v[j%3]) * mid / abs(v[(j+1)%3]-v[j%3]);\n      P b = rotate(a, M_PI/2.0);\n      l[j-pos] = L(v[(j+1)%3]+b, v[j%3]+b);\n    }\n    res = P2(mid, crossPoint(l[0],l[1]));\n\n    if(equal(abs(res.second-p.second), res.first+p.first)) return res;\n    else if(abs(res.second-p.second) < res.first+p.first) ri = mid;\n    else le = mid;\n  }\n}\n\nint check(double r){\n  L l[2];\n  P2 p[3];\n  for(int i=0;i<2;i++){\n    P a = (v[i+1]-v[i]) * r / abs(v[i+1]-v[i]);\n    P b = rotate(a, M_PI/2.0);\n    l[i] = L(v[i+1]+b, v[i]+b);\n  }\n  p[0] = P2(r, crossPoint(l[0],l[1]));\n\n\n  for(int i=1;i<3;i++) p[i] = check2(p[0], i);\n\n  if(equal(abs(p[2].second-p[1].second), p[2].first+p[1].first)){\n    //sort(p,p+3,cmp);\n    printf(\"%.6f %.6f %.6f\\n\",p[2].first, p[0].first, p[1].first);\n    return 1;\n  }\n  else if(abs(p[2].second-p[1].second) < p[2].first+p[1].first) return 2;\n  else return 0;\n  \n}\n\nvoid solve(){\n  double le = 0.0, ri = 2.0 * areaV() / (abs(v[1]-v[0]) + abs(v[2]-v[1]) + abs(v[0]-v[2]));\n  for(int i=0;i<100;i++){\n    double mid = (le + ri) / 2.0;\n    int res = check(mid);\n    if(res == 0) ri = mid;\n    else if(res == 2) le = mid;\n    else return;\n  }\n}\n\nint main(){\n  int x[3],y[3];\n  while(cin >> x[0] >> y[0] >> x[1] >> y[1] >> x[2] >> y[2] && (x[0]|y[0]|x[1]|y[1]|x[2]|y[2])){\n    for(int i=0;i<3;i++) v[i] = P((double)x[i], (double)y[i]);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// 2009ツアツジツアツ地ツ凝ヲツ予ツ選 G : Malfatti Circles\n#include <iostream>\n#include <complex>\n#include <stdio.h>\n\nusing namespace std;\n\nconst double EPS = 1e-12;\n\ntypedef complex<double> P;\nstruct L{ P p, q; L(P p, P q) : p(p), q(q) {} };\n\ndouble cross(P a, P b) { return imag(conj(a)*b); }\n\ndouble lpDist(L l, P p){\n\treturn abs(cross(l.q-l.p,p-l.p))/abs(l.q-l.p);\n}\n\nP crossPoint(L l, L m){\n\tdouble A = cross(l.q-l.p, m.q-m.p);\n\tdouble B = cross(l.q-l.p, l.q-m.p);\n\treturn m.p + B/A*(m.q-m.p);\n}\n\nint main(){\n\tint x1, y1, x2, y2, x3, y3;\n\twhile(cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3){\n\t\tif(!(x1||y1||x2||y2||x3||y3)) break;\n\t\tP p1 = P(x1,y1), p2 = P(x2,y2), p3 = P(x3,y3);\n\t\tP dirA = (p2-p1)/abs(p2-p1)+(p3-p1)/abs(p3-p1);\n\t\tP dirB = (p1-p2)/abs(p1-p2)+(p3-p2)/abs(p3-p2);\n\t\tP c = crossPoint(L(p1,p1+dirA),L(p2,p2+dirB));\n\t\tdouble rA, rB, rC;\n\t\tdouble leftA = 0.0, rightA = 1.0, leftB, rightB, leftC, rightC;\n\t\twhile(true){\n\t\t\tdouble midA = (leftA+rightA)/2;\n\t\t\tP cA = p1 + (c-p1)*midA, cB, cC;\n\t\t\trA = lpDist(L(p1,p2), cA);\n\t\t\tleftB = 0.0, rightB = 1.0, leftC = 0.0, rightC = 1.0;\n\t\t\twhile(rightB-leftB>EPS){\n\t\t\t\tdouble midB = (leftB+rightB)/2;\n\t\t\t\tcB = p2 + (c-p2)*midB;\n\t\t\t\trB = lpDist(L(p2,p3), cB);\n\t\t\t\tif(rA+rB < abs(cB-cA)) leftB  = midB;\n\t\t\t\telse                   rightB = midB;\n\t\t\t}\n\t\t\twhile(rightC-leftC>EPS){\n\t\t\t\tdouble midC = (leftC+rightC)/2;\n\t\t\t\tcC = p3 + (c-p3)*midC;\n\t\t\t\trC = lpDist(L(p3,p1), cC);\n\t\t\t\tif(rA+rC < abs(cC-cA)) leftC  = midC;\n\t\t\t\telse                   rightC = midC;\n\t\t\t}\n\t\t\tif(rB+rC > abs(cB-cC)) leftA  = midA;\n\t\t\telse                   rightA = midA;\n\t\t\tif(rightA-leftA < EPS){\n\t\t\t\tprintf(\"%.5lf %.5lf %.5lf\\n\", rA, rB, rC);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<algorithm>\n\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\nint main(){\n\tfor(int x1,y1,x2,y2,x3,y3;scanf(\"%d%d%d%d%d%d\",&x1,&y1,&x2,&y2,&x3,&y3),x1||y1||x2||y2||x3||y3;){\n\t\tdouble a,b,c;\n\t\ta=hypot(x2-x3,y2-y3);\n\t\tb=hypot(x3-x1,y3-y1);\n\t\tc=hypot(x1-x2,y1-y2);\n\t\tdouble A,B,C;\n\t\tA=acos((b*b+c*c-a*a)/(2.*b*c))/2;\n\t\tB=acos((c*c+a*a-b*b)/(2.*c*a))/2;\n\t\tC=acos((a*a+b*b-c*c)/(2.*a*b))/2;\n\n\t\tdouble cotA,cotB,cotC;\n\t\tcotA=cos(A)/sin(A);\n\t\tcotB=cos(B)/sin(B);\n\t\tcotC=cos(C)/sin(C);\n\n\t\tdouble s=(a+b+c)/2;\n\t\tdouble area=sqrt(s*(s-a)*(s-b)*(s-c));\n\n\t\tdouble r1,r2,r3;\n\t\tdouble r1min=0.05,r1max=2*area/(a+b+c);\n\t\trep(i,50){\n\t\t\tr1=(r1min+r1max)/2;\n\t\t\tr2=(-sqrt(r1)+sqrt(r1+cotB*(c-r1*cotA)))/cotB;\tr2=r2*r2;\n\t\t\tr3=(-sqrt(r1)+sqrt(r1+cotC*(b-r1*cotA)))/cotC;\tr3=r3*r3;\n\t\t\tif(r2*cotB+2*sqrt(r2*r3)+r3*cotC<a)\tr1max=r1;\n\t\t\telse\t\t\t\t\t\t\t\tr1min=r1;\n\t\t}\n\t\tprintf(\"%f %f %f\\n\",r1,r2,r3);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n    // üªª½sÈêÍdÈÁÄ¢È¢±ÆÉ·é\n    if(abs(cross(a2-a1,b2-b1)) < EPS){\n        return 0;\n    }\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,a)>0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n\n// @üxNgðßé\nP unitVector(P a){\n\treturn P(-a.imag(),a.real());\n}\n// PÊ@üxNgðßé\nP unitNormalVector(P a,P b){\n\tP tmp=(b-a);\n\tP e=P(-tmp.imag(),tmp.real());\n\te/=abs(e);\n\treturn e;\n}\n\nP ap,bp,cp;\nP acp,bcp,ccp;\ndouble ar,br,cr;\n\nP selDot(P &ab1_a,P &ab1_b,P &ab2_a,P &ab2_b,P &ac1_a,P &ac1_b,P& ac2_a,P &ac2_b){\n\tP inDot=P(-1,-1);\n\t// »ê¼êÌð_ðßAOp`ÌÉÜÜêéàÌðIÔ\n\tif(isInTriangle(ap,bp,cp,intersection_l(ab1_a,ab1_b,ac1_a,ac1_b)))\n\t\tinDot=intersection_l(ab1_a,ab1_b,ac1_a,ac1_b);\n\telse if(isInTriangle(ap,bp,cp,intersection_l(ab1_a,ab1_b,ac2_a,ac2_b)))\n\t\tinDot=intersection_l(ab1_a,ab1_b,ac2_a,ac2_b);\n\telse if(isInTriangle(ap,bp,cp,intersection_l(ab2_a,ab2_b,ac2_a,ac2_b)))\n\t\tinDot=intersection_l(ab2_a,ab2_b,ac2_a,ac2_b);\n\telse if(isInTriangle(ap,bp,cp,intersection_l(ab2_a,ab2_b,ac1_a,ac1_b)))\n\t\tinDot=intersection_l(ab2_a,ab2_b,ac1_a,ac1_b);\n\treturn inDot;\n}\n\n// ~bÆ~cÌÖWð`FbN\nbool checkB(double r){\n\tP ba1_a,ba1_b,ba2_a,ba2_b;\n\tP bc1_a,bc1_b,bc2_a,bc2_b;\n\n\tP e1=unitNormalVector(bp,ap);\n\tP e2=unitNormalVector(bp,cp);\n\n\tba1_a=e1*r+bp;\n\tba1_b=e1*r+ap;\n\tba2_a=-e1*r+bp;\n\tba2_b=-e1*r+ap;\n\tbc1_a=e2*r+bp;\n\tbc1_b=e2*r+cp;\n\tbc2_a=-e2*r+bp;\n\tbc2_b=-e2*r+cp;\n\tP inDot=selDot(ba1_a,ba1_b,ba2_a,ba2_b,bc1_a,bc1_b,bc2_a,bc2_b);\n\t// ðð½·ð_ª¶ÝµÈ¢\n\tif(EQ(inDot.real(),-1))return false;\n\tbcp=inDot;\n\tbr=r;\n\t// ~aªOp`ÌOÉÍÝoÄ¢½çA»Ì_Åfalse\n\tdouble d1=distance_l_p(ap,bp,bcp);\n\tdouble d2=distance_l_p(bp,cp,bcp);\n\tdouble d3=distance_l_p(cp,ap,bcp);\n\tif((!EQ(d1,br)&&d1<br)||(!EQ(d2,br)&&d2<br)||(!EQ(d3,br)&&d3<br))return false;\n\t//~aÆdÈé©`FbN\n\t// dÈéÈçfalse\n\tif(abs(acp-bcp)<br+ar)return false;\n\treturn true;\n}\nbool checkC(double r){\n\tP ca1_a,ca1_b,ca2_a,ca2_b;\n\tP cb1_a,cb1_b,cb2_a,cb2_b;\n\n\tP e1=unitNormalVector(cp,ap);\n\tP e2=unitNormalVector(cp,bp);\n\n\tca1_a=e1*r+cp;\n\tca1_b=e1*r+ap;\n\tca2_a=-e1*r+cp;\n\tca2_b=-e1*r+ap;\n\tcb1_a=e2*r+cp;\n\tcb1_b=e2*r+bp;\n\tcb2_a=-e2*r+cp;\n\tcb2_b=-e2*r+bp;\n\tP inDot=selDot(ca1_a,ca1_b,ca2_a,ca2_b,cb1_a,cb1_b,cb2_a,cb2_b);\n\t// ðð½·ð_ª¶ÝµÈ¢\n\tif(EQ(inDot.real(),-1))return false;\n\tccp=inDot;\n\tcr=r;\n\tdouble d1=distance_l_p(ap,bp,ccp);\n\tdouble d2=distance_l_p(bp,cp,ccp);\n\tdouble d3=distance_l_p(cp,ap,ccp);\n\tif((!EQ(d1,cr)&&d1<cr)||(!EQ(d2,cr)&&d2<cr)||(!EQ(d3,cr)&&d3<cr))return false;\n\t//~aÆdÈé©`FbN\n\t// dÈéÈçfalse\n\tif(abs(ccp-acp)<cr+ar)return false;\n\treturn true;\n}\n\n// _AÉß¢~ð¼arÅu¯é©`FbN\nbool check(double r){\n\tP ab1_a,ab1_b;\n\tP ab2_a,ab2_b;\n\n\tP ac1_a,ac1_b;\n\tP ac2_b,ac2_a;\n\n\tP e1=unitNormalVector(ap,bp);\n\tP e2=unitNormalVector(ap,cp);\n\n\tab1_a=e1*r+ap;\n\tab1_b=e1*r+bp;\n\tab2_a=-e1*r+ap;\n\tab2_b=-e1*r+bp;\n\tac1_a=e2*r+ap;\n\tac1_b=e2*r+cp;\n\tac2_a=-e2*r+ap;\n\tac2_b=-e2*r+cp;\n\n\tP inDot=selDot(ab1_a,ab1_b,ab2_a,ab2_b,ac1_a,ac1_b,ac2_a,ac2_b);\n\t// ðð½·ð_ª¶ÝµÈ¢\n\tif(EQ(inDot.real(),-1))\n\t\treturn false;\n\tacp=inDot;\n\tar=r;\n\t// ~aªOp`ÌOÉÍÝoÄ¢½çA»Ì_Åfalse\n\tdouble d1=distance_l_p(ap,bp,acp);\n\tdouble d2=distance_l_p(ap,cp,acp);\n\tdouble d3=distance_l_p(bp,cp,acp);\n\tif((!EQ(d1,ar)&&d1<ar)||(!EQ(d2,ar)&&d2<ar)||(!EQ(d3,ar)&&d3<ar))return false;\n\t// _BÉß¢~Ì¼aÆS_ðßé\n\tdouble ub=1000;\n\tdouble lb=0;\n\tint loop=100;\n\twhile(loop--){\n\t\tdouble mid=(ub+lb)/2;\n\t\tif(checkB(mid))lb=mid;\n\t\telse ub=mid;\n\t}\n\tbr=ub;\n\tub=1000;\n\tlb=0;\n\tloop=30;\n\twhile(loop--){\n\t\tdouble mid=(ub+lb)/2;\n\t\tif(checkC(mid))lb=mid;\n\t\telse ub=mid;\n\t}\n\tcr=ub;\n\t// àµbÆcÌ~ª­ÁÂ©È¢ÈçAfalse\n\tif(abs(bcp-ccp)>cr+br)return false;\n\treturn true;\n}\n\nint main(){\n\n\tint x1,x2,x3,y1,y2,y3;\n\twhile(cin>>x1>>y1>>x2>>y2>>x3>>y3&&!(x1==0&&y1==0&&x2==0&&y2==0&&x3==0&&y3==0)){\n\t\tap=P(x1,y1);\n\t\tbp=P(x2,y2);\n\t\tcp=P(x3,y3);\n\t\tdouble ub=1000;\n\t\tdouble lb=0;\n\t\tint loop=30;\n\t\tP acp;\n\t\twhile(loop--){\n\t\t\tdouble mid=(ub+lb)/2;\n\t\t\tif(check(mid))lb=mid;\n\t\t\telse ub=mid;\n\t\t}\n\t\tprintf(\"%.10f %.10f %.10f\\n\",ar,br,cr);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <numeric> \n#include <cstdlib> \n#include <climits> \n#include <cmath> \n#include <cstdio> \n#include <cfloat> \n#include <map> \n#include <utility> \n#include <cassert>\n#include <set> \n#include <memory> \n#include <algorithm> \n#include <functional> \n#include <sstream> \n#include <complex> \n#include <iomanip>\n#include <stack> \n#include <queue> \n#include <string> \n#include <vector> \nusing namespace std; \n\n#define rep(i, n) for(int i = 0; i < n; i++) \n#define rep2(i, m, n) for(int i = m; i < n; i++) \nconst double EPS = 1E-10; \ntypedef long long ll; \ntypedef pair<int, int> P; \ntypedef pair<int, P> PP; \ntypedef complex<double> xy_t; \nconst int INF = 1 << 30; \n\ndouble cross(xy_t a, xy_t b){\n  return imag(conj(a) * b);\n}\n\ndouble dot(xy_t a, xy_t b){\n  return real(conj(a) * b);\n}\n\nxy_t A, B, C;\n\ndouble limit;\nxy_t r1, r2[2];\ndouble db, dc;\n\nvoid setR(xy_t s, xy_t p0, xy_t p1, double R){\n  xy_t p = p0 - s;\n  xy_t q = p1 - s;\n  p /= abs(p);\n  q /= abs(q);\n  xy_t r = p + q;\n  r /= abs(r);\n  double d = abs(cross(r, p));\n  r1 = s + r * (R / d);\n  \n}\n\ndouble getR2(xy_t s, xy_t p0, xy_t p1, double R, int id){\n  xy_t p = p0 - s;\n  xy_t q = p1 - s;\n  p /= abs(p);\n  q /= abs(q);\n  xy_t r = p + q;\n  r /= abs(r);\n  double d = abs(cross(r, p));\n\n\n  double ub = limit;\n  double lb = 0;\n  \n  for(int i = 0; i < 300; i++){\n    double mb = (ub + lb) / 2.0;\n    r2[id] = s + r * (mb / d);\n    if(abs(r2[id] - r1) > mb + R) lb = mb;\n    else ub = mb;\n  }\n \n  return lb;\n}\n\nbool ok(double mb){\n  \n  setR(A, B, C , mb);\n  db = getR2(B, A, C, mb, 0);\n  dc = getR2(C, A, B, mb, 1);\n  //  cout << (b + c) << \" \" << abs(r2[0] - r2[1]) << endl;\n  return (db + dc) > abs(r2[0] - r2[1]);\n}\n\nint main(){\n  int a, b, c, d, e, f;\n  while(cin >> a >> b >> c >> d >> e >> f && (a || b || c || d || e || f)){\n    A = xy_t(a, b);\n    B = xy_t(c, d);\n    C = xy_t(e, f);\n\n    double S = abs(cross(B - A, C - A)) / 2.0;\n    limit = S * 2 / (abs(B - A) + abs(C - A) + abs(C - B));\n  \n    double ub = limit;\n    double lb = 0;\n    rep(i, 300){\n      double mb = (ub + lb) / 2.0;\n      if(ok(mb)) lb = mb;\n      else ub = mb;\n    }\n    cout << fixed << setprecision(9) << lb << \" \" << db << \" \" << dc << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntypedef complex<double> C;\n\nconst double PI = 4*atan(1.0);\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(){}\n    L(const C a, const C b) {\n        push_back(a); push_back(b);\n    }\n};\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nbool eq(C c1,C c2)\n{\n  return (eq(c1.real(),c2.real()) && eq(c1.imag(),c2.imag()));\n}\n\n//?????¶??????sqrt\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n//??£??????\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//?§????(rad)\ndouble getarg(C a,C b){\n    return arg(b*conj(a));\n}\n\n//??????\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\n//??????\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;   //b--a--c on line\n}\n//??´???????????????????????????(????????´??????True)\nbool intersectLL(const L& l, const L& m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//??´?????¨?????????????????????(????????±??????????????¨??????)\nbool intersectLS(const L& l, const L& s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//??´?????¨????????????(??±???)??????\nbool intersectLP(const L& l, const C p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//??????????????????????????????(????????±??????????????¨??????)\nbool intersectSS(const L& s, const L& t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n//????????¨????????????(??±???)??????\nbool intersectSP(const L& s, const C p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n//??´???????????????????????????\nC crosspointLL(const L& l, const L& m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //????????´????????¨???\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n//???p?????´???l???????°???±\nC projection(const L& l, const C p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n//crosspointCL????????¨????????¢??°(??????????¬???§???)\ndouble gettime(C c1,C c2)\n{\n    return (dot(c1,c2) < 0 ? -1.0 : 1.0 ) * abs(c2) / abs(c1);\n}\n//?????¨??´????????????\nvector<C> crosspointCL(C c1,double r1,const L& l)\n{\n    C a=l[0], b=l[1];\n    vector<C> res;\n    C base=b-a,  target=projection(L(a,b),c1);\n    double length=abs(base), h=abs(c1-target);\n    base/=length;\n    if(r1+EPS<h)    return res;\n    double w=Sqrt(r1*r1-h*h);\n    double LL=gettime(normalize(b-a),target-a)-w,RR=LL+w*2.0;\n    res.push_back(a+base*LL);\n    if(eq(LL,RR))   return res;\n    res.push_back(a+base*RR);\n    return res;\n}\n\n//?????¨???????????????\nvector<C> crosspointCS(C c1,double r1,const L& s)\n{\n    vector<C> tmp=crosspointCL(c1,r1,s);\n    vector<C> res;\n    rep(i,tmp.size()){\n        if(eq(abs(s[1]-s[0]),abs(s[0]-tmp[i])+abs(s[1]-tmp[i]))){\n            res.push_back(tmp[i]);\n        }\n    }\n    return res;\n}\n//?????????????????????\nL crosspointCC(const C c1, const double r1, const C c2, const double r2)\n{\n    C a = conj(c2-c1), b = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), c = r1*r1*(c2-c1);\n    C d = b*b-4.0*a*c;\n    C z1 = (-b+sqrt(d))/(2.0*a)+c1, z2 = (-b-sqrt(d))/(2.0*a)+c1;\n    return L(z1, z2);\n}\n//???p?????´???l????????¨??????????§°?§????\nC reflection(const L &l, const C p)\n{\n    return p + (projection(l, p) - p)*2.0;\n}\n//?????¨??´???????????¢\ndouble distanceLP(const L &l, const C p)\n{\n    return abs(p - projection(l, p));\n}\n//??´?????¨??´???????????¢\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n//??´?????¨??????????????¢\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n//????????¨???????????¢\ndouble distanceSP(const L &s, const C p)\n{\n    const C r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n//????????¨??????????????¢\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n//?????¨????§???¢?????±?????¨????????¢???\ndouble getarea(C c1,double r1,C a,C b)\n{\n    C va=c1-a,vb=c1-b;\n    double A=abs(va),B=abs(vb);\n    double f=cross(va,vb),d=distanceSP(L(a,b),c1),res=0;\n    if(eq(f,0.0))   return 0;\n    if(A < r1+EPS && B < r1+EPS)    return f*0.5;\n    if(d>r1-EPS)    return r1*r1*M_PI*getarg(va,vb)/(2.0*M_PI);\n    vector<C> u=crosspointCS(c1,r1,L(a,b));\n    u.insert(u.begin(),a),u.push_back(b);\n    for(int i=0;i+1<(int)u.size();i++){\n        res+=getarea(c1,r1,u[i],u[i+1]);\n    }\n    return res;\n}\ndouble getcrossarea(const vector<C>& t,C c1,double r1)\n{\n    int n = (int)t.size();\n    if(n<3) return 0;\n    double res=0;\n    rep(i,n){\n      C a=t[i], b=t[(i+1)%n];\n      res += getarea(c1,r1,a,b);\n    }\n    return res;\n}\n//??????????±???????(O(nlogn))\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = (int)ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n//?????§??????\nbool isconvex(const vector<C>& ps)\n{\n    rep(i,ps.size()){\n        if (ccw(ps[(i+ps.size()-1) % ps.size()],ps[i],ps[(i+1) % ps.size()])) return false;\n    }\n    return true;\n}\n//????§???¢????¬????????????¢???(??????????????£)\ndouble area(const vector<C>& ps)\n{\n    double A = 0;\n    rep(i,ps.size()){\n        A += cross(ps[i],ps[(i+1) % ps.size()]);\n    }\n    return A / 2.0;\n}\n//???????§???¢?????´?????§???????????????????????´????????¢\nvector<C> convex_cut(const vector<C>& ps, const L& l)\n{\n    vector<C> Q;\n    rep(i,ps.size()){\n        C A = ps[i], B = ps[(i+1)%ps.size()];\n        if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspointLL(L(A, B),l));\n    }\n    return Q;\n}\n//??????????§???¢???????????????????????????(0??????????????????,1?????????,2???????????????)\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n//???????§???¢?????????\nvector<C> convex_intersection(const vector<C>& ps,const vector<C>& qs)\n{\n\tvector<C> rs;\n\tint a = ps.size(),b = qs.size();\n\trep(i,a){\n        if(contains(qs,ps[i])){\n            rs.push_back(ps[i]);\n        }\n    }\n\trep(i,b){\n        if(contains(ps,qs[i])){\n            rs.push_back(qs[i]);\n        }\n    }\n    rep(i,a){\n        rep(j,b){\n            L l1(ps[i],ps[(i+1)%a]),l2(qs[j],qs[(j+1)%b]);\n\t\t    if(intersectSS(l1,l2)){\n                rs.push_back(crosspointLL(l1,l2));\n            }\n        }\n\t}\n\tsort(rs.begin(),rs.end());\n\trs.erase(unique(rs.begin(),rs.end()),rs.end());\n\tif(rs.size() <= 1){\n        return rs;\n    }\n\treturn convex_hull(rs);\n}\n//???????§???¢?????´???????±???????(?????£????????????)\n//maxi,maxj?????????????????¨??????\ndouble convex_diameter(const vector<C>& ps)\n{\n    const int n = (int)ps.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) is = i;\n        if (imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double maxd = abs(ps[is]-ps[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if (cross(ps[(i+1)%ps.size()]-ps[i],ps[(j+1)%ps.size()]-ps[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (abs(ps[i]-ps[j]) > maxd) {\n            maxd = abs(ps[i]-ps[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd;\n}\n\nbool compyx(C c1,C c2)\n{\n    return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();\n}\n\n//????????????????±???????\ndouble closest_pair(C* a, int n)\n{\n    if(n<=1) return 1e100;\n    int m=n/2;\n    double x=a[m].real();\n    double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,compyx);\n    vector<C> b;\n    rep(i,n){\n        if(abs(x-a[i].real())>=d) continue;\n        rep(j,b.size()){\n            C dp=a[i]-b[b.size()-1-j];\n            if(dp.imag()>=d) break;\n            d=min(d,abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\ndouble compute_shortest(C* a,int n)\n{\n    sort(a,a+n);\n    return closest_pair(a,n);\n}\n//2??????????????¢????????????(????????????2??????????????±?????\\????????°)\nint getstateCC(C c1,double r1,C c2,double r2)\n{\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)return 4;\n    if(d>r1+r2-EPS)return 3;\n    if(d>abs(r1-r2)+EPS)return 2;\n    if(d>abs(r1-r2)-EPS)return 1;\n    return 0;\n}\n//?????????????????\\???????????????????????\\???\nC gettangentCP_(C c1,double r1,C p,int flg){\n    C base=c1-p;\n    double w=Sqrt(norm(base)-r1*r1);\n    C s=p+base*C(w,r1 * flg)/norm(base)*w;\n    return s;\n}\n//????????????????????\\???\nvector<L> gettangentCP(C c1,double r1,C p){\n    vector<L> res;\n    C s=gettangentCP_(c1,r1,p,1);\n    C t=gettangentCP_(c1,r1,p,-1);\n    //??????????????¨??????????????´???\n    if(eq(s,t)){\n        res.push_back(L(s,s+(c1-p)*C(0,1)));\n    }else{\n        res.push_back(L(p,s));\n        res.push_back(L(p,t));\n    }\n    return res;\n}\n\n//2????????±????????\\???????±???????\nL getintangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double w=r1+r2;\n    double h=Sqrt(norm(base)-w*w);\n    C k=base*C(w,h*flg)/norm(base);\n    return L(c1+k*r1,c2-k*r2);\n}\n//2????????±????????\\???????±???????\nL getouttangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double h=r2-r1;\n    double w=Sqrt(norm(base)-h*h);\n    C k=base*C(w,h*flg)/norm(base)*C(0,flg);\n    return L(c1+k*r1,c2+k*r2);\n}\n//2????????±?????\\???????±???????(?????´??????????????????????????????????????\\???)\nvector<L> gettangentCC(C c1,double r1,C c2,double r2)\n{\n    vector<L> res;\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)  res.push_back(getintangent(c1,r1,c2,r2,1));\n    if(d>r1+r2-EPS)  res.push_back(getintangent(c1,r1,c2,r2,-1));\n    if(d>abs(r1-r2)+EPS)    res.push_back(getouttangent(c1,r1,c2,r2,1));\n    if(d>abs(r1-r2)-EPS)    res.push_back(getouttangent(c1,r1,c2,r2,-1));\n    return res;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        C x,y,z;\n        int p1,p2,p3,p4,p5,p6;\n        cin >> p1 >> p2 >> p3 >> p4 >> p5 >> p6;\n        x = C(p1,p2),y = C(p3,p4),z = C(p5,p6);\n        if(x == y){\n            break;\n        }\n        double a = abs(x-y),b = abs(y-z),c = abs(z-x);\n        vector<C> vec = {x,y,z};\n        double s = (a + b + c) / 2;\n        double r = abs(area(vec)) / s;\n        double d = sqrt(r*r+((-a+b+c)/2)*((-a+b+c)/2)), e = sqrt(r*r+((a-b+c)/2)*((a-b+c)/2)), f = sqrt(r*r+((a+b-c)/2)*((a+b-c)/2));\n        printf(\"%.12lf %.12lf %.12lf\\n\",r*(s+e-r-d-f)/(2*(s-b)),r*(s+f-r-d-e)/(2*(s-c)),r*(s+d-r-e-f)/(2*(s-a)));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x_ = 0, double y_ = 0):x(x_), y(y_) {}\n    Point operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n};\nistream &operator>>(istream &is, Point &p) {\n    return is >> p.x >> p.y;\n}\nostream &operator<<(ostream &os, Point &p) {\n    return os << '(' << p.x << \", \" << p.y << ')';\n}\n\ndouble herons_formula(double a, double b, double c) {\n    double s = (a+b+c) / 2.0;\n    double S = sqrt((a+b+c)*(b+c-a)*(a+c-b)*(a+b-c)) / 4.0;\n    double r = S / s;\n    return r;\n}\n\ndouble dist(const Point &a, const Point &b) {\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\ndouble angle(double a, double b, double c) {\n    double cosA =  (b*b + c*c - a*a) / (2*b*c);\n    return acos(cosA);\n}\n\ndouble f(double r, double A, double B, double C) {\n    double nume = r * (1.0 + tan(B/4.0)) * (1.0 + tan(C/4.0));\n    double deno = 2.0 * (1.0 + tan(A/4.0));\n    return nume / deno;\n}\n\nint main() {\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    \n    while (true) {\n        Point p1, p2, p3;\n        cin >> p1 >> p2 >> p3;\n        if (p1.x == 0 && p1.y == 0 &&\n            p2.x == 0 && p2.y == 0 &&\n            p3.x == 0 && p3.y == 0) break;\n\n        double a = dist(p1, p2);\n        double b = dist(p2, p3);\n        double c = dist(p3, p1);\n        double r = herons_formula(a, b, c);\n\n        double A = angle(a, b, c);\n        double B = angle(b, a, c);\n        double C = angle(c, a, b);\n\n        double r1 = f(r, B, C, A);\n        double r2 = f(r, C, A, B);\n        double r3 = f(r, A, B, C);\n\n        cout << r1 << \" \" << r2 << \" \" << r3 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ndouble add(double a,double b)\n{\n\tif(abs(a+b)<eps*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\n\nstruct P\n{\n\tdouble x,y;\n\tP() {}\n\tP(double x,double y) : x(x),y(y){}\n\tP operator + (P p)\n\t{\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p)\n\t{\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d)\n\t{\n\t\treturn P(x*d,y*d);\n\t}\n\tdouble dot(P p)\n\t{\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p)\n\t{\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tdouble len()\n\t{\n\t\treturn sqrt(x*x+y*y);\n\t}\n};\ndouble dist(P a,P b)\n{\n\treturn (a-b).len();\n}\nP A,B,C,I,ab,ai,ah;\ndouble a,b,c,IA,IB,IC,s,r,ra,rb,rc;\nint main()\n{\n\twhile(1)\n\t{\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf\",&A.x,&A.y,&B.x,&B.y,&C.x,&C.y);\n\t\tif(A.x+A.y+B.x+B.y+C.x+C.y==0)break;\n\t\ta = dist(B,C); b = dist(A,C); c = dist(A,B);\n\t\ts = (a+b+c)/2.0;\n\t\tI = (A*a+B*b+C*c)*(1.0/(a+b+c));\n\t\tIA = dist(I,A); IB = dist(I,B); IC = dist(I,C);\n\t\tab = B-A; ai = I-A;\n\t\tah = ab*(ab.dot(ai)/ab.len()/ab.len());\n\t\tr = (ai-ah).len();\n\t\tra = r*(s-r-(IB+IC-IA))/2.0/(s-a);\n\t\trb = r*(s-r-(IC+IA-IB))/2.0/(s-b);\n\t\trc = r*(s-r-(IA+IB-IC))/2.0/(s-c);\n\t\tprintf(\"%f %f %f\\n\",ra,rb,rc);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\ndouble length(double x1, double y1, double x2, double y2){\n  return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n}\n\ndouble angle(double len1, double len2, double len3){\n  double bunshi = len1*len1 + len2*len2 - len3*len3;\n  double bunbo = 2.0 * len1 * len2;\n  return acos(bunshi/bunbo);\n}\n\ndouble calc_area(double a, double b, double c, double theta){\n  return (a * b * sin(theta))/(a + b + c);\n}\n\ndouble radii(double r, double a, double b, double c){\n  double bunshi = r * (1.0 + tan(a/4.0)) * (1.0 + tan(b/4.0));\n  double bunbo = 2.0 * (1.0 + tan(c/4.0));\n  return bunshi / bunbo;\n}\n\nint main(){\n  double x1,y1,x2,y2,x3,y3;\n  cout.precision(10);\n  for(;cin>>x1>>y1>>x2>>y2>>x3>>y3,!((x1==0)&&(y1==0)&&(x2==0)&&(y2==0)&&(x3==0)&&(y3==0));){\n    double r,r1,r2,r3;\n    double ab,bc,ac;\n    double theta_a,theta_b,theta_c;\n //   cout<<x1<<\" \"<<y1<<\" \"<<x2<<\" \"<<y2<<\" \"<<x3<< \" \"<<y3<<endl;\n    ab = length(x1,y1,x2,y2);\n    bc = length(x3,y3,x2,y2);\n    ac = length(x1,y1,x3,y3);\n    //cout<<ab<<\" \"<<bc<<\" \"<<ac<<endl;\n    theta_a = angle(ab,ac,bc);\n    theta_b = angle(ab,bc,ac);\n    theta_c = angle(ac,bc,ab);\n    //cout<<theta_a<<\" \"<<theta_b<<\" \"<<theta_c<<endl;\n    r = calc_area(ac,bc,ab,theta_c);\n //   cout<<r<<endl;\n    r1 = radii(r,theta_b,theta_c,theta_a);\n    r2 = radii(r,theta_a,theta_c,theta_b);\n    r3 = radii(r,theta_b,theta_a,theta_c);\n    cout<<r1<<\" \"<<r2<<\" \"<<r3<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\n#include <fstream>\n#include <sstream>\nclass svg {\n\tofstream f;\n\tstringstream s;\n\tdouble x1 = 1e9, y1 = 1e9, x2 = -1e9, y2 = -1e9;\npublic:\n\tsvg(string path) :f(path, ios::trunc) {\n\t}\n\t~svg(){\n\t\tf << \"<?xml version=\\\"1.0\\\" standalone=\\\"no\\\"?><svg viewBox='\"<<x1*1.1-x2*0.1<<\" \"<<y1*1.1-y2*0.1<<\" \"<<(x2-x1)*1.2<<\" \"<<(y2-y1)*1.2<<\"' xmlns = \\\"http://www.w3.org/2000/svg\\\" xmlns:xlink = \\\"http://www.w3.org/1999/xlink\\\" >\\n\";\n\t\tf << s.str();\n\t\tf << \"</svg>\";\n\t}\n\tvoid circle(C c) {\n\t\ts << fixed << \"<circle cx = \\\"\" << c.p.real() << \"\\\" cy = \\\"\" << c.p.imag() << \"\\\" r = \\\"\" << c.r << \"\\\" stroke=\\\"black\\\" stroke-width=\\\"0.01\\\" fill = \\\"none\\\"/>\\n\";\n\t\tcmin(x1, c.p.real() - c.r);\n\t\tcmin(y1, c.p.imag() - c.r);\n\t\tcmax(x2, c.p.real() + c.r);\n\t\tcmax(y2, c.p.imag() + c.r);\n\t}\n\tvoid line(L l) {\n\t\ts << fixed << \"<line x1=\\\"\" << l.a.real() << \"\\\" y1=\\\"\" << l.a.imag() << \"\\\" x2=\\\"\" << l.b.real() << \"\\\" y2=\\\"\" << l.b.imag() << \"\\\" stroke=\\\"black\\\" stroke-width=\\\"0.01\\\"/>\\n\";\n\t\tcmin(x1, l.a.real());\n\t\tcmin(y1, l.a.imag());\n\t\tcmax(x2, l.a.real());\n\t\tcmax(y2, l.a.imag());\n\t\tcmin(x1, l.b.real());\n\t\tcmin(y1, l.b.imag());\n\t\tcmax(x2, l.b.real());\n\t\tcmax(y2, l.b.imag());\n\t}\n};\nint main() {\n\tVP p(3);\n\tfor (;;) {\n\t\trep(i, 3) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = { (double)x,(double)y };\n\t\t}\n\t\tif (p[0] == p[1])break;\n\t\tP up1 = (p[1] * abs(p[2] - p[0]) + p[2] * abs(p[1] - p[0])) / (abs(p[2] - p[0]) + abs(p[1] - p[0]));\n\t\tP dn1 = p[0];\n\t\tP up2, up3;\n\t\tdouble r1, r2, r3;\n\t\trep(i, 50) {\n\t\t\tP m1 = (up1 + dn1) * 0.5;\n\t\t\tr1 = dist_lp({ p[0],p[1] }, m1);\n\t\t\tup2 = (p[0] * abs(p[2] - p[1]) + p[2] * abs(p[0] - p[1])) / (abs(p[2] - p[1]) + abs(p[0] - p[1]));\n\t\t\tup3 = (p[0] * abs(p[2] - p[1]) + p[1] * abs(p[0] - p[2])) / (abs(p[2] - p[1]) + abs(p[0] - p[2]));\n\t\t\tP dn2 = p[1], dn3 = p[2];\n\t\t\trep(j, 50) {\n\t\t\t\tP m2 = (up2 + dn2)*0.5, m3 = (up3 + dn3)*0.5;\n\t\t\t\tr2 = dist_lp({ p[0],p[1] }, m2);\n\t\t\t\tr3 = dist_lp({ p[0],p[2] }, m3);\n\t\t\t\tif (!isis_ls({ p[0],up1 }, { p[1],m2 }) && dist_lp({ p[0],p[2] }, m2) > r2 && abs(m1 - m2) > r1 + r2)dn2 = m2;\n\t\t\t\telse up2 = m2;\n\t\t\t\tif (!isis_ls({ p[0],up1 }, { p[2],m3 }) && dist_lp({ p[0],p[1] }, m3) > r3 && abs(m3 - m1) > r1 + r3)dn3 = m3;\n\t\t\t\telse up3 = m3;\n\t\t\t}\n\t\t\tif (dist_lp({ p[1],p[2] }, m1) > r1&&abs(up2 - up3) < r2 + r3)dn1 = m1;\n\t\t\telse up1 = m1;\n\t\t}\n\t\tcout << fixed << setprecision(10) << r1 << \",\" << r2 << \",\" << r3 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <vector>\n#define EPS (1e-10)\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,double> C;\n\ndouble cross(P a, P b){ return a.X*b.Y - a.Y*b.X;}\n\nvector<double> malfatti_circle(P a, P b, P c){\n  const double A = abs(b-c), B = abs(a-c), C = abs(a-b), r = abs(cross(b-a,c-a))/(A+B+C),\n    x = (-A+B+C)/2.0/r, y = (A-B+C)/2.0/r, z = (A+B-C)/2.0/r;\n  vector<double> ret(3);\n  double r_a, r_b, r_c, small = 0.0, large = r;\n  for(int i = 0; i < 100; ++i){\n    r_a = (small+large)/2.0;\n    //printf(\"r_a = %.12f\\n\", r_a);\n    double s = y*y, t = x*y*r_a - C*y - 2*r_a, u = C*C - 2.0*C*x*r_a + x*x*r_a*r_a;\n    r_b = (-t - sqrt(t*t - s*u))/s;\n    //printf(\"r_b = %.12f\\n\", r_b);\n    //printf(\"s*r_b*r_b + 2*t*r_b + u = %.12f\\n\", s*r_b*r_b + 2*t*r_b + u);\n    //printf(\"2*sqrt(r_a*r_b) + y*r_b + x*r_a = %.12f, C = %.12f\\n\", 2*sqrt(r_a*r_b) + y*r_b + x*r_a, C);\n    s = z*z;\n    t = x*z*r_a - B*z - 2*r_a;\n    u = B*B - 2.0*B*x*r_a + x*x*r_a*r_a;\n    r_c = (-t - sqrt(t*t - s*u))/s;\n    //printf(\"r_c = %.12f\\n\", r_c);\n    //printf(\"2*sqrt(r_a*r_c) + z*r_c + x*r_a = %.12f, B = %.12f\\n\", 2*sqrt(r_a*r_c) + z*r_c + x*r_a, B);\n\n    //printf(\"2*sqrt(r_b*r_c) + y*r_b + z*r_c = %.12f, A = %.12f\\n\", 2*sqrt(r_b*r_c) + y*r_b + z*r_c, A);\n    if(2*sqrt(r_b*r_c) + y*r_b + z*r_c > A){\n      small = r_a;\n    }else{\n      large = r_a;\n    }\n  }\n  ret[0] = r_a;\n  ret[1] = r_b;\n  ret[2] = r_c;\n  return ret;\n}\n\nint main(){\n  double x_a, y_a, x_b, y_b, x_c, y_c;\n  while(cin >> x_a >> y_a >> x_b >> y_b >> x_c >> y_c, x_a||y_a||x_b||y_b||x_c||y_c){\n    P a = P(x_a,y_a), b = P(x_b,y_b), c = P(x_c,y_c);\n    vector<double> R = malfatti_circle(a,b,c);\n    for(int i = 0; i < 3; ++i){\n      printf(\"%.12f\", R[i]);\n      if(i < 3) cout << \" \";\n    }cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tVP p(3);\n\tfor (;;) {\n\t\trep(i, 3) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = { (double)x,(double)y };\n\t\t}\n\t\tif (p[0] == p[1])break;\n\t\tP up1 = (p[1] * abs(p[2] - p[0]) + p[2] * abs(p[1] - p[0])) / (abs(p[2] - p[0]) + abs(p[1] - p[0]));\n\t\tP dn1 = p[0];\n\t\tdouble r1,r2, r3;\n\t\trep(i, 30) {\n\t\t\tP m1 = (up1 + dn1) * 0.5l;\n\t\t\tr1 = dist_lp({ p[0],p[1] }, m1);\n\t\t\tP up2 = (p[0] * abs(p[2] - p[1]) + p[2] * abs(p[0] - p[1])) / (abs(p[2] - p[1]) + abs(p[0] - p[1]));\n\t\t\tP up3 = (p[0] * abs(p[2] - p[1]) + p[1] * abs(p[0] - p[2])) / (abs(p[2] - p[1]) + abs(p[0] - p[2]));\n\t\t\tP dn2 = p[1], dn3 = p[2];\n\t\t\trep(j, 30) {\n\t\t\t\tP m2 = (up2 + dn2)*0.5l, m3 = (up3 + dn3)*0.5l;\n\t\t\t\tr2 = dist_lp({ p[0],p[1] }, m2);\n\t\t\t\tr3 = dist_lp({ p[0],p[2] }, m3);\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[1],m2 }) && dist_lp({ p[0],p[2] }, m2) > r2 && abs(m1 - m2) > r1 + r2)dn2 = m2;\n\t\t\t\telse up2 = m2;\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[2],m3 }) && dist_lp({ p[0],p[1] }, m3) > r3 && abs(m3 - m1) > r1 + r3)dn3 = m3;\n\t\t\t\telse up3 = m3;\n\t\t\t}\n\t\t\tif (isis_ss({ p[1],up2 }, { p[2],up3 }) || abs(up2 - up3) < r2 + r3)dn1 = m1;\n\t\t\telse up1 = m1;\n\t\t}\n\t\tcout << fixed << setprecision(10) << r1 << \" \" << r2 << \" \" << r3 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\n\nstruct Line : public vector<Point> {\n    Line(const Point& a, const Point& b) {\n        push_back(a); push_back(b);\n    }\n    Point vector() const {\n        return back() - front();\n    }\n};\ndouble cross(Point a, Point b){\n    return imag(conj(a) * b);\n}\ndouble distanceLP(Line l, Point p){\n    // return abs(p - projection(l, p));\n    return abs(cross(l.vector(), p - l[0])) / abs(l.vector());\n}\n\nPoint incenter(Point p1, Point p2, Point p3){\n    double a = abs(p2 - p3);\n    double b = abs(p3 - p1);\n    double c = abs(p1 - p2);\n    return (a * p1 + b * p2 + c * p3) / (a + b + c);\n}\n\nPoint find_point(Point a, double r, Point p, Point c, Line l){\n    double lb = 0, ub = 1;\n    REP(iter, 50){\n        double mid = (lb + ub) / 2;\n        Point q = p * (1 - mid) + c * mid;\n        double s = distanceLP(l, q);\n        if(abs(a - q) < r + s){ // too near\n            ub = mid;\n        }else{ // come closer\n            lb = mid;\n        }\n    }\n    return p * (1 - lb) + c * lb;\n}\n\nint main(){\n    while(true){\n        Point tri[3];\n        REP(i, 3){\n            double x, y;\n            cin >> x >> y;\n            tri[i] = Point(x, y);\n        }\n        if(tri[0] == tri[1]) break;\n        Point c = incenter(tri[0], tri[1], tri[2]);\n        double lb = 0, ub = 1;\n        REP(iter, 50){\n            double mid = (lb + ub) / 2;\n            Point p0 = (tri[0] * (1 - mid) + c * mid);\n            double r0 = distanceLP(Line(tri[0], tri[1]), p0);\n            //cout << \"mid : \" << mid << endl;\n            //cout << \"p0 : \" << p0 << \" r0 : \" << r0 << endl;\n\n            Line l(tri[1], tri[2]);\n            Point p1 = find_point(p0, r0, tri[1], c, l);\n            double r1 = distanceLP(l, p1);\n            //cout << \"p1 : \" << p1 << \" r1 : \" << r1 << endl;\n            Point p2 = find_point(p0, r0, tri[2], c, l);\n            double r2 = distanceLP(l, p2);\n            //cout << \"p2 : \" << p2 << \" r2 : \" << r2 << endl;\n            if(abs(p1 - p2) < r1 + r2){ // come closer\n                //cout << \"lb update\" << endl;\n                lb = mid;\n            }else{\n                //cout << \"ub update\" << endl;\n                ub = mid;\n            }\n        }\n\n        Point p0 = (tri[0] * (1 - lb) + c * lb);\n        double r0 = distanceLP(Line(tri[0], tri[1]), p0);\n        Line l(tri[1], tri[2]);\n        Point p1 = find_point(p0, r0, tri[1], c, l);\n        double r1 = distanceLP(l, p1);\n        Point p2 = find_point(p0, r0, tri[2], c, l);\n        double r2 = distanceLP(l, p2);\n        printf(\"%.6f %.6f %.6f\\n\", r0, r1, r2);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define inf (1<<29)\n \nusing namespace std;\n \nclass Point\n{\n  public:\n  double x,y;\n \n  Point(double x = -1,double y = -1): x(x),y(y){}\n \n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//テ「ツ?サテッツスツイテッツスツケテッツセツ津ッツセツ敕」ツ?ォテゥツ卍静」ツつ?\n \n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n \n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n \n//テ・ツソツ?ィツヲツ?」ツ?ォテ・ツソツ愿」ツ?佚」ツ?ヲ\ndouble norm()\n{\nreturn x*x+y*y;\n}\n \n};\n \nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n \n \ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n \ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n \ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n \nbool pequals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n \n//rad テ」ツ?ッティツァツ津・ツコツヲテ」ツつ津」ツδゥテ」ツつクテ」ツつ「テ」ツδウテ」ツ?ァテヲツ個?」ツ?淌」ツ?崚」ツつ凝」ツ?禿」ツ?ィ\nPoint rotate(Point a,double rad)\n{\n  return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y);\n}\n \n// テ・ツコツヲテ」ツつ津」ツδゥテ」ツつクテ」ツつ「テ」ツδウテ」ツ?ォテ・ツ、ツ嘉ヲツ渉?\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n \ndouble getArea(vector<Point>& vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n \ndouble getDist(Point a,Point b)\n{\n  return sqrt(norm(a-b));\n}\n \nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \nstruct P\n{\n \n};\n \nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n \nbool isIntersect(Segment s1,Segment s2)\n{\n  return isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n \n \n \nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  assert(isIntersect(a1,a2,b1,b2));//テ、ツコツ、テ・ツキツョテ」ツ?療」ツ?ヲテ」ツ??」ツ?ェテ」ツ??」ツ??」ツ?禿」ツつ古」ツつ津・ツ、ツ姪」ツ?療」ツ?ヲテ」ツつづ」ツ?づ」ツつ凝ァツィツ凝・ツコツヲテッツシツ暗」ツ?セテ」ツ?淌」ツ?ッテ」ツ?療」ツ?」テ」ツ?凝」ツつ甘ッツシツ淌ッツシツ嘉」ツ?ッテ」ツ??」ツ?氾」ツ??」ツ?ヲテ」ツ?湘」ツつ古」ツつ?\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n \n// Line Line テ、ツクツ甘」ツ?ィテ・ツ青古」ツ??assertテ」ツ?ェテ」ツ??\nPoint getCrossPointLines( Line s1, Line s2){\n    Point a = s1.p2 - s1.p1;\n    Point base = s2.p2 -s2.p1;\n    return s1.p1 + a * (cross(base, s2.p1 - s1.p1)/cross(base, a));\n}\n \n//テ、ツクツ嘉ィツァツ津・ツスツ「ABCテ」ツ?ョテ・ツ??ヲツ篠・テ・ツ??・ツ債甘・ツセツ?」ツつ津ヲツアツづ」ツつ?」ツつ?\ndouble getInradius(Point A,Point B,Point C)\n{\n  vector<Point> vec(3);\n  vec[0] = A, vec[1] = B, vec[2] = C;\n  double S = getArea(vec);\n  double a = getDist(B,C);\n  double b = getDist(A,C);\n  double c = getDist(A,B);\n  return 2.0*S/(a+b+c);\n}\n \n//segテ」ツつ池テ」ツ??」ツ?妥・ツケツウティツ。ツ古」ツ?ォテ」ツつケテ」ツδゥテ」ツつ、テ」ツδ?\nSegment slideSeg(Segment seg,double r)\n{\n  Point p = (seg.p2-seg.p1)*r/abs(seg.p2-seg.p1);\n  p = rotate(p,toRad(90.0));\n  seg = Segment(seg.p1+p,seg.p2+p);\n  if(fabs(seg.p1.x) < EPS)seg.p1.x = 0;\n  if(fabs(seg.p1.y) < EPS)seg.p1.y = 0;\n  if(fabs(seg.p2.x) < EPS)seg.p2.x = 0;\n  if(fabs(seg.p2.y) < EPS)seg.p2.y = 0;\n  return seg;\n}\n \n//テ、ツクツ嘉ィツァツ津・ツスツ「ABCテ」ツ?ョテ・ツ??・ツソツε」ツつ津ヲツアツづ」ツつ?」ツつ?\nPoint getIncenter(Point A,Point B,Point C)\n{\n  double inradius = getInradius(A,B,C);\n \n  Segment seg1 = Segment(A,B);\n  Segment seg2 = Segment(B,C);\n  seg1 = slideSeg(seg1,inradius);\n  seg2 = slideSeg(seg2,inradius);\n  return getCrossPointLines(seg1,seg2);\n}\n \n \n//vector<Point> getMalfattieCircles(Point A,Point B,Point C)\nvoid getMalfattieCircles(Point A,Point B,Point C)\n{\n  Point I = getIncenter(A,B,C);\n  double r = getInradius(A,B,C);\n  double a = getDist(B,C);\n  double b = getDist(C,A);\n  double c = getDist(A,B);\n  double s = (a+b+c)/2.0;\n  double IA = getDist(I,A);\n  double IB = getDist(I,B);\n  double IC = getDist(I,C);\n \n  double r1 = ( r/(2.0*(s-a)) )*( s - r - (IB + IC - IA));\n  double r2 = ( r/(2.0*(s-b)) )*( s - r - (IC + IA - IB));\n  double r3 = ( r/(2.0*(s-c)) )*( s - r - (IA + IB - IC));\n \n  cout << setiosflags(ios::fixed) << setprecision(6) << r1 << \" \" << r2 << \" \" << r3 << endl;\n}\n \nint main()\n{\n  while(true)\n    {\n      Point A,B,C;\n      cin >> A.x >> A.y >> B.x >> B.y >> C.x >> C.y;\n      if(A.x+A.y+B.x+B.y+C.x+C.y == 0)break;\n      getMalfattieCircles(A,B,C);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\ndouble ABS(double a){return max(a,-a);}\ndouble x[5];\ndouble y[5];\ndouble EPS=1e-9;\ndouble PI=acos(-1.0);\nint main(){\n\twhile(1){\n\t\tfor(int i=0;i<3;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tdouble gm=0;\n\t\tfor(int i=0;i<3;i++)gm+=ABS(x[i])+ABS(y[i]);\n\t\tif(gm<EPS)break;\n\t\tdouble l1=sqrt((x[0]-x[1])*(x[0]-x[1])+(y[0]-y[1])*(y[0]-y[1]));\n\t\tdouble l2=sqrt((x[0]-x[2])*(x[0]-x[2])+(y[0]-y[2])*(y[0]-y[2]));\n\t\tdouble th=atan2(y[2]-y[0],x[2]-x[0])-atan2(y[1]-y[0],x[1]-x[0]);\n\t\tif(th<-PI)th+=PI*2;\n\t\tif(th>PI)th-=PI*2;\n\t\tif(th<0){\n\t\t\tth=-th;\n\t\t}\n\t\tdouble t2=atan2(y[2]-y[1],x[2]-x[1])-atan2(y[0]-y[1],x[0]-x[1]);\n\t\tdouble t3=atan2(y[0]-y[2],x[0]-x[2])-atan2(y[1]-y[2],x[1]-x[2]);\n\t\t\n\t\tif(t2<-PI)t2+=PI*2;\n\t\tif(t2>PI)t2-=PI*2;\n\t\tif(t2<0)t2=-t2;\n\t\tif(t3<-PI)t3+=PI*2;\n\t\tif(t3>PI)t3-=PI*2;\n\t\tif(t3<0)t3=-t3;\n\t//\tprintf(\"%f %f %f \",th,t2,t3);\n\t\t//printf(\"%f %f\\n\",l1,l2);\n\t\t\n\t\tdouble L=0;\n\t\tdouble R=10000;\n\t\tdouble R2,R3;\n\t\tfor(int i=0;i<50;i++){\n\t\t\tdouble M=(L+R)/2;\n\t\t\tdouble X1=M/tan(th/2);\n\t\t\tdouble Y1=M;\n\t\t\tif(X1>l1||X1>l2){\n\t\t\t\tR=M;continue;\n\t\t\t}\n\t\t\tdouble left=0;\n\t\t\tdouble right=100000000;\n\t\t\tdouble X2,Y2;\n\t\t\tfor(int j=0;j<50;j++){\n\t\t\t\tdouble md=(left+right)/2;\n\t\t\t\tX2=l1-md/tan(t2/2);\n\t\t\t\tY2=md;\n\t\t\t\t//printf(\"%f %f %f\\n\",X1,X2,Y2);\n\t\t\t\tif(X2<X1){right=md;continue;}\n\t\t\t\tif((X1-X2)*(X1-X2)+(Y1-Y2)*(Y1-Y2)>(M+md)*(M+md))left=md;\n\t\t\t\telse right=md;\n\t\t\t}\n\t\t\tR2=right;\n\t\t\tdouble X3,Y3;\n\t\t\tleft=0;right=100000000;\n\t\t\tfor(int j=0;j<50;j++){\n\t\t\t\tdouble md=(left+right)/2;\n\t\t\t\tX3=l2-md/tan(t3/2);\n\t\t\t\tY3=md;\n\t\t\t\tif(X3<X1){right=md;continue;}\n\t\t\t\tif((X1-X3)*(X1-X3)+(Y1-Y3)*(Y1-Y3)>(M+md)*(M+md))left=md;\n\t\t\t\telse right=md;\n\t\t\t}\n\t\t\tR3=right;\n\t\t\tdouble xf=X3*cos(th/2)+Y3*sin(th/2);\n\t\t\tdouble yf=X3*sin(th/2)-Y3*cos(th/2);\n\t\t\tX3=xf*cos(th/2)-yf*sin(th/2);\n\t\t\tY3=xf*sin(th/2)+yf*cos(th/2);\n\t\t//\tif(Y3<Y2){R=M;continue;}\n\t\t\t//printf(\"(%f %f), (%f %f), (%f %f)\\n\",X1,Y1,X2,Y2,X3,Y3);\n\t\t\tif((X2-X3)*(X2-X3)+(Y2-Y3)*(Y2-Y3)>(R2+R3)*(R2+R3))R=M;\n\t\t\telse L=M;\n\t\t}\n\t\tprintf(\"%.5f %.5f %.5f\\n\",R,R2,R3);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cstdio>\nusing namespace std;\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n \n#define EPS 0.00001\n \nPoint A, B, C;\n \nvoid getR(double alpha, double beta, double l, double r, double R, double &ans, bool &suc){\n    double a, b, c;\n    a = 1.0/((tan(beta)*tan(beta)));\n    b = 2*r/(tan(alpha)*tan(beta)) - 2*l/tan(beta) - 4*r;\n    c = l*l - 2*r*l/tan(alpha) + r*r/(tan(alpha)*tan(alpha));\n    double rr1 = (-b - sqrt(b*b-4*a*c))/(2*a);\n    double rr2 = (-b + sqrt(b*b-4*a*c))/(2*a);\n    suc = false;\n    if ( 0 <= rr1 && rr1 <= R ) { ans = rr1; suc = true;}\n    if ( 0 <= rr2 && rr2 <= R ) { ans = rr2; suc = true;}\n}\n \nvoid compute(){\n    double a = abs(B - C), b = abs(A-C), c = abs(A-B), r1, r2, r3;\n    double s = (a + b + c)/2.0;\n    double R = sqrt(s*(s-a)*(s-b)*(s-c))/s;\n    double X = acos((c*c + b*b - a*a)/(2*c*b));\n    double Y = acos((c*c + a*a - b*b)/(2*c*a));\n    double Z = acos((a*a + b*b - c*c)/(2*a*b));\n    double l = 0, r = 2*R;\n    bool suc1, suc2;\n    while(1){\n        r1 = (l + r)/2.0;\n        getR(X/2, Y/2, c, r1, R, r2, suc1);\n        getR(X/2, Z/2, b, r1, R, r3, suc2);\n        Vector v1 = A - B;\n        Vector v2 = A - C;\n        v1 = polar(r2/sin(Y/2), arg(v1) - Y/2) + B; \n        v2 = polar(r3/sin(Z/2), arg(v2) + Z/2) + C; \n        double d = abs(v1 - v2);\n        if ( fabs(d - (r2+r3)) < EPS ) break;\n        if ( d < r2+r3 || !suc1 || !suc2) l = r1;\n        else r = r1;\n    }\n     \n    printf(\"%.5lf %.5lf %.5lf\\n\", r1, r2, r3);\n}\n \nmain(){\n    while(1){\n    cin >> A.real() >> A.imag();\n    cin >> B.real() >> B.imag();\n    cin >> C.real() >> C.imag();\n    if ( A.real() == 0 && A.imag() == 0 && \n         B.real() == 0 && B.imag() == 0 && \n         C.real() == 0 && C.imag() == 0 ) break;\n    compute();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define inf (1<<29)\n\nusing namespace std;\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n//必要に応じて\ndouble norm()\n{\nreturn x*x+y*y;\n}\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n\nbool pequals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad)\n{\n  return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y);\n}\n\n// 度をラジアンに変換\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\ndouble getArea(vector<Point>& vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\ndouble getDist(Point a,Point b)\n{\n  return sqrt(norm(a-b));\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nstruct P\n{\n\n};\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\n  return isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  assert(isIntersect(a1,a2,b1,b2));//交差していない　これを外してもある程度（またはしっかり？）はうごいてくれる\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n\n// Line Line 上と同じ assertなし\nPoint getCrossPointLines( Line s1, Line s2){\n    Point a = s1.p2 - s1.p1;\n    Point base = s2.p2 -s2.p1;\n    return s1.p1 + a * (cross(base, s2.p1 - s1.p1)/cross(base, a));\n}\n\nvoid printS(Segment seg)\n{\n  cout << \"( \"  << \"(\" << seg.p1.x << \" , \" << seg.p1.y << \")\"  << \" , \" <<       \"(\" <<seg.p2.x << \",\"  << seg.p2.y<<  \")\" << \" )\" << endl;\n}\n\n\ndouble getInradius(Point A,Point B,Point C)\n{\n  vector<Point> vec(3);\n  vec[0] = A, vec[1] = B, vec[2] = C;\n  double S = getArea(vec);\n  double a = getDist(B,C);\n  double b = getDist(A,C);\n  double c = getDist(A,B);\n  return 2.0*S/(a+b+c);\n}\n\nSegment slideSeg(Segment seg,double r)\n{\n  Point p = (seg.p2-seg.p1)*r/abs(seg.p2-seg.p1);\n  p = rotate(p,toRad(90.0));\n  seg = Segment(seg.p1+p,seg.p2+p);\n  if(fabs(seg.p1.x) < EPS)seg.p1.x = 0;\n  if(fabs(seg.p1.y) < EPS)seg.p1.y = 0;\n  if(fabs(seg.p2.x) < EPS)seg.p2.x = 0;\n  if(fabs(seg.p2.y) < EPS)seg.p2.y = 0;\n  return seg;\n}\n\nPoint getIncenter(Point A,Point B,Point C)\n{\n  double inradius = getInradius(A,B,C);\n\n  Segment seg1 = Segment(A,B);\n  Segment seg2 = Segment(B,C);\n  seg1 = slideSeg(seg1,inradius);\n  seg2 = slideSeg(seg2,inradius);\n  return getCrossPointLines(seg1,seg2);\n}\n\nvector<Point> getMalfattieCircles(Point A,Point B,Point C)\n{\n  Point I = getIncenter(A,B,C);\n  double r = getInradius(A,B,C);\n  double a = getDist(B,C);\n  double b = getDist(C,A);\n  double c = getDist(A,B);\n  double s = (a+b+c)/2.0;\n  double IA = getDist(I,A);\n  double IB = getDist(I,B);\n  double IC = getDist(I,C);\n  double r1 = ( r/(2.0*(s-a)) )*( s - r - (IB + IC - IA));\n  double r2 = ( r/(2.0*(s-b)) )*( s - r - (IC + IA - IB));\n  double r3 = ( r/(2.0*(s-c)) )*( s - r - (IA + IB - IC));\n\n  cout << setiosflags(ios::fixed) << setprecision(6) << r1 << \" \" << r2 << \" \" << r3 << endl;\n\n  vector<Point> vec(3);\n  \n  Segment seg1 = Segment(C,A);\n  Segment seg2 = Segment(A,B);\n  seg1 = slideSeg(seg1,r1);\n  seg2 = slideSeg(seg2,r1);\n  vec[0] = getCrossPointLines(seg1,seg2);\n\n\n  seg1 = Segment(A,B);\n  seg2 = Segment(B,C);\n  seg1 = slideSeg(seg1,r2);\n  seg2 = slideSeg(seg2,r2);\n  vec[1] = getCrossPointLines(seg1,seg2);\n\n  seg1 = Segment(B,C);\n  seg2 = Segment(C,A);\n  seg1 = slideSeg(seg1,r3);\n  seg2 = slideSeg(seg2,r3);\n  vec[2] = getCrossPointLines(seg1,seg2);\n\n\n\n\n  return vec;\n}\n\nvoid printP(Point p)\n{\n  cout << setiosflags(ios::fixed) << setprecision(6) << \"(\" << p.x << \",\" << p.y << \")\" << endl;\n}\n\nint main()\n{\n  while(true)\n    {\n      Point A,B,C;\n      cin >> A.x >> A.y >> B.x >> B.y >> C.x >> C.y;\n      if(A.x+A.y+B.x+B.y+C.x+C.y == 0)break;\n      vector<Point> points = getMalfattieCircles(A,B,C);\n      //printP(points[0]);\n      //printP(points[1]);\n      //printP(points[2]);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#define POINT_A 1\n#define POINT_B 2\n#define POINT_C 3\n#define EPS 1.0e-6\nusing namespace std;\ntypedef long double elem;\ntypedef complex<elem> point, vec;\nbool eq(elem a, elem b){return abs(a - b)<EPS; } \nvec normv(const vec &v){return v/abs(v);}\nelem dist(const point &a, const point &b){return abs(a-b); }\nelem dot(const vec &a, const vec &b){return a.real()*b.real()+a.imag()*b.imag();}\nelem AreaOfTriangle(elem a, elem b, elem c){ elem s = (a+b+c)/2; return sqrt(s)*sqrt(s-a)*sqrt(s-b)*sqrt(s-c); }\nelem InradiusOfTriangle(elem a, elem b, elem c){ return AreaOfTriangle(a,b,c) / (a+b+c); }\nelem InradiusOfTriangleByMalfatti(elem r1, elem r2, elem r3){ return ( 2 * sqrt(r1*r2*r3) ) / ( sqrt(r1)+sqrt(r2)+sqrt(r3) - sqrt(r1+r2+r3) ); }\nelem QueryR(point A, point B, point C, elem ka, elem Ra, int query){\n\tvec v1,v2,px,X,e;\n\tpoint p;\n\t\n\tX = ka * ( normv( normv(B-A) + normv(C-A) ) ) + A;\n\tif( query == POINT_B ){ v1 = A-B; v2 = C-B; p = B;\n\t}else if(  query == POINT_C ){ v1 = A-C; v2 = B-C; p = C; }\n\tpx = X - p;\n\te = normv( normv(v1) + normv(v2) );\n\n\t//cout << \"E: \" << e << \" X: \" << X << endl;\n\n\telem sinH = sin( acos( dot(v1,v2) / (abs(v1)*abs(v2)) ) / 2 );\n\telem a = 1 - ( 1 / pow(sinH,2) );\n\telem b = Ra + dot(px,e)/sinH;\n\telem c = pow(Ra,2)-pow(abs(px),2);\n\n\telem candR1 = ( -b + sqrt( pow(b,2) - a*c ) ) / a;\n\telem candR2 = ( -b - sqrt( pow(b,2) - a*c ) ) / a;\n\n\t//cout << \"POINT \" << p << \"CAND R1: \" << candR1 << \" CAND R2: \" << candR2 << endl;\n\n\tif( candR1 * candR2 < 0 )\n\t\treturn max( candR1, candR2 );\n\telse\n\t\treturn min( candR1, candR2 );\n}\nint main(){\n\twhile(true){\n\t\tpoint A,B,C;\t\t\t\t// ¸_\n\t\telem a,b,c;\t\t\t\t\t// ÎÓÌå«³\n\t\telem sinAh, sinBh, sinCh;\t// sin(A/2)ÈÇ\n\t\telem ka,kb,kc;\n\t\telem Ra, Rb, Rc;\n\n\t\telem xa,ya,xb,yb,xc,yc;\n\t\tscanf(\"%Lf%Lf%Lf%Lf%Lf%Lf\",&xa,&ya,&xb,&yb,&xc,&yc);\n\t\tif(xa==0.0&&ya==0.0&&xb==0.0&&yb==0.0&&xc==0.0&&yc==0.0)break;\n\n\t\tA=complex<elem>(xa,ya);B=complex<elem>(xb,yb);C=complex<elem>(xc,yc);\n\t\ta = abs( B-C ); b = abs( C-A ); c = abs( B-A );\n\t\tvec v1,v2;\n\t\tv1 = B - A; v2 = C - A; sinAh=sin( acos( dot(v1,v2) / (abs(v1)*abs(v2)) ) / 2 );\n\t\tv1 = A - B; v2 = C - B; sinBh=sin( acos( dot(v1,v2) / (abs(v1)*abs(v2)) ) / 2 );\n\t\tv1 = A - C; v2 = B - C; sinCh=sin( acos( dot(v1,v2) / (abs(v1)*abs(v2)) ) / 2 );\n\n\t\t/* binary serach */\n\t\tRa = Rb = Rc = 0.0;\n\t\telem l = 0;\n\t\telem r = 2 * abs( ((c/(b+c))*(C-B) + B) - A );\n\t\twhile( r > l + EPS )\n\t\t{\n\t\t\telem m = (l+r)/2;\n\t\t\t//printf(\"L=%Lf M=%Lf R=%Lf Ra=%Lf Rb=%Lf Rc=%Lf\\n\", l,m,r,Ra,Rb,Rc);\n\t\t\tka = m;\n\t\t\tRa = sinAh * ka;\n\t\t\tRb = QueryR(A,B,C,ka,Ra,POINT_B);\n\t\t\tRc = QueryR(A,B,C,ka,Ra,POINT_C);\n\t\t\tkb = Rb / sinBh;\n\t\t\tkc = Rc / sinCh;\n\t\t\tvec BY = kb * normv( normv(A-B) + normv(C-B) );\n\t\t\tvec CZ = kc * normv( normv(A-C) + normv(B-C) );\n\t\t\telem d = dist( B + BY, C + CZ );\n\t\t\tif( eq(d-(Rb+Rc),0.0) )\n\t\t\t\tbreak;\n\t\t\telse if( d > Rb + Rc ){\n\t\t\t\tr = m;\n\t\t\t}else{\n\t\t\t\tl = m;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.5Lf %.5Lf %.5Lf\\n\", Ra, Rb, Rc);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef pair<ll, ll> Pll;\n\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)(c).size())\n#define ten(x) ((int)1e##x)\n#define tenll(x) ((ll)1e##x)\n\n\nconst double EPS(1e-8);\nconst double PI = acos(-1.0);\n\n#pragma region 基本要素(struct,typedef)\n\ntypedef double T;\n\nstruct P {\n\tT x, y;\n\tP() : x(0), y(0) {}\n\tP(const T& x, const T& y) : x(x), y(y) {}\n\tP operator+(const P &a)const { return P(x + a.x, y + a.y); }\n\tP& operator+=(const P &a) { x += a.x; y += a.y; return *this; }\n\tP operator-(const P &a)const { return P(x - a.x, y - a.y); }\n\tP& operator-=(const P &a) { x -= a.x; y -= a.y; return *this; }\n\tP operator*(const T a)const { return P(a*x, a*y); }\n\tP& operator*=(const T a) { x *= a; y *= a; return *this; }\n\tP operator/(const T a)const { return P(x / a, y / a); }\n\tP& operator/=(const T a) { x /= a; y /= a; return *this; }\n\n\t//比較用\n\tbool operator<(const P &a)const { return (x != a.x) ? (x < a.x) : (y < a.y); }\n\n};\n\nstruct S {\n\tP a, b;\n\tS() {}\n\tS(const P& a, const P& b) : a(a), b(b) {}\n};\n\nstruct L {\n\tP a, b;\n\tL() {}\n\tL(const P& a, const P& b) : a(a), b(b) {}\n};\n\nstruct C {\n\tP c;\n\tT r;\n\tC() {}\n\tC(const P &c, T& r) : c(c), r(r) {}\n};\n\n#pragma endregion \n\n#pragma region 基本要素(関数)\n\nT SQ(T x) { return x*x; }\nT dist2(const P &a, const P &b) { return SQ(a.x - b.x) + SQ(a.y - b.y); }\nT abs2(const P& p) { return SQ(p.x) + SQ(p.y); }\ndouble abs(const P& p) { return sqrt(abs2(p)); }\nT dot(const P& a, const P& b) { return a.x*b.x + a.y*b.y; }\nT cross(const P& a, const P& b) { return a.x*b.y - a.y*b.x; }\nP rot(const P& a, const double theta) {\n\treturn P(a.x*cos(theta) - a.y*sin(theta),a.x*sin(theta) + a.y*cos(theta));\n}\ndouble arg(const P &a) { double t = atan2(a.y, a.x); return t<0 ? t + 2 * PI : t; }\n\nenum { CCW = 1, CW = -1, ON = 0 };\nint ccw(const P &a, P b, P c) {\n\tb -= a; c -= a;\n\tdouble rdir = cross(b, c);\n\tdouble len = abs(b) * abs(c); //誤差対策 (速度がやばい時は外すか、二乗に置き換える)\n\tif (rdir> EPS * len) return CCW; //cがabより上(反時計周り)\n\tif (rdir<-EPS * len) return CW; // cがabより下(時計周り)\n\treturn ON; // a,b,cが一直線上\n}\n\n#pragma endregion\n\n#pragma region 入出力\n\nstd::ostream& operator<<(std::ostream& os, const P& point) { return (os << '(' << point.x << ',' << point.y << ')'); }\nstd::ostream& operator<<(std::ostream& os, const S& seg) { return (os << '{' << seg.a << ',' << seg.b << '}'); }\nstd::istream& operator>>(std::istream& is, P& point) { return (is >> point.x >> point.y); }\n\n#pragma endregion\n\n//交点が存在するかどうか\nbool intersected(const S &S1, const S &S2) {\n\tif (max(S1.a.x, S1.b.x) + EPS<min(S2.a.x, S2.b.x)\n\t\t|| max(S1.a.y, S1.b.y) + EPS<min(S2.a.y, S2.b.y)\n\t\t|| max(S2.a.x, S2.b.x) + EPS<min(S1.a.x, S1.b.x)\n\t\t|| max(S2.a.y, S2.b.y) + EPS<min(S1.a.y, S1.b.y)) return false;\n\treturn ccw(S1.a, S1.b, S2.a)*ccw(S1.a, S1.b, S2.b) <= 0\n\t\t&& ccw(S2.a, S2.b, S1.a)*ccw(S2.a, S2.b, S1.b) <= 0;\n}\n\n#pragma region 距離\n\n//線分と点の距離(2乗)\ndouble dist2(const S &S, const P &p) {\n\tif (dot(S.b - S.a, p - S.a) <= 0) return dist2(p, S.a);\n\tif (dot(S.a - S.b, p - S.b) <= 0) return dist2(p, S.b);\n\treturn (double)SQ(cross(S.b - S.a, p - S.a)) / dist2(S.a, S.b);\n}\n\n//線分と点の距離\ndouble dist(const S &S, const P &p) { return sqrt(dist2(S, p)); }\n\n//線分と線分の距離\ndouble dist(const S &S1, const S &S2) {\n\tif (intersected(S1, S2)) return 0;\n\treturn sqrt(min(min(dist2(S1, S2.a), dist2(S1, S2.b)),\n\t\tmin(dist2(S2, S1.a), dist2(S2, S1.b))));\n}\n\n//直線と点の距離\ndouble dist(const L &L, const P &p) {\n\treturn sqrt((double)SQ(cross(L.b - L.a, p - L.a)) / dist2(L.a, L.b));\n}\n\n//a -- bの間の円が入った時の、a - b間の距離\n//円の間に\ndouble geodist(P a, P b, const C &c) {\n\tdouble r = c.r;\n\tS s(a, b);\n\tif (dist(s, c.c)>r)\n\t\treturn abs(a - b);\n\n\ta -= c.c;\n\tb -= c.c;\n\n\tdouble L1 = abs(a);\n\tdouble t1 = arg(a) + acos(r / L1); if (t1<0) t1 += 2 * PI;\n\tdouble t2 = arg(a) - acos(r / L1); if (t2<0) t2 += 2 * PI;\n\n\tdouble L2 = abs(b);\n\tdouble t3 = arg(b) + acos(r / L2); if (t3<0) t3 += 2 * PI;\n\tdouble t4 = arg(b) - acos(r / L2); if (t4<0) t4 += 2 * PI;\n\n\tdouble theta = 2 * PI;\n\ttheta = min(theta, min(abs(t1 - t4), 2 * PI - abs(t1 - t4)));\n\ttheta = min(theta, min(abs(t2 - t3), 2 * PI - abs(t2 - t3)));\n\treturn sqrt(L1*L1 - r*r) + sqrt(L2*L2 - r*r) + r*theta;\n}\n\n#pragma endregion\n\n#pragma region 面積\n\n//多角形の面積\ndouble area(const vector<P>& v) {\n\tdouble ans = 0;\n\tfor (int i = 2; i < (int)v.size(); i++) {\n\t\tans += cross(v[i - 1] - v[0], v[i] - v[0]);\n\t}\n\treturn abs(ans) / 2;\n}\n\n//三角形の面積\ndouble area(const P &a, const P &b, const P &c) {\n\treturn abs(cross(b - a, c - a)) / 2;\n}\n\n#pragma endregion\n\n#pragma region 包含\n\n//凸包\nvector<P> convex_hull(vector<P>& ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<P> ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\n\tch.resize(k - 1);\n\n\treturn ch;\n}\n\n//線分の内包判定\n//1. AB の 両方の点が多角形に内包されている\n//2. ABと多角形の交点がない\n\n//凸でない多角形に頂点が含まれるかどうか\nenum { POLY_OUT = -1, POLY_ON = 0, POLY_IN = 1 };\nint contains(vector<P>& poly, const P& p) {\n\tbool in = false;\n\tFOR(i, sz(poly)) {\n\t\tP a = poly[i] - p, b = poly[(i + 1) % sz(poly)] - p;\n\t\tif (a.y > b.y) swap(a, b);\n\t\tif (a.y <= 0 && 0 < b.y)\n\t\t\tif (cross(a, b) < 0) in = !in;\n\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return POLY_ON;\n\t}\n\treturn in ? POLY_IN : POLY_OUT;\n}\n\n//三角形abcにpが含まれているかどうか(線上の場合も含む)\nbool cover(const P& a, const P& b, const P& c, const P& p) {\n\treturn area(a, b, c) + EPS >= area(a, b, p) + area(a, c, p) + area(b, c, p);\n}\n\n#pragma endregion\n\n#pragma region 交点\n\n//円同士の交点\nint intersect(const C &C1, const C &C2, P* p = NULL, P *q = NULL) {\n\tdouble r1 = C1.r, r2 = C2.r;\n\tP p1 = C1.c, p2 = C2.c;\n\n\tdouble d = abs(p1 - p2);\n\tif (d<EPS && abs(r1 - r2)<EPS) { // C1==C2\n\t\treturn -1;\n\t} else if (r1 + r2<d - EPS || d + EPS<abs(r1 - r2)) {\n\t\treturn 0;\n\t} else {\n\t\tdouble a = (r1*r1 - r2*r2 + d*d) / (2 * d);\n\t\tdouble h = sqrt(max(r1*r1 - a*a, 0.0));\n\t\tP tmp1 = p1 + (p2 - p1)*a / d;\n\t\tP tmp2 = (p2 - p1)*h / d;\n\t\tif (abs(tmp2)<EPS) {\n\t\t\tif (p&&q) *p = *q = tmp1;\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (p&&q) {\n\t\t\t\t*p = P(tmp1.x - tmp2.y, tmp1.y + tmp2.x);\n\t\t\t\t*q = P(tmp1.x + tmp2.y, tmp1.y - tmp2.x);\n\t\t\t}\n\t\t\treturn 2;\n\t\t}\n\t}\n}\n\n// l : ax+by+c=0 に変換\ninline void calc_abc(const L &l, double &a, double &b, double &c) {\n\ta = l.a.y - l.b.y;\n\tb = l.b.x - l.a.x;\n\tc = l.a.x*l.b.y - l.b.x*l.a.y;\n}\n\n//PからLへの垂線の足\nP perp_foot(const P &p, const L &l) {\n\tdouble a, b, c;\n\tcalc_abc(l, a, b, c);\n\treturn p - P(a, b) * ((a*p.x + b*p.y + c) / (a*a + b*b));\n}\n\n//円と直線の交点\nint intersect(const C &c, const L &l, P *p = NULL, P *q = NULL) {\n\tP m = perp_foot(c.c, l);\n\tdouble d2 = abs2(c.c - m);\n\tif (c.r*c.r + EPS<d2)   return 0;\n\telse if (abs(c.r*c.r - d2)<EPS) {\n\t\tif (p&&q)    *p = *q = m;\n\t\treturn 1;\n\t} else {\n\t\tif (p&&q) {\n\t\t\tP v;\n\t\t\tdouble n0 = abs2(l.a - m), n1 = abs2(l.b - m);\n\t\t\tif (n0<n1)    v = l.b - m, n0 = n1;\n\t\t\telse        v = l.a - m;\n\t\t\tv *= sqrt((c.r*c.r - d2) / n0);\n\t\t\t*p = m + v, *q = m - v;\n\t\t}\n\t\treturn 2;\n\t}\n}\n\n//円と線分の交点\nint intersect(const C &c, const S &s, P *p = NULL, P *q = NULL) {\n\tP pp, qq;\n\tint n = intersect(c, L(s.a, s.b), &pp, &qq);\n\tif (n == 0)    return 0;\n\telse if (n == 1) {\n\t\tif (dot(pp - s.a, pp - s.b)<EPS) {\n\t\t\tif (p&&q)    *p = *q = pp;\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\tbool bp = (dot(pp - s.a, pp - s.b)<EPS);\n\t\tbool bq = (dot(qq - s.a, qq - s.b)<EPS);\n\t\tif (bp&&bq) {\n\t\t\tif (p&&q)    *p = pp, *q = qq;\n\t\t\treturn 2;\n\t\t}\n\t\tif (bp || bq) {\n\t\t\tif (p&&q)    *p = (bp ? pp : qq);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n}\n\n//直線の交点\nP intersect(const L &L1, const L &L2) {\n\tdouble a1 = cross(L1.b - L1.a, L2.b - L2.a);\n\tdouble a2 = cross(L1.b - L1.a, L1.b - L2.a);\n\tif (abs(a1)<EPS) return L1.a;\n\treturn L2.a + (L2.b - L2.a) * (a2 / a1);\n}\n\n//角ABC の二等分線,A + pはBC上の辺に存在する\nP bisect_angle(P A, P B, P C) {\n\tA -= B; C -= B;\n\tdouble alen = abs(A), clen = abs(C);\n\tP p = (A * clen + C * alen) / (alen + clen);\n\treturn p;\n}\n\n//三角形ABCにおいて、AからBCへの垂線の長さ\ndouble perp_len(P A, P B, P C) {\n\treturn 2 * area(A, B, C) / abs(B - C);\n}\n\n//三角形の内心\nP inner_center(P A, P B, P C) {\n\tP bis1 = bisect_angle(A, B, C);\n\tP bis2 = bisect_angle(B, A, C);\n\tL l1(B, B + bis1), l2(A, A + bis2);\n\treturn intersect(l1, l2);\n}\n\n#pragma endregion\n\n\nint main() {\n\tint x1, x2, x3, y1, y2, y3;\n\twhile (cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3) {\n\t\tif (!x1&&!x2&&!x3&&!y1&&!y2&&!y3) break;\n\t\tdouble A = hypot(x2 - x3, y2 - y3);\n\t\tdouble B = hypot(x3 - x1, y3 - y1);\n\t\tdouble C = hypot(x1 - x2, y1 - y2);\n\t\tdouble a1 = acos((B*B + C*C - A*A) / (2 * B*C)) / 2;\n\t\tdouble a2 = acos((C*C + A*A - B*B) / (2 * C*A)) / 2;\n\t\tdouble a3 = acos((A*A + B*B - C*C) / (2 * A*B)) / 2;\n\t\tdouble cotA = cos(a1) / sin(a1);\n\t\tdouble cotB = cos(a2) / sin(a2);\n\t\tdouble cotC = cos(a3) / sin(a3);\n\n\t\tdouble s = (A + B + C) / 2;\n\t\tdouble S = sqrt(s*(s - A)*(s - B)*(s - C));\n\t\tdouble r1, r2, r3;\n\t\tdouble l = 0, r = S / (A+B+C) * 2;\n\t\tFOR(_, 50) {\n\t\t\tr1 = (l + r) / 2;\n\t\t\tdouble p = r1 * cotA;\n\t\t\tr2 = (-sqrt(r1) + sqrt(r1 - cotB * (p - C))) / cotB;\n\t\t\tr2 *= r2;\n\t\t\tr3 = (-sqrt(r1) + sqrt(r1 - cotC * (p - B))) / cotC;\n\t\t\tr3 *= r3;\n\t\t\tdouble cur_A = r2*cotB + r3*cotC + 2 * sqrt(r2*r3);\n\t\t\tif (cur_A < A) r = r1;\n\t\t\telse l = r1;\n\t\t}\n\t\tprintf(\"%.10f %.10f %.10f\\n\", r1, r2, r3);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <complex>\n\nusing namespace std;\ntypedef long long ll;\ntypedef complex<double> Point;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\ninline double sq(double x) { return x * x; }\n\nPoint p[3];\nPoint vect[3];\ndouble len[3];\ndouble l[3];\ndouble sins[3];\nPoint inner;\n\nbool inbox(Point p, Point q, Point r) {\n  if (p.real() > q.real()) {\n    swap(p.real(), q.real());\n  }\n  if (p.imag() > q.imag()) {\n    swap(p.imag(), q.imag());\n  }\n  return p.real() <= r.real() && r.real() <= q.real() &&\n         p.imag() <= r.imag() && r.imag() <= q.imag();\n}\n\nPoint getPos(int index, double r) {\n  double d = r / sins[index];\n  return p[index] + vect[index] * d;\n}\n\npair<Point, double> bs(int index, Point center1, double r1) {\n  double left = 0.0;\n  double right = l[index] / 2;\n  REP(iter, 100) {\n    double mid = (left + right) / 2.0;\n    Point c = getPos(index, mid);\n    if (!inbox(p[index], inner, c) || abs(c - center1) < r1 + mid) {\n      right = mid;\n    } else {\n      left = mid;\n    }\n  }\n  return make_pair(getPos(index, left), left);\n}\n\nint main() {\n  int x1, x2, x3, y1, y2, y3;\n  while (scanf(\"%d %d %d %d %d %d\", &x1, &y1, &x2, &y2, &x3, &y3), x1|y1|x2|y2|x3|y3) {\n    p[0] = Point(x1, y1);\n    p[1] = Point(x2, y2);\n    p[2] = Point(x3, y3);\n    REP(i, 3) {\n      int prev = (i + 1) % 3;\n      int next = (i + 2) % 3;\n      len[i] = abs(p[prev] - p[next]);\n    }\n    inner = (len[0] * p[0] + len[1] * p[1] + len[2] * p[2]) / (len[0] + len[1] + len[2]);\n    REP(i, 3) {\n      vect[i] = inner - p[i];\n      l[i] = abs(vect[i]);\n      vect[i] /= abs(vect[i]);\n    }\n    REP(i, 3) {\n      int prev = (i + 1) % 3;\n      int next = (i + 2) % 3;\n      double c = (sq(l[i]) + sq(len[prev]) - sq(l[next])) / (2 * l[i] * len[prev]);\n      sins[i] = sqrt(1 - c * c);\n    }\n    double left = 0.0;\n    double right = l[0] / 2;\n    REP(iter, 100) {\n      double mid = (left + right) / 2.0;\n      Point center1 = getPos(0, mid);\n      pair<Point, double> center2 = bs(1, center1, mid);\n      pair<Point, double> center3 = bs(2, center1, mid);\n      //cout << center1 << \" \" << center2.first << \" \" << center3.first << endl;\n      //cout << mid << \" \" << center2.second << \" \" << center3.second << endl;\n      //cout << abs(center1 - center2.first) << \" \" << mid + center2.second << endl;\n      //cout << abs(center2.first - center3.first) << \" \" << center2.second + center3.second << endl;\n      //cout << abs(center3.first - center1) << \" \" << center3.second + mid << endl;\n      if (inbox(p[0], inner, center1) && abs(center2.first - center3.first) < center2.second + center3.second) {\n        left = mid;\n      } else {\n        right = mid;\n      }\n      if (iter == 99) {\n        printf(\"%.6lf %.6lf %.6lf\\n\", mid, center2.second, center3.second);\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// 2009ツアツジツアツ地ツ凝ヲツ予ツ選 G : Malfatti Circles\n#include <fstream>\n#include <complex>\n#include <stdio.h>\n\nusing namespace std;\n\nconst double EPS = 1e-12;\n\ntypedef complex<double> P;\nstruct L{ P p, q; L(P p, P q) : p(p), q(q) {} };\n\ndouble cross(P a, P b) { return imag(conj(a)*b); }\n\ndouble lpDist(L l, P p){\n\treturn abs(cross(l.q-l.p,p-l.p))/abs(l.q-l.p);\n}\n\nP crossPoint(L l, L m){\n\tdouble A = cross(l.q-l.p, m.q-m.p);\n\tdouble B = cross(l.q-l.p, l.q-m.p);\n\treturn m.p + B/A*(m.q-m.p);\n}\n\nint main(){\n\tint x1, y1, x2, y2, x3, y3;\n\twhile(cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3){\n\t\tif(!(x1||y1||x2||y2||x3||y3)) break;\n\t\tP p1 = P(x1,y1), p2 = P(x2,y2), p3 = P(x3,y3);\n\t\tP dirA = (p2-p1)/abs(p2-p1)+(p3-p1)/abs(p3-p1);\n\t\tP dirB = (p1-p2)/abs(p1-p2)+(p3-p2)/abs(p3-p2);\n\t\tP c = crossPoint(L(p1,p1+dirA),L(p2,p2+dirB));\n\t\tdouble rA, rB, rC;\n\t\tdouble leftA = 0.0, rightA = 1.0, leftB, rightB, leftC, rightC;\n\t\twhile(true){\n\t\t\tdouble midA = (leftA+rightA)/2;\n\t\t\tP cA = p1 + (c-p1)*midA, cB, cC;\n\t\t\trA = lpDist(L(p1,p2), cA);\n\t\t\tleftB = 0.0, rightB = 1.0, leftC = 0.0, rightC = 1.0;\n\t\t\twhile(rightB-leftB>EPS){\n\t\t\t\tdouble midB = (leftB+rightB)/2;\n\t\t\t\tcB = p2 + (c-p2)*midB;\n\t\t\t\trB = lpDist(L(p2,p3), cB);\n\t\t\t\tif(rA+rB < abs(cB-cA)) leftB  = midB;\n\t\t\t\telse                   rightB = midB;\n\t\t\t}\n\t\t\twhile(rightC-leftC>EPS){\n\t\t\t\tdouble midC = (leftC+rightC)/2;\n\t\t\t\tcC = p3 + (c-p3)*midC;\n\t\t\t\trC = lpDist(L(p3,p1), cC);\n\t\t\t\tif(rA+rC < abs(cC-cA)) leftC  = midC;\n\t\t\t\telse                   rightC = midC;\n\t\t\t}\n\t\t\tif(rB+rC > abs(cB-cC)) leftA  = midA;\n\t\t\telse                   rightA = midA;\n\t\t\tif(rightA-leftA < EPS){\n\t\t\t\tprintf(\"%.5lf %.5lf %.5lf\\n\", rA, rB, rC);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cstdio>\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\n#define EPS 0.0000001\n\nPoint A, B, C;\n\nvoid getR(double alpha, double beta, double l, double r, double R, double &ans, bool &suc){\n    double a, b, c;\n    a = 1.0/((tan(beta)*tan(beta)));\n    b = 2*r/(tan(alpha)*tan(beta)) - 2*l/tan(beta) - 4*r;\n    c = l*l - 2*r*l/tan(alpha) + r*r/(tan(alpha)*tan(alpha));\n    double rr1 = (-b - sqrt(b*b-4*a*c))/(2*a);\n    double rr2 = (-b + sqrt(b*b-4*a*c))/(2*a);\n    suc = false;\n    if ( 0 <= rr1 && rr1 <= R ) { ans = rr1; suc = true;}\n    if ( 0 <= rr2 && rr2 <= R ) { ans = rr2; suc = true;}\n}\n\nvoid compute(){\n    double a = abs(B - C);\n    double b = abs(A - C);\n    double c = abs(A - B);\n    double s = (a + b + c)/2.0;\n    double R = sqrt(s*(s-a)*(s-b)*(s-c))/s;\n    double X = acos((c*c + b*b - a*a)/(2*c*b));\n    double Y = acos((c*c + a*a - b*b)/(2*c*a));\n    double Z = acos((a*a + b*b - c*c)/(2*a*b));\n\n    double l = 0, r = 2*R;\n    double r1, r2, r3;\n    bool suc1, suc2;\n    while(1){\n\tr1 = (l + r)/2.0;\n\t//\t\t\tcout << r1 << endl;\n\tgetR(X/2, Y/2, c, r1, R, r2, suc1);\n\tgetR(X/2, Z/2, b, r1, R, r3, suc2);\n\t//\tif ( !suc1 || !suc2 ) continue;\n\tVector v1 = A - B;\n\tVector v2 = A - C;\n\tv1 = polar(r2/sin(Y/2), arg(v1) - Y/2) + B; \n\tv2 = polar(r3/sin(Z/2), arg(v2) + Z/2) + C; \n\tdouble d = abs(v1 - v2);\n\tif ( fabs(d - (r2+r3)) < EPS ) break;\n\tif ( d < r2+r3 || !suc1 || !suc2) l = r1;\n\telse r = r1;\n    }\n    \n    printf(\"%.5lf %.5lf %.5lf\\n\", r1, r2, r3);\n}\n\nmain(){\n    while(1){\n\tcin >> A.real() >> A.imag();\n\tcin >> B.real() >> B.imag();\n\tcin >> C.real() >> C.imag();\n\tif ( A.real() == 0 && A.imag() == 0 && \n\t     B.real() == 0 && B.imag() == 0 && \n\t     C.real() == 0 && C.imag() == 0 ) break;\n\tcompute();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tVP p(3);\n\tfor (;;) {\n\t\trep(i, 3) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = { (double)x,(double)y };\n\t\t}\n\t\tif (p[0] == p[1])break;\n\t\tP up1 = (p[1] * abs(p[2] - p[0]) + p[2] * abs(p[1] - p[0])) / (abs(p[2] - p[0]) + abs(p[1] - p[0]));\n\t\tP dn1 = p[0];\n\t\tdouble r1,r2, r3;\n\t\trep(i, 50) {\n\t\t\tP m1 = (up1 + dn1) * 0.5l;\n\t\t\tr1 = dist_lp({ p[0],p[1] }, m1);\n\t\t\tP up2 = (p[0] * abs(p[2] - p[1]) + p[2] * abs(p[0] - p[1])) / (abs(p[2] - p[1]) + abs(p[0] - p[1]));\n\t\t\tP up3 = (p[0] * abs(p[2] - p[1]) + p[1] * abs(p[0] - p[2])) / (abs(p[2] - p[1]) + abs(p[0] - p[2]));\n\t\t\tP dn2 = p[1], dn3 = p[2];\n\t\t\trep(j, 50) {\n\t\t\t\tP m2 = (up2 + dn2)*0.5l, m3 = (up3 + dn3)*0.5l;\n\t\t\t\tr2 = dist_lp({ p[0],p[1] }, m2);\n\t\t\t\tr3 = dist_lp({ p[0],p[2] }, m3);\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[1],m2 }) && dist_lp({ p[0],p[2] }, m2) > r2 && abs(m1 - m2) > r1 + r2)dn2 = m2;\n\t\t\t\telse up2 = m2;\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[2],m3 }) && dist_lp({ p[0],p[1] }, m3) > r3 && abs(m3 - m1) > r1 + r3)dn3 = m3;\n\t\t\t\telse up3 = m3;\n\t\t\t}\n\t\t\tif (isis_ss({ p[1],up2 }, { p[2],up3 }) || abs(up2 - up3) < r2 + r3)dn1 = m1;\n\t\t\telse up1 = m1;\n\t\t}\n\t\tcout << fixed << setprecision(10) << r1 << \" \" << r2 << \" \" << r3 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst double pi = 3.141592653589;\nconst double pih = pi / 2;\n\ndouble dist2(double x1, double y1, double x2, double y2)\n{\n\tdouble dx = x2 - x1, dy = y2 - y1;\n\treturn dx * dx + dy * dy;\n}\n\ndouble theta(int x1, int y1, int x2, int y2, int x3, int y3)\n{\n\tdouble a2 = dist2(x1, y1, x2, y2);\n\tdouble b2 = dist2(x1, y1, x3, y3);\n\tdouble c2 = dist2(x2, y2, x3, y3);\n\tdouble ab = sqrt(a2 * b2);\n\n\treturn acos((a2 + b2 - c2) / (2 * ab));\n}\n\ndouble radius(double r1, int x1, int y1, int x2, int y2, int x3, int y3)\n{\n\tdouble th1 = theta(x1, y1, x2, y2, x3, y3);\n\tdouble th2 = theta(x2, y2, x1, y1, x3, y3);\n\tdouble len = sqrt(dist2(x1, y1, x2, y2));\n\n\tdouble lb = 0.1, ub = 2000;\n\n\tdouble rx1 = len - r1 * tan(pih - th1 / 2);\n\tdouble ry1 = r1;\n\n\tfor(int step = 0; step < 100; ++step) {\n\n\t\tdouble mid = (lb + ub) / 2;\n\n\t\tdouble rx2 = mid * tan(pih - th2 / 2);\n\t\tdouble ry2 = mid;\n\n\t\tif(rx1 < rx2 || dist2(rx1, ry1, rx2, ry2) < (r1 + mid) * (r1 + mid))\n\t\t\tub = mid;\n\t\telse\n\t\t\tlb = mid;\n\t}\n\n\treturn lb;\n}\n\nbool ok(double r1, int x1, int y1, int x2, int y2, int x3, int y3)\n{\n\tdouble r2 = radius(r1, x1, y1, x2, y2, x3, y3);\n\tdouble r3 = radius(r1, x1, y1, x3, y3, x2, y2);\n\tdouble r3d = radius(r2, x2, y2, x3, y3, x1, y1);\n\n\treturn r3d < r3;\n}\n\n\nint main()\n{\n\twhile(true) {\n\n\t\tint x1, x2, x3, y1, y2, y3;\n\n\t\tscanf(\"%d%d%d%d%d%d\", &x1, &y1, &x2, &y2, &x3, &y3);\n\t\tif(abs(x1) + abs(x2) + abs(x3) + abs(y1) + abs(y2) + abs(y3) == 0)\n\t\t\tbreak;\n\n\t\tdouble lb = 0.1, ub = 2000.0;\n\n\t\tfor(int step = 0; step < 100; ++step) {\n\n\t\t\tdouble mid = (lb + ub) / 2;\n\n\t\t\tif(ok(mid, x1, y1, x2, y2, x3, y3))\n\t\t\t\tlb = mid;\n\t\t\telse\n\t\t\t\tub = mid;\n\t\t}\n\n\t\tdouble r1 = lb;\n\t\tdouble r2 = radius(r1, x1, y1, x2, y2, x3, y3);\n\t\tdouble r3 = radius(r1, x1, y1, x3, y3, x2, y2);\n\n\t\tprintf(\"%.9lf %.9lf %.9lf\\n\", r1, r2, r3);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\nint ax,ay,bx,by,cx,cy;\nP A,B,C;\ndouble sinA,cosA,sinB,cosB,sinC,cosC;\n\ndouble funcC(double ra){\n  double L=0,R=10000,M;\n  for(int i=0;i<50;i++){\n    M=(L+R)/2.0;\n    if( M/sinC*cosC + ra/sinA*cosA + sqrt( 4.0*ra*M ) < abs(A-C) ) L=M;\n    else R=M;\n  }\n  return L;\n}\n\ndouble funcB(double ra){\n  double L=0,R=10000,M;\n  for(int i=0;i<50;i++){\n    M=(L+R)/2.0;\n    if( M/sinB*cosB + ra/sinA*cosA + sqrt( 4.0*ra*M ) < abs(A-B) ) L=M;\n    else R=M;\n  }\n  return L;\n}\n\nbool check(double ra){\n  double rb=funcB(ra);\n  double rc=funcC(ra);\n  if( rb/sinB*cosB + rc/sinC*cosC + sqrt( 4.0*rb*rc ) < abs(C-B) ){\n    return true;\n  }else{\n    return false;\n  }\n}\n\nvoid calc(P AB,P AC,double &Sin,double &Cos){\n  AB/=abs(AB);AC/=abs(AC);\n  AB=(AB+AC)*0.5;\n  Sin = abs(imag(AB*conj(AC)))/abs(AB);\n  Cos = real(AB*conj(AC))/abs(AB);\n}\n\nint main(){\n  while(1){\n    cin>>ax>>ay>>bx>>by>>cx>>cy;\n    if(ax==0&&ay==0&&bx==0&&by==0&&cx==0&&cy==0)break;\n    A=P(ax,ay),B=P(bx,by),C=P(cx,cy);\n    calc(B-A,C-A,sinA,cosA);\n    calc(A-B,C-B,sinB,cosB);\n    calc(A-C,B-C,sinC,cosC);\n    double L=0,R=10000,M;\n    for(int i=0;i<50;i++){\n      M=(L+R)/2.0;\n      if(check(M))R=M;\n      else L=M;\n    }\n    printf(\"%.10f %.10f %.10f\\n\",L,funcB(L),funcC(L));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst int nrep = 50;\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : VP{\n    L(const P& a, const P& b){ resize(2); at(0)=a; at(1)=b; }\n    L(){ resize(2); }\n};\nstruct C{\n    P p;\n    double r;\n    C(const P& p, const double& r) : p(p), r(r) {}\n    C(){}\n};\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\n\nP projection(const L& l, const P& p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n}\n\nint main(){\n\twhile(1){\n\t\tvector<int> input(6);\n\t\tbool allzero = true;\n\t\tfor(int i=0; i<6; i++){\n\t\t\tcin >> input[i];\n\t\t\tif(input[i]!=0) allzero = false;\n\t\t}\n\t\tif(allzero) break;\n\t\t\n\t\tVP v(3);\n\t\tfor(int i=0; i<3; i++){\n\t\t\tv[i] = P(input[2*i], input[2*i+1]);\n\t\t}\n\t\t\n\t\tVP bisection(3);\n\t\tfor(int i=0; i<3; i++){\n\t\t\tdouble a = abs(v[(i+1)%3] -v[i]), b = abs(v[(i+2)%3] -v[i]);\n\t\t\tbisection[i] = v[(i+1)%3] + (v[(i+2)%3]-v[(i+1)%3])* a/(a+b);\n\t\t}\n\t\t\n\t\tC c[3];\n\t\tP b = v[0], e = bisection[0];\n\t\tfor(int i=0; i<nrep; i++){\n\t\t\tP mid = 0.5*(b+e);\n\t\t\tc[0] = C(mid, distanceLP(L(v[0], v[1]), mid));\n\t\t\tif(distanceLP(L(v[1], v[2]), mid) < c[0].r +EPS){\n\t\t\t\te = mid;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=1; j<=2; j++){\n\t\t\t\tP b = v[j], e = bisection[j];\n\t\t\t\tfor(int k=0; k<nrep; k++){\n\t\t\t\t\tP mid = 0.5*(b+e);\n\t\t\t\t\tc[j] = C(mid, distanceLP(L(v[1], v[2]), mid));\n\t\t\t\t\tif(distanceLP(L(v[(j+1)%3], v[(j+2)%3]), mid) < c[j].r +EPS){\n\t\t\t\t\t\te = mid;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(abs(c[0].p -c[j].p) < c[0].r+c[j].r){\n\t\t\t\t\t\te = mid;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tb = mid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(abs(c[1].p -c[2].p) < c[1].r+c[2].r){\n\t\t\t\tb = mid;\n\t\t\t}else{\n\t\t\t\te = mid;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << fixed;\n\t\tcout << setprecision(10);\n\t\tcout << c[0].r << \" \" << c[1].r << \" \" << c[2].r << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define eq(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n#define le(a, b) (eq(a, b) || lt(a, b))\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\ndouble norm(Vector v) { return v.x*v.x + v.y*v.y; }\ndouble abs(Vector v) { return sqrt(norm(v)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nbool isOrthogonal(Vector a, Vector b) {\n  return eq(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isParallel(Vector a, Vector b) {\n  return eq(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1 - a2, b1 - b2);\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\ndouble getDistance(Point a, Point b) { return abs(a - b); }\ndouble getAngle(Point a, Point b, Point c) {\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\nVector getAngleBisectorVector(Point a, Point b, Point c) {\n  Vector v = a - b, w = c - b;\n  v = v / abs(v), w = w / abs(w);\n  Vector u = v + w;\n  return u / abs(u);\n}\n\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}\n};\ntypedef Segment Line;\n\nbool isOrthogonal(Segment s1, Segment s2) {\n  return eq(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Segment s1, Segment s2) {\n  return eq(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2.0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2) {\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPoint getCrossPointLL(Line l1, Line l2) {\n  Vector v1 = l1.p2 - l1.p1, v2 = l2.p2 - l2.p1;\n  double d = cross(v2, v1);\n  if(abs(d) < EPS) return l2.p1;\n  return l1.p1 + v1 * cross(v2, l2.p2 - l1.p1) * (1.0 / d);\n}\nLine getPerpendicularBisector(Point p1, Point p2) {\n  Point c = (p1 + p2) / 2.0;\n  Point q = Point(c.x + (p1.y - p2.y), c.y + (p2.x - p1.x));\n  return Line(c, q);\n}\nvector<Vector> getNormalLineVector(Line l) {\n  vector<Vector> vs;\n  Vector v = l.p2 - l.p1, p = v / abs(v);\n  vs.emplace_back(-p.y, p.x);\n  vs.emplace_back(p.y, p.x);\n  return vs;\n}\nvector<Line> getTranslation(Line l, double d) {\n  vector<Vector> nlv = getNormalLineVector(l);\n  vector<Line> nl;\n  nl.emplace_back(l.p1 + nlv[0]*d, l.p2 + nlv[0]*d);\n  nl.emplace_back(l.p1 + nlv[1]*d, l.p2 + nlv[1]*d);\n  return nl;\n}\n\nstruct Circle {\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0):c(c), r(r){}\n};\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n  // assert(intersect(c, l));\n  Vector pr = project(l, c.c);\n  Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n  double base = sqrt(c.r*c.r - norm(pr - c.c));\n  return make_pair(pr + e * base, pr - e * base);\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n  // assert(intersect(c1, c2));\n  double d = abs(c1.c - c2.c);\n  double a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2*c1.r*d));\n  double t = arg(c2.c - c1.c);\n  return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\ntypedef vector<Point> Polygon;\n\ndouble getArea(Polygon p) {\n  double ret = 0.0;\n  for(int i = 0; i < (int)p.size(); i++) {\n    ret += cross(p[i], p[(i+1)%p.size()]);\n  }\n  return abs(ret) / 2.0;\n}\n\n#define IN_POLYGON  2\n#define ON_POLYGON  1\n#define OUT_POLYGON 0\nint contains(Polygon g, Point p) {\n  int n = g.size();\n  bool x = false;\n  for(int i = 0; i < n; i++) {\n    Point a = g[i] - p, b = g[(i+1) % n] - p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON_POLYGON;\n    if(a.y > b.y) swap(a, b);\n    if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? IN_POLYGON : OUT_POLYGON);\n}\n\nPolygon convexHull(Polygon ps) {\n  int N = ps.size(), j = 0;\n  Polygon pg(N*2);\n\n  sort(ps.begin(), ps.end(), [](Point p1, Point p2) -> bool {\n      return p1.y != p2.y ? lt(p1.y, p2.y) : lt(p1.x, p2.x); });\n  for(int i = 0; i < N; i++, j++) {\n    while(j >= 2 && ccw(pg[j-2], pg[j-1], ps[i]) == -1) j--;\n    pg[j] = ps[i];\n  }\n  int k = j+1;\n  for(int i = N-2; i >= 0; i--, j++) {\n    while(j >= k && ccw(pg[j-2], pg[j-1], ps[i]) == -1) j--;\n    pg[j] = ps[i];\n  }\n  pg.resize(j-1);\n  return pg;\n}\n\nPolygon convexCut(Polygon s, Line l) {\n  Polygon t;\n  for(int i = 0; i < (int)s.size(); i++) {\n    Point a = s[i], b = s[(i+1)%s.size()];\n    if(ccw(l.p1, l.p2, a) != -1) t.push_back(a);\n    if(ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0) {\n      t.push_back(getCrossPointLL(Line(a, b), l));\n    }\n  }\n  return t;\n}\n\nbool mergeIfAble(Segment &s1, Segment s2) {\n  if(abs(cross(s1.p2 - s1.p1, s2.p2 - s2.p1)) > EPS) return false;\n  if(ccw(s1.p1, s2.p1, s1.p2) == COUNTER_CLOCKWISE ||\n     ccw(s1.p1, s2.p1, s1.p2) == CLOCKWISE) return false;\n  if(ccw(s1.p1, s1.p2, s2.p1) == ONLINE_FRONT ||\n     ccw(s2.p1, s2.p2, s1.p1) == ONLINE_FRONT) return false;\n  s1 = Segment(min(s1.p1, s2.p1), max(s1.p2, s2.p2));\n  return true;\n}\nvoid mergeSegments(vector<Segment>& segs) {\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].p2 < segs[i].p1) swap(segs[i].p1, segs[i].p2);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i+1; j < segs.size(); j++) {\n      if(mergeIfAble(segs[i], segs[j])) {\n\tsegs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nstruct edge {\n  int to;\n  double cost;\n  edge(){}\n  edge(int to, double cost):to(to), cost(cost){}\n\n  bool operator < (const edge& e) const {\n    return lt(cost, e.cost);\n  }\n};\ntypedef vector< vector<edge> > Graph;\n\nGraph segmentArrangement(vector<Segment>& segs, vector<Point>& ps) {\n  for(int i = 0; i < segs.size(); i++) {\n    ps.push_back(segs[i].p1);\n    ps.push_back(segs[i].p2);\n    for(int j = i+1; j < segs.size(); j++) {\n      if(intersect(segs[i], segs[j])) ps.push_back(getCrossPoint(segs[i], segs[j]));\n    }\n  }\n  sort(ps.begin(), ps.end());\n  ps.erase(unique(ps.begin(), ps.end()), ps.end());\n  Graph graph(ps.size());\n  for(int i = 0; i < segs.size(); i++) {\n    vector< pair<double, int> > ls;\n    for(int j = 0; j < ps.size(); j++) {\n      if(intersect(segs[i], ps[j])) {\n\tls.emplace_back(getDistanceSP(segs[i], ps[j]), j);\n      }\n    }\n    sort(ls.begin(), ls.end());\n    for(int j = 0; j+1 < ls.size(); j++) {\n      int u = ls[j].second, v = ls[j+1].second;\n      graph[u].emplace_back(v, getDistance(ps[u], ps[v]));\n      graph[v].emplace_back(u, getDistance(ps[u], ps[v]));\n    }\n  }\n  return graph;\n}\n\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  Point a, b, c;\n  while(1) {\n    cin >> a.x >> a.y >> b.x >> b.y >> c.x >> c.y;\n    if(!(a.x||a.y||b.x||b.y||c.x||c.y)) break;\n    // aub - angle A Unit Bisector\n    Vector aub = getAngleBisectorVector(c, a, b);\n    Vector bub = getAngleBisectorVector(a, b, c);\n    Vector cub = getAngleBisectorVector(b, c, a);\n    Point cab, cbb, ccb;\n    double ra, rb, rc;\n    double la = 0.0, ua = getDistanceSP(Segment(b, c), a);\n    for(int i = 0; i < 100; i++) {\n      double ma = (la + ua) / 2;\n      // cab - Center on angle A Bisector\n      cab = a + aub*ma;\n      ra = getDistanceSP(Segment(a, b), cab);\n\n      double lb = 0.0, ub = getDistanceSP(Segment(c, a), b);\n      for(int j = 0; j < 100; j++) {\n\tdouble mb = (lb + ub) / 2;\n\tcbb = b + bub*mb;\n\trb = getDistanceSP(Segment(b, c), cbb);\n\tif(le(ra + rb, getDistance(cab, cbb))) lb = mb;\n\telse ub = mb;\n      }\n\n      double lc = 0.0, uc = getDistanceSP(Segment(a, b), c);\n      for(int j = 0; j < 100; j++) {\n\tdouble mc = (lc + uc) / 2;\n\tccb = c + cub*mc;\n\trc = getDistanceSP(Segment(c, a), ccb);\n\tif(le(ra + rc, getDistance(cab, ccb))) lc = mc;\n\telse uc = mc;\n      }\n\n      if(le(rb + rc, getDistance(cbb, ccb))) ua = ma;\n      else la = ma;\n    }\n    cout << ra << \" \" << rb << \" \" << rc << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n    // üªª½sÈêÍdÈÁÄ¢È¢±ÆÉ·é\n    if(abs(cross(a2-a1,b2-b1)) < EPS){\n        return 0;\n    }\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,a)>0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n\n// @üxNgðßé\nP unitVector(P a){\n\treturn P(-a.imag(),a.real());\n}\n// PÊ@üxNgðßé\nP unitNormalVector(P a,P b){\n\tP tmp=(b-a);\n\tP e=P(-tmp.imag(),tmp.real());\n\te/=abs(e);\n\treturn e;\n}\n\nP ap,bp,cp;\nP acp,bcp,ccp;\ndouble ar,br,cr;\n\nP selDot(P &ab1_a,P &ab1_b,P &ab2_a,P &ab2_b,P &ac1_a,P &ac1_b,P& ac2_a,P &ac2_b){\n\tP inDot=P(-1,-1);\n\t// »ê¼êÌð_ðßAOp`ÌÉÜÜêéàÌðIÔ\n\tif(isInTriangle(ap,bp,cp,intersection_l(ab1_a,ab1_b,ac1_a,ac1_b)))\n\t\tinDot=intersection_l(ab1_a,ab1_b,ac1_a,ac1_b);\n\telse if(isInTriangle(ap,bp,cp,intersection_l(ab1_a,ab1_b,ac2_a,ac2_b)))\n\t\tinDot=intersection_l(ab1_a,ab1_b,ac2_a,ac2_b);\n\telse if(isInTriangle(ap,bp,cp,intersection_l(ab2_a,ab2_b,ac2_a,ac2_b)))\n\t\tinDot=intersection_l(ab2_a,ab2_b,ac2_a,ac2_b);\n\telse if(isInTriangle(ap,bp,cp,intersection_l(ab2_a,ab2_b,ac1_a,ac1_b)))\n\t\tinDot=intersection_l(ab2_a,ab2_b,ac1_a,ac1_b);\n\treturn inDot;\n}\n\n// ~bÆ~cÌÖWð`FbN\nbool checkB(double r){\n\tP ba1_a,ba1_b,ba2_a,ba2_b;\n\tP bc1_a,bc1_b,bc2_a,bc2_b;\n\n\tP e1=unitNormalVector(bp,ap);\n\tP e2=unitNormalVector(bp,cp);\n\n\tba1_a=e1*r+bp;\n\tba1_b=e1*r+ap;\n\tba2_a=-e1*r+bp;\n\tba2_b=-e1*r+ap;\n\tbc1_a=e2*r+bp;\n\tbc1_b=e2*r+cp;\n\tbc2_a=-e2*r+bp;\n\tbc2_b=-e2*r+cp;\n\tP inDot=selDot(ba1_a,ba1_b,ba2_a,ba2_b,bc1_a,bc1_b,bc2_a,bc2_b);\n\t// ðð½·ð_ª¶ÝµÈ¢\n\tif(EQ(inDot.real(),-1))return false;\n\tbcp=inDot;\n\tbr=r;\n\t// ~aªOp`ÌOÉÍÝoÄ¢½çA»Ì_Åfalse\n\tdouble d1=distance_l_p(ap,bp,bcp);\n\tdouble d2=distance_l_p(bp,cp,bcp);\n\tdouble d3=distance_l_p(cp,ap,bcp);\n\tif((!EQ(d1,br)&&d1<br)||(!EQ(d2,br)&&d2<br)||(!EQ(d3,br)&&d3<br))return false;\n\t//~aÆdÈé©`FbN\n\t// dÈéÈçfalse\n\tif(abs(acp-bcp)<br+ar)return false;\n\treturn true;\n}\nbool checkC(double r){\n\tP ca1_a,ca1_b,ca2_a,ca2_b;\n\tP cb1_a,cb1_b,cb2_a,cb2_b;\n\n\tP e1=unitNormalVector(cp,ap);\n\tP e2=unitNormalVector(cp,bp);\n\n\tca1_a=e1*r+cp;\n\tca1_b=e1*r+ap;\n\tca2_a=-e1*r+cp;\n\tca2_b=-e1*r+ap;\n\tcb1_a=e2*r+cp;\n\tcb1_b=e2*r+bp;\n\tcb2_a=-e2*r+cp;\n\tcb2_b=-e2*r+bp;\n\tP inDot=selDot(ca1_a,ca1_b,ca2_a,ca2_b,cb1_a,cb1_b,cb2_a,cb2_b);\n\t// ðð½·ð_ª¶ÝµÈ¢\n\tif(EQ(inDot.real(),-1))return false;\n\tccp=inDot;\n\tcr=r;\n\tdouble d1=distance_l_p(ap,bp,ccp);\n\tdouble d2=distance_l_p(bp,cp,ccp);\n\tdouble d3=distance_l_p(cp,ap,ccp);\n\tif((!EQ(d1,cr)&&d1<cr)||(!EQ(d2,cr)&&d2<cr)||(!EQ(d3,cr)&&d3<cr))return false;\n\t//~aÆdÈé©`FbN\n\t// dÈéÈçfalse\n\tif(abs(ccp-acp)<cr+ar)return false;\n\treturn true;\n}\n\n// _AÉß¢~ð¼arÅu¯é©`FbN\nbool check(double r){\n\tP ab1_a,ab1_b;\n\tP ab2_a,ab2_b;\n\n\tP ac1_a,ac1_b;\n\tP ac2_b,ac2_a;\n\n\tP e1=unitNormalVector(ap,bp);\n\tP e2=unitNormalVector(ap,cp);\n\n\tab1_a=e1*r+ap;\n\tab1_b=e1*r+bp;\n\tab2_a=-e1*r+ap;\n\tab2_b=-e1*r+bp;\n\tac1_a=e2*r+ap;\n\tac1_b=e2*r+cp;\n\tac2_a=-e2*r+ap;\n\tac2_b=-e2*r+cp;\n\n\tP inDot=selDot(ab1_a,ab1_b,ab2_a,ab2_b,ac1_a,ac1_b,ac2_a,ac2_b);\n\t// ðð½·ð_ª¶ÝµÈ¢\n\tif(EQ(inDot.real(),-1))\n\t\treturn false;\n\tacp=inDot;\n\tar=r;\n\t// ~aªOp`ÌOÉÍÝoÄ¢½çA»Ì_Åfalse\n\tdouble d1=distance_l_p(ap,bp,acp);\n\tdouble d2=distance_l_p(ap,cp,acp);\n\tdouble d3=distance_l_p(bp,cp,acp);\n\tif((!EQ(d1,ar)&&d1<ar)||(!EQ(d2,ar)&&d2<ar)||(!EQ(d3,ar)&&d3<ar))return false;\n\t// _BÉß¢~Ì¼aÆS_ðßé\n\tdouble ub=1000;\n\tdouble lb=0;\n\tint loop=50;\n\twhile(loop--){\n\t\tdouble mid=(ub+lb)/2;\n\t\tif(checkB(mid))lb=mid;\n\t\telse ub=mid;\n\t}\n\tbr=ub;\n\tub=1000;\n\tlb=0;\n\tloop=50;\n\twhile(loop--){\n\t\tdouble mid=(ub+lb)/2;\n\t\tif(checkC(mid))lb=mid;\n\t\telse ub=mid;\n\t}\n\tcr=ub;\n\t// àµbÆcÌ~ª­ÁÂ©È¢ÈçAfalse\n\tif(abs(bcp-ccp)>cr+br)return false;\n\treturn true;\n}\n\nint main(){\n\n\tint x1,x2,x3,y1,y2,y3;\n\twhile(cin>>x1>>y1>>x2>>y2>>x3>>y3&&!(x1==0&&y1==0&&x2==0&&y2==0&&x3==0&&y3==0)){\n\t\tap=P(x1,y1);\n\t\tbp=P(x2,y2);\n\t\tcp=P(x3,y3);\n\t\tdouble ub=1000;\n\t\tdouble lb=0;\n\t\tint loop=50;\n\t\tP acp;\n\t\twhile(loop--){\n\t\t\tdouble mid=(ub+lb)/2;\n\t\t\tif(check(mid))lb=mid;\n\t\t\telse ub=mid;\n\t\t}\n\t\tprintf(\"%.10f %.10f %.10f\\n\",ar,br,cr);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong double dist(long double x1, long double y1, long double x2, long double y2) {\n    return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n}\n\nint main() {\n    int x1, y1, x2, y2, x3, y3;\n    scanf(\"%d%d%d%d%d%d\", &x1, &y1, &x2, &y2, &x3, &y3);\n    while (x1 != 0 || y1 != 0 || x2 != 0 || y2 != 0 || x3 != 0 || y3 != 0) {\n        long double a = dist(x1, y1, x2, y2);\n        long double b = dist(x1, y1, x3, y3);\n        long double c = dist(x2, y2, x3, y3);\n        long double p = (a + b + c);\n        long double s = p/2;\n        long double area = sqrt(s * (s-a) * (s-b) * (s-c));\n        long double r = area/s;\n        long double ox = (x1*c + x2*b + x3*a)/p;\n        long double oy = (y1*c + y2*b + y3*a)/p;\n        // printf(\"a=%Lf, b=%Lf, c=%Lf\\n\", a, b, c);\n        // printf(\"area=%Lf, r=%Lf\\n\", area, r);\n        // printf(\"ox,oy = %Lf, %Lf\\n\", ox, oy);\n        long double d = dist(x3, y3, ox, oy);\n        long double e = dist(x2, y2, ox, oy);\n        long double f = dist(x1, y1, ox, oy);\n        // printf(\"d,e,f = %Lf, %Lf, %Lf\\n\", d, e, f);\n        long double r3 = r*(s+d-r-e-f)/(2*(s-a));\n        long double r2 = r*(s+e-r-d-f)/(2*(s-b));\n        long double r1 = r*(s+f-r-d-e)/(2*(s-c));\n        printf(\"%Lf %Lf %Lf\\n\", r1, r2, r3);\n        scanf(\"%d%d%d%d%d%d\", &x1, &y1, &x2, &y2, &x3, &y3);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define inf (1<<29)\n\nusing namespace std;\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n//必要に応じて\ndouble norm()\n{\nreturn x*x+y*y;\n}\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n\nbool pequals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad)\n{\n  return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y);\n}\n\n// 度をラジアンに変換\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\ndouble getArea(vector<Point>& vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\ndouble getDist(Point a,Point b)\n{\n  return sqrt(norm(a-b));\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nstruct P\n{\n\n};\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\n  return isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  assert(isIntersect(a1,a2,b1,b2));//交差していない　これを外してもある程度（またはしっかり？）はうごいてくれる\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n\n// Line Line 上と同じ assertなし\nPoint getCrossPointLines( Line s1, Line s2){\n    Point a = s1.p2 - s1.p1;\n    Point base = s2.p2 -s2.p1;\n    return s1.p1 + a * (cross(base, s2.p1 - s1.p1)/cross(base, a));\n}\n\n//三角形ABCの内接円半径を求める\ndouble getInradius(Point A,Point B,Point C)\n{\n  vector<Point> vec(3);\n  vec[0] = A, vec[1] = B, vec[2] = C;\n  double S = getArea(vec);\n  double a = getDist(B,C);\n  double b = getDist(A,C);\n  double c = getDist(A,B);\n  return 2.0*S/(a+b+c);\n}\n\n//segをrだけ平行にスライド\nSegment slideSeg(Segment seg,double r)\n{\n  Point p = (seg.p2-seg.p1)*r/abs(seg.p2-seg.p1);\n  p = rotate(p,toRad(90.0));\n  seg = Segment(seg.p1+p,seg.p2+p);\n  if(fabs(seg.p1.x) < EPS)seg.p1.x = 0;\n  if(fabs(seg.p1.y) < EPS)seg.p1.y = 0;\n  if(fabs(seg.p2.x) < EPS)seg.p2.x = 0;\n  if(fabs(seg.p2.y) < EPS)seg.p2.y = 0;\n  return seg;\n}\n\n//三角形ABCの内心を求める\nPoint getIncenter(Point A,Point B,Point C)\n{\n  double inradius = getInradius(A,B,C);\n\n  Segment seg1 = Segment(A,B);\n  Segment seg2 = Segment(B,C);\n  seg1 = slideSeg(seg1,inradius);\n  seg2 = slideSeg(seg2,inradius);\n  return getCrossPointLines(seg1,seg2);\n}\n\n\n//vector<Point> getMalfattieCircles(Point A,Point B,Point C)\nvoid getMalfattieCircles(Point A,Point B,Point C)\n{\n  Point I = getIncenter(A,B,C);\n  double r = getInradius(A,B,C);\n  double a = getDist(B,C);\n  double b = getDist(C,A);\n  double c = getDist(A,B);\n  double s = (a+b+c)/2.0;\n  double IA = getDist(I,A);\n  double IB = getDist(I,B);\n  double IC = getDist(I,C);\n  /*\n    r1,r2,r3はそれぞれ三角形内の円の半径\n    チェック済み\n   */\n  double r1 = ( r/(2.0*(s-a)) )*( s - r - (IB + IC - IA));\n  double r2 = ( r/(2.0*(s-b)) )*( s - r - (IC + IA - IB));\n  double r3 = ( r/(2.0*(s-c)) )*( s - r - (IA + IB - IC));\n\n  cout << setiosflags(ios::fixed) << setprecision(6) << r1 << \" \" << r2 << \" \" << r3 << endl;\n\n  /*\n    以下は未チェック（ちょっとだけチェック済み）\n    三角形内の３つの円の中心点\n  */\n  /*\n  vector<Point> vec(3);\n  \n  Segment seg1 = Segment(C,A);\n  Segment seg2 = Segment(A,B);\n  seg1 = slideSeg(seg1,r1);\n  seg2 = slideSeg(seg2,r1);\n  vec[0] = getCrossPointLines(seg1,seg2);\n  //cout << vec[0].x << \",\" << vec[0].y << endl;\n\n  seg1 = Segment(A,B);\n  seg2 = Segment(B,C);\n  seg1 = slideSeg(seg1,r2);\n  seg2 = slideSeg(seg2,r2);\n  vec[1] = getCrossPointLines(seg1,seg2);\n  //cout << vec[1].x << \",\" << vec[1].y << endl;\n\n  seg1 = Segment(B,C);\n  seg2 = Segment(C,A);\n  seg1 = slideSeg(seg1,r3);\n  seg2 = slideSeg(seg2,r3);\n  vec[2] = getCrossPointLines(seg1,seg2);\n  //cout << vec[2].x << \",\" << vec[2].y << endl;\n\n  return vec;\n  */\n}\n\nint main()\n{\n  while(true)\n    {\n      Point A,B,C;\n      cin >> A.x >> A.y >> B.x >> B.y >> C.x >> C.y;\n      if(A.x+A.y+B.x+B.y+C.x+C.y == 0)break;\n      getMalfattieCircles(A,B,C);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <iomanip>\n#include <cassert>\nusing namespace std;\n\ntypedef complex<double> P;\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define EPS 1e-7\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nP rotateP(P a, P b, double rad)\n{\n\tdouble x0=a.real(), x=b.real();\n\tdouble y0=a.imag(), y=b.imag();\n\tdouble xx=x0+(x-x0)*cos(rad)-(y-y0)*sin(rad);\n\tdouble yy=y0+(x-x0)*sin(rad)+(y-y0)*cos(rad);\n\t\n\treturn P(xx,yy);\n}\n\nP a[3], Cp[3];\ndouble Cr[3];\n\nbool putC(int n, L fl)\n{\n\tdouble rad=arg( (a[(n+2)%3]-a[n]) / (a[(n+1)%3]-a[n]) );\n\trad/=2.0;\n\t\n\tP d=rotateP(a[n], a[(n+1)%3], rad);\t\n\tP c = crosspoint(fl, L(a[n], d));\n\t\n\tif(a[n]==c) c=d;\n\t\n\tP hi=c, lo=a[n];\n\twhile(abs(hi-lo) > EPS)\n\t{\n\t\tP mi=(hi+lo)/2.0;\n\t\tdouble r=distanceSP(L(a[n], a[(n+1)%3]) , mi);\n\t\tif(abs(Cp[0]-mi) < r+Cr[0]) hi=mi;\n\t\telse lo=mi;\n\t}\n\t\n\tCr[n]=distanceSP(L(a[n], a[(n+1)%3]), hi);\n\tCp[n]=hi;\n\t\n\tif(n==2)\n\t{\n\t\tif(abs(Cp[2]-Cp[1]) > Cr[2]+Cr[1]) return false;\n\t\treturn true;\n\t}\n\t\n\treturn putC(n+1, fl);\n}\n\nint main()\n{\n\tcout << setiosflags(ios::fixed) << setprecision(8);\n\twhile(1)\n\t{\n\t\tbool e=true;\n\t\tREP(i,3)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\ta[i]=P(x,y);\n\t\t\t\n\t\t\tif(x||y) e=false;\n\t\t}\n\t\tif(e) break;\n\t\t\n\t\tdouble rad=arg( (a[2]-a[0]) / (a[1]-a[0]) );\n\t\trad/=2.0;\n\t\t\n\t\tP d=rotateP(a[0], a[1], rad);\n\t\tP c = crosspoint(L(a[1], a[2]), L(a[0], d));\n\t\t\n\t\tP hi=c, lo=a[0];\n\t\twhile(abs(hi-lo) > EPS)\n\t\t{\n\t\t\tP mi=(hi+lo)/2.0;\n\t\t\t\n\t\t\tCr[0]=distanceSP(L(a[0], a[1]), mi);\n\t\t\tCp[0]=mi;\n\t\t\t\n\t\t\tbool ret=putC(1, L(a[0], c));\n\t\t\t\n\t\t\tif(!ret) hi=mi;\n\t\t\telse lo=mi;\n\t\t}\n\t\tcout << Cr[0] << \" \" << Cr[1] << \" \" << Cr[2] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\n//  ?§?????????????????????????\nLine getBisectorOfAngle(Point base,Point a,Point b){\n  Vector v1=(a-base),v2=(b-base);\n  double s=acos(dot(v1,v2)/(abs(v1)*abs(v2)))*360/(4*pi);\n  return Line(base,rotate(base,a,s));\n  //return Line(base,rotate(base,a,180-s));\n}\n\n//  ????§???¢???????§?????????????????????????\nLine getBisectorOfAngleInTriangle(Point base,Point a,Point b){\n  Line L=getBisectorOfAngle(base,a,b);\n  Point p=getCrossPointLL(Line(a,b),L);\n  return Segment(base,p);\n}\n\nPoint p1,p2,p3;\nSegment s1,s2,s3;\nLine L1,L2,L3;\nvector<double> ans;\n\nbool check(Line L,Point A,double a,double dis){\n  Vector V=(L.p2-L.p1)/abs(L.p2-L.p1);\n  Point P=L.p1+V*dis;\n  double d=getDistanceLP(s3,P);\n  if(((a+d)-abs(A-P))<eps)return true;\n  return false;\n}\n\nbool in(Point P,double r){\n  if(getDistanceLP(s1,P)-r<-eps)return false;\n  if(getDistanceLP(s2,P)-r<-eps)return false;\n  if(getDistanceLP(s3,P)-r<-eps)return false;\n  return true;\n}\n\nbool ok(double dis){\n  Vector V=(L1.p2-L1.p1)/abs(L1.p2-L1.p1);\n  Point A=L1.p1+V*dis;\n  double a,b,c,l,r,m;\n  a=getDistanceLP(s1,A);\n\n  l=0;r=abs(L2.p1-L2.p2);\n  for(int i=0;i<100;i++){\n    m=(l+r)/2.0;\n    if(check(L2,A,a,m))l=m;\n    else r=m;\n  }\n  V=(L2.p2-L2.p1)/abs(L2.p2-L2.p1);\n  Point B=L2.p1+V*m;\n  b=getDistanceLP(s3,B);\n  if(!in(B,b))return false;\n\n  l=0;r=abs(L3.p1-L3.p2);\n  for(int i=0;i<100;i++){\n    m=(l+r)/2.0;\n    if(check(L3,A,a,m))l=m;\n    else r=m;\n  }\n  V=(L3.p2-L3.p1)/abs(L3.p2-L3.p1);\n  Point C=L3.p1+V*m;\n  c=getDistanceLP(s3,C);\n  if(!in(C,c))return false;\n\n  if(equals(c+b,abs(C-B))){\n    ans.push_back(a);\n    ans.push_back(b);\n    ans.push_back(c);\n  }\n  //printf(\"%.10f %.10f %.10f %.10f\\n\",a,b,c,abs(C-B));\n  if(((c+b)-abs(C-B))<-eps)return true;\n  return false;\n}\n\nint main()\n{\n  int a,b,c,d,e,f;\n  while(1){\n    cin>>a>>b>>c>>d>>e>>f;\n    if(a+b+c+d+e+f==0)break;\n    p1=Point(a,b);\n    p2=Point(c,d);\n    p3=Point(e,f);\n    s1=Segment(p1,p2);\n    s2=Segment(p1,p3);\n    s3=Segment(p2,p3);\n    L1=getBisectorOfAngleInTriangle(p1,p2,p3);\n    L2=getBisectorOfAngleInTriangle(p2,p3,p1);\n    L3=getBisectorOfAngleInTriangle(p3,p1,p2);\n    Point cp=getCrossPointLL(L1,L2);\n    L1.p2=cp;\n    L2.p2=cp;\n    L3.p2=cp;\n    ans.clear();\n\n    double l=0,r=abs(L1.p2-L1.p1);\n    for(int i=0;i<100;i++){\n      double m=(l+r)/2.0;\n      if(ok(m))r=m;\n      else l=m;\n      if(!ans.empty())break;\n    }\n\n    printf(\"%.10f %.10f %.10f\\n\",ans[0],ans[1],ans[2]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\nint main() {\n\n\tdouble x1, x2, x3;\n\tdouble y1, y2, y3;\n\tdouble a, b, c;\n\tdouble r1, r2, r3;\n\tdouble d,e,f;\n\tdouble r, s;\n\tdouble ix, iy;\n\n\tscanf(\"%lf %lf\", &x1, &y1);\n\tscanf(\"%lf %lf\", &x2, &y2);\n\tscanf(\"%lf %lf\", &x3, &y3);\n\n    while( x1 != 0 || x2 != 0 || x3 != 0 ||\n    \t   y1 != 0 || y2 != 0 || y3 != 0){\n\n    \t// from wikipedia: https://en.wikipedia.org/wiki/Malfatti_circles#Radius_formula\n    \tc = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n     \ta = sqrt((x2-x3)*(x2-x3) + (y2-y3)*(y2-y3));\n    \tb = sqrt((x3-x1)*(x3-x1) + (y3-y1)*(y3-y1));\n    \t// std::cout << a << \" \" << b << \" \" << c << std::endl;\n\n    \ts = (a+b+c) / 2;\n    \t// std::cout << s <<std::endl;\n\n    \t// formula for incenter of a triange\n    \t// http://mathworld.wolfram.com/Incenter.html\n    \tix = (a*x1 + b*x2 + c*x3) / (a+b+c);\n    \tiy = (a*y1 + b*y2 + c*y3) / (a+b+c);\n\n    \t// std::cout << ix << \" \" << iy << std::endl;\n    \td = sqrt((ix-x1)*(ix-x1) + (iy-y1)*(iy-y1));\n    \te = sqrt((ix-x2)*(ix-x2) + (iy-y2)*(iy-y2));\n    \tf = sqrt((ix-x3)*(ix-x3) + (iy-y3)*(iy-y3));\n\n    \t// std::cout << d << \" \" << e << \" \" << f << std::endl;\n\n    \tr=sqrt(s*(s-a)*(s-b)*(s-c))/s;\n\n    \tr1 = r*(s-r+d-e-f)/(2*(s-a));\n    \tr2 = r*(s-r-d+e-f)/(2*(s-b));\n    \tr3 = r*(s-r-d-e+f)/(2*(s-c));\n\n    \tprintf(\"%lf %lf %lf\\n\", r1, r2, r3);\n\t    \n\t\tscanf(\"%lf %lf\", &x1, &y1);\n\t\tscanf(\"%lf %lf\", &x2, &y2);\n\t\tscanf(\"%lf %lf\", &x3, &y3);\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntypedef complex<double> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tVP p(3);\n\tfor (;;) {\n\t\trep(i, 3) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = { (double)x,(double)y };\n\t\t}\n\t\tif (p[0] == p[1])break;\n\t\tP up1 = (p[1] * abs(p[2] - p[0]) + p[2] * abs(p[1] - p[0])) / (abs(p[2] - p[0]) + abs(p[1] - p[0]));\n\t\tP dn1 = p[0];\n\t\tdouble r1,r2, r3;\n\t\trep(i, 100) {\n\t\t\tP m1 = (up1 + dn1) * 0.5l;\n\t\t\tr1 = dist_lp({ p[0],p[1] }, m1);\n\t\t\tP up2 = (p[0] * abs(p[2] - p[1]) + p[2] * abs(p[0] - p[1])) / (abs(p[2] - p[1]) + abs(p[0] - p[1]));\n\t\t\tP up3 = (p[0] * abs(p[2] - p[1]) + p[1] * abs(p[0] - p[2])) / (abs(p[2] - p[1]) + abs(p[0] - p[2]));\n\t\t\tP dn2 = p[1], dn3 = p[2];\n\t\t\trep(j, 100) {\n\t\t\t\tP m2 = (up2 + dn2)*0.5l, m3 = (up3 + dn3)*0.5l;\n\t\t\t\tr2 = dist_lp({ p[0],p[1] }, m2);\n\t\t\t\tr3 = dist_lp({ p[0],p[2] }, m3);\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[1],m2 }) && dist_lp({ p[0],p[2] }, m2) > r2 && abs(m1 - m2) > r1 + r2)dn2 = m2;\n\t\t\t\telse up2 = m2;\n\t\t\t\tif (!isis_ss({ p[0],m1 }, { p[2],m3 }) && dist_lp({ p[0],p[1] }, m3) > r3 && abs(m3 - m1) > r1 + r3)dn3 = m3;\n\t\t\t\telse up3 = m3;\n\t\t\t}\n\t\t\tif (isis_ss({ p[1],up2 }, { p[2],up3 }) || abs(up2 - up3) < r2 + r3)dn1 = m1;\n\t\t\telse up1 = m1;\n\t\t}\n\t\tcout << fixed << setprecision(10) << r1 << \" \" << r2 << \" \" << r3 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<utility>\n#include<stack>\n#include<bitset>\n#include<numeric>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define stop char nyaa;cin>>nyaa;\nconst ll mod = 1000000007;\nconst long double eps = 1e-8;\ntypedef pair<int, int> P;\n\ntypedef long double ld;\n\n#include<complex>\ntypedef complex<ld> Point;\nconst ld pi = acos(-1.0);\nld dot(Point a, Point b) { return real(conj(a)*b); }\nld cross(Point a, Point b) { return imag(conj(a)*b); }\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\treturn lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();\n\t}\n}\nstruct Line {\n\tPoint a, b;\n};\nstruct Circle {\n\tPoint p; ld r;\n};\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps)return 1;//counter clockwise\n\tif (cross(b, c) < -eps)return -1;//clock wise\n\tif (dot(b, c) < 0)return 2;//c--a--b on line\n\tif (norm(b) < norm(c))return -2;//a--b--c on line\n\treturn 0; //a--c--b on line\n}\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\nbool isis_ss(Line s, Line t) {\n\treturn(cross(s.b - s.a, t.a - s.a)*cross(s.b - s.a, t.b - s.a) < -eps && cross(t.b - t.a, s.a - t.a)*cross(t.b - t.a, s.b - t.a) < -eps);\n}\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2 * d);\n\tld dfr = c1.r*c1.r - rc * rc;\n\tif (abs(dfr) < eps)dfr = 0.0;\n\tif (dfr < 0.0)return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0)res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + eps)return res;\n\tld len = (d > c.r) ? 0.0 : sqrt(c.r*c.r - d * d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(proj(l, c.p) + len * nor);\n\tres.push_back(proj(l, c.p) - len * nor);\n\treturn res;\n}\nvector<Point> is_sc(Circle c, Line s) {\n\tvector<Point> res, cop; cop = is_lc(c, s);\n\tint len = cop.size();\n\trep(k, len) {\n\t\tif (ccw(s.a, cop[k], s.b) == -2) {\n\t\t\tres.push_back(cop[k]);\n\t\t}\n\t}\n\treturn res;\n}\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(p - r) : min(abs(p - s.a), abs(p - s.b));\n}\n\nPoint p[3];\nld dist(int i, int j) {\n\tld dx = real(p[j]) - real(p[i]), dy = imag(p[j]) - imag(p[i]);\n\treturn sqrt(dx*dx + dy * dy);\n}\nld calc_cos(ld d1, ld d2, ld d3) {\n\treturn (d1*d1 + d2 * d2 - d3 * d3) / (2 * d1*d2);\n}\n\n\nvoid solve() {\n\tld thec[3];\n\tthec[0] = calc_cos(dist(0, 1), dist(0, 2), dist(1, 2));\n\tthec[1] = calc_cos(dist(1, 0), dist(1, 2), dist(0, 2));\n\tthec[2] = calc_cos(dist(2, 1), dist(0, 2), dist(1, 0));\n\trep(i, 3) {\n\t\tthec[i] = acos(thec[i]);\n\t}\n\tPoint d[3];\n\trep(i, 3) {\n\t\tint j = (i + 1) % 3, k = (i + 2) % 3;\n\t\tPoint l = p[j] - p[i], r = p[k] - p[i];\n\t\tl = l / abs(l); r = r / abs(r);\n\t\tPoint mid = l + r;\n\t\tmid = mid / abs(mid);\n\t\td[i] = mid;\n\t}\n\tCircle c1, c2, c3;\n\tld le = 0, ri = 3000;\n\trep(aa, 50) {\n\t\tld mid = (le + ri)/2.0;\n\t\tc1.p = p[0] + mid * d[0];\n\t\tc1.r = mid * sin(thec[0] / 2.0);\n\t\tif (isis_ss({ p[1],p[2] }, { p[0],c1.p })) {\n\t\t\tri = mid; continue;\n\t\t}\n\t\tif (dist_sp({ p[1],p[2] }, c1.p)<c1.r) {\n\t\t\tri = mid; continue;\n\t\t}\n\t\t//cout << \"hello\" << endl;\n\t\tbool f = false;\n\t\tld cle = 0, cri = 3000;\n\t\trep(bb, 50) {\n\t\t\tld cmid = (cle + cri) / 2.0;\n\t\t\tc2.p = p[1] + cmid * d[1];\n\t\t\tc2.r = cmid * sin(thec[1] / 2.0);\n\t\t\tf = true;\n\t\t\tif (isis_ss({ p[0],p[2] }, { p[1],c2.p })) {\n\t\t\t\tcri = cmid; continue;\n\t\t\t}\n\t\t\tif (dist_sp({ p[0],p[2] }, c2.p) < c2.r) {\n\t\t\t\tcri = cmid; continue;\n\t\t\t}\n\t\t\tf = false;\n\t\t\tif (is_cc(c1, c2).size() > 0) {\n\t\t\t\tcri = cmid;\n\t\t\t}\n\t\t\telse cle = cmid;\n\t\t}\n\t\tif (f) {\n\t\t\tle = mid; continue;\n\t\t}\n\t\tf = false;\n\t\tcle = 0, cri = 3000;\n\t\trep(bb, 50) {\n\t\t\tld cmid = (cle + cri) / 2.0;\n\t\t\tc3.p = p[2] + cmid * d[2];\n\t\t\tc3.r = cmid * sin(thec[2] / 2.0); \n\t\t\tf = true;\n\t\t\tif (isis_ss({ p[0],p[1] }, { p[2],c3.p })) {\n\t\t\t\tcri = cmid; continue;\n\t\t\t}\n\t\t\tif (dist_sp({ p[1],p[0] }, c3.p)<c3.r) {\n\t\t\t\tcri = cmid; continue;\n\t\t\t}\n\t\t\tf = false;\n\t\t\tif (is_cc(c1, c3).size() > 0) {\n\t\t\t\tcri = cmid;\n\t\t\t}\n\t\t\telse cle = cmid;\n\t\t}\n\t\tif (f) {\n\t\t\tle = mid; continue;\n\t\t}\n\t\t//cout << c1.r<<\" \"<<c2.r << \" \" << c3.r << endl;\n\t\tif (is_cc(c2, c3).size() > 0) {\n\t\t\tle = mid;\n\t\t}\n\t\telse {\n\t\t\tri = mid;\n\t\t}\n\t}\n\tcout << c1.r << \" \" << c2.r << \" \" << c3.r << endl;\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(10);\n\twhile (true) {\n\t\tbool f = true;\n\t\trep(i, 3) {\n\t\t\tld x, y; cin >> x >> y;\n\t\t\tp[i] = { x,y };\n\t\t\tif (x || y)f = false;\n\t\t}\n\t\tif (f)break;\n\t\tsolve();\n\t}\n\t//stop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// File Name: G.cpp\n// Author: YangYue\n// Created Time: Thu Oct 10 13:54:01 2013\n//headers \n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef pair<double,double> PDD;\ntypedef pair<LL, LL>PLL;\ntypedef pair<LL,int>PLI;\n\n#define lch(n) ((n<<1))\n#define rch(n) ((n<<1)+1)\n#define lowbit(i) (i&-i)\n#define sqr(x) ((x)*(x))\n#define fi first\n#define se second\n#define MP make_pair\n#define PB push_back\n\nconst int MaxN = 200005;\nconst double eps = 1e-8;\nconst double DINF = 1e100;\nconst int INF = 1000000006;\nconst LL LINF = 1000000000000000005ll;\n\nint dcmp(double x) { return x < -eps ? -1 : x > eps; }\nstruct Point {\n\tdouble x, y;\n\tPoint (){}\n\tPoint(double x, double y) : x(x), y(y) {}\n\tPoint operator - (const Point &b) { return Point(x - b.x, y - b.y); }\n\tPoint operator + (const Point &b) { return Point(x + b.x, y + b.y); }\n\tPoint operator * (const double &b) { return Point(x * b, y * b); }\n\tPoint operator / (const double &b) { return Point(x / b, y / b); }\n\tPoint rot90(int t) { return Point(-y, x) * t; }\n\tdouble operator * (const Point &b) { return x * b.y - y * b.x; }\n\tdouble operator % (const Point &b) { return x * b.x + y * b.y; }\n\tdouble len2() { return x * x + y * y; }\n\tdouble len() { return sqrt(x * x + y * y); }\n\tbool operator < (const Point &b) const {\n\t\tif (dcmp(x - b.x) != 0) return dcmp(x - b.x) < 0;\n\t\treturn dcmp(y - b.y) < 0;\n\t}\n\tbool operator == (const Point &b) const { return dcmp(x - b.x) == 0 && dcmp(y - b.y) == 0; }\n\tvoid init() {\n\t\tscanf(\"%lf%lf\", &x, &y); \n\t}\n} A, B, C;\ndouble sinA, sinB, sinC;\nvector<double> solve(double a, double b, double c) {\n\tdouble delta = b * b - 4 * a * c;\n\tvector<double> res;\n\tif (dcmp(a)) {\n\t\tif (delta < 0) return res;\n\t\tdouble x1 = (-b + sqrt(delta)) / (2.0*a);\n\t\tdouble x2 = (-b - sqrt(delta)) / (2.0*a);\n\t\tif (x1 > x2) swap(x1, x2);\n\t\tres.push_back(x1);\n\t\tres.push_back(x2);\n\t\treturn res;\n\t}\n\tif (!dcmp(b) && dcmp(c)) return res;\n\tres.push_back(-c / b);\n\treturn res;\n}\ndouble get(Point A, Point B, Point C, double r1, double sinC) {\n\tPoint a = (C - B);\n\tPoint b = (C - A);\n\tPoint c = (B - A);\n\ta = a / a.len();\n\tb = b / b.len();\n\tc = c / c.len();\n\tr1 /= (b+c).len();\n\tdouble l1 = (b+c).len();\n\tdouble l2 = (a+b).len();\n\tvector<double> root = solve((a+b).len2() - l2*l2*sinC*sinC, 2.0*((b*r1 + c*r1 - (C-A))%(a+b)) - 2*r1*sinA*sinC*l1*l2, (b*r1+c*r1-(C-A)).len2()-l1*l1*r1*r1*sinA*sinA);\n\tif (root.size() == 0) return -1;\n\t//printf(\"%.10f\\n\", root[0]);\n\treturn root[0] * l2;\n}\nbool ccheck(Point c1,Point c2,double r1,double r2) {\n\tif (dcmp((c1-c2).len() - (r1+r2)) == 0) return 1;\n\treturn 0;\n}\nbool check(double r1, double &ra, double &rb, double &rc) {\n\tdouble r3 = get(A, B, C, r1, sinC);\n\tif (r3 < eps) return 0;\n\tdouble r2 = get(A, C, B, r1, sinB);\n\tif (r2 < eps) return 0;\n\tPoint a = (C-B);\n\tPoint b = (C-A);\n\tPoint c = (B-A);\n\ta = a / a.len();\n\tb = b / b.len();\n\tc = c / c.len();\n\n\t//Point c1 = A + (b+c)*r1/(b+c).len();\n\tPoint c2 = B + (a-c)*r2/(a-c).len();\n\tPoint c3 = C - (a+b)*r3/(a+b).len();\n\n\tra = r1 * sinA;\n\trb = r2 * sinB;\n\trc = r3 * sinC;\n\t//\tprintf(\"%d\\n\", ccheck(c1, c2, ra, rb));\n\t//\tprintf(\"%d\\n\", ccheck(c1, c3, ra, rc));\n\tif (dcmp((c2-c3).len2() - sqr(rc+rb)) >= 0) return 1;\n\treturn 0;\n}\nint main()\n{\n\t//freopen(\"in\",\"r\",stdin);\n\n\twhile (1) {\n\t\tA.init(); B.init(); C.init();\n\t\tif (A == Point(0, 0) && B == Point(0, 0) && C == Point(0, 0)) break;\n\t\tdouble l = 0, r = min((B-A).len(), (C-A).len()); ////////===============================================!!!\n\t\tdouble ra, rb, rc;\n\n\t\tPoint a = (C-B) / (C-B).len();\n\t\tPoint b = (C-A) / (C-A).len();\n\t\tPoint c = (B-A) / (B-A).len();\n\t\tsinA = fabs((b + c) * b / (b + c).len());\n\t\tsinC = fabs((a + b) * b / (a + b).len());\n\t\tsinB = fabs((a - c) * a / (a - c).len());\n\n\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\tdouble mid = (l + r) * 0.5;\n\t\t\tif (check(mid, ra, rb, rc)) r = mid; else l = mid;\n\t\t}\n\t\tcheck(r, ra, rb, rc);\n\t\tprintf(\"%.10f %.10f %.10f\\n\", ra, rb, rc);\n\t}\n\n\treturn 0;\n}\n\n// hehe ~"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\n#define FOR(i,a,n) for(ll i=a;i<(ll)(n);i++)\n\nstruct point {\n   int x;\n   int y;\n};\n\nint main(){\n   point A,B,C;\n   while(cin>>A.x>>A.y>>B.x>>B.y>>C.x>>C.y, A.x||A.y||B.x||B.y||C.x||C.y){\n      //辺の長さ\n      double aL = sqrt(pow(C.x-B.x, 2)+pow(C.y-B.y, 2));\n      double bL = sqrt(pow(C.x-A.x, 2)+pow(C.y-A.y, 2));\n      double cL = sqrt(pow(B.x-A.x, 2)+pow(B.y-A.y, 2));\n\n      //角度\n      double rad[3];\n      rad[0] = acos((bL*bL+cL*cL-aL*aL)/(2*bL*cL));\n      rad[1] = acos((cL*cL+aL*aL-bL*bL)/(2*cL*aL));\n      rad[2] = acos((aL*aL+bL*bL-cL*cL)/(2*aL*bL));\n\n      //面積\n      double s = (aL+bL+cL)/2;\n      double S = sqrt(s*(s-aL)*(s-bL)*(s-cL));\n      //内接円半径\n      double r = S/s;\n      \n      //マルファッティ円の半径\n      double rM[3];\n      for(int i=0; i<3; i++){\n         rM[i] = ((1+tan(rad[(1+i)%3]/4))*(1+tan(rad[(2+i)%3]/4)))/(2*(1+tan(rad[i]/4)))*r;\n         cout << fixed << setprecision(10) << rM[i];\n         if(i < 2) cout << \" \";\n      }\n      cout<<endl;\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<double,P> P2;\n\nconst double EPS = 1e-7;\nP v[3];\n\ndouble cross(P a, P b){ return imag(conj(a)*b);}\n\nP rotate(P p, double rad){\n  double x = real(p) * cos(rad) - imag(p) * sin(rad);\n  double y = real(p) * sin(rad) + imag(p) * cos(rad);\n  return P(x,y);\n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  return m.first + B / A * (m.second - m.first);\n}\n\ndouble areaV(){\n  double sum = 0.0;\n  for(int i=0;i<3;i++) sum += (real(v[i]) - real(v[(i+1)%3])) * (imag(v[i]) + imag(v[(i+1)%3]));\n  return abs(sum) / 2.0;\n}\n\nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\nP2 check2(P2 p, int pos){\n  double le = 0.1, ri = 2.0 * areaV() / (abs(v[1]-v[0]) + abs(v[2]-v[1]) + abs(v[0]-v[2]));\n  L l[2];\n  P2 res;\n  for(int i=0;i<1000;i++){\n    double mid = (le + ri) / 2.0;\n\n    for(int j=pos;j<pos+2;j++){\n      P a = (v[(j+1)%3]-v[j%3]) * mid / abs(v[(j+1)%3]-v[j%3]);\n      P b = rotate(a, M_PI/2.0);\n      l[j-pos] = L(v[(j+1)%3]+b, v[j%3]+b);\n    }\n    res = P2(mid, crossPoint(l[0],l[1]));\n\n    if(equal(abs(res.second-p.second), res.first+p.first)) return res;\n    else if(abs(res.second-p.second) < res.first+p.first) ri = mid;\n    else le = mid;\n  }\n}\n\nint check(double r, int pos){\n  L l[2];\n  P2 p[3];\n  for(int i=0;i<2;i++){\n    P a = (v[i+1]-v[i]) * r / abs(v[i+1]-v[i]);\n    P b = rotate(a, M_PI/2.0);\n    l[i] = L(v[i+1]+b, v[i]+b);\n  }\n  p[0] = P2(r, crossPoint(l[0],l[1]));\n\n\n  for(int i=1;i<3;i++) p[i] = check2(p[0], i);\n\n  if(pos == 999 || equal(abs(p[2].second-p[1].second), p[2].first+p[1].first)){\n    printf(\"%.6f %.6f %.6f\\n\",p[2].first, p[0].first, p[1].first);\n    return 1;\n  }\n  else if(abs(p[2].second-p[1].second) < p[2].first+p[1].first) return 2;\n  else return 0;\n  \n}\n\nvoid solve(){\n  double le = 0.1, ri = 2.0 * areaV() / (abs(v[1]-v[0]) + abs(v[2]-v[1]) + abs(v[0]-v[2]));\n  for(int i=0;i<1000;i++){\n    double mid = (le + ri) / 2.0;\n    int res = check(mid,i);\n    if(res == 0) ri = mid;\n    else if(res == 2) le = mid;\n    else return;\n  }\n}\n\nint main(){\n  int x[3],y[3];\n  while(cin >> x[0] >> y[0] >> x[1] >> y[1] >> x[2] >> y[2] && (x[0]|y[0]|x[1]|y[1]|x[2]|y[2])){\n    for(int i=0;i<3;i++) v[i] = P((double)x[i], (double)y[i]);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst double EPS = 1e-8;\nconst double eps = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;\nnamespace std{\n\tbool operator < (const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b){\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b){\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P>{\n\tL(){}\n\tL(const P &a, const P &b){\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\n\nstruct C{\n\tP p; double r;\n\tC(){}\n\tC(const P &p, double r) : p(p), r(r){}\n};\n\nint ccw(P a, P b, P c){\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;       // counter clockwise\n\tif(cross(b, c) < 0)   return -1;       // clockwise\n\tif(dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif(norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nP crosspoint(const L &l, const L &m){\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif(abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nint intersectCC(const C &c1, const C &c2){\n\tdouble d = std::abs(c1.p - c2.p), r1 = c1.r, r2 = c2.r;\n\tif(r1 + r2 < d) return 0;                   // ??¢????????????\n\tif(std::abs(r1 + r2 - d) < eps) return -2;  // ?????\\\n\tif(std::abs(d + r1 - r2) < eps) return +1;  // c1 ??? c2 ????????§?????\\\n\tif(std::abs(d + r2 - r1) < eps) return -1;  // c2 ??? c1 ????????§?????\\\n\tif(d + r1 < r2) return +3;                  // c1 ??? c2 ??????\n\tif(d + r2 < r1) return -3;                  // c2 ??? c1 ??????\n\treturn 2;                                    // 2?????????????????????\n}\n\nP projection(const L &l, const P &p){\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\n\ndouble distanceLP(const L &l, const P &p){\n\treturn abs(p - projection(l, p));\n}\n\nstd::vector<P> crosspointCL(const C &c, const L &l){\n\tstd::vector<P> res;\n\tdouble d = distanceLP(l, c.p);      // ????????¨??´???????????¢\n\tif(d > c.r) return res;  // ??¢????????????\n\n\tif(std::abs(d - c.r) < eps){  // ?§?????????????\n\t\tres.push_back(projection(l, c.p));\n\t\treturn res;\n\t}\n\tP h = projection(l, c.p);\n\tP u = std::sqrt(c.r * c.r - d * d) * (l[1] - l[0]) / std::abs(l[1] - l[0]);\n\tres.push_back(h + u);\n\tres.push_back(h - u);\n\treturn res;\n}\n\nP p[3];\nL ls[3];\nP no[3];\n\nbool InTriangle(P p){\n\tfor(int i = 0; i < 3; i++){\n\t\tif(ccw(ls[i][0], ls[i][1], p) != 1) return false;\n\t}\n\treturn true;\n}\n\nbool InTriangle(C c){\n\tfor(int i = 0; i < 3; i++){\n\t\tauto res = crosspointCL(c, ls[i]);\n\t\tif(res.size() == 2) return false;\n\t}\n\treturn true;\n}\n\nvoid PrintC(C c){\n\tcout << \"Circle \" << c.p.real() << \" \" << c.p.imag() << \" \" << c.r << endl;\n}\n\ndouble d(double x1, double y1, double x2, double y2){\n\tx1 -= x2, y1 -= y2;\n\treturn sqrt(x1 * x1 + y1 * y1);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\twhile(true){\n\t\tdouble sum = 0;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tsum += x + y;\n\t\t\tp[i] = P(x, y);\n\t\t}\n\t\tif(abs(sum) < 1e-6) break;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tP p1 = p[i], p2 = p[(i + 1) % 3];\n\t\t\tls[i] = L(p1, p2);\n\t\t\tdouble d = abs(p1 - p2);\n\t\t\tno[i] = (p2 - p1) / d * polar(1.0, PI / 2.0);\n\t\t}\n\n\t\tdouble lb1 = 1e-6, ub1 = 1e6;\n\t\tC c1, c2, c3;\n\t\tfor(int loop1 = 0; loop1 < 100; loop1++){\n\t\t\tdouble mid1 = (lb1 + ub1) / 2.0;\n\t\t\tP p1;\n\t\t\t{\n\t\t\t\tL l1 = ls[0], l2 = ls[1];\n\t\t\t\tl1[0] += no[0] * mid1;\n\t\t\t\tl1[1] += no[0] * mid1;\n\t\t\t\tl2[0] += no[1] * mid1;\n\t\t\t\tl2[1] += no[1] * mid1;\n\t\t\t\tp1 = crosspoint(l1, l2);\n\t\t\t\tif(!InTriangle(p1) || !InTriangle(C(p1, mid1))){\n\t\t\t\t\tub1 = mid1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc1 = C(p1, mid1);\n\n\t\t\tdouble lb2 = 1e-6, ub2 = 1e6;\n\t\t\tP p2;\n\n\t\t\tfor(int loop2 = 0; loop2 < 100; loop2++){\n\t\t\t\tdouble mid2 = (lb2 + ub2) / 2.0;\n\t\t\t\t{\n\t\t\t\t\tL l1 = ls[1], l2 = ls[2];\n\t\t\t\t\tl1[0] += no[1] * mid2;\n\t\t\t\t\tl1[1] += no[1] * mid2;\n\t\t\t\t\tl2[0] += no[2] * mid2;\n\t\t\t\t\tl2[1] += no[2] * mid2;\n\t\t\t\t\tp2 = crosspoint(l1, l2);\n\t\t\t\t\tif(!InTriangle(p2) || !InTriangle(C(p2, mid2)) || intersectCC(c1, C(p2, mid2)) != 0){\n\t\t\t\t\t\tub2 = mid2;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlb2 = mid2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tc2 = C(p2, lb2);\n\n\n\t\t\tdouble dist = abs(c1.p - c2.p);\n\t\t\tif(dist > c1.r + c2.r + eps){\n\t\t\t\tlb1 = mid1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//PrintC(c1);\n\t\t\t//PrintC(c2);\n\n\t\t\t// c1??¨??\\?????????c3????±???????\n\t\t\tdouble lb3 = 1e-6, ub3 = 1e6;\n\t\t\tP p3;\n\t\t\tfor(int loop2 = 0; loop2 < 100; loop2++){\n\t\t\t\tdouble mid3 = (lb3 + ub3) / 2.0;\n\t\t\t\t{\n\t\t\t\t\tL l1 = ls[2], l2 = ls[0];\n\t\t\t\t\tl1[0] += no[2] * mid3;\n\t\t\t\t\tl1[1] += no[2] * mid3;\n\t\t\t\t\tl2[0] += no[0] * mid3;\n\t\t\t\t\tl2[1] += no[0] * mid3;\n\t\t\t\t\tp3 = crosspoint(l1, l2);\n\t\t\t\t\tif(!InTriangle(p3) || !InTriangle(C(p3, mid3)) || intersectCC(c1, C(p3, mid3)) != 0){\n\t\t\t\t\t\tub3 = mid3;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlb3 = mid3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tc3 = C(p3, lb3);\n\n\t\t\tdist = abs(p2 - p3);\n\t\t\tif(dist > c2.r + c3.r) ub1 = mid1;\n\t\t\telse lb1 = mid1;\n\t\t\t//PrintC(c1);\n\t\t\t//PrintC(c2);\n\t\t\t//PrintC(c3);\n\t\t}\n\n\t\tcout << fixed << setprecision(15) << c3.r << \" \" << c1.r << \" \" << c2.r << endl;\n\t\t//PrintC(c1);\n\t\t//PrintC(c2);\n\t\t//PrintC(c3);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\nstruct point {\n\tdouble x, y;\n\tpoint() { x = y = 0.0; }\n\tpoint(double x, double y) : x(x), y(y) {}\n};\n\ndouble dist(point p1, point p2) {\n\treturn hypot(fabs(p1.x - p2.x), fabs(p1.y - p2.y));\n}\n\nint main() {\n    while(true) {\n        int x1,y1,x2,y2,x3,y3;\n        cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        if (x1 == 0 && x2 == 0 && x3 == 0 && y1 == 0 && y2 == 0 && y3 == 0) break;\n\n        point ap = point(x1,y1);\n        point bp = point(x2,y2);\n        point cp = point(x3,y3);\n\n        // side opposite vertex point\n        double a = dist(bp,cp);\n        double b = dist(ap,cp);\n        double c = dist(ap,bp);\n\n        // herons rule\n        double s = (a+b+c)/2;\n        double triangleArea = sqrt(s*(s-a)*(s-b)*(s-c));\n        \n        // Inradius\n        double r = triangleArea/s;\n\n        // Incenter of triangle\n        point ip = point((a*ap.x + b*bp.x + c*cp.x)/(a+b+c), (a*ap.y + b*bp.y + c*cp.y)/(a+b+c));\n\n        // distance from incenter to each vertex\n        double d = dist(ip,ap);\n        double e = dist(ip,bp);\n        double f = dist(ip,cp);\n\n        // Malfatti's radius formula\n        double r1 = r/(2*(s-a)) * (s+d-r-e-f);\n        double r2 = r/(2*(s-b)) * (s+e-r-d-f);\n        double r3 = r/(2*(s-c)) * (s+f-r-d-e);\n\n        printf(\"%.6f %.6f %.6f\\n\", r1, r2, r3);\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <numeric> \n#include <cstdlib> \n#include <climits> \n#include <cmath> \n#include <cstdio> \n#include <cfloat> \n#include <map> \n#include <utility> \n#include <cassert>\n#include <set> \n#include <memory> \n#include <algorithm> \n#include <functional> \n#include <sstream> \n#include <complex> \n#include <iomanip>\n#include <stack> \n#include <queue> \n#include <string> \n#include <vector> \nusing namespace std; \n\n#define rep(i, n) for(int i = 0; i < n; i++) \n#define rep2(i, m, n) for(int i = m; i < n; i++) \nconst double EPS = 1E-10; \ntypedef long long ll; \ntypedef pair<int, int> P; \ntypedef pair<int, P> PP; \ntypedef complex<double> xy_t; \nconst int INF = 1 << 30; \n\ndouble cross(xy_t a, xy_t b){\n  return imag(conj(a) * b);\n}\n\ndouble dot(xy_t a, xy_t b){\n  return real(conj(a) * b);\n}\n\nxy_t A, B, C;\n\ndouble limit;\nxy_t r1, r2[2];\ndouble db, dc;\n\nvoid setR(xy_t s, xy_t p0, xy_t p1, double R){\n  xy_t p = p0 - s;\n  xy_t q = p1 - s;\n  p /= abs(p);\n  q /= abs(q);\n  xy_t r = p + q;\n  r /= abs(r);\n  double d = abs(cross(r, p));\n  r1 = s + r * (R / d);\n  \n}\n\ndouble getR2(xy_t s, xy_t p0, xy_t p1, double R, int id){\n  xy_t p = p0 - s;\n  xy_t q = p1 - s;\n  p /= abs(p);\n  q /= abs(q);\n  xy_t r = p + q;\n  r /= abs(r);\n  double d = abs(cross(r, p));\n\n\n  double ub = limit;\n  double lb = 0;\n  \n  for(int i = 0; i < 100; i++){\n    double mb = (ub + lb) / 2.0;\n    r2[id] = s + r * (mb / d);\n    if(abs(r2[id] - r1) > mb + R) lb = mb;\n    else ub = mb;\n  }\n \n  return lb;\n}\n\nbool ok(double mb){\n  \n  setR(A, B, C , mb);\n  db = getR2(B, A, C, mb, 0);\n  dc = getR2(C, A, B, mb, 1);\n  //  cout << (b + c) << \" \" << abs(r2[0] - r2[1]) << endl;\n  return (db + dc) > abs(r2[0] - r2[1]);\n}\n\nint main(){\n  int a, b, c, d, e, f;\n  while(cin >> a >> b >> c >> d >> e >> f && (a || b || c || d || e || f)){\n    A = xy_t(a, b);\n    B = xy_t(c, d);\n    C = xy_t(e, f);\n\n    double S = abs(cross(B - A, C - A)) / 2.0;\n    limit = S * 2 / (abs(B - A) + abs(C - A) + abs(C - B));\n  \n    double ub = limit;\n    double lb = 0;\n    rep(i, 100){\n      double mb = (ub + lb) / 2.0;\n      if(ok(mb)) lb = mb;\n      else ub = mb;\n    }\n    cout << fixed << setprecision(9) << lb << \" \" << db << \" \" << dc << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nP p[3];\ndouble ih;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\nbool intersects(P a,double ra,P b,double rb){\n  return abs(a-b)<=ra+rb;\n}\n\nP angle_bisector(P a,P b){\n  return a/abs(a)+b/abs(b);\n}\n  \nP rtop(int x,double r){\n  P a=p[(x+1)%3]-p[x];\n  P b=p[(x+2)%3]-p[x];\n  P m=angle_bisector(a,b);\n  return p[x]+m*r*abs(a)/cross(a,m);\n}\n\nbool isx(int a,double ra,int b,double rb){\n  return intersects(rtop(a,ra),ra,rtop(b,rb),rb);\n}\n\nvector<double> os(double r){\n  vector<double> v(2);\n  for(int i=0;i<2;i++){\n    double l=0,h=ih;\n    for(int j=0;j<99;j++){\n      double m=(l+h)/2;\n      if(isx(i,m,2,r)){\n\th=m;\n      }else{\n\tl=m;\n      }\n    }\n    v[i]=l;\n  }\n  return v;\n}\n\nint main(){\n  for(;;){\n    bool f=false;\n    for(int i=0;i<3;i++){\n      int x,y;\n      cin>>x>>y;\n      f|=x|y;\n      p[i]=P(x,y);\n    }\n    if(!f)break;\n    P a=p[1]-p[0];\n    P b=p[2]-p[0];\n    ih=cross(a,b)/(abs(a)+abs(b)+abs(p[1]-p[2]));\n    double l=0,h=ih;\n    for(int i=0;i<99;i++){\n      double m=(l+h)/2;\n      auto r=os(m);\n      if(isx(0,r[0],1,r[1])){\n\tl=m;\n      }else{\n\th=m;\n      }\n    }\n    auto r=os(l);\n    cout.precision(9);\n    cout<<fixed<<r[0]<<' '<<r[1]<<' '<<l<<endl;\n  }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + P(2,0) * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble bi_search(double lb, double ub, bool (*ok)(double)) {\n  REP(i,100) { // ±±ÍKÉ\n    double mid = (lb+ub)/2;\n    if (ok(mid)) lb = mid;\n    else ub = mid;\n  }\n  return ub;\n}\n\ndouble calct(P a, P b, double r, double ang) {\n  double A = norm(a) * cos(ang/2) * cos(ang/2);\n  double B = - 2 * (dot(a, b) + r * abs(a) * sin(ang/2));\n  double C = norm(b) - r * r;\n\n  assert(A!=0);\n  assert(B*B-4*A*C>=0);\n\n  double res = (-B - sqrt(B*B-4*A*C)) / (2*A);\n  \n  return res;\n}\n\ndouble ang(P a, P b) {        // xNg©çÝ½xNgÌpxÌvZ[0,2pi]\n  double ret1 = arg(b)-arg(a);\n  ret1 = (ret1>=0) ? ret1 : ret1 + 2*PI;\n  double ret2 = arg(a)-arg(b);\n  ret2 = (ret2>=0) ? ret2 : ret2 + 2*PI;\n  return min(ret1, ret2);\n}\n\nP point[3];\n\ndouble ans[3];\n\nbool ok(double r) {\n  P a = point[1] - point[0]; a /= abs(a);\n  P b = point[2] - point[0]; b /= abs(b);\n  P c = a+b; c /= abs(c);\n  c *= r / sin(ang(a,b)/2);\n  double len = abs(c) * cos(ang(a,b)/2);\n  if (len >= abs(point[1]-point[0])-EPS || len >= abs(point[2] - point[0])-EPS)\n    return 0;\n  c += point[0];\n  \n  a = point[0] - point[1]; a /= abs(a);\n  b = point[2] - point[1]; b /= abs(b);\n  double t = calct(a+b, c-point[1], r, ang(a,b));\n  \n  P d1 = t*(a+b);\n  double r1 = abs(d1) * sin(ang(a,b)/2);\n  a = point[0] - point[2]; a /= abs(a);\n  b = point[1] - point[2]; b /= abs(b);\n  t = calct(a+b, c-point[2], r, ang(a,b));\n  P d2 = t*(a+b);\n  double r2 = abs(d2) * sin(ang(a,b)/2);\n  d2 += point[2] - point[1];\n\n  ans[0] = r;\n  ans[1] = r1;\n  ans[2] = r2;\n\n  // cout << c << \" \" << point[1] + d1 << \" \" << point[2] + d1 << endl;\n  // cout << r << \" \" << r1 << \" \" << r2 << endl;\n  // cout << abs(d1 - d2) << \" \" << r1 + r2 << endl;\n  return abs(d1 - d2) < r1 + r2;\n}\n\nint main() {\n  while(1) {\n    bool f = 0;\n    REP(i, 3) {\n      double x, y;\n      cin >> x >> y;\n      if (x||y) f = 1;\n      point[i] = P(x, y);\n    }\n    if (!f) break;\n    \n    bi_search(0, 5000, ok);\n    printf(\"%.12f %.12f %.12f\\n\", ans[0], ans[1], ans[2]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\n\nstruct Line : public vector<Point> {\n    Line(const Point& a, const Point& b) {\n        push_back(a); push_back(b);\n    }\n    Point vector() const {\n        return back() - front();\n    }\n};\ndouble cross(Point a, Point b){\n    return imag(conj(a) * b);\n}\ndouble distanceLP(Line l, Point p){\n    // return abs(p - projection(l, p));\n    return abs(cross(l.vector(), p - l[0])) / abs(l.vector());\n}\n\nPoint incenter(Point p1, Point p2, Point p3){\n    double a = abs(p2 - p3);\n    double b = abs(p3 - p1);\n    double c = abs(p1 - p2);\n    return (a * p1 + b * p2 + c * p3) / (a + b + c);\n}\n\nPoint find_point(Point a, double r, Point p, Point c, Line l){\n    double lb = 0, ub = 1;\n    REP(iter, 100){\n        double mid = (lb + ub) / 2;\n        Point q = p * (1 - mid) + c * mid;\n        double s = distanceLP(l, q);\n        if(abs(a - q) < r + s){ // too near\n            ub = mid;\n        }else{ // come closer\n            lb = mid;\n        }\n    }\n    return p * (1 - lb) + c * lb;\n}\n\nint main(){\n    while(true){\n        Point tri[3];\n        REP(i, 3){\n            double x, y;\n            cin >> x >> y;\n            tri[i] = Point(x, y);\n        }\n        if(tri[0] == tri[1]) break;\n        Point c = incenter(tri[0], tri[1], tri[2]);\n        double lb = 0, ub = 1;\n        REP(iter, 100){\n            double mid = (lb + ub) / 2;\n            Point p0 = (tri[0] * (1 - mid) + c * mid);\n            double r0 = distanceLP(Line(tri[0], tri[1]), p0);\n            //cout << \"mid : \" << mid << endl;\n            //cout << \"p0 : \" << p0 << \" r0 : \" << r0 << endl;\n\n            Line l(tri[1], tri[2]);\n            Point p1 = find_point(p0, r0, tri[1], c, l);\n            double r1 = distanceLP(l, p1);\n            //cout << \"p1 : \" << p1 << \" r1 : \" << r1 << endl;\n            Point p2 = find_point(p0, r0, tri[2], c, l);\n            double r2 = distanceLP(l, p2);\n            //cout << \"p2 : \" << p2 << \" r2 : \" << r2 << endl;\n            if(abs(p1 - p2) < r1 + r2){ // come closer\n                //cout << \"lb update\" << endl;\n                lb = mid;\n            }else{\n                //cout << \"ub update\" << endl;\n                ub = mid;\n            }\n        }\n\n        Point p0 = (tri[0] * (1 - lb) + c * lb);\n        double r0 = distanceLP(Line(tri[0], tri[1]), p0);\n        Line l(tri[1], tri[2]);\n        Point p1 = find_point(p0, r0, tri[1], c, l);\n        double r1 = distanceLP(l, p1);\n        Point p2 = find_point(p0, r0, tri[2], c, l);\n        double r2 = distanceLP(l, p2);\n        printf(\"%.6f %.6f %.6f\\n\", r0, r1, r2);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-7;\nconst double PI = acos(-1);\nconst int INF = 1<<24;\n\nbool equals(double a, double b) { return fabs(a - b) < EPS; }\n\nnamespace std {\n  bool operator < (const P &a, const P b) {\n    return ( a.real() != b.real()\n\t     ? a.real() < b.real() : a.imag() < b.imag() );\n  }\n}\n\nstruct L : public vector<P> {\n  L(P a, P b) {\n    push_back(a), push_back(b);\n  }\n};\n\nstruct C {\n  P o;\n  double r;\n  C() {}\n  C(P o, double r) : o(o), r(r) {}\n};\n\ndouble norm(P a) { return a.real()*a.real() + a.imag() * a.imag(); }\ndouble abs (P a) { return sqrt(norm(a)); }\ndouble dot  (P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\ndouble cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\n\nbool isOrthogonal(P a, P b) { return equals(dot(a, b), 0.0); }\nbool isParallel  (P a, P b) { return equals(cross(a, b), 0.0); }\n\nP project(P s1, P s2, P p) {\n  P base = s2 - s1;\n  double t = dot(p - s1, base)/norm(base);\n  return s1 + base*t;\n}\n\nP reflect(P s1, P s2, P p) { return p + (project(s1, s2, p) - p)*2.0; }\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return fabs(cross(s2 - s1, p - s1)/abs(s2 - s1));\n}\n\nP getRotateP(P p, double rad, P o = P(0, 0)) {\n  P q = p - o;\n  return o + P(q.real()*cos(rad) - q.imag()*sin(rad),\n\t   q.real()*sin(rad) + q.imag()*cos(rad));\n}\n\nnamespace CCW {\n  enum { COUNTER_CLOCKWISE = 1, CLOCKWISE = -1,\n\t ONLINE_BACK = 2, ONLINE_FRONT = -2,\n\t ONSEGMENT = 0 };\n}\nint ccw(P p0, P a, P b) {\n  a -= p0;\n  b -= p0;\n  if(cross(a, b) > EPS) return CCW::COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CCW::CLOCKWISE;\n  if(dot(a, b) < -EPS) return CCW::ONLINE_BACK;\n  if(norm(a) < norm(b)) return CCW::ONLINE_FRONT;\n  return CCW::ONSEGMENT;\n}\n\n// üªÆüªÌð·»èB\nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t   ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\n// ¼üÆ~Ìð·»èBßèlÍð_ÌB\nint isIntersect(P s1, P s2, C c) {\n  double d = getDistanceLP(s1, s2, c.o);\n  if(equals(d, c.r)) return 1;\n  else if(d < c.r) return 2;\n  else return 0;\n}\n\n// ~Æ~Ìð·»èB\n//  0 : ð·AàïÈµ\n//  1 : OÅ1_ÆÚ·é\n//  2 : 2_Åð·\n// -1 : àïµÄÚ·é\n// -2 : ®SÉàï\nint isIntersect(C a, C b) {\n  double x = a.o.real() - b.o.real();\n  double y = a.o.imag() - b.o.imag();\n  double s = a.r + b.r;\n  double d = x*x + y*y;\n  s *= s;\n  if(equals(d, s)) return 1;\n  if(d > s) return 0;\n  double r = abs(a.r - b.r);\n  r *= r;\n  if(equals(d, r)) return -1;\n  if(d > r) return 2;\n  return -2;\n}\n\n// ¼üÆ¼üÌð_B\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  // cross ÌÖW è\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\n// ¼üÆ~Ìð_B\nvector<P> getCrossP(P s1, P s2, C c) {\n  vector<P> v;\n  P p = project(s1, s2, c.o);\n  if(isIntersect(s1, s2, c) == 1) {\n    v.push_back(p);\n  } else {\n    double h = abs(p-c.o);\n    double d = sqrt(c.r*c.r - h*h);\n    P base = s2 - s1;\n    v.push_back(p + d*base/abs(base));\n    v.push_back(p - d*base/abs(base));\n  }\n  return v;\n}\n\n// xNg(1, 0)ðîÆµ½xNgÌpx(-PI <= rad <= PI)\ndouble getAngle(P a) {\n  return atan2(a.imag(), a.real());\n}\n\n// 2ÂÌxNgÌÈ·p(0 <= rad <= PI)\ndouble getAngle(P a, P b) {\n  if(cross(a, b) < 0.0) swap(a, b);\n  return getAngle(b) - getAngle(a);\n  //return acos(dot(a, b)/(abs(a)*abs(b)));\n}\n\n// 2ÂÌ¼üÉÚ·é¼arÌ~\nC getC(P a1, P a2, P b1, P b2, double r) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  if(cross(a, b) < 0) swap(a, b);\n  P p = getCrossP(a1, a2, b1, b2);\n  double rad = getAngle(a, b) / 2.0;\n  double alpha = getAngle(a);\n  C res;\n  res.r = r;\n  res.o = p + P(cos(alpha + rad), sin(alpha + rad)) * r / sin(rad);\n  return res;\n}\n\n// wÌö®ðp¢ÄOp`Ì3ÓÌ·³©çÊÏðßé\ndouble heron(double a, double b, double c) {\n  double s = (a+b+c)/2.0;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\n// ½p`ÌÊÏ\ndouble getArea(vector<P> &G) {\n  int n = G.size();\n  double S = 0;\n  for(int i = 0; i < n; ++i) {\n    S += cross(G[i], G[(i+1)%n]);\n  }\n  return S/2.0;\n}\n\n// Op`ÌàÚ~Ì¼a\ndouble getIncircleR(P p1, P p2, P p3) {\n  double a = abs(p1 - p2);\n  double b = abs(p2 - p3);\n  double c = abs(p3 - p1);\n  return heron(a,b,c)*2.0/(a+b+c);\n}\n\nC getIncircle(P p1, P p2, P p3) {\n  return getC(p1, p2, p1, p3, getIncircleR(p1, p2, p3));\n}\n\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for(int i = 0; i < n; ch[k++] = ps[i++])\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = CCW::CLOCKWISE) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\nP p[3];\nC incircle;\n\nC calc(P a1, P a2, P b1, P b2, C c) {\n  C res;\n  double s, t;\n  s = 0.0, t = incircle.r;\n  while(1) {\n    double r = (s+t)/2.0;\n    res = getC(a1, a2, b1, b2, r);\n    int tmp = isIntersect(c, res);\n    if(tmp == 0) {\n      s = r;\n    } else if(tmp == 1) {\n      return res;\n    } else {\n      t = r;\n    }\n  }\n}\n\nvoid solve() {\n  incircle = getIncircle(p[0], p[1], p[2]);\n  double s, t;\n  C c[3];\n  s = 0.0, t = incircle.r;\n  while(1) {\n    double r = (s+t)/2.0;\n    c[0] = getC(p[0], p[1], p[0], p[2], r);\n\n    if(!isIntersect(c[0], incircle)) {\n      s = r;\n      continue;\n    }\n\n    c[1] = calc(p[1], p[2], p[1], p[0], c[0]);\n    c[2] = calc(p[2], p[0], p[2], p[1], c[0]);\n\n    int tmp = isIntersect(c[1], c[2]);\n\n    if(tmp == 1) {\n      for(int i = 0; i < 3; ++i) {\n\tif(i) printf(\" \");\n\tprintf(\"%.6f\", c[i].r);\n      }\n      printf(\"\\n\");\n      return;\n    } else if(tmp == 0) {\n      t = r;\n    } else {\n      s = r;\n    }\n  }\n}\n\nint main() {\n  while(1) {\n    bool allZero = true;\n    for(int i = 0; i < 3; ++i) {\n      cin >> p[i].real() >> p[i].imag();\n      if(p[i].real() != 0 || p[i].imag() != 0) allZero = false;\n    }\n    if(allZero) break;\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\ntypedef long double D;\ntypedef complex<D> P;\n\n#define X real()\n#define Y imag()\n\nconst D eps=1e-8;\nconst D inf=1e12;\nconst D PI=acos(-1);\n\nD cross(P a,P b){ return (conj(a)*b).Y; }\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\nP projection(L l,P p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*(c/b).X;\n}\nD distanceLP(L l,P p) {\n  return abs(p-projection(l,p));\n}\nP crosspoint(L l,L m) {\n  D A=cross(l[1]-l[0],m[1]-m[0]);\n  D B=cross(l[1]-l[0],l[1]-m[0]);\n  if (abs(A)<eps&&abs(B)<eps) return m[0]; // same line\n  if (abs(A)<eps) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0]+B/A*(m[1]-m[0]);\n}\n\nP p[3],q[3],e[3],x[3];\nD r[3];\nP g;\n\nbool ok(){\n  r[0]=distanceLP(L(p[0],p[1]),x[0]);\n  P cp=crosspoint(L(p[1],q[1]),L(p[2],q[2]));\n  repl(i,1,3){\n    D lb=0,ub=abs(cp-p[i]);\n    rep(hoge,100){\n      D mid=(ub+lb)/2.0;\n      x[i]=p[i]+e[i]*mid;\n      r[i]=distanceLP(L(p[i],p[(i+1)%3]),x[i]);\n      D d0i=abs(x[i]-x[0]);\n      if(d0i>r[0]+r[i])lb=mid;\n      else ub=mid;\n    }\n  }\n  D d12=abs(x[1]-x[2]);\n  return d12>r[1]+r[2];\n}\n\nint main(){\n  while(1){\n    bool done=true;\n    rep(i,3){\n      int x,y;\n      cin>>x>>y;\n      if(x!=0||y!=0)done=false;\n      p[i]=P(x,y);\n    }\n    if(done)break;\n\n    D absA=abs(p[2]-p[1]); D absB=abs(p[2]-p[0]); D absC=abs(p[1]-p[0]);\n    q[0]=(p[1]*absB+p[2]*absC)/(absB+absC);\n    q[1]=(p[0]*absA+p[2]*absC)/(absA+absC);\n    q[2]=(p[0]*absA+p[1]*absB)/(absA+absB);\n    rep(i,3)e[i]=(q[i]-p[i])/abs(q[i]-p[i]);\n    D lb=0,ub=abs(q[0]-p[0]);\n    rep(hoge,100){\n      D mid=(lb+ub)/2.0;\n      x[0]=p[0]+e[0]*mid;\n      if(ok())ub=mid;\n      else lb=mid;\n    }\n    printf(\"%.10Lf %.10Lf %.10Lf\\n\", r[0], r[1], r[2]);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<complex>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst double eps = 1e-10;\nconst double MINRAD=eps;\nconst double pi = acos(-1);\n\ntypedef complex<double> P;\n\nvoid output_circle(P cr1,double r1){\n  cout << \"[\" << cr1.real()<<\",\"<<cr1.imag()<<\",\"\n       << r1 << \"],\"<<endl;\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a)<eps)return abs(c-a);\n  if (dot(a-b,c-b)<eps)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool is_intersected_cl(P a,P b,P circle,double r){\n  bool flag1 = abs(a-circle) < r+eps;\n  bool flag2 = abs(b-circle) < r+eps;\n  if (flag1 == flag2){\n    if (!flag1){\n      if (distance_ls_p(a,b,circle) < r+eps)return true;\n    }else if (flag1){\n      return true;\n    }\n  }else {\n    return true;\n  }\n  return false;\n}\n\n//0:a include b\n//1:b include a\n//2:intersected\n//3:same\n//4:far away\n// r1 >= r2\n\nint is_intersected_circle(P a,P b,double r1,double r2){\n  double d = abs(a-b);\n  if (d<eps && abs(r1-r2)<eps)return 3;\n  if (d+r2 < r1)return 0;\n  if (d+r1 < r2)return 1;\n  if (fabs(r1+r2-d) < eps)return 5;\n  if (d > r1+r2)return 4;\n\n  return 2;\n}\n\n\nbool is_out(P *cmp,P cr1){\n  if (cross(cmp[2]-cmp[1],cr1-cmp[1])<eps||\n      cross(cmp[3]-cmp[2],cr1-cmp[2])<eps||\n      cross(cmp[1]-cmp[3],cr1-cmp[3])<eps)return true;\n  return false;\n}\n\ndouble compute_r(P cr1,double r1,\n\t\t double x2,double y2,double sintheta2,\n\t\t double mx2,double my2,\n\t\t P*cmp,int ind1,int ind2){\n  double l =0.1,r=5000;\n  double mid;\n  P cr2;\n  while(l < r){\n    mid = (l+r)/2;\n    cr2=P(x2+mid/sintheta2*mx2,y2+mid/sintheta2*my2);\n\n    if (is_out(cmp,cr2)\n\t||is_intersected_cl(cmp[ind1],cmp[ind2],cr2,mid)\n\t){\n      r=mid-MINRAD;\n      continue;\n    }\n    \n    int state;\n    if (mid > r1){\n      state=is_intersected_circle(cr2,cr1,mid,r1);\n    }else {\n      state=is_intersected_circle(cr1,cr2,r1,mid);\n    }\n    \n    /*\n    cout <<\"state \" << state << endl;\n    output_circle(cr1,r1);\n    output_circle(cr2,mid);\n    */\n\n\n    if (state == 5){\n      break;\n    }else if(state == 4){\n      l=mid+eps;\n    }else {\n      r=mid-eps;\n    }\n  }\n  //  output_circle(cr2,mid);\n  return mid;\n}\n\nvoid solve(double x1,double y1,double sintheta1,\n\t   double mx1,double my1,\n\t   double x2,double y2,double sintheta2,\n\t   double mx2,double my2,\n\t   double x3,double y3,double sintheta3,\n\t   double mx3,double my3){\n  double l=0.1,r=5000;\n  double r1,r2,r3,r13,r23;\n  P cmp[4];cmp[1]=P(x1,y1);cmp[2]=P(x2,y2);cmp[3]=P(x3,y3);\n  while(l < r){\n    //    cout << l <<\" \" << (l+r)/2 <<\" \" << r << endl;\n\n    r1=(l+r)/2;\n    P cr1(x1+r1/sintheta1*mx1,y1+r1/sintheta1*my1);\n\n    //    cout <<\"circle 1 \" << endl;output_circle(cr1,r1);\n    \n    if (is_intersected_cl(cmp[2],cmp[3],cr1,r1)||\n\tis_out(cmp,cr1)){\n      r=r1-MINRAD;\n      continue;\n    }\n\n\n    r2=compute_r(cr1,r1,x2,y2,sintheta2,mx2,my2,cmp,1,3);\n    P cr2=P(x2+r2/sintheta2*mx2,y2+r2/sintheta2*my2);\n    //    cout <<\"circle2 \"<< endl;output_circle(cr2,r2);\n    \n    r13=compute_r(cr1,r1,x3,y3,sintheta3,mx3,my3,cmp,1,2);\n\n    r23=compute_r(cr2,r2,x3,y3,sintheta3,mx3,my3,cmp,1,2);\n    \n    \n    r3=r13;\n    if (fabs(r13-r23)<MINRAD){\n      //cout <<\"exactly\"<<endl;\n      r3=r13;\n      break;\n    }\n    if (r13 < r23){\n      r=r1-MINRAD;\n    }else if(r13 > r23){\n      l=r1+MINRAD;\n    }\n\n\n\n  }\n  //  cout <<\"answer\"<<endl;\n  printf(\"%.6lf %.6lf %.6lf\\n\",r1,r2,r3);\n}\n\n\ndouble compute_info(double x1,double y1,\n\t\t    double x2,double y2,\n\t\t    double x3,double y3,\n\t\t    double &mx1,double &my1,double &sintheta1){\n  P p1(x1,y1),p2(x2,y2),p3(x3,y3);\n  P tmp =p2-p1;\n  double theta1;\n  double theta2=arg(p2-p1);\n  double theta3=arg(p3-p1);\n  if (theta3<0&&theta2>0)theta3+=2*pi;\n  theta1=theta3-theta2;\n  theta1/=2;\n\n  mx1=tmp.real()*cos(theta1)-tmp.imag()*sin(theta1);\n  my1=tmp.real()*sin(theta1)+tmp.imag()*cos(theta1);\n\n  double abab=(abs(P(mx1,my1)));\n  mx1/=abab;\n  my1/=abab;\n  sintheta1=sin(theta1);\n}\n\n\nmain(){\n  double x1,x2,x3,y1,y2,y3;\n  while(cin>>x1>>y1>>x2>>y2>>x3>>y3){\n    if (x1==0&&x2==0&&x3==0&&\n\ty1==0&&y2==0&&y3==0)break;\n    double mx1,my1,mx2,my2,mx3,my3;\n    double sintheta1,sintheta2,sintheta3;\n    \n    \n    compute_info(x1,y1,x2,y2,x3,y3,mx1,my1,sintheta1);\n    compute_info(x2,y2,x3,y3,x1,y1,mx2,my2,sintheta2);\n    compute_info(x3,y3,x1,y1,x2,y2,mx3,my3,sintheta3);\n\n    \n    //    cout <<\"input\" << endl;cout << \"[\";cout << \"[\" << x1 <<\",\"<<y1<<\"],\";cout << \"[\" << x2 <<\",\"<<y2<<\"],\"; cout << \"[\" << x3 <<\",\"<<y3<<\"],\";cout << \"[\" << x1 <<\",\"<<y1<<\"],\";cout << \"],\"<<endl;cout <<\"input end \"<<endl;\n    \n\n\n    solve(x1,y1,sintheta1,mx1,my1,\n\t  x2,y2,sintheta2,mx2,my2,\n\t  x3,y3,sintheta3,mx3,my3);\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <iomanip>\n#include <cassert>\nusing namespace std;\n\ntypedef complex<double> P;\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define EPS 1e-12\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nP rotateP(P a, P b, double rad)\n{\n\tdouble x0=a.real(), x=b.real();\n\tdouble y0=a.imag(), y=b.imag();\n\tdouble xx=x0+(x-x0)*cos(rad)-(y-y0)*sin(rad);\n\tdouble yy=y0+(x-x0)*sin(rad)+(y-y0)*cos(rad);\n\t\n\treturn P(xx,yy);\n}\n\nP a[3], Cp[3];\ndouble Cr[3];\n\nbool putC(int n, L fl)\n{\n\tdouble rad=arg( (a[(n+2)%3]-a[n]) / (a[(n+1)%3]-a[n]) );\n\trad/=2.0;\n\t\n\tP d=rotateP(a[n], a[(n+1)%3], rad);\t\n\tP c = crosspoint(fl, L(a[n], d));\n\t\n\tif(abs(a[n]-c) < EPS) c=d;\n\t\n\tP hi=c, lo=a[n], mi;\n\twhile(abs(hi-lo) > EPS)\n\t{\n\t\tmi=(hi+lo)/2.0;\n\t\tdouble r=distanceSP(L(a[n], a[(n+1)%3]) , mi);\n\t\tif(abs(Cp[0]-mi) < r+Cr[0]) hi=mi;\n\t\telse lo=mi;\n\t}\n\t\n\tCr[n]=distanceSP(L(a[n], a[(n+1)%3]), mi);\n\tCp[n]=mi;\n\t\n\tif(n==2)\n\t{\n\t\tif(abs(Cp[2]-Cp[1]) > Cr[2]+Cr[1]) return false;\n\t\treturn true;\n\t}\n\t\n\treturn putC(n+1, fl);\n}\n\nint main()\n{\n\t\n\tcout << setiosflags(ios::fixed) << setprecision(5);\n\twhile(1)\n\t{\n\t\tbool e=true;\n\t\tREP(i,3)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\t\n\t\t\ta[i]=P(x,y);\n\t\t\t\n\t\t\tif(x||y) e=false;\n\t\t}\n\t\tif(e) break;\n\t\t\n\t\tdouble rad=arg( (a[2]-a[0]) / (a[1]-a[0]) );\n\t\trad/=2.0;\n\t\tP d=rotateP(a[0], a[1], rad);\n\t\t\n\t\tdouble rad2=arg( (a[1]-a[2]) / (a[0]-a[2]) );\n\t\trad2/=2.0;\n\t\tP g=rotateP(a[2], a[0], rad2);\n\t\t\n\t\tP c = crosspoint(L(a[2], g), L(a[0], d));\n\t\tif(abs(a[0]-c) < EPS) c=d;\n\t\t\n\t\tP hi=c, lo=a[0];\n\t\twhile(abs(hi-lo) > EPS)\n\t\t{\n\t\t\tP mi=(hi+lo)/2.0;\n\t\t\t\n\t\t\tCr[0]=distanceSP(L(a[0], a[1]), mi);\n\t\t\tCp[0]=mi;\n\t\t\t\n\t\t\tbool ret=putC(1, L(a[0], c));\n\t\t\t\n\t\t\tif(!ret) hi=mi;\n\t\t\telse lo=mi;\n\t\t}\n\t\tcout << Cr[0] << \" \" << Cr[1] << \" \" << Cr[2] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<double,P> P2;\n\nconst double EPS = 1e-6;\nP v[3];\n\ndouble cross(P a, P b){ return imag(conj(a)*b);}\n\nP rotate(P p, double rad){\n  double x = real(p) * cos(rad) - imag(p) * sin(rad);\n  double y = real(p) * sin(rad) + imag(p) * cos(rad);\n  return P(x,y);\n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  return m.first + B / A * (m.second - m.first);\n}\n\ndouble areaV(){\n  double sum = 0.0;\n  for(int i=0;i<3;i++) sum += (real(v[i]) - real(v[(i+1)%3])) * (imag(v[i]) + imag(v[(i+1)%3]));\n  return abs(sum) / 2.0;\n}\n\nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\nP2 check2(P2 p, int pos){\n  double le = 0.1, ri = 2.0 * areaV() / (abs(v[1]-v[0]) + abs(v[2]-v[1]) + abs(v[0]-v[2]));\n  L l[2];\n  P2 res;\n  for(int i=0;i<1000;i++){\n    double mid = (le + ri) / 2.0;\n\n    for(int j=pos;j<pos+2;j++){\n      P a = (v[(j+1)%3]-v[j%3]) * mid / abs(v[(j+1)%3]-v[j%3]);\n      P b = rotate(a, M_PI/2.0);\n      l[j-pos] = L(v[(j+1)%3]+b, v[j%3]+b);\n    }\n    res = P2(mid, crossPoint(l[0],l[1]));\n\n    if(equal(abs(res.second-p.second), res.first+p.first)) return res;\n    else if(abs(res.second-p.second) < res.first+p.first) ri = mid;\n    else le = mid;\n  }\n}\n\nint check(double r){\n  L l[2];\n  P2 p[3];\n  for(int i=0;i<2;i++){\n    P a = (v[i+1]-v[i]) * r / abs(v[i+1]-v[i]);\n    P b = rotate(a, M_PI/2.0);\n    l[i] = L(v[i+1]+b, v[i]+b);\n  }\n  p[0] = P2(r, crossPoint(l[0],l[1]));\n\n\n  for(int i=1;i<3;i++) p[i] = check2(p[0], i);\n\n  if(equal(abs(p[2].second-p[1].second), p[2].first+p[1].first)){\n    printf(\"%.6f %.6f %.6f\\n\",p[2].first, p[0].first, p[1].first);\n    return 1;\n  }\n  else if(abs(p[2].second-p[1].second) < p[2].first+p[1].first) return 2;\n  else return 0;\n  \n}\n\nvoid solve(){\n  double le = 0.1, ri = 2.0 * areaV() / (abs(v[1]-v[0]) + abs(v[2]-v[1]) + abs(v[0]-v[2]));\n  while(1){\n    double mid = (le + ri) / 2.0;\n    int res = check(mid);\n    if(res == 0) ri = mid;\n    else if(res == 2) le = mid;\n    else return;\n  }\n}\n\nint main(){\n  int x[3],y[3];\n  while(cin >> x[0] >> y[0] >> x[1] >> y[1] >> x[2] >> y[2] && (x[0]|y[0]|x[1]|y[1]|x[2]|y[2])){\n    for(int i=0;i<3;i++) v[i] = P((double)x[i], (double)y[i]);\n    solve();\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <cmath>\n\ntypedef std::pair<double,double> Point;\n#define x first\n#define y second\n\n\ndouble dist(Point a, Point b){\n\tdouble x = a.x - b.x;\n\tdouble y = a.y - b.y;\n\n\treturn sqrt(x*x+y*y);\n}\n\n\nint main(){\n\n\tPoint A;\n\tPoint B;\n\tPoint C;\n\n\tstd::cin >> A.x >> A.y >> B.x >> B.y >> C.x >> C.y;\n\n\twhile(A.x != 0 || A.y != 0 || B.x != 0 || B.y != 0 \n\t\t\t|| C.x != 0 || C.y != 0){\n\n\t\tdouble AB = dist(A,B);\n\t\tdouble AC = dist(A,C);\n\t\tdouble BC = dist(B,C);\n\n\t\t//random forumual stuff that i dont really get here\n\t\tdouble s = (AB + AC + BC)/2;\n\t\tPoint I;//centre of triangle \n\t\tI.x = (BC * A.x + AC * B.x + AB * C.x)/(AB+AC+BC);\n\t\tI.y = (BC * A.y + AC * B.y + AB * C.y)/(AB+AC+BC); \n\t\tdouble r = sqrt((s-AB)*(s-AC)*(s-BC)/s);\n\n\t\tdouble IA = dist(I,A);\n\t\tdouble IB = dist(I,B);\n\t\tdouble IC = dist(I,C);\n\n\t\tdouble r1 = (r/(2*(s-BC)))*(s-r + IA-IC-IB);\n\t\tdouble r2 = (r/(2*(s-AC)))*(s-r + IB-IC-IA);\n\t\tdouble r3 = (r/(2*(s-AB)))*(s-r + IC-IB-IA);\n\n\t\tstd::cout << r1 << \" \" << r2 << \" \" << r3 << \"\\n\";\n\n\t\tstd::cin >> A.x >> A.y >> B.x >> B.y >> C.x >> C.y;\n\t}\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ndouble X1, X2, X3, Y1, Y2, Y3; //coor\ndouble r1, r2, r3;             //radii\ndouble e1, e2, e3;             //edge\ndouble a1, a2, a3;             //angle\ndouble r;\n\nvoid calc()\n{\n\te1 = sqrt(pow(X2 - X3, 2) + pow(Y2 - Y3, 2));\n\te2 = sqrt(pow(X1 - X3, 2) + pow(Y1 - Y3, 2));\n\te3 = sqrt(pow(X1 - X2, 2) + pow(Y1 - Y2, 2));\n\ta1 = acos((e2 * e2 + e3 * e3 - e1 * e1) / (2 * e2 * e3));\n\ta2 = acos((e3 * e3 + e1 * e1 - e2 * e2) / (2 * e1 * e3));\n\ta3 = acos((e1 * e1 + e2 * e2 - e3 * e3) / (2 * e1 * e2));\n\tr = e2 * e3 * sin(a1) / (e1 + e2 + e3);\n\tr1 = r * ((1 + tan(a2 / 4)) * (1 + tan(a3 / 4))) / (2 * (1 + tan(a1 / 4)));\n\tr2 = r * ((1 + tan(a1 / 4)) * (1 + tan(a3 / 4))) / (2 * (1 + tan(a2 / 4)));\n\tr3 = r * ((1 + tan(a1 / 4)) * (1 + tan(a2 / 4))) / (2 * (1 + tan(a3 / 4)));\n}\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf\", &X1, &Y1, &X2, &Y2, &X3, &Y3);\n\t\tif (X1 == 0 && X2 == 0 && X3 == 0 && Y1 == 0 && Y2 == 0 && Y3 == 0)\n\t\t\tbreak;\n\t\tcalc();\n\t\tprintf(\"%lf %lf %lf\\n\", r1, r2, r3);\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "/**\n * 2009??´ ??¢?????¢G\n * icpc??´?????????\n **/\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n//#define PI 3.14159\n\ndouble length(int x1, int y1, int x2, int y2) {\n    double a = (double)abs(x2-x1);\n    double b = (double)abs(y2-y1);\n\n    return sqrt(a*a+b*b);\n}\ndouble radius(double A,double B,double C,double r) {\n    return (r*(1.0+tan(B*0.25))*(1.0+tan(C*0.25)) / (2.0*(1.0+tan(A*0.25))));\n}\ndouble space(double a,double b,double c) {\n    double s;\n    s = (a+b+c)*0.5;\n\treturn sqrt(s*(s-a)*(s-b)*(s-c));\n}\ndouble height(double c,double S) {\n    return S/c*2.0;\n}\ndouble radian(double b,double h) {\n    return asin(h/b);\n}\ndouble naisetu_r(double a,double b,double c,double S) {\n    return S/(a+b+c)*2.0;\n}\n\nint main(void) {\n    int x[3];\n    int y[3];\n    int i,j;\n    double a,b,c;\n    double inst[3];\n    int max;\n    int num;\n    double r[3];\n    double A,B,C;\n    double h;\n    double S;\n\n    while(1) {\n        scanf(\"%d %d %d %d %d %d\",&x[0],&y[0],&x[1],&y[1],&x[2],&y[2]);\n        if(x[0] == 0 && y[0] == 0 && x[1] == 0 && y[1] == 0 && x[2] == 0 && y[2] == 0) break;\n\n        for(i=0;i<3;i++) {\n            if(i!=2) {\n                inst[i] = length(x[i],y[i],x[i+1],y[i+1]);\n            }\n            else inst[i] = length(x[i],y[i],x[0],y[0]);\n        }\n\n        max = 0;\n\n        for(i=0;i<3;i++) {\n            if(i==0 || max < inst[i]) {\n                max = inst[i];\n                num = i;\n            }\n        }\n\n        if(num == 2) {\n            c = inst[2];\n            a = inst[0];\n            b = inst[1];\n        }\n        else if(num == 1) {\n            c = inst[1];\n            a = inst[2];\n            b = inst[0];\n        }\n        else {\n            c = inst[0];\n            a = inst[1];\n            b = inst[2];\n        }\n        a = fabs(a);\n        b = fabs(b);\n        c = fabs(c);\n        //printf(\"(a,b,c)=(%f,%f,%f)\\n\",a,b,c);\n        S = space(a,b,c);\n        h = height(c,S);\n        A = radian(b,h);\n        B = radian(a,h);\n        C = M_PI-(A+B);\n        //printf(\"(S,h,A,B,C,R)=(%f,%f,%f,%f,%f,%f)\\n\",S,h,A,B,C,naisetu_r(a,b,c,S));\n        r[0] = radius(A,B,C,naisetu_r(a,b,c,S));\n        r[1] = radius(B,C,A,naisetu_r(a,b,c,S));\n        r[2] = radius(C,A,B,naisetu_r(a,b,c,S));\n       if(num==2) {\n            printf(\"%0.10f %0.10f %0.10f\\n\",r[0],r[1],r[2]);\n       }\n        else if(num==1) {\n            printf(\"%0.10f %0.10f %0.10f\\n\",r[2],r[0],r[1]);\n        }\n        else printf(\"%0.10f %0.10f %0.10f\\n\",r[0],r[1],r[2]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define PI 3.14159\n\ndouble length(int x1, int y1, int x2, int y2) {\n    double a = (double)abs(x2-x1);\n    double b = (double)abs(y2-y1);\n\n    return sqrt(a*a+b*b);\n}\ndouble radius(double A,double B,double C,double r) {\n    return (r*(1+tan(B/4))*(1+tan(C/4))/(2*(1+tan(A/4))));\n}\ndouble space(double a,double b,double c) {\n    //return (0.5*b*c*sin(a/b))/2;\n    double s;\n    s = (a+b+c)/2;\n    return sqrt(s*(s-a)*(s-b)*(s-c));\n}\ndouble height(double c,double S) {\n    return 2*(S/c);\n}\ndouble radian(double b,double h) {\n    return asin(h/b);\n}\ndouble naisetu_r(double a,double b,double c,double S) {\n    return 2*S/(a+b+c);\n}\n\nint main(void) {\n    int x[3];\n    int y[3];\n    int i,j;\n    double a,b,c;\n    double inst[3];\n    int max;\n    int num;\n    double r[3];\n    double A,B,C;\n    double h;\n    double S;\n\n    while(1) {\n        scanf(\"%d %d %d %d %d %d\",&x[0],&y[0],&x[1],&y[1],&x[2],&y[2]);\n        if(x[0] == 0 && y[0] == 0 && x[1] == 0 && y[1] == 0 && x[2] == 0 && y[2] == 0) break;\n\n        for(i=0;i<3;i++) {\n            if(i!=2) {\n                inst[i] = length(x[i],y[i],x[i+1],y[i+1]);\n            }\n            else inst[i] = length(x[i],y[i],x[0],y[0]);\n        }\n\n        max = 0;\n\n        for(i=0;i<3;i++) {\n            if(i==0 || max < inst[i]) {\n                max = inst[i];\n                num = i;\n            }\n        }\n\n        if(num == 2) {\n            c = inst[2];\n            a = inst[0];\n            b = inst[1];\n        }\n        else if(num == 1) {\n            c = inst[1];\n            a = inst[2];\n            b = inst[0];\n        }\n        else {\n            c = inst[0];\n            a = inst[1];\n            b = inst[2];\n        }\n        a = fabs(a);\n        b = fabs(b);\n        c = fabs(c);\n        //printf(\"(a,b,c)=(%f,%f,%f)\\n\",a,b,c);\n        S = space(a,b,c);\n        h = height(c,S);\n        A = radian(b,h);\n        B = radian(a,h);\n        C = PI-(A+B);\n        //printf(\"(S,h,A,B,C)=(%f,%f,%f,%f,%f)\\n\",S,h,A,B,C);\n        r[0] = radius(A,B,C,naisetu_r(a,b,c,S));\n        r[1] = radius(B,C,A,naisetu_r(a,b,c,S));\n        r[2] = radius(C,A,B,naisetu_r(a,b,c,S));            \n        if(num==2) {\n            printf(\"%f %f %f\\n\",r[0],r[1],r[2]);\n        }\n        else if(num==1) {\n            printf(\"%f %f %f\\n\",r[2],r[0],r[1]);\n        }\n        else printf(\"%f %f %f\\n\",r[1],r[2],r[0]);\n    }\n}"
  },
  {
    "language": "C",
    "code": "/**\n * 2009??´ ??¢?????¢G\n * icpc??´?????????\n **/\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define PI 3.14159\n\ndouble length(int x1, int y1, int x2, int y2) {\n    double a = (double)abs(x2-x1);\n    double b = (double)abs(y2-y1);\n\n    return sqrt(a*a+b*b);\n}\ndouble radius(double A,double B,double C,double r) {\n    return (r*(1+tan(B/4))*(1+tan(C/4))/(2*(1+tan(A/4))));\n}\ndouble space(double a,double b,double c) {\n    //return (0.5*b*c*sin(a/b))/2;\n    double s;\n    s = (a+b+c)/2;\n    return sqrt(s*(s-a)*(s-b)*(s-c));\n}\ndouble height(double c,double S) {\n    return 2*(S/c);\n}\ndouble radian(double b,double h) {\n    return asin(h/b);\n}\ndouble naisetu_r(double a,double b,double c,double S) {\n    return 2*S/(a+b+c);\n}\n\nint main(void) {\n    int x[3];\n    int y[3];\n    int i,j;\n    double a,b,c;\n    double inst[3];\n    int max;\n    int num;\n    double r[3];\n    double A,B,C;\n    double h;\n    double S;\n\n    while(1) {\n        scanf(\"%d %d %d %d %d %d\",&x[0],&y[0],&x[1],&y[1],&x[2],&y[2]);\n        if(x[0] == 0 && y[0] == 0 && x[1] == 0 && y[1] == 0 && x[2] == 0 && y[2] == 0) break;\n\n        for(i=0;i<3;i++) {\n            if(i!=2) {\n                inst[i] = length(x[i],y[i],x[i+1],y[i+1]);\n            }\n            else inst[i] = length(x[i],y[i],x[0],y[0]);\n        }\n\n        max = 0;\n\n        for(i=0;i<3;i++) {\n            if(i==0 || max < inst[i]) {\n                max = inst[i];\n                num = i;\n            }\n        }\n\n        if(num == 2) {\n            c = inst[2];\n            a = inst[0];\n            b = inst[1];\n        }\n        else if(num == 1) {\n            c = inst[1];\n            a = inst[2];\n            b = inst[0];\n        }\n        else {\n            c = inst[0];\n            a = inst[1];\n            b = inst[2];\n        }\n        a = fabs(a);\n        b = fabs(b);\n        c = fabs(c);\n        //printf(\"(a,b,c)=(%f,%f,%f)\\n\",a,b,c);\n        S = space(a,b,c);\n        h = height(c,S);\n        A = radian(b,h);\n        B = radian(a,h);\n        C = PI-(A+B);\n        //printf(\"(S,h,A,B,C)=(%f,%f,%f,%f,%f)\\n\",S,h,A,B,C);\n        r[0] = radius(A,B,C,naisetu_r(a,b,c,S));\n        r[1] = radius(B,C,A,naisetu_r(a,b,c,S));\n        r[2] = radius(C,A,B,naisetu_r(a,b,c,S));            \n        if(num==2) {\n            printf(\"%0.6f %0.6f %0.6f\\n\",r[0],r[1],r[2]);\n        }\n        else if(num==1) {\n            printf(\"%0.6f %0.6f %0.6f\\n\",r[2],r[0],r[1]);\n        }\n        else printf(\"%0.6f %0.6f %0.6f\\n\",r[1],r[2],r[0]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "/**\n * 2009??´ ??¢?????¢G\n * icpc??´?????????\n **/\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define PI 3.14159\n\ndouble length(int x1, int y1, int x2, int y2) {\n    double a = (double)abs(x2-x1);\n    double b = (double)abs(y2-y1);\n\n    return sqrt(a*a+b*b);\n}\ndouble radius(double A,double B,double C,double r) {\n    return (r*(1+tan(B/4))*(1+tan(C/4))/(2*(1+tan(A/4))));\n}\ndouble space(double a,double b,double c) {\n    //return (0.5*b*c*sin(a/b))/2;\n    double s;\n    s = (a+b+c)/2;\n    return sqrt(s*(s-a)*(s-b)*(s-c));\n}\ndouble height(double c,double S) {\n    return 2*(S/c);\n}\ndouble radian(double b,double h) {\n    return asin(h/b);\n}\ndouble naisetu_r(double a,double b,double c,double S) {\n    return 2*S/(a+b+c);\n}\n\nint main(void) {\n    int x[3];\n    int y[3];\n    int i,j;\n    double a,b,c;\n    double inst[3];\n    int max;\n    int num;\n    double r[3];\n    double A,B,C;\n    double h;\n    double S;\n\n    while(1) {\n        scanf(\"%d %d %d %d %d %d\",&x[0],&y[0],&x[1],&y[1],&x[2],&y[2]);\n        if(x[0] == 0 && y[0] == 0 && x[1] == 0 && y[1] == 0 && x[2] == 0 && y[2] == 0) break;\n\n        for(i=0;i<3;i++) {\n            if(i!=2) {\n                inst[i] = length(x[i],y[i],x[i+1],y[i+1]);\n            }\n            else inst[i] = length(x[i],y[i],x[0],y[0]);\n        }\n\n        max = 0;\n\n        for(i=0;i<3;i++) {\n            if(i==0 || max < inst[i]) {\n                max = inst[i];\n                num = i;\n            }\n        }\n\n        if(num == 2) {\n            c = inst[2];\n            a = inst[0];\n            b = inst[1];\n        }\n        else if(num == 1) {\n            c = inst[1];\n            a = inst[2];\n            b = inst[0];\n        }\n        else {\n            c = inst[0];\n            a = inst[1];\n            b = inst[2];\n        }\n        a = fabs(a);\n        b = fabs(b);\n        c = fabs(c);\n        //printf(\"(a,b,c)=(%f,%f,%f)\\n\",a,b,c);\n        S = space(a,b,c);\n        h = height(c,S);\n        A = radian(b,h);\n        B = radian(a,h);\n        C = PI-(A+B);\n        //printf(\"(S,h,A,B,C)=(%f,%f,%f,%f,%f)\\n\",S,h,A,B,C);\n        r[0] = radius(A,B,C,naisetu_r(a,b,c,S));\n        r[1] = radius(B,C,A,naisetu_r(a,b,c,S));\n        r[2] = radius(C,A,B,naisetu_r(a,b,c,S));            \n        if(num==2) {\n            printf(\"%0.7f %0.7f %0.7f\\n\",r[0],r[1],r[2]);\n        }\n        else if(num==1) {\n            printf(\"%0.7f %0.7f %0.7f\\n\",r[2],r[0],r[1]);\n        }\n        else printf(\"%0.7f %0.7f %0.7f\\n\",r[1],r[2],r[0]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "/**\n * 2009??´ ??¢?????¢G\n * icpc??´?????????\n **/\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define PI 3.14159\n\ndouble length(int x1, int y1, int x2, int y2) {\n    double a = (double)abs(x2-x1);\n    double b = (double)abs(y2-y1);\n\n    return sqrt(a*a+b*b);\n}\ndouble radius(double A,double B,double C,double r) {\n    return (r*(1+tan(B*25*0.01))*(1+tan(C*25*0.01))/(2*(1+tan(A*25*0.01))));\n}\ndouble space(double a,double b,double c) {\n    //return (0.5*b*c*sin(a/b))/2;\n    double s;\n    s = (a+b+c)*0.5;\n    return sqrt(s*(s-a)*(s-b)*(s-c));\n}\ndouble height(double c,double S) {\n    return S/c*2;\n}\ndouble radian(double b,double h) {\n    return asin(h/b);\n}\ndouble naisetu_r(double a,double b,double c,double S) {\n    return S/(a+b+c)*2;\n}\n\nint main(void) {\n    int x[3];\n    int y[3];\n    int i,j;\n    double a,b,c;\n    double inst[3];\n    int max;\n    int num;\n    double r[3];\n    double A,B,C;\n    double h;\n    double S;\n\n    while(1) {\n        scanf(\"%d %d %d %d %d %d\",&x[0],&y[0],&x[1],&y[1],&x[2],&y[2]);\n        if(x[0] == 0 && y[0] == 0 && x[1] == 0 && y[1] == 0 && x[2] == 0 && y[2] == 0) break;\n\n        for(i=0;i<3;i++) {\n            if(i!=2) {\n                inst[i] = length(x[i],y[i],x[i+1],y[i+1]);\n            }\n            else inst[i] = length(x[i],y[i],x[0],y[0]);\n        }\n\n        max = 0;\n\n        for(i=0;i<3;i++) {\n            if(i==0 || max < inst[i]) {\n                max = inst[i];\n                num = i;\n            }\n        }\n\n        if(num == 2) {\n            c = inst[2];\n            a = inst[0];\n            b = inst[1];\n        }\n        else if(num == 1) {\n            c = inst[1];\n            a = inst[2];\n            b = inst[0];\n        }\n        else {\n            c = inst[0];\n            a = inst[1];\n            b = inst[2];\n        }\n        a = fabs(a);\n        b = fabs(b);\n        c = fabs(c);\n        //printf(\"(a,b,c)=(%f,%f,%f)\\n\",a,b,c);\n        S = space(a,b,c);\n        h = height(c,S);\n        A = radian(b,h);\n        B = radian(a,h);\n        C = PI-(A+B);\n       // printf(\"(S,h,A,B,C,R)=(%f,%f,%f,%f,%f,%f)\\n\",S,h,A,B,C,naisetu_r(a,b,c,S));\n        r[0] = radius(A,B,C,naisetu_r(a,b,c,S));\n        r[1] = radius(B,C,A,naisetu_r(a,b,c,S));\n        r[2] = radius(C,A,B,naisetu_r(a,b,c,S));\n       if(num==2) {\n            printf(\"%0.10f %0.10f %0.10f\\n\",r[0],r[1],r[2]);\n       }\n        else if(num==1) {\n            printf(\"%0.10f %0.10f %0.10f\\n\",r[2],r[0],r[1]);\n        }\n        else printf(\"%0.10f %0.10f %0.10f\\n\",r[0],r[1],r[2]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "/**\n * 2009??´ ??¢?????¢G\n * icpc??´?????????\n **/\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n//#define PI 3.14159\n\ndouble length(int x1, int y1, int x2, int y2) {\n    double a = (double)abs(x2-x1);\n    double b = (double)abs(y2-y1);\n\n    return sqrt(a*a+b*b);\n}\ndouble radius(double A,double B,double C,double r) {\n    return (r*(1.0+tan(B*0.25))*(1.0+tan(C*0.25)) / (2.0*(1.0+tan(A*0.25))));\n}\ndouble space(double a,double b,double c) {\n    double s;\n    s = (a+b+c)*0.5;\n\treturn sqrt(s*(s-a)*(s-b)*(s-c));\n}\ndouble height(double c,double S) {\n    return S/c*2.0;\n}\ndouble radian(double b,double h) {\n    return asin(h/b);\n}\ndouble naisetu_r(double a,double b,double c,double S) {\n    return S/(a+b+c)*2.0;\n}\n\nint main(void) {\n    int x[3];\n    int y[3];\n    int i,j;\n    double a,b,c;\n    double inst[3];\n    int max;\n    int num;\n    double r[3];\n    double A,B,C;\n    double h;\n    double S;\n\n    while(1) {\n        scanf(\"%d %d %d %d %d %d\",&x[0],&y[0],&x[1],&y[1],&x[2],&y[2]);\n        if(x[0] == 0 && y[0] == 0 && x[1] == 0 && y[1] == 0 && x[2] == 0 && y[2] == 0) break;\n\n        for(i=0;i<3;i++) {\n            if(i!=2) {\n                inst[i] = length(x[i],y[i],x[i+1],y[i+1]);\n            }\n            else inst[i] = length(x[i],y[i],x[0],y[0]);\n        }\n\n        max = 0;\n\n        for(i=0;i<3;i++) {\n            if(i==0 || max < inst[i]) {\n                max = inst[i];\n                num = i;\n            }\n        }\n\n        if(num == 2) {\n            a = inst[0];\n            b = inst[1];\n            c = inst[2];\n        }\n        else if(num == 1) {\n            a = inst[2];\n            b = inst[0];\n            c = inst[1];\n        }\n        else {\n            a = inst[1];\n            b = inst[2];\n            c = inst[0];\n        }\n        a = fabs(a);\n        b = fabs(b);\n        c = fabs(c);\n        //printf(\"(a,b,c)=(%f,%f,%f)\\n\",a,b,c);\n        S = space(a,b,c);\n        h = height(c,S);\n        A = radian(b,h);\n        B = radian(a,h);\n        C = M_PI-(A+B);\n        //printf(\"(S,h,A,B,C,R)=(%f,%f,%f,%f,%f,%f)\\n\",S,h,A,B,C,naisetu_r(a,b,c,S));\n        r[0] = radius(A,B,C,naisetu_r(a,b,c,S));\n        r[1] = radius(B,C,A,naisetu_r(a,b,c,S));\n        r[2] = radius(C,A,B,naisetu_r(a,b,c,S));\n       if(num==2) {\n            printf(\"%0.5f %0.5f %0.5f\\n\",r[0],r[1],r[2]);\n       }\n        else if(num==1) {\n            printf(\"%0.5f %0.5f %0.5f\\n\",r[2],r[0],r[1]);\n        }\n        else printf(\"%0.5f %0.5f %0.5f\\n\",r[1],r[0],r[2]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct point {\n\tdouble\tx, y;\n};\n\nstruct triangle {\n\tstruct point\tvertices[3];\n};\n\nstatic inline double\ndistance(const struct point *p, const struct point *q)\n{\n\treturn hypot(p->x - q->x, p->y - q->y);\n}\n\nstatic inline void\ndecompose(size_t size, double **a)\n{\n\tsize_t\ti, j, p;\n\tsize_t\ti_max;\n\tdouble\ta_max, a_cur;\n\n\tfor (p = 0; p < size - 1; p ++) {\n\t\ti_max = p;\n\t\ta_max = fabs(a[p][p]);\n\t\tfor (i = p + 1; i < size; i ++) {\n\t\t\ta_cur = fabs(a[i][p]);\n\t\t\tif (a_cur > a_max) {\n\t\t\t\ti_max = i;\n\t\t\t\ta_max = a_cur;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tdouble\t*tmp = a[p];\n\t\t\ta[p] = a[i_max];\n\t\t\ta[i_max] = tmp;\n\t\t}\n\t\tfor (i = p + 1; i < size; i ++) {\n\t\t\ta[i][p] /= a[p][p];\n\t\t\tfor (j = p + 1; j < size; j ++) {\n\t\t\t\ta[i][j] -= a[i][p] * a[p][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < size; i ++) {\n\t\tfor (p = 0; p < i; p ++) {\n\t\t\ta[i][size] -= a[p][size] * a[i][p];\n\t\t}\n\t}\n\tfor (i = size; i > 0; ) {\n\t\ti --;\n\t\tfor (p = i + 1; p < size; p ++) {\n\t\t\ta[i][size] -= a[p][size] * a[i][p];\n\t\t}\n\t\ta[i][size] /= a[i][i];\n\t}\n}\n\ndouble *\nmalfatti_radii(const struct triangle *tri, double mradii[])\n{\n\tdouble\ta, b, c, s, sa, sb, sc, ir;\n\tdouble\tl, m, n;\n\tdouble\tx, y, z;\n\tdouble\tlx, my, nz;\n\tdouble\tsqrt_x, sqrt_y, sqrt_z;\n\tdouble\tf, g, h;\n\tdouble\tnorm_prev, norm_cur;\n\n\ta = distance(&tri->vertices[1], &tri->vertices[2]);\n\tb = distance(&tri->vertices[2], &tri->vertices[0]);\n\tc = distance(&tri->vertices[0], &tri->vertices[1]);\n\ts = (a + b + c) / 2;\n\tsa = s - a;\n\tsb = s - b;\n\tsc = s - c;\n\tir = sqrt(sa * sb * sc / s);\n\tl = sa / ir;\n\tm = sb / ir;\n\tn = sc / ir;\n\tx = 1;\n\ty = 1;\n\tz = 1;\n\tnorm_cur = HUGE_VAL;\n\twhile (lx = l * x, my = m * y, nz = n * z,\n\t       sqrt_x = sqrt(x), sqrt_y = sqrt(y), sqrt_z = sqrt(z),\n\t       f = my + nz + 2 * sqrt_y * sqrt_z - (m + n),\n\t       g = lx + nz + 2 * sqrt_x * sqrt_z - (l + n),\n\t       h = lx + my + 2 * sqrt_x * sqrt_y - (l + m),\n\t       norm_prev = norm_cur,\n\t       (norm_cur = fabs(f) + fabs(g) + fabs(h)) < norm_prev) {\n\t\tdouble\ttable_base[3][4] = {\n\t\t\t{0, m + sqrt_z / sqrt_y, n + sqrt_y / sqrt_z, f},\n\t\t\t{l + sqrt_z / sqrt_x, 0, n + sqrt_x / sqrt_z, g},\n\t\t\t{l + sqrt_y / sqrt_x, m + sqrt_x / sqrt_y, 0, h},\n\t\t};\n\t\tdouble\t*table[3] = {\n\t\t\ttable_base[0], table_base[1], table_base[2]\n\t\t};\n\t\tdecompose(3, table);\n\t\tx -= table[0][3];\n\t\ty -= table[1][3];\n\t\tz -= table[2][3];\n\t}\n\tmradii[0] = x * ir;\n\tmradii[1] = y * ir;\n\tmradii[2] = z * ir;\n\treturn mradii;\n}\n\nint\nmain(int argc, char *argv[])\n{\n\tdouble\tx0, y0, x1, y1, x2, y2;\n\tstruct triangle\tt;\n\tdouble\tr[3];\n\n\twhile (scanf(\"%lf%lf%lf%lf%lf%lf\", &x0, &y0, &x1, &y1, &x2, &y2) == 6 &&\n\t       !(x0 == 0 && y0 == 0 && x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0)) {\n\t\tt.vertices[0].x = x0;\n\t\tt.vertices[0].y = y0;\n\t\tt.vertices[1].x = x1;\n\t\tt.vertices[1].y = y1;\n\t\tt.vertices[2].x = x2;\n\t\tt.vertices[2].y = y2;\n\t\tmalfatti_radii(&t, r);\n\t\tprintf(\"%.6f %.6f %.6f\\n\", r[0], r[1], r[2]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define PI 3.14159\n\ndouble length(int x1, int y1, int x2, int y2) {\n    double a = (double)abs(x2-x1);\n    double b = (double)abs(y2-y1);\n\n    return sqrt(a*a+b*b);\n}\ndouble radius(double A,double B,double C,double r) {\n    return (r*(1+tan(B/4))*(1+tan(C/4))/(2*(1+tan(A/4))));\n}\ndouble space(double a,double b,double c) {\n    //return (0.5*b*c*sin(a/b))/2;\n    double s;\n    s = (a+b+c)/2;\n    return sqrt(s*(s-a)*(s-b)*(s-c));\n}\ndouble height(double c,double S) {\n    return 2*(S/c);\n}\ndouble radian(double b,double h) {\n    return asin(h/b);\n}\ndouble naisetu_r(double a,double b,double c,double S) {\n    return 2*S/(a+b+c);\n}\n\nint main(void) {\n    int x[3];\n    int y[3];\n    int i,j;\n    double a,b,c;\n    double inst[3];\n    int max;\n    int num;\n    double r[3];\n    double A,B,C;\n    double h;\n    double S;\n\n    while(1) {\n        scanf(\"%d %d %d %d %d %d\",&x[0],&y[0],&x[1],&y[1],&x[2],&y[2]);\n        if(x[0] == 0 && y[0] == 0 && x[1] == 0 && y[1] == 0 && x[2] == 0 && y[2] == 0) break;\n\n        for(i=0;i<3;i++) {\n            if(i!=2) {\n                inst[i] = length(x[i],y[i],x[i+1],y[i+1]);\n            }\n            else inst[i] = length(x[i],y[i],x[0],y[0]);\n        }\n\n        max = 0;\n\n        for(i=0;i<3;i++) {\n            if(i==0 || max < inst[i]) {\n                max = inst[i];\n                num = i;\n            }\n        }\n\n        if(num == 2) {\n            c = inst[2];\n            a = inst[0];\n            b = inst[1];\n        }\n        else if(num == 1) {\n            c = inst[1];\n            a = inst[2];\n            b = inst[0];\n        }\n        else {\n            c = inst[0];\n            a = inst[1];\n            b = inst[2];\n        }\n        a = fabs(a);\n        b = fabs(b);\n        c = fabs(c);\n        //printf(\"(a,b,c)=(%f,%f,%f)\\n\",a,b,c);\n        S = space(a,b,c);\n        h = height(c,S);\n        A = radian(b,h);\n        B = radian(a,h);\n        C = PI-(A+B);\n        //printf(\"(S,h,A,B,C)=(%f,%f,%f,%f,%f)\\n\",S,h,A,B,C);\n        r[0] = radius(A,B,C,naisetu_r(a,b,c,S));\n        r[1] = radius(B,C,A,naisetu_r(a,b,c,S));\n        r[2] = radius(C,A,B,naisetu_r(a,b,c,S));            \n        if(num==2) {\n            printf(\"%f %f %f\\n\",r[0],r[1],r[2]);\n        }\n        else if(num==1) {\n            printf(\"%f %f %f\\n\",r[2],r[0],r[1]);\n        }\n        else printf(\"%f %f %f\\n\",r[1],r[2],r[0]);\n    }\n}"
  },
  {
    "language": "C",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define PI 3.14159\n\ndouble length(int x1, int y1, int x2, int y2) {\n    double a = (double)abs(x2-x1);\n    double b = (double)abs(y2-y1);\n\n    return sqrt(a*a+b*b);\n}\ndouble radius(double A,double B,double C,double r) {\n    return (r*(1+tan(B/4))*(1+tan(C/4))/(2*(1+tan(A/4))));\n}\ndouble space(double a,double b,double c) {\n    //return (0.5*b*c*sin(a/b))/2;\n    double s;\n    s = (a+b+c)/2;\n    return sqrt(s*(s-a)*(s-b)*(s-c));\n}\ndouble height(double c,double S) {\n    return 2*(S/c);\n}\ndouble radian(double b,double h) {\n    return asin(h/b);\n}\ndouble naisetu_r(double a,double b,double c,double S) {\n    return 2*S/(a+b+c);\n}\n\nint main(void) {\n    int x[3];\n    int y[3];\n    int i,j;\n    double a,b,c;\n    double inst[3];\n    int max;\n    int num;\n    double r[3];\n    double A,B,C;\n    double h;\n    double S;\n\n    while(1) {\n        scanf(\"%d %d %d %d %d %d\",&x[0],&y[0],&x[1],&y[1],&x[2],&y[2]);\n        if(x[0] == 0 && y[0] == 0 && x[1] == 0 && y[1] == 0 && x[2] == 0 && y[2] == 0) break;\n\n        for(i=0;i<3;i++) {\n            if(i!=2) {\n                inst[i] = length(x[i],y[i],x[i+1],y[i+1]);\n            }\n            else inst[i] = length(x[i],y[i],x[0],y[0]);\n        }\n\n        max = 0;\n\n        for(i=0;i<3;i++) {\n            if(i==0 || max < inst[i]) {\n                max = inst[i];\n                num = i;\n            }\n        }\n\n        if(num == 2) {\n            c = inst[2];\n            a = inst[0];\n            b = inst[1];\n        }\n        else if(num == 1) {\n            c = inst[1];\n            a = inst[2];\n            b = inst[0];\n        }\n        else {\n            c = inst[0];\n            a = inst[1];\n            b = inst[2];\n        }\n        a = fabs(a);\n        b = fabs(b);\n        c = fabs(c);\n        //printf(\"(a,b,c)=(%f,%f,%f)\\n\",a,b,c);\n        S = space(a,b,c);\n        h = height(c,S);\n        A = radian(b,h);\n        B = radian(a,h);\n        C = PI-(A+B);\n        //printf(\"(S,h,A,B,C)=(%f,%f,%f,%f,%f)\\n\",S,h,A,B,C);\n        r[0] = radius(A,B,C,naisetu_r(a,b,c,S));\n        r[1] = radius(B,C,A,naisetu_r(a,b,c,S));\n        r[2] = radius(C,A,B,naisetu_r(a,b,c,S));            \n        if(num==2) {\n            printf(\"%f %f %f\\n\",r[0],r[1],r[2]);\n        }\n        else if(num==1) {\n            printf(\"%f %f %f\\n\",r[2],r[0],r[1]);\n        }\n        else printf(\"%f %f %f\\n\",r[1],r[2],r[0]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "/**\n * 2009??´ ??¢?????¢G\n * icpc??´?????????\n **/\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n//#define PI 3.14159\n\ntypedef struct {\n    double x;\n    double y;\n} Point;\n\ndouble length(Point p1, Point p2) {\n    double x = p2.x - p1.x;\n    double y = p2.y - p1.y;\n\n    x = x*x;\n    y = y*y;\n\n    return sqrt(x+y);\n}\ndouble radius(double A,double B,double C,double r) {\n    \n    double ans = ( r*((1.0+tan(B*0.25)) *(1.0+tan(C*0.25)) ) ); //\n    //printf(\"%lf\\n\",ans);\n    ans /= (2.0*(1.0+tan(A*0.25) ) );\n    return ans;\n}\ndouble space(double a,double b,double c) {\n    double s;\n    s = (a+b+c)*0.5;\n    return sqrt(s*(s-a)*(s-b)*(s-c));\n}\ndouble height(double c,double S) {\n    return ((S/c)*2.0);\n}\ndouble radian(double b,double h) {\n    return asin(h/b);\n}\ndouble naisetu_r(double a,double b,double c,double S) {\n    return (S/(a+b+c))*2.0;\n}\n\nint main(void) {\n    Point p[3];\n    int i,j;\n    double a,b,c;\n    double inst[3];\n    int max;\n    int num;\n    double r[3];\n    double A,B,C;\n    double h;\n    double S;\n    double R;\n    int buff;\n\n    while(1) {\n        scanf(\"%lf %lf %lf %lf %lf %lf\",&p[0].x, &p[0].y, &p[1].x, &p[1].y, &p[2].x, &p[2].y);\n\n        if(p[0].x==0 && p[0].y==0 && p[1].x==0 && p[1].y==0 && p[2].x==0 && p[2].y==0)\n            break;\n\n        for(i=0;i<3;i++) {\n            if(i==2) inst[i] = length(p[i], p[0]);\n            else {\n                inst[i] = length(p[i], p[i+1]);\n            }\n            //printf(\"(%lf %lf),\",p[i].x ,p[i].y);\n            //printf(\"(%lf),\",inst[i]);\n        }\n        //printf(\"\\n\");\n        a = inst[1];\n        b = inst[2];\n        c = inst[0];\n\n        //printf(\"(a,b,c)=(%f,%f,%f)\\n\",a,b,c);\n\n        S = space(a,b,c);\n        //\n        if(a>=b && a>=c) {\n            h = height(a,S);\n            B = radian(c,h);\n            C = radian(b,h);\n            A = M_PI-B-C;\n      }\n        else if(b>=c && b>=a) {\n            h = height(b,S);\n            C = radian(a,h);\n            A = radian(c,h);\n            B = M_PI-A-C;\n\n        }\n        else {\n            h = height(c,S);\n            A = radian(b,h);\n            B = radian(a,h);\n            C = M_PI-A-B;\n\n        }\n        //\n        //A = radian(b,h);\n        //B = radian(a,h);\n        //C = M_PI-A-B;\n        R = naisetu_r(a,b,c,S);\n        //printf(\"(S,h,A,B,C,R)=(%f,%f,%f,%f,%f,%f)\\n\",S,h,A,B,C,naisetu_r(a,b,c,S));\n        r[0] = radius(A,C,B,R);\n        r[1] = radius(B,A,C,R);\n        r[2] = radius(C,B,A,R);\n\n        printf(\"%0.5f %0.5f %0.5f\\n\",r[0],r[1],r[2]);\n        //printf(\" ----- \\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define PI 3.14159\n\ndouble length(int x1, int y1, int x2, int y2) {\n    double a = (double)abs(x2-x1);\n    double b = (double)abs(y2-y1);\n\n    return sqrt(a*a+b*b);\n}\ndouble radius(double A,double B,double C,double r) {\n    return (r*(1+tan(B/4))*(1+tan(C/4))/(2*(1+tan(A/4))));\n}\ndouble space(double a,double b,double c) {\n    //return (0.5*b*c*sin(a/b))/2;\n    double s;\n    s = (a+b+c)/2;\n    return sqrt(s*(s-a)*(s-b)*(s-c));\n}\ndouble height(double c,double S) {\n    return 2*(S/c);\n}\ndouble radian(double b,double h) {\n    return asin(h/b);\n}\ndouble naisetu_r(double a,double b,double c,double S) {\n    return 2*S/(a+b+c);\n}\n\nint main(void) {\n    int x[3];\n    int y[3];\n    int i,j;\n    double a,b,c;\n    double inst[3];\n    int max;\n    int num;\n    double r[3];\n    double A,B,C;\n    double h;\n    double S;\n\n    while(1) {\n        scanf(\"%d %d %d %d %d %d\",&x[0],&y[0],&x[1],&y[1],&x[2],&y[2]);\n        if(x[0] == 0 && y[0] == 0 && x[1] == 0 && y[1] == 0 && x[2] == 0 && y[2] == 0) break;\n\n        for(i=0;i<3;i++) {\n            if(i!=2) {\n                inst[i] = length(x[i],y[i],x[i+1],y[i+1]);\n            }\n            else inst[i] = length(x[i],y[i],x[0],y[0]);\n        }\n\n        max = 0;\n\n        for(i=0;i<3;i++) {\n            if(i==0 || max < inst[i]) {\n                max = inst[i];\n                num = i;\n            }\n        }\n\n        if(num == 2) {\n            c = inst[2];\n            a = inst[0];\n            b = inst[1];\n        }\n        else if(num == 1) {\n            c = inst[1];\n            a = inst[2];\n            b = inst[0];\n        }\n        else {\n            c = inst[0];\n            a = inst[1];\n            b = inst[2];\n        }\n        a = fabs(a);\n        b = fabs(b);\n        c = fabs(c);\n        //printf(\"(a,b,c)=(%f,%f,%f)\\n\",a,b,c);\n        S = space(a,b,c);\n        h = height(c,S);\n        A = radian(b,h);\n        B = radian(a,h);\n        C = PI-(A+B);\n        //printf(\"(S,h,A,B,C)=(%f,%f,%f,%f,%f)\\n\",S,h,A,B,C);\n        r[0] = radius(A,B,C,naisetu_r(a,b,c,S));\n        r[1] = radius(B,C,A,naisetu_r(a,b,c,S));\n        r[2] = radius(C,A,B,naisetu_r(a,b,c,S));\n\n        printf(\"%f %f %f\\n\",r[0],r[1],r[2]);\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\nconst double EPS = 1e-8;\ntypedef pair<double, double> pt;\n\n#define x first\n#define y second\n\ndouble sq(double a) { return a * a; }\n\ndouble dist(pt p, pt q) {\n  return sqrt(sq(p.x - q.x) + sq(p.y - q.y));\n}\n\nbool equal(double x, double y) {\n    if (fabs(x-y) < EPS){\n        return true;\n    }\n    return false;\n}\n\n\npt operator-(pt a, pt b) {\n  return pt(a.x - b.x, a.y - b.y);\n}\n\ndouble dotProduct(pt a, pt b) {\n    return a.x * b.x + a.y * b.y;\n}\n\nbool zero(double x) {\n  return fabs(x) <= EPS;\n}\n\nstruct line {\n  double a, b, c;\n};\n\nline getLine(pt a, pt b) {\n    line l;\n    l.a = a.y - b.y; // y1 - y2\n    l.b = b.x - a.x; // -(x1-x2)\n    // m = l.b / -l.a\n    l.c =  a.x*b.y - b.x*a.y ;\n    return l;\n}\n\npt intersect(line a, line b) {\n    double y = (a.a*b.c - a.c*b.a)/(a.b*b.a - a.a*b.b);\n    double x = (a.c*b.b - a.b*b.c)/(a.b*b.a - a.a*b.b);\n    return pt(x, y);\n}\n\npt intermediatePoint(pt a, pt b, double ratio) {\n    return pt(\n        (b.x-a.x)*ratio/(ratio+1)+a.x,\n         (b.y-a.y)*ratio/(ratio+1)+a.y\n         );\n}\n\ndouble angleBetween(pt a, pt b, pt c) {\n    return acos(dotProduct(pt(b.x-a.x,b.y-a.y), pt(c.x-a.x, c.y-a.y))/\n        (dist(a, b) * dist(a, c)));\n}\ndouble inRadius(double s, double a, double b, double c){\n    return sqrt(s*(s-a)*(s-b)*(s-c))/s;\n//return a*b/(a+b+c);\n}\n\ndouble malfatti(double s, double c, double inradius, double d, double e, double f) {\n    return inradius * (s + d - inradius - e -f)/2/(s-c);\n}\n\nint main() {\n\n    cout << setprecision(6) << fixed;\n    int x1, y1, x2, y2, x3, y3;\n    cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n    while(x1 != 0 || y1 != 0 || x2 != 0 || y2 != 0 || x3 != 0 || y3 != 0) {\n        pt A = pt(x1, y1);\n        pt B = pt(x2, y2);\n        pt C = pt(x3, y3);\n\n        double a = dist(B, C);\n        double b = dist(A, C);\n        double c = dist(A, B);\n\n        double s = (a+b+c)/2;\n\n        double Cratio = a / b;\n        pt Cbisectpt = intermediatePoint(B, A, Cratio);\n        line Cline = getLine(C, Cbisectpt);\n\n        double Bratio = c / a;\n        pt Bbisectpt = intermediatePoint(A, C, Bratio);\n        line Bline = getLine(B, Bbisectpt);\n\n        pt intpt = intersect(Cline, Bline);\n        double inr = inRadius(s, a, b, c);\n        double d = dist(A, intpt);\n        double e = dist(B, intpt);\n        double f = dist(C, intpt);\n\n        cout << malfatti(s, a, inr, d, e, f) << \" \"\n         << malfatti(s, b, inr, e, f, d) << \" \"\n        << malfatti(s, c, inr, f, d, e) << endl;\n\n        cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1301: Malfatti Circles\n// 2018.1.26 bal4u@uu\n\n#include <stdio.h>\n#include <math.h>\n\n#define ABS(a)  ((a)>=0?(a):-(a))\n\ndouble ra, rb, rc;\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tif (c == '-') {\n\t\tc = getchar_unlocked();\n\t\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\t\twhile (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\ndouble cross(int xa, int ya, int xb, int yb){ return xa*yb - ya*xb; }\n\nvoid malfattiCircle(int xa, int ya, int xb, int yb, int xc, int yc)\n{\n\tint i;\n\tdouble a, b, c, x, y, z, r;\n\tdouble lo, hi, t1, t2, t3;\n\n\ta = hypot(xb-xc, yb-yc), b = hypot(xa-xc, ya-yc), c = hypot(xa-xb, ya-yb);\n\tr = ABS(cross(xb-xa, yb-ya, xc-xa, yc-ya))/(a+b+c);\n    x = (-a+b+c)/(2*r), y = (a-b+c)/(2*r), z = (a+b-c)/(2*r);\n\tlo = 0, hi = r;\n\tfor (i = 0; i < 100; i++) {\n\t\tra = (lo + hi) / 2;\n\t\tt1 = y*y, t2 = x*y*ra - c*y - 2*ra, t3 = (c-x*ra)*(c-x*ra);\n\t\trb = (-t2 - sqrt(t2*t2 - t1*t3))/t1;\n\t\tt1 = z*z, t2 = x*z*ra - b*z - 2*ra, t3 = (b-x*ra)*(b-x*ra);\n\t\trc = (-t2 - sqrt(t2*t2 - t1*t3))/t1;\n\t\tif (2*sqrt(rb*rc) + y*rb + z*rc > a) lo = ra; else hi = ra;\n\t}\n}\n \nint main()\n{\n\tint x1, y1, x2, y2, x3, y3;\n\t\n\twhile (1) {\n\t\tx1 = in(), y1 = in(), x2 = in(), y2 = in(), x3 = in(), y3 = in();\n\t\tif (!(x1|y1|x2|y2|x3|y3)) break;\n\t\tmalfattiCircle(x1, y1, x2, y2, x3, y3);\n\t\tprintf(\"%.6lf %.6lf %.6lf\\n\", ra, rb, rc);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define PI 3.14159\n\ndouble length(int x1, int y1, int x2, int y2) {\n    double a = (double)abs(x2-x1);\n    double b = (double)abs(y2-y1);\n\n    return sqrt(a*a+b*b);\n}\ndouble radius(double A,double B,double C,double r) {\n    return (r*(1+tan(B/4))*(1+tan(C/4))/(2*(1+tan(A/4))));\n}\ndouble space(double a,double b,double c) {\n    //return (0.5*b*c*sin(a/b))/2;\n    double s;\n    s = (a+b+c)/2;\n    return sqrt(s*(s-a)*(s-b)*(s-c));\n}\ndouble height(double c,double S) {\n    return 2*(S/c);\n}\ndouble radian(double b,double h) {\n    return asin(h/b);\n}\ndouble naisetu_r(double a,double b,double c,double S) {\n    return 2*S/(a+b+c);\n}\n\nint main(void) {\n    int x[3];\n    int y[3];\n    int i,j;\n    double a,b,c;\n    double inst[3];\n    int max;\n    int num;\n    double r[3];\n    double A,B,C;\n    double h;\n    double S;\n\n    while(1) {\n        scanf(\"%d %d %d %d %d %d\",&x[0],&y[0],&x[1],&y[1],&x[2],&y[2]);\n        if(x[0] == 0 && y[0] == 0 && x[1] == 0 && y[1] == 0 && x[2] == 0 && y[2] == 0) break;\n\n        for(i=0;i<3;i++) {\n            if(i!=2) {\n                inst[i] = length(x[i],y[i],x[i+1],y[i+1]);\n            }\n            else inst[i] = length(x[i],y[i],x[0],y[0]);\n        }\n\n        max = 0;\n\n        for(i=0;i<3;i++) {\n            if(i==0 || max < inst[i]) {\n                max = inst[i];\n                num = i;\n            }\n        }\n\n        if(num == 2) {\n            c = inst[2];\n            a = inst[0];\n            b = inst[1];\n        }\n        else if(num == 1) {\n            c = inst[1];\n            a = inst[2];\n            b = inst[0];\n        }\n        else {\n            c = inst[0];\n            a = inst[1];\n            b = inst[2];\n        }\n        a = fabs(a);\n        b = fabs(b);\n        c = fabs(c);\n        //printf(\"(a,b,c)=(%f,%f,%f)\\n\",a,b,c);\n        S = space(a,b,c);\n        h = height(c,S);\n        A = radian(b,h);\n        B = radian(a,h);\n        C = PI-(A+B);\n        //printf(\"(S,h,A,B,C)=(%f,%f,%f,%f,%f)\\n\",S,h,A,B,C);\n        r[0] = radius(A,B,C,naisetu_r(a,b,c,S));\n        r[1] = radius(B,C,A,naisetu_r(a,b,c,S));\n        r[2] = radius(C,A,B,naisetu_r(a,b,c,S));            \n        if(num==2) {\n            printf(\"%f %f %f\\n\",r[0],r[1],r[2]);\n        }\n        else if(num==1) {\n            printf(\"%f %f %f\\n\",r[2],r[0],r[1]);\n        }\n        else printf(\"%f %f %f\\n\",r[1],r[2],r[0]);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Main{\n    void run() throws IOException{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        while(true){\n            String[] num = in.readLine().split(\" \",0);\n            int Ax = Integer.parseInt(num[0]);\n            int Ay = Integer.parseInt(num[1]);\n            int Bx = Integer.parseInt(num[2]);\n            int By = Integer.parseInt(num[3]);\n            int Cx = Integer.parseInt(num[4]);\n            int Cy = Integer.parseInt(num[5]);\n            if(Ax == 0 && Ay == 0 && Bx == 0 && By == 0 && Cx == 0 && Cy == 0)\n                break;\n            int AbecAx = Bx - Ax;\n            int AbecAy = By - Ay;\n            int AbecBx = Cx - Ax;\n            int AbecBy = Cy - Ay;\n            double A = Math.acos((AbecAx * AbecBx + AbecAy * AbecBy) / (Math.sqrt(AbecAx*AbecAx + AbecAy*AbecAy) * Math.sqrt(AbecBx*AbecBx + AbecBy*AbecBy)));\n            int BbecAx = Ax - Bx;\n            int BbecAy = Ay - By;\n            int BbecBx = Cx - Bx;\n            int BbecBy = Cy - By;\n            double B = Math.acos((BbecAx * BbecBx + BbecAy * BbecBy) / (Math.sqrt(BbecAx*BbecAx + BbecAy*BbecAy) * Math.sqrt(BbecBx*BbecBx + BbecBy*BbecBy)));\n            int CbecAx = Bx - Cx;\n            int CbecAy = By - Cy;\n            int CbecBx = Ax - Cx;\n            int CbecBy = Ay - Cy;\n            double C = Math.acos((CbecAx * CbecBx + CbecAy * CbecBy) / (Math.sqrt(CbecAx*CbecAx + CbecAy*CbecAy) * Math.sqrt(CbecBx*CbecBx + CbecBy*CbecBy)));\n            //????§????????????\\???\n            double henA = Math.sqrt((Bx - Ax)*(Bx - Ax)+(By - Ay)*(By - Ay));\n            double henB = Math.sqrt((Cx - Bx)*(Cx - Bx)+(Cy - By)*(Cy - By));\n            double henC = Math.sqrt((Ax - Cx)*(Ax - Cx)+(Ay - Cy)*(Ay - Cy));\n            double s = (henA + henB + henC)/2;\n            double S = Math.sqrt(s*(s-henA)*(s-henB)*(s-henC));\n            double r = S/s;\n            //System.out.println(\"r\"+r);\n\n            //r1????±???????\n            double r1 = (r*(1+Math.tan(B/4))*(1+Math.tan(C/4)))/(2*(1+Math.tan(A/4)));\n            System.out.print(r1+\" \");\n            double r2 = (r*(1+Math.tan(A/4))*(1+Math.tan(C/4)))/(2*(1+Math.tan(B/4)));\n            System.out.print(r2+\" \");\n            double r3 = (r*(1+Math.tan(B/4))*(1+Math.tan(A/4)))/(2*(1+Math.tan(C/4)));\n            System.out.print(r3);\n            System.out.println();\n        }\n\n    }\n    public static void main(String[] args) throws IOException{\n        Main ma = new Main();\n        ma.run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint x1 = scan.nextInt();\n\t\t\tint y1 = scan.nextInt();\n\t\t\tint x2 = scan.nextInt();\n\t\t\tint y2 = scan.nextInt();\n\t\t\tint x3 = scan.nextInt();\n\t\t\tint y3 = scan.nextInt();\n\t\t\tif(x1==0 && y1==0 && x2==0 && y2==0 && x3==0 && y3==0) break;\n\t\t\tdouble ab = Math.sqrt(Math.pow(x1-x2,2)+Math.pow(y1-y2,2));\n\t\t\tdouble bc = Math.sqrt(Math.pow(x2-x3,2)+Math.pow(y2-y3,2));\n\t\t\tdouble ca = Math.sqrt(Math.pow(x3-x1,2)+Math.pow(y3-y1,2));\n\t\t\tdouble s =  (ab+bc+ca)/2;\n\t\t\tdouble scale = Math.sqrt(s*(s-ab)*(s-bc)*(s-ca));\n\t\t\tdouble r = scale/s;\n\t\t\tdouble h=0;\n\t\t\tdouble arad=0;\n\t\t\tdouble brad=0; \n\t\t\tdouble crad=0;\n\t\t\tif(ab>=bc && ab>=ca){\n\t\t\t\th=2*(scale/ab);\n\t\t\t\tbrad = Math.asin(h/ca);\n\t\t\t\tcrad = Math.asin(h/bc);\n\t\t\t\tarad = Math.PI-(brad+crad);\n\t\t\t}\n\t\t\telse if(bc>=ab && bc>=ca){\n\t\t\t\th=2*(scale/bc);\n\t\t\t\tarad = Math.asin(h/ca);\n\t\t\t\tcrad = Math.asin(h/ab);\n\t\t\t\tbrad = Math.PI-(arad+crad);\n\t\t\t}\n\t\t\telse if(ca>=ab && ca>=bc){\n\t\t\t\th=2*(scale/ca);\n\t\t\t\tarad = Math.asin(h/bc);\n\t\t\t\tbrad = Math.asin(h/ab);\n\t\t\t\tcrad = Math.PI-(arad+brad);\n\t\t\t}\n\t\t\tdouble r1 = (r*(1+Math.tan(brad/4))*(1+Math.tan(crad/4)))/(2*(1+Math.tan(arad/4)));\n\t\t\tdouble r2 = (r*(1+Math.tan(arad/4))*(1+Math.tan(crad/4)))/(2*(1+Math.tan(brad/4)));\n\t\t\tdouble r3 = (r*(1+Math.tan(arad/4))*(1+Math.tan(brad/4)))/(2*(1+Math.tan(crad/4)));\n\t\t\t//System.out.println(ab+\":\"+bc+\":\"+ca);\n\t\t\t//System.out.println(\"S:\"+scale);\n\t\t\t//System.out.println(arad+\":\"+brad+\":\"+crad);\n\t\t\t//System.out.println(r);\n\t\t\tSystem.out.println(r2+\" \"+r3+\" \"+r1);\n\t\t}\n\t}\n\n    public static void main(String[] args){\n\t\tMain app = new Main();\n\t\tapp.run();\t\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;import java.math.*;public class Main{class P{double x;double y;P(double x,double y){this.x=x;this.y=y;}P add(P a){return new P(x+a.x,y+a.y);}P mul(double a){return new P(x*a,y*a);}double abs(){return Math.sqrt(x*x+y*y);}}Scanner sc=new Scanner(System.in);void run(){for(;;){P[]p=new P[3];double v=0;for (int i=0;i<3;i++){p[i]=new P(sc.nextDouble(),sc.nextDouble());v+=Math.abs(p[i].x)+Math.abs(p[i].y);}if(v<1){break;}P[]t=new P[3];double len[]=new double[3];for (int i=0;i<3;i++){P p1=p[(i+1)%3].add(p[i].mul(-1));P p2=p[(i+2)%3].add(p[i].mul(-1));double p1l=p1.abs();double p2l=p2.abs();P np1=p1.mul(1/p1l);P np2=p2.mul(1 / p2l);P tt=np1.add(np2);t[i]=tt.mul(1/tt.abs());len[i]=Math.min(p1.abs(),p2.abs());}double min=0;double max=len[0];P a[]=new P[3];double r[]=new double[3];for(;;){if(Math.abs(min-max)<1e-6) {break;}double p0=(min+max)/2;a[0]=t[0].mul(p0).add(p[0]);{P org=p[0].mul(-1);P a0=a[0].add(org);P p1 = p[1].add(org);\n\t\t\t\t\tdouble lp1 = p1.abs();\n\t\t\t\t\tP p1v = p1.mul(1 / lp1);\n\n\t\t\t\t\tdouble dot = a0.x * p1v.x + a0.y * p1v.y;\n\n\t\t\t\t\tr[0] = Math.sqrt(p0 * p0 - dot * dot);\n\t\t\t\t}\n\n\t\t\t\tdouble min1 = 0;\n\t\t\t\tdouble max1 = len[1];\n\t\t\t\tfor (;;) {if (Math.abs(min1 - max1) < 1e-6) {\nbreak;}\n\t\tdouble p1 = (min1 + max1) / 2;\n\t\t\t\t\ta[1] = t[1].mul(p1).add(p[1]);\n\n\t\t\t\t\t{\n\t\t\t\t\t\tP org = p[1].mul(-1);\n\n\t\t\t\t\t\tP a0 = a[1].add(org);\n\t\t\t\t\t\tP p2 = p[0].add(org);\n\t\t\t\t\t\tdouble lp1 = p2.abs();\n\t\t\t\t\t\tP p1v = p2.mul(1 / lp1);\n\n\t\t\t\t\t\tdouble dot = a0.x * p1v.x + a0.y * p1v.y;\n\n\t\t\t\t\t\tr[1] = Math.sqrt(p1 * p1 - dot * dot);\n\t\t\t\t\t}\n\n\n\t\t\t\t\tdouble diff = a[1].mul(-1).add(a[0]).abs();\n\n\t\t\t\t\tif (diff < r[1] + r[0]) {\n\t\t\t\t\t\tmax1 = p1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmin1 = p1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdouble min2 = 0;\n\t\t\t\tdouble max2 = len[2];\n\t\t\t\tfor (;;) {\n\t\t\t\t\tif (Math.abs(min2 - max2) < 1e-6) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdouble p1 = (min2 + max2) / 2;\n\t\t\t\t\ta[2] = t[2].mul(p1).add(p[2]);\n\n\t\t\t\t\t{\n\t\t\t\t\t\tP org = p[2].mul(-1);\n\n\t\t\t\t\t\tP a0 = a[2].add(org);\n\t\t\t\t\t\tP p2 = p[0].add(org);\n\t\t\t\t\t\tdouble lp1 = p2.abs();\n\t\t\t\t\t\tP p1v = p2.mul(1 / lp1);\n\n\t\t\t\t\t\tdouble dot = a0.x * p1v.x + a0.y * p1v.y;\n\n\t\t\t\t\t\tr[2] = Math.sqrt(p1 * p1 - dot * dot);\n\t\t\t\t\t}\n\n\t\t\t\t\tdouble diff = a[2].mul(-1).add(a[0]).abs();\n\n\t\t\t\t\tif (diff < r[2] + r[0]) {\n\t\t\t\t\t\tmax2 = p1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmin2 = p1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tdouble diff = a[2].mul(-1).add(a[1]).abs();\n\t\t\t\tif (diff > r[2] + r[1]) {\n\t\t\t\t\tmax = p0;\n\t\t\t\t\t// System.out.println(\" < \"+r[0]);\n\t\t\t\t} else {\n\t\t\t\t\tmin = p0;\n\t\t\t\t\t// System.out.println(\" > \"+r[0]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tSystem.out.println(r[0] + \" \" + r[1] + \" \" + r[2]);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint x1 = scan.nextInt();\n\t\t\tint y1 = scan.nextInt();\n\t\t\tint x2 = scan.nextInt();\n\t\t\tint y2 = scan.nextInt();\n\t\t\tint x3 = scan.nextInt();\n\t\t\tint y3 = scan.nextInt();\n\t\t\tif(x1==0 && y1==0 && x2==0 && y2==0 && x3==0 && y3==0) break;\n\t\t\tdouble ab = Math.sqrt(Math.pow(x1-x2,2)+Math.pow(y1-y2,2));\n\t\t\tdouble bc = Math.sqrt(Math.pow(x2-x3,2)+Math.pow(y2-y3,2));\n\t\t\tdouble ca = Math.sqrt(Math.pow(x3-x1,2)+Math.pow(y3-y1,2));\n\t\t\tdouble s =  (ab+bc+ca)/2;\n\t\t\tdouble scale = Math.sqrt(s*(s-ab)*(s-bc)*(s-ca));\n\t\t\tdouble r = scale/s;\n\t\t\tdouble h=0;\n\t\t\tdouble arad=0;\n\t\t\tdouble brad=0; \n\t\t\tdouble crad=0;\n\t\t\tif(ab>=bc && ab>=ca){\n\t\t\t\th=2*(scale/ab);\n\t\t\t\tbrad = Math.asin(h/ca);\n\t\t\t\tcrad = Math.asin(h/bc);\n\t\t\t\tarad = Math.PI-(brad+crad);\n\t\t\t}\n\t\t\telse if(bc>=ab && bc>=ca){\n\t\t\t\th=2*(scale/bc);\n\t\t\t\tarad = Math.asin(h/ca);\n\t\t\t\tcrad = Math.asin(h/ab);\n\t\t\t\tbrad = Math.PI-(arad+crad);\n\t\t\t}\n\t\t\telse if(ca>=ab && ca>=bc){\n\t\t\t\th=2*(scale/ca);\n\t\t\t\tarad = Math.asin(h/bc);\n\t\t\t\tbrad = Math.asin(h/ab);\n\t\t\t\tcrad = Math.PI-(arad+brad);\n\t\t\t}\n\t\t\t/*\n\t\t\tdouble arad = Math.atan(ab/bc);\n\t\t\tdouble brad = Math.atan(bc/ca);\n\t\t\tdouble crad = Math.atan(ca/ab);\n\t\t\t*/\n\t\t\tdouble r1 = (r*(1+Math.tan(brad/4))*(1+Math.tan(crad/4)))/(2*(1+Math.tan(arad/4)));\n\t\t\tdouble r2 = (r*(1+Math.tan(arad/4))*(1+Math.tan(crad/4)))/(2*(1+Math.tan(brad/4)));\n\t\t\tdouble r3 = (r*(1+Math.tan(arad/4))*(1+Math.tan(brad/4)))/(2*(1+Math.tan(crad/4)));\n\t\t\t//System.out.println(ab+\":\"+bc+\":\"+ca);\n\t\t\t//System.out.println(arad+\":\"+brad+\":\"+crad);\n\t\t\t//System.out.println(r);\n\t\t\tdouble[] array = new double[3];\n\t\t\tarray[0] = r1;\n\t\t\tarray[1] = r2;\n\t\t\tarray[2] = r3;\n\t\t\tArrays.sort(array);\n\t\t\tSystem.out.println(array[0]+\" \"+array[1]+\" \"+array[2]);\n\t\t}\n\t}\n\n    public static void main(String[] args){\n\t\tMain app = new Main();\n\t\tapp.run();\t\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Malfatti Circles\npublic class Main{\n\n\tfinal double EPS = 1e-9, EPS2 = 1e-6;\n\t\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a){\n\t\treturn Math.hypot(a[0], a[1]);\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tdouble angleTan(double[] a, double[] b){\n\t\treturn Math.atan2(cross(a, b), dot(a, b));\n\t}\n\tdouble angleCos(double[] a, double[] b){\n\t\tdouble na = norm(a), nb = norm(b);\n\t\treturn Math.acos(dot(a, b)/na/nb);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(Math.abs(cross(sub(b, a), sub(t, s)))<EPS){\n\t\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))))<EPS;\n\t\t}\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dist(double[] a, double[] b, double[] s, double[] t){\n\t\tif(crossing(a, b, s, t))return 0;\n\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))));\n\t}\n\tdouble distLP(double[] a, double[] b, double[] p){\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble[] cp(double[] a, double[] b, double[] s, double[] t){\n\t\tdouble ds = distLP(a, b, s), dt = distLP(a, b, t);\n\t\tdouble k = ds/(ds+dt);\n\t\tdouble[] d = sub(t, s);\n\t\treturn new double[]{s[0]+k*d[0], s[1]+k*d[1]};\n\t}\n\tdouble thita(double[] a, double[] b){\n\t\treturn Math.atan2(cross(a, b), dot(a, b));\n\t}\n\tdouble[][] circleCrossPoint(double x1, double y1, double r1, double x2, double y2, double r2){\n\t\tdouble x = x2-x1, y = y2-y1;\n\t\tdouble S = x*x+y*y;\n\t\tdouble A = (S+r1*r1-r2*r2)/2;\n\t\tdouble[][] res = new double[2][2];\n\t\tres[0][0] = (A*x+y*Math.sqrt(S*r1*r1-A*A))/S; res[0][1] = (A*y-x*Math.sqrt(S*r1*r1-A*A))/S;\n\t\tres[1][0] = (A*x-y*Math.sqrt(S*r1*r1-A*A))/S; res[1][1] = (A*y+x*Math.sqrt(S*r1*r1-A*A))/S;\n\t\treturn res;\n\t}\n\t\n\tdouble[][] p, d, q;\n\tdouble[] thita, CP, len, r;\n\t\n\tint check(double t){\n\t\tq[0][0] = p[0][0]+t*d[0][0];\n\t\tq[0][1] = p[0][1]+t*d[0][1];\n\t\tr[0] = dist(p[0], p[1], q[0]);\n\t\tdouble R2 = dist(p[1], p[2], q[0]);\n\t\tif(R2+EPS < r[0])return 1;\n\t\tsearch(1); search(2);\n\t\t//ここだけは緩めの許容誤差にしないと、いつまでたっても終わらない\n\t\tif(Math.abs(r[1]+r[2]-norm(q[1], q[2]))<EPS2)return 0;\n\t\treturn r[1]+r[2] < norm(q[1], q[2])?1:-1;\n\t}\n\t\n\tvoid search(int k){\n\t\tdouble L = 0, R = len[k];\n\t\tfor(int LOOP=0;LOOP<60&&R-L>EPS;LOOP++){\n\t\t\tdouble m = (L+R)/2;\n\t\t\tint c = checkSub(m, k);\n\t\t\tif(c==0)break;\n\t\t\tif(c<0)L = m;\n\t\t\telse R = m;\n\t\t}\n\t}\n\t\n\tint checkSub(double t, int k){\n\t\tq[k][0] = p[k][0]+t*d[k][0];\n\t\tq[k][1] = p[k][1]+t*d[k][1];\n\t\tr[k] = dist(p[k], p[(k+1)%3], q[k]);\n\t\tif(t < EPS)return -1;\n\t\tif(Math.abs(t-len[k])<EPS)return 1;\n\t\tdouble RK = dist(p[(k+1)%3], p[(k+2)%3], q[k]);\n\t\tif(RK+EPS < r[k])return 1;\n\t\tif(Math.abs(r[0]+r[k]-norm(q[0], q[k]))<EPS)return 0;\n\t\treturn r[0]+r[k] < norm(q[0], q[k])?-1:1;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint X1 = sc.nextInt(), Y1 = sc.nextInt(), X2 = sc.nextInt(), Y2 = sc.nextInt(), X3 = sc.nextInt(), Y3 = sc.nextInt();\n\t\t\tif((X1|Y1|X2|Y2|X3|Y3)==0)break;\n\t\t\tp = new double[][]{{X1, Y1},{X2, Y2}, {X3, Y3}};\n\t\t\tthita = new double[3];\n\t\t\td = new double[3][2];\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tdouble[] subs = sub(p[(i+1)%3], p[i]), subt = sub(p[(i+2)%3], p[i]);\n\t\t\t\tdouble thita = angleTan(subs, subt)/2;\n\t\t\t\td[i][0] = Math.cos(thita)*subs[0]-Math.sin(thita)*subs[1];\n\t\t\t\td[i][1] = Math.sin(thita)*subs[0]+Math.cos(thita)*subs[1];\n\t\t\t\tdouble D = norm(d[i]);\n\t\t\t\td[i][0]/=D; d[i][1]/=D;\n\t\t\t}\n\t\t\tdouble[] A = p[0], B = {p[0][0]+10000*d[0][0], p[0][1]+10000*d[0][1]}, C = p[1], D = {p[1][0]+10000*d[1][0], p[1][1]+10000*d[1][1]};\n\t\t\tCP = cp(A, B, C, D);\n\t\t\tlen = new double[3];\n\t\t\tfor(int i=0;i<3;i++)len[i] = norm(p[i], CP);\n\t\t\tq = new double[3][2];\n\t\t\tr = new double[3];\n\t\t\tdouble L = 0, R = len[0];\n\t\t\tfor(;;){\n\t\t\t\tdouble m = (L+R)/2;\n\t\t\t\tint c = check(m);\n\t\t\t\tif(c==0)break;\n\t\t\t\tif(c<0)L = m;\n\t\t\t\telse R = m;\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.6f %.6f %.6f\\n\", r[0], r[1], r[2]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint x1 = scan.nextInt();\n\t\t\tint y1 = scan.nextInt();\n\t\t\tint x2 = scan.nextInt();\n\t\t\tint y2 = scan.nextInt();\n\t\t\tint x3 = scan.nextInt();\n\t\t\tint y3 = scan.nextInt();\n\t\t\tif(x1==0 && y1==0 && x2==0 && y2==0 && x3==0 && y3==0) break;\n\t\t\tdouble ab = Math.sqrt(Math.pow(x1-x2,2)+Math.pow(y1-y2,2));\n\t\t\tdouble bc = Math.sqrt(Math.pow(x2-x3,2)+Math.pow(y2-y3,2));\n\t\t\tdouble ca = Math.sqrt(Math.pow(x3-x1,2)+Math.pow(y3-y1,2));\n\t\t\tdouble s =  (ab+bc+ca)/2;\n\t\t\tdouble scale = Math.sqrt(s*(s-ab)*(s-bc)*(s-ca));\n\t\t\tdouble r = scale/s;\n\t\t\tdouble h=0;\n\t\t\tdouble arad=0;\n\t\t\tdouble brad=0; \n\t\t\tdouble crad=0;\n\t\t\tif(ab>=bc && ab>=ca){\n\t\t\t\th=2*(scale/ab);\n\t\t\t\tbrad = Math.asin(h/ca);\n\t\t\t\tcrad = Math.asin(h/bc);\n\t\t\t\tarad = Math.PI-(brad+crad);\n\t\t\t}\n\t\t\telse if(bc>=ab && bc>=ca){\n\t\t\t\th=2*(scale/bc);\n\t\t\t\tarad = Math.asin(h/ca);\n\t\t\t\tcrad = Math.asin(h/ab);\n\t\t\t\tbrad = Math.PI-(arad+crad);\n\t\t\t}\n\t\t\telse if(ca>=ab && ca>=bc){\n\t\t\t\th=2*(scale/ca);\n\t\t\t\tarad = Math.asin(h/bc);\n\t\t\t\tbrad = Math.asin(h/ab);\n\t\t\t\tcrad = Math.PI-(arad+brad);\n\t\t\t}\n\t\t\t/*\n\t\t\tdouble arad = Math.atan(ab/bc);\n\t\t\tdouble brad = Math.atan(bc/ca);\n\t\t\tdouble crad = Math.atan(ca/ab);\n\t\t\t*/\n\t\t\tdouble r1 = (r*(1+Math.tan(brad/4))*(1+Math.tan(crad/4)))/(2*(1+Math.tan(arad/4)));\n\t\t\tdouble r2 = (r*(1+Math.tan(arad/4))*(1+Math.tan(crad/4)))/(2*(1+Math.tan(brad/4)));\n\t\t\tdouble r3 = (r*(1+Math.tan(arad/4))*(1+Math.tan(brad/4)))/(2*(1+Math.tan(crad/4)));\n\t\t\t//System.out.println(ab+\":\"+bc+\":\"+ca);\n\t\t\t//System.out.println(arad+\":\"+brad+\":\"+crad);\n\t\t\t//System.out.println(r);\n\t\t\t/*\n\t\t\tdouble[] array = new double[3];\n\t\t\tarray[0] = r1;\n\t\t\tarray[1] = r2;\n\t\t\tarray[2] = r3;\n\t\t\tArrays.sort(array);\n\t\t\tSystem.out.println(array[0]+\" \"+array[1]+\" \"+array[2]);\n\t\t\t*/\n\t\t\tSystem.out.println(r2+\" \"+r3+\" \"+r1);\n\t\t}\n\t}\n\n    public static void main(String[] args){\n\t\tMain app = new Main();\n\t\tapp.run();\t\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tclass P {\n\t\tdouble x;\n\t\tdouble y;\n\n\t\tP(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tP add(P a) {\n\t\t\treturn new P(x + a.x, y + a.y);\n\t\t}\n\n\t\tP mul(double a) {\n\t\t\treturn new P(x * a, y * a);\n\t\t}\n\n\t\tdouble abs() {\n\t\t\treturn Math.sqrt(x * x + y * y);\n\t\t}\n\t}\n\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tP[] p = new P[3];\n\t\t\tdouble v = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tp[i] = new P(sc.nextDouble(), sc.nextDouble());\n\t\t\t\tv += Math.abs(p[i].x) + Math.abs(p[i].y);\n\t\t\t}\n\t\t\tif (v < 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tP[] t = new P[3];\n\t\t\tdouble len[] = new double[3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tP p1 = p[(i + 1) % 3].add(p[i].mul(-1));\n\t\t\t\tP p2 = p[(i + 2) % 3].add(p[i].mul(-1));\n\t\t\t\tdouble p1l = p1.abs();\n\t\t\t\tdouble p2l = p2.abs();\n\t\t\t\tP np1 = p1.mul(1 / p1l);\n\t\t\t\tP np2 = p2.mul(1 / p2l);\n\n\t\t\t\tP tt = np1.add(np2);\n\t\t\t\tt[i] = tt.mul(1 / tt.abs());\n\t\t\t\t// t[i] = np1.add(np2).mul(0.5);\n\n\t\t\t\tlen[i] = Math.min(p1.abs(),\n\t\t\t\t\t\tp2.abs());\n\n\t\t\t}\n\n\t\t\tdouble min = 0;\n\t\t\tdouble max = len[0];\n\t\t\t// double max = t[0].add(p[0].mul(-1)).abs();\n\n\t\t\tP a[] = new P[3];\n\t\t\tdouble r[] = new double[3];\n\n\t\t\tfor (;;) {\n\t\t\t\t// System.out.println(min+\" \"+max);\n\t\t\t\tif (Math.abs(min - max) < 1e-6) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tdouble p0 = (min + max) / 2;\n\n\t\t\t\ta[0] = t[0].mul(p0).add(p[0]);\n\n\t\t\t\t{\n\t\t\t\t\tP org = p[0].mul(-1);\n\n\t\t\t\t\tP a0 = a[0].add(org);\n\t\t\t\t\tP p1 = p[1].add(org);\n\t\t\t\t\tdouble lp1 = p1.abs();\n\t\t\t\t\tP p1v = p1.mul(1 / lp1);\n\n\t\t\t\t\tdouble dot = a0.x * p1v.x + a0.y * p1v.y;\n\n\t\t\t\t\t// System.out.println(\"dot\"+dot);\n\t\t\t\t\tr[0] = Math.sqrt(p0 * p0 - dot * dot);\n\t\t\t\t}\n\t\t\t\t// System.out.println(a[0].x + \" _81_ \"+a[0].y + \" \"+ r[0]);\n\n\t\t\t\tdouble min1 = 0;\n\t\t\t\tdouble max1 = len[1];\n\t\t\t\tfor (;;) {\n\t\t\t\t\tif (Math.abs(min1 - max1) < 1e-6) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdouble p1 = (min1 + max1) / 2;\n\t\t\t\t\ta[1] = t[1].mul(p1).add(p[1]);\n\n\t\t\t\t\t{\n\t\t\t\t\t\tP org = p[1].mul(-1);\n\n\t\t\t\t\t\tP a0 = a[1].add(org);\n\t\t\t\t\t\tP p2 = p[0].add(org);\n\t\t\t\t\t\tdouble lp1 = p2.abs();\n\t\t\t\t\t\tP p1v = p2.mul(1 / lp1);\n\n\t\t\t\t\t\tdouble dot = a0.x * p1v.x + a0.y * p1v.y;\n\n\t\t\t\t\t\tr[1] = Math.sqrt(p1 * p1 - dot * dot);\n\t\t\t\t\t}\n\n\t\t\t\t\t// System.out.println(a[1].x + \" _105_ \"+a[1].y + \" \"+\n\t\t\t\t\t// r[1]);\n\n\t\t\t\t\tdouble diff = a[1].mul(-1).add(a[0]).abs();\n\n\t\t\t\t\tif (diff < r[1] + r[0]) {\n\t\t\t\t\t\tmax1 = p1;\n\t\t\t\t\t\t// System.out.println(\"m1\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmin1 = p1;\n\t\t\t\t\t\t// System.out.println(\"m2\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdouble min2 = 0;\n\t\t\t\tdouble max2 = len[2];\n\t\t\t\tfor (;;) {\n\t\t\t\t\tif (Math.abs(min2 - max2) < 1e-6) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdouble p1 = (min2 + max2) / 2;\n\t\t\t\t\ta[2] = t[2].mul(p1).add(p[2]);\n\n\t\t\t\t\t{\n\t\t\t\t\t\tP org = p[2].mul(-1);\n\n\t\t\t\t\t\tP a0 = a[2].add(org);\n\t\t\t\t\t\tP p2 = p[0].add(org);\n\t\t\t\t\t\tdouble lp1 = p2.abs();\n\t\t\t\t\t\tP p1v = p2.mul(1 / lp1);\n\n\t\t\t\t\t\tdouble dot = a0.x * p1v.x + a0.y * p1v.y;\n\n\t\t\t\t\t\tr[2] = Math.sqrt(p1 * p1 - dot * dot);\n\t\t\t\t\t}\n\t\t\t\t\t// System.out.println(a[2].x + \" _139_ \"+a[2].y + \" \"+\n\t\t\t\t\t// r[2]);\n\n\t\t\t\t\tdouble diff = a[2].mul(-1).add(a[0]).abs();\n\n\t\t\t\t\tif (diff < r[2] + r[0]) {\n\t\t\t\t\t\tmax2 = p1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmin2 = p1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// System.out.println(a[1].mul(-1).add(a[0]).abs() +\n\t\t\t\t// \" \"+r[1]+\" \"+r[0]);\n\n\t\t\t\t{\n\t\t\t\t\tP p1 = a[0];\n\t\t\t\t\tP p2 = p[0];\n\t\t\t\t\tP p3 = a[1];\n\t\t\t\t\tP p4 = a[2];\n\t\t\t\t\t{\n\t\t\t\t\t\tP org = p3.mul(-1);\n\t\t\t\t\t\tp1 = p1.add(org);\n\t\t\t\t\t\tp2 = p2.add(org);\n\n\t\t\t\t\t\tp4 = p4.add(org);\n\n\t\t\t\t\t\tdouble a1 = -p1.x * p4.y + p1.y * p4.x;\n\t\t\t\t\t\tdouble a2 = -p2.x * p4.y + p2.y * p4.x;\n\t\t\t\t\t\tif (a1 * a2 < 0) {\n\t\t\t\t\t//\t\tSystem.err.println(\"here\");\n\t\t\t\t\t\t//\tmax = p0;\n\t\t\t\t\t\t\t//continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdouble diff = a[2].mul(-1).add(a[1]).abs();\n\t\t\t\t// System.out.println(\" a \"+diff);\n\t\t\t\tif (diff > r[2] + r[1]) {\n\t\t\t\t\tmax = p0;\n\t\t\t\t\t// System.out.println(\" < \"+r[0]);\n\t\t\t\t} else {\n\t\t\t\t\tmin = p0;\n\t\t\t\t\t// System.out.println(\" > \"+r[0]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; i++) {\n//\t\t\t\tSystem.out.println(\"x:\" + a[i].x + \" y:\" + a[i].y + \" r:\"\n\t//\t\t\t\t\t+ r[i]);\n\t\t\t}\n\t\t//\tArrays.sort(r);\n\t\t\tSystem.out.println(r[0] + \" \" + r[1] + \" \" + r[2]);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Malfatti Circles\npublic class Main{\n\n\tfinal double EPS = 1e-10;\n\tdouble[] BASE = {0, 1};\n\t\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a){\n\t\treturn Math.hypot(a[0], a[1]);\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tdouble angleTan(double[] a, double[] b){\n\t\treturn Math.atan2(cross(a, b), dot(a, b));\n\t}\n\tdouble angleCos(double[] a, double[] b){\n\t\tdouble na = norm(a), nb = norm(b);\n\t\treturn Math.acos(dot(a, b)/na/nb);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\t//A-B, S-Tが共に平行の場合、2線分間の距離が0か否かで交差を判定する\n\t\tif(Math.abs(cross(sub(b, a), sub(t, s)))<EPS){\n\t\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))))<EPS;\n\t\t}\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t\t//ここでex(,,)*ex(,,)<EPSとすると、(0,0)(1,0)-(2,0)(3.0)のような一直線に並んでいて交差していないものもtrueとなってしまう\n\t\t//→平行な場合は先頭のif文内で処理するようになった\n\t}\n\t//Segment a-b Point p\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\t//Segment a-b Segment s-t\n\tdouble dist(double[] a, double[] b, double[] s, double[] t){\n\t\tif(crossing(a, b, s, t))return 0;\n\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))));\n\t}\n\t//Line a-b Point p\n\tdouble distLP(double[] a, double[] b, double[] p){\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\t//TODO verify\n\tdouble[] cp(double[] a, double[] b, double[] s, double[] t){\n\t\tdouble ds = distLP(a, b, s), dt = distLP(a, b, t);\n\t\tdouble k = ds/(ds+dt);\n\t\tdouble[] d = sub(t, s);\n\t\treturn new double[]{s[0]+k*d[0], s[1]+k*d[1]};\n\t}\n\t//TODO verify\n\tdouble thita(double[] a, double[] b){\n\t\treturn Math.atan2(cross(a, b), dot(a, b));\n\t}\n\t//TODO verify\n\tdouble[][] circleCrossPoint(double x1, double y1, double r1, double x2, double y2, double r2){\n\t\tdouble x = x2-x1, y = y2-y1;\n\t\tdouble S = x*x+y*y;\n\t\tdouble A = (S+r1*r1-r2*r2)/2;\n\t\tdouble[][] res = new double[2][2];\n\t\tres[0][0] = (A*x+y*Math.sqrt(S*r1*r1-A*A))/S; res[0][1] = (A*y-x*Math.sqrt(S*r1*r1-A*A))/S;\n\t\tres[1][0] = (A*x-y*Math.sqrt(S*r1*r1-A*A))/S; res[1][1] = (A*y+x*Math.sqrt(S*r1*r1-A*A))/S;\n\t\treturn res;\n\t}\n\t\n\tdouble[][] p, d, q;\n\tdouble[] thita, CP, len, r;\n\t\n\tint check(double t){\n\t\tq[0][0] = p[0][0]+t*d[0][0];\n\t\tq[0][1] = p[0][1]+t*d[0][1];\n\t\tr[0] = dist(p[0], p[1], q[0]);\n\t\tdouble R2 = dist(p[1], p[2], q[0]);\n\t\tif(R2+EPS < r[0])return 1;\n//\t\tSystem.out.println(\"r[0]: \"+r[0]+\" R2:\"+R2);\n\t\tsearch(1); search(2);\n//\t\tSystem.out.println(\"Q1 \"+q[1][0]+\",\"+q[1][1]+\" R:\"+r[1]);\n//\t\tSystem.out.println(\"Q2 \"+q[2][0]+\",\"+q[2][1]+\" R:\"+r[2]);\n//\t\tSystem.out.println(\"NORM : \" + norm(q[1], q[2]));\n\t\tif(Math.abs(r[1]+r[2]-norm(q[1], q[2]))<EPS)return 0;\n\t\treturn r[1]+r[2] < norm(q[1], q[2])?1:-1;\n\t}\n\t\n\tvoid search(int k){\n\t\tdouble L = 0, R = len[k];\n\t\tfor(;R-L>EPS;){\n\t\t\tdouble m = (L+R)/2;\n\t\t\tint c = checkSub(m, k);\n//\t\t\tSystem.out.println(\"Search C:\"+c+\" K:\"+k+\" L:\"+L+\" R:\"+R);\n\t\t\tif(c==0){\n//\t\t\t\tSystem.out.println(\"C==0**************************************************************\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(c<0)L = m;\n\t\t\telse R = m;\n\t\t}\n\t}\n\t\n\tint checkSub(double t, int k){\n\t\tq[k][0] = p[k][0]+t*d[k][0];\n\t\tq[k][1] = p[k][1]+t*d[k][1];\n//\t\tSystem.out.println(\"Q0: \"+q[0][0]+\",\"+q[0][1]);\n//\t\tSystem.out.println(\"Q K:\"+k+\" \"+q[k][0]+\",\"+q[k][1]);\n\t\tr[k] = dist(p[k], p[(k+1)%3], q[k]);\n\t\tif(t < EPS)return -1;\n\t\tif(Math.abs(t-len[k])<EPS)return 1;\n//\t\tdouble RK = dist(p[(k+1)%3], p[(k+2)%3], q[k]);\n//\t\tif(RK+EPS < r[k])return 1;\n//\t\tSystem.out.println(\"T:\"+t+\" K:\"+k+\" R[k]:\"+r[k]);\n//\t\tSystem.out.println(\"r[0]+r[k]: \"+(r[0]+r[k]));\n//\t\tSystem.out.println(\"NORM:\"+norm(q[0], q[k]));\n\t\tif(Math.abs(r[0]+r[k]-norm(q[0], q[k]))<EPS)return 0;\n\t\treturn r[0]+r[k] < norm(q[0], q[k])?-1:1;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint X1 = sc.nextInt(), Y1 = sc.nextInt(), X2 = sc.nextInt(), Y2 = sc.nextInt(), X3 = sc.nextInt(), Y3 = sc.nextInt();\n\t\t\tif((X1|Y1|X2|Y2|X3|Y3)==0)break;\n\t\t\tp = new double[][]{{X1, Y1},{X2, Y2}, {X3, Y3}};\n\t\t\tthita = new double[3];\n\t\t\td = new double[3][2];\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tdouble[] subs = sub(p[(i+1)%3], p[i]), subt = sub(p[(i+2)%3], p[i]);\n\t\t\t\tdouble thita = angleTan(subs, subt)/2;\n//\t\t\t\tSystem.out.println(thita*180/Math.PI);\n\t\t\t\t\n//\t\t\t\tdouble t1 = angleTan(BASE, sub(p[(i+1)%3], p[i])), t2 = angleTan(BASE, sub(p[(i+2)%3], p[i]));\n//\t\t\t\tSystem.out.println(t1*180/Math.PI+\" \"+t2*180/Math.PI);\n//\t\t\t\tdouble t = (t1+t2)/2;\n//\t\t\t\tif(t<0)t+=2*Math.PI;\n//\t\t\t\tSystem.out.println(t*180/Math.PI);\n\t\t\t\td[i][0] = Math.cos(thita)*subs[0]-Math.sin(thita)*subs[1];\n\t\t\t\td[i][1] = Math.sin(thita)*subs[0]+Math.cos(thita)*subs[1];\n//\t\t\t\td[i][0] = -Math.sin(t); d[i][1] = Math.cos(t);\n\t\t\t\tdouble D = norm(d[i]);\n\t\t\t\td[i][0]/=D; d[i][1]/=D;\n//\t\t\t\tSystem.out.println(\"D:\"+d[i][0]+\",\"+d[i][1]);\n\t\t\t}\n\t\t\tdouble[] A = p[0], B = {p[0][0]+10000*d[0][0], p[0][1]+10000*d[0][1]}, C = p[1], D = {p[1][0]+10000*d[1][0], p[1][1]+10000*d[1][1]};\n//\t\t\tdouble[] cpp = cp(A, B, p[1], p[2]);\n//\t\t\tSystem.out.println(cpp[0]+\",\"+cpp[1]+\" CPP\");\n\t\t\tCP = cp(A, B, C, D);\n//\t\t\tSystem.out.println(\"ABCD\");\n//\t\t\tSystem.out.println(A[0]+\",\"+A[1]+\" - \"+B[0]+\",\"+B[1]);\n//\t\t\tSystem.out.println(C[0]+\",\"+C[1]+\" - \"+D[0]+\",\"+D[1]);\n//\t\t\tCP = cp(p[0], new double[]{p[0][0]+10000*d[0][0], p[0][1]+10000*d[0][1]}, p[1], new double[]{p[1][0]+10000*d[1][0], p[1][1]+10000*d[1][1]});\n\t\t\tlen = new double[3];\n\t\t\tlen[0] = norm(p[0], CP);\n\t\t\tlen[1] = norm(p[1], cp(p[0], p[2], p[1], new double[]{p[1][0]+10000*d[1][0], p[1][1]+10000*d[1][1]}));\n//\t\t\tdouble[] CPP =  cp(p[0], p[2], p[1], new double[]{p[1][0]+10000*d[1][0], p[1][1]+10000*d[1][0]});\n//\t\t\tdouble[] CPP = cp(p[0], p[1], p[2], new double[]{p[2][0]+10000*d[2][0], p[2][1]+10000*d[2][1]});\n//\t\t\tSystem.out.println(CPP[0]+\", \"+CPP[1]+\" CPPPP\");\n\t\t\tlen[2] = norm(p[2], cp(p[1], p[0], p[2], new double[]{p[2][0]+10000*d[2][0], p[2][1]+10000*d[2][1]}));\n//\t\t\tSystem.out.println(\"CrossPoint: \"+CP[0]+\",\"+CP[1]);\n//\t\t\tSystem.out.println(len[0]+\",\"+len[1]+\",\"+len[2]);\n\t\t\tq = new double[3][2];\n\t\t\tr = new double[3];\n\t\t\tdouble L = 0, R = len[0];\n\t\t\tfor(;;){\n\t\t\t\tdouble m = (L+R)/2;\n\t\t\t\tint c = check(m);\n//\t\t\t\tSystem.out.println(\"RES C:\"+c+\" Q[0] \"+q[0][0]+\",\"+q[0][1]+\" R:\"+r[0]);\n\t\t\t\tif(c==0)break;\n\t\t\t\tif(c<0)L = m;\n\t\t\t\telse R = m;\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.6f %.6f %.6f\\n\", r[0], r[1], r[2]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Main{\n    void run() throws IOException{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        while(true){\n            String[] num = in.readLine().split(\" \",0);\n            int Ax = Integer.parseInt(num[0]);\n            int Ay = Integer.parseInt(num[1]);\n            int Bx = Integer.parseInt(num[2]);\n            int By = Integer.parseInt(num[3]);\n            int Cx = Integer.parseInt(num[4]);\n            int Cy = Integer.parseInt(num[5]);\n            int AbecAx = Bx - Ax;\n            int AbecAy = By - Ay;\n            int AbecBx = Cx - Ax;\n            int AbecBy = Cy - Ay;\n            double A = Math.acos((AbecAx * AbecBx + AbecAy * AbecBy) / (Math.sqrt(AbecAx*AbecAx + AbecAy*AbecAy) * Math.sqrt(AbecBx*AbecBx + AbecBy*AbecBy)));\n            int BbecAx = Ax - Bx;\n            int BbecAy = Ay - By;\n            int BbecBx = Cx - Bx;\n            int BbecBy = Cy - By;\n            double B = Math.acos((BbecAx * BbecBx + BbecAy * BbecBy) / (Math.sqrt(BbecAx*BbecAx + BbecAy*BbecAy) * Math.sqrt(BbecBx*BbecBx + BbecBy*BbecBy)));\n            int CbecAx = Bx - Cx;\n            int CbecAy = By - Cy;\n            int CbecBx = Ax - Cx;\n            int CbecBy = Ay - Cy;\n            double C = Math.acos((CbecAx * CbecBx + CbecAy * CbecBy) / (Math.sqrt(CbecAx*CbecAx + CbecAy*CbecAy) * Math.sqrt(CbecBx*CbecBx + CbecBy*CbecBy)));\n            //????§????????????\\???\n            double henA = Math.sqrt((Bx - Ax)*(Bx - Ax)+(By - Ay)*(By - Ay));\n            double henB = Math.sqrt((Cx - Bx)*(Cx - Bx)+(Cy - By)*(Cy - By));\n            double henC = Math.sqrt((Ax - Cx)*(Ax - Cx)+(Ay - Cy)*(Ay - Cy));\n            double s = (henA + henB + henC)/2;\n            double S = Math.sqrt(s*(s-henA)*(s-henB)*(s-henC));\n            double r = S/s;\n            //System.out.println(\"r\"+r);\n\n            //r1????±???????\n            double r1 = (r*(1+Math.tan(B/4))*(1+Math.tan(C/4)))/(2*(1+Math.tan(A/4)));\n            System.out.print(r1+\" \");\n            double r2 = (r*(1+Math.tan(A/4))*(1+Math.tan(C/4)))/(2*(1+Math.tan(B/4)));\n            System.out.print(r2+\" \");\n            double r3 = (r*(1+Math.tan(B/4))*(1+Math.tan(A/4)))/(2*(1+Math.tan(C/4)));\n            System.out.print(r3);\n            System.out.println();\n        }\n\n    }\n    public static void main(String[] args) throws IOException{\n        Main ma = new Main();\n        ma.run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Malfatti Circles\npublic class Main{\n\n\tfinal double EPS = 1e-9, EPS2 = 1e-6;\n\t\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a){\n\t\treturn Math.hypot(a[0], a[1]);\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tdouble angleTan(double[] a, double[] b){\n\t\treturn Math.atan2(cross(a, b), dot(a, b));\n\t}\n\tdouble angleCos(double[] a, double[] b){\n\t\tdouble na = norm(a), nb = norm(b);\n\t\treturn Math.acos(dot(a, b)/na/nb);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\t//A-B, S-Tが共に平行の場合、2線分間の距離が0か否かで交差を判定する\n\t\tif(Math.abs(cross(sub(b, a), sub(t, s)))<EPS){\n\t\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))))<EPS;\n\t\t}\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t\t//ここでex(,,)*ex(,,)<EPSとすると、(0,0)(1,0)-(2,0)(3.0)のような一直線に並んでいて交差していないものもtrueとなってしまう\n\t\t//→平行な場合は先頭のif文内で処理するようになった\n\t}\n\t//Segment a-b Point p\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\t//Segment a-b Segment s-t\n\tdouble dist(double[] a, double[] b, double[] s, double[] t){\n\t\tif(crossing(a, b, s, t))return 0;\n\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))));\n\t}\n\t//Line a-b Point p\n\tdouble distLP(double[] a, double[] b, double[] p){\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\t//TODO verify\n\tdouble[] cp(double[] a, double[] b, double[] s, double[] t){\n\t\tdouble ds = distLP(a, b, s), dt = distLP(a, b, t);\n\t\tdouble k = ds/(ds+dt);\n\t\tdouble[] d = sub(t, s);\n\t\treturn new double[]{s[0]+k*d[0], s[1]+k*d[1]};\n\t}\n\t//TODO verify\n\tdouble thita(double[] a, double[] b){\n\t\treturn Math.atan2(cross(a, b), dot(a, b));\n\t}\n\t//TODO verify\n\tdouble[][] circleCrossPoint(double x1, double y1, double r1, double x2, double y2, double r2){\n\t\tdouble x = x2-x1, y = y2-y1;\n\t\tdouble S = x*x+y*y;\n\t\tdouble A = (S+r1*r1-r2*r2)/2;\n\t\tdouble[][] res = new double[2][2];\n\t\tres[0][0] = (A*x+y*Math.sqrt(S*r1*r1-A*A))/S; res[0][1] = (A*y-x*Math.sqrt(S*r1*r1-A*A))/S;\n\t\tres[1][0] = (A*x-y*Math.sqrt(S*r1*r1-A*A))/S; res[1][1] = (A*y+x*Math.sqrt(S*r1*r1-A*A))/S;\n\t\treturn res;\n\t}\n\t\n\tdouble[][] p, d, q;\n\tdouble[] thita, CP, len, r;\n\t\n\tint check(double t){\n\t\tq[0][0] = p[0][0]+t*d[0][0];\n\t\tq[0][1] = p[0][1]+t*d[0][1];\n\t\tr[0] = dist(p[0], p[1], q[0]);\n\t\tdouble R2 = dist(p[1], p[2], q[0]);\n\t\tif(R2+EPS < r[0])return 1;\n//\t\tSystem.out.println(\"r[0]: \"+r[0]+\" R2:\"+R2);\n\t\tsearch(1); search(2);\n//\t\tSystem.out.println(\"Q1 \"+q[1][0]+\",\"+q[1][1]+\" R:\"+r[1]);\n//\t\tSystem.out.println(\"Q2 \"+q[2][0]+\",\"+q[2][1]+\" R:\"+r[2]);\n//\t\tSystem.out.println(\"NORM : \" + norm(q[1], q[2]));\n\t\tif(Math.abs(r[1]+r[2]-norm(q[1], q[2]))<EPS2)return 0;\n\t\treturn r[1]+r[2] < norm(q[1], q[2])?1:-1;\n\t}\n\t\n\tvoid search(int k){\n\t\tdouble L = 0, R = len[k];\n\t\tfor(int LOOP=0;LOOP<80&&R-L>EPS;LOOP++){\n\t\t\tdouble m = (L+R)/2;\n\t\t\tint c = checkSub(m, k);\n//\t\t\tSystem.out.println(\"Search C:\"+c+\" K:\"+k+\" L:\"+L+\" R:\"+R);\n\t\t\tif(c==0){\n//\t\t\t\tSystem.out.println(\"C==0**************************************************************\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(c<0)L = m;\n\t\t\telse R = m;\n\t\t}\n\t}\n\t\n\tint checkSub(double t, int k){\n\t\tq[k][0] = p[k][0]+t*d[k][0];\n\t\tq[k][1] = p[k][1]+t*d[k][1];\n//\t\tSystem.out.println(\"Q0: \"+q[0][0]+\",\"+q[0][1]);\n//\t\tSystem.out.println(\"Q K:\"+k+\" \"+q[k][0]+\",\"+q[k][1]);\n\t\tr[k] = dist(p[k], p[(k+1)%3], q[k]);\n\t\tif(t < EPS)return -1;\n\t\tif(Math.abs(t-len[k])<EPS)return 1;\n\t\tdouble RK = dist(p[(k+1)%3], p[(k+2)%3], q[k]);\n\t\tif(RK+EPS < r[k])return 1;\n//\t\tSystem.out.println(\"T:\"+t+\" K:\"+k+\" R[k]:\"+r[k]);\n//\t\tSystem.out.println(\"r[0]+r[k]: \"+(r[0]+r[k]));\n//\t\tSystem.out.println(\"NORM:\"+norm(q[0], q[k]));\n\t\tif(Math.abs(r[0]+r[k]-norm(q[0], q[k]))<EPS)return 0;\n\t\treturn r[0]+r[k] < norm(q[0], q[k])?-1:1;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint X1 = sc.nextInt(), Y1 = sc.nextInt(), X2 = sc.nextInt(), Y2 = sc.nextInt(), X3 = sc.nextInt(), Y3 = sc.nextInt();\n\t\t\tif((X1|Y1|X2|Y2|X3|Y3)==0)break;\n\t\t\tp = new double[][]{{X1, Y1},{X2, Y2}, {X3, Y3}};\n\t\t\tthita = new double[3];\n\t\t\td = new double[3][2];\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tdouble[] subs = sub(p[(i+1)%3], p[i]), subt = sub(p[(i+2)%3], p[i]);\n\t\t\t\tdouble thita = angleTan(subs, subt)/2;\n//\t\t\t\tSystem.out.println(thita*180/Math.PI);\n\t\t\t\td[i][0] = Math.cos(thita)*subs[0]-Math.sin(thita)*subs[1];\n\t\t\t\td[i][1] = Math.sin(thita)*subs[0]+Math.cos(thita)*subs[1];\n\t\t\t\tdouble D = norm(d[i]);\n\t\t\t\td[i][0]/=D; d[i][1]/=D;\n//\t\t\t\tSystem.out.println(\"D:\"+d[i][0]+\",\"+d[i][1]);\n\t\t\t}\n\t\t\tdouble[] A = p[0], B = {p[0][0]+10000*d[0][0], p[0][1]+10000*d[0][1]}, C = p[1], D = {p[1][0]+10000*d[1][0], p[1][1]+10000*d[1][1]};\n\t\t\tCP = cp(A, B, C, D);\n\t\t\tlen = new double[3];\n\t\t\tfor(int i=0;i<3;i++)len[i] = norm(p[i], CP);\n//\t\t\tSystem.out.println(\"CrossPoint: \"+CP[0]+\",\"+CP[1]);\n//\t\t\tSystem.out.println(len[0]+\",\"+len[1]+\",\"+len[2]);\n\t\t\tq = new double[3][2];\n\t\t\tr = new double[3];\n\t\t\tdouble L = 0, R = len[0];\n\t\t\tfor(;;){\n\t\t\t\tdouble m = (L+R)/2;\n\t\t\t\tint c = check(m);\n//\t\t\t\tSystem.out.println(\"M:\"+m);\n//\t\t\t\tSystem.out.println(\"RES C:\"+c+\" Q[0] \"+q[0][0]+\",\"+q[0][1]+\" R:\"+r[0]);\n\t\t\t\tif(c==0)break;\n\t\t\t\tif(c<0)L = m;\n\t\t\t\telse R = m;\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.6f %.6f %.6f\\n\", r[0], r[1], r[2]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Malfatti Circles\npublic class Main{\n\n\tfinal double EPS = 1e-9, EPS2 = 1e-6;\n\t\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a){\n\t\treturn Math.hypot(a[0], a[1]);\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tdouble angleTan(double[] a, double[] b){\n\t\treturn Math.atan2(cross(a, b), dot(a, b));\n\t}\n\tdouble angleCos(double[] a, double[] b){\n\t\tdouble na = norm(a), nb = norm(b);\n\t\treturn Math.acos(dot(a, b)/na/nb);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(Math.abs(cross(sub(b, a), sub(t, s)))<EPS){\n\t\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))))<EPS;\n\t\t}\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dist(double[] a, double[] b, double[] s, double[] t){\n\t\tif(crossing(a, b, s, t))return 0;\n\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))));\n\t}\n\tdouble distLP(double[] a, double[] b, double[] p){\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble[] cp(double[] a, double[] b, double[] s, double[] t){\n\t\tdouble ds = distLP(a, b, s), dt = distLP(a, b, t);\n\t\tdouble k = ds/(ds+dt);\n\t\tdouble[] d = sub(t, s);\n\t\treturn new double[]{s[0]+k*d[0], s[1]+k*d[1]};\n\t}\n\tdouble thita(double[] a, double[] b){\n\t\treturn Math.atan2(cross(a, b), dot(a, b));\n\t}\n\tdouble[][] circleCrossPoint(double x1, double y1, double r1, double x2, double y2, double r2){\n\t\tdouble x = x2-x1, y = y2-y1;\n\t\tdouble S = x*x+y*y;\n\t\tdouble A = (S+r1*r1-r2*r2)/2;\n\t\tdouble[][] res = new double[2][2];\n\t\tres[0][0] = (A*x+y*Math.sqrt(S*r1*r1-A*A))/S; res[0][1] = (A*y-x*Math.sqrt(S*r1*r1-A*A))/S;\n\t\tres[1][0] = (A*x-y*Math.sqrt(S*r1*r1-A*A))/S; res[1][1] = (A*y+x*Math.sqrt(S*r1*r1-A*A))/S;\n\t\treturn res;\n\t}\n\t\n\tdouble[][] p, d, q;\n\tdouble[] thita, CP, len, r;\n\t\n\tint check(double t){\n\t\tq[0][0] = p[0][0]+t*d[0][0];\n\t\tq[0][1] = p[0][1]+t*d[0][1];\n\t\tr[0] = dist(p[0], p[1], q[0]);\n\t\tdouble R2 = dist(p[1], p[2], q[0]);\n\t\tif(R2+EPS < r[0])return 1;\n\t\tsearch(1); search(2);\n\t\t//ここだけは緩めの許容誤差にしないと、いつまでたっても終わらない\n\t\tif(Math.abs(r[1]+r[2]-norm(q[1], q[2]))<EPS2)return 0;\n\t\treturn r[1]+r[2] < norm(q[1], q[2])?1:-1;\n\t}\n\t\n\tvoid search(int k){\n\t\tdouble L = 0, R = len[k];\n\t\tfor(int LOOP=0;LOOP<80&&R-L>EPS;LOOP++){\n\t\t\tdouble m = (L+R)/2;\n\t\t\tint c = checkSub(m, k);\n\t\t\tif(c==0)break;\n\t\t\tif(c<0)L = m;\n\t\t\telse R = m;\n\t\t}\n\t}\n\t\n\tint checkSub(double t, int k){\n\t\tq[k][0] = p[k][0]+t*d[k][0];\n\t\tq[k][1] = p[k][1]+t*d[k][1];\n\t\tr[k] = dist(p[k], p[(k+1)%3], q[k]);\n\t\tif(t < EPS)return -1;\n\t\tif(Math.abs(t-len[k])<EPS)return 1;\n\t\tdouble RK = dist(p[(k+1)%3], p[(k+2)%3], q[k]);\n\t\tif(RK+EPS < r[k])return 1;\n\t\tif(Math.abs(r[0]+r[k]-norm(q[0], q[k]))<EPS)return 0;\n\t\treturn r[0]+r[k] < norm(q[0], q[k])?-1:1;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint X1 = sc.nextInt(), Y1 = sc.nextInt(), X2 = sc.nextInt(), Y2 = sc.nextInt(), X3 = sc.nextInt(), Y3 = sc.nextInt();\n\t\t\tif((X1|Y1|X2|Y2|X3|Y3)==0)break;\n\t\t\tp = new double[][]{{X1, Y1},{X2, Y2}, {X3, Y3}};\n\t\t\tthita = new double[3];\n\t\t\td = new double[3][2];\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tdouble[] subs = sub(p[(i+1)%3], p[i]), subt = sub(p[(i+2)%3], p[i]);\n\t\t\t\tdouble thita = angleTan(subs, subt)/2;\n\t\t\t\td[i][0] = Math.cos(thita)*subs[0]-Math.sin(thita)*subs[1];\n\t\t\t\td[i][1] = Math.sin(thita)*subs[0]+Math.cos(thita)*subs[1];\n\t\t\t\tdouble D = norm(d[i]);\n\t\t\t\td[i][0]/=D; d[i][1]/=D;\n\t\t\t}\n\t\t\tdouble[] A = p[0], B = {p[0][0]+10000*d[0][0], p[0][1]+10000*d[0][1]}, C = p[1], D = {p[1][0]+10000*d[1][0], p[1][1]+10000*d[1][1]};\n\t\t\tCP = cp(A, B, C, D);\n\t\t\tlen = new double[3];\n\t\t\tfor(int i=0;i<3;i++)len[i] = norm(p[i], CP);\n\t\t\tq = new double[3][2];\n\t\t\tr = new double[3];\n\t\t\tdouble L = 0, R = len[0];\n\t\t\tfor(;;){\n\t\t\t\tdouble m = (L+R)/2;\n\t\t\t\tint c = check(m);\n\t\t\t\tif(c==0)break;\n\t\t\t\tif(c<0)L = m;\n\t\t\t\telse R = m;\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.6f %.6f %.6f\\n\", r[0], r[1], r[2]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nDELTA = 1e-10\n\n### classes\n\nclass Pt\n  attr_accessor :x, :y\n\n  def initialize() end\n  def initialize(_x, _y) @x = _x; @y = _y end\n\n  def ==(pt) @x == pt.x && @y == pt.y end\n  def +(pt) Pt.new(@x + pt.x, @y + pt.y) end\n  def -(pt) Pt.new(@x - pt.x, @y - pt.y) end\n  def -@() Pt.new(-@x, -@y) end\n  def *(t) Pt.new(@x * t, @y * t) end\n  def /(t) Pt.new(@x / t, @y / t) end\n  def dot(v) @x * v.x + @y * v.y end\n  def cross(v) @x * v.y - @y * v.x end\n  def d2() @x * @x + @y * @y end\n  def d() Math.sqrt(d2()) end\n  def normalize() self / d() end\n  def to_s() \"(#{@x},#{@y})\" end\n  def to_a() [@x, @y] end\nend\n\n### subroutines\n\ndef calc_cr(c0, r0, pi, vi, ri, lb, ub)\n  ci = rit = nil\n  loop do\n    t = (lb + ub) / 2\n    ci = vi * t + pi\n    rit = ri * t\n    \n    if (ci - c0).d > r0 + rit\n      lb = t\n    else\n      ub = t\n    end\n\n    break if ub - lb <= DELTA\n  end\n  [ci, rit]\nend\n\n### main\n\nloop do\n  x0, y0, x1, y1, x2, y2 = gets.split.map(&:to_i)\n  break if (x0 | y0 | x1 | y1 | x2 | y2) == 0\n\n  pts = [\n    Pt.new(x0.to_f, y0.to_f),\n    Pt.new(x1.to_f, y1.to_f),\n    Pt.new(x2.to_f, y2.to_f)\n  ]\n  #p pts.map{|pt| pt.to_a}\n\n  ls = (0...3).map{|i| (pts[(i + 2) % 3] - pts[(i + 1) % 3]).d}\n  lsum = ls.inject(:+)\n  ipt = (0...3).map{|i| pts[i] * ls[i]}.inject(:+) / lsum\n  r = (pts[1] - pts[0]).cross(pts[2] - pts[0]) / lsum\n  \n  divvs = []\n  rs = []\n  cts = []\n  \n  for i in (0...3)\n    iv = ipt - pts[i]\n    ivd = iv.d\n    divvs << iv / ivd\n    rs << r / iv.d\n    cts << ivd\n  end\n  #p divvs.map{|v| v.to_a}\n  #p rs\n\n  lb = 0.0\n  ub = cts[0]\n  r0 = r1 = r2 = nil\n  \n  loop do\n    t0 = (lb + ub) / 2\n    c0 = divvs[0] * t0 + pts[0]\n    r0 = rs[0] * t0\n\n    c1, r1 = calc_cr(c0, r0, pts[1], divvs[1], rs[1], 0.0, cts[1])\n    c2, r2 = calc_cr(c0, r0, pts[2], divvs[2], rs[2], 0.0, cts[2])\n\n    if (c2 - c1).d2 > (r1 + r2) ** 2\n      ub = t0\n    else\n      lb = t0\n    end\n\n    break if ub - lb <= DELTA\n  end\n\n  puts [r0, r1, r2].map{|r| \"%.6f\" % r}.join(' ')\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nstruct Point {\n    double y, x;\n    Point opBinary(alias op)(in Point a) const {\n        return Point(mixin(\"y\" ~ op ~ \"a.y\"), mixin(\"x\" ~ op ~ \"a.x\"));\n    }\n    Point opBinary(alias op)(double a) const {\n        return Point(mixin(\"y\" ~ op ~ \"a\"), mixin(\"x\" ~ op ~ \"a\"));\n    }\n}\n\nvoid main() {\n    Point[] P = new Point[3];\n\n    bool input() {\n        scanf(\"%lf %lf %lf %lf %lf %lf\\n\", &P[0].x, &P[0].y, &P[1].x, &P[1].y, &P[2].x, &P[2].y);\n        if (P[0 .. 3].all!\"a.y == 0 && a.x == 0\") return false;\n        return true;\n    }\n    size_t next(size_t n) {\n        return (n + 1) % 3;\n    }\n    double distance2D(in Point a, in Point b) {\n        double dx = a.x - b.x,\n               dy = a.y - b.y;\n        return sqrt(dx * dx + dy * dy);\n    }\n    void solve() {\n        double L0 = distance2D(P[0], P[1]);\n        double L1 = distance2D(P[0], P[2]);\n        double L2 = distance2D(P[1], P[2]);\n        double theta = acos( (L0 * L0 + L1 * L1 - L2 * L2) / (2 * L0 * L1) ) / 2;\n        double theta1 = acos( (L2 * L2 + L0 * L0 - L1 * L1) / (2 * L2 * L0) ) / 2;\n        double theta2 = acos( (L1 * L1 + L2 * L2 - L0 * L0) / (2 * L1 * L2) ) / 2;\n        double r1, r2;\n        bool C(double R) {\n            double a = (L0 - R / tan(theta)) / tan(theta1) + R;\n            r1 = ((sqrt(a) - sqrt(R)) * tan(theta1)) ^^ 2;\n            a = (L1 - R / tan(theta)) / tan(theta2) + R;\n            r2 = ((sqrt(a) - sqrt(R)) * tan(theta2)) ^^ 2;\n            double d = L2 - (r1 / tan(theta1)) - (r2 / tan(theta2));\n            //writeln([R, r1, r2], [d]);\n            if (d < 0) return false;\n            return d ^^ 2 + (r1 - r2) ^^ 2 >= (r1 + r2) ^^ 2;\n        }\n        double area = L0 * L1 * sin(theta) / 2;\n        double lb = 0, ub = area * 2 / (L0 + L1 + L2);\n        foreach (_; 0 .. 100) {\n            double mid = (lb + ub) / 2;\n            if (C(mid)) {\n                ub = mid;\n            } else {\n                lb = mid;\n            }\n        }\n        writefln(\"%.10f %.10f %.10f\", ub, r1, r2);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nstruct Point {\n    double y, x;\n    Point opBinary(alias op)(in Point a) const {\n        return Point(mixin(\"y\" ~ op ~ \"a.y\"), mixin(\"x\" ~ op ~ \"a.x\"));\n    }\n    Point opBinary(alias op)(double a) const {\n        return Point(mixin(\"y\" ~ op ~ \"a\"), mixin(\"x\" ~ op ~ \"a\"));\n    }\n}\n\nvoid main() {\n    Point[] P = new Point[3];\n\n    bool input() {\n        scanf(\"%lf %lf %lf %lf %lf %lf\\n\", &P[0].x, &P[0].y, &P[1].x, &P[1].y, &P[2].x, &P[2].y);\n        if (P[0 .. 3].all!\"a.y == 0 && a.x == 0\") return false;\n        return true;\n    }\n    size_t next(size_t n) {\n        return (n + 1) % 3;\n    }\n    double distance2D(in Point a, in Point b) {\n        double dx = a.x - b.x,\n               dy = a.y - b.y;\n        return sqrt(dx * dx + dy * dy);\n    }\n    void solve() {\n        double L0 = distance2D(P[0], P[1]);\n        double L1 = distance2D(P[0], P[2]);\n        double L2 = distance2D(P[1], P[2]);\n        double theta = acos( (L0 * L0 + L1 * L1 - L2 * L2) / (2 * L0 * L1) ) / 2;\n        double theta1 = acos( (L2 * L2 + L0 * L0 - L1 * L1) / (2 * L2 * L0) ) / 2;\n        double theta2 = acos( (L1 * L1 + L2 * L2 - L0 * L0) / (2 * L1 * L2) ) / 2;\n        double r1, r2;\n        bool C(double R) {\n            double a = (L0 - R / tan(theta)) / tan(theta1) + R;\n            r1 = ((sqrt(a) - sqrt(R)) * tan(theta1)) ^^ 2;\n            a = (L1 - R / tan(theta)) / tan(theta2) + R;\n            r2 = ((sqrt(a) - sqrt(R)) * tan(theta2)) ^^ 2;\n            double d = L2 - (r1 / tan(theta1)) - (r2 / tan(theta2));\n            //writeln([R, r1, r2], [d]);\n            if (d < 0) return false;\n            return d ^^ 2 + (r1 - r2) ^^ 2 >= (r1 + r2) ^^ 2;\n        }\n        double area = L0 * L1 * sin(theta * 2) / 2;\n        double lb = 0, ub = area * 2 / (L0 + L1 + L2);\n        foreach (_; 0 .. 100) {\n            double mid = (lb + ub) / 2;\n            //writeln(\"[lb, ub]:\", [lb, ub]);\n            if (C(mid)) {\n                ub = mid;\n            } else {\n                lb = mid;\n            }\n        }\n        C(lb);\n        writefln(\"%.10f %.10f %.10f\", lb, r1, r2);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nstruct Point {\n    double y, x;\n    Point opBinary(alias op)(in Point a) const {\n        return Point(mixin(\"y\" ~ op ~ \"a.y\"), mixin(\"x\" ~ op ~ \"a.x\"));\n    }\n    Point opBinary(alias op)(double a) const {\n        return Point(mixin(\"y\" ~ op ~ \"a\"), mixin(\"x\" ~ op ~ \"a\"));\n    }\n}\n\nvoid main() {\n    Point[] P = new Point[3];\n\n    bool input() {\n        scanf(\"%lf %lf %lf %lf %lf %lf\\n\", &P[0].x, &P[0].y, &P[1].x, &P[1].y, &P[2].x, &P[2].y);\n        if (P[0 .. 3].all!\"a.y == 0 && a.x == 0\") return false;\n        return true;\n    }\n    size_t next(size_t n) {\n        return (n + 1) % 3;\n    }\n    double distance2D(in Point a, in Point b) {\n        double dx = a.x - b.x,\n               dy = a.y - b.y;\n        return sqrt(dx * dx + dy * dy);\n    }\n    void solve() {\n        double L0 = distance2D(P[0], P[1]);\n        double L1 = distance2D(P[0], P[2]);\n        double L2 = distance2D(P[1], P[2]);\n        double theta = acos( (L0 * L0 + L1 * L1 - L2 * L2) / (2 * L0 * L1) ) / 2;\n        double theta1 = acos( (L2 * L2 + L0 * L0 - L1 * L1) / (2 * L2 * L0) ) / 2;\n        double theta2 = acos( (L1 * L1 + L2 * L2 - L0 * L0) / (2 * L1 * L2) ) / 2;\n        double r1, r2;\n        bool C(double R) {\n            double a = (L0 - R / tan(theta)) / tan(theta1) + R;\n            r1 = ((sqrt(a) - sqrt(R)) * tan(theta1)) ^^ 2;\n            a = (L1 - R / tan(theta)) / tan(theta2) + R;\n            r2 = ((sqrt(a) - sqrt(R)) * tan(theta2)) ^^ 2;\n            double d = L2 - (r1 / tan(theta1)) - (r2 / tan(theta2));\n            //writeln([R, r1, r2], [d]);\n            if (d < 0) return false;\n            return d ^^ 2 + (r1 - r2) ^^ 2 >= (r1 + r2) ^^ 2;\n        }\n        double area = L0 * L1 * sin(theta * 2) / 2;\n        double lb = 0, ub = area * 2 / (L0 + L1 + L2);\n        foreach (_; 0 .. 100) {\n            double mid = (lb + ub) / 2;\n            //writeln(\"[lb, ub]:\", [lb, ub]);\n            if (C(mid)) {\n                ub = mid;\n            } else {\n                lb = mid;\n            }\n        }\n        C(lb);\n        writefln(\"%.10f %.10f %.10f\", lb, r1, r2);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "import math\n\ndef length(x1, y1, x2, y2):\n    return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\nwhile True:\n    p = list(map(int, input().split()))\n    if not list(filter(lambda x: x, p)):\n        break\n\n    a, b, c = length(p[0], p[1], p[2], p[3]), length(p[0], p[1], p[4], p[5]), length(p[2], p[3], p[4], p[5])\n    S = 0.5 * a * b * (1 - ((a ** 2 + b ** 2 - c ** 2) / (a * b * 2)) ** 2) ** 0.5\n    R = (2 * S) / (a + b + c)\n\n    s = (a + b + c) / 2\n    d = (((- a + b + c) / 2) ** 2 + R ** 2) ** 0.5\n    e = (((a - b + c) / 2) ** 2 + R ** 2) ** 0.5\n    f = (((a + b - c) / 2) ** 2 + R ** 2) ** 0.5\n\n    print(R / (2 * (s - c)) * (s + f - R - e - d), end=\" \")\n    print(R / (2 * (s - b)) * (s + e - R - d - f), end=\" \")\n    print(R / (2 * (s - a)) * (s + d - R - e - f))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    x1, y1, x2, y2, x3, y3 = map(int, readline().split())\n    if x1 == y1 == x2 == y2 == x3 == y3 == 0:\n        return False\n    d12 = ((x1-x2)**2 + (y1-y2)**2)**.5\n    d23 = ((x2-x3)**2 + (y2-y3)**2)**.5\n    d31 = ((x3-x1)**2 + (y3-y1)**2)**.5\n    e1 = ((x1, y1), ((x2-x1)/d12, (y2-y1)/d12), ((x3-x1)/d31, (y3-y1)/d31))\n    e2 = ((x2, y2), ((x3-x2)/d23, (y3-y2)/d23), ((x1-x2)/d12, (y1-y2)/d12))\n    e3 = ((x3, y3), ((x1-x3)/d31, (y1-y3)/d31), ((x2-x3)/d23, (y2-y3)/d23))\n    def calc(e, x):\n        p0, p1, p2 = e\n        x0, y0 = p0; x1, y1 = p1; x2, y2 = p2\n        xc = (x1 + x2)/2; yc = (y1 + y2)/2; dc = (xc**2 + yc**2)**.5\n        cv = (x1*xc + y1*yc)/dc\n        sv = (x1*yc - y1*xc)/dc\n        d = x / cv\n        return (x0 + xc * d / dc, y0 + yc * d / dc), x * sv / cv\n\n    EPS = 1e-8\n    def check(p0, r0):\n        x0, y0 = p0\n        left = 0; right = min(d12, d23)\n        while right - left > EPS:\n            mid = (left + right) / 2\n            (x1, y1), r1 = calc(e2, mid)\n            if (x0-x1)**2 + (y0-y1)**2 < (r0+r1)**2:\n                right = mid\n            else:\n                left = mid\n        (x1, y1), r1 = calc(e2, left)\n        left = 0; right = min(d23, d31)\n        while right - left > EPS:\n            mid = (left + right) / 2\n            (x2, y2), r2 = calc(e3, mid)\n            if (x0-x2)**2 + (y0-y2)**2 < (r0+r2)**2:\n                right = mid\n            else:\n                left = mid\n        (x2, y2), r2 = calc(e3, left)\n        return (x1-x2)**2 + (y1-y2)**2 < (r1+r2)**2, r1, r2\n\n    left = 0; right = min(d12, d31)\n    while right - left > EPS:\n        mid = (left + right) / 2\n        p0, r0 = calc(e1, mid)\n        if check(p0, r0)[0]:\n            left = mid\n        else:\n            right = mid\n    p0, r0 = calc(e1, right)\n    e, r1, r2 = check(p0, r0)\n\n    write(\"%.16f %.16f %.16f\\n\" % (r0, r1, r2))\n    return True\nwhile solve():\n    ...\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nProblems 1301\nProblem G: Malfatti Circles\n\"\"\"\nimport math\ndef main():\n    while True:\n        x1, y1, x2, y2, x3, y3 = map(int,input().split())\n        if  x1 == y1 == x2 == y2 == x3 == y3 == 0:\n            break\n        \n        a = math.sqrt( (x2-x3)*(x2-x3) + (y2-y3)*(y2-y3) ) # aの長さ\n        b = math.sqrt( (x1-x3)*(x1-x3) + (y1-y3)*(y1-y3) ) # bの長さ\n        c = math.sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) ) # cの長さ\n\n        cosA = round((b*b + c*c - a*a),10) / round(2*b*c,10) # 余弦定理\n        cosB = round((a*a + c*c - b*b),10) / round(2*a*c,10) # 余弦定理\n        cosC = round((a*a + b*b - c*c),6) / round(2*a*b,10) # 余弦定理\n        \n        A = math.degrees(math.acos(cosA)) # bcの角度\n        B = math.degrees(math.acos(cosB)) # acの角度\n        C = math.degrees(math.acos(cosC)) # abの角度\n        \n        S = 1/2*a*c*math.sin(math.radians(B)) # 三角形の面積\n        r = 2*S / (a+b+c) # 内接円半径\n        \n        tanA4 = round(math.tan(math.radians(A)/4),10) # tan(A/4)\n        tanB4 = round(math.tan(math.radians(B)/4),10) # tan(B/4)\n        tanC4 = round(math.tan(math.radians(C)/4),10) # tan(C/4)\n        \n        r1 = ((1+tanB4)*(1+tanC4))/(2*(1+tanA4))*r\n        r2 = ((1+tanC4)*(1+tanA4))/(2*(1+tanB4))*r\n        r3 = ((1+tanA4)*(1+tanB4))/(2*(1+tanC4))*r\n        \n        print(r1, r2, r3)\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "from functools import reduce\nimport math\n\n\ndef length(p1, p2):\n    sub2 = [(a - b)**2 for a, b in zip(p1, p2)]\n    return math.sqrt(sum(sub2))\n\n\ndef r_center(lines):\n    lines_sum = reduce(lambda a, b: a + b, lines)\n    s = lines_sum / 2\n    area = math.sqrt(s * (s - lines[0]) * (s - lines[1]) * (s - lines[2]))\n    return 2 * area / (lines_sum)\n\n\ndef r_length(lines, r_center):\n    x = (lines[0] + lines[2] - lines[1]) / 2\n    b_l = math.sqrt(x**2 + r_center**2)\n    a_l = math.sqrt((lines[2] - x)**2 + r_center**2)\n    c_l = math.sqrt((lines[0] - x)**2 + r_center**2)\n    return [a_l, b_l, c_l]\n\n\nwhile True:\n    positions = list(map(int, input().split()))\n    if reduce(lambda a, b: a | b, positions) == 0:\n        break\n    p1, p2, p3 = [[i, j] for i, j in zip(positions[::2], positions[1::2])]\n\n    lines = [length(a, b) for a, b in ((p1, p2), (p2, p3), (p3, p1))]\n    lines_sum = reduce(lambda a, b: a + b, lines)\n\n    r_c = r_center(lines)\n    round_half = lines_sum / 2\n    rc_len = r_length(lines, r_c)\n\n    r1 = r_c * (round_half + rc_len[0] - r_c - rc_len[1] -\n                rc_len[2]) / (2 * (round_half - lines[0]))\n    r2 = r_c * (round_half + rc_len[1] - r_c - rc_len[0] -\n                rc_len[2]) / (2 * (round_half - lines[1]))\n    r3 = r_c * (round_half + rc_len[2] - r_c - rc_len[1] -\n                rc_len[0]) / (2 * (round_half - lines[2]))\n\n    print(r2, r3, r1)\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    from sys import stdin\n    file_input = stdin\n    \n    while True:\n        x1, y1, x2, y2, x3, y3 = map(int, file_input.readline().split())\n        if x1 == y1 == x2 == y2 == 0:\n            break\n        \n        A = x1 + y1 * 1j\n        B = x2 + y2 * 1j\n        C = x3 + y3 * 1j\n        \n        a = abs(B - C)\n        b = abs(C - A)\n        c = abs(A - B)\n        \n        s = (a + b + c) / 2\n        \n        r = (s * (s - a) * (s - b) * (s - c)) ** 0.5 / s\n        \n        D = (b * B + c * C) / (c + b)\n        BD = abs(D - B)\n        \n        I = (BD * A + c * D) / (c + BD)\n        \n        d = abs(A - I)\n        e = abs(B - I)\n        f = abs(C - I)\n        \n        r1 = r / 2 / (s - a) * (s + d - r - e - f)\n        r2 = r / 2 / (s - b) * (s + e - r - d - f)\n        r3 = r / 2 / (s - c) * (s + f - r - d - e)\n        \n        print(r1, r2, r3)\n\nsolve()\n"
  }
]