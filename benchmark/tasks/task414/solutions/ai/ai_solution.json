[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <stdbool.h>\n\n#define MAX_SIZE 20\n#define MAX_NODES 400\n#define INF 1e9\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint h, w;\nchar grid[MAX_SIZE][MAX_SIZE];\nPoint start, goal;\nint num_floor;\nPoint floor_tiles[MAX_NODES];\ndouble dist[MAX_SIZE][MAX_SIZE];\nbool in_queue[MAX_SIZE][MAX_SIZE];\nPoint queue[MAX_NODES];\nint front, rear;\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nvoid init() {\n    num_floor = 0;\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            if (grid[i][j] == 's') {\n                start.x = i;\n                start.y = j;\n            } else if (grid[i][j] == 'g') {\n                goal.x = i;\n                goal.y = j;\n            }\n            if (grid[i][j] == '.' || grid[i][j] == 's') {\n                floor_tiles[num_floor].x = i;\n                floor_tiles[num_floor].y = j;\n                num_floor++;\n            }\n        }\n    }\n}\n\nbool is_valid(int x, int y) {\n    return x >= 0 && x < h && y >= 0 && y < w && grid[x][y] != '#';\n}\n\nvoid solve() {\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            dist[i][j] = INF;\n            in_queue[i][j] = false;\n        }\n    }\n    dist[goal.x][goal.y] = 0;\n    front = rear = 0;\n    queue[rear++] = goal;\n    in_queue[goal.x][goal.y] = true;\n\n    while (front != rear) {\n        Point cur = queue[front++];\n        if (front == MAX_NODES) front = 0;\n        in_queue[cur.x][cur.y] = false;\n\n        for (int d = 0; d < 4; d++) {\n            int nx = cur.x + dx[d];\n            int ny = cur.y + dy[d];\n            if (!is_valid(nx, ny)) continue;\n\n            if (grid[nx][ny] == '*') {\n                double sum = 0;\n                for (int k = 0; k < num_floor; k++) {\n                    sum += dist[floor_tiles[k].x][floor_tiles[k].y];\n                }\n                double avg = sum / num_floor;\n                if (dist[nx][ny] > 1 + avg) {\n                    dist[nx][ny] = 1 + avg;\n                    if (!in_queue[nx][ny]) {\n                        queue[rear++] = (Point){nx, ny};\n                        if (rear == MAX_NODES) rear = 0;\n                        in_queue[nx][ny] = true;\n                    }\n                }\n            } else {\n                if (dist[nx][ny] > 1 + dist[cur.x][cur.y]) {\n                    dist[nx][ny] = 1 + dist[cur.x][cur.y];\n                    if (!in_queue[nx][ny]) {\n                        queue[rear++] = (Point){nx, ny};\n                        if (rear == MAX_NODES) rear = 0;\n                        in_queue[nx][ny] = true;\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &h, &w);\n    for (int i = 0; i < h; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    init();\n    solve();\n\n    if (dist[start.x][start.y] < INF) {\n        printf(\"%.10f\\n\", dist[start.x][start.y]);\n    } else {\n        printf(\"-1\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:27:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\n\nconst double INF = 1e18;\nconst double EPS = 1e-9;\n\nstruct Position {\n    int x, y;\n    Position(int x = 0, int y = 0) : x(x), y(y) {}\n    bool operator==(const Position& other) const {\n        return x == other.x && y == other.y;\n    }\n};\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> grid(H);\n    Position start, goal;\n    vector<Position> floors;\n    vector<Position> springs;\n\n    for (int i = 0; i < H; ++i) {\n        cin >> grid[i];\n        for (int j = 0; j < W; ++j) {\n            if (grid[i][j] == 's') {\n                start = Position(i, j);\n                floors.push_back(start);\n            } else if (grid[i][j] == 'g') {\n                goal = Position(i, j);\n            } else if (grid[i][j] == '.') {\n                floors.push_back(Position(i, j));\n            } else if (grid[i][j] == '*') {\n                springs.push_back(Position(i, j));\n            }\n        }\n    }\n\n    int N = H * W;\n    vector<vector<double>> dist(H, vector<double>(W, INF));\n    dist[start.x][start.y] = 0.0;\n    priority_queue<pair<double, Position>, vector<pair<double, Position>>, greater<pair<double, Position>>> pq;\n    pq.push({0.0, start});\n\n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n\n    while (!pq.empty()) {\n        auto current = pq.top();\n        pq.pop();\n        double current_dist = current.first;\n        Position pos = current.second;\n\n        if (pos == goal) {\n            break;\n        }\n\n        if (current_dist > dist[pos.x][pos.y] + EPS) {\n            continue;\n        }\n\n        for (int d = 0; d < 4; ++d) {\n            int nx = pos.x + dx[d];\n            int ny = pos.y + dy[d];\n            if (nx < 0 || nx >= H || ny < 0 || ny >= W || grid[nx][ny] == '#') {\n                continue;\n            }\n\n            double new_dist = current_dist + 1.0;\n            if (grid[nx][ny] == '*') {\n                double total_floors = floors.size();\n                if (total_floors == 0) {\n                    continue;\n                }\n                double avg = 0.0;\n                for (const auto& floor : floors) {\n                    avg += dist[floor.x][floor.y] / total_floors;\n                }\n                new_dist = 1.0 + avg;\n            }\n\n            if (new_dist < dist[nx][ny] - EPS) {\n                dist[nx][ny] = new_dist;\n                pq.push({new_dist, Position(nx, ny)});\n            }\n        }\n    }\n\n    cout << fixed << setprecision(10) << dist[goal.x][goal.y] << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:28:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SpringTiles {\n    static class State {\n        int x, y;\n        State(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        List<String> grid = new ArrayList<>();\n        while (sc.hasNextLine()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) break;\n            grid.add(line);\n        }\n        int rows = grid.size();\n        int cols = grid.get(0).length();\n        int startX = -1, startY = -1;\n        int goalX = -1, goalY = -1;\n        List<State> floors = new ArrayList<>();\n        for (int i = 0; i < rows; i++) {\n            String row = grid.get(i);\n            for (int j = 0; j < cols; j++) {\n                char c = row.charAt(j);\n                if (c == 's') {\n                    startX = i;\n                    startY = j;\n                    floors.add(new State(i, j));\n                } else if (c == 'g') {\n                    goalX = i;\n                    goalY = j;\n                } else if (c == '.' || c == '*') {\n                    floors.add(new State(i, j));\n                }\n            }\n        }\n        int N = floors.size();\n        double[][] A = new double[N][N];\n        double[] b = new double[N];\n        Map<State, Integer> stateToIndex = new HashMap<>();\n        for (int i = 0; i < N; i++) {\n            stateToIndex.put(floors.get(i), i);\n        }\n        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        for (int i = 0; i < N; i++) {\n            State curr = floors.get(i);\n            int x = curr.x;\n            int y = curr.y;\n            char c = grid.get(x).charAt(y);\n            if (c == 'g') {\n                A[i][i] = 1;\n                b[i] = 0;\n                continue;\n            }\n            if (c == '*') {\n                A[i][i] = 1;\n                for (State floor : floors) {\n                    char fc = grid.get(floor.x).charAt(floor.y);\n                    if (fc != 'g' && fc != '*') {\n                        int j = stateToIndex.get(floor);\n                        A[i][j] -= 1.0 / (floors.size() - 1);\n                    }\n                }\n                b[i] = 1;\n                continue;\n            }\n            List<State> neighbors = new ArrayList<>();\n            for (int[] dir : dirs) {\n                int nx = x + dir[0];\n                int ny = y + dir[1];\n                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols) {\n                    char nc = grid.get(nx).charAt(ny);\n                    if (nc != '#') {\n                        neighbors.add(new State(nx, ny));\n                    }\n                }\n            }\n            int m = neighbors.size();\n            if (m == 0) {\n                A[i][i] = 1;\n                b[i] = 0;\n                continue;\n            }\n            A[i][i] = 1;\n            for (State neighbor : neighbors) {\n                char nc = grid.get(neighbor.x).charAt(neighbor.y);\n                if (nc == 'g') {\n                    b[i] += -1.0 / m;\n                } else if (nc == '*') {\n                    int j = stateToIndex.get(neighbor);\n                    A[i][j] += -1.0 / m;\n                } else {\n                    int j = stateToIndex.get(neighbor);\n                    A[i][j] += -1.0 / m;\n                }\n            }\n            b[i] += 1;\n        }\n        double[] x = new double[N];\n        for (int k = 0; k < N; k++) {\n            int max = k;\n            for (int i = k + 1; i < N; i++) {\n                if (Math.abs(A[i][k]) > Math.abs(A[max][k])) {\n                    max = i;\n                }\n            }\n            double[] temp = A[k];\n            A[k] = A[max];\n            A[max] = temp;\n            double t = b[k];\n            b[k] = b[max];\n            b[max] = t;\n            for (int i = k + 1; i < N; i++) {\n                double factor = A[i][k] / A[k][k];\n                b[i] -= factor * b[k];\n                for (int j = k; j < N; j++) {\n                    A[i][j] -= factor * A[k][j];\n                }\n            }\n        }\n        for (int i = N - 1; i >= 0; i--) {\n            double sum = 0.0;\n            for (int j = i + 1; j < N; j++) {\n                sum += A[i][j] * x[j];\n            }\n            x[i] = (b[i] - sum) / A[i][i];\n        }\n        State startState = new State(startX, startY);\n        int startIdx = stateToIndex.get(startState);\n        System.out.printf(\"%.6f\\n\", x[startIdx]);\n    }\n}",
    "timestamp": "2025-08-05 21:28:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SpringTiles {\n    private static final int[] dx = {0, 0, 1, -1};\n    private static final int[] dy = {1, -1, 0, 0};\n    \n    public static double solve(char[][] grid) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        \n        // Find start and goal positions\n        int startX = -1, startY = -1, goalX = -1, goalY = -1;\n        List<int[]> springPositions = new ArrayList<>();\n        List<int[]> floorPositions = new ArrayList<>();\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == 's') {\n                    startX = i;\n                    startY = j;\n                }\n                if (grid[i][j] == 'g') {\n                    goalX = i;\n                    goalY = j;\n                }\n                if (grid[i][j] == '*') {\n                    springPositions.add(new int[]{i, j});\n                }\n                if (grid[i][j] == '.' || grid[i][j] == 's') {\n                    floorPositions.add(new int[]{i, j});\n                }\n            }\n        }\n        \n        // Compute expected moves using dynamic programming\n        double[][] expectedMoves = new double[rows][cols];\n        boolean[][] visited = new boolean[rows][cols];\n        \n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{goalX, goalY});\n        expectedMoves[goalX][goalY] = 0;\n        visited[goalX][goalY] = true;\n        \n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int x = curr[0], y = curr[1];\n            \n            for (int d = 0; d < 4; d++) {\n                int nx = x + dx[d], ny = y + dy[d];\n                \n                if (nx < 0 || nx >= rows || ny < 0 || ny >= cols || grid[nx][ny] == '#') continue;\n                \n                if (grid[nx][ny] == '*') {\n                    double avgMoves = 0;\n                    for (int[] floor : floorPositions) {\n                        if (floor[0] == nx && floor[1] == ny) continue;\n                        avgMoves += expectedMoves[floor[0]][floor[1]];\n                    }\n                    avgMoves /= floorPositions.size() - 1;\n                    expectedMoves[nx][ny] = avgMoves + 1;\n                }\n                else {\n                    expectedMoves[nx][ny] = expectedMoves[x][y] + 1;\n                }\n                \n                if (!visited[nx][ny]) {\n                    queue.offer(new int[]{nx, ny});\n                    visited[nx][ny] = true;\n                }\n            }\n        }\n        \n        return expectedMoves[startX][startY];\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int rows = scanner.nextInt();\n        int cols = scanner.nextInt();\n        scanner.nextLine();\n        \n        char[][] grid = new char[rows][cols];\n        for (int i = 0; i < rows; i++) {\n            grid[i] = scanner.nextLine().toCharArray();\n        }\n        \n        double result = solve(grid);\n        System.out.printf(\"%.6f\\n\", result);\n    }\n}",
    "timestamp": "2025-08-05 21:29:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 20\n#define MAX_M 20\n\nchar grid[MAX_N][MAX_M];\nint n, m;\nint floor_tiles[MAX_N * MAX_M];\nint floor_count = 0;\nint start_x, start_y;\nint goal_x, goal_y;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\ntypedef struct {\n    int x, y;\n} Point;\n\ndouble expected_moves[MAX_N][MAX_M];\nint visited[MAX_N][MAX_M];\n\nint is_valid(int x, int y) {\n    return x >= 0 && x < n && y >= 0 && y < m && grid[x][y] != '#';\n}\n\ndouble min_expected_moves(int x, int y) {\n    if (x == goal_x && y == goal_y) return 0.0;\n    if (visited[x][y]) return expected_moves[x][y];\n    \n    visited[x][y] = 1;\n    \n    if (grid[x][y] == '*') {\n        double total_moves = 0.0;\n        for (int i = 0; i < floor_count; i++) {\n            int tx = floor_tiles[i] / m;\n            int ty = floor_tiles[i] % m;\n            total_moves += 1.0 + min_expected_moves(tx, ty);\n        }\n        expected_moves[x][y] = total_moves / floor_count;\n        return expected_moves[x][y];\n    }\n    \n    double min_moves = INT_MAX;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (is_valid(nx, ny)) {\n            double moves = 1.0 + min_expected_moves(nx, ny);\n            if (moves < min_moves) {\n                min_moves = moves;\n            }\n        }\n    }\n    \n    expected_moves[x][y] = min_moves;\n    return min_moves;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    \n    floor_count = 0;\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", grid[i]);\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == '.' || grid[i][j] == 's') {\n                floor_tiles[floor_count++] = i * m + j;\n            }\n            if (grid[i][j] == 's') {\n                start_x = i;\n                start_y = j;\n            }\n            if (grid[i][j] == 'g') {\n                goal_x = i;\n                goal_y = j;\n            }\n            expected_moves[i][j] = 0.0;\n            visited[i][j] = 0;\n        }\n    }\n    \n    double result = min_expected_moves(start_x, start_y);\n    printf(\"%.10f\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:29:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 20;\nint H, W;\nchar grid[MAX_N][MAX_N];\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\n\nstruct State {\n    int x, y;\n    double expected_moves;\n    \n    bool operator<(const State& other) const {\n        return expected_moves > other.expected_moves;\n    }\n};\n\nvector<pair<int, int>> floor_tiles;\nvector<pair<int, int>> spring_tiles;\nint start_x, start_y, goal_x, goal_y;\n\nbool is_valid(int x, int y) {\n    return x >= 0 && x < H && y >= 0 && y < W && grid[x][y] != '#';\n}\n\nbool is_floor(int x, int y) {\n    return is_valid(x, y) && grid[x][y] == '.' || grid[x][y] == 's';\n}\n\ndouble solve() {\n    vector<vector<double>> dist(H, vector<double>(W, DBL_MAX));\n    vector<vector<bool>> visited(H, vector<bool>(W, false));\n    \n    priority_queue<State> pq;\n    dist[start_x][start_y] = 0;\n    pq.push({start_x, start_y, 0.0});\n    \n    while (!pq.empty()) {\n        auto [x, y, curr_moves] = pq.top();\n        pq.pop();\n        \n        if (visited[x][y]) continue;\n        visited[x][y] = true;\n        \n        if (x == goal_x && y == goal_y) return curr_moves;\n        \n        for (int k = 0; k < 4; k++) {\n            int nx = x + dx[k], ny = y + dy[k];\n            \n            if (!is_valid(nx, ny)) continue;\n            \n            double next_moves = curr_moves + 1;\n            \n            if (grid[nx][ny] == '*') {\n                int total_floor = floor_tiles.size();\n                next_moves += 1.0;\n                \n                for (auto [fx, fy] : floor_tiles) {\n                    if (dist[fx][fy] > next_moves) {\n                        dist[fx][fy] = next_moves;\n                        pq.push({fx, fy, next_moves});\n                    }\n                }\n            } else {\n                if (dist[nx][ny] > next_moves) {\n                    dist[nx][ny] = next_moves;\n                    pq.push({nx, ny, next_moves});\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    cin >> H >> W;\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> grid[i][j];\n            \n            if (grid[i][j] == 's') {\n                start_x = i;\n                start_y = j;\n            }\n            \n            if (grid[i][j] == 'g') {\n                goal_x = i;\n                goal_y = j;\n            }\n            \n            if (grid[i][j] == '.') {\n                floor_tiles.push_back({i, j});\n            }\n            \n            if (grid[i][j] == '*') {\n                spring_tiles.push_back({i, j});\n            }\n        }\n    }\n    \n    double result = solve();\n    printf(\"%.2f\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:29:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\nimport sys\n\ndef expected_moves(labyrinth):\n    rows, cols = len(labyrinth), len(labyrinth[0])\n    floor_tiles = []\n    springs = {}\n    start_pos = None\n    goal_pos = None\n\n    for r in range(rows):\n        for c in range(cols):\n            if labyrinth[r][c] == '.':\n                floor_tiles.append((r, c))\n            elif labyrinth[r][c] == 's':\n                start_pos = (r, c)\n                floor_tiles.append((r, c))\n            elif labyrinth[r][c] == 'g':\n                goal_pos = (r, c)\n                floor_tiles.append((r, c))\n            elif labyrinth[r][c] == '*':\n                springs[(r, c)] = True\n\n    floor_tile_count = len(floor_tiles)\n    adj_list = {}\n\n    for r in range(rows):\n        for c in range(cols):\n            if labyrinth[r][c] in {'.', 's', 'g'}:\n                adj_list[(r, c)] = []\n                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nr, nc = r + dr, c + dc\n                    if (0 <= nr < rows) and (0 <= nc < cols) and (labyrinth[nr][nc] != '#'):\n                        adj_list[(r, c)].append((nr, nc))\n\n    def bfs():\n        queue = deque([goal_pos])\n        distances = {goal_pos: 0}\n\n        while queue:\n            current = queue.popleft()\n            current_distance = distances[current]\n\n            for neighbor in adj_list.get(current, []):\n                if neighbor not in distances:\n                    distances[neighbor] = current_distance + 1\n                    queue.append(neighbor)\n\n        for spring in springs:\n            distances[spring] = sum(distances[floor] for floor in floor_tiles) / floor_tile_count\n\n        return distances\n\n    distances = bfs()\n\n    # dp[state] holds the minimum expected moves from state to goal\n    dp = {}\n\n    def min_expected_moves(state):\n        if state in dp:\n            return dp[state]\n        if state == goal_pos:\n            return 0\n\n        expected = float('inf')\n        for neighbor in adj_list[state]:\n            if neighbor in springs:\n                expected = min(expected, 1 + distances[neighbor])\n            else:\n                expected = min(expected, 1 + min_expected_moves(neighbor))\n        dp[state] = expected\n        return expected\n\n    return min_expected_moves(start_pos)\n\n# Read input\ndef main():\n    input_data = sys.stdin.read().splitlines()\n    labyrinth = [list(line) for line in input_data]\n    result = expected_moves(labyrinth)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 06:30:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SpringTiles {\n\n    private static class State {\n        int x, y;\n        double probability;\n\n        State(int x, int y, double probability) {\n            this.x = x;\n            this.y = y;\n            this.probability = probability;\n        }\n    }\n\n    private static final char WALL = '#';\n    private static final char FLOOR = '.';\n    private static final char START = 's';\n    private static final char GOAL = 'g';\n    private static final char SPRING = '*';\n\n    private static final int[] DX = {-1, 1, 0, 0};\n    private static final int[] DY = {0, 0, -1, 1};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int rows = sc.nextInt();\n        int cols = sc.nextInt();\n        sc.nextLine();\n\n        char[][] labyrinth = new char[rows][cols];\n        int startX = -1, startY = -1;\n        List<int[]> floorTiles = new ArrayList<>();\n\n        for (int i = 0; i < rows; i++) {\n            String line = sc.nextLine().trim();\n            for (int j = 0; j < cols; j++) {\n                labyrinth[i][j] = line.charAt(j);\n                if (labyrinth[i][j] == START) {\n                    startX = i;\n                    startY = j;\n                }\n                if (labyrinth[i][j] == FLOOR) {\n                    floorTiles.add(new int[]{i, j});\n                }\n            }\n        }\n\n        int floorCount = floorTiles.size();\n        double[][] expectedMoves = new double[rows][cols];\n        boolean[][] visited = new boolean[rows][cols];\n\n        PriorityQueue<State> queue = new PriorityQueue<>(Comparator.comparingDouble(s -> s.probability));\n        queue.add(new State(startX, startY, 0.0));\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            if (visited[current.x][current.y]) continue;\n            visited[current.x][current.y] = true;\n\n            if (labyrinth[current.x][current.y] == GOAL) {\n                System.out.printf(\"%.10f\\n\", current.probability);\n                return;\n            }\n\n            for (int d = 0; d < 4; d++) {\n                int nx = current.x + DX[d];\n                int ny = current.y + DY[d];\n                if (nx < 0 || ny < 0 || nx >= rows || ny >= cols || labyrinth[nx][ny] == WALL) continue;\n\n                if (labyrinth[nx][ny] == SPRING) {\n                    double springProb = current.probability + 1;\n                    for (int[] floorTile : floorTiles) {\n                        int fx = floorTile[0];\n                        int fy = floorTile[1];\n                        if (!visited[fx][fy]) {\n                            double tileProbability = springProb + expectedMoves[current.x][current.y] / floorCount;\n                            queue.add(new State(fx, fy, tileProbability));\n                        }\n                    }\n                } else {\n                    double newProbability = current.probability + 1;\n                    queue.add(new State(nx, ny, newProbability));\n                }\n            }\n        }\n\n        System.out.println(\"No path to goal found.\");\n    }\n}",
    "timestamp": "2025-08-13 06:31:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define MAXN 100\n#define INF 1e9\n#define EPS 1e-9\n\nint n, m;\nchar labyrinth[MAXN][MAXN];\ndouble expected[MAXN][MAXN];\nint visited[MAXN][MAXN];\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nint in_bounds(int x, int y) {\n    return x >= 0 && x < n && y >= 0 && y < m;\n}\n\ndouble dfs(int x, int y) {\n    if (visited[x][y]) {\n        return expected[x][y];\n    }\n    visited[x][y] = 1;\n    \n    if (labyrinth[x][y] == 'g') {\n        return 0.0;\n    }\n\n    double sum = 0.0, count = 0.0;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (in_bounds(nx, ny) && labyrinth[nx][ny] != '#') {\n            count += 1.0;\n            sum += 1.0 + dfs(nx, ny);\n        }\n    }\n\n    if (labyrinth[x][y] == '*') {\n        double safe_counts = 0.0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (labyrinth[i][j] == '.') {\n                    safe_counts += 1.0;\n                }\n            }\n        }\n        sum = 0.0;\n        count = safe_counts;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (labyrinth[i][j] == '.') {\n                    sum += dfs(i, j);\n                }\n            }\n        }\n    }\n\n    if (count < EPS) {\n        return INF;\n    }\n\n    return expected[x][y] = sum / count;\n}\n\nint main() {\n    while (scanf(\"%d %d\", &n, &m) != EOF) {\n        memset(expected, 0, sizeof(expected));\n        memset(visited, 0, sizeof(visited));\n        int sx, sy;\n        for (int i = 0; i < n; i++) {\n            scanf(\"%s\", labyrinth[i]);\n            for (int j = 0; j < m; j++) {\n                if (labyrinth[i][j] == 's') {\n                    sx = i;\n                    sy = j;\n                }\n            }\n        }\n        double result = dfs(sx, sy);\n        if (result >= INF) {\n            printf(\"-1\\n\");\n        } else {\n            printf(\"%.9f\\n\", result);\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 06:31:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nimport numpy as np\n\ndef solve_spring_tiles(grid: List[str]) -> float:\n    rows, cols = len(grid), len(grid[0])\n    floor_tiles = []\n    start = None\n    goal = None\n\n    # Find all floor tiles, start, and goal\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '.':\n                floor_tiles.append((r, c))\n            elif grid[r][c] == 's':\n                start = (r, c)\n            elif grid[r][c] == 'g':\n                goal = (r, c)\n\n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    def is_valid(r, c):\n        return 0 <= r < rows and 0 <= c < cols and grid[r][c] != '#'\n\n    def get_spring_destinations(r, c):\n        return [tile for tile in floor_tiles if grid[tile[0]][tile[1]] not in ['*', 'g']]\n\n    # Build graph representing possible moves\n    graph = {}\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] in ['.', 's']:\n                graph[(r, c)] = []\n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    if is_valid(nr, nc):\n                        if grid[nr][nc] == '*':\n                            graph[(r, c)].extend(get_spring_destinations(nr, nc))\n                        elif grid[nr][nc] != '#':\n                            graph[(r, c)].append((nr, nc))\n\n    # Value iteration to find expected moves\n    value = {tile: float('inf') for tile in floor_tiles + [start]}\n    value[goal] = 0\n\n    while True:\n        delta = 0\n        for tile in value:\n            if tile == goal:\n                continue\n            \n            if grid[tile[0]][tile[1]] == '*':\n                spring_dest = get_spring_destinations(tile[0], tile[1])\n                new_value = 1 + sum(value.get(dest, float('inf')) for dest in spring_dest) / len(spring_dest)\n            else:\n                new_value = 1 + min(value.get(next_tile, float('inf')) for next_tile in graph.get(tile, []))\n            \n            if new_value < value[tile]:\n                delta = max(delta, value[tile] - new_value)\n                value[tile] = new_value\n\n        if delta < 1e-6:\n            break\n\n    return value[start]\n\n# Example usage\ngrid = [\n    \"########\",\n    \"#..##g.#\",\n    \"#*#.*#. #\",\n    \"#......#\",\n    \"#*s#*.* #\",\n    \"########\"\n]\nprint(f\"{solve_spring_tiles(grid):.7f}\")",
    "timestamp": "2025-08-13 06:31:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    H, W = map(int, input[ptr:ptr+2])\n    ptr +=2\n    grid = []\n    start = None\n    goal = None\n    floors = []\n    \n    for i in range(H):\n        row = input[ptr]\n        ptr +=1\n        grid.append(row)\n        for j in range(W):\n            c = row[j]\n            if c == 's':\n                start = (i, j)\n            elif c == 'g':\n                goal = (i, j)\n            if c == '.' or c == 's':\n                floors.append((i, j))\n    \n    if not start or not goal:\n        print(-1)\n        return\n    \n    # Directions: up, down, left, right\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Initialize E: expected moves from (i,j)\n    INF = float('inf')\n    E = [[INF for _ in range(W)] for __ in range(H)]\n    E[goal[0]][goal[1]] = 0\n    \n    # We'll use a priority queue, but for simplicity, we'll use a deque and process in BFS manner\n    # But since it's a graph with cycles and non-uniform edge weights, we need to use a priority queue\n    # So Dijkstra's algorithm is suitable here\n    \n    # Priority queue: (current E, i, j)\n    import heapq\n    heap = []\n    heapq.heappush(heap, (0, goal[0], goal[1]))\n    \n    # Number of floor tiles (excluding springs and goal)\n    K = len(floors)\n    \n    while heap:\n        current_E, i, j = heapq.heappop(heap)\n        if current_E > E[i][j]:\n            continue\n        for di, dj in dirs:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < H and 0 <= nj < W:\n                if grid[ni][nj] == '#':\n                    continue\n                new_E = INF\n                if grid[ni][nj] == 'g':\n                    continue  # no need to process goal\n                elif grid[ni][nj] == '*':\n                    # When stepping on a spring, teleported to a random floor (excluding goal and springs)\n                    # The new_E is (sum_{all floors} E[floor]) / K + 1\n                    sum_E = 0.0\n                    for (fi, fj) in floors:\n                        sum_E += E[fi][fj]\n                    avg_E = sum_E / K\n                    new_E = avg_E + 1\n                else:  # '.' or 's'\n                    new_E = current_E + 1\n                if new_E < E[ni][nj]:\n                    E[ni][nj] = new_E\n                    heapq.heappush(heap, (new_E, ni, nj))\n    \n    if E[start[0]][start[1]] == INF:\n        print(-1)\n    else:\n        print(\"{0:.10f}\".format(E[start[0]][start[1]]))\n\nsolve()",
    "timestamp": "2025-08-13 06:32:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <iomanip>\n#include <unordered_map>\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n// A function to check if a move is within the labyrinth bounds\nbool inBounds(int x, int y, int r, int c) {\n    return x >= 0 && x < r && y >= 0 && y < c;\n}\n\nint main() {\n    int r, c;\n    cin >> r >> c;\n    vector<string> labyrinth(r);\n    queue<pair<int, int>> q;\n    pair<int, int> start, goal;\n    vector<pair<int, int>> floors;\n    \n    for (int i = 0; i < r; ++i) {\n        cin >> labyrinth[i];\n        for (int j = 0; j < c; ++j) {\n            if (labyrinth[i][j] == 's') {\n                start = {i, j};\n            } else if (labyrinth[i][j] == 'g') {\n                goal = {i, j};\n            }\n            if (labyrinth[i][j] == '.' || labyrinth[i][j] == 's') {\n                floors.push_back({i, j});\n            }\n        }\n    }\n    \n    unordered_map<pair<int, int>, double, hash<pair<int, int>>> expectedMoves;\n    vector<vector<double>> dist(r, vector<double>(c, INF));\n    dist[start.first][start.second] = 0.0;\n    \n    // BFS to calculate the shortest path to the goal\n    q.push(goal);\n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n        for (int d = 0; d < 4; ++d) {\n            int nx = x + dir[d][0];\n            int ny = y + dir[d][1];\n            if (inBounds(nx, ny, r, c) && labyrinth[nx][ny] != '#') {\n                if (dist[nx][ny] > dist[x][y] + 1) {\n                    dist[nx][ny] = dist[x][y] + 1;\n                    q.push({nx, ny});\n                }\n            }\n        }\n    }\n    \n    // Handling springs manually as they require an expectation calculation\n    for (int i = 0; i < r; ++i) {\n        for (int j = 0; j < c; ++j) {\n            if (labyrinth[i][j] == '*') {\n                double sum = 0;\n                for (auto& [fx, fy] : floors) {\n                    sum += dist[fx][fy];\n                }\n                expectedMoves[{i, j}] = sum / floors.size();\n            } else {\n                expectedMoves[{i, j}] = dist[i][j];\n            }\n        }\n    }\n    \n    // Calculate the expected number of steps from the start point\n    cout << fixed << setprecision(6) << expectedMoves[start] << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:32:31"
  }
]